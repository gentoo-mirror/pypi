<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Django Side EffectsDjango app for managing external side effects.## Compatibility**This project now supports Python 3.8+ and Django 3.2+ only on master.**Legacy versions are tagged.## BackgroundThis project was created to try and bring some order to the use ofexternal side-effects within the YunoJuno platform. Externalside-effects are (as defined by us) those actions that affect externalsystems, and that are not part of the core application integrity. Theyfall into two main categories within our application - *notifications*and *updates*, and are best illustrated by example:**Notifications*** Slack messages* SMS (via Twilio)* Push notifications* Email**Updates*** Base CRM (sales)* Mailchimp CRM (marketing)* Elasticsearch (full-text index)There are some shared aspects of all of these side-effects:1. They can all be processed asynchronously (queued)2. They can all be replayed (and are idempotent)3. They can be executed in any order4. They are not time critical5. They do not affect the state of the Django applicationAs we have continued to build out YunoJuno our use of these side-effectshas become ever more complex, and has in some areas left us with functionsthat are 80% side-effects:```pythondef foo():    # do the thing the function is supposed to do    update_object(obj)    # spend the rest of the function working out which side-effects to fire    if settings.notify_account_handler:        send_notification(obj.account_handler)    if obj.has_changed_foo():        udpate_crm(obj)```This results in a codebase is:* Hard to read* Hard to test* Hard to document^^ Barely a week goes by without someone asking *&quot;what happens when X does Y -I thought they got email Z?&quot;*## SolutionThis project aims to address all three of the issues above by:* Removing all side-effects code from core functions* Simplifying mocking / disabling of side-effects in tests* Simplifying testing of side-effects only* Automating documentation of side-effectsIt does this with a combination of function decorators that canbe used to build up a global registry of side-effects.The first decorator, `has_side_effects`, is used to mark a function as onethat has side effects:```python# mark this function as one that has side-effects. The label# can be anything, and is used as a dict key for looking up# associated side-effects functions@side_effects.decorators.has_side_effects('update_profile')def foo(*args, **kwargs):    pass```**Decorating view functions**By default, the `has_side_effects` decorator will run so long as the innerfunction does not raise an exception. View functions, however, are a paticularcase where the function may run, and return a perfectly valid `HttpResponse`object, but you do **not** want the side effects to run, as the response objecthas a `status_code` of 404, 500, etc. In this case, you want to inspect theinner function return value before deciding whether to fire the side effectsfunctions. In order to support this, the `has_side_effects` decorator hasa kwarg `run_on_exit` which takes a function that takes a single parameter,the return value from the inner function, and must return `True` or `False`which determines whether to run the side effects.The `decorators` module contains the default argument for this kwarg, afunction called `http_response_check`. This will return `False` if theinner function return value is an `HttpResponse` object with a statuscode in the 4xx-5xx range.The second decorator, `is_side_effect_of`, is used to bind those functionsthat implement the side effects to the origin function:```python# bind this function to the event 'update_profile'@is_side_effect_of('update_profile')def send_updates(*args, **kwargs):    &quot;&quot;&quot;Update CRM system.&quot;&quot;&quot;    pass# bind this function also to 'update_profile'@is_side_effect_of('update_profile')def send_notifications(*args, **kwargs):    &quot;&quot;&quot;Notify account managers.&quot;&quot;&quot;    pass```In the above example, the updates and notifications have been separatedout from the origin function, which is now easier to understand as it isonly responsible for its own functionality. In this example we have twoside-effects bound to the same origin, however this is an implementationdetail - you could have a single function implementing all theside-effects, or split them out further into the individual externalsystems.**Passing origin function return value to side-effects handlers**By default, side-effects handling functions must have the same functionsignature as the origin function. (Internally the `(*args, **kwargs)`are just a straight pass-through to the handler.) However, in certaincases it is very useful to have access to the origin function returnvalue. A common case is where the origin function creates a new object.The framework handles this internally by introspecting the handlerfunction, and looking for `**kwargs`.This is best illustrated with an example:```python@has_side_effects(&quot;foo&quot;)def origin_func(arg1: int, arg2: int) -&gt; int:    return arg1 + arg2@is_side_effect_of(&quot;foo&quot;)def handle_func1(arg1, arg2):    # this func will not receive the return_value, as    # no kwargs are specified@is_side_effect_of(&quot;foo&quot;)def handle_func1(arg1, arg2, **kwargs):    # this func will receive the return_value via **kwargs    assert &quot;return_value&quot; in kwargs@is_side_effect_of(&quot;foo&quot;)def handle_func1(arg1, arg2, return_value=None):    # this func will receive the return_value@is_side_effect_of(&quot;foo&quot;)def handle_func1(arg1, arg2, return_value):    # this func will receive the return_value, as it is a named arg,    # and there is no *args variable@is_side_effect_of(&quot;foo&quot;)def handle_func1(*args, return_value):    # this func will *NOT* receive the return_value```Internally, the app maintains a registry of side-effects functions boundto origin functions using the text labels. The docstrings for all thebound functions can be grouped using these labels, and then be printedout using the management command `display_side_effects`:```shell$ ./manage.py display_side_effectsThis command prints out the first line from the docstrings of all functionsregistered using the @is_side_effect decorator, grouped by label.update_profile:    - Update CRM system.    - Notify account managers.close_account:    - Send confirmation email to user.    - Notify customer service.```If you have a lot of side-effects wired up, you can filter the list by the label:```shell$ ./manage.py display_side_effects --label update_profileupdate_profile:    - Update CRM system.    - Notify account managers.```Or by a partial match on the event label:```shell$ ./manage.py display_side_effects --label-contains profileupdate_profile:    - Update CRM system.    - Notify account managers.```If you want to enforce docstrings on side-effect functions, then you can use the`--check-docstrings` option, which will exit with a non-zero exit code if anydocstrings are missing. This can be used as part of a CI process, failing anybuild that does not have all its functions documented. (The exit code is the countof functions without docstrings).```shell$ ./manage.py display_side_effects --check-docstringsupdate_profile:    *** DOCSTRING MISSING: update_crm ***    - Notify account managers.ERROR: InvocationError for command '...' (exited with code 1)```## Why not use signals?The above solution probably looks extremely familiar - and it is very closelyrelated to the built-in Django signals implementation. You could easilyreproduce the output of this project using signals - this project is reallyjust a formalisation of the way in which a signal-like pattern could be usedto make your code clear and easy to document. The key differences are:1. Explicit statement that a function has side-effects2. A simpler binding mechanism (using text labels)3. (TODO) Async processing of receiver functionsIt may well be that this project merges back in to the signals pattern indue course - at the moment we are still experimenting.## InstallationThe project is available through PyPI as `django-side-effects`:```shell$ pip install django-side-effects```And the main package itself is just `side_effects`:```python&gt;&gt;&gt; from side_effects import decorators```## TestsThe project has pretty good test coverage (&gt;90%) and the tests themselves run through `tox`.```shell$ pip install tox$ tox```If you want to run the tests manually, make sure you install the requirements, and Django.```shell$ pip install django==2.0  # your version goes here$ tox```If you are hacking on the project, please keep coverage up.NB If you implement side-effects in your project, you will most likely want to be able to turn off the side-effects when testing your own code (so that you are not actually sending emails, updating systems), but you also probably want to know that the side-effects events that you are expecting are fired.The following code snippet shows how to use the `disable_side_effects` context manager, which returns a list of all the side-effects events that are fired. There is a matching function decorator, which will append the events list as an arg to the decorated function, in the same manner that `unittest.mock.patch` does.```pythonfrom side_effects import decorators, registry@decorators.has_side_effects('do_foo')def foo():    passdef test_foo():    # to disable side-effects temporarily, use decorator    with registry.disable_side_effects() as events:        foo()        assert events == ['do_foo']        foo()        assert events == ['do_foo', 'do_foo']# events list is added to the test function as an arg@decorators.disable_side_effects()def test_foo_without_side_effects(events: list[str]):    foo()    assert events == ['do_foo']```In addition to these testing tools there is a universal 'kill-switch' which can be set using the env var `SIDE_EFFECTS_TEST_MODE=True`. This will completely disable all side-effects events. It is a useful tool when you are migrating a project over to the side_effects pattern - as it can highlight where existing tests are relying on side-effects from firing. Use with caution.## ContributingStandard GH rules apply: clone the repo to your own account, create a branch, make sure you update the tests, and submit a pull request.## StatusWe are using it at YunoJuno, but 'caveat emptor'. It does what we need it to do right now, and we will extend it as we evolve. If you need or want additional features, get involved :-).</longdescription>
</pkgmetadata>