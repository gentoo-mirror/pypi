<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Chili [![PyPI version](https://badge.fury.io/py/chili.svg)](https://pypi.org/project/chili) [![codecov](https://codecov.io/gh/kodemore/chili/branch/main/graph/badge.svg?token=TCG7SRQFD5)](https://codecov.io/gh/kodemore/chili) [![CI](https://github.com/kodemore/chili/actions/workflows/main.yaml/badge.svg?branch=main)](https://github.com/kodemore/chili/actions/workflows/main.yaml) [![Release](https://github.com/kodemore/chili/actions/workflows/release.yml/badge.svg)](https://github.com/kodemore/chili/actions/workflows/release.yml) [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)Chili is an extensible library which provides a simple and efficient way to encode and decode complex Python objects to and from their dictionary representation.It offers complete coverage for the `typing` package; including generics, and supports custom types, allowing you to extend the library to handle your specific needs. With support for nested data structures, default values, forward references, and data mapping and transformation, Chili is designed to be both easy to use and powerful enough to handle complex data structures.# InstallationTo install the library, simply use pip:```shellpip install chili``````shellpoetry add chili```# UsageThe library provides three main classes for encoding and decoding objects, `chili.Encoder` and `chili.Decoder`, and `chili.Serializer`, which combines both functionalities.## Defining encodable/decodable propertiesTo define the properties of a class that should be encoded and decoded, you need to define them with type annotations. The `@encodable`, `@decodable`, or `@serializable` decorator should also be used to mark the class as encodable/decodable or serializable.```pythonfrom chili import encodable@encodableclass Pet:    name: str    age: int    breed: str    def __init__(self, name: str, age: int, breed: str):        self.name = name        self.age = age        self.breed = breed```## EncodingTo encode an object, you need to create an instance of the `chili.Encoder` class, and then call the `encode` method, passing the object to be encoded as an argument.&gt; Note: The `chili.Encoder` class is a generic class, and you need to pass the type of the object to be encoded as a type argument.```pythonfrom chili import Encoderencoder = Encoder[Pet]()my_pet = Pet(&quot;Max&quot;, 3, &quot;Golden Retriever&quot;)encoded = encoder.encode(my_pet)assert encoded == {&quot;name&quot;: &quot;Max&quot;, &quot;age&quot;: 3, &quot;breed&quot;: &quot;Golden Retriever&quot;}```## DecodingTo decode an object, you need to create an instance of the `chili.Decoder` class, and then call the `decode` method, passing the dictionary to be decoded as an argument.&gt; Note: The `chili.Decoder` class is a generic class, and you need to pass the type of the object to be decoded as a type argument.```pythonfrom chili import Decoderdecoder = Decoder[Pet]()data = {&quot;name&quot;: &quot;Max&quot;, &quot;age&quot;: 3, &quot;breed&quot;: &quot;Golden Retriever&quot;}decoded = decoder.decode(data)assert isinstance(decoded, Pet)```## Missing PropertiesIf a property is not present in the dictionary when decoding, the `chili.Decoder` class will not fill in the property value, unless there is a default value defined in the type annotation. Similarly, if a property is not defined on the class, the `chili.Encoder` class will hide the property in the resulting dictionary.## Using Default ValuesTo provide default values for class properties that are not present in the encoded dictionary, you can define the properties with an equal sign and the default value. For example:```pythonfrom typing import Listfrom chili import Decoder, decodable@decodableclass Book:    name: str    author: str    isbn: str = &quot;1234567890&quot;    tags: List[str] = []book_data = {&quot;name&quot;: &quot;The Hobbit&quot;, &quot;author&quot;: &quot;J.R.R. Tolkien&quot;}decoder = Decoder[Book]()book = decoder.decode(book_data)assert book.tags == []assert book.isbn == &quot;1234567890&quot;```&gt; Note: When using default values with mutable objects, such as lists or dictionaries, be aware that the default value is shared among all instances of the class that do not have that property defined in the encoded dictionary. However, if the default value is empty (e.g. `[]` for a list, `{}` for a dictionary), it is not shared among instances.## Custom Type EncodersYou can also specify custom type encoders by defining a class that implements the `chili.TypeEncoder` protocol and passing it as a dictionary to the `encoders` argument of the Encoder constructor.```pythonfrom chili import Encoder, TypeEncoderclass MyCustomEncoder(TypeEncoder[MyCustomType, str]):    def encode(self, value: MyCustomType) -&gt; str:        return value.encode()    type_encoders = {MyCustomType: MyCustomEncoder()}encoder = Encoder[Pet](encoders=type_encoders)```## Custom Type DecodersYou can also specify custom type decoders by defining a class that implements the `chili.TypeDecoder` protocol and passing it as a dictionary to the `decoders` argument of the Decoder constructor.```pythonfrom chili import Decoder, TypeDecoderclass MyCustomDecoder(TypeDecoder[str, MyCustomType]):    def decode(self, value: str) -&gt; MyCustomType:        return MyCustomType.decode(value)type_decoders = {MyCustomType: MyCustomDecoder()}decoder = Decoder[Pet](decoders=type_decoders)```## Convenient FunctionsThe library also provides convenient functions for encoding and decoding objects. The encode function takes an object and an optional type hint and returns a dictionary. The decode function takes a dictionary, a type hint, and optional custom decoders and returns an object.```pythonfrom chili import encode, decodemy_pet = Pet(&quot;Max&quot;, 3, &quot;Golden Retriever&quot;)encoded = encode(my_pet)decoded = decode(encoded, Pet)```## SerializationIf your object is both encodable and decodable, you can use the `@serializable` decorator to mark it as such. You can then use the `chili.Serializer` class to encode and decode objects.```pythonfrom chili import Serializer, serializable@serializableclass Pet:    name: str    age: int    breed: str    def __init__(self, name: str, age: int, breed: str):        self.name = name        self.age = age        self.breed = breedmy_pet = Pet(&quot;Max&quot;, 3, &quot;Golden Retriever&quot;)serializer = Serializer[Pet]()encoded = serializer.encode(my_pet)decoded = serializer.decode(encoded)```&gt; Note: that you should only use the `@serializable` decorator for objects that are both encodable and decodable.## JSON SerializationThe library also provides classes for encoding and decoding objects to and from JSON formats. The `chili.JsonEncoder` and `chili.JsonDecoder` classes provide JSON serialization.```pythonfrom chili import JsonEncoder, JsonDecoder, JsonSerializer# JSON Serializationencoder = JsonEncoder[Pet]()decoder = JsonDecoder[Pet]()serializer = JsonSerializer[Pet]()my_pet = Pet(&quot;Max&quot;, 3, &quot;Golden Retriever&quot;)encoded = encoder.encode(my_pet)decoded = decoder.decode(encoded)```The `encoded` value will be a json string:```json{&quot;name&quot;: &quot;Max&quot;, &quot;age&quot;: 3, &quot;breed&quot;: &quot;Golden Retriever&quot;}```The `decoded` value will be an instance of a Pet object.## MappingMapping allows you to remap keys, apply functions to the values, and even change the structure of the input dictionary. This is particularly useful when you need to convert data from one format to another, such as when interacting with different APIs or data sources that use different naming conventions.### Simple mappingHere's an example of how to use the `chili.Mapper` class from the library with a Pet class:```pythonfrom chili import Mapper# Create a Mapper instance with the specified schememapper = Mapper({    &quot;pet_name&quot;: &quot;name&quot;,    &quot;pet_age&quot;: &quot;age&quot;,    &quot;pet_tags&quot;: {        &quot;tag_name&quot;: &quot;tag&quot;,        &quot;tag_type&quot;: &quot;type&quot;,    },})data = {    &quot;pet_name&quot;: &quot;Max&quot;,    &quot;pet_age&quot;: 3,    &quot;pet_tags&quot;: [        {&quot;tag_name&quot;: &quot;cute&quot;, &quot;tag_type&quot;: &quot;description&quot;},        {&quot;tag_name&quot;: &quot;furry&quot;, &quot;tag_type&quot;: &quot;description&quot;},    ],}# Apply the mapping to your input datamapped_data = mapper.map(data)print(mapped_data)```The `mapped_data` output would be:```python{    &quot;name&quot;: &quot;Max&quot;,    &quot;age&quot;: 3,    &quot;pet_tags&quot;: [        {&quot;tag&quot;: &quot;cute&quot;, &quot;type&quot;: &quot;description&quot;},        {&quot;tag&quot;: &quot;furry&quot;, &quot;type&quot;: &quot;description&quot;},    ],}```### Using KeyScheme`KeyScheme` can be used to define mapping rules for nested structures more explicitly. It allows you to specify both the old key and the nested mapping scheme in a single, concise object. This can be particularly useful when you want to map a nested structure but need to maintain clarity in your mapping scheme.Here's an example of how to use `chili.KeyScheme` with the `chili.Mapper` class:```pythonfrom chili import Mapper, KeyScheme# Create a Mapper instance with the specified schememapper = Mapper({    &quot;pet_name&quot;: &quot;name&quot;,    &quot;pet_age&quot;: &quot;age&quot;,    &quot;pet_tags&quot;: KeyScheme(&quot;tags&quot;, {        &quot;tag_name&quot;: &quot;tag&quot;,        &quot;tag_type&quot;: &quot;type&quot;,    }),})pet_dict = {    &quot;pet_name&quot;: &quot;Max&quot;,    &quot;pet_age&quot;: 3,    &quot;pet_tags&quot;: [        {&quot;tag_name&quot;: &quot;cute&quot;, &quot;tag_type&quot;: &quot;description&quot;},        {&quot;tag_name&quot;: &quot;furry&quot;, &quot;tag_type&quot;: &quot;description&quot;},    ],}# Apply the mapping to your input datamapped_data = mapper.map(pet_dict)print(mapped_data)```The `mapped_data` output would be:```python{    &quot;name&quot;: &quot;Max&quot;,    &quot;age&quot;: 3,    &quot;tags&quot;: [        {&quot;tag&quot;: &quot;cute&quot;, &quot;type&quot;: &quot;description&quot;},        {&quot;tag&quot;: &quot;furry&quot;, &quot;type&quot;: &quot;description&quot;},    ],}```### Using wildcards in mappingThe `chili.Mapper` supports using `...` (Ellipsis) as a wildcard for keys that you want to include in the mapping but do not want to explicitly define. This can be useful when you want to map all keys in the input data, or when you want to map specific keys and leave the remaining keys unchanged.You can use a lambda function with the `...` wildcard to apply a transformation to the keys or values that match the wildcard.Here's an example of how to use the `...` wildcard with the `chili.Mapper` class:```pythonfrom chili import Mapper# Create a Mapper instance with the specified scheme containing a wildcard ...mapper = Mapper({    &quot;pet_name&quot;: &quot;name&quot;,    &quot;pet_age&quot;: &quot;age&quot;,    ...: lambda k, v: (f&quot;extra_{k}&quot;, v.upper() if isinstance(v, str) else v),})pet_dict = {    &quot;pet_name&quot;: &quot;Max&quot;,    &quot;pet_age&quot;: 3,    &quot;pet_color&quot;: &quot;white&quot;,    &quot;pet_breed&quot;: &quot;Golden Retriever&quot;,    &quot;pet_tags&quot;: [        {&quot;tag&quot;: &quot;cute&quot;, &quot;type&quot;: &quot;description&quot;},        {&quot;tag&quot;: &quot;furry&quot;, &quot;type&quot;: &quot;description&quot;},    ],}# Apply the mapping to your input datamapped_data = mapper.map(pet_dict)print(mapped_data)```The `mapped_data` output would be:```python{    &quot;pet_name&quot;: &quot;Fluffy&quot;,    &quot;pet_age&quot;: 3,    &quot;extra_color&quot;: &quot;WHITE&quot;,    &quot;extra_breed&quot;: &quot;POODLE&quot;,    &quot;extra_tags&quot;: [        {            &quot;tag&quot;: &quot;cute&quot;,            &quot;type&quot;: &quot;description&quot;,        },        {            &quot;tag&quot;: &quot;furry&quot;,            &quot;type&quot;: &quot;description&quot;,        },    ],}```## Error handlingThe library raises errors if an invalid type is passed to the Encoder or Decoder, or if an invalid dictionary is passed to the Decoder.```pythonfrom chili import Encoder, EncoderError, Decoder, DecoderError# Invalid Typeencoder = Encoder[MyInvalidType]()  # Raises EncoderError.invalid_typedecoder = Decoder[MyInvalidType]()  # Raises DecoderError.invalid_type# Invalid Dictionarydecoder = Decoder[Pet]()invalid_data = {&quot;name&quot;: &quot;Max&quot;, &quot;age&quot;: &quot;three&quot;, &quot;breed&quot;: &quot;Golden Retriever&quot;}decoded = decoder.decode(invalid_data)  # Raises DecoderError.invalid_input```</longdescription>
</pkgmetadata>