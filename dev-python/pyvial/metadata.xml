<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Vial&lt;p&gt;    &lt;a href=&quot;https://pypi.org/project/pyvial/&quot;&gt;        &lt;img src=&quot;https://badgen.net/pypi/v/pyvial&quot; alt=&quot;Latest Version&quot; style=&quot;max-width:100%;&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://github.com/michaeldimchuk/pyvial/actions/workflows/tests.yaml&quot;&gt;        &lt;img src=&quot;https://github.com/michaeldimchuk/pyvial/actions/workflows/tests.yaml/badge.svg&quot; alt=&quot;Test Status&quot; style=&quot;max-width:100%;&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://github.com/pre-commit/pre-commit&quot;&gt;        &lt;img src=&quot;https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&amp;logoColor=white&quot; alt=&quot;Pre-Commit Enabled&quot; style=&quot;max-width:100%;&quot;&gt;    &lt;/a&gt;&lt;/p&gt;Vial is an unopinionated micro web framework for AWS Lambda. It's main purpose is to provide an easy to useinterface while also making the core functionality of the framework as modular as possible.## InstallationTo add vial to your project, run the following command:```poetry add pyvial```## Usage### Entry PointThe main entry point of the application is always the `Vial#__call__` function. When deploying to AWS Lambda,the Lambda handler should point to the `Vial` object in whichever file it's defined in. As an example:```from vial.app import Vialapp = Vial(__name__)```If this code snippet is defined in an `app.py` file, the handler would be `app.app`.### Basic API```from vial.app import Vialapp = Vial(__name__)@app.get(&quot;/health&quot;)def health() -&gt; dict[str, str]:    return {&quot;status&quot;: &quot;OK&quot;}```A test case with this example is available in [tests/samples/test_with_app.py](tests/samples/test_with_app.py).The project can be deployed with the [serverless framework](https://www.serverless.com/framework/docs/getting-started).To get started with serverless for the first time, run the following commands in your project directory:```yarn add --dev serverless serverless-python-requirements```Below is a basic `serverless.yml` file to configure and deploy the project. It assumes that the only file to deployis app.py, and the Vial object is defined there as a variable named `app`.```service: storecustom:  pythonRequirements:    usePoetry: true    slim: trueprovider:  name: aws  runtime: python3.9  memorySize: 128  region: us-west-2functions:  api:    handler: app.app    events:      - http: get /healthplugins:  - serverless-python-requirementspackage:  patterns:    - &quot;app.py&quot;    - &quot;!.*/**&quot;    - &quot;!package.json&quot;    - &quot;!yarn.json&quot;    - &quot;!node_modules&quot;    - &quot;poetry.lock&quot;    - &quot;pyproject.toml&quot;```You can now deploy the project with `yarn run serverless deploy`.An example of this application is available at [samples/store/serverless.yml](samples/store/serverless.yml).### Current RequestThe current request is tracked within a contextual object that wraps the lambda request, and can be accessedthrough the `vial.request` module. The `request.get()` function is only available during a lambda request,and will raise an error if called outside of one. It can be accessed like so:```from vial import requestfrom vial.app import Vialfrom vial.types import Requestapp = Vial(__name__)@app.get(&quot;/hello-world&quot;)def hello_world() -&gt; dict[str, list[str]]:    if not (query_params := request.get().query_parameters):        raise ValueError(&quot;Must provide at least one query parameter&quot;)    return dict(query_params)```A test case with this example is available in [tests/samples/test_with_current_request.py](tests/samples/test_with_current_request.py).### Path ParametersYou can define path parameters like this:```from dataclasses import dataclassfrom vial.app import Vialapp = Vial(__name__)@dataclassclass User:    user_id: str@app.get(&quot;/users/{user_id}&quot;)def get_user(user_id: str) -&gt; User:    return User(user_id)```A test case with this example is available in [tests/samples/test_with_path_parameters.py](tests/samples/test_with_path_parameters.py).Vial supports some path parameter parsing as part of the invocation process. For example when using a UUIDas a path parameter, Vial can convert it from a string to a UUID automatically:```from dataclasses import dataclassfrom uuid import UUID, uuid4from vial.app import Vialapp = Vial(__name__)@dataclassclass User:    user_id: UUID@app.get(&quot;/users/{user_id:uuid}&quot;)def get_user(user_id: UUID) -&gt; User:    if not isinstance(user_id, UUID):        raise AssertionError(&quot;Invalid input&quot;)    return User(user_id)```A test case with this example is available in [tests/samples/test_with_parser.py](tests/samples/test_with_parser.py).The following parsers are supported by default:| Parser        | Type              || ------------- | ----------------- || `str`         | `str`             || `bool`        | `bool`            || `int`         | `int`             || `float`       | `float`           || `decimal`     | `decimal.Decimal` || `uuid`        | `uuid.UUID`       |You can register your own parser that consumes a string variable and converts it to any other type.As parsers are bound directly to the registered route function, they have to be defined before the routefunction that uses one is registered.```@app.parser(&quot;list&quot;)def list_parser(value: str) -&gt; list[str]:    return [value]@app.get(&quot;/users/{user_ids:list}&quot;)def get_users(user_ids: list[str]) -&gt; list[User]:    if not isinstance(user_ids, list) or len(user_ids) != 1:        raise AssertionError(&quot;Invalid input&quot;)    return list(map(User, user_ids))```A test case with this example is available in [tests/samples/test_with_custom_parser.py](tests/samples/test_with_custom_parser.py).## ResourcesAs your application grows, you may want to split certain functionality amongst resources and files, similar toblueprints of other popular frameworks like Flask.You can define a resource like this:```from dataclasses import dataclassfrom vial.app import Resource, Vialstores_app = Resource(__name__)@dataclassclass Store:    store_id: str@stores_app.get(&quot;/stores/{store_id}&quot;)def get_store(store_id: str) -&gt; Store:    return Store(store_id)app = Vial(__name__)app.register_resource(stores_app)```A test case with this example is available in [tests/samples/test_with_resources.py](tests/samples/test_with_resources.py).## MiddlewareYou can register middleware functions to be executed before / after route invocations. All middleware is scoped towhere it's registered. A middleware function registered with the `Vial` instance is scoped to all routes withinthe application, but a function registered with a `Resource` instance will only be invoked for routes defined inthat specific resource.The route invocation will be the last callable in the call chain, so any middleware in the chain before canexit the request and prevent the route invocation or even any other middleware from being called, exiting instead.This may be helpful in cases where an application needs to fail early if the request isn't valid, like if arequired header is missing.Below is an example of registering a middleware to log route invocation:```from __future__ import annotationsfrom vial import requestfrom vial.app import Vialfrom vial.middleware import CallChainfrom vial.types import Request, Responseapp = Vial(__name__)@app.middlewaredef log_events(event: Request, chain: CallChain) -&gt; Response:    app.logger.info(&quot;Began execution of %s&quot;, event.context)    event.headers[&quot;custom-injected-header&quot;] = &quot;hello there&quot;    try:        return chain(event)    finally:        app.logger.info(&quot;Completed execution of %s&quot;, event.context)@app.get(&quot;/hello-world&quot;)def hello_world() -&gt; dict[str, str | list[str]]:    return {&quot;hello&quot;: &quot;world&quot;, **request.get().headers}```A test case with this example is available in [tests/samples/test_with_middleware.py](tests/samples/test_with_middleware.py).## Error HandlingWhen errors are raised by the application, the default error handler will iterate the class inheritance hierarchy of theexception that was raised, trying to find the most fine grained error handler possible. Default error handlers for commonexception types like `Exception` or `ValueError` are provided, but can be overridden. Below is a sample on how to registercustom error handlers or override existing ones:```from http import HTTPStatusfrom vial.app import Vialfrom vial.gateway import Gatewayfrom vial.types import Responseapp = Vial(__name__)class CustomError(Exception):    passclass ConfusedError(CustomError):    pass@app.error_handler(CustomError)def custom_error_handler(error: CustomError) -&gt; Response:    return Response({&quot;custom_message&quot;: str(error)}, status=HTTPStatus.IM_A_TEAPOT)@app.error_handler(ConfusedError)def confused_error_handler(error: ConfusedError) -&gt; Response:    return Response({&quot;custom_message&quot;: str(error)}, status=HTTPStatus.BAD_GATEWAY)@app.get(&quot;/teapot&quot;)def teapot() -&gt; None:    raise CustomError(&quot;I really am a teapot&quot;)@app.get(&quot;/confused-teapot&quot;)def confused_teapot() -&gt; None:    raise ConfusedError(&quot;I'm a really confused teapot&quot;)```A test case with this example is available in [tests/samples/test_with_error_handling.py](tests/samples/test_with_error_handling.py).Error handlers are bound to the resource they were registered in, whether that's the global `Vial` application ora specific `Resource` instance. When an error occurs in a route, the &quot;owner&quot; application / resource is taken into consideration whenchoosing the error handler to use.An error handler registered in a `Resource` will always have precedence over a global error handler registered in the `Vial`application. This allows for resources to either override global error handling mechanisms or add customization for morefine grained exception types.Note that the most fine grained error handler is always chosen, no matter where it comes from. That means that in a scenariolike this:```class First(Exception):    passclass Second(First):    passclass Third(Second):    pass```If the `Vial` application registers error handlers for `First` and `Third` while the `Resource` registers an override for`Second`, then when an exception of type `Third` is thrown, the global error handler will be used because it has a closermatch to the exception, even if its parent is overridden in the `Resource`.Below is an example of a `Resource` specific error handler:```from http import HTTPStatusfrom vial.app import Resource, Vialfrom vial.types import Responseapp = Vial(__name__)confused_app = Resource(f&quot;confused_{__name__}&quot;)class CustomError(Exception):    passclass ConfusedError(CustomError):    pass@app.error_handler(CustomError)def custom_error_handler(error: CustomError) -&gt; Response:    return Response({&quot;custom_message&quot;: str(error)}, status=HTTPStatus.IM_A_TEAPOT)@confused_app.error_handler(ConfusedError)def confused_error_handler(error: ConfusedError) -&gt; Response:    return Response({&quot;custom_message&quot;: str(error)}, status=HTTPStatus.BAD_GATEWAY)@app.get(&quot;/teapot&quot;)def teapot() -&gt; None:    raise CustomError(&quot;I really am a teapot&quot;)@confused_app.get(&quot;/confused-teapot&quot;)def confused_teapot() -&gt; None:    raise ConfusedError(&quot;I'm a really confused teapot&quot;)app.register_resource(confused_app)```A test case with this example is available in [tests/samples/test_with_resource_error_handling.py](tests/samples/test_with_resource_error_handling.py).## Json EncodingYou can customize how Vial serializes / deserializes JSON objects by passing a custom encoder. The belowexample shows how to substitute the native JSON module with another library like `simplejson`:```from decimal import Decimalfrom typing import Anyimport simplejsonfrom vial.app import Vialfrom vial.json import Jsonclass SimpleJson(Json):    @staticmethod    def dumps(value: Any) -&gt; str:        return simplejson.dumps(value)    @staticmethod    def loads(value: str) -&gt; Any:        return simplejson.loads(value)class SimpleJsonVial(Vial):    json_class = SimpleJsonapp = SimpleJsonVial(__name__)@app.get(&quot;/prices&quot;)def get_prices() -&gt; dict[str, Decimal]:    # Decimal is not supported natively by the json module, but is by simplejson.    return {&quot;bread&quot;: Decimal(&quot;42.24&quot;), &quot;cheese&quot;: Decimal(&quot;129.34&quot;)}```A test case with this example is available in [tests/samples/test_with_json_encoding.py](tests/samples/test_with_json_encoding.py).## TestingThe `vial.gateway.Gateway` class provides functionality to interact with the Vial application locally,without deploying to AWS Lambda. It can be constructed using the original `Vial` application instance,exposing the application endpoints with basic URL path matching.Here is an example test case using `pytest`:```from http import HTTPStatusimport pytestfrom vial import requestfrom vial.app import Vialfrom vial.exceptions import BadRequestErrorfrom vial.gateway import Gatewayapp = Vial(__name__)@app.get(&quot;/health&quot;)def health() -&gt; dict[str, str]:    return {&quot;status&quot;: &quot;OK&quot;}@app.post(&quot;/stores/{store_id}&quot;)def create_store(store_id: str) -&gt; dict[str, str]:    if not (body := request.get().body):        raise BadRequestError(&quot;Bad request&quot;)    return {&quot;store_id&quot;: store_id, **app.json.loads(body)}@pytest.fixture(name=&quot;gateway&quot;)def gateway_fixture() -&gt; Gateway:    return Gateway(app)def test_health(gateway: Gateway) -&gt; None:    response = gateway.get(&quot;/health&quot;)    assert response.status == HTTPStatus.OK    assert response.body == {&quot;status&quot;: &quot;OK&quot;}def test_create_store(gateway: Gateway) -&gt; None:    body = app.json.dumps({&quot;store_name&quot;: &quot;My cool store&quot;})    response = gateway.post(&quot;/stores/my-cool-store&quot;, body)    assert response.status == HTTPStatus.OK    assert response.body == {&quot;store_id&quot;: &quot;my-cool-store&quot;, &quot;store_name&quot;: &quot;My cool store&quot;}```This code is also available in [tests/samples/test_with_gateway.py](tests/samples/test_with_gateway.py).</longdescription>
</pkgmetadata>