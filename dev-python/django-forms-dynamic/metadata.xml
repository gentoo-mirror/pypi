<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>django-forms-dynamic====================**Resolve form field arguments dynamically when a form is instantiated, not when it's declared.**Tested against Django 2.2, 3.2 and 4.0 on Python 3.6, 3.7, 3.8, 3.9 and 3.10![Build Status](https://github.com/dabapps/django-forms-dynamic/workflows/CI/badge.svg)[![pypi release](https://img.shields.io/pypi/v/django-forms-dynamic.svg)](https://pypi.python.org/pypi/django-forms-dynamic)### InstallationInstall from PyPI    pip install django-forms-dynamic## Usage### Passing arguments to form fields from the viewThe standard way to change a Django form's fields at runtime is override the form's `__init__` method, pass in any values you need from the view, and poke around in `self.fields`:```pythonclass SelectUserFromMyTeamForm(forms.Form):    user = forms.ModelChoiceField(queryset=User.objects.none())    def __init__(self, *args, **kwargs):        team = kwargs.pop(&quot;team&quot;)        super().__init__(*args, **kwargs)        self.fields[&quot;user&quot;].queryset = User.objects.filter(team=team)``````pythondef select_user_view(request):    form = SelectUserFromMyTeamForm(team=request.user.team)    return render(&quot;form.html&quot;, {&quot;form&quot;: form})```This works, but it doesn't scale very well to more complex requirements. It also feels messy: Django forms are intended to be declarative, and this is very much procedural code.With `django-forms-dynamic`, we can improve on this approach. We need to do two things:1. Add the `DynamicFormMixin` to your form class (before `forms.Form`).2. Wrap any field that needs dynamic behaviour in a `DynamicField`.The first argument to the `DynamicField` constructor is the field _class_ that you are wrapping (eg `forms.ModelChoiceField`). All other arguments (with one special-cased exception detailed below) are passed along to the wrapped field when it is created.But there's one very important difference: **any argument that would normally be passed to the field constructor can optionally be a _callable_**. If it is a callable, it will be called _when the form is being instantiated_ and it will be passed the form _instance_ as an argument. The value returned by this callable will then be passed into to the field's constructor as usual.Before we see a code example, there's one further thing to note: instead of passing arbitrary arguments (like `team` in the example above) into the form's constructor in the view, we borrow a useful idiom from Django REST framework serializers and instead pass a _single_ argument called `context`, which is a dictionary that can contain any values you need from the view. This is attached to the form as `form.context`.Here's how the code looks now:```pythonfrom dynamic_forms import DynamicField, DynamicFormMixinclass SelectUserFromMyTeamForm(DynamicFormMixin, forms.Form):    user = DynamicField(        forms.ModelChoiceField,        queryset=lambda form: User.objects.filter(team=form.context[&quot;team&quot;]),    )``````pythondef select_user_view(request):    form = SelectUserFromMyTeamForm(context={&quot;team&quot;: request.user.team})    return render(&quot;form.html&quot;, {&quot;form&quot;: form})```This is much nicer!## Truly dynamic forms with XHRBut let's go further. Once we have access to the `form`, we can make forms truly dynamic by configuring fields based on the values of _other_ fields. This doesn't really make sense in the standard Django request/response approach, but it _does_ make sense when we bring JavaScript into the equation. A form can be loaded from the server multiple times (or in multiple pieces) by making XHR requests from JavaScript code running in the browser.Implementing this &quot;from scratch&quot; in JavaScript is left as an exercise for the reader. Instead, let's look at how you might do this using some modern &quot;low JavaScript&quot; frameworks.### [HTMX](https://htmx.org/)To illustrate the pattern we're going to use one of the examples from the HTMX documentation: &quot;Cascading Selects&quot;. This is where the options available in one `&lt;select&gt;` depend on the value chosen in another `&lt;select&gt;`. See [the HTMX docs page](https://htmx.org/examples/value-select/) for full details and a working example.How would we implement the backend of this using `django-forms-dynamic`?First, let's have a look at the form:```pythonclass MakeAndModelForm(DynamicFormMixin, forms.Form):    MAKE_CHOICES = [        (&quot;audi&quot;, &quot;Audi&quot;),        (&quot;toyota&quot;, &quot;Toyota&quot;),        (&quot;bmw&quot;, &quot;BMW&quot;),    ]    MODEL_CHOICES = {        &quot;audi&quot;: [            (&quot;a1&quot;, &quot;A1&quot;),            (&quot;a3&quot;, &quot;A3&quot;),            (&quot;a6&quot;, &quot;A6&quot;),        ],        &quot;toyota&quot;: [            (&quot;landcruiser&quot;, &quot;Landcruiser&quot;),            (&quot;tacoma&quot;, &quot;Tacoma&quot;),            (&quot;yaris&quot;, &quot;Yaris&quot;),        ],        &quot;bmw&quot;: [            (&quot;325i&quot;, &quot;325i&quot;),            (&quot;325ix&quot;, &quot;325ix&quot;),            (&quot;x5&quot;, &quot;X5&quot;),        ],    }    make = forms.ChoiceField(        choices=MAKE_CHOICES,        initial=&quot;audi&quot;,    )    model = DynamicField(        forms.ChoiceField,        choices=lambda form: form.MODEL_CHOICES[form[&quot;make&quot;].value()],    )```The key bit is right at the bottom. We're using a lambda function to load the choices for the `model` field based on the currently selected value of the `make` field. When the form is first shown to the user, `form[&quot;make&quot;].value()` will be `&quot;audi&quot;`: the `initial` value supplied to the `make` field. After the form is bound, `form[&quot;make&quot;].value()` will return whatever the user selected in the `make` dropdown.HTMX tends to encourage a pattern of splitting your UI into lots of small endpoints that return fragments of HTML. So we need two views: one to return the entire form on first page load, and one to return _just_ the HTML for the `model` field. The latter will be loaded whenever the `make` field changes, and will return the available `models` for the chosen `make`.Here are the two views:```pythondef htmx_form(request):    form = MakeAndModelForm()    return render(request, &quot;htmx.html&quot;, {&quot;form&quot;: form})def htmx_models(request):    form = MakeAndModelForm(request.GET)    return HttpResponse(form[&quot;model&quot;])```Remember that the string representation of `form[&quot;model&quot;]` (the bound field) is the HTML for the `&lt;select&gt;` element, so we can return this directly in the `HttpResponse`.These can be wired up to URLs like this:```pythonurlpatterns = [    path(&quot;htmx-form/&quot;, htmx_form),    path(&quot;htmx-form/models/&quot;, htmx_models),]```And finally, we need a template. We're using [django-widget-tweaks](https://github.com/jazzband/django-widget-tweaks) to add the necessary `hx-` attributes to the `make` field right in the template.```django{% load widget_tweaks %}&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;script src=&quot;https://unpkg.com/htmx.org@1.6.1&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form method=&quot;POST&quot;&gt;      &lt;h3&gt;Pick a make/model&lt;/h3&gt;      {% csrf_token %}      &lt;div&gt;        {{ form.make.label_tag }}        {% render_field form.make hx-get=&quot;/htmx-form/models/&quot; hx-target=&quot;#id_model&quot; %}      &lt;/div&gt;      &lt;div&gt;        {{ form.model.label_tag }}        {{ form.model }}      &lt;/div&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;```### [Unpoly](https://unpoly.com/)Let's build exactly the same thing with Unpoly. Unpoly favours a slightly different philosophy: rather than having the backend returning HTML fragments, it tends to prefer the server to return full HTML pages with every XHR request, and &quot;plucks out&quot; the relevant element(s) and inserts them into the DOM, replacing the old ones.When it comes to forms, Unpoly uses a special attribute `[up-validate]` to mark fields which, when changed, should trigger the form to be submitted and re-validated. [The docs for `[up-validate]`](https://unpoly.com/input-up-validate) also describe it as &quot;a great way to partially update a form when one field depends on the value of another field&quot;, so this is what we'll use to implement our cascading selects.The form is exactly the same as the HTMX example above. But this time, we only need one view!```pythondef unpoly_form(request):    form = MakeAndModelForm(request.POST or None)    return render(request, &quot;unpoly.html&quot;, {&quot;form&quot;: form})``````pythonurlpatterns = [    path(&quot;unpoly-form/&quot;, unpoly_form),]```And the template is even more simple:```django{% load widget_tweaks %}&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;script src=&quot;https://unpkg.com/unpoly@2.5.0/unpoly.min.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form method=&quot;POST&quot;&gt;      &lt;h3&gt;Pick a make/model&lt;/h3&gt;      {% csrf_token %}      &lt;div&gt;        {{ form.make.label_tag }}        {% render_field form.make up-validate=&quot;form&quot; %}      &lt;/div&gt;      &lt;div&gt;        {{ form.model.label_tag }}        {{ form.model }}      &lt;/div&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;```## The `include` argumentThere's one more feature we might need: what if we want to remove a field from the form entirely unless another field has a particular value? To accomplish this, the `DynamicField` constructor takes one special argument that isn't passed along to the constructor of the wrapped field: `include`. Just like any other argument, this can be a callable that is passed the form instance, and it should return a boolean: `True` if the field should be included in the form, `False` otherwise. Here's an example:```pythonclass CancellationReasonForm(DynamicFormMixin, forms.Form):    CANCELLATION_REASONS = [        (&quot;too-expensive&quot;, &quot;Too expensive&quot;),        (&quot;too-boring&quot;, &quot;Too boring&quot;),        (&quot;other&quot;, &quot;Other&quot;),    ]    cancellation_reason = forms.ChoiceField(choices=CANCELLATION_REASONS)    reason_if_other = DynamicField(        forms.CharField,        include=lambda form: form[&quot;cancellation_reason&quot;].value() == &quot;other&quot;,    )```## Known gotcha: callable argumentsOne thing that might catch you out: if the object you're passing in to your form field's constructor is _already_ a callable, you will need to wrap it in another callable that takes the `form` argument and returns the _actual_ callable you want to pass to the field.This is most likely to crop up when you're passing a custom widget class, because classes are callable:```pythonclass CancellationReasonForm(DynamicFormMixin, forms.Form):    ...  # other fields    reason_if_other = DynamicField(        forms.CharField,        include=lambda form: form[&quot;cancellation_reason&quot;].value() == &quot;other&quot;,        widget=lambda _: forms.TextArea,    )```## Why the awkward name?Because `django-dynamic-forms` was already taken.## Code of conductFor guidelines regarding the code of conduct when contributing to this repository please review [https://www.dabapps.com/open-source/code-of-conduct/](https://www.dabapps.com/open-source/code-of-conduct/)</longdescription>
</pkgmetadata>