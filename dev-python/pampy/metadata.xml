<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![Pampy in Star Wars](https://raw.githubusercontent.com/santinic/pampy/master/imgs/pampy.png &quot;Pampy in Star Wars&quot;)# Pampy: Pattern Matching for Python[![License MIT](https://go-shields.herokuapp.com/license-MIT-blue.png)]()[![Travis-CI Status](https://api.travis-ci.org/santinic/pampy.svg?branch=master)](https://travis-ci.org/santinic/pampy)[![Coverage Status](https://coveralls.io/repos/github/santinic/pampy/badge.svg?branch=master)](https://coveralls.io/github/santinic/pampy?branch=master)[![PyPI version](https://badge.fury.io/py/pampy.svg)](https://badge.fury.io/py/pampy)Pampy is pretty small (150 lines), reasonably fast, and often makes your code more readableand hence easier to reason about. [There is also a JavaScript version, called Pampy.js](https://github.com/santinic/pampy.js).&lt;kbd&gt;  &lt;img src=&quot;https://raw.githubusercontent.com/santinic/pampy/master/imgs/slide1.png&quot; width=&quot;700&quot;&gt;&lt;/kbd&gt;## You can write many patternsPatterns are evaluated in the order they appear.&lt;kbd&gt;  &lt;img src=&quot;https://raw.githubusercontent.com/santinic/pampy/master/imgs/slide2.png&quot; width=&quot;700&quot;&gt;&lt;/kbd&gt;## You can write FibonacciThe operator _ means &quot;any other case I didn't think of&quot;.```pythonfrom pampy import match, _def fibonacci(n):    return match(n,        1, 1,        2, 1,        _, lambda x: fibonacci(x-1) + fibonacci(x-2)    )```## You can write a Lisp calculator in 5 lines```pythonfrom pampy import match, REST, _def lisp(exp):    return match(exp,        int,                lambda x: x,        callable,           lambda x: x,        (callable, REST),   lambda f, rest: f(*map(lisp, rest)),        tuple,              lambda t: list(map(lisp, t)),    )plus = lambda a, b: a + bminus = lambda a, b: a - bfrom functools import reducelisp((plus, 1, 2))                 # =&gt; 3lisp((plus, 1, (minus, 4, 2)))     # =&gt; 3lisp((reduce, plus, (range, 10)))       # =&gt; 45```## You can match so many things!```pythonmatch(x,    3,              &quot;this matches the number 3&quot;,    int,            &quot;matches any integer&quot;,    (str, int),     lambda a, b: &quot;a tuple (a, b) you can use in a function&quot;,    [1, 2, _],      &quot;any list of 3 elements that begins with [1, 2]&quot;,    {'x': _},       &quot;any dict with a key 'x' and any value associated&quot;,    _,              &quot;anything else&quot;)```## You can match [HEAD, TAIL]```pythonfrom pampy import match, HEAD, TAIL, _x = [1, 2, 3]match(x, [1, TAIL],     lambda t: t)            # =&gt; [2, 3]match(x, [HEAD, TAIL],  lambda h, t: (h, t))    # =&gt; (1, [2, 3])````TAIL` and `REST` actually mean the same thing.## You can nest lists and tuples```pythonfrom pampy import match, _x = [1, [2, 3], 4]match(x, [1, [_, 3], _], lambda a, b: [1, [a, 3], b])           # =&gt; [1, [2, 3], 4]```## You can nest dicts. And you can use _ as key!```pythonpet = { 'type': 'dog', 'details': { 'age': 3 } }match(pet, { 'details': { 'age': _ } }, lambda age: age)        # =&gt; 3match(pet, { _ : { 'age': _ } },        lambda a, b: (a, b))    # =&gt; ('details', 3)```It feels like putting multiple _ inside dicts shouldn't work. Isn't ordering in dicts not guaranteed ?But it does because[in Python 3.7, dict maintains insertion key order by default](https://mail.python.org/pipermail/python-dev/2017-December/151283.html)## You can match class hierarchies```pythonclass Pet:          passclass Dog(Pet):     passclass Cat(Pet):     passclass Hamster(Pet): passdef what_is(x):    return match(x,        Dog, 'dog',        Cat, 'cat',        Pet, 'any other pet',          _, 'this is not a pet at all',    )what_is(Cat())      # =&gt; 'cat'what_is(Dog())      # =&gt; 'dog'what_is(Hamster())  # =&gt; 'any other pet'what_is(Pet())      # =&gt; 'any other pet'what_is(42)         # =&gt; 'this is not a pet at all'```## Using DataclassesPampy supports Python 3.7 dataclasses. You can pass the operator `_` as arguments and it will match those fields.```python@dataclassclass Pet:    name: str    age: intpet = Pet('rover', 7)match(pet, Pet('rover', _), lambda age: age)                    # =&gt; 7match(pet, Pet(_, 7), lambda name: name)                        # =&gt; 'rover'match(pet, Pet(_, _), lambda name, age: (name, age))            # =&gt; ('rover', 7)```## Using typingPampy supports typing annotations.```pythonclass Pet:          passclass Dog(Pet):     passclass Cat(Pet):     passclass Hamster(Pet): passtimestamp = NewType(&quot;year&quot;, Union[int, float])def annotated(a: Tuple[int, float], b: str, c: E) -&gt; timestamp:    passmatch((1, 2), Tuple[int, int], lambda a, b: (a, b))             # =&gt; (1, 2)match(1, Union[str, int], lambda x: x)                          # =&gt; 1match('a', Union[str, int], lambda x: x)                        # =&gt; 'a'match('a', Optional[str], lambda x: x)                          # =&gt; 'a'match(None, Optional[str], lambda x: x)                         # =&gt; Nonematch(Pet, Type[Pet], lambda x: x)                              # =&gt; Petmatch(Cat, Type[Pet], lambda x: x)                              # =&gt; Catmatch(Dog, Any, lambda x: x)                                    # =&gt; Dogmatch(Dog, Type[Any], lambda x: x)                              # =&gt; Dogmatch(15, timestamp, lambda x: x)                               # =&gt; 15match(10.0, timestamp, lambda x: x)                             # =&gt; 10.0match([1, 2, 3], List[int], lambda x: x)                        # =&gt; [1, 2, 3]match({'a': 1, 'b': 2}, Dict[str, int], lambda x: x)            # =&gt; {'a': 1, 'b': 2}match(annotated,     Callable[[Tuple[int, float], str, Pet], timestamp], lambda x: x)                                                               # =&gt; annotated```For iterable generics actual type of value is guessed based on the first element. ```pythonmatch([1, 2, 3], List[int], lambda x: x)                        # =&gt; [1, 2, 3]match([1, &quot;b&quot;, &quot;a&quot;], List[int], lambda x: x)                    # =&gt; [1, &quot;b&quot;, &quot;a&quot;]match([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], List[int], lambda x: x)                  # raises MatchErrormatch([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], List[Union[str, int]], lambda x: x)      # [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]match({&quot;a&quot;: 1, &quot;b&quot;: 2}, Dict[str, int], lambda x: x)            # {&quot;a&quot;: 1, &quot;b&quot;: 2}match({&quot;a&quot;: 1, &quot;b&quot;: &quot;dog&quot;}, Dict[str, int], lambda x: x)        # {&quot;a&quot;: 1, &quot;b&quot;: &quot;dog&quot;}match({&quot;a&quot;: 1, 1: 2}, Dict[str, int], lambda x: x)              # {&quot;a&quot;: 1, 1: 2}match({2: 1, 1: 2}, Dict[str, int], lambda x: x)                # raises MatchErrormatch({2: 1, 1: 2}, Dict[Union[str, int], int], lambda x: x)    # {2: 1, 1: 2}```Iterable generics also match with any of their subtypes.```pythonmatch([1, 2, 3], Iterable[int], lambda x: x)                     # =&gt; [1, 2, 3]match({1, 2, 3}, Iterable[int], lambda x: x)                     # =&gt; {1, 2, 3}match(range(10), Iterable[int], lambda x: x)                     # =&gt; range(10)match([1, 2, 3], List[int], lambda x: x)                         # =&gt; [1, 2, 3]match({1, 2, 3}, List[int], lambda x: x)                         # =&gt; raises MatchErrormatch(range(10), List[int], lambda x: x)                         # =&gt; raises MatchErrormatch([1, 2, 3], Set[int], lambda x: x)                          # =&gt; raises MatchErrormatch({1, 2, 3}, Set[int], lambda x: x)                          # =&gt; {1, 2, 3}match(range(10), Set[int], lambda x: x)                          # =&gt; raises MatchError```For Callable any arg without annotation treated as Any. ```pythondef annotated(a: int, b: int) -&gt; float:    passdef not_annotated(a, b):    passdef partially_annotated(a, b: float):    passmatch(annotated, Callable[[int, int], float], lambda x: x)     # =&gt; annotatedmatch(not_annotated, Callable[[int, int], float], lambda x: x) # =&gt; raises MatchErrormatch(not_annotated, Callable[[Any, Any], Any], lambda x: x)   # =&gt; not_annotatedmatch(annotated, Callable[[Any, Any], Any], lambda x: x)       # =&gt; raises MatchErrormatch(partially_annotated,     Callable[[Any, float], Any], lambda x: x)                                                              # =&gt; partially_annotated```TypeVar is not supported.## All the things you can matchAs Pattern you can use any Python type, any class, or any Python value.The operator `_` and built-in types like `int` or `str`, extract variables that are passed to functions.Types and Classes are matched via `instanceof(value, pattern)`.`Iterable` Patterns match recursively through all their elements.  The same goes for dictionaries.| Pattern Example | What it means | Matched Example |  Arguments Passed to function | NOT Matched Example || --------------- | --------------| --------------- | ----------------------------- | ------------------ || `&quot;hello&quot;` |  only the string `&quot;hello&quot;` matches | `&quot;hello&quot;` | nothing | any other value || `None` | only `None` | `None` | nothing | any other value || `int` | Any integer | `42` | `42` | any other value || `float` | Any float number | `2.35` | `2.35` | any other value || `str` | Any string | `&quot;hello&quot;` | `&quot;hello&quot;` | any other value || `tuple` | Any tuple | `(1, 2)` | `(1, 2)` | any other value || `list` | Any list | `[1, 2]` | `[1, 2]` | any other value || `MyClass` | Any instance of MyClass. **And any object that extends MyClass.** | `MyClass()` | that instance | any other object || `_` | Any object (even None) |  | that value | || `ANY` | The same as `_` | | that value | || `(int, int)` | A tuple made of any two integers | `(1, 2)` | `1` and `2` | (True, False) || `[1, 2, _]`  | A list that starts with 1, 2 and ends with any value | `[1, 2, 3]` | `3` | `[1, 2, 3, 4]` || `[1, 2, TAIL]` | A list that start with 1, 2 and ends with any sequence | `[1, 2, 3, 4]`| `[3, 4]` | `[1, 7, 7, 7]` || `{'type':'dog', age: _ }` | Any dict with `type: &quot;dog&quot;` and with an age | `{&quot;type&quot;:&quot;dog&quot;, &quot;age&quot;: 3}` | `3` | `{&quot;type&quot;:&quot;cat&quot;, &quot;age&quot;:2}` || `{'type':'dog', age: int }` | Any dict with `type: &quot;dog&quot;` and with an `int` age | `{&quot;type&quot;:&quot;dog&quot;, &quot;age&quot;: 3}` | `3` | `{&quot;type&quot;:&quot;dog&quot;, &quot;age&quot;:2.3}` || `re.compile('(\w+)-(\w+)-cat$')` | Any string that matches that regular expression expr | `&quot;my-fuffy-cat&quot;` | `&quot;my&quot;` and `&quot;puffy&quot;` | `&quot;fuffy-dog&quot;` | | `Pet(name=_, age=7)` | Any Pet dataclass with `age == 7` | `Pet('rover', 7)` | `['rover']` | `Pet('rover', 8)` || `Any` | The same as `_` | | that value | || `Union[int, float, None]` | Any integer or float number or None | `2.35` | `2.35` | any other value || `Optional[int]` | The same as `Union[int, None]` | `2` | `2` | any other value || `Type[MyClass]` | Any subclass of MyClass. **And any class that extends MyClass.** | `MyClass` | that class | any other object || `Callable[[int], float]` | Any callable with exactly that signature | `def a(q:int) -&gt; float: ...` | that function | `def a(q) -&gt; float: ...` || `Tuple[MyClass, int, float]` | The same as `(MyClass, int, float)` | | | || `Mapping[str, int]` Any subtype of `Mapping` acceptable too | any mapping or subtype of mapping with string keys and integer values | `{'a': 2, 'b': 3}` | that dict | `{'a': 'b', 'b': 'c'}` || `Iterable[int]` Any subtype of `Iterable` acceptable too | any iterable or subtype of iterable with integer values | `range(10)` and `[1, 2, 3]` | that iterable | `['a', 'b', 'v']` |## Using defaultBy default `match()` is strict. If no pattern matches, it raises a `MatchError`.You can instead provide a fallback value using `default` to be used when nothing matches.```&gt;&gt;&gt; match([1, 2], [1, 2, 3], &quot;whatever&quot;)MatchError: '_' not provided. This case is not handled: [1, 2]&gt;&gt;&gt; match([1, 2], [1, 2, 3], &quot;whatever&quot;, default=False)False```## Using Regular ExpressionsPampy supports Python's Regex. You can pass a compiled regex as pattern, and Pampy is going to run `patter.search()`, and then pass to the action function the result of `.groups()`.```python def what_is(pet):    return match(pet,        re.compile('(\w+)-(\w+)-cat$'),     lambda name, my: 'cat '+name,        re.compile('(\w+)-(\w+)-dog$'),     lambda name, my: 'dog '+name,        _,                                  &quot;something else&quot;    )what_is('fuffy-my-dog')     # =&gt; 'dog fuffy'what_is('puffy-her-dog')    # =&gt; 'dog puffy'what_is('carla-your-cat')   # =&gt; 'cat carla'what_is('roger-my-hamster') # =&gt; 'something else'```## Install for Python3Pampy works in Python &gt;= 3.6 [Because dict matching can work only in the latest Pythons](https://mail.python.org/pipermail/python-dev/2017-December/151283.html).To install it:```$ pip install pampy```or```$ pip3 install pampy```## If you really must use Python2Pampy is Python3-first, but you can use most of its features in Python2 via [this backport](https://pypi.org/project/backports.pampy/) by Manuel Barkhau:```pip install backports.pampy``````pythonfrom backports.pampy import match, HEAD, TAIL, _```</longdescription>
</pkgmetadata>