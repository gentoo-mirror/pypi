<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Marshy - Better Marshalling for Python.This project is a general purpose externalizer for python objects.(Like Marshmallow or Pedantic) The guiding philosophy is conventionover configuration, with the aim of still making customizations aspain free as possible, based on python type hints.Out of the box, it supports primitives, dataclasses, and enums.## Installation`pip install marshy`## General UsageGiven the following dataclass:```from typing import List, Optionalimport dataclasses@dataclasses.dataclassclass Doohickey:  title: str  description: Optional[str] = None  tags: List[str] = dataclasses.field(default_factory=list)```Marshall data with:```import marshyresult = marshy.dump(Doohickey('Thingy', tags=['a','b']))# result == dict(title='Thingy', description=None, tags=['a','b'])```Unmarshall data with:```result = marshy.load(Doohickey, dict(title='Thingy'))# result == Doohickey('Thingy', description=None, tags=[])```## Custom propertiesCustom properties are also serialized by default. (If theyhave a setter, it is used when loading):```@dataclassclass Factorial:  value: int    @property  def factorial(self) -&gt; int:    return reduce(lambda a, b: a*b, range(1, self.value+1))    factorial = Factorial(4)dumped = dump(factorial)# dumped == dict(value=4, factorial=24)loaded = load(Factorial, dumped)# loaded == factorial```## Under The HoodInternally, API defines 3 core concepts:* A [Marshaller](marshy/marshaller/marshaller_abc.py): Is   responsible for marshalling / unmarshalling a single type of  object.* A [MarshallerFactory](marshy/factory/marshaller_factory_abc.py): has  a `create` method used to create marshallers for types, and has  a priority which controls the order in which they are run.   (higher first)* A [MarshallerContext](marshy/marshaller_context.py): coordinates  the activities of Marshallers and Factories## Creating a Custom Marshaller ContextIf you need multiple independent sets of rules formarshalling data, then you should create your own marshallingcontexts and store references to them. The default works wellotherwise:```# Dump a Doohickey using the default context (Same as marshy.dump...)from marshy import get_default_contextdumped = get_default_context().dump(Doohickey('Thingy'))# Create a new blank marshaller context - this will fail# because there are no preset types or factories.from marshy.marshaller_context import MarshallerContextmy_marshaller_context = MarshallerContext()dumped = my_marshaller_context.dump(Doohickey('Thingy'))# Create a new marshaller context which copies the default rules.from marshy.default_context import new_default_contextmy_default_context = new_default_context()dumped = my_default_context.dump(Doohickey('Thingy'))```## Creating a Custom MarshallerTo customize marshalling for a type, write a marshaller and thenregister it with your context:```from marshy.marshaller.marshaller_abc import MarshallerABCfrom marshy.types import ExternalTypeclass MyDoohickeyMarshaller(MarshallerABC[Doohickey]):    def __init__(self):        super().__init__(Doohickey)    def load(self, item: ExternalType) -&gt; Doohickey:        return Doohickey(item[0], item[1], item[2])    def dump(self, item: Doohickey) -&gt; ExternalType:        return [item.title, item.description, item.tags]my_default_context.register_marshaller(MyDoohickeyMarshaller())dumped = my_default_context.dump(Doohickey('Thingy'))# dumped == ['Thingy', None, []]loaded = my_default_context.load(Doohickey, dumped)# dumped == Doohickey('Thingy')```## Creating a Custom Marshaller FactorySometimes you need to create a marshaller for a while concept ofobject rather than a single type - In this case you need a factory,(this is how the default rules work!). Examples:* [ListMarshallerFactory](marshy/factory/list_marshaller_factory.py)  looks for typed lists (e.g.,: List[str]) and creates marshallers  for them - you already saw the results in `Doohickey.tags` above.* [OptionalMarshallerFactory](marshy/factory/optional_marshaller_factory.py)  looks for optional fields (e.g.,: Optional[str]) and creates   marshallers that mean each individual other marshaller does not  need to accommodate the case where a value is None - just mark  it optional!* [DataClassMarshallerFactory](marshy/factory/dataclass_marshaller_factory.py)  provides a marshaller for dataclasses assuming they have a standard  constructor based on their fields.  ## Customizing dataclass attributes:Taking the doohickey example:```from marshy import dump, get_default_contextfrom marshy.marshaller import str_marshaller, bool_marshallerfrom marshy.marshaller.obj_marshaller import ObjMarshallerattr_marshallers = dict(title=str_marshaller, tags=bool_marshaller)get_default_context().register_marshaller(ObjMarshaller(Doohickey, attr_marshallers, False))dumped = dump(Doohickey('Thingy'))# dumped == dict(title='Thingy', tags=False)```## Customizing dataclass marshallingAs an alternative to defining a custom marshaller / factory, it is possible to simplydefine a __marshaller_factory__ class method. (Note: this becomes the default for allcontexts) Imagine a case where you have a dataclass representing a 2D point, which youwant to be marshalled in the format [x, y] (An array rather than the standard object):```from dataclasses import dataclassfrom marshy.marshaller.marshaller_abc import MarshallerABCfrom marshy import load, dump@dataclassclass Point:    x: float    y: float        @classmethod    def __marshaller_factory__(cls, marshaller_context):       return PointMarshaller()       class PointMarshaller(MarshallerABC):    def __init__(self):        super().__init__(Point)    def load(self, item):        return Point(item[0], item[1])        def dump(self, item):        return [item.x, item.y]        dumped = dump(Point(1.2, 3.4))loaded = load(Point, dumped)```## Circular ReferencesDue to the fact that types in the object graph can self reference,we defer resolution of most marshaller until as late as possible.[DeferredMarshaller](marshy/marshaller/deferred_marshaller.py) is responsible for this, and means types can [self reference](test/test_marshall_deferred.py). Circular references within objects will still cause an error.(Unless you decide on an error handling protocol for this an implement a custom Factory to deal with it!)## Customizing the default contextThe project uses the namespace convention `marshy_config_` to identity configuration packages.(https://packaging.python.org/guides/creating-and-discovering-plugins/). Configuration packages should have an integerpriority attribute, and a  `def configure(context: MarshallerContext)` function. e.g.:[default_config](marshy_config_default/__init__.py)## Adding Polymorphic ImplementationsTaking the following polymorphic classes where `Pet` has implementations `Cat` and `Dog`:```from abc import ABC, abstractmethodfrom dataclasses import dataclass@dataclassclass PetAbc(ABC):    name: str    @abstractmethod    def vocalize(self) -&gt; str:        &quot;&quot;&quot; What sound does this make? &quot;&quot;&quot;class Cat(PetAbc):    def vocalize(self):        return &quot;Meow!&quot;class Dog(PetAbc):    def vocalize(self) -&gt; str:        return &quot;Woof!&quot;```In order to deserialize a Pet, marshy needs to be informed tha the implementations exist. This can be done at any point in the configuration:```from marshy import loadfrom marshy.factory.impl_marshaller_factory import register_implregister_impl(PetAbc, Cat)register_impl(PetAbc, Dog)pet = ['Cat', dict(name='Felix')]loaded = load(PetAbc, pet)```[Tests for this are here] (test/test_impl_marshaller.py)## Performance TestsBasic Tests show performance is approximate with marshmallow:```python -m timeit -s &quot;from test.performance.marshy_performance import runrun(1000)&quot;``````python -m timeit -s &quot;from test.performance.marshmallow_performance import runrun(1000)&quot;```## Release Proceedure![status](https://github.com/tofarr/marshy/actions/workflows/quality.yml/badge.svg?branch=main)The typical process here is:* Create a PR with changes. Merge these to main (The `Quality` workflows make sure that your PR  meets the styling, linting, and code coverage standards).* New releases created in github are automatically uploaded to pypi</longdescription>
</pkgmetadata>