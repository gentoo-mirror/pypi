<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>|Build Status| |Coverage Status| |Documentation Status| |Version||gitter|pyconll-------*Easily work with* **CoNLL** *files using the familiar syntax of***python**\ *.*Links'''''-  `Homepage &lt;https://pyconll.github.io&gt;`__-  `Documentation &lt;https://pyconll.readthedocs.io/&gt;`__Installation~~~~~~~~~~~~As with most python packages, simply use ``pip`` to install from PyPi.::   pip install pyconll``pyconll`` is also available as a conda package on the ``pyconll``channel. Only packages 2.2.0 and newer are available on conda at themoment.::   conda install -c pyconll pyconllpyconll supports Python 3.8 and greater. In general, pyconll will focusdevelopment efforts on officially supported python versions.Use~~~This tool is intended to be a **minimal**, **low level**, **expressive**and **pragmatic** library in a widely used programming language. pyconllcreates a thin API on top of raw CoNLL annotations that is simple andintuitive.It offers the following features: \* Regular CI testing and validationagainst all UD v2.x versions. \* A strong domain model that includesCoNLL sources, Sentences, Tokens, Trees, etc. \* A typed API for betterdevelopment experience and better semantics. \* A focus on usability andsimplicity in design (no dependencies) \* Performance optimizations fora smooth development workflow no matter the dataset size (performs about25%-35% faster than other comparable packages)See the following code example to understand the basics of the API... code:: python   # This snippet finds sentences where a token marked with part of speech 'AUX' are   # governed by a NOUN. For example, in French this is a less common construction   # and we may want to validate these examples because we have previously found some   # problematic examples of this construction.   import pyconll   train = pyconll.load_from_file('./ud/train.conllu')   review_sentences = []   # Conll objects are iterable over their sentences, and sentences are iterable   # over their tokens. Sentences also de/serialize comment information.   for sentence in train:      for token in sentence:      # Tokens have attributes such as upos, head, id, deprel, etc, and sentences      # can be indexed by a token's id. We must check that the token is not the      # root token, whose id, '0', cannot be looked up.      if token.upos == 'AUX' and (token.head != '0' and sentence[token.head].upos == 'NOUN'):         review_sentences.append(sentence)   print('Review the following sentences:')   for sent in review_sentences:      print(sent.id)A full definition of the API can be found in the`documentation &lt;https://pyconll.readthedocs.io/&gt;`__ or use the `quickstart &lt;https://pyconll.readthedocs.io/en/stable/starting.html&gt;`__ guidefor a focused introduction.Uses and Limitations~~~~~~~~~~~~~~~~~~~~This package edits CoNLL-U annotations. This does not include theannotated text itself. Word forms on Tokens are not editable andSentence Tokens cannot be reassigned or reordered. ``pyconll`` focuseson editing CoNLL-U annotation rather than creating it or changing theunderlying text that is annotated. If there is interest in thisfunctionality area, please create a GitHub issue for more visibility.This package also is only validated against the CoNLL-U format. TheCoNLL and CoNLL-X format are not supported, but are very similar. Ioriginally intended to support these formats as well, but their formatis not as well defined as CoNLL-U so they are not included. Pleasecreate an issue for visibility if this feature interests you.Lastly, linguistic data can often be very large and this packageattempts to keep that in mind. pyconll provides methods for creating inmemory conll objects along with an iterate only version in case a corpusis too large to store in memory (the size of the memory structure isseveral times larger than the actual corpus file). The iterate onlyversion can parse upwards of 100,000 words per second on a 16gb rammachine, so for most datasets to be used on a local dev machine, thispackage will perform well. The 2.2.0 release also improves parse timeand memory footprint by about 25%!Contributing~~~~~~~~~~~~Contributions to this project are welcome and encouraged! If you areunsure how to contribute, here is a`guide &lt;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&gt;`__from Github explaining the basic workflow. After cloning this repo,please run ``pip install -r requirements.txt`` to properly setuplocally. Some of these tools like yapf, pylint, and mypy do not have tobe run locally, but CI builds will fail without their successfulrunning. Some other release dependencies like twine and sphinx are alsoinstalled.For packaging new versions, use setuptools version 24.2.0 or greater forcreating the appropriate packaging that recognizes the``python_requires`` metadata. Final packaging and release is now donewith Github actions so this is less of a concern.README and CHANGELOG^^^^^^^^^^^^^^^^^^^^When changing either of these files, please change the Markdown versionand run ``make gendocs`` so that the other versions stay in sync.Release Checklist^^^^^^^^^^^^^^^^^Below enumerates the general release process explicitly. This section isfor internal use and most people do not have to worry about this. Firstnote, that the dev branch is always a direct extension of master withthe latest changes since the last release. That is, it is essentially astaging release branch.-  Change the version in ``pyconll/_version.py`` appropriately.-  Merge dev into master **locally**. Github does not offer a fast   forward merge and explicitly uses --no-ff. So to keep the linear   nature of changes, merge locally to fast forward. This is assuming   that the dev branch looks good on CI tests which do not automatically   run in this situation.-  Push the master branch. This should start some CI tests specifically   for master. After validating these results, create a tag   corresponding to the next version number and push the tag.-  Create a new release from this tag from the `Releases   page &lt;https://github.com/pyconll/pyconll/releases&gt;`__. On creating   this release, two workflows will start. One releases to pypi, and the   other releases to conda.-  Validate these workflows pass, and the package is properly released   on both platforms... |Build Status| image:: https://github.com/pyconll/pyconll/workflows/CI/badge.svg?branch=master   :target: https://github.com/pyconll/pyconll.. |Coverage Status| image:: https://coveralls.io/repos/github/pyconll/pyconll/badge.svg?branch=master   :target: https://coveralls.io/github/pyconll/pyconll?branch=master.. |Documentation Status| image:: https://readthedocs.org/projects/pyconll/badge/?version=stable   :target: https://pyconll.readthedocs.io/en/stable.. |Version| image:: https://img.shields.io/github/v/release/pyconll/pyconll   :target: https://github.com/pyconll/pyconll/releases.. |gitter| image:: https://badges.gitter.im/pyconll/pyconll.svg   :target: https://gitter.im/pyconll/pyconll?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge</longdescription>
</pkgmetadata>