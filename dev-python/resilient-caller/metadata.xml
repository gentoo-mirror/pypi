<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Resilient CallerA Python package that provides a customizable wrapper to retry function calls with custom logic. This package was developed to address the need for executing numerous requests with similar, yet slightly different, exception handling. The wrapper reduces the need to write multiple while loops and try/except blocks for each request.The wrapper can be implemented for any function, not just requests-related functions. The module also includes a Python requests implementation with auto proxy formatting from a string, by simply passing the proxy as a string to the send_request function. Async functions support as well.The resilient caller supports the following keyword arguments (kwargs) for the wrapper. Note that these kwargs will not be passed to the wrapped function:- `conditions`: A dictionary specifying the actions to take for a given outcome.- `conditions_criteria`: The criteria to use when checking the `conditions`.- `exceptions`: A dictionary specifying the actions to take for a given exception or 'all' for non-handled or all exceptions.- `retries`: The maximum number of times to retry the function (disabled by default).- `delay`: The number of seconds to sleep between retries.- `on_retry`: A callback function to execute on retry, for example, a log function.In the module, a Python requests implementation is provided with automatic proxy formatting from a string.Please refer to the usage examples below and the examples folder in the repository for more information on how to use the resilient caller. ## InstallationInstall the package using pip:```pip install resilient_caller```## Examples### Quick simple and easy web scraping monitorIn this example, we will create a `SimpleScraper` class that monitors [glizzykingdreko's medium blog](https://medium.com/@glizzykingdreko) for new articles. By defining the start method with the `@resilient_call()` decorator and passing `delay=5` and `exceptions={&quot;all&quot;: RETRY_EVENT}` when calling it, we ensure that the scraper handles all exceptions with a retry and adds a delay of 5 seconds between each request.```pythonfrom bs4 import BeautifulSoupfrom requests import Sessionfrom typing import Listfrom time import sleepfrom resilenter_caller import resilient_call, RETRY_EVENTclass SimpleScraper:    def __init__(self):        self.session, self.articles = Session(), []        # This is making the function run through a while loop with a delay of 5 seconds        # and handling any exception with a retry event.        self.start(delay=5, exceptions={&quot;all&quot;: RETRY_EVENT})    @resilient_call()    def start(self) -&gt; None:        data = self.load_api_data()        self.load_response_details(data)    def load_response_details(self, response: str) -&gt; List[str]:        data = BeautifulSoup(response, &quot;html.parser&quot;)        new_articles = [            [d.find(&quot;h2&quot;).text, d.find(&quot;a&quot;).get(&quot;href&quot;)]             for d in data.find_all(&quot;article&quot;)             if d.find(&quot;h2&quot;).text not in self.articles        ]        for article in new_articles:            name, url = article            print(f&quot;New glizzykingdreko's article on medium \&quot;{name}\&quot;! Check it out at {url}.&quot;)            self.articles.append(name)        return new_articles    def load_api_data(self) -&gt; str:        url = &quot;https://medium.com/@glizzykingdreko&quot;        return self.session.get(url).textif __name__ == &quot;__main__&quot;:    SimpleScraper()```### Web scraping with retry, custom handling and handling for all exceptionsIn this example, we will use the send_request() function provided in the module to perform web scraping. We will also use all the available options to customize the handling of different HTTP response codes and handle all exceptions.```pythonfrom bs4 import BeautifulSoupfrom resilenter_caller import send_request, RETRY_EVENTdef handle_success(response):    print(f&quot;Request successful, status code: {response.status_code}&quot;)    soup = BeautifulSoup(response.text, &quot;html.parser&quot;)    title = soup.find(&quot;title&quot;)    print(f&quot;Page title: {title.string}&quot;)    return responsedef handle_not_found(response):    print(f&quot;Page not found, status code: {response.status_code}&quot;)    return RETRY_EVENTdef handle_server_error(response):    print(f&quot;Server error, status code: {response.status_code}&quot;)    return RETRY_EVENTdef handle_all_exceptions(exception):    print(f&quot;An exception occurred: {type(exception).__name__} - {exception}&quot;)    return RETRY_EVENTif __name__ == &quot;__main__&quot;:    response = send_request(        &quot;https://www.example.com&quot;,        retries=3,        delay=2,        conditions={200: handle_success, 404: handle_not_found, 500: handle_server_error},        exceptions={&quot;all&quot;: handle_all_exceptions},        on_retry=lambda tries: print(f&quot;Retry {tries}&quot;)    )```### File processing with retry and custom handlingIn this example, we will use the resilient_call() decorator to implement a function that processes a file and retries the operation in case of failure. We will also use all the available options to customize the handling of different file sizes.```pythonimport osfrom resilenter_caller import resilient_call, RETRY_EVENTdef process_large_file(file_path):    print(f&quot;Processing large file: {file_path}&quot;)    return RETRY_EVENTdef process_small_file(file_path):    print(f&quot;Processing small file: {file_path}&quot;)    return RETRY_EVENTdef process_valid_file(file_path):    print(f&quot;Processing valid file: {file_path}&quot;)    return file_path@resilient_call()def process_file(file_path):    file_size = os.path.getsize(file_path)    return file_sizeif __name__ == &quot;__main__&quot;:    processed_file = process_file(        &quot;example.txt&quot;,        retries=5,        delay=2,        conditions={-1: process_large_file, 1: process_small_file},        conditions_criteria=lambda file_size: -1 if file_size &gt; 1000000 else 1 if file_size &lt; 1000 else 0,        on_retry=lambda tries: print(f&quot;Retry {tries}&quot;)    )```### Asynchronous API call with rate limiting retryIn this example, we will use the resilient_call() decorator to implement an asynchronous function that makes an API call and retries the call in case of failure or rate limiting.```pythonimport aiohttp, asynciofrom resilenter_caller import resilient_call, RETRY_EVENTasync def handle_rate_limit(e):    print(f&quot;Rate limited: {e}&quot;)    return RETRY_EVENT@resilient_call()async def async_api_call(url):    async with aiohttp.ClientSession() as session:        async with session.get(url) as response:            if response.status == 429:                raise Exception(&quot;Rate limited&quot;)            data = await response.json()            return dataasync def main():    await async_api_call(        &quot;https://httpbin.org/status/429&quot;,        retries=3,         delay=5,        exceptions={Exception: handle_rate_limit}    )if __name__ == &quot;__main__&quot;:    asyncio.run(main())```### Custom backoff strategy (exponential backoff)In this example, we will create a function that will randomly fail with a 30% chance.If it fails, we will retry the function with an exponential backoff strategy.```pythonimport loggingimport randomfrom resilenter_caller import resilient_call, RETRY_EVENT# Set level as debug to get full logslogging.basicConfig(level=logging.DEBUG)def exponential_backoff(tries):    return 2 ** (tries - 1) + random.uniform(0, 1)# If 2 arguments are passed to an exception function# the second argument will be the number of tries# (same thing for a condition)def print_exception(exception, tries):    print(f&quot;Exception: {exception} (try {tries})&quot;)    return RETRY_EVENT@resilient_call()def example_function():    random_num = random.random()    if random_num &lt; 0.7:        print(&quot;Failed, retrying...&quot;)        raise ValueError(&quot;Random number too low&quot;)    else:        print(&quot;Success!&quot;)        return &quot;Successful response&quot;if __name__ == '__main__':    result = example_function(        retries=5,         on_retry=exponential_backoff,        exceptions={ValueError: print_exception}    )    print(&quot;Result:&quot;, result)```### Pass the number of tries to the action functionIn this example, by using a function that takes 2 arguments, we can pass the number of tries to the action function.```pythonimport randomfrom resilenter_caller import resilient_call, RETRY_EVENTdef some_condition(response):    return response == &quot;Retry&quot;def handle_response(response, tries):    if tries &lt; 3 and some_condition(response):        return RETRY_EVENT    else:        return response# We set the max execution time to 10 seconds@resilient_call(max_elapsed_time=10)def example_function():    random_num = random.random()    if random_num &lt; 0.6:        print(&quot;Returning 'Retry'&quot;)        return &quot;Retry&quot;    else:        print(&quot;Success!&quot;)        return &quot;Successful response&quot;if __name__ == '__main__':    result = example_function(        # With 'all' we can handle all the        # possible responses or exceptions        conditions={'all': handle_response},    )    print(&quot;Result:&quot;, result)```These examples demonstrate the versatility and usefulness of the Resilient Caller module. This module can be applied to a wide range of use cases, from web scraping and file processing to API calls and custom backoff strategies. Make sure to explore the examples folder in the repository for even more examples and use cases with other parameters and configurations.## Personal ThoughtsI hope this module will help many developers save time and make their code more efficient. Please feel free to contact me for any help or suggestions via [Email](mailto:glizzykingdreko@protonmail.com) or [Twitter](https://mobile.twitter.com/glizzykingdreko). Don't forget to follow me on GitHub and Medium for more exciting content and updates. I appreciate your feedback and contributions to the project.## ContributingI welcome contributions to the Resilient Caller project! To contribute, please follow these steps:- Fork the repository on GitHub.- Create a new branch with a descriptive name.- Make your changes, add new features, or fix bugs.- Write tests to ensure that your changes work as expected.- Update the documentation and examples to reflect your changes.- Commit your changes and create a pull request.Please make sure to follow the existing code style and provide clear, concise commit messages. If you have any questions, feel free to open an issue, and we'll be happy to help.## LicenseThis project is licensed under the MIT [License](LICENSE). See the LICENSE file for more details.## My links- [Project repository](https://github.com/glizzykingdreko/resilient_caller)- [GitHub](https://github.com/glizzykingdreko)- [Twitter](https://mobile.twitter.com/glizzykingdreko)- [Medium](https://medium.com/@glizzykingdreko)- [Email](mailto:glizzykingdreko@protonmail.com)</longdescription>
</pkgmetadata>