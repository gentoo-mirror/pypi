<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pydantic-yaml[![PyPI version](https://badge.fury.io/py/pydantic-yaml.svg)](https://badge.fury.io/py/pydantic-yaml) [![Documentation Status](https://readthedocs.org/projects/pydantic-yaml/badge/?version=latest)](https://pydantic-yaml.readthedocs.io/en/latest/?badge=latest) [![Unit Tests](https://github.com/NowanIlfideme/pydantic-yaml/actions/workflows/python-testing.yml/badge.svg)](https://github.com/NowanIlfideme/pydantic-yaml/actions/workflows/python-testing.yml)This is a small helper library that adds some YAML capabilities to [pydantic](https://github.com/samuelcolvin/pydantic), namely dumping to yaml via the `yaml_model.yaml()` function, and parsing from strings/files using `YamlModel.parse_raw()` and `YamlModel.parse_file()`. It also adds `Enum` subclasses that get dumped to YAML as strings or integers, and fixes dumping of some typical types.[Documentation on ReadTheDocs.org](https://pydantic-yaml.readthedocs.io/en/latest/)## Basic UsageTypical usage is seen below. See the [pydantic docs](https://pydantic-docs.helpmanual.io/)for more usage examples.```pythonfrom pydantic import BaseModel, validatorfrom pydantic_yaml import YamlStrEnum, YamlModelclass MyEnum(YamlStrEnum):    &quot;&quot;&quot;This is a custom enumeration that is YAML-safe.&quot;&quot;&quot;    a = &quot;a&quot;    b = &quot;b&quot;class InnerModel(BaseModel):    &quot;&quot;&quot;This is a normal pydantic model that can be used as an inner class.&quot;&quot;&quot;    fld: float = 1.0class MyModel(YamlModel):    &quot;&quot;&quot;This is our custom class, with a `.yaml()` method.    The `parse_raw()` and `parse_file()` methods are also updated to be able to    handle `content_type='application/yaml'`, `protocol=&quot;yaml&quot;` and file names    ending with `.yml`/`.yaml`    &quot;&quot;&quot;    x: int = 1    e: MyEnum = MyEnum.a    m: InnerModel = InnerModel()    @validator('x')    def _chk_x(cls, v: int) -&gt; int:  # noqa        &quot;&quot;&quot;You can add your normal pydantic validators, like this one.&quot;&quot;&quot;        assert v &gt; 0        return vm1 = MyModel(x=2, e=&quot;b&quot;, m=InnerModel(fld=1.5))# This dumps to YAML and JSON respectivelyyml = m1.yaml()jsn = m1.json()m2 = MyModel.parse_raw(yml)  # This automatically assumes YAMLassert m1 == m2m3 = MyModel.parse_raw(jsn)  # This will fallback to JSONassert m1 == m3m4 = MyModel.parse_raw(yml, proto=&quot;yaml&quot;)assert m1 == m4m5 = MyModel.parse_raw(yml, content_type=&quot;application/yaml&quot;)assert m1 == m5```## Installation`pip install pydantic_yaml`Make sure to install `ruamel.yaml` or `pyyaml` as well. These are optional dependencies:`pip install pydantic_yaml[ruamel]``pip install pydantic_yaml[pyyaml]`## Mixin ClassVersion 0.5.0 adds a `YamlModelMixin` which can be used to add YAML functionality ontop of, or alongside, other base classes:```pythonfrom typing import Listfrom pydantic import BaseModelfrom pydantic_yaml import YamlModelMixinclass MyBase(BaseModel):    &quot;&quot;&quot;This is a normal.&quot;&quot;&quot;    x: str = &quot;x&quot;class ExtModel(YamlModelMixin, MyBase):    &quot;&quot;&quot;This model can be sent to/read from YAML.&quot;&quot;&quot;    y: List[int] = [1, 2, 3]  # and you can define additional fields, if you want```Note that this `YamlModelMixin` must be **before** any `BaseModel`-derived classes.This will hopefully be resolved in Pydantic 2.0(see [this discussion](https://github.com/samuelcolvin/pydantic/discussions/3025)for more details). If you know a better way of implementing this, please make raisean issue or create a PR!## ConfigurationYou can configure the function used to dump and load the YAML by using the `Config`inner class, [as in Pydantic](https://pydantic-docs.helpmanual.io/usage/model_config/):```pythonclass MyModel(YamlModel):    # ...    class Config:        # You can override these fields:        yaml_dumps = my_custom_dumper        yaml_loads = lambda x: MyModel()        # As well as other Pydantic configuration:        allow_mutation = False```## Versioned ModelsSince YAML is often used for config files, there is also a `SemVer` str-like class and `VersionedYamlModel` base class.The `version` attribute is parsed according to the SemVer([Semantic Versioning](https://semver.org/)) specification.It's constrained between the `min_version` and `max_version` specified by your models'`Config` inner class (similar to regular `pydantic` models).### Usage example```pythonfrom pydantic import ValidationErrorfrom pydantic_yaml import SemVer, VersionedYamlModelclass A(VersionedYamlModel):    &quot;&quot;&quot;Model with min, max constraints as None.&quot;&quot;&quot;    foo: str = &quot;bar&quot;class B(VersionedYamlModel):    &quot;&quot;&quot;Model with a maximum version set.&quot;&quot;&quot;    foo: str = &quot;bar&quot;    class Config:        min_version = &quot;2.0.0&quot;ex_yml = &quot;&quot;&quot;version: 1.0.0foo: baz&quot;&quot;&quot;a = A.parse_raw(ex_yml)assert a.version == SemVer(&quot;1.0.0&quot;)assert a.foo == &quot;baz&quot;try:    B.parse_raw(ex_yml)except ValidationError as e:    print(&quot;Correctly got ValidationError:&quot;, e, sep=&quot;\n&quot;)```</longdescription>
</pkgmetadata>