<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Python StateMachine[![pypi](https://img.shields.io/pypi/v/python-statemachine.svg)](https://pypi.python.org/pypi/python-statemachine)[![downloads](https://img.shields.io/pypi/dm/python-statemachine.svg)](https://pypi.python.org/pypi/python-statemachine)[![build status](https://github.com/fgmacedo/python-statemachine/actions/workflows/python-package.yml/badge.svg?branch=develop)](https://github.com/fgmacedo/python-statemachine/actions/workflows/python-package.yml?query=branch%3Adevelop)[![Coverage report](https://codecov.io/gh/fgmacedo/python-statemachine/branch/develop/graph/badge.svg)](https://codecov.io/gh/fgmacedo/python-statemachine)[![Documentation Status](https://readthedocs.org/projects/python-statemachine/badge/?version=latest)](https://python-statemachine.readthedocs.io/en/latest/?badge=latest)[![GitHub commits since last release (main)](https://img.shields.io/github/commits-since/fgmacedo/python-statemachine/main/develop)](https://github.com/fgmacedo/python-statemachine/compare/main...develop)Python [finite-state machines](https://en.wikipedia.org/wiki/Finite-state_machine) made easy.* Free software: MIT license* Documentation: https://python-statemachine.readthedocs.io.Welcome to python-statemachine, an intuitive and powerful state machine framework designed for agreat developer experience.ðŸš€ With StateMachine, you can easily create complex, dynamic systems with clean, readable code.ðŸ’¡ Our framework makes it easy to understand and reason about the different states, events andtransitions in your system, so you can focus on building great products.ðŸ”’ python-statemachine also provides robust error handling and ensures that your system staysin a valid state at all times.A few reasons why you may consider using it:* ðŸ“ˆ python-statemachine is designed to help you build scalable,  maintainable systems that can handle any complexity.* ðŸ’ª You can easily create and manage multiple state machines within a single application.* ðŸš« Prevents common mistakes and ensures that your system stays in a valid state at all times.## Getting startedTo install Python State Machine, run this command in your terminal:    pip install python-statemachineTo generate diagrams from your machines, you'll also need `pydot` and `Graphviz`. You caninstall this library already with `pydot` dependency using the `extras` install option. Seeour docs for more details.    pip install python-statemachine[diagrams]Define your state machine:```py&gt;&gt;&gt; from statemachine import StateMachine, State&gt;&gt;&gt; class TrafficLightMachine(StateMachine):...     &quot;A traffic light machine&quot;...     green = State(initial=True)...     yellow = State()...     red = State()......     cycle = (...         green.to(yellow)...         | yellow.to(red)...         | red.to(green)...     )......     def before_cycle(self, event: str, source: State, target: State, message: str = &quot;&quot;):...         message = &quot;. &quot; + message if message else &quot;&quot;...         return f&quot;Running {event} from {source.id} to {target.id}{message}&quot;......     def on_enter_red(self):...         print(&quot;Don't move.&quot;)......     def on_exit_red(self):...         print(&quot;Go ahead!&quot;)```You can now create an instance:```py&gt;&gt;&gt; sm = TrafficLightMachine()```This state machine can be represented graphically as follows:```py&gt;&gt;&gt; img_path = &quot;docs/images/readme_trafficlightmachine.png&quot;&gt;&gt;&gt; sm._graph().write_png(img_path)```![](https://raw.githubusercontent.com/fgmacedo/python-statemachine/develop/docs/images/readme_trafficlightmachine.png)Where on the `TrafficLightMachine`, we've defined `green`, `yellow`, and `red` as states, andone event called `cycle`, which is bound to the transitions from `green` to `yellow`, `yellow` to `red`,and `red` to `green`. We also have defined three callbacks by name convention, `before_cycle`, `on_enter_red`, and `on_exit_red`.Then start sending events to your new state machine:```py&gt;&gt;&gt; sm.send(&quot;cycle&quot;)'Running cycle from green to yellow'```That's it. This is all an external object needs to know about your state machine: How to send events.Ideally, all states, transitions, and actions should be kept internally and not checked externally to avoid unnecessary coupling.But if your use case needs, you can inspect state machine properties, like the current state:```py&gt;&gt;&gt; sm.current_state.id'yellow'```Or get a complete state representation for debugging purposes:```py&gt;&gt;&gt; sm.current_stateState('Yellow', id='yellow', value='yellow', initial=False, final=False)```The `State` instance can also be checked by equality:```py&gt;&gt;&gt; sm.current_state == TrafficLightMachine.yellowTrue&gt;&gt;&gt; sm.current_state == sm.yellowTrue```Or you can check if a state is active at any time:```py&gt;&gt;&gt; sm.green.is_activeFalse&gt;&gt;&gt; sm.yellow.is_activeTrue&gt;&gt;&gt; sm.red.is_activeFalse```Easily iterate over all states:```py&gt;&gt;&gt; [s.id for s in sm.states]['green', 'red', 'yellow']```Or over events:```py&gt;&gt;&gt; [t.name for t in sm.events]['cycle']```Call an event by its name:```py&gt;&gt;&gt; sm.cycle()Don't move.'Running cycle from yellow to red'```Or send an event with the event name:```py&gt;&gt;&gt; sm.send('cycle')Go ahead!'Running cycle from red to green'&gt;&gt;&gt; sm.green.is_activeTrue```You can pass arbitrary positional or keyword arguments to the event, andthey will be propagated to all actions and callbacks using something similar to dependency injection. In other words, the library will only inject the parameters declared on thecallback method.Note how `before_cycle` was declared:```pydef before_cycle(self, event: str, source: State, target: State, message: str = &quot;&quot;):    message = &quot;. &quot; + message if message else &quot;&quot;    return f&quot;Running {event} from {source.id} to {target.id}{message}&quot;```The params `event`, `source`, `target` (and others) are available built-in to be used on any action.The param `message` is user-defined, in our example we made it default empty so we can call `cycle` withor without a `message` parameter.If we pass a `message` parameter, it will be used on the `before_cycle` action:```py&gt;&gt;&gt; sm.send(&quot;cycle&quot;, message=&quot;Please, now slowdown.&quot;)'Running cycle from green to yellow. Please, now slowdown.'```By default, events with transitions that cannot run from the current state or unknown eventsraise a `TransitionNotAllowed` exception:```py&gt;&gt;&gt; sm.send(&quot;go&quot;)Traceback (most recent call last):statemachine.exceptions.TransitionNotAllowed: Can't go when in Yellow.```Keeping the same state as expected:```py&gt;&gt;&gt; sm.yellow.is_activeTrue```A human-readable name is automatically derived from the `State.id`, which is used on the messagesand in diagrams:```py&gt;&gt;&gt; sm.current_state.name'Yellow'```## A more useful exampleA simple didactic state machine for controlling an `Order`:```py&gt;&gt;&gt; class OrderControl(StateMachine):...     waiting_for_payment = State(initial=True)...     processing = State()...     shipping = State()...     completed = State(final=True)......     add_to_order = waiting_for_payment.to(waiting_for_payment)...     receive_payment = (...         waiting_for_payment.to(processing, cond=&quot;payments_enough&quot;)...         | waiting_for_payment.to(waiting_for_payment, unless=&quot;payments_enough&quot;)...     )...     process_order = processing.to(shipping, cond=&quot;payment_received&quot;)...     ship_order = shipping.to(completed)......     def __init__(self):...         self.order_total = 0...         self.payments = []...         self.payment_received = False...         super(OrderControl, self).__init__()......     def payments_enough(self, amount):...         return sum(self.payments) + amount &gt;= self.order_total......     def before_add_to_order(self, amount):...         self.order_total += amount...         return self.order_total......     def before_receive_payment(self, amount):...         self.payments.append(amount)...         return self.payments......     def after_receive_payment(self):...         self.payment_received = True......     def on_enter_waiting_for_payment(self):...         self.payment_received = False```You can use this machine as follows.```py&gt;&gt;&gt; control = OrderControl()&gt;&gt;&gt; control.add_to_order(3)3&gt;&gt;&gt; control.add_to_order(7)10&gt;&gt;&gt; control.receive_payment(4)[4]&gt;&gt;&gt; control.current_state.id'waiting_for_payment'&gt;&gt;&gt; control.current_state.name'Waiting for payment'&gt;&gt;&gt; control.process_order()Traceback (most recent call last):...statemachine.exceptions.TransitionNotAllowed: Can't process_order when in Waiting for payment.&gt;&gt;&gt; control.receive_payment(6)[4, 6]&gt;&gt;&gt; control.current_state.id'processing'&gt;&gt;&gt; control.process_order()&gt;&gt;&gt; control.ship_order()&gt;&gt;&gt; control.payment_receivedTrue&gt;&gt;&gt; control.order_total10&gt;&gt;&gt; control.payments[4, 6]&gt;&gt;&gt; control.completed.is_activeTrue```There's a lot more to cover, please take a look at our docs:https://python-statemachine.readthedocs.io.## Contributing to the project* &lt;a class=&quot;github-button&quot; href=&quot;https://github.com/fgmacedo/python-statemachine&quot; data-icon=&quot;octicon-star&quot; aria-label=&quot;Star fgmacedo/python-statemachine on GitHub&quot;&gt;Star this project&lt;/a&gt;* &lt;a class=&quot;github-button&quot; href=&quot;https://github.com/fgmacedo/python-statemachine/issues&quot; data-icon=&quot;octicon-issue-opened&quot; aria-label=&quot;Issue fgmacedo/python-statemachine on GitHub&quot;&gt;Open an Issue&lt;/a&gt;* &lt;a class=&quot;github-button&quot; href=&quot;https://github.com/fgmacedo/python-statemachine/fork&quot; data-icon=&quot;octicon-repo-forked&quot; aria-label=&quot;Fork fgmacedo/python-statemachine on GitHub&quot;&gt;Fork&lt;/a&gt;- If you found this project helpful, please consider giving it a star on GitHub.- **Contribute code**: If you would like to contribute code to this project, please submit a pullrequest. For more information on how to contribute, please see our [contributing.md](contributing.md) file.- **Report bugs**: If you find any bugs in this project, please report them by opening an issue  on our GitHub issue tracker.- **Suggest features**: If you have a great idea for a new feature, please let us know by opening  an issue on our GitHub issue tracker.- **Documentation**: Help improve this project's documentation by submitting pull requests.- **Promote the project**: Help spread the word about this project by sharing it on social media,  writing a blog post, or giving a talk about it. Tag me on Twitter  [@fgmacedo](https://twitter.com/fgmacedo) so I can share it too!</longdescription>
</pkgmetadata>