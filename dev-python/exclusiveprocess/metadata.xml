<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>exclusiveprocess - Simple Cross-Process Locking in Python=========================================================This is a simple Python 3.4+ module for ensuring that your code does notexecute concurrently in multiple processes, using POSIX file locking.The lock can be acquired easily using ``with`` syntax or as a decorator.Why?----If you have long-running processes that would cause corruption if it'sexecuted multiple times concurrently, this package is for you. You mightuse this in scripts that make backups, perform database migrations, orother long-running processes that need to abort if they are alreadyrunning.How it works under the hood---------------------------The module uses POSIX file locking and a PID file:-  A file is selected to hold lock information, typically   ``/var/lock/py_exclusivelock_yournamehere.lock``, called the   lockfile, based on a name you provide. The name is sanitized before   being used in the filename.-  If the lockfile already exists and it contains the PID of a running   process (including the current process), then a ``CannotAcquireLock``   exception is thrown.-  Otherwise the lockfile is created (or overwritten) and this process's   integer process ID is written to the file. POSIX file locking (lockf)   and open with O_EXCL is used to prevent race conditions.-  The lockfile is deleted when the ``with`` block or decorated function   exits. Or when used with ``.forever()`` (see below), at program exit.How to use it-------------First install this package:::    pip3 install exclusiveprocessThen in your Python file import the package:::    from exclusiveprocess import Lock, CannotAcquireLockYou can use it in a ``with`` statement:::    try:        with Lock(name=&quot;myprocess&quot;):            print(&quot;This block cannot be executed concurrently!&quot;)    except CannotAcquireLock:        print(&quot;Well, that's bad.&quot;)Or as a decorator:::    # lock name chosen based on __file__    @Lock    def myfunc():        print(&quot;This function cannot be executed concurrently!&quot;)    # lock name is &quot;myprocess&quot;    @Lock(name=&quot;myprocess&quot;)    def myfunc():        print(&quot;This function cannot be executed concurrently!&quot;)The ``name`` is up to you. The lock is specific to the name. The name issystem global (as global as the file system is).There are also some handy features for locking your whole program.1. The ``name`` argument is optional and defaults to the filename of the   module that contains the function that called ``Lock`` (i.e. your   Python source file), using   `inspect.stack() &lt;https://docs.python.org/3.5/library/inspect.html#inspect.stack&gt;`__,   which results in the Lock being automatically exclusive to all   invocations of your application.2. When you set the optional ``die`` keyword argument to ``True``,   ``Lock`` will print an error to STDERR and exit the process   immediately with exit code 1 if the lock cannot be acquired, instead   of rasing an exception.3. The lock can be acquired with ``.forever()``, instead of ``with`` or   decorator syntax, in which case the lock will be released only at   program exit using   `atexit &lt;https://docs.python.org/3.5/library/atexit.html&gt;`__.With these features, you can make your whole program exclusive byplacing the following line at the start of your program:::    # At program start.    Lock(die=True).forever()    # program exits here if lock could not be acquiredIf two such programs are run conncurrently you will see on STDERR:::    Another '/home/user/your_script.py' process is already running (pid 27922).Advanced--------The ``with`` object can be captured if you want to see where thelockfile is stored:::    with Lock(name=&quot;test1&quot;) as lock:        print(lock.lockfile)    # outputs:    /var/lock/py_exclusivelock_test1.lockThe ``Lock`` class logs every lock acquired and released to``logging.info``.</longdescription>
</pkgmetadata>