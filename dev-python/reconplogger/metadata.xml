<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://circleci.com/gh/omni-us/reconplogger.svg?style=svg    :target: https://circleci.com/gh/omni-us/reconplogger.. image:: https://codecov.io/gh/omni-us/reconplogger/branch/master/graph/badge.svg    :target: https://codecov.io/gh/omni-us/reconplogger.. image:: https://sonarcloud.io/api/project_badges/measure?project=omni-us_reconplogger&amp;metric=alert_status    :target: https://sonarcloud.io/dashboard?id=omni-us_reconplogger.. image:: https://badge.fury.io/py/reconplogger.svg    :target: https://badge.fury.io/py/reconplogger.. image:: https://img.shields.io/badge/contributions-welcome-brightgreen.svg    :target: https://github.com/omni-us/reconploggerreconplogger - omni:us python logger====================================This repository contains the code of reconplogger, a python package intended toease the standardization of logging within omni:us. The main design decision ofreconplogger is to allow total freedom to reconfigure loggers without hardcoding anything.The package contains essentially three things:- A default logging configuration.- A function for loading logging configuration for regular python code.- A function for loading logging configuration for flask-based microservices.- An inheritable class to add a logger property.- Lower level functions for:  - Loading logging configuration from any of: config file, environment variable, or default.  - Replacing the handlers of an existing Logger object.  - Function to add a file handler to a logger.How to use==========There are two main use cases reconplogger targets. One is for logging in regulargeneric python code and the second one is logging in microservices. See the twostandardizing sections below for a detailed explanation of the two use cases.Add as requirement------------------The first step to use reconplogger is adding it as a requirement in therespective package where it will be used. This means adding it in the file`setup.cfg` as an item in :code:`install_requires` or in an:code:`extras_require` depending on whether reconplogger is intended to be acore or an optional requirement.Note: It is highly discouraged to develop packages in which requirements areadded directly to `setup.py` or to have an ambiguous `requirements.txt` file.See the `setup.cfg` file in the reconplogger source code for reference.Default logging configuration-----------------------------A feature that reconplogger provides is the possibility of externally settingthe logging configuration without having to change code or implement any parsingof configuration. However, if a logging configuration is not given externally,reconplogger provides a default configuration.The default configuration defines three handlers, two of which are streamhandlers and are set to DEBUG log level. The first handler called:code:`plain_handler` uses a simple plain text formatter, and the second handlercalled :code:`json_handler` as the name suggests outputs in json format, usingthe `logmatic &lt;https://pypi.org/project/logmatic-python/&gt;`_ JsonFormatter class.The third handler called :code:`null_handler` is useful to disable all logging.For each handler the default configuration defines a corresponding logger::code:`plain_logger`, :code:`json_logger` and :code:`null_logger`.Standardizing logging in regular python---------------------------------------One objective of reconplogger is to ease the use of logging and standardize theway it is done across all omni:us python code. The use of reconplogger comesdown to calling one function to get the logger object. For regular python code(i.e. not a microservice) the function to use is`reconplogger.logger_setup`.The following code snippet illustrates the use:.. code-block:: python    import reconplogger    # Default plain logger    logger = reconplogger.logger_setup()    logger.info('My log message')    # Json logger and custom prefix    logger = reconplogger.logger_setup('json_logger', env_prefix='MYAPP')    logger.info('My log message in json format')This function gives you the ability to set the default logger to use(:code:`logger_name` argument whose default value is :code:`plain_logger`) andoptionally provide a logging :code:`config` and/or a logging :code:`level` thatoverrides the level in the config.All of these values can be overridden via environment variables whose names areprefixed by the value of the :code:`env_prefix` argument. The environmentvariables supported are: :code:`{env_prefix}_CFG`, :code:`{env_prefix}_NAME` and:code:`{env_prefix}_LEVEL`. Note that the environment variable names are notrequired to be prefixed by the default :code:`env_prefix='LOGGER'`. The prefixcan be chosen by the user for each particular application.For functions or classes that receive logger object as an argument, it might bedesired to set a non-logging default so that it can be called without specifyingone. For this reconplogger defines :code:`null logger` that could be used asfollows:.. code-block:: python    from reconplogger import null_logger    ...    def my_func(arg1, arg2, logger=null_logger):    ...Standardizing logging in flask-based microservices--------------------------------------------------The most important objective of reconplogger is to allow standardization of astructured logging format for all microservices developed. Thus, the loggingfrom all microservices should be configured like explained here. The use isanalogous to the previous case, but using the function`reconplogger.flask_app_logger_setup` instead, and giving as first argumentthe flask app object.Additional to the previous case, this function:- Replaces the flask app and werkzeug loggers to use a reconplogger configured one.- Add to the logs the correlation_id- Add before and after request functions to log the request details when the request is processed- Patch the *requests* library forwarding the correlation id in any call to other microservices**What is the correlation ID?**In a system build with microservices we need a way to correlate logs coming from different microservices to the same &quot;external&quot; call.For example when a user of our system do a call to the MicroserviceA this could need to retrieve some information from the MicroserviceB,if there is an error and we want to check the logs of the MicroserviceB related to the user call we don't have a way to correlate them,to solve this we use the correlation id!Its a uuid4 that its passed in the headers of the rest calls and will be forwarded automatically when we do calls with the library *requests*,if the correlation id its not present in the request headers it will be generated, all of this is taken care in the background by this library.The usage would be as follows:.. code-block:: python    import reconplogger    from flask import Flask    ...    app = Flask(__name__)    ...    logger = reconplogger.flask_app_logger_setup(app, level='DEBUG')    ## NOTE: do not change logger beyond this point!    ...    ## Use logger in code    myclass = MyClass(..., logger=logger)    ...    ## User logger in a flask request    @app.route('/')    def hello_world():        logger.info('i like logs')        correlation_id = reconplogger.get_correlation_id()        logger.info('correlation id for this request: '+correlation_id)        return 'Hello, World!'    ...As illustrated in the previous example the `get_correlation_id` functioncan be used to get the correlation id for the current application context.However, there are cases in which it is desired to set the correlation id,instead of getting a randomly generated one. In this case the`get_correlation_id` function is used, for example as follows:.. code-block:: python    @app.route('/')    def hello_world():        reconplogger.set_correlation_id('my_correlation_id')        logger.info('i like logs')        return 'Hello, World!'An important note is that after configuring the logger, the code should notmodify the logger configuration. For example, the logging level should not bemodified. Adding an additional handler to the logger is not a problem. Thiscould be desired for example to additionally log to a file.In the helm `values.yaml` file of the microservice, the default values for theenvironment variables should be set as:.. code-block:: yaml    LOGGER_CFG:    LOGGER_NAME: json_logger    LOGGER_LEVEL: DEBUGWith the :code:`json_logger` logger, the format of the logs should looksomething like the following::    {&quot;asctime&quot;: &quot;2018-09-05 17:38:38,137&quot;, &quot;levelname&quot;: &quot;INFO&quot;, &quot;filename&quot;: &quot;test_formatter.py&quot;, &quot;lineno&quot;: 5, &quot;message&quot;: &quot;Hello world&quot;}    {&quot;asctime&quot;: &quot;2018-09-05 17:38:38,137&quot;, &quot;levelname&quot;: &quot;DEBUG&quot;, &quot;filename&quot;: &quot;test_formatter.py&quot;, &quot;lineno&quot;: 9, &quot;message&quot;: &quot;Hello world&quot;}    {&quot;asctime&quot;: &quot;2018-09-05 17:38:38,137&quot;, &quot;levelname&quot;: &quot;ERROR&quot;, &quot;filename&quot;: &quot;test_formatter.py&quot;, &quot;lineno&quot;: 13, &quot;message&quot;: &quot;Hello world&quot;}    {&quot;asctime&quot;: &quot;2018-09-05 17:38:38,137&quot;, &quot;levelname&quot;: &quot;CRITICAL&quot;, &quot;filename&quot;: &quot;test_formatter.py&quot;, &quot;lineno&quot;: 17, &quot;message&quot;: &quot;Hello world&quot;}    {&quot;asctime&quot;: &quot;2018-09-05 17:38:38,137&quot;, &quot;levelname&quot;: &quot;ERROR&quot;, &quot;filename&quot;: &quot;test_formatter.py&quot;, &quot;lineno&quot;: 25, &quot;message&quot;: &quot;division by zero&quot;}    {&quot;asctime&quot;: &quot;2018-09-05 17:38:38,138&quot;, &quot;levelname&quot;: &quot;ERROR&quot;, &quot;filename&quot;: &quot;test_formatter.py&quot;, &quot;lineno&quot;: 33, &quot;message&quot;: &quot;Exception has occured&quot;, &quot;exc_info&quot;: &quot;Traceback (most recent call last):\n  File \&quot;reconplogger/tests/test_formatter.py\&quot;, line 31, in test_exception_with_trace\n    b = 100 / 0\nZeroDivisionError: division by zero&quot;}    {&quot;asctime&quot;: &quot;2018-09-05 17:38:38,138&quot;, &quot;levelname&quot;: &quot;INFO&quot;, &quot;filename&quot;: &quot;test_formatter.py&quot;, &quot;lineno&quot;: 37, &quot;message&quot;: &quot;Hello world&quot;, &quot;context check&quot;: &quot;check&quot;}    {&quot;asctime&quot;: &quot;2020-09-02 17:20:16,428&quot;, &quot;levelname&quot;: &quot;INFO&quot;, &quot;filename&quot;: &quot;hello.py&quot;, &quot;lineno&quot;: 12, &quot;message&quot;: &quot;i like logs&quot;, &quot;correlation_id&quot;: &quot;3958f378-5d48-4e1c-b83b-3c6d9f95faec&quot;}    {&quot;asctime&quot;: &quot;2020-09-02 17:20:16,428&quot;, &quot;levelname&quot;: &quot;INFO&quot;, &quot;filename&quot;: &quot;reconplogger.py&quot;, &quot;lineno&quot;: 271, &quot;message&quot;: &quot;Request is completed&quot;, &quot;http_endpoint&quot;: &quot;/&quot;, &quot;http_method&quot;: &quot;GET&quot;, &quot;http_response_code&quot;: 200, &quot;http_response_size&quot;: 56, &quot;http_input_payload_size&quot;: null, &quot;http_input_payload_type&quot;: null, &quot;http_response_time&quot;: &quot;0.0002014636993408203&quot;, &quot;correlation_id&quot;: &quot;3958f378-5d48-4e1c-b83b-3c6d9f95faec&quot;}Use of the logger object------------------------The logger objects returned by the setup functions are normal python:code:`logging.Logger` objects, so all the standard logging functionalitiesshould be used. Please refer to the `logging package documentation&lt;https://docs.python.org/3/howto/logging.html&gt;`_ for details.A couple of logging features that should be very commonly used are thefollowing. To add additional structured information to a log, the :code:`extra`argument should be used. A simple example could be::    logger.info('Successfully processed document', extra={'uuid': uuid})When an exception occurs the :code:`exc_info=True` argument should be used, forexample::    try:        ...    except:        logger.critical('Failed to run task', exc_info=True)Adding a file handler---------------------In some circumstances it is desired to add to a logger a file handler so thatthe logging messages are also saved to a file. This normally requires at leastthree lines of code, thus to simplify things reconplogger provides the`reconplogger.add_file_handler` function to do the same with a single lineof code. The use is quite straightforward as::    reconplogger.add_file_handler(logger, '/path/to/log/file.log')Adding a logging property-------------------------When implementing classes it is common to add logging support to it. For this aninheritable class `.RLoggerProperty` is included in reconplogger to add an:code:`rlogger` property to easily set and get the reconplogger logger. Anexample of use is the following:.. code-block:: python    from reconplogger import RLoggerProperty    class MyClass(RLoggerProperty):        def __init__(self, logger):            self.rlogger = logger        def my_method(self):            self.rlogger.error('my_method was called')    MyClass(logger=True).my_method()Overriding logging configuration--------------------------------An important feature of reconplogger is that the logging configuration of appsthat use it can be easily changed via the environment variables. First set theenvironment variables with the desired logging configuration and logger name:.. code-block:: bash    export LOGGER_NAME=&quot;example_logger&quot;    export LOGGER_CFG='{        &quot;version&quot;: 1,        &quot;formatters&quot;: {            &quot;verbose&quot;: {                &quot;format&quot;: &quot;%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s&quot;            }        },        &quot;handlers&quot;: {            &quot;console&quot;:{                &quot;level&quot;:&quot;DEBUG&quot;,                &quot;class&quot;:&quot;logging.StreamHandler&quot;,                &quot;formatter&quot;: &quot;verbose&quot;            }        },        &quot;loggers&quot;: {            &quot;example_logger&quot;: {                &quot;handlers&quot;: [&quot;console&quot;],                &quot;level&quot;: &quot;ERROR&quot;,            }        }    }'Then, in the python code the logger would be used as follows:.. code-block:: python    &gt;&gt;&gt; import reconplogger    &gt;&gt;&gt; logger = reconplogger.logger_setup(env_prefix='LOGGER')    &gt;&gt;&gt; logger.error('My error message')    ERROR 2019-10-18 14:45:22,629 &lt;stdin&gt; 16876 139918773925696 My error messageLow level functions===================Loading configuration---------------------The `reconplogger.load_config` function allows loading of a python loggingconfiguration. The format config can be either json or yaml. The loading ofconfiguration can be from a file (giving its path), from an environment variable(giving the variable name), a raw configuration string, or loading the defaultconfiguration that comes with reconplogger. See below examples of loading foreach of the cases:.. code-block:: python    import reconplogger    ## Load from config file    reconplogger.load_config('/path/to/config.yaml')    ## Load from environment variable    reconplogger.load_config('LOGGER_CFG')    ## Load default config    reconplogger.load_config('reconplogger_default_cfg')Replacing logger handlers-------------------------In some cases it might be needed to replace the handlers of some alreadyexisting logger. For this reconplogger provides the`reconplogger.replace_logger_handlers` function. To use it, simply providethe logger in which to replace the handlers and the logger from where to get thehandlers. The procedure would be as follows:.. code-block:: python    import reconplogger    logger = reconplogger.logger_setup('json_logger')    reconplogger.replace_logger_handlers('some_logger_name', logger)Contributing============Contributions to this package are very welcome. When you plan to work with thesource code, note that this project does not include a `requirements.txt` file.This is by intention. To make it very clear what are the requirements fordifferent use cases, all the requirements of the project are stored in the file`setup.cfg`. The basic runtime requirements are defined in section:code:`[options]` in the :code:`install_requires` entry. All optionalrequirements are stored in section :code:`[options.extras_require]`. There are:code:`test`, :code:`dev` and :code:`doc` extras require to be used bydevelopers (e.g. requirements to run the unit tests) and an :code:`all` extrasrequire for optional runtime requirements, namely Flask support.The recommended way to work with the source code is the following. First clonethe repository, then create a virtual environment, activate it and finallyinstall the development requirements. More precisely the steps would be:.. code-block:: bash    git clone https://github.com/omni-us/reconplogger.git    cd reconplogger    virtualenv -p python3 venv    . venv/bin/activateThe crucial step is installing the requirements which would be done by running:.. code-block:: bash    pip3 install --editable &quot;.[dev]&quot;Running the unit tests can be done either using using `tox&lt;https://tox.readthedocs.io/en/stable/&gt;`__ or the :code:`setup.py` script. Theunit tests are also installed with the package, thus can be used to in aproduction system... code-block:: bash    tox  # Run tests using tox    ./setup.py test_coverage  # Run tests and generate coverage report    python3 -m reconplogger_tests  # Run tests for installed packagePull requests-------------- To contribute it is required to create and push to a new branch and issue a  pull request.- A pull request will only be accepted if:    - All python files pass pylint checks.    - All unit tests run successfully.    - New code has docstrings and gets included in the html documentation.- When developing, after cloning be sure to run the githook-pre-commit to setup  the pre-commit hook. This will help you by automatically running pylint before  every commit.Using bump version------------------Only the maintainer of this repo should bump versions and this should be doneonly on the master branch. To bump the version it is required to use thebumpversion command that should already be installed if :code:`pip3 install--editable .[dev,doc,test,all]` was run as previously instructed... code-block:: bash    bumpversion major/minor/patchPush the tags to the repository as well... code-block:: bash    git push; git push --tagsWhen the version tags are pushed, circleci will automatically build the wheelfile, test it and if successful, push the package to pypi.</longdescription>
</pkgmetadata>