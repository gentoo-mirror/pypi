<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># artifax![Tests](https://github.com/brunolange/artifax/actions/workflows/pythonpackage.yml/badge.svg)![Coverage](https://img.shields.io/codecov/c/github/brunolange/artifax?color=%2334D058)artifax is a Python package to evaluate nodes in a computation graph wherethe dependencies associated with each node are extracted directly from theirfunction signatures. Here's an example of `artifax` in action:```python&gt;&gt;&gt; from artifax import build&gt;&gt;&gt; import math&gt;&gt;&gt; build({...     'x': math.pi/3,...     'sin': lambda x: math.sin(x),...     'cos': lambda x: math.cos(x),...     'y': lambda sin, cos: 2*sin - 1.2*cos... }){'x': 1.0471975511965976, 'sin': 0.8660254037844386, 'cos': 0.5000000000000001, 'y': 1.132050807568877}```Install with pip:```bash$ python3 -m pip install artifax```A computation graph can be entirely encoded in a standard python dictionary.Each key represents a node or an artifact, that will eventually be computedonce all of its dependencies have been calculated. The value associated witheach key can be either a constant - a string, a number or an instance of a class,or a function. In the latter case, the function arguments map to other nodesin the computation graph to establish a direct dependency between the nodes.For example, the following dictionary:```pythonartifacts = {    'A': 42,    'B': 7,    'C': lambda: 10,    'AB': lambda A, B: A*B,    'C-B': lambda B, C: C - B,    'greeting': 'Hello',    'message': lambda greeting, A: '{} World! The answer is {}.'.format(greeting, A)}```yields the following computation graph:![Screenshot](sample-dag.png)&lt;div style=&quot;font-style:italic&quot;&gt;Figure 1. Example of a computation graph.&lt;/div&gt;The `build` function evalutes the entire computation graph and returns a new dictionarywith the same keys as the original one and with the calculated values for each of the nodesin the computation graph.```pythonfrom artifax import buildartifacts = {    'A': 42,    'B': 7,    'C': lambda: 10,    'AB': lambda A, B: A*B,    'C-B': lambda B, C: C - B,    'greeting': 'Hello',    'message': lambda greeting, A: '{} World! The answer is {}.'.format(greeting, A)}result = build(artifacts)for k, v in result.items():    print(f&quot;{k:&lt;10}: {v}&quot;)```outputs```shellA         : 42B         : 7C         : 10AB        : 294C-B       : 3greeting  : Hellomessage   : Hello World! The answer is 42.```# Artifax classThe `build` function represents the core transformation that yields artifacts.It is entirely stateless and has no side-effects. Given the same input graph, it will alwaysevaluate every single node and generate the same results.Whilst these features are highly desirable from any core component, the stateful `Artifax`class can be employed to interface with the build function and provide some additional featuresand performance enhancements.```pythonfrom artifax import Artifax, Atdef double(x):    return x*2afx = Artifax()afx.set('a', 42)afx.set('b', At('a', double))# set also accepts named argumentsafx.set(c=lambda b: -b)assert len(afx) == 3assert 'b' in afxresults = afx.build()for k, v in results.items():    print(k, v)# c -84# a 42# b 84```## Lazy buildsArtifax instances optimize sequential builds by only re-evaluating nodes thathave become stale due to an update. For example, given the graph illustrated inFigure 1, if node `B` is updated, e.g, `afx.set('B', -5))`, nodes `B`, `AB` and`C-B` get re-evaluated when the build method is invoked, but not any othernodes.In the example below, the second call to the `build` method triggers are-evaluation of node `p1` and all the nodes that depend on it. Nodes `v2` and`m2`, on the other hand, do not require re-evaluation since they do not dependon the updated node.```pythonimport artifaximport mathclass Vector:    def __init__(self, u, v):        self.u = u        self.v = v    def magnitude(self):        print('Calculating magnitude of vector {}...'.format(self))        return math.sqrt(self.u**2 + self.v**2)    def __repr__(self):        return '({}, {})'.format(self.u, self.v)afx = artifax.Artifax(    p1=(3, 4),    v1=lambda p1: Vector(*p1),    m1=lambda v1: v1.magnitude(),    v2=Vector(5, 12),    m2=lambda v2: v2.magnitude())_ = afx.build()print('Updating p1...')afx.set(p1=(1, 1))_ = afx.build()``````Calculating magnitude of vector (3, 4)...Calculating magnitude of vector (5, 12)...Updating p1...Calculating magnitude of vector (1, 1)...```## Targeted buildsThe `build` method accepts an optional argument that specifies which node inyour computation graph should be built. Instead of returning the usual dictionary,targeted builds return a tuple containing the value associated with each of thetarget nodes.```pythonterminal_node_value = afx.build(targets='terminal_node')some_node, another_node = afx.build(targets=('node1', 'node2'))```Targeted builds only evaluate dependencies for the target node and the target node itself.Any other nodes in the computation graph do not get evaluated.```pythonfrom artifax import Artifaxafx = Artifax({    'name': 'World',    'punctuation': '?',    'greeting': lambda name, punctuation: 'Hello, {}{}'.format(name, punctuation),})greeting = afx.build(targets='greeting')print(greeting) # prints &quot;Hello, World?&quot;afx.set('punctuation', '!')greeting, punctuation = afx.build(targets=('greeting', 'punctuation'))print(greeting) # prints &quot;Hello, World!&quot;print('Cool beans{}'.format(punctuation)) # prints &quot;Cool beans!&quot;```Targeted builds are an efficient way of retrieving certain nodes withoutevaluating the entire computation graph.# SolversDepending on the use case, different solvers can be employed to increase performance.The `build` function and methods accept an optional `solver` parameter which defaults to`linear`.## The `linear` solverThe linear solver topologically sorts the computation graph to define a sequenceof nodes to be calculated in an order such that for any node, all of its dependencies appearbefore in the sequence.## The `parallel` solverThe `parallel` solver consumes the computation graph starting from the nodes that haveno dependencies and processes them all in parallel. When this initial set of nodes is resolved,their immediate neighbors make up the new frontier which also gets processed in parallel.This procedure continues until there are no more nodes to be calculated. At any step, thesolver spawns one new process for each node at the frontier without exceeding the number ofavailable cores minus 1.## The `async` solverThe `async` solver takes the parallelism of the `parallel` solver one step further. It is triggeredeach time a node evaluation is completed, looking for new nodes that can be started and evaluatingthem in a new process immediately.# Error handlingIf the computation graph represented by the artifacts dictionary is not a DAG(Direct Acyclic Graph), a `CircularDependencyError` exception is thrown.```pythonimport artifaxtry:    _ = artifax.build({'x': lambda x: x+1})except artifax.CircularDependencyError as err:    print('Cannot build artifacts: {}'.format(err))``````Cannot build artifacts: artifact graph is not a DAG```If a particular node is represented by a function for which any of its arguments isn't partof the computation graph, an `UnresolvedDependencyError` exception is thrown.```python_ = artifax.build({    'x': 42,    'p': lambda x, y: x + y}) # raises UnresolvedDependencyError due to missing 'y' node```However, sometimes this behavior might be desirable if we want nodes to resolve to partiallyapplied functions that can be used elsewhere. If that's the case, the exception can be suppressedby setting the `allow_partial_functions` optional parameter to `build` to `True`.```pythonresults = artifax.build({    'x': 42,    'p': lambda x, y: x + y}, allow_partial_functions=True)print(results['p'](100)) # prints 142```</longdescription>
</pkgmetadata>