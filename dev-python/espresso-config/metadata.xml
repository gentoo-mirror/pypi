<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Espresso ConfigA struct config parser that you can set up in the time ittakes to make an espresso. To install, run```bashpip install espresso-config```Python 3.8 or newer is required.## Why Espresso Config?There are a million of parsers that can turn a YAML configuration / CLI flags into a configuration file, *e.g.*, [Hydra](https://hydra.cc), [ML Collections](https://github.com/google/ml_collections), so why another one? Espresso Config was designed to meet the following requirements:1. Support structured configs (*i.e.*, define configurations with classes)2. Allow nested classes in configuration3. Functions## Motivating ExampleImagine you want to run the following experiment:```yamlbackbone: t5-largemodel:  metrics:    rouge:      _target_: torchmetrics.functional.text.rouge.rouge_score  tokenizer:    _target_: transformers.AutoTokenizer.from_pretrained    pretrained_model_name_or_path: t5-large  transformer:    _target_: transformers.AutoModelForSeq2SeqLM.from_pretrained    max_sequence_length: 64    pretrained_model_name_or_path: t5-large```Sure, you could parse that yaml file and get a `dict`.But (a) working with dictionaries is tedious (b) there's notyping, and (c) you don't want to have to declare all blockseach time; it would be good if you could save some commonly usedconfigurations, such as the parameters for one of `transformer`or `tokenizer` keys.Espresso Config allows you to solve all off those problemsby specifying a struct class as follows:```pythonfrom espresso_config import (    ConfigNode,    ConfigRegistry,    ConfigParam,    ConfigFlexNode)@ConfigRegistry.addclass seq2seq(ConfigNode):    _target_: ConfigParam(str) = 'transformers.AutoModelForSeq2SeqLM.from_pretrained'@ConfigRegistry.addclass tok(ConfigNode):    _target_: ConfigParam(str) = 'transformers.AutoTokenizer.from_pretrained'@ConfigRegistry.addclass rouge(ConfigNode):    _target_: ConfigParam(str) = 'torchmetrics.functional.text.rouge.rouge_score'class ApplicationConfig(ConfigNode):    backbone: ConfigParam(str)    class model(ConfigNode):        class transformer(ConfigNode):            _target_: ConfigParam(str)            pretrained_model_name_or_path: ConfigParam(str) = '${backbone}'            max_sequence_length: ConfigParam(int) = 64        class tokenizer(ConfigNode):            _target_: ConfigParam(str)            pretrained_model_name_or_path: ConfigParam(str) = '${backbone}'        metrics: ConfigParam(ConfigFlexNode) = {}```Then, your YAML configuration can be as simple as:```yamlbackbone: t5-largemodel:  transformer@seq2seq: {}  tokenizer@tok: {}  metrics:    rouge@rouge: {}```Voila! To load the config, run:```pythonfrom espresso_config import config_from_fileconfig = config_from_file(ApplicationConfig, path_to_yaml)```## Placeholder VariableA placeholder variable is a config value that references anothersection of the config, e.g. another value or section.It uses syntax `${path.to.key}`.## Registry ReferenceA registry reference is a reference to a node config that has beenadded to the config registry. It uses syntax `@placeholder_name`.</longdescription>
</pkgmetadata>