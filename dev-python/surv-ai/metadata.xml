<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># üïµ Multi-agent modeling with large language models &lt;!-- [![PyPi](https://img.shields.io/badge/Official%20Website-agpt.co-blue?style=flat&amp;logo=world&amp;logoColor=white)](https://agpt.co) --&gt;[![PyPi](https://shields.io/pypi/v/surv-ai)](https://pypi.org/project/surv-ai/)[![PyPi](https://shields.io/pypi/pyversions/surv-ai)](https://pypi.org/project/surv-ai/)[![Unit Tests](https://shields.io/github/actions/workflow/status/DanielBalsam/surv_ai/.github/workflows/ci.yaml?branch=main)](https://github.com/DanielBalsam/surv_ai/actions/workflows/ci.yaml)[![GitHub Repo stars](https://img.shields.io/github/stars/DanielBalsam/surv_ai?style=social)](https://github.com/DanielBalsam/surv_ai/stargazers)**`surv_ai` is a large language model framework designed for multi-agent modeling. This allows large-language models to be used as engines to power research into predictive modeling, bias analysis, and other forms of comparative analysis.**![](https://raw.githubusercontent.com/DanielBalsam/surv_ai/main/examples/midterms_2022.png)**Multi-agent modeling** involves generating statistical models based on the actions of multiple agents. In our case, these models are crafted by agents querying and processing text from a comprehensive data corpus. The agents then reason with the information extracted to produce a data point.Given the stochastic nature of large language models, individual data points may vary. However, if a sufficient number of agents are employed, the generated models can effectively support comparative analysis.They key idea here was inspired by the [technique of bagging (bootstrap aggregating) in classical ensemble classifiers.](https://en.wikipedia.org/wiki/Bootstrap_aggregating) The basic idea is that if you have a lot of weak learners with only limited information - in aggregate those weak learners can produce much higher quality results than a single weak learner with maximum information (or a bunch a weak learners with maximum information).This technique appears to work better when each agent has access to a limited subset of the total information even when using language models with larger context windows.The abstraction in this repository capable of producing a multi-agent data point is known as a `Survey`. A `Survey` takes a statement as input and returns the percentage of agents that agreed with it.A more complex abstraction, called a `Model`, enables the variation of input parameters into a `Survey` to create a nuanced multi-agent model.The data points produced serve as sentiment analysis against a text corpus, making them susceptible to the biases of both the large language models and the corpus itself. However, if the data source provided is quality - then the model produced can be high quality as well.As advances in large language models and AI continue, multi-agent modeling may remain a valuable framework for classification and regression models. It also has the potential to become a useful data point for researchers investigating complex issues with numerous underlying variables.## üì≤ Installation Package is available on [PyPi](https://pypi.org/project/surv-ai/): ```pip install surv-ai```## üìª Contact For all inquiries, contact me at: daniel.balsam@survai.org## ‚úÖ Responsible use The examples provided below are intended merely to illustrate potential applications of this framework; they are not to be considered scientifically rigorous.Approaches like this have potential in guiding research and decision-making. However, it is crucial to rely on a diverse range of data points and to interpret each model cautiously.I am always open to suggestions for further enhancing this approach.## üìù Basic usage The two key abstractions in this repository are a `Survey` and a `Model`. Executing the method `Survey.conduct` with a hypothesis will spin up a number of agents and seed them with some base knowledge. The agents are then asked to to assign a true or false value to the hypothesis provided. ```class Survey:    def __init__(        self,        client: LargeLanguageModelClientInterface,        tool_belt: ToolBeltInterface,        n_agents=10,        max_concurrency=10,        max_knowledge_per_agent=3,    ):        ...    async def conduct(self, hypothesis: str) -&gt; SurveyResponse:        ...```A `Model` is an abstraction that allows one to conduct many surveys while changing some independent variable.For example: one could could change the publish date of news articles that should be considered in the survey. ```class Model:    def __init__(        self,        survey_class: type[SurveyInterface],        parameters: list[SurveyParameter],        max_concurrency: int = 1,    ):        ...    async def build(self, hypothesis: str) -&gt; list[DataPoint]:        ...```All abstractions implemented in this repository adhere to simple abstract interfaces - so you can easily build your own agents, surveys, and models.## üéì Examples All the below examples will be conducted with either GPT or Claude, and Google Custom Search. Links to relevant docs to get your own API keys:[**OpenAI Docs**](https://platform.openai.com/) / [**Anthropic Docs**](https://console.anthropic.com/docs) / [**Google Custom Search Docs**](https://developers.google.com/custom-search/v1/overview)### Comparing against a ground truthLet's start by establishing the system's ability to figure out if information is true.```from surv_ai import (    GPTClient,    Survey,    ToolBelt,    GoogleCustomSearchTool,    Knowledge)client = GPTClient(os.environ[&quot;OPEN_AI_API_KEY&quot;])tool_belt = ToolBelt(    tools=[        GoogleCustomSearchTool(            google_api_key=os.environ[&quot;GOOGLE_API_KEY&quot;],            google_search_engine_id=os.environ[&quot;GOOGLE_SEARCH_ENGINE_ID&quot;],            start_date=&quot;2023-01-01&quot;,            end_date=&quot;2023-05-01&quot;,            n_pages=10,        )    ])base_knowledge = [    Knowledge(        text=&quot;It is currently 2023/05/01, all the articles are from 2023.&quot;,        source=&quot;Additional context&quot;,    ),]survey = Survey(    client=client,    tool_belt=tool_belt,    base_knowledge=base_knowledge,    max_knowledge_per_agent=3,    n_agents=10,)await survey.conduct(    &quot;California experienced a significant amount of rainfall this winter.&quot;,)  # This should always returns high a confidence agreement.```Executing this code should yield an output similar to: `SurveyResponse(in_favor=10, against=0, undecided=0, error=0, percent_in_favor=1.0, uncertainty=0.0)`It's important to recognize that occasionally, one or two agents might incorrectly respond to a straightforward question like this. That's why we employ multiple agents in these systems - to counteract the randomness inherent in Large Language Models (LLMs).To further test our hypothesis, we could also assert the contrary position and ensure we obtain the opposite value.```from surv_ai import (    GPTClient,    Survey,    ToolBelt,    GoogleCustomSearchTool,    Knowledge)client = GPTClient(os.environ[&quot;OPEN_AI_API_KEY&quot;])tool_belt = ToolBelt(    tools=[        GoogleCustomSearchTool(            google_api_key=os.environ[&quot;GOOGLE_API_KEY&quot;],            google_search_engine_id=os.environ[&quot;GOOGLE_SEARCH_ENGINE_ID&quot;],            start_date=&quot;2023-01-01&quot;,            end_date=&quot;2023-05-01&quot;,            n_pages=10,        )    ])base_knowledge = [    Knowledge(        text=&quot;It is currently 2023/05/01, all the articles are from 2023.&quot;,        source=&quot;Additional context&quot;,    ),]survey = Survey(    client=client,    tool_belt=tool_belt,    base_knowledge=base_knowledge,    max_knowledge_per_agent=3,    n_agents=10,)await survey.conduct(    &quot;California experienced little rainfall this winter.&quot;,)  # This should always returns a high confidence disagreement.```Executing this code should result in an output similar to: `SurveyResponse(in_favor=0, against=10, undecided=0, error=0, percent_in_favor=0.0, uncertainty=0.0)`### Comparing changes in sentiment over timeOne thing we can use this tool for is measuring changes in sentiment overtime. GPT's training data ends in late 2021, so one way we can test our models with GPT is by looking at events that happened after GPT's training cutoff.For instance, we can plot how sentiment regarding the United States' 2022 Midterm Elections evolved in the months leading up to it:```from surv_ai import (    GPTClient,    Model,    ToolBelt,    GoogleCustomSearchTool,    Knowledge,    Survey,    SurveyParameter)client = GPTClient(os.environ[&quot;OPEN_AI_API_KEY&quot;])def build_parameter(date_range: tuple[str, str]):    tool_belt = ToolBelt(        tools=[            GoogleCustomSearchTool(                google_api_key=os.environ[&quot;GOOGLE_API_KEY&quot;],                google_search_engine_id=os.environ[&quot;GOOGLE_SEARCH_ENGINE_ID&quot;],                n_pages=30,                start_date=date_range[0],                end_date=date_range[1],                max_concurrency=20,            ),        ],    )    base_knowledge = [        Knowledge(            text=f&quot;It is currently {date_range[0]}. The included articles were published between {date_range[0]} and {date_range[1]}&quot;,            source=&quot;Additional context&quot;,        ),    ]    return SurveyParameter(        independent_variable=date_range[1],        kwargs={            &quot;client&quot;: client,            &quot;n_agents&quot;: 100,            &quot;max_knowledge_per_agent&quot;:5,            &quot;max_concurrency&quot;: 20,            &quot;tool_belt&quot;: tool_belt,            &quot;base_knowledge&quot;: base_knowledge,        },    )date_ranges = [    ('2022-05-01', '2022-06-01'),    ('2022-06-01', '2022-07-01'),    ('2022-07-01', '2022-08-01'),    ('2022-08-01', '2022-09-01'),    ('2022-09-01', '2022-10-01'),    ('2022-10-01', '2022-11-05'),]model = Model(    Survey,    parameters=[build_parameter(date_range) for date_range in date_ranges],)democrat_results = await model.build(    &quot;Democrats are favored to maintain control of the Senate in the 2022 November Midterm elections.&quot;,)```We can also plot the inverted statement and observe opposite trend lines:```republican_results = await model.build(    &quot;Republicans are favored to maintain control of the Senate in the 2022 November Midterm elections.&quot;,)```When compared with a leading model in political opinion polling, our model is presented as follows:![](https://raw.githubusercontent.com/DanielBalsam/surv_ai/main/examples/midterms_2022.png)*In this example, the agents crawled websites such as nytimes.com, wsj.com, abcnews.com, cnn.com, bloomberg.com, foxnews.com, economist.com, washingtonpost.com, and nbcnews.com. [FiveThirtyEight data can be found here.](https://projects.fivethirtyeight.com/2022-election-forecast/senate/)*Pretty cool! Note that the outputs don't represent complementary probabilities due to nuances in how the models reason, and biases of the models and data sources, but we can observe trend lines that do mirror each other quite well.Another example could involve plotting sentiments about the economy and using fluctuations in the S&amp;P 500 as a benchmark for accuracy.```from surv_ai import (    GPTClient,    Model,    ToolBelt,    GoogleCustomSearchTool,    Knowledge,    Survey,    SurveyParameter)client = GPTClient(os.environ[&quot;OPEN_AI_API_KEY&quot;])def build_parameter(date_range: tuple[str, str]):    tool_belt = ToolBelt(        tools=[            GoogleCustomSearchTool(                google_api_key=os.environ[&quot;GOOGLE_API_KEY&quot;],                google_search_engine_id=os.environ[&quot;GOOGLE_SEARCH_ENGINE_ID&quot;],                n_pages=20,                start_date=date_range[0],                end_date=date_range[1]            ),        ],    )    base_knowledge = [        Knowledge(            text=f&quot;It is currently {date_range[0]}. The included articles were published between {date_range[0]} and {date_range[1]}&quot;,            source=&quot;Additional context&quot;,        ),    ]    return SurveyParameter(        independent_variable=date_range[1],        kwargs={            &quot;client&quot;: client,            &quot;n_agents&quot;: 100,            &quot;max_knowledge_per_agent&quot;:5,            &quot;max_concurrency&quot;: 10,            &quot;tool_belt&quot;: tool_belt,            &quot;base_knowledge&quot;: base_knowledge,        },    )date_ranges = [    ('2021-09-01', '2022-01-01'),    ('2022-01-01', '2022-03-01'),    ('2022-03-01', '2022-06-01'),    ('2022-06-01', '2022-09-01'),    ('2022-09-01', '2023-01-01'),    ('2023-01-01', '2023-03-01'),    ('2023-03-01', '2023-06-01'),]model = Model(    Survey,    parameters=[build_parameter(date_range) for date_range in date_ranges],)results = await model.build(    &quot;The United States economy looks like it is heading for a recession.&quot;,)```This gives us the following graph:![](https://raw.githubusercontent.com/DanielBalsam/surv_ai/main/examples/S&amp;P.png)*In this example, the agents crawled websites such as nytimes.com, wsj.com, abcnews.com, cnn.com, bloomberg.com, foxnews.com, economist.com, washingtonpost.com, and nbcnews.com. Please note that it is the complement of multi-agent model that is plotted. [S&amp;P data can be found here.](https://www.google.com/finance/quote/.INX:INDEXSP?sa=X&amp;ved=2ahUKEwi2hJWyg6D_AhXiGFkFHdqHCIYQ3ecFegQIIRAf)*### Measuring bias in a data corpusA promising application of this technique is observing bias within a text corpus. For instance, we could create a model that uses different news sites as its independent variable to explore how the agents' conclusions might vary based on the data source utilized.```from surv_ai import (    GPTClient,    Model,    ToolBelt,    GoogleCustomSearchTool,    Knowledge,    Survey,    SurveyParameter)client = GPTClient(os.environ[&quot;OPEN_AI_API_KEY&quot;])def build_parameter(news_source: str):    tool_belt = ToolBelt(        tools=[            GoogleCustomSearchTool(                google_api_key=os.environ[&quot;GOOGLE_API_KEY&quot;],                google_search_engine_id=os.environ[&quot;GOOGLE_SEARCH_ENGINE_ID&quot;],                n_pages=20,                start_date=&quot;2023-05-01&quot;,                end_date=&quot;2023-06-01&quot;,                only_include_sources=[news_source]            ),        ],    )    base_knowledge = [        Knowledge(            text=f&quot;It is currently 2023-06-01. The included articles were published between 2023-05-01 and 2023-06-01&quot;,            source=&quot;Additional context&quot;,        ),    ]    return SurveyParameter(        independent_variable=news_source,        kwargs={            &quot;client&quot;: client,            &quot;n_agents&quot;: 100,            &quot;max_knowledge_per_agent&quot;:10,            &quot;max_concurrency&quot;: 10,            &quot;tool_belt&quot;: tool_belt,            &quot;base_knowledge&quot;: base_knowledge,        },    )news_sources = [    &quot;nytimes.com&quot;,    &quot;cnn.com&quot;,    &quot;wsj.com&quot;,    &quot;foxnews.com&quot;,]model = Model(    Survey,    parameters=[build_parameter(news_source) for news_source in news_sources],)results = await model.build(    &quot;Republicans are responsible for the impending debt ceiling crisis.&quot;)```This provides us with a scatter plot representing the above-mentioned news sources:![](https://raw.githubusercontent.com/DanielBalsam/surv_ai/main/examples/debt_ceiling.png)*In this example, for each news site the agents looked only at articles published in May of 2023. Omitted publications did not have enough articles on the topic published to get reliable results.*### Measuring biases in different large language modelsAnother promising method for measuring bias involves comparing biases across various large language models, provided they all receive identical input parameters.```from surv_ai import (    GPTClient,    AnthropicClient,    Model,    ToolBelt,    GoogleCustomSearchTool,    Knowledge,    Survey,    SurveyParameter,    LargeLanguageModelClientInterface)clients = [AnthropicClient(os.environ[&quot;ANTHROPIC_API_KEY&quot;]), GPTClient(os.environ[&quot;OPEN_AI_API_KEY&quot;])]def build_parameter(client: LargeLanguageModelClientInterface):    tool_belt = ToolBelt(        tools=[            GoogleCustomSearchTool(                google_api_key=os.environ[&quot;GOOGLE_API_KEY&quot;],                google_search_engine_id=os.environ[&quot;GOOGLE_SEARCH_ENGINE_ID&quot;],                n_pages=20,                start_date=&quot;2023-01-01&quot;,                end_date=&quot;2024-05-01&quot;,                max_concurrency=3,            )        ],    )    base_knowledge = [        Knowledge(            text=f&quot;It is currently 2023-06-01. The included articles were published between 2023-01-01 and 2023-06-01&quot;,            source=&quot;Additional context&quot;,        ),    ]    return SurveyParameter(        independent_variable=client.__class__.__name__,        kwargs={            &quot;client&quot;: client,            &quot;n_agents&quot;: 100,            &quot;max_knowledge_per_agent&quot;:3,            &quot;max_concurrency&quot;: 3,            &quot;tool_belt&quot;: tool_belt,            &quot;base_knowledge&quot;: base_knowledge,        },    )model = Model(    Survey,    parameters=[build_parameter(client) for client in clients],)results = await model.build(    &quot;OpenAI has been irresponsible in their handling of AI technology.&quot;)```When we compare the results between Anthropic and OpenAI's models, the scatter plot appears as follows:![](https://raw.githubusercontent.com/DanielBalsam/surv_ai/main/examples/openai.png)*In this example, the agents crawled websites such as nytimes.com, wsj.com, abcnews.com, cnn.com, bloomberg.com, foxnews.com, economist.com, washingtonpost.com, and nbcnews.com for articles published in the first half of 2023.*### Measuring sentiment on TwitterIn addition to querying news sources we can also query social media websites for sentiment. There are many uses for this, but one simple and fun one would be to try and see if we can predict who will win the Academy Award for best picture.```from surv_ai import (    GPTClient,    ToolBelt,    TwitterTool,    Knowledge,    Survey,)client = GPTClient(os.environ[&quot;OPEN_AI_API_KEY&quot;])films = [    &quot;Everything Everywhere All At Once&quot;,    &quot;All Quiet On the Western Front&quot;,    &quot;The Banshees of Inisherin&quot;,    &quot;The Fablemans&quot;,    &quot;T√°r&quot;,    &quot;Top Gun: Maverick&quot;,    &quot;Triangle of Sadness&quot;,    &quot;Women Talking&quot;,]survey = Survey(    client,    n_agents=200,    tool_belt=ToolBelt(        tools=[            TwitterTool(                start_date=&quot;2023-01-01&quot;,                end_date=&quot;2023-03-11&quot;,                n_tweets=1000,            )        ]    ),    max_knowledge_per_agent=10,    base_knowledge=[        Knowledge(text=&quot;It is currently March 11th, 2023 and the Oscar's are tomorrow.&quot;, source=&quot;Additional context&quot;)    ])results = {}for film in films:    results[film] = await survey.conduct(f&quot;{film} is likely to win the Academy Award for Best Picture.&quot;)```Placing our results on a scatter plot, we get the correct result!![](https://raw.githubusercontent.com/DanielBalsam/surv_ai/main/examples/best_picture.png)*In this example, the agents were allowed to read Tweets up between January 1st 2023, and March 11th 2023 (the day before the Oscar's).*Sentiment on Twitter will not always be perfectly predictive of who will win an Academy Award, but it is an interesting way to try and predict outcomes.## üß† Tips Ultimately, a `Survey` is powered by a Large Language Model (LLM), which means that the survey hypothesis might require tuning, much like the general need to tune prompts. Here are some insights on crafting hypotheses.In these systems, any ambiguity in the original hypothesis can lead to unexpected results. This often happens because the agents interpret the statement too literally, thus rejecting the precise phrasing of the statement.Another useful tactic involves seeding base knowledge to the agents, which provides extra context to the problem. To revisit a previous example:```from surv_ai import (    GPTClient,    Survey,    ToolBelt,    GoogleCustomSearchTool,    Knowledge)client = GPTClient(os.environ[&quot;OPEN_AI_API_KEY&quot;])tool_belt = ToolBelt(    tools=[        GoogleCustomSearchTool(            google_api_key=os.environ[&quot;GOOGLE_API_KEY&quot;],            google_search_engine_id=os.environ[&quot;GOOGLE_SEARCH_ENGINE_ID&quot;],            start_date=&quot;2023-01-01&quot;,            end_date=&quot;2023-05-01&quot;,            n_pages=10,        )    ])base_knowledge = [    Knowledge(        text=&quot;It is currently 2023/05/01, all the articles are from 2023.&quot;,        source=&quot;Additional context&quot;,    ),]survey = Survey(    client=client,    tool_belt=tool_belt,    base_knowledge=base_knowledge,    max_knowledge_per_agent=3,    n_agents=10,)await survey.conduct(    &quot;California experienced a significant amount of rainfall this winter.&quot;,)  # This should always returns high a confidence agreement.```The base knowledge assists in keeping the agents on track. As GPT's training data concludes in 2021, without an additional prompt, GPT might assume it's still 2021, which would prevent it from evaluating the statement's validity accurately.A bit of trial and error is often necessary, but you can debug more efficiently by reading the output of the agents. This is made possible by setting the log level:```from lib.log import logger, AgentLogLevellogger.set_log_level(AgentLogLevel.OUTPUT)  # Output from the agents will be loggedlogger.set_log_level(AgentLogLevel.INTERNAL)  # Agent internal &quot;thoughts&quot; will be logged```You may also prompt agents directly:```from surv_ai import (    GPTClient,    ReasoningAgent,    Knowledge)client = GPTClient(os.environ[&quot;OPEN_AI_API_KEY&quot;])agent = ReasoningAgent(client)agent.teach_text(&quot;You can provide text information to an agent using `teach_text`.&quot;, &quot;Context&quot;)agent.teach_knowledge(    Knowledge(        text=&quot;You can similarly pass a knowledge object directly using `teach_knowledge`&quot;,        source=&quot;Context&quot;    ))agent.prompt(&quot;There are multiple ways to teach an agent knowledge.&quot;)```If you are noticing a large number of errors, you may be hitting rate limits in your LLM API - you can get around this by adjusting the `max_concurrency` parameter in both your tools and `Survey`.## ü§© Inspiration This project was inspired by numerous innovative projects and recent papers. Some of the inspirations for this project include:1. [Generative Agents: Interactive Simulacra of Human Behavior](https://arxiv.org/abs/2304.03442).2. [Large Language Models are Zero-Shot Reasoners](https://arxiv.org/abs/2205.11916)3. [AutoGPT](https://github.com/Significant-Gravitas/Auto-GPT)Additionally, thanks go to the multitude of researchers and engineers out there who are contributing to unlocking the power of these models!## üìà Next steps A few directions I plan to explore with this project include:1. Use the AmbiFC fact-checking data set to benchmark the approach of this framework and compare all future changes against this benchmark: https://paperswithcode.com/paper/evidence-based-verification-for-real-world2. More documentation and use guides!3. Kicking off a development blog.4. More integrations with various helpful tools.5. More examples and use cases.6. Experimentation to further optimize performance.## ü§ù Contribute If you'd like to contribute then please reach out!</longdescription>
</pkgmetadata>