<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![PyPI](https://img.shields.io/pypi/v/autolv)# autolv - Interact with LabVIEW VIs from PythonThe only export from autolv is App that opens an ActiveX connection toLabVIEW through its VI Server. With a reference to LabVIEW it is then possibleto open an ActiveX connection to a specific VI. The primary use case for thislibrary is to set control values on the VI front panel from Python, run the VI,and read the control values back into Python.Installation------------pip install autolvExample usage-------------Suppose the VI name is 'test.vi' and has a single Numeric control with the name (label)'input' and a single Numeric indicator with the name 'output'. The VI implements2*'input' -&gt; 'output'```python&gt;&gt;&gt; import autolv&gt;&gt;&gt; lv = autolv.App()&gt;&gt;&gt; vi = lv.open('test.vi')&gt;&gt;&gt; vi.input = 2.0&gt;&gt;&gt; vi.run()&gt;&gt;&gt; vi.output4.0```Now move the 'input and 'output' Numeric controls into a Cluster called 'data'.![test.vi](./doc/_static/testvi.png)```python&gt;&gt;&gt; vi = lv.open('test.vi')&gt;&gt;&gt; vi.data.input = 3.0&gt;&gt;&gt; vi.run()&gt;&gt;&gt; vi.data.output6.0```It's possible to get an error code explanation. Suppose a VI attempts to createan invalid DAQmx channel.![error.vi](./doc/_static/errorvi.png)```python&gt;&gt;&gt; vi = lv.open('error.vi')&gt;&gt;&gt; vi.DAQmx = &quot;PXI1Slot2&quot;&gt;&gt;&gt; vi.run()&gt;&gt;&gt; vi['error out'].code.value-201237&gt;&gt;&gt; lv.explain_error(_)'Physical channel name specified is invalid...'```In Jupyter, run the VI in the following way:```pythonIn [1]: import autolvIn [2]: lv = autolv.App()In [3]: vi = lv.open('test.vt')In [4]: vi.input = 2.0In [5]: await vi.run()In [6]: vi.outputOut[6]: 4.0```As a context manager:```python&gt;&gt;&gt; with autolv.App() as lv:    vi = lv.open(&lt;file&gt;)    ...&gt;&gt;&gt;```LabVIEW will close upon exiting the context if it was not running prior toentering the context.VI() and VI.run()-----------------It is possible to call the VI object directly instead of using VI.run(). Reusing the'test.vi' from above where `output`= 2 * `input` and these controls have been wiredto the connector pane:```python&gt;&gt;&gt; import autolv&gt;&gt;&gt; lv = autolv.App()&gt;&gt;&gt; vi = lv.open('test.vi')&gt;&gt;&gt; vi(input=2.0, output=0.0)&gt;&gt;&gt; vi.output4.0```There are two key differences between VI() and VI.run():- VI() is blocking where as VI.run() is an asyncio task and supports a timeout.- VI() supports reentrant calls where as VI.run() is equivalent to Operate-&gt;Run and    does not support reentrant calls.Specify a cluster as a dictionary. Suppose 'test.vi' has a cluster `data_in` withone numeric control `input` and a cluster `data_out` with one numeric indicator `output`and `output` = 2 * `input`:![test.vi](./doc/_static/testvi_clusters.png)```python&gt;&gt;&gt; vi = lv.open('test.vi')&gt;&gt;&gt; vi(data_in={&quot;input&quot;: 3}, data_out={})&gt;&gt;&gt; vi.data.output6.0```Control labels--------------It is recommended to label controls as a valid Python identifier which improvesproductivity when using dot-access in an interactive session. But, LabVIEW controlsoften are given names that are invalid Python identifiers. It is possible to workwith these. Suppose a numeric control is labeled `x in` and the indicator `y out`:```python&gt;&gt;&gt; import autolv&gt;&gt;&gt; lv = autolv.App()&gt;&gt;&gt; vi = lv.open('test.vi')&gt;&gt;&gt; vi(**{&quot;x in&quot;: 3, &quot;y out&quot;: 0})&gt;&gt;&gt; vi[&quot;y out&quot;]4.0```Waveform Graph--------------The Waveform Graph control can be a 1d array of y-axis values, 2d array of x-axis andy-axis values, or a cluster (t0, dt, Y) where t0 and dt are scalers and Y is they-axis values.## As 1d array![graph_1d.vi](./doc/_static/graph_1d.png)```python&gt;&gt;&gt; vi = lv.open(&quot;graph_1d.vi&quot;)&gt;&gt;&gt; vi.run()&gt;&gt;&gt; vi.graph.valuearray([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])```## As 2d array![graph_2d.vi](./doc/_static/graph_2d.png)```python&gt;&gt;&gt; vi = lv.open(&quot;graph_1d.vi&quot;)&gt;&gt;&gt; vi.run()&gt;&gt;&gt; vi.graph.valuearray([[0., 1., 2., 3., 4., 5., 6., 7., 8., 9.],       [0., 1., 2., 3., 4., 5., 6., 7., 8., 9.]])```## As cluster![graph_cluster.vi](./doc/_static/graph_cluster.png)```python&gt;&gt;&gt; vi = lv.open(&quot;graph_cluster.vi&quot;)&gt;&gt;&gt; vi.run()&gt;&gt;&gt; vi.graph.value[0.0, 1.0, (0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0)]&gt;&gt;&gt; vi.graph.t00.0&gt;&gt;&gt; vi.graph.dt1.0&gt;&gt;&gt; vi.graph.Yarray([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])```## Tab control![tab control.vi](./doc/_static/tabctrl.png)```python&gt;&gt;&gt; vi = lv.open(&quot;tab control.vi&quot;)&gt;&gt;&gt; vi.tabcontrol.page1.cluster.b0.0```## Project```python&gt;&gt;&gt; project = lv.open('&lt;file&gt;.lvproj')&gt;&gt;&gt; vi = project.open('&lt;file&gt;.vi')```## Reordering cluster controlsClusters in the Silver visual style need to be reordered after opening the VI.![silver error cluster.vi](./doc/_static/silver_errclstr.png)```python&gt;&gt;&gt; vi = lv.open(&quot;silver error cluster.vi&quot;)&gt;&gt;&gt; vi[&quot;error in&quot;]Cluster({'code': True, 'source': , 'status': False})&gt;&gt;&gt; cluster = vi[&quot;error in&quot;]&gt;&gt;&gt; cluster.reorder_controls([&quot;status&quot;, &quot;code&quot;, &quot;source&quot;])&gt;&gt;&gt; vi.read_controls()&gt;&gt;&gt; vi[&quot;error in&quot;]Cluster({'status': True, 'code': 1, 'source': abc})```Notes------ LV Controls have a Label attribute. ActiveX calls this Label 'name' and this isthe only mechanism for set/get a Control. So, the Label must be unique amongthe front panel controls.- As a best practice, it is recommended to set the Label to a valid Python identifier.This increases productivity when using dot-access in an interactive session such asIPython.- If your machine has multiple LabVIEW versions, launch the desired version firstbefore interacting with it in Python.- LV's 'Time Stamp' comes across ActiveX as naive and represented in Pythonas datetime.datetime.- LabVIEW's FXP and Waveform data types are not supported- Array's of clusters can be read but not set</longdescription>
</pkgmetadata>