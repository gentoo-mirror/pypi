<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># adjudicator&gt; __Adjudicator__ _(nount_): An adjudicator is a person or body that makes formal judgments on a disputed matter. They&gt; are the ones who settle disputes or decide who is right in a disagreement. This could be a judge in a courtroom, an&gt; arbitrator in a negotiation, or any person or system given the power to make decisions of this type.Adjudicator is a framework for implementing type-based rule engines largely inspired by the Pants build system. Therule graph consists of nodes which are concrete Python types and edges which are functions that take a set of inputtypes and produce an output type.Rules are matched on a set of facts, which populate the possible input types of a rule. Deriving a type may requirechained execution of rules, which is supported. Global facts may be used to populate a potential input type for allrule executions.The Adjudicator rule engine is designed to be used in a request-response fashion. A request is a set of facts thatshould be used to derive a type. A response is the derived type. The rule engine will execute the rules necessary toderive the type and return the response. If a rule was already executed with the same inputs, it will not be executedagain. For optimal use of the caching mechanism, all types participating in the rule evaluation should be immutableand implement a stable hash (e.g. using `@dataclass(frozen=True)` and `tuple` instead of `list`, etc.).When a mutable type should intentionally participate in the rule evaluation, usually this works automatically becausethe hash of a Python object that does not provide a custom `__hash__()` implementation or disables its hashing is basedon the object's identity. This means that the hash is stable for the memory allocation of the object, and will notchange if the object is mutated. For types that do not _support_ hashing, support can be enabled explicitly using the`RuleEngine.hashsupport` object.__Table of Contents__&lt;!-- toc --&gt;* [Quickstart](#quickstart)* [Installation](#installation)* [Future Extensions](#future-extensions)&lt;!-- end toc --&gt;## QuickstartThe following example shows how to use Adjudicator to implement a simple &quot;Hello World&quot; application. The rule engineinvokes the `say_hello()` production rule because a `HelloResponse` is requested and a `HelloRequest` is provided,which matches the rule's signature.&lt;!-- include code:python examples/hello.py --&gt;```pythonfrom dataclasses import dataclassfrom adjudicator import Params, RuleEngine, rule@dataclass(frozen=True)class HelloRequest:    name: str@dataclass(frozen=True)class HelloResponse:    greeting: str@rule()def say_hello(request: HelloRequest) -&gt; HelloResponse:    return HelloResponse(greeting=f&quot;Hello {request.name}!&quot;)engine = RuleEngine()engine.load_module(__name__)response = engine.get(HelloResponse, Params(HelloRequest(name=&quot;World&quot;)))print(response.greeting)```&lt;!-- end include --&gt;A more complex example can be found in the [mksync](https://github.com/NiklasRosenstein/mksync) project.## InstallationAdjudicator is available on PyPI. You need at least Python 3.10.```bashpip install python-adjudicator```## Future Extensions* Currently the rule graph stores rules as connections between types and rules on edges. A more efficient  representation would be the one illustrated above, where types are connected to rules which are connected to types.* The ability to mark facts as required to be consumed. If such a fact is not consumed during the execution of a  request, an error will be raised.</longdescription>
</pkgmetadata>