<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># sql-metadata[![PyPI](https://img.shields.io/pypi/v/sql_metadata.svg)](https://pypi.python.org/pypi/sql_metadata)[![Tests](https://github.com/macbre/sql-metadata/actions/workflows/python-ci.yml/badge.svg)](https://github.com/macbre/sql-metadata/actions/workflows/python-ci.yml)[![Coverage Status](https://coveralls.io/repos/github/macbre/sql-metadata/badge.svg?branch=master&amp;1)](https://coveralls.io/github/macbre/sql-metadata?branch=master)&lt;a href=&quot;https://github.com/psf/black&quot;&gt;&lt;img alt=&quot;Code style: black&quot; src=&quot;https://img.shields.io/badge/code%20style-black-000000.svg&quot;&gt;&lt;/a&gt;[![Maintenance](https://img.shields.io/badge/maintained%3F-yes-green.svg)](https://github.com/macbre/sql-metadata/graphs/commit-activity)[![Downloads](https://pepy.tech/badge/sql-metadata/month)](https://pepy.tech/project/sql-metadata)Uses tokenized query returned by [`python-sqlparse`](https://github.com/andialbrecht/sqlparse) and generates query metadata.**Extracts column names and tables** used by the query. Automatically conduct **column alias resolution**, **sub queries aliases resolution** as well as **tables aliases resolving**.Provides also a helper for **normalization of SQL queries**.Supported queries syntax:* MySQL* PostgreSQL* Sqlite* MSSQL* [Apache Hive](https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML)(note that listed backends can differ quite substantially but should work in regard of query types supported by `sql-metadata`)You can test the capabilities of `sql-metadata` with an interactive demo: [https://sql-app.infocruncher.com/](https://sql-app.infocruncher.com/)## Usage```pip install sql-metadata```### Extracting raw sql-metadata tokens```pythonfrom sql_metadata import Parser# extract raw sql-metadata tokensParser(&quot;SELECT * FROM foo&quot;).tokens# ['SELECT', '*', 'FROM', 'foo']```### Extracting columns from query```pythonfrom sql_metadata import Parser# get columns from query - for more examples see `tests/test_getting_columns.py`Parser(&quot;SELECT test, id FROM foo, bar&quot;).columns# ['test', 'id']Parser(&quot;INSERT /* VoteHelper::addVote xxx */  INTO `page_vote` (article_id,user_id,`time`) VALUES ('442001','27574631','20180228130846')&quot;).columns# ['article_id', 'user_id', 'time']parser = Parser(&quot;SELECT a.* FROM product_a.users AS a JOIN product_b.users AS b ON a.ip_address = b.ip_address&quot;)# note that aliases are auto-resolvedparser.columns# ['product_a.*', 'product_a.users.ip_address', 'product_b.users.ip_address']# note that you can also extract columns with their place in the query# which will return dict with lists divided into select, where, order_by, group_by, join, insert and updateparser.columns_dict# {'select': ['product_a.users.*'], 'join': ['product_a.users.ip_address', 'product_b.users.ip_address']}```### Extracting columns aliases from query```pythonfrom sql_metadata import Parserparser = Parser(&quot;SELECT a, (b + c - u) as alias1, custome_func(d) alias2 from aa, bb order by alias1&quot;)# note that columns list do not contain aliases of the columnsparser.columns# [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;u&quot;, &quot;d&quot;]# but you can still extract aliases namesparser.columns_aliases_names# [&quot;alias1&quot;, &quot;alias2&quot;]# aliases are resolved to the columns which they refer toparser.columns_aliases# {&quot;alias1&quot;: [&quot;b&quot;, &quot;c&quot;, &quot;u&quot;], &quot;alias2&quot;: &quot;d&quot;}# you can also extract aliases used by section of the query in which they are usedparser.columns_aliases_dict# {&quot;order_by&quot;: [&quot;alias1&quot;], &quot;select&quot;: [&quot;alias1&quot;, &quot;alias2&quot;]}# the same applies to aliases used in queries section when you extract columns_dict# here only the alias is used in order by but it's resolved to actual columnsassert parser.columns_dict == {'order_by': ['b', 'c', 'u'],                               'select': ['a', 'b', 'c', 'u', 'd']}```### Extracting tables from query```pythonfrom sql_metadata import Parser# get tables from query - for more examples see `tests/test_getting_tables.py`Parser(&quot;SELECT a.* FROM product_a.users AS a JOIN product_b.users AS b ON a.ip_address = b.ip_address&quot;).tables# ['product_a.users', 'product_b.users']Parser(&quot;SELECT test, id FROM foo, bar&quot;).tables# ['foo', 'bar']# you can also extract aliases of the tables as a dictionaryparser = Parser(&quot;SELECT f.test FROM foo AS f&quot;)# get table aliasesparser.tables_aliases# {'f': 'foo'}# note that aliases are auto-resolved for columnsparser.columns# [&quot;foo.test&quot;]```### Extracting values from insert query```pythonfrom sql_metadata import Parserparser = Parser(    &quot;INSERT /* VoteHelper::addVote xxx */  INTO `page_vote` (article_id,user_id,`time`) &quot;     &quot;VALUES ('442001','27574631','20180228130846')&quot;)# extract values from queryparser.values# [&quot;442001&quot;, &quot;27574631&quot;, &quot;20180228130846&quot;]# extract a dictionary with column-value pairsparser.values_dict#{&quot;article_id&quot;: &quot;442001&quot;, &quot;user_id&quot;: &quot;27574631&quot;, &quot;time&quot;: &quot;20180228130846&quot;}# if column names are not set auto-add placeholdersparser = Parser(    &quot;INSERT IGNORE INTO `table` VALUES (9, 2.15, '123', '2017-01-01');&quot;)parser.values# [9, 2.15, &quot;123&quot;, &quot;2017-01-01&quot;]parser.values_dict#{&quot;column_1&quot;: 9, &quot;column_2&quot;: 2.15, &quot;column_3&quot;: &quot;123&quot;, &quot;column_4&quot;: &quot;2017-01-01&quot;}```### Extracting limit and offset```pythonfrom sql_metadata import ParserParser('SELECT foo_limit FROM bar_offset LIMIT 50 OFFSET 1000').limit_and_offset# (50, 1000)Parser('SELECT foo_limit FROM bar_offset limit 2000,50').limit_and_offset# (50, 2000)```### Extracting with names```pythonfrom sql_metadata import Parserparser = Parser(    &quot;&quot;&quot;WITH    database1.tableFromWith AS (SELECT aa.* FROM table3 as aa                                 left join table4 on aa.col1=table4.col2),    test as (SELECT * from table3)SELECT  &quot;xxxxx&quot;FROM  database1.tableFromWith aliasLEFT JOIN database2.table2 ON (&quot;tt&quot;.&quot;ttt&quot;.&quot;fff&quot; = &quot;xx&quot;.&quot;xxx&quot;)&quot;&quot;&quot;)# get names/ aliases of with statementsparser.with_names# [&quot;database1.tableFromWith&quot;, &quot;test&quot;]# get definition of with queriesparser.with_queries# {&quot;database1.tableFromWith&quot;: &quot;SELECT aa.* FROM table3 as aa left join table4 on aa.col1=table4.col2&quot;#  &quot;test&quot;: &quot;SELECT * from table3&quot;}# note that names of with statements do not appear in tablesparser.tables# [&quot;table3&quot;, &quot;table4&quot;, &quot;database2.table2&quot;]```### Extracting sub-queries```pythonfrom sql_metadata import Parserparser = Parser(&quot;&quot;&quot;SELECT COUNT(1) FROM(SELECT std.task_id FROM some_task_detail std WHERE std.STATUS = 1) aJOIN (SELECT st.task_id FROM some_task st WHERE task_type_id = 80) bON a.task_id = b.task_id;&quot;&quot;&quot;)# get sub-queries dictionaryparser.subqueries# {&quot;a&quot;: &quot;SELECT std.task_id FROM some_task_detail std WHERE std.STATUS = 1&quot;,#  &quot;b&quot;: &quot;SELECT st.task_id FROM some_task st WHERE task_type_id = 80&quot;}# get names/ aliases of sub-queries / derived tablesparser.subqueries_names# [&quot;a&quot;, &quot;b&quot;]# note that columns coming from sub-queries are resolved to real columnsparser.columns#[&quot;some_task_detail.task_id&quot;, &quot;some_task_detail.STATUS&quot;, &quot;some_task.task_id&quot;, # &quot;task_type_id&quot;]# same applies for columns_dict, note the join columns are resolvedparser.columns_dict#{'join': ['some_task_detail.task_id', 'some_task.task_id'],# 'select': ['some_task_detail.task_id', 'some_task.task_id'],# 'where': ['some_task_detail.STATUS', 'task_type_id']}```See `tests` file for more examples of a bit more complex queries.### Queries normalization and comments extraction```pythonfrom sql_metadata import Parserparser = Parser('SELECT /* Test */ foo FROM bar WHERE id in (1, 2, 56)')# generalize queryparser.generalize# 'SELECT foo FROM bar WHERE id in (XYZ)'# remove commentsparser.without_comments# 'SELECT foo FROM bar WHERE id in (1, 2, 56)'# extract commentsparser.comments# ['/* Test */']```See `test/test_normalization.py` file for more examples of a bit more complex queries.## Migrating from `sql_metadata` 1.x`sql_metadata.compat` module has been implemented to make the introduction of sql-metadata v2.0 smoother.You can use it by simply changing the imports in your code from:```pythonfrom sql_metadata import get_query_columns, get_query_tables```into:```pythonfrom sql_metadata.compat import get_query_columns, get_query_tables```The following functions from the old API are available in the `sql_metadata.compat` module:* `generalize_sql`* `get_query_columns` (since #131 columns aliases ARE NOT returned by this function)* `get_query_limit_and_offset`* `get_query_tables`* `get_query_tokens`* `preprocess_query`## Authors and contributorsCreated and maintained by [@macbre](https://github.com/macbre) with a great contributions from [@collerek](https://github.com/collerek) and the others.* aborecki (https://github.com/aborecki)* collerek (https://github.com/collerek)* dylanhogg (https://github.com/dylanhogg)* macbre (https://github.com/macbre)## Stargazers over time[![Stargazers over time](https://starchart.cc/macbre/sql-metadata.svg)](https://starchart.cc/macbre/sql-metadata)</longdescription>
</pkgmetadata>