<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>===============================================================================vistir: Setup / utilities which most projects eventually need===============================================================================.. image:: https://img.shields.io/pypi/v/vistir.svg    :target: https://pypi.python.org/pypi/vistir.. image:: https://img.shields.io/pypi/l/vistir.svg    :target: https://pypi.python.org/pypi/vistir.. image:: https://travis-ci.com/sarugaku/vistir.svg?branch=master    :target: https://travis-ci.com/sarugaku/vistir.. image:: https://img.shields.io/pypi/pyversions/vistir.svg    :target: https://pypi.python.org/pypi/vistir.. image:: https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg    :target: https://saythanks.io/to/techalchemy.. image:: https://readthedocs.org/projects/vistir/badge/?version=latest    :target: https://vistir.readthedocs.io/en/latest/?badge=latest    :alt: Documentation Status.. image:: https://dev.azure.com/sarugaku/vistir/_apis/build/status/Vistir%20Build%20Pipeline?branchName=master    :target: https://dev.azure.com/sarugaku/vistir/_build/latest?definitionId=2&amp;branchName=master游낼 Installation=================Install from `PyPI`_:  ::    $ pipenv install vistirInstall from `Github`_:  ::    $ pipenv install -e git+https://github.com/sarugaku/vistir.git#egg=vistir.. _PyPI: https://www.pypi.org/project/vistir.. _Github: https://github.com/sarugaku/vistir.. _`Summary`:游낼 Summary===========**vistir** is a library full of utility functions designed to make life easier. Here aresome of the places where these functions are used:  * `pipenv`_  * `requirementslib`_  * `pip-tools`_  * `passa`_  * `pythonfinder`_.. _passa: https://github.com/sarugaku/passa.. _pipenv: https://github.com/pypa/pipenv.. _pip-tools: https://github.com/jazzband/pip-tools.. _requirementslib: https://github.com/sarugaku/requirementslib.. _pythonfinder: https://github.com/sarugaku/pythonfinder.. _`Usage`:游낼 Usage==========Importing a utility--------------------You can import utilities directly from **vistir**:.. code:: python    from vistir import cd    with cd('/path/to/somedir'):        do_stuff_in('somedir').. _`Functionality`:游낼 Functionality==================**vistir** provides several categories of functionality, including:    * Compatibility Shims    * Context Managers    * Miscellaneous Utilities    * Path Utilities游낼 Context Managers--------------------**vistir** provides the following context managers as utility contexts:    * ``vistir.contextmanagers.atomic_open_for_write``    * ``vistir.contextmanagers.cd``    * ``vistir.contextmanagers.open_file``    * ``vistir.contextmanagers.replaced_stream``    * ``vistir.contextmanagers.replaced_streams``    * ``vistir.contextmanagers.temp_environ``    * ``vistir.contextmanagers.temp_path``.. _`atomic_open_for_write`:**atomic_open_for_write**///////////////////////////This context manager ensures that a file only gets overwritten if the contents can besuccessfully written in its place.  If you open a file for writing and then fail in themiddle under normal circumstances, your original file is already gone... code:: python    &gt;&gt;&gt; fn = &quot;test_file.txt&quot;    &gt;&gt;&gt; with open(fn, &quot;w&quot;) as fh:            fh.write(&quot;this is some test text&quot;)    &gt;&gt;&gt; read_test_file()    this is some test text    &gt;&gt;&gt; def raise_exception_while_writing(filename):            with vistir.contextmanagers.atomic_open_for_write(filename) as fh:                fh.write(&quot;Overwriting all the text from before with even newer text&quot;)                raise RuntimeError(&quot;But did it get overwritten now?&quot;)    &gt;&gt;&gt; raise_exception_while_writing(fn)        Traceback (most recent call last):            ...        RuntimeError: But did it get overwritten now?    &gt;&gt;&gt; read_test_file()    this is some test text.. _`cd`:**cd**///////A context manager for temporarily changing the working directory... code:: python    &gt;&gt;&gt; os.path.abspath(os.curdir)    '/tmp/test'    &gt;&gt;&gt; with vistir.contextmanagers.cd('/tmp/vistir_test'):            print(os.path.abspath(os.curdir))    /tmp/vistir_test.. _`open_file`:**open_file**///////////////A context manager for streaming file contents, either local or remote. It is recommendedto pair this with an iterator which employs a sensible chunk size... code:: python    &gt;&gt;&gt; filecontents = b&quot;&quot;        with vistir.contextmanagers.open_file(&quot;https://norvig.com/big.txt&quot;) as fp:            for chunk in iter(lambda: fp.read(16384), b&quot;&quot;):                filecontents.append(chunk)    &gt;&gt;&gt; import io    &gt;&gt;&gt; import shutil    &gt;&gt;&gt; filecontents = io.BytesIO(b&quot;&quot;)    &gt;&gt;&gt; with vistir.contextmanagers.open_file(&quot;https://norvig.com/big.txt&quot;) as fp:            shutil.copyfileobj(fp, filecontents)**replaced_stream**////////////////////.. _`replaced_stream`:A context manager to temporarily swap out *stream_name* with a stream wrapper.  This willcapture the stream output and prevent it from being written as normal... code-block:: python    &gt;&gt;&gt; orig_stdout = sys.stdout    &gt;&gt;&gt; with replaced_stream(&quot;stdout&quot;) as stdout:    ...     sys.stdout.write(&quot;hello&quot;)    ...     assert stdout.getvalue() == &quot;hello&quot;    ...     assert orig_stdout.getvalue() != &quot;hello&quot;    &gt;&gt;&gt; sys.stdout.write(&quot;hello&quot;)    'hello'.. _`replaced_streams`:**replaced_streams**/////////////////////Temporarily replaces both *sys.stdout* and *sys.stderr* and captures anything writtento these respective targets... code-block:: python    &gt;&gt;&gt; import sys    &gt;&gt;&gt; with vistir.contextmanagers.replaced_streams() as streams:    &gt;&gt;&gt;     stdout, stderr = streams    &gt;&gt;&gt;     sys.stderr.write(&quot;test&quot;)    &gt;&gt;&gt;     sys.stdout.write(&quot;hello&quot;)    &gt;&gt;&gt;     assert stdout.getvalue() == &quot;hello&quot;    &gt;&gt;&gt;     assert stderr.getvalue() == &quot;test&quot;    &gt;&gt;&gt; stdout.getvalue()    'hello'    &gt;&gt;&gt; stderr.getvalue()    'test'.. _`spinner`:**spinner**////////////A context manager for wrapping some actions with a threaded, interrupt-safe spinner. Thespinner is fully compatible with all terminals (you can use ``bouncingBar`` on non-utf8terminals) and will allow you to update the text of the spinner itself by simply setting``spinner.text`` or write lines to the screen above the spinner by using``spinner.write(line)``. Success text can be indicated using ``spinner.ok(&quot;Text&quot;)`` andfailure text can be indicated with ``spinner.fail(&quot;Fail text&quot;)``... code:: python    &gt;&gt;&gt; lines = [&quot;a&quot;, &quot;b&quot;]    &gt;&gt;&gt; with vistir.contextmanagers.spinner(spinner_name=&quot;dots&quot;, text=&quot;Running...&quot;, handler_map={}, nospin=False) as sp:            for line in lines:            sp.write(line + &quot;\n&quot;)            while some_variable = some_queue.pop():                sp.text = &quot;Consuming item: %s&quot; % some_variable            if success_condition:                sp.ok(&quot;Succeeded!&quot;)            else:                sp.fail(&quot;Failed!&quot;).. _`temp_environ`:**temp_environ**/////////////////Sets a temporary environment context to freely manipulate ``os.environ`` which willbe reset upon exiting the context... code:: python    &gt;&gt;&gt; os.environ['MY_KEY'] = &quot;test&quot;    &gt;&gt;&gt; os.environ['MY_KEY']    'test'    &gt;&gt;&gt; with vistir.contextmanagers.temp_environ():            os.environ['MY_KEY'] = &quot;another thing&quot;            print(&quot;New key: %s&quot; % os.environ['MY_KEY'])    New key: another thing    &gt;&gt;&gt; os.environ['MY_KEY']    'test'.. _`temp_path`:**temp_path**//////////////Sets a temporary environment context to freely manipulate ``sys.path`` which willbe reset upon exiting the context... code:: python    &gt;&gt;&gt; path_from_virtualenv = load_path(&quot;/path/to/venv/bin/python&quot;)    &gt;&gt;&gt; print(sys.path)    ['/home/user/.pyenv/versions/3.7.0/bin', '/home/user/.pyenv/versions/3.7.0/lib/python37.zip', '/home/user/.pyenv/versions/3.7.0/lib/python3.7', '/home/user/.pyenv/versions/3.7.0/lib/python3.7/lib-dynload', '/home/user/.pyenv/versions/3.7.0/lib/python3.7/site-packages']    &gt;&gt;&gt; with temp_path():            sys.path = path_from_virtualenv            # Running in the context of the path above            run([&quot;pip&quot;, &quot;install&quot;, &quot;stuff&quot;])    &gt;&gt;&gt; print(sys.path)    ['/home/user/.pyenv/versions/3.7.0/bin', '/home/user/.pyenv/versions/3.7.0/lib/python37.zip', '/home/user/.pyenv/versions/3.7.0/lib/python3.7', '/home/user/.pyenv/versions/3.7.0/lib/python3.7/lib-dynload', '/home/user/.pyenv/versions/3.7.0/lib/python3.7/site-packages']游낼 Cursor Utilities--------------------------The following Cursor utilities are available to manipulate the console cursor:    * ``vistir.cursor.hide_cursor``    * ``vistir.cursor.show_cursor``.. _`hide_cursor`:**hide_cursor**/////////////////Hide the console cursor in the given stream... code:: python    &gt;&gt;&gt; vistir.cursor.hide_cursor(stream=sys.stdout).. _`show_cursor`:**show_cursor**/////////////////Show the console cursor in the given stream... code:: python    &gt;&gt;&gt; vistir.cursor.show_cursor(stream=sys.stdout)游낼 Miscellaneous Utilities--------------------------The following Miscellaneous utilities are available as helper methods:    * ``vistir.misc.shell_escape``    * ``vistir.misc.unnest``    * ``vistir.misc.run``    * ``vistir.misc.load_path``    * ``vistir.misc.partialclass``    * ``vistir.misc.to_text``    * ``vistir.misc.to_bytes``    * ``vistir.misc.take``    * ``vistir.misc.decode_for_output``    * ``vistir.misc.get_canonical_encoding_name``    * ``vistir.misc.get_wrapped_stream``    * ``vistir.misc.StreamWrapper``    * ``vistir.misc.get_text_stream``    * ``vistir.misc.replace_with_text_stream``    * ``vistir.misc.get_text_stdin``    * ``vistir.misc.get_text_stdout``    * ``vistir.misc.get_text_stderr``    * ``vistir.misc.echo``.. _`shell_escape`:**shell_escape**/////////////////Escapes a string for use as shell input when passing *shell=True* to ``os.Popen``... code:: python    &gt;&gt;&gt; vistir.misc.shell_escape(&quot;/tmp/test/test script.py hello&quot;)    '/tmp/test/test script.py hello'.. _`unnest`:**unnest**///////////Unnests nested iterables into a flattened one... code:: python    &gt;&gt;&gt; nested_iterable = (1234, (3456, 4398345, (234234)), (2396, (23895750, 9283798, 29384, (289375983275, 293759, 2347, (2098, 7987, 27599)))))    &gt;&gt;&gt; list(vistir.misc.unnest(nested_iterable))    [1234, 3456, 4398345, 234234, 2396, 23895750, 9283798, 29384, 289375983275, 293759, 2347, 2098, 7987, 27599].. _`dedup`:**dedup**//////////Deduplicates an iterable (like a ``set``, but preserving order)... code:: python    &gt;&gt;&gt; iterable = [&quot;repeatedval&quot;, &quot;uniqueval&quot;, &quot;repeatedval&quot;, &quot;anotherval&quot;, &quot;somethingelse&quot;]    &gt;&gt;&gt; list(vistir.misc.dedup(iterable))    ['repeatedval', 'uniqueval', 'anotherval', 'somethingelse'].. _`run`:**run**////////Runs the given command using ``subprocess.Popen`` and passing sane defaults... code:: python    &gt;&gt;&gt; out, err = vistir.run([&quot;cat&quot;, &quot;/proc/version&quot;])    &gt;&gt;&gt; out    'Linux version 4.15.0-27-generic (buildd@lgw01-amd64-044) (gcc version 7.3.0 (Ubuntu 7.3.0-16ubuntu3)) #29-Ubuntu SMP Wed Jul 11 08:21:57 UTC 2018'.. _`load_path`:**load_path**//////////////Load the ``sys.path`` from the given python executable's environment as json... code:: python    &gt;&gt;&gt; load_path(&quot;/home/user/.virtualenvs/requirementslib-5MhGuG3C/bin/python&quot;)    ['', '/home/user/.virtualenvs/requirementslib-5MhGuG3C/lib/python37.zip', '/home/user/.virtualenvs/requirementslib-5MhGuG3C/lib/python3.7', '/home/user/.virtualenvs/requirementslib-5MhGuG3C/lib/python3.7/lib-dynload', '/home/user/.pyenv/versions/3.7.0/lib/python3.7', '/home/user/.virtualenvs/requirementslib-5MhGuG3C/lib/python3.7/site-packages', '/home/user/git/requirementslib/src'].. _`partialclass`:**partialclass**/////////////////Create a partially instantiated class... code:: python    &gt;&gt;&gt; source = partialclass(Source, url=&quot;https://pypi.org/simple&quot;)    &gt;&gt;&gt; new_source = source(name=&quot;pypi&quot;)    &gt;&gt;&gt; new_source    &lt;__main__.Source object at 0x7f23af189b38&gt;    &gt;&gt;&gt; new_source.__dict__    {'url': 'https://pypi.org/simple', 'verify_ssl': True, 'name': 'pypi'}.. _`to_text`:**to_text**////////////Convert arbitrary text-formattable input to text while handling errors... code:: python    &gt;&gt;&gt; vistir.misc.to_text(b&quot;these are bytes&quot;)    'these are bytes'.. _`to_bytes`:**to_bytes**/////////////Converts arbitrary byte-convertable input to bytes while handling errors... code:: python    &gt;&gt;&gt; vistir.misc.to_bytes(&quot;this is some text&quot;)    b'this is some text'    &gt;&gt;&gt; vistir.misc.to_bytes(u&quot;this is some text&quot;)    b'this is some text'.. _`chunked`:**chunked**////////////Splits an iterable up into groups *of the specified length*, per `more itertools`_.  Returns an iterable.This example will create groups of chunk size **5**, which means there will be *6 groups*... code-block:: python    &gt;&gt;&gt; chunked_iterable = vistir.misc.chunked(5, range(30))    &gt;&gt;&gt; for chunk in chunked_iterable:    ...     add_to_some_queue(chunk).. _more itertools: https://more-itertools.readthedocs.io/en/latest/api.html#grouping.. _`take`:**take**/////////Take elements from the supplied iterable without consuming it... code-block:: python    &gt;&gt;&gt; iterable = range(30)    &gt;&gt;&gt; first_10 = take(10, iterable)    &gt;&gt;&gt; [i for i in first_10]    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]    &gt;&gt;&gt; [i for i in iterable]    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29].. _`divide`:**divide**////////////Splits an iterable up into the *specified number of groups*, per `more itertools`_.  Returns an iterable... code-block:: python    &gt;&gt;&gt; iterable = range(30)    &gt;&gt;&gt; groups = []    &gt;&gt;&gt; for grp in vistir.misc.divide(3, iterable):    ...     groups.append(grp)    &gt;&gt;&gt; groups    [&lt;tuple_iterator object at 0x7fb7966006a0&gt;, &lt;tuple_iterator object at 0x7fb796652780&gt;, &lt;tuple_iterator object at 0x7fb79650a2b0&gt;].. _more itertools: https://more-itertools.readthedocs.io/en/latest/api.html#grouping.. _`decode_for_output`:**decode_for_output**//////////////////////Converts an arbitrary text input to output which is encoded for printing to terminaloutputs using the system preferred locale using ``locale.getpreferredencoding(False)``with some additional hackery on linux systems... _`get_canonical_encoding_name`:**get_canonical_encoding_name**////////////////////////////////Given an encoding name, get the canonical name from a codec lookup... code-block:: python    &gt;&gt;&gt; vistir.misc.get_canonical_encoding_name(&quot;utf8&quot;)    &quot;utf-8&quot;.. _`get_wrapped_stream`:**get_wrapped_stream**//////////////////////Given a stream, wrap it in a `StreamWrapper` instance and return the wrapped stream... code-block:: python    &gt;&gt;&gt; stream = sys.stdout    &gt;&gt;&gt; wrapped_stream = vistir.misc.get_wrapped_stream(sys.stdout)    &gt;&gt;&gt; wrapped_stream.write(&quot;unicode\u0141&quot;)    &gt;&gt;&gt; wrapped_stream.seek(0)    &gt;&gt;&gt; wrapped_stream.read()    &quot;unicode\u0141&quot;.. _`StreamWrapper`:**StreamWrapper**//////////////////A stream wrapper and compatibility class for handling wrapping file-like stream objectswhich may be used in place of ``sys.stdout`` and other streams... code-block:: python    &gt;&gt;&gt; wrapped_stream = vistir.misc.StreamWrapper(sys.stdout, encoding=&quot;utf-8&quot;, errors=&quot;replace&quot;, line_buffering=True)    &gt;&gt;&gt; wrapped_stream = vistir.misc.StreamWrapper(io.StringIO(), encoding=&quot;utf-8&quot;, errors=&quot;replace&quot;, line_buffering=True).. _`get_text_stream`:**get_text_stream**////////////////////An implementation of the **StreamWrapper** for the purpose of wrapping **sys.stdin** or **sys.stdout**.On Windows, this returns the appropriate handle to the requested output stream... code-block:: python    &gt;&gt;&gt; text_stream = vistir.misc.get_text_stream(&quot;stdout&quot;)    &gt;&gt;&gt; sys.stdout = text_stream    &gt;&gt;&gt; sys.stdin = vistir.misc.get_text_stream(&quot;stdin&quot;)    &gt;&gt;&gt; vistir.misc.echo(u&quot;\0499&quot;, fg=&quot;green&quot;)    훛.. _`replace_with_text_stream`:**replace_with_text_stream**/////////////////////////////Given a text stream name, replaces the text stream with a **StreamWrapper** instance... code-block:: python    &gt;&gt;&gt; vistir.misc.replace_with_text_stream(&quot;stdout&quot;)Once invoked, the standard stream in question is replaced with the required wrapper,turning it into a ``TextIOWrapper`` compatible stream (which ensures that unicodecharacters can be written to it)... _`get_text_stdin`:**get_text_stdin**///////////////////A helper function for calling **get_text_stream(&quot;stdin&quot;)**... _`get_text_stdout`:**get_text_stdout**////////////////////A helper function for calling **get_text_stream(&quot;stdout&quot;)**... _`get_text_stderr`:**get_text_stderr**////////////////////A helper function for calling **get_text_stream(&quot;stderr&quot;)**... _`echo`:**echo**/////////Writes colored, stream-compatible output to the desired handle (``sys.stdout`` by default)... code-block:: python    &gt;&gt;&gt; vistir.misc.echo(&quot;some text&quot;, fg=&quot;green&quot;, bg=&quot;black&quot;, style=&quot;bold&quot;, err=True)  # write to stderr    some text    &gt;&gt;&gt; vistir.misc.echo(&quot;some other text&quot;, fg=&quot;cyan&quot;, bg=&quot;white&quot;, style=&quot;underline&quot;)  # write to stdout    some other text游낼 Path Utilities------------------**vistir** provides utilities for interacting with filesystem paths:    * ``vistir.path.get_converted_relative_path``    * ``vistir.path.normalize_path``    * ``vistir.path.is_in_path``    * ``vistir.path.handle_remove_readonly``    * ``vistir.path.is_file_url``    * ``vistir.path.is_readonly_path``    * ``vistir.path.is_valid_url``    * ``vistir.path.mkdir_p``    * ``vistir.path.ensure_mkdir_p``    * ``vistir.path.create_tracked_tempdir``    * ``vistir.path.create_tracked_tempfile``    * ``vistir.path.path_to_url``    * ``vistir.path.rmtree``    * ``vistir.path.safe_expandvars``    * ``vistir.path.set_write_bit``    * ``vistir.path.url_to_path``    * ``vistir.path.walk_up``.. _`normalize_path`:**normalize_path**//////////////////Return a case-normalized absolute variable-expanded path... code:: python    &gt;&gt;&gt; vistir.path.normalize_path(&quot;~/${USER}&quot;)    /home/user/user.. _`is_in_path`:**is_in_path**//////////////Determine if the provided full path is in the given parent root... code:: python    &gt;&gt;&gt; vistir.path.is_in_path(&quot;~/.pyenv/versions/3.7.1/bin/python&quot;, &quot;${PYENV_ROOT}/versions&quot;)    True.. _`get_converted_relative_path`:**get_converted_relative_path**////////////////////////////////Convert the supplied path to a relative path (relative to ``os.curdir``).. code:: python    &gt;&gt;&gt; os.chdir('/home/user/code/myrepo/myfolder')    &gt;&gt;&gt; vistir.path.get_converted_relative_path('/home/user/code/file.zip')    './../../file.zip'    &gt;&gt;&gt; vistir.path.get_converted_relative_path('/home/user/code/myrepo/myfolder/mysubfolder')    './mysubfolder'    &gt;&gt;&gt; vistir.path.get_converted_relative_path('/home/user/code/myrepo/myfolder')    '.'.. _`handle_remove_readonly`:**handle_remove_readonly**///////////////////////////Error handler for shutil.rmtree.Windows source repo folders are read-only by default, so this error handler attempts toset them as writeable and then proceed with deletion.This function will call check ``vistir.path.is_readonly_path`` before attempting tocall ``vistir.path.set_write_bit`` on the target path and try again... _`is_file_url`:**is_file_url**////////////////Checks whether the given url is a properly formatted ``file://`` uri... code:: python    &gt;&gt;&gt; vistir.path.is_file_url('file:///home/user/somefile.zip')    True    &gt;&gt;&gt; vistir.path.is_file_url('/home/user/somefile.zip')    False.. _`is_readonly_path`:**is_readonly_path**/////////////////////Check if a provided path exists and is readonly by checking for ``bool(path.stat &amp; stat.S_IREAD) and not os.access(path, os.W_OK)``.. code:: python    &gt;&gt;&gt; vistir.path.is_readonly_path('/etc/passwd')    True    &gt;&gt;&gt; vistir.path.is_readonly_path('/home/user/.bashrc')    False.. _`is_valid_url`:**is_valid_url**/////////////////Checks whether a URL is valid and parseable by checking for the presence of a scheme anda netloc... code:: python    &gt;&gt;&gt; vistir.path.is_valid_url(&quot;https://google.com&quot;)    True    &gt;&gt;&gt; vistir.path.is_valid_url(&quot;/home/user/somefile&quot;)    False.. _`mkdir_p`:**mkdir_p**/////////////Recursively creates the target directory and all of its parents if they do notalready exist.  Fails silently if they do... code:: python    &gt;&gt;&gt; os.mkdir('/tmp/test_dir')    &gt;&gt;&gt; os.listdir('/tmp/test_dir')    []    &gt;&gt;&gt; vistir.path.mkdir_p('/tmp/test_dir/child/subchild/subsubchild')    &gt;&gt;&gt; os.listdir('/tmp/test_dir/child/subchild')    ['subsubchild'].. _`ensure_mkdir_p`:**ensure_mkdir_p**///////////////////A decorator which ensures that the caller function's return value is created as adirectory on the filesystem... code:: python    &gt;&gt;&gt; @ensure_mkdir_p    def return_fake_value(path):        return path    &gt;&gt;&gt; return_fake_value('/tmp/test_dir')    &gt;&gt;&gt; os.listdir('/tmp/test_dir')    []    &gt;&gt;&gt; return_fake_value('/tmp/test_dir/child/subchild/subsubchild')    &gt;&gt;&gt; os.listdir('/tmp/test_dir/child/subchild')    ['subsubchild'].. _`create_tracked_tempdir`:**create_tracked_tempdir**////////////////////////////Creates a tracked temporary directory using ``vistir.path.TemporaryDirectory``, but doesnot remove the directory when the return value goes out of scope, instead registers ahandler to cleanup on program exit... code:: python    &gt;&gt;&gt; temp_dir = vistir.path.create_tracked_tempdir(prefix=&quot;test_dir&quot;)    &gt;&gt;&gt; assert temp_dir.startswith(&quot;test_dir&quot;)    True    &gt;&gt;&gt; with vistir.path.create_tracked_tempdir(prefix=&quot;test_dir&quot;) as temp_dir:        with io.open(os.path.join(temp_dir, &quot;test_file.txt&quot;), &quot;w&quot;) as fh:            fh.write(&quot;this is a test&quot;)    &gt;&gt;&gt; os.listdir(temp_dir).. _`create_tracked_tempfile`:**create_tracked_tempfile**////////////////////////////Creates a tracked temporary file using ``vistir.compat.NamedTemporaryFile``, but createsa ``weakref.finalize`` call which will detach on garbage collection to close and deletethe file... code:: python    &gt;&gt;&gt; temp_file = vistir.path.create_tracked_tempfile(prefix=&quot;requirements&quot;, suffix=&quot;txt&quot;)    &gt;&gt;&gt; temp_file.write(&quot;some\nstuff&quot;)    &gt;&gt;&gt; exit().. _`path_to_url`:**path_to_url**////////////////Convert the supplied local path to a file uri... code:: python    &gt;&gt;&gt; path_to_url(&quot;/home/user/code/myrepo/myfile.zip&quot;)    'file:///home/user/code/myrepo/myfile.zip'.. _`rmtree`:**rmtree**///////////Stand-in for ``shutil.rmtree`` with additional error-handling.This version of `rmtree` handles read-only paths, especially in the case of index fileswritten by certain source control systems... code:: python    &gt;&gt;&gt; vistir.path.rmtree('/tmp/test_dir')    &gt;&gt;&gt; [d for d in os.listdir('/tmp') if 'test_dir' in d]    [].. note::    Setting `ignore_errors=True` may cause this to silently fail to delete the path.. _`safe_expandvars`:**safe_expandvars**////////////////////Call ``os.path.expandvars`` if value is a string, otherwise do nothing... code:: python    &gt;&gt;&gt; os.environ['TEST_VAR'] = &quot;MY_TEST_VALUE&quot;    &gt;&gt;&gt; vistir.path.safe_expandvars(&quot;https://myuser:${TEST_VAR}@myfakewebsite.com&quot;)    'https://myuser:MY_TEST_VALUE@myfakewebsite.com'.. _`set_write_bit`:**set_write_bit**//////////////////Set read-write permissions for the current user on the target path.  Fail silentlyif the path doesn't exist... code:: python    &gt;&gt;&gt; vistir.path.set_write_bit('/path/to/some/file')    &gt;&gt;&gt; with open('/path/to/some/file', 'w') as fh:            fh.write(&quot;test text!&quot;).. _`url_to_path`:**url_to_path**////////////////Convert a valid file url to a local filesystem path. Follows logic taken from pip... code:: python    &gt;&gt;&gt; vistir.path.url_to_path(&quot;file:///home/user/somefile.zip&quot;)    '/home/user/somefile.zip'</longdescription>
</pkgmetadata>