<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Auto-ViML![banner](logo.png)&lt;br&gt;Automatically Build Various Interpretable ML models fast!&lt;br&gt;[![Downloads](https://pepy.tech/badge/autoviml/week)](https://pepy.tech/project/autoviml/week)[![Downloads](https://pepy.tech/badge/autoviml/month)](https://pepy.tech/project/autoviml/month)[![Downloads](https://pepy.tech/badge/autoviml)](https://pepy.tech/project/autoviml)[![standard-readme compliant](https://img.shields.io/badge/standard--readme-OK-green.svg?style=flat-square)](https://github.com/RichardLitt/standard-readme)[![Python Versions](https://img.shields.io/pypi/pyversions/autoviml.svg?logo=python&amp;logoColor=white)](https://pypi.org/project/autoviml)[![PyPI Version](https://img.shields.io/pypi/v/autoviml.svg?logo=pypi&amp;logoColor=white)](https://pypi.org/project/autoviml)[![PyPI License](https://img.shields.io/pypi/l/autoviml.svg)](https://github.com/AutoViML/Auto_ViML/blob/master/LICENSE)Auto_ViML is pronounced as &quot;auto vimal&quot; (autovimal logo created by Sanket Ghanmare).## Update (March 2023)&lt;ol&gt;&lt;li&gt;&lt;b&gt;Auto_ViML has a new flag to speed up processing using GPU's&lt;/b&gt;. Just set the `GPU_flag`=`True` on Colab and other environments. But don't forget to set the runtime type to be &quot;GPU&quot; while running on Colab. Otherwise you will get an error.&lt;/li&gt;&lt;/ol&gt;## Update (May 2022)&lt;ol&gt;&lt;li&gt;&lt;b&gt;Auto_ViML as of version 0.1.710 uses a very high performance library called `imbalanced_ensemble` for Imbalanced dataset problems.&lt;/b&gt; It will produce a 5-10% boost in your balanced_accuracy based on my experience with  many datasets I have tried.&lt;/li&gt;&lt;br&gt;&lt;p&gt;In addition, new features in this version are:&lt;br&gt;&lt;ul&gt;&lt;li&gt;SULOV -&gt; Uses the SULOV algorithm for removing highly correlated features automatically.&lt;/li&gt;&lt;li&gt;Auto_NLP -&gt; AutoViML automatically detects Text variables and does NLP processing using Auto_NLP&lt;/li&gt;&lt;li&gt;Date Time -&gt; It automatically detects  date time variables and generates new features&lt;/li&gt;&lt;li&gt;`imbalanced_ensemble` library -&gt; Uses imbalanced_ensemble library for imbalanced data. Just set Imbalanced_Flag = True in arguments&lt;/li&gt;&lt;li&gt;Feature Selection -&gt; We use the same algorithm that featurewiz library uses: SULOV and Recursive XGBoost to select best features fast. See below.&lt;/li&gt;&lt;/ul&gt;## Table of Contents&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#background&quot;&gt;Background&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#install&quot;&gt;Install&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#usage&quot;&gt;Usage&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#tips-for-using-auto_viml&quot;&gt;Tips for using Auto_ViML&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#api&quot;&gt;API&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#maintainers&quot;&gt;Maintainers&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#contributing&quot;&gt;Contributing&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#license&quot;&gt;License&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;## Background&lt;p&gt;Read this &lt;a href=&quot;https://towardsdatascience.com/why-automl-is-an-essential-new-tool-for-data-scientists-2d9ab4e25e46&quot;&gt;Medium article to learn how to use Auto_ViML effectively.&lt;/a&gt;&lt;p&gt;Auto_ViML was designed for building High Performance Interpretable Models with the fewest variables needed.The &quot;V&quot; in Auto_ViML stands for Variant because it tries multiple models with multiple features to find you the best performing model for your dataset. The &quot;i&quot; in Auto_ViML stands for &quot;interpretable&quot; since Auto_ViML selects the least number of features necessary to build a simpler, more interpretable model. In most cases, Auto_ViML builds models with 20%-99% fewer features than a similar performing model with all included features (this is based on my trials. Your experience may vary).&lt;br&gt;&lt;p&gt;Auto_ViML is every Data Scientist's model accelerator tool that:&lt;ol&gt;&lt;li&gt;&lt;b&gt;Helps you with data cleaning&lt;/b&gt;: you can send in your entire dataframe as is and Auto_ViML will suggest changes to help with missing values, formatting variables, adding variables, etc. It loves dirty data. The dirtier the better!&lt;br&gt;&lt;li&gt;&lt;b&gt;Performs Feature Selection&lt;/b&gt;: Auto_ViML selects variables automatically by default. This is very helpful when you have hundreds if not thousands of variables since it can readily identify which of those are important variables vs which are unnecessary. You can turn this off as well (see API).&lt;br&gt;![xgboost](sulov_xgboost.png)&lt;li&gt;&lt;b&gt;Removes highly correlated features automatically&lt;/b&gt;. If two variables are highly correlated in your dataset, which one should you remove and which one should you keep? The decision is not as easy as it looks. Auto_ViML uses the SULOV algorithm to remove highly correlated features. You can understand SULOV from this picture more intuitively.&lt;br&gt;![sulov](SULOV.jpg)&lt;li&gt;&lt;b&gt;Generates performance results graphically&lt;/b&gt;. Just set verbose = 1 (or) 2 instead of 0 (silent). You will get higher quality of insights as you increase verbosity. &lt;br&gt;&lt;li&gt;&lt;b&gt;Handles text, date-time, structs (lists, dictionaries), numeric, boolean, factor and categorical&lt;/b&gt; variables all in one model using one straight process.&lt;br&gt;&lt;/ol&gt;Auto_ViML is built using scikit-learn, numpy, pandas and matplotlib. It should run on most Python 3 Anaconda installations. You won't have to import any special libraries other than &quot;XGBoost&quot;, &quot;Imbalanced-Learn&quot;, &quot;CatBoost&quot;, and &quot;featuretools&quot; library. We use &quot;SHAP&quot; library for interpretability. &lt;br&gt;But if you don't have these libraries, Auto_ViML will install those for you automatically.## Install**Prerequsites:**- [Anaconda](https://docs.anaconda.com/anaconda/install/)To clone Auto_ViML, it is better to create a new environment, and install the required dependencies:To install from PyPi:&lt;p&gt;&lt;code&gt;$ pip install autoviml --upgrade --ignore-installed&lt;/code&gt;&lt;br&gt;or```pip install git+https://github.com/AutoViML/Auto_ViML.git```To install from source:```cd &lt;AutoVIML_Destination&gt;git clone git@github.com:AutoViML/Auto_ViML.git# or download and unzip https://github.com/AutoViML/Auto_ViML/archive/master.zipconda create -n &lt;your_env_name&gt; python=3.7 anacondaconda activate &lt;your_env_name&gt; # ON WINDOWS: `source activate &lt;your_env_name&gt;`cd Auto_ViMLpip install -r requirements.txt```## UsageIn the same directory, open a Jupyter Notebook and use this line to import the .py file:```from autoviml.Auto_ViML import Auto_ViML```Load a data set (any CSV or text file) into a Pandas dataframe and split it into Train and Test dataframes. If you don't have a test dataframe, you can simple assign the test variable below to '' (empty string):```model, features, trainm, testm = Auto_ViML(    train,    target,    test,    sample_submission,    hyper_param=&quot;GS&quot;,    feature_reduction=True,    scoring_parameter=&quot;weighted-f1&quot;,    KMeans_Featurizer=False,    Boosting_Flag=False,    Binning_Flag=False,    Add_Poly=False,    Stacking_Flag=False,    Imbalanced_Flag=False,    verbose=0,)```Finally, it writes your submission file to disk in the current directory called `mysubmission.csv`.This submission file is ready for you to show it clients or submit it to competitions.If no submission file was given, but as long as you give it a test file name, it will create a submission file for you named `mySubmission.csv`.Auto_ViML works on any Multi-Class, Multi-Label Data Set. So you can have many target labels.You don't have to tell Auto_ViML whether it is a Regression or Classification problem.## Tips for using Auto_ViML:1. `scoring_parameter`: For Classification problems and imbalanced classes, choose scoring_parameter=&quot;balanced_accuracy&quot;. It works better.2. `Imbalanced_Flag`: For Imbalanced Classes (&lt;5% samples in rare class), choose &quot;Imbalanced_Flag&quot;=True. You can also set this flag to True for Regression problems where the target variable might have skewed distributions.3. `target`: For Multi-Label dataset, the target input target variable can be sent in as a list of variables.4. `Boosting_Flag`: It is recommended that you first set Boosting_Flag=None to get a Linear model. Once you understand that, then you can try to set Boosting_Flag=False to get a Random Forest model. Finally, try Boosting_Flag=True to get an XGBoost model. This is the order that we recommend in order to use Auto_ViML. Finally try Boosting_Flag=&quot;CatBoost&quot; to get a complex but high performing model.5. `Binning_Flag`: Binning_Flag=True improves a CatBoost model since it adds to the list of categorical vars in data6. `KMeans_featurizer`: KMeans_featurizer=True works well in NLP and CatBoost models since it creates cluster variables7. `Add_Poly`: Add_Poly=3 improves certain models where there is date-time or categorical and numeric variables8. `feature_reduction`: feature_reduction=True is the default and works best. But when you have &lt;10 features in data, set it to False9. `Stacking_Flag`: Do not set Stacking_Flag=True with Linear models since your results may not look great.10. `Stacking_Flag`: Use Stacking_Flag=True only for complex models and as a last step with Boosting_Flag=True or CatBoost11. `hyper_param`: Leave hyper_param =&quot;RS&quot; as input since it runs faster than GridSearchCV and gives better results unless you have a small data set and can afford to spend time on hyper tuning.12. `KMeans_Featurizer`: KMeans_Featurizer=True does not work well for small data sets. Use it for data sets &gt; 10,000 rows.13. `Final thoughts`: Finally Auto_ViML is meant to be a baseline or challenger solution to your data set. So use it for making quick models that you can compare against or in Hackathons. It is not meant for production!## API**Arguments**- `train`: could be a datapath+filename or a dataframe. It will detect which is which and load it.- `test`: could be a datapath+filename or a dataframe. If you don't have any, just leave it as &quot;&quot;.- `submission`: must be a datapath+filename. If you don't have any, just leave it as empty string.- `target`: name of the target variable in the data set.- `sep`: if you have a spearator in the file such as &quot;,&quot; or &quot;\t&quot; mention it here. Default is &quot;,&quot;.- `scoring_parameter`: if you want your own scoring parameter such as &quot;f1&quot; give it here. If not, it will assume the appropriate scoring param for the problem and it will build the model.- `hyper_param`: Tuning options are GridSearch ('GS') and RandomizedSearch ('RS'). Default is 'RS'.- `feature_reduction`: Default = 'True' but it can be set to False if you don't want automatic feature_reduction since in Image data sets like digits and MNIST, you get better results when you don't reduce features automatically. You can always try both and see.- `KMeans_Featurizer`  - `True`: Adds a cluster label to features based on KMeans. Use for Linear.  - `False (default)` For Random Forests or XGB models, leave it False since it may overfit.- `Boosting Flag`: you have 4 possible choices (default is False):  - `None` This will build a Linear Model  - `False` This will build a Random Forest or Extra Trees model (also known as Bagging)  - `True` This will build an XGBoost model  - `CatBoost` This will build a CatBoost model (provided you have CatBoost installed)- `Add_Poly`: Default is 0 which means do-nothing. But it has three interesting settings:  - `1` Add interaction variables only such as x1*x2, x2*x3,...x9\*10 etc.  - `2` Add Interactions and Squared variables such as x1**2, x2**2, etc.  - `3` Adds both Interactions and Squared variables such as x1*x2, x1**2,x2*x3, x2**2, etc.- `Stacking_Flag`: Default is False. If set to True, it will add an additional feature which is derived from predictions of another model. This is used in some cases but may result in overfitting. So be careful turning this flag &quot;on&quot;.- `Binning_Flag`: Default is False. It set to True, it will convert the top numeric variables into binned variables through a technique known as &quot;Entropy&quot; binning. This is very helpful for certain datasets (especially hard to build models).- `Imbalanced_Flag`: Default is False. Uses imbalanced_ensemble library for imbalanced data. Just set Imbalanced_Flag = True in arguments- `verbose`: This has 3 possible states:  - `0` limited output. Great for running this silently and getting fast results.  - `1` more charts. Great for knowing how results were and making changes to flags in input.  - `2` lots of charts and output. Great for reproducing what Auto_ViML does on your own.**Return values**- `model`: It will return your trained model- `features`: the fewest number of features in your model to make it perform well- `train_modified`: this is the modified train dataframe after removing and adding features- `test_modified`: this is the modified test dataframe with the same transformations as train## Maintainers* [@AutoViML](https://github.com/AutoViML)* [@morenoh149](https://github.com/morenoh149)* [@hironroy](https://github.com/hironroy)## ContributingSee [the contributing file](CONTRIBUTING.md)!PRs accepted.## LicenseApache License 2.0 © 2020 Ram Seshadri## DISCLAIMERThis project is not an official Google project. It is not supported by Google and Google specifically disclaims all warranties as to its quality, merchantability, or fitness for a particular purpose.</longdescription>
</pkgmetadata>