<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>======Logics======Logics is a Python framework for mathematical logic. It aims at generality (being able to represent as many systemsas possible), well-documented and readable code and minimal dependencies, rather than speed. Some of its intendedapplications are educational software (e.g. `TAUT &lt;https://taut-logic.com/&gt;`_, which uses a previous version of thispackage), and quick prototyping of ideas for research purposes.To see the documentation, visit `this link &lt;https://logics.readthedocs.io/en/latest/?&gt;`_.Installation############To install using ``pip``:.. code:: bash   $ pip install logicsOr clone it from this repository:.. code:: bash   $ git clone https://github.com/ariroffe/logics.gitExamples########The following are some random examples of what you can do with this package. For a full specification of thefunctionality see the documentation.Define a language:&gt;&gt;&gt; from logics.classes.propositional import Language&gt;&gt;&gt; language = Language(atomics=['p', 'q', 'r'],...                     constant_arity_dict={'~': 1, '∧': 2},...                     sentential_constants=['⊥', '⊤'],...                     metavariables=['A', 'B', 'C'],...                     context_variables=['Γ', 'Δ', 'Σ', 'Λ', 'Π', 'Θ'])Construct formulae and inferences/metainferences, and use specific methods of those classes:&gt;&gt;&gt; from logics.utils.parsers import classical_parser&gt;&gt;&gt; formula = classical_parser.parse('~(p and not q)')&gt;&gt;&gt; inference = classical_parser.parse('(p / p) // (q / p &amp; not p)')&gt;&gt;&gt; type(formula)&lt;class 'logics.classes.propositional.formula.Formula'&gt;&gt;&gt;&gt; type(inference)&lt;class 'logics.classes.propositional.inference.Inference'&gt;&gt;&gt;&gt; formula.depth3&gt;&gt;&gt; formula.is_well_formed(language)True&gt;&gt;&gt; formula.is_instance_of(classical_parser.parse('not (A and B)'), language)True&gt;&gt;&gt; formula2 = formula.substitute(classical_parser.parse(&quot;p&quot;), classical_parser.parse(&quot;p or q&quot;))&gt;&gt;&gt; classical_parser.unparse(formula2)'~((p ∨ q) ∧ ~q)'&gt;&gt;&gt; inference.level2Define a mixed many-valued model theory, and use it:&gt;&gt;&gt; from logics.instances.propositional.languages import classical_infinite_language_with_sent_constants&gt;&gt;&gt; from logics.classes.propositional.semantics import MixedManyValuedSemantics&gt;&gt;&gt; trivalued_truth_values = ['1', 'i', '0']&gt;&gt;&gt; trivalued_truth_functions = {...     '~': ['0', 'i', '1'],...     '∧': [ #1   #i   #0...           ['1', 'i', '0'],    # 1...           ['i', 'i', '0'],    # i...           ['0', '0', '0']],   # 0...     '∨': [ #1   #i   #0...           ['1', '1', '1'],    # 1...           ['1', 'i', 'i'],    # i...           ['1', 'i', '0']],   # 0...     '→': [ #1   #i   #0...           ['1', 'i', '0'],    # 1...           ['1', 'i', 'i'],    # i...           ['1', '1', '1']],   # 0...     '↔': [ #1   #i   #0...           ['1', 'i', '0'],    # 1...           ['i', 'i', 'i'],    # i...           ['0', 'i', '1']],   # 0...     }&gt;&gt;&gt; ST = MixedManyValuedSemantics(language=classical_infinite_language_with_sent_constants,...                               truth_values=trivalued_truth_values,...                               premise_designated_values=['1'],...                               conclusion_designated_values=['1', 'i'],...                               truth_function_dict=trivalued_truth_functions,...                               sentential_constant_values_dict={'⊥': '0', '⊤': '1'},...                               name='ST')&gt;&gt;&gt; ST.valuation(classical_parser.parse('p then q'), {'p': '1', 'q': 'i'})'i'&gt;&gt;&gt; ST.satisfies(classical_parser.parse('(A / B), (B / C) // (A / C)'), {'A': '1', 'B': 'i', 'C': '0'})False&gt;&gt;&gt; ST.is_valid(classical_parser.parse('p and ~p / q'))True&gt;&gt;&gt; ST.is_locally_valid(classical_parser.parse('(A / B), (B / C) // (A / C)'))False&gt;&gt;&gt; ST.is_globally_valid(classical_parser.parse('(A / B), (B / C) // (A / C)'))True&gt;&gt;&gt; # There are also some predefined systems (ST is one of them, the above was unnecesary)&gt;&gt;&gt; from logics.instances.propositional.many_valued_semantics import TS_mvl_semantics as TS&gt;&gt;&gt; from logics.instances.propositional.many_valued_semantics import LP_mvl_semantics as LP&gt;&gt;&gt; LP.is_valid(classical_parser.parse('p and ~p / q'))False&gt;&gt;&gt; from logics.classes.propositional.semantics import MixedMetainferentialSemantics&gt;&gt;&gt; TSST = MixedMetainferentialSemantics([TS, ST])&gt;&gt;&gt; TSST.is_locally_valid(classical_parser.parse('(A / B), (B / C) // (A / C)'))TrueAs in `TAUT &lt;https://taut-logic.com/&gt;`_, logics has natural deduction module:&gt;&gt;&gt; # You can define your own natural deduction system, here we will just import a predefined instance:&gt;&gt;&gt; from logics.instances.propositional.natural_deduction import classical_natural_deduction_system&gt;&gt;&gt; from logics.utils.solvers import classical_natural_deduction_solver&gt;&gt;&gt; derivation = classical_natural_deduction_solver.solve(classical_parser.parse(&quot;A → B, ~B / ~A&quot;))&gt;&gt;&gt; derivation.print_derivation(classical_parser)0. A → B; premise; []1. ~B; premise; []|  2. A; supposition; []|  3. B; E→; [0, 2]|  4. ⊥; E~; [1, 3]5. ~A; I~; [2, 4]&gt;&gt;&gt; classical_natural_deduction_system.is_correct_derivation(derivation)True&gt;&gt;&gt; # Also in first order!&gt;&gt;&gt; from logics.utils.parsers import classical_predicate_parser&gt;&gt;&gt; from logics.utils.solvers.first_order_natural_deduction import first_order_natural_deduction_solver&gt;&gt;&gt; derivation = first_order_natural_deduction_solver.solve(classical_predicate_parser.parse('~∃x P(x) / ∀x ~P(x)'))&gt;&gt;&gt; derivation.print_derivation(classical_predicate_parser)0. ~∃x P(x); premise; []|  1. P(a); supposition; []|  2. ∃x P(x); I∃; [1]|  3. ⊥; E~; [0, 2]4. ~P(a); I~; [1, 3]5. ∀x ~P(x); I∀; [4]I have now added tableaux systems:&gt;&gt;&gt; from logics.classes.propositional.proof_theories import TableauxNode&gt;&gt;&gt; # Again, you can define your own tableaux system, here I use a predefined instance&gt;&gt;&gt; from logics.instances.propositional.tableaux import classical_tableaux_system&gt;&gt;&gt; n1 = TableauxNode(content=classical_parser.parse('~~~~p'))&gt;&gt;&gt; n2 = TableauxNode(content=classical_parser.parse('~p'), parent=n1)&gt;&gt;&gt; n3 = TableauxNode(content=classical_parser.parse('~~p'), justification='R~~', parent=n2)&gt;&gt;&gt; n1.print_tree(classical_parser)(~~~p)└── ~p    └── ~~p (R~~)&gt;&gt;&gt; classical_tableaux_system.node_is_closed(n2)False&gt;&gt;&gt; classical_tableaux_system.tree_is_closed(n1)True&gt;&gt;&gt; classical_tableaux_system.rule_is_applicable(n1, 'R~~')True&gt;&gt;&gt; classical_tableaux_system.is_correct_tree(n1)True&gt;&gt;&gt; # The tableaux solver (unlike ND one) will work for any arbitrary system you define&gt;&gt;&gt; tree = classical_tableaux_system.solve_tree(classical_parser.parse(&quot;~(p ∧ q) / ~p ∨ ~q&quot;))&gt;&gt;&gt; tree.print_tree(classical_parser)~(p ∧ q)└── ~(~p ∨ ~q)    ├── ~p (R~∧)    │   └── ~~p (R~∨)    │       └── ~~q (R~∨)    └── ~q (R~∧)        └── ~~p (R~∨)            └── ~~q (R~∨)&gt;&gt;&gt; # There is even a tableaux class for indexed tableaux, here is a predefined instance&gt;&gt;&gt; from logics.instances.propositional.tableaux import LP_tableaux_system&gt;&gt;&gt; tree2 = LP_tableaux_system.solve_tree(classical_parser.parse(&quot;~(p ∨ q) / ~~p ∧ ~~q&quot;))&gt;&gt;&gt; tree2.print_tree(classical_parser)~(p ∨ q), 1└── ~~p ∧ ~~q, 0    └── ~p ∧ ~q, 1 (R~∨1)        ├── ~~p, 0 (R∧0)        │   └── ~p, 1 (R∧1)        │       └── ~q, 1 (R∧1)        │           └── p, 0 (R~~0)        └── ~~q, 0 (R∧0)            └── ~p, 1 (R∧1)                └── ~q, 1 (R∧1)                    └── q, 0 (R~~0)And sequent calculi:&gt;&gt;&gt; sequent = classical_parser.parse(&quot;Gamma, A ==&gt; B, Delta&quot;)&gt;&gt;&gt; classical_parser.unparse(sequent)'Γ, A ⇒ B, Δ'&gt;&gt;&gt; sequent2 = sequent.substitute(language, &quot;Γ&quot;, classical_parser.parse(&quot;D&quot;))&gt;&gt;&gt; classical_parser.unparse(sequent2)'D, A ⇒ B, Δ'&gt;&gt;&gt; # Again, you can define your sequent calculus, here I use a predefined instance&gt;&gt;&gt; from logics.instances.propositional.sequents import LK&gt;&gt;&gt; LK.sequent_is_axiom(classical_parser.parse(&quot;p or q ==&gt; p or q&quot;))True&gt;&gt;&gt; from logics.classes.propositional.proof_theories import SequentNode&gt;&gt;&gt; n1 = SequentNode(content=classical_parser.parse('A ==&gt; A'), justification='identity')&gt;&gt;&gt; n2 = SequentNode(content=classical_parser.parse('A ==&gt; A, Delta'), justification='WR', children=[n1])&gt;&gt;&gt; n3 = SequentNode(content=classical_parser.parse('Gamma, A ==&gt; A, Delta'), justification='WL', children=[n2])&gt;&gt;&gt; n3.print_tree(classical_parser)  # the root of the tree is the derived nodeΓ, A ⇒ A, Δ (WL)└── A ⇒ A, Δ (WR)    └── A ⇒ A (identity)&gt;&gt;&gt; LK.is_correct_tree(n1)True&gt;&gt;&gt; LK.tree_is_closed(n3)True&gt;&gt;&gt; # There is also a solver that will work whenever your system has no elimination rules&gt;&gt;&gt; # A system that the solver can work with easily, see the docs for a description&gt;&gt;&gt; from logics.instances.propositional.sequents import LKminEA&gt;&gt;&gt; tree = LKminEA.reduce(classical_parser.parse(&quot;Gamma ==&gt; A or ~A&quot;))&gt;&gt;&gt; tree.print_tree(classical_parser)Γ ⇒ A ∨ ~A (∨R1)└── Γ ⇒ A, ~A (~R)    └── Γ, A ⇒ A (WL)        └── A ⇒ A (identity)There are also some predicate logic tools:&gt;&gt;&gt; from logics.classes.predicate.semantics import Model&gt;&gt;&gt; model = Model({...     'domain': {1, 2},...     'a': 1,...     'b': 2,...     'P': {1},...     'R': {(1,1), (1,2)},...     'f': {((1,), 2), ((2,), 1)},...     'g': {((1, 1), 1), ((1, 2), 2), ((2, 1), 1), ((2, 2), 2)}... })&gt;&gt;&gt; model.denotation('f'){((2,), 1), ((1,), 1)}&gt;&gt;&gt; # Again, predefined instance, you can define this yourself&gt;&gt;&gt; from logics.instances.predicate.model_semantics import classical_functional_model_semantics&gt;&gt;&gt; classical_functional_model_semantics.valuation(parser.parse(&quot;P(a)&quot;), model)'1'&gt;&gt;&gt; classical_functional_model_semantics.valuation(parser.parse(&quot;R(a, b)&quot;), model)'1'&gt;&gt;&gt; classical_functional_model_semantics.valuation(parser.parse(&quot;R(f(a), g(f(a), b))&quot;), model)'0'&gt;&gt;&gt; classical_functional_model_semantics.valuation(parser.parse(&quot;exists x (P(f(x)))&quot;), model)'1'&gt;&gt;&gt; classical_functional_model_semantics.valuation(parser.parse(&quot;forall X (exists x (X(f(x))))&quot;), model)'0'&gt;&gt;&gt; # You can also define theories with fixed denotations for some terms by subclassing Model&gt;&gt;&gt; from itertools import count&gt;&gt;&gt; from logics.instances.predicate.model_subclasses import ArithmeticModel&gt;&gt;&gt; from logics.utils.parsers.predicate_parser import arithmetic_parser&gt;&gt;&gt; from logics.instances.predicate.model_semantics import arithmetic_model_semantics&gt;&gt;&gt; arithmetic_model = ArithmeticModel({'domain': count(0)})&gt;&gt;&gt; arithmetic_model_semantics.valuation(arithmetic_parser.parse(&quot;s(0) &gt; 0&quot;), arithmetic_model)'1'&gt;&gt;&gt; arithmetic_model_semantics.valuation(arithmetic_parser.parse(&quot;s(0) + s(0) = s(s(0))&quot;), arithmetic_model)'1'&gt;&gt;&gt; arithmetic_model_semantics.valuation(arithmetic_parser.parse(&quot;exists x (x = s(0))&quot;), arithmetic_model)'1'And many more things! (see the documentation)Acknowledgements################`logics` is a project by `Ariel Jonathan Roffé &lt;https://sites.google.com/view/ariel-roffe/home&gt;`_ (CONICET / Universityof Buenos Aires)Contributors to the project:* `Joaquin S. Toranzo Calderon &lt;https://uba.academia.edu/JoaquinToranzoCalderon&gt;`_ (`mapped_logics` module)The author also wishes to thank the `Buenos Aires Logic Group &lt;https://www.ba-logic.com/&gt;`_ who supported this project.</longdescription>
</pkgmetadata>