<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># BigQuery Schema Generator[![BigQuery Schema Generator CI](https://github.com/bxparks/bigquery-schema-generator/actions/workflows/pythonpackage.yml/badge.svg)](https://github.com/bxparks/bigquery-schema-generator/actions/workflows/pythonpackage.yml)This script generates the BigQuery schema from the newline-delimited datarecords on the STDIN. The records can be in JSON format or CSV format. TheBigQuery data importer (`bq load`) uses only the[first 500 records](https://cloud.google.com/bigquery/docs/schema-detect)when the schema auto-detection feature is enabled. In contrast, this script usesall data records to generate the schema.Usage:```$ generate-schema &lt; file.data.json &gt; file.schema.json$ generate-schema --input_format csv &lt; file.data.csv &gt; file.schema.json```**Version**: 1.5.1 (2022-12-04)**Changelog**: [CHANGELOG.md](CHANGELOG.md)## Table of Contents* [Background](#Background)* [Installation](#Installation)    * [Ubuntu Linux](#UbuntuLinux)    * [MacOS](#MacOS)        * [MacOS 11 (Big Sur)](#MacOS11)        * [MacOS 10.14 (Mojave)](#MacOS1014)* [Usage](#Usage)    * [Command Line](#CommandLine)    * [Schema Output](#SchemaOutput)    * [Command Line Flag Options](#FlagOptions)        * [Help (`--help`)](#Help)        * [Input Format (`--input_format`)](#InputFormat)        * [Keep Nulls (`--keep_nulls`)](#KeepNulls)        * [Quoted Values Are Strings(`--quoted_values_are_strings`)](#QuotedValuesAreStrings)        * [Infer Mode (`--infer_mode`)](#InferMode)        * [Debugging Interval (`--debugging_interval`)](#DebuggingInterval)        * [Debugging Map (`--debugging_map`)](#DebuggingMap)        * [Sanitize Names (`--sanitize_names`)](#SanitizedNames)        * [Ignore Invalid Lines (`--ignore_invalid_lines`)](#IgnoreInvalidLines)        * [Existing Schema Path (`--existing_schema_path`)](#ExistingSchemaPath)        * [Preserve Input Sort Order          (`--preserve_input_sort_order`)](#PreserveInputSortOrder)    * [Using as a Library](#UsingAsLibrary)        * [`SchemaGenerator.run()`](#SchemaGeneratorRun)        * [`SchemaGenerator.deduce_schema()` with File](#SchemaGeneratorDeduceSchemaFromFile)        * [`SchemaGenerator.deduce_schema()` with Dict](#SchemaGeneratorDeduceSchemaFromDict)* [Schema Types](#SchemaTypes)    * [Supported Types](#SupportedTypes)    * [Type Inference](#TypeInference)* [Examples](#Examples)* [Benchmarks](#Benchmarks)* [System Requirements](#SystemRequirements)* [License](#License)* [Feedback and Support](#Feedback)* [Authors](#Authors)&lt;a name=&quot;Background&quot;&gt;&lt;/a&gt;## BackgroundData can be imported into [BigQuery](https://cloud.google.com/bigquery/) usingthe [bq](https://cloud.google.com/bigquery/bq-command-line-tool) command linetool. It accepts a number of data formats including CSV or newline-delimitedJSON. The data can be loaded into an existing table or a new table can becreated during the loading process. The structure of the table is defined byits [schema](https://cloud.google.com/bigquery/docs/schemas). The table'sschema can be defined manually or the schema can be[auto-detected](https://cloud.google.com/bigquery/docs/schema-detect#auto-detect).When the auto-detect feature is used, the BigQuery data importer examines onlythe [first 500 records](https://cloud.google.com/bigquery/docs/schema-detect)of the input data. In many cases, this is sufficientbecause the data records were dumped from another database and the exact schemaof the source table was known. However, for data extracted from a service(e.g. using a REST API) the record fields could have been organically addedat later dates. In this case, the first 100 records do not contain fields whichare present in later records. The **bq load** auto-detection fails and the datafails to load.The **bq load** tool does not support the ability to process the entire datasetto determine a more accurate schema. This script fills in that gap. Itprocesses the entire dataset given in the STDIN and outputs the BigQuery schemain JSON format on the STDOUT. This schema file can be fed back into the **bqload** tool to create a table that is more compatible with the data fields inthe input dataset.&lt;a name=&quot;Installation&quot;&gt;&lt;/a&gt;## Installation**Prerequisite**: You need have Python 3.6 or higher.Install from [PyPI](https://pypi.python.org/pypi) repository using `pip3`. Thereare too many ways to install packages in Python. The following are in orderhighest to lowest recommendation:1) If you are using a virtual environment (such as[venv](https://docs.python.org/3/library/venv.html)), then use:```$ pip3 install bigquery_schema_generator```2) If you aren't using a virtual environment you can install intoyour local Python directory:```$ pip3 install --user bigquery_schema_generator```3) If you want to install the package for your entire system globally, use```$ sudo -H pip3 install bigquery_schema_generator```but realize that you will be running code from PyPI as `root` so this hassecurity implications.Sometimes, your Python environment gets into a complete mess and the `pip3`command won't work. Try typing `python3 -m pip` instead.A successful install should print out something like the following (the versionnumber may be different):```Collecting bigquery-schema-generatorInstalling collected packages: bigquery-schema-generatorSuccessfully installed bigquery-schema-generator-1.1```The shell script `generate-schema` will be installed somewhere in your system,depending on how your Python environment is configured. See below forsome notes for Ubuntu Linux and MacOS.&lt;a name=&quot;UbuntuLinux&quot;&gt;&lt;/a&gt;### Ubuntu Linux (18.04, 20.04, 22.04)After running `pip3 install bigquery_schema_generator`, the `generate-schema`script may be installed in one the following locations:* `/usr/bin/generate-schema`* `/usr/local/bin/generate-schema`* `$HOME/.local/bin/generate-schema`* `$HOME/.virtualenvs/{your_virtual_env}/bin/generate-schema`&lt;a name=&quot;MacOS&quot;&gt;&lt;/a&gt;### MacOSI don't have any Macs which are able to run the latest macOS, and I don't usethem much for software development these days, but here are some notes if theyhelp.&lt;a name=&quot;MacOS11&quot;&gt;&lt;/a&gt;#### MacOS 11 (Big Sur)I believe Big Sur comes preinstalled with Python 3.8. If you install`bigquery_schema_generator` using:```$ pip3 install --user bigquery_schema_generator```then the `generate-schema` wrapper script will be installed at:```/User/{your-login}/Library/Python/3.8/bin/generate-schema```&lt;a name=&quot;MacOS1014&quot;&gt;&lt;/a&gt;#### MacOS 10.14 (Mojave)This MacOS version comes with Python 2.7 only. To install Python 3, you caninstall using:1)) Downloading the [macos installer directly from   Python.org](https://www.python.org/downloads/macos/).The python3 binary will be located at `/usr/local/bin/python3`, and the`/usr/local/bin/pip3` is a symlink to`/Library/Frameworks/Python.framework/Versions/3.6/bin/pip3`.So running```$ pip3 install --user bigquery_schema_generator```will install `generate-schema` at`/Library/Frameworks/Python.framework/Versions/3.6/bin/generate-schema`.The Python installer updates `$HOME/.bash_profile` to add`/Library/Frameworks/Python.framework/Versions/3.6/bin` to the `$PATH`environment variable. So you should be able to run the `generate-schema`command without typing in the full path.2)) Using [Homebrew](https://docs.brew.sh/Homebrew-and-Python).In this environment, the `generate-schema` script will probably be installed in`/usr/local/bin` but I'm not completely certain.&lt;a name=&quot;Usage&quot;&gt;&lt;/a&gt;## Usage&lt;a name=&quot;CommandLine&quot;&gt;&lt;/a&gt;### Command LineThe `generate_schema.py` script accepts a newline-delimited JSON orCSV data file on the STDIN. JSON input format has been tested extensively.CSV input format was added more recently (in v0.4) using the `--input_formatcsv` flag. The support is not as robust as JSON file. For example, CSV formatsupports only the comma-separator, and does not support the pipe (`|`) or tab(`\t`) character.Unlike `bq load`, the `generate_schema.py` script reads every record in theinput data file to deduce the table's schema. It prints the JSON formattedschema file on the STDOUT.There are at least 3 ways to run this script:**1) Shell script**If you installed using `pip3`, then it should have installed a small helperscript named `generate-schema` in your local `./bin` directory of your currentenvironment (depending on whether you are using a virtual environment).```$ generate-schema &lt; file.data.json &gt; file.schema.json```**2) Python module**You can invoke the module directly using:```$ python3 -m bigquery_schema_generator.generate_schema &lt; file.data.json &gt; file.schema.json```This is essentially what the `generate-schema` command does.**3) Python script**If you retrieved this code from its[GitHub repository](https://github.com/bxparks/bigquery-schema-generator),then you can invoke the Python script directly:```$ ./generate_schema.py &lt; file.data.json &gt; file.schema.json```&lt;a name=&quot;SchemaOutput&quot;&gt;&lt;/a&gt;### Using the Schema OutputThe resulting schema file can be given to the **bq load** command using the`--schema` flag:```$ bq load --source_format NEWLINE_DELIMITED_JSON \    --ignore_unknown_values \    --schema file.schema.json \    mydataset.mytable \    file.data.json```where `mydataset.mytable` is the target table in BigQuery.For debugging purposes, here is the equivalent `bq load` command using schemaautodetection:```$ bq load --source_format NEWLINE_DELIMITED_JSON \    --autodetect \    mydataset.mytable \    file.data.json```If the input file is in CSV format, the first line will be the header line whichenumerates the names of the columns. But this header line must be skipped whenimporting the file into the BigQuery table. We accomplish this using`--skip_leading_rows` flag:```$ bq load --source_format CSV \    --schema file.schema.json \    --skip_leading_rows 1 \    mydataset.mytable \    file.data.csv```Here is the equivalent `bq load` command for CSV files using autodetection:```$ bq load --source_format CSV \    --autodetect \    mydataset.mytable \    file.data.csv```A useful flag for `bq load`, particularly for JSON files,  is`--ignore_unknown_values`, which causes `bq load` to ignore fields in the inputdata which are not defined in the schema. When `generate_schema.py` detects aninconsistency in the definition of a particular field in the input data, itremoves the field from the schema definition. Without the`--ignore_unknown_values`, the `bq load` fails when the inconsistent data recordis read.Another useful flag during development and debugging is `--replace` whichreplaces any existing BigQuery table.After the BigQuery table is loaded, the schema can be retrieved using:```$ bq show --schema mydataset.mytable | python3 -m json.tool```(The `python -m json.tool` command will pretty-print the JSON formatted schemafile. An alternative is the [jq command](https://stedolan.github.io/jq/).)The resulting schema file should be identical to `file.schema.json`.&lt;a name=&quot;FlagOptions&quot;&gt;&lt;/a&gt;### Command Line Flag OptionsThe `generate_schema.py` script supports a handful of command line flagsas shown by the `--help` flag below.&lt;a name=&quot;Help&quot;&gt;&lt;/a&gt;#### Help (`--help`)Print the built-in help strings:```bash$ generate-schema --helpusage: generate-schema [-h] [--input_format INPUT_FORMAT] [--keep_nulls]                       [--quoted_values_are_strings] [--infer_mode]                       [--debugging_interval DEBUGGING_INTERVAL]                       [--debugging_map] [--sanitize_names]                       [--ignore_invalid_lines]                       [--existing_schema_path EXISTING_SCHEMA_PATH]                       [--preserve_input_sort_order]Generate BigQuery schema from JSON or CSV file.optional arguments:  -h, --help            show this help message and exit  --input_format INPUT_FORMAT                        Specify an alternative input format ('csv', 'json',                        'dict')  --keep_nulls          Print the schema for null values, empty arrays or                        empty records  --quoted_values_are_strings                        Quoted values should be interpreted as strings  --infer_mode          Determine if mode can be 'NULLABLE' or 'REQUIRED'  --debugging_interval DEBUGGING_INTERVAL                        Number of lines between heartbeat debugging messages  --debugging_map       Print the metadata schema_map instead of the schema  --sanitize_names      Forces schema name to comply with BigQuery naming                        standard  --ignore_invalid_lines                        Ignore lines that cannot be parsed instead of stopping  --existing_schema_path EXISTING_SCHEMA_PATH                        File that contains the existing BigQuery schema for a                        table. This can be fetched with: `bq show --schema                        &lt;project_id&gt;:&lt;dataset&gt;:&lt;table_name&gt;  --preserve_input_sort_order                        Preserve the original ordering of columns from input                        instead of sorting alphabetically. This only impacts                        `input_format` of json or dict```&lt;a name=&quot;InputFormat&quot;&gt;&lt;/a&gt;#### Input Format (`--input_format`)Specifies the format of the input file as a string. It must be one of `json`(default), `csv`, or `dict`:* `json`    * a &quot;file-like&quot; object containing newline-delimited JSON* `csv`    * a &quot;file-like&quot; object containing newline-delimited CSV* `dict`    * a `list` of Python `dict` objects corresponding to list of      newline-delimited JSON, in other words `List[Dict[str, Any]]`    * applies only if `SchemaGenerator` is used as a library through the      `run()` or `deduce_schema()` method    * useful if the input data (usually JSON) has already been read into memory      and parsed from newline-delimited JSON into native Python dict objects.If `csv` file is specified, the `--keep_nulls` flag is automatically activated.This is required because CSV columns are defined positionally, so the schemafile must contain all the columns specified by the CSV file, in the sameorder, even if the column contains an empty value for every record.See [Issue #26](https://github.com/bxparks/bigquery-schema-generator/issues/26)for implementation details.&lt;a name=&quot;KeepNulls&quot;&gt;&lt;/a&gt;#### Keep Nulls (`--keep_nulls`)Normally when the input data file contains a field which has a null, emptyarray or empty record as its value, the field is suppressed in the schema file.This flag enables this field to be included in the schema file.In other words, using a data file containing just nulls and empty values:```bash$ generate_schema{ &quot;s&quot;: null, &quot;a&quot;: [], &quot;m&quot;: {} }^DINFO:root:Processed 1 lines[]```With the `keep_nulls` flag, we get:```bash$ generate-schema --keep_nulls{ &quot;s&quot;: null, &quot;a&quot;: [], &quot;m&quot;: {} }^DINFO:root:Processed 1 lines[  {    &quot;mode&quot;: &quot;REPEATED&quot;,    &quot;type&quot;: &quot;STRING&quot;,    &quot;name&quot;: &quot;a&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;fields&quot;: [      {        &quot;mode&quot;: &quot;NULLABLE&quot;,        &quot;type&quot;: &quot;STRING&quot;,        &quot;name&quot;: &quot;__unknown__&quot;      }    ],    &quot;type&quot;: &quot;RECORD&quot;,    &quot;name&quot;: &quot;d&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;type&quot;: &quot;STRING&quot;,    &quot;name&quot;: &quot;s&quot;  }]```&lt;a name=&quot;QuotedValuesAreStrings&quot;&gt;&lt;/a&gt;#### Quoted Values Are Strings (`--quoted_values_are_strings`)By default, quoted values are inspected to determine if they can be interpretedas `DATE`, `TIME`, `TIMESTAMP`, `BOOLEAN`, `INTEGER` or `FLOAT`. This isconsistent with the algorithm used by `bq load`. However, for the `BOOLEAN`,`INTEGER`, or `FLOAT` types, it is sometimes more useful to interpret those asnormal strings instead. This flag disables type inference for `BOOLEAN`,`INTEGER` and `FLOAT` types inside quoted strings.```bash$ generate-schema{ &quot;name&quot;: &quot;1&quot; }^D[  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;name&quot;,    &quot;type&quot;: &quot;INTEGER&quot;  }]$ generate-schema --quoted_values_are_strings{ &quot;name&quot;: &quot;1&quot; }^D[  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;name&quot;,    &quot;type&quot;: &quot;STRING&quot;  }]```&lt;a name=&quot;InferMode&quot;&gt;&lt;/a&gt;#### Infer Mode (`--infer_mode`)Set the schema `mode` of a field to `REQUIRED` instead of the default`NULLABLE` if the field contains a non-null or non-empty value for every datarecord in the input file. This option is available only for CSV(`--input_format csv`) files. It is theoretically possible to implement thisfeature for JSON files, but too difficult to implement in practice becausefields are often completely missing from a given JSON record (instead ofexplicitly being defined to be `null`).In addition to the above, this option, when used in conjunction with`--existing_schema_map`, will allow fields to be relaxed from REQUIRED toNULLABLE if they were REQUIRED in the existing schema and NULL rows are found inthe new data we are inferring a schema from. In this case it can be used witheither input_format, CSV or JSON.See [Issue #28](https://github.com/bxparks/bigquery-schema-generator/issues/28)for implementation details.&lt;a name=&quot;DebuggingInterval&quot;&gt;&lt;/a&gt;#### Debugging Interval (`--debugging_interval`)By default, the `generate_schema.py` script prints a short progress messageevery 1000 lines of input data. This interval can be changed using the`--debugging_interval` flag.```bash$ generate-schema --debugging_interval 50 &lt; file.data.json &gt; file.schema.json```&lt;a name=&quot;DebuggingMap&quot;&gt;&lt;/a&gt;#### Debugging Map (`--debugging_map`)Instead of printing out the BigQuery schema, the `--debugging_map` prints outthe bookkeeping metadata map which is used internally to keep track of thevarious fields and their types that were inferred using the data file. Thisflag is intended to be used for debugging.```bash$ generate-schema --debugging_map &lt; file.data.json &gt; file.schema.json```&lt;a name=&quot;SanitizedNames&quot;&gt;&lt;/a&gt;#### Sanitize Names (`--sanitize_names`)BigQuery column names are [restricted to certain characters andlength](https://cloud.google.com/bigquery/docs/schemas#column_names):* it must contain only letters (a-z, A-Z), numbers (0-9), or underscores* it must start with a letter or underscore* the maximum length is 128 characters* column names are case-insensitiveFor CSV files, the `bq load` command seems to automatically convert invalidcolumn names into valid column names. This flag attempts to perform some of thesame transformations, to avoid having to scan through the input data twice togenerate the schema file. The transformations are:* any character outside of ASCII letters, numbers and underscore  (`[a-zA-Z0-9_]`) are converted to an underscore. For example `go&amp;2#there!` is  converted to `go_2_there_`;* names longer than 128 characters are truncated to 128.My recollection is that the `bq load` command does *not* normalize the JSON keynames. Instead it prints an error message. So the `--sanitize_names` flag isuseful mostly for CSV files. For JSON files, you'll have to do a second passthrough the data files to cleanup the column names anyway. See[Issue #14](https://github.com/bxparks/bigquery-schema-generator/issues/14) and[Issue #33](https://github.com/bxparks/bigquery-schema-generator/issues/33).&lt;a name=&quot;IgnoreInvalidLines&quot;&gt;&lt;/a&gt;#### Ignore Invalid Lines (`--ignore_invalid_lines`)By default, if an error is encountered on a particular line, processing stopsimmediately with an exception. This flag causes invalid lines to be ignored andprocessing continues. A list of all errors and their line numbers will beprinted on the STDERR after processing the entire file.This flag is currently most useful for JSON files, to ignore lines which do notparse correctly as a JSON object.This flag is probably not useful for CSV files. CSV files are processed by the`DictReader` class which performs its own line processing internally, includingextracting the column names from the first line of the file. If the `DictReader`does throw an exception on a given line, we would not be able to catch it andcontinue processing. Fortunately, CSV files are fairly robust, and the schemadeduction logic will handle any missing or extra columns gracefully.Fixes[Issue #49](https://github.com/bxparks/bigquery-schema-generator/issues/49).&lt;a name=&quot;ExistingSchemaPath&quot;&gt;&lt;/a&gt;#### Existing Schema Path (`--existing_schema_path`)There are cases where we would like to start from an existing BigQuery tableschema rather than starting from scratch with a new batch of data we would liketo load. In this case we can specify the path to a local file on disk that isour existing bigquery table schema. This can be generated via the following `bqshow --schema` command:```bashbq show --schema &lt;PROJECT_ID&gt;:&lt;DATASET_NAME&gt;.&lt;TABLE_NAME&gt; &gt; existing_table_schema.json```We can then run generate-schema with the additional option```bash--existing_schema_path existing_table_schema.json```There is some subtle interaction between the `--existing_schema_path` and fieldswhich are marked with a `mode` of `REQUIRED` in the existing schema. If the newdata contains a `null` value (either in a CSV or JSON data file), it is notclear if the schema should be changed to `mode=NULLABLE` or whether the new datashould be ignored and the schema should remain `mode=REQUIRED`. The choice isdetermined by overloading the `--infer_mode` flag:* If `--infer_mode` is given, the new schema will be allowed to revert back to  `NULLABLE`.* If `--infer_mode` is not given, the offending new record will be ignored  and the new schema will remain `REQUIRED`.See discussion in[PR #57](https://github.com/bxparks/bigquery-schema-generator/pull/57) formore details.&lt;a name=&quot;PreserveInputSortOrder&quot;&gt;&lt;/a&gt;#### Preserve Input Sort Order (`--preserve_input_sort_order`)By default, the order of columns in the BQ schema file is sortedlexicographically, which matched the original behavior of `bq load--autodetect`. If the `--preserve_input_sort_order` flag is given, the columnsin the resulting schema file is not sorted, but preserves the order ofappearance in the input JSON data. For example, the following JSON data withthe `--preserve_input_sort_order` flag will produce:```bash$ generate-schema --preserve_input_sort_order{ &quot;s&quot;: &quot;string&quot;, &quot;i&quot;: 3, &quot;x&quot;: 3.2, &quot;b&quot;: true }^D[  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;s&quot;,    &quot;type&quot;: &quot;STRING&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;i&quot;,    &quot;type&quot;: &quot;INTEGER&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;x&quot;,    &quot;type&quot;: &quot;FLOAT&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;b&quot;,    &quot;type&quot;: &quot;BOOLEAN&quot;  }]```It is possible that each JSON record line contains only a partial subset of thetotal possible columns in the data set. The order of the columns in the BQschema will then be the order that each column was first *seen* by thescript:```bash$ generate-schema --preserve_input_sort_order{ &quot;s&quot;: &quot;string&quot;, &quot;i&quot;: 3 }{ &quot;x&quot;: 3.2, &quot;s&quot;: &quot;string&quot;, &quot;i&quot;: 3 }{ &quot;b&quot;: true, &quot;x&quot;: 3.2, &quot;s&quot;: &quot;string&quot;, &quot;i&quot;: 3 }^D[  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;s&quot;,    &quot;type&quot;: &quot;STRING&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;i&quot;,    &quot;type&quot;: &quot;INTEGER&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;x&quot;,    &quot;type&quot;: &quot;FLOAT&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;b&quot;,    &quot;type&quot;: &quot;BOOLEAN&quot;  }]```**Note**: In Python 3.6 (the earliest version of Python supported by thisproject), the order of keys in a `dict` was the insertion-order, but thisordering was an implementation detail, and not guaranteed. In Python 3.7, thatordering was made permanent. So the `--preserve_input_sort_order` flag**should** work in Python 3.6 but is not guaranteed.See discussion in[PR #75](https://github.com/bxparks/bigquery-schema-generator/pull/75) formore details.&lt;a name=&quot;UsingAsLibrary&quot;&gt;&lt;/a&gt;### Using As a LibraryThe `SchemaGenerator` class can be used programmatically as a library from alarger Python application.&lt;a name=&quot;SchemaGeneratorRun&quot;&gt;&lt;/a&gt;#### `SchemaGenerator.run()`The `bigquery_schema_generator` module can be used as a library by an externalPython client code by creating an instance of `SchemaGenerator` and calling the`run(input, output)` method:```pythonfrom bigquery_schema_generator.generate_schema import SchemaGeneratorgenerator = SchemaGenerator(    input_format=input_format,    infer_mode=infer_mode,    keep_nulls=keep_nulls,    quoted_values_are_strings=quoted_values_are_strings,    debugging_interval=debugging_interval,    debugging_map=debugging_map,    sanitize_names=sanitize_names,    ignore_invalid_lines=ignore_invalid_lines,    preserve_input_sort_order=preserve_input_sort_order,)FILENAME = &quot;...&quot;with open(FILENAME) as input_file:    generator.run(input_file=input_file, output_file=output_file)```The `input_format` is one of `json`, `csv`, and `dict` as described in the[Input Format](#InputFormat) section above. The `input_file` must match theformat given by this parameter.See [generatorrun.py](examples/generatorrun.py) for an example.&lt;a name=&quot;SchemaGeneratorDeduceSchemaFromFile&quot;&gt;&lt;/a&gt;#### `SchemaGenerator.deduce_schema()` from FileIf you need to process the generated schema programmatically, use the`deduce_schema()` method and process the resulting `schema_map` and `error_log`data structures like this:```pythonimport jsonimport loggingimport sysfrom bigquery_schema_generator.generate_schema import SchemaGeneratorFILENAME = &quot;jsonfile.json&quot;generator = SchemaGenerator(    input_format='json',    quoted_values_are_strings=True,)with open(FILENAME) as file:    schema_map, errors = generator.deduce_schema(file)schema_map, error_logs = generator.deduce_schema(input_data=input_data)for error in error_logs:    logging.info(&quot;Problem on line %s: %s&quot;, error['line_number'], error['msg'])schema = generator.flatten_schema(schema_map)json.dump(schema, sys.stdout, indent=2)print()```See [csvreader.py](examples/csvreader.py) and[jsoneader.py](examples/jsoneader.py) for 2 examples.The `deduce_schema()` also supports starting from an existing `schema_map`instead of starting from scratch. This is the internal version of the`--existing_schema_path` functionality.```pythonschema_map1, error_logs = generator.deduce_schema(input_data=data1)schema_map2, error_logs = generator.deduce_schema(    input_data=data1, schema_map=schema_map1)```The `input_data` must match the `input_format` given in the constructor. Theformat is described in the [Input Format](#InputFormat) section above.&lt;a name=&quot;SchemaGeneratorDeduceSchemaFromDict&quot;&gt;&lt;/a&gt;#### `SchemaGenerator.deduce_schema()` from DictIf the JSON data set has already been read into memory into a Python `dict`object, the `SchemaGenerator` can process that too like this:```Pythonimport jsonimport loggingimport sysfrom bigquery_schema_generator.generate_schema import SchemaGeneratorgenerator = SchemaGenerator(input_format='dict')input_data = [    {        's': 'string',        'b': True,    },    {        'd': '2021-08-18',        'x': 3.1    },]schema_map, error_logs = generator.deduce_schema(input_data)schema = generator.flatten_schema(schema_map)json.dump(schema, sys.stdout, indent=2)print()```See [dictreader.py](examples/dictreader.py) for an example.&lt;a name=&quot;SchemaTypes&quot;&gt;&lt;/a&gt;## Schema Types&lt;a name=&quot;SupportedTypes&quot;&gt;&lt;/a&gt;### Supported TypesThe `bq show --schema` command produces a JSON schema file that uses theolder [Legacy SQL date types](https://cloud.google.com/bigquery/data-types).For compatibility, **generate-schema** script will also generate a schema fileusing the legacy data types.The supported types are:* `BOOLEAN`* `INTEGER`* `FLOAT`* `STRING`* `TIMESTAMP`* `DATE`* `TIME`* `RECORD`The `generate-schema` script supports both `NULLABLE` and `REPEATED` modes ofall of the above types.The supported format of `TIMESTAMP` is as close as practical to the[bq load format](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#timestamp-type):```YYYY-[M]M-[D]D[( |T)[H]H:[M]M:[S]S[.DDDDDD]][time zone]```which appears to be an extension of the[ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601).The difference from `bq load` is that the `[time zone]` component can be only* `Z`* `UTC` (same as `Z`)* `(+|-)H[H][:M[M]]`Note that BigQuery supports up to 6 decimal places after the integer 'second'component. `generate-schema` follows the same restriction for compatibility. Ifyour input file contains more than 6 decimal places, you need to write a datacleansing filter to fix this.The suffix `UTC` is not standard ISO 8601 nor[documented by Google](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#time-zones)but the `UTC` suffix is used by `bq extract` and the web interface. (See[Issue 19](https://github.com/bxparks/bigquery-schema-generator/issues/19).)Timezone names from the [tz database](http://www.iana.org/time-zones) (e.g.&quot;America/Los_Angeles&quot;) are _not_ supported by `generate-schema`.The following types are _not_ supported at all:* `BYTES`* `DATETIME` (unable to distinguish from `TIMESTAMP`)&lt;a name=&quot;TypeInference&quot;&gt;&lt;/a&gt;### Type Inference RulesThe `generate-schema` script attempts to emulate the various type conversion andcompatibility rules implemented by **bq load**:* `INTEGER` can upgrade to `FLOAT`    * if a field in an early record is an `INTEGER`, but a subsequent record      shows this field to have a `FLOAT` value, the type of the field will be      upgraded to a `FLOAT`    * the reverse does not happen, once a field is a `FLOAT`, it will remain a      `FLOAT`* conflicting `TIME`, `DATE`, `TIMESTAMP` types upgrades to `STRING`    * if a field is determined to have one type of &quot;time&quot; in one record, then      subsequently a different &quot;time&quot; type, then the field will be assigned a      `STRING` type* `NULLABLE RECORD` can upgrade to a `REPEATED RECORD`    * a field may be defined as `RECORD` (aka &quot;Struct&quot;) type with `{ ... }`    * if the field is subsequently read as an array with a `[{ ... }]`, the      field is upgraded to a `REPEATED RECORD`* a primitive type (`FLOAT`, `INTEGER`, `STRING`) cannot upgrade to a `REPEATED`  primitive type    * there's no technical reason why this cannot be allowed, but **bq load**      does not support it, so we follow its behavior* a `DATETIME` field is always inferred to be a `TIMESTAMP`    * the format of these two fields is identical (in the absence of timezone)    * we follow the same logic as **bq load** and always infer these as      `TIMESTAMP`* `BOOLEAN`, `INTEGER`, and `FLOAT` can appear inside quoted strings    * In other words, `&quot;true&quot;` (or `&quot;True&quot;` or `&quot;false&quot;`, etc) is considered a      BOOLEAN type, `&quot;1&quot;` is considered an INTEGER type, and `&quot;2.1&quot;` is      considered a FLOAT type. Luigi Mori (jtschichold@) added additional logic      to replicate the type conversion logic used by `bq load` for these      strings.    * This type inference inside quoted strings can be disabled using the      `--quoted_values_are_strings` flag    * (See [Issue #22](https://github.com/bxparks/bigquery-schema-generator/issues/22) for more details.)* `INTEGER` values overflowing a 64-bit signed integer upgrade to `FLOAT`    * integers greater than `2^63-1` (9223372036854775807)    * integers less than `-2^63` (-9223372036854775808)    * (See [Issue #18](https://github.com/bxparks/bigquery-schema-generator/issues/18) for more details)&lt;a name=&quot;Examples&quot;&gt;&lt;/a&gt;## ExamplesHere is an example of a single JSON data record on the STDIN (the `^D` belowmeans typing Control-D, which indicates &quot;end of file&quot; under Linux and MacOS):```bash$ generate-schema{ &quot;s&quot;: &quot;string&quot;, &quot;b&quot;: true, &quot;i&quot;: 1, &quot;x&quot;: 3.1, &quot;t&quot;: &quot;2017-05-22T17:10:00-07:00&quot; }^DINFO:root:Processed 1 lines[  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;b&quot;,    &quot;type&quot;: &quot;BOOLEAN&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;i&quot;,    &quot;type&quot;: &quot;INTEGER&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;s&quot;,    &quot;type&quot;: &quot;STRING&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;t&quot;,    &quot;type&quot;: &quot;TIMESTAMP&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;x&quot;,    &quot;type&quot;: &quot;FLOAT&quot;  }]```In most cases, the data file will be stored in a file:```bash$ cat &gt; file.data.json{ &quot;a&quot;: [1, 2] }{ &quot;i&quot;: 3 }^D$ generate-schema &lt; file.data.json &gt; file.schema.jsonINFO:root:Processed 2 lines$ cat file.schema.json[  {    &quot;mode&quot;: &quot;REPEATED&quot;,    &quot;name&quot;: &quot;a&quot;,    &quot;type&quot;: &quot;INTEGER&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;i&quot;,    &quot;type&quot;: &quot;INTEGER&quot;  }]```Here is the schema generated from a CSV input file. The first line is the headercontaining the names of the columns, and the schema lists the columns in thesame order as the header:```bash$ generate-schema --input_format csve,b,c,d,a1,x,true,,2.02,x,,,43,,,,^DINFO:root:Processed 3 lines[  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;e&quot;,    &quot;type&quot;: &quot;INTEGER&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;b&quot;,    &quot;type&quot;: &quot;STRING&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;c&quot;,    &quot;type&quot;: &quot;BOOLEAN&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;d&quot;,    &quot;type&quot;: &quot;STRING&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;a&quot;,    &quot;type&quot;: &quot;FLOAT&quot;  }]```Here is an example of the schema generated with the `--infer_mode` flag:```bash$ generate-schema --input_format csv --infer_modename,surname,ageJohnMichael,,Maria,Smith,30Joanna,Anders,21^DINFO:root:Processed 4 lines[  {    &quot;mode&quot;: &quot;REQUIRED&quot;,    &quot;name&quot;: &quot;name&quot;,    &quot;type&quot;: &quot;STRING&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;surname&quot;,    &quot;type&quot;: &quot;STRING&quot;  },  {    &quot;mode&quot;: &quot;NULLABLE&quot;,    &quot;name&quot;: &quot;age&quot;,    &quot;type&quot;: &quot;INTEGER&quot;  }]```&lt;a name=&quot;Benchmarks&quot;&gt;&lt;/a&gt;## BenchmarksI wrote the `bigquery_schema_generator/anonymize.py` script to create ananonymized data file `tests/testdata/anon1.data.json.gz`:```bash$ ./bigquery_schema_generator/anonymize.py &lt; original.data.json \    &gt; anon1.data.json$ gzip anon1.data.json```This data file is 290MB (5.6MB compressed) with 103080 data records.Generating the schema using```bash$ bigquery_schema_generator/generate_schema.py &lt; anon1.data.json \    &gt; anon1.schema.json```took 67s on a Dell Precision M4700 laptop with an Intel Core i7-3840QM CPU @2.80GHz, 32GB of RAM, Ubuntu Linux 18.04, Python 3.6.7.&lt;a name=&quot;SystemRequirements&quot;&gt;&lt;/a&gt;## System RequirementsThis project was initially developed on Ubuntu 17.04 using Python 3.5.3, but itnow requires Python 3.6 or higher, I think mostly due to the use of f-strings.I have tested it on:* Ubuntu 22.04, Python 3.10.6* Ubuntu 20.04, Python 3.8.5* Ubuntu 18.04, Python 3.7.7* Ubuntu 18.04, Python 3.6.7* Ubuntu 17.10, Python 3.6.3* MacOS 11.7.1 (Big Sur), Python 3.8.9* MacOS 10.14.2 (Mojave), Python 3.6.4* MacOS 10.13.2 (High Sierra), Python 3.6.4The GitHub Actions continuous integration pipeline validates on Python 3.6, 3.7and 3.8.The unit tests are invoked with `$ make tests` target, and depends only on thebuilt-in Python `unittest` package.The coding style check is invoked using `$ make flake8` and depends on the`flake8` package. It can be installed using `$ pip3 install --user flake8`.&lt;a name=&quot;License&quot;&gt;&lt;/a&gt;## LicenseApache License 2.0&lt;a name=&quot;Feedback&quot;&gt;&lt;/a&gt;## Feedback and SupportIf you have any questions, comments, or feature requests for this library,please use the [GitHubDiscussions](https://github.com/bxparks/bigquery-schema-generator/discussions)for this project. If you have bug reports, please file a ticket in [GitHubIssues](https://github.com/bxparks/bigquery-schema-generator/issues). Featurerequests should go into Discussions first because they often have alternativesolutions which are useful to remain visible, instead of disappearing from thedefault view of the Issue tracker after the ticket is closed.Please refrain from emailing me directly unless the content is sensitive. Theproblem with email is that I cannot reference the email conversation when otherpeople ask similar questions later.&lt;a name=&quot;Authors&quot;&gt;&lt;/a&gt;## Authors* Created by Brian T. Park (brian@xparks.net).* Type inference inside quoted strings by Luigi Mori (jtschichold@).* Flag to disable type inference inside quoted strings by Daniel Ecer  (de-code@).* Support for CSV files and detection of `REQUIRED` fields by Sandor Korotkevics  (korotkevics@).* Better support for using `bigquery_schema_generator` as a library from an  external Python code by StefanoG_ITA (StefanoGITA@).* Sanitizing of column names to valid BigQuery characters and length by Jon  Warghed (jonwarghed@).* Bug fix in `--sanitize_names` by Riccardo M. Cefala (riccardomc@).* Print full path of nested JSON elements in error messages, by Austin Brogle  (abroglesc@).* Allow an existing schema file to be specified using `--existing_schema_path`,  by Austin Brogle (abroglesc@) and Bozo Dragojevic (bozzzzo@).* Allow `SchemaGenerator.deduce_schema()` to accept a list of native Python  `dict` objects, by Zigfrid Zvezdin (ZiggerZZ@).* Make the column order in the BQ schema file match the order of appearance in  the JSON data file using the `--preserve_input_sort_order` flag. By Kevin  Deggelman (kdeggelman@).</longdescription>
</pkgmetadata>