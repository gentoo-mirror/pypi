<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Config File&gt; Simple manipulation of ini, json, yaml, or toml files![Python Version](https://img.shields.io/pypi/pyversions/config-file.svg)[![Version](https://img.shields.io/pypi/v/config-file)](https://pypi.org/project/config-file/)[![Style](https://img.shields.io/badge/code%20style-black-000000.svg)](https://pypi.org/project/black/)[![Build Status](https://github.com/eugenetriguba/config-file/actions/workflows/python-package-ci.yml/badge.svg)](https://github.com/eugenetriguba/config-file/actions/workflows/python-package-ci.yml)[![Codecov](https://codecov.io/gh/eugenetriguba/config-file/graph/badge.svg)](https://codecov.io/gh/eugenetriguba/config-file)## About Config FileThe Config File project is designed to allow you to easily manipulate yourconfiguration files with the same simple API whether they are in INI, JSON,YAML, or TOML.## InstallationConfig File is available to download through PyPI.```bash$ pip install config-file```### Installing ExtrasIf you want to manipulate YAML and TOML, you'll want to download the extras as well.```bash$ pip install config-file[yaml, toml]```You can also use [Poetry](https://python-poetry.org).```bash$ poetry install config-file -E yaml -E toml```## UsageFor this overview, let's say you have the following `ini` fileyou want to manipulate.Do note, however, that the `ini` format is the oddest format that`ConfigFile` supports in that it has no formal specification and isnot type aware. When retrieving items from the file, it will returnthem as strings by default. Others are more type aware and do notrequire as much type coercion.```ini[section]num_key = 5str_key = blahbool_key = truelist_key = [1, 2][second_section]dict_key = { &quot;another_num&quot;: 5 }```It must have a `.ini` extension in orderfor the package to recognize it and use the correct parser for it.### Setting up ConfigFileTo use the package, we import in the `ConfigFile` object. This objectis the only thing considered to be part of the public API.We can set it up by giving it a string or `pathlib.Path` as the argument.Any home tildes `~` in the string or `Path` are recognized and convertedto the full path for us.```pythonfrom config_file import ConfigFileconfig = ConfigFile(&quot;~/some-project/config.ini&quot;)```#### Handling ConfigFile Initialization Errors```pythonfrom config_file import ConfigFile, ParsingErrortry:    config = ConfigFile(&quot;~/some-file.ini&quot;)except ParsingError:    print(&quot;could not parse the file&quot;)except ValueError:    print(&quot;extension that isn't supported was used or is a directory&quot;)except FileNotFoundError:    print(&quot;file does not exist&quot;)```### Using `get()`A recurring pattern you'll see here is that all methods thatneed to specify something inside your configuration file willdo so using a dot syntax.#### Retrieving keys and sectionsSo to retrieve our `num_key`, we'd specify the heading and thekey separated by a dot. All values will then be retrieved asstrings.```pythonconfig.get('section.num_key')&gt;&gt;&gt; '5'```While we can retrieves keys, we can also retrieve the entiresection, which will be returned back to us as a dictionary.```pythonconfig.get('section')&gt;&gt;&gt; {'num_key': '5', 'str_key': 'blah', 'bool_key': 'true', 'list_key': '[1, 2]'}```Furthermore, you can also index into the `ConfigFile` objectto retrieve keys if that is preferred.```pythonconfig['section']['num_key']&gt;&gt;&gt; '5'```#### Coercing the return typesHowever, some of these keys are obviously not strings natively.If we are retrieving a particular value of a key, we may want tocoerce it right away without doing clunky type conversions aftereach time we retrieve a value. To do this, we can utilize the`return_type` keyword argument.```pythonconfig.get('section.num_key', return_type=int)&gt;&gt;&gt; 5```Sometimes we don't have structures quite that simple though. Whatif we wanted all the values in `section` coerced? For that, we canutilize a `parse_types` keyword argument.```pythonconfig.get('section', parse_types=True)&gt;&gt;&gt; {'num_key': 5, 'str_key': 'blah', 'bool_key': True, 'list_key': [1, 2]}```It also works for regular keys.```pythonconfig.get('section.num_key', parse_types=True)&gt;&gt;&gt; 5```#### Handling non-existent keysSometimes we want to retrieve a key but are unsure of if it will exist.There are two ways we could handle that.The first is the one we're used to seeing: catch the error.```pythontry:    important_value = config.get('section.i_do_not_exist')except KeyError:    important_value = 42```However, the `get` method comes with a `default` keyword argument that wecan utilze for this purpose.```pythonconfig.get('section.i_do_not_exist', default=42)&gt;&gt;&gt; 42```This can be handy if you have a default for a particular configuration value.### Using `set()`We can use `set()` to set a existing key's value.```pythonconfig.set('section.num_key', 6)```The method does not return anything, since there is nothinguseful to return. If something goes wrong where it is unable to setthe value, an exception will be raised instead. This is the casefor most methods on `ConfigFile`, such as `delete()` or `save()`,where there would be no useful return value to utilize.With `set()`, we can also create and set keys that don't exist yet.```pythonconfig.set('new_section.new_key', 'New key value!')```Would then result in the following section being added to our original file:```ini[new_section]new_key = New key value!```The exact behavior of how these new keys or sections are added are a bitdependent on the file format we're using, since every format is a littledifferent in it's structure and in what it supports. Mostly though, `ini`is just the odd one.If we try the following in `ini`, which does not support subsections ornested keys, we simply get a single section.```pythonconfig.set(&quot;section.sub_section.sub_sub_section.key&quot;, 5)``````ini[section.sub_section.sub_sub_section]key = 5```Lastly, we can set values using an array notation as well. The underlyingcontent is all manipulated as a dictionary for every file type. If we wantedto create a new section, we'd simply set it to be an empty dictionary.```pythonconfig['new_section'] = {}```Which would result to be an empty section:```ini[new_section]```### Using `delete()``delete()` allows us to delete entire sections or specific keys.```pythonconfig.delete('section')```Would result in the entire section being removed from our configuration file.However, we can also just delete a single key.```pythonconfig.delete('section.num_key')```We can also use the array notation here as well.```pythondel config['section']['num_key']```### Using `has()``has()` allows us to check whether a given key exists in our file. Thereare two ways to use `has()`.The first is using the dot syntax.```pythonconfig.has('section.str_key')&gt;&gt;&gt; Trueconfig.has('does_not_exist')&gt;&gt;&gt; False```This will check if our specific key or section exists. However, we canalso check in general if a given key or sections exists anywhere in ourfile with the `wild` keyword argument.```pythonconfig.has('str_key', wild=True)&gt;&gt;&gt; True```### Using `save()`For any changes we make to our configuration file, they are not written outto the filesystem until we call `save()`. This is to avoid unnecessary writecalls after each operation until we actually need to save.```pythonconfig.delete('section.list_key')config.save()```### Stringifying our ConfigFileTo retrieve the file as a string, with any changes we've made, we can use thebuilt-in `str()` method on the ConfigFile. This will always show us our latest changes since it is stringify-ing our internal representation of the configuration file, not just the file we've read in.```pythonstr(config)&gt;&gt;&gt; '[section]\nnum_key = 5\nstr_key = blah\nbool_key = true\nlist_key = [1, 2]\n\n[second_section]\ndict_key = { &quot;another_num&quot;: 5 }\n\n'```### Using `restore_original()`If we have a initial configuration file state, we could keep a copy of thatinitial file and restore back to it whenever needed using `restore_original()`.By default, if we created our `ConfigFile` object with the path of `~/some-project/config.ini`,`restore_original()` will look for our original file at `~/some-project/config.original.ini`.```pythonconfig.restore_original()```However, if we have a specific path elsewhere that this original configuration file is or itis named differently than what the default expects, we can utilize the `original_path`keyword argument.```pythonconfig.restore_original(original_path=&quot;~/some-project/original-configs/config.ini&quot;)```## Format Versions Supported| Format  | Specification version supported || ------------- | ------------- || INI  | No official specification. || JSON  | [RFC 7159](https://tools.ietf.org/html/rfc7159.html)  || YAML  | [v1.2](https://yaml.org/spec/1.2/spec.html)  || TOML  | [v1.0.0-rc.1](https://github.com/toml-lang/toml/releases/tag/v1.0.0-rc.1)  |For `ini` and `json`, Python's standard library modules are used.Regarding `ini`, there is no formal specification so the syntax that configparsersupports is what is supported here.## LicenseThe [MIT](https://github.com/eugenetriguba/config-file/blob/main/LICENSE) License.</longdescription>
</pkgmetadata>