<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;  &lt;a href=&quot;https://ovsyanka83.github.io/pydantic-duality/&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Ovsyanka83/pydantic-duality/main/docs/_media/logo_with_text.svg&quot; alt=&quot;Pydantic Duality&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;  &lt;b&gt;Automatically and lazily generate three versions of your pydantic models: one with Extra.forbid, one with Extra.ignore, and one with all fields optional&lt;/b&gt;&lt;/p&gt;---&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/ovsyanka83/pydantic-duality/actions?query=workflow%3ATests+event%3Apush+branch%3Amain&quot; target=&quot;_blank&quot;&gt;    &lt;img src=&quot;https://github.com/Ovsyanka83/pydantic-duality/actions/workflows/test.yaml/badge.svg?branch=main&amp;event=push&quot; alt=&quot;Test&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codecov.io/gh/ovsyanka83/pydantic-duality&quot; target=&quot;_blank&quot;&gt;    &lt;img src=&quot;https://img.shields.io/codecov/c/github/ovsyanka83/pydantic-duality?color=%2334D058&quot; alt=&quot;Coverage&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://pypi.org/project/pydantic-duality/&quot; target=&quot;_blank&quot;&gt;    &lt;img alt=&quot;PyPI&quot; src=&quot;https://img.shields.io/pypi/v/pydantic-duality?color=%2334D058&amp;label=pypi%20package&quot; alt=&quot;Package version&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://pypi.org/project/pydantic-duality/&quot; target=&quot;_blank&quot;&gt;    &lt;img src=&quot;https://img.shields.io/pypi/pyversions/pydantic-duality?color=%2334D058&quot; alt=&quot;Supported Python versions&quot;&gt;&lt;/a&gt;&lt;/p&gt;## Installation```bashpip install pydantic-duality```## QuickstartGiven the following models:```pythonfrom pydantic_duality import DualBaseModelclass User(DualBaseModel):    id: UUID    name: strclass Auth(DualBaseModel):    some_field: str    user: User```Using pydantic-duality is roughly equivalent to making all of the following models by hand:```pythonfrom pydantic import BaseModel# Equivalent to User and User.__request__class UserRequest(BaseModel, extra=Extra.forbid):    id: UUID    name: str# Rougly equivalent to Auth and Auth.__request__class AuthRequest(BaseModel, extra=Extra.forbid):    some_field: str    user: UserRequest# Rougly equivalent to User.__response__class UserResponse(BaseModel, extra=Extra.ignore):    id: UUID    name: str# Rougly equivalent to Auth.__response__class AuthResponse(BaseModel, extra=Extra.ignore):    some_field: str    user: UserResponse# Rougly equivalent to User.__patch_request__class UserPatchRequest(BaseModel, extra=Extra.forbid):    id: UUID | None    name: str | None# Rougly equivalent to Auth.__patch_request__class AuthPatchRequest(BaseModel, extra=Extra.forbid):    some_field: str | None    user: UserPatchRequest | None```So it takes you up to 3 times less code to write the same thing. Note also that pydantic-duality does everything lazily so you will not notice any significant performance or memory usage difference when using it instead of writing everything by hand. Think of it as using all the customized models as cached properties.Inheritance, inner models, custom configs, [custom names](https://ovsyanka83.github.io/pydantic-duality/#/?id=customizing-schema-names), config kwargs, isinstance and subclass checks work intuitively and in the same manner as they would work if you were not using pydantic-duality.## HelpSee [documentation](https://ovsyanka83.github.io/pydantic-duality/#/) for more details</longdescription>
</pkgmetadata>