<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Miniserial![PyPI](https://img.shields.io/pypi/v/miniserial)![PyPI - Python Version](https://img.shields.io/pypi/pyversions/miniserial)Miniserial is a Python package for dead-simple, space-efficient serializationand deserialization of simple dataclasses. There are many great packages forgeneral purpose serialization in the standard library and on PyPI (e.g. `json`,`marshal`, `pickle`, `ujson`, `bson`, etc.), but most use serializationformats that can come with significant byte overhead. Sometimes, projectconstraints—like the 256-byte-max-packet radio devices that inspired thispackage—encourage the use of a much more compact format, something akin toprotobuf or the layout of C structs. But libraries in this space typically comewith the overhead of implementing manual serializers, modifying class fieldswith various wrappers, or using non python data specifications (e.g. `.proto`files). `msgpack` comes close, but does not work out of the box with classes.Miniserial makes compact serialization easy. Simply have yourdataclass inherit from the `Serialization` mixin, and `serialize` and`deserialize` methods will be automatically generated for the class.For example:```python3from dataclasses import dataclassfrom miniserial import Serializable@dataclassclass Person(Serializable):    name   : str    age    : int    titles : list[str]    balance: float    p = Person(&quot;Bob&quot;, 34, [&quot;Mr.&quot;, &quot;Dr.&quot;, &quot;Professor&quot;], 239847.25)assert Person.deserialize(p.serialize()) == p```Classes that inherit the `Serializable` mixin must be dataclasses composed offields annotated with supported types, which include any other class whichinherits `Serializable`. This means that even recursive structures,like trees, can be serialized and deserialized.```python3from __future__ import annotationsfrom dataclasses import dataclassfrom miniserial import Serializable@dataclassclass Node(Serializable):    value   : int    children: list[Node]#                 1#               /   \ #              2     3 #             / \#            4   5tree = Node(1, [Node(2, [Node(4, []), Node(5, [])]), Node(3, [])])assert Node.deserialize(tree.serialize()) == tree```Documentation of supported types and the serialization format is on the way. Fornow, `bool`, `int`, `float`, `str`, and subclasses of `collections.abc.Collection`(e.g. `list`, `set`, `tuple`) are supported, along with any other user-definedclass that inherits `Serializable`. `int` and `float` are taken to be 32 bitvalues. Support for more types, including `int64`, `float64`, etc. from `numpy`are on the horizon.</longdescription>
</pkgmetadata>