<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># dictaA dict subclass that observes a nested dict and listens for changes in its data structure. If a data change is registered, Dicta reacts with a callback or a data-export to a JSON file.## Core Functionality- Detect data changes in a nested dict- Throw a callback, when the nested data structure changes- Write data to a JSON file, when the nested data structure changes- Easily import &amp; export JSON files to/from a nested dict## Features- Behaves like a regular `dict` and supports all `dict`, `list`, `tuple` and `set` methods.- Supports nesting of all possible datatypes like `dict`, `list`, `tuple`, `set` and other objects like custom classes.- Encodes non-serializable objects to a binary-string when writing data to a file (Optional / deactivated by default).- Reading data from a file will decode a binary-string back to a non-serializable object (Optional / deactivated by default).- Import/Insert additional data from json files.- Export data to json files.## Install```pip3 install dicta```## How to use```pythonimport dicta# Declare the 'Dicta' class.dicta = dicta.Dicta()# Activate binary serializationdicta.setBinarySerializer(True)# Set a synch file path.dicta.synchFile(&quot;data.json&quot;)# Define the callback methoddef callback():    print(&quot;Data changed!&quot;)    print(dicta)# Bind the callback method to dictadicta.bind(callback)# Add datadicta.importData({&quot;key&quot;:&quot;value&quot;})dicta.importData(key2=value2, key3=value3)dicta[&quot;entities&quot;] = {}dicta[&quot;entities&quot;][&quot;persons&quot;] = []dicta[&quot;entities&quot;][&quot;persons&quot;].append({&quot;name&quot;:&quot;john&quot;, &quot;age&quot;:23})dicta[&quot;entities&quot;][&quot;persons&quot;].append({&quot;name&quot;:&quot;peter&quot;, &quot;age&quot;:13})# Update a key in a dictdicta[&quot;entities&quot;][&quot;persons&quot;][1][&quot;age&quot;] = 42# Add another nested list to the dictdicta[&quot;entities&quot;][&quot;animals&quot;] = []dicta[&quot;entities&quot;][&quot;animals&quot;].append(&quot;lion&quot;)dicta[&quot;entities&quot;][&quot;animals&quot;].append(&quot;elephant&quot;)# Slice item from listdel dicta[&quot;entities&quot;][&quot;animals&quot;][0:1]# Remove item from dictdicta[&quot;entities&quot;].pop(&quot;persons&quot;)# and so forth…# Should support all regular dict behaviours and # list methods (pop(), append(), slice(), insert() …)# Import additional data from another file. # (New data will be added. Old data remains but will # be overwritten if dict keys match.)dicta.importFile(&quot;additional_data_file.json&quot;)# Export the data to another filedicta.exportFile(&quot;data_backup.json&quot;)# Get string representation of the Dictadicta.stringify()```## Reference---#### Dicta()```pythonDicta(*args, **kwargs)Dicta(dict)Dicta(key=value,key2=value)```A dict subclass.###### **Parameter**- ***args** *(Optional)*- ****kwargs** *(Optional)*###### **Return**- **Dicta Class**---### Methods#### Dicta Methods---##### Dicta.bind()```pythonDicta.bind(callback, response=False, *args, *kwargs)```Sets the callback method for the Dicta Class. If `response=False` (default) the callback method only gets the `*args, *kwargs` as parameters you define. If `response=True` the callback method gets response from the Dicta Class. You should define your callback function with a `*kwargs` parameter or with three positional parameters:`def my_callback(**kwargs)`or`def my_callback(modifed_object, modify_info, modify_trace)`###### **Parameter**- **callback** *(method)*- **default_response** *(bool) (optional / default = False)*###### **Callback**- **args** as defined in setCallback *(optional / default: None)*- **kwargs** as defined in setCallback *(optional / default: None)*- **modifed_object** *(object)*- ***modify_info*** *(json_string)*: Contains info about the data mod- **modify_trace** *(list)*: Contains the dict-tree-path to the modified object as a list starting from root*---##### Dicta.syncFile()```pythonDicta.syncFile(path, reset=False)```Sets the sync file to automatically store the data on data change. If `reset=False` (default) old data will remain and will be updated with new data . If `reset=True` the data wil be cleared when `syncFile()` is called.**This will fail if your dict contains non-serializable objects and binary serialization is not activated.** For security reasons this is deactivated by default. You can activate binary serialization manually with `Dicta.useBinarySerializer(True)`.If you activate the binary-serializer all non-serializable objects will be encoded to a binary string and packed into a `dict` labeled with the key `'&lt;serialized-object&gt;'`. See the reference for `Dicta.useBinarySerializer()`.###### **Parameter**- **path** *(string)*- **reset** *(bool) (optional / default = False)*---##### Dicta.importFile()```pythonDicta.importFile(path)```Import data from a file. New data will be added to the DictObsercer, old data remains but will be overwritten if dict keys match.###### **Parameter**- **path** *(string)*---##### Dicta.exportFile()```pythonDicta.exportFile(path, reset=True)```Export data to a file. If `reset=True` the data wil be cleared when `exportFile()` (default) is called . If `reset=False` the data will be updated.**This will fail if your dict contains non-serializable objects and binary serialization is not activated.** For security reasons this is deactivated by default. You can activate binary serialization by calling `Dicta.useBinarySerializer(True)` before.If you activate the binary-serializer all non-serializable objects will be encoded to a binary string and packed into a `dict` labeled with the key `'&lt;serialized-object&gt;'`. See the reference for `Dicta.useBinarySerializer()`.###### **Parameter**- **path** (string)- **reset** *(bool) (optional / default = True)*---##### Dicta.clearFile()```pythonDicta.clearFile(path)```Clear a file.###### **Parameter**- **path** *(string)*---##### Dicta.removeFile()```pythonDicta.removeFile(path)```Remove a data file.###### **Parameter**- **path** *(string)*---##### Dicta.importData(*args,**kwargs)```pythonDicta.importData(dict)Dicta.importData(key=value,key2=value2…)```Import data as dict or key/value pairs.---##### Dicta.dictify()```pythonDicta.dictify()```Returns a plain dict representation of the data without Dicta functionality.###### **Parameter**- None###### **Return**- **dict**---##### Dicta.stringify()```pythonDicta.stringify(returnBinaries=False)```Returns a string representation of the data in Dicta.**This will fail if your dict contains non-serializable objects and binary serialization is not activated.** For security reasons this is deactivated by default. You can activate binary serialization by calling `Dicta.useBinarySerializer(True)` before.If you activate the binary-serializer all non-serializable objects will be encoded to a binary string and packed into a `dict` labeled with the key `'&lt;serialized-object&gt;'`. See the reference for `Dicta.useBinarySerializer()`.For better readability serialized objects won´t be returned by default and are replaced by a the `'&lt;serialized-object&gt;'` hook. If you want to return the binaries set the `return_binaries`parameter to `True`.###### **Parameter**- **return_binaries** *(bool) (default = False)*###### **Return**- **string**---##### Dicta.setBinarySerializer()```pythonDicta.setBinarySerializer(binary_serializer=False, serializer_hook='&lt;serialized-object&gt;')```For security reasons binary serialization of non-serializable objects is deactivated by default. You can activate or deactivate binary serialization with this method (default=False).If you activate the binary-serializer all non-serializable objects will be encoded to a binary string and packed into a dict labeled with the key `'&lt;serialized-object&gt;'`. In case you need this key for your data structure, define a custom serializer-hook by using the `serializer_hook` parameter (optional). If you don´t use the `serializer_hook` parameter the default hook `'&lt;serialized-object&gt;'` will be used.###### Parameter- **binary_serializer** *(bool) (default = False)*- **serializer_hook** *(string) (optional / default = '\&lt;serialized-object&gt;')*###### Example```pythonmyDicta.setBinarySerializer(True)myDicta.setBinarySerializer(True, '&lt;my_serialzer_hook&gt;')```---#### Data Type MethodsBehaves like a regular nested dict and supports all data type methods. Adding, removing, modifiying and accessing of nested elements should work out of the box. For example:---##### NestedDict.update()```pythonNestedDict.update(*args, *kwargs)```---##### NestedDict.clear()```pythonNestedDict.clear()```---##### NestedDict.pop()```pythonNestedDict.pop(key)```---##### NestedDict.popitem()```pythonNestedDict.popitem(key)```---##### NestedDict.setdefault()```pythonNestedDict.setdefault(key, default=None)```*and so forth: keys(), iter() …*---##### NestedList.append()```pythonNestedList.append(item)```*and so forth: pop()…*---## Dependencies- os- re- json- pickle</longdescription>
</pkgmetadata>