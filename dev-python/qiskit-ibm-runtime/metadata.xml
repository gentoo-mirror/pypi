<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Qiskit Runtime IBM Client[![License](https://img.shields.io/github/license/Qiskit/qiskit-ibm-runtime.svg?style=popout-square)](https://opensource.org/licenses/Apache-2.0)[![CI](https://github.com/Qiskit/qiskit-ibm-runtime/actions/workflows/ci.yml/badge.svg)](https://github.com/Qiskit/qiskit-ibm-runtime/actions/workflows/ci.yml)[![](https://img.shields.io/github/release/Qiskit/qiskit-ibm-runtime.svg?style=popout-square)](https://github.com/Qiskit/qiskit-ibm-runtime/releases)[![](https://img.shields.io/pypi/dm/qiskit-ibm-runtime.svg?style=popout-square)](https://pypi.org/project/qiskit-ibm-runtime/)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![Coverage Status](https://coveralls.io/repos/github/Qiskit/qiskit-ibm-runtime/badge.svg?branch=main)](https://coveralls.io/github/Qiskit/qiskit-ibm-runtime?branch=main)**Qiskit** is an open-source SDK for working with quantum computers at the level of circuits, algorithms, and application modules.**Qiskit Runtime** is a new architecture offered by IBM Quantum that streamlines quantum computations.It is designed to use classical compute resources to execute quantum circuits with more efficiency on quantum processors.Using Qiskit Runtime, for example, a research team at IBM Quantum was able to achieve 120x speedup in their lithium hydride simulation. For more information, see the[IBM Research blog](https://research.ibm.com/blog/120x-quantum-speedup).This module provides the interface to access Qiskit Runtime.## InstallationYou can install this package using pip:```bashpip install qiskit-ibm-runtime```## Account Setup### Qiskit Runtime on IBM CloudQiskit Runtime is now part of the IBM Quantum Services on IBM Cloud. To use this service, you'llneed to create an IBM Cloud account and a quantum service instance.[This guide](https://cloud.ibm.com/docs/quantum-computing?topic=quantum-computing-get-started)contains step-by-step instructions on setting this up, including directions to find yourIBM Cloud API key and Cloud Resource Name (CRN), which you will need for authentication.### Qiskit Runtime on IBM QuantumPrior to becoming an IBM Cloud service, Qiskit Runtime was offered on IBM Quantum. If you have anexisting IBM Quantum account, you can continue using Qiskit Runtime on IBM Quantum.You will need your IBM Quantum API token to authenticate with the Qiskit Runtime service:1. Create an IBM Quantum account or log in to your existing account by visiting the [IBM Quantum login page].1. Copy (and optionally regenerate) your API token from your   [IBM Quantum account page].### Saving Account on DiskOnce you have the account credentials, you can save them on disk, so you won't have to inputthem each time. The credentials are saved in the `$HOME/.qiskit/qiskit-ibm.json` file, where `$HOME` is your home directory.| :warning: Account credentials are saved in plain text, so only do so if you are using a trusted device. ||:---------------------------| ```pythonfrom qiskit_ibm_runtime import QiskitRuntimeService# Save an IBM Cloud account.QiskitRuntimeService.save_account(channel=&quot;ibm_cloud&quot;, token=&quot;MY_IBM_CLOUD_API_KEY&quot;, instance=&quot;MY_IBM_CLOUD_CRN&quot;)# Save an IBM Quantum account.QiskitRuntimeService.save_account(channel=&quot;ibm_quantum&quot;, token=&quot;MY_IBM_QUANTUM_TOKEN&quot;)```Once the account is saved on disk, you can instantiate the service without any arguments:```pythonfrom qiskit_ibm_runtime import QiskitRuntimeServiceservice = QiskitRuntimeService()```### Loading Account from Environment VariablesAlternatively, the service can discover credentials from environment variables:```bashexport QISKIT_IBM_TOKEN=&quot;MY_IBM_CLOUD_API_KEY&quot;export QISKIT_IBM_INSTANCE=&quot;MY_IBM_CLOUD_CRN&quot;export QISKIT_IBM_CHANNEL=&quot;ibm_cloud&quot;```Then instantiate the service without any arguments:```pythonfrom qiskit_ibm_runtime import QiskitRuntimeServiceservice = QiskitRuntimeService()```### Enabling Account for Current Python SessionAs another alternative, you can also enable an account just for the current session by instantiating theservice with your credentials.```pythonfrom qiskit_ibm_runtime import QiskitRuntimeService# For an IBM Cloud account.ibm_cloud_service = QiskitRuntimeService(channel=&quot;ibm_cloud&quot;, token=&quot;MY_IBM_CLOUD_API_KEY&quot;, instance=&quot;MY_IBM_CLOUD_CRN&quot;)# For an IBM Quantum account.ibm_quantum_service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=&quot;MY_IBM_QUANTUM_TOKEN&quot;)```## Qiskit Runtime SessionA Qiskit Runtime **session** allows you to group a collection of iterative calls to the quantum computer. A session is started when the first job within the session is started. Subsequent jobs within the session are prioritized by the scheduler to minimize artificial delay within an iterative algorithm. Data used within a session, such as transpiled circuits, is also cached to avoid unnecessary overhead.You can use the [`qiskit_ibm_runtime.Session`](https://github.com/Qiskit/qiskit-ibm-runtime/blob/main/qiskit_ibm_runtime/session.py) class to start asession. You are encouraged to start a session as a context manager, to ensure the session is automatically closed upon exit. There are some examples in the sections below.## Primitives**Primitives** are prebuilt programs that provide a simplified interface for defining near-time quantum-classical workloads required to efficiently build and customize applications. The initial release of Qiskit Runtime includes two primitives: ``Estimator`` and ``Sampler``. They perform foundational quantum computing tasks and act as an entry point to the Qiskit Runtime service.There are several different options you can specify when calling the primitive programs. See [`qiskit_ibm_runtime.Options`](https://github.com/Qiskit/qiskit-ibm-runtime/blob/main/qiskit_ibm_runtime/options.py#L103) class for more information.### SamplerThis is a program that takes a list of user circuits as an input and generates an error-mitigated readout of quasi-probabilities. This provides users a way to better evaluate shot results using error mitigation and enables them to more efficiently evaluate the possibility of multiple relevant data points in the context of destructive interference.To invoke the `Sampler` primitive within a session:```pythonfrom qiskit_ibm_runtime import QiskitRuntimeService, Session, Options, Samplerfrom qiskit import QuantumCircuitservice = QiskitRuntimeService()options = Options(optimization_level=1)options.execution.shots = 1024  # Options can be set using auto-complete.bell = QuantumCircuit(2)bell.h(0)bell.cx(0, 1)bell.measure_all()with Session(service=service, backend=&quot;ibmq_qasm_simulator&quot;) as session:    sampler = Sampler(session=session, options=options)    job = sampler.run(circuits=bell)    print(f&quot;Job ID is {job.job_id()}&quot;)    print(f&quot;Job result is {job.result()}&quot;)    # You can make additional calls to Sampler and/or Estimator.```### EstimatorThis is a program that takes circuits and observables to evaluate expectation values and variances for a given parameter input. This primitive allows users to efficiently calculate and interpret expectation values of quantum operators required for many algorithms.To invoke the `Estimator` primitive within a session:```pythonfrom qiskit_ibm_runtime import QiskitRuntimeService, Session, Options, Estimatorfrom qiskit import QuantumCircuitfrom qiskit.circuit.library import RealAmplitudesfrom qiskit.quantum_info import SparsePauliOpservice = QiskitRuntimeService()options = Options(optimization_level=1)options.execution.shots = 1024  # Options can be set using auto-complete.psi1 = RealAmplitudes(num_qubits=2, reps=2)H1 = SparsePauliOp.from_list([(&quot;II&quot;, 1), (&quot;IZ&quot;, 2), (&quot;XI&quot;, 3)])theta1 = [0, 1, 1, 2, 3, 5]with Session(service=service, backend=&quot;ibmq_qasm_simulator&quot;) as session:    estimator = Estimator(session=session, options=options)    # calculate [ &lt;psi1(theta1)|H1|psi1(theta1)&gt; ]    job = estimator.run(circuits=[psi1], observables=[H1], parameter_values=[theta1])    print(f&quot;Job ID is {job.job_id()}&quot;)    print(f&quot;Job result is {job.result()}&quot;)    # You can make additional calls to Sampler and/or Estimator.```## Accessing Qiskit Runtime ProgramsIn addition to the primitives, there are other Qiskit Runtime programs that you can call directly. These programs, however, don't have special class wrappers.### Finding available programsTo list all available programs:```pythonfrom qiskit_ibm_runtime import QiskitRuntimeServiceservice = QiskitRuntimeService()service.pprint_programs()````pprint_programs()` prints the summary metadata of the first 20 programs visible to you. A program's metadataconsists of its ID, name, description, input parameters, return values, interim results, andother information that helps you to know more about the program. `pprint_programs(detailed=True, limit=None)`will print all metadata for all programs visible to you.### Executing a ProgramTo run a program, specify the program ID, input parameters, as well as any execution options:```pythonfrom qiskit_ibm_runtime import QiskitRuntimeServiceservice = QiskitRuntimeService()program_inputs = {    'iterations': 1}options = {'backend': 'ibmq_qasm_simulator'}job = service.run(    program_id=&quot;hello-world&quot;,    options=options,    inputs=program_inputs)print(f&quot;job ID: {job.job_id()}&quot;)result = job.result()```## Accessing your IBM Quantum backendsA **backend** is a quantum device or simulator capable of running quantum circuits or pulse schedules.You can query for the backends you have access to. Attributes and methods of the returned instancesprovide information, such as qubit counts, error rates, and statuses, of the backends.```pythonfrom qiskit_ibm_runtime import QiskitRuntimeServiceservice = QiskitRuntimeService()# Display all backends you have access.print(service.backends())# Get a specific backend.backend = service.backend('ibmq_qasm_simulator')# Print backend coupling map.print(backend.coupling_map)```## Next StepsNow you're set up and ready to check out some of the [tutorials].## Contribution GuidelinesIf you'd like to contribute to qiskit-ibm-runtime, please take a look at our[contribution guidelines]. This project adheres to Qiskit's [code of conduct].By participating, you are expected to uphold to this code.We use [GitHub issues] for tracking requests and bugs. Please use our [slack]for discussion and simple questions. To join our Slack community use theinvite link at [Qiskit.org]. For questions that are more suited for a forum weuse the `Qiskit` tag in [Stack Exchange].## License[Apache License 2.0].[IBM Quantum]: https://www.ibm.com/quantum-computing/[IBM Quantum login page]:  https://quantum-computing.ibm.com/login[IBM Quantum account page]: https://quantum-computing.ibm.com/account[contribution guidelines]: https://github.com/Qiskit/qiskit-ibm-runtime/blob/main/CONTRIBUTING.md[code of conduct]: https://github.com/Qiskit/qiskit-ibm-runtime/blob/main/CODE_OF_CONDUCT.md[GitHub issues]: https://github.com/Qiskit/qiskit-ibm-runtime/issues[slack]: https://qiskit.slack.com[Qiskit.org]: https://qiskit.org[Stack Exchange]: https://quantumcomputing.stackexchange.com/questions/tagged/qiskit[many people]: https://github.com/Qiskit/qiskit-ibm-runtime/graphs/contributors[BibTeX file]: https://github.com/Qiskit/qiskit/blob/master/Qiskit.bib[Apache License 2.0]: https://github.com/Qiskit/qiskit-ibm-runtime/blob/main/LICENSE.txt[tutorials]: https://github.com/Qiskit/qiskit-ibm-runtime/tree/main/docs/tutorials</longdescription>
</pkgmetadata>