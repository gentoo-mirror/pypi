<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>## pysailfish### Example EA --- simple client```pythonfrom pysailfish.internal.MT_EA.MT4_EA import MT4_EAclass MT4DemoEA(MT4_EA):    def __init__(self):        super().__init__()    # override    def _OnInit(self) -&gt; int:        self._logger.info(self._user_inputs)        self._logger.info(&quot;Here&quot;)        return 0    # override    def _OnDeinit(self, reason: int) -&gt; None:        self._logger.info(f&quot;Here reason: {reason}&quot;)        return None    # override    def _OnTick(self) -&gt; None:        self._logger.info(&quot;Here&quot;)        return None    # override    def _OnTimer(self) -&gt; None:        return None    # override    def _OnTester(self) -&gt; float:        self._logger.info(&quot;Here&quot;)        return 0.0    # override    def _OnChartEvent(self                      , id: int                      , lparam: int                      , dparam: float                      , sparam: str) -&gt; None:        self._logger.info(f&quot;Here id: {id} lparam: {lparam} dparam: {dparam} sparam: {sparam}&quot;)        return Nonedef main() -&gt; None:    ea = MT4DemoEA()    ea.InitComponent(server_ip=&quot;127.0.0.1&quot;                     , server_port=23456                     , ea_name=&quot;MT4DemoEA&quot;)    ea.StartEA()if __name__ == &quot;__main__&quot;:    main()```### Example EA --- Moving Average EA```pythonfrom datetime import datetimeimport pysailfish.internal.MT_EA.mt4_const as mcfrom pysailfish.internal.MT_EA.MT4_EA import MT4_EAclass MA_EA(MT4_EA):    def __init__(self):        super().__init__()    # override    def _OnInit(self) -&gt; int:        self._logger.info(self._user_inputs)        self._logger.info(&quot;Here&quot;)        return 0    # override    def _OnDeinit(self, reason: int) -&gt; None:        self._logger.info(f&quot;Here reason: {reason}&quot;)        return None    # override    def _OnTick(self) -&gt; None:        vv = self.iADX(symbol=self._pv.symbol                       , timeframe=mc.PERIOD_CURRENT                       , period=self._user_inputs[&quot;MovingPeriod&quot;]                       , applied_price=mc.PRICE_CLOSE                       , mode=mc.MODE_MAIN                       , shift=0)        # self._logger.info(f&quot;Here {self._pv.symbol} {self._pv.time[0]}&quot;)        # --- check for history and trading        if self._pv.bars &lt; 100 or self._pv.is_trade_allowed == False:            return        # --- calculate open orders by current symbol        if self.__calculate_current_orders(self._pv.symbol) == 0:            self.__check_for_open()        else:            self.__check_for_close()        return None    # override    def _OnTimer(self) -&gt; None:        return None    # override    def _OnTester(self) -&gt; float:        self._logger.info(&quot;Here&quot;)        return 0.0    # override    def _OnChartEvent(self                      , id: int                      , lparam: int                      , dparam: float                      , sparam: str) -&gt; None:        self._logger.info(f&quot;Here id: {id} lparam: {lparam} dparam: {dparam} sparam: {sparam}&quot;)        return None    def __check_for_close(self) -&gt; None:        ma: float = 0        #--- go trading only for first tiks of new bar        if self._pv.volume[0] &gt; 1:            return None        #--- get Moving Average        ma = self.iMA(symbol=self._pv.symbol                      , timeframe=mc.PERIOD_CURRENT                      , ma_period=self._user_inputs[&quot;MovingPeriod&quot;]                      , ma_shift=self._user_inputs[&quot;MovingShift&quot;]                      , ma_method=mc.MODE_SMA                      , applied_price=mc.PRICE_CLOSE                      , shift=0)        #---        for i in range(self.OrdersTotal()):            if self.OrderSelect(index=i, select=mc.SELECT_BY_POS, pool=mc.MODE_TRADES) == False:                break            if self.OrderMagicNumber() != self._pv.magic_num or self.OrderSymbol() != self._pv.symbol:                continue            #--- check order type            if self.OrderType() == mc.OP_BUY:                if self._pv.open[1] &gt; ma and self._pv.close[1] &lt; ma:                    if not self.OrderClose(ticket=self.OrderTicket(), lots=self.OrderLots(), price=self._pv.bid, slippage=3, arrow_color=mc.clrWhite):                        self._logger.error(f&quot;OrderClose error {self.GetLastError()}&quot;)                break            if self.OrderType() == mc.OP_SELL:                if self._pv.open[1] &lt; ma and self._pv.close[1] &gt; ma:                    if not self.OrderClose(ticket=self.OrderTicket(), lots=self.OrderLots(), price=self._pv.ask, slippage=3, arrow_color=mc.clrWhite):                        self._logger.error(f&quot;OrderClose error {self.GetLastError()}&quot;);                break    def __lots_optimized(self) -&gt; float:        lot: float = float(self._user_inputs[&quot;Lots&quot;])        maximum_risk: float = float(self._user_inputs[&quot;MaximumRisk&quot;])        decrease_factor: float = float(self._user_inputs[&quot;DecreaseFactor&quot;])        orders: int = self.OrdersHistoryTotal() # history orders total        losses: int = 0 # number of losses orders without a break        #--- select lot size        lot = self.NormalizeDouble(value=(self.AccountFreeMargin() * maximum_risk / 1000.0), digits=1);        #--- calcuulate number of losses orders without a break        if decrease_factor &gt; 0:            for i in reversed(range(orders)):                if self.OrderSelect(index=i, select=mc.SELECT_BY_POS, pool=mc.MODE_HISTORY) == False:                    self._logger.error(&quot;Error in history&quot;)                    break                if self.OrderSymbol() != self._pv.symbol or self.OrderType() &gt; mc.OP_SELL:                    continue                #---                if self.OrderProfit() &gt; 0:                    break                if self.OrderProfit() &lt; 0:                    losses += 1            if losses &gt; 1:                lot = self.NormalizeDouble(value=(lot - lot * losses / decrease_factor), digits=1)        #--- return lot size        if lot &lt; 0.1:            lot = 0.1        return lot    def __check_for_open(self) -&gt; None:        ma: float = 0        res: int = 0        #--- go trading only for first tiks of new bar        if self._pv.volume[0] &gt; 1:            return None        #--- get Moving Average        ma = self.iMA(symbol=self._pv.symbol                      , timeframe=mc.PERIOD_CURRENT                      , ma_period=self._user_inputs[&quot;MovingPeriod&quot;]                      , ma_shift=self._user_inputs[&quot;MovingShift&quot;]                      , ma_method=mc.MODE_SMA                      , applied_price=mc.PRICE_CLOSE                      , shift=0)        #--- sell conditions        if self._pv.open[1] &gt; ma and self._pv.close[1] &lt; ma:            res = self.OrderSend(symbol=self._pv.symbol                                 , cmd=mc.OP_SELL                                 , volume=self.__lots_optimized()                                 , price=self._pv.bid                                 , slippage=3                                 , stoploss=0                                 , takeprofit=0                                 , comment=&quot;&quot;                                 , magic=self._pv.magic_num                                 , expiration=datetime(1970, 1, 1, 0, 0, 0)                                 , arrow_color=mc.clrRed)            return None        #--- buy conditions        if self._pv.open[1] &lt; ma and self._pv.close[1] &gt; ma:            res = self.OrderSend(symbol=self._pv.symbol                                 , cmd=mc.OP_BUY                                 , volume=self.__lots_optimized()                                 , price=self._pv.ask                                 , slippage=3                                 , stoploss=0                                 , takeprofit=0                                 , comment=&quot;&quot;                                 , magic=self._pv.magic_num                                 , expiration=datetime(1970, 1, 1, 0, 0, 0)                                 , arrow_color=mc.clrBlue)            return None    def __calculate_current_orders(self, symbol: str) -&gt; int:        buys: int = 0        sells: int = 0        # ---        for i in range(self.OrdersTotal()):            if self._tf.order_select(index=i, select=mc.SELECT_BY_POS, pool=mc.MODE_TRADES) == False:                break            if self.OrderSymbol() == self._pv.symbol and self.OrderMagicNumber() == self._pv.magic_num:                if self.OrderType() == mc.OP_BUY:                    buys += 1                if self.OrderType() == mc.OP_SELL:                    sells += 1        # --- return orders volume        if buys &gt; 0:            return buys        else:            return -sellsdef main() -&gt; None:    ea = MA_EA()    ea.InitComponent(server_ip=&quot;127.0.0.1&quot;                     , server_port=23456                     , ea_name=&quot;MA_EA&quot;)    ea.StartEA()if __name__ == &quot;__main__&quot;:    main()```### How to publish to pypi```bash# set up pypi token$ poetry config pypi-token.pypi my-token# build the project$ poetry build# publish the project$ poetry publish# DONE```</longdescription>
</pkgmetadata>