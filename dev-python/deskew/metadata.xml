<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># DeskewNote: Skew is measured in degrees. Deskewing is a process whereby skew is removed by rotating an image by the same amount as its skew but in the opposite direction. This results in a horizontally and vertically aligned image where the text runs across the page rather than at an angle.The return angle is between -45 and 45 degrees to don't arbitrary change the image orientation.By using the library you can set the argument `angle_pm_90` to `True` to have an angle between -90 and 90 degrees.## Skew detection and correction in images containing text| Image with skew                                      | Image after deskew                                                 || ---------------------------------------------------- | ------------------------------------------------------------------ || ![Image with skew](doc/input.jpeg 'Image with skew') | ![Image after deskew](doc/sample_output.jpeg 'Image after deskew') |## Cli usageGet the skew angle:```bashdeskew input.png```Deskew an image:```bashdeskew --output output.png input.png```## Lib usageWith scikit-image:```pythonimport numpy as npfrom skimage import iofrom skimage.color import rgb2grayfrom skimage.transform import rotatefrom deskew import determine_skewimage = io.imread('input.png')grayscale = rgb2gray(image)angle = determine_skew(grayscale)rotated = rotate(image, angle, resize=True) * 255io.imsave('output.png', rotated.astype(np.uint8))```With OpenCV:```pythonimport mathfrom typing import Tuple, Unionimport cv2import numpy as npfrom deskew import determine_skewdef rotate(        image: np.ndarray, angle: float, background: Union[int, Tuple[int, int, int]]) -&gt; np.ndarray:    old_width, old_height = image.shape[:2]    angle_radian = math.radians(angle)    width = abs(np.sin(angle_radian) * old_height) + abs(np.cos(angle_radian) * old_width)    height = abs(np.sin(angle_radian) * old_width) + abs(np.cos(angle_radian) * old_height)    image_center = tuple(np.array(image.shape[1::-1]) / 2)    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)    rot_mat[1, 2] += (width - old_width) / 2    rot_mat[0, 2] += (height - old_height) / 2    return cv2.warpAffine(image, rot_mat, (int(round(height)), int(round(width))), borderValue=background)image = cv2.imread('input.png')grayscale = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)angle = determine_skew(grayscale)rotated = rotate(image, angle, (0, 0, 0))cv2.imwrite('output.png', rotated)```## Debug imagesIf you get wrong skew angle you can generate debug images, that can help you to tune the skewing detection.If you install deskew with `pip install deskew[debug_images]` you can get some debug images used forthe skew detection with the function `determine_skew_debug_images`.To start the investigation you should first increase the `num_peaks` (default `20`) and usethe `determine_skew_debug_images` function.Then you can try to tune the following arguments `num_peaks`, `angle_pm_90`, `min_angle`, `max_angle`,`min_deviation` and eventually `sigma`.Inspired by Alyn: https://github.com/kakul/Alyn## ContributingInstall the pre-commit hooks:```bashpip install pre-commitpre-commit install --allow-missing-config```</longdescription>
</pkgmetadata>