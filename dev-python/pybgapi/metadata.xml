<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># PyBGAPIThis package provides a Python interface for the BGAPI binary protocol. Itreads the BGAPI definition file and dynamically generates a parser for it.## Getting StartedTo get started with Silicon Labs Bluetooth software, see[QSG169: Bluetooth® SDK v3.x Quick Start Guide](https://www.silabs.com/documents/public/quick-start-guides/qsg169-bluetooth-sdk-v3x-quick-start-guide.pdf).In the NCP context, the application runs on a host MCU or a PC, which isthe NCP Host, while the Bluetooth stack runs on an EFR32, which is theNCP Target.The NCP Host and Target communicate via a serial interface (UART). Thecommunication between the NCP Host and Target is defined in the Silicon Labsproprietary protocol, BGAPI. pyBGAPI is the reference implementation ofthe BGAPI protocol in Python for the NCP Host.[AN1259: Using the v3.x Silicon Labs Bluetooth® Stack in Network CoProcessor Mode](https://www.silabs.com/documents/public/application-notes/an1259-bt-ncp-mode-sdk-v3x.pdf)provides a detailed description how NCP works and how to configure it forcustom hardware.For latest BGAPI documentation, see [docs.silabs.com](https://docs.silabs.com/bluetooth/latest/).For pyBGAPI example applications, see [github.com/SiliconLabs/pybgapi-examples](https://github.com/SiliconLabs/pybgapi-examples).## UsageFirst, create an instance of the BGLib class, which is the main component of the package.BGLib class provides functions for sendingBGAPI commands and returning responses and ways to receiveasynchronous BGAPI events. The BGLib constructor takes a connector, which isthe transport between BGLib and the device, and a list of BGAPI definitionfiles. The currently supported connectors are `bgapi.SerialConnector` and`bgapi.SocketConnector`.Start by importing the *bgapi* package and creating a BGLib object withthe Bluetooth API and a serial port connector. The *SerialConnector* takes theserial port as an argument, which is a device file on Linux OS and macOS, e.g.,`'/dev/tty.usbmodem1421'`, or a COM port on windows, e.g., `'COM1'`. Remember tochange the path to *sl_bt.xapi* which can be found for each SDK version in theBluetooth SDK under */path/to/sdks/gecko_sdk_suite/v3.x/protocol/bluetooth/api*.    &gt;&gt;&gt; import bgapi    &gt;&gt;&gt; l = bgapi.BGLib(    ...         bgapi.SerialConnector('/dev/tty.usbmodem1421'),    ...         '/path/to/SDK/protocol/bluetooth/api/sl_bt.xapi')    &gt;&gt;&gt; l.open()The BGLib constructor has an *event_handler* parameter too. Its default value is`None`, which means that all received events go to a queue for later retrieval.Alternatively, an event handler function may be passed, which is useful ininteractive mode for printing the received events, as follows:    &gt;&gt;&gt; def event_handler(evt):    ...     print(&quot;Received event: {}&quot;.format(evt))Start calling BGAPI commands, as follows:    &gt;&gt;&gt; l.bt.system.hello()    rsp_system_hello(result=0)The command functions are blocking, where the return value is the command'sresponse. The commands are in an attributenamed after the device name that the API is for, `bt` in this example. Then,they are grouped by the class name.The response objects behave like a Python *namedtuple*, i.e., the responsefields can be accessed as attributes (the dot notation) or like a tuple bytheir index. The attribute access is usually the preferred option.    &gt;&gt;&gt; response = l.bt.system.get_counters(0)    &gt;&gt;&gt; print(response)    rsp_system_get_counters(result=0, tx_packets=543, rx_packets=2000, crc_errors=195, failures=0)    &gt;&gt;&gt; print(response.crc_errors)    195    &gt;&gt;&gt; print(response[3])    195    &gt;&gt;&gt; address, = l.bt.system.get_bt_address()    &gt;&gt;&gt; print(address)    00:0b:57:49:2b:47If a command fails and reports a non-zero result code, an exception is thrown, as follows:    &gt;&gt;&gt; try:    ...     l.bt.advertiser.start(0, 0, 0)    ... except bgapi.bglib.CommandFailedError as e:    ...     print(&quot;Error 0x{:x} received, &quot;    ...           &quot;try to create an advertising set first.&quot;    ...           .format(e.errorcode))    Error 0x21 received, try to create an advertising set first.The received events are stored in an event queue, which can be accessed by functions,such as `gen_events()`. This function is a generator, whichyields events from the queue as they are received. With the default parameters,it is non-blocking and stops as soon as no more events are received. Usually,to receive a single event, you'll set a timeout, the *timeout* parameter,and the maximum time the generator will run altogether, which is the *max_time*parameter. The following example resets the device and waits for a boot eventfor one second.    &gt;&gt;&gt; l.bt.system.reset(0)    &gt;&gt;&gt; for e in l.gen_events(timeout=None, max_time=1):    ...     print(&quot;Received event: {}&quot;.format(e))    ...     if e == 'bt_evt_system_boot':    ...         print(&quot;Bluetooth stack booted: v{major}.{minor}.{patch}-b{build}&quot;.format(**vars(e)))    ...         break    Received event: bt_evt_system_boot(major=3, minor=2, patch=0, build=169, bootloader=17563648, hw=1, hash=3698707457)    Bluetooth stack booted: v3.2.0-b169Event object fields are accessed the same way as the response objects.## Changelog### 1.2.0 - 2022-09-02#### Added- Thread safety for commands.- Support the `byte_array` type.#### Changed- Improve error messages in deserializer.### 1.1.0 - 2021-06-28#### Added- Support the `sl_bt_uuid_16_t` type.- Fix communication issues caused by glitches on the physical layer.- Parse API version to support compatibility check.#### Changed- Parse define and enum names so that they start with the group name.### 1.0.0 - 2021-04-19#### Added- Initial public version.</longdescription>
</pkgmetadata>