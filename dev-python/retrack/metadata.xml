<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;  &lt;a href=&quot;https://github.com/gabrielguarisa/retrack&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gabrielguarisa/retrack/main/logo.png&quot; alt=&quot;retrack&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;em&gt;A business rules engine&lt;/em&gt;&lt;/p&gt;&lt;div align=&quot;center&quot;&gt;[![Package version](https://img.shields.io/pypi/v/retrack?color=%2334D058&amp;label=pypi%20package)](https://pypi.org/project/retrack/)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![Semantic Versions](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--versions-e10079.svg)](https://github.com/gabrielguarisa/retrack/releases)[![License](https://img.shields.io/github/license/gabrielguarisa/retrack)](https://github.com/gabrielguarisa/retrack/blob/main/LICENSE)&lt;/div&gt;## Installation```bashpip install retrack```## Usage```pythonimport retrackrunner = retrack.Runner.from_json(&quot;your-rule.json&quot;)response = runner.execute(input_data)```Or, if you want to create the parser and runner manually:```pythonimport retrack# Parse the rule/modelparser = retrack.Parser(rule)# Create a runnerrunner = retrack.Runner(parser, name=&quot;your-rule&quot;)# Run the rule/model passing the datarunner.execute(data)```The `Parser` class parses the rule/model and creates a graph of nodes. The `Runner` class runs the rule/model using the data passed to the runner. The `data` is a dictionary or a list of dictionaries containing the data that will be used to evaluate the conditions and execute the actions. To see wich data is required for the given rule/model, check the `runner.request_model` property that is a pydantic model used to validate the data.Optionally you can name the rule by passing the `name` field to the `retrack.Runner` constructor. This is useful to identify the rule when exceptions are raised.### Creating a rule/modelA rule is a set of conditions and actions that are executed when the conditions are met. The conditions are evaluated using the data passed to the runner. The actions are executed when the conditions are met.Each rule is composed of many nodes. To see each node type, check the [nodes](https://github.com/gabrielguarisa/retrack/tree/main/retrack/nodes) folder.To create a rule, you need to create a JSON file with the following structure:```json{  &quot;nodes&quot;: {&quot;node id&quot;: {&quot;id&quot;: &quot;node id&quot;,&quot;data&quot;: {},&quot;inputs&quot;: {},&quot;outputs&quot;: {},&quot;name&quot;: &quot;node name&quot;,},    // ... more nodes  }}```The `nodes` key is a dictionary of nodes. Each node has the following properties:- `id`: The node id. This is used to reference the node in the `inputs` and `outputs` properties.- `data`: The node data. This is used as a metadata for the node.- `inputs`: The node inputs. This is used to reference the node inputs.- `outputs`: The node outputs. This is used to reference the node outputs.- `name`: The node name. This is used to define the node type.The `inputs` and `outputs` properties are dictionaries of node connections. Each connection has the following properties:- `node`: The node id that is connected to the current node.- `input`: The input name of the connection that is connected to the current node. This is only used in the `inputs` property.- `output`: The output name of the connection that is connected to the current node. This is only used in the `outputs` property.To see some examples, check the [examples](https://github.com/gabrielguarisa/retrack/tree/main/examples) folder.### Creating a custom nodeTo create a custom node, you need to create a class that inherits from the `BaseNode` class. Each node is a pydantic model, so you can use pydantic features to create your custom node. To see the available features, check the [pydantic documentation](https://pydantic-docs.helpmanual.io/).To create a custom node you need to define the inputs and outputs of the node. To do this, you need to define the `inputs` and `outputs` class attributes. Let's see an example of a custom node that has two inputs, sum them and return the result:```pythonimport retrackimport pydanticimport pandas as pdimport typingclass SumInputsModel(pydantic.BaseModel):    input_value_0: retrack.InputConnectionModel    input_value_1: retrack.InputConnectionModelclass SumOutputsModel(pydantic.BaseModel):    output_value: retrack.OutputConnectionModelclass SumNode(retrack.BaseNode):    inputs: SumInputsModel    outputs: SumOutputsModel    def run(self, input_value_0: pd.Series,        input_value_1: pd.Series,    ) -&gt; typing.Dict[str, pd.Series]:        output_value = input_value_0.astype(float) + input_value_1.astype(float)        return {            &quot;output_value&quot;: output_value,        }```After creating the custom node, you need to register it in the nodes registry and pass the registry to the parser. Let's see an example:```pythonimport retrack# Register the custom noderetrack.component_registry.register_node(&quot;sum&quot;, SumNode)# Parse the rule/modelparser = Parser(rule, component_registry=retrack.component_registry)```## ContributingContributions are welcome! Please read the [contributing guidelines](https://github.com/gabrielguarisa/retrack/tree/main/CONTRIBUTING.md) first.</longdescription>
</pkgmetadata>