<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># mashumaro###### Fast and well tested serialization library on top of dataclasses[![Build Status](https://github.com/Fatal1ty/mashumaro/workflows/tests/badge.svg)](https://github.com/Fatal1ty/mashumaro/actions)[![Coverage Status](https://coveralls.io/repos/github/Fatal1ty/mashumaro/badge.svg?branch=master)](https://coveralls.io/github/Fatal1ty/mashumaro?branch=master)[![Latest Version](https://img.shields.io/pypi/v/mashumaro.svg)](https://pypi.python.org/pypi/mashumaro)[![Python Version](https://img.shields.io/pypi/pyversions/mashumaro.svg)](https://pypi.python.org/pypi/mashumaro)[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)When using dataclasses, you often need to dump and load objects based on theschema you have. Mashumaro not only lets you save and load things in differentways, but it also does it _super quick_.**Key features*** üöÄ One of the fastest libraries* ‚òùÔ∏è Mature and time-tested* üë∂ Easy to use out of the box* ‚öôÔ∏è Highly customizable* üéâ Built-in support for JSON, YAML, MessagePack, TOML* üì¶ Built-in support for almost all Python types including typing-extensions* üìù JSON Schema generationTable of contents--------------------------------------------------------------------------------* [Installation](#installation)* [Changelog](#changelog)* [Supported serialization formats](#supported-serialization-formats)* [Supported data types](#supported-data-types)* [Usage example](#usage-example)* [How does it work?](#how-does-it-work)* [Benchmark](#benchmark)* [Serialization mixins](#serialization-mixins)  * [`DataClassDictMixin`](#dataclassdictmixin)  * [`DataClassJSONMixin`](#dataclassjsonmixin)  * [`DataClassORJSONMixin`](#dataclassorjsonmixin)  * [`DataClassMessagePackMixin`](#dataclassmessagepackmixin)  * [`DataClassYAMLMixin`](#dataclassyamlmixin)  * [`DataClassTOMLMixin`](#dataclasstomlmixin)* [Customization](#customization)    * [`SerializableType` interface](#serializabletype-interface)      * [User-defined types](#user-defined-types)      * [User-defined generic types](#user-defined-generic-types)    * [`SerializationStrategy`](#serializationstrategy)      * [Third-party types](#third-party-types)      * [Third-party generic types](#third-party-generic-types)    * [Field options](#field-options)        * [`serialize` option](#serialize-option)        * [`deserialize` option](#deserialize-option)        * [`serialization_strategy` option](#serialization_strategy-option)        * [`alias` option](#alias-option)    * [Config options](#config-options)        * [`debug` config option](#debug-config-option)        * [`code_generation_options` config option](#code_generation_options-config-option)        * [`serialization_strategy` config option](#serialization_strategy-config-option)        * [`aliases` config option](#aliases-config-option)        * [`serialize_by_alias` config option](#serialize_by_alias-config-option)        * [`omit_none` config option](#omit_none-config-option)        * [`namedtuple_as_dict` config option](#namedtuple_as_dict-config-option)        * [`allow_postponed_evaluation` config option](#allow_postponed_evaluation-config-option)        * [`dialect` config option](#dialect-config-option)        * [`orjson_options`](#orjson_options-config-option)    * [Passing field values as is](#passing-field-values-as-is)    * [Dialects](#dialects)      * [`serialization_strategy` dialect option](#serialization_strategy-dialect-option)      * [`omit_none` dialect option](#omit_none-dialect-option)      * [Changing the default dialect](#changing-the-default-dialect)    * [Code generation options](#code-generation-options)        * [Add `omit_none` keyword argument](#add-omit_none-keyword-argument)        * [Add `by_alias` keyword argument](#add-by_alias-keyword-argument)        * [Add `dialect` keyword argument](#add-dialect-keyword-argument)    * [Generic dataclasses](#generic-dataclasses)      * [Generic dataclass inheritance](#generic-dataclass-inheritance)      * [Generic dataclass in a field type](#generic-dataclass-in-a-field-type)    * [`GenericSerializableType` interface](#genericserializabletype-interface)    * [Serialization hooks](#serialization-hooks)        * [Before deserialization](#before-deserialization)        * [After deserialization](#after-deserialization)        * [Before serialization](#before-serialization)        * [After serialization](#after-serialization)* [JSON Schema](#json-schema)    * [Building JSON Schema](#building-json-schema)    * [JSON Schema constraints](#json-schema-constraints)    * [Extending JSON Schema](#extending-json-schema)    * [JSON Schema and custom serialization methods](#json-schema-and-custom-serialization-methods)Installation--------------------------------------------------------------------------------Use pip to install:```shell$ pip install mashumaro```The current version of `mashumaro` supports Python versions 3.7 - 3.11.The latest version of `mashumaro` that can be installed on Python 3.6 is 3.1.1.Changelog--------------------------------------------------------------------------------This project follows the principles of [Semantic Versioning](https://semver.org).Changelog is available on [GitHub Releases page](https://github.com/Fatal1ty/mashumaro/releases).Supported serialization formats--------------------------------------------------------------------------------This library adds methods for dumping to and loading from thefollowing formats:* [plain dict](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)* [JSON](https://www.json.org)* [YAML](https://yaml.org)* [MessagePack](https://msgpack.org)* [TOML](https://toml.io)Plain dict can be useful when you need to pass a dict object to athird-party library, such as a client for MongoDB.You can find the documentation for the specific serialization format [below](#serialization-mixins).Supported data types--------------------------------------------------------------------------------There is support for generic types from the standard [`typing`](https://docs.python.org/3/library/typing.html) module:* [`List`](https://docs.python.org/3/library/typing.html#typing.List)* [`Tuple`](https://docs.python.org/3/library/typing.html#typing.Tuple)* [`NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple)* [`Set`](https://docs.python.org/3/library/typing.html#typing.Set)* [`FrozenSet`](https://docs.python.org/3/library/typing.html#typing.FrozenSet)* [`Deque`](https://docs.python.org/3/library/typing.html#typing.Deque)* [`Dict`](https://docs.python.org/3/library/typing.html#typing.Dict)* [`OrderedDict`](https://docs.python.org/3/library/typing.html#typing.OrderedDict)* [`DefaultDict`](https://docs.python.org/3/library/typing.html#typing.DefaultDict)* [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)* [`Mapping`](https://docs.python.org/3/library/typing.html#typing.Mapping)* [`MutableMapping`](https://docs.python.org/3/library/typing.html#typing.MutableMapping)* [`Counter`](https://docs.python.org/3/library/typing.html#typing.Counter)* [`ChainMap`](https://docs.python.org/3/library/typing.html#typing.ChainMap)* [`Sequence`](https://docs.python.org/3/library/typing.html#typing.Sequence)for standard generic types on [PEP 585](https://www.python.org/dev/peps/pep-0585/) compatible Python (3.9+):* [`list`](https://docs.python.org/3/library/stdtypes.html#list)* [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple)* [`namedtuple`](https://docs.python.org/3/library/collections.html#collections.namedtuple)* [`set`](https://docs.python.org/3/library/stdtypes.html#set)* [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset)* [`collections.abc.Set`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Set)* [`collections.abc.MutableSet`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSet)* [`collections.deque`](https://docs.python.org/3/library/collections.html#collections.deque)* [`dict`](https://docs.python.org/3/library/stdtypes.html#dict)* [`collections.OrderedDict`](https://docs.python.org/3/library/collections.html#collections.OrderedDict)* [`collections.defaultdict`](https://docs.python.org/3/library/collections.html#collections.defaultdict)* [`collections.abc.Mapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping)* [`collections.abc.MutableMapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping)* [`collections.Counter`](https://docs.python.org/3/library/collections.html#collections.Counter)* [`collections.ChainMap`](https://docs.python.org/3/library/collections.html#collections.ChainMap)* [`collections.abc.Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence)* [`collections.abc.MutableSequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence)for special primitives from the [`typing`](https://docs.python.org/3/library/typing.html) module:* [`Any`](https://docs.python.org/3/library/typing.html#typing.Any)* [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional)* [`Union`](https://docs.python.org/3/library/typing.html#typing.Union)* [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar)* [`TypeVarTuple`](https://docs.python.org/3/library/typing.html#typing.TypeVarTuple)* [`NewType`](https://docs.python.org/3/library/typing.html#newtype)* [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated)* [`Literal`](https://docs.python.org/3/library/typing.html#typing.Literal)* [`Self`](https://docs.python.org/3/library/typing.html#typing.Self)* [`Unpack`](https://docs.python.org/3/library/typing.html#typing.Unpack)for standard interpreter types from [`types`](https://docs.python.org/3/library/types.html#standard-interpreter-types) module:* [`NoneType`](https://docs.python.org/3/library/types.html#types.NoneType)* [`UnionType`](https://docs.python.org/3/library/types.html#types.UnionType)for enumerations based on classes from the standard [`enum`](https://docs.python.org/3/library/enum.html) module:* [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum)* [`IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum)* [`StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)* [`Flag`](https://docs.python.org/3/library/enum.html#enum.Flag)* [`IntFlag`](https://docs.python.org/3/library/enum.html#enum.IntFlag)for common built-in types:* [`int`](https://docs.python.org/3/library/functions.html#int)* [`float`](https://docs.python.org/3/library/functions.html#float)* [`bool`](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values)* [`str`](https://docs.python.org/3/library/stdtypes.html#str)* [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes)* [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray)for built-in datetime oriented types (see [more](#deserialize-option) details):* [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime)* [`date`](https://docs.python.org/3/library/datetime.html#datetime.date)* [`time`](https://docs.python.org/3/library/datetime.html#datetime.time)* [`timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta)* [`timezone`](https://docs.python.org/3/library/datetime.html#datetime.timezone)* [`ZoneInfo`](https://docs.python.org/3/library/zoneinfo.html#zoneinfo.ZoneInfo)for pathlike types:* [`PurePath`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath)* [`Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path)* [`PurePosixPath`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePosixPath)* [`PosixPath`](https://docs.python.org/3/library/pathlib.html#pathlib.PosixPath)* [`PureWindowsPath`](https://docs.python.org/3/library/pathlib.html#pathlib.PureWindowsPath)* [`WindowsPath`](https://docs.python.org/3/library/pathlib.html#pathlib.WindowsPath)* [`os.PathLike`](https://docs.python.org/3/library/os.html#os.PathLike)for other less popular built-in types:* [`uuid.UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID)* [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal)* [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction)* [`ipaddress.IPv4Address`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address)* [`ipaddress.IPv6Address`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Address)* [`ipaddress.IPv4Network`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Network)* [`ipaddress.IPv6Network`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Network)* [`ipaddress.IPv4Interface`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Interface)* [`ipaddress.IPv6Interface`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Interface)for backported types from [`typing-extensions`](https://github.com/python/typing_extensions):* [`OrderedDict`](https://docs.python.org/3/library/typing.html#typing.OrderedDict)* [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)* [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated)* [`Literal`](https://docs.python.org/3/library/typing.html#typing.Literal)* [`Self`](https://docs.python.org/3/library/typing.html#typing.Self)* [`TypeVarTuple`](https://docs.python.org/3/library/typing.html#typing.TypeVarTuple)* [`Unpack`](https://docs.python.org/3/library/typing.html#typing.Unpack)for arbitrary types:* [user-defined types](#user-defined-types)* [third-party types](#third-party-types)* [user-defined generic types](#user-defined-generic-types)* [third-party generic types](#third-party-generic-types)Usage example--------------------------------------------------------------------------------```pythonfrom enum import Enumfrom typing import Listfrom dataclasses import dataclassfrom mashumaro.mixins.json import DataClassJSONMixinclass Currency(Enum):    USD = &quot;USD&quot;    EUR = &quot;EUR&quot;@dataclassclass CurrencyPosition(DataClassJSONMixin):    currency: Currency    balance: float@dataclassclass StockPosition(DataClassJSONMixin):    ticker: str    name: str    balance: int@dataclassclass Portfolio(DataClassJSONMixin):    currencies: List[CurrencyPosition]    stocks: List[StockPosition]my_portfolio = Portfolio(    currencies=[        CurrencyPosition(Currency.USD, 238.67),        CurrencyPosition(Currency.EUR, 361.84),    ],    stocks=[        StockPosition(&quot;AAPL&quot;, &quot;Apple&quot;, 10),        StockPosition(&quot;AMZN&quot;, &quot;Amazon&quot;, 10),    ])json_string = my_portfolio.to_json()Portfolio.from_json(json_string)  # same as my_portfolio```How does it work?--------------------------------------------------------------------------------This library works by taking the schema of the data and generating aspecific parser and builder for exactly that schema, taking into account thespecifics of the serialization format. This is much faster than inspection offield types on every call of parsing or building at runtime.These specific parsers and builders are presented by the corresponding`from_*` and `to_*` methods. They are compiled during import time (or atruntime in some cases) and are set as attributes to your dataclasses.Benchmark--------------------------------------------------------------------------------* macOS 13.0.1 Ventura* Apple M1* 8GB RAM* Python 3.11.0Load and dump [sample data](https://github.com/Fatal1ty/mashumaro/blob/master/benchmark/sample.py) 100 times in 5 runs.The following figures show the best overall time in each case.&lt;img src=&quot;https://raw.githubusercontent.com/Fatal1ty/mashumaro/master/benchmark/charts/load.png&quot; width=&quot;400&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Fatal1ty/mashumaro/master/benchmark/charts/dump.png&quot; width=&quot;400&quot;&gt;&lt;table&gt;  &lt;col&gt;  &lt;colgroup span=&quot;2&quot;&gt;&lt;/colgroup&gt;  &lt;colgroup span=&quot;2&quot;&gt;&lt;/colgroup&gt;  &lt;tr&gt;    &lt;th rowspan=&quot;2&quot;&gt;Library&lt;/th&gt;    &lt;th colspan=&quot;2&quot; scope=&quot;colgroup&quot;&gt;From dict&lt;/th&gt;    &lt;th colspan=&quot;2&quot; scope=&quot;colgroup&quot;&gt;To dict&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;th scope=&quot;col&quot;&gt;Time&lt;/th&gt;    &lt;th scope=&quot;col&quot;&gt;Slowdown factor&lt;/th&gt;    &lt;th scope=&quot;col&quot;&gt;Time&lt;/th&gt;    &lt;th scope=&quot;col&quot;&gt;Slowdown factor&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;th scope=&quot;row&quot;&gt;&lt;a href=&quot;https://github.com/Fatal1ty/mashumaro&quot;&gt;mashumaro&lt;/a&gt;&lt;/th&gt;    &lt;td align=&quot;right&quot;&gt;0.14791&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;1x&lt;/td&gt;    &lt;td align=&quot;right&quot;&gt;0.10294&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;1x&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;th scope=&quot;row&quot;&gt;&lt;a href=&quot;https://github.com/Tinche/cattrs&quot;&gt;cattrs&lt;/a&gt;&lt;/th&gt;    &lt;td align=&quot;right&quot;&gt;0.18913&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;1.28x&lt;/td&gt;    &lt;td align=&quot;right&quot;&gt;0.13879&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;1.35x&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;th scope=&quot;row&quot;&gt;&lt;a href=&quot;https://github.com/samuelcolvin/pydantic/&quot;&gt;pydantic&lt;/a&gt;&lt;/th&gt;    &lt;td align=&quot;right&quot;&gt;0.92652&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;6.26x&lt;/td&gt;    &lt;td align=&quot;right&quot;&gt;0.81281&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;7.9x&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;th scope=&quot;row&quot;&gt;&lt;a href=&quot;https://github.com/marshmallow-code/marshmallow&quot;&gt;marshmallow&lt;/a&gt;&lt;/th&gt;    &lt;td align=&quot;right&quot;&gt;1.38964&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;9.39x&lt;/td&gt;    &lt;td align=&quot;right&quot;&gt;0.45987&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;4.47x&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;th scope=&quot;row&quot;&gt;&lt;a href=&quot;https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict&quot;&gt;dataclasses&lt;/a&gt;&lt;/th&gt;    &lt;td align=&quot;left&quot;&gt;‚Äî&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;‚Äî&lt;/td&gt;    &lt;td align=&quot;right&quot;&gt;0.68592&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;6.66x&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;th scope=&quot;row&quot;&gt;&lt;a href=&quot;https://github.com/konradhalas/dacite&quot;&gt;dacite&lt;/a&gt;&lt;/th&gt;    &lt;td align=&quot;right&quot;&gt;2.40445&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;16.26x&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;‚Äî&lt;/td&gt;    &lt;td align=&quot;left&quot;&gt;‚Äî&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;To run benchmark in your environment:```bashgit clone git@github.com:Fatal1ty/mashumaro.gitcd mashumaropython3 -m venv env &amp;&amp; source env/bin/activatepip install -e .pip install -r requirements-dev.txtpython benchmark/run.py```Serialization mixins--------------------------------------------------------------------------------`mashumaro` provides mixins for each serialization format.#### [`DataClassDictMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/dict.py#L14)Can be imported in two ways:```pythonfrom mashumaro import DataClassDictMixinfrom mashumaro.mixins.dict import DataClassDictMixin```The core mixin that adds serialization functionality to a dataclass.This mixin is a base class for all other serialization format mixins.It adds methods [`from_dict`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/dict.py#L38-L47)and [`to_dict`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/dict.py#L27-L36).#### [`DataClassJSONMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/json.py#L14)Can be imported as:```pythonfrom mashumaro.mixins.json import DataClassJSONMixin```This mixins adds json serialization functionality to a dataclass.It adds methods [`from_json`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/json.py#L24-L31)and [`to_json`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/json.py#L17-L22).#### [`DataClassORJSONMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/orjson.py#L29)Can be imported as:```pythonfrom mashumaro.mixins.orjson import DataClassORJSONMixin```This mixins adds json serialization functionality to a dataclass usinga third-party [`orjson`](https://pypi.org/project/orjson/) library.It adds methods [`from_json`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/orjson.pyi#L33-L39),[`to_jsonb`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/orjson.pyi#L19-L25),[`to_json`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/orjson.pyi#L26-L32).In order to use this mixin, the [`orjson`](https://pypi.org/project/orjson/) package must be installed.You can install it manually or using an extra option for `mashumaro`:```shellpip install mashumaro[orjson]```Using this mixin the following data types will be handled by[`orjson`](https://pypi.org/project/orjson/) library by default:* [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime)* [`date`](https://docs.python.org/3/library/datetime.html#datetime.date)* [`time`](https://docs.python.org/3/library/datetime.html#datetime.time)* [`uuid.UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID)#### [`DataClassMessagePackMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/msgpack.py#L35)Can be imported as:```pythonfrom mashumaro.mixins.msgpack import DataClassMessagePackMixin```This mixins adds MessagePack serialization functionality to a dataclass.It adds methods [`from_msgpack`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/msgpack.py#L58-L65)and [`to_msgpack`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/msgpack.py#L51-L56).In order to use this mixin, the [`msgpack`](https://pypi.org/project/msgpack/) package must be installed.You can install it manually or using an extra option for `mashumaro`:```shellpip install mashumaro[msgpack]```Using this mixin the following data types will be handled by[`msgpack`](https://pypi.org/project/msgpack/) library by default:* [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes)* [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray)#### [`DataClassYAMLMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/yaml.py#L27)Can be imported as:```pythonfrom mashumaro.mixins.yaml import DataClassYAMLMixin```This mixins adds YAML serialization functionality to a dataclass.It adds methods [`from_yaml`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/msgpack.py#L51-L56)and [`to_yaml`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/yaml.py#L30-L35).In order to use this mixin, the [`pyyaml`](https://pypi.org/project/PyYAML/) package must be installed.You can install it manually or using an extra option for `mashumaro`:```shellpip install mashumaro[yaml]```#### [`DataClassTOMLMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/toml.py#L32)Can be imported as:```pythonfrom mashumaro.mixins.toml import DataClassTOMLMixin```This mixins adds TOML serialization functionality to a dataclass.It adds methods [`from_toml`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/toml.py#L55-L62)and [`to_toml`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/toml.py#L48-L53).In order to use this mixin, the [`tomli`](https://pypi.org/project/tomli/) and[`tomli-w`](https://pypi.org/project/tomli-w/) packages must be installed.In Python 3.11+, `tomli` is included as[`tomlib`](https://docs.python.org/3/library/tomllib.html) standard librarymodule and can be used my this mixin.You can install the missing packages manually or using an extra option for `mashumaro`:```shellpip install mashumaro[toml]```Using this mixin the following data types will be handled by[`tomli`](https://pypi.org/project/tomli/)/[`tomli-w`](https://pypi.org/project/tomli-w/) library by default:* [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime)* [`date`](https://docs.python.org/3/library/datetime.html#datetime.date)* [`time`](https://docs.python.org/3/library/datetime.html#datetime.time)Fields with value `None` will be omitted on serialization because TOML doesn't support null values.Customization--------------------------------------------------------------------------------Customization options of `mashumaro` are extensive and will most likely cover your needs.When it comes to non-standard data types and non-standard serialization support, you can do the following:* Turn an existing regular or generic class into a serializable oneby inheriting the [`SerializableType`](#serializabletype-interface) class* Write different serialization strategies for an existing regular or generic type that is not under your controlusing [`SerializationStrategy`](#serializationstrategy) class* Define serialization / deserialization methods:  * for a specific dataclass field by using [field options](#field-options)  * for a specific data type used in the dataclass by using [`Config`](#config-options) class* Alter input and output data with serialization / deserialization [hooks](#serialization-hooks)* Separate serialization scheme from a dataclass in a reusable manner using [dialects](#dialects)* Choose from predefined serialization engines for the specific data types, e.g. `datetime` and `NamedTuple`### SerializableType interfaceIf you have a custom class or hierarchy of classes whose instances you wantto serialize with `mashumaro`, the first option is to implement`SerializableType` interface.#### User-defined typesLet's look at this not very practicable example:```pythonfrom dataclasses import dataclassfrom mashumaro import DataClassDictMixinfrom mashumaro.types import SerializableTypeclass Airport(SerializableType):    def __init__(self, code, city):        self.code, self.city = code, city    def _serialize(self):        return [self.code, self.city]    @classmethod    def _deserialize(cls, value):        return cls(*value)    def __eq__(self, other):        return self.code, self.city == other.code, other.city@dataclassclass Flight(DataClassDictMixin):    origin: Airport    destination: AirportJFK = Airport(&quot;JFK&quot;, &quot;New York City&quot;)LAX = Airport(&quot;LAX&quot;, &quot;Los Angeles&quot;)input_data = {    &quot;origin&quot;: [&quot;JFK&quot;, &quot;New York City&quot;],    &quot;destination&quot;: [&quot;LAX&quot;, &quot;Los Angeles&quot;]}my_flight = Flight.from_dict(input_data)assert my_flight == Flight(JFK, LAX)assert my_flight.to_dict() == input_data```You can see how `Airport` instances are seamlessly created from lists of twostrings and serialized into them.By default `_deserialize` method will get raw input data without any transformations before. This should be enough in many cases, especially whenyou need to perform non-standard transformations yourself, but let's extendour example:```pythonclass Itinerary(SerializableType):    def __init__(self, flights):        self.flights = flights    def _serialize(self):        return self.flights    @classmethod    def _deserialize(cls, flights):        return cls(flights)@dataclassclass TravelPlan(DataClassDictMixin):    budget: float    itinerary: Itineraryinput_data = {    &quot;budget&quot;: 10_000,    &quot;itinerary&quot;: [        {            &quot;origin&quot;: [&quot;JFK&quot;, &quot;New York City&quot;],            &quot;destination&quot;: [&quot;LAX&quot;, &quot;Los Angeles&quot;]        },        {            &quot;origin&quot;: [&quot;LAX&quot;, &quot;Los Angeles&quot;],            &quot;destination&quot;: [&quot;SFO&quot;, &quot;San Fransisco&quot;]        }    ]}```If we pass the flight list as is into `Itinerary._deserialize`, our itinerarywill have something that we may not expect ‚Äî `list[dict]` instead of`list[Flight]`. The solution is quite simple. Instead of calling`Flight._deserialize` yourself, just use annotations:```pythonclass Itinerary(SerializableType, use_annotations=True):    def __init__(self, flights):        self.flights = flights    def _serialize(self) -&gt; list[Flight]:        return self.flights    @classmethod    def _deserialize(cls, flights: list[Flight]):        return cls(flights)my_plan = TravelPlan.from_dict(input_data)assert isinstance(my_plan.itinerary.flights[0], Flight)assert isinstance(my_plan.itinerary.flights[1], Flight)assert my_plan.to_dict() == input_data```Here we add annotations to the only argument of `_deserialize` method andto the return value of `_serialize` method as well. The latter is needed forcorrect serialization.The importance of explicit passing `use_annotations=True` when defining a classis that otherwise implicit using annotations might break compatibility with oldcode that wasn't aware of this feature. It will be enabled by default in thefuture major release.#### User-defined generic typesThe great thing to note about using annotations in `SerializableType` is thatthey work seamlessly with [generic](https://docs.python.org/3/library/typing.html#user-defined-generic-types)and [variadic generic](https://peps.python.org/pep-0646/) types.Let's see how this can be useful:```pythonfrom datetime import datefrom typing import TypeVarfrom dataclasses import dataclassfrom mashumaro import DataClassDictMixinfrom mashumaro.types import SerializableTypeKT = TypeVar(&quot;KT&quot;)VT = TypeVar(&quot;VT&quot;)class DictWrapper(dict[KT, VT], SerializableType, use_annotations=True):    def _serialize(self) -&gt; dict[KT, VT]:        return dict(self)    @classmethod    def _deserialize(cls, value: dict[KT, VT]) -&gt; 'DictWrapper[KT, VT]':        return cls(value)@dataclassclass DataClass(DataClassDictMixin):    x: DictWrapper[date, str]    y: DictWrapper[str, date]input_data = {    &quot;x&quot;: {&quot;2022-12-07&quot;: &quot;2022-12-07&quot;},    &quot;y&quot;: {&quot;2022-12-07&quot;: &quot;2022-12-07&quot;}}obj = DataClass.from_dict(input_data)assert obj == DataClass(    x=DictWrapper({date(2022, 12, 7): &quot;2022-12-07&quot;}),    y=DictWrapper({&quot;2022-12-07&quot;: date(2022, 12, 7)}))assert obj.to_dict() == input_data```You can see that formatted date is deserialized to `date` object before passingto `DictWrapper._deserialize` in a key or value according to the genericparameters.If you have generic dataclass types, you can use `SerializableType` for them as well, but it's not necessary sincethey're [supported](#generic-dataclasses) out of the box.### SerializationStrategyIf you want to add support for a custom third-party type that is not under your control,you can write serialization and deserialization logic inside `SerializationStrategy` class,which will be reusable and so well suited in case that third-party type is widely used.`SerializationStrategy` is also good if you want to create strategies that are slightly different from each other,because you can add the strategy differentiator in the `__init__` method.#### Third-party typesTo demonstrate how `SerializationStrategy` works let's write a simple strategy for datetime serializationin different formats. In this example we will use the same strategy class for two dataclass fields,but a string representing the date and time will be different.```pythonfrom dataclasses import dataclass, fieldfrom datetime import datetimefrom mashumaro import DataClassDictMixin, field_optionsfrom mashumaro.types import SerializationStrategyclass FormattedDateTime(SerializationStrategy):    def __init__(self, fmt):        self.fmt = fmt    def serialize(self, value: datetime) -&gt; str:        return value.strftime(self.fmt)    def deserialize(self, value: str) -&gt; datetime:        return datetime.strptime(value, self.fmt)@dataclassclass DateTimeFormats(DataClassDictMixin):    short: datetime = field(        metadata=field_options(            serialization_strategy=FormattedDateTime(&quot;%d%m%Y%H%M%S&quot;)        )    )    verbose: datetime = field(        metadata=field_options(            serialization_strategy=FormattedDateTime(&quot;%A %B %d, %Y, %H:%M:%S&quot;)        )    )formats = DateTimeFormats(    short=datetime(2019, 1, 1, 12),    verbose=datetime(2019, 1, 1, 12),)dictionary = formats.to_dict()# {'short': '01012019120000', 'verbose': 'Tuesday January 01, 2019, 12:00:00'}assert DateTimeFormats.from_dict(dictionary) == formats```Similarly to `SerializableType`, `SerializationStrategy` could also take advantage of annotations:```pythonfrom dataclasses import dataclassfrom datetime import datetimefrom mashumaro import DataClassDictMixinfrom mashumaro.types import SerializationStrategyclass TsSerializationStrategy(SerializationStrategy, use_annotations=True):    def serialize(self, value: datetime) -&gt; float:        return value.timestamp()    def deserialize(self, value: float) -&gt; datetime:        # value will be converted to float before being passed to this method        return datetime.fromtimestamp(value)@dataclassclass Example(DataClassDictMixin):    dt: datetime    class Config:        serialization_strategy = {            datetime: TsSerializationStrategy(),        }example = Example.from_dict({&quot;dt&quot;: &quot;1672531200&quot;})print(example)# Example(dt=datetime.datetime(2023, 1, 1, 3, 0))print(example.to_dict())# {'dt': 1672531200.0}```Here the passed string value `&quot;1672531200&quot;` will be converted to `float` before being passed to `deserialize` methodthanks to the `float` annotation.As well as for `SerializableType`, the value of `use_annotatons` will be `True` by default in the future major release.#### Third-party generic typesTo create a generic version of a serialization strategy you need to follow these steps:* inherit [`Generic[...]`](https://docs.python.org/3/library/typing.html#typing.Generic) typewith the number of parameters matching the number of parametersof the target generic type* Write generic annotations for `serialize` method's return type and for `deserialize` method's argument type* Use the origin type of the target generic type in the [`serialization_strategy`](#serialization_strategy-config-option) config section([`typing.get_origin`](https://docs.python.org/3/library/typing.html#typing.get_origin) might be helpful)There is no need to add `use_annotations=True` here because it's enabled implicitlyfor generic serialization strategies.For example, there is a third-party [multidict](https://pypi.org/project/multidict/) package that has a generic `MultiDict` type.A generic serialization strategy for it might look like this:```pythonfrom dataclasses import dataclassfrom datetime import datefrom pprint import pprintfrom typing import Generic, List, Tuple, TypeVarfrom mashumaro import DataClassDictMixinfrom mashumaro.types import SerializationStrategyfrom multidict import MultiDictT = TypeVar(&quot;T&quot;)class MultiDictSerializationStrategy(SerializationStrategy, Generic[T]):    def serialize(self, value: MultiDict[T]) -&gt; List[Tuple[str, T]]:        return [(k, v) for k, v in value.items()]    def deserialize(self, value: List[Tuple[str, T]]) -&gt; MultiDict[T]:        return MultiDict(value)@dataclassclass Example(DataClassDictMixin):    floats: MultiDict[float]    date_lists: MultiDict[List[date]]    class Config:        serialization_strategy = {            MultiDict: MultiDictSerializationStrategy()        }example = Example(    floats=MultiDict([(&quot;x&quot;, 1.1), (&quot;x&quot;, 2.2)]),    date_lists=MultiDict(        [(&quot;x&quot;, [date(2023, 1, 1), date(2023, 1, 2)]),         (&quot;x&quot;, [date(2023, 2, 1), date(2023, 2, 2)])]    ),)pprint(example.to_dict())# {'date_lists': [['x', ['2023-01-01', '2023-01-02']],#                 ['x', ['2023-02-01', '2023-02-02']]],#  'floats': [['x', 1.1], ['x', 2.2]]}assert Example.from_dict(example.to_dict()) == example```### Field optionsIn some cases creating a new class just for one little thing could beexcessive. Moreover, you may need to deal with third party classes that you arenot allowed to change. You can use[`dataclasses.field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field)function as a default field value to configure some serialization aspectsthrough its `metadata` parameter. Next section describes all supported optionsto use in `metadata` mapping.#### `serialize` optionThis option allows you to change the serialization method. When usingthis option, the serialization behaviour depends on what type of value theoption has. It could be either `Callable[[Any], Any]` or `str`.A value of type `Callable[[Any], Any]` is a generic way to specify any callableobject like a function, a class method, a class instance method, an instanceof a callable class or even a lambda function to be called for serialization.A value of type `str` sets a specific engine for serialization. Keep in mindthat all possible engines depend on the data type that this option is usedwith. At this moment there are next serialization engines to choose from:| Applicable data types      | Supported engines    | Description                                                                                                                                                                                                  ||:---------------------------|:---------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|| `NamedTuple`, `namedtuple` | `as_list`, `as_dict` | How to pack named tuples. By default `as_list` engine is used that means your named tuple class instance will be packed into a list of its values. You can pack it into a dictionary using `as_dict` engine. || `Any`                      | `omit`               | Skip the field during serialization                                                                                                                                                                          |In addition, you can pass a field value as is without changes using[`pass_through`](#passing-field-values-as-is).Example:```pythonfrom datetime import datetimefrom dataclasses import dataclass, fieldfrom typing import NamedTuplefrom mashumaro import DataClassDictMixinclass MyNamedTuple(NamedTuple):    x: int    y: float@dataclassclass A(DataClassDictMixin):    dt: datetime = field(        metadata={            &quot;serialize&quot;: lambda v: v.strftime('%Y-%m-%d %H:%M:%S')        }    )    t: MyNamedTuple = field(metadata={&quot;serialize&quot;: &quot;as_dict&quot;})```#### `deserialize` optionThis option allows you to change the deserialization method. When usingthis option, the deserialization behaviour depends on what type of value theoption has. It could be either `Callable[[Any], Any]` or `str`.A value of type `Callable[[Any], Any]` is a generic way to specify any callableobject like a function, a class method, a class instance method, an instanceof a callable class or even a lambda function to be called for deserialization.A value of type `str` sets a specific engine for deserialization. Keep in mindthat all possible engines depend on the data type that this option is usedwith. At this moment there are next deserialization engines to choose from:| Applicable data types      | Supported engines                                                                                                                   | Description                                                                                                                                                                                                                                                                                             ||:---------------------------|:------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|| `datetime`, `date`, `time` | [`ciso8601`](https://github.com/closeio/ciso8601#supported-subset-of-iso-8601), [`pendulum`](https://github.com/sdispater/pendulum) | How to parse datetime string. By default native [`fromisoformat`](https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat) of corresponding class will be used for `datetime`, `date` and `time` fields. It's the fastest way in most cases, but you can choose an alternative. || `NamedTuple`, `namedtuple` | `as_list`, `as_dict`                                                                                                                | How to unpack named tuples. By default `as_list` engine is used that means your named tuple class instance will be created from a list of its values. You can unpack it from a dictionary using `as_dict` engine.                                                                                       |In addition, you can pass a field value as is without changes using[`pass_through`](#passing-field-values-as-is).Example:```pythonfrom datetime import datetimefrom dataclasses import dataclass, fieldfrom typing import List, NamedTuplefrom mashumaro import DataClassDictMixinimport ciso8601import dateutilclass MyNamedTuple(NamedTuple):    x: int    y: float@dataclassclass A(DataClassDictMixin):    x: datetime = field(        metadata={&quot;deserialize&quot;: &quot;pendulum&quot;}    )class B(DataClassDictMixin):    x: datetime = field(        metadata={&quot;deserialize&quot;: ciso8601.parse_datetime_as_naive}    )@dataclassclass C(DataClassDictMixin):    dt: List[datetime] = field(        metadata={            &quot;deserialize&quot;: lambda l: list(map(dateutil.parser.isoparse, l))        }    )@dataclassclass D(DataClassDictMixin):    x: MyNamedTuple = field(metadata={&quot;deserialize&quot;: &quot;as_dict&quot;})```#### `serialization_strategy` optionThis option is useful when you want to change the serialization logicfor a dataclass field depending on some defined parameters using a reusable serialization scheme.You can find an example in the [`SerializationStrategy`](#serializationstrategy) chapter.In addition, you can pass a field value as is without changes using[`pass_through`](#passing-field-values-as-is).#### `alias` optionIn some cases it's better to have different names for a field in your class andin its serialized view. For example, a third-party legacy API you are workingwith might operate with camel case style, but you stick to snake case style inyour code base. Or even you want to load data with keys that are invalididentifiers in Python. This problem is easily solved by using aliases:```pythonfrom dataclasses import dataclass, fieldfrom mashumaro import DataClassDictMixin, field_options@dataclassclass DataClass(DataClassDictMixin):    a: int = field(metadata=field_options(alias=&quot;FieldA&quot;))    b: int = field(metadata=field_options(alias=&quot;#invalid&quot;))x = DataClass.from_dict({&quot;FieldA&quot;: 1, &quot;#invalid&quot;: 2})  # DataClass(a=1, b=2)x.to_dict()  # {&quot;a&quot;: 1, &quot;b&quot;: 2}  # no aliases on serialization by default```If you want to write all the field aliases in one place there is[such a config option](#aliases-config-option).If you want to serialize all the fields by aliases you have two options to do so:* [`serialize_by_alias` config option](#serialize_by_alias-config-option)* [`by_alias` keyword argument in `to_*` methods](#add-by_alias-keyword-argument)It's hard to imagine when it might be necessary to serialize only specificfields by alias, but such functionality is easily added to the library. Openthe issue if you need it.If you don't want to remember the names of the options you can use`field_options` helper function:```pythonfrom dataclasses import dataclass, fieldfrom mashumaro import DataClassDictMixin, field_options@dataclassclass A(DataClassDictMixin):    x: int = field(        metadata=field_options(            serialize=str,            deserialize=int,            ...        )    )```More options are on the way. If you know which option would be useful for many,please don't hesitate to create an issue or pull request.### Config optionsIf inheritance is not an empty word for you, you'll fall in love with the`Config` class. You can register `serialize` and `deserialize` methods, definecode generation options and other things just in one place. Or in someclasses in different ways if you need flexibility. Inheritance is always on thefirst place.There is a base class `BaseConfig` that you can inherit for the sake ofconvenience, but it's not mandatory.In the following example you can see howthe `debug` flag is changed from class to class: `ModelA` will have debug mode enabled but`ModelB` will not.```pythonfrom mashumaro import DataClassDictMixinfrom mashumaro.config import BaseConfigclass BaseModel(DataClassDictMixin):    class Config(BaseConfig):        debug = Trueclass ModelA(BaseModel):    a: intclass ModelB(BaseModel):    b: int    class Config(BaseConfig):        debug = False```Next section describes all supported options to use in the config.#### `debug` config optionIf you enable the `debug` option the generated code for your data classwill be printed.#### `code_generation_options` config optionSome users may need functionality that wouldn't exist without extra cost suchas valuable cpu time to execute additional instructions. Since not everyoneneeds such instructions, they can be enabled by a constant in the list,so the fastest basic behavior of the library will always remain by default.The following table provides a brief overview of all the available constantsdescribed below.| Constant                                                        | Description                                                          ||:----------------------------------------------------------------|:---------------------------------------------------------------------|| [`TO_DICT_ADD_OMIT_NONE_FLAG`](#add-omit_none-keyword-argument) | Adds `omit_none` keyword-only argument to `to_*` methods.            || [`TO_DICT_ADD_BY_ALIAS_FLAG`](#add-by_alias-keyword-argument)   | Adds `by_alias` keyword-only argument to `to_*` methods.             || [`ADD_DIALECT_SUPPORT`](#add-dialect-keyword-argument)          | Adds `dialect` keyword-only argument to `from_*` and `to_*` methods. |#### `serialization_strategy` config optionYou can register custom [`SerializationStrategy`](#serializationstrategy), `serialize` and `deserialize`methods for specific types just in one place. It could be configured usinga dictionary with types as keys. The value could be either a[`SerializationStrategy`](#serializationstrategy) instance or a dictionary with `serialize` and`deserialize` values with the same meaning as in the[field options](#field-options).```pythonfrom dataclasses import dataclassfrom datetime import datetime, datefrom mashumaro import DataClassDictMixinfrom mashumaro.config import BaseConfigfrom mashumaro.types import SerializationStrategyclass FormattedDateTime(SerializationStrategy):    def __init__(self, fmt):        self.fmt = fmt    def serialize(self, value: datetime) -&gt; str:        return value.strftime(self.fmt)    def deserialize(self, value: str) -&gt; datetime:        return datetime.strptime(value, self.fmt)@dataclassclass DataClass(DataClassDictMixin):    x: datetime    y: date    class Config(BaseConfig):        serialization_strategy = {            datetime: FormattedDateTime(&quot;%Y&quot;),            date: {                # you can use specific str values for datetime here as well                &quot;deserialize&quot;: &quot;pendulum&quot;,                &quot;serialize&quot;: date.isoformat,            },        }instance = DataClass.from_dict({&quot;x&quot;: &quot;2021&quot;, &quot;y&quot;: &quot;2021&quot;})# DataClass(x=datetime.datetime(2021, 1, 1, 0, 0), y=Date(2021, 1, 1))dictionary = instance.to_dict()# {'x': '2021', 'y': '2021-01-01'}```#### `aliases` config optionSometimes it's better to write the field aliases in one place. You can mixaliases here with [aliases in the field options](#alias-option), but the last ones will alwaystake precedence.```pythonfrom dataclasses import dataclassfrom mashumaro import DataClassDictMixinfrom mashumaro.config import BaseConfig@dataclassclass DataClass(DataClassDictMixin):    a: int    b: int    class Config(BaseConfig):        aliases = {            &quot;a&quot;: &quot;FieldA&quot;,            &quot;b&quot;: &quot;FieldB&quot;,        }DataClass.from_dict({&quot;FieldA&quot;: 1, &quot;FieldB&quot;: 2})  # DataClass(a=1, b=2)```#### `serialize_by_alias` config optionAll the fields with [aliases](#alias-option) will be serialized by them bydefault when this option is enabled. You can mix this config option with[`by_alias`](#add-by_alias-keyword-argument) keyword argument.```pythonfrom dataclasses import dataclass, fieldfrom mashumaro import DataClassDictMixin, field_optionsfrom mashumaro.config import BaseConfig@dataclassclass DataClass(DataClassDictMixin):    field_a: int = field(metadata=field_options(alias=&quot;FieldA&quot;))    class Config(BaseConfig):        serialize_by_alias = TrueDataClass(field_a=1).to_dict()  # {'FieldA': 1}```#### `omit_none` config optionAll the fields with `None` values will be skipped during serialization bydefault when this option is enabled. You can mix this config option with[`omit_none`](#add-omit_none-keyword-argument) keyword argument.```pythonfrom dataclasses import dataclass, fieldfrom typing import Optionalfrom mashumaro import DataClassDictMixin, field_optionsfrom mashumaro.config import BaseConfig@dataclassclass DataClass(DataClassDictMixin):    x: Optional[int] = None    class Config(BaseConfig):        omit_none = TrueDataClass().to_dict()  # {}```#### `namedtuple_as_dict` config optionDataclasses are a great way to declare and use data models. But it's not the only way.Python has a typed version of [namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple)called [NamedTuple](https://docs.python.org/3/library/typing.html#typing.NamedTuple)which looks similar to dataclasses:```pythonfrom typing import NamedTupleclass Point(NamedTuple):    x: int    y: int```the same with a dataclass will look like this:```pythonfrom dataclasses import dataclass@dataclassclass Point:    x: int    y: int```At first glance, you can use both options. But imagine that you need to createa bunch of instances of the `Point` class. Due to how dataclasses work you willhave more memory consumption compared to named tuples. In such a case it couldbe more appropriate to use named tuples.By default, all named tuples are packed into lists. But with `namedtuple_as_dict`option you have a drop-in replacement for dataclasses:```pythonfrom dataclasses import dataclassfrom typing import List, NamedTuplefrom mashumaro import DataClassDictMixinclass Point(NamedTuple):    x: int    y: int@dataclassclass DataClass(DataClassDictMixin):    points: List[Point]    class Config:        namedtuple_as_dict = Trueobj = DataClass.from_dict({&quot;points&quot;: [{&quot;x&quot;: 0, &quot;y&quot;: 0}, {&quot;x&quot;: 1, &quot;y&quot;: 1}]})print(obj.to_dict())  # {&quot;points&quot;: [{&quot;x&quot;: 0, &quot;y&quot;: 0}, {&quot;x&quot;: 1, &quot;y&quot;: 1}]}```If you want to serialize only certain named tuple fields as dictionaries, youcan use the corresponding [serialization](#serialize-option) and[deserialization](#deserialize-option) engines.#### `allow_postponed_evaluation` config option[PEP 563](https://www.python.org/dev/peps/pep-0563/) solved the problem of forward references by postponing the evaluationof annotations, so you can write the following code:```pythonfrom __future__ import annotationsfrom dataclasses import dataclassfrom mashumaro import DataClassDictMixin@dataclassclass A(DataClassDictMixin):    x: B@dataclassclass B(DataClassDictMixin):    y: intobj = A.from_dict({'x': {'y': 1}})```You don't need to write anything special here, forward references work out ofthe box. If a field of a dataclass has a forward reference in the typeannotations, building of `from_*` and `to_*` methods of this dataclasswill be postponed until they are called once. However, if for some reason youdon't want the evaluation to be possibly postponed, you can disable it using`allow_postponed_evaluation` option:```pythonfrom __future__ import annotationsfrom dataclasses import dataclassfrom mashumaro import DataClassDictMixin@dataclassclass A(DataClassDictMixin):    x: B    class Config:        allow_postponed_evaluation = False# UnresolvedTypeReferenceError: Class A has unresolved type reference B# in some of its fields@dataclassclass B(DataClassDictMixin):    y: int```In this case you will get `UnresolvedTypeReferenceError` regardless of whetherclass B is declared below or not.#### `dialect` config optionThis option is described [below](#changing-the-default-dialect) in theDialects section.#### `orjson_options` config optionThis option changes default options for `orjson.dumps` encoder which isused in [`DataClassORJSONMixin`](#dataclassorjsonmixin). For example, you cantell orjson to handle non-`str` `dict` keys as the built-in `json.dumps`encoder does. See [orjson documentation](https://github.com/ijl/orjson#option)to read more about these options.```pythonimport orjsonfrom dataclasses import dataclassfrom typing import Dictfrom mashumaro.config import BaseConfigfrom mashumaro.mixins.orjson import DataClassORJSONMixin@dataclassclass MyClass(DataClassORJSONMixin):    x: Dict[int, int]    class Config(BaseConfig):        orjson_options = orjson.OPT_NON_STR_KEYSassert MyClass({1: 2}).to_json() == {&quot;1&quot;: 2}```### Passing field values as isIn some cases it's needed to pass a field value as is without any changesduring serialization / deserialization. There is a predefined[`pass_through`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/helper.py#L49)object that can be used as `serialization_strategy` or`serialize` / `deserialize` options:```pythonfrom dataclasses import dataclass, fieldfrom mashumaro import DataClassDictMixin, pass_throughclass MyClass:    def __init__(self, some_value):        self.some_value = some_value@dataclassclass A1(DataClassDictMixin):    x: MyClass = field(        metadata={            &quot;serialize&quot;: pass_through,            &quot;deserialize&quot;: pass_through,        }    )@dataclassclass A2(DataClassDictMixin):    x: MyClass = field(        metadata={            &quot;serialization_strategy&quot;: pass_through,        }    )@dataclassclass A3(DataClassDictMixin):    x: MyClass    class Config:        serialization_strategy = {            MyClass: pass_through,        }@dataclassclass A4(DataClassDictMixin):    x: MyClass    class Config:        serialization_strategy = {            MyClass: {                &quot;serialize&quot;: pass_through,                &quot;deserialize&quot;: pass_through,            }        }my_class_instance = MyClass(42)assert A1.from_dict({'x': my_class_instance}).x == my_class_instanceassert A2.from_dict({'x': my_class_instance}).x == my_class_instanceassert A3.from_dict({'x': my_class_instance}).x == my_class_instanceassert A4.from_dict({'x': my_class_instance}).x == my_class_instancea1_dict = A1(my_class_instance).to_dict()a2_dict = A2(my_class_instance).to_dict()a3_dict = A3(my_class_instance).to_dict()a4_dict = A4(my_class_instance).to_dict()assert a1_dict == a2_dict == a3_dict == a4_dict == {&quot;x&quot;: my_class_instance}```### DialectsSometimes it's needed to have different serialization and deserializationmethods depending on the data source where entities of the dataclass arestored or on the API to which the entities are being sent or received from.There is a special Dialect type that may contain all the differences from thedefault serialization and deserialization methods. You can create differentdialects and use each of them for the same dataclass depending onthe situation.Suppose we have the following dataclass with a field of type `date`:```python@dataclassclass Entity(DataClassDictMixin):    dt: date```By default, a field of `date` type serializes to a string in ISO 8601 format,so the serialized entity will look like `{'dt': '2021-12-31'}`. But what if wehave, for example, two sensitive legacy Ethiopian and Japanese APIs that usetwo different formats for dates ‚Äî `dd/mm/yyyy` and `yyyyÂπ¥mmÊúàddÊó•`? Instead ofcreating two similar dataclasses we can have one dataclass and two dialects:```pythonfrom dataclasses import dataclassfrom datetime import date, datetimefrom mashumaro import DataClassDictMixinfrom mashumaro.config import ADD_DIALECT_SUPPORTfrom mashumaro.dialect import Dialectfrom mashumaro.types import SerializationStrategyclass DateTimeSerializationStrategy(SerializationStrategy):    def __init__(self, fmt: str):        self.fmt = fmt    def serialize(self, value: date) -&gt; str:        return value.strftime(self.fmt)    def deserialize(self, value: str) -&gt; date:        return datetime.strptime(value, self.fmt).date()class EthiopianDialect(Dialect):    serialization_strategy = {        date: DateTimeSerializationStrategy(&quot;%d/%m/%Y&quot;)    }class JapaneseDialect(Dialect):    serialization_strategy = {        date: DateTimeSerializationStrategy(&quot;%YÂπ¥%mÊúà%dÊó•&quot;)    }@dataclassclass Entity(DataClassDictMixin):    dt: date    class Config:        code_generation_options = [ADD_DIALECT_SUPPORT]entity = Entity(date(2021, 12, 31))entity.to_dict(dialect=EthiopianDialect)  # {'dt': '31/12/2021'}entity.to_dict(dialect=JapaneseDialect)   # {'dt': '2021Âπ¥12Êúà31Êó•'}Entity.from_dict({'dt': '2021Âπ¥12Êúà31Êó•'}, dialect=JapaneseDialect)```#### `serialization_strategy` dialect optionThis dialect option has the same meaning as the[similar config option](#serialization_strategy-config-option)but for the dialect scope. You can register custom [`SerializationStrategy`](#serializationstrategy),`serialize` and `deserialize` methods for the specific types.#### `omit_none` dialect optionThis dialect option has the same meaning as the[similar config option](#omit_none-config-option) but for the dialect scope.#### Changing the default dialectYou can change the default serialization and deserialization methods fora dataclass not only in the[`serialization_strategy`](#serialization_strategy-config-option) config optionbut using the `dialect` config option. If you have multiple dataclasses withouta common parent class the default dialect can help you to reduce the number ofcode lines written:```python@dataclassclass Entity(DataClassDictMixin):    dt: date    class Config:        dialect = JapaneseDialectentity = Entity(date(2021, 12, 31))entity.to_dict()  # {'dt': '2021Âπ¥12Êúà31Êó•'}assert Entity.from_dict({'dt': '2021Âπ¥12Êúà31Êó•'}) == entity```### Code generation options#### Add `omit_none` keyword argumentIf you want to have control over whether to skip `None` values on serializationyou can add `omit_none` parameter to `to_*` methods using the`code_generation_options` list. The default value of `omit_none`parameter depends on whether the [`omit_none`](#omit_none-config-option)config option or [`omit_none`](#omit_none-dialect-option) dialect option is enabled.```pythonfrom dataclasses import dataclassfrom mashumaro import DataClassDictMixinfrom mashumaro.config import BaseConfig, TO_DICT_ADD_OMIT_NONE_FLAG@dataclassclass Inner(DataClassDictMixin):    x: int = None    # &quot;x&quot; won't be omitted since there is no TO_DICT_ADD_OMIT_NONE_FLAG here@dataclassclass Model(DataClassDictMixin):    x: Inner    a: int = None    b: str = None  # will be omitted    class Config(BaseConfig):        code_generation_options = [TO_DICT_ADD_OMIT_NONE_FLAG]Model(x=Inner(), a=1).to_dict(omit_none=True)  # {'x': {'x': None}, 'a': 1}```#### Add `by_alias` keyword argumentIf you want to have control over whether to serialize fields by their[aliases](#alias-option) you can add `by_alias` parameter to `to_*` methodsusing the `code_generation_options` list. The default value of `by_alias`parameter depends on whether the [`serialize_by_alias`](#serialize_by_alias-config-option)config option is enabled.```pythonfrom dataclasses import dataclass, fieldfrom mashumaro import DataClassDictMixin, field_optionsfrom mashumaro.config import BaseConfig, TO_DICT_ADD_BY_ALIAS_FLAG@dataclassclass DataClass(DataClassDictMixin):    field_a: int = field(metadata=field_options(alias=&quot;FieldA&quot;))    class Config(BaseConfig):        code_generation_options = [TO_DICT_ADD_BY_ALIAS_FLAG]DataClass(field_a=1).to_dict()  # {'field_a': 1}DataClass(field_a=1).to_dict(by_alias=True)  # {'FieldA': 1}```#### Add `dialect` keyword argumentSupport for [dialects](#dialects) is disabled by default for performance reasons. You can enableit using a `ADD_DIALECT_SUPPORT` constant:```pythonfrom dataclasses import dataclassfrom datetime import datefrom mashumaro import DataClassDictMixinfrom mashumaro.config import BaseConfig, ADD_DIALECT_SUPPORT@dataclassclass Entity(DataClassDictMixin):    dt: date    class Config(BaseConfig):        code_generation_options = [ADD_DIALECT_SUPPORT]```### Generic dataclassesAlong with [user-defined generic types](#user-defined-generic-types)implementing `SerializableType` interface, generic and variadicgeneric dataclasses can also be used. There are two applicable scenariosfor them.#### Generic dataclass inheritanceIf you have a generic dataclass and want to serialize and deserialize itsinstances depending on the concrete types, you can use inheritance for that:```pythonfrom dataclasses import dataclassfrom datetime import datefrom typing import Generic, Mapping, TypeVar, TypeVarTuplefrom mashumaro import DataClassDictMixinKT = TypeVar(&quot;KT&quot;)VT = TypeVar(&quot;VT&quot;, date, str)Ts = TypeVarTuple(&quot;Ts&quot;)@dataclassclass GenericDataClass(Generic[KT, VT, *Ts]):    x: Mapping[KT, VT]    y: Tuple[*Ts, KT]@dataclassclass ConcreteDataClass(    GenericDataClass[str, date, *Tuple[float, ...]],    DataClassDictMixin,):    passConcreteDataClass.from_dict({&quot;x&quot;: {&quot;a&quot;: &quot;2021-01-01&quot;}, &quot;y&quot;: [1, 2, &quot;a&quot;]})# ConcreteDataClass(x={'a': datetime.date(2021, 1, 1)}, y=(1.0, 2.0, 'a'))```You can override `TypeVar` field with a concrete type or another `TypeVar`.Partial specification of concrete types is also allowed. If a generic dataclassis inherited without type overriding the types of its fields remain untouched.#### Generic dataclass in a field typeAnother approach is to specify concrete types in the field type hints. This canhelp to have different versions of the same generic dataclass:```pythonfrom dataclasses import dataclassfrom datetime import datefrom typing import Generic, TypeVarfrom mashumaro import DataClassDictMixinT = TypeVar('T')@dataclassclass GenericDataClass(Generic[T], DataClassDictMixin):    x: T@dataclassclass DataClass(DataClassDictMixin):    date: GenericDataClass[date]    str: GenericDataClass[str]instance = DataClass(    date=GenericDataClass(x=date(2021, 1, 1)),    str=GenericDataClass(x='2021-01-01'),)dictionary = {'date': {'x': '2021-01-01'}, 'str': {'x': '2021-01-01'}}assert DataClass.from_dict(dictionary) == instance```### GenericSerializableType interfaceThere is a generic alternative to [`SerializableType`](#serializabletype-interface)called `GenericSerializableType`. It makes it possible to decide yourself howto serialize and deserialize input data depending on the types provided:```pythonfrom dataclasses import dataclassfrom datetime import datefrom typing import Dict, TypeVarfrom mashumaro import DataClassDictMixinfrom mashumaro.types import GenericSerializableTypeKT = TypeVar(&quot;KT&quot;)VT = TypeVar(&quot;VT&quot;)class DictWrapper(Dict[KT, VT], GenericSerializableType):    __packers__ = {date: lambda x: x.isoformat(), str: str}    __unpackers__ = {date: date.fromisoformat, str: str}    def _serialize(self, types) -&gt; Dict[KT, VT]:        k_type, v_type = types        k_conv = self.__packers__[k_type]        v_conv = self.__packers__[v_type]        return {k_conv(k): v_conv(v) for k, v in self.items()}    @classmethod    def _deserialize(cls, value, types) -&gt; &quot;DictWrapper[KT, VT]&quot;:        k_type, v_type = types        k_conv = cls.__unpackers__[k_type]        v_conv = cls.__unpackers__[v_type]        return cls({k_conv(k): v_conv(v) for k, v in value.items()})@dataclassclass DataClass(DataClassDictMixin):    x: DictWrapper[date, str]    y: DictWrapper[str, date]input_data = {    &quot;x&quot;: {&quot;2022-12-07&quot;: &quot;2022-12-07&quot;},    &quot;y&quot;: {&quot;2022-12-07&quot;: &quot;2022-12-07&quot;},}obj = DataClass.from_dict(input_data)assert obj == DataClass(    x=DictWrapper({date(2022, 12, 7): &quot;2022-12-07&quot;}),    y=DictWrapper({&quot;2022-12-07&quot;: date(2022, 12, 7)}),)assert obj.to_dict() == input_data```As you can see, the code turns out to be massive compared to the[alternative](#user-defined-generic-types) but in rare cases such flexibilitycan be useful. You should think twice about whether it's really worth using it.### Serialization hooksIn some cases you need to prepare input / output data or do some extraordinaryactions at different stages of the deserialization / serialization lifecycle.You can do this with different types of hooks.#### Before deserializationFor doing something with a dictionary that will be passed to deserializationyou can use `__pre_deserialize__` class method:```python@dataclassclass A(DataClassJSONMixin):    abc: int    @classmethod    def __pre_deserialize__(cls, d: Dict[Any, Any]) -&gt; Dict[Any, Any]:        return {k.lower(): v for k, v in d.items()}print(DataClass.from_dict({&quot;ABC&quot;: 123}))    # DataClass(abc=123)print(DataClass.from_json('{&quot;ABC&quot;: 123}'))  # DataClass(abc=123)```#### After deserializationFor doing something with a dataclass instance that was created as a resultof deserialization you can use `__post_deserialize__` class method:```python@dataclassclass A(DataClassJSONMixin):    abc: int    @classmethod    def __post_deserialize__(cls, obj: 'A') -&gt; 'A':        obj.abc = 456        return objprint(DataClass.from_dict({&quot;abc&quot;: 123}))    # DataClass(abc=456)print(DataClass.from_json('{&quot;abc&quot;: 123}'))  # DataClass(abc=456)```#### Before serializationFor doing something before serialization you can use `__pre_serialize__`method:```python@dataclassclass A(DataClassJSONMixin):    abc: int    counter: ClassVar[int] = 0    def __pre_serialize__(self) -&gt; 'A':        self.counter += 1        return selfobj = DataClass(abc=123)obj.to_dict()obj.to_json()print(obj.counter)  # 2```#### After serializationFor doing something with a dictionary that was created as a result ofserialization you can use `__post_serialize__` method:```python@dataclassclass A(DataClassJSONMixin):    user: str    password: str    def __post_serialize__(self, d: Dict[Any, Any]) -&gt; Dict[Any, Any]:        d.pop('password')        return dobj = DataClass(user=&quot;name&quot;, password=&quot;secret&quot;)print(obj.to_dict())  # {&quot;user&quot;: &quot;name&quot;}print(obj.to_json())  # '{&quot;user&quot;: &quot;name&quot;}'```JSON Schema--------------------------------------------------------------------------------You can build JSON Schema not only for dataclasses but also for any other[supported](#supported-data-types) datatypes. There is support for the following standards:* [Draft 2022-12](https://json-schema.org/specification.html)* [OpenAPI Specification 3.1.0](https://swagger.io/specification/)### Building JSON SchemaFor simple one-time cases it's recommended to start from using a configurable`build_json_schema` function. It returns `JSONSchema` object that can beserialized to json or to dict:```pythonfrom dataclasses import dataclassfrom typing import Listfrom uuid import UUIDfrom mashumaro.jsonschema import build_json_schema@dataclassclass User:    id: UUID    name: strprint(build_json_schema(List[User]).to_json())```&lt;details&gt;&lt;summary&gt;Click to show the result&lt;/summary&gt;```json{    &quot;type&quot;: &quot;array&quot;,    &quot;items&quot;: {        &quot;type&quot;: &quot;object&quot;,        &quot;title&quot;: &quot;User&quot;,        &quot;properties&quot;: {            &quot;id&quot;: {                &quot;type&quot;: &quot;string&quot;,                &quot;format&quot;: &quot;uuid&quot;            },            &quot;name&quot;: {                &quot;type&quot;: &quot;string&quot;            }        },        &quot;additionalProperties&quot;: false,        &quot;required&quot;: [            &quot;id&quot;,            &quot;name&quot;        ]    }}```&lt;/details&gt;Additional validation keywords ([see below](#json-schema-constraints))can be added using annotations:```pythonfrom typing import Annotated, Listfrom mashumaro.jsonschema import build_json_schemafrom mashumaro.jsonschema.annotations import Maximum, MaxItemsprint(    build_json_schema(        Annotated[            List[Annotated[int, Maximum(42)]],            MaxItems(4)        ]    ).to_json())```&lt;details&gt;&lt;summary&gt;Click to show the result&lt;/summary&gt;```json{    &quot;type&quot;: &quot;array&quot;,    &quot;items&quot;: {        &quot;type&quot;: &quot;integer&quot;,        &quot;maximum&quot;: 42    },    &quot;maxItems&quot;: 4}```&lt;/details&gt;The [`$schema`](https://json-schema.org/draft/2020-12/json-schema-core.html#name-the-schema-keyword)keyword can be added by setting `with_dialect_uri` to True:```pythonprint(build_json_schema(str, with_dialect_uri=True).to_json())```&lt;details&gt;&lt;summary&gt;Click to show the result&lt;/summary&gt;```json{    &quot;$schema&quot;: &quot;https://json-schema.org/draft/2020-12/schema&quot;,    &quot;type&quot;: &quot;string&quot;}```&lt;/details&gt;By default, Draft 2022-12 dialect is being used, but you can change it toanother one by setting `dialect` parameter:```pythonfrom mashumaro.jsonschema import OPEN_API_3_1print(    build_json_schema(        str, dialect=OPEN_API_3_1, with_dialect_uri=True    ).to_json())```&lt;details&gt;&lt;summary&gt;Click to show the result&lt;/summary&gt;```json{    &quot;$schema&quot;: &quot;https://spec.openapis.org/oas/3.1/dialect/base&quot;,    &quot;type&quot;: &quot;string&quot;}```&lt;/details&gt;All dataclass JSON Schemas can or can not be placed in the[definitions](https://json-schema.org/draft/2020-12/json-schema-core.html#name-schema-re-use-with-defs)section, depending on the `all_refs` parameter, which default value comesfrom a dialect used (`False` for Draft 2022-12, `True` for OpenAPISpecification 3.1.0):```pythonprint(build_json_schema(List[User], all_refs=True).to_json())```&lt;details&gt;&lt;summary&gt;Click to show the result&lt;/summary&gt;```json{    &quot;type&quot;: &quot;array&quot;,    &quot;$defs&quot;: {        &quot;User&quot;: {            &quot;type&quot;: &quot;object&quot;,            &quot;title&quot;: &quot;User&quot;,            &quot;properties&quot;: {                &quot;id&quot;: {                    &quot;type&quot;: &quot;string&quot;,                    &quot;format&quot;: &quot;uuid&quot;                },                &quot;name&quot;: {                    &quot;type&quot;: &quot;string&quot;                }            },            &quot;additionalProperties&quot;: false,            &quot;required&quot;: [                &quot;id&quot;,                &quot;name&quot;            ]        }    },    &quot;items&quot;: {        &quot;$ref&quot;: &quot;#/defs/User&quot;    }}```&lt;/details&gt;The definitions section can be omitted from the final document by setting`with_definitions` parameter to `False`:```pythonprint(    build_json_schema(        List[User], dialect=OPEN_API_3_1, with_definitions=False    ).to_json())```&lt;details&gt;&lt;summary&gt;Click to show the result&lt;/summary&gt;```json{    &quot;type&quot;: &quot;array&quot;,    &quot;items&quot;: {        &quot;$ref&quot;: &quot;#/components/schemas/User&quot;    }}```&lt;/details&gt;Reference prefix can be changed by using `ref_prefix` parameter:```pythonprint(    build_json_schema(        List[User],        all_refs=True,        with_definitions=False,        ref_prefix=&quot;#/components/responses&quot;,    ).to_json())```&lt;details&gt;&lt;summary&gt;Click to show the result&lt;/summary&gt;```json{    &quot;type&quot;: &quot;array&quot;,    &quot;items&quot;: {        &quot;$ref&quot;: &quot;#/components/responses/User&quot;    }}```&lt;/details&gt;The omitted definitions could be found later in the `Context` object thatyou could have created and passed to the function, but it could be easierto use `JSONSchemaBuilder` for that. For example, you might found it handyto build OpenAPI Specification step by step passing your models to the builderand get all the registered definitions later. This builder has reasonabledefaults but can be customized if necessary.```pythonfrom mashumaro.jsonschema import JSONSchemaBuilder, OPEN_API_3_1builder = JSONSchemaBuilder(OPEN_API_3_1)@dataclassclass User:    id: UUID    name: str@dataclassclass Device:    id: UUID    model: strprint(builder.build(List[User]).to_json())print(builder.build(List[Device]).to_json())print(builder.get_definitions().to_json())```&lt;details&gt;&lt;summary&gt;Click to show the result&lt;/summary&gt;```json{    &quot;type&quot;: &quot;array&quot;,    &quot;items&quot;: {        &quot;$ref&quot;: &quot;#/components/schemas/User&quot;    }}``````json{    &quot;type&quot;: &quot;array&quot;,    &quot;items&quot;: {        &quot;$ref&quot;: &quot;#/components/schemas/Device&quot;    }}``````json{    &quot;User&quot;: {        &quot;type&quot;: &quot;object&quot;,        &quot;title&quot;: &quot;User&quot;,        &quot;properties&quot;: {            &quot;id&quot;: {                &quot;type&quot;: &quot;string&quot;,                &quot;format&quot;: &quot;uuid&quot;            },            &quot;name&quot;: {                &quot;type&quot;: &quot;string&quot;            }        },        &quot;additionalProperties&quot;: false,        &quot;required&quot;: [            &quot;id&quot;,            &quot;name&quot;        ]    },    &quot;Device&quot;: {        &quot;type&quot;: &quot;object&quot;,        &quot;title&quot;: &quot;Device&quot;,        &quot;properties&quot;: {            &quot;id&quot;: {                &quot;type&quot;: &quot;string&quot;,                &quot;format&quot;: &quot;uuid&quot;            },            &quot;model&quot;: {                &quot;type&quot;: &quot;string&quot;            }        },        &quot;additionalProperties&quot;: false,        &quot;required&quot;: [            &quot;id&quot;,            &quot;model&quot;        ]    }}```&lt;/details&gt;### JSON Schema constraintsApart from required keywords, that are added automatically for certain datatypes, you're free to use additional validation keywords.They're presented by the corresponding classes in[`mashumaro.jsonschema.annotations`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/jsonschema/annotations.py):Number constraints:* [`Minimum`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-minimum)* [`Maximum`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-maximum)* [`ExclusiveMinimum`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-exclusiveminimum)* [`ExclusiveMaximum`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-exclusivemaximum)* [`MultipleOf`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-multipleof)String constraints:* [`MinLength`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-minlength)* [`MaxLength`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-maxlength)* [`Pattern`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-pattern)Array constraints:* [`MinItems`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-minitems)* [`MaxItems`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-maxitems)* [`UniqueItems`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-uniqueitems)* [`Contains`](https://json-schema.org/draft/2020-12/json-schema-core.html#name-contains)* [`MinContains`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-mincontains)* [`MaxContains`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-maxcontains)Object constraints:* [`MaxProperties`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-maxproperties)* [`MinProperties`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-minproperties)* [`DependentRequired`](https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dependentrequired)### Extending JSON SchemaUsing a `Config` class it is possible to override some parts of the schema.Currently, it works for dataclass fields via &quot;properties&quot; key:```pythonfrom dataclasses import dataclassfrom mashumaro.jsonschema import build_json_schema@dataclassclass FooBar:    foo: str    bar: int    class Config:        json_schema = {            &quot;properties&quot;: {                &quot;foo&quot;: {                    &quot;type&quot;: &quot;string&quot;,                    &quot;description&quot;: &quot;bar&quot;                }            }        }print(build_json_schema(FooBar).to_json())```&lt;details&gt;&lt;summary&gt;Click to show the result&lt;/summary&gt;```json{    &quot;type&quot;: &quot;object&quot;,    &quot;title&quot;: &quot;FooBar&quot;,    &quot;properties&quot;: {        &quot;foo&quot;: {            &quot;type&quot;: &quot;string&quot;,            &quot;description&quot;: &quot;bar&quot;        },        &quot;bar&quot;: {            &quot;type&quot;: &quot;integer&quot;        }    },    &quot;additionalProperties&quot;: false,    &quot;required&quot;: [        &quot;foo&quot;,        &quot;bar&quot;    ]}```&lt;/details&gt;### JSON Schema and custom serialization methodsMashumaro provides different ways to override default serialization methods fordataclass fields or specific data types. In order for these overrides to bereflected in the schema, you need to make sure that the methods haveannotations of the return value type.```pythonfrom dataclasses import dataclass, fieldfrom mashumaro.config import BaseConfigfrom mashumaro.jsonschema import build_json_schemadef str_as_list(s: str) -&gt; list[str]:    return list(s)def int_as_str(i: int) -&gt; str:    return str(i)@dataclassclass FooBar:    foo: str = field(metadata={&quot;serialize&quot;: str_as_list})    bar: int    class Config(BaseConfig):        serialization_strategy = {            int: {                &quot;serialize&quot;: int_as_str            }        }print(build_json_schema(FooBar).to_json())```&lt;details&gt;&lt;summary&gt;Click to show the result&lt;/summary&gt;```json{    &quot;type&quot;: &quot;object&quot;,    &quot;title&quot;: &quot;FooBar&quot;,    &quot;properties&quot;: {        &quot;foo&quot;: {            &quot;type&quot;: &quot;array&quot;,            &quot;items&quot;: {                &quot;type&quot;: &quot;string&quot;            }        },        &quot;bar&quot;: {            &quot;type&quot;: &quot;string&quot;        }    },    &quot;additionalProperties&quot;: false,    &quot;required&quot;: [        &quot;foo&quot;,        &quot;bar&quot;    ]}```&lt;/details&gt;</longdescription>
</pkgmetadata>