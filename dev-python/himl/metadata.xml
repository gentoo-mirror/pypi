<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># himlA hierarchical config using yaml in Python.Latest version is: 0.13.0## DescriptionA python module which allows you to merge hierarchical config files using YAML syntax. It offers deep merge, variable interpolation and secrets retrieval from secrets managers.It is ideal if you want to structure your hierarchy in such a way that you avoid duplication. You can define a structure for your configuration using a hierarchy such environment/project/cluster/app. It is up to you what layers you want to use in this hierarchy. The tool will read all yaml files starting from the root (where default values would be) all the way to the leaf (where most specific values would be, which will take precedence).Idea came from puppet's hiera.## Table of Contents- [himl](#himl)  - [Description](#description)  - [Table of Contents](#table-of-contents)  - [Installation](#installation)    - [Using `pip`](#using-pip)    - [Using `docker` image](#using-docker-image)    - [From Source](#from-source)  - [Examples](#examples)    - [Using the python module](#using-the-python-module)    - [Using the cli](#using-the-cli)  - [Features](#features)    - [Interpolation](#interpolation)      - [Interpolating simple values](#interpolating-simple-values)      - [Interpolating whole `dict`](#interpolating-whole-dict)    - [Deep merge](#deep-merge)    - [Secrets retrieval](#secrets-retrieval)      - [AWS SSM](#aws-ssm)      - [AWS S3](#aws-s3)      - [Vault](#vault)    - [Merge with Terraform remote state](#merge-with-terraform-remote-state)    - [Merge with env variables](#merge-with-env-variables)  - [himl config merger](#himl-config-merger)    - [Extra merger features](#extra-merger-features)## Installation### Using `pip````shpip install himl```### Using `docker` image```shdocker run ghcr.io/adobe/himl:latest himl-config-merger --help```See all docker tags at: https://github.com/adobe/himl/pkgs/container/himl/versions### From Source```git clone https://github.com/adobe/himlcd himlsudo python install -e .```## Examples### Using the python moduleThis will merge simple/default.yaml with simple/production/env.yaml```pyfrom himl import ConfigProcessorconfig_processor = ConfigProcessor()path = &quot;examples/simple/production&quot;filters = () # can choose to output only specific keysexclude_keys = () # can choose to remove specific keysoutput_format = &quot;yaml&quot; # yaml/jsonconfig_processor.process(path=path, filters=filters, exclude_keys=exclude_keys,                         output_format=output_format, print_data=True)```The above example will merge `simple/default.yaml` with `simple/production/env.yaml`:```$ tree examples/simpleexamples/simple├── default.yaml└── production    └── env.yaml```The example also showcases deep merging of lists and maps.`examples/simple/default.yaml````yaml---env: defaultdeep:  key1: v1  key2: v2deep_list:  - item1  - item2````examples/simple/production/env.yaml````yaml---env: proddeep:  key3: v3deep_list:  - item3```Result:```yamlenv: proddeep:  key1: v1  key2: v2  key3: v3deep_list:- item1- item2- item3```### Using the cliA cli tool called `himl` is automatically installed via `pip`. You can use it to parse a tree of yamls and it will either output the combined configuration at standard output or write it to a file.```shusage: himl [-h] [--output-file OUTPUT_FILE] [--format OUTPUT_FORMAT]             [--filter FILTER] [--exclude EXCLUDE]             [--skip-interpolation-validation]             [--skip-interpolation-resolving] [--enclosing-key ENCLOSING_KEY]             [--cwd CWD]             [--list-merge-strategy {append,override,prepend,append_unique}]             path``````shhiml examples/complex/env=dev/region=us-east-1/cluster=cluster2```Based on the configuration tree from the [examples/complex](examples/complex) folder, the output of the above command will be the following:```cluster:  description: 'This is cluster: cluster2. It is using c3.2xlarge instance type.'  name: cluster2  node_type: c3.2xlargeregion:  location: us-east-1env: dev```Where the examples folder looks something like this:```$ tree examples/complexexamples/complex├── default.yaml├── env=dev│   ├── env.yaml│   ├── region=us-east-1│   │   ├── cluster=cluster1│   │   │   └── cluster.yaml│   │   ├── cluster=cluster2│   │   │   └── cluster.yaml│   │   └── region.yaml│   └── region=us-west-2│       ├── cluster=cluster1│       │   └── cluster.yaml│       └── region.yaml└── env=prod    ├── env.yaml    └── region=eu-west-2        ├── cluster=ireland1        │   └── cluster.yaml        └── region.yaml```## Features### InterpolationIn order to avoid repetition, we wanted to make it possible to define a value once and reuse it in other parts of the yaml config.Unlike yaml anchors, these interpolations work across multiple files.#### Interpolating simple values`data/default.yaml`:```yamlallowed_roles:  - &quot;arn:aws:iam::{{account.id}}:role/myrole&quot;````data/dev/env.yaml`:```account:  id: &quot;123456&quot;```#### Interpolating whole `dict````yamlprojects:  webapp1:    tagging:      Owner: &quot;Web Service Team&quot;      Environment: &quot;dev&quot;      CostCenter: &quot;123&quot;  data-store:      Owner: &quot;Backend Team&quot;      Environment: &quot;dev&quot;      CostCenter: &quot;455&quot;# this will copy the whole projects.webapp1.tagging dict to this keytagging: &quot;{{projects.webapp1.tagging}}&quot;# or even a double interpolationtagging: &quot;{{projects.{{project.name}}.tagging}}&quot;```### Deep mergeIt's possible to have the same key (eg. a dict/list) in multiple files and combine them using a deep merge.See an example [here](https://github.com/adobe/himl#deep-merge-example).### Secrets retrieval#### [AWS SSM](https://docs.aws.amazon.com/systems-manager/latest/userguide/integration-ps-secretsmanager.html)```yamlpassphrase: &quot;{{ssm.path(/key/coming/from/aws/secrets/store/manager).aws_profile(myprofile)}}&quot;```#### [AWS S3](https://aws.amazon.com/s3/)```yamlmy_value: &quot;{{s3.bucket(my-bucket).path(path/to/file.txt).base64encode(true).aws_profile(myprofile)}}&quot;```#### [Vault](https://www.vaultproject.io/)Use vault cli to authenticate, fallback method via LDAP.Retrieve only one key value from a secret, the path tail is used as key:```yamlmy_value: &quot;{{vault.key(/path/from/vault/key)}}&quot;```Retrieve all key/value pairs from a vault path:```yamlmy_dict: &quot;{{vault.path(/path/from/vault)}}&quot;```Generate a token for a policy:```yamlmy_token: &quot;{{vault.token_policy(my_vault_policy)}}&quot;```### Merge with [Terraform remote state](https://www.terraform.io/docs/state/remote.html)```yaml### Terraform remote states ###remote_states:  - name: cluster_composition    type: terraform    aws_profile: &quot;my_aws_profile&quot;    s3_bucket: &quot;my_terraform_bucket&quot;    s3_key: &quot;mycluster.tfstate&quot;endpoint: &quot;{{outputs.cluster_composition.output.value.redis_endpoint}}&quot;```### Merge with env variables```yamlkubeconfig_location: {{env(KUBECONFIG)}}```## himl config mergerThe `himl-config-merger` script, contains logic of merging a hierarchical config directory and creating the end result YAML files.```shhiml-config-merger examples/complex --output-dir merged_output --levels env region cluster --leaf-directories cluster``````INFO:__main__:Found input config directory: examples/complex/env=prod/region=eu-west-2/cluster=ireland1INFO:__main__:Storing generated config to: merged_output/prod/eu-west-2/ireland1.yamlINFO:__main__:Found input config directory: examples/complex/env=dev/region=us-west-2/cluster=cluster1INFO:__main__:Storing generated config to: merged_output/dev/us-west-2/cluster1.yamlINFO:__main__:Found input config directory: examples/complex/env=dev/region=us-east-1/cluster=cluster1INFO:__main__:Storing generated config to: merged_output/dev/us-east-1/cluster1.yamlINFO:__main__:Found input config directory: examples/complex/env=dev/region=us-east-1/cluster=cluster2INFO:__main__:Storing generated config to: merged_output/dev/us-east-1/cluster2.yaml```Input example:```&gt; tree examples/complexexamples/complex├── default.yaml├── env=dev│   ├── env.yaml│   ├── region=us-east-1│   │   ├── cluster=cluster1│   │   │   └── cluster.yaml│   │   ├── cluster=cluster2│   │   │   └── cluster.yaml│   │   └── region.yaml│   └── region=us-west-2│       ├── cluster=cluster1│       │   └── cluster.yaml│       └── region.yaml└── env=prod    ├── env.yaml    └── region=eu-west-2        ├── cluster=ireland1        │   └── cluster.yaml        └── region.yaml```Output:```merged_output├── dev│   ├── us-east-1│   │   ├── cluster1.yaml│   │   └── cluster2.yaml│   └── us-west-2│       └── cluster1.yaml└── prod    └── eu-west-2        └── ireland1.yaml```Leveraging HIML, the config-merger script loads the configs tree structure and deep-merges all keys from all YAML files found from a root path to an edge. For each leaf directory, a file will be created under `--output-dir`.Under each level, there is a mandatory &quot;level key&quot; that is used by config-merger for computing the end result. This key should be present in one of the files under each level. (eg. env.yaml under env).### Extra merger featuresApart from the standard features found in the `PyYaml` library, the `himl-config-merger` component also implements a custom YAML tag called `!include`.Example:```yamlVA7:     !include configs/env=int/region=va7/kafka-brokers.yaml regionBrokers.VA7```This will replace the value after interpolation with the value of the regionBrokers.VA7 found under the configs/env=int/region=va7/kafka-brokers.yaml path.## Custom merge strategyAn optional parameter `type_strategies` can be passed into ConfigProcessor to define custom merging behavior. It could be custom functions that fit your needs.Your function should take the arguments of (config, path, base, nxt) and return the merged result.Example:```pyfrom himl import ConfigProcessordef strategy_merge_override(config, path, base, nxt):    &quot;&quot;&quot;merge list of dicts. if objects have same id, nxt replaces base.&quot;&quot;&quot;    &quot;&quot;&quot;if remove flag is present in nxt item, remove base and not add nxt&quot;&quot;&quot;    result = deepcopy(base)    for nxto in nxt:        for baseo in result:            # if list is not a list of dicts, bail out and let the next strategy to execute            if not isinstance(baseo,dict) or not isinstance(nxto,dict):                return STRATEGY_END            if 'id' in baseo and 'id' in nxto and baseo['id'] == nxto['id']:                result.remove(baseo) #same id, remove previous item        if 'remove' not in nxto:            result.append(nxto)    return resultconfig_processor = ConfigProcessor()path = &quot;examples/simple/production&quot;filters = () # can choose to output only specific keysexclude_keys = () # can choose to remove specific keysoutput_format = &quot;yaml&quot; # yaml/jsonconfig_processor.process(path=path, filters=filters, exclude_keys=exclude_keys,                         output_format=output_format, print_data=True,                         type_strategies= [(list, [strategy_merge_override,'append']), (dict, [&quot;merge&quot;])] ))```</longdescription>
</pkgmetadata>