<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>backoff=======.. image:: https://travis-ci.org/litl/backoff.svg    :target: https://travis-ci.org/litl/backoff.. image:: https://coveralls.io/repos/litl/backoff/badge.svg    :target: https://coveralls.io/r/litl/backoff?branch=python-3.. image:: https://github.com/litl/backoff/workflows/CodeQL/badge.svg    :target: https://github.com/litl/backoff/actions/workflows/codeql-analysis.yml.. image:: https://img.shields.io/pypi/v/backoff.svg    :target: https://pypi.python.org/pypi/backoff.. image:: https://img.shields.io/github/license/litl/backoff    :target: https://github.com/litl/backoff/blob/master/LICENSE**Function decoration for backoff and retry**This module provides function decorators which can be used to wrap afunction such that it will be retried until some condition is met. Itis meant to be of use when accessing unreliable resources with thepotential for intermittent failures i.e. network resources and externalAPIs. Somewhat more generally, it may also be of use for dynamicallypolling resources for externally generated content.Decorators support both regular functions for synchronous code and`asyncio &lt;https://docs.python.org/3/library/asyncio.html&gt;`__'s coroutinesfor asynchronous code.Examples========Since Kenneth Reitz's `requests &lt;http://python-requests.org&gt;`_ modulehas become a defacto standard for synchronous HTTP clients in Python,networking examples below are written using it, but it is in no way requiredby the backoff module.@backoff.on_exception---------------------The ``on_exception`` decorator is used to retry when a specified exceptionis raised. Here's an example using exponential backoff when any``requests`` exception is raised:.. code-block:: python    @backoff.on_exception(backoff.expo,                          requests.exceptions.RequestException)    def get_url(url):        return requests.get(url)The decorator will also accept a tuple of exceptions for cases wherethe same backoff behavior is desired for more than one exception type:.. code-block:: python    @backoff.on_exception(backoff.expo,                          (requests.exceptions.Timeout,                           requests.exceptions.ConnectionError))    def get_url(url):        return requests.get(url)**Give Up Conditions**Optional keyword arguments can specify conditions under which to giveup.The keyword argument ``max_time`` specifies the maximum amountof total time in seconds that can elapse before giving up... code-block:: python    @backoff.on_exception(backoff.expo,                          requests.exceptions.RequestException,                          max_time=60)    def get_url(url):        return requests.get(url)Keyword argument ``max_tries`` specifies the maximum number of callsto make to the target function before giving up... code-block:: python    @backoff.on_exception(backoff.expo,                          requests.exceptions.RequestException,                          max_tries=8,                          jitter=None)    def get_url(url):        return requests.get(url)In some cases the raised exception instance itself may need to beinspected in order to determine if it is a retryable condition. The``giveup`` keyword arg can be used to specify a function which acceptsthe exception and returns a truthy value if the exception should notbe retried:.. code-block:: python    def fatal_code(e):        return 400 &lt;= e.response.status_code &lt; 500    @backoff.on_exception(backoff.expo,                          requests.exceptions.RequestException,                          max_time=300,                          giveup=fatal_code)    def get_url(url):        return requests.get(url)By default, when a give up event occurs, the exception in question is reraisedand so code calling an `on_exception`-decorated function may stillneed to do exception handling. This behavior can optionally be disabledusing the `raise_on_giveup` keyword argument.In the code below, `requests.exceptions.RequestException` will not be raisedwhen giveup occurs. Note that the decorated function will return `None` in thiscase, regardless of the logic in the `on_exception` handler... code-block:: python    def fatal_code(e):        return 400 &lt;= e.response.status_code &lt; 500    @backoff.on_exception(backoff.expo,                          requests.exceptions.RequestException,                          max_time=300,                          raise_on_giveup=False,                          giveup=fatal_code)    def get_url(url):        return requests.get(url)This is useful for non-mission critical code where you still wish to retrythe code inside of `backoff.on_exception` but wish to proceed with executioneven if all retries fail.@backoff.on_predicate---------------------The ``on_predicate`` decorator is used to retry when a particularcondition is true of the return value of the target function.  This maybe useful when polling a resource for externally generated content.Here's an example which uses a fibonacci sequence backoff when thereturn value of the target function is the empty list:.. code-block:: python    @backoff.on_predicate(backoff.fibo, lambda x: x == [], max_value=13)    def poll_for_messages(queue):        return queue.get()Extra keyword arguments are passed when initializing thewait generator, so the ``max_value`` param above is passed as a keywordarg when initializing the fibo generator.When not specified, the predicate param defaults to the falsey test,so the above can more concisely be written:.. code-block:: python    @backoff.on_predicate(backoff.fibo, max_value=13)    def poll_for_message(queue):        return queue.get()More simply, a function which continues polling every second until itgets a non-falsey result could be defined like like this:.. code-block:: python    @backoff.on_predicate(backoff.constant, jitter=None, interval=1)    def poll_for_message(queue):        return queue.get()The jitter is disabled in order to keep the polling frequency fixed.  @backoff.runtime----------------You can also use the ``backoff.runtime`` generator to make use of thereturn value or thrown exception of the decorated method.For example, to use the value in the ``Retry-After`` header of the response:.. code-block:: python    @backoff.on_predicate(        backoff.runtime,        predicate=lambda r: r.status_code == 429,        value=lambda r: int(r.headers.get(&quot;Retry-After&quot;)),        jitter=None,    )    def get_url():        return requests.get(url)Jitter------A jitter algorithm can be supplied with the ``jitter`` keyword arg toeither of the backoff decorators. This argument should be a functionaccepting the original unadulterated backoff value and returning it'sjittered counterpart.As of version 1.2, the default jitter function ``backoff.full_jitter``implements the 'Full Jitter' algorithm as defined in the AWSArchitecture Blog's `Exponential Backoff And Jitter&lt;https://www.awsarchitectureblog.com/2015/03/backoff.html&gt;`_ post.Note that with this algorithm, the time yielded by the wait generatoris actually the *maximum* amount of time to wait.Previous versions of backoff defaulted to adding some random number ofmilliseconds (up to 1s) to the raw sleep value. If desired, thisbehavior is now available as ``backoff.random_jitter``.Using multiple decorators-------------------------The backoff decorators may also be combined to specify differentbackoff behavior for different cases:.. code-block:: python    @backoff.on_predicate(backoff.fibo, max_value=13)    @backoff.on_exception(backoff.expo,                          requests.exceptions.HTTPError,                          max_time=60)    @backoff.on_exception(backoff.expo,                          requests.exceptions.Timeout,                          max_time=300)    def poll_for_message(queue):        return queue.get()Runtime Configuration---------------------The decorator functions ``on_exception`` and ``on_predicate`` aregenerally evaluated at import time. This is fine when the keyword argsare passed as constant values, but suppose we want to consult adictionary with configuration options that only become available atruntime. The relevant values are not available at import time. Instead,decorator functions can be passed callables which are evaluated atruntime to obtain the value:.. code-block:: python    def lookup_max_time():        # pretend we have a global reference to 'app' here        # and that it has a dictionary-like 'config' property        return app.config[&quot;BACKOFF_MAX_TIME&quot;]    @backoff.on_exception(backoff.expo,                          ValueError,                          max_time=lookup_max_time)Event handlers--------------Both backoff decorators optionally accept event handler functionsusing the keyword arguments ``on_success``, ``on_backoff``, and ``on_giveup``.This may be useful in reporting statistics or performing other customlogging.Handlers must be callables with a unary signature accepting a dictargument. This dict contains the details of the invocation. Valid keysinclude:* *target*: reference to the function or method being invoked* *args*: positional arguments to func* *kwargs*: keyword arguments to func* *tries*: number of invocation tries so far* *elapsed*: elapsed time in seconds so far* *wait*: seconds to wait (``on_backoff`` handler only)* *value*: value triggering backoff (``on_predicate`` decorator only)A handler which prints the details of the backoff event could beimplemented like so:.. code-block:: python    def backoff_hdlr(details):        print (&quot;Backing off {wait:0.1f} seconds after {tries} tries &quot;               &quot;calling function {target} with args {args} and kwargs &quot;               &quot;{kwargs}&quot;.format(**details))    @backoff.on_exception(backoff.expo,                          requests.exceptions.RequestException,                          on_backoff=backoff_hdlr)    def get_url(url):        return requests.get(url)**Multiple handlers per event type**In all cases, iterables of handler functions are also accepted, whichare called in turn. For example, you might provide a simple list ofhandler functions as the value of the ``on_backoff`` keyword arg:.. code-block:: python    @backoff.on_exception(backoff.expo,                          requests.exceptions.RequestException,                          on_backoff=[backoff_hdlr1, backoff_hdlr2])    def get_url(url):        return requests.get(url)**Getting exception info**In the case of the ``on_exception`` decorator, all ``on_backoff`` and``on_giveup`` handlers are called from within the except block for theexception being handled. Therefore exception info is available to thehandler functions via the python standard library, specifically``sys.exc_info()`` or the ``traceback`` module. The exception is alsoavailable at the *exception* key in the `details` dict passed to thehandlers.Asynchronous code-----------------Backoff supports asynchronous execution in Python 3.5 and above.To use backoff in asynchronous code based on`asyncio &lt;https://docs.python.org/3/library/asyncio.html&gt;`__you simply need to apply ``backoff.on_exception`` or ``backoff.on_predicate``to coroutines.You can also use coroutines for the ``on_success``, ``on_backoff``, and``on_giveup`` event handlers, with the interface otherwise being identical.The following examples use `aiohttp &lt;https://aiohttp.readthedocs.io/&gt;`__asynchronous HTTP client/server library... code-block:: python    @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60)    async def get_url(url):        async with aiohttp.ClientSession(raise_for_status=True) as session:            async with session.get(url) as response:                return await response.text()Logging configuration---------------------By default, backoff and retry attempts are logged to the 'backoff'logger. By default, this logger is configured with a NullHandler, sothere will be nothing output unless you configure a handler.Programmatically, this might be accomplished with something as simpleas:.. code-block:: python    logging.getLogger('backoff').addHandler(logging.StreamHandler())The default logging level is INFO, which corresponds to logginganytime a retry event occurs. If you would instead like to logonly when a giveup event occurs, set the logger level to ERROR... code-block:: python    logging.getLogger('backoff').setLevel(logging.ERROR)It is also possible to specify an alternate logger with the ``logger``keyword argument.  If a string value is specified the logger will belooked up by name... code-block:: python   @backoff.on_exception(backoff.expo,                         requests.exceptions.RequestException, logger='my_logger')   # ...It is also supported to specify a Logger (or LoggerAdapter) objectdirectly... code-block:: python    my_logger = logging.getLogger('my_logger')    my_handler = logging.StreamHandler()    my_logger.addHandler(my_handler)    my_logger.setLevel(logging.ERROR)    @backoff.on_exception(backoff.expo,                          requests.exceptions.RequestException,  logger=my_logger)    # ...Default logging can be disabled all together by specifying``logger=None``. In this case, if desired alternative logging behaviorcould be defined by using custom event handlers.</longdescription>
</pkgmetadata>