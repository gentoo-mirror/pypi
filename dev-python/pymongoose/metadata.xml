<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># PymongooseThis is a pymongo helper package, that let you make more complicated actions with your collections.It gives you the possibility to populate between packages without needs of creating an aggregation by yourself.Gives you the basic actions such as find, update and delete, with more simplicity.Pymongoose came with a Schema class that let you work with more efficiency and organization# First Steps```bashpip install pymongoose pymongo```## Create a model:models/role.py```pythonimport datetimefrom pymongoose import methodsfrom pymongoose.mongo_types import Types, Schema, MongoException, MongoErrorfrom bson import json_utilfrom bson.objectid import ObjectIdclass Role(Schema):    schema_name = &quot;roles&quot; # Name of the schema that mongo uses        # Attributes    id = None    name = None    action = None    def __init__(self, **kwargs):        self.schema = {            &quot;name&quot;: {                &quot;type&quot;: Types.String,                &quot;required&quot;: True            },            &quot;actions&quot;: [{                &quot;type&quot;: Types.String,                &quot;required&quot;: True            }]        }        super().__init__(self.schema_name, self.schema, kwargs)    def __str__(self):        return f&quot;Role: {self.name}, Actions: {self.action}&quot;```**Is higly recommended to follow this model for any schema**## Mongo ConfigurationThis mongo configuration is required for pymongoose to work correctlydb.py:```python    import os, traceback    import signal     from pymongo import MongoClient    from pymongoose.methods import set_schemas, get_cursor_length    from models.role import Role    MONGO_URI = os.environ.get(&quot;MONGO_URI&quot;)    mongo_db = None    def mongo_init ():        global mongo_db        client = MongoClient(MONGO_URI)        db = client.test        try:            # Now schemas can be set in two ways                        #-&gt; In a dict mode            schemas = {                &quot;roles&quot;: Role(empty=True).schema            }            set_schemas(db, schemas)            #-&gt; Or in a list mode            set_schemas_from_list (db, [Role (empty=True)])            print(&quot;MongoDB Connected!&quot;)        except:            traceback.print_exc()            print(&quot;Error initializing database&quot;)            exit(1)    if __name__ == &quot;__main__&quot;:        mongo_init()```## Examples:- For more model examples check examples/### Insert function: ```pythonuser = User(    name=&quot;TestA&quot;,    password=&quot;test&quot;,    role=role.id)id = user.save()```user.save() will throw an exception if a field marked as required in schema is **None**.### Find function:```pythonusers = User.find({})for user in users:    user = User.parse(user)```This will return a cursor of elements, which can be parsed into User model for a better management.### Find one function:```pythonuser = User.find({}, one=True)# ORuser = User.find_one ({})```This will return a User element with fields obtained by database, if you prefer a json just add ```pythonparse = False```At last of the **find** statement.### Find by id function:```python# this Function will search for &quot;_id&quot; field # so id must be a hex24 string or ObjectIduser = User.find_by_id(id)# for a complete useruser = User.find_by_id(id, select={&quot;name&quot;: 1, &quot;username&quot;: 1})# For a custom user```This will return a User element with fields obtained by database, if you prefer a json just add ```pythonparse = False```At last of the **find** statement.### Populate a search:```pythonuser = User.find_by_id(id, populate=[    {        &quot;path&quot;: &quot;role&quot;,        &quot;select&quot;: [&quot;name&quot;, &quot;actions&quot;],        &quot;options&quot;: [&quot;actions&quot;]    }])# For an extensive populate# oruser = User.find_by_id(id, populate=[&quot;role&quot;])# For a simple populate```This will return a User element with fields obtained by databasePopulate is a really useful tool when we work with difficult or complex models, with pymongoose you wont need to create an extensive aggregation to lookup for elements.Populate works with simple ids like:```pythonschema = {    &quot;name&quot;: {        &quot;type&quot;: Types.String,        &quot;required&quot;: True    },    &quot;role&quot;: { # &lt;- Simple field        &quot;type&quot;: Types.ObjectId,        &quot;ref&quot;: &quot;roles&quot;    }}```lists: ```pythonschema = {    &quot;name&quot;: {        &quot;type&quot;: Types.String,        &quot;required&quot;: True    },    &quot;logs&quot;: [{ # &lt;- List field        &quot;type&quot;: Types.ObjectId,        &quot;ref&quot;: &quot;logs&quot;    }]}```and complex models```pythonschema = {    &quot;name&quot;: {        &quot;type&quot;: Types.String,        &quot;required&quot;: True    },    &quot;friends&quot;: [{         &quot;friend&quot;: {            &quot;type&quot;: Types.ObjectId, # &lt;- Complex list field            &quot;ref&quot;: &quot;friends&quot;        },        &quot;frequent&quot;: {            &quot;type&quot;: Types.Boolean,            &quot;default&quot;: False        }    }]}```Pymongoose can recursively populate fields like this:```python    #menu schema:    menu_schema = {        # ...        &quot;items&quot;:[            {                &quot;type&quot;:Types.ObjectId,                &quot;ref&quot;:&quot;items&quot;            }        ],        # ...    }    #item schema:    item_schema: {        # ...        &quot;drink&quot;:{            &quot;type&quot;:Types.ObjectId,            &quot;ref&quot;:&quot;drinks&quot;        },        &quot;dish&quot;:{            &quot;type&quot;:Types.ObjectId,            &quot;ref&quot;:&quot;dishes&quot;        }        # ...    }    #Populate    menus = Menu.find({}, populate=[{        &quot;path&quot;: &quot;items&quot;,        &quot;options&quot;: [&quot;dish&quot;, &quot;drink&quot;]    }])    for menu in menus:        print(menu)```This will return a CursorCommand elementIn this example all menus populate each item of their array, at same time element dish and drink are populated, returning a complete array of populated menus with populated items.## Parsed finds:**pymongoose** has the ability to parse the return cursor as different types:Available types are    - IF **AS_DEFAULT(0)**, will return cursor if one == False, else a dict if parse == False    - IF **AS_DICT(1)**, will return a list of dicts if one == False, else as serializable dict    - IF **AS_STRING(2)**, will return a parsed list of dicts as str if one == False, else as a str parsed serializable dict*Note: In case you don't need a serializable dict, left cursor **AS_DEFAULT**## Update item:```pythoncount = User.update({},            {                &quot;$set&quot;: {                    &quot;password&quot;: &quot;0&quot;                }            }, many=True        ) #many is set to False by default```## Delete item:```pythoncount = User.delete({}, many=True) #many is set to False by default```# Note:If you are working with vscode I have already created a model snippet to save you a lots of time:https://github.com/Djcharles26/pymongoose/blob/master/pymongoose-snippets.jsonFor using this you must copy them to your python snippets:1. CTRL + SHIFT + P2. Configure User snippets3. python.json4. Copy snippets in blob5. Paste them in your user python.json</longdescription>
</pkgmetadata>