<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># cloudpickle[![Automated Tests](https://github.com/cloudpipe/cloudpickle/workflows/Automated%20Tests/badge.svg?branch=master&amp;event=push)](https://github.com/cloudpipe/cloudpickle/actions)[![codecov.io](https://codecov.io/github/cloudpipe/cloudpickle/coverage.svg?branch=master)](https://codecov.io/github/cloudpipe/cloudpickle?branch=master)`cloudpickle` makes it possible to serialize Python constructs not supportedby the default `pickle` module from the Python standard library.`cloudpickle` is especially useful for **cluster computing** where Pythoncode is shipped over the network to execute on remote hosts, possibly closeto the data.Among other things, `cloudpickle` supports pickling for **lambda functions**along with **functions and classes defined interactively** in the`__main__` module (for instance in a script, a shell or a Jupyter notebook).Cloudpickle can only be used to send objects between the **exact same versionof Python**.Using `cloudpickle` for **long-term object storage is not supported andstrongly discouraged.****Security notice**: one should **only load pickle data from trusted sources** asotherwise `pickle.load` can lead to arbitrary code execution resulting in a criticalsecurity vulnerability.Installation------------The latest release of `cloudpickle` is available from[pypi](https://pypi.python.org/pypi/cloudpickle):    pip install cloudpickleExamples--------Pickling a lambda expression:```python&gt;&gt;&gt; import cloudpickle&gt;&gt;&gt; squared = lambda x: x ** 2&gt;&gt;&gt; pickled_lambda = cloudpickle.dumps(squared)&gt;&gt;&gt; import pickle&gt;&gt;&gt; new_squared = pickle.loads(pickled_lambda)&gt;&gt;&gt; new_squared(2)4```Pickling a function interactively defined in a Python shell session(in the `__main__` module):```python&gt;&gt;&gt; CONSTANT = 42&gt;&gt;&gt; def my_function(data: int) -&gt; int:...     return data + CONSTANT...&gt;&gt;&gt; pickled_function = cloudpickle.dumps(my_function)&gt;&gt;&gt; depickled_function = pickle.loads(pickled_function)&gt;&gt;&gt; depickled_function&lt;function __main__.my_function(data:int) -&gt; int&gt;&gt;&gt;&gt; depickled_function(43)85```Overriding pickle's serialization mechanism for importable constructs:----------------------------------------------------------------------An important difference between `cloudpickle` and `pickle` is that`cloudpickle` can serialize a function or class **by value**, whereas `pickle`can only serialize it **by reference**. Serialization by reference treatsfunctions and classes as attributes of modules, and pickles them throughinstructions that trigger the import of their module at load time.Serialization by reference is thus limited in that it assumes that the modulecontaining the function or class is available/importable in the unpicklingenvironment. This assumption breaks when pickling constructs defined in aninteractive session, a case that is automatically detected by `cloudpickle`,that pickles such constructs **by value**.Another case where the importability assumption is expected to break is whendeveloping a module in a distributed execution environment: the workerprocesses may not have access to the said module, for example if they live on adifferent machine than the process in which the module is being developed. Byitself, `cloudpickle` cannot detect such &quot;locally importable&quot; modules andswitch to serialization by value; instead, it relies on its default mode, whichis serialization by reference. However, since `cloudpickle 2.0.0`, one canexplicitly specify modules for which serialization by value should be used,using the`register_pickle_by_value(module)`/`/unregister_pickle_by_value(module)` API:```python&gt;&gt;&gt; import cloudpickle&gt;&gt;&gt; import my_module&gt;&gt;&gt; cloudpickle.register_pickle_by_value(my_module)&gt;&gt;&gt; cloudpickle.dumps(my_module.my_function)  # my_function is pickled by value&gt;&gt;&gt; cloudpickle.unregister_pickle_by_value(my_module)&gt;&gt;&gt; cloudpickle.dumps(my_module.my_function)  # my_function is pickled by reference```Using this API, there is no need to re-install the new version of the module onall the worker nodes nor to restart the workers: restarting the client Pythonprocess with the new source code is enough.Note that this feature is still **experimental**, and may fail in the followingsituations:- If the body of a function/class pickled by value contains an `import` statement:  ```python  &gt;&gt;&gt; def f():  &gt;&gt;&gt; ... from another_module import g  &gt;&gt;&gt; ... # calling f in the unpickling environment may fail if another_module  &gt;&gt;&gt; ... # is unavailable  &gt;&gt;&gt; ... return g() + 1  ```- If a function pickled by reference uses a function pickled by value during its execution.Running the tests------------------ With `tox`, to test run the tests for all the supported versions of  Python and PyPy:      pip install tox      tox  or alternatively for a specific environment:      tox -e py312- With `pytest` to only run the tests for your current version of  Python:      pip install -r dev-requirements.txt      PYTHONPATH='.:tests' pytestHistory-------`cloudpickle` was initially developed by [picloud.com](http://web.archive.org/web/20140721022102/http://blog.picloud.com/2013/11/17/picloud-has-joined-dropbox/) and shipped as part ofthe client SDK.A copy of `cloudpickle.py` was included as part of PySpark, the Pythoninterface to [Apache Spark](https://spark.apache.org/). Davies Liu, JoshRosen, Thom Neale and other Apache Spark developers improved it significantly,most notably to add support for PyPy and Python 3.The aim of the `cloudpickle` project is to make that work available to a wideraudience outside of the Spark ecosystem and to make it easier to improve itfurther notably with the help of a dedicated non-regression test suite.</longdescription>
</pkgmetadata>