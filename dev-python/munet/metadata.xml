<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>#+STARTUP: indent* μNET (munet)#+html: &lt;a href=&quot;https://github.com/LabNConsulting/munet/actions&quot;&gt;&lt;img src=&quot;https://github.com/LabNConsulting/munet/actions/workflows/ci.yml/badge.svg?branch=main&quot;&gt;&lt;/a&gt;#+html: &lt;a href=&quot;https://codecov.io/gh/LabNConsulting/munet&quot; &gt;&lt;img src=&quot;https://codecov.io/gh/LabNConsulting/munet/branch/main/graph/badge.svg?token=FD2O4YGDTT&quot;&gt;&lt;/a&gt;#+html: &lt;a href=&quot;https://munet.readthedocs.io/en/latest/&quot;&gt;&lt;img src=&quot;https://readthedocs.org/projects/munet/badge?version=latest&quot;&gt;&lt;/a&gt;#+html: &lt;p&gt;&lt;/p&gt;For better documentation see: https://munet.readthedocs.io/en/latest/A package for creating network topologies and running programs and containerswithin them using linux namepsaces, podman containers and qemu virtual machines.Munet can be run in a standalone mode with a configuration file for launchinglinux shell and container based topologies, as well as be used as a library fromwithin another application to provide the same functionality.** Standalone ConfigThe standalone config can be provided in a number of formats, limited by theavailable encode/decode libraries withing the python environment. As JSON isbuilt in to python that format is always supported. Additionally YAML and TOMLare supported if the corresponding packages are available (i.e., ~PyYAML~ and~toml~).The config itself is defined with a YANG model which is fully defined at the endof this document. Below is an tree diagram of the overal format of a config file:#+NAME: Munet standalone config YANG tree diagram#+CALL: generate-tree(module=labn-munet-config)# Remove the #+RESULTS: before pushing to git, github is broken and# won't render it#+begin_examplemodule: labn-munet-config  +--rw cli  |  +--rw commands* [name]  |     +--rw exec?          string  |     +--rw exec-kind* [kind]  |     |  +--rw kind    string  |     |  +--rw exec?   string  |     +--rw format?        string  |     +--rw help?          string  |     +--rw interactive?   boolean  |     +--rw kinds*         -&gt; ../../../kinds/name  |     +--rw name           string  |     +--rw new-window?    boolean  |     +--rw top-level?     boolean  +--rw kinds* [name]  |  +--rw merge*         string  |  +--rw cap-add*       string  |  +--rw cap-remove*    string  |  +--rw cmd?           string  |  +--rw cleanup-cmd?   string  |  +--rw image?         string  |  +--rw server?        string  |  +--rw server-port?   uint16  |  +--rw qemu  |  |  +--rw bios?            string  |  |  +--rw disk?            string  |  |  +--rw kerenel?         string  |  |  +--rw initrd?          string  |  |  +--rw kvm?             boolean  |  |  +--rw ncpu?            uint32  |  |  +--rw memory?          string  |  |  +--rw root?            string  |  |  +--rw cmdline-extra?   string  |  |  +--rw extra-args?      string  |  |  +--rw console  |  |     +--rw user?       string  |  |     +--rw password?   string  |  |     +--rw expects*    string  |  |     +--rw sends*      string  |  |     +--rw timeout?    uint32  |  +--rw connections* [to]  |  |  +--rw to                    string  |  |  +--rw ip?                   string  |  |  +--rw name?                 string  |  |  +--rw hostintf?             string  |  |  +--rw physical?             string  |  |  +--rw remote-name?          string  |  |  +--rw driver?               string  |  |  +--rw delay?                uint64  |  |  +--rw jitter?               uint64  |  |  +--rw jitter-correlation?   decimal64  |  |  +--rw loss?                 uint64  |  |  +--rw loss-correlation?     decimal64  |  |  +--rw rate  |  |     +--rw rate?    number64  |  |     +--rw limit?   number64  |  |     +--rw burst?   number64  |  +--rw env* [name]  |  |  +--rw name     string  |  |  +--rw value?   string  |  +--rw gdb-cmd?       string  |  +--rw gdb-run-cmd*   string  |  +--rw init?          union  |  +--rw mounts* [destination]  |  |  +--rw destination    string  |  |  +--rw source?        string  |  |  +--rw tmpfs-size?    string  |  |  +--rw type?          string  |  +--rw name           string  |  +--rw podman  |  |  +--rw extra-args*   string  |  +--rw privileged?    boolean  |  +--rw shell?         union  |  +--rw volumes*       string  +--rw topology  |  +--rw dns-network?           -&gt; ../networks/name  |  +--rw ipv6-enable?           boolean  |  +--rw networks-autonumber?   boolean  |  +--rw networks* [name]  |  |  +--rw name    string  |  |  +--rw ip?     string  |  +--rw nodes* [name]  |     +--rw id?            uint32  |     +--rw kind?          -&gt; ../../../kinds/name  |     +--rw cap-add*       string  |     +--rw cap-remove*    string  |     +--rw cmd?           string  |     +--rw cleanup-cmd?   string  |     +--rw image?         string  |     +--rw server?        string  |     +--rw server-port?   uint16  |     +--rw qemu  |     |  +--rw bios?            string  |     |  +--rw disk?            string  |     |  +--rw kerenel?         string  |     |  +--rw initrd?          string  |     |  +--rw kvm?             boolean  |     |  +--rw ncpu?            uint32  |     |  +--rw memory?          string  |     |  +--rw root?            string  |     |  +--rw cmdline-extra?   string  |     |  +--rw extra-args?      string  |     |  +--rw console  |     |     +--rw user?       string  |     |     +--rw password?   string  |     |     +--rw expects*    string  |     |     +--rw sends*      string  |     |     +--rw timeout?    uint32  |     +--rw connections* [to]  |     |  +--rw to                    string  |     |  +--rw ip?                   string  |     |  +--rw name?                 string  |     |  +--rw hostintf?             string  |     |  +--rw physical?             string  |     |  +--rw remote-name?          string  |     |  +--rw driver?               string  |     |  +--rw delay?                uint64  |     |  +--rw jitter?               uint64  |     |  +--rw jitter-correlation?   decimal64  |     |  +--rw loss?                 uint64  |     |  +--rw loss-correlation?     decimal64  |     |  +--rw rate  |     |     +--rw rate?    number64  |     |     +--rw limit?   number64  |     |     +--rw burst?   number64  |     +--rw env* [name]  |     |  +--rw name     string  |     |  +--rw value?   string  |     +--rw gdb-cmd?       string  |     +--rw gdb-run-cmd*   string  |     +--rw init?          union  |     +--rw mounts* [destination]  |     |  +--rw destination    string  |     |  +--rw source?        string  |     |  +--rw tmpfs-size?    string  |     |  +--rw type?          string  |     +--rw name           string  |     +--rw podman  |     |  +--rw extra-args*   string  |     +--rw privileged?    boolean  |     +--rw shell?         union  |     +--rw volumes*       string  +--rw version?    uint32#+end_example** Examples*** Two Hosts TopologyA very simple config with 2 hosts connected to a mgmt network.In this config the networks are autonumbered which starts with~10.0.0.0/24~. So, ~h1~ will have an ~eth0~ interface with IP~10.0.0.1~ and ~h2~ will likewise have an ~eth0~ interface, and an IPof ~10.0.0.2~.#+begin_src yaml  topology:  networks-autonumber: true  networks:    - name: net0  nodes:    - name: h1      connections: [&quot;net0&quot;]    - name: h2      connections: [&quot;net0&quot;]#+end_src*** Router VMNOTE: This example is testing the boundaries of what munet can dowith a node. Its really here to document how to do this very complexthing. Beginners should probably skip it.Router VMs are very different from standard unix-like OSs. Munet does a lot ofautomatic configuration assuming a unix-like (and mostly Linux) OS. Variousconfiguration parameters need to be set to tune the automatic configuration andassumptions down. Here's an example munet config fragment that shows booting acisco VM using a nexos file system image.#+begin_src yaml  topology:  networks-autonumber: true  dns-network: &quot;mgmt0&quot;  networks:    - name: mgmt0      ip: 192.168.0.254/24      nat: true    - name: net0  nodes:    # ...    - name: r1      kind: cisco      connections:        - to: &quot;mgmt0&quot;          name: &quot;eth1&quot;          driver: &quot;e1000&quot;        - to: &quot;net0&quot;          name: &quot;eth2&quot;          driver: &quot;e1000&quot;  kinds:    - name: cisco      shell: false      cmd: |        terminal terminal-type dumb        terminal length 0        terminal width 511        terminal session 0        conf t        line console        exec-timeout 0        line vty        exec-timeout 0        int mgmt0          ip address 192.168.0.2/24        exit        feature ssh        feature telnet        end      qemu:        unix-os: false        disk: &quot;%CONFIGDIR%/nexus9300v64.10.2.3.F.qcow2&quot;        bios: &quot;open-firmware&quot;        memory: &quot;8192M&quot;        smp: 2        kvm: true        console:          stdio: false          user: &quot;admin&quot;          password: &quot;&quot;          prompt: &quot;(^|\r?\n\r?)switch(\\([^\\)]+\\))?#&quot;          expects:            - &quot;skip - bypass.*yes/skip/no\\)\\[no\\]:&quot;            - &quot;loader &gt; &quot;          sends:            - &quot;skip\n&quot;            - &quot;boot nxos64-cs.10.2.3.F.bin\n&quot;          timeout: 900  cli:    commands:      - name: ssh        exec: &quot;ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null admin@%IPADDR%&quot;        kinds: [&quot;cisco&quot;]        format: &quot;ssh NODE [NODE ...]&quot;        top-level: true        new-window: true#+end_src** Development*** DependenciesμNET requires the following packages:  python3 python3-venvAutomate tests require the following system packages:  podmanEnsure you have poetry setup, the following instructions work around some bugswith poetry:#+begin_src shell  python3 -m venv ~/.poetrybin  source ~/.poetrybin/bin/activate  pip install poetry  pip uninstall keyring#+end_srcNOTE: add &quot;~/.poetrybin/bin&quot; to your $PATHInstall μNET with dependencies:  poetry install --all-extras*** Check your install make*** Run an exampleThe following uses FRR (see https://frrouting.org)   sudo poetry run munet -c examples/frr/ospf/ospf/munet.yamlFor example:#+begin_src shellmunet$ sudo poetry run munet -c examples/frr/ospf/ospf/munet.yaml2022-09-16 13:37:05,603: INFO: Loaded logging config /home/lberger/Code/github/labn/munet/munet/logconf.yaml2022-09-16 13:37:05,609: INFO: Loaded config from /home/lberger/Code/github/labn/munet/examples/frr/ospf/ospf/munet.yaml2022-09-16 13:37:05,623: INFO: Loaded kinds config /home/lberger/Code/github/labn/munet/munet/kinds.yaml2022-09-16 13:37:05,745: INFO: Munet(munet): created2022-09-16 13:37:05,926: INFO: L3NamespaceNode(r1): created2022-09-16 13:37:06,086: INFO: L3NamespaceNode(r2): created2022-09-16 13:37:06,247: INFO: L3NamespaceNode(r3): created2022-09-16 13:37:06,778: INFO: Topology up: rundir: /tmp/unet-root--- Munet CLI Starting ---munet&gt;munet&gt; helpBasic Commands:  cli   :: open a secondary CLI window  help  :: this help  hosts :: list hosts  quit  :: quit the cli  HOST can be a host or one of the following:    - '*' for all hosts    - '.' for the parent munet    - a regex specified between '/' (e.g., '/rtr.*/')New Window Commands:  hterm HOST [HOST ...] :: open terminal[s] on HOST[S] (outside containers), * for all  pcap NETWORK  :: capture packets from NETWORK into file capture-NETWORK.pcap the command is run within a new window which also shows packet summaries  stdout HOST [HOST ...]        :: tail -f on the stdout of the cmd for this node  stdout HOST [HOST ...]        :: tail -f on the stdout of the cmd for this node  term HOST [HOST ...]  :: open terminal[s] (TMUX or XTerm) on HOST[S], * for all  vtysh ROUTER [ROUTER ...]     ::  xterm HOST [HOST ...] :: open XTerm[s] on HOST[S], * for allInline Commands:  [ROUTER ...] COMMAND  :: execute vtysh COMMAND on the router[s]  [HOST ...] sh &lt;SHELL-COMMAND&gt; :: execute &lt;SHELL-COMMAND&gt; on hosts  [HOST ...] shi &lt;INTERACTIVE-COMMAND&gt;  :: execute &lt;INTERACTIVE-COMMAND&gt; on HOST[s]munet&gt; show ip ospf neighbor2022-09-16 13:43:13,172: INFO: Filtering hosts to kinds: ['frr']2022-09-16 13:43:13,172: INFO: Filtered hosts: ['r1', 'r2', 'r3']------ Host: r1 ------Neighbor ID     Pri State           Up Time         Dead Time Address         Interface                        RXmtL RqstL DBsmL172.16.0.2        1 Full/DR         5m21s             33.727s 10.0.1.2        eth0:10.0.1.1                        0     0     0172.16.0.3        1 Full/DR         5m26s             33.735s 10.0.2.3        eth1:10.0.2.1                        0     0     0------- End: r1 ------------ Host: r2 ------Neighbor ID     Pri State           Up Time         Dead Time Address         Interface                        RXmtL RqstL DBsmL172.16.0.1        1 Full/Backup     5m21s             33.707s 10.0.1.1        eth0:10.0.1.2                        0     0     0172.16.0.3        1 Full/DR         5m26s             33.715s 10.0.3.3        eth1:10.0.3.2                        0     0     0------- End: r2 ------------ Host: r3 ------Neighbor ID     Pri State           Up Time         Dead Time Address         Interface                        RXmtL RqstL DBsmL172.16.0.1        1 Full/Backup     5m26s             33.707s 10.0.2.1        eth0:10.0.2.3                        0     0     0172.16.0.2        1 Full/Backup     5m26s             33.706s 10.0.3.2        eth1:10.0.3.3                        0     0     0------- End: r3 ------munet&gt; r1 show ip ospf neighbor2022-09-16 13:43:18,073: INFO: Filtering hosts to kinds: ['frr']2022-09-16 13:43:18,075: INFO: Filtered hosts: ['r1']Neighbor ID     Pri State           Up Time         Dead Time Address         Interface                        RXmtL RqstL DBsmL172.16.0.2        1 Full/DR         5m26s             38.788s 10.0.1.2        eth0:10.0.1.1                        0     0     0172.16.0.3        1 Full/DR         5m31s             38.795s 10.0.2.3        eth1:10.0.2.1                        0     0     0munet&gt;#+end_src** Config Model#+NAME: test-validate-module#+CALL: validate-module(module=labn-munet-config)#+NAME: labn-munet-config#+HEADER: :var dep1=dep-babel#+HEADER: :file labn-munet-config.yang :results output file silent :cache yes#+begin_src yang :exports code  module labn-munet-config {    yang-version 1.1;    namespace &quot;urn:labn:yang:labn-munet-config&quot;;    prefix c;    organization      &quot;LabN Consulting, L.L.C.&quot;;    contact      &quot;Author: Christian Hopps               &lt;mailto:chopps@labn.net&gt;&quot;;    description      &quot;This module defines the configuration state for munet.&quot;;    revision 2021-12-18 {      description &quot;Initial Revision&quot;;      reference &quot;https://github.com/LabNConsulting/munet/blob/main/README.md&quot;;    }    typedef number64 {      type union {        type uint64;        type string {          pattern '[0-9]+([KMGTPE]i?)?';        }      }      description        &quot;A number with optional suffix, where suffix means:           K -&gt; value*10^3, Ki -&gt; value*2^10,           M -&gt; value*10^6, Mi -&gt; value*2^20,           G -&gt; value*10^9, Gi -&gt; value*2^30,           T -&gt; value*10^12, Gi -&gt; value*2^40,           P -&gt; value*10^15, Gi -&gt; value*2^50,           E -&gt; value*10^18, Gi -&gt; value*2^60&quot;;    }    grouping intf-constraints {      description &quot;traffic control based interface constraints&quot;;      leaf delay {        type uint64;        description &quot;number of microseconds of delay&quot;;      }      leaf jitter {        type uint64;        must &quot;../delay&quot;;        description &quot;number of microseconds of possible jitter&quot;;      }      leaf jitter-correlation {        type decimal64 {          fraction-digits 16;          range &quot;0..100&quot;;        }        must &quot;../jitter&quot;;        description &quot;percent correlation between consecutive jitter values&quot;;      }      leaf loss {        type uint64;        must &quot;../delay&quot;;        description &quot;number of microseconds of possible jitter&quot;;      }      leaf loss-correlation {        type decimal64 {          fraction-digits 16;          range &quot;0..100&quot;;        }        must &quot;../loss&quot;;        description &quot;percent correlation between consecutive loss values&quot;;      }      container rate {        description &quot;bits per second maximum rate with possible limit and burst&quot;;        leaf rate {          type number64;          description &quot;bits per second maximum rate&quot;;        }        leaf limit {          type number64;          must &quot;../rate&quot;;          description &quot;bits per second maximum rate&quot;;        }        leaf burst {          type number64;          must &quot;../rate&quot;;          description &quot;bits per second maximum rate&quot;;        }      }    }    grouping common-node {      description &quot;Common node properties&quot;;      leaf-list cap-add {        type string;        description &quot;Capabilities to add to a container.&quot;;        reference &quot;https://man7.org/linux/man-pages/man7/capabilities.7.html&quot;;      }      leaf-list cap-remove {        type string;        description &quot;Capabilities to remove from a container.&quot;;        reference &quot;https://man7.org/linux/man-pages/man7/capabilities.7.html&quot;;      }      leaf cmd {        type string;        description &quot;Shell command[s] to execute when creating the node.&quot;;      }      leaf cleanup-cmd {        type string;        description          &quot;Shell command[s] to execute when deleting the node.           NOTE: With container nodes, the cleanup-cmd will be run           prior to the `cmd` being killed, so that the container is           present. For Qemu/VM nodes the cleanup command is run prior           to the VM being brought down.&quot;;      }      leaf ready-cmd {        type string;        description          &quot;Shell command[s] to execute to determine if the node is ready&quot;;      }      leaf image {        type string;        must &quot;not(../server) and not(../qemu)&quot; {          error-message &quot;Can only have one of image, server or qemu&quot;;        }        description &quot;Container image specification.&quot;;      }      leaf server {        type string;        must &quot;not(../image) and not(../qemu)&quot; {          error-message &quot;Can only have one of image, server or qemu&quot;;        }        description          &quot;Name of server for SSHRemote node functionality. If using           within pytest make sure you utilize the `unet_share` fixture           instead of the normal `unet` one, otherwise ssh may not           work as it is executing inside the munet namespace.&quot;;      }      leaf server-port {        type uint16;        must &quot;../server&quot; {          error-message &quot;server-port requires a server&quot;;        }        default 22;        description          &quot;SSH port to connect to server on&quot;;      }      container qemu {        must &quot;not(../image) and not(../server)&quot; {          error-message &quot;Can only have one of image, server or qemu&quot;;        }        description &quot;Specify parameters for Qemu VM node&quot;;        leaf bios {          type string;          description            &quot;'open-firmare' to use open firmware bios, or a path to             bios image file&quot;;        }        leaf disk {          type string;          description &quot;path to disk image possibly to boot from&quot;;        }        leaf kerenel {          type string;          description &quot;path to kernel image (e.g,. bzImage) to boot&quot;;        }        leaf initrd {          type string;          description &quot;path to initrd image (e.g,. rootfs.ext2) to boot&quot;;        }        leaf kvm {          type boolean;          default true;          description &quot;Run with HW acceleration&quot;;        }        leaf ncpu {          type uint32;          default 1;          description &quot;Number of cores&quot;;        }        leaf memory {          type string;          default &quot;512M&quot;;          description &quot;ammount of memory for VM.&quot;;        }        leaf root {          type string;          default &quot;/dev/ram0&quot;;          description &quot;root file system passed in cmdline as root=&lt;value&gt;&quot;;        }        leaf cmdline-extra {          type string;          description &quot;string to add to the kernel cmdline (qemu -append)&quot;;        }        leaf extra-args {          type string;          description &quot;extra qemu args passed when launching&quot;;        }        container console {          description &quot;Configuration for console handling&quot;;          leaf user {            type string;            description &quot;User to login to console with&quot;;          }          leaf password {            type string;            description &quot;Password to login to console with&quot;;          }          leaf-list expects {            type string;            description &quot;Strings to expect for logging into the console&quot;;          }          leaf-list sends {            type string;            description              &quot;Strings paired to `expects` for logging into the               console. These are sent to the console when the               corresponding expect is seen, zero length strings are               allowed which indicate send nothing. An Expect with a               send nothing could be used to reset the timeout timer on               long boots&quot;;          }          leaf timeout {            type uint32;            description &quot;Timeout for logging into the console&quot;;          }        }      }      list connections {        key to;        description &quot;Connections to other networks or nodes from this node&quot;;        leaf to {          type string;          description &quot;The target of this connection.&quot;;        }        leaf ip {          type string;          description &quot;IPv4 address and mask for the connection (interface).&quot;;        }        leaf ipv6 {          type string;          description &quot;IPv6 address and mask for the connection (interface).&quot;;        }        leaf name {          type string;          description &quot;Name for the connection (interface name).&quot;;        }        leaf hostintf {          type string;          description &quot;Host interface name for wired connections&quot;;        }        leaf physical {          type string;          description &quot;Physical interface name for wired connections&quot;;        }        leaf remote-name {          type string;          description            &quot;The remote name of a p2p connection. This is used for disambiguation             when there are multiple point-to-point connections to the same             remote node.&quot;;        }        leaf driver {          type string;          default &quot;virtio-net-pc&quot;;          description &quot;driver name for qemu based interfaces&quot;;        }        uses intf-constraints;      }      list env {        key name;        description          &quot;List of environment variable to add to the `cmd` execution           environment&quot;;        leaf name {          type string;          description &quot;Environment variable name.&quot;;        }        leaf value {          type string;          description &quot;Environment variable value.&quot;;        }      }      leaf gdb-cmd {        type string;        description &quot;Command to execute when --gdb option specified&quot; ;      }      leaf-list gdb-target-cmds {        type string;        description          &quot;GDB commands to execute to prior to setting breakpoints&quot; ;      }      leaf-list gdb-run-cmds {        type string;        description          &quot;GDB commands to send to gdb (e.g., to start the process running)&quot; ;      }      leaf init {        type union {          type boolean;          type string;        }        description &quot;Controls use of an init process.&quot;;      }      list mounts {        key destination;        description          &quot;Mounts to be made inside the namespace. Currently only supported for           container based nodes.&quot;;        leaf destination {          type string;          description            &quot;The inner mount point. If no source is given this will be a tmpfs             mount, otherwise the it is a bind mount from the `source`.&quot;;        }        leaf source {          type string;          description &quot;The source of the bind mount.&quot;;        }        leaf tmpfs-size {          type string;          description &quot;The size of the tmpfs.&quot;;        }        leaf type {          type string;          description &quot;The type of the mount (currently bind or tmpfs).&quot;;        }      }      leaf name {        type string;        description &quot;Name of this node or kind.&quot;;      }      container podman {        description &quot;Configuration related to podman containers.&quot;;        leaf-list extra-args {          type string;          description &quot;list of CLI arguments to add to the podman run command.&quot;;        }      }      leaf privileged {        type boolean;        description &quot;Controls running the container in privileged mode.&quot;;      }      leaf shell {        type union {          type boolean;          type string;        }        description          &quot;Controls use of an shell process for `cmd` execution. If 'false' then           `cmd` will be run directly with exec(1), otherwise a shell will be           used. If this value is `true` then the default shell will be used,           otherwise it is a string which specifies the path to the shell to           use.&quot;;      }      leaf-list volumes {        type string;        description          &quot;Bind or tmpfs mounts. For bind mounts the format of the string is           &lt;outer&gt;:&lt;inner&gt;, for tmpfs it's simply the inner mount path.&quot;;      }    }    container cli {      description &quot;CLI additions.&quot;;      list commands {        key name;        description &quot;A command to add to the CLI.&quot;;        leaf exec {          type string;          description            &quot;Command to execute when the CLI command is given. The string is             evaluated as a python f-string with `{host}` set to the current             host object (or None) `{unet}` set to the Munet object, and             `{user_input}` to any user input that follows the command (or '' if             none specified).&quot;;        }        list exec-kind {          key kind;          description &quot;A kind specific execution formats.&quot;;          leaf kind {            type string;            description &quot;Kind for which this command format should be used.&quot;;          }          leaf exec {            type string;            description              &quot;Command to execute when the CLI command is given. The string is               evaluated as a python f-string with `{host}` set to the current               host object (or None) `{unet}` set to the Munet object, and               `{user_input}` to any user input that follows the command (or ''               if none specified).&quot;;          }        }        leaf format {          type string;          description            &quot;The format of the command. Used to print help string for user.&quot;;        }        leaf help {          type string;          description            &quot;The description of the command. Used to print help string for             user.&quot;;        }        leaf interactive {          type boolean;          description            &quot;Run the command in interactive pty.&quot;;        }        leaf-list kinds {          type leafref {            path &quot;../../../kinds/name&quot;;          }          description            &quot;List of kinds for which this command should be restricted to             running on.&quot;;        }        leaf name {          type string;          description &quot;CLI command name.&quot;;        }        leaf new-window {          type boolean;          description            &quot;Controls if the command runs in the CLI window or opens a new             terminal window to run the command in.&quot;;        }        leaf top-level {          type boolean;          default false;          description            &quot;If true the command is run in the top-level containing namespace.             This is the namespace from which each of the hosts allocated             sub-namespaces from. Multple hosts are still allowed and their             variables will be substituted accordingly.&quot;;        }      }    }    list kinds {      key name;      description        &quot;List of kinds used to group and share common node properities.&quot;;      leaf-list merge {        type string;        description          &quot;List of properties which should be merged with their node specific           values, rather than being replaced by the node specific version.&quot;;      }      uses common-node;    }    container topology {      description &quot;The topology munet should create.&quot;;      leaf dns-network {        type leafref {          path &quot;../networks/name&quot;;        }        description &quot;network used for DNS addresses of hosts in hosts files.&quot;;      }      leaf ipv6-enable {        type boolean;        default false;        description          &quot;Controls if IPv6 is enabled or disabled.&quot;;      }      leaf networks-autonumber {        type boolean;        description          &quot;Controls if networks and node connections are given IP addresses if           not explicitly configured.&quot;;      }      list networks {        key name;        description &quot;List of networks to create.&quot;;        leaf name {          type string {            length &quot;1..11&quot;;            pattern &quot;[-a-zA-Z0-9_]+&quot;;          }          description &quot;Name of the network&quot;;        }        leaf ip {          type string;          description            &quot;IPv4 prefix for the network. If host bit's are set then the linux             bridge will be assigned that IP.&quot;;        }        leaf ipv6 {          type string;          description            &quot;IPv6 prefix for the network. If host bit's are set then the linux             bridge will be assigned that IP.&quot;;        }      }      list nodes {        key name;        description &quot;Nodes in the topology.&quot;;        leaf id {          type uint32;          description &quot;Explicitly set the ID for the node.&quot;;        }        leaf kind {          type leafref {            path &quot;../../../kinds/name&quot;;          }          description            &quot;Indicate the kind of this node, which pulls in the properies of that             `kind` for this node.&quot;;        }        uses common-node;      }    }    leaf version {      type uint32;      description &quot;version of this config&quot;;    }  }#+end_src* Appendix: Org Babel Functions#+name: dep-babel#+begin_src emacs-lisp :results none :exports none    (org-babel-do-load-languages 'org-babel-load-languages '((shell . t)))    (setq fill-column 69)    (setq org-confirm-babel-evaluate nil)#+end_src#+NAME: generate-tree#+HEADER: :var dep1=dep-babel#+begin_src shell :results output verbatim replace :wrap example :exports results  [ -d /yang ] || DOCKER=&quot;sudo podman run --net=host -v $(pwd):/work docker.io/labn/org-rfc&quot; #  $DOCKER pyang --tree-line-length=69 -f tree ${module} 2&gt; err.out;#+end_src#+NAME: validate-module#+HEADER: :var dep1=dep-babel#+begin_src bash :results output verbatim replace :wrap comment :exports none  [ -d /yang ] || DOCKER=&quot;sudo podman run --net=host -v $(pwd):/work docker.io/labn/org-rfc&quot;  if ! $DOCKER pyang -P build --lax-quote-checks -Werror --lint $module 2&gt;&amp;1; then echo FAIL; fi#+end_src</longdescription>
</pkgmetadata>