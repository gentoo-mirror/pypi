<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>aiohttp_csrf=============The library provides csrf (xsrf) protection for [aiohttp.web](https://docs.aiohttp.org/en/latest/web.html).**Breaking Change:** New in 0.1.0 is Blake3 hashes are used by default. This means you must pass `secret_phrase` to`aiohttp_csrf.storage.SessionStorage`**note:** The package [aiohttp-csrf-fixed](https://pypi.org/project/aiohttp-csrf-fixed) is aiohttp_csrf 0.0.2 +[this commit](https://github.com/oplik0/aiohttp-csrf/commit/b1bd9207f43a2abf30e32e72ecdb10983a251823). The maintainerdidn't submit a PR so I just saw it by chance. I haven't had  time to closely examine it but I think it's just removingthe HTTP security error that happens if no CSRF is provided. Why do that? An HTTP error is good because it tells theclient what happened and lets you handle it by middleware.__0.1.1:__ Converted `@aiohttp_csrf.csrf_exempt` decorator to a co-routine to make it compatible with latest aiohttp.![image](https://img.shields.io/travis/wikibusiness/aiohttp-csrf.svg%0A%20:target:%20https://travis-ci.org/wikibusiness/aiohttp-csrf)Basic usage-----------The library allows you to implement csrf (xsrf) protection for requestsBasic usage example:```pythonimport aiohttp_csrffrom aiohttp import webFORM_FIELD_NAME = '_csrf_token'COOKIE_NAME = 'csrf_token'def make_app():    csrf_policy = aiohttp_csrf.policy.FormPolicy(FORM_FIELD_NAME)    csrf_storage = aiohttp_csrf.storage.CookieStorage(COOKIE_NAME)    app = web.Application()    aiohttp_csrf.setup(app, policy=csrf_policy, storage=csrf_storage)    app.middlewares.append(aiohttp_csrf.csrf_middleware)    async def handler_get_form_with_token(request):        token = await aiohttp_csrf.generate_token(request)        body = '''            &lt;html&gt;                &lt;head&gt;&lt;title&gt;Form with csrf protection&lt;/title&gt;&lt;/head&gt;                &lt;body&gt;                    &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt;                        &lt;input type=&quot;hidden&quot; name=&quot;{field_name}&quot; value=&quot;{token}&quot; /&gt;                        &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;                        &lt;input type=&quot;submit&quot; value=&quot;Say hello&quot;&gt;                    &lt;/form&gt;                &lt;/body&gt;            &lt;/html&gt;        '''  # noqa        body = body.format(field_name=FORM_FIELD_NAME, token=token)        return web.Response(            body=body.encode('utf-8'),            content_type='text/html',        )    async def handler_post_check(request):        post = await request.post()        body = 'Hello, {name}'.format(name=post['name'])        return web.Response(            body=body.encode('utf-8'),            content_type='text/html',        )    app.router.add_route(        'GET',        '/',        handler_get_form_with_token,    )    app.router.add_route(        'POST',        '/',        handler_post_check,    )    return appweb.run_app(make_app())```### InitializeFirst of all, you need to initialize `aiohttp_csrf` in your application:```pythonapp = web.Application()csrf_policy = aiohttp_csrf.policy.FormPolicy(FORM_FIELD_NAME)csrf_storage = aiohttp_csrf.storage.CookieStorage(COOKIE_NAME)aiohttp_csrf.setup(app, policy=csrf_policy, storage=csrf_storage)```### Middleware and decoratorsAfter initialize you can use `@aiohttp_csrf.csrf_protect` for handlers, that you want to protect. Or you caninitialize `aiohttp_csrf.csrf_middleware` and do not disturb about usingdecorator ([full middleware example here](demo/middleware.py)):```python# ...app.middlewares.append(aiohttp_csrf.csrf_middleware)# ...```In this case all your handlers will be protected.**Note:** we strongly recommend to use `aiohttp_csrf.csrf_middleware` and `@aiohttp_csrf.csrf_exempt` instead ofmanually managing with `@aiohttp_csrf.csrf_protect`. But if you prefer to use `@aiohttp_csrf.csrf_protect`, don't forgetto use `@aiohttp_csrf.csrf_protect` for both methods: GET andPOST ([manual protection example](demo/manual_protection.py))If you want to use middleware, but need handlers without protection, you can use `@aiohttp_csrf.csrf_exempt`. Mark youhandler with this decorator and this handler will not check the token:```python@aiohttp_csrf.csrf_exemptasync def handler_post_not_check(request):    ...```### Generate tokenFor generate token you need to call `aiohttp_csrf.generate_token` in your handler:```python@aiohttp_csrf.csrf_protectasync def handler_get(request):    token = await aiohttp_csrf.generate_token(request)    ...```Advanced usage--------------### PoliciesYou can use different policies for check tokens. Library provides 3 types of policy:- **FormPolicy**. This policy will search token in the body of your POST request (Usually use for forms) or as a GET  variable of the same name. You need to specify name of field that will be checked.- **HeaderPolicy**. This policy will search token in headers of your POST request (Usually use for AJAX requests). You  need to specify name of header that will be checked.- **FormAndHeaderPolicy**. This policy combines behavior of **FormPolicy** and **HeaderPolicy**.You can implement your custom policies if needed. But make sure that your custom policyimplements `aiohttp_csrf.policy.AbstractPolicy` interface.### StoragesYou can use different types of storages for storing token. Library provides 2 types of storage:- **CookieStorage**. Your token will be stored in cookie variable. You need to specify cookie name.- **SessionStorage**. Your token will be stored in session. You need to specify session variable name.**Important:** If you want to use session storage, you need setup aiohttp\_session in yourapplication ([session storage example](demo/session_storage.py#L22))You can implement your custom storages if needed. But make sure that your custom storageimplements `aiohttp_csrf.storage.AbstractStorage` interface.### Token generatorsYou can use different token generator in your application. By default storagesusing `aiohttp_csrf.token_generator.SimpleTokenGenerator`But if you need more secure token generator - you can use `aiohttp_csrf.token_generator.HashedTokenGenerator`And you can implement your custom token generators if needed. But make sure that your custom token generatorimplements `aiohttp_csrf.token_generator.AbstractTokenGenerator` interface.### Invalid token behaviorBy default, if token is invalid, `aiohttp_csrf` will raise `aiohttp.web.HTTPForbidden` exception.You have ability to specify your custom error handler. It can be:- **callable instance. Input parameter - aiohttp request.**```pythondef custom_error_handler(request):    # do something    return aiohttp.web.Response(status=403)# orasync def custom_async_error_handler(request):    # await do something    return aiohttp.web.Response(status=403)```It will be called instead of protected handler.- **sub class of Exception**. In this case this Exception will be raised.```pythonclass CustomException(Exception):    pass```You can specify custom error handler globally, when initialize `aiohttp_csrf` in your application:```python...class CustomException(Exception):    pass...aiohttp_csrf.setup(app, policy=csrf_policy, storage=csrf_storage, error_renderer=CustomException)...```In this case custom error handler will be applied to all protected handlers.Or you can specify custom error handler locally, for specific handler:```python...class CustomException(Exception):    pass...@aiohttp_csrf.csrf_protect(error_renderer=CustomException)def handler_with_custom_csrf_error(request):    ...```In this case custom error handler will be applied to this handler only. For all other handlers will be applied globalerror handler.</longdescription>
</pkgmetadata>