<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=================================PostGreSQL/JSONB Data Persistence=================================This document outlines the general capabilities of the ``pjpersist``package. ``pjpersist`` is a PostGreSQL/JSONB storage implementation forpersistent Python objects. It is *not* a storage for the ZODB.The goal of ``pjpersist`` is to provide a data manager that serializesobjects to JSONB blobs at transaction boundaries. The PJ data manager is apersistent data manager, which handles events at transaction boundaries (see``transaction.interfaces.IDataManager``) as well as events from thepersistency framework (see ``persistent.interfaces.IPersistentDataManager``).An instance of a data manager is supposed to have the same life time as thetransaction, meaning that it is assumed that you create a new data managerwhen creating a new transaction:  &gt;&gt;&gt; import transactionNote: The ``conn`` object is a ``psycopg.Connection`` instance. In this caseour tests use the ``pjpersist_test`` database.Let's now define a simple persistent object:  &gt;&gt;&gt; import datetime  &gt;&gt;&gt; import persistent  &gt;&gt;&gt; class Person(persistent.Persistent):  ...  ...     def __init__(self, name, phone=None, address=None, friends=None,  ...                  visited=(), birthday=None):  ...         self.name = name  ...         self.address = address  ...         self.friends = friends or {}  ...         self.visited = visited  ...         self.phone = phone  ...         self.birthday = birthday  ...         self.today = datetime.datetime(2014, 5, 14, 12, 30)  ...  ...     def __str__(self):  ...         return self.name  ...  ...     def __repr__(self):  ...         return '&lt;%s %s&gt;' %(self.__class__.__name__, self)We will fill out the other objects later. But for now, let's create a newperson and store it in PJ:  &gt;&gt;&gt; stephan = Person('Stephan')  &gt;&gt;&gt; stephan  &lt;Person Stephan&gt;The datamanager provides a ``root`` attribute in which the object tree rootscan be stored. It is special in the sense that it immediately writes the datato the DB:  &gt;&gt;&gt; dm.root['stephan'] = stephan  &gt;&gt;&gt; dm.root['stephan']  &lt;Person Stephan&gt;Custom Persistence Tables-------------------------By default, persistent objects are stored in a table having the escapedPython path of the class:  &gt;&gt;&gt; from pjpersist import serialize  &gt;&gt;&gt; person_cn = serialize.get_dotted_name(Person, True)  &gt;&gt;&gt; person_cn  'u__main___dot_Person'  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; dumpTable(person_cn)  [{'data': {'_py_persistent_type': '__main__.Person',             'address': None,             'birthday': None,             'friends': {},             'name': 'Stephan',             'phone': None,             'today': {'_py_type': 'datetime.datetime',                        'value': '2014-05-14T12:30:00.000000'},             'visited': []},    'id': '0001020304050607080a0b0c0'}]As you can see, the stored document for the person looks very much like anatural JSON document. But oh no, I forgot to specify the full name forStephan. Let's do that:  &gt;&gt;&gt; dm.root['stephan'].name = 'Stephan Richter'  &gt;&gt;&gt; dm.root['stephan']._p_changed  TrueThis time, the data is not automatically saved:  &gt;&gt;&gt; fetchone(person_cn)['data']['name']  'Stephan'So we have to commit the transaction first:  &gt;&gt;&gt; dm.root['stephan']._p_changed  True  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; dm.root['stephan']._p_changed  &gt;&gt;&gt; fetchone(person_cn)['data']['name']  'Stephan Richter'Let's now add an address for Stephan. Addresses are also persistent objects:  &gt;&gt;&gt; class Address(persistent.Persistent):  ...     _p_pj_table = 'address'  ...  ...     def __init__(self, city, zip):  ...         self.city = city  ...         self.zip = zip  ...  ...     def __str__(self):  ...         return '%s (%s)' %(self.city, self.zip)  ...  ...     def __repr__(self):  ...         return '&lt;%s %s&gt;' %(self.__class__.__name__, self)pjpersist supports a special attribute called ``_p_pj_table``,which allows you to specify a custom table to use.  &gt;&gt;&gt; stephan = dm.root['stephan']  &gt;&gt;&gt; stephan.address = Address('Maynard', '01754')  &gt;&gt;&gt; stephan.address  &lt;Address Maynard (01754)&gt;Note that the address is not immediately saved in the database:  &gt;&gt;&gt; dumpTable('address', isolate=True)  relation &quot;address&quot; does not exist  ...But once we commit the transaction, everything is available:  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; dumpTable('address')  [{'data': {'_py_persistent_type': '__main__.Address',             'city': 'Maynard',             'zip': '01754'},    'id': '0001020304050607080a0b0c0'}]  &gt;&gt;&gt; dumpTable(person_cn)  [{'data': {'_py_persistent_type': '__main__.Person',             'address': {'_py_type': 'DBREF',                          'database': 'pjpersist_test',                          'id': '0001020304050607080a0b0c0',                          'table': 'address'},             'birthday': None,             'friends': {},             'name': 'Stephan Richter',             'phone': None,             'today': {'_py_type': 'datetime.datetime',                        'value': '2014-05-14T12:30:00.000000'},             'visited': []},    'id': '0001020304050607080a0b0c0'}]  &gt;&gt;&gt; dm.root['stephan'].address  &lt;Address Maynard (01754)&gt;Non-Persistent Objects----------------------As you can see, even the reference looks nice and all components are easilyvisible. But what about arbitrary non-persistent, but picklable,objects? Well, let's create a phone number object for that:  &gt;&gt;&gt; class Phone(object):  ...  ...     def __init__(self, country, area, number):  ...         self.country = country  ...         self.area = area  ...         self.number = number  ...  ...     def __str__(self):  ...         return '%s-%s-%s' %(self.country, self.area, self.number)  ...  ...     def __repr__(self):  ...         return '&lt;%s %s&gt;' %(self.__class__.__name__, self)  &gt;&gt;&gt; dm.root['stephan'].phone = Phone('+1', '978', '394-5124')  &gt;&gt;&gt; dm.root['stephan'].phone  &lt;Phone +1-978-394-5124&gt;Let's now commit the transaction and look at the JSONB document again:  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; dm.root['stephan'].phone  &lt;Phone +1-978-394-5124&gt;  &gt;&gt;&gt; dumpTable(person_cn)  [{'data': {'_py_persistent_type': '__main__.Person',             'address': {'_py_type': 'DBREF',                          'database': 'pjpersist_test',                          'id': '0001020304050607080a0b0c0',                          'table': 'address'},             'birthday': None,             'friends': {},             'name': 'Stephan Richter',             'phone': {'_py_type': '__main__.Phone',                        'area': '978',                        'country': '+1',                        'number': '394-5124'},             'today': {'_py_type': 'datetime.datetime',                        'value': '2014-05-14T12:30:00.000000'},             'visited': []},    'id': '0001020304050607080a0b0c0'}]As you can see, for arbitrary non-persistent objects we need a small hint inthe sub-document, but it is very minimal. If the ``__reduce__`` method returnsa more complex construct, more meta-data is written. We will see that nextwhen storing a date and other arbitrary data:  &gt;&gt;&gt; dm.root['stephan'].friends = {'roy': Person('Roy Mathew')}  &gt;&gt;&gt; dm.root['stephan'].visited = ('Germany', 'USA')  &gt;&gt;&gt; dm.root['stephan'].birthday = datetime.date(1980, 1, 25)  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; dm.root['stephan'].friends  {'roy': &lt;Person Roy Mathew&gt;}  &gt;&gt;&gt; dm.root['stephan'].visited  ['Germany', 'USA']  &gt;&gt;&gt; dm.root['stephan'].birthday  datetime.date(1980, 1, 25)As you can see, a dictionary key is always converted to unicode and tuples arealways maintained as lists, since JSON does not have two sequence types.  &gt;&gt;&gt; import pprint  &gt;&gt;&gt; pprint.pprint(dict(  ...     fetchone(person_cn, &quot;&quot;&quot;data @&gt; '{&quot;name&quot;: &quot;Stephan Richter&quot;}'&quot;&quot;&quot;)))  {'data': {'_py_persistent_type': '__main__.Person',            'address': {'_py_type': 'DBREF',                         'database': 'pjpersist_test',                         'id': '0001020304050607080a0b0c0',                         'table': 'address'},            'birthday': {'_py_type': 'datetime.date',                          'value': '1980-01-25'},            'friends': {'roy': {'_py_type': 'DBREF',                                  'database': 'pjpersist_test',                                  'id': '0001020304050607080a0b0c0',                                  'table': 'u__main___dot_Person'}},            'name': 'Stephan Richter',            'phone': {'_py_type': '__main__.Phone',                       'area': '978',                       'country': '+1',                       'number': '394-5124'},            'today': {'_py_type': 'datetime.datetime',                       'value': '2014-05-14T12:30:00.000000'},            'visited': ['Germany', 'USA']},   'id': '0001020304050607080a0b0c0'}Custom Serializers------------------(A patch to demonstrate)  &gt;&gt;&gt; dm.root['stephan'].birthday = datetime.date(1981, 1, 25)  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; pprint.pprint(  ...     fetchone(person_cn,  ...         &quot;&quot;&quot;data @&gt; '{&quot;name&quot;: &quot;Stephan Richter&quot;}'&quot;&quot;&quot;)['data']['birthday'])  {'_py_type': 'datetime.date', 'value': '1981-01-25'}As you can see, the serialization of the birthay is an ISO string. We can,however, provide a custom serializer that uses the ordinal to store the data.  &gt;&gt;&gt; class DateSerializer(serialize.ObjectSerializer):  ...  ...     def can_read(self, state):  ...         return isinstance(state, dict) and \  ...                state.get('_py_type') == 'custom_date'  ...  ...     def read(self, state):  ...         return datetime.date.fromordinal(state['ordinal'])  ...  ...     def can_write(self, obj):  ...         return isinstance(obj, datetime.date)  ...  ...     def write(self, obj):  ...         return {'_py_type': 'custom_date',  ...                 'ordinal': obj.toordinal()}  &gt;&gt;&gt; serialize.SERIALIZERS.append(DateSerializer())  &gt;&gt;&gt; dm.root['stephan']._p_changed = True  &gt;&gt;&gt; transaction.commit()Let's have a look again:  &gt;&gt;&gt; dm.root['stephan'].birthday  datetime.date(1981, 1, 25)  &gt;&gt;&gt; pprint.pprint(dict(  ...     fetchone(person_cn, &quot;&quot;&quot;data @&gt; '{&quot;name&quot;: &quot;Stephan Richter&quot;}'&quot;&quot;&quot;)))  {'data': {'_py_persistent_type': '__main__.Person',            'address': {'_py_type': 'DBREF',                         'database': 'pjpersist_test',                         'id': '0001020304050607080a0b0c0',                         'table': 'address'},            'birthday': {'_py_type': 'custom_date', 'ordinal': 723205},            'friends': {'roy': {'_py_type': 'DBREF',                                  'database': 'pjpersist_test',                                  'id': '0001020304050607080a0b0c0',                                  'table': 'u__main___dot_Person'}},            'name': 'Stephan Richter',            'phone': {'_py_type': '__main__.Phone',                       'area': '978',                       'country': '+1',                       'number': '394-5124'},            'today': {'_py_type': 'custom_date', 'ordinal': 735367},            'visited': ['Germany', 'USA']},   'id': '0001020304050607080a0b0c0'}Much better!  &gt;&gt;&gt; del serialize.SERIALIZERS[:]Persistent Objects as Sub-Documents-----------------------------------In order to give more control over which objects receive their own tablesand which do not, the developer can provide a special flag marking apersistent class so that it becomes part of its parent object's document:  &gt;&gt;&gt; class Car(persistent.Persistent):  ...     _p_pj_sub_object = True  ...  ...     def __init__(self, year, make, model):  ...         self.year = year  ...         self.make = make  ...         self.model = model  ...  ...     def __str__(self):  ...         return '%s %s %s' %(self.year, self.make, self.model)  ...  ...     def __repr__(self):  ...         return '&lt;%s %s&gt;' %(self.__class__.__name__, self)The ``_p_pj_sub_object`` is used to mark a type of object to be just partof another document:  &gt;&gt;&gt; dm.root['stephan'].car = car = Car('2005', 'Ford', 'Explorer')  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; dm.root['stephan'].car  &lt;Car 2005 Ford Explorer&gt;  &gt;&gt;&gt; pprint.pprint(dict(  ...     fetchone(person_cn, &quot;&quot;&quot;data @&gt; '{&quot;name&quot;: &quot;Stephan Richter&quot;}'&quot;&quot;&quot;)))  {'data': {'_py_persistent_type': '__main__.Person',            'address': {'_py_type': 'DBREF',                         'database': 'pjpersist_test',                         'id': '0001020304050607080a0b0c0',                         'table': 'address'},            'birthday': {'_py_type': 'datetime.date',                          'value': '1981-01-25'},            'car': {'_py_persistent_type': '__main__.Car',                     'make': 'Ford',                     'model': 'Explorer',                     'year': '2005'},            'friends': {'roy': {'_py_type': 'DBREF',                                  'database': 'pjpersist_test',                                  'id': '0001020304050607080a0b0c0',                                  'table': 'u__main___dot_Person'}},            'name': 'Stephan Richter',            'phone': {'_py_type': '__main__.Phone',                       'area': '978',                       'country': '+1',                       'number': '394-5124'},            'today': {'_py_type': 'datetime.date', 'value': '2014-05-14'},            'visited': ['Germany', 'USA']},   'id': '0001020304050607080a0b0c0'}The reason we want objects to be persistent is so that they pick up changesautomatically:  &gt;&gt;&gt; dm.root['stephan'].car.year = '2004'  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; dm.root['stephan'].car  &lt;Car 2004 Ford Explorer&gt;Table Sharing-------------Since PostGreSQL/JSONB is so flexible, it sometimes makes sense to storemultiple types of (similar) objects in the same table. In those cases youinstruct the object type to store its Python path as part of the document.Warning: Please note though that this method is less efficient, since thedocument must be loaded in order to create a ghost causing more databaseaccess.  &gt;&gt;&gt; class ExtendedAddress(Address):  ...  ...     def __init__(self, city, zip, country):  ...         super(ExtendedAddress, self).__init__(city, zip)  ...         self.country = country  ...  ...     def __str__(self):  ...         return '%s (%s) in %s' %(self.city, self.zip, self.country)In order to accomplish table sharing, you simply create another classthat has the same ``_p_pj_table`` string as another (sub-classing willensure that).So let's give Stephan two extended addresses now.  &gt;&gt;&gt; dm.root['stephan'].address2 = ExtendedAddress(  ...     'Tettau', '01945', 'Germany')  &gt;&gt;&gt; dm.root['stephan'].address2  &lt;ExtendedAddress Tettau (01945) in Germany&gt;  &gt;&gt;&gt; dm.root['stephan'].address3 = ExtendedAddress(  ...     'Arnsdorf', '01945', 'Germany')  &gt;&gt;&gt; dm.root['stephan'].address3  &lt;ExtendedAddress Arnsdorf (01945) in Germany&gt;  &gt;&gt;&gt; transaction.commit()When loading the addresses, they should be of the right type:  &gt;&gt;&gt; dm.root['stephan'].address  &lt;Address Maynard (01754)&gt;  &gt;&gt;&gt; dm.root['stephan'].address2  &lt;ExtendedAddress Tettau (01945) in Germany&gt;  &gt;&gt;&gt; dm.root['stephan'].address3  &lt;ExtendedAddress Arnsdorf (01945) in Germany&gt;Persistent Serialization Hooks------------------------------When persistent components implement the ``IPersistentSerializationHooks``, itis possible for the object to conduct some custom storage function.  &gt;&gt;&gt; from pjpersist.persistent import PersistentSerializationHooks  &gt;&gt;&gt; class Usernames(PersistentSerializationHooks):  ...     _p_pj_table = 'usernames'  ...     format = 'email'  ...  ...     def _pj_after_store_hook(self, conn):  ...         print('After Store Hook')  ...  ...     def _pj_after_load_hook(self, conn):  ...         print('After Load Hook')When we store the object, the hook is called:(actually twice, because this is a new object)  &gt;&gt;&gt; dm.root['stephan'].usernames = Usernames()  &gt;&gt;&gt; transaction.commit()  After Store Hook  After Store HookWhen loading, the same happens:  &gt;&gt;&gt; dm.root['stephan'].usernames.format  After Load Hook  'email'The store hook fires just once if the object is not new:  &gt;&gt;&gt; dm.root['stephan'].usernames.format = 'snailmail'  &gt;&gt;&gt; transaction.commit()  After Store HookColumn Serialization--------------------pjpersist also allows for the object to specify values, usually attributes orproperties, to be stored as columns on the object's storage table.Note that we support only a one-way transformation, because object statewill be always deserialized from the ``data`` jsonb field.  &gt;&gt;&gt; import zope.schema  &gt;&gt;&gt; class IPerson(zope.interface.Interface):  ...  ...     name = zope.schema.TextLine(title='Name')  ...     address = zope.schema.TextLine(title='Address')  ...     visited = zope.schema.Datetime(title='Visited')  ...     phone = zope.schema.TextLine(title='Phone')Initially, we are storing only the name in a column:  &gt;&gt;&gt; from pjpersist.persistent import SimpleColumnSerialization, select_fields  &gt;&gt;&gt; @zope.interface.implementer(IPerson)  ... class ColumnPerson(SimpleColumnSerialization, Person):  ...     _p_pj_table = 'cperson'  ...     _pj_column_fields = select_fields(IPerson, 'name')So once I create such a person and commit the transaction, the person table isextended to store the attribute and the person is added to the table:  &gt;&gt;&gt; dm.root['anton'] = anton = ColumnPerson('Anton')  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; dumpTable('cperson')  [{'data': {'_py_persistent_type': '__main__.ColumnPerson',             'address': None,             'birthday': None,             'friends': {},             'name': 'Anton',             'phone': None,             'today': {'_py_type': 'datetime.datetime',                        'value': '2014-05-14T12:30:00.000000'},             'visited': []},    'id': '0001020304050607080a0b0c0',    'name': 'Anton'}]Tricky Cases------------Changes in Basic Mutable Type~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Tricky, tricky. How do we make the framework detect changes in mutableobjects, such as lists and dictionaries? Answer: We keep track of whichpersistent object they belong to and provide persistent implementations.  &gt;&gt;&gt; type(dm.root['stephan'].friends)   &lt;class 'pjpersist.serialize.PersistentDict'&gt;  &gt;&gt;&gt; dm.root['stephan'].friends['roger'] = Person('Roger')  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; sorted(dm.root['stephan'].friends.keys())  ['roger', 'roy']The same is true for lists:  &gt;&gt;&gt; type(dm.root['stephan'].visited)   &lt;class 'pjpersist.serialize.PersistentList'&gt;  &gt;&gt;&gt; dm.root['stephan'].visited.append('France')  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; dm.root['stephan'].visited  ['Germany', 'USA', 'France']Circular Non-Persistent References~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Any mutable object that is stored in a sub-document, cannot have multiplereferences in the object tree, since there is no global referencing. Thesecircular references are detected and reported:  &gt;&gt;&gt; class Top(persistent.Persistent):  ...     foo = None  &gt;&gt;&gt; class Foo(object):  ...     bar = None  &gt;&gt;&gt; class Bar(object):  ...     foo = None  &gt;&gt;&gt; top = Top()  &gt;&gt;&gt; foo = Foo()  &gt;&gt;&gt; bar = Bar()  &gt;&gt;&gt; top.foo = foo  &gt;&gt;&gt; foo.bar = bar  &gt;&gt;&gt; bar.foo = foo  &gt;&gt;&gt; dm.root['top'] = top  Traceback (most recent call last):  ...  CircularReferenceError: &lt;...&gt;Circular Persistent References~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~In general, circular references among persistent objects are not a problem,since we always only store a link to the object. However, there is a case whenthe circular dependencies become a problem.If you set up an object tree with circular references and then add the tree tothe storage at once, it must insert objects during serialization, so thatreferences can be created. However, care needs to be taken to only create aminimal reference object, so that the system does not try to recursivelyreduce the state.  &gt;&gt;&gt; class PFoo(persistent.Persistent):  ...     bar = None  &gt;&gt;&gt; class PBar(persistent.Persistent):  ...     foo = None  &gt;&gt;&gt; top = Top()  &gt;&gt;&gt; foo = PFoo()  &gt;&gt;&gt; bar = PBar()  &gt;&gt;&gt; top.foo = foo  &gt;&gt;&gt; foo.bar = bar  &gt;&gt;&gt; bar.foo = foo  &gt;&gt;&gt; dm.root['ptop'] = topContainers and Tables---------------------Now that we have talked so much about the gory details on storing one object,what about mappings that reflect an entire table, for example atable of people.There are many approaches that can be taken. The following implementationdefines an attribute in the document as the mapping key and names atable:  &gt;&gt;&gt; from pjpersist import mapping  &gt;&gt;&gt; class People(mapping.PJTableMapping):  ...     __pj_table__ = person_cn  ...     __pj_mapping_key__ = 'short_name'The mapping takes the data manager as an argument. One can easily create asub-class that assigns the data manager automatically. Let's have a look:  &gt;&gt;&gt; People(dm).keys()  []The reason no person is in the list yet, is because no document has the keyyet or the key is null. Let's change that:  &gt;&gt;&gt; People(dm)['stephan'] = dm.root['stephan']  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; People(dm).keys()  ['stephan']  &gt;&gt;&gt; People(dm)['stephan']  &lt;Person Stephan Richter&gt;Also note that setting the &quot;short-name&quot; attribute on any other person will addit to the mapping:  &gt;&gt;&gt; dm.root['stephan'].friends['roy'].short_name = 'roy'  &gt;&gt;&gt; transaction.commit()  &gt;&gt;&gt; sorted(People(dm).keys())  ['roy', 'stephan']=======CHANGES=======3.1.3 (2022-11-23)------------------- Faster PJDataManager flush() when it contains a lot of objects.3.1.2 (2022-07-15)------------------- Replace collections with collections.abc for python 3.10 compatibility3.1.1 (2022-06-06)------------------- Fix `MappingView` fix, do not emit `hint` in the log message, hint object is the one  being loaded, this just causes pain.3.1.0 (2022-06-03)------------------- Fix `collections.abc.MappingView` subclass persistence. It was very bad, did not  store the underlying mapping at all, **caused silent data loss**.  Urgent update advised!  Also failed on loading the state of such.3.0.2 (2022-05-03)------------------- Fix `DBRef` comparisons to return valid results instead  of failing hard  when comparing to `None` and not `DBRef` instances.  (`__neq__` was unused because `__ne__` is the right method and `__ne__` anyway  delegates to `__eq__`)3.0.1 (2022-02-03)------------------- Fix imports in `testing.py`- Declare Python 3.9 compatibility- Small improvement in `pjpersist.zope.container.PJContainer._load_one`  Get the local cache just once, since the `_cache` property became  a bit more expensive.- Added `sqlbuilder.ILIKE` -- case-insensitive pair of LIKE3.0.0 (2021-02-22)------------------- Backwards incompatible change: PJDataManager now accepts a pool instead  of connection object. PJDataManager will get the connection from the pool  when joining the transaction, and return it back when transaction  completes (aborts or commits). This allows for more flexible connection  management. The connection pool must implement IPJConnectionPool interface  (it is compatible with psycopg2.pool).- `IPJDataManager.begin()` is renamed to `setTransactionOptions()`- Errors executing SQL statements now doom the entire transaction,  causing `transaction.interfaces.DoomedTransaction` exception on  any attempts to commit it.  A failed transaction must be aborted.2.0.1 (2020-10-13)------------------- Fixed persisting tuple keyed dicts. Persisting such objects worked,  but reading failed.2.0.0 (2020-06-02)------------------- Drop Python 2.7 and 3.6 support, add 3.8.- Remove buildout support.- Support for nested flushing. In complex use cases it can happen that during  serialization of an object, a query is made to look up another object. That  in turn causes a flush, resulting in a flush inside a flush. The `flush()`  method did not expect that behavior and failed if the inner flush would  flush objects that the outer flush had already handled.1.7.2 (2020-02-10)------------------- Optimization: do not dig in `data` when we have a native field for  `_pj_mapping_key`, should allow creating indexes for lookup1.7.1 (2019-06-19)------------------- Fixed an edge case when the serializer gets a mapping with a key `dict_data`.  Reading such object failed.- Fixed an edge case with the serializer, when an object's state living  in a persistent object became 'empty'. Basically the state was just  `{'_py_persistent_type': 'SomeClass'}`  `SomeClass.__setstate__` was not called, thus the object could miss  attributes. Like a subclass of `UserDict` would miss the `data` attribute.- Removed checking for 0x00 chars in dict keys. Turns out PostGreSQL just  can not store 0x00.1.7.0 (2019-05-29)------------------- Support for sub-second datetime and time resolution during serialization.- Add `use_cache` argument to `PJContainer._load_one()` to support ignoring  the cache. (This became handy if a container keeps track of multiple  versions of an item and you try to load all old revisions.)1.6.0 (2019-05-29)------------------- Make `id` and `data` column name configurable via `_pj_id_column` and  `_pj_data_column` attributes in `PJContainer`, respectively.- Auto-assign a name to objects when using `PJContainer`, not just  `IdNamesPJContainer`.1.5.0 (2018-10-10)------------------- Support for Python 3.7. Removed Python 3.5 testing from tox.1.4.1 (2018-09-13)------------------- No need to log in tpc_finish.1.4.0 (2018-09-13)------------------- Implemented skipping tpc_prepare when DM has no writes.  We found out that AWS Aurora is dog slow at the moment on tpc_prepare.  When the DataManager has no writes, there's no need to call tpc_prepare.  See `CALL_TPC_PREPARE_ON_NO_WRITE_TRANSACTION`, by default True for backwards  compatibility.- Added ability to log whether the transaction had writes.  See `LOG_READ_WRITE_TRANSACTION`, by default False1.3.2 (2018-04-19)------------------- More precise flushing of datamanager to avoid unnecessary database  writes.1.3.1 (2018-04-11)------------------- Enabled concurrent adds to IdNamesPJContainer by eliminating a query  that was causing transaction conflicts.1.3.0 (2018-03-22)------------------- Python 3 compatibility fixes- More efficient PJContainer.values() implementation1.2.2 (2017-12-12)------------------- Need to protect all DB calls against `DatabaseDisconnected`1.2.1 (2017-12-12)------------------- `psycopg2.OperationalError` and `psycopg2.InterfaceError` will be caught  on SQL command execution and reraised as `DatabaseDisconnected`1.2.0 (2017-10-24)------------------- Added a new helper function to link subobject to main doc object. This is  needed when a custom `__getstate__()` and `__setstate__()` is implemented. A  detailed example is provided.- Implemented `flush_hint` argument for `IDataManager.execute()` to allow  flushing only some objects during query. `flush_hints` is a list table names  that need to be flushed for the query to return a correct result.- The Zope-specific containers use the `flush_hint` to only flush objects they  manage when a query is run on the container.- While flushing objects, every main document object is now only flushed  once. Before that fix, any subobject would cause its doc object to be dumped  again.Note: These optimizations provide a 15% performance improvements in real-worldapplications.1.1.2 (2017-09-14)------------------- Make sure changed objects aren't `_p_changed` anymore after commit.1.1.1 (2017-07-03)------------------- Nothing changed yet.1.0.0 (2017-03-18)------------------- Initial Public Release- Project forked from mongopersist to work with PostGreSQL and JSONB data  type. The main motiviation is the ability to utilize PostGreSQL's great  transactional support.</longdescription>
</pkgmetadata>