<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Downloads](https://pepy.tech/badge/impy-array/month)](https://pepy.tech/project/impy-array)[![PyPI version](https://badge.fury.io/py/impy-array.svg)](https://badge.fury.io/py/impy-array)# A numpy extension for efficient and powerful image analysis workflow`impy` is an all-in-one image analysis library, equipped with parallel processing, GPU support, GUI based tools and so on.The core array, `ImgArray`, is a subclass of `numpy.ndarray`, tagged with information such as - image axes- scale of each axis- directory of the original image- and other image metadata## DocumentationDocumentation is available [here](https://hanjinliu.github.io/impy/).## Installation- use pip```pip install impy-array```- from source```git clone https://github.com/hanjinliu/impy```### Code as fast as you speakAlmost all the functions, such as filtering, deconvolution, labeling, single molecule detection, and even those pure `numpy` functions, are aware of image metadata. They &quot;know&quot; which dimension corresponds to `&quot;z&quot;` axis, which axes they should iterate along or where to save the image. As a result, **your code will be very concise**:```pythonimport impy as ipimport numpy as npimg = ip.imread(&quot;path/to/image&quot;)       # Read images with metadata.img[&quot;z=3;t=0&quot;].imshow()                # Plot image slice at z=3 and t=0.img_fil = img.gaussian_filter(sigma=2) # Paralell batch denoising. No more for loop!img_prj = np.max(img_fil, axis=&quot;z&quot;)    # Z-projection (numpy is aware of image axes!).img_prj.imsave(f&quot;Max-{img.name}&quot;)      # Save in the same place. Don't spend time on searching for the directory!```### Supported file formats`impy` automatically chooses proper reader/writer according to the extension.- Tiff file (&quot;.tif&quot;, &quot;.tiff&quot;)- MRC file (&quot;.mrc&quot;, &quot;.rec&quot;, &quot;.st&quot;, &quot;.map&quot;, &quot;.map.gz&quot;)- Zarr file (&quot;.zarr&quot;)- Other image file (&quot;.png&quot;, &quot;.jpg&quot;)### Switch between CPU and GPU`impy` can internally switches the functions between `numpy` and `cupy`.You can use GPU for calculation very easily.```pythonimg.gaussian_filter()  # &lt;- CPUwith ip.use(&quot;cupy&quot;):    img.gaussian_filter()  # &lt;- GPUip.Const[&quot;RESOURCE&quot;] = &quot;cupy&quot;  # &lt;- globally use GPU```### Seamless interface between `napari`[napari](https://github.com/napari/napari) is an interactive viewer for multi-dimensional images. `impy` has a **simple and efficient interface** with it, via the object `ip.gui`. Since `ImgArray` is tagged with image metadata, you don't have to care about axes or scales. Just run ```pythonip.gui.add(img)```### Extend your function for batch processingAlready have a function for `numpy` and `scipy`? Decorate it with `@ip.bind````python@ip.binddef imfilter(img, param=None):    # Your function here.    # Do something on a 2D or 3D image and return image, scalar or labels    return out```and it's ready for batch processing!```pythonimg.imfilter(param=1.0)```### Commaind line usage`impy` also supports command line based image analysis. All method of `ImgArray` is availablefrom commad line, such as```powershellimpy path/to/image.tif ./output.tif --method gaussian_filter --sigma 2.0```which is equivalent to```pythonimport impy as ipimg = ip.imread(&quot;path/to/image.tif&quot;)out = img.gaussian_filter(sigma=2.0)out.imsave(&quot;./output.tif&quot;)```For more complex procedure, it is possible to send image directly to `IPython````impy path/to/image.tif -i``````pythonthr = img.gaussian_filter().threshold()```or to `napari````impy path/to/image.tif -n```</longdescription>
</pkgmetadata>