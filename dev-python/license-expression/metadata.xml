<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>==================license-expression==================``license-expression`` is a comprehensive utility library to parse, compare,simplify and normalize license expressions (such as SPDX license expressions)using boolean logic.- License: Apache-2.0- Python: 3.7+- Homepage: https://github.com/nexB/license-expression/- Install: `pip install license-expression` also available in most Linux distro.Software project licenses are often a combination of several free and opensource software licenses. License expressions -- as specified by SPDX -- providea concise and human readable way to express these licenses without having toread long license texts, while still being machine-readable.License expressions are used by key FOSS projects such as Linux; severalpackages ecosystem use them to document package licensing metadata such asnpm and Rubygems; they are important when exchanging software data (such as withSPDX and SBOM in general) as a way to express licensing precisely.``license-expression`` is a comprehensive utility library to parse, compare,simplify and normalize these license expressions (such as SPDX license expressions)using boolean logic like in: `GPL-2.0-or-later WITH Classpath-exception-2.0 AND MIT`.It includes the license keys from SPDX https://spdx.org/licenses/ (version 3.20)and ScanCode license DB (version 21.6.7) https://scancode-licensedb.aboutcode.org/to get started quickly.``license-expression`` is both powerful and simple to use and is a used as thelicense expression engine in several projects and products such as:- AboutCode-toolkit https://github.com/nexB/aboutcode-toolkit- AlekSIS (School Information System) https://edugit.org/AlekSIS/official/AlekSIS-Core- Barista https://github.com/Optum/barista- Conda forge tools https://github.com/conda-forge/conda-smithy- DejaCode https://dejacode.com- DeltaCode https://github.com/nexB/deltacode- FenixscanX https://github.com/SmartsYoung/FenixscanX- FetchCode https://github.com/nexB/fetchcode- Flict https://github.com/vinland-technology/flict and https://github.com/vinland-technology- license.sh https://github.com/webscopeio/license.sh- liferay_inbound_checker https://github.com/carmenbianca/liferay_inbound_checker- REUSE https://reuse.software/ and https://github.com/fsfe/reuse-tool- ScanCode-io https://github.com/nexB/scancode.io- ScanCode-toolkit https://github.com/nexB/scancode-toolkitSee also for details:- https://spdx.github.io/spdx-spec/appendix-IV-SPDX-license-expressions/``license-expression`` is also packaged for most Linux distributions. See below.Alternative:There is no known alternative library for Python, but there are several similarlibraries in other languages (but not as powerful of course!):- JavaScript https://github.com/jslicense/spdx-expression-parse.js- Rust https://github.com/ehuss/license-exprs- Haskell https://github.com/phadej/spdx- Go https://github.com/kyoh86/go-spdx- Ada https://github.com/Fabien-Chouteau/spdx_ada- Java https://github.com/spdx/tools and https://github.com/aschet/spdx-license-expression-toolsBuild and tests status======================+--------------------------+------------------------+----------------------------------+|**Linux &amp; macOS (Travis)**| **Windows (AppVeyor)** |**Linux, Windows &amp; macOS (Azure)**|+==========================+========================+==================================+|                          |                        |                                  || |travis-badge-icon|      | |appveyor-badge-icon|  |   |azure-badge-icon|             ||                          |                        |                                  |+--------------------------+------------------------+----------------------------------+Source code and download========================- GitHub https://github.com/nexB/license-expression.git- PyPI https://pypi.python.org/pypi/license-expressionAlso available in several Linux distros:- Arch Linux https://archlinux.org/packages/community/any/python-license-expression/- Debian https://packages.debian.org/unstable/source/license-expression- DragonFly BSD https://github.com/DragonFlyBSD/DPorts/tree/master/textproc/py-license-expression- Fedora https://src.fedoraproject.org/rpms/python-license-expression/- FreeBSD https://www.freshports.org/textproc/py-license-expression- NixOS https://github.com/NixOS/nixpkgs/blob/release-21.05/pkgs/development/python-modules/license-expression/default.nix- openSUSE https://build.opensuse.org/package/show/openSUSE:Factory/python-license-expressionSupport=======- Submit bugs and questions at: https://github.com/nexB/license-expression/issues- Join the chat at: https://gitter.im/aboutcode-org/discussDescription===========This module defines a mini language to parse, validate, simplify, normalize andcompare license expressions using a boolean logic engine.This supports SPDX license expressions and also accepts other license namingconventions and license identifiers aliases to resolve and normalize any licenseexpressions.Using boolean logic, license expressions can be tested for equality, containment,equivalence and can be normalized or simplified.It also bundles the SPDX License list (3.20 as of now) and the ScanCode licenseDB (based on latest ScanCode) to easily parse and validate expressions usingthe license symbols.Usage examples==============The main entry point is the ``Licensing`` object that you can use to parse,validate, compare, simplify and normalize license expressions.Create an SPDX Licensing and parse expressions::&gt;&gt;&gt; from license_expression import get_spdx_licensing&gt;&gt;&gt; licensing = get_spdx_licensing()&gt;&gt;&gt; expression = ' GPL-2.0 or LGPL-2.1 and mit '&gt;&gt;&gt; parsed = licensing.parse(expression)&gt;&gt;&gt; print(parsed.pretty())OR(  LicenseSymbol('GPL-2.0-only'),  AND(    LicenseSymbol('LGPL-2.1-only'),    LicenseSymbol('MIT')  ))&gt;&gt;&gt; str(parsed)'GPL-2.0-only OR (LGPL-2.1-only AND MIT)'&gt;&gt;&gt; licensing.parse('unknwon with foo', validate=True, strict=True)license_expression.ExpressionParseError: A plain license symbol cannot be usedas an exception in a &quot;WITH symbol&quot; statement. for token: &quot;foo&quot; at position: 13&gt;&gt;&gt; licensing.parse('unknwon with foo', validate=True)license_expression.ExpressionError: Unknown license key(s): unknwon, foo&gt;&gt;&gt; licensing.validate('foo and MIT and GPL-2.0+')ExpressionInfo(    original_expression='foo and MIT and GPL-2.0+',    normalized_expression=None,    errors=['Unknown license key(s): foo'],    invalid_symbols=['foo'])Create a simple Licensing and parse expressions::    &gt;&gt;&gt; from license_expression import Licensing, LicenseSymbol    &gt;&gt;&gt; licensing = Licensing()    &gt;&gt;&gt; expression = ' GPL-2.0 or LGPL-2.1 and mit '    &gt;&gt;&gt; parsed = licensing.parse(expression)    &gt;&gt;&gt; expression = ' GPL-2.0 or LGPL-2.1 and mit '    &gt;&gt;&gt; expected = 'GPL-2.0-only OR (LGPL-2.1-only AND mit)'    &gt;&gt;&gt; assert str(parsed) == expected    &gt;&gt;&gt; assert parsed.render('{symbol.key}') == expectedCreate a Licensing with your own license symbols::    &gt;&gt;&gt; expected = [    ...   LicenseSymbol('GPL-2.0'),    ...   LicenseSymbol('LGPL-2.1'),    ...   LicenseSymbol('mit')    ... ]    &gt;&gt;&gt; assert licensing.license_symbols(expression) == expected    &gt;&gt;&gt; assert licensing.license_symbols(parsed) == expected    &gt;&gt;&gt; symbols = ['GPL-2.0+', 'Classpath', 'BSD']    &gt;&gt;&gt; licensing = Licensing(symbols)    &gt;&gt;&gt; expression = 'GPL-2.0+ with Classpath or (bsd)'    &gt;&gt;&gt; parsed = licensing.parse(expression)    &gt;&gt;&gt; expected = 'GPL-2.0+ WITH Classpath OR BSD'    &gt;&gt;&gt; assert parsed.render('{symbol.key}') == expected    &gt;&gt;&gt; expected = [    ...   LicenseSymbol('GPL-2.0+'),    ...   LicenseSymbol('Classpath'),    ...   LicenseSymbol('BSD')    ... ]    &gt;&gt;&gt; assert licensing.license_symbols(parsed) == expected    &gt;&gt;&gt; assert licensing.license_symbols(expression) == expectedAnd expression can be deduplicated, to remove duplicate license subexpressionswithout changing the order and without consider license choices as simplifiable::    &gt;&gt;&gt; expression2 = ' GPL-2.0 or (mit and LGPL 2.1) or bsd Or GPL-2.0  or (mit and LGPL 2.1)'    &gt;&gt;&gt; parsed2 = licensing.parse(expression2)    &gt;&gt;&gt; str(parsed2)    'GPL-2.0 OR (mit AND LGPL 2.1) OR BSD OR GPL-2.0 OR (mit AND LGPL 2.1)'    &gt;&gt;&gt; assert str(parsed2.simplify()) == 'BSD OR GPL-2.0 OR (LGPL 2.1 AND mit)'Expression can be simplified, treating them as boolean expressions::    &gt;&gt;&gt; expression2 = ' GPL-2.0 or (mit and LGPL 2.1) or bsd Or GPL-2.0  or (mit and LGPL 2.1)'    &gt;&gt;&gt; parsed2 = licensing.parse(expression2)    &gt;&gt;&gt; str(parsed2)    'GPL-2.0 OR (mit AND LGPL 2.1) OR BSD OR GPL-2.0 OR (mit AND LGPL 2.1)'    &gt;&gt;&gt; assert str(parsed2.simplify()) == 'BSD OR GPL-2.0 OR (LGPL 2.1 AND mit)'Two expressions can be compared for equivalence and containment:    &gt;&gt;&gt; expr1 = licensing.parse(' GPL-2.0 or (LGPL 2.1 and mit) ')    &gt;&gt;&gt; expr2 = licensing.parse(' (mit and LGPL 2.1)  or GPL-2.0 ')    &gt;&gt;&gt; licensing.is_equivalent(expr1, expr2)    True    &gt;&gt;&gt; licensing.is_equivalent(' GPL-2.0 or (LGPL 2.1 and mit) ',    ...                         ' (mit and LGPL 2.1)  or GPL-2.0 ')    True    &gt;&gt;&gt; expr1.simplify() == expr2.simplify()    True    &gt;&gt;&gt; expr3 = licensing.parse(' GPL-2.0 or mit or LGPL 2.1')    &gt;&gt;&gt; licensing.is_equivalent(expr2, expr3)    False    &gt;&gt;&gt; expr4 = licensing.parse('mit and LGPL 2.1')    &gt;&gt;&gt; expr4.simplify() in expr2.simplify()    True    &gt;&gt;&gt; licensing.contains(expr2, expr4)    TrueDevelopment===========- Checkout a clone from https://github.com/nexB/license-expression.git- Then run ``./configure --dev`` and then ``source tmp/bin/activate`` on Linux and POSIX.  This will install all dependencies in a local virtualenv, including  development deps.- On Windows run  ``configure.bat --dev`` and then ``Scripts\bin\activate`` instead.- To run the tests, run ``pytest -vvs``.. |travis-badge-icon| image:: https://api.travis-ci.org/nexB/license-expression.png?branch=master    :target: https://travis-ci.org/nexB/license-expression    :alt: Travis tests status    :align: middle.. |appveyor-badge-icon| image:: https://ci.appveyor.com/api/projects/status/github/nexB/license-expression?svg=true    :target: https://ci.appveyor.com/project/nexB/license-expression    :alt: Appveyor tests status    :align: middle.. |azure-badge-icon| image:: https://dev.azure.com/nexB/license-expression/_apis/build/status/nexB.license-expression?branchName=master    :target: https://dev.azure.com/nexB/license-expression/_build/latest?definitionId=2&amp;branchName=master    :alt: Azure pipelines tests status    :align: middle</longdescription>
</pkgmetadata>