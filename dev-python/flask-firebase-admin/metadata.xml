<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Flask Firebase AdminAdd Firebase (a Firebase Admin app) to a Flask application.[![PyPI Version](https://img.shields.io/pypi/v/flask-firebase-admin.svg)](https://pypi.org/project/flask-firebase-admin/)[![Tests](https://github.com/andrewrosss/flask-firebase-admin/actions/workflows/test.yaml/badge.svg)](https://github.com/andrewrosss/flask-firebase-admin/actions/workflows/test.yaml)[![codecov](https://codecov.io/gh/andrewrosss/flask-firebase-admin/branch/master/graph/badge.svg?token=JM7PL13H59)](https://codecov.io/gh/andrewrosss/flask-firebase-admin)[![Type Check](https://github.com/andrewrosss/flask-firebase-admin/actions/workflows/type-check.yaml/badge.svg)](https://github.com/andrewrosss/flask-firebase-admin/actions/workflows/type-check.yaml)[![Code Style](https://github.com/andrewrosss/flask-firebase-admin/actions/workflows/lint.yaml/badge.svg)](https://github.com/andrewrosss/flask-firebase-admin/actions/workflows/lint.yaml)## Installation```bashpip install flask-firebase-admin```## QuickstartIn the simplest case, let's protect a route, specifically, we'll require a user to provide a firebase jwt to one of our routes:```pythonfrom flask import Flask, requestfrom flask_firebase_admin import FirebaseAdminapp = Flask(__name__)firebase = FirebaseAdmin(app)  # uses GOOGLE_APPLICATION_CREDENTIALS@app.route(&quot;/unprotected&quot;)def unprotected():    return {&quot;message&quot;: &quot;Hello anonymous user!&quot;}@app.route(&quot;/protected&quot;)@firebase.jwt_required  # This route now requires authorization via firebase jwtdef protected():    # By default JWT payload is stored under request.jwt_payload    return {&quot;message&quot;: f&quot;Hello {request.jwt_payload['email']}!&quot;}if __name__ == &quot;__main__&quot;:    app.run(debug=True)```Assuming the code above is located in a module named `app.py`, start the Flask application:```bashGOOGLE_APPLICATION_CREDENTIALS=&quot;/path/to/service_account.json&quot; python app.py```And in a separate terminal window, ping the unprotected route:```bash$ curl http://127.0.0.1:5000/unprotected{  &quot;message&quot;: &quot;Hello anonymous user!&quot;}```Looks good. Now the protected route:```bash$ curl http://127.0.0.1:5000/protected{  &quot;error&quot;: {    &quot;message&quot;: &quot;No credentials provided&quot;  }}```OK, makes sense. Now with some credentials:```bash$ TOKEN=&quot;your-firebase-token ...&quot;$ curl -H &quot;Authorization: Bearer ${TOKEN}&quot; http://127.0.0.1:5000/protected{  &quot;message&quot;: &quot;Hello &lt;your@email.com&gt;!&quot;}```Excellent. We now have a application with routes (one route) which require the user to provide their Firebase JWT to access!Internally the `jwt_required` method provided by the `FirebaseAdmin` object calls the `firebase_admin.auth.verify_id_token` function which returns a dictionary of key-value pairs parsed from the decoded JWT. This dictionary is accessible via the `request` object provided by flask, specifically, this information is attached to the `request.jwt_payload` attribute by default.## Configuration&gt; **Note:** The following groups of configuration parameters are mutually exclusive:&gt;&gt; - `FIREBASE_ADMIN_APP` (This config parameter takes precendence and if specified then configuration from the other group is ignored)&gt;&gt;   ***&gt;&gt; - `FIREBASE_ADMIN_CREDENTIAL`&gt;&gt;   `FIREBASE_ADMIN_OPTIONS`&gt;&gt;   `FIREBASE_ADMIN_NAME`&gt;&gt;   `FIREBASE_ADMIN_RAISE_IF_APP_EXISTS`The `FirebaseAdmin` object can be configured in the following ways:- `FIREBASE_ADMIN_CREDENTIAL`  **Defaults to `None`**. This is the credential passed to the call to `firebase_admin.initialize_app`. When this parameter is None the Firebase Admin application tries to initialize using `GOOGLE_APPLICATION_CREDENTIALS`. If initializing the Firebase Admin app with the `GOOGLE_APPLICATION_CREDENTIALS` environment variable is undesirebale, credentials can be created manually, for example:  ```python  app = Flask(__name__)  app.config[&quot;FIREBASE_ADMIN_CREDENTIAL&quot;] = credentials.Certificate(&quot;/path/to/key.json&quot;)  firebase = FirebaseAdmin(app)  # no longer uses GOOGLE_APPLICATION_CREDENTIALS  ```  Or perhaps something like:  ```python  app = Flask(__name__)  cert = {      &quot;type&quot;: &quot;service_account&quot;,      &quot;project_id&quot;: os.getenv(&quot;PROJECT_ID&quot;),      &quot;private_key_id&quot;: os.getenv(&quot;PRIVATE_KEY_ID&quot;),      &quot;private_key&quot;: os.getenv(&quot;PRIVATE_KEY&quot;),      &quot;client_email&quot;: os.getenv(&quot;CLIENT_EMAIL&quot;),      &quot;client_id&quot;: os.getenv(&quot;CLIENT_ID&quot;),      &quot;auth_uri&quot;: &quot;https://accounts.google.com/o/oauth2/auth&quot;,      &quot;token_uri&quot;: &quot;https://oauth2.googleapis.com/token&quot;,      &quot;auth_provider_x509_cert_url&quot;: &quot;https://www.googleapis.com/oauth2/v1/certs&quot;,      &quot;client_x509_cert_url&quot;: os.getenv(&quot;CLIENT_X509_CERT_URL&quot;),  }  app.config[&quot;FIREBASE_ADMIN_CREDENTIAL&quot;] = credentials.Certificate(cert)  firebase = FirebaseAdmin(app)  # no longer uses GOOGLE_APPLICATION_CREDENTIALS  ```- `FIREBASE_ADMIN_OPTIONS`  **Defaults to `None`**. This config is passed directly to `admin.initialize_app()` as the second `options` argument. From the Firebase Admin SDK docs: _A dictionary of configuration options (optional). Supported options include **databaseURL**, **storageBucket**, **projectId**, **databaseAuthVariableOverride**, **serviceAccountId** and **httpTimeout**. If httpTimeout is not set, the SDK uses a default timeout of 120 seconds._- `FIREBASE_ADMIN_NAME`  **Defaults to `'[DEFAULT]'`**. This config is passed directly to `admin.initialize_app()` as the third `name` argument.- `FIREBASE_ADMIN_AUTHORIZATION_SCHEME`  **Defaults to `'Bearer'`**. This is the authorization scheme expected by the `FirebaseAdmin` object. Changing this parameter changes the format of the auth header that is required by the client. For example, if we set this to `'JWT'` we would then need to include an authorization header of the form: `Authorization: JWT &lt;token&gt;` when making requests to protected routes.- `FIREBASE_ADMIN_CHECK_REVOKED`  **Defaults to `True`**. This parameter is passed as the `check_revoked` argument in the call to `firebase_admin.auth.verify_id_token()`.- `FIREBASE_ADMIN_PAYLOAD_ATTR`  **Defaults to `'jwt_payload'`**. This is attribute on the flask `request` object from which we can access the JWT payload data. If we were to change this to, say, `'jwt'` we would then access the JWT payload using `request.jwt`- `FIREBASE_ADMIN_RAISE_IF_APP_EXISTS`  **Defaults to `True`**. Internally, `flask-firebase-admin` calls `admin.initialize_app()`, if the app with the configured name already exists the Firebase Admin SDK raises a `ValueError` exception. When this config variable is set to `False`, `flask-firebase-admin` will catch this error, get, and subsequently use the existing admin app by the given name.- `FIREBASE_ADMIN_APP`  **Defaults to `None`**. This is a way to explicity provided the `FirebaseAdmin` extension with a particular firebase admin app to use. For example:  ```python  import firebase_admin  from flask import Flask  from flask_firebase_admin import FirebaseAdmin  # elsewhere ...  default_admin_app = firebase_admin.initialize_app()  other_admin_app = firebase_admin.initialize_app(other_creds, other_options, other_name)  # then ...  app = Flask(__name__)  app.config[&quot;FIREBASE_ADMIN_APP&quot;] = other_admin_app  # now firebase.jwt_required will use other_admin_app for authentication  firebase = FirebaseAdmin(app)  ```An example using more of the available configuration:```pythonfrom flask import Flask, requestfrom firebase_admin import credentialsfrom flask_firebase_admin import FirebaseAdminapp = Flask(__name__)app.config[&quot;FIREBASE_ADMIN_CREDENTIAL&quot;] = credentials.Certificate(&quot;/path/to/key.json&quot;)app.config[&quot;FIREBASE_ADMIN_AUTHORIZATION_SCHEME&quot;] = &quot;JWT&quot;app.config[&quot;FIREBASE_ADMIN_CHECK_REVOKED&quot;] = False  # don't check for revoked tokensapp.config[&quot;FIREBASE_ADMIN_PAYLOAD_ATTR&quot;] = &quot;firebase_jwt&quot;# initialized with credentials defined above, not GOOGLE_APPLICATION_CREDENTIALSfirebase = FirebaseAdmin(app)@app.route(&quot;/unprotected&quot;)def unprotected():    return {&quot;message&quot;: &quot;Hello anonymous user!&quot;}@app.route(&quot;/protected&quot;)@firebase.jwt_required  # This route now requires authorization via firebase jwtdef protected():    # we now access the JWT payload using request.firebase_jwt    return {&quot;message&quot;: f&quot;Hello {request.firebase_jwt['email']}!&quot;}if __name__ == &quot;__main__&quot;:    app.run(debug=True)```To call the `/protected` route we have to update our auth header that we sent originally:```bash$ TOKEN=&quot;your-firebase-token ...&quot;$ curl -H &quot;Authorization: JWT ${TOKEN}&quot; http://127.0.0.1:5000/protected{  &quot;message&quot;: &quot;Hello &lt;your@email.com&gt;!&quot;}```## ExtrasFor convenience, the modules in the `firebase_admin` package are aliased as class-level attributes on the `FirebaseAdmin` object. For example:```pythonfrom flask import Flaskfrom flask_firebase_admin import FirebaseAdminapp = Flask(__name__)firebase = FirebaseAdmin(app)db = firebase.firestore.client()  # &lt;-- connect firestore client@app.route(&quot;/unprotected&quot;)def unprotected():    return {&quot;message&quot;: &quot;Hello anonymous user!&quot;}@app.route(&quot;/protected&quot;)@firebase.jwt_requireddef protected():    # do stuff in firestore using the db object defined above.    ...if __name__ == &quot;__main__&quot;:    app.run(debug=True)```## Contributing1. Have or install a recent version of `poetry` (version &gt;= 1.1)1. Fork the repo1. Setup a virtual environment (however you prefer)1. Run `poetry install`1. Run `pre-commit install`1. Add your changes (adding/updating tests is always nice too)1. Commit your changes + push to your fork1. Open a PR</longdescription>
</pkgmetadata>