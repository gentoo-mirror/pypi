<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Documentation Status](https://readthedocs.org/projects/parsr/badge/?version=latest)](https://parsr.readthedocs.io/en/latest/?badge=latest)[![Test Status](https://travis-ci.org/csams/parsr.svg?branch=master)](https://travis-ci.org/csams/parsr.svg?branch=master)[![Coverage Status](https://coveralls.io/repos/github/csams/parsr/badge.svg?branch=master)](https://coveralls.io/github/csams/parsr?branch=master)# parsrparsr is a little library for parsing simple, mostly context free grammars thatmight require knowledge of indentation or matching tags.It contains a small set of combinators that perform recursive decent withbacktracking. Fancy tricks like rewriting left recursions and optimizations like[packrat](https://pdos.csail.mit.edu/~baford/packrat/thesis/thesis.pdf) are notimplemented since the goal is a library that's small yet sufficient for parsingnon-standard configuration files. It also includes a generic data model thatparsers can target to take advantage of an embedded query system.To see how a handwritten parser might evolve to something like this project,check out the [lesson](https://github.com/csams/parsr/blob/master/parsr/lesson).[parser.query](https://github.com/csams/parsr/blob/master/parsr/query) contains the common data model and query system.## Install1. Ensure python2.7, python3.6, or python3.7 is installed.2. `python3.7 -m venv myproject &amp;&amp; cd myproject`3. `source bin/activate`4. `pip install parsr`## Examples* [Arithmetic](https://github.com/csams/parsr/blob/master/parsr/examples/arith.py)* [Generic Key/Value Pair configuration](https://github.com/csams/parsr/blob/master/parsr/examples/kvpairs.py)* [INI configuration](https://github.com/csams/parsr/blob/master/parsr/examples/iniparser.py) is an example of significant indentation.* [json](https://github.com/csams/parsr/blob/master/parsr/examples/json_parser.py)* [httpd configuration](https://github.com/csams/parsr/blob/master/parsr/examples/httpd_conf.py) is an example of matching starting and ending tags.* [nginx configuration](https://github.com/csams/parsr/blob/master/parsr/examples/nginx_conf.py)* [corosync configuration](https://github.com/csams/parsr/blob/master/parsr/examples/corosync_conf.py)* [multipath configuration](https://github.com/csams/parsr/blob/master/parsr/examples/multipath_conf.py)* [logrotate configuration](https://github.com/csams/parsr/blob/master/parsr/examples/logrotate_conf.py)## PrimitivesThese are the building blocks for matching individual characters, sets ofcharacters, and a few convenient objects like numbers. All matching is casesensitive except for the `ignore_case` option with `Literal`.### CharMatch a single character.```pythona = Char(&quot;a&quot;)     # parses a single &quot;a&quot;val = a(&quot;a&quot;)      # produces an &quot;a&quot; from the data.val = a(&quot;b&quot;)      # raises an exception```### InSetMatch any single character in a set.```pythonvowel = InSet(&quot;aeiou&quot;)  # or InSet(set(&quot;aeiou&quot;))val = vowel(&quot;a&quot;)  # okayval = vowel(&quot;e&quot;)  # okayval = vowel(&quot;i&quot;)  # okayval = vowel(&quot;o&quot;)  # okayval = vowel(&quot;u&quot;)  # okayval = vowel(&quot;y&quot;)  # raises an exception```### StringMatch one or more characters in a set. Matching is greedy.```pythonvowels = String(&quot;aeiou&quot;)val = vowels(&quot;a&quot;)            # returns &quot;a&quot;val = vowels(&quot;u&quot;)            # returns &quot;u&quot;val = vowels(&quot;aaeiouuoui&quot;)   # returns &quot;aaeiouuoui&quot;val = vowels(&quot;uoiea&quot;)        # returns &quot;uoiea&quot;val = vowels(&quot;oouieaaea&quot;)    # returns &quot;oouieaaea&quot;val = vowels(&quot;ga&quot;)           # raises an exception```### StringUntilMatches any number of characters until a predicate is seen. You may setlower and upper bounds. Both are inclusive. The characters that matchthe predicate are not consumed.```pythonsu  = StringUntil(Char(&quot;=&quot;))  # parses any number of characters until '='val = su(&quot;ab=&quot;)               # produces &quot;ab&quot; from the data.val = su(&quot;ab&quot;)                # raises an exceptionsu  = StringUntil(Char(&quot;=&quot;), lower=2)  # parses at least two characters until '='val = su(&quot;ab=&quot;)                        # produces &quot;ab&quot; from the data.val = su(&quot;a=&quot;)                         # raises an exceptionsu  = StringUntil(Char(&quot;=&quot;), upper=2)  # parses at most two characters until '='val = su(&quot;ab=&quot;)                        # produces &quot;ab&quot; from the data.val = su(&quot;a=&quot;)                         # produces &quot;a&quot;val = su(&quot;abc=&quot;)                       # raises an exception```### RegexMatch characters against a regular expression.```pythonidentifier = Regex(&quot;[a-zA-Z]([a-zA-Z0-9])*&quot;)identifier(&quot;abcd1&quot;) # returns &quot;abcd1&quot;identifier(&quot;1bcd1&quot;) # raises an exception```### LiteralMatch a literal string. The `value` keyword lets you return a python valueinstead of the matched input. The `ignore_case` keyword makes the match caseinsensitive.```pythonlit = Literal(&quot;true&quot;)val = lit(&quot;true&quot;)  # returns &quot;true&quot;val = lit(&quot;True&quot;)  # raises an exceptionval = lit(&quot;one&quot;)   # raises an exceptionlit = Literal(&quot;true&quot;, ignore_case=True)val = lit(&quot;true&quot;)  # returns &quot;true&quot;val = lit(&quot;TRUE&quot;)  # returns &quot;TRUE&quot;val = lit(&quot;one&quot;)   # raises an exceptiont = Literal(&quot;true&quot;, value=True)f = Literal(&quot;false&quot;, value=False)val = t(&quot;true&quot;)  # returns the boolean Trueval = t(&quot;True&quot;)  # raises an exceptionval = f(&quot;false&quot;) # returns the boolean Falseval = f(&quot;False&quot;) # raises and exceptiont = Literal(&quot;true&quot;, value=True, ignore_case=True)f = Literal(&quot;false&quot;, value=False, ignore_case=True)val = t(&quot;true&quot;)  # returns the boolean Trueval = t(&quot;True&quot;)  # returns the boolean Trueval = f(&quot;false&quot;) # returns the boolean Falseval = f(&quot;False&quot;) # returns the boolean False```### NumberMatch a possibly negative integer or simple floating point number and returnthe python `int` or `float` for it.```pythonval = Number(&quot;123&quot;)  # returns 123val = Number(&quot;-12&quot;)  # returns -12val = Number(&quot;12.4&quot;)  # returns 12.4val = Number(&quot;-12.4&quot;)  # returns -12.4```parsr also provides SingleQuotedString, DoubleQuotedString, QuotedString, EOL,EOF, WS, AnyChar, and several other primitives. See the bottom of[parsr/\_\_init\_\_.py](https://github.com/csams/parsr/blob/master/parsr/__init__.py)## CombinatorsThere are several ways of combining primitives and their combinations.### SequenceRequire expressions to be in order.Sequences are optimized so only the first object maintains a list of itself andfollowing objects. Be aware that using a sequence in other sequences will causeit to accumulate the elements of the new sequence onto it, which could affect itif it's used in multiple definitions. To ensure a sequence isn't &quot;sticky&quot; afterits definition, wrap it in a `Wrapper` object.```pythona = Char(&quot;a&quot;)     # parses a single &quot;a&quot;b = Char(&quot;b&quot;)     # parses a single &quot;b&quot;c = Char(&quot;c&quot;)     # parses a single &quot;c&quot;ab = a + b        # parses a single &quot;a&quot; followed by a single &quot;b&quot;                  # (a + b) creates a &quot;Sequence&quot; object. Using `ab` as an                  # element in a later sequence would modify its original                  # definition.abc = a + b + c   # parses &quot;abc&quot;                  # (a + b) creates a &quot;Sequence&quot; object to which c is appendedval = ab(&quot;ab&quot;)    # produces a list [&quot;a&quot;, &quot;b&quot;]val = ab(&quot;a&quot;)     # raises an exceptionval = ab(&quot;b&quot;)     # raises an exceptionval = ab(&quot;ac&quot;)    # raises an exceptionval = ab(&quot;cb&quot;)    # raises an exceptionval = abc(&quot;abc&quot;)  # produces [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]```### ChoiceAccept one of several alternatives. Alternatives are checked from left to right,and checking stops with the first one to succeed.Choices are optimized so only the first object maintains a list of alternatives.Be aware that using a choice object as an element in other choices willcause it to accumulate the elemtents of the new choice onto it, which couldaffect it if it's used in multiple definitions. To ensure a Choice isn't&quot;sticky&quot; after its definition, wrap it in a `Wrapper` object.```pythonabc = a | b | c   # alternation or choice.val = abc(&quot;a&quot;)    # parses a single &quot;a&quot;val = abc(&quot;b&quot;)    # parses a single &quot;b&quot;val = abc(&quot;c&quot;)    # parses a single &quot;c&quot;val = abc(&quot;d&quot;)    # raises an exception```### ManyMatch zero or more occurences of an expression. Matching is greedy.Since `Many` can match zero occurences, it always succeeds. Keep this in mindwhen using it in a list of alternatives or with `FollowedBy` or `NotFollowedBy`.```pythonx = Char(&quot;x&quot;)xs = Many(x)      # parses many (or no) x's in a rowval = xs(&quot;&quot;)      # returns []val = xs(&quot;a&quot;)     # returns []val = xs(&quot;x&quot;)     # returns [&quot;x&quot;]val = xs(&quot;xxxxx&quot;) # returns [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]val = xs(&quot;xxxxb&quot;) # returns [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]ab = Many(a + b)  # parses &quot;abab...&quot;val = ab(&quot;&quot;)      # produces []val = ab(&quot;ab&quot;)    # produces [[&quot;a&quot;, b&quot;]]val = ab(&quot;ba&quot;)    # produces []val = ab(&quot;ababab&quot;)# produces [[&quot;a&quot;, b&quot;], [&quot;a&quot;, &quot;b&quot;], [&quot;a&quot;, &quot;b&quot;]]ab = Many(a | b)  # parses any combination of &quot;a&quot; and &quot;b&quot; like &quot;aababbaba...&quot;val = ab(&quot;aababb&quot;)# produces [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;]xs = Many(x, lower=1)     # parses many (or no) x's in a rowval = xs(&quot;&quot;)      # raises an exceptionval = xs(&quot;a&quot;)     # raises an exceptionval = xs(&quot;x&quot;)     # returns [&quot;x&quot;]val = xs(&quot;xxxxx&quot;) # returns [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]val = xs(&quot;xxxxb&quot;) # returns [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]ab = Many(a + b, lower=1) # parses &quot;abab...&quot;val = ab(&quot;&quot;)      # raises an exceptionval = ab(&quot;ab&quot;)    # produces [[&quot;a&quot;, &quot;b&quot;]]val = ab(&quot;ba&quot;)    # raises an exceptionval = ab(&quot;ababab&quot;)# produces [[&quot;a&quot;, &quot;b&quot;], [&quot;a&quot;, &quot;b&quot;], [&quot;a&quot;, &quot;b&quot;]]ab = Many(a | b, lower=1) # parses any combination of &quot;a&quot; and &quot;b&quot; like &quot;aababbaba...&quot;val = ab(&quot;aababb&quot;)# produces [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;]ab = Many(a | b, upper=2) # parses any combination of &quot;a&quot; and &quot;b&quot; like &quot;aababbaba...&quot;val = ab(&quot;ab&quot;)    # produces [&quot;a&quot;, &quot;b&quot;]val = ab(&quot;aab&quot;)   # raises an exception```### UntilMatch zero or more occurences of an expression until a predicate matches.Matching is greedy.Since `Until` can match zero occurences, it always succeeds. Keep this in mindwhen using it in a list of alternatives or with `FollowedBy` or `NotFollowedBy`.```pythoncs = AnyChar.until(Char(&quot;y&quot;)) # parses many (or no) characters until a &quot;y&quot; is                              # encountered.val = cs(&quot;&quot;)                  # returns []val = cs(&quot;a&quot;)                 # returns [&quot;a&quot;]val = cs(&quot;x&quot;)                 # returns [&quot;x&quot;]val = cs(&quot;ccccc&quot;)             # returns [&quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;]val = cs(&quot;abcdycc&quot;)           # returns [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]```### Followed byRequire an expression to be followed by another, but don't consume the inputthat matches the latter expression.```pythonab = Char(&quot;a&quot;) &amp; Char(&quot;b&quot;) # matches an &quot;a&quot; followed by a &quot;b&quot;, but the &quot;b&quot;                           # isn't consumed from the input.val = ab(&quot;ab&quot;)             # returns &quot;a&quot; and leaves &quot;b&quot; to be consumed.val = ab(&quot;ac&quot;)             # raises an exception and doesn't consume &quot;a&quot;.```### Not followed byRequire an expression to *not* be followed by another.```pythonanb = Char(&quot;a&quot;) / Char(&quot;b&quot;) # matches an &quot;a&quot; not followed by a &quot;b&quot;.val = anb(&quot;ac&quot;)             # returns &quot;a&quot; and leaves &quot;c&quot; to be consumedval = anb(&quot;ab&quot;)             # raises an exception and doesn't consume &quot;a&quot;.```### Keep Left / Keep Right`KeepLeft` (`&lt;&lt;`) and `KeepRight` (`&gt;&gt;`) match adjacent expressions but ignoreone of their results.```pythona = Char(&quot;a&quot;)q = Char('&quot;')qa = a &lt;&lt; q      # like a + q except only the result of a is returnedval = qa('a&quot;')   # returns &quot;a&quot;. Keeps the thing on the left of the &lt;&lt; qa = q &gt;&gt; a      # like q + a except only the result of a is returnedval = qa('&quot;a')   # returns &quot;a&quot;. Keeps the thing on the right of the &gt;&gt; qa = q &gt;&gt; a &lt;&lt; q # like q + a + q except only the result of the a is returnedval = qa('&quot;a&quot;')  # returns &quot;a&quot;.```### Opt`Opt` wraps a parser and returns a default value of `None` if it fails. Thatvalue can be changed with the `default` keyword. Input is consumed if thewrapped parser succeeds but not otherwise.```pythona = Char(&quot;a&quot;)o = Opt(a)      # matches an &quot;a&quot; if its available. Still succeeds otherwise but                # doesn't advance the read pointer.val = o(&quot;a&quot;)    # returns &quot;a&quot;val = o(&quot;b&quot;)    # returns None. Read pointer is not advanced.o = Opt(a, default=&quot;x&quot;) # matches an &quot;a&quot; if its available. Returns &quot;x&quot; otherwise.val = o(&quot;a&quot;)    # returns &quot;a&quot;val = o(&quot;b&quot;)    # returns &quot;x&quot;. Read pointer is not advanced.```### mapAll parsers have a `.map` function that allows you to pass a function toevaluate the input they've matched.```pythondef to_number(val):    # val is like [non_zero_digit, [other_digits]]    first, rest = val    s = first + &quot;&quot;.join(rest)    return int(s)m = NonZeroDigit + Many(Digit)  # returns [nzd, [other digits]]n = m.map(to_number)  # converts the match to an actual integerval = n(&quot;15&quot;)  # returns the int 15```### LiftAllows a multiple parameter function to work on parsers.```pythondef comb(a, b, c):    &quot;&quot;&quot; a, b, and c should be strings. Returns their concatenation.&quot;&quot;&quot;    return &quot;&quot;.join([a, b, c])# You'd normally invoke comb like comb(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), but you can &quot;lift&quot; it for# use with parsers like this:x = Char(&quot;x&quot;)y = Char(&quot;y&quot;)z = Char(&quot;z&quot;)p = Lift(comb) * x * y * z# The * operator separates parsers whose results will go into the arguments of# the lifted function. I've used Char above, but x, y, and z can be arbitrarily# complex.val = p(&quot;xyz&quot;)  # would return &quot;xyz&quot;val = p(&quot;xyx&quot;)  # raises an exception. nothing would be consumed```### Forward`Forward` allows recursive grammars where a nonterminal's definition includesitself directly or indirectly. You initially create a `Forward` nonterminalwith regular assignment.```pythonexpr = Forward()```You later give it its real definition with the `&lt;=` operator.```pythonexpr &lt;= (term + Many(LowOps + term)).map(op)```### ArithmeticHere's an arithmetic parser that ties several concepts together. A progressionof this parser from a simple imperative style to what you see below is in the[repo](https://github.com/csams/parsr/blob/master/parsr/lesson).```pythonfrom parsr import EOF, Forward, InSet, LeftParen, Many, Number, RightParen, WSdef op(args):    ans, rest = args    for op, arg in rest:        if op == &quot;+&quot;:            ans += arg        elif op == &quot;-&quot;:            ans -= arg        elif op == &quot;*&quot;:            ans *= arg        elif op == &quot;/&quot;:            ans /= arg    return ans# high precedence operationsHighOps = InSet(&quot;*/&quot;)# low precedence operationsLowOps = InSet(&quot;+-&quot;)# Operator precedence is handled by having different declarations for each# prededence level. expr handles low level operations, term handles high level# operations, and factor handles simple numbers or subexpressions between# parentheses. Since the first element in expr is term and the first element in# term is factor, factors are evaluated first, then terms, and then exprs.# We have to declare expr before its definition since it's used recursively# through the definition of factor.expr = Forward()# A factor is a simple number or a subexpression between parentheses.factor = WS &gt;&gt; (Number | (LeftParen &gt;&gt; expr &lt;&lt; RightParen)) &lt;&lt; WS# A term handles strings of multiplication and division. As written, it would# convert &quot;1 + 2 - 3 + 4&quot; into [1, [['+', 2], ['-', 3], ['+', 4]]]. The first# element in the outer list is the initial factor. The second element of the# outer list is another list, which is the result of the Many. The Many's list# contains several two-element lists generated from each match of# (HighOps + factor). We pass the entire structure into the op function with# map.term = (factor + Many(HighOps + factor)).map(op)# expr has the same form and behavior as term.# Notice that we assign to expr with &quot;&lt;=&quot; instead of &quot;=&quot;. This is how you assign# to nonterminals that have been declared previously as Forward.expr &lt;= (term + Many(LowOps + term)).map(op)val = expr(&quot;2*(3+4)/3+4&quot;)  # returns 8.666666666666668```</longdescription>
</pkgmetadata>