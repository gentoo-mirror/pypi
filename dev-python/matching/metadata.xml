<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![CI status](https://github.com/daffidwilde/matching/actions/workflows/ci.yml/badge.svg?branch=main)[![Code style](https://img.shields.io/badge/code%20style-black-black)](https://github.com/ambv/black)[![Zenodo archive](https://zenodo.org/badge/DOI/10.5281/zenodo.2553125.svg)](https://doi.org/10.5281/zenodo.2553125)[![JOSS paper](https://joss.theoj.org/papers/10.21105/joss.02169/status.svg)](https://doi.org/10.21105/joss.02169)# A package for solving matching gamesMatching games allow for the allocation of resources and partnerships ina fair way. Typically, a matching game is defined by two sets of playersthat each have preferences over at least some of the elements of theother set. The objective of the game is then to find a mapping betweenthe sets of players in which everyone is happy enough with their match.In `matching`, we deal with four types of matching game:-   the stable marriage problem (SM);-   the hospital-resident assignment problem (HR);-   the student-allocation problem (SA);-   the stable roommates problem (SR).## InstallationMatching requires Python 3.5 or above, and relies only on[NumPy](http://www.numpy.org/) for general use.The library is most easily installed using `pip`:```bash    $ python -m pip install matching```However, if you would like to install it from source then go ahead andclone the GitHub repository:```bash    $ git clone https://github.com/daffidwilde/matching.git    $ cd matching    $ python -m pip install .```## DocumentationFull documentation (including tutorials and discussion material) isavailable here: &lt;https://matching.readthedocs.io&gt;An academic paper on this library has been included in the Journal ofOpen Source Software (JOSS) and is available here:&lt;https://joss.theoj.org/papers/10.21105/joss.02169&gt;## Playing a simple gameWith all games, Matching uses a `Player` class to represent the membersof the &quot;applying&quot; party, i.e. residents and students. For HR and SA,there are specific classes to represent the roles of `Hospital`,`Project` and `Supervisor`.Consider the following instance of SM which is represented on abipartite graph where the suitors and reviewers are along the left andright respectively.![image](./tex/stable_marriage.png){.align-center width=&quot;10cm&quot;}We can construct these preferences using dictionaries:```python&gt;&gt;&gt; suitor_preferences = {...     &quot;A&quot;: [&quot;D&quot;, &quot;E&quot;, &quot;F&quot;], &quot;B&quot;: [&quot;D&quot;, &quot;F&quot;, &quot;E&quot;], &quot;C&quot;: [&quot;F&quot;, &quot;D&quot;, &quot;E&quot;]... }&gt;&gt;&gt; reviewer_preferences = {...     &quot;D&quot;: [&quot;B&quot;, &quot;C&quot;, &quot;A&quot;], &quot;E&quot;: [&quot;A&quot;, &quot;C&quot;, &quot;B&quot;], &quot;F&quot;: [&quot;C&quot;, &quot;B&quot;, &quot;A&quot;]... }```Then to solve this matching game, we make use of the `StableMarriage`class, like so:```python&gt;&gt;&gt; from matching.games import StableMarriage&gt;&gt;&gt; game = StableMarriage.create_from_dictionaries(...     suitor_preferences, reviewer_preferences... )&gt;&gt;&gt; game.solve(){A: E, B: D, C: F}```## The `Matching` objectThis matching is not a standard Python dictionary, though it doeslargely look and behave like one. It is in fact an instance of the`SingleMatching` class:```python&gt;&gt;&gt; matching = game.matching&gt;&gt;&gt; type(matching)&lt;class 'matching.matchings.SingleMatching'&gt;```This dictionary-like object is primarily useful as a teaching devicethat eases the process of manipulating a matching after a solution hasbeen found.## `Player` classesDespite passing dictionaries of strings here, the matching displaysinstances of `matching.player.Player`:```python&gt;&gt;&gt; matching = game.matching&gt;&gt;&gt; for suitor in matching:...     print(type(suitor))&lt;class 'matching.players.player.Player'&gt;&lt;class 'matching.players.player.Player'&gt;&lt;class 'matching.players.player.Player'&gt;```This is because `create_from_dictionaries` creates instances of theappropriate player classes first and passes them to the game class.Using dictionaries like this can be an efficient way of creating largegames but it does require the names of the players in each party to beunique.With all games, Matching uses a `Player` class to represent the membersof the &quot;applying&quot; party, i.e. residents and students. For HR and SA,there are specific classes to represent the roles of `Hospital`,`Project` and `Supervisor`.## A note on performanceOne of the limitations of this library is the time complexities of thealgorithm implementations. In practical terms, the running time of anyof the algorithms in Matching is negligible but the theoretic complexityof each has not yet been attained. For example, an instance of HR with400 applicants and 20 hospitals is solved in less than one tenth of asecond:```python&gt;&gt;&gt; from matching.games import HospitalResident&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; prng = np.random.default_rng(0)&gt;&gt;&gt; num_residents, num_hospitals = 400, 20&gt;&gt;&gt; resident_prefs = {...     r: np.argsort(prng.random(size=num_hospitals))...     for r in range(num_residents)... }&gt;&gt;&gt; hospital_prefs = {...     h: np.argsort(prng.random(size=num_residents))...     for h in range(num_hospitals)... }&gt;&gt;&gt; capacities = {h: num_hospitals for h in hospital_prefs}&gt;&gt;&gt; game = HospitalResident.create_from_dictionaries(...     resident_prefs, hospital_prefs, capacities... )&gt;&gt;&gt; _ = game.solve() # 48.6 ms ± 963 µs per loop```## Get in contact!I hope this package is useful, and feel free to contact me here with anyissues or recommendations. Pull requests are always welcome!</longdescription>
</pkgmetadata>