<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># UnasyncA tool to transform asynchronous Python code to synchronous Python code.## Why?Unasyncd is largely inspired by [unasync](https://github.com/python-trio/unasync), anda detailed discussion about this approach can be found[here](https://github.com/urllib3/urllib3/issues/1323).Its purpose is to reduce to burden of having to maintain both a synchronous and anasynchronous version of otherwise functionally identical code. The idea behind simply&quot;taking out the async&quot; is that often, synchronous and asynchronous code only differslightly: A few `await`s, `async def`s, `async with`s, and a couple of different methodnames. The unasync approach makes use of this by treating the asynchronous version as asource of truth from wich the synchronous version is then generated.## Why unasyncd?The original [unasync](https://github.com/python-trio/unasync) works by simply replacingcertain token, which is enough for most basic use cases, but can be somewhat restrictivein the way the code can be written. More complex cases such as exclusion of functions /classes or transformations (such as `AsyncExitStack` to `ExitStack` wich have not onlydifferent names but also different method names that then need to be replaced onlywithin a certain scope) are not possible. This can lead to the introduction of shims,introducing additional complexity.Unasyncd's goal is to impose as little restrictions as possible to the way theasynchronous code can be written, as long as it maps to a functionally equivalentsynchronous version.To achieve this, unasyncd leverages [libcst](https://libcst.readthedocs.io/), enabling amore granular control and complex transformations.Unasyncd features:1. Transformation of arbitrary modules, not bound to any specific directory structure2. (Per-file) Exclusion of (nested) functions, classes and methods3. Optional transformation of docstrings4. Replacements based on fully qualified names   (e.g. `typing.AsyncGenerator` is different than `foo.typing.AsyncGenerator`)5. Transformation of constructs like `asyncio.TaskGroup` to a thread based equivalent*A full list of supported transformations is available below.*## Table of contents&lt;!-- TOC --&gt;* [Unasync](#unasync)  * [Why?](#why)  * [Why unasyncd?](#why-unasyncd)  * [Table of contents](#table-of-contents)  * [What can be transformed?](#what-can-be-transformed)    * [Asynchronous functions](#asynchronous-functions)    * [`await`](#await)    * [Asynchronous iterators, iterables and generators](#asynchronous-iterators-iterables-and-generators)    * [Asynchronous iteration](#asynchronous-iteration)    * [Asynchronous context managers](#asynchronous-context-managers)    * [`contextlib.AsyncExitStack`](#contextlibasyncexitstack)    * [`asyncio.TaskGroup`](#asynciotaskgroup)    * [`anyio.create_task_group`](#anyiocreatetaskgroup)    * [`asyncio.sleep` / `anyio.sleep`](#asynciosleep--anyiosleep)    * [Type annotations](#type-annotations)    * [Docstrings](#docstrings)  * [Usage](#usage)    * [Installation](#installation)    * [CLI](#cli)    * [As a pre-commit hook](#as-a-pre-commit-hook)    * [Configuration](#configuration)      * [File](#file)      * [CLI options](#cli-options)      * [Exclusions](#exclusions)      * [Extending name replacements](#extending-name-replacements)    * [Handling of imports](#handling-of-imports)    * [Integration with linters](#integration-with-linters)    * [Limitations](#limitations)    * [Disclaimer](#disclaimer)&lt;!-- TOC --&gt;## What can be transformed?Unasyncd supports a wide variety of transformation, ranging from simple namereplacements to more complex transformations such as task groups.### Asynchronous functions*Async*```pythonasync def foo() -&gt; str:    return &quot;hello&quot;```*Sync*```pythondef foo() -&gt; str:    return &quot;hello&quot;```### `await`*Async*```pythonawait foo()```*Sync*```pythonfoo()```### Asynchronous iterators, iterables and generators*Async*```pythonfrom typing import AsyncGeneratorasync def foo() -&gt; AsyncGenerator[str, None]:    yield &quot;hello&quot;```*Sync*```pythonfrom typing import Generatordef foo() -&gt; Generator[str, None, None]:    yield &quot;hello&quot;```*Async*```pythonfrom typing import AsyncIteratorclass Foo:    async def __aiter__(self) -&gt; AsyncIterator[str]:        ...    async def __anext__(self) -&gt; str:        raise StopAsyncIteration```*Sync*```pythonfrom typing import Iteratorclass Foo:    def __next__(self) -&gt; str:        raise StopIteration    def __iter__(self) -&gt; Iterator[str]:        ...```*Async*```pythonx = aiter(foo)```*Sync*```pythonx = iter(foo)```*Async*```pythonx = await anext(foo)```*Sync*```pythonx = next(foo)```### Asynchronous iteration*Async*```pythonasync for x in foo():    pass```*Sync*```pythonfor x in foo():    pass```*Async*```python[x async for x in foo()]```*Sync*```python[x for x in foo()]```### Asynchronous context managers*Async*```pythonasync with foo() as something:    pass```*Sync*```pythonwith foo() as something:    pass```*Async*```pythonclass Foo:    async def __aenter__(self):        ...    async def __aexit__(self, exc_type, exc_val, exc_tb):        ...```*Sync*```pythonclass Foo:    def __enter__(self):        ...    def __exit__(self, exc_type, exc_val, exc_tb):        ...```*Async*```pythonfrom contextlib import asynccontextmanagerfrom typing import AsyncGenerator@asynccontextmanagerasync def foo() -&gt; AsyncGenerator[str, None]:    yield &quot;hello&quot;```*Sync*```pythonfrom contextlib import contextmanagerfrom typing import Generator@contextmanagerdef foo() -&gt; Generator[str, None, None]:    yield &quot;hello&quot;```### `contextlib.AsyncExitStack`*Async*```pythonimport contextlibasync with contextlib.AsyncExitStack() as exit_stack:    exit_stack.enter_context(context_manager_one())    exit_stack.push(callback_one)    exit_stack.callback(on_exit_one)    await exit_stack.enter_async_context(context_manager_two())    exit_stack.push_async_exit(on_exit_two)    exit_stack.push_async_callback(callback_two)    await exit_stack.aclose()```*Sync*```pythonimport contextlibwith contextlib.ExitStack() as exit_stack:    exit_stack.enter_context(context_manager_one())    exit_stack.push(callback_one)    exit_stack.callback(on_exit_one)    exit_stack.enter_context(context_manager_two())    exit_stack.push(on_exit_two)    exit_stack.callback(callback_two)    exit_stack.close()```See [limitations](#limitations)### `asyncio.TaskGroup`*Async*```pythonimport asyncioasync with asyncio.TaskGroup() as task_group:    task_group.create_task(something(1, 2, 3, this=&quot;that&quot;))```*Sync*```pythonimport concurrent.futureswith concurrent.futures.ThreadPoolExecutor() as executor:    executor.submit(something, 1, 2, 3, this=&quot;that&quot;)```See [limitations](#limitations)### `anyio.create_task_group`*Async*```pythonimport anyioasync with anyio.create_task_group() as task_group:    task_group.start_soon(something, 1, 2, 3)```*Sync*```pythonimport concurrent.futureswith concurrent.futures.ThreadPoolExecutor() as executor:    executor.submit(something, 1, 2, 3)```See [limitations](#limitations)### `asyncio.sleep` / `anyio.sleep`Calls to `asyncio.sleep` and `anyio.sleep` will be replaced with calls to `time.sleep`:*Async*```pythonimport asyncioawait asyncio.sleep(1)```*Sync*```pythonimport timetime.sleep(1)```If the call argument is `0`, the call will be replaced entirely:```pythonimport asyncioawait asyncio.sleep(0)```### Type annotations|                                   |                                    ||-----------------------------------|------------------------------------|| `typing.AsyncIterable[int]`       | `typing.Iterable[int]`             || `typing.AsyncIterator[int]`       | `typing.Iterator[int]`             || `typing.AsyncGenerator[int, str]` | `typing.Generator[int, str, None]` |### DocstringsSimply token replacement is available in docstrings:*Async*```pythonasync def foo():    &quot;&quot;&quot;This calls ``await bar()`` and ``asyncio.sleep``&quot;&quot;&quot;```*Sync*```pythondef foo():    &quot;&quot;&quot;This calls ``bar()`` and ``time.sleep``&quot;&quot;&quot;```## Usage### Installation```shellpip install unasyncd```### CLIInvoking `unasyncd` without any parameters will apply the configuration from the configfile:```shellunasyncd```But it's also possible to specify the files to be transformed directly:```shellunasyncd async_thing.py:aync_thing.py```This will transform `async_thing.py` and write the result back into `sync_thing.py`### As a pre-commit hookUnasyncd is available as a pre-commit hook:```yaml- repo: https://github.com/provinzkraut/unasyncd  rev: v0.2.1  hooks:    - id: unasyncd```### ConfigurationUnasyncd can be configured via a `pyproject.toml` file, a dedicated `.unasyncd.toml`file or the command line interface.#### File| config file key               | type  | default | description                                                                        ||-------------------------------|-------|---------|------------------------------------------------------------------------------------|| `files`                       | table | -       | A table mapping source file names / directories to target file names / directories || `exclude`                     | array | -       | An array of names to exclude from transformation                                   || `per_file_exclude`            | table | -       | A table mapping files names to an array of names to exclude from transformation    || `add_replacements`            | table | -       | A table of additional name replacements                                            || `per_file_add_replacements`   | table | -       | A table mapping file names to tables of additional replacements                    || `transform_docstrings`        | bool  | false   | Enable transformation of docstrings                                                || `add_editors_note`            | bool  | false   | Add a note on top of the generated files                                           || `infer_type_checking_imports` | bool  | true    | Infer if new imports should be added to an 'if TYPE_CHECKING' block                || `cache`                       | bool  | true    | Cache transformation results                                                       || `force_regen`                 | bool  | false   | Always regenerate files, regardless if their content has changed                   || `ruff_fix`                    | bool  | false   | Run `ruff --fix` on the generated code                                             |**Example**```toml[tool.unasyncd]files = { &quot;async_thing.py&quot; = &quot;sync_thing.py&quot;, &quot;foo.py&quot; = &quot;bar.py&quot; }exclude = [&quot;Something&quot;, &quot;SomethingElse.within&quot;]per_file_exclude = { &quot;foo.py&quot; = [&quot;special_foo&quot;] }add_replacements = { &quot;my_async_func&quot; = &quot;my_sync_func&quot; }per_file_add_replacements = { &quot;async_thing.py&quot; = { &quot;AsyncClass&quot; = &quot;SyncClass&quot; } }transform_docstrings = trueremove_unused_imports = falseno_cache = falseno_cache = falseforce_regen = false```#### CLI options*Feature flags corresponding to configuration values. These will override theconfiguration file values*| option                             | description                                                         ||------------------------------------|---------------------------------------------------------------------|| `--cache`                          | Cache transformation results                                        || `--no-cache `                      | Don't cache transformation results                                  || `--transform-docstrings`           | Enable transformation of docstrings                                 || `--no-transform-docstrings`        | Inverse of `--transform-docstrings`                                 || `--infer-type-checking-imports`    | Infer if new imports should be added to an 'if TYPE_CHECKING' block || `--no-infer-type-checking-imports` | Inverse of `infer-type-checking-imports`                            || `--add-editors-note`               | Add a note on top of each generated file                            || `--no-add-editors-note`            | Inverse of `--add-editors-note`                                     || `--ruff-fix`                       | Run `ruff --fix` on the generated code                              || `--no-ruff-fix`                    | Inverse of `--ruff-fix`                                             || `--force`                          | Always regenerate files, regardless if their content has changed    || `--no-force`                       | Inverse of `--force`                                                || `--check`                          | Don't write changes back to files                                   || `--write`                          | Inverse of `--check`                                                |*Additional CLI options*| option      | description                          ||-------------|--------------------------------------|| `--config`  | Alternative configuration file       || `--verbose` | Increase verbosity of console output || `--quiet`   | Suppress all console output          |#### ExclusionsIt is possible to exclude specific functions classes and methods from thetransformation. This can be achieved by adding their fully qualified name(relative to the transformed module) under the `exclude` key:```toml[tool.unasyncd]exclude = [&quot;Something&quot;, &quot;SomethingElse.within&quot;]```In this example, classes or functions with the name `Something`, and the `within`method of the `SomethingElse` class will be skipped.The same option is available on a per-file basis, under the `per_file_exclude` key:```toml[tool.unasyncd]per_file_exclude.&quot;module.py&quot; = [&quot;Something&quot;, &quot;SomethingElse.within&quot;]```This sets the same exclusion rules as above, but only for the file `module.py`.#### Extending name replacementsAdditional name replacement rules can be defined by adding fully qualified names(relative to the transformed module) and replacements under the `add_replacements` key:```toml[tool.unasyncd]add_replacements = { &quot;some_module.some_name&quot; = &quot;some_other_module.some_other_name&quot; }```The same option is available on a per-file basis, under the `per_file_add_replacements`key:```toml[tool.unasyncd]per_file_add_replacements.&quot;module.py&quot; = { &quot;some_module.some_name&quot; = &quot;some_other_module.some_other_name&quot; }```### Handling of importsUnasyncd will add new imports when necessary and tries to be sensible about the way itdoes. There are however no guarantees about import order or compatibility with e.g.isort or black. It follows a few basic rules:1. Relativity of imports should be kept intact, e.g. `typing.AsyncGenerator` will be   replaced with `typing.Generator` and `from typing import AsyncGenerator` with   `from typing import Generator`2. Existing imports will be updated if possible, for instance `from time import time`   would become `from time import time, sleep` if `sleep` has been added by unasyncd   during the transformation3. New imports are added before the first non-import block that's not a docstring or a   commentUnasyncd will not remove imports that have become unused as a result of the appliedtransformations. This is because tracking of usages is a complex task and best left totools made specifically for this job like [ruff](https://beta.ruff.rs/docs) or[autoflake](https://github.com/PyCQA/autoflake).### Integration with lintersUsing unasyncd in conjunction with linters offering autofixing behaviour can lead to anedit-loop, where unasyncd generates a new file which the other tool then changes in anon-AST-equivalent way - for example by removing an import that has become unused as aresult of the transformation applied by unasyncd -, in turn causing unasyncd toregenerate the file the next time it is invoked, since the target file is no longerAST-equivalent to what unasyncd thinks it should be.To alleviate this, unasyncd offers a [ruff](https://beta.ruff.rs/docs) integration,which can automatically run `ruff --fix` on the generated code before writing it back.It will use the existing ruff configuration for this to ensure the fixes applied toadhere to the rules used throughout the project.If this option is used, the transformed code will never be altered by ruff, thereforebreaking the cycle.This option can be enabled with the `ruff_fix = true` feature flag, or by using the`--ruff-fix` CLI flag.Usage of this option requires an installation of `ruff`. If not independently installed,it can be installed as an extra of unasyncd: `pip install unasyncd[ruff]`.**Why is only ruff supported?**Ruff was chosen for its speed, having a negligible impact on the overall performance ofunasyncd, and because it can replace most of the common linters / tools with autofixingcapabilities, removing the need for separate integrations.### LimitationsTransformations for `contextlib.AsyncContextManager`, `asyncio.TaskGroup` and`anyio.create_task_group` only work when they're being called in a `with` statementdirectly. This is due to the fact that unasyncd does not track assignments or supporttype inference. Support for these usages might be added in a future version.### DisclaimerUnasyncd's output should not be blindly trusted. While it is unlikely that it will breakthings the resulting code should always be tested. Unasyncd is not intended to be run atbuild time, but integrated into a git workflow (e.g. with[pre-commit](https://pre-commit.com/)).</longdescription>
</pkgmetadata>