<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>| |travisci| |version| |versions| |impls| |wheel| |coverage|.. |travisci| image:: https://travis-ci.org/jonathaneunice/textdata.svg?branch=master    :alt: Travis CI build status    :target: https://travis-ci.org/jonathaneunice/textdata.. |version| image:: http://img.shields.io/pypi/v/textdata.svg?style=flat    :alt: PyPI Package latest release    :target: https://pypi.org/project/textdata.. |versions| image:: https://img.shields.io/pypi/pyversions/textdata.svg    :alt: Supported versions    :target: https://pypi.org/project/textdata.. |impls| image:: https://img.shields.io/pypi/implementation/textdata.svg    :alt: Supported implementations    :target: https://pypi.org/project/textdata.. |wheel| image:: https://img.shields.io/pypi/wheel/textdata.svg    :alt: Wheel packaging support    :target: https://pypi.org/project/textdata.. |coverage| image:: https://img.shields.io/badge/test_coverage-99%25-blue.svg    :alt: Test line coverage    :target: https://pypi.org/project/textdataOne often needs to state data in program source. Python, however, needs itsprogram lines indented *just so*. Multi-line strings therefore often have extraspaces and newline characters you didn't really want. Many developers &quot;fix&quot;this by using Python ``list`` literals, but that's tedious, verbose, and oftenless legible.The ``textdata`` package makes it easy to have clean, nicely-whitespaceddata specified in your program, but to get the data without extra syntaxcluttering things up. It's permissive of the layouts needed to make Pythoncode look and work right, without reflecting those requirements in theresulting data.Text (Strings and Lists)------------------------.. code-block:: pycon    &gt;&gt;&gt; lines(&quot;&quot;&quot;    ...     There was an old woman who lived in a shoe.    ...     She had so many children, she didn't know what to do;    ...     She gave them some broth without any bread;    ...     Then whipped them all soundly and put them to bed.    ... &quot;&quot;&quot;)    ['There was an old woman who lived in a shoe.',     &quot;She had so many children, she didn't know what to do;&quot;,     'She gave them some broth without any bread;',     'Then whipped them all soundly and put them to bed.']Note that the &quot;extra&quot; newlines and leading spaces have beentaken care of and discarded. Or do you want that as just onestring? Okay:.. code-block:: pycon    &gt;&gt;&gt; text(&quot;&quot;&quot;    ...     There was an old woman who lived in a shoe.    ...     She had so many children, she didn't know what to do;    ...     She gave them some broth without any bread;    ...     Then whipped them all soundly and put them to bed.    ... &quot;&quot;&quot;)    &quot;There was an old woman who lived in a shoe.\nShe ...put them to bed.&quot;Here ``text()`` does the same stripping of pointless whitespace at the beginningand end of lines, returning the data as a clean, convenient string. Or if youdon't want most of the line endings, try ``textline`` on the same input to get asingle no-breaks line.Words and Phrases-----------------Other times, the data you need is almost, but not quite, a series ofwords. A list of names, a list of colors--values that are mostlysingle words, but sometimes have an embedded spaces. ``textdata`` has youcovered:.. code-block:: pycon    &gt;&gt;&gt; words(' Billy Bobby &quot;Mr. Smith&quot; &quot;Mrs. Jones&quot;  ')    ['Billy', 'Bobby', 'Mr. Smith', 'Mrs. Jones']Embedded quotes (either single or double) can be used to construct&quot;words&quot; (or phrases) containing whitespace (including tabs and newlines).``words``, like the other ``textdata`` facilities, allows you tocomment individual lines that would otherwise muck up string literals:.. code-block:: pycon    exclude = words(&quot;&quot;&quot;        __pycache__ *.pyc *.pyo     # compilation artifacts        .hg* .git*                  # repository artifacts        .coverage                   # code tool artifacts        .DS_Store                   # platform artifacts    &quot;&quot;&quot;)Yields:.. code-block:: pycon    ['__pycache__', '*.pyc', '*.pyo', '.hg*', '.git*',     '.coverage', '.DS_Store']Paragraphs----------Instead of words, you might wan to collect &quot;paragraphs&quot;--contiguous runs of textlines delineated by blank lines. Markdown and RST document formats, for example,use this convention... code-block:: pycon    &gt;&gt;&gt; rhyme = &quot;&quot;&quot;        Hey diddle diddle,        The cat and the fiddle,        The cow jumped over the moon.        The little dog laughed,        To see such sport,        And the dish ran away with the spoon.    &quot;&quot;&quot;    &gt;&gt;&gt; paras(rhyme)    [['Hey diddle diddle,'],     ['The cat and the fiddle,',      'The cow jumped over the moon.',      'The little dog laughed,',      'To see such sport,'],     ['And the dish ran away with the spoon.']]Or if you'd like paras, but each paragraph in a single string:.. code-block:: pycon    &gt;&gt;&gt; paras(rhyme, join=&quot;\n&quot;)    ['Hey diddle diddle,',     'The cat and the fiddle,\nThe cow jumped over the moon.\nThe little dog laughed,\nTo see such sport,',     'And the dish ran away with the spoon.']Dictionaries------------Or maybe you want a ``dict``. The ``attrs`` function makes it easy tograb::.. code-block:: pycon    &gt;&gt;&gt; attrs(&quot;a=1 b=2 c='something more'&quot;)    {'a': 1, 'b': 2, 'c': 'something more'}If you want to cut and paste data directly from JavaScript, JSON, HTML, CSS, orXML, easy peasy! No text editing required... code-block:: pycon    &gt;&gt;&gt; # JavaScript    &gt;&gt;&gt; attrs(&quot;a: 1, b: 2, c: 'something more'&quot;)    {'a': 1, 'b': 2, 'c': 'something more'}    &gt;&gt;&gt; # JSON    &gt;&gt;&gt; attrs('&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &quot;something more&quot;')    {'a': 1, 'b': 2, 'c': 'something more'}    &gt;&gt;&gt; # HTML or XML    &gt;&gt;&gt; attrs('a=&quot;1&quot; b=&quot;2&quot; c=&quot;something more&quot;')    {'a': '1', 'b': '2', 'c': 'something more'}    &gt;&gt;&gt; # above returns strings, because values quoted, which denotes strings    &gt;&gt;&gt; # 'full' evaluation needed to transform strings into values    &gt;&gt;&gt; attrs('a=&quot;1&quot; b=&quot;2&quot; c=&quot;something more&quot;', evaluate='full')    {'a': 1, 'b': 2, 'c': 'something more'}    &gt;&gt;&gt; # CSS    &gt;&gt;&gt; attrs(&quot;a: 1; b: 2; c: 'something more'&quot;)    {'a': 1, 'b': 2, 'c': 'something more'}Tables------Or maybe you have tabular data... code-block:: pycon    &gt;&gt;&gt; tabledata = &quot;&quot;&quot;    ...     name  age  strengths    ...     ----  ---  ---------------    ...     Joe   12   woodworking    ...     Jill  12   slingshot    ...     Meg   13   snark, snapchat    ... &quot;&quot;&quot;    &gt;&gt;&gt; table(tabledata)    [['name', 'age', 'strengths'],     ['Joe', 12, 'woodworking'],     ['Jill', 12, 'slingshot'],     ['Meg', 13, 'snark, snapchat']]    &gt;&gt;&gt; records(tabledata)    [{'name': 'Joe', 'age': 12, 'strengths': 'woodworking'},     {'name': 'Jill', 'age': 12, 'strengths': 'slingshot'},     {'name': 'Meg', 'age': 13, 'strengths': 'snark, snapchat'}]This works even if you have a table with a lot of extra fluff:.. code-block:: pycon    &gt;&gt;&gt; fancy = &quot;&quot;&quot;    ... +------+-----+-----------------+    ... | name | age | strengths       |    ... +------+-----+-----------------+    ... | Joe  |  12 | woodworking     |    ... | Jill |  12 | slingshot       |    ... | Meg  |  13 | snark, snapchat |    ... +------+-----+-----------------+    ... &quot;&quot;&quot;    &gt;&gt;&gt; assert table(tabledata) == table(fancy)    &gt;&gt;&gt; assert records(tabledata) == records(fancy)It works with tables formatted in a variety of ways including Markdown, RST,ANSI/Unicode line drawing characters, plain text columns and borders.... You'dmight think table parsing would be a dicey proposition, prone to failure, but``textdata`` has *dozens* of tests, including rather complex cases, showingit's a reliable, high-probability heuristic.In Summary----------``textdata`` is all about conveniently grabbing the data you want from textfiles and program source, and doing it in a highly functional, convenient,well-tested way. Take it for a spin today!See `the full documentationat Read the Docs &lt;https://textdata.readthedocs.org/en/latest/&gt;`_.</longdescription>
</pkgmetadata>