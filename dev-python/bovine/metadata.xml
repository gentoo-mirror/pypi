<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># BovineThis package contains two essential parts of bovine. Firstit defines `BovineActor`, which contains all the necessitiesto write ActivityPub Clients. Furthermore, this package containsthe cryptographic routines to verify HTTP signatures.Furthermore, the folder `examples` contains a few examples onhow `BovineActor` can be used. The cryptographic routinesare used in `bovine_fedi` to verify signatures.Documentation is available at [ReadTheDocs](https://bovine.readthedocs.io/en/latest/)## Example: Make a post aka Faking at being a ServerWhile [ActivityPub](https://www.w3.org/TR/activitypub/) specifies Server to Server and Client to Server, they really are just two sides of the same coin. In this example, we will work through how to use `BovineActor` to post a message.Without having an ActivityPub Server supporting Client to Server, this will require a bit of setup. This setup will build a stub server that just allows other ActivityPub servers to associate us with a domain.The stub server is given by the following snippet. One should note that it just answers with predefined json from a config file, that hasn't been generated yet. One could easily replace it with serving static files. See also [the Mastodon Blog](https://blog.joinmastodon.org/2018/06/how-to-implement-a-basic-activitypub-server/) for a similar implementation.```pythonimport tomliimport jsonfrom quart import Quartapp = Quart(__name__)with open(&quot;server.toml&quot;, &quot;rb&quot;) as fp:    config = tomli.load(fp)@app.get(&quot;/.well-known/webfinger&quot;)async def webfinger():    return json.loads(config[&quot;webfinger&quot;])@app.get(&quot;/actor&quot;)async def actor():    return json.loads(config[&quot;actor&quot;])if __name__ == &quot;__main__&quot;:    app.run()```The following script generates the config files. You will have to adapt the `hostname` variable and be able to serve the entire thing through https.```pythonimport bovineimport tomli_wimport jsonhostname = &quot;bovine-demo.mymath.rocks&quot;public_key, private_key = bovine.utils.crypto.generate_public_private_key()actor_url = f&quot;https://{hostname}/actor&quot;actor = (    bovine.activitystreams.build_actor(&quot;actor&quot;)    .with_account_url(actor_url)    .with_public_key(public_key))webfinger = {    &quot;subject&quot;: f&quot;acct:actor@{hostname}&quot;,    &quot;links&quot;: [        {            &quot;href&quot;: actor_url,            &quot;rel&quot;: &quot;self&quot;,            &quot;type&quot;: &quot;application/activity+json&quot;,        }    ],}server_config = {&quot;actor&quot;: json.dumps(actor.build()), &quot;webfinger&quot;: json.dumps(webfinger)}actor_config = {    &quot;account_url&quot;: actor_url,    &quot;public_key_url&quot;: f&quot;{actor_url}#main-key&quot;,    &quot;private_key&quot;: private_key,}with open(&quot;server.toml&quot;, &quot;wb&quot;) as fp:    tomli_w.dump(server_config, fp)with open(&quot;bovine.toml&quot;, &quot;wb&quot;) as fp:    tomli_w.dump(actor_config, fp)```You can now access the urls, which are in my case [https://bovine-demo.mymath.rocks/actor](https://bovine-demo.mymath.rocks/actor) and [https://bovine-demo.mymath.rocks/.well-known/webfinger?resource=acct:actor@bovine-demo.mymath.rocks](https://bovine-demo.mymath.rocks/.well-known/webfinger?resource=acct:actor@bovine-demo.mymath.rocks). Using this, we can now lookup the fediverse handle `actor@bovine-demo.mymath.rocks` on most FediVerse applications.You can now send a post via the following code snippet:```pythonimport asynciofrom uuid import uuid4from bovine import BovineActortarget_account = &quot;https://mas.to/users/themilkman&quot;async def run():    async with BovineActor.from_file(&quot;bovine.toml&quot;) as actor:        activity_factory, object_factory = actor.factories        note = (            object_factory.note(&quot;Hello&quot;)            .add_to(target_account)            .with_mention(target_account)            .build()        )        note[&quot;id&quot;] = actor.actor_id + &quot;/&quot; + str(uuid4())        create = activity_factory.create(note).build()        create[&quot;id&quot;] = actor.actor_id + &quot;/&quot; + str(uuid4())        remote_actor = await actor.get(target_account)        target_inbox = remote_actor[&quot;inbox&quot;]        await actor.post(target_inbox, create)asyncio.run(run())```A few comments are in order:- The id needs to be set on the Note and Create in order to be compatible with Mastodon. When using proper Client To Server as below, it is superfluous- The form of adding the `target_account` to both to and mention causes it to be a direct message.## Using BovineClientOne can import it via `from bovine import BovineClient`. Then one can either use it via:```pythonasync with BovineClient(config) as actor:    ...# oractor = BovineClient(config)await actor.init()```Here the config object can be present in two variants. First it can contain the keys `host` and `private_key`, where `host` is the domain the ActivityPub Actor is on and `private_key` is a mutlicodec encoded Ed25519 key, whose corresponding did-key has been added to the Actor. In this case [Moo-Auth-1](https://blog.mymath.rocks/2023-03-15/BIN1_Moo_Authentication_and_Authoriation) will be used. The second variant is to use [HTTP Signatures](https://docs.joinmastodon.org/spec/security/#http), where the keys `account_url`, `public_key_url`, and `private_key` need to be present. Alternatively, to passing a config object, one can use `BovineActor.from_file(path_to_toml_file)`.### Making a postBovineActor contains two factories to create [ActivityStreams Objects](https://www.w3.org/TR/activitystreams-vocabulary/#object-types) and [ActivityStreams Activities](https://www.w3.org/TR/activitystreams-vocabulary/#activity-types). One can obtain them by running```pythonactivity_factory, object_factory = actor.factories```The simplest usage example is a create wrapping a note, that looks like:```pythonactivity_factory, object_factory = actor.factoriesnote = object_factory.note(&quot;Hello&quot;).as_public().build()create = activity_factory.create(note).build()```The result should be the something equivalent to the json```json{  &quot;@context&quot;: &quot;https://www.w3.org/ns/activitystreams&quot;,  &quot;type&quot;: &quot;Create&quot;,  &quot;actor&quot;: &quot;https://domain/actor&quot;,  &quot;object&quot;: {    &quot;attributedTo&quot;: &quot;https://domain/actor&quot;,    &quot;type&quot;: &quot;Note&quot;,    &quot;content&quot;: &quot;Hello&quot;,    &quot;published&quot;: &quot;2023-03-25T08:12:32Z&quot;,    &quot;to&quot;: &quot;as:Public&quot;,    &quot;cc&quot;: &quot;https://domain/followers_collection&quot;  },  &quot;published&quot;: &quot;2023-03-25T08:12:32Z&quot;,  &quot;to&quot;: &quot;as:Public&quot;,  &quot;cc&quot;: &quot;https://domain/followers_collection&quot;}```The details depend on the used actor and will likely contain superfluous elements until the creation process is improved. We can now send this activity to our outbox using```pythonawait actor.send_to_outbox(create)```__Note__: This is different from what we did in the first example, where we used `await actor.post(inbox, create)`. The difference is that in the first example, we faked being a server, now we are actually using Client To Server.### The inbox and outboxBy running```pythoninbox = await actor.inbox()outbox = await actor.outbox()```one can obtain `CollectionHelper` objects. These are meant to make it easier to interact with collection objects. In the simplest use case, one can use```pythonawait inbox.next_item()```to get the items from the inbox one after the other. It is also possible to print a summary of all elements that have been fetched from the inbox using `await inbox.summary()`. Finally, it is possible to iterate over the inbox via```pythonasync for item in inbox.iterate(max_number=3):    do_something(item)```### Proxying elementsWe have already seen the difference between using `post` directly to an inbox and posting to the actor's outbox using `send_to_outbox`. A similar pattern applies to fetching objects. Both of these commands often have a similar result```pythonawait actor.get(object_id)await actor.proxy_element(object_id)```However, they do different things:- The first `actor.get` sends a webrequest to the server `object_id` is on and retrieves it- The second `actor.proxy_element` sends a request to the actor's server for the object. This request is then either answered from the server's object store or by the server fetching the object. The cache behavior is up to the server. Depending of the evolution of `proxyUrl` of an Actor, more options might be added here.As most servers don't support Moo-Auth-1, using `proxy_element` is the only way to obtain foreign objects, when using it.### Event SourceThe event source is demonstrated in `examples/sse.py`. First, the event source will be specified in a [FEP](https://codeberg.org/fediverse/fep) to come. It provides a way to receive updates from the server, whenever a new element is added to the inbox or outbox. The basic usage is```pythonevent_source = await actor.event_source()async for event in event_source:    if event and event.data:        data = json.loads(event.data)        do_something(data)```If you plan on writing long running applications, the event source does not automatically reconnect, so you will need to implement this. [mechanical_bull](https://codeberg.org/helge/mechanical_bull) uses the event source in this way.</longdescription>
</pkgmetadata>