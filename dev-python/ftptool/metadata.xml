<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=======ftptool=======Higher-level ftplib`ftplib` in itself is a bit raw, as it leaves details about the protocol forthe user to handle. `ftptool` abstracts that away, and even provides a neatinterface for file management.Connecting &amp; Authenticating===========================Code says more than words, so let's look at an example: connecting.&gt;&gt;&gt; a_host = FTPHost.connect(&quot;ftp.python.org&quot;, user=&quot;foo&quot;, password=&quot;bar&quot;)`connect` is a classmethod that lets you create an `FTPHost` instance with anunderlying `ftplib.FTP` instance. Working with Directories========================Changing Working Directory--------------------------Changing and getting the current directory is implemented as a property called`current_directory`. It is lazy; it won't ask the server which the currentdirectory is until you ask for it.Note that since it's a property, this will actually go one level up:&gt;&gt;&gt; a_host.current_directory = &quot;..&quot;Similarly, this will descend into the &quot;foo&quot; directory:&gt;&gt;&gt; a_host.current_directory = &quot;foo&quot;In most cases, it's easier to just specify absolute paths:&gt;&gt;&gt; a_host.current_directory = &quot;/foo&quot;`current_directory` will always be the server-side representation; when youchange directory, it ends up sending a ``CWD`` and then a ``PWD`` to get theresult of the operation (since the FTP protocol doesn't define what the replytext to a ``CWD`` is.)Listing and Walking the Directory Tree--------------------------------------A `os.walk` interface is implemented for walking the directory tree:&gt;&gt;&gt; for (dirname, subdirs, files) in a_host.walk(&quot;/a_dir&quot;):...     print dirname, &quot;has file(s)&quot;, &quot;, &quot;.join(files).../a_dir has file(s) foo, bar/a_dir/other_dir has file(s) hello/a_dir/some_dir has file(s)Just like `os.walk`, you can remove entries in the `subdirs` list to avoiddescending into them:&gt;&gt;&gt; for (dirname, subdirs, files) in a_host.walk(&quot;/a_dir&quot;):...     for subdir in subdirs:...         if subdir.startswith(&quot;other_&quot;):...             subdirs.remove(subdir)...     print dirname, &quot;has file(s)&quot;, &quot;, &quot;.join(files).../a_dir has file(s) foo, bar/a_dir/some_dir has file(s)You can non-recursively list a directory using `listdir`:&gt;&gt;&gt; a_host.listdir(&quot;/a_dir&quot;)(['other_dir', 'some_dir'], ['foo', 'bar'])Creating, Deleting and Renaming-------------------------------The most simple form of creating a directory is `mkdir`. You simply give it adirectory to create, and so it does:&gt;&gt;&gt; a_host.mkdir(&quot;/new_dir&quot;)If you just want to ascertain that a directory is ready, i.e., exists for anupload, you could use `makedirs` which tries to create every part of thedirectory, piece by piece.&gt;&gt;&gt; a_host.makedirs(&quot;/a_dir/some_dir/a_new_dir/other_new_dir&quot;)Would, hypothetically, create ``a_new_dir`` and ``other_new_dir``.`ftptool` implements it by first trying to change directory into the givenpath, to see if it exists, and then changes back. If it does, it simplyreturns, otherwise it creates the directories piece by piece.Using the File Proxy====================Files in `ftptool` are implemented using proxy objects called `FTPFileProxy`.They represent a file on a remote host. Using them is easy as pie!&gt;&gt;&gt; a_host.file_proxy(&quot;/a_dir/foo&quot;).download_to_str()'This is the file &quot;foo&quot;.'&gt;&gt;&gt; a_host.file_proxy(&quot;/a_dir/new_file&quot;).upload_from_str(&quot;Hello world!&quot;)The Three Upload &amp; Download Methods-----------------------------------`ftptool` provides three ways of uploading or downloading files:* to/from_str: using a str object,* to/from_file: using a filename,* and the default: using a file-like object.Given:&gt;&gt;&gt; f = a_host.file_proxy(&quot;/foo.txt&quot;)You could upload and download from str using these two:&gt;&gt;&gt; f.upload_from_str(&quot;Hi!&quot;)&gt;&gt;&gt; f.download_to_str()'Hi!'And using a filename like this:&gt;&gt;&gt; f.upload_from_file(&quot;/etc/motd&quot;)&gt;&gt;&gt; f.download_to_file(&quot;/tmp/motd&quot;)And lastly, using file-like objects:&gt;&gt;&gt; f.upload(StringIO(&quot;Test!&quot;))&gt;&gt;&gt; fp = StringIO()&gt;&gt;&gt; f.download(fp)&gt;&gt;&gt; fp.getvalue()'Test!'Renaming Files--------------Renaming is a method of the file proxies, called `rename`. It returns a newfile proxy for the renamed-to file, so the common pattern will be:&gt;&gt;&gt; a_file = a_host.file_proxy(&quot;hello_world&quot;)&gt;&gt;&gt; a_file = a_file.rename(&quot;foobar&quot;)This will issue a rename command, too, so `a_file` will essentially be the sameas before, with a new name and a new instance ID.Deleting Files--------------Deleting a file is much like renaming it: it's a method of the file proxies,called `delete`. It, however, doesn't have a meaningful return value.&gt;&gt;&gt; a_file.delete()Mirroring=========`ftptool` supports two types of mirroring: local to remote, and remote tolocal. As in, it can download a whole directory and all descendants into alocal directory, for you to play with. It can also upload a whole directory toa remote host.The first one, downloading, is called `mirror_to_local`. It's used like so:&gt;&gt;&gt; a_host.mirror_to_local('/a_dir', 'my_copy_of_a_dir')The cousin, mirror_to_remote, has the same signature; source first, thendestination.&gt;&gt;&gt; a_host.mirror_to_remote('my_copy_of_a_dir', '/a_dir')If the local working directory is the one you want to upload, you can just give`mirror_to_remote` an empty string or a dot.</longdescription>
</pkgmetadata>