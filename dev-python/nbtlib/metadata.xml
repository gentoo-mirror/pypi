<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># nbtlib[![GitHub Actions](https://github.com/vberlier/nbtlib/workflows/CI/badge.svg)](https://github.com/vberlier/nbtlib/actions)[![PyPI](https://img.shields.io/pypi/v/nbtlib.svg)](https://pypi.org/project/nbtlib/)[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/nbtlib.svg)](https://pypi.org/project/nbtlib/)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)[![Discord](https://img.shields.io/discord/900530660677156924?color=7289DA&amp;label=discord&amp;logo=discord&amp;logoColor=fff)](https://discord.gg/98MdSGMm8j)&gt; A python library to read and edit [nbt data](http://wiki.vg/NBT). Requires&gt; python 3.8.**Features**- Create, read and edit nbt files- Supports gzipped and uncompressed files- Supports big-endian and little-endian files- Parse and serialize raw nbt data- Define tag schemas that automatically enforce predefined tag types- Convert nbt between binary form and literal notation- Use nbt paths to access deeply nested properties- Includes a CLI to quickly perform read/write/merge operations## Installation&gt; **Notice ðŸš§**&gt;&gt; Version `2.0` is actively being worked on and is not stable yet. You should probably keep using version `1.12.1` for the moment. You can check out the `2.0` roadmap in the [`nbtlib 2.0` issue](https://github.com/vberlier/nbtlib/issues/156).The package can be installed with `pip`.```bash$ pip install &quot;nbtlib==1.12.1&quot;```## Basic usageThe following examples will give you a very basic overview of what youcan do. For more advanced examples, check out the&quot;[Usage](https://github.com/vberlier/nbtlib/blob/main/docs/Usage.ipynb)&quot;notebook in the docs folder.### Reading filesThe `nbtlib.load` function can be used to load nbt files as `nbtlib.File` objects. Every nbt tag inherits fromits python counterpart. This means that all the builtin operations defined on the python counterpart can be used on nbt tags.```pythonimport nbtlibnbt_file = nbtlib.load('bigtest.nbt')assert nbt_file['intTest'] == 2147483647```For example, instances of `nbtlib.File` inherit from regular `Compound` tags, which themselves inherit from the builtin python dictionary `dict`. Similarly, instances of `Int` tags inherit from the builtin class `int`.For more details on loading nbt files and how to work with nbt tags check out the &quot;[Usage](https://github.com/vberlier/nbtlib/blob/main/docs/Usage.ipynb)&quot;notebook.### Editing filesYou can use instances of `nbtlib.File` as context managers in order to save modificationsautomatically at the end of the `with` statement.```pythonimport nbtlibfrom nbtlib.tag import Intwith nbtlib.load('demo.nbt') as demo:    demo['counter'] = Int(demo['counter'] + 1)```You can also call the `save` method manually.```pythonimport nbtlibfrom nbtlib.tag import Intdemo = nbtlib.load('demo.nbt')demo['counter'] = Int(demo['counter'] + 1)demo.save()```For more details on the `save` method check out the &quot;[Usage](https://github.com/vberlier/nbtlib/blob/main/docs/Usage.ipynb)&quot;notebook.### Using schemas`nbtlib` allows you to define `Compound` schemas that enforce a specific tag typefor any given key.```pythonfrom nbtlib import schemafrom nbtlib.tag import Short, StringMySchema = schema('MySchema', {    'foo': String,    'bar': Short})my_object = MySchema({'foo': 'hello world', 'bar': 21})assert isinstance(my_object, MySchema)assert isinstance(my_object['foo'], String)```For more details on schemas check out the &quot;[Usage](https://github.com/vberlier/nbtlib/blob/main/docs/Usage.ipynb)&quot;notebook.### Nbt literalsYou can parse nbt literals using the `nbtlib.parse_nbt` function.```pythonfrom nbtlib import parse_nbtfrom nbtlib.tag import String, List, Compound, IntArraymy_compound = parse_nbt('{foo: [hello, world], bar: [I; 1, 2, 3]}')assert my_compound == Compound({    'foo': List[String](['hello', 'world']),    'bar': IntArray([1, 2, 3])})```Nbt tags can be serialized to their literal representation with the `nbtlib.serialize_tag` function.```pythonfrom nbtlib import serialize_tagfrom nbtlib.tag import String, List, Compound, IntArraymy_compound = Compound({    'foo': List[String](['hello', 'world']),    'bar': IntArray([1, 2, 3])})assert serialize_tag(my_compound) == '{foo: [&quot;hello&quot;, &quot;world&quot;], bar: [I; 1, 2, 3]}'```For more details on nbt literals check out the &quot;[Usage](https://github.com/vberlier/nbtlib/blob/main/docs/Usage.ipynb)&quot;notebook.### Nbt pathsNbt paths can be used to access deeply nested properties in nbt data. The implementation is based on information available on the [Minecraft wiki](https://minecraft.gamepedia.com/Commands/data#NBT_path).```pythonfrom nbtlib import parse_nbt, Pathdata = parse_nbt('{a: [{b: {c: 42}}]}')assert data['a'][0]['b']['c'] == 42assert data[Path('a[0].b.c')] == 42```You can retrieve, modify and delete multiple properties at the same time.```pythonfrom nbtlib import parse_nbt, Pathfrom nbtlib.tag import Intdata = parse_nbt('{foo: [{a: 1, b: {c: 42}}, {a: 2, b: {c: 0}}]}')data[Path('foo[].a')] = Int(99)assert str(data) == '{foo: [{a: 99, b: {c: 42}}, {a: 99, b: {c: 0}}]}'assert data.get_all(Path('foo[].b.c')) == [42, 0]del data[Path('foo[].b{c: 0}')]assert str(data) == '{foo: [{a: 99, b: {c: 42}}, {a: 99}]}'```Nbt paths are immutable but can be manipulated and combined together to form new paths.```pythonfrom nbtlib import Pathfrom nbtlib.tag import Compoundpath = Path()['hello']['world']assert path[:][Compound({'a': Int(0)})] == 'hello.world[{a: 0}]'assert path + path == 'hello.world.hello.world'assert sum('abcdef', Path()) == 'a.b.c.d.e.f'assert Path()[0] + 'foo{a: 1}' + '{b: 2}.bar' == '[0].foo{a: 1, b: 2}.bar'assert path['key.with.dots'] == 'hello.world.&quot;key.with.dots&quot;'assert path + 'key.with.dots' == 'hello.world.key.with.dots'```## Command-line interfaceThe package comes with a small CLI that makes it easy to quickly performbasic operations on nbt files.```$ nbt --helpusage: nbt [-h] [-r | -s] [-w &lt;nbt&gt; | -m &lt;nbt&gt;] [--plain] [--little]           [--compact] [--pretty] [--unpack] [--json]           [--path &lt;path&gt;] [--find &lt;path&gt;]           &lt;file&gt;Perform operations on nbt files.positional arguments:  &lt;file&gt;         the target fileoptional arguments:  -h, --help     show this help message and exit  -r             read nbt data from a file  -s             read snbt from a file  -w &lt;nbt&gt;       write nbt to a file  -m &lt;nbt&gt;       merge nbt into a file  --plain        don't use gzip compression  --little       use little-endian format  --compact      output compact snbt  --pretty       output indented snbt  --unpack       output interpreted nbt  --json         output nbt as json  --path &lt;path&gt;  output all the matching tags  --find &lt;path&gt;  recursively find the first matching tag```### Read nbt dataYou can read nbt files by using the `-r` option. This will print theliteral notation of the binary nbt data.```bash$ nbt -r my_file.nbt{foo: [1, 2, 3], bar: &quot;Hello, world!&quot;}```You can use the following command if you want to save the output into afile.```bash$ nbt -r my_file.nbt &gt; my_file.snbt```Using the `--compact` argument will remove all the extra whitespace from the output.```bash$ nbt -r my_file.nbt --compact{foo:[1,2,3],bar:&quot;Hello, world!&quot;}```You can use the `--pretty` argument if you want the command to output indented snbt.```bash$ nbt -r my_file.nbt --pretty{    foo: [1, 2, 3],    bar: &quot;Hello, world!&quot;}```The output can be converted to json with the `--json` flag.```bash$ nbt -r my_file.nbt --json{&quot;foo&quot;: [1, 2, 3], &quot;bar&quot;: &quot;Hello, world!&quot;}```The `--path` option lets you output tags that match a given path.```bash$ nbt -r my_file.nbt --path &quot;bar&quot;&quot;Hello, world!&quot;$ nbt -r my_file.nbt --path &quot;foo[]&quot;123```You can combine this with the `--unpack` flag to print out the unpacked python objects.```bash$ nbt -r my_file.nbt --path &quot;bar&quot; --unpackHello, world!```If you don't know exactly how to access the data you're interested in you can use the `--find` option to recursively try to match a given path.```bash$ nbt -r my_file.nbt --find &quot;[1]&quot;2```You can also perform all these operations on snbt by using the `-s` option instead of the `-r` option.```bash$ nbt -s foo.snbt --path bar&quot;Hello, world!&quot;```### Write nbt dataYou can write nbt data to a file by using the `-w` option. This willconvert the literal nbt notation to its binary form and save it in thespecified file.```bash$ nbt -w '{foo:[1,2,3],bar:{hello:[B;1b,1b,0b,1b]}}' my_file.nbt```The file will be created if it doesn't already exist.You can combine the `-w` flag with other flags to read, filter and write nbt data.```bash$ nbt -r my_file.nbt --path &quot;bar&quot; -w bar.nbt```### Merge nbt dataFinally, you can merge some nbt data into an already existing file byusing the `-m` option. This will recursively update the file withthe values parsed from the literal argument.```bash$ nbt -m '{bar:{&quot;new key&quot;:56f}}' my_file.nbt```You can check the result by using the `-r` option.```bash$ nbt -r my_file.nbt{foo: [1, 2, 3], bar: {hello: [B; 1B, 1B, 0B, 1B], &quot;new key&quot;: 56.0f}}```Here, the compound values that aren't present in the input literal areleft untouched. Using the `-w` option instead of `-m` wouldoverwrite the whole file.You can combine the `-m` flag with other flags to read, filter and merge nbt data.```bash$ nbt -s foo.snbt -m my_file.nbt```### Compression and byte orderBy default, the CLI will assume that you're working with gzipped nbtfiles. If you want to read, write or merge uncompressed nbt files, youcan use the `--plain` option. Similarly, the default byte order isbig-endian so you'll need to use the `--little` option to performoperations on little-endian files.**Reading**```bash$ nbt -r my_file.nbt --plain --little{name: &quot;Reading an uncompressed little-endian file&quot;}```**Writing**```bash$ nbt -w '{name:&quot;Writing in an uncompressed little-endian file&quot;}' my_file.nbt --plain --little```**Merging**```bash$ nbt -m '{name:&quot;Merging in an uncompressed little-endian file&quot;}' my_file.nbt --plain --little```## ContributingContributions are welcome. This project uses [`poetry`](https://poetry.eustace.io/) so you'll need to install it first if you want to be able to work with the project locally.```sh$ curl -sSL https://raw.githubusercontent.com/sdispater/poetry/main/get-poetry.py | python```You should now be able to install the required dependencies.```sh$ poetry install```You can run the tests with `poetry run pytest`.```sh$ poetry run pytest```---License - [MIT](https://github.com/vberlier/nbtlib/blob/main/LICENSE)</longdescription>
</pkgmetadata>