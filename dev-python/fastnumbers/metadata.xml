<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>fastnumbers===========.. image:: https://img.shields.io/pypi/v/fastnumbers.svg    :target: https://pypi.org/project/fastnumbers/.. image:: https://img.shields.io/pypi/pyversions/fastnumbers.svg    :target: https://pypi.org/project/fastnumbers/.. image:: https://img.shields.io/pypi/l/fastnumbers.svg    :target: https://github.com/SethMMorton/fastnumbers/blob/main/LICENSE.. image:: https://github.com/SethMMorton/fastnumbers/workflows/Tests/badge.svg    :target: https://github.com/SethMMorton/fastnumbers/actions.. image:: https://codecov.io/gh/SethMMorton/fastnumbers/branch/main/graph/badge.svg    :target: https://codecov.io/gh/SethMMorton/fastnumbersSuper-fast and clean conversions to numbers.    - Source Code: https://github.com/SethMMorton/fastnumbers    - Downloads: https://pypi.org/project/fastnumbers/    - Documentation: https://fastnumbers.readthedocs.io/    - `Quick Start`_    - `Timing`_    - `High-level Algorithm`_    - `How To Run Tests`_    - `History`_``fastnumbers`` is a module with the following three objectives (in orderof decreasing importance as to why the module was created):    #. Provide a set of convenience functions that wrap calls to       ``int`` and ``float`` and provides easy, concise, powerful, fast       and flexible error handling.    #. Provide a set of functions that can be used to rapidly identify if       an input *could* be converted to *int* or *float*.    #. Provide drop-in replacements for the Python built-in ``int`` and       ``float`` that are on par or faster with the Python equivalents       (see the `Timing`_ section for details). These functions       should behave *identically* to the Python built-ins except for a few       specific corner-cases as mentioned in the       `API documentation for those functions &lt;https://fastnumbers.readthedocs.io/en/stable/api.html#the-built-in-replacement-functions&gt;`_.       - **PLEASE** read the quick start for these functions to fully         understand the caveats before using them.**What kind of speedups can you expect?** Here are some highlights, but pleasesee the `Timing`_ section for the raw data if you want details.    - Up to 2x faster conversion of strings to integers than the built-in      ``int()`` function    - Up to 5x faster conversion of strings to floats than the built-in      ``float()`` function (possibly greater for very long strings)    - Up to 10x faster handling of errors during conversion than using      user-side error handling    - On top of the above, operations to convert a list of strings      (with the ``map`` option or ``try_array`` function) is 2x faster      than the equivalent list comprehension.**NOTICE**: As of ``fastnumbers`` version 4.0.0, only Python &gt;= 3.7 issupported.**NOTICE**: As of ``fastnumbers`` version 4.0.0, the functions ``fast_real``,``fast_float``, ``fast_int``, ``fast_forceint``, ``isreal``, ``isfloat``,``isint``, and ``isintlike`` have been deprecated and are replaced with``try_real``, ``try_float``, ``try_int``, ``try_forceint``, ``check_real``,``check_float``, ``check_int``, and ``check_intlike``, respectively. Thesenew functions have more flexible APIs and have names that better reflectthe intent of the functions. The old functions can still be used (they will*never* be removed from ``fastnumbers``), but the new ones should bepreferred for new development.**NOTICE**: As of ``fastnumbers`` version 4.0.0, ``query_type`` now sets``allow_underscores`` to ``False`` by default instead of ``True``.Quick Start------------ `Error-handling Functions`_- `Checking Functions`_- `Drop-in Replacement Functions`_There are three broad categories of functions exposed by ``fastnumbers``.The below quick start will demonstrate each of these categories. Thequick start is &quot;by example&quot;, and will show a sample interactive sessionusing the ``fastnumbers`` API.Error-Handling Functions++++++++++++++++++++++++- `Error-handling function API &lt;https://fastnumbers.readthedocs.io/en/stable/api.html#the-error-handling-functions&gt;`_- `Fast operations on lists and other iterables`_- `About the on_fail option`_``try_float`` will be used to demonstrate the functionality of the``try_*`` functions... code-block:: python    &gt;&gt;&gt; from fastnumbers import RAISE, try_float    &gt;&gt;&gt; # Convert string to a float    &gt;&gt;&gt; try_float('56.07')    56.07    &gt;&gt;&gt; # Integers are converted to floats    &gt;&gt;&gt; try_float(54)    54.0    &gt;&gt;&gt;    &gt;&gt;&gt; # Unconvertable string returned as-is by default    &gt;&gt;&gt; try_float('bad input')    'bad input'    &gt;&gt;&gt; # Unconvertable strings can trigger a default value    &gt;&gt;&gt; try_float('bad input', on_fail=0)    0    &gt;&gt;&gt;    &gt;&gt;&gt; # One can ask inf or nan to be substituted with another value    &gt;&gt;&gt; try_float('nan')    nan    &gt;&gt;&gt; try_float('nan', nan=0.0)    0.0    &gt;&gt;&gt; try_float(float('nan'), nan=0.0)    0.0    &gt;&gt;&gt; try_float('56.07', nan=0.0)    56.07    &gt;&gt;&gt;    &gt;&gt;&gt; # The default built-in float behavior can be triggered with    &gt;&gt;&gt; # RAISE given to &quot;on_fail&quot;.    &gt;&gt;&gt; try_float('bad input', on_fail=RAISE) #doctest: +IGNORE_EXCEPTION_DETAIL    Traceback (most recent call last):      ...    ValueError: invalid literal for float(): bad input    &gt;&gt;&gt;    &gt;&gt;&gt; # A function can be used to return an alternate value for invalid input    &gt;&gt;&gt; try_float('bad input', on_fail=len)    9    &gt;&gt;&gt; try_float(54, on_fail=len)    54.0    &gt;&gt;&gt;    &gt;&gt;&gt; # Single unicode characters can be converted.    &gt;&gt;&gt; try_float('\u2164')  # Roman numeral 5 (V)    5.0    &gt;&gt;&gt; try_float('\u2466')  # 7 enclosed in a circle    7.0``try_int`` behaves the same as ``try_float``, but for integers... code-block:: python    &gt;&gt;&gt; from fastnumbers import try_int    &gt;&gt;&gt; try_int('1234')    1234    &gt;&gt;&gt; try_int('\u2466')    7``try_real`` is like ``try_float`` or ``try_int`` dependingon if there is any fractional component of thi return value... code-block:: python    &gt;&gt;&gt; from fastnumbers import try_real    &gt;&gt;&gt; try_real('56')    56    &gt;&gt;&gt; try_real('56.0')    56    &gt;&gt;&gt; try_real('56.0', coerce=False)    56.0    &gt;&gt;&gt; try_real('56.07')    56.07    &gt;&gt;&gt; try_real(56.07)    56.07    &gt;&gt;&gt; try_real(56.0)    56    &gt;&gt;&gt; try_real(56.0, coerce=False)    56.0``try_forceint`` always returns an integer... code-block:: python    &gt;&gt;&gt; from fastnumbers import try_forceint    &gt;&gt;&gt; try_forceint('56')    56    &gt;&gt;&gt; try_forceint('56.0')    56    &gt;&gt;&gt; try_forceint('56.07')    56    &gt;&gt;&gt; try_forceint(56.07)    56Fast operations on lists and other iterables^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Each of the ``try_*`` functions have a ``map`` option causes the functionto accept an iterable of items to convert and returns a list. Using``try_float`` as an example, the following are all functionally equivalent... code-block:: python    &gt;&gt;&gt; from fastnumbers import try_float    &gt;&gt;&gt; iterable = [&quot;5&quot;, &quot;4.5&quot;, &quot;34567.6&quot;, &quot;32&quot;]    &gt;&gt;&gt; try_float(iterable, map=list) == list(map(try_float, iterable))    True    &gt;&gt;&gt; try_float(iterable, map=list) == [try_float(x) for x in iterable]    True    &gt;&gt;&gt; try_float(iterable, map=list) == list(try_float(iterable, map=True))    TrueThe difference is that the ``map`` option is 2x the speed of the listcomprehension method, and 1.5x the speed of the ``map`` method. The reasonis that it avoids Python function call overhead on each iteration. Note that*True* causes the function to return an iterator, and *list* causes it toreturn a ``list``. In practice the performance of these are similar(see `Timing`_ for raw data).If you need to store your output in a ``numpy`` array, you can use``try_array`` to do this conversion directly. This function has someadditional handling for overflow that is not present in the other``fastnumbers`` functions that may come in handy when dealing with``numpy`` arrays... code-block:: python    &gt;&gt;&gt; from fastnumbers import try_array    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; iterable = [&quot;5&quot;, &quot;4.5&quot;, &quot;34567.6&quot;, &quot;32&quot;]    &gt;&gt;&gt; np.array_equal(np.array(try_float(iterable, map=list), dtype=np.float64), try_array(iterable))    TrueYou will see about a 2x speedup of doing this in one step over convertingto a list then converting that list to an array.About the ``on_fail`` option^^^^^^^^^^^^^^^^^^^^^^^^^^^^The ``on_fail`` option is a way for you to do *anything* in the event thatthe given input cannot be converted to a number. It can* return given object as-is if set to ``fastnumbers.INPUT`` (this is the default)* raise a ``ValueError`` if set to ``fastnumbers.RAISE``* return a default value if given any non-callable object* call a function with the given object if given a single-argument callableBelow are a couple of ideas to get you thinking.**NOTE**:: There is also an ``on_type_error`` option that behaves the same as``on_fail`` except that a) it is triggered when the given object is of aninvalid type and b) the default value is ``fastnumbers.RAISE``, not``fastnumbers.INPUT``... code-block:: python    &gt;&gt;&gt; from fastnumbers import INPUT, RAISE, try_float    &gt;&gt;&gt; # You want to convert strings that can be converted to numbers, but    &gt;&gt;&gt; # leave the rest as strings. Use fastnumbers.INPUT (the default)    &gt;&gt;&gt; try_float('45.6')    45.6    &gt;&gt;&gt; try_float('invalid input')    'invalid input'    &gt;&gt;&gt; try_float('invalid input', on_fail=INPUT)    'invalid input'    &gt;&gt;&gt;    &gt;&gt;&gt;    &gt;&gt;&gt;    &gt;&gt;&gt; # You want to convert any invalid string to NaN    &gt;&gt;&gt; try_float('45.6', on_fail=float('nan'))    45.6    &gt;&gt;&gt; try_float('invalid input', on_fail=float('nan'))    nan    &gt;&gt;&gt;    &gt;&gt;&gt;    &gt;&gt;&gt;    &gt;&gt;&gt; # Simple callable case, send the input through some function to generate a number.    &gt;&gt;&gt; try_float('invalid input', on_fail=lambda x: float(x.count('i')))  # count the 'i's    3.0    &gt;&gt;&gt;    &gt;&gt;&gt;    &gt;&gt;&gt;    &gt;&gt;&gt; # Suppose we know that our input could either be a number, or if not    &gt;&gt;&gt; # then we know we just have to strip off parens to get to the number    &gt;&gt;&gt; # e.g. the input could be '45' or '(45)'. Also, suppose that if it    &gt;&gt;&gt; # still cannot be converted to a number we want to raise an exception.    &gt;&gt;&gt; def strip_parens_and_try_again(x):    ...     return try_float(x.strip('()'), on_fail=RAISE)    ...    &gt;&gt;&gt; try_float('45', on_fail=strip_parens_and_try_again)    45.0    &gt;&gt;&gt; try_float('(45)', on_fail=strip_parens_and_try_again)    45.0    &gt;&gt;&gt; try_float('invalid input', on_fail=strip_parens_and_try_again) #doctest: +IGNORE_EXCEPTION_DETAIL    Traceback (most recent call last):      ...    ValueError: invalid literal for float(): invalid input    &gt;&gt;&gt;    &gt;&gt;&gt;    &gt;&gt;&gt;    &gt;&gt;&gt; # Suppose that whenever an invalid input is given, it needs to be    &gt;&gt;&gt; # logged and then a default value is returned.    &gt;&gt;&gt; def log_and_default(x, log_method=print, default=0.0):    ...     log_method(&quot;The input {!r} is not valid!&quot;.format(x))    ...     return default    ...    &gt;&gt;&gt; try_float('45', on_fail=log_and_default)    45.0    &gt;&gt;&gt; try_float('invalid input', on_fail=log_and_default)    The input 'invalid input' is not valid!    0.0    &gt;&gt;&gt; try_float('invalid input', on_fail=lambda x: log_and_default(x, default=float('nan')))    The input 'invalid input' is not valid!    nanChecking Functions++++++++++++++++++- `Checking function API &lt;https://fastnumbers.readthedocs.io/en/stable/api.html#the-checking-functions&gt;`_``check_float`` will be used to demonstrate the functionality of the``check_*`` functions. There is also the ``query_type`` function... code-block:: python    &gt;&gt;&gt; from fastnumbers import check_float    &gt;&gt;&gt; from fastnumbers import ALLOWED, DISALLOWED, NUMBER_ONLY, STRING_ONLY    &gt;&gt;&gt; # Check that a string can be converted to a float    &gt;&gt;&gt; check_float('56')    True    &gt;&gt;&gt; check_float('56', strict=True)    False    &gt;&gt;&gt; check_float('56.07')    True    &gt;&gt;&gt; check_float('56.07 lb')    False    &gt;&gt;&gt;    &gt;&gt;&gt; # Check if a given number is a float    &gt;&gt;&gt; check_float(56.07)    True    &gt;&gt;&gt; check_float(56)    False    &gt;&gt;&gt;    &gt;&gt;&gt; # Specify if only strings or only numbers are allowed    &gt;&gt;&gt; check_float(56.07, consider=STRING_ONLY)    False    &gt;&gt;&gt; check_float('56.07', consider=NUMBER_ONLY)    False    &gt;&gt;&gt;    &gt;&gt;&gt; # Customize handling for nan or inf (see API for more details)    &gt;&gt;&gt; check_float('nan')    False    &gt;&gt;&gt; check_float('nan', nan=ALLOWED)    True    &gt;&gt;&gt; check_float(float('nan'))    True    &gt;&gt;&gt; check_float(float('nan'), nan=DISALLOWED)    False``check_int`` works the same as ``check_float``, but for integers... code-block:: python    &gt;&gt;&gt; from fastnumbers import check_int    &gt;&gt;&gt; check_int('56')    True    &gt;&gt;&gt; check_int(56)    True    &gt;&gt;&gt; check_int('56.0')    False    &gt;&gt;&gt; check_int(56.0)    False``check_real`` is very permissive - any float or integer is accepted... code-block:: python    &gt;&gt;&gt; from fastnumbers import check_real    &gt;&gt;&gt; check_real('56.0')    True    &gt;&gt;&gt; check_real('56')    True    &gt;&gt;&gt; check_real(56.0)    True    &gt;&gt;&gt; check_real(56)    True``check_intlike`` checks if a number is &quot;int-like&quot;, if it has nofractional component... code-block:: python    &gt;&gt;&gt; from fastnumbers import check_intlike    &gt;&gt;&gt; check_intlike('56.0')    True    &gt;&gt;&gt; check_intlike('56.7')    False    &gt;&gt;&gt; check_intlike(56.0)    True    &gt;&gt;&gt; check_intlike(56.7)    FalseThe ``query_type`` function can be used if you need to determine ifa value is one of many types, rather than whether or not it is one specifictype... code-block:: python    &gt;&gt;&gt; from fastnumbers import query_type    &gt;&gt;&gt; query_type('56.0')    &lt;class 'float'&gt;    &gt;&gt;&gt; query_type('56')    &lt;class 'int'&gt;    &gt;&gt;&gt; query_type(56.0)    &lt;class 'float'&gt;    &gt;&gt;&gt; query_type(56)    &lt;class 'int'&gt;    &gt;&gt;&gt; query_type(56.0, coerce=True)    &lt;class 'int'&gt;    &gt;&gt;&gt; query_type('56.0', allowed_types=(float, int))    &lt;class 'float'&gt;    &gt;&gt;&gt; query_type('hey')    &lt;class 'str'&gt;    &gt;&gt;&gt; query_type('hey', allowed_types=(float, int))  # returns NoneDrop-in Replacement Functions+++++++++++++++++++++++++++++- `Drop-in replacement function API &lt;https://fastnumbers.readthedocs.io/en/stable/api.html#the-built-in-replacement-functions&gt;`_**PLEASE** do not take it for granted that these functions will provide youwith a speedup - they may not. Every platform, compiler, and data-set isdifferent, and you should perform a timing test on your system with your datato evaluate if you will see a benefit. As you can see from the data linked inthe `Timing`_ section, the amount of speedup you will get is particularlydata-dependent. *In general* you will see a performance boost for floats (andthis boost increases as the size of the float increases), but for integers itis largely dependent on the length of the integer. You will likely *not* seea performance boost if the input are already numbers instead of strings.**NOTE**: in the below examples, we use ``from fastnumbers import int`` insteadof ``import fastnumbers``. This is because calling ``fastnumbers.int()`` is abit slower than just ``int()`` because Python has to first find ``fastnumbers``in your namespace, then find ``int`` in the ``fastnumbers`` namespace, insteadof just finding ``int`` in your namespace - this will slow down the functioncall and defeat the purpose of using ``fastnumbers``. If you do not want toactually shadow the built-in ``int`` function, you can do``from fastnumbers import int as fn_int`` or something like that... code-block:: python    &gt;&gt;&gt; # Use is identical to the built-in functions    &gt;&gt;&gt; from fastnumbers import float, int    &gt;&gt;&gt; float('10')    10.0    &gt;&gt;&gt; int('10')    10    &gt;&gt;&gt; float('bad input') #doctest: +IGNORE_EXCEPTION_DETAIL    Traceback (most recent call last):      ...    ValueError: invalid literal for float(): bad input``real`` is provided to give a float or int dependingon the fractional component of the input... code-block:: python    &gt;&gt;&gt; from fastnumbers import real    &gt;&gt;&gt; real('56.0')    56    &gt;&gt;&gt; real('56.7')    56.7    &gt;&gt;&gt; real('56.0', coerce=False)    56.0Timing------Just how much faster is ``fastnumbers`` than a pure python implementation?Please look https://github.com/SethMMorton/fastnumbers/tree/main/profiling.High-Level Algorithm--------------------For integers, CPython goes to great lengths to ensure that your string inputis converted to a number *correctly* and *losslessly* (you can prove this toyourself by examining the source code for`integer conversions &lt;https://github.com/python/cpython/blob/e349bf23584eef20e0d1e1b2989d9b1430f15507/Objects/longobject.c#L2213&gt;`_).This extra effort is only needed for integers that cannot fit into a 64-bitinteger data type - for those that can, a naive algorithm of &lt; 10 linesof C code is sufficient and significantly faster. ``fastnumbers`` uses aheuristic to determine if the input can be safely converted with the muchfaster naive algorithm, and if so it does so, falling back onthe CPython implementation for longer input strings.Most real-world numbers pass the heuristic and so you should generally seeimproved performance with ``fastnumbers`` for integers.For floats, ``fastnumbers`` utilizes the ultra-fast`fast_float::from_chars &lt;https://github.com/fastfloat/fast_float&gt;`_ functionto convert strings representing floats into a C ``double`` both quickly *andsafely* - the conversion provides the same accuracy as the CPython`float conversion function &lt;https://github.com/python/cpython/blob/e349bf23584eef20e0d1e1b2989d9b1430f15507/Python/dtoa.c#L1434&gt;`_but instead of scaling linearly with length of the input string it seemsto have roughly constant performance. By completely bypassing the CPythonconverter we get significant performance gains with no penalty, so youshould always see improved performance with ``fastnumbers`` for floats.Installation------------Use ``pip``!.. code-block::    $ pip install fastnumbersHow to Run Tests----------------Please note that ``fastnumbers`` is NOT set-up to support``python setup.py test``.The recommended way to run tests is with`tox &lt;https://tox.readthedocs.io/en/latest/&gt;`_.Suppose you want to run tests for Python 3.8 - you can run tests by simplyexecuting the following:.. code-block:: sh    $ tox run -e py38``tox`` will create virtual a virtual environment for your tests and installall the needed testing requirements for you.If you want to run testing on all supported Python versions you can simply execute.. code-block:: sh    $ tox runYou can change the how much &quot;random&quot; input your tests will try with.. code-block:: sh    # Run fewer tests with &quot;random&quot; input - much faster    $ tox run -- --hypothesis-profile fast    # Run more tests with &quot;random&quot; input - takes much longer but is more thorough    $ tox run -- --hypothesis-profile thoroughIf you want to run the performce analysis yourself, you can execute.. code-block:: sh    # This assumes Python 3.9 - adjust for the version you want to profile    $ tox run -e py39-profIf you do not wish to use ``tox``, you can install the testing dependencies with the``dev-requirements.txt`` file and then run the tests manually using`pytest &lt;https://docs.pytest.org/en/latest/&gt;`_... code-block:: sh    $ pip install -r dev/requirements.txt    $ pytestAuthor------Seth M. MortonHistory-------Please visit the changelog `on GitHub &lt;https://github.com/SethMMorton/fastnumbers/blob/main/CHANGELOG.md&gt;`_or `in the documentation &lt;https://fastnumbers.readthedocs.io/en/stable/changelog.html&gt;`_.</longdescription>
</pkgmetadata>