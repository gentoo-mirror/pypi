<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>pysasl======Pure Python SASL client and server library. The design of the library isintended to be agnostic of the protocol or network library.The library currently offers `PLAIN` and `LOGIN` mechanisms by default. The`CRAM-MD5`, `EXTERNAL`, and `XOAUTH2` mechanisms are also available for specialcircumstances.There are currently no plans to implement[security layer](https://datatracker.ietf.org/doc/html/rfc4422#section-3.7)negotiation support.[![build](https://github.com/icgood/pysasl/actions/workflows/python-package.yml/badge.svg)](https://github.com/icgood/pysasl/actions/workflows/python-package.yml)[![Coverage Status](https://coveralls.io/repos/icgood/pysasl/badge.svg?branch=main)](https://coveralls.io/r/icgood/pysasl?branch=main)[![PyPI](https://img.shields.io/pypi/v/pysasl.svg)](https://pypi.python.org/pypi/pysasl)[![PyPI](https://img.shields.io/pypi/pyversions/pysasl.svg)](https://pypi.python.org/pypi/pysasl)[![PyPI](https://img.shields.io/pypi/l/pysasl.svg)](https://pypi.python.org/pypi/pysasl)#### [API Documentation](https://icgood.github.io/pysasl/)Installation============Available in [PyPi](https://pypi.python.org/):```pip install pysasl```### Running TestsInstall into a virtual environment:```python3 -m venv .venvsource .venv/bin/activatepip install -r requirements-dev.txt```Run the tests and report coverage metrics:```invoke```Usage=====## Server-sideServer-side SASL has three basic requirements:* Must advertise supported mechanisms,* Must issue authentication challenges to the client and read responses,* Must determine if credentials are considered valid.#### Advertising MechanismsImplementations may decide on any sub-set of mechanisms to advertise. Make thischoice when instantiating the [`SASLAuth`][1] object:```pythonfrom pysasl import SASLAuthauth1 = SASLAuth.defaults()  # equivalent to...auth2 = SASLAuth.named([b'PLAIN', b'LOGIN'])```To get the names of all available mechanisms:```pythonmechanisms = [mech.name for mech in auth1.server_mechanisms]mech = auth1.get_server(b'PLAIN')```#### Issuing ChallengesOnce a mechanism has been chosen by the client, enter a loop of issuingchallenges to the client:```pythondef server_side_authentication(sock, mech):    challenges = []    while True:        try:            creds, _ = mech.server_attempt(challenges)            return creds        except ServerChallenge as chal:            sock.send(chal.data + b'\r\n')            resp = sock.recv(1024).rstrip(b'\r\n')            challenges.append(ChallengeResponse(chal.data, resp))```It's worth noting that implementations are not quite that simple. Most willexpect all transmissions to base64-encoded, often with a prefix before theserver challenges such as `334` or `+`. See the appropriate RFC for yourprotocol, such as [RFC 4954 for SMTP][3] or [RFC 3501 for IMAP][4].#### Checking CredentialsOnce the challenge-response loop has been completed and we are left with thea [`ServerCredentials`][2] object, we can access information from theattempt:```pythonfrom pysasl.creds.server import ServerCredentialsfrom pysasl.identity import ClearIdentity, HashedIdentityresult: ServerCredentials = ...print('Authenticating as:', result.authcid)print('Authorizing as:', result.authzid)# To compare to a known cleartext password...identity = ClearIdentity('myuser', 's3kr3t')assert result.verify(identity)# Or to compare hashes...from pysasl.hashing import BuiltinHashidentity = HashedIdentity('myuser, '$pbkdf2-sha256$500000$...', hash=BuiltinHash())assert result.verify(identity)# Or use passlib hashing...from passlib.apps import custom_app_contextidentity = HashedIdentity('myuser', '$6$rounds=656000$...', hash=custom_app_context)assert result.verify(identity)```## Client-sideThe goal of client-side authentication is to respond to server challenges untilthe authentication attempt either succeeds or fails.#### Choosing a MechanismThe first step is to pick a SASL mechanism. The protocol should allow the serverto advertise to the client which mechanisms are available to it:```pythonfrom pysasl import SASLAuthauth = SASLAuth.named(advertised_mechanism_names)mech = auth.client_mechanisms[0]```Any mechanism name that is not recognized will be ignored.#### Issuing ResponsesOnce a mechanism is chosen, we enter of a loop of responding to serverchallenges:```pythonfrom pysasl.creds.client import ClientCredentialsdef client_side_authentication(sock, mech, username, password):    creds = ClientCredentials(username, password)    challenges = []    while True:        resp = mech.client_attempt(creds, challenges)        sock.send(resp + b'\r\n')        data = sock.recv(1024).rstrip(b'\r\n')        if data == 'SUCCESS':            return True        elif data == 'FAILURE':            return False        challenges.append(ServerChallenge(data))```As you might expect, a real protocol probably won't return `SUCCESS` or`FAILURE`, that will depend entirely on the details of the protocol.## Supporting Initial ResponsesSome protocols (e.g. SMTP) support the client ability to send an initialresponse before the first server challenge, for mechanisms that support it.A perfectly valid authentication can then have no challenges at all:```AUTH PLAIN AHVzZXJuYW1lAHBhc3N3b3Jk235 2.7.0 Authentication successful```In this case, both client-side and server-side authentication should behandled a bit differently. For example for server-side:```pythonchallenges = []if initial_response:    challenges.append(ChallengeResponse(b'', initial_response))```And for client-side, just call `resp = mech.client_attempt(creds, [])`to get the initial response before starting the transmission. Allmechanisms should either return an initial response or an empty stringwhen given an empty list for the second argument.[1]: https://icgood.github.io/pysasl/pysasl.html#pysasl.SASLAuth[2]: https://icgood.github.io/pysasl/pysasl.creds.html#pysasl.creds.server.ServerCredentials[3]: https://tools.ietf.org/html/rfc4954[4]: https://tools.ietf.org/html/rfc3501#section-6.2.2</longdescription>
</pkgmetadata>