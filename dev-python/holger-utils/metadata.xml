<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Holger Utils## Sentry&gt; settings.py```pythonfrom holger import sentry...SENTRY_KEY = '&lt;your sentry key&gt;'SENTRY_ORGANIZATION = '&lt;your sentry organization name&gt;'SENTRY_PROJECT = '&lt;your sentry project name&gt;'SENTRY_ALLOWED_ALL = 'if true all status captured' # default FalseSENTRY_ALLOWED_STATUS = 'list of status that should capture' # default []sentry.init()```or```pythonfrom holger import sentry...SENTRY_URL = '&lt;your sentry url&gt;'SENTRY_ALLOWED_ALL = 'if true all status captured' # default FalseSENTRY_ALLOWED_STATUS = 'list of status that should capture' # default []sentry.init()``` ## Elastic search&gt; settings.py```pythonELASTIC_PROTOCOL = '&lt;http or https&gt;' # default 'http'ELASTIC_HOST = '&lt;host that elastic run&gt;' # default 'localhost'ELASTIC_PORT = '&lt;listen port&gt;' # default 9200ELASTIC_USE_SSL = '' # default FalseTIME_ZONE = '&lt;elastic timezone&gt;' # default 'UTC'ELASTIC_ALLOWED_STATUS = ['&lt;allowed status&gt;'] # default []ELASTIC_USER = '&lt;elastic username&gt;' # default ''ELASTIC_PASSWORD = '&lt;elastic secret&gt;' # default ''```## Firebase&gt; settings.py```pythonFIREBASE_APP_OPTIONS = '&lt;app dict options&gt;' # default {}FIREBASE_APP_NAME = 'your app name' # default 'FIRESTORE_DEFAULT'```## Log&gt; for use log, you must config elastic search and sentry before## JWT Authenticationin your root urls.py file (or any other url config), include routes for Holgerâ€™s TokenObtainPairView and TokenRefreshView views:```pythonfrom django.urls import pathfrom holger.rest.authorization import (    HolgerTokenObtainPairView,    HolgerRefreshView)urlpatterns = [    ...,    path('apiv1/accounts/token/', HolgerTokenObtainPairView.as_view(), name='token_obtain_pair'),    path('apiv1/accounts/refresh/', HolgerRefreshView.as_view(), name='token_refresh'),    ...]```### SettingsSome of Holgerâ€™s authentication behavior can be customized through settings variables in settings.py```pythonfrom datetime import timedeltaSIMPLE_JWT = {    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),    'ROTATE_REFRESH_TOKENS': False,    'BLACKLIST_AFTER_ROTATION': True,    'ALGORITHM': 'HS256',    'SIGNING_KEY': SECRET_KEY,    'VERIFYING_KEY': None,    'AUDIENCE': None,    'ISSUER': None,    'AUTH_HEADER_TYPES': ('Bearer',),    'USER_ID_FIELD': 'id',    'USER_ID_CLAIM': 'user_id',    'AUTH_TOKEN_CLASSES': ('Holger.rest.authorization.AccessToken',),    'TOKEN_TYPE_CLAIM': 'token_type',    'JTI_CLAIM': 'jti',    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',    'SLIDING_TOKEN_LIFETIME': timedelta(minutes=5),    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),}```## Database replica routerWith `database.router.ReplicaRouter` all read queries will go to a replicadatabase;  all inserts, updates, and deletes will do to the ``default``database.First, define ``REPLICA_DATABASES`` in your settings.  It should be a list ofdatabase aliases that can be found in ``DATABASES``:```pythonDATABASES = {    'default': {...},    'replica-1': {...},    'replica-2': {...},}REPLICA_DATABASES = ['replica-1', 'replica-2']```Then put ``database.router.ReplicaRouter`` into DATABASE_ROUTERS:```pythonDATABASE_ROUTERS = ('database.router.ReplicaRouter',)```    The replica databases will be chosen in round-robin fashion.If you want to get a connection to a replica in your app, use `database.router.ReplicaRouter````pythonfrom django.db import connectionsfrom holger.database import routerconnection = connections[router.get_replica()]```### Database PinningReplicaRouterIn some applications, the lag between the primary database receiving awrite and its replication to the replicas is enough to cause inconsistencyfor the end user. For example, imagine a scenario with 1 second of replication lag.If a user makes a forum post (to the primary) and then is redirected to a fully-rendered view of it (from a replica) 500ms later, the view will fail. If this is a problem in your application, consider using `multidb.PinningReplicaRouter`. This router works in combination with `multidb.middleware.PinningRouterMiddleware` to assure that, after writing to the `default` database, future reads from the same user agent are directed to the `default` database for a configurable length of time.`PinningRouterMiddleware` identifies database writes primarily by request type, assuming that requests with HTTP methods that are not `GET`, `TRACE`, `HEAD`, or `OPTIONS` are writes. You can indicate that any view writes to the database by using the `holger.database.router.db_write` decorator. This will cause the same result as if the request were, e.g., a `POST`.To use `PinningReplicaRouter`, put it into `DATABASE_ROUTERS` in your settings:```pythonDATABASE_ROUTERS = ('database.router.PinningReplicaRouter',)```Then, install the middleware. It must be listed before any other middleware which performs database writes:```pythonMIDDLEWARE_CLASSES = (    'multidb.middleware.PinningRouterMiddleware',    ...more middleware here...)````PinningRouterMiddleware` attaches a cookie to any user agent who has just written. The cookie should be set to expire at a time longer than your replication lag. By default, its value is a conservative 15 seconds, but it can be adjusted like so:```pythonHOLGER_PINNING_SECONDS = 5```If you need to change the name of the cookie, use the `HOLGER_PINNING_COOKIE` setting:```pythonHOLGER_PINNING_COOKIE = 'holger_pin_writes'```</longdescription>
</pkgmetadata>