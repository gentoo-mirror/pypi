<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Watiba#### Version:  **0.6.59**#### Date: 2021/12/04Watiba, pronounced wah-TEE-bah, is a lightweight Python pre-compiler for embedding Linux shell commands within Python applications.  It is similar to other languages' syntactical enhancements whereXML or HTML is integrated into a language such as JavaScript.  That is the concept applied here but integratingBASH shell commands with Python.As you browse this document, you'll find Watiba is rich with features for shell command integration with Python.Features:- Shell command integration with Python code- In-line access to shell command results- Current directory context maintained across commands throughout your Python code- Async/promise support for integrated shell commands- Remote shell command execution- Remote shell command chaining and piping## Table of Contents1. [Usage](#usage)2. [Directory Context](#directory-context)3. [Commands as Variables](#commands-as-variables)4. [Command Results](#command-results)5. [Asynchronous Spawning and Promises](#async-spawing-and-promises)    1. [Useful Properties in Promise](#useful-properties-in-promise)    2. [Spawn Controller](#spawn-controller)    3. [Join, Wait or Watch](#join-wait-watch)    4. [The Promise Tree](#promise-tree)    5. [Threads](#threads)6. [Remote Execution](#remote-execution)    1. [Change SSH port for remote execution](#change-ssh-port)7. [Command Hooks](#command-hooks)8. [Command Chaining](#command-chaining)9. [Command Chain Piping (Experimental)](#piping-output)10. [Installation](#installation)11. [Pre-compiling](#pre-compiling)12. [Code Examples](#code-examples)&lt;div id=&quot;usage&quot;/&gt;## UsageWatiba files, suffixed with &quot;.wt&quot;, are Python programs containing embedded shell commands. Shell commands are expressed within backtick characters emulating BASH's original capture syntax.They can be placed in any Python statement or expression.  Watiba keeps track of the current working directory after the execution of any shell command so that all subsequent shell commands keep context.  For example:Basic example of embedded commands:```#!/usr/bin/python3# Typical Python programif __name__ == &quot;__main__&quot;:    # Change directory context    `cd /tmp`        # Directory context maintained    for file in `ls -lrt`.stdout:  # In-line access to command results        print(f&quot;File in /tmp: {file}&quot;)```This loop will display the file list from /tmp. The `ls -lrt` is run in the context of previous `cd /tmp`.  &lt;div id=&quot;commands-as-variables&quot;/&gt;#### Commands Expressed as VariablesCommands within backticks can _be_ a variable, but cannot contain snippets of Python code or Python variables. The statement within the backticks _must_ be either a pure shell command or a Python variable containing a pureshell command.  To execute commands in a Python variable, prefix the variable name between backticks with a dollar sign._A command variable is denoted by prepending a dollar sign on the variable name within backticks_:```# Set the Python variable to the commandcmdA = 'echo &quot;This is a line of output&quot; &gt; /tmp/blah.txt'cmdB = 'cat /tmp/blah.txt'# Execute first command`$cmdA`  # Execute the command within Python variable cmdA# Execute second commandfor line in `$cmdB`.stdout:    print(line)```_This example demonstrates keeping dir context and executing a command by variable_:```#!/usr/bin/python3if __name__ == &quot;__main__&quot;:    # Change CWD to /tmp    `cd /tmp`        # Set a command string    my_cmd = &quot;tar -zxvf tmp.tar.gz&quot;        # Execute that command and save the command results in variable &quot;w&quot;    w = `$my_cmd`    if w.exit_code == 0:        for l in w.stderr:            print(l)```_These constructs are **not** supported_: ```file_name = &quot;blah.txt&quot;# Python variable within backticks`touch file_name`  # NOT SUPPORTED!# Attempting to access Python variable with dollar sign`touch $file_name` # NOT SUPPORTED!# Python within backticks is NOT SUPPORTED!`if x not in l: ls -lrt x````&lt;div id=&quot;directory-context&quot;/&gt;## Directory ContextAn important Watiba usage point is directory context is kept for dispersed shell commands.Any command that changes the shell's CWD is discovered and kept by Watiba.  Watiba achieves this by tagging a `&amp;&amp; echo pwd` to the user's command, locating the result in the command's STDOUT, and finally setting the Python environment to that CWD with `os.chdir(dir)`.  This is automatic and opaque to the user.  The user will not see the results of the generated suffix.  If the `echo` suffix presents a problem for the user, it can be eliminated by prefixing the leading backtick with adash.  The dash turns off the context tracking by not suffixing the command and so causes Watiba tolose its context.  However, the context is maintained _within_ the set of commands in the backticks just notwhen it returns.  For example, **out = -\`cd /tmp &amp;&amp; ls -lrt\`** honors the ```cd``` within the scopeof that execution line, but not for any backticked commands that follow later in your code.**_Warning!_** The dash will cause Watiba to lose its directory context should the commandcause a CWD change either explicitly or implicitly._Example_:````cd /tmp`  # Context will be kept# This will print from /home/user, but context is NOT kept  for line in -`cd /home/user &amp;&amp; ls -lrt`.stdout:    print(line) # This will print from /tmp, not /home/userfor line in `ls -lrt`.stdout:    print(line)```&lt;div id=&quot;command-results&quot;/&gt;## Command ResultsThe results of the command issued in backticks are available in the propertiesof the object returned by Watiba.  Following are those properties:&lt;table&gt;    &lt;th&gt;Property&lt;/th&gt;&lt;th&gt;Data Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;stdout&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;List&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;STDOUT lines from the command normalized for display&lt;/td&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;stderr&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;List&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;STDERR lines from the command normalized for display&lt;/td&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;exit_code&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Integer&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Exit code value from command&lt;/td&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;cwd&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;String&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Current working directory &lt;i&gt;after&lt;/i&gt; command was executed&lt;/td&gt;&lt;/table&gt;Technically, the returned object for any shell command is defined in the WTOutput class.&lt;div id=&quot;async-spawing-and-promises&quot;/&gt;## Asynchronous Spawning and PromisesShell commands can be executed asynchronously with a defined resolver callback block.  Each _spawn_ expression createsand runs a new OS thread. The resolver is a callback block that follows the Watiba _spawn_ expression.  The spawn feature is executed when a ```spawn `cmd` args: resolver block``` code block is encountered. The resolver is passed the results in the promise object. (The promise structure contains the properties defined in section [&quot;Results from Spawned Commands&quot;](#spawn-results)  The _spawn_ expression also returns a _promise_ object to the caller of _spawn_.  The promise object is passed to the _resolver block_ in argument _promise_.  The outer code can check its state with a call to _resolved()_ on the *returned* promise object.  Output from the commandis found in _promise.output_.  The examples throughout this README and in the _examples.wt_ file make this clear.&lt;div id=&quot;useful-properties-in-promise&quot;/&gt;##### Useful properties in promise structure A promise is either returned in assignment from outermost spawn, or passed to child spawns in argument &quot;promise&quot;.  &lt;table&gt;      &lt;th&gt;Property&lt;/th&gt;      &lt;th&gt;Data Type&lt;/th&gt;      &lt;th&gt;Description&lt;/th&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;host&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;String&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Host name on which spawned command ran&lt;/td&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;children&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;List&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Children promises for this promise node&lt;/td&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;parent&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Reference&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Parent promise node of child promise. None if root promise.&lt;/td&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;command&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;String&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Shell command issued for this promise&lt;/td&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;resolved()&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Method&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Call to find out if this promise is resolved&lt;/td&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;resolve_parent()&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Method&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Call inside resolver block to resolve parent promise&lt;/td&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;tree_dump()&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Method&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Call to show the promise tree.  Takes subtree argument otherwise it defaults to the root promise&lt;/td&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;join()&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Method&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Call to wait on on promise and all its children&lt;/td&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;wait()&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Method&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Call to wait on just this promise&lt;/td&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;watch()&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Method&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Call to create watcher on this promise&lt;/td&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;start_time&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Time&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Time that spawned command started&lt;/td&gt;      &lt;tr&gt;&lt;/tr&gt;      &lt;td valign=&quot;top&quot;&gt;end_time&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Time&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Time that promise resolved&lt;/td&gt;  &lt;/table&gt;_Example of simple spawn_:```buildoutcfgprom = spawn `tar -zcvf big_file.tar.gz some_dir/*`:    # Resolver block to which &quot;promise&quot; and &quot;args&quot; is passed...    print(f&quot;{promise.command} completed.&quot;)    return True  # Resolve promise# Do other things while tar is running# Finally wait for tar promise to resolveprom.join()```&lt;div id=&quot;spawn-controller&quot;/&gt;#### Spawn ControllerAll spawned threads are managed by Watiba's Spawn Controller.  The controller watches for too many threads andincrementally slows down each thread start when that threshold is exceeded until either all the promises in the treeresolve, or an expiration count is reached, at which time an exception is thrown on the last spawned command.  This exception is raised by the default error method. This method as well as other spawn controlling parameters can be overridden.  The controller's purpose is to not allow run away threads and provide signaling of possiblehung threads._spawn-ctl_ example:```buildoutcfg# Only allow 20 spawns max, # and increase slowdown by 1/2 second each 3rd cycle...python code...spawn-ctl {&quot;max&quot;:20, &quot;sleep-increment&quot;:.500}  ```Spawn control parameters:&lt;table&gt;    &lt;th&gt;Key Name&lt;/th&gt;    &lt;th&gt;Data Type&lt;/th&gt;    &lt;th&gt;Description&lt;/th&gt;    &lt;th&gt;Default&lt;/th&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;max&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Integer&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;The maximum number of spawned commands allowed before the controller enters slowdown mode&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;10&lt;/td&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;sleep-floor&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Integer&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Seconds of &lt;i&gt;starting&lt;/i&gt; sleep value when the controller enters slowdown mode&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;.125 (start at 1/8th second pause)&lt;/td&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;sleep-increment&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Integer&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Seconds the &lt;i&gt;amount&lt;/i&gt; of seconds sleep will increase every 3rd cycle when in slowdown       mode&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;.125 (Increase pause 1/8th second every 3rd cycle)&lt;/td&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;sleep-ceiling&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Integer&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Seconds the &lt;i&gt;highest&lt;/i&gt; length sleep value allowed when in slowdown mode        (As slow as it will get)&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;3 (won't get slower than 3 second pauses)&lt;/td&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;expire&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Integer&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Total number of slowdown cycles allowed before the error method is called&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;No expiration&lt;/td&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;error&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Method&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;    Callback method invoked when slowdown mode expires. Use this to catch hung commands.            This method is passed 2 arguments:    - **promise** - The promise attempting execution at the time of expiration- **count** - The thread count (unresolved promises) at the time of expiration    &lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Generic error handler.  Just throws &lt;i&gt;WTSpawnException&lt;/i&gt; that hold properties &lt;i&gt;promise&lt;/i&gt; and &lt;i&gt;message&lt;/i&gt;&lt;/td&gt;&lt;/td&gt;&lt;/table&gt; &lt;hr&gt;**_spawn-ctl_** only overrides the values it sets and does not affect values not specified.  _spawn-ctl_ statements canset whichever values it wants, can be dispersed throughout your code (i.e. multiple _spawn-ctl_ statements) and only affects subsequent spawn expressions._Notes:_1. Arguments can be passed to the resolver by specifying a trailing variable after the command.  If the argumentsvariable is omitted, an empty dictionary, i.e. {}, is passed to the resolver in _args_.**_Warning!_** Python threading does not deep copy objects passed as arguments to threads.  What you place in ```args```of the spawn expression will only be shallow copied so if there are references to other objects, it's not likely to    survive the copy.2. The resolver must return _True_ to set the promise to resolved, or _False_ to leave it unresolved.3. A resolver can also set the promise to resolved by calling ```promise.set_resolved()```.  This is handy in cases wherea resolver has spawned another command and doesn't want the outer promise resolved until the inner resolvers are done. To resolve an outer, i.e. parent, resolver issue _promise.resolve_parent()_.  Then the parent resolver can return_False_ at the end of its block so it leaves the resolved determination to the inner resolver block.4. Each promise object holds its OS thread object in property _thread_ and its thread id in property _thread_id_. Thiscan be useful for controlling the thread directly.  For example, to signal a kill. 5. _spawn-ctl_ has no affect on _join_, _wait_, or _watch_.  This is because _spawn-ctl_ establishes an upper endthrottle on the overall spawning process.  When the number of spawns hits the max value, throttling (i.e. slowdown    mode) takes affect and will expire if none of the promises resolve.  Conversely, the arguments used by _join_,    _wait_ and _watch_ control the sleep cycle and expiration of just those calls, not the spawned threads as a whole. When   an expiration is set for, say, _join_, then that join will expire at that time.  When an expiration is set in   _spawn-ctl_, then if all the spawned threads as a whole don't resolve in time then an expiration function is called.**_Spawn Syntax:_**```my_promise = spawn `cmd` [args]:    resolver block (promise, args)    args passed in args    return resolved or unresolved (True or False) ```    _Spawn with resolver arguments omitted_:```my_promise = spawn `cmd`:    resolver block (promise, args)    return resolved or unresolved (True or False)```_Simple spawn example_:```buildoutcfgp = spawn `tar -zcvf /tmp/file.tar.gz /home/user/dir`:    # Resolver block to which &quot;promise&quot; and &quot;args&quot; are passed    # Resolver block is called when spawned command has completed    for line in promise.output.stderr:        print(line)        # This marks the promise resolved    return True    # Wait for spawned command to resolve (not merely complete)try:    p.join({&quot;expire&quot;: 3})    print(&quot;tar resolved&quot;)except Exception as ex:    print(ex.args)```_Example of file that overrides spawn controller parameters_:```#!/usr/bin/python3def spawn_expired(promise, count):    print(&quot;I do nothing just to demonstrate the error callback.&quot;)    print(f&quot;This command failed {promise.command} at this threshold {count}&quot;)        raise Exception(&quot;Too many threads.&quot;)    if __name__ == &quot;__main__&quot;:    # Example showing default values    parms = {&quot;max&quot;: 10, # Max number of threads allowed before slowdown mode         &quot;sleep-floor&quot;: .125,  # Starting sleep value         &quot;sleep-ceiling&quot;: 3,  # Maximum sleep value         &quot;sleep-increment&quot;: .125,  # Incremental sleep value         &quot;expire&quot;: -1,  # Default: no expiration         &quot;error&quot;: spawn_expired  # Method called upon slowdown expiration    }         # Set spawn controller parameter values    spawn-ctl parms```&lt;div id=&quot;join-wait-watch&quot;/&gt;#### Join, Wait, or WatchOnce commands are spawned, the caller can wait for _all_ promises, including inner or child promises, to complete, orthe caller can wait for just a specific promise to complete.  To wait for all _child_ promises includingthe promise on which you're calling this method, call _join()_.  It will wait for that promise and all its children. To wait for just one specific promise, call _wait()_ on the promise of interest.  To wait for _all_ promises in the promise tree, call _join()_ on the root promise._join_ and _wait_ can be controlled through parameters.  Each are iterators paused with a sleep method and will throwan expiration exception should you set a limit for iterations.  If an expiration value is not set,no exception will be thrown and the cycle will run only until the promise(s) are resolved.  _join_ and _wait_ are notaffected by _spawn-ctl_._watch_ is called to establish a separate asynchronous thread that will call back a function of your choosing shouldthe command the promise is attached to time out.  This is different than _join_ and _wait_ in that _watch_ is not synchronous and does not pause.  This is used to keep an eye on a spawned command and take action should it hang.  Your watcherfunction is passed the promise on which the watcher was attached, and the arguments, if any, from the spawn expression.If your command does not time out (i.e. hangs and expires), the watcher thread will quietly go away when the promiseis resolved.  _watch_ expiration is expressed in **seconds**, unlike _join_ and _wait_ which are expressed as total_iterations_ paused at the sleep value.  _watch_'s polling cycle pause is .250 seconds, so the expiration value ismultiplied by 4.  The default expiration is 15 seconds.Examples:```# Spawn a thread running this commandp = spawn `ls -lrt`:    ## resolver block ##    return True    # Wait for promises, pause for 1/4 second each iteration, and throw an exception after 4 iterations (1 second)try:    p.join({&quot;sleep&quot;: .250, &quot;expire&quot;: 4})except Exception as ex:    print(ex.args)# Wait for this promise, pause for 1 second each iteration, and throw an exception after 5 iterations (5 seconds)try:    p.wait({&quot;sleep&quot;: 1, &quot;expire&quot;: 5})except Exception as ex:    print(ex.args) # My watcher function (called if spawned command never resolves by its experation period)def watcher(promise, args):    print(f&quot;This promise is likely hung: {promise.command}&quot;)    print(f&quot;and I still have the spawn expression's args: {args}&quot;)p = spawn `echo &quot;hello&quot; &amp;&amp; sleep 5` args:    print(f&quot;Args passed to me: {args}&quot;)    return True# Attach a watcher to this thread.  It will be called upon experation.p.watch(watcher)print(&quot;watch() does not pause like join or wait&quot;)# Attach a watcher that will expire in 5 secondsp.watch(watcher, {&quot;expire&quot;: 5})```**_join_ syntax**```promise.join({optional args})Where args is a Python dictionary with the following options:    &quot;sleep&quot; - seconds of sleep for each iteration (fractions such as .5 are honored)        default: .5 seconds    &quot;expire&quot; - number of sleep iterations until an excpetions is raised        default: no expirationNote: &quot;args&quot; is optional and can be omitted```_Example of joining parent and children promises_:```p = spawn `ls *.txt`:    for f in promise.output.stdout:        cmd = f&quot;tar -zcvf {f}.tar.gz {f}&quot;        spawn `$cmd` {&quot;file&quot;:f}:            print(f&quot;{f} completed&quot;)            promise.resolve_parent()            return True    return False# Wait for all commands to completetry:    p.join({&quot;sleep&quot;:1, &quot;expire&quot;:20})except Exception as ex:    print(ex.args)```**_wait_ syntax**```promise.wait({optional args})Where args is a Python dictionary with the following options:    &quot;sleep&quot; - seconds of sleep for each iteration (fractions such as .5 are honored)        default: .5 seconds    &quot;expire&quot; - number of sleep iterations until an excpetions is raised        default: no expirationNote: &quot;args&quot; is optional and can be omitted```_Example of waiting on just the parent promise_:```p = spawn `ls *.txt`:    for f in promise.output.stdout:        cmd = f&quot;tar -zcvf {f}.tar.gz {}&quot;        spawn `$cmd` {&quot;file&quot;:f}:            print(f&quot;{f} completed&quot;)            promise.resolve_parent() # Wait completes here            return True    return False# Wait for just the parent promise to completetry:    p.wait({&quot;sleep&quot;:1, &quot;expire&quot;:20})except Exception as ex:    print(ex.args)```**_watch_ syntax**```promise.watch(callback, {optional args})Where args is a Python dictionary with the following options:    &quot;sleep&quot; - seconds of sleep for each iteration (fractions such as .5 are honored)        default: .5 seconds    &quot;expire&quot; - number of sleep iterations until an excpetions is raised        default: no expirationNote: &quot;args&quot; is optional and can be omitted```_Example of creating a watcher_:```buildoutcfg# Define watcher method.  Called if command times out (i.e. expires)def time_out(promise, args):    print(f&quot;Command {promise.command} timed out.&quot;)# Spawn a thread running some command that hangsp = spawn `long-running.sh`:    print(&quot;Finally completed.  Watcher method won't be called.&quot;)    return True p.watch(time_out)  # Does not wait.  Calls method &quot;time_out&quot; if this promise expires (i.e. command hangs) # Do other things... ```&lt;div id=&quot;promise-tree&quot;/&gt;#### The Promise TreeEach _spawn_ issued inserts its promise object into the promise tree.  The outermost _spawn_ will generate the rootpromise and each inner _spawn_ will be among its children.  There's no limit to how far it can nest.  _wait_ only appliesto the promise on which it is called and is how it is different than _join_.  _wait_ does not consider any otherpromise state but the one it's called for, whereas _join_ considers the one it's called for **and** anything below itin the tree.The promise tree can be printed with the ```dump_tree()``` method on the promise.  This method is intended fordiagnostic purposes where it must be determined why spawned commands hung.  ```dump_tree(subtree)``` acceptsa subtree promise as an argument.  If no arguments are passed, ```dump_tree()``` dumps from the root promise on down.```# Simple example with no child promisesp = spawn `date`:    return True    p.tree_dump()  # Dump tree from root# orp.tree_dump(subtree_promise)  # Dump tree from node in argument```Example dumping tree from subtree node:```buildoutcfg# Complex example with child and grandchild promises# Demonstrates how to dump the promise tree from various points within itp = spawn `date`:    # Spawn child command (child promise)    spawn `pwd`:        # Spawn a grandchild to the parent promise        spawn `python --version`:            promise.tree_dump(promise)  # Dump the subtree from this point down            return False    # Spawn another child     spawn `echo &quot;blah&quot;`:         # Resolve parent promise         promise.resolve_parent()         # Resolve child promise        return True    # Do NOT resolve parent promise, let child do that    return False    p.join()p.tree_dump(p.children[0])  # Dump subtree from first child on downp.tree_dump(p.children[1])  # Dump subtree from the second childp.tree_dump(p.children[0].children[0]) # Dump subtree from the grandchild # Dump all childrenfor c in p.children:    p.tree_dump(c)```_Parent and child joins shown in these two examples_:``` root_promise = spawn `ls -lr`:    for file in promise.stdout:        t = f&quot;touch {file}&quot;        spawn `$t` {&quot;file&quot; file}:  # This promise is a child of root            print(f&quot;{file} updated&quot;.)            spawn `echo &quot;done&quot; &gt; /tmp/done&quot;`:  # Another child promise (root's grandchild)                print(&quot;Complete&quot;)                promise.resolve_parent()                return True            promise.resolve_parent()            return False    return Falseroot_promise.join()  # Wait on the root promise and all its children.  Thus, waiting for everything.`````` root_promise = spawn `ls -lr`:    for file in promise.output.stdout:        t = f&quot;touch {file}&quot;        spawn `$t` {&quot;file&quot; file}:  # This promise is a child of root            print(f&quot;{promise.args['file'])} updated&quot;)            promise.join() # Wait for this promise and its children but not its parent (root)            spawn `echo &quot;done&quot; &gt; /tmp/done&quot;`:                print(&quot;Complete&quot;)```_Resolving a parent promise_:```p = spawn `ls -lrt`:    for f in promise.output.stdout:        cmd = f&quot;touch {f}&quot;        # Spawn command from this resolver and pass our promise        spawn `$cmd`:            print(&quot;Resolving all promises&quot;)            promise.resolve_parent() # Resolve parent promise here            return True # Resolve child promise        return False # Do NOT resolve parent promise herep.join()  # Wait for ALL promises to be resolved```&lt;div id=&quot;spawn-results&quot;/&gt;### Results from Spawned CommandsSpawned commands return their results in the _promise.output_ property of the _promise_ object passed tothe resolver block, and in the spawn expression if there is an assignment in that spawn expression.The result properties can then be accessed as followed:&lt;table&gt;    &lt;th&gt;Property&lt;/th&gt;&lt;th&gt;Data Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;promise.output.stdout&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;List&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;STDOUT lines from the command normalized for display&lt;/td&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;promise.output.stderr&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;List&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;STDERR lines from the command normalized for display&lt;/td&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;promise.output.exit_code&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Integer&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Exit code value from command&lt;/td&gt;    &lt;tr&gt;&lt;/tr&gt;    &lt;td valign=&quot;top&quot;&gt;promise.output.cwd&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;String&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Current working directory &lt;i&gt;after&lt;/i&gt; command was executed&lt;/td&gt;&lt;/table&gt;_Notes:_1. Watiba backticked commands can exist within the resolver 2. Other _spawn_ blocks can be embedded within a resolver (recursion allowed)3. The command within the _spawn_ definition can be a variable    (The same rules apply as for all backticked shell commands.  This means the variable must contain   pure shell commands.)4. The leading dash to ignore CWD _cannot_ be used in the _spawn_ expression5. The _promise.output_ object is not available until _promise.resolved()_ returns True_Simple example with the shell command as a Python variable_:```#!/usr/bin/python3# run &quot;date&quot; command asynchronously d = 'date &quot;+%Y/%m/%d&quot;'spawn `$d`:    print(promise.output.stdout[0])    return True```_Example with shell commands executed within resolver block_:```#!/usr/bin/python3print(&quot;Running Watiba spawn with wait&quot;)`rm /tmp/done`# run &quot;ls -lrt&quot; command asynchronously p = spawn `ls -lrt`:    print(f&quot;Exit code: {promise.output.exit_code}&quot;)    print(f&quot;CWD: {promise.output.cwd}&quot;)    print(f&quot;STDERR: {promise.output.stderr}&quot;)    # Loop through STDOUT from command    for l in promise.output.stdout:        print(l)    `echo &quot;Done&quot; &gt; /tmp/done`    # Resolve promise    return True# Pause until spawn command is completep.wait()print(&quot;complete&quot;)```&lt;div id=&quot;threads&quot;/&gt;### ThreadsEach promise produced from a _spawn_ expression results in one OS thread.  To access the number of threads your code has spawned collectively, you can do the following:``` num_of_spawns = promise.spawn_count()  # Returns number of nodes in the promise treenum_of_resolved_promises = promise.resolved_count() # Returns the number of promises resolved in tree``` &lt;div id=&quot;remote-execution&quot;/&gt;## Remote ExecutionShell commands can be executed remotely.  This is achieved though the SSH command, issued by Watiba, and has the following requirements:- OpenSSH is installed on the local and remote hosts- The local SSH key is in the remote's _authorized_keys_ file.  _The details of this  process is beyond the scope of this README.  For those instructions, consult www.ssh.com_  - Make sure that SSH'ing to the target host does not cause any prompts.    Test that your SSH environment is setup first by manually entering: ```ssh {user}@{host} &quot;ls -lrt&quot;# For examplessh rwalk@walkubu &quot;ls -lrt&quot;# If SSH prompts you, then Watiba remote execution cannot function. ```To execute a command remotely, a _@host_ parameter is suffixed to the backticked command.  The host name can be aliteral or a variable.  To employ a variable, prepend a _$_ to the name following _@_ such as _@$var_.&lt;div id=&quot;change-ssh-port&quot;/&gt;#### Change SSH port for remote executionTo change the default SSH port 22 to a custom value, add to your Watiba code:  ```watiba-ctl {&quot;ssh-port&quot;: custom port}```Example:```buildoutcfgwatiba-ctl {&quot;ssh-port&quot;: 2233}```Examples:```buildoutcfgp = spawn `ls -lrt`@remoteserver {parms}:    for line in promise.output.stdout:        print(line)    return True     ```  ```buildoutcfgremotename = &quot;serverB&quot;p = spawn `ls -lrt`@$remotename {parms}:    for line in p.output.stdout:        print(line)    return True``````buildoutcfgout = `ls -lrt`@remoteserverfor line in out.stdout:    print(line)``````buildoutcfgremotename = &quot;serverB&quot;out = `ls -lrt`@$remotenamefor line in out.stdout:    print(line)```&lt;div id=&quot;command-hooks&quot;/&gt;## Command HooksHooks are pre- or -post functions that are attached to a _command_ _pattern_, which is a regular expression (regex).  Anytime Watiba encounters a commandthat matches the pattern for the hook, the hook function is called.All commands, spawned, remote, or local, can have Python functions executed **before** exection, by default, or **post hooks** that are run **after** the command.  (Note: Post hooks are not run for spwaned commands because the resolver function is a post hook itself.)  These functions can be passed arguments, too.### Command Hook Expressions```# Run before commands that match that patternhook-cmd &quot;pattern&quot; hook-function parms# Run before commands that match that pattern, but is non-recursivehook-cmd-nr &quot;pattern&quot; hook-function parms # Run after commands that match that patternpost-hook-cmd &quot;pattern&quot; hook-function parms# Run after commands that match that pattern, but is non-recursivepost-hook-cmd-nr &quot;pattern&quot; hook-function parms ```### Hook RecursionHooks, which are nothing more than Python functions called before or after a command is run, can issue their own commands and, thus, cause the hookto be recursively called.  However, if the command in the hook block of code matches a command pattern that causes that same hook function to be run again,an infinte loop can occur.  To prevent that, use the **-nr** suffix on the Watiba hook expression. (-nr stands for non-recursive.)  This will ensure thatthe hook cannot be re-invoked for any commands that are within it.&lt;br&gt;To attach a hook:1. Code one or more Python functions that will be the hooks.  At the end of each hook, you must return True if the hook was successful, or Falseif something wrong.2. Use the _hook-cmd_ expression to attach those hooks to a commandpattern, which is a regular expression3. To remove the hooks, use the _remove-hooks &quot;pattern&quot;_ expression.  If a pattern, i.e. command regex pattern, is omitted, then all command hooks are removed.**hook-cmd &quot;command pattern&quot; function parms**The first parameter always passed to the hook function is the Python _match_ object from the command match.  This is provided so the hook has accessto the tokens on the command should it need them.Example:```def my_hook(match, parms):    print(match.groups())    print(f'Tar file name is {match.group(1)}')    print(parms[&quot;parmA&quot;])    print(parms[&quot;parmB&quot;])    return True  # Successful executiondef your_hook(match, parms):    # This hook doesn't need the match object, so ignores it    print(parms[&quot;something&quot;])    if parms[&quot;something-else&quot;] != &quot;blah&quot;:        return False # Failed execution    return True # Successful excution# Add first hook to my tar commandhook-cmd &quot;tar -zcvf (\S.*)&quot; my_hook: {&quot;parmA&quot;:&quot;A&quot;, &quot;parmB&quot;:&quot;B&quot;}# Add another hook to my tar commandhook-cmd &quot;tar -zcvf (\S.*)&quot; your_hook: {&quot;parmD&quot;:1, &quot;parmE&quot;:&quot;something&quot;}# Spawn command, but hooks will be invoked first...spawn `tar -zcvf files.tar.gz /tmp/files/* `:    # Resolver code block    return True  # Resolve promise```Your parameters are whatever is valid for Python.  These are simply passed to their attached functions, essentially each one's key is the function name, as specified._Where are the hooks run for spawned commands?_  All hooks run under the thread of the issuer on the local host, not the target thread._Where are the hooks run for remote commands?_ As with spawned commands, all hooks are issued on the local host, not the remote.  Note that youcan have remote backticked commands in your hook and that will run those remotely.  If your remote command matches a hook(s) pattern, then those hooks will be run.  This means if your command pattern for the first remote call runs a hook that contains another remote command that matches that same command pattern, then the hook is run again.  Since this can lead to infinte hook loops, Watiba offers a non-recursive definition for the command pattern.  Note that this non-recursive settingonly applies to the command pattern and not the hook function itself.  So if _hookA_ is run for two different command patterns, say, &quot;ls -lrt&quot; and &quot;ls -laF&quot; you canmake one non-recusrive and still run the same hook for both commands.  For the recursive command pattern, the hook has no limit to its recursion.  For non-recursive,it will only be called once during the recursion process.To set a command pattern as non-recursive, use _hook-cmd-nr_.Example using a variation on a previous example:```def my_hook(match, parms)    `tar -zcvf /tmp/files`  # my_hook will NOT because for this command even though it matches    print(&quot;Will be called only once!&quot;)    return True# Note the &quot;-nr&quot; on the expression.  That's for non-recursivehook-cmd-nr &quot;tar -zcvf (\S.*)&quot; my_hook: {&quot;parmA&quot;:&quot;A&quot;, &quot;parmB&quot;:&quot;B&quot;}# my_hook will be called before this command runs` tar -zcvf tarball.tar.gz /home/user/files.*````&lt;div id=&quot;command-chaining&quot;/&gt;## Command ChainingWatiba extends its remote command execution to chaining commands across multiple remote hosts.  This is achievedby the _chain_ expression.  This expression will execute the backticked command across a list of hosts, passed bythe user, sequentially, synchronously until the hosts list is exhausted, or the command fails.  _chain_ returns aPython dictionary where the keys are the host names and the values the WTOutput from the command run on that host.#### Chain ExceptionThe _chain_ expression raises a WTChainException on the first failed command.  The exception raisedhas the following properties:_WTChainException_:&lt;table&gt;&lt;th&gt;Property&lt;/th&gt;&lt;th&gt;Data Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;tr&gt;&lt;/tr&gt;&lt;td valign=&quot;top&quot;&gt;command&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;String&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Command that failed&lt;/td&gt;&lt;tr&gt;&lt;/tr&gt;&lt;td valign=&quot;top&quot;&gt;host&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;String&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Host where command failed&lt;/td&gt;&lt;tr&gt;&lt;/tr&gt;&lt;td valign=&quot;top&quot;&gt;message&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;String&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Error message&lt;/td&gt;&lt;tr&gt;&lt;/tr&gt;&lt;td valign=&quot;top&quot;&gt;output&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;WTOutput structure:- stdout- stderr- exit_code- cwd&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;Output from command&lt;/td&gt;&lt;/table&gt;Import this exception to catch it:```buildoutcfgfrom watiba import WTChainException```Examples:```from watiba import WTChainExceptiontry:    out = chain `tar -zcvf backup/file.tar.gz dir/*` {&quot;hosts&quot;, [&quot;serverA&quot;, &quot;serverB&quot;]}    for host,output in out.items():        print(f'{host} exit code: {output.exit_code}')        for line in output.stderr:            print(line) except WTChainException(ex):    print(f&quot;Error: {ex.message}&quot;)    print(f&quot;  host: {ex.host} exit code: {ex.output.exit_code} command: {ex.command})            ```&lt;div id=&quot;piping-output&quot;/&gt;## Command Chain Piping (Experimental)The _chain_ expression supports piping STDOUT and/or STDERR to other commands executed on remote servers.  Complexarrangements can be constructed through the Python dictionary passed to the _chain_ expression.  The dictionarycontents function as follows:- &quot;hosts&quot;: [server, server, ...]   This entry instructions _chain_ on which hosts the backticked command will run.    This is a required entry.    - &quot;stdout&quot;: {server:command, server:command, ...}    This is an optional entry.  - &quot;stderr&quot;: {server:command, server:command, ...}    This is an optional entry.Just like a _chain_ expression that does not pipe output, the return object is a dictionary of WTOutput object keyedby the host name from the _hosts_ list and *not* from the commands recieving the piped output.If any command fails, a WTChainException is raised.  Import this exception to catch it:```buildoutcfgfrom watiba import WTChainException```_Note_: _The piping feature is experimental as of this release, and a better design will eventuallysupercede it._Examples:  ```from watiba import WTChainException# This is a simple chain with no pipingtry:    args = {&quot;hosts&quot;: [&quot;serverA&quot;, &quot;serverB&quot;, &quot;serverC&quot;]}    out = chain `ls -lrt dir/` args    for host, output in out.items():        print(f'{host} exit code: {output.exit_code}')except WTChainException as ex:    print(f'ERROR: {ex.message}, {ex.host}, {ex.command}, {ex.output.stderr}')``````# This is a more complex chain that runs the &quot;ls -lrt&quot; command on each server listed in &quot;hosts&quot;# and pipes the STDOUT output from serverC to serverV and serverD, to those commands, and serverB's STDERR# to serverX and its commandtry:    args = {&quot;hosts&quot;: [&quot;serverA&quot;, &quot;serverB&quot;, &quot;serverC&quot;],                &quot;stdout&quot;: {&quot;serverC&quot;:{&quot;serverV&quot;: &quot;grep something&quot;, &quot;serverD&quot;:&quot;grep somethingelse&quot;}},                &quot;stderr&quot;: {&quot;serverB&quot;:{&quot;serverX&quot;: &quot;cat &gt;&gt; /tmp/serverC.err&quot;}}           }    out = chain `ls -lrt dir/` args    for host, output in out.items():        print(f'{host} exit code: {output.exit_code}')except WTChainException as ex:    print(f'ERROR: {ex.message}, {ex.host}, {ex.command}, {ex.output.stderr}')```####How does this work?Watiba will run the backticked command in the expression on each host listed in _hosts_, in sequence and synchronously.If there is a &quot;stdout&quot; found in the arguments, then it will name the source host as the key, i.e. the host from whichSTDOUT will be read, and fed to each host and command listed under that host.  This is true for STDERR as well.The method in which Watiba feeds the piped output is through a an _echo_ command shell piped to the command to be runon that host.  So, &quot;stdout&quot;: {&quot;serverC&quot;:{&quot;serverV&quot;: &quot;grep something&quot;}} causes Watiba to read each line of STDOUT fromserverC and issue ```echo &quot;$line&quot; | grep something``` on serverV.  It is piping from serverC to serverV.&lt;div id=&quot;installation&quot;/&gt;## Installation### PIPIf you installed this as a Python package, e.g. pip, then the pre-compiler, _watiba-c_,will be placed in your system's PATH by PIP.### GITHUBIf you cloned this from github, you'll still need to install the package with pip, first, for thewatbia module.  Follow these steps to install Watiba locally.```# Watiba package requiredpython3 -m pip install watiba```&lt;div id=&quot;pre-compiling&quot;/&gt;## Pre-compilingTest that the pre-compiler functions in your environment:```watiba-c version```For example:```buildoutcfgrwalk@walkubu:~$ watiba-c versionWatiba 0.3.26```To pre-compile a .wt file:```watiba-c my_file.wt &gt; my_file.pychmod +x my_file.py./my_file.py```Where _my_file.wt_ is your Watiba code.&lt;div id=&quot;code-examples&quot;/&gt;## Code Examples**my_file.wt**```#!/usr/bin/python3# Stand alone commands.  One with directory context, one without# This CWD will be active until a subsequent command changes it`cd /tmp`# Simple statement utilizing command and results in one statementprint(`cd /tmp`.cwd)# This will not change the Watiba CWD context, because of the dash prefix, but within # the command itself the cd is honored.  file.txt is created in /home/user/blah but# this does not impact the CWD of any subsequent commands.  They# are still operating from the previous cd command to /tmp-`cd /home/user/blah &amp;&amp; touch file.txt`# This will print &quot;/tmp&quot; _not_ /home because of the leading dash on the commandprint(f&quot;CWD is not /home: {-`cd /home`.cwd)}&quot;# This will find text files in /tmp/, not /home/user/blah  (CWD context!)w=`find . -name '*.txt'`for l in w.stdout:    print(f&quot;File: {l}&quot;)# Embedding commands in print expressions that will print the stderr output, which tar writes toprint(`echo &quot;Some textual comment&quot; &gt; /tmp/blah.txt &amp;&amp; tar -zcvf /tmp/blah.tar.gz /tmp`).stdout)# This will print the first line of stdout from the echoprint(`echo &quot;hello!&quot;`.stdout[0])# Example of more than one command in a statement lineif len(`ls -lrt`.stdout) &gt; 0 or len(-`cd /tmp`.stdout) &gt; 0:    print(&quot;You have stdout or stderr messages&quot;)# Example of a command as a Python varible and#  receiving a Watiba objectcmd = &quot;tar -zcvf /tmp/watiba_test.tar.gz /mnt/data/git/watiba/src&quot;cmd_results = `$cmd`if cmd_results.exit_code == 0:    for l in cmd_results.stderr:        print(l)# Simple reading of command output#  Iterate on the stdout propertyfor l in `cat blah.txt`.stdout:    print(l)# Example of a failed command to see its exit codexc = `lsvv -lrt`.exit_codeprint(f&quot;Return code: {xc}&quot;)# Example of running a command asynchronously and resolving promisespawn `cd /tmp &amp;&amp; tar -zxvf tarball.tar.gz`:    for l in promise.output.stderr:        print(l)    return True  # Mark promise resolved# List dirs from CWD, iterate through them, spawn a tar command# then within the resolver, spawn a move command# Demonstrates spawns within resolversfor dir in `ls -d *`.stdout:    tar = &quot;tar -zcvf {}.tar.gz {}&quot;    prom = spawn `$tar` {&quot;dir&quot;: dir}:        print(f&quot;{}args['dir'] tar complete&quot;)        mv = f&quot;mv -r {args['dir']}/* /tmp/.&quot;        spawn `$mv`:            print(&quot;Move done&quot;)            # Resolve outer promise            promise.resolve_parent()            return True        # Do not resolve this promise yet.  Let the inner resolver do it        return False    prom.join()```</longdescription>
</pkgmetadata>