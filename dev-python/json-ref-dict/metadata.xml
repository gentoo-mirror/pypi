<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Build Status](https://travis-ci.com/jacksmith15/json-ref-dict.svg?branch=master)](https://travis-ci.com/jacksmith15/json-ref-dict)# JSONSchema Ref DictPython dict-like object which abstracts resolution of JSONSchema references.```pythonfrom json_ref_dict import RefDictschema = RefDict(&quot;https://json-schema.org/draft-07/schema#/&quot;)```Nested items containing `&quot;$ref&quot;` will be resolved lazily when accessed,meaning the dictionary can be treating as a single, continuous (andpossibly infinite) document.Remote references are supported, and will be resolved relative to the currentdocument.If no scheme is provided, it is assumed that the document is present on thelocal filesystem (see [Example](#example) below).If [PyYAML](https://github.com/yaml/pyyaml) is installed, then loading of YAML documents will be supported, otherwise only JSON documents may be loaded.## ExampleGiven the following related schemas:#### _master.yaml_```yamldefinitions:  foo:    type: string  local_ref:    $ref: '#/definitions/foo'  remote_ref:    $ref: 'other.yaml#/definitions/bar'  backref:    $ref: 'other.yaml#/definitions/baz'```#### _other.yaml_```yamldefinitions:  bar:    type: integer  baz:    $ref: 'master.yaml#/definitions/foo'```We can parse these as a single object as follows:```pythonfrom json_ref_dict import RefDictschema = RefDict(&quot;master.yaml#/definitions&quot;)print(schema)&gt;&gt;&gt; {'foo': {'type': 'string'}, 'local_ref': {'$ref': '#/definitions/foo'}, 'remote_ref': {'$ref': 'other.yaml#/definitions/bar'}, 'backref': {'$ref': 'other.yaml#/definitions/baz'}}print(schema[&quot;local_ref&quot;])&gt;&gt;&gt; {'type': 'string'}print(schema[&quot;remote_ref&quot;])&gt;&gt;&gt; {'type': 'integer'}print(schema[&quot;backref&quot;])&gt;&gt;&gt; {'type': 'string'}```## Materializing documentsIf you don't want the lazy behaviour, and want to get all of the IO out of the way up front, then you can &quot;materialize&quot; the dictionary:```pythonfrom json_ref_dict import materialize, RefDictschema = materialize(RefDict(&quot;https://json-schema.org/draft-04/schema#/&quot;))assert isinstance(schema, dict)```A materialized `RefDict` is just a regular dict, containing a document with all references resolved. This is useful if, for example, you want to cache/persist the entire schema. Be aware that if there are cyclical references in the schema, these will be present on the materialized dictionary.The `materialize` helper also supports some basic transformation options, as performing global transformations on infinite documents is non-trivial:- `include_keys` - an iterable of keys to include in the materialized document.- `exclude_keys` - an iterable of keys to exclude from the materialized document.- `value_map` - an operation to apply to the values of the document (not lists or dictionaries).# RequirementsThis package is currently tested for Python 3.6.# InstallationThis project may be installed using [pip](https://pip.pypa.io/en/stable/):```pip install json-ref-dict```# Development1. Clone the repository: `git clone git@github.com:jacksmith15/json-ref-dict.git &amp;&amp; cd json-ref-dict`2. Install the requirements: `pip install -r requirements.txt -r requirements-test.txt`3. Run `pre-commit install`4. Run the tests: `bash run_test.sh -c -a`This project uses the following QA tools:- [PyTest](https://docs.pytest.org/en/latest/) - for running unit tests.- [PyLint](https://www.pylint.org/) - for enforcing code style.- [MyPy](http://mypy-lang.org/) - for static type checking.- [Travis CI](https://travis-ci.org/) - for continuous integration.- [Black](https://black.readthedocs.io/en/stable/) - for uniform code formatting.# LicenseThis project is distributed under the MIT license.</longdescription>
</pkgmetadata>