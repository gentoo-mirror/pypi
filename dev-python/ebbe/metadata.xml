<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Build Status](https://github.com/Yomguithereal/ebbe/workflows/Tests/badge.svg)](https://github.com/Yomguithereal/ebbe/actions)# EbbeA collection of typical helper functions for python that cannot be found in the however great standard library.## InstallationYou can install `ebbe` with pip with the following command:```pip install ebbe```## Usage*Iterator functions** [as_chunks](#as_chunks)* [as_grams](#as_grams)* [fail_fast](#fail_fast)* [uniq](#uniq)* [distinct](#distinct)* [with_prev](#with_prev)* [with_prev_and_next](#with_prev_and_next)* [with_next](#with_next)* [with_is_first](#with_is_first)* [with_is_last](#with_is_last)* [without_first](#without_first)* [without_last](#without_last)*Utilities** [get](#get)* [getter](#getter)* [getpath](#getpath)* [pathgetter](#pathgetter)* [indexed](#indexed)* [grouped](#grouped)* [partitioned](#partitioned)* [sorted_uniq](#sorted_uniq)* [pick](#pick)* [omit](#omit)*Functional Programming** [noop](#noop)* [compose](#compose)* [rcompose](#rcompose)*Formatting** [and_join](#and_join)* [format_int](#format_int)* [format_time](#format_time)*Decorators** [decorators.fail_fast](#decoratorsfail_fast)* [decorators.with_defer](#decoratorswith_defer)*Benchmarking** [Timer](#timer)### as_chunksIterate over chunks of the desired size by grouping items as we iterate over them.```pythonfrom ebbe import as_chunkslist(as_chunks(3, [1, 2, 3, 4, 5]))&gt;&gt;&gt; [[1, 2, 3], [4, 5]]```### as_gramsIterate over grams (sometimes called n-grams or q-grams etc.) of the given iterable. It works with strings, lists and other sized sequences as well as with lazy iterables without consuming any superfluous memory while doing so.```pythonfrom ebbe import as_gramslist(as_grams(3, 'hello'))&gt;&gt;&gt; ['hel', 'ell', 'llo']list(as_grams(2, (i * 2 for i in range(5))))&gt;&gt;&gt; [(0, 2), (2, 4), (4, 6), (6, 8)]```### fail_fastTake an iterable (but this has been geared towards generators, mostly), and tries to access the first value to see if an Exception will be raised before returning an equivalent iterator.This is useful with some badly-conceived generators that checks arguments and raise if they are not valid, for instance, and if you don't want to wrap the whole iteration block within a try/except.This logic is also available as a [decorator](#failfastdecorator).```pythonfrom ebbe import fail_fastdef hellraiser(n):  if n &gt; 10:    raise TypeError  yield from range(n)# You will need to do this to catch the error:gen = hellraiser(15)try:  for i in gen:    print(i)except TypeError:  print('Something went wrong when creating the generator')# With fail_fasttry:  gen = fail_fast(hellraiser(15))except TypeError:  print('Something went wrong when creating the generator')for i in gen:  print(i)```### uniqFilter repeated items, optionally by key, seen next to each other in the given iterator.```pythonfrom ebbe import uniqlist(uniq([1, 1, 1, 2, 3, 4, 4, 5, 5, 6]))&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]# BEWARE: it does not try to remember items (like the `uniq` command)list(uniq([1, 2, 2, 3, 2]))&gt;&gt;&gt; [1, 2, 3, 2]# Using a keylist(uniq([(1, 2), (1, 3), (2, 4)], key=lambda x: x[0]))&gt;&gt;&gt; [(1, 2), (2, 4)]```### distinctFilter repeated items, optionally by key, in the given iterator.```pythonfrom ebbe import distinctlist(distinct([0, 3, 4, 4, 1, 0, 3]))&gt;&gt;&gt; [0, 3, 4, 1]list(distinct(range(6), key=lambda x: x % 2))&gt;&gt;&gt; [0, 1]```### with_prevIterate over items along with the previous one.```pythonfrom ebbe import with_prevfor previous_item, item in with_prev(iterable):  print(previous_item, 'came before', item)list(with_prev([1, 2, 3]))&gt;&gt;&gt; [(None, 1), (1, 2), (2, 3)]```### with_prev_and_nextIterate over items along with the previous and the next one.```pythonfrom ebbe import with_prev_and_nextfor previous_item, item, next_item in with_prev_and_next(iterable):  print(previous_item, 'came before', item)  print(next_item, 'will come after', item)list(with_prev_and_next([1, 2, 3]))&gt;&gt;&gt; [(None, 1, 2), (1, 2, 3), (2, 3, None)]```### with_nextIterate over items along with the next one.```pythonfrom ebbe import with_nextfor item, next_item in with_next(iterable):  print(next_item, 'will come after', item)list(with_next([1, 2, 3]))&gt;&gt;&gt; [(1, 2), (2, 3), (3, None)]```### with_is_firstIterate over items along with the information that the current item is the first one or not.```pythonfrom ebbe import with_is_firstfor is_first, item in with_is_first(iterable):  if is_first:    print(item, 'is first')  else:    print(item, 'is not first')list(with_is_first([1, 2, 3]))&gt;&gt;&gt; [(True, 1), (False, 2), (False, 3)]```### with_is_lastIterate over items along with the information that the current item is the last one or not.```pythonfrom ebbe import with_is_lastfor is_last, item in with_is_last(iterable):  if is_last:    print(item, 'is last')  else:    print(item, 'is not last')list(with_is_last([1, 2, 3]))&gt;&gt;&gt; [(False, 1), (False, 2), (True, 3)]```### without_firstIterate over the given iterator after skipping its first item. Can be useful if you want to skip headers of a CSV file for instance.```pythonfrom ebbe import without_firstlist(without_first([1, 2, 3]))&gt;&gt;&gt; [2, 3]for row in without_first(csv.reader(f)):  print(row)```### without_lastIterate over the given iterator but skipping its last item.```pythonfrom ebbe import without_lastlist(without_last([1, 2, 3]))&gt;&gt;&gt; [1, 2]```### getOperator function similar to `operator.getitem` but able to take a default value.```pythonfrom ebbe import getget([1, 2, 3], 1)&gt;&gt;&gt; 2get([1, 2, 3], 4)&gt;&gt;&gt; None# With default valueget([1, 2, 3], 4, 35)&gt;&gt;&gt; 35```### getterOperator factory similar to `operator.itemgetter` but able to take a default value.```pythonfrom ebbe import getterget_second_or_thirty = getter(1, 30)get_second_or_thirty([1, 2, 3])&gt;&gt;&gt; 2get_second_or_thirty([1])&gt;&gt;&gt; 30# Overriding default on the spotget_second_or_thirty([1], 76)&gt;&gt;&gt; 76```### getpathOperator function used to retrieve a value at given path in a nested structure or a default value if this value cannot be found.```pythonfrom ebbe import getpathdata = {'a': {'b': [{'c': 34}, 'test'], 'd': 'hello'}}getpath(data, ['a', 'b', 0, 'c'])&gt;&gt;&gt; 34getpath(data, ['t', 'e', 's', 't'])&gt;&gt;&gt; None# Using a default return valuegetpath(data, ['t', 'e', 's', 't'], 45)&gt;&gt;&gt; 45# Using a string pathgetpath(data, 'a.b.d', split_char='.')&gt;&gt;&gt; 'hello'```*Arguments** **target** *any*: target object.* **path** *iterable*: path to get.* **default** *?any* [`None`]: default value to return.* **items** *?bool* [`True`]: whether to attempt to traverse keys and indices.* **attributes** *?bool* [`False`]: whether to attempt to traverse attributes.* **split_char** *?str*: if given, will split strings passed as path instead of raising `TypeError`.* **parse_indices** *?bool* [`False`]: whether to parse integer indices when splitting string paths.### pathgetterFunction returning a getter function working as [getpath](#getpath) and partially applied to use the provided path or paths.```pythonfrom ebbe import pathgetterdata = {'a': {'b': [{'c': 34}, 'test'], 'd': 'hello'}}getter = pathgetter(['a', 'b', 0, 'c'])getter(data)&gt;&gt;&gt; 34getter = pathgetter(['t', 'e', 's', 't'])getter(data)&gt;&gt;&gt; None# Using a default return valuegetter = pathgetter(['t', 'e', 's', 't'])getter(data, 45)&gt;&gt;&gt; 45# Using a string pathgetter = pathgetter('a.b.d', split_char='.')getter(data)&gt;&gt;&gt; 'hello'# Using multiple pathsgetter = pathgetter(  ['a', 'b', 0, 'c'],  ['t', 'e', 's', 't'],  ['a', 'b', 'd'])getter(data)&gt;&gt;&gt; (34, None, 'hello')```*Arguments** **paths** *list*: paths to get.* **items** *?bool* [`True`]: whether to attempt to traverse keys and indices.* **attributes** *?bool* [`False`]: whether to attempt to traverse attributes.* **split_char** *?str*: if given, will split strings passed as path instead of raising `TypeError`.* **parse_indices** *?bool* [`False`]: whether to parse integer indices when splitting string paths.*Getter arguments** **target** *any*: target object.* **default** *?any* [`None`]: default value to return.### indexedFunction indexing the given iterable in a dict-like structure. This is basically just some functional sugar over a `dict` constructor.```pythonfrom ebbe import indexedindexed(range(3), key=lambda x: x * 10)&gt;&gt;&gt; {  0: 0,  10: 1,  20: 2}```### groupedFunction grouping the given iterable by a key.```pythonfrom ebbe import groupedgrouped(range(4), key=lambda x: x % 2)&gt;&gt;&gt; {  0: [0, 2],  1: [1, 3]}# Using an optional valuegrouped(range(4), key=lambda x: x % 2, value=lambda x: x * 10)&gt;&gt;&gt; {  0: [0, 20],  1: [10, 30]}# Using the items variantfrom ebbe import grouped_itemsgrouped_items((x % 2, x * 10) for i in range(4))&gt;&gt;&gt; {  0: [0, 20],  1: [10, 30]}```### partitionedFunction partitioning the given iterable by key.```pythonfrom ebbe import partitionedpartitioned(range(4), key=lambda x: x % 2)&gt;&gt;&gt; [  [0, 2],  [1, 3]]# Using an optional valuepartitioned(range(4), key=lambda x: x % 2, value=lambda x: x * 10)&gt;&gt;&gt; [  [0, 20],  [10, 30]]# Using the items variantfrom ebbe import partitioned_itemspartitioned_items((x % 2, x * 10) for i in range(4))&gt;&gt;&gt; [  [0, 20],  [10, 30]]```### sorted_uniqFunction sorting the given iterable then dropping its duplicate through a single linear pass over the data.```pythonfrom ebbe import sorted_uniqnumbers = [3, 17, 3, 4, 1, 4, 5, 5, 1, -1, 5]sorted_uniq(numbers)&gt;&gt;&gt; [-1, 1, 3, 4, 5, 17]# It accepts all of `sorted` kwargs:sorted_uniq(numbers, reverse=True)&gt;&gt;&gt; [17, 5, 4, 3, 1, -1]```### pickFunction returning the given dictionary with only the selected keys.```pythonfrom ebbe import pick# Selected keys must be an iterable:pick({'a': 1, 'b': 2, 'c': 3}, ['a', 'c'])&gt;&gt;&gt; {'a': 1, 'c': 3}# If you need the function to raise if one of the picked keys is not found:pick({'a': 1, 'b': 2, 'c': 3}, ['a', 'd'], strict=True)&gt;&gt;&gt; KeyError: 'd'```### omitFunction returning the given dictionary without the selected keys.```pythonfrom ebbe import omit# Selected keys must be a container:omit({'a': 1, 'b': 2, 'c': 3}, ['a', 'c'])&gt;&gt;&gt; {'b': 2}# If need to select large numbers of keys, use a set:omit({'a': 1, 'b': 2, 'c': 3}, {'a', 'c'})&gt;&gt;&gt; {'b': 2}```### noopNoop function (a function that can be called with any arguments and does nothing). Useful as a default to avoid complicating code sometimes.```pythonfrom ebbe import noopnoop() # Does nothing...noop(4, 5) # Still does nothing...noop(4, index=65) # Nothing yet again...```### composeFunction returning the composition function of its variadic arguments.```pythondef times_2(x):  return x * 2def plus_5(x):  return x + 5compose(times_2, plus_5)(10)&gt;&gt;&gt; 30# Reverse ordercompose(times_2, plus_5, reverse=True)(10)&gt;&gt;&gt; 25```### rcomposeFunction returning the reverse composition function of its variadic arguments.```pythondef times_2(x):  return x * 2def plus_5(x):  return x + 5rcompose(times_2, plus_5)(10)&gt;&gt;&gt; 25```### and_joinJoin function able to group the last items with a custom copula such as &quot;and&quot;.```pythonfrom ebbe import and_joinand_join(['1', '2', '3'])&gt;&gt;&gt; '1, 2 and 3'and_join(['1', '2', '3'], separator=';', copula=&quot;y&quot;)&gt;&gt;&gt; '1; 2 y 3'```### format_intFormat given number as an int with thousands separator.```pythonfrom ebbe import format_intformat_int(4500)&gt;&gt;&gt; '4,500'format_int(10000, separator=' ')&gt;&gt;&gt; '10 000'```### format_timeFormat time with custom precision and unit from years to nanoseconds.```pythonfrom ebbe import format_timeformat_time(57309)&gt;&gt;&gt; &quot;57 microseconds and 309 nanoseconds&quot;format_time(57309, precision=&quot;microseconds&quot;)&gt;&gt;&gt; &quot;57 microsecondsformat_time(78, unit=&quot;seconds&quot;)&gt;&gt;&gt; &quot;1 minute and 18 seconds&quot;format_time(4865268458795)&gt;&gt;&gt; &quot;1 hour, 21 minutes, 5 seconds, 268 milliseconds, 458 microseconds and 795 nanoseconds&quot;assert format_time(4865268458795, max_items=2)&gt;&gt;&gt; &quot;1 hour and 21 minutes&quot;format_time(4865268458795, short=True)&gt;&gt;&gt; &quot;1h, 21m, 5s, 268ms, 458µs, 795ns&quot;```### decorators.fail_fastDecorate a generator function by wrapping it into another generator function that will fail fast if some validation is run before executing the iteration logic so that exceptions can be caught early.This logic is also available as a [function](#failfast).```pythonfrom ebbe.decorators import fail_fastdef hellraiser(n):  if n &gt; 10:    raise TypeError  yield from range(n)# This will not raise until you consume `gen`gen = hellraiser(15)@fail_fast()def hellraiser(n):  if n &gt; 10:    raise TypeError  yield from range(n)# This will raise immediatelygen = hellraiser(15)```### decorators.with_deferDecorates a function calling it with a `defer` kwarg working a bit like Go's [defer statement](https://gobyexample.com/defer) so that you can &quot;defer&quot; actions to be done by the end of the function or when an exception is raised to cleanup or tear down things.This relies on an [ExitStack](https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack) and can of course be also accomplished by context managers but this way of declaring things to defer can be useful sometimes to avoid nesting in complex functions.```pythonfrom ebbe.decorators import with_defer@with_defer()def main(content, *, defer):  f = open('./output.txt', 'w')  defer(f.close)  f.write(content)```### TimerContext manager printing the time (to stderr by default) it took to execute wrapped code. Very useful to run benchmarks.```pythonfrom ebbe import Timerwith Timer():  some_costly_operation()# Will print &quot;Timer: ...s etc.&quot; on exit# To display a custom message:with Timer('my operation'):  ...# To print to stdoutimport syswith Timer(file=sys.stdout):  ...```</longdescription>
</pkgmetadata>