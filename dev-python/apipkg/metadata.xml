<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Welcome to apipkg !-------------------With apipkg you can control the exported namespace of a Python package andgreatly reduce the number of imports for your users.It is a `small pure Python module`_ that works on CPython 3.7+,Jython and PyPy. It cooperates well with Python's ``help()`` system,custom importers (PEP302) and common command-line completion tools.Usage is very simple: you can require 'apipkg' as a dependency or youcan copy paste the ~200 lines of code into your project.Tutorial example-------------------Here is a simple ``mypkg`` package that specifies one namespaceand exports two objects imported from different modules:.. code-block:: python    # mypkg/__init__.py    import apipkg    apipkg.initpkg(__name__, {        'path': {            'Class1': &quot;_mypkg.somemodule:Class1&quot;,            'clsattr': &quot;_mypkg.othermodule:Class2.attr&quot;,        }    }The package is initialized with a dictionary as namespace.You need to create a ``_mypkg`` package with a ``somemodule.py``and ``othermodule.py`` containing the respective classes.The ``_mypkg`` is not special - it's a completelyregular Python package.Namespace dictionaries contain ``name: value`` mappingswhere the value may be another namespace dictionary ora string specifying an import location.  On accessingan namespace attribute an import will be performed:.. code-block:: pycon    &gt;&gt;&gt; import mypkg    &gt;&gt;&gt; mypkg.path    &lt;ApiModule 'mypkg.path'&gt;    &gt;&gt;&gt; mypkg.path.Class1   # '_mypkg.somemodule' gets imported now    &lt;class _mypkg.somemodule.Class1 at 0xb7d428fc&gt;    &gt;&gt;&gt; mypkg.path.clsattr  # '_mypkg.othermodule' gets imported now    4 # the value of _mypkg.othermodule.Class2.attrThe ``mypkg.path`` namespace and its two entries areloaded when they are accessed.   This means:* lazy loading - only what is actually needed is ever loaded* only the root &quot;mypkg&quot; ever needs to be imported to get  access to the complete functionality* the underlying modules are also accessible, for example:.. code-block:: python    from mypkg.sub import Class1Including apipkg in your package--------------------------------------If you don't want to add an ``apipkg`` dependency to your package youcan copy the `apipkg.py`_ file somewhere to your own package,for example ``_mypkg/apipkg.py`` in the above example.  Youthen import the ``initpkg`` function from that new place andare good to go... _`small pure Python module`:.. _`apipkg.py`: https://github.com/pytest-dev/apipkg/blob/master/src/apipkg/__init__.pyFeedback?-----------------------If you have questions you are welcome to* join the **#pytest** channel on irc.libera.chat_  (using an IRC client, via webchat_, or via Matrix_).* create an issue on the bugtracker_.. _irc.libera.chat: ircs://irc.libera.chat:6697/#pytest.. _webchat: https://web.libera.chat/#pytest.. _matrix: https://matrix.to/#/%23pytest:libera.chat.. _bugtracker: https://github.com/pytest-dev/apipkg/issues</longdescription>
</pkgmetadata>