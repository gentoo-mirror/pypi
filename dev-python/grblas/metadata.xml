<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># grblas[![conda-forge](https://img.shields.io/conda/vn/conda-forge/grblas.svg)](https://anaconda.org/conda-forge/grblas)[![pypi](https://img.shields.io/pypi/v/grblas.svg)](https://pypi.python.org/pypi/grblas/)[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://github.com/metagraph-dev/grblas/blob/main/LICENSE)[![Tests](https://github.com/metagraph-dev/grblas/workflows/Tests/badge.svg?branch=main)](https://github.com/metagraph-dev/grblas/actions)[![Docs](https://readthedocs.org/projects/grblas/badge/?version=latest)](https://grblas.readthedocs.io/en/latest/)[![Coverage](https://coveralls.io/repos/metagraph-dev/grblas/badge.svg?branch=main)](https://coveralls.io/r/metagraph-dev/grblas)[![Code style](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/metagraph-dev/grblas/HEAD?filepath=notebooks%2FIntro%20to%20GraphBLAS%20%2B%20SSSP%20example.ipynb)## *__DEPRECATED__: `grblas` has been renamed.  Use [`python-graphblas` (PyPI)](https://pypi.org/project/python-graphblas/) [(github)](https://github.com/python-graphblas/python-graphblas) instead.*Python wrapper around GraphBLASTo install, `conda install -c conda-forge grblas` or `pip install grblas`. This will also install the SuiteSparse `graphblas` compiled C library.Currently works with [SuiteSparse:GraphBLAS](https://github.com/DrTimothyAldenDavis/GraphBLAS), but the goal is to make it work with all implementations of the GraphBLAS spec.The approach taken with this library is to follow the C-API specification as closely as possible while making improvementsallowed with the Python syntax. Because the spec always passes in the output object to be written to, we follow the same,which is very different from the way Python normally operates. In fact, many who are familiar with other Python datalibraries (numpy, pandas, etc) will find it strange to not create new objects for every call.At the highest level, the goal is to separate output, mask, and accumulator on the left side of the assignmentoperator `=` and put the computation on the right side. Unfortunately, that approach doesn't always work very wellwith how Python handles assignment, so instead we (ab)use the left-shift `&lt;&lt;` notation to give the same flavor ofassignment. This opens up all kinds of nice possibilities.This is an example of how the mapping works:```C// C callGrB_Matrix_mxm(M, mask, GrB_PLUS_INT64, GrB_MIN_PLUS_INT64, A, B, NULL)``````python# Python callM(mask.V, accum=binary.plus) &lt;&lt; A.mxm(B, semiring.min_plus)```The expression on the right `A.mxm(B)` creates a delayed object which does no computation. Once it is used in the`&lt;&lt;` expression with `M`, the whole thing is translated into the equivalent GraphBLAS call.Delayed objects also have a `.new()` method which can be used to force computation and return a newobject. This is convenient and often appropriate, but will create many unnecessary objects if used in a loop. Italso loses the ability to perform accumulation with existing results. For best performance, following the standardGraphBLAS approach of (1) creating the object outside the loop and (2) using the object repeatedly within each loopis a much better approach, even if it doesn't feel very Pythonic.Descriptor flags are set on the appropriate elements to keep logic close to what it affects. Here is the same callwith descriptor bits set. `ttcsr` indicates transpose the first and second matrices, complement the structure of the mask,and do a replacement on the output.```C// C callGrB_Matrix_mxm(M, mask, GrB_PLUS_INT64, GrB_MIN_PLUS_INT64, A, B, desc.ttcsr)``````python# Python callM(~mask.S, accum=binary.plus, replace=True) &lt;&lt; A.T.mxm(B.T, semiring.min_plus)```The objects receiving the flag operations (A.T, ~mask, etc) are also delayed objects. They hold on to the state butdo no computation, allowing the correct descriptor bits to be set in a single GraphBLAS call.**If no mask or accumulator is used, the call looks like this**:```pythonM &lt;&lt; A.mxm(B, semiring.min_plus)```The use of `&lt;&lt;` to indicate updating is actually just syntactic sugar for a real `.update()` method. The aboveexpression could be written as:```pythonM.update(A.mxm(B, semiring.min_plus))```## Operations```pythonM(mask, accum) &lt;&lt; A.mxm(B, semiring)        # mxmw(mask, accum) &lt;&lt; A.mxv(v, semiring)        # mxvw(mask, accum) &lt;&lt; v.vxm(B, semiring)        # vxmM(mask, accum) &lt;&lt; A.ewise_add(B, binaryop)  # eWiseAddM(mask, accum) &lt;&lt; A.ewise_mult(B, binaryop) # eWiseMultM(mask, accum) &lt;&lt; A.kronecker(B, binaryop)  # kroneckerM(mask, accum) &lt;&lt; A.T                       # transpose```## Extract```pythonM(mask, accum) &lt;&lt; A[rows, cols]             # rows and cols are a list or a slicew(mask, accum) &lt;&lt; A[rows, col_index]        # extract columnw(mask, accum) &lt;&lt; A[row_index, cols]        # extract rows = A[row_index, col_index].value           # extract single element```## Assign```pythonM(mask, accum)[rows, cols] &lt;&lt; A             # rows and cols are a list or a sliceM(mask, accum)[rows, col_index] &lt;&lt; v        # assign columnM(mask, accum)[row_index, cols] &lt;&lt; v        # assign rowM(mask, accum)[rows, cols] &lt;&lt; s             # assign scalar to many elementsM[row_index, col_index] &lt;&lt; s                # assign scalar to single element                                            # (mask and accum not allowed)del M[row_index, col_index]                 # remove single element```## Apply```pythonM(mask, accum) &lt;&lt; A.apply(unaryop)M(mask, accum) &lt;&lt; A.apply(binaryop, left=s)   # bind-firstM(mask, accum) &lt;&lt; A.apply(binaryop, right=s)  # bind-second```## Reduce```pythonv(mask, accum) &lt;&lt; A.reduce_rowwise(op)      # reduce row-wisev(mask, accum) &lt;&lt; A.reduce_columnwise(op)   # reduce column-wises(accum) &lt;&lt; A.reduce_scalar(op)s(accum) &lt;&lt; v.reduce(op)```## Creating new Vectors / Matrices```pythonA = Matrix.new(dtype, num_rows, num_cols)   # new_typeB = A.dup()                                 # dupA = Matrix.from_values([row_indices], [col_indices], [values])  # build```## New from delayedDelayed objects can be used to create a new object using `.new()` method```pythonC = A.mxm(B, semiring).new()```## Properties```pythonsize = v.size                               # sizenrows = M.nrows                             # nrowsncols = M.ncols                             # ncolsnvals = M.nvals                             # nvalsrindices, cindices, vals = M.to_values()    # extractTuples```## InitializationThere is a mechanism to initialize `grblas` with a context prior to use. This allows for setting the backend touse as well as the blocking/non-blocking mode. If the context is not initialized, a default initialization willbe performed automatically.```pythonimport grblas as gb# Context initialization must happen before any other importsgb.init('suitesparse', blocking=True)# Now we can import other items from grblasfrom grblas import binary, semiringfrom grblas import Matrix, Vector, Scalar```## Performant User Defined Functions`grblas` requires `numba` which enables compiling user-defined Python functions to native C for use in GraphBLAS.Example customized UnaryOp:```pythonfrom grblas import unaryfrom grblas.operator import UnaryOpdef force_odd_func(x):    if x % 2 == 0:        return x + 1    return xUnaryOp.register_new('force_odd', force_odd_func)v = Vector.from_values([0, 1, 3], [1, 2, 3])w = v.apply(unary.force_odd).new()w  # indexes=[0, 1, 3], values=[1, 3, 3]```Similar methods exist for BinaryOp, Monoid, and Semiring.## Import/Export connectors to the Python ecosystem`grblas.io` contains functions for converting to and from:```pythonimport grblas as gb# numpy arrays# 1-D array becomes Vector, 2-D array becomes MatrixA = gb.io.from_numpy(m)m = gb.io.to_numpy(A)# scipy.sparse matricesA = gb.io.from_scipy_sparse_matrix(m)m = gb.io.to_scipy_sparse_matrix(m, format='csr')# networkx graphsA = gb.io.from_networkx(g)g = gb.io.to_networkx(A)```## AttributionThis library borrows some great ideas from [pygraphblas](https://github.com/michelp/pygraphblas),especially around parsing operator names from SuiteSparse and the concept of a Scalar which the backendimplementation doesn't need to know about.</longdescription>
</pkgmetadata>