<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Config![PyPI - Python Version](https://img.shields.io/pypi/pyversions/pythonic-config.svg?style=flat-square)[![Codecov](https://img.shields.io/codecov/c/github/PetrochukM/HParams/master.svg?style=flat-square)](https://codecov.io/gh/PetrochukM/HParams)[![Downloads](http://pepy.tech/badge/pythonic-config)](http://pepy.tech/project/pythonic-config)[![Build Status](https://img.shields.io/travis/PetrochukM/HParams/master.svg?style=flat-square)](https://travis-ci.com/PetrochukM/HParams)[![License: MIT](https://img.shields.io/badge/License-MIT-brightgreen.svg?style=flat-square)](https://opensource.org/licenses/MIT)[![Twitter: PetrochukM](https://img.shields.io/twitter/follow/MPetrochuk.svg?style=social)](https://twitter.com/MPetrochuk)This package allows you to configure functions explicitly and safely. You will be able to create anintuitive type-checked configuration file that directly sets function arguments, globally.This is a lightweight package with only two widely used dependencies and only a couple hundred lineof code.#### Contents- [Config](#config)      - [Contents](#contents)  - [Install](#install)  - [Usage ü§ó](#usage-)    - [Configuring a function](#configuring-a-function)    - [Writing a configuration file](#writing-a-configuration-file)    - [Configuring via the command line](#configuring-via-the-command-line)    - [Logging the configuration](#logging-the-configuration)    - [Advanced: Sharing configurations between processes](#advanced-sharing-configurations-between-processes)    - [Advanced: Ensuring the configuration is used](#advanced-ensuring-the-configuration-is-used)    - [Advanced: Find unused configurations](#advanced-find-unused-configurations)## InstallMake sure you have Python 3, then you can install `pythonic-config` using `pip`:```bashpip install pythonic-config```Install the latest code via:```bashpip install git+https://github.com/PetrochukM/Config.git```## Usage ü§ó### Configuring a functionAny function can be configured, and then used anywhere, see below:```pythonimport config as cf# Define functiondef do_something_cool(how_many_times: int):    pass# Configure functioncf.add({do_something_cool: cf.Args(how_many_times=5)})# Use the configured function anywhere! üéâdo_something_cool(how_many_times=cf.get())```This approach is simple but powerful. Now, each configuration can be directly attributed to adocumented function argument.Furthermore, `config` incorporates `typeguard` üíÇ‚ôÄÔ∏è so every configuration is type checked at runtime.### Writing a configuration fileThe simple example above can be extended to create a configuration file, for example:```pythonimport config as cfimport dataimport traincf.add({  data.get_data: cf.Args(      train_data_path=&quot;url_lists/all_train.txt&quot;,      val_data_path=&quot;url_lists/all_val.txt&quot;  ),  data.dataset_reader: cf.Args(      type_=&quot;cnn_dm&quot;,      source_max_tokens=1022,      target_max_tokens=54,  ),  train.make_model: cf.Args(type_=&quot;bart&quot;),  train.Trainer.make_optimizer: cf.Args(      type_=&quot;huggingface_adamw&quot;,      lr=3e-5,      correct_bias=True  )  train.Trainer.__init__: cf.Args(      num_epochs=3,      learning_rate_scheduler=&quot;polynomial_decay&quot;,      grad_norm=1.0,  )})```With this approach, this configuration file will make it clear which (hyper)parameters are set andwhere. This improves overall readability of the configuration file.üêç Last but not least, the configuration file is written in Python, you can use variables, lambdas,etc to further modularize.### Configuring via the command lineIn case you want to change one variable at a time, this package supports configuration from thecommand line, for example:```consolepython example.py --sorted='Args(reverse=True)'``````pythonimport sysimport config as cfcf.add(cf.parse_cli_args(sys.argv[1:]))```### Logging the configurationLastly, it's useful to track the configuration file by logging it. This package supports thatvia `config.log`. In the example below, we log the configuration to[Comet](https://www.comet.ml/).```pythonfrom comet_ml import Experimentimport config as cfexperiment = Experiment()experiment.log_parameters(cf.log())```### Advanced: Sharing configurations between processesIn multiprocessing, it may be useful to share the configuration file between processes. In thiscase, the configuration can be exported to another process and then subsequently imported, seebelow:```pythonfrom multiprocessing import Processimport config as cfdef handler(configs: cf.Config):    cf.add(configs)if __name__ == &quot;__main__&quot;:    process = Process(target=handler, args=(cf.export(),))    process.start()    process.join()```### Advanced: Ensuring the configuration is usedIn a large code base, it might be hard to tell if the configuration has been set for every functioncall. In this case, we've exposed `config.trace` which can double check every function callagainst the configuration, see below:```pythonimport sysimport config as cfdef configured(a=111):    passsys.settrace(cf.trace)cf.add({configured: cf.Args(a=1)})configured()  # `cf.trace` issues a WARNING!configured(a=cf.get())```We also have another option for faster tracing with `config.enable_fast_trace`. Instead of a systemwide trace, this traces the configured functions by modifying their code and inserting a tracefunction at the beginning of the function definition. This has a MUCH lower overhead; however, it isstill in beta due to the number of edge cases.### Advanced: Find unused configurationsIn a large code base, you may have a lot of configurations, some of which are no longer being used.`purge` can be run on a process exit, and it'll warn you if configurations were not used.```pythonimport atexitimport config as cfatexit.register(cf.purge)```</longdescription>
</pkgmetadata>