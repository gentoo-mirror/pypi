<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># PurposeThis package was created to aid with the designing process of mechanisms involving linkages, cams, and gears. In regardto linkages, it is capable of implementing a kinematic analysis with the knowledge of the degrees of freedom for thevectors that make up the mechanism. With the aid of numerical solving and iteration, the position, velocity, andacceleration of these vectors and points may be acquired.In regard to cams, this package is capable of supplying coordinates of a cam profile, plotting SVAJ diagrams, andgetting a cam and follower animation for roller and flat faced followers. In turn, the coordinates may be supplied to amachinist or imported into SolidWorks. All that is needed to know is the motion description (i.e. rise 2 inches in 1second, dwell for 1.5 seconds, fall 2 inches in 3 seconds). As of right now, the kinds of motion supported arenaive/uniform motion (how the cam shouldn't be designed), harmonic motion, and cycloidal motion. It is possible thatthis gets updated in the future with better options such as modified sinusoidal motion.For gears, this package is capable of providing the coordinates of a spur gear tooth profile given a set of properties.The analysis is based on the diametral pitch, number of teeth, and pitch diameter if desired over the number of teeth.An argument for AGMA standards may be set to `True` if desired.Install this package via pip: `pip install mechanism`.# Results/Examples`fourbarlinkage.py`![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fourbarlinkage.gif)`fivebarlinkage.py`![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fivebarlinkage.gif)`crunode_coupler.py`![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/crunode_coupler.gif)`crankslider.py`![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/crankslider.gif)`engine.py`![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/engine.gif)`non_grashof.py`![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/non_grashof.gif)`offset_crankslider.py`![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/offset_crankslider.gif)`cam2_example.py`![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/cam2.gif)# Linkages, Cranks, Couplers, and RockersIn order to use the contents of `mechanism.py`, a basic knowledge of vector loops must be known. The structure of thevector loops function is shown in several files under the `examples` folder. To gain a greater understanding of thispackage's usage, this walk through is provided.## Four Bar Linkage Example![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fourbarlinkage.PNG)A four bar linkage is the basic building block of all mechanisms. This is similar to how the triangle is the basicbuilding block of all structures. What defines a mechanism or structure is the system's overall number of degrees offreedom, and the number of degrees of freedom is determined via Kutzbachâ€™s equation.![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fourbarlinkage_dof.PNG)Kutzbach's equation is: *total degrees of freedom = 3(#links - 1) - 2(J1) - J2* where J1 is the number of full joints(also known as a revolute joint) and J2 is the number of half joints. For this four bar linkage, there are 4 fulljoints.The number of degrees of freedom is: 3(4 - 1) - 2(4) = 1This means that we need one known input to find the unknowns of the system. This can be explained further with a diagramof the vectors that make up the four bar linkage.![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fourbarlinkage_loop.PNG)From the above image, the vector &quot;a&quot; is the crank. The speed at which it rotates will be considered as the input to thesystem, and thus, it is the defining parameter to the system.The lengths of all the vectors are known. The only two unknowns are the angle that corresponds to vector &quot;b&quot; and &quot;d&quot;. Itis important to note that the objects that make up this package are vectors, and the polar form of the vectors is themain interest.There is only one loop equation which provides two equations when breaking down the vectors into its components. Withtwo equations and two unknowns, this system becomes solvable.### Problem StatementConsider the four bar linkage shown above. The lengths of a, b, c, and d are 5&quot;, 8&quot;, 8&quot; and 9&quot;. The crank (a) rotates ata constant 500 RPM. Use `mechanism` to get an animation of this linkage system and plot the angles, angular velocity,and angular acceleration of vector d as a function of time.### SolutionThe four bar linkage is a grashof linkage because it satisfies the grashof condition (9 + 5 &lt; 8 + 8). This means thatthe crank is able to fully rotate. The input can be deduced by integrating and differentiating the constant value of theconstant angular velocity of the crank.Always begin with defining the joints and vectors.```pythonfrom mechanism import *import numpy as npimport matplotlib.pyplot as plt# Declare the joints that make up the system.O, A, B, C = get_joints('O A B C')# Declare the vectors and keep in mind that angles are in radians and start from the positive x-axis.a = Vector((O, A), r=5)b = Vector((A, B), r=8)c = Vector((O, C), r=8, theta=0, style='ground')d = Vector((C, B), r=9)```Always define the vectors in the polar form. The first argument is the joints, and the first joint is the tail of thevector, and the second is the head. Additionally, extra keyword arguments will be passed to plt.plot() for styling.By not defining the angles for a vector (like `a`, `b`, and `c`) you are saying that this vector will have a varyingangle and the same is true for the length argument (`r`). If both the length and the angle are defined, as with `c`,then the vector is stationary and will remain at this length and angle. If niether `r` or `theta` is specified, then youare saying that the vector changes in length and angle, so you should expect two degrees of freedom for the input ofthis vector in the vector loop equations. There should be half as many loop equations as there are unknown. The inputvector &quot;a&quot; does not need to have its known values at its declaration. Instead, it's values will be accounted for in theloop equation. The next thing to do is to define the known input and guesses for the first iteration of the unknownvalues.```python# Define the known input to the system.# For a 500 RMP crank, the time it takes to rotate one rev is 0.12stime = np.linspace(0, 0.12, 300)angular_velocity = 50*np.pi/3  # This is 500 RPM in rad/stheta = angular_velocity*time  # Integrate to find the thetaomega = np.full((time.size,), angular_velocity)  # Just an array of the same angular velocityalpha = np.zeros(time.size)# Guess the unknownspos_guess = np.deg2rad([45, 90])vel_guess = np.array([1000, 1000])acc_guess = np.array([1000, 1000])```The guess values need to be arrays of the same length as the number of unknowns. These arrays will be passed as thefirst iteration. The next thing to do is to define the loop function and create the mechanism object.```python# Define the loop equation(s)def loop(x, i):    return a(i) + b(x[0]) - c() - d(x[1])# Create the mechanism objectmechanism = Mechanism(vectors=(a, b, c, d), origin=O, loops=loop, pos=theta, vel=omega, acc=alpha,                      guess=(pos_guess, vel_guess, acc_guess))```This example is simpler than most others because there is only one loop equation. For multiple loop equations, it isimportant that the function returns a flattened array of the same length as there are unknown, and the indexing of thefirst array argument to the loop corresponds to the input guess values. The second argument is the input. It is stronglyencouraged to view the examples for the more rigorous structure of the loop function. The last thing to do is tocall `mechanism.iterate()`, which is necessary if the input from `pos`, `vel`, and `acc` are arrays. If they are notarrays, then it is assumed that the mechanism at an instant is desired. If this is the case, thencall `mechanism.calculate()` then call `mechanism.plot()` (see `plot_at_instant.py`).```python# Call mechanism.iterate() then get and show the animationmechanism.iterate()ani, fig_, ax_ = mechanism.get_animation()# Plot the angles, angular velocity, and angular acceleration of vector dfig, ax = plt.subplots(nrows=3, ncols=1)ax[0].plot(time, d.pos.thetas, color='maroon')ax[1].plot(time, d.vel.omegas, color='maroon')ax[2].plot(time, d.acc.alphas, color='maroon')ax[0].set_ylabel(r'$\theta$')ax[1].set_ylabel(r'$\omega$')ax[2].set_ylabel(r'$\alpha$')ax[2].set_xlabel(r'Time (s)')ax[0].set_title(r'Analysis of $\vec{d}$')for a in (ax[0], ax[1], ax[2]):    a.minorticks_on()    a.grid(which='both')fig.set_size_inches(7, 7)# fig.savefig('../images/analysis_d.png')plt.show()```This will produce the following output:![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fourbar_animation.gif)![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/analysis_d.png)# CamsThere are several kinds of motion types for a cam, but there is an important corollary when designing cams: *The jerkfunction must be finite across the entire interval (360 degrees)* (Robert Norton's *Design of Machinery*). Usually, thecycloidal motion type achieves this corollary, but it comes at a cost. It produces an acceleration and velocity that istypically higher than the other motion types. More motion types are to come later (hopefully).## Problem StatementDesign a cam using cycloidal motion that has the following motion description:* Dwell at zero displacement for 90 degrees* Rise 1 inch in 90 degrees* Dwell for 90 degrees* Fall 1 inch in 90 degreesThe cam's angular velocity is 2*pi radians per second. Show the SVAJ diagram as well as the cam's profile. Size the camfor a roller follower with a radius of 1/2&quot; with a maximum pressure angle of 30 degrees. Also size the cam for a flatfaced follower. Get an animation for both a roller/flat faced follower. Finally, save the coordinates of the profile toa text file and show the steps for creating a part in SolidWorks.## SolutionBegin by creating a cam object with the correct motion description.```pythonimport numpy as npfrom mechanism import Camimport matplotlib.pyplot as pltcam = Cam(motion=[    ('Dwell', 90),    ('Rise', 1, 90),    ('Dwell', 90),    ('Fall', 1, 90)], degrees=True, omega=2*np.pi)```The motion description is a list of tuples. Each tuple must contain 3 items for rising and falling and two items fordwelling. The first item of the tuple is a string equal to &quot;Rise&quot;, &quot;Fall&quot;, or &quot;Dwell&quot; (not case-sensitive). For rise andfall motion, the second item in the tuple is the distance at which the follower falls or rises. For dwelling, the seconditem in the tuple is either the time (in seconds) or angle (in degrees) for which the displacement remains constant. Thethird item in the tuple for rising and falling is equivalent to the second item for dwelling. If degrees is set to true,then the last item in each tuple is interpreted as the angle for which the action occurs. A manual input for the angularvelocity is then required if conducting further analysis via SVAJ.This is all that's required to call the following methods.```pythonfig1, ax1 = cam.plot(kind='all')fig2, ax2 = cam.svaj(kind='cycloidal')plt.show()```This produces the following:![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/displacement_plot.png)![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/svaj.png)Looking at the acceleration plot, there are no vertical lines. This means that there is no infinite derivative at anyinstant along the cam's profile; the jerk function is finite across each instant, making this an acceptable motion type.If a roller follower with a 1/2&quot; radius is desired, an analysis depending on the cam's radius of curvature and pressureangle can be conducted to determine the base circle of the cam.```pythonroller_analysis = cam.get_base_circle(kind='cycloidal', follower='roller', roller_radius=1/2, max_pressure_angle=30,                                      plot=True)fig3, ax3 = cam.profile(kind='cycloidal', base=roller_analysis['Rb'], show_base=True, roller_radius=1/2,                        show_pitch=True)plt.show()```Output:![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/pressure_angle.png)![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/roller_profile.png)For a flat faced follower, the radius of curvature at the point of contact should be positive (or greater than 0.25&quot;)for all theta. There is an option to return the base radius such that the radius of curvature of the cam's profile ispositive for all values of theta (this is the conservative approach).```pythonflat_analysis = cam.get_base_circle(kind='cycloidal', follower='flat', desired_min_rho=0.25)print(flat_analysis['Rb'])print(flat_analysis['Min Face Width'])fig4, ax4 = cam.profile(kind='cycloidal', base=flat_analysis['Rb'], show_base=True)plt.show()```Output:![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/flat_profile.png)The base circle radius was found to be 1.893&quot; and the minimum face width for the follower was found to be 2.55&quot;.To get the roller animation, call this:```pythonani, fig5, ax5, follower = cam.get_animation(kind='cycloidal', base=roller_analysis['Rb'], roller_radius=1/2, length=2,                                             width=3/8, inc=5)fig6, ax6 = follower.plot()plt.show()```Output:![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/cam_roller.gif)![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/roller_follower_displacement.png)The graph above shows the actual follower displacement due to the circle having to always be tangent to the surface ofthe cam. Note that as a result of this physical limitation, the follower will have higher magnitudes of velocity andacceleration.For the flat faced follower,```pythonani_flat, fig7, ax7, follower = cam.get_animation(kind='cycloidal', base=flat_analysis['Rb'], face_width=2.75, length=2,                                                  width=3/8, inc=5)fig8, ax8 = follower.plot()plt.show()```Output:![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/cam_flat.gif)![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/flat_follower_displacement.png)### Getting Coordinates into SolidWorksSave the coordinates to a text file.```pythoncam.save_coordinates('cam_coordinates.txt', kind='cycloidal', base=1.3, solidworks=True)```Select `Curve Through XYZ Points`![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/curve_xyz.png)The cam profile will always be extended to the front plane due to the manner in which SolidWorks defines the globalcoordinates. Next, select browse and choose the saved coordinate file, making sure that text files are able to be seen.![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/select_file.PNG)Create a sketch on the front plane. Select the curve and then convert entities. The sketch is now projected to the frontplane.![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/front_plane.PNG)Notice that the sketch is not closed. Add a line to close the sketch, then extrude the sketch.![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/solidworks_cam.PNG)# GearsTo use this feature, a knowledge of gear nomenclature must be known. Here is a figure from Robert Norton's *Design ofMachinery*:![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/gear_nomenclature.PNG)For gears, a general rule of thumb is that the base circle must fall below the dedendum circle because the curve belowbase circle cannot be an involute curve. This package will send a warning if this occurs, and if it is desired tocontinue, the curve below the circle is just a straight line, and undercutting will occur.For a reference, here are the AGMA (American Gear Manufacturers Association) standards from *Design of Machinery*:![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/agma.PNG)## Problem StatementDesign a gear that has a diametral pitch of 32 and has 60 teeth using `mechanism`. The gear follows the AGMA standards.Compare the gear to SolidWorks' gear from the tool library.## SolutionDefine a gear object with the known information and save the coordinates to a file.```pythonfrom mechanism import SpurGearimport matplotlib.pyplot as pltgear = SpurGear(N=60, pd=32, agma=True, size=500)fig, ax = gear.plot()fig.savefig('../images/gear60.PNG', dpi=240)plt.show()gear.save_coordinates(file='gear_tooth_coordinates.txt', solidworks=True)gear.rundown()```output:![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/gear60.PNG)| Property                 | Value    ||--------------------------|----------|| Number of Teeth (N)      | 60       || Diametral Pitch (pd)     | 32.00000 || Pitch Diameter (d)       | 1.87500  || Pitch Radius (r)         | 0.93750  || Pressure Angle (phi)     | 20.00000 || Base Radius              | 0.88096  || Addendum (a)             | 0.03125  || Dedendum (b)             | 0.03906  || Circular Tooth Thickness | 0.04846  || Circular Space Width     | 0.04971  || Circular Backlash        | 0.00125  |Keep in mind that the `size` argument refers to the size of the coordinates that make up the involute curve. The morepoints, the sharper it is, but SolidWorks sometimes struggles with points being too close together. To fix this issue,make the size smaller. The default value is 1000.### SolidWorks ResultsFollow the same steps to get the curve into SolidWorks from the cam example. Make sure that the units in SolidWorksmatches the units of the analysis.![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/gear60_compare.PNG)The results are a near identical match, and the addendum and dedendum fit perfectly. If analyzed closely, the onlydifference is the tooth thickness. The gray gear (the resulting gear from this package) has a slightly larger tooththickness compared to SolidWorks' gear. This is due to the fact that SolidWorks doesn't use an involute gear toothprofile, as gears from the SolidWorks toolbox are for visuals only. Instead, the tooth profile is circular. Their gearsshould not be used for manufacturing as this is not accurate at all. The purpose of the involute tooth profile is thatthe meshing of gears will always produce a constant angular velocity, even when the gears aren't perfectly placedtangent to the pitch circles.</longdescription>
</pkgmetadata>