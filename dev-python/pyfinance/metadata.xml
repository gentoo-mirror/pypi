<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pyfinancepyfinance is a Python package built for investment management and analysis of security returns.It is meant to be a complement to existing packages geared towards quantitative finance, such as [pyfolio](https://github.com/quantopian/pyfolio),[pandas-datareader](https://github.com/pydata/pandas-datareader), and [fecon235](https://github.com/rsvp/fecon235).&lt;table&gt;&lt;tr&gt;  &lt;td&gt;Supports&lt;/td&gt;  &lt;td&gt;Python 3.5 | 3.6 | 3.7 | 3.8 | 3.9&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;  &lt;td&gt;Latest Release&lt;/td&gt;  &lt;td&gt;    &lt;a href=&quot;https://pypi.org/project/pyfinance/&quot;&gt;    &lt;img src=&quot;https://img.shields.io/pypi/v/pyfinance.svg&quot; alt=&quot;latest release&quot; /&gt;    &lt;/a&gt;  &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;  &lt;td&gt;Package Status&lt;/td&gt;  &lt;td&gt;    &lt;a href=&quot;https://pypi.org/project/pyfinance/&quot;&gt;    &lt;img src=&quot;https://img.shields.io/pypi/status/pyfinance.svg&quot; alt=&quot;status&quot; /&gt;&lt;/td&gt;    &lt;/a&gt;&lt;/tr&gt;&lt;tr&gt;  &lt;td&gt;License&lt;/td&gt;  &lt;td&gt;    &lt;a href=&quot;https://github.com/bsolomon1124/pyfinance/blob/master/LICENSE&quot;&gt;    &lt;img src=&quot;https://img.shields.io/pypi/l/pyfinance.svg&quot; alt=&quot;license&quot; /&gt;    &lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;## Contentspyfinance is best explored on a module-by-module basis:| Module | Description || ------ | ----------- || `datasets.py`  | Financial dataset download &amp; assembly via `requests`. || `general.py`   | General-purpose financial computations, such as active share calculation, returns distribution approximation, and tracking error optimization. || `ols.py`       | Ordinary least-squares (OLS) regression, supporting static and rolling cases, built with a matrix formulation and implemented with NumPy. || `options.py`   | Vectorized option calculations, including Black-Scholes Merton European option valuation, Greeks, and implied volatility, as well as payoff determination for common money-spread option strategies. || `returns.py`   | Statistical analysis of financial time series through the CAPM framework, designed to mimic functionality of software such as FactSet Research Systems and Zephyr, with improved speed and flexibility. || `utils.py`     | Utilities not fitting into any of the above. |Please note that `returns` and `general` are still in development; they are not thoroughly tested and have some NotImplemented features.Installationpyfinance is available via [PyPI](https://pypi.python.org/pypi/pyfinance/).  Install with pip:```bash$ python3 -m install pyfinance```**Note**: pyfinance aims for compatibility with all minor releases of Python 3.x, but does not guarantee workability with Python 2.x.## Dependenciespyfinance relies primarily on Python's scientific stack, including NumPy, Pandas, Matplotlib, Seaborn, Scikit-Learn, and StatsModels.  Other dependencies include Beautiful Soup, Requests, xrld, and xmltodict.See `setup.py` for specific version threshold requirements.## TutorialThis is a walkthrough of some of pyfinance's features.The `returns.py` module is designed for statistical analysis of financial time series through the CAPM framework, designed to mimic functionality of software such as FactSet Research Systems and Zephyr, with improved speed and flexibility.Its main class is `TSeries`, a subclassed Pandas Series.  The DataFrame equivalent, `TFrame`, is not yet implemented as of March 2018.`TSeries` implements a collection of new methods that pertain specifically to investment management and the study of security returns and asset performance, such cumulative return indices and drawdown.Here's an example of construction:```python&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; from pyfinance import TSeries&gt;&gt;&gt; np.random.seed(444)# Normally distributed with 0.08% daily drift term.&gt;&gt;&gt; s = np.random.randn(400) / 100 + 0.0008&gt;&gt;&gt; idx = pd.date_range(start='2016', periods=len(s))  # default daily freq.&gt;&gt;&gt; ts = TSeries(s, index=idx)&gt;&gt;&gt; ts.head()2016-01-01    0.00442016-01-02    0.00462016-01-03    0.01462016-01-04    0.01262016-01-05   -0.0086Freq: D, dtype: float64```And a few &quot;new&quot; methods:```python&gt;&gt;&gt; ts.max_drawdown()-0.12374551561531844# Downsample to quarterly compounded returns.&gt;&gt;&gt; ts.rollup('Q')2016-03-31    0.04502016-06-30    0.12402016-09-30    0.06312016-12-31   -0.00812017-03-31    0.1925Freq: Q-DEC, dtype: float64&gt;&gt;&gt; ts.anlzd_stdev()0.16318780660107757&gt;&gt;&gt; ts.sharpe_ratio(ddof=1)2.501797257311737```Some statistics are benchmark-relative.  For methods that take a `benchmark` parameter, `benchmark` can be either another `TSeries`, a Pandas Series, a 1d NumPy array.```python&gt;&gt;&gt; bmk = TSeries(np.random.randn(400) / 100 + .0005,...               index=ts.index)&gt;&gt;&gt; ts.beta_adj(bmk)0.3176455956603447&gt;&gt;&gt; ts.tracking_error(benchmark=bmk)0.23506660057562254```With CAPM-related statistics such as alpha, beta, and R-squared, it can also be a Pandas DataFrame or 2d NumPy array.```python&gt;&gt;&gt; multi_bmk = pd.DataFrame(np.random.randn(400, 2) / 100 + .0005,...                          index=ts.index)&gt;&gt;&gt; # Multifactor model support.&gt;&gt;&gt; ts.alpha(multi_bmk)0.0010849614688207107````TSeries` comes with just one additional and optional argument that must be as a keyword argument: `freq` (default `None`) allows for manual specification of the time-series frequency.  It may be any frequency string or anchored offset string recognized by Pandas, such as 'D', '5D', 'Q', 'Q-DEC', or 'BQS-APR'.```python&gt;&gt;&gt; # This is okay as long as a frequency can be inferred.&gt;&gt;&gt; ts.freq is NoneTrue```The purpose of this extra parameter is to create an annualization factor for statistics that are given on an annualized basis, such as standard deviation.If no frequency is passed explicitly, pyfinance will attempt to infer an annualization factor from the Index, with an exception being raised if neither of these yield a frequency.```python&gt;&gt;&gt; no_idx = TSeries(np.random.laplace(size=24) * .01 + .005,                     freq='M')&gt;&gt;&gt; no_idx.freq'M'&gt;&gt;&gt; no_idx.anlzd_ret()0.04975219957136123````freq` can also be passed within some methods, which will override the class instance's `.freq` if it exists:```python&gt;&gt;&gt; no_idx.anlzd_ret(freq='W')  # Treat `no_idx` as weekly returns.0.2341731795205313````datasets.py` provides for financial dataset download &amp; assembly via `requests`.  It leverages sources including:- Ken French's data library (via `pandas-datareader`);- SEC.gov;- cboe.com;- AQR's dataset page;- fred.stlouisfed.org;- Robert Shiller's page at econ.yale.edu.Below is a batch of examples.Load SEC 13F filings:```python# Third Point LLC June 2017 13F&gt;&gt;&gt; from pyfinance import datasets&gt;&gt;&gt; url = 'https://www.sec.gov/Archives/edgar/data/1040273/000108514617001787/form13fInfoTable.xml'  # noqa&gt;&gt;&gt; df = datasets.load_13f(url=url)&gt;&gt;&gt; df.head()          nameOfIssuer   titleOfClass      cusip   value  votingAuthority0  ALEXION PHARMACE...            COM  015351109  152088          12500001  ALIBABA GROUP HL...  SPONSORED ADS  01609W102  634050          45000002         ALPHABET INC   CAP STK CL A  02079K305  534566           5750003           ANTHEM INC            COM  036752103  235162          12500004       BANCO MACRO SA     SPON ADR B  05961W105   82971           900000```Industry-portfolio monthly returns:```python&gt;&gt;&gt; from pyfinance import datasets&gt;&gt;&gt; ind = datasets.load_industries()&gt;&gt;&gt; ind.keys()dict_keys([5, 10, 12, 17, 30, 38, 48])# Monthly returns to 5 industry portfolios&gt;&gt;&gt; ind[5].head()            Cnsmr  Manuf  HiTec  Hlth   OtherDate1950-01-31   1.26   1.47   3.21   1.06   3.191950-02-28   1.91   1.29   2.06   1.92   1.021950-03-31   0.28   1.93   3.46  -2.90  -0.681950-04-30   3.22   5.21   3.58   5.52   1.501950-05-31   3.81   6.18   1.07   3.96   1.36```S&amp;P 500 and interest rate data from Robert Shiller's website, 1871-present:```python&gt;&gt;&gt; from pyfinance import datasets&gt;&gt;&gt; shiller = datasets.load_shiller()&gt;&gt;&gt; shiller.iloc[:7, :5]            sp50p  sp50d  sp50e      cpi  real_ratedate1871-01-31   4.44   0.26    0.4  12.4641     5.32001871-02-28   4.50   0.26    0.4  12.8446     5.32331871-03-31   4.61   0.26    0.4  13.0350     5.32671871-04-30   4.74   0.26    0.4  12.5592     5.33001871-05-31   4.86   0.26    0.4  12.2738     5.33331871-06-30   4.82   0.26    0.4  12.0835     5.33671871-07-31   4.73   0.26    0.4  12.0835     5.3400```The `ols.py` module provides ordinary least-squares (OLS) regression, supporting static and rolling cases, and is built with a matrix formulation and implemented with NumPy.First, let's load some data on currencies, interest rates, and commodities to generate a regression of changes in the trade-weighted USD against interest rate term spreads and copper.```python&gt;&gt;&gt; from pandas_datareader import DataReader&gt;&gt;&gt; syms = {...     'TWEXBMTH': 'usd',...     'T10Y2YM': 'term_spread',...     'PCOPPUSDM': 'copper'...     }&gt;&gt;&gt; data = DataReader(syms.keys(), data_source='fred',...                   start='2000-01-01', end='2016-12-31')\...     .pct_change()\...     .dropna()\...     .rename(columns=syms)&gt;&gt;&gt; y = data.pop('usd')&gt;&gt;&gt; data.head()            term_spread  copperDATE2000-02-01      -1.4091 -0.02002000-03-01       2.0000 -0.03722000-04-01       0.5185 -0.03332000-05-01      -0.0976  0.06142000-06-01       0.0270 -0.0185&gt;&gt;&gt; y.head()DATE2000-02-01    0.01262000-03-01   -0.00012000-04-01    0.00562000-05-01    0.02202000-06-01   -0.0101```The `OLS` class implements &quot;static&quot; (single) linear regression, with the model being fit when the object is instantiated.It is designed primarily for statistical inference, not out-of-sample prediction, and its attributes largely mimic the structure of StatsModels' [RegressionResultsWrapper](http://www.statsmodels.org/dev/generated/statsmodels.regression.linear_model.RegressionResults.html).```python&gt;&gt;&gt; from pyfinance import ols&gt;&gt;&gt; model = ols.OLS(y=y, x=data)&gt;&gt;&gt; model.alpha  # the intercept - a scalar0.0012303204434167458&gt;&gt;&gt; model.beta  # the coefficientsarray([-0.0006, -0.0949])&gt;&gt;&gt; model.fstat33.42923069295481# Residuals and predicted y values are NumPy arrays# with the same shape as `y`.&gt;&gt;&gt; model.resids.shape(203,)&gt;&gt;&gt; model.predicted.shape(203,)```The module also supports rolling regression.  (Iterative regressions done on sliding windows over the data.)- `RollingOLS` has methods that generate NumPy arrays as outputs.- `PandasRollingOLS` is a wrapper around `RollingOLS` and is meant to mimic the look of Pandas's deprecated `MovingOLS` class.  It generates Pandas DataFrame and Series outputs.**Note**: all solutions are generated through a matrix formulation, which takes advantage of NumPy's broadcasting capabilities to expand the classical [matrix formulation](https://onlinecourses.science.psu.edu/stat501/node/382) to an additional dimension.  This approach may be slow for significantly large datasets.Also, note that windows are not &quot;time-aware&quot; in the way that Pandas time functionality is.  Because of the NumPy implementation, specifying a window of 12 where the index contains one missing months would generate a regression over 13 months.  To avoid this, simply reindex the input data to a set frequency.```python# 12-month rolling regressions# First entry would be the &quot;12 months ending&quot; 2001-01-30&gt;&gt;&gt; rolling = ols.PandasRollingOLS(y=y, x=data, window=12)&gt;&gt;&gt; rolling.beta.head()            term_spread  copperDATE2001-01-01   9.9127e-05  0.05562001-02-01   4.7607e-04  0.06272001-03-01   1.4671e-03  0.03572001-04-01   1.6101e-03  0.02962001-05-01   1.5839e-03 -0.0449&gt;&gt;&gt; rolling.alpha.head()DATE2001-01-01    0.00552001-02-01    0.00502001-03-01    0.00672001-04-01    0.00702001-05-01    0.0048&gt;&gt;&gt; rolling.pvalue_alpha.head()DATE2001-01-01    0.09962001-02-01    0.11012001-03-01    0.05552001-04-01    0.04792001-05-01    0.1020````options.py` is built for vectorized options calculations.`BSM` encapsulates a European option and its associated value, Greeks, and implied volatility, using the Black-Scholes Merton model.```python&gt;&gt;&gt; from pyfinance.options import BSM&gt;&gt;&gt; op = BSM(S0=100, K=100, T=1, r=.04, sigma=.2)&gt;&gt;&gt; op.summary()OrderedDict([('Value', 9.925053717274437),             ('d1', 0.3),             ('d2', 0.09999999999999998),             ('Delta', 0.6179114221889526),             ('Gamma', 0.019069390773026208),             ('Vega', 38.138781546052414),             ('Theta', -5.888521694670074),             ('Rho', 51.86608850162082),             ('Omega', 6.225774084360724)])# What is the implied annualized volatility at P=10?&gt;&gt;&gt; op.implied_vol(value=10)0.20196480875586834# Vectorized - pass an array of strikes.&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; ops = BSM(S0=100, K=np.arange(100, 110), T=1, r=.04, sigma=.2)&gt;&gt;&gt; ops.value()array([9.9251, 9.4159, 8.9257, 8.4543, 8.0015, 7.567 , 7.1506, 6.7519,       6.3706, 6.0064])# Multiple array inputs are evaluated elementwise/zipped.&gt;&gt;&gt; ops2 = BSM(S0=np.arange(100, 110), K=np.arange(100, 110),...            T=1, r=.04, sigma=.2)&gt;&gt;&gt; ops2BSM(kind=call,    S0=[100 101 102 103 104 105 106 107 108 109],    K=[100 101 102 103 104 105 106 107 108 109],    T=1,    r=0.04,    sigma=0.2)&gt;&gt;&gt; ops2.value()array([ 9.9251, 10.0243, 10.1236, 10.2228, 10.3221, 10.4213, 10.5206,       10.6198, 10.7191, 10.8183])````options.py` also exports a handful of options *strategies*, such as `Straddle`, `Straddle`, `Strangle`, `BullSpread`, and `ShortButterfly`, to name a few.All of these inherit from a generic and customizable `OpStrat` class, which can be built from an arbitrary number of puts and/or calls.Here is an example of constructing a bear spread, which is a combination of 2 puts or 2 calls (*put* is the default).  Here, we are short a put at 1950 and long a put at 2050.  Like the case of a single option, the instance methods are vectorized, so we can compute payoff and profit across a vector or grid:```python&gt;&gt;&gt; from pyfinance import options as op&gt;&gt;&gt; spread = op.BearSpread(St=np.array([2100, 2000, 1900]),...                        K1=1950., K2=2050.,...                        price1=56.01, price2=107.39)&gt;&gt;&gt; spread.payoff()array([  0.,  50., 100.])&gt;&gt;&gt; spread.profit()array([-51.38,  -1.38,  48.62])```The `utils.py` module contains odds-and-ends utilities.```python&gt;&gt;&gt; from pyfinance import utils# Generate 7 unique 5-letter mutual fund tickers&gt;&gt;&gt; utils.random_tickers(length=5, n_tickers=7, endswith='X')['JXNQX', 'DPTJX', 'WAKOX', 'DZIHX', 'MDYXX', 'HSKWX', 'IDMZX']# Same for ETFs&gt;&gt;&gt; utils.random_tickers(3, 8)['FIS', 'FNN', 'FZC', 'PWV', 'PBA', 'RDG', 'BKY', 'CDW']# Five-asset portfolio leveraged 1.5x.&gt;&gt;&gt; utils.random_weights(size=5, sumto=1.5)array([0.3263, 0.1763, 0.4703, 0.4722, 0.0549])# Two 7-asset portfolios leverage 1.0x and 1.5x, respectively.&gt;&gt;&gt; utils.random_weights(size=(2, 7), sumto=[1., 1.5])array([[0.1418, 0.2007, 0.0255, 0.2575, 0.0929, 0.2272, 0.0544],       [0.3041, 0.109 , 0.2561, 0.2458, 0.3001, 0.0333, 0.2516]])&gt;&gt;&gt; utils.random_weights(size=(2, 7), sumto=[1., 1.5]).sum(axis=1)array([1. , 1.5])# Convert Pandas offset alises to periods per year.&gt;&gt;&gt; from pyfinance import utils&gt;&gt;&gt; utils.get_anlz_factor('M')12.0&gt;&gt;&gt; utils.get_anlz_factor('BQS-DEC')4.0```## APIFor in-depth call syntaxes, see the source docstrings.</longdescription>
</pkgmetadata>