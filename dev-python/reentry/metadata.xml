<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://github.com/aiidateam/reentry/workflows/ci/badge.svg    :target: https://github.com/aiidateam/reentry/actions.. image:: https://codecov.io/gh/aiidateam/reentry/branch/develop/graph/badge.svg   :target: https://codecov.io/gh/aiidateam/reentry=======Reentry=======A plugin manager based on setuptools entry points with 10x the speedArchival notice----------------Python 3.8 saw the introduction of `importlib.metadata &lt;https://docs.python.org/3/library/importlib.metadata.html&gt;`_ into the Python standard library.It is both fast to ``import importlib.metadata`` and fast to scan for entry points using the ``entry_points()`` function.The separate `importlib-metadata &lt;https://pypi.org/project/importlib-metadata/&gt;`_ package backports this functionality to python &gt;=3.6, and as of version 4.6.3 (or earlier), scanning is even faster than with the standard library.Below are timings recorded on a MacBook Air M1 (2020) in a python 3.9.1 conda environment with 248 packages installed (~30 of which register entry points).``pkg_resources``: ~147 msec in total::    $ python -mtimeit -n1 -r1 'import pkg_resources'    1 loop, best of 1: 146 msec per loop    $ python -mtimeit -s 'import pkg_resources as pkg' 'pkg.iter_entry_points(&quot;aiida.calculations&quot;)'    500000 loops, best of 5: 435 nsec per loop``importlib.metadata``: ~39 msec in total::    $ python -mtimeit -n1 -r1 'import importlib.metadata'    1 loop, best of 1: 17.8 msec per loop    $ python -mtimeit -s 'import importlib.metadata as im' 'im.entry_points()'    50 loops, best of 5: 21.4 msec per loop``importlib-metadata`` package (v4.6.3): ~40 msec in total::    $ python -mtimeit -n1 -r1 'import importlib_metadata'    1 loop, best of 1: 33.8 msec per loop    $ python -mtimeit -s 'import importlib_metadata as im' 'im.entry_points()'    50 loops, best of 5: 5.94 msec per loop``reentry`` (v1.3.1): 25 msec in total::    $ python -mtimeit -n1 -r1 'import reentry'    1 loop, best of 1: 23.8 msec per loop    $ python -mtimeit  -s 'from reentry.default_manager import PluginManager as p' 'p().get_entry_map()'    200 loops, best of 5: 1.07 msec per loopThe advent of faster (solid-state) disks, together with the faster importlib implementations have led to a substantial reduction of the speed benefit that ``reentry`` provided (down to ~15 ms or ~40% in the benchmark above).While there may still be certain edge cases where ``reentry`` is useful, we will stop using it going forward and are thus archiving this repository.Users interested in continuing the maintenance of ``reentry`` are encouraged to open an issue on the issue tracker. Features--------* finding plugins: reentry keeps a map of entry points in a file* speed: reentry provides an EntryPoint implementation that trades extra checks for search and load speed* automatic registering: use ``reentry_register: True`` in your ``setup.py`` to automatically register pluginsNote that ``reentry_register`` creates a *build-time*dependency on ``reentry``. The suggested way to resolve that is using themethod described in `PEP518 &lt;https://www.python.org/dev/peps/pep-0518/&gt;`_, forwhich `support has been added in pip 10 &lt;https://pip.pypa.io/en/latest/reference/pip/#pep-518-support&gt;`_:next to ``setup.py``, put a file ``pyproject.toml`` containing::   [build-system]   # Minimum requirements for the build system to execute.   requires = [&quot;setuptools&quot;, &quot;wheel&quot;, &quot;reentry&quot;]An alternative way for specifying a build dependency is to put::   setup(      ...      setup_requires=[reentry],      ...   )in your ``setup.py``.This alternative works with all versions of ``pip``, but fails on systems,where python is linked to old ``SSL`` libraries (such as the system python forsome versions of OS X).Limitations-----------* entry points with extra dependencies (``name = module_name:attrs [extras]``)  are still supported. Trying to load them, however, will lead to importing ``pkg_resources`` and  forego the speedup.Quickstart----------Use the following in your plugins's ``setup.py``::   setup(      ...      setup_requires=['reentry'],      reentry_register=True,      entry_points={         'my_plugins': ['this_plugin = this_package.subpackage:member'],         ...      }And iterate over installed plugin from the host package::   from reentry import manager   available_plugins = manager.iter_entry_points(group='my_plugins')   for plugin in available_plugins:      plugin_object = plugin.load()      plugin_object.use()The syntax is consistent with ``setuptools``'s ``pkg_resources``, so you may use it as a fallback::   try:      from reentry import manager as entry_pt_manager   except:      import pkg_resources as entry_pt_manager   entry_pt_manager.iter_entry_points(...)   ...Reentry Configuration---------------------Reentry supports getting information from a configuration file. The file willbe searched at the following paths:* &lt;HOME&gt;/.reentryrc* &lt;HOME&gt;/.config/reentry/configThe configuration file has an ``ini`` format and supports the following keys::   [general]   datadir=/path/to/data/dir   data_filename=nameThe ``datadir`` is the folder in which ``reentry`` stores the data filethat contains the information about the registered entry points.If the config file doesn't exist in one of the above paths, the ``datadir`` isset to ``&lt;HOME&gt;/.config/reentry/data``.``data_filename`` is the name of the data file, in case you want to pick thename by your own instead of letting ``reentry`` choose it.Warning: By default, ``reentry`` creates a separate data file for every pythoninterpreter in order not to mix entry points between different pythonenvironments on your system. Setting a ``data_filename`` in the configurationfile tells ``reentry`` to *always* use this data file and may result inunexpected behavior if you use ``reentry`` in multiple python environments.You can also set configuration options for ``reentry`` via environmentvariables:* ``datadir`` can be defined by ``REENTRY_DATADIR``.* ``data_filename`` can be defined by ``REENTRY_DATA_FILENAME``.Environment variables take precedence over the configuration file.What for?---------To make entry points usable for plugins in time-critical situations such ascommand line interfaces!Setuptool's entry point system is convenient to use for plugin-basedpython applications. It allows separate python packages to act as pluginsto a host package (or to each other), making it easy for the host to find anditerate over the relevant data structures from plugins.However, the time spent on importing `setuptools` scales badly with thenumber of installed distributions and can easily reach 0.5 seconds formoderately complex environments.Finding and loading of plugins can be time-critical, for example in commandline tools that need to load subcommands, where 100 ms are a noticeable delay.Importing setuptools's `pkg_resources` takes time, because it verifies thatdependencies are installed correctly for all distributions present in theenvironment. This allows entry points to have additional dependencies or&quot;extras&quot; (``entry_point = module_name:attrs [extras]``).Reentry forgoes this dependency check for entry points without 'extras'and thereby manages to be fast and scale better with the numberof plugins installed.Standalone Manager Usage------------------------Sometimes it might be necessary to update the cached entry points, for example* after uninstalling a plugin (there are no uninstall hooks by setuptools at the moment)* after installing a plugin that does not use install hooks* while developing a plugin / plugin hostfor those cases reentry has a commandline interface::   $ reentry --help   Usage: reentry [OPTIONS] COMMAND [ARGS]...     manage your reentry python entry point cache   Options:     --help  Show this message and exit.   Commands:     clear  Clear entry point map.     dev    Development related commands.     map    Print out a map of cached entry points     scan   Scan for python entry points to cache for faster loading.::   $ reentry scan --help   Usage: reentry scan [OPTIONS] PATTERN      Scan for python entry points to cache for faster loading.      Scan only for specific PATTERNs or leave empty to scan all   Options:      -r, --regex  Treat PATTERNs as regular expresions      --help       Show this message and exit.::   $ reentry map --help   Usage: reentry map [OPTIONS]   Options:     --dist TEXT   limit map to a distribution     --group TEXT  limit map to an entry point group     --name TEXT   limit map to entrypoints that match NAME     --help        Show this message and exit.Note: Where needed (e.g. in jupyter notebooks), these operations also beperformed in python using the reentry ``manager``, e.g.::   from reentry import manager   manager.scan()CLI Example-----------Reentry provides a drop-in replacement for iter_entry_points::   import click   from click_plugins import with_plugins   from reentry.manager import iter_entry_points   @with_plugins(iter_entry_points('cli_plugins'))   @click.group()   def cli():      &quot;&quot;&quot;      command with subcommands loaded from plugin entry points      &quot;&quot;&quot;For this to work, reentry has to be installed and must have been used toscan for entry points in the 'cli_plugins' group once.Development -----------Running the tests::    toxCreating a release::    tox -e py39-release</longdescription>
</pkgmetadata>