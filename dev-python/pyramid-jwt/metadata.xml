<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>JWT authentication for Pyramid==============================This package implements an authentication policy for Pyramid that using  `JSONWeb Tokens &lt;http://jwt.io/&gt;`_. This standard (`RFC 7519&lt;https://tools.ietf.org/html/rfc7519&gt;`_) is often used to secure backend APIs.The excellent `PyJWT &lt;https://pyjwt.readthedocs.org/en/latest/&gt;`_ library isused for the JWT encoding / decoding logic.Enabling JWT support in a Pyramid application is very simple:.. code-block:: python   from pyramid.config import Configurator   from pyramid.authorization import ACLAuthorizationPolicy   def main():       config = Configurator()       # Pyramid requires an authorization policy to be active.       config.set_authorization_policy(ACLAuthorizationPolicy())       # Enable JWT authentication.       config.include('pyramid_jwt')       config.set_jwt_authentication_policy('secret')This will set a JWT authentication policy using the `Authorization` HTTP headerwith a `JWT` scheme to retrieve tokens. Using another HTTP header is trivial:.. code-block:: python    config.set_jwt_authentication_policy('secret', http_header='X-My-Header')If your application needs to decode tokens which contain an `Audience &lt;http://pyjwt.readthedocs.io/en/latest/usage.html?highlight=decode#audience-claim-aud&gt;`_ claim you can extend this with:.. code-block:: python    config.set_jwt_authentication_policy('secret',                                        auth_type='Bearer',                                        callback=add_role_principals,                                        audience=&quot;example.org&quot;)To make creating valid tokens easier a new ``create_jwt_token`` method isadded to the request. You can use this in your view to create tokens. A simpleauthentication view for a REST backend could look something like this:.. code-block:: python    @view_config('login', request_method='POST', renderer='json')    def login(request):        login = request.POST['login']        password = request.POST['password']        user_id = authenticate(login, password)  # You will need to implement this.        if user_id:            return {                'result': 'ok',                'token': request.create_jwt_token(user_id)            }        else:            return {                'result': 'error'            }Unless you are using JWT cookies within cookies (see the next section), thestandard ``remember()`` and ``forget()`` functions from Pyramid are not useful.Trying to use them while regular (header-based) JWT authentication is enabledwill result in a warning.Using JWT inside cookies------------------------Optionally, you can use cookies as a transport for the JWT Cookies. This is anuseful technique to allow browser-based web apps to consume your REST APIswithout the hassle of managing token storage (where to store JWT cookies is aknown-issue), since ``http_only`` cookies cannot be handled by Javascriptrunning on the pageUsing JWT within cookies have some added benefits, the first one being *slidingsessions*: Tokens inside cookies will automatically be reissued whenever``reissue_time`` is past... code-block:: python   from pyramid.config import Configurator   from pyramid.authorization import ACLAuthorizationPolicy   def main():       config = Configurator()       # Pyramid requires an authorization policy to be active.       config.set_authorization_policy(ACLAuthorizationPolicy())       # Enable JWT authentication.       config.include('pyramid_jwt')       config.set_jwt_cookie_authentication_policy(           'secret', reissue_time=7200       )When working with JWT alone, there's no standard for manually invalidating atoken: Either the token validity expires, or the application needs to handle atoken blacklist (or even better, a whitelist)On the other hand, when using cookies, this library allows the app to *logout*a given user by erasing its cookie: This policy follows the standard cookiedeletion mechanism respected by most browsers, so a call to Pyramid's``forget()`` function will instruct the browser remove that cookie, effectivelythrowing that JWT token away, even though it may still be valid.See `Creating a JWT within a cookie`_ for examples.Extra claims------------Normally pyramid_jwt only makes a single JWT claim: the *subject* (or``sub`` claim) is set to the principal. You can also add extra claims to thetoken by passing keyword parameters to the ``create_jwt_token`` method... code-block:: python   token = request.create_jwt_token(user.id,       name=user.name,       admin=(user.role == 'admin'))All claims found in a JWT token can be accessed through the ``jwt_claims``dictionary property on a request. For the above example you can retrieve thename and admin-status for the user directly from the request:.. code-block:: python   print('User id: %d' % request.authenticated_userid)   print('Users name: %s', request.jwt_claims['name'])   if request.jwt_claims['admin']:      print('This user is an admin!')Keep in mind that data ``jwt_claims`` only reflects the claims from a JWTtoken and do not check if the user is valid: the callback configured for theauthentication policy is *not* checked. For this reason you should always use``request.authenticated_userid`` instead of ``request.jwt_claims['sub']``.You can also use extra claims to manage extra principals for users. For exampleyou could claims to represent add group membership or roles for a user. Thisrequires two steps: first add the extra claims to the JWT token as shown above,and then use the authentication policy's callback hook to turn the extra claiminto principals. Here is a quick example:.. code-block:: python   def add_role_principals(userid, request):      return ['role:%s' % role for role in request.jwt_claims.get('roles', [])]   config.set_jwt_authentication_policy(callback=add_role_principals)You can then use the role principals in an ACL:.. code-block:: python   class MyView:       __acl__ = [           (Allow, Everyone, ['read']),           (Allow, 'role:admin', ['create', 'update']),       ]Validation Example------------------After creating and returning the token through your API with``create_jwt_token`` you can test by issuing an HTTP authorization header typefor JWT... code-block:: text   GET /resource HTTP/1.1   Host: server.example.com   Authorization: JWT eyJhbGciOiJIUzI1NiIXVCJ9...TJVA95OrM7E20RMHrHDcEfxjoYZgeFONFh7HgQWe can test using curl... code-block:: bash   curl --header 'Authorization: JWT TOKEN' server.example.com/ROUTE_PATH.. code-block:: python   config.add_route('example', '/ROUTE_PATH')   @view_config(route_name=example)   def some_action(request):       if request.authenticated_userid:           # Do somethingSettings--------There are a number of flags that specify how tokens are created and verified.You can either set this in your .ini-file, or pass/override them directly to the``config.set_jwt_authentication_policy()`` function.+--------------+-----------------+---------------+--------------------------------------------+| Parameter    | ini-file entry  | Default       | Description                                |+==============+=================+===============+============================================+| private_key  | jwt.private_key |               | Key used to hash or sign tokens.           |+--------------+-----------------+---------------+--------------------------------------------+| public_key   | jwt.public_key  |               | Key used to verify token signatures. Only  ||              |                 |               | used with assymetric algorithms.           |+--------------+-----------------+---------------+--------------------------------------------+| algorithm    | jwt.algorithm   | HS512         | Hash or encryption algorithm               |+--------------+-----------------+---------------+--------------------------------------------+| expiration   | jwt.expiration  |               | Number of seconds (or a datetime.timedelta ||              |                 |               | instance) before a token expires.          |+--------------+-----------------+---------------+--------------------------------------------+| audience     | jwt.audience    |               | Proposed audience for the token            |+--------------+-----------------+---------------+--------------------------------------------+| leeway       | jwt.leeway      | 0             | Number of seconds a token is allowed to be ||              |                 |               | expired before it is rejected.             |+--------------+-----------------+---------------+--------------------------------------------+| http_header  | jwt.http_header | Authorization | HTTP header used for tokens                |+--------------+-----------------+---------------+--------------------------------------------+| auth_type    | jwt.auth_type   | JWT           | Authentication type used in Authorization  ||              |                 |               | header. Unused for other HTTP headers.     |+--------------+-----------------+---------------+--------------------------------------------+| json_encoder |                 | None          | A subclass of JSONEncoder to be used       ||              |                 |               | to encode principal and claims infos.      |+--------------+-----------------+---------------+--------------------------------------------+The follow options applies to the cookie-based authentication policy:+----------------+---------------------------+---------------+--------------------------------------------+| Parameter      | ini-file entry            | Default       | Description                                |+================+===========================+===============+============================================+| cookie_name    | jwt.cookie_name           | Authorization | Key used to identify the cookie.           |+----------------+---------------------------+---------------+--------------------------------------------+| cookie_path    | jwt.cookie_path           | None          | Path for cookie.                           |+----------------+---------------------------+---------------+--------------------------------------------+| https_only     | jwt.https_only_cookie     | True          | Whether or not the token should only be    ||                |                           |               | sent through a secure HTTPS transport      |+----------------+---------------------------+---------------+--------------------------------------------+| reissue_time   | jwt.cookie_reissue_time   |  None         | Number of seconds (or a datetime.timedelta ||                |                           |               | instance) before a cookie (and the token   ||                |                           |               | within it) is reissued                     |+----------------+---------------------------+---------------+--------------------------------------------+Pyramid JWT example use cases=============================This is a basic guide (that will assume for all following statements that youhave followed the Readme for this project) that will explain how (and why) touse JWT to secure/restrict access to a pyramid REST style backend API, thisguide will explain a basic overview on:- Creating JWT's- Decoding JWT's- Restricting access to certain pyramid views via JWT'sCreating JWT's--------------First off, lets start with the first view in our pyramid project, this wouldnormally be say a login view, this view has no permissions associated with it,any user can access and post login credentials to it, for example:.. code-block:: python   def authenticate_user(login, password):       # Note the below will not work, its just an example of returning a user       # object back to the JWT creation.       login_query = session.query(User).\           filter(User.login == login).\           filter(User.password == password).first()       if login_query:           user_dict = {               'userid': login_query.id,               'user_name': login_query.user_name,               'roles': login_query.roles           }           # An example of login_query.roles would be a list           # print(login_query.roles)           # ['admin', 'reports']           return user_dict       else:           # If we end up here, no logins have been found           return None   @view_config('login', request_method='POST', renderer='json')   def login(request):       '''Create a login view       '''       login = request.POST['login']       password = request.POST['password']       user = authenticate(login, password)       if user:           return {               'result': 'ok',               'token': request.create_jwt_token(                                               user['userid'],                                               roles=user['roles'],                                               userName=user['user_name']                                               )           }       else:           return {               'result': 'error',               'token': None           }Now what this does is return your JWT back to whatever front end applicationyou may have, with the user details, along with their permissions, this willreturn a decoded token such as:.. code-block::   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyTmFtZSI6Imx1a2UiLCJyb2xlcyI6WyJhZG1pbiIsInJlcG9ydHMiXSwic3ViIjo0LCJpYXQiOjE1MTkwNDQyNzB9.__KjyW1U-tpAEvTbSJsasS-8CaFyXH784joUPONH6hQNow I would suggest heading over to `JWT.io &lt;https://jwt.io&gt;`_, copy this datainto their page, and you will see the decoded token:.. code-block:: json   {     &quot;userName&quot;: &quot;luke&quot;,     &quot;roles&quot;: [       &quot;admin&quot;,       &quot;reports&quot;     ],     &quot;sub&quot;: 4,     &quot;iat&quot;: 1519044270   }Note, at the bottom of jwt.io's webpage, that the signature shows verified, ifyou change the &quot;secret&quot; at the bottom, it will say &quot;NOT Verified&quot; this isbecause in order for any JWT process to be verified, the valid &quot;secret&quot; or&quot;private key&quot; must be used. It is important to note that any data sent in a JWTis accessible and readable by anyone.Decoding JWT------------The following section would also work if pyramid did not create the JWT, all itneeds to know to decode a JWT is the &quot;secret&quot; or &quot;private key&quot; used tocreate/sign the original JWT.By their nature  JWT's aren't secure, but they canbe used &quot;to secure&quot;. In our example above, we returned the &quot;roles&quot; array in ourJWT, this had two properties &quot;admin&quot; and &quot;reports&quot; so we could then in ourpyramid application, setup an ACL to map JWT permissions to pyramid basedsecurity, for example in our projects __init__.py we could add:.. code-block:: python   from pyramid.security import ALL_PERMISSIONS   class RootACL(object):       __acl__ = [           (Allow, 'admin', ALL_PERMISSIONS),           (Allow, 'reports', ['reports'])       ]       def __init__(self, request):           passWhat this ACL will do is allow anyone with the &quot;admin&quot; role in their JWT accessto all views protected via a permission, where as users with &quot;reports&quot; in theirJWT will only have access to views protected via the &quot;reports&quot; permission.Now this ACL in itself is not enough to map the JWT permission to pyramidssecurity backend, we need to also add the following to __init__.py:.. code-block:: python   from pyramid.authorization import ACLAuthorizationPolicy   def add_role_principals(userid, request):       return request.jwt_claims.get('roles', [])   def main(global_config, **settings):       &quot;&quot;&quot; This function returns a Pyramid WSGI application.       &quot;&quot;&quot;       config = Configurator(settings=settings)       ...       # Enable JWT - JSON Web Token based authentication       config.set_root_factory(RootACL)       config.set_authorization_policy(ACLAuthorizationPolicy())       config.include('pyramid_jwt')       config.set_jwt_authentication_policy('myJWTsecretKeepThisSafe',                                           auth_type='Bearer',                                           callback=add_role_principals)This code will map any properties of the &quot;roles&quot; attribute of the JWT, run themthrough the ACL and then tie them into pyramids security framework.Creating a JWT within a cookie------------------------------Since cookie-based authentication is already standardized within Pyramid by the``remember()`` and ``forget()`` calls, you should simply use them:.. code-block:: python   from pyramid.response import Response   from pyramid.security import remember   @view_config('login', request_method='POST', renderer='json')   def login_with_cookies(request):       '''Create a login view       '''       login = request.POST['login']       password = request.POST['password']       user = authenticate(login, password)  # From the previous snippet       if user:           headers = remember(               user['userid'],               roles=user['roles'],               userName=user['user_name']           )           return Response(headers=headers, body=&quot;OK&quot;)  # Or maybe redirect somewhere else       return Response(status=403)  # Or redirect back to loginPlease note that since the JWT cookies will be stored inside the cookies,there's no need for your app to explicitly include it on the response body.The browser (or whatever consuming this response) is responsible to keep thatcookie for as long as it's valid, and re-send it on the following requests.Also note that there's no need to decode the cookie manually. The Policyhandles that through the existing ``request.jwt_claims``.How is this secure?-------------------For example, a JWT could easily be manipulated, anyone could hijack the token,change the values of the &quot;roles&quot; array to gain access to a view they do notactually have access to. WRONG! pyramid_jwt checks the signature of all JWTtokens as part of the decode process, if it notices that the signature of thetoken is not as expected, it means either the application has been setupcorrectly with the wrong private key, OR an attacker has tried to manipulatethe token.The major security concern when working with JWT tokens is where to store thetoken itself: While pyramid_jwt is able to detect tampered tokens, nothing canbe done if the actual valid token leaks. Any user with a valid token will becorrectly authenticated within your app. Storing the token securely is outsidethe scope of this library.When using JWT within a cookie, the browser (or tool consuming the cookie) isresponsible for storing it, but pyramid_jwt does set the ``http_only`` flag onall cookies, so javascript running on the page cannot access these cookies,which helps mitigate XSS attacks. It's still mentioning that the tokens arestill visible through the browser's debugging/inspection tools.Securing views with JWT's-------------------------In the example posted above we creating an &quot;admin&quot; role that we gaveALL_PERMISSIONS access in our ACL, so any user with this role could access anyview e.g.:.. code-block:: python   @view_config(route_name='view_a', request_method='GET',                permission=&quot;admin&quot;, renderer='json')   def view_a(request):       return   @view_config(route_name='view_b', request_method='GET',                permission=&quot;cpanel&quot;, renderer='json')   def view_b(request):       returnThis user would be able to access both of these views, however any user withthe &quot;reports&quot; permission would not be able to access any of these views, theycould only access permissions with &quot;reports&quot;. Obviously in our use case, oneuser had both &quot;admin&quot; and &quot;reports&quot; permissions, so they would be able toaccess any view regardless.</longdescription>
</pkgmetadata>