<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># ðŸ“Ÿ aionotion: a Python3, asyncio-friendly library for NotionÂ® Home Monitoring[![CI][ci-badge]][ci][![PyPI][pypi-badge]][pypi][![Version][version-badge]][version][![License][license-badge]][license][![Code Coverage][codecov-badge]][codecov][![Maintainability][maintainability-badge]][maintainability]&lt;a href=&quot;https://www.buymeacoffee.com/bachya1208P&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://cdn.buymeacoffee.com/buttons/default-orange.png&quot; alt=&quot;Buy Me A Coffee&quot; height=&quot;41&quot; width=&quot;174&quot;&gt;&lt;/a&gt;`aionotion` is a Python 3, asyncio-friendly library for interacting with [Notion][notion]home monitoring sensors.- [Installation](#installation)- [Python Versions](#python-versions)- [Usage](#usage)- [Contributing](#contributing)# Installation```bashpip install aionotion```# Python Versions`aionotion` is currently supported on:- Python 3.9- Python 3.10- Python 3.11# Usage```pythonimport asynciofrom aiohttp import ClientSessionfrom aionotion import async_get_clientasync def main() -&gt; None:    &quot;&quot;&quot;Create the aiohttp session and run the example.&quot;&quot;&quot;    client = await async_get_client(&quot;&lt;EMAIL&gt;&quot;, &quot;&lt;PASSWORD&gt;&quot;, session=session)    # Get all &quot;households&quot; associated with the account:    response = await client.system.async_all()    # &gt;&gt;&gt; response -&gt; systems=[System(...), ...]    # Get a system by ID:    response = await client.system.async_get(12345)    # &gt;&gt;&gt; response -&gt; system=System(...)    # Create a system (with associated parameters):    response = await client.system.async_create({&quot;system_id&quot;: 12345, &quot;name&quot;: &quot;Test&quot;})    # &gt;&gt;&gt; response -&gt; system=System(...)    # Update a system with new parameters:    response = await client.system.async_update(12345, {&quot;name&quot;: &quot;Test&quot;})    # &gt;&gt;&gt; response -&gt; system=System(...)    # Delete a system by ID:    await client.system.async_delete(12345)    # Get all bridges associated with the account:    response = await client.bridge.async_all()    # &gt;&gt;&gt; response -&gt; bridges=[Bridge(...), ...]    # Get a bridge by ID:    response = await client.bridge.async_get(12345)    # &gt;&gt;&gt; response -&gt; bridge=Bridge(...)    # Create a bridge (with associated parameters):    response = await client.bridge.async_create({&quot;system_id&quot;: 12345, &quot;name&quot;: &quot;Test&quot;})    # &gt;&gt;&gt; response -&gt; bridge=Bridge(...)    # Update a bridge with new parameters:    response = await client.bridge.async_update(12345, {&quot;name&quot;: &quot;Test&quot;})    # &gt;&gt;&gt; response -&gt; bridge=Bridge(...)    # Reset a bridge (deprovision its WiFi credentials):    response = await client.bridge.async_reset(12345)    # &gt;&gt;&gt; response -&gt; bridge=Bridge(...)    # Delete a bridge by ID:    await client.bridge.async_delete(12345)    # Get all devices associated with the account:    response = await client.device.async_all()    # &gt;&gt;&gt; response -&gt; devices=[Device(...), ...]    # Get a device by ID:    response = await client.device.async_get(12345)    # &gt;&gt;&gt; response -&gt; Device(...)    # Create a device (with associated parameters):    response = await client.device.async_create({&quot;id&quot;: 12345})    # &gt;&gt;&gt; response -&gt; Device(...)    # Delete a device by ID:    await client.device.async_delete(12345)    # Get all sensors:    response = await client.sensor.async_all()    # &gt;&gt;&gt; response -&gt; sensors=[Sensor(...), ...]    # Get a sensor by ID:    response = await client.sensor.async_get(12345)    # &gt;&gt;&gt; response -&gt; Sensor(...)    # Get &quot;listeners&quot; (conditions that a sensor is monitoring) for all sensors:    response = await client.sensor.async_listeners()    # &gt;&gt;&gt; response -&gt; listeners=[Listener(...), ...]    # Get &quot;listeners&quot; (conditions that a sensor is monitoring) for a specific sensor;    # note that unlike other sensor endpoints, this one requires the sensor UUID, *not*    # the sensor ID:    response = await client.sensor.async_listeners_for_sensor(        &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;    )    # &gt;&gt;&gt; response -&gt; listeners=[Listener(...), ...]    # Create a sensor (with associated parameters):    response = await client.sensor.async_create({&quot;sensor_id&quot;: 12345, &quot;name&quot;: &quot;Test&quot;})    # &gt;&gt;&gt; response -&gt; Sensor(...)    # Update a sensor with new parameters:    response = await client.sensor.async_update(12345, {&quot;name&quot;: &quot;Test&quot;})    # &gt;&gt;&gt; response -&gt; Sensor(...)    # Delete a sensor by ID:    await client.sensor.async_delete(12345)    # Get user preferences:    user_preferences = await client.user.async_preferences()asyncio.run(main())```By default, the library creates a new connection to Notion with each coroutine. If youare calling a large number of coroutines (or merely want to squeeze out every second ofruntime savings possible), an [`aiohttp`][aiohttp] `ClientSession` can be used forconnection pooling:```pythonimport asynciofrom aiohttp import ClientSessionfrom aionotion import async_get_clientasync def main() -&gt; None:    &quot;&quot;&quot;Create the aiohttp session and run the example.&quot;&quot;&quot;    async with ClientSession() as session:        # Create a Notion API client:        client = await async_get_client(&quot;&lt;EMAIL&gt;&quot;, &quot;&lt;PASSWORD&gt;&quot;, session=session)        # Get to work...asyncio.run(main())```Check out the examples, the tests, and the source files themselves for methodsignatures and more examples.# ContributingThanks to all of [our contributors][contributors] so far!1. [Check for open features/bugs][issues] or [initiate a discussion on one][new-issue].2. [Fork the repository][fork].3. (_optional, but highly recommended_) Create a virtual environment: `python3 -m venv .venv`4. (_optional, but highly recommended_) Enter the virtual environment: `source ./.venv/bin/activate`5. Install the dev environment: `script/setup`6. Code your new feature or bug fix on a new branch.7. Write tests that cover your new functionality.8. Run tests and ensure 100% code coverage: `poetry run pytest --cov aionotion tests`9. Update `README.md` with any new documentation.10. Submit a pull request![aiohttp]: https://github.com/aio-libs/aiohttp[ci-badge]: https://github.com/bachya/aionotion/workflows/CI/badge.svg[ci]: https://github.com/bachya/aionotion/actions[codecov-badge]: https://codecov.io/gh/bachya/aionotion/branch/dev/graph/badge.svg[codecov]: https://codecov.io/gh/bachya/aionotion[contributors]: https://github.com/bachya/aionotion/graphs/contributors[fork]: https://github.com/bachya/aionotion/fork[issues]: https://github.com/bachya/aionotion/issues[license-badge]: https://img.shields.io/pypi/l/aionotion.svg[license]: https://github.com/bachya/aionotion/blob/main/LICENSE[maintainability-badge]: https://api.codeclimate.com/v1/badges/bd79edca07c8e4529cba/maintainability[maintainability]: https://codeclimate.com/github/bachya/aionotion/maintainability[new-issue]: https://github.com/bachya/aionotion/issues/new[notion]: https://getnotion.com[pypi-badge]: https://img.shields.io/pypi/v/aionotion.svg[pypi]: https://pypi.python.org/pypi/aionotion[version-badge]: https://img.shields.io/pypi/pyversions/aionotion.svg[version]: https://pypi.python.org/pypi/aionotion</longdescription>
</pkgmetadata>