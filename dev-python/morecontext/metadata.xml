<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: http://www.repostatus.org/badges/latest/active.svg    :target: http://www.repostatus.org/#active    :alt: Project Status: Active â€” The project has reached a stable, usable          state and is being actively developed... image:: https://github.com/jwodder/morecontext/workflows/Test/badge.svg?branch=master    :target: https://github.com/jwodder/morecontext/actions?workflow=Test    :alt: CI Status.. image:: https://codecov.io/gh/jwodder/morecontext/branch/master/graph/badge.svg    :target: https://codecov.io/gh/jwodder/morecontext.. image:: https://img.shields.io/pypi/pyversions/morecontext.svg    :target: https://pypi.org/project/morecontext/.. image:: https://img.shields.io/github/license/jwodder/morecontext.svg    :target: https://opensource.org/licenses/MIT    :alt: MIT License`GitHub &lt;https://github.com/jwodder/morecontext&gt;`_| `PyPI &lt;https://pypi.org/project/morecontext/&gt;`_| `Issues &lt;https://github.com/jwodder/morecontext/issues&gt;`_| `Changelog &lt;https://github.com/jwodder/morecontext/blob/master/CHANGELOG.md&gt;`_``morecontext`` provides context managers for some common minor operations:specifically, changing the current working directory, an object's attribute, a``dict`` field, or an environment variable and then setting it back afterwards.Sure, it's easy enough to implement these on your own, but why bother doingthat over &amp; over again when you can let this package do it for you once?Type annotated!  Fully tested!Installation============``morecontext`` requires Python 3.6 or higher.  Just use `pip&lt;https://pip.pypa.io&gt;`_ for Python 3 (You have pip, right?) to install``morecontext``::    python3 -m pip install morecontextExamples========&gt;&gt;&gt; import os&gt;&gt;&gt; import morecontext&gt;&gt;&gt; os.getcwd()'/some/dir'&gt;&gt;&gt; with morecontext.dirchanged('/some/other/dir'):...     # Now we're in /some/other/dir...     os.getcwd()...'/some/other/dir'&gt;&gt;&gt; # Out of the `with`, back to /some/dir&gt;&gt;&gt; os.getcwd()'/some/dir'&gt;&gt;&gt; d = {&quot;foo&quot;: 42}&gt;&gt;&gt; with morecontext.itemset(d, &quot;foo&quot;, &quot;bar&quot;):...     # d[&quot;foo&quot;] == &quot;bar&quot; in here...     d[&quot;foo&quot;]...     # If we change d[&quot;foo&quot;] in here, it'll still be set back to 42 on exit...     d[&quot;foo&quot;] = 3.14...'bar'&gt;&gt;&gt; # Out of the `with`, it's back to 42&gt;&gt;&gt; d[&quot;foo&quot;]42API===Functions---------All of the following context manager functions are defined with``contextlib.contextmanager``, so they can be used as function decorators aswell.  They also all return ``None`` on entry, so there's no point in writing&quot;``with dirchanged(path) as foo:``&quot;; just do &quot;``with dirchanged(path):``&quot;.These functions are not thread-safe... code:: python    dirchanged(dirpath: Union[str, bytes, os.PathLike]) -&gt; ContextManager[None]Temporarily change the current working directory.``dirchanged(dirpath)`` returns a context manager.  On entry, it stores thecurrent working directory path and then changes the current directory to``dirpath``.  On exit, it changes the current directory back to the storedpath... code:: python    dirrollback() -&gt; ContextManager[None]Save &amp; restore the current working directory.``dirrollback()`` returns a context manager that stores the current workingdirectory on entry and changes back to that directory on exit... code:: python    attrset(obj: Any, name: str, value: Any) -&gt; ContextManager[None]Temporarily change the value of an object's attribute.``attrset(obj, name, value)`` returns a context manager.  On entry, it storesthe current value of the attribute of ``obj`` with name ``name``, and then itsets that attribute to ``value``.  On exit, it sets the attribute back to thestored value.If the given attribute is unset on entry, the context manager will unset it onexit... code:: python    attrdel(obj: Any, name: str) -&gt; ContextManager[None]Temporarily unset an object's attribute.``attrdel(obj, name)`` returns a context manager.  On entry, it stores thecurrent value of the attribute of ``obj`` with name ``name``, and then itunsets that attribute.  On exit, it sets the attribute back to the storedvalue.If the given attribute is unset on entry, the context manager will unset it onexit... code:: python    attrrollback(obj: Any, name: str, copy: bool = False, deepcopy: bool = False) -&gt; ContextManager[None]Save &amp; restore the value of an object's attribute.``attrrollback(obj, name)`` returns a context manager that stores the value ofthe attribute of ``obj`` with name ``name`` on entry and sets the attributeback to that value on exit.  If the given attribute is unset on entry, thecontext manager will unset it on exit.If ``copy`` is true, a shallow copy of the attribute will be saved &amp; restored.If ``deepcopy`` is true, a deep copy of the attribute will be saved &amp; restored.If both options are true, ``deepcopy`` takes precedence... code:: python    itemset(d: MutableMapping[K,V], key: K, value: V) -&gt; ContextManager[None]Temporarily change the value of a mapping's entry.``itemset(d, key, value)`` returns a context manager.  On entry, it stores thecurrent value of ``d[key]``, and then it sets that field to ``value``.  Onexit, it sets the field back to the stored value.If the given field is unset on entry, the context manager will unset it onexit... code:: python    itemdel(d: MutableMapping[K, Any], key: K) -&gt; ContextManager[None]Temporarily unset a mapping's entry.``itemdel(d, key)`` returns a context manager.  On entry, it stores the currentvalue of ``d[key]``, and then it unsets that field.  On exit, it sets the fieldback to the stored value.If the given field is unset on entry, the context manager will unset it onexit... code:: python    itemrollback(d: MutableMapping[K, Any], key: K, copy: bool = False, deepcopy: bool = False) -&gt; ContextManager[None]Save &amp; restore the value of a mapping's entry.``itemrollback(d, key)`` returns a context manager that stores the value of``d[key]`` on entry and sets the field back to that value on exit.  If thegiven field is unset on entry, the context manager will unset it on exit.If ``copy`` is true, a shallow copy of the field will be saved &amp; restored.  If``deepcopy`` is true, a deep copy of the field will be saved &amp; restored.  Ifboth options are true, ``deepcopy`` takes precedence... code:: python    envset(name: str, value: str) -&gt; ContextManager[None]Temporarily set an environment variable.``envset(name, value)`` returns a context manager.  On entry, it stores thecurrent value of the environment variable ``name``, and then it sets thatenvironment variable to ``value``.  On exit, it sets the environment variableback to the stored value.If the given environment variable is unset on entry, the context manager willunset it on exit... code:: python    envdel(name: str) -&gt; ContextManager[None]Temporarily unset an environment variable.``envdel(name)`` returns a context manager.  On entry, it stores the currentvalue of the environment variable ``name``, and then it unsets that environmentvariable.  On exit, it sets the environment variable back to the stored value.If the given environment variable is unset on entry, the context manager willunset it on exit... code:: python    envrollback(name: str) -&gt; ContextManager[None]Save &amp; restore the value of an environment variable.``envrollback(name)`` returns a context manager that stores the value of theenvironment variable ``name`` on entry and sets the environment variable backto that value on exit.  If the given environment variable is unset on entry,the context manager will unset it on exit... code:: python    additem(lst: MutableSequence[T], value: T, prepend: bool = False) -&gt; ContextManager[None]Temporarily add a value to a sequence.``additem(lst, value)`` returns a context manager that appends ``value`` to thesequence ``lst`` on entry and removes the last item (if any) in ``lst`` thatequals ``value`` on exit.If ``prepend`` is true, ``value`` is instead prepended to ``lst`` on entry, andthe first item in ``lst`` that equals ``value`` is removed on exit.Classes-------.. code:: python    class OpenClosable:        def open(self) -&gt; None:            ...        def close(self) -&gt; None:            ...A base class for creating simple reentrant_ context managers.  ``OpenClosable``defines ``__enter__`` and ``__exit__`` methods that keep track of the number ofnested ``with`` statements in effect and call the instance's ``open()`` and``close()`` methods when entering &amp; exiting the outermost ``with``.Subclasses should override ``open()`` and/or ``close()`` with the desiredcode to run on entering &amp; exiting the outermost ``with``; the default``open()`` and ``close()`` methods defined by ``OpenClosable`` do nothing... _reentrant: https://docs.python.org/3/library/contextlib.html#reentrant-cms</longdescription>
</pkgmetadata>