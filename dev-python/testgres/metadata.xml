<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Build Status](https://travis-ci.com/postgrespro/testgres.svg?branch=master)](https://app.travis-ci.com/github/postgrespro/testgres/branches)[![codecov](https://codecov.io/gh/postgrespro/testgres/branch/master/graph/badge.svg)](https://codecov.io/gh/postgrespro/testgres)[![PyPI version](https://badge.fury.io/py/testgres.svg)](https://badge.fury.io/py/testgres)[Documentation](https://postgrespro.github.io/testgres/)# testgresPostgreSQL testing utility. Both Python 2.7 and 3.3+ are supported.## InstallationTo install `testgres`, run:```pip install testgres```We encourage you to use `virtualenv` for your testing environment.## Usage### Environment&gt; Note: by default testgres runs `initdb`, `pg_ctl`, `psql` provided by `PATH`.There are several ways to specify a custom postgres installation:* export `PG_CONFIG` environment variable pointing to the `pg_config` executable;* export `PG_BIN` environment variable pointing to the directory with executable files.Example:```bashexport PG_BIN=$HOME/pg_10/binpython my_tests.py```### ExamplesHere is an example of what you can do with `testgres`:```python# create a node with random name, port, etcwith testgres.get_new_node() as node:    # run inidb    node.init()    # start PostgreSQL    node.start()    # execute a query in a default DB    print(node.execute('select 1'))# ... node stops and its files are about to be removed```There are four API methods for runnig queries:| Command | Description ||----------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|| `node.psql(query, ...)` | Runs query via `psql` command and returns tuple `(error code, stdout, stderr)`. || `node.safe_psql(query, ...)` | Same as `psql()` except that it returns only `stdout`. If an error occures during the execution, an exception will be thrown. || `node.execute(query, ...)` | Connects to PostgreSQL using `psycopg2` or `pg8000` (depends on which one is installed in your system) and returns two-dimensional array with data. || `node.connect(dbname, ...)` | Returns connection wrapper (`NodeConnection`) capable of running several queries within a single transaction. |The last one is the most powerful: you can use `begin(isolation_level)`, `commit()` and `rollback()`:```pythonwith node.connect() as con:    con.begin('serializable')    print(con.execute('select %s', 1))    con.rollback()```### LoggingBy default, `cleanup()` removes all temporary files (DB files, logs etc) that were created by testgres' API methods.If you'd like to keep logs, execute `configure_testgres(node_cleanup_full=False)` before running any tests.&gt; Note: context managers (aka `with`) call `stop()` and `cleanup()` automatically.`testgres` supports [python logging](https://docs.python.org/3.6/library/logging.html),which means that you can aggregate logs from several nodes into one file:```pythonimport logging# write everything to /tmp/testgres.loglogging.basicConfig(filename='/tmp/testgres.log')# enable logging, and create two different nodestestgres.configure_testgres(use_python_logging=True)node1 = testgres.get_new_node().init().start()node2 = testgres.get_new_node().init().start()# execute a few queriesnode1.execute('select 1')node2.execute('select 2')# disable loggingtestgres.configure_testgres(use_python_logging=False)```Look at `tests/test_simple.py` file for a complete example of the loggingconfiguration.### Backup &amp; replicationIt's quite easy to create a backup and start a new replica:```pythonwith testgres.get_new_node('master') as master:    master.init().start()    # create a backup    with master.backup() as backup:        # create and start a new replica        replica = backup.spawn_replica('replica').start()        # catch up with master node        replica.catchup()        # execute a dummy query        print(replica.execute('postgres', 'select 1'))```### Benchmarks`testgres` is also capable of running benchmarks using `pgbench`:```pythonwith testgres.get_new_node('master') as master:    # start a new node    master.init().start()    # initialize default DB and run bench for 10 seconds    res = master.pgbench_init(scale=2).pgbench_run(time=10)    print(res)```### Custom configurationIt's often useful to extend default configuration provided by `testgres`.`testgres` has `default_conf()` function that helps control some basicoptions. The `append_conf()` function can be used to add customlines to configuration lines:```pythonext_conf = &quot;shared_preload_libraries = 'postgres_fdw'&quot;# initialize a new nodewith testgres.get_new_node().init() as master:    # ... do something ...    # reset main config file    master.default_conf(fsync=True,                        allow_streaming=True)    # add a new config line    master.append_conf('postgresql.conf', ext_conf)```Note that `default_conf()` is called by `init()` function; both of them overwritethe configuration file, which means that they should be called before `append_conf()`.## Authors[Ildar Musin](https://github.com/zilder)  [Dmitry Ivanov](https://github.com/funbringer)  [Ildus Kurbangaliev](https://github.com/ildus)  [Yury Zhuravlev](https://github.com/stalkerg)  </longdescription>
</pkgmetadata>