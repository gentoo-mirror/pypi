<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Compysition========What?-----::A Python application framework to build and manage asynchronous and highly concurrent event-driven data flowI have created **compysition** to build off the simple way in which Wishbone_ managed message flow across multiplemodules. Compysition expands upon this module registration method to provide abstracted multi-process communicationvia 0mq_, as well as the ability for full cyclical communication for in-process request/response behavior in a lightweight,fast, and fully concurrent manner, using gevent_ greenlets and concurrency patterns to consume and output events.. _0mq: http://zeromq.org/.. _Wishbone: https://github.com/smetj/wishbone.. _gevent: http://www.gevent.org**Compysition is currently new and in pre-Beta release. It will be undergoing many deep changes in the coming months**The **compysition** project is built upon the original work of the Wishbone_ projectVariations from the traditional Actor Model-----The traditional and strict actor model requires that all actors have exactly one inbox and one outbox. I found that this wasoverly constraining for creating and crafting complex data flow models. So compysition inherently supports multiple inboxesand multiple outboxes on every single actor.To put it in actor model terms, every actor is also a &quot;funnel&quot; and a &quot;fanout&quot;. The default behavior, unless stated otherwise in the module documentation, is that all modules will send/copy an event to ALLconnected outbox queuesFull Circle WSGI Example-------For the example below, we want to execute an XML transformation on a request and send it back to the client in a fastand concurrent way. All steps and executions are spun up as spawned greenlet on the router    .. code-block:: pythonfrom compysition import Directorfrom compysition.actors import WSGI, BasicAuth, Transformerfrom myproject.actors import SomeRequestExecutorfrom myprojectresources import my_xsl_files as xslsdirector = Director()wsgi = director.register_actor(WSGIServer, &quot;wsgi&quot;)auth = director.register_actor(BasicAuth, &quot;auth&quot;)submit_transform = director.register_actor(Transformer, &quot;submit_transform&quot;, xsls['submit'])acknowledge_transform = director.register_actor(Transformer, &quot;acknowledge_transform&quot;, my_xsl_files['acknowledge.xsl'])request_executor = director.register_actor(SomeRequestExecutor, &quot;request_executor&quot;)director.connect_queue(wsgi, auth)director.connect_queue(auth, submit_transform)director.connect_queue_error(auth, wsgi) # Redirect auth errors to the wsgi server as a 401 Unaothorized Errordirector.connect_queue(submit_transform, request_executor)director.connect_queue_error(submit_transform, wsgi)director.connect_queue(request_executor, acknowledge_transform)director.connect_queue(acknowledge_transform, wsgi)director.start()Note how modular each component is. It allows us to configure any steps in between class method executions and addany additional executions, authorizations, or transformations in between the request and response by simplyadding it into the message execution flowOne-way messaging example-------.. code-block:: pythonfrom compysition import Directorfrom compysition.actors import TestEvent, STDOUTdirector = Director()event_generator = director.register_actor(TestEvent, &quot;event_generator&quot;, interval=1)output_one = director.register_actor(STDOUT, &quot;output_one&quot;, prefix=&quot;I am number one: &quot;, timestamp=True)output_two = director.register_actor(STDOUT, &quot;output_two&quot;, prefix=&quot;I am number two: &quot;, timestamp=True)    director.connect_queue(event_generator, [output_one, output_two])    director.start()    Output: [2015-02-13 16:56:35.850659] I am number two: test[2015-02-13 16:56:35.850913] I am number one: test[2015-02-13 16:56:36.851588] I am number two: test[2015-02-13 16:56:36.851856] I am number one: test[2015-02-13 16:56:37.852456] I am number two: test[2015-02-13 16:56:37.852737] I am number one: test[2015-02-13 16:56:38.858107] I am number two: test[2015-02-13 16:56:38.858400] I am number one: test[2015-02-13 16:56:39.860292] I am number two: test[2015-02-13 16:56:39.860570] I am number one: testZeroMQ MajorDomo Implementation Example-------The following example is a single-process example of the multi-process MajorDomo Protocal from ZMQ. The pieces noted could all be run outside this process in their own compysitionscript, scalable across multiple hosts and cores.. code-block:: python    from compysition.actors import MDPClient, MDPWorker, MDPBroker, WSGI, MDPBrokerRegistrationService, STDOUT, Data    from compysition import Director    director = Director()    mdp_client          = director.register_actor(MDPClient,                     &quot;mdp_client&quot;)    mdp_broker          = director.register_actor(MDPBroker,                     &quot;mdp_broker&quot;)     # This could be it's own process    mdp_regservice      = director.register_actor(MDPBrokerRegistrationService,  &quot;mdp_regservice&quot;) # This could be it's own process    mdp_worker          = director.register_actor(MDPWorker,                     &quot;mdp_worker&quot;, &quot;test_service&quot;) # This (These) would be their own processes    stdout              = director.register_actor(STDOUT,                        &quot;stdout&quot;)    data                = director.register_actor(Data,                          &quot;data&quot;, data=&quot;Hello, this has been a test&quot;)    wsgi                = director.register_actor(WSGI,                          &quot;wsgi&quot;, run_server=True, address=&quot;0.0.0.0&quot;, port=7000)    director.register_log_actor(STDOUT,                                          &quot;stdoutmodule&quot;, timestamp=True)    director.connect_queue(wsgi,             mdp_client)    director.connect_queue(mdp_worker,       data)    director.connect_queue(data,             mdp_worker)    director.connect_queue(mdp_client,       wsgi)    director.start()After running this process, initiating a http request to http://127.0.0.1:7000/test_service would show the dataflow across MDP componentsInstalling----------Through Pypi:$ pip install compysitionOr the latest development branch from Github:$ git clone git@github.com:fiebiga/compysition.git$ cd compysition$ sudo python setup.py installSupport-------You may email myself at fiebig.adam@gmail.com</longdescription>
</pkgmetadata>