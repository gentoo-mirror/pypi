<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;    &lt;img src=&quot;https://raw.githubusercontent.com/guilatrova/gracy/main/img/logo.png&quot;&gt;&lt;/p&gt;&lt;h2 align=&quot;center&quot;&gt;Gracefully manage your API interactions&lt;/h2&gt;&lt;p align=&quot;center&quot;&gt;  &lt;!-- CI --&gt;&lt;a href=&quot;https://github.com/guilatrova/gracy/actions&quot;&gt;&lt;img alt=&quot;Actions Status&quot; src=&quot;https://github.com/guilatrova/gracy/workflows/CI/badge.svg&quot;&gt;&lt;/a&gt;  &lt;!-- PyPI --&gt;&lt;a href=&quot;https://pypi.org/project/gracy/&quot;&gt;&lt;img alt=&quot;PyPI&quot; src=&quot;https://img.shields.io/pypi/v/gracy&quot;/&gt;&lt;/a&gt;  &lt;!-- Supported Python versions --&gt;&lt;img src=&quot;https://badgen.net/pypi/python/gracy&quot; /&gt;  &lt;!-- Alternative Python versioning: &lt;img alt=&quot;python version&quot; src=&quot;https://img.shields.io/badge/python-3.9%20%7C%203.10-blue&quot;&gt; --&gt;  &lt;!-- PyPI downloads --&gt;&lt;a href=&quot;https://pepy.tech/project/gracy/&quot;&gt;&lt;img alt=&quot;Downloads&quot; src=&quot;https://static.pepy.tech/badge/gracy/week&quot;/&gt;&lt;/a&gt;  &lt;!-- LICENSE --&gt;&lt;a href=&quot;https://github.com/guilatrova/gracy/blob/main/LICENSE&quot;&gt;&lt;img alt=&quot;GitHub&quot; src=&quot;https://img.shields.io/github/license/guilatrova/gracy&quot;/&gt;&lt;/a&gt;  &lt;!-- Formatting --&gt;&lt;a href=&quot;https://github.com/psf/black&quot;&gt;&lt;img alt=&quot;Code style: black&quot; src=&quot;https://img.shields.io/badge/code%20style-black-000000.svg&quot;/&gt;&lt;/a&gt;  &lt;!-- Tryceratops --&gt;&lt;a href=&quot;https://github.com/guilatrova/tryceratops&quot;&gt;&lt;img alt=&quot;try/except style: tryceratops&quot; src=&quot;https://img.shields.io/badge/try%2Fexcept%20style-tryceratops%20%F0%9F%A6%96%E2%9C%A8-black&quot; /&gt;&lt;/a&gt;  &lt;!-- Typing --&gt;&lt;a href=&quot;https://github.com/python/mypy&quot;&gt;&lt;img alt=&quot;Types: mypy&quot; src=&quot;https://img.shields.io/badge/types-mypy-blue.svg&quot;/&gt;&lt;/a&gt;  &lt;!-- Follow handle --&gt;&lt;a href=&quot;https://twitter.com/intent/user?screen_name=guilatrova&quot;&gt;&lt;img alt=&quot;Follow guilatrova&quot; src=&quot;https://img.shields.io/twitter/follow/guilatrova?style=social&quot;/&gt;&lt;/a&gt;  &lt;!-- Sponsor --&gt;&lt;a href=&quot;https://github.com/sponsors/guilatrova&quot;&gt;&lt;img alt=&quot;Sponsor guilatrova&quot; src=&quot;https://img.shields.io/github/sponsors/guilatrova?logo=GitHub%20Sponsors&amp;style=social&quot;/&gt;&lt;/a&gt;&lt;/p&gt;Gracy helps you handle failures, logging, retries, throttling, and tracking for all your HTTP interactions. Gracy uses [httpx](https://github.com/encode/httpx) under the hood.&gt; &quot;Let Gracy do the boring stuff while you focus on your application&quot;---**Summary**- [üßëüíª Get started](#-get-started)  - [Installation](#installation)  - [Usage](#usage)    - [Simple example](#simple-example)    - [More examples](#more-examples)- [Settings](#settings)  - [Strict/Allowed status code](#strictallowed-status-code)  - [Custom Validators](#custom-validators)  - [Parsing](#parsing)  - [Retry](#retry)  - [Throttling](#throttling)  - [Logging](#logging)  - [Custom Exceptions](#custom-exceptions)- [Reports](#reports)  - [Logger](#logger)  - [List](#list)  - [Table](#table)- [Replay requests](#replay-requests)  - [Recording](#recording)  - [Replay](#replay)- [Advanced Usage](#advanced-usage)  - [Customizing/Overriding configs per method](#customizingoverriding-configs-per-method)  - [Customizing HTTPx client](#customizing-httpx-client)  - [Overriding default request timeout](#overriding-default-request-timeout)  - [Creating a custom Replay data source](#creating-a-custom-replay-data-source)  - [Hooks before/after request](#hooks-beforeafter-request)- [üìö Extra Resources](#-extra-resources)- [Change log](#change-log)- [License](#license)- [Credits](#credits)## üßëüíª Get started### Installation```pip install gracy```OR```poetry add gracy```### UsageExamples will be shown using the [PokeAPI](https://pokeapi.co).#### Simple example```py# 0. Importimport asyncioimport typing as tfrom gracy import BaseEndpoint, Gracy, GracyConfig, LogEvent, LogLevel# 1. Define your endpointsclass PokeApiEndpoint(BaseEndpoint):    GET_POKEMON = &quot;/pokemon/{NAME}&quot; # üëà Put placeholders as needed# 2. Define your Graceful APIclass GracefulPokeAPI(Gracy[str]):    class Config:  # type: ignore        BASE_URL = &quot;https://pokeapi.co/api/v2/&quot; # üëà Optional BASE_URL        # üëá Define settings to apply for every request        SETTINGS = GracyConfig(          log_request=LogEvent(LogLevel.DEBUG),          log_response=LogEvent(LogLevel.INFO, &quot;{URL} took {ELAPSED}&quot;),          parser={            &quot;default&quot;: lambda r: r.json()          }        )    async def get_pokemon(self, name: str) -&gt; t.Awaitable[dict]:        return await self.get(PokeApiEndpoint.GET_POKEMON, {&quot;NAME&quot;: name})pokeapi = GracefulPokeAPI()async def main():    try:      pokemon = await pokeapi.get_pokemon(&quot;pikachu&quot;)      print(pokemon)    finally:        pokeapi.report_status(&quot;rich&quot;)asyncio.run(main())```#### More examples- [PokeAPI with retries, parsers, logs](./examples/pokeapi.py)- [PokeAPI with throttling](./examples/pokeapi_throttle.py)- [PokeAPI with SQLite replay](./examples/pokeapi_replay.py)- [PokeAPI with Mongo replay](./examples/pokeapi_replay_mongo.py)## Settings### Strict/Allowed status codeBy default Gracy considers any successful status code (200-299) as successful.**Strict**You can modify this behavior by defining a strict status code or increase the range of allowed status codes:```pyfrom http import HTTPStatusGracyConfig(  strict_status_code=HTTPStatus.CREATED)```or a list of values:```pyfrom http import HTTPStatusGracyConfig(  strict_status_code={HTTPStatus.OK, HTTPStatus.CREATED})```Using `strict_status_code` means that any other code not specified will raise an error regardless of being successful or not.**Allowed**You can also keep the behavior, but extend the range of allowed codes.```pyfrom http import HTTPStatusGracyConfig(  allowed_status_code=HTTPStatus.NOT_FOUND)```or a list of values```pyfrom http import HTTPStatusGracyConfig(  allowed_status_code={HTTPStatus.NOT_FOUND, HTTPStatus.FORBIDDEN})```Using `allowed_status_code` means that all successful codes plus your defined codes will be considered successful.This is quite useful for parsing as you'll see soon.‚ö†Ô∏è Note that `strict_status_code` takes precedence over `allowed_status_code`, probably you don't want to combine those. Prefer one or the other.### Custom ValidatorsYou can implement your own custom validator to do further checks on the response and decide whether to consider the request failed (and as consequence trigger retries if they're set).```pyfrom gracy import GracefulValidatorclass MyException(Exception):  passclass MyCustomValidator(GracefulValidator):    def check(self, response: httpx.Response) -&gt; None:        jsonified = response.json()        if jsonified.get('error', None):          raise MyException(&quot;Error is not expected&quot;)        return None...class Config:  SETTINGS = GracyConfig(    ...,    retry=GracefulRetry(retry_on=MyException, ...),  # Set up retry to work whenever our validator fails    validators=MyCustomValidator(),  # Set up validator  )```### ParsingParsing allows you to handle the request based on the status code returned.The basic example is parsing `json`:```pyGracyConfig(  parser={    &quot;default&quot;: lambda r: r.json()  })```In this example all successful requests will automatically return the `json()` result.You can also narrow it down to handle specific status codes.```pyclass Config:  SETTINGS = GracyConfig(    ...,    allowed_status_code=HTTPStatusCode.NOT_FOUND,    parser={      &quot;default&quot;: lambda r: r.json()      HTTPStatusCode.NOT_FOUND: None    }  )async def get_pokemon(self, name: str) -&gt; dict| None:  # üëá Returns either dict or None  return await self.get(PokeApiEndpoint.GET_POKEMON, {&quot;NAME&quot;: name})```Or even customize [exceptions to improve your code readability](https://guicommits.com/handling-exceptions-in-python-like-a-pro/):```pyclass PokemonNotFound(GracyUserDefinedException):  ... # More on exceptions belowclass Config:  GracyConfig(    ...,    allowed_status_code=HTTPStatusCode.NOT_FOUND,    parser={      &quot;default&quot;: lambda r: r.json()      HTTPStatusCode.NOT_FOUND: PokemonNotFound    }  )async def get_pokemon(self, name: str) -&gt; Awaitable[dict]:  # üëá Returns either dict or raises PokemonNotFound  return await self.get(PokeApiEndpoint.GET_POKEMON, {&quot;NAME&quot;: name})```### RetryWho doesn't hate flaky APIs? üôãYet there're many of them.Using tenacity, backoff, retry, aiohttp_retry, and any other retry libs is **NOT easy enough**. üôÖYou still would need to code the implementation for each request which is annoying.Here's how Gracy allows you to implement your retry logic:```pyclass Config:  GracyConfig(    retry=GracefulRetry(      delay=1,      max_attempts=3,      delay_modifier=1.5,      retry_on=None,      log_before=None,      log_after=LogEvent(LogLevel.WARNING),      log_exhausted=LogEvent(LogLevel.CRITICAL),      behavior=&quot;break&quot;,    )  )```| Parameter        | Description                                                                                                     | Example                                                                                                                              || ---------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ || `delay`          | How many seconds to wait between retries                                                                        | `2` would wait 2 seconds, `1.5` would wait 1.5 seconds, and so on                                                                    || `max_attempts`   | How many times should Gracy retry the request?                                                                  | `10` means 1 regular request with additional 10 retries in case they keep failing. `1` should be the minimum                         || `delay_modifier` | Allows you to specify increasing delay times by multiplying this value to `delay`                               | Setting `1` means no delay change. Setting `2` means delay will be doubled every retry                                               || `retry_on`       | Should we retry for which status codes/exceptions? `None` means for any non successful status code or exception | `HTTPStatus.BAD_REQUEST`, or `{HTTPStatus.BAD_REQUEST, HTTPStatus.FORBIDDEN}`, or `Exception` or `{Exception, HTTPStatus.NOT_FOUND}` || `log_before`     | Specify log level. `None` means don't log                                                                       | More on logging later                                                                                                                || `log_after`      | Specify log level. `None` means don't log                                                                       | More on logging later                                                                                                                || `log_exhausted`  | Specify log level. `None` means don't log                                                                       | More on logging later                                                                                                                || `behavior`       | Allows you to define how to deal if the retry fails. `pass` will accept any retry failure                       | `pass` or `break` (default)                                                                                                          || `overrides`      | Allows to override `delay` based on last response status code                                                   | `{HTTPStatus.BAD_REQUEST: OverrideRetryOn(delay=0), HTTPStatus.INTERNAL_SERVER_ERROR: OverrideRetryOn(delay=10)}`                    |### ThrottlingRate limiting issues? No more.Gracy helps you proactively deal with it before any API throws 429 in your face.**Creating rules**You can define rules per endpoint using regex:```pySIMPLE_RULE = ThrottleRule(  url_pattern=r&quot;.*&quot;,  max_requests=2)print(SIMPLE_RULE)# Output: &quot;2 requests per second for URLs matching re.compile('.*')&quot;COMPLEX_RULE = ThrottleRule(  url_pattern=r&quot;.*\/pokemon\/.*&quot;,  max_requests=10,  per_time=timedelta(minutes=1, seconds=30),)print(COMPLEX_RULE)# Output: 10 requests per 90 seconds for URLs matching re.compile('.*\\/pokemon\\/.*')```**Setting throttling**You can set up logging and assign rules as:```pyclass Config:  GracyConfig(    throttling=GracefulThrottle(        rules=ThrottleRule(r&quot;.*&quot;, 2), # 2 reqs/s for any endpoint        log_limit_reached=LogEvent(LogLevel.ERROR),        log_wait_over=LogEvent(LogLevel.WARNING),    ),  )```### LoggingYou can **define and customize logs** for events by using `LogEvent` and `LogLevel`:```pyverbose_log = LogEvent(LogLevel.CRITICAL)custom_warn_log = LogEvent(LogLevel.WARNING, custom_message=&quot;{METHOD} {URL} is quite slow and flaky&quot;)custom_error_log = LogEvent(LogLevel.INFO, custom_message=&quot;{URL} returned a bad status code {STATUS}, but that's fine&quot;)```Note that placeholders are formatted and replaced later on by Gracy based on the event type, like:**Placeholders per event**| Placeholder             | Description                                           | Example                                     | Supported Events                   || ----------------------- | ----------------------------------------------------- | ------------------------------------------- | ---------------------------------- || `{URL}`                 | Full url being targetted                              | `https://pokeapi.co/api/v2/pokemon/pikachu` | *All*                              || `{UURL}`                | Full **Unformatted** url being targetted              | `https://pokeapi.co/api/v2/pokemon/{NAME}`  | *All*                              || `{ENDPOINT}`            | Endpoint being targetted                              | `/pokemon/pikachu`                          | *All*                              || `{UENDPOINT}`           | **Unformatted** endpoint being targetted              | `/pokemon/{NAME}`                           | *All*                              || `{METHOD}`              | HTTP Request being used                               | `GET`, `POST`                               | *All*                              || `{STATUS}`              | Status code returned by the response                  | `200`, `404`, `501`                         | *After Request, On request errors* || `{ELAPSED}`             | Amount of seconds taken for the request to complete   | *Numeric*                                   | *After Request, On request errors* || `{RETRY_DELAY}`         | How long Gracy will wait before repeating the request | *Numeric*                                   | *Any Retry event*                  || `{CUR_ATTEMPT}`         | Current attempt count for the current request         | *Numeric*                                   | *Any Retry event*                  || `{MAX_ATTEMPT}`         | Max attempt defined for the current request           | *Numeric*                                   | *Any Retry event*                  || `{THROTTLE_LIMIT}`      | How many reqs/s is defined for the current request    | *Numeric*                                   | *Any Throttle event*               || `{THROTTLE_TIME}`       | How long Gracy will wait before calling the request   | *Numeric*                                   | *Any Throttle event*               || `{THROTTLE_TIME_RANGE}` | Time range defined by the throttling rule             | `second`, `90 seconds`                      | *Any Throttle event*               |and you can set up the log events as follows:**Requests**1. Before request2. After response3. Response has non successful errors```pyGracyConfig(  log_request=LogEvent(),  log_response=LogEvent(),  log_errors=LogEvent(),)```**Retry**1. Before retry2. After retry3. When retry exhausted```pyGracefulRetry(  ...,  log_before=LogEvent(),  log_after=LogEvent(),  log_exhausted=LogEvent(),)```**Throttling**1. When reqs/s limit is reached2. When limit decreases again```pyGracefulThrottle(  ...,  log_limit_reached=LogEvent()  log_wait_over=LogEvent())```**Dynamic Customization**You can customize it even further by passing a lambda:```pyLogEvent(    LogLevel.ERROR,    lambda r: &quot;Request failed with {STATUS}&quot; f&quot; and it was {'redirected' if r.is_redirect else 'NOT redirected'}&quot;    if r    else &quot;&quot;,)```Consider that:- Not all log events have the response available, so you need to guard yourself against it- Placeholders still works (e.g. `{STATUS}`)- You need to watch out for some attrs that might break the formatting logic (e.g. `r.headers`)### Custom ExceptionsYou can define custom exceptions for more [fine grained control over your exception messages/types](https://guicommits.com/how-to-structure-exception-in-python-like-a-pro/).The simplest you can do is:```pyfrom gracy import Gracy, GracyConfigfrom gracy.exceptions import GracyUserDefinedExceptionclass MyCustomException(GracyUserDefinedException):  passclass MyApi(Gracy[str]):  class Config:    SETTINGS = GracyConfig(      ...,      parser={        HTTPStatus.BAD_REQUEST: MyCustomException      }    )```This will raise your custom exception under the conditions defined in your parser.You can improve it even further by customizing your message:```pyclass PokemonNotFound(GracyUserDefinedException):    BASE_MESSAGE = &quot;Unable to find a pokemon with the name [{NAME}] at {URL} due to {STATUS} status&quot;    def _format_message(self, request_context: GracyRequestContext, response: httpx.Response) -&gt; str:        format_args = self._build_default_args()        name = request_context.endpoint_args.get(&quot;NAME&quot;, &quot;Unknown&quot;)        return self.BASE_MESSAGE.format(NAME=name, **format_args)```## Reports### LoggerRecommended for production environments.Gracy reports a short summary using `logger.info`.```pythonpokeapi = GracefulPokeAPI()# do stuff with your APIpokeapi.report_status(&quot;logger&quot;)# OUTPUT‚ùØ Gracy tracked that 'https://pokeapi.co/api/v2/pokemon/{NAME}' was hit 1 time(s) with a success rate of 100.00%, avg latency of 0.45s, and a rate of 1.0 reqs/s.‚ùØ Gracy tracked a total of 2 requests with a success rate of 100.00%, avg latency of 0.24s, and a rate of 1.0 reqs/s.```### ListUses `print` to generate a short list with all attributes:```pythonpokeapi = GracefulPokeAPI()# do stuff with your APIpokeapi.report_status(&quot;list&quot;)# OUTPUT   ____  / ___|_ __ __ _  ___ _   _ | |  _| '__/ _` |/ __| | | | | |_| | | | (_| | (__| |_| |  \____|_|  \__,_|\___|\__, |                       |___/  Requests Summary Report1. https://pokeapi.co/api/v2/pokemon/{NAME}    Total Reqs (#): 1       Success (%): 100.00%          Fail (%): 0.00%   Avg Latency (s): 0.39   Max Latency (s): 0.39         2xx Resps: 1         3xx Resps: 0         4xx Resps: 0         5xx Resps: 0      Avg Reqs/sec: 1.0 reqs/s2. https://pokeapi.co/api/v2/generation/{ID}/    Total Reqs (#): 1       Success (%): 100.00%          Fail (%): 0.00%   Avg Latency (s): 0.04   Max Latency (s): 0.04         2xx Resps: 1         3xx Resps: 0         4xx Resps: 0         5xx Resps: 0      Avg Reqs/sec: 1.0 reqs/sTOTAL    Total Reqs (#): 2       Success (%): 100.00%          Fail (%): 0.00%   Avg Latency (s): 0.21   Max Latency (s): 0.00         2xx Resps: 2         3xx Resps: 0         4xx Resps: 0         5xx Resps: 0      Avg Reqs/sec: 1.0 reqs/s```### TableIt requires you to install [Rich](https://github.com/Textualize/rich).```pypokeapi = GracefulPokeAPI()# do stuff with your APIpokeapi.report_status(&quot;rich&quot;)```Here's an example of how it looks:![Report](https://raw.githubusercontent.com/guilatrova/gracy/main/img/report-example.png)## Replay requestsGracy allows you to replay requests and responses from previous interactions.This is powerful because it allows you to test APIs without latency or consuming your rate limit. Now writing unit tests that relies on third-party APIs is doable.It works in two steps:| **Step**     | **Description**                                                                | **Hits the API?** || ------------ | ------------------------------------------------------------------------------ | ----------------- || 1. Recording | Stores all requests/responses to be later replayed                             | **Yes**           || 2. Replay    | Returns all previously generated responses based on your request as a &quot;replay&quot; | No                |### RecordingThe effort to record requests/responses is ZERO. You just need to pass a recording config to your Graceful API:```pyfrom gracy import GracyReplayfrom gracy.replays.storages.sqlite import SQLiteReplayStoragerecord_mode = GracyReplay(&quot;record&quot;, SQLiteReplayStorage(&quot;pokeapi.sqlite3&quot;))pokeapi = GracefulPokeAPI(record_mode)```**Every request** will be recorded to the defined data source.### ReplayOnce you have recorded all your requests you can enable the replay mode:```pyfrom gracy import GracyReplayfrom gracy.replays.storages.sqlite import SQLiteReplayStoragereplay_mode = GracyReplay(&quot;replay&quot;, SQLiteReplayStorage(&quot;pokeapi.sqlite3&quot;))pokeapi = GracefulPokeAPI(replay_mode)```**Every request** will be routed to the defined data source resulting in faster responses.**‚ö†Ô∏è Note that parsers, retries, throttling, and similar configs will work as usual**.## Advanced Usage### Customizing/Overriding configs per methodAPIs may return different responses/conditions/payloads based on the endpoint.You can override any `GracyConfig` on a per method basis by using the `@graceful` decorator.NOTE: Use `@graceful_generator` if your function uses `yield`.```pythonfrom gracy import Gracy, GracyConfig, GracefulRetry, graceful, graceful_generatorretry = GracefulRetry(...)class GracefulPokeAPI(Gracy[PokeApiEndpoint]):    class Config:  # type: ignore        BASE_URL = &quot;https://pokeapi.co/api/v2/&quot;        SETTINGS = GracyConfig(            retry=retry,            log_errors=LogEvent(                LogLevel.ERROR, &quot;How can I become a pokemon master if {URL} keeps failing with {STATUS}&quot;            ),        )    @graceful(        retry=None, # üëà Disables retry set in Config        log_errors=None, # üëà Disables log_errors set in Config        allowed_status_code=HTTPStatus.NOT_FOUND,        parser={            &quot;default&quot;: lambda r: r.json()[&quot;order&quot;],            HTTPStatus.NOT_FOUND: None,        },    )    async def maybe_get_pokemon_order(self, name: str):        val: str | None = await self.get(PokeApiEndpoint.GET_POKEMON, {&quot;NAME&quot;: name})        return val    @graceful( # üëà Retry and log_errors are still set for this one      strict_status_code=HTTPStatus.OK,      parser={&quot;default&quot;: lambda r: r.json()[&quot;order&quot;]},    )    async def get_pokemon_order(self, name: str):      val: str = await self.get(PokeApiEndpoint.GET_POKEMON, {&quot;NAME&quot;: name})      return val    @graceful_generator( # üëà Retry and log_errors are still set for this one      parser={&quot;default&quot;: lambda r: r.json()[&quot;order&quot;]},    )    async def get_2_pokemons(self):      names = [&quot;charmander&quot;, &quot;pikachu&quot;]      for name in names:          r = await self.get(PokeApiEndpoint.GET_POKEMON, {&quot;NAME&quot;: name})          yield r```### Customizing HTTPx clientYou might want to modify the HTTPx client settings, do so by:```pyclass YourAPIClient(Gracy[str]):    class Config:  # type: ignore        ...    def __init__(self, token: token) -&gt; None:        self._token = token        super().__init__()    # üëá Implement your logic here    def _create_client(self) -&gt; httpx.AsyncClient:        client = super()._create_client()        client.headers = {&quot;Authorization&quot;: f&quot;token {self._token}&quot;}  # type: ignore        return client```### Overriding default request timeoutAs default Gracy won't enforce a request timeout.You can define your own by setting it on Config as:```pyclass GracefulAPI(GracyApi[str]):  class Config:    BASE_URL = &quot;https://example.com&quot;    REQUEST_TIMEOUT = 10.2  # üëà Here```### Creating a custom Replay data sourceGracy was built with extensibility in mind.You can create your own storage to store/load anywhere (e.g. SQL Database), here's an example:```pyimport httpxfrom gracy import GracyReplayStorageclass MyCustomStorage(GracyReplayStorage):  def prepare(self) -&gt; None: # (Optional) Executed upon API instance creation.    ...  async def record(self, response: httpx.Response) -&gt; None:    ... # REQUIRED. Your logic to store the response object. Note the httpx.Response has request data.  async def load(self, request: httpx.Request) -&gt; httpx.Response:    ... # REQUIRED. Your logic to load a response object based on the request.# Usagerecord_mode = GracyReplay(&quot;record&quot;, MyCustomStorage())replay_mode = GracyReplay(&quot;replay&quot;, MyCustomStorage())pokeapi = GracefulPokeAPI(record_mode)```### Hooks before/after requestYou can set up hooks simply by defining `async def before` and `async def after` methods.‚ö†Ô∏è NOTE: Gracy configs are disabled within these methods which means that retries/parsers/throttling won't take effect inside it.```pyclass GracefulPokeAPI(Gracy[PokeApiEndpoint]):    class Config:  # type: ignore        BASE_URL = &quot;https://pokeapi.co/api/v2/&quot;        SETTINGS = GracyConfig(            retry=RETRY,            allowed_status_code={HTTPStatus.NOT_FOUND},            parser={HTTPStatus.NOT_FOUND: None},        )    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt; None:        self.before_count = 0        self.after_status_counter = defaultdict[HTTPStatus, int](int)        self.after_aborts = 0        self.after_retries_counter = 0        super().__init__(*args, **kwargs)    async def before(self, context: GracyRequestContext):        self.before_count += 1    async def after(        self,        context: GracyRequestContext, # Current request context        response_or_exc: httpx.Response | Exception,  # Either the request or an error        retry_state: GracefulRetryState | None,  # Set when this is generated from a retry    ):        if retry_state:            self.after_retries_counter += 1        if isinstance(response_or_exc, httpx.Response):            self.after_status_counter[HTTPStatus(response_or_exc.status_code)] += 1        else:            self.after_aborts += 1    async def get_pokemon(self, name: str):        return await self.get(PokeApiEndpoint.GET_POKEMON, {&quot;NAME&quot;: name})```In the example above invoking `get_pokemon()` will trigger `before()`/`after()` hooks in sequence.## üìö Extra ResourcesSome good practices I learned over the past years guided Gracy's philosophy, you might benefit by reading:- [How to log](https://guicommits.com/how-to-log-in-python-like-a-pro/)- [How to handle exceptions](https://guicommits.com/handling-exceptions-in-python-like-a-pro/)  - [How to structure exceptions](https://guicommits.com/how-to-structure-exception-in-python-like-a-pro/)- [How to use Async correctly](https://guicommits.com/effective-python-async-like-a-pro/)- [Book: Python like a PRO](https://guilatrova.gumroad.com/l/python-like-a-pro)- [Book: Effective Python](https://amzn.to/3bEVHpG)&lt;!-- ## Contributing --&gt;&lt;!-- Thank you for considering making Gracy better for everyone! --&gt;&lt;!-- Refer to [Contributing docs](docs/CONTRIBUTING.md).--&gt;## Change logSee [CHANGELOG](CHANGELOG.md).## LicenseMIT## CreditsThanks to the last three startups I worked which forced me to do the same things and resolve the same problems over and over again. I got sick of it and built this lib.Most importantly: **Thanks to God**, who allowed me (a random üáßüá∑ guy) to work for many different üá∫üá∏ startups. This is ironic since due to God's grace, I was able to build Gracy. üôåAlso, thanks to the [httpx](https://github.com/encode/httpx) and [rich](https://github.com/Textualize/rich) projects for the beautiful and simple APIs that powers Gracy.</longdescription>
</pkgmetadata>