<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![PyPI version](https://badge.fury.io/py/odd-collector-sdk.svg)](https://badge.fury.io/py/odd-collector-sdk)# ODD Collector SDKRoot project for ODD collectors### Domain* `CollectorConfig`    _Main config file for collector_    ``` python    class CollectorConfig(pydantic.BaseSettings):        default_pulling_interval: int # pulling interval in minutes        token: str                    # token for requests to odd-platform        plugins: Any        platform_host_url: str    ```* `Collector`    Args:    `config_path`: str - path to collector_config.yaml (i.e. `'/collector_config.yaml'`)    `root_package`: str - root package for adapters which will be loaded (i.e. `'my_collector.adapters'`)    `plugins_union_type` - Type variable for pydantic model.* `Plugin`  Is a config for adapter  ```python  class Plugin(pydantic.BaseSettings):    name: str    description: Optional[str] = None    namespace: Optional[str] = None  ```  Plugin class inherited from Pydantic's BaseSetting,it means it can take any field, which was skipped in `collector_config.yaml`, from env variables.  Field `type: Literal[&quot;custom_adapter&quot;]`  is obligatory for each plugin, by convention literal **MUST** have same name with adapter package  Plugins example:  ```python    # plugins.py    class AwsPlugin(Plugin):        aws_secret_access_key: str        aws_access_key_id: str        aws_region: str        class S3Plugin(AwsPlugin):        type: Literal[&quot;s3&quot;]        buckets: Optional[List[str]] = []    class GluePlugin(AwsPlugin):        type: Literal[&quot;glue&quot;]        # For Collector's plugins_union_type argument    AvailablePlugin = Annotated[        Union[            GluePlugin,            S3Plugin,        ],        pydantic.Field(discriminator=&quot;type&quot;),    ]  ```* AbstractAdapter    Abstract adapter which **MUST** be implemented by generic adapters## Collector example### RequirenmentsUse the package manager [poetry](https://python-poetry.org/) to install add odd-collector-sdk and asyncio.```bashpoetry add odd-collector-sdk```### A typical top-level collector's directory layout (as an example we took poetry project)    .    ├── my_collector                │   ├── adapters            # Adapters    │   │   ├── custom_adapter  # Some adapter package    │   │   │   ├── adapter.py  # Entry file for adapter    │   │   │   └── __init__.py    │   │   ├── other_custom_adapter    │   │   ├── ...             # Other adapters    │   │   └── __init__.py    │   ├── domain              # Domain models    │   │   ├── ...    │   │   ├── plugins.py      # Models for available plugins    │   │   └── __init__.py    │   ├── __init__.py             │   └── __main__.py         # Entry file for collector    ├── ...    ├── collector_config.yaml    ├── pyproject.toml    ├── LICENSE    └── README.md### Adapters folderEach adapter inside adapters folder must have an `adapter.py` file with an `Adapter` class implementing `AbstractAdapter````python    # custom_adapter/adapter.py example    from odd_collector_sdk.domain.adapter import AbstractAdapter    from odd_models.models import DataEntityList    #     class Adapter(AbstractAdapter):        def __init__(self, config: any) -&gt; None:            super().__init__()        def get_data_entity_list(self) -&gt; DataEntityList:            return DataEntityList(data_source_oddrn=&quot;test&quot;)        def get_data_source_oddrn(self) -&gt; str:            return &quot;oddrn&quot;```### PluginsEach plugin must implement `Plugin` class from sdk```python    # domain/plugins.py    from typing import Literal, Union    from typing_extensions import Annotated    import pydantic    from odd_collector_sdk.domain.plugin import Plugin    class CustomPlugin(Plugin):        type: Literal[&quot;custom_adapter&quot;]    class OtherCustomPlugin(Plugin):        type: Literal[&quot;other_custom_adapter&quot;]    # Needs this type variable for Collector initialization    AvailablePlugins = Annotated[        Union[CustomPlugin, OtherCustomPlugin],        pydantic.Field(discriminator=&quot;type&quot;),    ]```### collector_config.yaml```yamldefault_pulling_interval: 10 token: &quot;&quot; platform_host_url: &quot;http://localhost:8080&quot; plugins:  - type: custom_adapter    name: custom_adapter_name  - type: other_custom_adapter    name: other_custom_adapter_name```## Usage```python# __main__.pyimport asyncioimport loggingfrom os import pathfrom odd_collector_sdk.collector import Collector# Union type of avalable pluginsfrom my_collector.domain.plugins import AvailablePluginslogging.basicConfig(    level=logging.INFO, format=&quot;[%(asctime)s] %(levelname)s in %(module)s: %(message)s&quot;)try:    cur_dirname = path.dirname(path.realpath(__file__))    config_path = path.join(cur_dirname, &quot;../collector_config.yaml&quot;)    root_package = &quot;my_collector.adapters&quot;    loop = asyncio.get_event_loop()    collector = Collector(config_path, root_package, AvailablePlugin)    loop.run_until_complete(collector.register_data_sources())    collector.start_polling()    loop.run_forever()except Exception as e:    logging.error(e, exc_info=True)    loop.stop()```And run```bashpoetry run python -m my_collector```</longdescription>
</pkgmetadata>