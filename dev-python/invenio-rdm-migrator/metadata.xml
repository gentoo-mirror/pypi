<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>..    Copyright (C) 2022-2023 CERN.    Invenio-RDM-Migrator is free software; you can redistribute it and/or    modify it under the terms of the MIT License; see LICENSE file for more    details.===================== Invenio-RDM-Migrator=====================.. image:: https://github.com/inveniosoftware/invenio-rdm-migrator/workflows/CI/badge.svg        :target: https://github.com/inveniosoftware/invenio-rdm-migrator/actions?query=workflow%3ACI+branch%3Amaster.. image:: https://img.shields.io/github/tag/inveniosoftware/invenio-rdm-migrator.svg        :target: https://github.com/inveniosoftware/invenio-rdm-migrator/releases.. image:: https://img.shields.io/pypi/dm/invenio-rdm-migrator.svg        :target: https://pypi.python.org/pypi/invenio-rdm-migrator.. image:: https://img.shields.io/github/license/inveniosoftware/invenio-rdm-migrator.svg        :target: https://github.com/inveniosoftware/invenio-rdm-migrator/blob/master/LICENSEDataCite-based data model for Invenio.Development===========Install-------Make sure that you have `libpq-dev` installed in your system. See`psycopg installation instructions &lt;https://www.psycopg.org/install/&gt;`_for more information.Choose a version of search and database, then run:.. code-block:: console    pip install -e .Tests-----.. code-block:: console    ./run-tests.shHow to run it=============To run the migration you need:- A running InvenioRDM instance.- If your data contains references to other records (e.g. vocabularies),  then it is also required to run the setup step... code-block:: console    invenio-cli services setup --force --no-demo-data- Install Invenio-RDM-Migrator, any other dependencies must be handled  in the Pipfile of your instance... code-block:: console    $ pip install invenio-rdm-migrator- Create/edit the configuration file on your instance, for example  `streams.yaml`:.. code-block:: yaml    data_dir: /path/to/data    tmp_dir: /path/to/tmp    state_dir: /path/to/state    log_dir: /path/to/logs    db_uri: postgresql+psycopg2://inveniordm:inveniordm@localhost:5432/inveniordm    old_secret_key: CHANGE_ME    new_secret_key: CHANGE_ME    records:        extract:            filename: /path/to/records.json- You will need to create a small python script  putting together the different blocks of the ETL. You can find an eample  at `my-site/site/my_site/migrator/__main__.py`... code-block:: python    from invenio_rdm_migrator.streams import StreamDefinition    from invenio_rdm_migrator.streams.records import RDMRecordCopyLoad    if __name__ == &quot;__main__&quot;:        RecordStreamDefinition = StreamDefinition(            name=&quot;records&quot;,            extract_cls=JSONLExtract,            transform_cls=ZenodoToRDMRecordTransform,            load_cls=RDMRecordCopyLoad,        )        runner = Runner(            stream_definitions=[                RecordStreamDefinition,            ],            config_filepath=&quot;path/to/your/streams.yaml&quot;,        )        runner.run()- Finally, you can execute the above code. Since it is in the `__main__` file  of the python package, you can run it as a module:.. code-block:: console    $ python -m my_site.migrator- Once the migration has completed, in your instance you can reindex the data.  Following the records example above, it would look like:.. code-block:: console    $ invenio-cli pyshell    In [1]: from invenio_access.permissions import system_identity    In [2]: from invenio_rdm_records.proxies import current_rdm_records_service    In [3]: current_rdm_records_service.rebuild_index(identity=system_identity)ETL {Extract/Transform/Load} architecture=========================================There are four packages in this module `extract`, `transform`, `load`, and`streams`. The first three correspond to the three steps of an ETL process.The `streams` package contains the logic to run the process and differentstream-specific implementations of ETL classes (e.g. `records`).Extract-------The extract is the first part of the data processing stream. It'sfunctionality is quite simple: return an iterator (e.g. of records), where eachyielded value is a dictionary. Note that the data in this step is _transformed_in format (e.g. JSON, XML), not in content. For example, the implementation of`XMLExtract` would look as follows:.. code-block:: python    class XMLExtract(Extract):    ...        def run(self):            with open(&quot;file.xml&quot;) as file:                for entry in file:                    yield xml.loads(entry)Transform---------The transformer is in charge of modifying the content to suit, in this case,the InvenioRDM data model (e.g. for records) so it can be imported in the DB.It will loop through the entries (i.e. the iterator returned by the extractclass), transform and yield (e.g. the record). Diving more in the example ofa record:To transform something to an RDM record, you need to implement`streams/records/transform.py:RDMRecordTransform`. For each record it willyield what is considered a semantically &quot;full&quot; record: the record itself,its parent, its draft in case it exists and the files related them... code-block:: python    {        &quot;record&quot;: self._record(entry),        &quot;draft&quot;: self._draft(entry),        &quot;parent&quot;: self._parent(entry),        &quot;record_files&quot;: self._record_files(entry),        &quot;draft_files&quot;: self._draft_files(entry),    }This means that you will need to implement the functions for each key. Notethat, only `_record` and `_parent` should return content, the others can return`None`.Some of these functions can themselves use a `transform/base:Entry`transformer. An _entry_ transformer is an extra layer of abstraction, toprovide an interface with the methods needed to generate valid data for part ofthe `Transform` class. In the record example, you can implement`transform.base:RDMRecordEntry`, which can be used in the`RDMRecordTransform._record` function mentioned in the code snippet above. Notethat implementing this interface will produce valid _data_ for a record.However, there is no abc for _metadata_. It is an open question how much weshould define these interfaces and avoid duplicating the already existingMarshmallow schemas of InvenioRDM.At this point you might be wondering &quot;Why not Marshmallow then?&quot;. The answer is&quot;separation of responsibilities, performance and simplicity&quot;. The later layswith the fact that most of the data transformation is custom, so we would endup with a schema full of `Method` fields, which does not differ much from whatwe have but would have an impact on performance (Marshmallow is slow...).Regarding the responsibilities part, validating (mostly referential, likevocabularies) can only be done on (or after) _load_ where RDM instance knowledge/appctxis available.Note that no validation, not even structural, is done in this step.Load----The final step to have the records available in the RDM instance is to loadthem. There are two types of loading _bulk_ or _transactions_.Bulk....Bulk loading will insert data in the database table by table using `COPY`. Sincethe order of the tables is not guaranteed it is necessary to drop foreign keys beforeloading. They can be restored afterwards. In addition, dropping indices would increaseperformance since they will only be calculated once, when they are restored after loading.Bulk loading is done using the `load.postgresql.bulk:PostgreSQLCopyLoad` class, which willcarry out 2 steps:1. Prepare the data, writing one DB row per line in a csv file:.. code-block:: console    $ /path/to/data/tables1668697280.943311        |        | - pidstore_pid.csv        | - rdm_parents_metadata.csv        | - rdm_records_metadata.csv        | - rdm_versions_state.csv2. Perform the actual loading, using `COPY`. Inserting all rows at once is more   efficient than performing one `INSERT` per row.Internally what is happening is that the `prepare` function makes use of`TableGenerator` implementations and then yields the list of csv files.So the `load` only iterates through the filenames, not the actual entries.A `TableGenerator` will, for each value in the iterator, yield oneor more rows (lines to be written to the a csv file). For example for a recordit will yield: recid, DOI and OAI (PersistentIdentifiers), record and parentmetadata, etc. which will be written to the respective CSV file.Transactions............Another option is to migrate transactions. For example, once you have done the initialpart of it in bulk, you can migrate the changes that were persisted while the bulkmigration happened. That can be achieved by migrating transactions. A transaction is agroup of operations, which can be understod as SQL statement and thus have two values:the operation type (created, update, delete) and its data represented as a database model.Transaction loading is done using the `load.postgresql.transactions:PostgreSQLExecuteLoad`class, which will carry out 2 similar steps to the one above:1. Prepare the data, storing in memory a series of `Operation`\s.2. Perform the actual loading by adding or removing from the session, or updating the   corresponding object. Each operation is flushed to the database to avoid foreing key   violations. However, each transaction is atomic, meaning that an error in one of the   operations will cause the full transaction to fail as a group.Internally, the load will use an instance of`load.postgresql.transactions.generators.group:TxGenerator` to prepare theoperations. This class contains a mapping between table names and`load.postgresql.transactions.generators.row:RowGenerators`, which will return a list ofoperations with the data as database model in the `obj` attribute.Note that the `TxGenerator` is tightly coupled to the`transform.transactions.Tx` since it expects the dictionaries to have aspecific structure:.. code-block::    {        &quot;tx_id&quot;: the actual transaction id, useful for debug and error handling        &quot;action&quot;: this information refers to the semantic meaning of the group                       for example: record metadata update or file upload        &quot;operations&quot;: [            {                &quot;op&quot;: c (create), u (update), d (delete)                &quot;table&quot;: the name of the table in the source system (e.g. Zenodo)                &quot;data&quot;: the transformed data, this can use any `Transform` implementation            }        ]    }State=====During a migration run, there is a need to share information across different streamsor different generators on the same stream. For example, the records stream needs toaccess the UUID to slug map that was populated on the communities stream; or thedrafts generator needs to know which parent records have been created on the recordsgenerator to keep the version state consistent.All this information is persisted to a SQLite database. This state database is keptin memory during each stream processing, and it is persisted to disk if the streamfinishes without errors. The state will be saved with the name of the stream(e.g. `records.db`) to avoid overwriting a previous state. Therefore, a migration can berestarted from any stream.There are two ways to add more information to the state:- Full entities, for example record or users, require their own DB table. Those must be  defined at `state.py:State._initialize_db`. In addition, to abstract the access to that  table, a state entity is required. It needs to be initialized in the `Runner.py:Runner`  constructor and added the the `state_entities` dictionary.- Independent value, for example the maximum value of generated primary keys. Those can be  stored in the `global_state`. This state has two columns: key and value; adding  information to it would look like `{key: name_of_the_value, value: actual_value}`.Notes=====**Using python generators**Using generators instead of lists, allows us to iterate through the dataonly once and perform the E-T-L steps on them. Instead of loop for E, loopfor T, loop for L. In addition, this allows us to have the csv files openduring the writing and closing them at the end (open/close is an expensiveop when done 3M times)...    Copyright (C) 2022-2023 CERN.    Invenio-RDM-Migrator is free software; you can redistribute it and/or    modify it under the terms of the MIT License; see LICENSE file for more    details.Changes=======Version 4.3.0- Add community basic CRUD actions.- Add DB session fixtures.Version 4.2.0- Rename `FileUploadAction` to `DraftFileUploadAction`.Version 4.1.0- Add file upload action.- Add draft edit action.Version 4.0.0- Namespace actions by load and transform.Version 3.1.0- Add `DatetimeMixin` to transform timestamps into iso formatted date strings.- Add `JSONLoadMixin` to load dictionaries from strings.Version 3.0.0- `Operation` instances have split the model and the data into two attributes.- Add user actions.- `PostgreSQLTx` `resolve_references` function has now a default behaviour (`pass`).- Add nullable configuration to draft and user related models.- Minor bug fixes.Version 2.0.0- Make state globally available.- Refactor transactions into actions. Create transaction and load data classes.- Removed empty kafka extract module.- Improved error handling and created specialized classes.- Move `dict_set` to utils.- Remove Python 3.8 from test matrix.Version 1.0.0- Initial public release.</longdescription>
</pkgmetadata>