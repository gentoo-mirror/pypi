<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># `pure_eval`[![Build Status](https://travis-ci.org/alexmojaki/pure_eval.svg?branch=master)](https://travis-ci.org/alexmojaki/pure_eval) [![Coverage Status](https://coveralls.io/repos/github/alexmojaki/pure_eval/badge.svg?branch=master)](https://coveralls.io/github/alexmojaki/pure_eval?branch=master) [![Supports Python versions 3.5+](https://img.shields.io/pypi/pyversions/pure_eval.svg)](https://pypi.python.org/pypi/pure_eval)This is a Python package that lets you safely evaluate certain AST nodes without triggering arbitrary code that may have unwanted side effects.It can be installed from PyPI:    pip install pure_evalTo demonstrate usage, suppose we have an object defined as follows:```pythonclass Rectangle:    def __init__(self, width, height):        self.width = width        self.height = height    @property    def area(self):        print(&quot;Calculating area...&quot;)        return self.width * self.heightrect = Rectangle(3, 5)```Given the `rect` object, we want to evaluate whatever expressions we can in this source code:```pythonsource = &quot;(rect.width, rect.height, rect.area)&quot;```This library works with the AST, so let's parse the source code and peek inside:```pythonimport asttree = ast.parse(source)the_tuple = tree.body[0].valuefor node in the_tuple.elts:    print(ast.dump(node))```Output:```pythonAttribute(value=Name(id='rect', ctx=Load()), attr='width', ctx=Load())Attribute(value=Name(id='rect', ctx=Load()), attr='height', ctx=Load())Attribute(value=Name(id='rect', ctx=Load()), attr='area', ctx=Load())```Now to actually use the library. First construct an Evaluator:```pythonfrom pure_eval import Evaluatorevaluator = Evaluator({&quot;rect&quot;: rect})```The argument to `Evaluator` should be a mapping from variable names to their values. Or if you have access to the stack frame where `rect` is defined, you can instead use:```pythonevaluator = Evaluator.from_frame(frame)```Now to evaluate some nodes, using `evaluator[node]`:```pythonprint(&quot;rect.width:&quot;, evaluator[the_tuple.elts[0]])print(&quot;rect:&quot;, evaluator[the_tuple.elts[0].value])```Output:```rect.width: 3rect: &lt;__main__.Rectangle object at 0x105b0dd30&gt;```OK, but you could have done the same thing with `eval`. The useful part is that it will refuse to evaluate the property `rect.area` because that would trigger unknown code. If we try, it'll raise a `CannotEval` exception.```pythonfrom pure_eval import CannotEvaltry:    print(&quot;rect.area:&quot;, evaluator[the_tuple.elts[2]])  # failsexcept CannotEval as e:    print(e)  # prints CannotEval```To find all the expressions that can be evaluated in a tree:```pythonfor node, value in evaluator.find_expressions(tree):    print(ast.dump(node), value)```Output:```pythonAttribute(value=Name(id='rect', ctx=Load()), attr='width', ctx=Load()) 3Attribute(value=Name(id='rect', ctx=Load()), attr='height', ctx=Load()) 5Name(id='rect', ctx=Load()) &lt;__main__.Rectangle object at 0x105568d30&gt;Name(id='rect', ctx=Load()) &lt;__main__.Rectangle object at 0x105568d30&gt;Name(id='rect', ctx=Load()) &lt;__main__.Rectangle object at 0x105568d30&gt;```Note that this includes `rect` three times, once for each appearance in the source code. Since all these nodes are equivalent, we can group them together:```pythonfrom pure_eval import group_expressionsfor nodes, values in group_expressions(evaluator.find_expressions(tree)):    print(len(nodes), &quot;nodes with value:&quot;, values)```Output:```1 nodes with value: 31 nodes with value: 53 nodes with value: &lt;__main__.Rectangle object at 0x10d374d30&gt;```If we want to list all the expressions in a tree, we may want to filter out certain expressions whose values are obvious. For example, suppose we have a function `foo`:```pythondef foo():    pass```If we refer to `foo` by its name as usual, then that's not interesting:```pythonfrom pure_eval import is_expression_interestingnode = ast.parse('foo').body[0].valueprint(ast.dump(node))print(is_expression_interesting(node, foo))```Output:```pythonName(id='foo', ctx=Load())False```But if we refer to it by a different name, then it's interesting:```pythonnode = ast.parse('bar').body[0].valueprint(ast.dump(node))print(is_expression_interesting(node, foo))```Output:```pythonName(id='bar', ctx=Load())True```In general `is_expression_interesting` returns False for the following values:- Literals (e.g. `123`, `'abc'`, `[1, 2, 3]`, `{'a': (), 'b': ([1, 2], [3])}`)- Variables or attributes whose name is equal to the value's `__name__`, such as `foo` above or `self.foo` if it was a method.- Builtins (e.g. `len`) referred to by their usual name.To make things easier, you can combine finding expressions, grouping them, and filtering out the obvious ones with:```pythonevaluator.interesting_expressions_grouped(root)```To get the source code of an AST node, I recommend [asttokens](https://github.com/gristlabs/asttokens).Here's a complete example that brings it all together:```pythonfrom asttokens import ASTTokensfrom pure_eval import Evaluatorsource = &quot;&quot;&quot;x = 1d = {x: 2}y = d[x]&quot;&quot;&quot;names = {}exec(source, names)atok = ASTTokens(source, parse=True)for nodes, value in Evaluator(names).interesting_expressions_grouped(atok.tree):    print(atok.get_text(nodes[0]), &quot;=&quot;, value)```Output:```pythonx = 1d = {1: 2}y = 2d[x] = 2```</longdescription>
</pkgmetadata>