<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># django-entangledEdit JSON-Model Fields using a Standard Django Form.[![Build Status](https://travis-ci.org/jrief/django-entangled.svg?branch=master)](https://travis-ci.org/jrief/django-entangled)[![Coverage](https://codecov.io/github/jrief/django-entangled/coverage.svg?branch=master)](https://codecov.io/github/jrief/django-entangled?branch=master)[![PyPI](https://img.shields.io/pypi/pyversions/django-entangled.svg)]()[![PyPI version](https://img.shields.io/pypi/v/django-entangled.svg)](https://https://pypi.python.org/pypi/django-entangled)[![PyPI](https://img.shields.io/pypi/l/django-entangled.svg)]()## Use-CaseA Django Model may contain fields which accept arbitrary data stored as JSON. Django itself, provides a[JSON field](https://docs.djangoproject.com/en/stable/ref/models/fields/#django.db.models.JSONField) to store arbitraryserializable data.When creating a form from a model, the input field associated with a JSON field, typically is a `&lt;textarea ...&gt;&lt;/textarea&gt;`.This textarea widget is very inpracticable for editing, because it just contains a textual representation of thatobject notation. One possibility is to use a generic [JSON editor](https://github.com/josdejong/jsoneditor),which with some JavaScript, transforms the widget into an attribute-value-pair editor. This approach however requiresto manage the field keys ourself. It furthermore prevents us from utilizing all the nice features provided by the Djangoform framework, such as field validation, normalization of data and the usage of foreign keys.By using **django-entangled**, one can use a Django `ModelForm`, and store all,or a subset of that form fields in one or more JSON fields inside of the associated model.## InstallationSimply install this Django app, for instance by invoking:```bashpip install django-entangled```There is no need to add any configuration directives to the project's `settings.py`.## ExampleSay, we have a Django model to describe a bunch of different products. The name and the price fields are common to allproducts, whereas the properties can vary depending on its product type. Since we don't want to create a differentproduct model for each product type, we use a JSON field to store these arbitrary properties.```pythonfrom django.db import modelsclass Product(models.Model):    name = models.CharField(max_length=50)    price = models.DecimalField(max_digits=5, decimal_places=2)    properties = models.JSONField()```In a typical form editing view, we would create a form inheriting from[ModelForm](https://docs.djangoproject.com/en/stable/topics/forms/modelforms/#modelform) and refer to this model usingthe `model` attribute in its `Meta`-class. Then the `properties`-field would show up as unstructured JSON, renderedinside a `&lt;textarea ...&gt;&lt;/textarea&gt;`. This definitely is not what we want! Instead we create a typical Django Form usingthe alternative class `EntangledModelForm`.```pythonfrom django.contrib.auth import get_user_modelfrom django.forms import fields, modelsfrom entangled.forms import EntangledModelFormfrom .models import Productclass ProductForm(EntangledModelForm):    color = fields.RegexField(        regex=r'^#[0-9a-f]{6}$',    )    size = fields.ChoiceField(        choices=[('s', &quot;small&quot;), ('m', &quot;medium&quot;), ('l', &quot;large&quot;), ('xl', &quot;extra large&quot;)],    )    tenant = models.ModelChoiceField(        queryset=get_user_model().objects.filter(is_staff=True),    )    class Meta:        model = Product        entangled_fields = {'properties': ['color', 'size', 'tenant']}  # fields provided by this form        untangled_fields = ['name', 'price']  # these fields are provided by the Product model```In case our form inherits from another `ModelForm`, rewrite the class declarartion as:```pythonclass ProductForm(EntangledModelFormMixin, BaseProductForm):    ...```In addition we add a special dictionary named `entangled_fields` to our `Meta`-options. In this dictionary, the key(here `'properties'`) refers to the JSON-field in our model `Product`. The value (here `['color', 'size', 'tenant']`)is a list of named form fields, declared in our form- or base-class of thereof. This allows us to assign all standardDjango form fields to arbitrary JSON fields declared in our Django model. Moreover, we can even use a `ModelChoiceField`or a `ModelMultipleChoiceField` to refer to another model object using a[generic relation](https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/#generic-relations)Since in this form we also want to access the non-JSON fields from our Django model, we add a list named`untangled_fields` to our `Meta`-options. In this list, (here `['name', 'price']`) we refer to the non-JSON fieldsin our model `Product`. From both of these iterables, `entangled_fields` and `untangled_fields`, the parent class`EntangledModelForm` then builds the `Meta`-option `fields`, otherwise required. Therefore you should notuse `fields` to declare this list, but rather rely on `entangled_fields` and `untangled_fields`.We can use this form in any Django form view. A typical use-case, is the built-in Django `ModelAdmin`:```pythonfrom django.contrib import adminfrom .models import Productfrom .forms import ProductForm@admin.register(Product)class ProductAdmin(admin.ModelAdmin):    form = ProductForm```Since the form used by this `ModelAdmin`-class[can not be created dynamically](https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.form),we have to declare it explicitly using the `form`-attribute. This is the only change which has to be performed, inorder to store arbitrary content inside our JSON model-fields.## Nested Data StructuresSometimes it can be desirable to store the data in a nested hierarchy of dictionaries, rather than having allattribute-value-pairs in the first level of our JSON field. This can for instance be handy when merging more than oneform, all themselves ineriting from `EntangledModelFormMixin`.Say that we have different types of products, all of which share the same base product form:```pythonfrom django.contrib.auth import get_user_modelfrom django.forms import modelsfrom entangled.forms import EntangledModelFormMixinfrom .models import Productclass BaseProductForm(EntangledModelFormMixin):    tenant = models.ModelChoiceField(        queryset=get_user_model().objects.filter(is_staff=True),    )    class Meta:        model = Product        entangled_fields = {'properties': ['tenant']}        untangled_fields = ['name', 'price']```In order to specialize our base product towards, say clothing, we typically would inherit from the base formand add some additional fields, here `color` and `size`:```pythonfrom django.forms import fieldsfrom .forms import BaseProductFormfrom .models import Productclass ClothingProductForm(BaseProductForm):    color = fields.RegexField(        regex=r'^#[0-9a-f]{6}$',    )    size = fields.ChoiceField(        choices=[('s', &quot;small&quot;), ('m', &quot;medium&quot;), ('l', &quot;large&quot;), ('xl', &quot;extra large&quot;)],    )    class Meta:        model = Product        entangled_fields = {'properties': ['color', 'size']}        retangled_fields = {'color': 'variants.color', 'size': 'variants.size'}```By adding a name mapping from our existing field names, we can group the fields `color` and `size`into a sub-dictionary named `variants` inside our `properties` fields. Such a field mapping isdeclared through the optional Meta-option `retangled_fields`. In this dictionary, all entries areoptional; if a field name is missing, it just maps to itself.This mapping table can also be used to map field names to other keys inside the resulting JSONdatastructure. This for instance is handy to map fields containg an underscore into field-namescontaining instead a dash. ## CaveatsDue to the nature of JSON, indexing and thus building filters or sorting rules based on the fields content is not assimple, as with standard model fields. Therefore, this approach is best suited, if the main focus is to store data,rather than digging through data.Foreign keys are stored as `&quot;fieldname&quot;: {&quot;model&quot;: &quot;appname.modelname&quot;, &quot;pk&quot;: 1234}` in our JSON field, meaning thatwe have no database constraints. If a target object is deleted, that foreign key points to nowhere. Therefore alwayskeep in mind, that we don't have any referential integrity and hence must write our code in a defensive manner.[![Twitter Follow](https://img.shields.io/twitter/follow/jacobrief?style=social)](https://twitter.com/jacobrief)</longdescription>
</pkgmetadata>