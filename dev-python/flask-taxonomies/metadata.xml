<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Flask Taxonomies[![](https://img.shields.io/github/license/oarepo/flask-taxonomies.svg)](https://github.com/oarepo/flask-taxonomies/blob/master/LICENSE)[![](https://img.shields.io/travis/oarepo/flask-taxonomies.svg)](https://travis-ci.org/oarepo/flask-taxonomies)[![](https://img.shields.io/coveralls/oarepo/flask-taxonomies.svg)](https://coveralls.io/r/oarepo/flask-taxonomies)[![](https://img.shields.io/pypi/v/flask-taxonomies.svg)](https://pypi.org/pypi/flask-taxonomies)&lt;!--TOC--&gt;- [Flask Taxonomies](#flask-taxonomies)  - [Installation](#installation)  - [Terminology](#terminology)  - [REST API](#rest-api)    - [Retrieving resources](#retrieving-resources)      - [``Prefer`` HTTP header](#prefer-http-header)        - [Returned representation](#returned-representation)        - [Includes and excludes](#includes-and-excludes)          - [Including extra data](#including-extra-data)          - [Excluding data](#excluding-data)      - [Query parameters](#query-parameters)      - [Selecting subset of term data](#selecting-subset-of-term-data)      - [Pagination](#pagination)    - [Taxonomy](#taxonomy)      - [Creating](#creating)      - [Updating](#updating)        - [Replacing via HTTP PUT](#replacing-via-http-put)        - [Patching with HTTP POST](#patching-with-http-post)      - [Deleting](#deleting)    - [Taxonomy Term](#taxonomy-term)      - [Creating](#creating-1)      - [Updating](#updating-1)      - [Deleting](#deleting-1)      - [Un-Deleting](#un-deleting)      - [Moving](#moving)      - [Renaming](#renaming)  - [Configuration](#configuration)    - [Configuration Variables](#configuration-variables)    - [Security](#security)      - [Recommended initial settings](#recommended-initial-settings)  - [Python API](#python-api)    - [Signals](#signals)&lt;!--TOC--&gt;## Installation```bashpip install flask-taxonomies``````pythonfrom flask_taxonomies.ext import FlaskTaxonomiesfrom flask_taxonomies.views import blueprintfrom flask import Flaskfrom flask_principal import Principalapp = Flask('__test__')FlaskTaxonomies(app)Principal(app)app.register_blueprint(blueprint, url_prefix=app.config['FLASK_TAXONOMIES_URL_PREFIX'])db = ...from flask_taxonomies.models import BaseBase.metadata.create_all(db.engine)```## Terminology**Taxonomy** is a tree of taxonomy terms. It is represented as a database object identified by*code*. A taxonomy may contain its original url (in case the taxonomy is defined elsewhere)and additional metadata as a json object (containing, for example, taxonomy title). It may alsocontain a default set of selectors for filtering metadata.**TaxonomyTerm** represents a single node in a taxonomy. It is identified by its *slug* and may contain additional metadata as json object. A term can contain children to representhierarchy of taxonomy terms. Term does not define ordering within children, it is up to application logic to define any ordering.   ## REST APIThe rest API sits on the ``app.config['FLASK_TAXONOMIES_URL_PREFIX']`` url, implicitly ``/api/2.0/taxonomies/``. It follows the REST API principles with pagination inspiredby GitHub API. ### Retrieving resources#### ``Prefer`` HTTP headerImplicitly, the API returns rather minimal representation. The amount of the returned metadatacan be changed via HTTP ``prefer`` header or alternatively by query parameters.##### Returned representationThe ``prefer`` header is a standard way of telling what you expect to getas a response to the request. It is defined in [rfc7240](https://tools.ietf.org/html/rfc7240).If the header is not present, ``return=representation`` is assumed. One can specify ``return=minimal``to obtain minimal dataset, or other return types (even your own) defined in ``FLASK_TAXONOMIES_REPRESENTATION`` config.**return=minimal**returns the minimal representation. Mostly not usable directly as it does not return any metadata,just the code/slug.*Listing:*```console$ curl -i -H &quot;Prefer: return=minimal&quot; http://127.0.0.1:5000/api/2.0/taxonomies/HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/&gt;; rel=self[  {    &quot;code&quot;: &quot;country&quot;  }]```*Get taxonomy:*```console$ curl -i -H &quot;Prefer: return=minimal&quot; http://127.0.0.1:5000/api/2.0/taxonomies/countryHTTP/1.0 200 OKContent-Type: application/json{  &quot;code&quot;: &quot;country&quot;}```*Get term:*```console$ curl -i -H &quot;Prefer: return=minimal&quot; http://127.0.0.1:5000/api/2.0/taxonomies/country/europeHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&gt;; rel=tree{  &quot;slug&quot;: &quot;europe&quot;}```**return=representation**this is the default return type. Returns all user data declared on taxonomy/term together withancestor and urls. For example:*Listing:*```console$ curl -i http://127.0.0.1:5000/api/2.0/taxonomies/HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/&gt;; rel=self[  {    &quot;code&quot;: &quot;country&quot;,     &quot;links&quot;: {      &quot;custom&quot;: &quot;https://www.kaggle.com/nikitagrec/world-capitals-gps/data&quot;,       &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/&quot;    },     &quot;title&quot;: &quot;List of countries&quot;  }]```*Get term:*```console$ curl -i http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/czHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz?representation:include=dsc&gt;; rel=tree{  &quot;CapitalLatitude&quot;: &quot;50.083333333333336&quot;,   &quot;CapitalLongitude&quot;: &quot;14.466667&quot;,   &quot;CapitalName&quot;: &quot;Prague&quot;,   &quot;ContinentName&quot;: &quot;Europe&quot;,   &quot;CountryCode&quot;: &quot;CZ&quot;,   &quot;CountryName&quot;: &quot;Czech Republic&quot;,   &quot;ancestors&quot;: [    {      &quot;links&quot;: {        &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&quot;      }    }  ],   &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&quot;  }}`````Europe`` has no user data, so it contains only the ``links`` section.##### Includes and excludesThe returned representation can be modified by specifying which metadata should be included/excluded. Currently supported includes/excludes are:```pythonINCLUDE_URL = 'url'INCLUDE_DESCENDANTS_URL = 'drl'INCLUDE_DESCENDANTS_COUNT = 'dcn'INCLUDE_ANCESTORS_HIERARCHY = 'anh'INCLUDE_ANCESTORS = 'anc'INCLUDE_ANCESTOR_LIST = 'anl'INCLUDE_DATA = 'data'INCLUDE_ID = 'id'INCLUDE_DESCENDANTS = 'dsc'INCLUDE_ENVELOPE='env'INCLUDE_DELETED = 'del'INCLUDE_SLUG = 'slug'INCLUDE_LEVEL = 'lvl'INCLUDE_STATUS = 'sta'```###### Including extra dataExamples:**Include record url in response**```console$ curl -i -H &quot;Prefer: return=minimal; include=url&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europeHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&gt;; rel=tree{  &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&quot;  },   &quot;slug&quot;: &quot;europe&quot;}```Adds a ``links`` section to payload with record url (``&quot;self&quot;:``)**Include descendants url in response**```console$ curl -i -H &quot;Prefer: return=minimal; include=url drl&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europeHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&gt;; rel=tree{  &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&quot;,     &quot;tree&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&quot;  },   &quot;slug&quot;: &quot;europe&quot;}```Adds a ``links`` section to payload with recoord url with descendants (``&quot;tree&quot;:``)**Include descendants count in response**```console$ curl -i -H &quot;Prefer: return=minimal; include=dcn&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europeHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&gt;; rel=tree{  &quot;slug&quot;: &quot;europe&quot;,  &quot;descendants_count&quot;: 58}```Adds a ``descendant_count`` with a number of descendant terms under the term. The value is 0if the term is a leaf term.On taxonomy, returns the total number of terms in taxonomy:```console$ curl -i -H &quot;Prefer: return=minimal; include=dcn&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/countryHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country?representation:include=dsc&gt;; rel=tree{  &quot;code&quot;: &quot;country&quot;,  &quot;descendants_count&quot;: 253}```**Include ancestors with hierarchy in response**```console$ curl -i -H &quot;Prefer: return=minimal; include=anh url&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz{  &quot;children&quot;: [    {      &quot;links&quot;: {        &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&quot;      },       &quot;slug&quot;: &quot;europe/cz&quot;    }  ],   &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&quot;  },   &quot;slug&quot;: &quot;europe&quot;,  &quot;ancestor&quot;: true}```If the term has ancestors, they are serialized and the term is included as theirchild. This is useful for example when showing the taxonomy in tree form - therendering mechanism for the tree will stay the same. All ancestor terms are markedwith ``ancestor=true`` flag to help with ui rendering (for example to gray ancestors).Adding url as well is recommended to get urls of ancestors.**Include ancestors without hierarchy in response**```console$ curl -i -H &quot;Prefer: return=minimal; include=anc url&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/czHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz?representation:include=dsc&gt;; rel=tree{  &quot;ancestors&quot;: [    {      &quot;links&quot;: {        &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&quot;      },       &quot;slug&quot;: &quot;europe&quot;    }  ],   &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&quot;  },   &quot;slug&quot;: &quot;europe/cz&quot;}```The ancestors are rendered inside the ``ancestors`` element. Adding url as well is recommended to get urls of ancestors.**Include ancestor list in response**```console$ curl -i -H &quot;Prefer: return=representation; include=anl ant par&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/czHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz?representation:include=dsc&gt;; rel=tree[  {    &quot;links&quot;: {      &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&quot;    },    &quot;is_ancestor&quot;: true  },   {    &quot;CapitalLatitude&quot;: &quot;50.083333333333336&quot;,     &quot;CapitalLongitude&quot;: &quot;14.466667&quot;,     &quot;CapitalName&quot;: &quot;Prague&quot;,     &quot;ContinentName&quot;: &quot;Europe&quot;,     &quot;CountryCode&quot;: &quot;CZ&quot;,     &quot;CountryName&quot;: &quot;Czech Republic&quot;,     &quot;links&quot;: {      &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&quot;,      &quot;parent&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&quot;    },    &quot;is_ancestor&quot;: false  }]```The ancestors are rendered on the same level as the term. This rendering might be usedfor example when serializing the taxonomy term to elasticsearch - this way all the ancestors are serialized within one array and indexed into one object in ES.Note also the:   * ``ant`` - adds ``ancestor`` field (``false`` if this is the term that has been queried),      ``true`` for ancestor term   * ``parent`` - adds link to the parent within ``links`` sectionEven one-term result is rendered as array:```console$ curl -i -H &quot;Prefer: return=representation; include=anl ant par&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europeHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&gt;; rel=tree[  {    &quot;links&quot;: {      &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&quot;    },    &quot;is_ancestor&quot;: false  }]```**Include data in response**This is the default setting unless ``minimal`` representation is selected. In this case,pass ``include=data`` to have data included.```console$ curl -i -H &quot;Prefer: return=minimal; include=data&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/czHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz?representation:include=dsc&gt;; rel=tree{  &quot;CapitalLatitude&quot;: &quot;50.083333333333336&quot;,   &quot;CapitalLongitude&quot;: &quot;14.466667&quot;,   &quot;CapitalName&quot;: &quot;Prague&quot;,   &quot;ContinentName&quot;: &quot;Europe&quot;,   &quot;CountryCode&quot;: &quot;CZ&quot;,   &quot;CountryName&quot;: &quot;Czech Republic&quot;,   &quot;slug&quot;: &quot;europe/cz&quot;}```**Include id in response**Use ``include=id`` to get the internal id included. This is rarely needed as API does not acceptthis id at all.**Include descendant terms in response**To serialize descendants into the response, use ``include=dsc``:```console$ curl -i -H &quot;Prefer: return=minimal; include=dsc&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europeHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&gt;; rel=tree{  &quot;children&quot;: [    {      &quot;slug&quot;: &quot;europe/ad&quot;    },     {      &quot;slug&quot;: &quot;europe/al&quot;    },     ...    {      &quot;slug&quot;: &quot;europe/va&quot;    }  ],  &quot;slug&quot;: &quot;europe&quot;}```**Include slug in response**Adds ``slug`` to response. In the ``minimal`` mode the slug is added automatically, use this tag to add it in ``return=representation``:```console$ curl -i -H &quot;Prefer: return=representation; include=slug&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/czHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz?representation:include=dsc&gt;; rel=tree{  &quot;CapitalLatitude&quot;: &quot;50.083333333333336&quot;,   &quot;CapitalLongitude&quot;: &quot;14.466667&quot;,   &quot;CapitalName&quot;: &quot;Prague&quot;,   &quot;ContinentName&quot;: &quot;Europe&quot;,   &quot;CountryCode&quot;: &quot;CZ&quot;,   &quot;CountryName&quot;: &quot;Czech Republic&quot;,   &quot;ancestors&quot;: [    {      &quot;links&quot;:{&quot;self&quot;:&quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&quot;},      &quot;slug&quot;: &quot;europe&quot;    }  ],   &quot;links&quot;:{&quot;self&quot;:&quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&quot;},  &quot;slug&quot;: &quot;europe/cz&quot;}```**Include hierarchy level in response**Adds hierarchy level to taxonomy term. Top-level terms have ``level=1``, taxonomy ``0``.```console$ curl -i -H &quot;Prefer: return=minimal; include=lvl&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/czHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz?representation:include=dsc&gt;; rel=tree{  &quot;level&quot;: 2,   &quot;slug&quot;: &quot;europe/cz&quot;}```**Include deleted terms in response**Let's delete a country from Europe:```console$ curl -X DELETE -i http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/gbHTTP/1.0 200 OKContent-Type: application/json{  &quot;CapitalLatitude&quot;: &quot;51.5&quot;,   &quot;CapitalLongitude&quot;: &quot;-0.083333&quot;,   &quot;CapitalName&quot;: &quot;London&quot;,   &quot;ContinentName&quot;: &quot;Europe&quot;,   &quot;CountryCode&quot;: &quot;GB&quot;,   &quot;CountryName&quot;: &quot;United Kingdom&quot;,  &quot;links&quot;:{&quot;self&quot;:&quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/gb&quot;}}```United Kingdom has indeed been removed from Europe:```console$ curl -i http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/gbHTTP/1.0 410 GONE{  &quot;message&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/gb was not found on the server&quot;,  &quot;reason&quot;: &quot;deleted&quot;}```Now run the GET again with removed terms included:```console$ curl -i -H &quot;Prefer: return=minimal; include=del sta&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/gbHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/gb&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/gb?representation:include=dsc&gt;; rel=tree{  &quot;slug&quot;: &quot;europe/gb&quot;,   &quot;status&quot;: &quot;deleted&quot;,  &quot;busy_count&quot;:0,  &quot;descendants_busy_count&quot;:0}```**Include term status**Including the status will add the following metadata:  * ``status`` of the term (alive, delete_pending, deleted, moved)  * ``busy_count`` - an integer saying how &quot;busy&quot; the term is. Being busy means    that a potentially destructive operation (such as deleting, moving or renaming slug)    is in progress.   * ``descendants_busy_count`` - a number of descendants that are busy```console$ curl -i -H &quot;Prefer: return=minimal; include=del sta dsc&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europeHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&gt;; rel=tree{  &quot;busy_count&quot;:0,  &quot;children&quot;: [    {      &quot;busy_count&quot;:0,      &quot;descendants_busy_count&quot;:0,      &quot;slug&quot;: &quot;europe/ad&quot;,       &quot;status&quot;: &quot;alive&quot;    },     ...    {      &quot;busy_count&quot;:0,      &quot;descendants_busy_count&quot;:0,      &quot;slug&quot;: &quot;europe/gb&quot;,       &quot;status&quot;: &quot;deleted&quot;    },     ...    {      &quot;busy_count&quot;:0,      &quot;descendants_busy_count&quot;:0,      &quot;slug&quot;: &quot;europe/va&quot;,       &quot;status&quot;: &quot;alive&quot;    }  ],   &quot;descendants_busy_count&quot;:0,  &quot;slug&quot;: &quot;europe&quot;,   &quot;status&quot;: &quot;alive&quot;}```###### Excluding dataTo exclude data from the representation, use ``exclude=...`` in prefer header.#### Query parametersValues from the ``prefer`` header can be used as query parameters:```curl -i -H &quot;Prefer: return=minimal;&quot; \  &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?     representation:include=sta,url&amp;representation:exclude=slug&quot;HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&gt;; rel=tree{  &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&quot;  },   &quot;status&quot;: &quot;alive&quot;}```#### Selecting subset of term dataUse ``select=&lt;json pointer&gt; &lt;json pointer&gt;...`` in ``prefer`` header or ``representation:select=`` query parameterto select just part of user data:```console$ curl -i -H &quot;Prefer: return=representation;select=/CapitalName /CountryCode&quot; \     &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&quot;HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz?representation:include=dsc&gt;; rel=tree{  &quot;CapitalName&quot;: &quot;Prague&quot;,   &quot;CountryCode&quot;: &quot;CZ&quot;,   &quot;ancestors&quot;: [    {      &quot;links&quot;: {        &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&quot;      }    }  ],   &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/cz&quot;  }}```#### Maximum levelsWhen descendants are selected, a maximum level of descendants can be specified via``levels=&lt;n&gt;`` part of ``prefer`` header (or representation:levels=n in the query).Example: ```console$ curl -i -H &quot;Prefer: return=representation; levels=1&quot; \     &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country&quot;HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country?representation:include=dsc&gt;; rel=tree{        'children': [            {'slug': 'africa'},            {'slug': 'antarctica'},            {'slug': 'asia'},            {'slug': 'australia'},            {'slug': 'central-america'},            {'slug': 'europe'},            {'slug': 'north-america'},            {'slug': 'south-america'}        ],        'code': 'country',        'title': 'List of countries'}```#### PaginationIf descendants are requested without further arguments the whole tree is returned (well, in fact at most FLASK_TAXONOMIES_MAX_RESULTS_RETURNED terms to prevent server crash). This leads to high amount of data transferred and possibly a client crash. To prevent this, pagination should be used on largertaxonomies.Specify ``size`` argument to have at most this number of taxonomy terms returned. For example:```console$ curl -i -H &quot;Prefer: return=minimal;&quot; \  &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&amp;size=5&quot;HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&gt;; rel=treeX-Page: 1X-PageSize: 5X-Total: 58{  &quot;children&quot;: [    {      &quot;slug&quot;: &quot;europe/ad&quot;    },     {      &quot;slug&quot;: &quot;europe/al&quot;    },     {      &quot;slug&quot;: &quot;europe/am&quot;    },     {      &quot;slug&quot;: &quot;europe/at&quot;    }  ],   &quot;slug&quot;: &quot;europe&quot;}```This returns 5 terms - europe and 4 children. To return the next page, add ``page=2`` argument:```console$ curl -i -H &quot;Prefer: return=minimal;&quot; \  &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&amp;size=5&amp;page=4&quot;HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/dk&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/dk?representation:include=dsc&gt;; rel=treeX-Page: 4X-PageSize: 5X-Total: 58[  {    &quot;slug&quot;: &quot;europe/dk&quot;  },   {    &quot;slug&quot;: &quot;europe/ee&quot;  },   {    &quot;slug&quot;: &quot;europe/es&quot;  },   {    &quot;slug&quot;: &quot;europe/fi&quot;  },   {    &quot;slug&quot;: &quot;europe/fo&quot;  }]```Note that the first page contains the root element and the second does not. To fix it, either use ``include=anh``to always get hierarchical representation:```console$ curl -i -H &quot;Prefer: return=minimal;&quot; \  &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc,anh&amp;size=5&amp;page=2&quot;HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/ax&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/ax?representation:include=dsc&gt;; rel=treeX-Page: 2X-PageSize: 5X-Total: 58{  &quot;ancestor&quot;: true,   &quot;children&quot;: [    {      &quot;slug&quot;: &quot;europe/ax&quot;    },     {      &quot;slug&quot;: &quot;europe/az&quot;    },     {      &quot;slug&quot;: &quot;europe/ba&quot;    },     {      &quot;slug&quot;: &quot;europe/be&quot;    }  ],   &quot;slug&quot;: &quot;europe&quot;}```or, if interested only in descendants and not the node itself, ``exclude=self`````console$ curl -i -H &quot;Prefer: return=minimal;&quot; \  &quot;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?     representation:include=dsc&amp;representation:exclude=self&amp;size=5&amp;page=1&quot;HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/ad&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe/ad?representation:include=dsc&gt;; rel=treeX-Page: 1X-PageSize: 5X-Total: 58[  {    &quot;slug&quot;: &quot;europe/ad&quot;  },   {    &quot;slug&quot;: &quot;europe/al&quot;  },   {    &quot;slug&quot;: &quot;europe/am&quot;  },   {    &quot;slug&quot;: &quot;europe/at&quot;  },   {    &quot;slug&quot;: &quot;europe/ax&quot;  }]```#### SearchingUse ``q=`` parameter to search within terms. Returns all the resourceswhose ``metadata`` contain the expression in q.##### Simple queryIf ``q`` is a simple string not containing ':' or string in quotes,it is interpreted as a string that must be present in any of values inside the json.The current implementation is dependent on the database backendand might perform sub-optimal ``ilike %x%`` query on textified json.```console$ curl -i -H &quot;Prefer: return=minimal; include=data dsc; exclude=self&quot; \  http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?q=PragueHTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/country/europe?representation:include=dsc&gt;; rel=tree[    {      &quot;CapitalLatitude&quot;: &quot;50.083333333333336&quot;,       &quot;CapitalLongitude&quot;: &quot;14.466667&quot;,       &quot;CapitalName&quot;: &quot;Prague&quot;,       &quot;ContinentName&quot;: &quot;Europe&quot;,       &quot;CountryCode&quot;: &quot;CZ&quot;,       &quot;CountryName&quot;: &quot;Czech Republic&quot;,       &quot;slug&quot;: &quot;europe/cz&quot;    }]```##### Lucene-like queryIf the ``q`` contains a ':' character not enclosed in quotes,it is parsed as a query in lucene syntax, with the followingallowed constructs:   * path:value for matching value at the given path   * a.b.c:value for representing nested paths    * AND, OR, NOT, bracketsThe query will be executed if the database or search backend supportit. If not supported, HTTP 501 will be returned.### Taxonomy#### CreatingTo create a taxonomy, either use HTTP PUT:```console$ curl -i -X PUT 'http://127.0.0.1:5000/api/2.0/taxonomies/test' \-H 'Content-Type: application/json' \--data-raw '{    &quot;title&quot;: &quot;Test taxonomy&quot;}'HTTP/1.0 201 CREATEDLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/?representation:include=dsc&gt;; rel=treeLocation: http://127.0.0.1:5000/api/2.0/taxonomies/test/{  &quot;code&quot;: &quot;test&quot;,   &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/&quot;  },   &quot;title&quot;: &quot;Test taxonomy&quot;}```Or HTTP POST with ``code`` in the payload```console$ curl -i -X POST 'http://127.0.0.1:5000/api/2.0/taxonomies/' \    -H 'Content-Type: application/json' --data-raw '{    &quot;title&quot;: &quot;Test taxonomy 1&quot;, &quot;code&quot;: &quot;test1&quot;}'HTTP/1.0 201 CREATEDLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test1/&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test1/?representation:include=dsc&gt;; rel=treeLocation: http://127.0.0.1:5000/api/2.0/taxonomies/test1/{  &quot;code&quot;: &quot;test1&quot;,   &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test1/&quot;  },   &quot;title&quot;: &quot;Test taxonomy 1&quot;}```#### Updating##### Replacing via HTTP PUT```console$ curl -i -X PUT 'http://127.0.0.1:5000/api/2.0/taxonomies/test' \  --header 'Content-Type: application/json' --data-raw '{    &quot;title&quot;: &quot;Test taxonomy updated&quot;}'HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/?representation:include=dsc&gt;; rel=tree{  &quot;code&quot;: &quot;test&quot;,   &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/&quot;  },   &quot;title&quot;: &quot;Test taxonomy updated&quot;}```Note that terms are not updated nor removed when taxonomy metadata are updated.##### Patching with HTTP PATCH```console$ curl -i -X PATCH 'http://127.0.0.1:5000/api/2.0/taxonomies/test' \  --header 'Content-Type: application/json' --data-raw '[{    &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/title&quot;, &quot;value&quot;: &quot;Test taxonomy updated via patch&quot;}]'HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/?representation:include=dsc&gt;; rel=tree{  &quot;code&quot;: &quot;test&quot;,   &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/&quot;  },   &quot;title&quot;: &quot;Test taxonomy updated via patch&quot;}```#### Deleting```console$ curl -i -X DELETE 'http://127.0.0.1:5000/api/2.0/taxonomies/test1'HTTP/1.0 204 NO CONTENTContent-Type: text/html; charset=utf-8```### Taxonomy Term#### CreatingAs in creating taxonomy, term can be created either via HTTP PUT:```console$ curl -i -X PUT 'http://127.0.0.1:5000/api/2.0/taxonomies/test/term' \  --header 'Content-Type: application/json' --data-raw '{    &quot;title&quot;: &quot;Test Term&quot;}'HTTP/1.0 201 CREATEDLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term?representation:include=dsc&gt;; rel=treeLocation: http://127.0.0.1:5000/api/2.0/taxonomies/test/term{  &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/term&quot;  },   &quot;title&quot;: &quot;Test Term&quot;}```or POST:```console$ curl -i -X POST 'http://127.0.0.1:5000/api/2.0/taxonomies/test' \  --header 'Content-Type: application/json' --data-raw '{    &quot;title&quot;: &quot;Test term 1&quot;, &quot;slug&quot;: &quot;term1&quot;}'HTTP/1.0 201 CREATEDLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term1&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term1?representation:include=dsc&gt;; rel=treeLocation: http://127.0.0.1:5000/api/2.0/taxonomies/test/term1{  &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/term1&quot;  },   &quot;title&quot;: &quot;Test term 1&quot;}``` As PUT/POST operation also mean updating term if slug exists, to be surethat you are creating a new one use ``If-None-Match: '*'`` header:```console$ curl -i -X PUT 'http://127.0.0.1:5000/api/2.0/taxonomies/test/term' \  --header 'Content-Type: application/json' \  --header 'If-None-Match: '*'' \  --data-raw '{    &quot;title&quot;: &quot;Test Term&quot;}'HTTP/1.0 412 Precondition Failed{     &quot;message&quot;: &quot;The taxonomy already contains a term on this slug. As If-None-Match: '*' has been requested, not modifying the term&quot;,     &quot;reason&quot;: &quot;term-exists&quot;}```Terms can be created within terms via HTTP PUT:```console$ curl -i -X PUT 'http://127.0.0.1:5000/api/2.0/taxonomies/test/term/nested' \  --header 'Content-Type: application/json' --data-raw '{    &quot;title&quot;: &quot;Nested Term&quot;}'HTTP/1.0 201 CREATEDLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term/nested&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term/nested?representation:include=dsc&gt;; rel=treeLocation: http://127.0.0.1:5000/api/2.0/taxonomies/test/term/nested{  &quot;ancestors&quot;:[     {       &quot;links&quot;:{         &quot;self&quot;:&quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/term&quot;       },       &quot;title&quot;:&quot;Test Term&quot;     }  ],  &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/term/nested&quot;  },   &quot;title&quot;: &quot;Nested Term&quot;}```or POST:```console$ curl -i -X POST 'http://127.0.0.1:5000/api/2.0/taxonomies/test/term1' \  --header 'Content-Type: application/json' --data-raw '{    &quot;title&quot;: &quot;Test nested term 1&quot;, &quot;slug&quot;: &quot;nested1&quot;}'HTTP/1.0 201 CREATEDLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term1/nested1&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term1/nested1?representation:include=dsc&gt;; rel=treeLocation: http://127.0.0.1:5000/api/2.0/taxonomies/test/term1/nested1{  &quot;ancestors&quot;:[     {       &quot;links&quot;:{         &quot;self&quot;:&quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/term1&quot;       },       &quot;title&quot;:&quot;Test term 1&quot;     }  ],  &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/term1/nested1&quot;  },   &quot;title&quot;: &quot;Test nested term 1&quot;}``` #### UpdatingAs for taxonomy, use HTTP ``PUT``:```console$ curl -i -X PUT 'http://127.0.0.1:5000/api/2.0/taxonomies/test/term' \    --header 'Content-Type: application/json' --data-raw '{    &quot;title&quot;: &quot;Test Term updated&quot;                 }'HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term?representation:include=dsc&gt;; rel=tree{  &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/term&quot;  },   &quot;title&quot;: &quot;Test Term updated&quot;}```or ``PATCH``:```console$ curl -i -X PATCH 'http://127.0.0.1:5000/api/2.0/taxonomies/test/term' \  --header 'Content-Type: application/json' --data-raw '[{    &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/title&quot;, &quot;value&quot;: &quot;Test taxonomy term updated via patch&quot;}]'HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term?representation:include=dsc&gt;; rel=tree{  &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/term&quot;  },   &quot;title&quot;: &quot;Test taxonomy term updated via patch&quot;}```As PUT operation also means creating term if slug does not exist, to be surethat you are just updating use ``If-Match: '*'`` header:```console$ curl -i -X PUT 'http://127.0.0.1:5000/api/2.0/taxonomies/test/unknown' \  --header 'Content-Type: application/json' \  --header 'If-Match: '*'' \  --data-raw '{    &quot;title&quot;: &quot;Test Term&quot;}'HTTP/1.0 412 Precondition Failed{         &quot;message&quot;: &quot;The taxonomy does not contain a term on this slug. As If-Match: '*' has been requested, not creating a new term&quot;,         &quot;reason&quot;: &quot;term-does-not-exist&quot;}```#### DeletingUse HTTP delete to remove a term. The removed term will be returned in the response:```console$ curl -i -X DELETE 'http://127.0.0.1:5000/api/2.0/taxonomies/test/term1'HTTP/1.0 200 OKContent-Type: application/json{  &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/term1&quot;  },   &quot;title&quot;: &quot;Test term 1&quot;}```Subsequent GET returns 410:```console$ curl -i 'http://127.0.0.1:5000/api/2.0/taxonomies/test/term1'HTTP/1.0 410 GONE{  &quot;message&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/term1 was not found on the server&quot;,  &quot;reason&quot;: &quot;deleted&quot;}```But the term stays on the server:```console$ curl -i 'http://127.0.0.1:5000/api/2.0/taxonomies/test/term?representation:include=del'HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term?representation:include=dsc&gt;; rel=tree{  &quot;links&quot;: {    &quot;self&quot;: &quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/term&quot;  },   &quot;title&quot;: &quot;Test taxonomy term updated via patch&quot;}```#### Un-DeletingTo salvage a deleted term, update it via PATCH, with an empty set of operations to keep it unmodified:```console$ curl -i -X PATCH -H &quot;Prefer: return=minimal; include=del&quot; \   'http://127.0.0.1:5000/api/2.0/taxonomies/test/term' \    --header 'Content-Type: application/json' --data-raw '[]'HTTP/1.0 200 OKLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term&gt;; rel=selfLink: &lt;http://127.0.0.1:5000/api/2.0/taxonomies/test/term?representation:include=dsc&gt;; rel=tree{  &quot;slug&quot;: &quot;term&quot;}```#### MovingUse HTTP post with content type ``application/vnd.move`` and ``Destination`` header:```console$ curl -i -X POST \   -H 'Content-Type: application/vnd.move' \   -H &quot;Destination: /&quot; \  'http://127.0.0.1:5000/api/2.0/taxonomies/test/term/nested'HTTP/1.0 200 OK{    &quot;links&quot;:{        &quot;self&quot;:&quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/nested&quot;    },    &quot;title&quot;:&quot;Nested Term&quot;}```The original url returns 301:```console$ curl -i 'http://127.0.0.1:5000/api/2.0/taxonomies/test/term/nested'HTTP/1.0 301 MOVED PERMANENTLYLocation: http://127.0.0.1:5000/api/2.0/taxonomies/test/nestedLink: &lt;http://localhost/api/2.0/taxonomies/test/term/nested&gt;; rel=selfLink: &lt;http://localhost/api/2.0/taxonomies/test/nested&gt;; rel=obsoleted_by{    &quot;links&quot;: {        &quot;self&quot;: &quot;http://localhost/api/2.0/taxonomies/test/term/nested&quot;,         &quot;obsoleted_by&quot;: &quot;http://localhost/api/2.0/taxonomies/test/nested&quot;    },     &quot;status&quot;: &quot;moved&quot;}```#### RenamingUse HTTP post with content type ``application/vnd.move`` and ``Rename`` header:```console$ curl -i -X POST \   -H 'Content-Type: application/vnd.move' \   -H &quot;Rename: renamed-nested&quot; \  'http://127.0.0.1:5000/api/2.0/taxonomies/test/nested'HTTP/1.0 200 OK{    &quot;links&quot;:{        &quot;self&quot;:&quot;http://127.0.0.1:5000/api/2.0/taxonomies/test/renamed-nested&quot;    },    &quot;title&quot;:&quot;Nested Term&quot;}```The original url returns 301:```console$ curl -i 'http://127.0.0.1:5000/api/2.0/taxonomies/test/nested'HTTP/1.0 301 MOVED PERMANENTLYLocation: http://127.0.0.1:5000/api/2.0/taxonomies/test/renamed-nestedLink: &lt;http://localhost/api/2.0/taxonomies/test/nested&gt;; rel=selfLink: &lt;http://localhost/api/2.0/taxonomies/test/renamed-nested&gt;; rel=obsoleted_by{    &quot;links&quot;: {        &quot;self&quot;: &quot;http://localhost/api/2.0/taxonomies/test/nested&quot;,         &quot;obsoleted_by&quot;: &quot;http://localhost/api/2.0/taxonomies/test/renamed-nested&quot;    },     &quot;status&quot;: &quot;moved&quot;}```## Configuration### Configuration Variables``FLASK_TAXONOMIES_SERVER_NAME``Server name hosting the taxonomies. If not set, SERVER_NAME is used.``FLASK_TAXONOMIES_SERVER_SCHEME``Scheme to use in generated urls, defaults to ``https````FLASK_TAXONOMIES_URL_PREFIX``A prefix on which taxonomies are served, defaults to ``/api/2.0/taxonomies/````FLASK_TAXONOMIES_REPRESENTATION``Values for ``Prefer: return=`` header. ``minimal`` and ``representation`` are obligatory,you are free to add other return representations. ```pythonfrom flask_taxonomies.constants import *FLASK_TAXONOMIES_REPRESENTATION = {    'minimal': {        'include': [INCLUDE_SLUG, INCLUDE_SELF],        'exclude': [],        'select': None,        'options': {}    },    'representation': {        'include': [INCLUDE_DATA, INCLUDE_ANCESTORS,                     INCLUDE_URL, INCLUDE_SELF],        'exclude': [],        'select': None,        'options': {}    },    'full': {        'include': [INCLUDE_DATA, INCLUDE_ANCESTORS, INCLUDE_URL,                     INCLUDE_DESCENDANTS_URL, INCLUDE_SELF],        'exclude': [],        'select': None,        'options': {}    }}`````FLASK_TAXONOMIES_MAX_RESULTS_RETURNED``Specifies max results returned when pagination is not used. Defaults to ``10000``.### SecurityFlask taxonomies uses ``flask-principal`` to handle security. The default permissions arethat everyone is allowed to read/create/update/delete/move all taxonomies and terms.To restrict the access, specify permission factories (a function that returns a list of permission)for each operation.``FLASK_TAXONOMIES_PERMISSION_FACTORIES``A dictionary of operation to a list of permissions.```FLASK_TAXONOMIES_PERMISSION_FACTORIES = {    'taxonomy_list':   request -&gt; List[Permission]    'taxonomy_read':   request, taxonomy -&gt; List[Permission]    'taxonomy_create': request, code -&gt; List[Permission]    'taxonomy_update': request, taxonomy -&gt; List[Permission]    'taxonomy_delete': request, taxonomy -&gt; List[Permission],    'taxonomy_term_read':   request, taxonomy, slug -&gt; List[Permission]    'taxonomy_term_create': request, taxonomy, slug -&gt; List[Permission]    'taxonomy_term_update': request, taxonomy, term -&gt; List[Permission]    'taxonomy_term_delete': request, taxonomy, term -&gt; List[Permission],    'taxonomy_term_move': request, taxonomy, term, destination, rename -&gt; List[Permission],}```The right-hand side can be either a list/tuple of permissions, function with the above-mentionedsignatures or a string pointing to the implementation. The string form is resolved on the first request. If ``.can`` on any of the permissions returns True or the list is empty, access is granted.#### Recommended initial settingsThe recommended initial settings are read-only for everyone except admin role:```pythonfrom flask_principal import RoleNeedFLASK_TAXONOMIES_PERMISSION_FACTORIES = {    'taxonomy_create': [RoleNeed('admin')],    'taxonomy_update': [RoleNeed('admin')],    'taxonomy_delete': [RoleNeed('admin')],    'taxonomy_term_create': [RoleNeed('admin')],    'taxonomy_term_update': [RoleNeed('admin')],    'taxonomy_term_delete': [RoleNeed('admin')],    'taxonomy_term_move': [RoleNeed('admin')]}```## Python APIThe calls below use ``session`` as an optional parameter. If not supplied, session fromcurrent_app is used. ``TermIdentification`` is a class to identify taxonomy term, binding taxonomy (or its code),slug or a term instance. See [flask_taxonomies/term_identification.py](./flask_taxonomies/term_identification.py)for details.```pythonfrom flask_taxonomies.proxies import current_flask_taxonomies# returns a taxonomy listcurrent_flask_taxonomies.list_taxonomies(session=None)# returns a taxonomy with the given code. Fails by default if not foundcurrent_flask_taxonomies.get_taxonomy(code, fail=True, session=None)# creates a new taxonomycurrent_flask_taxonomies.create_taxonomy(code, extra_data=None, url=None,     select=None, session=None)# updates a taxonomycurrent_flask_taxonomies.update_taxonomy(    taxonomy: [Taxonomy, str], extra_data,     url=MISSING, select=MISSING,    session=None)# deletes a taxonomycurrent_flask_taxonomies.delete_taxonomy(taxonomy: Taxonomy, session=None)# lists terms within the taxonomy. current_flask_taxonomies.list_taxonomy(taxonomy: [Taxonomy, str], levels=None,    status_cond=TaxonomyTerm.status == TermStatusEnum.alive,    order=True, session=None)# creates a new term inside a taxonomycurrent_flask_taxonomies.create_term(ti: TermIdentification,     extra_data=None, session=None)# updates a term, setting or patching extra_datacurrent_flask_taxonomies.update_term(ti: [TaxonomyTerm, TermIdentification],    status_cond=TaxonomyTerm.status == TermStatusEnum.alive,    extra_data=None, patch=False, status=MISSING, session=None)# returns all descendants of a termcurrent_flask_taxonomies.descendants(ti: TermIdentification, levels=None,    status_cond=TaxonomyTerm.status == TermStatusEnum.alive,    order=True, session=None)# returns a term and its descendantscurrent_flask_taxonomies.descendants_or_self(ti: TermIdentification, levels=None,    status_cond=TaxonomyTerm.status == TermStatusEnum.alive,    order=True, session=None)# returns all ancestors of a termcurrent_flask_taxonomies.ancestors(ti: TermIdentification,     status_cond=TaxonomyTerm.status == TermStatusEnum.alive, session=None)# returns term and its ancestorscurrent_flask_taxonomies.ancestors_or_self(ti: TermIdentification,    status_cond=TaxonomyTerm.status == TermStatusEnum.alive, session=None)# removes a termcurrent_flask_taxonomies.delete_term(ti: TermIdentification,     remove_after_delete=True, session=None)# renames term's slugcurrent_flask_taxonomies.rename_term(ti: TermIdentification, new_slug=None,    remove_after_delete=True, session=None)# moves term into a new parent within the same taxonomycurrent_flask_taxonomies.move_term(ti: TermIdentification, new_parent=None,    remove_after_delete=True, session=None)```### SignalsSee [flask_taxonomies/signals.py](flask_taxonomies/signals.py) for details</longdescription>
</pkgmetadata>