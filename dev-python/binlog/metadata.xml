<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># binlog[![Test](https://github.com/ysimonson/binlog/actions/workflows/test.yml/badge.svg)](https://github.com/ysimonson/binlog/actions/workflows/test.yml)[![crates.io](https://img.shields.io/crates/v/binlog.svg)](https://crates.io/crates/binlog)[![API docs](https://docs.rs/binlog/badge.svg)](https://docs.rs/binlog)A rust library for creating and managing logs of arbitrary binary data. Presently it's used to collect sensor data. But it should generally be helpful in cases where you need to store timeseries data, in a nearly (but not strictly) append-only fashion.The underlying storage of logs are pluggable via a few [traits](https://github.com/ysimonson/binlog/blob/main/src/stores/traits.rs). Binlog includes built-in implementations via sqlite, redis, and in-memory-only. Additionally, python bindings allow you to use (a subset of) binlog from python.## Usage### From RustA small example:```rustuse binlog::{Entry, Error, Range, RangeableStore, SqliteStore, Store};use std::borrow::Cow;use string_cache::Atom;/// Demonstrates the sqlite store, with results in `example.db`. You may want to delete that before/// running this to see the results of this on an empty database.fn main() -&gt; Result&lt;(), Error&gt; {    // Create a new datastore with sqlite backing. The result will be stored in example.db, with    // default compression options. In-memory is also possible via    // `binlog::MemoryStore::default()`.    let store = SqliteStore::new(&quot;example.db&quot;, None)?;    // Add 10 entries.    for i in 1..11u8 {        let entry = Entry::new_with_timestamp(i as i64, Atom::from(&quot;sqlite_example&quot;), vec![i]);        store.push(Cow::Owned(entry))?;    }    // Queries are done via `range`. Here we grab entries with any timestamp and any name.    let range = store.range(.., Option::&lt;String&gt;::None)?;    // Count the number of entries.    println!(&quot;initial count: {}&quot;, range.count()?);    // We can also iterate on the entries.    for entry in range.iter()? {        println!(&quot;entry: {:?}&quot;, entry?);    }    // Remove the entries with 4 &lt;= ts &lt;= 6 and with the name `sqlite_example`.    store.range(4..=6, Some(Atom::from(&quot;sqlite_example&quot;)))?.remove()?;    // Now get the range of entries with 5 &lt;= ts and with the name `sqlite_example`.    let range = store.range(5.., Some(Atom::from(&quot;sqlite_example&quot;)))?;    println!(&quot;count after range deletion: {}&quot;, range.count()?);    for entry in range.iter()? {        println!(&quot;entry: {:?}&quot;, entry?);    }    Ok(())}```### From PythonA small example:```pythonfrom binlog import binlogstore = binlog.SqliteStore(&quot;example.db&quot;)store.push(binlog.Entry(1, &quot;pytest_push&quot;, [1, 2, 3]))```## StoresStores implement the [`Store` trait, and zero or more optional extensions](https://github.com/ysimonson/binlog/blob/main/src/stores/traits.rs) depending on their supported functionality. A few stores implementations are built-in to `binlog`:### In-memory-onlyThe in-memory-only store has no means of persistence, but offers the full log functionality. This is also used internally for fuzzing other implementations against.### RedisThe redis implementation is enableable via the `redis-store` feature. Under the hood, it uses redis streams. It supports subscriptions, but not ranges.### SqliteThe sqlite implementation is enableable via the `sqlite-store` feature. It supports ranges, but not subscriptions.## Testing### Unit testsTests can be run via `make test`. This will also be run in CI.### BenchmarksBenchmarks can be run via `make bench`.### FuzzingA fuzzer is available, ensuring the the sqlite and in-memory datastores operate identically. Run it via `make fuzz`.### ChecksLint and formatting checks can be run via `make check`. Equivalent checks will also run in CI.</longdescription>
</pkgmetadata>