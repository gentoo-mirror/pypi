<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># coveo-settingsWhenever you want the user to be able to configure something through an environment variable, this module has your back:```pythonfrom coveo_settings import StringSetting, BoolSettingDATABASE_URL = StringSetting('project.database.url')DATABASE_USE_SSL = BoolSetting('project.database.ssl')```The user can then configure the environment variables `project.database.url` and `project.database.ssl` to configure the application.When accessed, the values are automatically converted to the desired type:- `StringSetting` will always be a string- `BoolSetting` is either True or False, but accepts &quot;yes|no|true|false|1|0&quot; as input (case-insensitive, of course)- `IntSetting` and `FloatSetting` are self-explanatory- `DictSetting` allows you to use JSON maps- `PathSetting` gives a Path instance, and also implements PathLike and the `/` operatorIf the input cannot be converted to the value type, an `TypeConversionConfigurationError` exception is raised.A default (fallback) value may be specified. The fallback may be a `callable`.A validation callback may be specified for custom logic and error messages.Not limited to environment variables; supports redirection to custom implementations.**A setting can be set as sensitive for logging purposes. When logging, use repr(setting) to get the correct representation.**## Accessing the valueThere are various ways to obtain the value:```pythonfrom coveo_settings import BoolSettingDATABASE_USE_SSL = BoolSetting('project.database.ssl')# this method will raise an exception if the setting has no value and no fallbackuse_ssl = bool(DATABASE_USE_SSL)use_ssl = DATABASE_USE_SSL.get_or_raise()assert use_ssl in [True, False]# this method will not raise an exceptionuse_ssl = DATABASE_USE_SSL.valueassert use_ssl in [True, False, None]# use &quot;is_set&quot; to check if there is a value set for this setting; skips validation checkif DATABASE_USE_SSL.is_set:    use_ssl = bool(DATABASE_USE_SSL)# use &quot;is_valid&quot; to verify if the value passes the validation callback. implies is_set.if not DATABASE_USE_SSL.is_valid:    ...```## Loose environment key matchingMatching the key of the environment variable `project.database.ssl` is done very loosely:- case-insensitive- dots and underscores are ignored completely (`foo_bar` and `f__ooba.r` are equal)    - useful for some runners that don't support dots in environment variable keys## Use ready validationYou can quickly validate that a string is in a specific list like this:```pythonfrom coveo_settings.settings import StringSettingfrom coveo_settings.validation import InSequenceENV = StringSetting(&quot;environment&quot;, fallback=&quot;dev&quot;, validation=InSequence(&quot;prod&quot;, &quot;staging&quot;, &quot;dev&quot;))```## RedirectionYou can register custom redirection schemes in order to support any data source.Much like `https://` is a clear scheme, you may register callback functions to trigger when the value of a settingstarts with the scheme(s) you define. For instance, let's support a custom API and a file storage:```pythonfrom coveo_settings import settings_adapter, StringSetting, ConfigValue@settings_adapter(&quot;internal-api::&quot;)def internal_api_adapter(key: str) -&gt; ConfigValue:    # the scheme was automatically removed for convenience; only the resource remains    assert &quot;internal-api::&quot; not in key    return &quot;internal api&quot;  # implement logic to obtain value from internal api@settings_adapter(&quot;file::&quot;, strip_scheme=False)def file_adapter(key: str) -&gt; ConfigValue:    # you can keep the scheme by specifying `strip_scheme=False`    assert key.startswith(&quot;file::&quot;)    return &quot;file adapter&quot;  # implement logic to parse the key and retrieve the setting valueassert StringSetting('...', fallback=&quot;internal-api::settings/user-name&quot;).value == &quot;internal api&quot;assert StringSetting('...', fallback=&quot;file::settings.yaml/user-name&quot;).value == &quot;file adapter&quot;# even though we used `fallback` above, the redirection is driven by the user:import osREDIRECT_ME = StringSetting('test')os.environ['test'] = &quot;file::user.json::name&quot;assert REDIRECT_ME.value == &quot;file adapter&quot;os.environ['test'] = &quot;internal-api::url&quot;assert REDIRECT_ME.value == &quot;internal api&quot;```Keep in mind that there's no restriction on the prefix scheme; it's your responsibility to pick something uniquethat can be set as the value of an environment variable.### Redirection is recursiveThe value of a redirection may be another redirection and may juggle between adapters.A limit of 50 redirections is supported:```pythonimport osfrom coveo_settings import StringSettingos.environ[&quot;expected&quot;] = &quot;final value&quot;os.environ[&quot;redirected&quot;] = &quot;env-&gt;expected&quot;os.environ[&quot;my-setting&quot;] = &quot;env-&gt;redirected&quot;assert StringSetting(&quot;my-setting&quot;).value == &quot;final value&quot;```### Builtin environment redirectionThe builtin redirection scheme `env-&gt;` can be used to redirect to a different environment variable.The example below demonstrates the deprecation/migration of `my-setting` into `new-setting`:```pythonimport osfrom coveo_settings import StringSettingos.environ[&quot;new-setting&quot;] = &quot;correct-value&quot;os.environ[&quot;my-setting&quot;] = &quot;env-&gt;new-setting&quot;assert StringSetting(&quot;my-setting&quot;).value == &quot;correct-value&quot;```## CachedYou can set a setting to cache the first valid value with `cached=True`.This is particularly useful in redirection scenarios to avoid repeating requests too often.## Setting the valueYou can override the value using `setting.value = &quot;some value&quot;` and clear the override with `setting.value = None`.Clearing the override resumes the normal behavior of the environment variables and the fallback value, if set.This is typically used as a way to propagate CLI switches globally.For mocking scenarios, refer to the `Mocking` section below.## MockingWhen you need a setting value for a test, use the `mock_config_value` context manager:```pythonfrom coveo_settings import StringSettingfrom coveo_settings.mock import mock_config_valueSETTING = StringSetting(...)assert not SETTING.is_setwith mock_config_value(SETTING, 'new-value'):    assert SETTING.is_set```You can also clear the value:```pythonfrom coveo_settings import StringSettingfrom coveo_settings.mock import mock_config_valueSETTING = StringSetting(..., fallback='test')assert SETTING.is_setwith mock_config_value(SETTING, None):    assert not SETTING.is_set```</longdescription>
</pkgmetadata>