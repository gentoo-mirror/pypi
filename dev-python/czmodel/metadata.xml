<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>This project provides simple-to-use conversion tools to generate a CZANN file from a [TensorFlow](https://www.tensorflow.org/) or [ONNX](https://onnx.ai/) model that resides in memory or on disk to be usable in the [ZEN Intellesis](https://www.zeiss.com/microscopy/int/products/microscope-software/zen-intellesis-image-segmentation-by-deep-learning.html) module starting with ZEN blue &gt;=3.2 and ZEN Core &gt;3.0.  Please check the following compatibility matrix for ZEN Blue/Core and the respective version (self.version) of the CZANN Model Specification JSON Meta data file (see _CZANN Model Specification_ below). Version compatibility is defined via the [Semantic Versioning Specification (SemVer)](https://semver.org/lang/de/).| Model (legacy)/JSON | ZEN Blue | ZEN Core ||---------------------|:--------:|---------:|| 1.1.0               | \&gt;= 3.5  |  \&gt;= 3.4 || 1.0.0               | \&gt;= 3.5  |  \&gt;= 3.4 || 3.1.0 (legacy)      | \&gt;= 3.4  |  \&gt;= 3.3 || 3.0.0 (legacy)      | \&gt;= 3.2  |  \&gt;= 3.1 |If you encounter a version mismatch when importing a model into ZEN, please check for the correct version of this package.## Structure of repoThis repo is divided into 3 separate packages -: core, tensorflow, pytorch.- Core - Provides base functionality, no dependency on Tensorflow or Pytorch required.- Tensorflow - Provides Tensorflow-specific functionalities, and converters based on Tensorflow-logics.- PyTorch - Provides PyTorch-specific functionalities, and converters based on PyTorch-logics.## InstallationThe library provides a base package and extras for export functionalities that require specific dependencies -:- ```pip install czmodel``` - This would only install base dependencies, no Tensorflow-/Pytorch-specific packages.- ```pip install czmodel[tensorflow]``` - This would install base and Tensorflow-specific packages.- ```pip install czmodel[pytorch]``` - This would install base and Pytorch-specific packages.## Samples### For czmodel[pytorch]:- For single-class semantic segmentation:&amp;nbsp;[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/zeiss-microscopy/OAD/blob/master/Machine_Learning/notebooks/czmodel/SingleClassSemanticSegmentation_PyTorch_5_0_0.ipynb)- For regression:&amp;nbsp;[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/zeiss-microscopy/OAD/blob/master/Machine_Learning/notebooks/czmodel/Regresssion_PyTorch_5_0_0.ipynb)### For czmodel[tensorflow]:- For single-class semantic segmentation:&amp;nbsp;[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/zeiss-microscopy/OAD/blob/master/Machine_Learning/notebooks/czmodel/SingleClassSemanticSegmentation_Tensorflow_5_0_0.ipynb)- For regression:&amp;nbsp;[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/zeiss-microscopy/OAD/blob/master/Machine_Learning/notebooks/czmodel/Regresssion_Tensorflow_5_0_0.ipynb)## System setupThe current version of this toolbox only requires a fresh Python 3.x installation. It was tested with Python 3.7 on Windows.## Model conversionThe toolbox provides a `convert` module that features all supported conversion strategies. It currently supports converting Keras / PyTorch models in memory or stored on disk with a corresponding metadata JSON file (see _CZANN Model Specification_ below).### Keras / PyTorch models in memoryThe toolbox also provides functionality that can be imported e.g. in the training script used to fit a Keras / PyTorch model. It provides different converters to target specific versions of the export format. Currently, there are two converters available:- DefaultConverter: Exports a .czann file complying with the specification below.- LegacyConverter (Only for segmentation): Exports a .czmodel file (version 3.1.0 of the legacy ANN-based segmentation models in ZEN).The converters are accessible by running:For Keras model:```pythonfrom czmodel.tensorflow.convert import DefaultConverter, LegacyConverter```For PyTorch model:```pythonfrom czmodel.pytorch.convert import DefaultConverter, LegacyConverter```Every converter provides a `convert_from_model_spec` function that uses a model specification object to convert a model to the corresponding export format. It accepts a `tensorflow.keras.Model` / `torch.nn.Module` that will be exported to [ONNX](https://onnx.ai/) (For Keras model, in case of failure it will be exported to [SavedModel](https://www.tensorflow.org/guide/saved_model))format and at the same time wrapped into a .czann/.czmodel file that can be imported and used by Intellesis.  To provide the meta data, the toolbox provides a ModelSpec class that must be filled with the model, a ModelMetadata instance containing the information required by the specification (see _Model Metadata_ below), and optionally a license file. A CZANN/CZMODEL can be created from a Keras / PyTorch model with the following three steps.#### 1. Create a model meta data classTo export a CZANN, meta information is needed that must be provided through a `ModelMetadata` instance.For segmentation:```pythonfrom czmodel.core.model_metadata import ModelMetadata, ModelTypemodel_metadata = ModelMetadata(    input_shape=[1024, 1024, 3],    output_shape=[1024, 1024, 5],    model_type=ModelType.SINGLE_CLASS_SEMANTIC_SEGMENTATION,    classes=[&quot;class1&quot;, &quot;class2&quot;, &quot;class3&quot;, &quot;class4&quot;, &quot;class5&quot;],    model_name=&quot;ModelName&quot;,    min_overlap=[90, 90])```For regression:```pythonfrom czmodel.core.model_metadata import ModelMetadata, ModelTypemodel_metadata = ModelMetadata(    input_shape=[1024, 1024, 3],    output_shape=[1024, 1024, 3],    model_type=ModelType.REGRESSION,    model_name=&quot;ModelName&quot;,    min_overlap=[90, 90])```For legacy CZMODEL models the legacy `ModelMetadata` must be used:```pythonfrom czmodel.core.legacy_model_metadata import ModelMetadata as LegacyModelMetadatamodel_metadata_legacy = LegacyModelMetadata(    name=&quot;Simple_Nuclei_SegmentationModel_Legacy&quot;,    classes=[&quot;class1&quot;, &quot;class2&quot;],    pixel_types=&quot;Bgr24&quot;,    color_handling=&quot;ConvertToMonochrome&quot;,    border_size=90,)``` #### 2 .Creating a model specificationThe model and its corresponding metadata are now wrapped into a ModelSpec object.```pythonfrom czmodel.tensorflow.model_spec import ModelSpec # for czmodel[tensorflow]#from czmodel.pytorch.model_spec import ModelSpec   # for czmodel[pytorch]model_spec = ModelSpec(    model=model,    model_metadata=model_metadata,    license_file=&quot;C:\\some\\path\\to\\a\\LICENSE.txt&quot;)```The corresponding model spec for legacy models is instantiated analogously.```pythonfrom czmodel.tensorflow.legacy_model_spec import ModelSpec as LegacyModelSpec  # for czmodel[tensorflow]#from czmodel.pytorch.legacy_model_spec import ModelSpec as LegacyModelSpec    # for czmodel[pytorch]legacy_model_spec = LegacyModelSpec(    model=model,    model_metadata=model_metadata_legacy,    license_file=&quot;C:\\some\\path\\to\\a\\LICENSE.txt&quot;)```#### 3. Converting the modelThe actual model conversion is finally performed with the ModelSpec object and the output path and name of the CZANN.```pythonfrom czmodel.tensorflow.convert import DefaultConverter as TensorflowDefaultConverter  # for czmodel[tensorflow]TensorflowDefaultConverter().convert_from_model_spec(model_spec=model_spec, output_path='some/path', output_name='some_file_name')from czmodel.pytorch.convert import DefaultConverter as PytorchDefaultConverter  # for czmodel[pytorch]PytorchDefaultConverter().convert_from_model_spec(model_spec=model_spec, output_path='some/path', output_name='some_file_name', input_shape=(3, 1024, 1024))```For legacy models the interface is similar.```pythonfrom czmodel.tensorflow.convert import LegacyConverter as TensorflowDefaultConverter  # for czmodel[tensorflow]TensorflowDefaultConverter().convert_from_model_spec(model_spec=legacy_model_spec, output_path='some/path',                                                 output_name='some_file_name')from czmodel.pytorch.convert import LegacyConverter as PytorchLegacyConverter  # for czmodel[pytorch]PytorchLegacyConverter().convert_from_model_spec(model_spec=legacy_model_spec, output_path='some/path',                                          output_name='some_file_name', input_shape=(3, 1024, 1024))```### Exported TensorFlow / PyTorch modelsNot all TensorFlow / PyTorch models can be converted. You can convert a model exported from TensorFlow / PyTorch if the model and the provided meta data comply with the _CZANN Model Specification_ below.The actual conversion is triggered by either calling:```pythonfrom czmodel.tensorflow.convert import DefaultConverter as TensorflowDefaultConverter  # for czmodel[tensorflow]TensorflowDefaultConverter().convert_from_json_spec('Path to JSON file', 'Output path', 'Model Name')from czmodel.pytorch.convert import DefaultConverter as PytorchDefaultConverter  # for czmodel[pytorch]PytorchDefaultConverter().convert_from_json_spec('Path to JSON file', 'Output path', (3, 1024, 1024), 'Model Name')```or by using the command line interface of the `savedmodel2czann` script (only for Keras model):```consolesavedmodel2ann path/to/model_spec.json output/path/ output_name --license_file path/to/license_file.txt```### Adding pre- and post-processing layers (only for Keras model)Both, `convert_from_json_spec` and `convert_from_model_spec` in the converter classes accept the following optional parameters:- `spatial_dims`: Set new spatial dimensions for the new input node of the model. This parameter is expected to contain the new height and width in that order. **Note:** The spatial input dimensions can only be changed in ANN architectures that are invariant to the spatial dimensions of the input, e.g. FCNs.- `preprocessing`: One or more pre-processing layers that will be prepended to the deployed model. A pre-processing layer must be derived from the `tensorflow.keras.layers.Layer` class.- `postprocessing`: One or more post-processing layers that will be appended to the deployed model. A post-processing layer must be derived from the `tensorflow.keras.layers.Layer` class.While ANN models are often trained on images in RGB(A) space, the ZEN infrastructure requires models inside a CZANN to expect inputs in BGR(A) color space. This toolbox offers pre-processing layers to convert the color space before passing the input to the model to be actually deployed. The following code shows how to add a BGR to RGB conversion layer to a model and set its spatial input dimensions to 512x512.```pythonfrom czmodel.tensorflow.util.transforms import TransposeChannelsfrom czmodel.tensorflow.convert import DefaultConverter# Define dimensions and pre-processingspatial_dims = 512, 512  # Optional: Target spatial dimensions of the modelpreprocessing = [TransposeChannels(order=(2, 1,                                          0))]  # Optional: Pre-Processing layers to be prepended to the model. Can be a single layer, a list of layers or None.postprocessing = None  # Optional: Post-Processing layers to be appended to the model. Can be a single layer, a list of layers or None.# Perform conversionDefaultConverter().convert_from_model_spec(    model_spec=model_spec,    output_path='some/path',    output_name='some_file_name',    spatial_dims=spatial_dims,    preprocessing=preprocessing,    postprocessing=postprocessing)```Additionally, the toolbox offers a `SigmoidToSoftmaxScores` layer that can be appended through the `postprocessing` parameter to convert the output of a model with sigmoid output activation to the output that would be produced by an equivalent model with softmax activation.### Unpacking CZANN/CZSEG filesThe czmodel library offers functionality to unpack existing CZANN/CZSEG models. For a given .czann or .czseg model it is possible to extract the underlying ANN model to a specified folder and retrieve the corresponding meta-data as instances of the meta-data classes defined in the czmodel library.For CZANN files:```pythonfrom czmodel.tensorflow.convert import DefaultConverter  # for czmodel[tensorflow]#from czmodel.pytorch.convert import DefaultConverter    # for czmodel[pytorch]from pathlib import Pathmodel_metadata, model_path = DefaultConverter().unpack_model(model_file='Path of the .czann file',                                                             target_dir=Path('Output Path'))```For CZSEG/CZMODEL files:```pythonfrom czmodel.tensorflow.convert import LegacyConverter  # for czmodel[tensorflow]#from czmodel.pytorch.convert import DefaultConverter   # for czmodel[pytorch]from pathlib import Pathmodel_metadata, model_path = LegacyConverter().unpack_model(model_file='Path of the .czseg/.czann file',                                                            target_dir=Path('Output Path'))```## CZANN Model SpecificationThis section specifies the requirements for an artificial neural network (ANN) model and the additionally required metadata to enable execution of the model inside the ZEN Intellesis infrastructure starting with ZEN blue &gt;=3.2 and ZEN Core &gt;3.0.  The model format currently allows to bundle models for semantic segmentation, instance segmentation, object detection, classification and regression and is defined as a ZIP archive with the file extension .czann containing the following files with the respective filenames:- JSON Meta data file. (filename: model.json)- Model in ONNX/TensorFlow SavedModel format. In case of  SavedModel format the folder representing the model must be zipped to a single file. (filename: model.model)- Optionally: A license file for the contained model. (filename: license.txt)The meta data file must comply with the following specification:```json{    &quot;$schema&quot;: &quot;http://iglucentral.com/schemas/com.snowplowanalytics.self-desc/schema/jsonschema/1-0-0#&quot;,    &quot;$id&quot;: &quot;http://127.0.0.1/model_format.schema.json&quot;,    &quot;title&quot;: &quot;Exchange format for ANN models&quot;,    &quot;description&quot;: &quot;A format that defines the meta information for exchanging ANN models. Any future versions of this specification should be evaluated through https://docs.snowplowanalytics.com/docs/pipeline-components-and-applications/iglu/igluctl-0-7-2/#lint-1 with --skip-checks numericMinMax,stringLength,optionalNull and https://www.json-buddy.com/json-schema-analyzer.htm.&quot;,    &quot;type&quot;: &quot;object&quot;,    &quot;self&quot;: {        &quot;vendor&quot;: &quot;com.zeiss&quot;,        &quot;name&quot;: &quot;model-format&quot;,        &quot;format&quot;: &quot;jsonschema&quot;,        &quot;version&quot;: &quot;1-1-0&quot;    },    &quot;properties&quot;: {        &quot;Id&quot;: {            &quot;description&quot;: &quot;Universally unique identifier of 128 bits for the model.&quot;,            &quot;type&quot;: &quot;string&quot;        },        &quot;Type&quot;: {            &quot;description&quot;: &quot;The type of problem addressed by the model.&quot;,            &quot;type&quot;: &quot;string&quot;,            &quot;enum&quot;: [&quot;SingleClassInstanceSegmentation&quot;, &quot;MultiClassInstanceSegmentation&quot;, &quot;SingleClassSemanticSegmentation&quot;, &quot;MultiClassSemanticSegmentation&quot;, &quot;SingleClassClassification&quot;, &quot;MultiClassClassification&quot;, &quot;ObjectDetection&quot;, &quot;Regression&quot;]        },        &quot;MinOverlap&quot;: {            &quot;description&quot;: &quot;The minimum overlap of tiles for each dimension in pixels. Must be divisible by two. In tiling strategies that consider tile borders instead of overlaps the minimum overlap is twice the border size.&quot;,            &quot;type&quot;: &quot;array&quot;,            &quot;items&quot;: {                &quot;description&quot;: &quot;The overlap of a single spatial dimension&quot;,                &quot;type&quot;: &quot;integer&quot;,                &quot;minimum&quot;: 0            },            &quot;minItems&quot;: 1        },        &quot;Classes&quot;: {            &quot;description&quot;: &quot;The class names corresponding to the last output dimension of the prediction. If the last dimension of the prediction has shape n the provided list must be of length n&quot;,            &quot;type&quot;: &quot;array&quot;,            &quot;items&quot;: {                &quot;description&quot;: &quot;A name describing a class for segmentation and classification tasks&quot;,                &quot;type&quot;: &quot;string&quot;            },            &quot;minItems&quot;: 2        },        &quot;ModelName&quot;: {            &quot;description&quot;: &quot;The name of exported neural network model in ONNX (file) or TensorFlow SavedModel (folder) format in the same ZIP archive as the meta data file. In the case of ONNX the model must use ONNX opset version 12. In the case of TensorFlow SavedModel all operations in the model must be supported by TensorFlow 2.0.0. The model must contain exactly one input node which must comply with the input shape defined in the InputShape parameter and must have a batch dimension as its first dimension that is either 1 or undefined.&quot;,            &quot;type&quot;: &quot;string&quot;        },        &quot;InputShape&quot;: {            &quot;description&quot;: &quot;The shape of an input image. A typical 2D model has an input of shape [h, w, c] where h and w are the spatial dimensions and c is the number of channels. A 3D model is expected to have an input shape of [z, h, w, c] that contains an additional dimension z which represents the third spatial dimension. The batch dimension is not specified here. The input of the model must be of type float32 in the range [0..1].&quot;,            &quot;type&quot;: &quot;array&quot;,            &quot;items&quot;: {                &quot;description&quot;: &quot;The size of a single dimension&quot;,                &quot;type&quot;: &quot;integer&quot;,                &quot;minimum&quot;: 1            },            &quot;minItems&quot;: 3,            &quot;maxItems&quot;: 4        },        &quot;OutputShape&quot;: {            &quot;description&quot;: &quot;The shape of the output image. A typical 2D model has an input of shape [h, w, c] where h and w are the spatial dimensions and c is the number of classes. A 3D model is expected to have an input shape of [z, h, w, c] that contains an additional dimension z which represents the third spatial dimension. The batch dimension is not specified here. If the output of the model represents an image, it must be of type float32 in the range [0..1].&quot;,            &quot;type&quot;: &quot;array&quot;,            &quot;items&quot;: {                &quot;description&quot;: &quot;The size of a single dimension&quot;,                &quot;type&quot;: &quot;integer&quot;,                &quot;minimum&quot;: 1            },            &quot;minItems&quot;: 3,            &quot;maxItems&quot;: 4        },        &quot;Scaling&quot;: {            &quot;description&quot;: &quot;The extent of a pixel in x- and y-direction (in that order) in units of m.&quot;,            &quot;type&quot;: &quot;array&quot;,            &quot;items&quot;: {                &quot;description&quot;: &quot;The extent of a pixel in a single dimension in units of m&quot;,                &quot;type&quot;: &quot;number&quot;            },            &quot;minItems&quot;: 2,            &quot;maxItems&quot;: 2        }    },    &quot;required&quot;: [&quot;Id&quot;, &quot;Type&quot;, &quot;InputShape&quot;, &quot;OutputShape&quot;]}```Json files can contain escape sequences and \\-characters in paths must be escaped with \\\\.The following code snippet shows an example for a valid metadata file:For single-class semantic segmentation:```json{  &quot;Id&quot;: &quot;b511d295-91ff-46ca-bb60-b2e26c393809&quot;,  &quot;Type&quot;: &quot;SingleClassSemanticSegmentation&quot;,  &quot;Classes&quot;: [&quot;class1&quot;, &quot;class2&quot;, &quot;class3&quot;, &quot;class4&quot;, &quot;class5&quot;],  &quot;InputShape&quot;: [1024, 1024, 3],  &quot;OutputShape&quot;: [1024, 1024, 5]}```For regression:```json{  &quot;Id&quot;: &quot;064587eb-d5a1-4434-82fc-2fbc9f5871f9&quot;,  &quot;Type&quot;: &quot;Regression&quot;,  &quot;InputShape&quot;: [1024, 1024, 3],  &quot;OutputShape&quot;: [1024, 1024, 3]}```</longdescription>
</pkgmetadata>