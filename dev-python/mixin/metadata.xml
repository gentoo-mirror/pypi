<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># do mixin for python  This project wants to implement a mixin library like ruby's module.## What mixin isIn object-oriented programming languages, a mixin is a class which contains a combination of methods from other classes. How such a combination is done depends on the language, but it is not by inheritance. If a combination contains all methods of combined classes it is equivalent to multiple inheritance.For more information, please refer to this wiki:http://en.wikipedia.org/wiki/Mixin## install pymixininstall it from pip:    pip install mixinIn fact, the pymix package only has one file, it is mixin.py, so you can also copy it directly to your project directory.## how to use pymixin### a simple exampleImport the Mixin class and mixin decorator from the mixin module:    &gt;&gt;&gt; from mixin import Mixin, mixinThe user's mixin class should always inherit from the Mixin class:    &gt;&gt;&gt; class MixinA(Mixin):    ...     def func_mixin_a(self):    ...             return 'do_func_mixin_a'    ...and then use the mixin decorator to add the mixin to a class:    &gt;&gt;&gt; @mixin(MixinA)    ... class A(object): pass    ...    &gt;&gt;&gt; a = A()    &gt;&gt;&gt; a.func_mixin_a()    'do_func_mixin_a'### add a mixin to another mixinThe mixin should not be inherited by another class:    &gt;&gt;&gt; class MixinA(Mixin): pass    ...    &gt;&gt;&gt; class A(MixinA): pass    ...    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;      File &quot;mixin.py&quot;, line 58, in __new__        raise InheritMixinError(clsname)    __main__.InheritMixinError: ABut you can add a mixin to another mixin:    &gt;&gt;&gt; class MixinA(Mixin):    ...     def func_mixin_a(self):    ...             return 'do_func_mixin_a'    ...    &gt;&gt;&gt; @mixin(MixinA)    ... class MixinB(Mixin):    ...     def func_mixin_b(self):    ...             return 'do_func_mixin_b'    ...Then add the MixinB to a normal class    &gt;&gt;&gt; @mixin(MixinB)    ... class M(object): pass    ...    &gt;&gt;&gt; m = M()    &gt;&gt;&gt; m.func_mixin_a()    'do_func_mixin_a'    &gt;&gt;&gt; m.func_mixin_b()    'do_func_mixin_b'### a mixin class can not be instantiated    &gt;&gt;&gt; class MixinA(Mixin): pass    ...    &gt;&gt;&gt; a = MixinA()    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;      File &quot;mixin.py&quot;, line 44, in mixin_new        raise InstantiationMixinError(cls)    __main__.InstantiationMixinError: &lt;class '__main__.MixinA'&gt;### inherit multi mixinTwo kind of methods to inherit multi mixins, one is writing multi mixins in one decorator:    &gt;&gt;&gt; class MixinA(Mixin): pass    ...    &gt;&gt;&gt; class MixinB(Mixin): pass    ...    &gt;&gt;&gt; @mixin(MixinA, MixinB)    ... class M(object): pass    ...Another is using multi decorators:    &gt;&gt;&gt; @mixin(MixinA)    ... @mixin(MixinB)    ... class M(object): pass    ...### inherit priorityWhen writes multi mixins to one decorator, the left mixin has a higher priority    &gt;&gt;&gt; class MixinA(Mixin):    ...     def mixin_func(self):    ...             return 'do_mixin_a'    ...    &gt;&gt;&gt; class MixinB(Mixin):    ...     def mixin_func(self):    ...             return 'do_mixin_b'    ...    &gt;&gt;&gt; @mixin(MixinA, MixinB)    ... class M(object): pass    ...    &gt;&gt;&gt; m = M()    &gt;&gt;&gt; m.mixin_func()    'do_mixin_a'When writes multi mixins in multi decorators, the up mixin has a higher priority:    &gt;&gt;&gt; @mixin(MixinA)    ... @mixin(MixinB)    ... class M(object): pass    ...    &gt;&gt;&gt; m = M()    &gt;&gt;&gt; m.mixin_func()    'do_mixin_a'If the class has a funciton which has the same name as the mixin, the mixin method will be overwrite:    &gt;&gt;&gt; class MixinA(Mixin):    ...     def mixin_func(self):    ...             return 'do_mixin_a'    ...    &gt;&gt;&gt; @mixin(MixinA)    ... class A(object):    ...     def mixin_func(self):    ...             return 'real_class_mixin_a'    ...    &gt;&gt;&gt; a = A()    &gt;&gt;&gt; a.mixin_func()    'real_class_mixin_a'If a class has a father class, and the father class has a same name method as the mixin, the father class' method will be overwrite:    &gt;&gt;&gt; class MixinA(Mixin):    ...     def mixin_func(self):    ...             return 'do_mixin_a'    ...    &gt;&gt;&gt; class Father(object):    ...     def mixin_func(self):    ...             return 'father_mixin'    ...    &gt;&gt;&gt; @mixin(MixinA)    ... class A(Father): pass    ...    &gt;&gt;&gt; a=A()    &gt;&gt;&gt; a.mixin_func()    'do_mixin_a'## python version supportTested on python2.6, python2.7 and python3.4</longdescription>
</pkgmetadata>