<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>The `tc-admin` library supports administration of the runtime configuration of a Taskcluster deployment.This means creation and maintenance of resources such as roles, hooks, and worker pools, based on version-controlled specifications..# UsageThis library is used as a dependency of a Python application containing code and configuration specific to the taskcluster deployment(s) being administered.The project should contain a `tc-admin.py` that serves to define the application configuration.Assuming that is in place, the tool is easy to use:After installing the app, run `tc-admin generate` to generate the expected set of resources (use `--json` to get JSON output).This will require `TASKCLUSTER_ROOT_URL` to be set in the environment, to know which deployment to talk to.Similarly, `tc-admin current` will generate the current set of resources (optionally with `--json`).To compare them, run `tc-admin diff`.If the configuration includes secrets, you may want to pass the `--without-secrets` option.This option skips managing the content of secrets, and thus needs neither access to secret values nor Taskcluster credentials to fetch secrets.Run `tc-admin apply` to apply the changes.Note that only `apply` will require Taskcluster credentials, and it's a good practice to only set TC credentials when running this command.See `tc-admin &lt;command&gt; --help` for more useful options.## ChecksChecks are a way to double-check that purpose-specific invariants are satisfied in a Taskcluster deployment.For example, it may be important to check that only specific repository roles have scopes to create tasks in critical worker pools.Checks are defined as normal Python tests, and have access to the current and generated configurations.If the app has checks set up, then `tc-admin check` will run those checks.# Quick Guide to Library OperationThe operation of this tool is pretty simple: it generates a set of expected Taskcluster resources, downloads existing resources from the Taskcluster API, and compares them.A collection of resources also specifies the set of &quot;managed&quot; resources -- this allows deletion of resources that are no longer expected, without risk of deleting *everything* in the Taskcluster API.After generation, resources can be &quot;modified&quot;.This is typically used to make minor changes to resources depending on environment.For exmaple, in a staging environment, hook schedules might be removed.# App Configuration## `tc-admin` and `tc-admin.py`A tc-admin app is configured by `tc-admin.py`.This is a Python file which is responsible for creating and customizing an `AppConfig` object.```pythonfrom tcadmin.appconfig import AppConfigappconfig = AppConfig()# .. customize```The `tc-admin` command looks for `tc-admin.py` in the current directory, or in the directory given by `$TC_ADMIN_PY` or command-line argument `--tc-admin-py`.Like most Python modules, the global `__file__` is set when `tc-admin.py` is executed, and can be used to determine relative paths.Before `tc-admin.py` is executed, the current working directory is changed to the directory containing it.This enables relative imports as well as loading files with relative paths (such as with LocalLoader, below).## Programmatic InterfaceThis library can also be used programmatically.Simply create an AppConfig object directly and call `tcadmin.main.main` with it:```pythonfrom tcadmin.appconfig import AppConfigfrom tcadmin.main import maindef boot():    appconfig = AppConfig()    # .. customize    main(appconfig)if __name__ == &quot;__main__&quot;:    boot()```Note that the current directory is not automatically set in this case.## AppConfigThe AppConfig object contains a number of properties that can be customized, described below.During execution, the current AppConfig object is available from `AppConfig.current()`.This can be useful when generators or modifiers are defined in separate Python modules.### GeneratorsGenerators generate expected Taskcluster resources and defined the managed resource names.Each generator is an async function that is given a `Resources` object and is expected to call `resources.manage` and `resources.update`.Generators are registered with `appconfig.generators.register`, most easily with a decorator:```python@appconfig.generators.registerasync def update_resources(resources):    # modify in place ...```When generating secrets, respect the `--with-secrets` option, and generate secrets without values when it is false.You can also use this option to determine whether the generation process requires access to secret values.This allows generation runs with `--without-secrets` to occur without any credentials or access to secret values.```python@appconfig.generators.registerasync def update_resources(resources):    # modify in place ...    if appconfig.options.get('--with-secrets'):        secretstore = load_secret_values()        resources.add(Secret(            name=&quot;top-secret/cookie-recipe&quot;,            secret=secretstore.decrypt('recipes/double-chocolate-chip')))     else:        resources.add(Secret(name=&quot;top-secret/cookie-recipe&quot;))```### ModifiersModifiers are responsible for modifying an existing set of resources.Since resources are immutable, the signature differs slightly from generators:```python@appconfig.modifiers.registerasync def modify_resources(resources):    # return new set of resources    return resources.map(..)```Modifiers are called sequentially in the order in which they were registered.### CallbacksCallbacks are external function from your own application that can be executed at specific times during the `tc-admin apply` execution:* A `before_apply` callback will run before a resource is created, updated or deleted,* A `after_apply` callback will run after a resource has beencreated, updated or deleted.Supported actions are :* create* update* deleteBy default all actions are used.All resources are supported by callbacks, and enabled by default. If you want to limit your callback to some resources, you need to specify them using their class (not a string).You can declare your callbacks as:```pythonfrom tcadmin.resources import Secretasync def my_action(action, resource):    print(&quot;Got a callback on&quot;, action, resource)# Will call your function when a secret has been updated or deletedappconfig.callbacks.add(&quot;after_apply&quot;, my_action, actions=[&quot;update&quot;, &quot;delete&quot;], resources=[Secret, ])```### Command-Line OptionsApps can add additional command-line options, the values of which are then available during resource generation.To register an option, call `appconfig.options.add`, with the full option name and any of the following keyword options: * `required` - if True, the option is required * `help` - help string to be shown in `tc-admin generate --help` * `default` - default value for the optionTo retrieve the option value during generation, call `appconfig.options.get(name)`.All together, then:```pythonappconfig.options.add(&quot;--branch&quot;, help=&quot;configuration branch to read from&quot;)@appconfig.generators.registerasync def update_resources(resources):    branch = appconfig.options.get(&quot;--branch&quot;)    # ...```As a special case, the `--with-secrets` secret is available through this same mechanism.### ChecksThe `appconfig.check_path` property gives the path of the checks to run for `tc-admin check`, relative to the current directory.This directory is a &quot;normal&quot; pytest directory.To help distinguish checks from tests, include a `pytest.ini` in this directory:```ini[pytest]python_classes = Check*python_files = check_*.pypython_functions = check_*```### description_prefixThe `appconfig.description_prefix` property allows the users to customize the prefix of the description.This can be customized in the `tc-admin.py` as follows:```pythonfrom tcadmin.appconfig import AppConfigappconfig = AppConfig()appconfig.description_prefix = &quot;YOUR_CUSTOM_PREFIX&quot;```The DEFAULT value of the description_prefix is `*DO NOT EDIT* - This resource is configured automatically.\n\n`### Root URLFor the common case of a configuration that applies to only one Taskcluster deployment, specify that deployment's root URL in `tc-admin.py`:```pythonfrom tcadmin.appconfig import AppConfigappconfig = AppConfig()appconfig.root_url = &quot;https://taskcluster.example.com&quot;```To support more complex cases, this value can also be an async callable.It will be invoked once, after the `click` options have been processed, so it can access `appconfig.options` if necessary.The current root URL is available from an async helper function:```pythonfrom tcadmin.util.root_url import root_urlasync def foo():    print(await root_url())```This will retrieve the value from the AppConfig or, if that is not set, from `TASKCLUSTER_ROOT_URL`.If both are set, and the values do not match, it will produce an error message.### Loading Config SourcesMost uses of this library load configuration data from some easily-modified YAML files.The `tcadmin.util.config` package provides some support for loading and parsing these files.All of this is entirely optional; use what is appropriate to the purpose.#### LoadersFirst, define a loader that can load data from files.```pythonfrom tcadmin.util.config import LocalLoaderloader = LocalLoader()```The LocalLoader class knows how to load configuration from files relative to `tc-admin.py`.It has a `load` method that will load data, optionally parsing it as YAML:```pythondata = loader.load(&quot;data.bin&quot;)aliases = await loader.load(&quot;aliases.yml&quot;, parse=&quot;yaml&quot;)```You can also define your own loader class.Just implement the `load_raw` method to return bytes, given a filename.#### ConfigYAML data is inconvenient to deal with in Python, introducig a lot of `[&quot;..&quot;]` noise.Commonly, config files are either a top-level array, or a top-level object with named &quot;stanzas&quot; of configuration.The ConfigList and ConfigDict classes support these formats.We suggest using these with the Python `attrs` library.Define a class that inherits from either of these classes, specifies the filename to load from, and has an `Item` class for the items in the collection:```pythonfrom tcadmin.util.config import ConfigListclass Workers(ConfigList):    filename = &quot;workers.yml&quot;    @attr.s    class Item:        workerId = attr.ib(type=str)        bigness = attr.ib(type=int, default=1)```Then simply call `await Workers.load(loader)` to load a `workers.yml` that looks something like```yaml- workerId: small  bigness: 5- workerId: huge  bigness: 5000```The ConfigDict class is similar, but parses files like```yamlsmall:  bigness: 5huge:  bigness: 5000```ConfigList creates new `Item` instances from array elements `item` with `Item(**item)`.ConfigDict creates new `Item` instances from `k: item` with `Item(k, **item)`.This approach is compatible with `attrs`, where in the latter case `k` should be the first attribute defined.If array elements or object values are not themselves YAML objects, add a class method named `transform_item` to transform the data in the YAML file into a Python dictionary.For example:```pythonclass Workers(ConfigList):    @classmethod    def transform_item(cls, item):        # given a simple string, assume that is the workerId and apply defaults        if isinstance(item, str):            return {&quot;workerId&quot;: item}        return item    ...```## ResourcesThe `tcadmin.resources` package contains clasess for defining Taskcluster resources and collections.```pythonfrom tcadmin.resources import Resources```The `Resources` class defines a collection of resources and tracks what resources are managed.Resources found in the Taskcluster deployment that match the &quot;managed&quot; patterns but are not generated will be deleted on `apply`.The class has the following methods:* `resources.add(resource)` - add a resource to the collection.  The resource must be managed.* `resources.update(iterable)` - add an iterable full of resources to the collection.  All resources must be managed.* `resources.manage(pattern)` - consider reources matching regular expression string `pattern` to be managed* `resources.is_managed(id)` - return true if the given resource is managed* `resources.filter(pattern)` - return a new Resources object containing only resources matching the given regular expression string* `resources.map(functor)` - return a new Resources object, with fuctor applied to each resource.  This is typically used in modifiers.Resources must be unique -- tc-admin cannot manage multiple hooks with the same name, for example.However, some resource kinds support merging, where adding a resource with the same identity as one that already exists &quot;merges&quot; it into the existing resource.See the description of roles, below.The remaining classes represent individual resources.Each has an `id` formed from its kind and the unique identifier for the resource in the Taskcluster.For example, `Hook=release-hooks/beta-release`.Resources are immutable once created, but can be &quot;evolved&quot; (returning a new resource) with `rsrc.evolve(**updates)`.Resources with descriptions automatically prepend a &quot;DO NOT EDIT&quot; prefix to dissuade users from editing them in the Taskcluster UI.### Hook```pythonfrom tcadmin.resources import Hook, Bindinghook = Hook(    hookGroupId=..,    hookId=..,    name=..,    description=..,    owner=..,    emailOnError=..,    schedule=(.., ..),    bindings=(.., ..),    task={..},    triggerSchema={..})```Most of these fields correspond directly to the Taskcluster definition.Both `schedule` and `bindings` must be tuples, not lists (as lists are mutable).The items in `schedule` are cron-like strings.The items in `bindings` are instances of `Binding(exchange=.., routingKeyPattern=..)`.### Secret```pythonfrom tcadmin.resources import Secretsecret = Secret(    name=..,    secret=..)# or, when not managing secret valuessecret = Secret(name=..)```Secrets are managed using the Secret resource type.While Taskcluster supports expiration times on secrets, this library sets those times the far future, effectively creating non-expiring secretsThis library is careful to not display secret values in its output.Instead, it displays `&lt;unknown&gt;` when not managing secret values, and displays a salted hash of the secret value when managing secret values.The salted hash allows `tc-admin diff` to show that a secret value has changed, without revealing the value of that secret.The salt includes a per-run salt, and the name of the secret, with the result that even if two secrets have the same value, they will be shown with different hashes in `tc-admin generate`.### Role```pythonfrom tcadmin.resources import Rolerole = Role(    roleId=..,    description=..,    scopes=(.., ..))```As with hooks, `scopes` must be a tuple (not a list) of strings.Roles can be merged if their descriptions match.The resulting role contains the union of the scopes of the input roles.This functionality makes management of roles easier in cases where different parts of the generation process may add scopes to the same role.For example:```pythonresources.add(Role(roleId=&quot;my-role&quot;, description=&quot;My Role&quot;, scopes=[&quot;scope1&quot;]))resources.add(Role(roleId=&quot;my-role&quot;, description=&quot;My Role&quot;, scopes=[&quot;scope2&quot;]))```This will result in a single Role with scopes `[&quot;scope1&quot;, &quot;scope2&quot;]`.### Client```pythonfrom tcadmin.resources import Clientclient = Client(    clientId=..,    description=..,    scopes=(.., ..))```Clients work much like roles.As with roles, `scopes` must be a tuple (not a list) of strings.This library does not manage access tokens: it discards them from the response to `auth.createClient`.The expectation is that project admins who need credentials for the managed clients will call `auth.resetAccessToken` and use the returned token.Clients configured by this library have an expiration date far in the future.Like roles, the clients managed here last &quot;forever&quot;.### WorkerPool```pythonfrom tcadmin.resources import WorkerPoolworkerPool = WorkerPool(    workerPoolId=..,    providerId=..,    description=..,    owner=..,    config={..},    emailOnError=..)```All attributes of this class match the Taskcluster definition.## UtiliitesThe library provides a number of utilities for common application requirements.*NOTE*: only functions described in this README are considered stable.Other functions defined by the library may change without notice.### ScopesAs an aid to writing checks, tc-admin supplies local implementations of various scope-related algorithms.```pythonfrom tcadmin.util.scopes import satisfies, normalizeScopes, Resolver```The `satisfies` function determines scope satisfaction, without any expansion.Satisfaction means that the first argument contains all scopes in the second argument.```pythonassert satisfies(['balloons:*', 'cake:birthday'], ['baloons:mylar:happy-birthday'])```The `normalizeScopes` function normalizes a scopeset, removing redundant scopes and sorting.```pythonassert normalizedScopes(['balloons:*', 'balloons:mylar:*']) == ['baloons:*']```Finally, `Resolver` can perform scope expansion.It is initialized with a dictionary mapping roleIds to scope lists.Alternately, it can be initialized from a `Resources` instance using `Resolver.from_resources(resources)`.Its `expandScopes` method behaves identically to the remote call `auth.expandScopes`.```pythonresolver = Resolver.from_resources(resources)assert resolver.expandScopes(['assume:clown:grimaldi']) == ['assume:clown:grimaldi', 'ruffle:full']```### aiohttp sessionThe library uses `aiohttp` to communicate with Taskcluster, and establishes a single session for efficiency.Applications can use the same session for any other HTTP operations.```pythonfrom tcadmin.util.session import aiohttp_sessionasync def foo():    # ...    async with aiohttp_session().get(url) as response:        response.raise_for_status()        result = await response.read()```Tests and checks can set this value using `with_aiohttp_session`:```pythonfrom tcadmin.util.sessions import with_aiohttp_sessionimport pytest@pytest.mark.asyncio@with_aiohttp_sessionasync def test_something():    # ...```### MatchListA MatchList is a list of regular expressions that can determine whether a givenstring matches one of those patterns.  Patterns are rooted at the left, butshould use `$` where required to match the end of the string.```pythonfrom tcadmin.util.matchlist import MatchListml = MatchList()ml.add(&quot;fo+$&quot;)ml.add(&quot;ba+r$&quot;)assert ml.matches(&quot;foo&quot;)```This functionality is used to track managed resources, but may be useful otherwise.# DevelopmentTo install for development, in a virtualenv:```pip install -e [path]```And to run flake8 and tests:```python setup.py flake8python setup.py test```The library uses [Black](https://black.readthedocs.io/en/stable/) to format code.```pip install blackblack tcadmin```## ReleasingTo release: * update version in `setup.py` and `git commit -m &quot;vX.Y.Z&quot;` * `git tag vX.Y.z` * push those changes to `main` * `./release.sh --real` and enter your pypi credentials when prompted (omit the `--real` to try it against the testing pypi, if you're not sure) * Find the tag in https://github.com/taskcluster/tc-admin/releases and create a new release with a brief description of the changes</longdescription>
</pkgmetadata>