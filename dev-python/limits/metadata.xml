<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. |ci| image:: https://github.com/alisaifee/limits/workflows/CI/badge.svg?branch=master    :target: https://github.com/alisaifee/limits/actions?query=branch%3Amaster+workflow%3ACI.. |codecov| image:: https://codecov.io/gh/alisaifee/limits/branch/master/graph/badge.svg   :target: https://codecov.io/gh/alisaifee/limits.. |pypi| image:: https://img.shields.io/pypi/v/limits.svg?style=flat-square    :target: https://pypi.python.org/pypi/limits.. |pypi-versions| image:: https://img.shields.io/pypi/pyversions/limits?style=flat-square    :target: https://pypi.python.org/pypi/limits.. |license| image:: https://img.shields.io/pypi/l/limits.svg?style=flat-square    :target: https://pypi.python.org/pypi/limits.. |docs| image:: https://readthedocs.org/projects/limits/badge/?version=latest   :target: https://limits.readthedocs.orglimits------|docs| |ci| |codecov| |pypi| |pypi-versions| |license|**limits** is a python library to perform rate limiting with commonly used storage backends (Redis, Memcached, MongoDB &amp; Etcd).----Sponsored by Zuplo - fully-managed, programmable API Management platform.Add rate limiting and more to your public API in minutes, try it at `zuplo.com &lt;https://zuplo.link/3DZM9Ej&gt;`_----Supported Strategies====================`Fixed Window &lt;https://limits.readthedocs.io/en/latest/strategies.html#fixed-window&gt;`_   This strategy resets at a fixed interval (start of minute, hour, day etc).   For example, given a rate limit of ``10/minute`` the strategy will:   - Allow 10 requests between ``00:01:00`` and ``00:02:00``   - Allow 10 requests at ``00:00:59`` and 10 more requests at ``00:01:00```Fixed Window (Elastic) &lt;https://limits.readthedocs.io/en/latest/strategies.html#fixed-window-with-elastic-expiry&gt;`_   Identical to Fixed window, except every breach of rate limit results in an extension   to the time out. For example a rate limit of `1/minute` hit twice within a minute will   result in a lock-out for two minutes.`Moving Window &lt;https://limits.readthedocs.io/en/latest/strategies.html#moving-window&gt;`_   Sliding window strategy enforces a rate limit of N/(m time units)   on the **last m** time units at the second granularity.   For example, with a rate limit of ``10/minute``:   - Allow 9 requests that arrive at ``00:00:59``   - Allow another request that arrives at ``00:01:00``   - Reject the request that arrives at ``00:01:01``Storage backends================- `Redis &lt;https://limits.readthedocs.io/en/latest/storage.html#redis-storage&gt;`_- `Memcached &lt;https://limits.readthedocs.io/en/latest/storage.html#memcached-storage&gt;`_- `MongoDB &lt;https://limits.readthedocs.io/en/latest/storage.html#mongodb-storage&gt;`_- `Etcd &lt;https://limits.readthedocs.io/en/latest/storage.html#etcd-storage&gt;`_- `In-Memory &lt;https://limits.readthedocs.io/en/latest/storage.html#in-memory-storage&gt;`_Dive right in=============Initialize the storage backend.. code-block:: python   from limits import storage   memory_storage = storage.MemoryStorage()   # or memcached   memcached_storage = storage.MemcachedStorage(&quot;memcached://localhost:11211&quot;)   # or redis   redis_storage = storage.RedisStorage(&quot;redis://localhost:6379&quot;)   # or use the factory   storage_uri = &quot;memcached://localhost:11211&quot;   some_storage = storage.storage_from_string(storage_uri)Initialize a rate limiter with the Moving Window Strategy.. code-block:: python   from limits import strategies   moving_window = strategies.MovingWindowRateLimiter(memory_storage)Initialize a rate limit.. code-block:: python    from limits import parse    one_per_minute = parse(&quot;1/minute&quot;)Initialize a rate limit explicitly.. code-block:: python    from limits import RateLimitItemPerSecond    one_per_second = RateLimitItemPerSecond(1, 1)Test the limits.. code-block:: python    assert True == moving_window.hit(one_per_minute, &quot;test_namespace&quot;, &quot;foo&quot;)    assert False == moving_window.hit(one_per_minute, &quot;test_namespace&quot;, &quot;foo&quot;)    assert True == moving_window.hit(one_per_minute, &quot;test_namespace&quot;, &quot;bar&quot;)    assert True == moving_window.hit(one_per_second, &quot;test_namespace&quot;, &quot;foo&quot;)    assert False == moving_window.hit(one_per_second, &quot;test_namespace&quot;, &quot;foo&quot;)    time.sleep(1)    assert True == moving_window.hit(one_per_second, &quot;test_namespace&quot;, &quot;foo&quot;)Check specific limits without hitting them.. code-block:: python    assert True == moving_window.hit(one_per_second, &quot;test_namespace&quot;, &quot;foo&quot;)    while not moving_window.test(one_per_second, &quot;test_namespace&quot;, &quot;foo&quot;):        time.sleep(0.01)    assert True == moving_window.hit(one_per_second, &quot;test_namespace&quot;, &quot;foo&quot;)Links=====* `Documentation &lt;http://limits.readthedocs.org/en/latest&gt;`_* `Changelog &lt;http://limits.readthedocs.org/en/stable/changelog.html&gt;`_</longdescription>
</pkgmetadata>