<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># graphql-sync-dataloadersUse DataLoaders in your Python GraphQL servers that have to run in a synccontext (i.e. Django).## Requirements* Python 3.8+* graphql-core &gt;=3.2.0## InstallationThis package can be installed from [PyPi](https://pypi.python.org/pypi/graphql-sync-dataloaders) by running:```bashpip install graphql-sync-dataloaders```## Strawberry setupWhen creating your Strawberry Schema pass `DeferredExecutionContext` as the`execution_context_class` argument:```python# schema.pyimport strawberryfrom graphql_sync_dataloaders import DeferredExecutionContextschema = strawberry.Schema(Query, execution_context_class=DeferredExecutionContext)```Then create your dataloaders using the `SyncDataLoader` class:```pythonfrom typing import Listfrom graphql_sync_dataloaders import SyncDataLoaderfrom .app import models  # your Django modelsdef load_users(keys: List[int]) -&gt; List[User]:    qs = models.User.objects.filter(id__in=keys)    user_map = {user.id: user for user in qs}    return [user_map.get(key, None) for key in keys]user_loader = SyncDataLoader(load_users)```You can then use the loader in your resolvers and it will automatically bebatched to reduce the number of SQL queries:```pythonimport strawberry@strawberry.typeclass Query:    @strawberry.field    def get_user(self, id: strawberry.ID) -&gt; User:        return user_loader.load(id)```**Note: You probably want to setup your loaders in context. Seehttps://strawberry.rocks/docs/guides/dataloaders#usage-with-context for moredetails**The following query will only make 1 SQL query:```graphqlfragment UserDetails on User {  username}query {  user1: getUser(id: '1') {    ...UserDetails  }  user2: getUser(id: '2') {    ...UserDetails  }  user3: getUser(id: '3') {    ...UserDetails  }}```## Graphene-Django setup**Requires graphene-django &gt;=3.0.0b8**When setting up your GraphQLView pass `DeferredExecutionContext` as the`execution_context_class` argument:```python# urls.pyfrom django.urls import pathfrom graphene_django.views import GraphQLViewfrom graphql_sync_dataloaders import DeferredExecutionContextfrom .schema import schemaurlpatterns = [    path(        &quot;graphql&quot;,        csrf_exempt(            GraphQLView.as_view(                schema=schema,                 execution_context_class=DeferredExecutionContext            )        ),    ),]```Then create your dataloaders using the `SyncDataLoader` class:```pythonfrom typing import Listfrom graphql_sync_dataloaders import SyncDataLoaderfrom .app import models  # your Django modelsdef load_users(keys: List[int]) -&gt; List[User]:    qs = models.User.objects.filter(id__in=keys)    user_map = {user.id: user for user in qs}    return [user_map.get(key, None) for key in keys]user_loader = SyncDataLoader(load_users)```You can then use the loader in your resolvers and it will automatically bebatched to reduce the number of SQL queries:```pythonimport grapheneclass Query(graphene.ObjectType):    get_user = graphene.Field(User, id=graphene.ID)    def resolve_get_user(root, info, id):        return user_loader.load(id)```The following query will only make 1 SQL query:```graphqlfragment UserDetails on User {  username}query {  user1: getUser(id: '1') {    ...UserDetails  }  user2: getUser(id: '2') {    ...UserDetails  }  user3: getUser(id: '3') {    ...UserDetails  }}```## How it worksThis library implements a custom version of the graphql-core[ExecutionContext class](https://github.com/graphql-python/graphql-core/blob/5f6a1944cf6923f6249d1575f5b3aad87e629c66/src/graphql/execution/execute.py#L171)that is aware of the `SyncFuture` objects defined in this library. A`SyncFuture` represents a value that hasn't been resolved to a value yet(similiar to asycnio Futures or JavaScript Promises) and that is what the`SyncDataLoader` returns when you call the `.load` function.When the custom `ExecutionContext` encounters a `SyncFuture` that gets returnedfrom a resolver and it keeps track of them. Then after the first pass of theexection it triggers the `SyncFuture` callbacks until there are none left. Oncethere are none left the data is fully resolved and can be returned to thecaller synchronously. This allows us to implement a `DataLoader` pattern thatbatches calls to a loader function, and it allows us to do this in a fullysynchronously way.## Credits[@Cito](https://github.com/Cito) for graphql-core and for implementing the first version of this in https://github.com/graphql-python/graphql-core/pull/155</longdescription>
</pkgmetadata>