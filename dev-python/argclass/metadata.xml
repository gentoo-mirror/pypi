<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>argclass========.. image:: https://coveralls.io/repos/github/mosquito/argclass/badge.svg?branch=master   :target: https://coveralls.io/github/mosquito/argclass?branch=master.. image:: https://github.com/mosquito/argclass/workflows/tests/badge.svg   :target: https://github.com/mosquito/argclass/actions?query=workflow%3Atests   :alt: Actions.. image:: https://img.shields.io/pypi/v/argclass.svg   :target: https://pypi.python.org/pypi/argclass/   :alt: Latest Version.. image:: https://img.shields.io/pypi/pyversions/argclass.svg   :target: https://pypi.python.org/pypi/argclass/.. image:: https://img.shields.io/pypi/l/argclass.svg   :target: https://pypi.python.org/pypi/argclass/A wrapper around the standard ``argparse`` module that allows you to describeargument parsers declaratively.By default, the ``argparse`` module suggests creating parsers imperative,which is not convenient from the point of view of type checking andaccess to attributes, of course, IDE autocompletion and type hints notapplicable in this case.This module allows you to declare command-line parsers with classes.Simple example:.. code-block:: python    :name: test_simple_example    import logging    import argclass    class CopyParser(argclass.Parser):        recursive: bool        preserve_attributes: bool    parser = CopyParser()    parser.parse_args([&quot;--recursive&quot;, &quot;--preserve-attributes&quot;])    assert parser.recursive    assert parser.preserve_attributesAs you can see this example shown a basic module usage, when you want specifyargument default and other options you have to use ``argclass.Argument``.Following example use ``argclass.Argument`` and argument groups:.. code-block:: python    :name: test_example    from typing import FrozenSet    import logging    import argclass    class AddressPortGroup(argclass.Group):        address: str = argclass.Argument(default=&quot;127.0.0.1&quot;)        port: int    class Parser(argclass.Parser):        log_level: int = argclass.LogLevel        http = AddressPortGroup(title=&quot;HTTP options&quot;, defaults=dict(port=8080))        rpc = AddressPortGroup(title=&quot;RPC options&quot;, defaults=dict(port=9090))        user_id: FrozenSet[int] = argclass.Argument(            nargs=&quot;*&quot;, type=int, converter=frozenset        )    parser = Parser(        config_files=[&quot;.example.ini&quot;, &quot;~/.example.ini&quot;, &quot;/etc/example.ini&quot;],        auto_env_var_prefix=&quot;EXAMPLE_&quot;    )    parser.parse_args([])    # Remove all used environment variables from os.environ    parser.sanitize_env()    logging.basicConfig(level=parser.log_level)    logging.info('Listening http://%s:%d', parser.http.address, parser.http.port)    logging.info(f'Listening rpc://%s:%d', parser.rpc.address, parser.rpc.port)    assert parser.http.address == '127.0.0.1'    assert parser.rpc.address == '127.0.0.1'    assert parser.http.port == 8080    assert parser.rpc.port == 9090Run this script:.. code-block::    $ python example.py    INFO:root:Listening http://127.0.0.1:8080    INFO:root:Listening rpc://127.0.0.1:9090Example of ``--help`` output:.. code-block::    $ python example.py --help    usage: example.py [-h] [--log-level {debug,info,warning,error,critical}]                     [--http-address HTTP_ADDRESS] [--http-port HTTP_PORT]                     [--rpc-address RPC_ADDRESS] [--rpc-port RPC_PORT]    optional arguments:      -h, --help            show this help message and exit      --log-level {debug,info,warning,error,critical}                            (default: info) [ENV: EXAMPLE_LOG_LEVEL]    HTTP options:      --http-address HTTP_ADDRESS                            (default: 127.0.0.1) [ENV: EXAMPLE_HTTP_ADDRESS]      --http-port HTTP_PORT                            (default: 8080) [ENV: EXAMPLE_HTTP_PORT]    RPC options:      --rpc-address RPC_ADDRESS                            (default: 127.0.0.1) [ENV: EXAMPLE_RPC_ADDRESS]      --rpc-port RPC_PORT   (default: 9090) [ENV: EXAMPLE_RPC_PORT]    Default values will based on following configuration files ['example.ini',    '~/.example.ini', '/etc/example.ini']. Now 1 files has been applied    ['example.ini']. The configuration files is INI-formatted files where    configuration groups is INI sections.    See more https://pypi.org/project/argclass/#configsSecrets+++++++Arguments reflecting some sensitive data, tokens or encryption keys,urls with passwords, when passed through environment variables or aconfiguration file, can be printed in the output of `--help`.To hide defaults, add the `secret=True` parameter,or use the special default constructor `argclass.Secret` instead of`argclass.Argument`... code-block:: python    import argclass    class HttpAuthentication(argclass.Group):        username: str = argclass.Argument()        password: str = argclass.Secret()    class HttpBearerAuthentication(argclass.Group):        token: str = argclass.Argument(secret=True)    class Parser(argclass.Parser):        http_basic = HttpAuthentication()        http_bearer = HttpBearerAuthentication()    parser = Parser()    parser.print_help()Trying to protect data from being written to the log~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~A secret is not actually a string, but a special class inheritedfrom a `str`, and all attempts to cast this type to a `str`(using `__str__` method) should be fine, and returning the originalvalue, unless the `__str__` method call is from a `logging` module... code-block:: python    &gt;&gt;&gt; import logging    &gt;&gt;&gt; from argclass import SecretString    &gt;&gt;&gt; logging.basicConfig(level=logging.INFO)    &gt;&gt;&gt; s = SecretString(&quot;my-secret-password&quot;)    &gt;&gt;&gt; logging.info(s)          # __str__ will be called from logging    &gt;&gt;&gt; logging.info(f&quot;s=%s&quot;, s) # __str__ will be called from logging too    &gt;&gt;&gt; logging.info(f&quot;{s!r}&quot;)   # repr is safe    &gt;&gt;&gt; logging.info(f&quot;{s}&quot;)     # the password will be compromisedOf course this is not a absolute sensitive data protection,but I hope it helps against accidental logging of this kind of values.The repr for this will always give placeholder, so it is better to alwaysadd `!r` for any f-string, for example `f'{value!r}'`.Configs+++++++The parser objects might be get default values from environment variables orone of passed configuration files... code-block:: python    class AddressPortGroup(argclass.Group):        address: str = argclass.Argument(default=&quot;127.0.0.1&quot;)        port: int    class Parser(argclass.Parser):        spam: str        quantity: int        log_level: int = argclass.LogLevel        http = AddressPortGroup(title=&quot;HTTP options&quot;)        rpc = AddressPortGroup(title=&quot;RPC options&quot;)        user_ids = argclass.Argument(            type=int, converter=frozenset, nargs=argclass.Nargs.ONE_OR_MORE        )    # Trying to parse all passed configuration files    # and break after first success.    parser = Parser(        config_files=[&quot;.example.ini&quot;, &quot;~/.example.ini&quot;, &quot;/etc/example.ini&quot;],    )    parser.parse_args()In this case each passed and existent configuration file will be opened.The root level arguments might described in the ``[DEFAULT]`` section.Other arguments might be described in group specific sections.So the full example of config file for above example is:.. code-block:: ini    [DEFAULT]    log_level=info    spam=egg    quantity=100    user_ids=[1, 2, 3]    [http]    address=127.0.0.1    port=8080    [rpc]    address=127.0.0.1    port=9090Subparsers++++++++++Complex example with subparsers:.. code-block:: python    import logging    from functools import singledispatch    from pathlib import Path    from typing import Optional, Any    import argclass    class AddressPortGroup(argclass.Group):        address: str = argclass.Argument(default=&quot;127.0.0.1&quot;)        port: int    class CommitCommand(argclass.Parser):        comment: str = argclass.Argument()    class PushCommand(argclass.Parser):        comment: str = argclass.Argument()    class Parser(argclass.Parser):        log_level: int = argclass.LogLevel        endpoint = AddressPortGroup(            title=&quot;Endpoint options&quot;,            defaults=dict(port=8080)        )        commit: Optional[CommitCommand] = CommitCommand()        push: Optional[PushCommand] = PushCommand()    @singledispatch    def handle_subparser(subparser: Any) -&gt; None:        raise NotImplementedError(            f&quot;Unexpected subparser type {subparser.__class__!r}&quot;        )    @handle_subparser.register(type(None))    def handle_none(_: None) -&gt; None:        Parser().print_help()        exit(2)    @handle_subparser.register(CommitCommand)    def handle_commit(subparser: CommitCommand) -&gt; None:        print(&quot;Commit command called&quot;, subparser)    @handle_subparser.register(PushCommand)    def handle_push(subparser: PushCommand) -&gt; None:        print(&quot;Push command called&quot;, subparser)    parser = Parser(        config_files=[&quot;example.ini&quot;, &quot;~/.example.ini&quot;, &quot;/etc/example.ini&quot;],        auto_env_var_prefix=&quot;EXAMPLE_&quot;    )    parser.parse_args()    handle_subparser(parser.current_subparser)Value conversion++++++++++++++++If the argument has a generic or composite type, then you must explicitlydescribe it using ``argclass.Argument``, while specifying the converterfunction with ``type`` or ``converter`` argument to transform the valueafter parsing the arguments.The exception to this rule is `Optional` with a single type. In this case,an argument without a default value will not be required,and its value can be None... code-block:: python    :name: test_converter    import argclass    from typing import Optional, Union    def converter(value: str) -&gt; Optional[Union[int, str, bool]]:        if value.lower() == &quot;none&quot;:            return None        if value.isdigit():            return int(value)        if value.lower() in (&quot;yes&quot;, &quot;true&quot;, &quot;enabled&quot;, &quot;enable&quot;, &quot;on&quot;):            return True        return False    class Parser(argclass.Parser):        gizmo: Optional[Union[int, str, bool]] = argclass.Argument(            converter=converter        )        optional: Optional[int]    parser = Parser()    parser.parse_args([&quot;--gizmo=65535&quot;])    assert parser.gizmo == 65535    parser.parse_args([&quot;--gizmo=None&quot;])    assert parser.gizmo is None    parser.parse_args([&quot;--gizmo=on&quot;])    assert parser.gizmo is True    assert parser.optional is None    parser.parse_args([&quot;--gizmo=off&quot;, &quot;--optional=10&quot;])    assert parser.gizmo is False    assert parser.optional == 10</longdescription>
</pkgmetadata>