<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># arghandler [![Build Status](https://travis-ci.org/druths/arghandler.svg?branch=master)](https://travis-ci.org/druths/arghandler) #*Making argparse even more awesome*I love [argparse](https://docs.python.org/3/library/argparse.html), but thereare some things that it simply doesn't help with as much as I'd like. Enterarghandler.The goal behind arghandler is to provide all the capabilities of argparse*plus* some high-level capabilities that crop up a lot when writingcommand-line tools: the library aims for high quality command line interfaceswith (even more) minimal code.At present, arghandler provides two key capabilities:  1. Adding subcommands with basically zero extra lines of code. This gives  support for writing programs like `git` and `svn` which have nested  subcommands.  1. Configuring the logging framework (e.g., the desired logging level) from  the command line - again with basically one line of code.We have lots more improvements we want to add - and as we have time and receivefeedback, we'll add more features.If you have ideas, [email me](mailto:druths@networkdynamics.org) or code it upand generate a pull request!## Installation ##Use `pip` or `easy_install` to install the library:pip install arghandleroreasy_install arghandlerYou can find arghandler on pypi for relevant details should you need them.## Usage ##Just like with[argparse.ArgumentParser](https://docs.python.org/3/library/argparse.html#argumentparser-objects),in `arghandler` everything revolves around `ArgumentHandler`. In fact, it's(not so secretly) a subclass of ArgumentParser, so you can use it exactly theway you use `ArgumentParser`.  But `ArgumentHandler` has some new tricks.To benefit from `ArgumentHandler`, your command-line configuration code willfollow this logic:from arghandler import ArgumentHandlerhandler = ArgumentHandler() # this accepts all args supported by ArgumentParser# config the handler using add_argument, set_logging_level, set_subcommands, etc...handler.run() # throw the configured handler at an argument string!Now for some details...### Invoking ArgumentHandler ###`ArgumentHandler` can be invoked on arguments in two ways.  *`ArgumentHandler.parse_args([argv])`* is little different from`ArgumentParser.parse_args([argv])`.  If `argv` is omitted, then the value of`sys.argv` is used. The only notable differences are:  * If a logging argument was set, then this will be included in the namespace    object returned.  * If subcommands are available, then the subcommand will be given by thevalue of `args.cmd` and the subcommand's arguments will be given by`args.cargs`.*`ArgumentHandler.run(argv,context_fxn)`* makes the class perform its moreunique and powerful capabilities.  Notably: configuring the logger and runningsubcommands.  As with `parse_args(...)`, if `argv` is not specified, then`sys.argv` will be used.  The `context_fxn` is also optional and is used aspart of subcommand processing.  See that [section](#subcommands) below for moredetails.#### Enabling autocompletion ####When constructing an `ArgumentHandler`, you can enable autocompletion.  Thisrequires doing two separate things.First, pass the keyword argument `enable_autocompetion=True` to`ArgumentHandler(...)`.Second, in the top-level script that will be your command-line tool, includethe line# PYTHON_ARGCOMPLETE_OKnear the top (in the first 1024 bytes).  For more details on this, see the[argcomplete](https://argcomplete.readthedocs.io/en/latest/) documentation.For an example of this in action, see [examples/dummy.py!](examples/dummy.py).### Setting the logging level ###If you use the python [logging](https://docs.python.org/3/library/logging.html)package, this feature will save you some time.The `ArgumentParser.set_logging_argument(...)` method allows you to specify acommand-line argument that will set the logging level.  The method acceptsseveral arguments:ArgumentParser.set_logging_argument(*names,default_level=logging.ERROR,config_fxn=None)  * `*names` stands in for one or more arguments that specify theargument names that will be used. These follow the same rules as onespassed into[ArgumentParser.add_argument(...)](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument).Moreover, they MUST be optional arguments (i.e., start with a '-'character).  * `default_level` indicates the default level the loggingframework will be set to should the level not be specified on the commandline.  * `config_fxn` allows the developer to write special loggingconfiguration code.  If not specified, the[logging.basicConfig](https://docs.python.org/3/library/logging.html#logging.basicConfig)function will be invoked with the appropriate logging level. The functionmust accept two arguments: the logging level and the namespace args objectreturned by the `ArgumentParser.parse_args` method. The configurationitself will happen when the `ArgumentHandler.run(...)` method is called.If you're cool with the defaults in `basicConfig`, then your method call willlook something like thishandler.set_logging_argument('-l','-log_level',default_level=logging.INFO)If you do want to do some customization, then your code will look like thishandler.set_logging_argument('-l','-llevel',config_fxn=lambda level,args: logging.basicConfig(level=level,format='%(message)'))### &lt;a name=&quot;subcommands&quot;&gt;&lt;/a&gt;Declaring subcommands using decorators ###This feature makes it possible to write nested commands like `git commit` and`svn checkout` with basically zero boilerplate code.  To do this `arghandler`provides the `@subcmd` decorator.  To declare a subcommand, just put thedecorator on the function  you want to act as the subcommand.from arghandler import *@subcmddef echo(parser,context,args):print ' '.join(args)# here we associate the subcommand 'foobar' with function cmd_foobar@subcmd('foobar', help = 'Does foobar')def cmd_foobar(parser,context,args):print 'foobar'handler = ArgumentHandler()handler.run(['echo','hello','world']) # echo will be called and 'hello world' will be printedNotice that the subcommands always take three arguments.`args` is the set of arguments that *follow* the subcommand on the commandline.`context` is an object that can make valuable global information available tosubcommands.  By default, the context is the namespace object returned by theinternal call to `ArgumentHandler.parse_args(...)`.  Other contexts can beproduced by passing a context-producing function to the`ArgumentHandler.run(...)` function:@subcmd('ping')def ping_server(parser,server_address,args):os.system('ping %s' % server_address)handler = ArgumentHandler()handler.add_argument('-s','--server')# when this is run, the context will be set to the return value of context_fxn# in this case, it will be the string '127.0.0.1'handler.run(['-s','127.0.0.1','ping'],context_fxn=lambda args: args.serverFinally, `parser` is an instance of `argparse.ArgumentParser` which has beenpreconfigured to behave properly for the subcommand.  Most crucially, thismeans that `parser.prog` is set to `&lt;top_level_program&gt; &lt;sub_command&gt;` so thathelp messages print out correctly for the subcommand.  Should your subcommandwant to parse arguments, this parser object should be used.### Declaring subcommands without decorators ###While decorators are the preferred way to specify subcommands, subcommands canalso be specified using the `ArgumentHandler.set_subcommands(...)` function.This method expects a dictionary: keys are command names, values are thecommand functions:from arghandler import *def echo(parser,context,args):print ' '.join(args)def cmd_foobar(parser,context,args):print 'foobar'handler = ArgumentHandler()handler.set_subcommands( {'echo':echo, 'foobar':cmd_foobar} )handler.run(['echo','hello','world']) # echo will be called and 'hello world' will be printedAll the logic and rules around the context function apply here.  Moreoever, thecomplete set of subcommands include those specified using decorators AND thosespecified through the `set_subcommands(...)` method.#### Making subcommands in subcommands ####One valuable use for the `set_subcommands(...)` method is implementingsubcommand options for a subcommand.  For example, suppose you want a program with the followingcommand subtree:```power  - create    - config    - proj  - run    - all    - proj```In this case, `create` and `run` would be top-level subcommands that could bedeclared using standard `subcmd` decorators.  But what about the `config` and`proj` commands underneath `create`?  These can be created using a new`ArgumentHandler` inside the `create` function like this:```def create_config(parser, context, args):    parser.add_argument('location')    args = parser.parse_args(args)    # do stuff    returndef create_proj(parser, context, args):    parser.add_argument('name')    args = parser.parse_args(args)    print(f'Creating the project: {args.name}')    # do stuff    return@subcmd('create', help='create a resource')def create(parser, context, args):    handler = ArgumentHandler()    handler.set_subcommands({'config': (create_config, 'create a config file'),                             'proj': (create_proj, 'create a project')                            },                            use_registered_subcmds=False)    handler.run(args)```Note the use of `use_registered_subcmds=False` - this is important to omit anyfunctions globally registered as commands using the `@subcmd` decorator.### Setting the help message ###The format of the help message can be set to one more friendly for subcommandsby passing the `ArgumentHandler` constructor the keyword argument`use_subcommand_help=True`.This will produce a help message that looks something like this:usage: test.py [-h] subcommandpositional arguments:  subcommand        cmd1  cmd1_help_stroptional arguments:    -h, --help  show this help message and exit## Some best practices ##*Use `ArgumentParser` or `ArgumentHandler` inside subcommands.* This willensure that informative help messages are available for all your subcommands.from arghandler import *@subcmddef echo(parser,context,args):parser.add_argument('-q','--quote_char',required=True)args = parser.parse_args(args)print '%s%s%s' % (args.quote_char,' '.join(args),args.quote_char)@subcmd('foobar')def cmd_foobar(parser,context,args):print 'foobar'handler = ArgumentHandler()handler.run(['echo','-h']) # the help message for echo will be printed*Use logging.* Logging gives you much more control over whatdebugging/informational content is printed out by your program. And with`arghandler` it's easier than ever to configure from the command line!</longdescription>
</pkgmetadata>