<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>This awesome code allows you to run some mind-boggling quantum stuff that you get from the Quantum Composer. It's all about playing with qubits, gates, and measurements, just like the pros do. You can do cool things like checking out the available qubits, applying gates, and even measuring the results.You won't believe it, but this code supports 100% of the examples from the IBM tutorial. Yep, every single one. And it's not just limited to that. There are tons of additional tests and examples that you can explore. The whole implementation is pretty compact too, with only 675 lines of code for the 5-qubit quantum computer simulator. Plus, there are twice as many lines dedicated to test programs and examples.To give you a taste of what you can do, check out this example. You can create a quantum computer object, write some mind-bending code in the Quantum Composer style, and execute it. In this case, we're creating a super cool GHZ state:.. code-block:: python   from amin_qvm.QuantumComputer import *   ghz_example_code = &quot;&quot;&quot;   h q[0];   h q[1];   x q[2];   cx q[1], q[2];   cx q[0], q[2];   h q[0];   h q[1];   h q[2];   &quot;&quot;&quot;   qc = QuantumComputer()   qc.execute(ghz_example_code)   Probability.pretty_print_probabilities(qc.qubits.get_quantum_register_containing(&quot;q0&quot;).get_state())And voila! It will print out the probabilities of different states. Mind-blowing, right?You can also dive deeper into the quantum realm by working with individual states and gates directly in pure Python. It's like being a quantum wizard! You can create states, apply gates, and see the magic unfold. Here's an example based on the &quot;Swap Qubits&quot; tutorial from IBM:.. code-block:: python      # Swap Qubits example IBM tutorial Section IV, Page 2   qc = QuantumComputer()   qc.apply_gate(Gate.X, &quot;q2&quot;)   qc.apply_two_qubit_gate_CNOT(&quot;q1&quot;, &quot;q2&quot;)   qc.apply_gate(Gate.H, &quot;q1&quot;)   qc.apply_gate(Gate.H, &quot;q2&quot;)   qc.apply_two_qubit_gate_CNOT(&quot;q1&quot;, &quot;q2&quot;)   qc.apply_gate(Gate.H, &quot;q1&quot;)   qc.apply_gate(Gate.H, &quot;q2&quot;)   qc.apply_two_qubit_gate_CNOT(&quot;q1&quot;, &quot;q2&quot;)   qc.measure(&quot;q1&quot;)   qc.measure(&quot;q2&quot;)   Probability.pretty_print_probabilities(qc.qubits.get_quantum_register_containing(&quot;q1&quot;).get_state())Boom! You'll witness the power of quantum computation as it prints out probabilities and states.If you're a math nerd and want to explore the mathematical side of things, you can manipulate individual states and gates using the Kronecker product. It's like playing with Lego blocks to create mind-blowing structures. Here's an example based on the same &quot;Swap Qubits&quot; tutorial:.. code-block:: python   # Swap Qubits example IBM tutorial Section IV, Page 2   q1 = State.zero_state   q2 = State.zero_state   q2 = Gate.X * q2   new_state = Gate.CNOT2_01 * np.kron(q1, q2)   H2_0 = np.kron(Gate.H, Gate.eye)   H2_1 = np.kron(Gate.eye, Gate.H)   new_state = H2_0 * new_state   new_state = H2_1 * new_state   new_state = Gate.CNOT2_01 * new_state   new_state = H2_0 * new_state   new_state = H2_1 * new_state   new_state = Gate.CNOT2_01 * new_state   Probability.pretty_print_probabilities(new_state)Prepare to have your mind blown once again as it displays probabilities and states.So, whether you're a quantum prodigy or just a curious mind, this code is perfect for unraveling the mysteries of quantum computing. Give it a whirl and explore the wonders of the quantum realm. Have fun!amin_qvm.functions Module=========================This module provides functions for quantum machine learning using Pennylane.Examples--------Training and Testing a Quantum Model~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.. code-block:: python   import numpy as np   from amin_qvm.functions import train, test      # Generate training and testing data   X_train = np.random.rand(100, 2)   Y_train = np.random.choice([-1, 1], 100)   X_test = np.random.rand(20, 2)   Y_test = np.random.choice([-1, 1], 20)      # Train the quantum model   num_qubits = 2   num_layers = 4   num_steps = 100   params = train(X_train, Y_train, num_qubits, num_layers, num_steps)      # Test the quantum model   accuracy = test(X_test, Y_test, params, num_qubits)   print(&quot;Accuracy:&quot;, accuracy)Custom Quantum Machine Learning~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.. code-block:: python   import numpy as np   from amin_qvm.functions import custom_quantum_machine_learning      # Generate custom training and testing data   X_train = np.random.rand(100, 2)   Y_train = np.random.choice([-1, 1], 100)   X_test = np.random.rand(20, 2)   Y_test = np.random.choice([-1, 1], 20)      # Perform custom quantum machine learning   num_qubits = 2   num_layers = 4   num_steps = 100   accuracy = custom_quantum_machine_learning(X_train, Y_train, X_test, Y_test, num_qubits, num_layers, num_steps)   print(&quot;Accuracy (custom):&quot;, accuracy)Grover's Search Algorithm~~~~~~~~~~~~~~~~~~~~~~~~~.. code-block:: python   from amin_qvm.functions import grover_search      # Perform Grover's search   secret_bitstring = &quot;1010&quot;   guessed_bitstring = grover_search(secret_bitstring)   print(&quot;Guessed bitstring:&quot;, guessed_bitstring)Deutsch's Algorithm~~~~~~~~~~~~~~~~~~~.. code-block:: python   # Define your own function   def my_function(x):       # Modify this function according to your requirements       return x % 2 == 0   # Example usage   result = deutsch(my_function)   print(&quot;The function is:&quot;, result)WARNING: NERDS ONLY~~~~~~~~~~~~~~~~~~~~~~~~~Normalizing Quantum States--------------------------.. image:: images/equation.png    :alt: an unnormalized quantum stateSuppose we are given an unnormalized quantum state like the one above.We can turn this into an equivalent, valid quantum state by normalizing it. This function, given alphaand beta, normalizes this state to.. image:: images/equation2.png   :alt: a normalized quantum stateSuppose we are given the inputs  alpha = 2.0 + 1.0j  beta = -0.3 + 0.4j The function should return the vector  np.array([ 0.87287156+0.43643578j, -0.13093073+0.17457431j]) which represents the qubit state.. image:: images/equation3.png   :alt: The qubit state representationHere is the code example.. code-block:: python   from amin-qvm.functions import normalize_state   import numpy as np   ket_0 = np.array([1, 0])   ket_1 = np.array([0, 1])   print(normalize_state(ket_0, ket_1))</longdescription>
</pkgmetadata>