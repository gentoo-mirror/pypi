<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># ubirch-protocol for pythonThis is an implementation of the [ubirch-protocol](https://github.com/ubirch/ubirch-protocol)for [Python 3](https://www.python.org/). Please see [ubirch-protocol](https://github.com/ubirch/ubirch-protocol)for details.The library consists of three parts which can be used individually:* `ubirch.API` - a python layer covering the ubirch backend REST API* `ubirch.Protocol` - the protocol compiler which packages messages and handles signing and verification* `ubirch.KeyStore` - a simple key store based on [pyjks](https://pypi.org/project/pyjks/) to store keys and certificates&gt; the [ubirch](https://ubirch.com) protocol uses the [Ed25519](https://ed25519.cr.yp.to/) signature scheme by default. ## UsageInstall the library: `pip install ubirch-protocol`  ### Creating keypair and messages```pythonimport ubirchfrom uuid import UUIDimport binascii# create a keystore for the device keypairkeystore = ubirch.KeyStore(&quot;demo-device.jks&quot;, &quot;keystore&quot;)# create a UUID that identifies the device and load or create a keypairuuid = UUID(hex=&quot;575A5601FD744F8EB6AEEF592CDEE12C&quot;)if not keystore.exists_signing_key(uuid):    keystore.create_ed25519_keypair(uuid)# implement the _sign method of the ubirch.Protocol to use the just created keys to sign the messageclass ProtocolImpl(ubirch.Protocol):    def _sign(self, uuid: UUID, message: bytes) -&gt; bytes:        return keystore.find_signing_key(uuid).sign(message)        # create an instance of the ubirch protocolproto = ProtocolImpl()# create ubirch protocol messagesprint(binascii.hexlify(proto.message_chained(uuid, 0x00, [1, 2, 3])))print(binascii.hexlify(proto.message_chained(uuid, 0x00, [4, 5, 6])))``` ### Sending messages using the ubirch APIPlease see [test-protocol.py](examples/test-protocol.py) for a comprehensive example, how to create a device andsend data. Below is a snipped that will send two chained messages, using a generic key/value payload.You will need a password for the ubirch backend. Go to https://console.demo.ubirch.com to register your UUID under `Things`. Then click on your device and copy the password from the `apiConfig`-field.```pythonimport ubirchfrom uuid import UUIDimport binasciifrom datetime import datetime# create a keystore for the device key pairkeystore = ubirch.KeyStore(&quot;demo-device.jks&quot;, &quot;keystore&quot;)# create a UUID that identifies the device and load or create a key pairuuid = UUID(hex=&quot;575A5601FD744F8EB6AEEF592CDEE12C&quot;)if not keystore.exists_signing_key(uuid):    keystore.create_ed25519_keypair(uuid)# implement the _sign method of the ubirch.Protocolclass ProtocolImpl(ubirch.Protocol):    def _sign(self, _uuid: UUID, message: bytes) -&gt; bytes:        return keystore.find_signing_key(uuid).sign(message)# create an instance of the ubirch protocolproto = ProtocolImpl()# create an instance of the ubirch API and set the passwordapi = ubirch.API()api.set_authentication(uuid, &quot;&lt;&lt; password for the ubirch backend &gt;&gt;&quot;)  # register your UUID at https://console.demo.ubirch.com and retrieve your password# message 1msg = proto.message_chained(uuid, 0x53, {'ts': int(datetime.utcnow().timestamp()), 'v': 99})print(binascii.hexlify(msg))# send message to ubirch backendr = api.send(uuid, msg)print(&quot;{}: {}&quot;.format(r.status_code, r.content))# message 2 (chained to message 1)msg = proto.message_chained(uuid, 0x53, {&quot;ts&quot;: int(datetime.utcnow().timestamp()), &quot;v&quot;: 100})print(binascii.hexlify(msg))# send message to ubirch backendr = api.send(uuid, msg)print(&quot;{}: {}&quot;.format(r.status_code, r.content))```### Verification of received message```pythonimport ubirchfrom ed25519 import VerifyingKey, BadSignatureErrorfrom uuid import UUIDremote_uuid = UUID(hex=&quot;9d3c78ff22f34441a5d185c636d486ff&quot;)remote_vk = VerifyingKey(&quot;a2403b92bc9add365b3cd12ff120d020647f84ea6983f98bc4c87e0f4be8cd66&quot;, encoding='hex')# create a keystore and insert the verifying keykeystore = ubirch.KeyStore(&quot;demo-device.jks&quot;, &quot;keystore&quot;)keystore.insert_ed25519_verifying_key(remote_uuid, remote_vk)# implement the _verify method of the ubirch.Protocolclass ProtocolImpl(ubirch.Protocol):    def _verify(self, uuid: UUID, message: bytes, signature: bytes) -&gt; dict:        return keystore.find_verifying_key(uuid).verify(signature, message)# create an instance of the ubirch protocolproto = ProtocolImpl()message = bytes.fromhex(    &quot;9623c4109d3c78ff22f34441a5d185c636d486ffc440a5b371acdfc8495790ee86802399585da50401b0d3c87f60946719338eb0283d36c0bac9b8a6a75a5385342e62932335da988b97c0ec211556db082e9f8478070081a76d657373616765bf796f7572207265717565737420686173206265656e207375626d6974746564c440c8529623a4c2335f7a8ae1eeea655768d2e9a0df141f481ced557c9dac7216e8f64ca9f6970fc6c1096ed49bcc6f7fa77d8f85d05bff5e1301588597edc9770e&quot;)# verify the message (throws an exception if the message could not be verified)try:    print(proto.message_verify(message))    print(&quot;verification successful!&quot;)except BadSignatureError as e:    print(&quot;ERROR: verification failed!&quot;)```### Existing keysIn case you create a key pair from our demo website, use the following code to insert it into the key store:```pythonimport ubirchimport ed25519import uuidhwDeviceId = uuid.uuid4()keystore = ubirch.KeyStore(&quot;demo-device.jks&quot;, &quot;keystore&quot;)key_encoded = input(&quot;paste the encoded private key here:&quot;)sk = ed25519.SigningKey(key_encoded, encoding='hex')vk = sk.get_verifying_key() keystore.insert_ed25519_keypair(hwDeviceId, vk, sk)```### Running the example```bashpython3 -m venv venv3. venv3/bin/activatepip install -r requirements.txtpip install ubirch-protocolPYTHONPATH=. python3 examples/test-protocol.py```At the first launch the script generates a random UUID for your device and you will be askedabout the authentication token and the device group. You can safely ignore the device group, just press Enter.The script creates a file `demo-device.ini` which is loaded upon running the script again. Ifyou need to change anything edit that file.The script goes through a number of steps:1. checks the existence of the device and deletes the device if it exists2. registers the device with the backend3. generates a new identity for that device and stores it in the key store4. registers the new identity with the backend5. sends two consecutive chained messages to the backend### TestingUnit tests are added to test the functionality of all objects provided in this library.```bashpip install -r requirements.test.txtpython3 -m pytest tests``` # License The protocol and its implementation are publicized under the [Apache License 2.0](LICENSE).</longdescription>
</pkgmetadata>