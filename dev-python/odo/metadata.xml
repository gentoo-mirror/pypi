<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Odo===|Build Status| |Doc Status|.. image:: https://binstar.org/blaze/odo/badges/build.svg   :target: https://binstar.org/blaze/odo/builds.. image:: https://binstar.org/blaze/odo/badges/version.svg   :target: https://binstar.org/blaze/odoData migration in PythonDocumentation_Example-------Odo migrates data between different containers.. code-block:: python   &gt;&gt;&gt; from odo import odo   &gt;&gt;&gt; odo((1, 2, 3), list)   [1, 2, 3]It operates on small, in-memory containers (as above) and large, out-of-corecontainers (as below).. code-block:: python   &gt;&gt;&gt; odo('myfile.hdf5::/data', 'postgresql://user:pass@host::my-table')   Table('my-table', MetaData(bind=Engine(postgresql://user:****@host)), ...)Odo leverages the existing Python ecosystem.  The example above uses``sqlalchemy`` for SQL interation and ``h5py`` for HDF5 interaction.Method------Odo migrates data using network of small data conversion functions betweentype pairs. That network is below:.. image:: https://raw.githubusercontent.com/blaze/odo/master/docs/source/images/conversions.png   :alt: odo conversionsEach node is a container type (like ``pandas.DataFrame`` or``sqlalchemy.Table``) and each directed edge is a function that transforms orappends one container into or onto another.  We annotate these functions/edgeswith relative costs.This network approach allows ``odo`` to select the shortest path between anytwo types (thank you networkx_).  For performance reasons these functions oftenleverage non-Pythonic systems like NumPy arrays or native ``CSV-&gt;SQL`` loadingfunctions.  Odo is not dependent on only Python iterators.This network approach is also robust.  When libraries go missing or runtimeerrors occur ``odo`` can work around these holes and find new paths.This network approach is extensible.  It is easy to write small functions andregister them to the overall graph.  In the following example showing how weconvert from ``pandas.DataFrame`` to a ``numpy.ndarray``... code-block:: python   from odo import convert   @convert.register(np.ndarray, pd.DataFrame, cost=1.0)   def dataframe_to_numpy(df, **kwargs):       return df.to_records(index=False)We decorate ``convert`` functions with the target and source types as well as arelative cost.  This decoration establishes a contract that the underlyingfunction must fulfill, in this case with the fast ``DataFrame.to_records``method.  Similar functions exist for ``append``, to add to existing data, and``resource`` for URI resolution.* ``convert``: Transform dataset into new container* ``append``: Add dataset onto existing container* ``resource``: Given a URI find the appropriate data resource* ``odo``: Call one of the above based on inputs.  E.g. ``odo((1, 2, 3), list) -&gt; convert(list, (1, 2, 3))``  while ``L = []; odo((1, 2, 3), L) -&gt; append(L, (1, 2, 3))``Finally, ``odo`` is also aware of which containers must reside in memory andwhich do not.  In the graph above the *red-colored* nodes are robust tolarger-than-memory datasets.  Transformations between two out-of-core datasetsoperate only on the subgraph of the red nodes.LICENSE-------New BSD. See `License File &lt;https://github.com/blaze/odo/blob/master/LICENSE.txt&gt;`__.History-------Odo was factored out from the Blaze_ project... _Blaze: http://blaze.pydata.org/.. _networkx: https://networkx.github.io/.. _Documentation: https://odo.readthedocs.org/en/latest/.. |Build Status| image:: https://travis-ci.org/blaze/odo.png   :target: https://travis-ci.org/blaze/odo.. |Doc Status| image:: https://readthedocs.org/projects/odo/badge/?version=latest   :target: https://readthedocs.org/projects/odo/?badge=latest   :alt: Documentation Status</longdescription>
</pkgmetadata>