<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Django Lineage==============Handling which navigation element is active in a particular template can becomeannoying. Template blocks can be defined and later overriden to &quot;activate&quot; aclass on a particular navigational element, **but thats gets ugly!****Lineage makes things neater** by defining your conditions centrally, and itlooks like this::  {% load lineage %}    &lt;ul&gt;      &lt;li class=&quot;{% ancestor '/home/' %}&quot;&gt;&lt;a href=&quot;/home/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;      &lt;li class=&quot;{% ancestor '/blog/' %}&quot;&gt;&lt;a href=&quot;/blog/&quot;&gt;Blog&lt;/a&gt;&lt;/li&gt;      &lt;li class=&quot;{% ancestor '/about/' %}&quot;&gt;&lt;a href=&quot;/about/&quot;&gt;About&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;When an ``ancestor`` tag is evaludated, it compares it's argument to the page URL.If the argument string matches the start of the current pages URL, it outputs&quot;active&quot;. **It's that simple!**Read on for accepted arguments:Installation------------Install using pip:    pip install django-lineageAdd ``'lineage'`` to ``INSTALLED_APPS`` in ``settings.py``::  INSTALLED_APPS = (      'lineage',  )Usage-----The ``ancestor`` tag needs to, of course, be loaded into your template:    {% load lineage %}The simplest way to use Lineage is the aformentioned ``ancestor`` tag. Again ifthe argument matches the start of the page URL it outputs &quot;active&quot;, this shouldhandle most use cases::  {% ancestor '/arbitrary/path/' %}But wait... ``ancestor`` can also handle variables, filters and all that stuff::  {% ancestor some_variable|somefilter %}Or even full blown ``url`` tag type reverse resolution (Behind the scenes the``url`` tag derives our expected argument - a URL path string.)  {% ancestor 'core:model_detail' model.pk %}Active?~~~~~~~By default ``ancestor`` outputs &quot;active&quot; if it's argument matches the start ofthe page URL. You can globally set the output of the ``ancestor`` tag by adding``LINEAGE_ANCESTOR_PHRASE = 'newphrase'`` to ``settings.py``Advanced~~~~~~~~If fine-grain control is what your after, you'll be looking for the``ifancestor/endifancestor`` combo::  {% ifancestor 'pattern_name' %}      This text here is only renderd if the      URL argument is an ancestor.  {% endifancestor %}It accepts the same exact arguments as ``ancestor``, but allows you to define,on a per definition basis, what the output will be.Assumptions-----------Lineage depends on sensible URL hierarchies, because it compares paths usingregex matching. The ``{% ifancestor '/base/' %}`` block will be true if thecurrent URL begins with that URL. For example ``/base/`` and ``/base/section/page/``return true, but ``/other/path/`` and ``/base`` (missing trailing slash) will not.``request`` must be present in the request context, since it's used to determinethe current URL. Django has `a context preprocessor`__ that can insert it foryou... _ContextProcessors: https://docs.djangoproject.com/en/dev/ref/templates/api/#django-core-context-processors-request__ ContextProcessors_</longdescription>
</pkgmetadata>