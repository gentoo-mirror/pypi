<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>dendroid========[![](https://github.com/lycantropos/dendroid/workflows/CI/badge.svg)](https://github.com/lycantropos/dendroid/actions/workflows/ci.yml &quot;Github Actions&quot;)[![](https://codecov.io/gh/lycantropos/dendroid/branch/master/graph/badge.svg)](https://codecov.io/gh/lycantropos/dendroid &quot;Codecov&quot;)[![](https://img.shields.io/github/license/lycantropos/dendroid.svg)](https://github.com/lycantropos/dendroid/blob/master/LICENSE &quot;License&quot;)[![](https://badge.fury.io/py/dendroid.svg)](https://badge.fury.io/py/dendroid &quot;PyPI&quot;)In what follows `python` is an alias for `python3.7` or `pypy3.7`or any later version (`python3.8`, `pypy3.8` and so on).Installation------------Install the latest `pip` &amp; `setuptools` packages versions```bashpython -m pip install --upgrade pip setuptools```### UserDownload and install the latest stable version from `PyPI` repository```bashpython -m pip install --upgrade dendroid```### DeveloperDownload the latest version from `GitHub` repository```bashgit clone https://github.com/lycantropos/dendroid.gitcd dendroid```Install dependencies```bashpython -m pip install -r requirements.txt```Install```bashpython setup.py install```Usage-----```python&gt;&gt;&gt; from dendroid import avl, red_black, splay&gt;&gt;&gt; from random import sample&gt;&gt;&gt; min_value, max_value = -100, 100&gt;&gt;&gt; size = (max_value - min_value) // 2&gt;&gt;&gt; values = sample(range(min_value, max_value), size)&gt;&gt;&gt; avl_set, red_black_set, splay_set = (avl.set_(*values),...                                      red_black.set_(*values),...                                      splay.set_(*values))&gt;&gt;&gt; len(avl_set) == len(red_black_set) == len(splay_set) == sizeTrue&gt;&gt;&gt; max_value not in avl_set and max_value not in red_black_set and max_value not in splay_setTrue&gt;&gt;&gt; list(avl_set) == list(red_black_set) == list(splay_set) == sorted(values)True&gt;&gt;&gt; avl_set.add(max_value)&gt;&gt;&gt; red_black_set.add(max_value)&gt;&gt;&gt; splay_set.add(max_value)&gt;&gt;&gt; len(avl_set) == len(red_black_set) == len(splay_set) == size + 1True&gt;&gt;&gt; max_value in avl_set and max_value in red_black_set and max_value in splay_setTrue&gt;&gt;&gt; list(avl_set) == list(red_black_set) == list(splay_set) == sorted(values) + [max_value]True&gt;&gt;&gt; prev_max_value = max(values)&gt;&gt;&gt; avl_set.prev(max_value) == red_black_set.prev(max_value) == splay_set.prev(max_value) == prev_max_valueTrue&gt;&gt;&gt; avl_set.next(prev_max_value) == red_black_set.next(prev_max_value) == splay_set.next(prev_max_value) == max_valueTrue&gt;&gt;&gt; avl_set.remove(max_value)&gt;&gt;&gt; red_black_set.remove(max_value)&gt;&gt;&gt; splay_set.remove(max_value)&gt;&gt;&gt; len(avl_set) == len(red_black_set) == len(splay_set) == len(values)True&gt;&gt;&gt; max_value not in avl_set and max_value not in red_black_set and max_value not in splay_setTrue&gt;&gt;&gt; list(avl_set) == list(red_black_set) == list(splay_set) == sorted(values)True&gt;&gt;&gt; avl_set.max() == red_black_set.max() == splay_set.max() == max(values)True&gt;&gt;&gt; avl_set.min() == red_black_set.min() == splay_set.min() == min(values)True&gt;&gt;&gt; avl_set.max() == red_black_set.max() == splay_set.max() == max(values)True&gt;&gt;&gt; avl_set.min() == red_black_set.min() == splay_set.min() == min(values)True&gt;&gt;&gt; avl_set.add(max_value)&gt;&gt;&gt; red_black_set.add(max_value)&gt;&gt;&gt; splay_set.add(max_value)&gt;&gt;&gt; avl_set.popmax() == red_black_set.popmax() == splay_set.popmax() == max_valueTrue&gt;&gt;&gt; avl_set.add(min_value)&gt;&gt;&gt; red_black_set.add(min_value)&gt;&gt;&gt; splay_set.add(min_value)&gt;&gt;&gt; avl_set.popmin() == red_black_set.popmin() == splay_set.popmin() == min_valueTrue&gt;&gt;&gt; min_key, max_key = min_value, max_value&gt;&gt;&gt; keys = sample(range(min_key, max_key), size)&gt;&gt;&gt; items = list(zip(keys, values))&gt;&gt;&gt; avl_map, red_black_map, splay_map = (avl.map_(*items),...                                      red_black.map_(*items),...                                      splay.map_(*items))&gt;&gt;&gt; len(avl_map) == len(red_black_map) == len(splay_map) == sizeTrue&gt;&gt;&gt; max_key not in avl_map and max_key not in red_black_map and max_key not in splay_mapTrue&gt;&gt;&gt; list(avl_map) == list(red_black_map) == list(splay_map) == sorted(keys)True&gt;&gt;&gt; avl_map[max_key] = red_black_map[max_key] = splay_map[max_key] = max_value&gt;&gt;&gt; len(avl_map) == len(red_black_map) == len(splay_map) == size + 1True&gt;&gt;&gt; max_key in avl_map and max_key in red_black_map and max_key in splay_mapTrue&gt;&gt;&gt; avl_map[max_key] == red_black_map[max_key] == splay_map[max_key] == max_valueTrue&gt;&gt;&gt; list(avl_map) == list(red_black_map) == list(splay_map) == sorted(keys) + [max_key]True&gt;&gt;&gt; prev_max_key, prev_max_value = items[max(range(size), key=keys.__getitem__)]&gt;&gt;&gt; avl_map.prev(max_key) == red_black_map.prev(max_key) == splay_map.prev(max_key) == prev_max_valueTrue&gt;&gt;&gt; avl_map.next(prev_max_key) == red_black_map.next(prev_max_key) == splay_map.next(prev_max_key) == max_valueTrue&gt;&gt;&gt; del avl_map[max_key], red_black_map[max_key], splay_map[max_key]&gt;&gt;&gt; len(avl_map) == len(red_black_map) == len(splay_map) == sizeTrue&gt;&gt;&gt; max_key not in avl_map and max_key not in red_black_map and max_key not in splay_mapTrue&gt;&gt;&gt; list(avl_map) == list(red_black_map) == list(splay_map) == sorted(keys)True&gt;&gt;&gt; avl_map.max() == red_black_map.max() == splay_map.max() == values[max(range(size), key=keys.__getitem__)]True&gt;&gt;&gt; avl_map.min() == red_black_map.min() == splay_map.min() == values[min(range(size), key=keys.__getitem__)]True&gt;&gt;&gt; avl_map[max_key] = red_black_map[max_key] = splay_map[max_key] = max_value&gt;&gt;&gt; avl_map.popmax() == red_black_map.popmax() == splay_map.popmax() == max_valueTrue&gt;&gt;&gt; avl_map[min_key] = red_black_map[min_key] = splay_map[min_key] = min_value&gt;&gt;&gt; avl_map.popmin() == red_black_map.popmin() == splay_map.popmin() == min_valueTrue```Development-----------### Bumping version#### PreparationInstall[bump2version](https://github.com/c4urself/bump2version#installation).#### Pre-releaseChoose which version number category to bump following [semverspecification](http://semver.org/).Test bumping version```bashbump2version --dry-run --verbose $CATEGORY```where `$CATEGORY` is the target version number category name, possiblevalues are `patch`/`minor`/`major`.Bump version```bashbump2version --verbose $CATEGORY```This will set version to `major.minor.patch-alpha`. #### ReleaseTest bumping version```bashbump2version --dry-run --verbose release```Bump version```bashbump2version --verbose release```This will set version to `major.minor.patch`.### Running testsInstall dependencies```bashpython -m pip install -r requirements-tests.txt```Plain```bashpytest```Inside `Docker` container:- with `CPython`  ```bash  docker-compose --file docker-compose.cpython.yml up  ```- with `PyPy`  ```bash  docker-compose --file docker-compose.pypy.yml up  ````Bash` script:- with `CPython`  ```bash  ./run-tests.sh  ```  or  ```bash  ./run-tests.sh cpython  ```- with `PyPy`  ```bash  ./run-tests.sh pypy  ````PowerShell` script:- with `CPython`  ```powershell  .\run-tests.ps1  ```  or  ```powershell  .\run-tests.ps1 cpython  ```- with `PyPy`  ```powershell  .\run-tests.ps1 pypy  ```</longdescription>
</pkgmetadata>