<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># &lt;a href=&quot;https://tatsu-lab.github.io/alpaca_eval/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tatsu-lab/alpaca_eval/main/docs/AlpacaFarm_small.png&quot; width=&quot;35&quot;&gt;&lt;/a&gt; [AlpacaEval](https://tatsu-lab.github.io/alpaca_eval/) : An Automatic Evaluator for Instruction-following Language Models[![Code License](https://img.shields.io/badge/Code%20License-Apache_2.0-green.svg)](https://github.com/tatsu-lab/alpaca_farm/blob/main/LICENSE)[![Data License](https://img.shields.io/badge/Data%20License-CC%20By%20NC%204.0-red.svg)](https://github.com/tatsu-lab/alpaca_farm/blob/main/DATA_LICENSE)[![Python 3.10+](https://img.shields.io/badge/python-3.10+-blue.svg)](https://www.python.org/downloads/release/python-3100/)[![discord](https://img.shields.io/badge/discord-server-blue?logo=discord&amp;logoColor=white)](https://discord.gg/GJMxJSVZZM)Evaluation of instruction-following models (e.g., ChatGPT) typically requires human interactions. This istime-consuming, expensive, and hard to replicate. AlpacaEval in an LLM-based automatic evaluation that is fast, cheap,replicable, and validated against 20K human annotations.It is particularly useful for model development.Although we improved over prior automatic evaluation pipelines, there are still fundamental [limitations](#limitations) like the preference for longer outputs.AlpacaEval provides the following:- [**Leaderboard**](https://tatsu-lab.github.io/alpaca_eval/): a leaderboard of common models on the AlpacaEval  evaluation set. **Caution**: Automatic evaluator (e.g. GPT4) may be biased towards models that generate longer outputs and/or that were fine-tuned on the model underlying the evaluator (e.g. GPT4).- [**Automatic evaluator**](#evaluators): an automatic evaluator that has high agreement with humans (validated on 20K  annotations). We evaluate a  model by  measuring the fraction of times an powerful LLM (e.g. GPT 4 or Claude or ChatGPT) prefers the outputs from that model  over  outputs from a reference model. Our evaluators enable caching and output randomization by default.- [**Toolkit for building automatic evaluators**](#analysis): a simple interface for  building advanced automatic evaluators (e.g. with caching, batching, or multi-annotators) and analyzing them (quality,  price, speed, statistical power, bias, variance etc).- [**Human evaluation data**](#data-release): 20K human preferences between a given and reference model  on the [AlpacaFarm](https://github.com/tatsu-lab/alpaca_farm/tree/main)  evaluation set. 2.5K of these are cross-annotations (4 humans annotating the same 650 examples).- [**AlpacaEval dataset**](https://huggingface.co/datasets/tatsu-lab/alpaca_eval/blob/main/alpaca_eval.json): a simplification  of [AlpacaFarm's](https://github.com/tatsu-lab/alpaca_farm/tree/main) evaluation set, where &quot;instructions&quot; and &quot;  inputs&quot; are merged  into one field, and reference outputs are longer. [Details here](#data-release).**When to use AlpacaEval?** Our automatic evaluator is a quick and cheap proxy for human evaluation of simpleinstruction-following tasks.It is useful if youhave to run many evaluations quickly, e.g., during model development.**When not to use AlpacaEval?**As any other automatic evaluator, AlpacaEval should **not replace human evaluation inhigh-stake decision-making**, e.g., to decide on model release. In particular, AlpacaEval is limited by the factthat (1) the instructions in the eval set might not be representative of advanced usage of LLMs; (2) automaticevaluators may have biases such as favoring style overfactuality of the answer; and (3) AlpacaEval does not measure the risks that a model could cause.Details in [limitations](#limitations).&lt;details open&gt;  &lt;summary&gt;&lt;b&gt;Table of Contents&lt;/b&gt;&lt;/summary&gt;1. [Quick Start](#quick-start)2. [Leaderboards and how to interpret them](#leaderboards-and-how-to-interpret-them)    - [Models](#models)    - [Evaluators](#evaluators)3. [Use-cases](#use-cases)    - [Evaluating a model](#evaluating-a-model)    - [Making a new leaderboard](#making-a-new-leaderboard)    - [Making a new evaluator](#making-a-new-evaluator)4. [Analysis](#additional-analysis-and-plots)    - [Analyzing an evaluator](#analyzing-an-evaluator)    - [Analyzing an eval set](#analyzing-an-eval-set)5. [Contributing](#contributing)    - [Contributing a model](#contributing-a-model)    - [Contributing an evaluator](#contributing-an-evaluator)    - [Contributing an eval set](#contributing-an-eval-set)    - [Contributing a completion function](#contributing-a-completion-function)6. [Limitations](#limitations)7. [Citation](#citation)8. [Additional information](#additional-information)    - [Data Release](#data-release)    - [Differences with AlpacaFarm](#differences-with-alpacafarm)    - [Related work](#related-work)    - [Major updates](#major-updates)&lt;/details&gt;# Quick StartTo install the stable release, run```bashpip install alpaca-eval```To install the nightly version, run```bashpip install git+https://github.com/tatsu-lab/alpaca_eval```Then you can use it as follows:```bashexport OPENAI_API_KEY=&lt;your_api_key&gt;export OPENAI_ORGANIZATION_IDS=&lt;your_organization_id&gt;  # Optional; if not set, this will be your default org id.alpaca_eval --model_outputs 'example/outputs.json' ```This will print the leaderboard to the console, and save both the leaderboard and the annotations to the same directory as the `model_outputs` file. Important parameters are the following:- **model_outputs** : A path to a json file for the outputs of the model to add to the leaderboard. Each dictionary  should  contain the keys `instruction` and `output`.- **annotators_config**: This is the annotator to use (e.g., `alpaca_eval_gpt4` or `claude`  or `chatgpt_fn`). `alpaca_eval_gpt4` (  default) has the  highest agreement rate with our human annotation data. `claude` has a decent agreement and is free for  academics. `chatgpt_fn` is the worst of the three, but is available to everyone, cheap, and has 2x larger context  window (16K tokens). For a comparison of annotators see [here](#evaluators).- **reference_outputs**:  The outputs of the reference model. Same format as `model_outputs`. By default, this  is `text-davinci003` outputs on  AlpacaEval dataset.- **output_path**: Path for saving annotations and leaderboard.If you don't have the model outputs, you canuse [`evaluate_from_model`](https://github.com/tatsu-lab/alpaca_eval/tree/main#evaluating-a-model) andpass a local path or a name of aHuggingFacemodel, or a model from a standard API (OpenAI, Anthropic, Cohere). Other commands:&lt;details open&gt;  &lt;summary&gt;&lt;code&gt;&gt;&gt;&gt; alpaca_eval -- --help&lt;/code&gt;&lt;/summary&gt;```SYNOPSIS    alpaca_eval COMMANDCOMMANDS    COMMAND is one of the following:     evaluate       Evaluate a model based on its outputs. This is the default entrypoint if no command is specified.     evaluate_from_model       Evaluate a model from HuggingFace or an API provider. This is a wrapper around `evaluate` which includes generating from a desired model.     make_leaderboard       Precompute and save an entire leaderboard for a given dataset / evaluator / set of models generations.     analyze_evaluators       Analyze an evaluator (agreement with human, speed, price,...).```&lt;/details&gt;For more information about each function use `alpaca_eval &lt;command&gt; -- --help`.# Leaderboards and how to interpret them## ModelsOur leaderboards are computed on the [AlpacaEval dataset](https://huggingface.co/datasets/tatsu-lab/alpaca_eval).We precomputed the leaderboard for important models using `alpaca_eval_gpt4` (best quality),  `claude` (free foracademics, and high quality), and `chatgpt_fn` (cheap and available for everyone). Our full leaderboards can be foundat [on this page](https://tatsu-lab.github.io/alpaca_eval/), butwe give minimal leaderboards below.Later we also show how to [add your model](https://github.com/tatsu-lab/alpaca_eval#evaluating-a-model) to theleaderboard and how to makea [new leaderboard for your evaluator/dataset](https://github.com/tatsu-lab/alpaca_eval#making-a-new-leaderboard).See [here](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/models_configs) for the configs of allmodels that are available out of the box.**`alpaca_eval_gpt4` minimal leaderboard**:|                       | Win Rate | Std Error ||:----------------------|---------:|----------:|| gpt4                  |     95.3 |       0.7 || claude                |     88.4 |       1.1 || chatgpt               |     86.1 |       1.2 || wizardlm-13b          |     75.3 |       1.5 || guanaco-65b           |     71.8 |       1.6 || vicuna-13b            |     70.4 |       1.6 || oasst-rlhf-llama-33b  |     66.5 |       1.7 || text_davinci_003      |     50.0 |       0.0 || falcon-40b-instruct   |     45.7 |       1.8 || alpaca-farm-ppo-human |     41.2 |       1.7 || alpaca-7b             |     26.5 |       1.5 || text_davinci_001      |     15.2 |       1.2 |&lt;details&gt;  &lt;summary&gt;&lt;b&gt;How exactly are those metrics computed?&lt;/b&gt;&lt;/summary&gt;**Win Rate**: the win rate measures the fraction of time the model's output is preferred over text-davinci-003 outputs (i.e. the reference).More specifically, to compute the win rate we collect pairs of outputs of the desired model on every instruction fromtheApacaEval dataset.We then pair each output with the output of our reference model (`text-davinci-003`) on the same instruction.We then ask our automatic evaluator which output they prefer.See [here](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/evaluators_configs/alpaca_eval_gpt4)and [here](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/evaluators_configs/claude) for the exactprompts and configs for GPT4 and Claude, in particular we randomize the order ofoutputs to avoid position bias.We then average the preferences over all instructions in the dataset to get the win rate of the model overtext-davinci-003.If both outputs are exactly the same we use a half preference for both models.**Standard error**: this is the standard error (normalized by N-1) of the win rate, i.e., the preferences averaged overthe different instructions.[//]: # (The standard error measures the uncertainty over instructions and sampling from the evaluator.)&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;b&gt;Details about &lt;code&gt;alpaca_eval_gpt4&lt;/code&gt;&lt;/b&gt;&lt;/summary&gt;Our `alpaca_eval_gpt4` (see [configs](#https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/evaluators_configs/alpaca_eval_gpt4/configs.yaml#L5))annotator averages over preferences, where preferences are obtained as follows:1. it takes in an instruction and a pair of outputs (from the desired model and the reference model)2. if a preference was this triple was already computed, it returns it (i.e. it uses caching)3. it randomizes the order of the outputs to avoid position bias4. it formats the instruction and outputs into   the [following zero-shot prompt](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/evaluators_configs/alpaca_eval_gpt4/alpaca_eval.txt),   which asks to order the outputs in order of preference5. it completes the prompt using GPT4 with `temperature=0`6. it parses the preference from the completions and returns itThe annotator is a mix between (and was highly influenced by) [AlpacaFarm](https://github.com/tatsu-lab/alpaca_farm)and [Aviary](https://github.com/ray-project/aviary/tree/master) evaluators.In particular, we use the same code as for AlpacaFarm (caching/randomization/hyperparameters) but use a ranking promptsimilar to that of Aviary.We make changes to Aviary's prompt to decrease the bias for longer outputs.Details in [Related work](#related-work).&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;b&gt;&lt;code&gt;claude&lt;/code&gt; minimal leaderboard&lt;/b&gt;&lt;/summary&gt;|                       | Win Rate | Std Error ||:----------------------|---------:|----------:|| gpt4                  |     77.0 |       1.5 || claude                |     75.8 |       1.5 || chatgpt               |     67.7 |       1.6 || wizardlm-13b          |     66.1 |       1.7 || vicuna-13b            |     63.2 |       1.7 || guanaco-65b           |     62.6 |       1.7 || oasst-rlhf-llama-33b  |     57.3 |       1.7 || text_davinci_003      |     50.0 |       0.0 || falcon-40b-instruct   |     46.7 |       1.8 || alpaca-farm-ppo-human |     46.5 |       1.8 || alpaca-7b             |     32.3 |       1.6 || text_davinci_001      |     21.5 |       1.4 |&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;b&gt;&lt;code&gt;chatgpt_fn&lt;/code&gt; minimal leaderboard&lt;/b&gt;&lt;/summary&gt;|                       | Win Rate | Std Err. ||:----------------------|---------:|---------:|| gpt4                  |     73.8 |      1.5 || claude                |     70.4 |      1.6 || chatgpt               |     66.1 |      1.7 || wizardlm-13b          |     65.2 |      1.7 || vicuna-13b            |     64.1 |      1.7 || guanaco-65b           |     62.4 |      1.7 || oasst-rlhf-llama-33b  |     62.0 |      1.7 || alpaca-farm-ppo-human |     60.2 |      1.7 || falcon-40b-instruct   |     56.5 |      1.7 || text_davinci_003      |     50.0 |      0.0 || alpaca-7b             |     45.2 |      1.7 || text_davinci_001      |     28.1 |      1.6 |&lt;/details&gt;## EvaluatorsWe evaluate different automatic annotators on the AlpacaEval set by comparing to2.5K [human annotations](https://huggingface.co/datasets/tatsu-lab/alpaca_eval/blob/main/alpaca_farm_human_crossannotations.json)we collected (~650 instructions each with 4 human annotations).Below we show metrics for our suggested evaluator (`alpaca_eval_gpt4`), for priorautomaticevaluators ([`alpaca_farm_greedy_gpt4`](https://github.com/tatsu-lab/alpaca_farm),[`aviary_gpt4`](https://aviary.anyscale.com/),[`lmsys_gpt4`](https://chat.lmsys.org/)),for humans (`humans`), and for different base models with essentially the sameprompt (`gpt4`,`claude`,`text_davinci_003`,`chatgpt_fn`,`guanaco_33b`, `chatgpt`).See [here](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/evaluators_configs) for the configs of allevaluators that are available out of the box and their associated metrics.|                         | Human agreement [%] | Price [$/1000 examples] | Time [seconds/1000 examples] | Bias | Variance | Proba. prefer longer ||:------------------------|--------------------:|------------------------:|-----------------------------:|-----:|---------:|--------------------:|| alpaca_eval_gpt4_fn     |                71.0 |                    14.5 |                         5046 | 27.6 |     11.1 |  0.75 || alpaca_eval_gpt4        |                69.2 |                    13.6 |                         1455 | 28.4 |     14.6 |                 0.68 || aviary_gpt4             |                69.1 |                    12.8 |                         1869 | 29.5 |     13.1 |                 0.70 || gpt4                    |                66.9 |                    12.5 |                         1037 | 31.5 |     14.6 |                 0.65 || alpaca_farm_greedy_gpt4 |                66.4 |                    15.3 |                          878 | 30.2 |     19.3 |                 0.60 || humans                  |                65.7 |                   300.0 |                        36800 |  0.0 |     34.3 |                 0.64 || claude                  |                65.5 |                    11.1 |                          173 | 31.9 |     18.0 |                 0.62 || text_davinci_003        |                64.1 |                     8.7 |                          121 | 33.8 |     22.7 |                 0.70 || lmsys_gpt4              |                63.2 |                    13.9 |                        17982 | 34.7 |     16.1 |                 0.74 || chatgpt_fn              |                60.0 |                     1.0 |                          530 | 36.9 |     27.7 |                 0.62 || chatgpt                 |                57.2 |                     0.8 |                          285 | 39.4 |     34.1 |                 0.59 |&lt;details&gt;  &lt;summary&gt;&lt;b&gt;How exactly are those metrics computed?&lt;/b&gt;&lt;/summary&gt;We now explain in words how we compute the metrics in the tableabove. [The code is here](https://github.com/tatsu-lab/alpaca_eval/blob/f05cbd651b79ac93906b19d01fe443b45828b0f2/src/alpaca_eval/analyze.py#L366).**Human agreement [%]**: this measures the agreement between the current annotator and the majority preferences ofhumans onour~650 annotations fromour [cross-annotation set](https://huggingface.co/datasets/tatsu-lab/alpaca_eval/blob/main/alpaca_farm_human_crossannotations.json),which contains 4 human annotations per example.To estimate the agreement between a single human (`humans` row in the table above) and the majority of humans, we takeone of the 4 annotations and compute the accuracy that it has when predicting the mode of the other 3 annotations.We then average this accuracy over all 4 annotations and over the 650 instructions to get the human agreement, i.e., wecompute the expected (over humans and samples)leave-one-out agreement.If the mode is not unique, we take one of the modes at random.We perform exactly the same computation for the automatic annotators, so that the final numbers are comparable.[//]: # ($$agreement = E[E_i[I[z_i == mode&amp;#40;{z^*_j}_{j \neq i}&amp;#41;]]]$$)**Price [$/1000 examples]**: this is the average price of every 1000 annotations.For humans, it is the price that [we paid Mechanical Turkers](https://arxiv.org/abs/2305.14387) to collect thoseannotations ($18/hour).If the price depends on the machine used to compute the annotations (e.g. Guanaco) we leave it empty.**Time [seconds/1000 examples]**: this is the average time it takes to compute 1000 annotations.For humans, it is the estimated median time that each Mechanical Turker took to annotate 1000 examples.For automatic annotators, it is the average time that it took us when running the annotations. Note that this can dependon API limits that are different for different users and the number of requests that the clusters areprocessing.**Bias**: agreement between the most likely human label and the most likely automatic one.For automatic annotators we estimate it by sampling 4 different annotations for each example.The randomness here comes from the order of the outputs in the prompt, sampling from the LLM, and if applicable theorder of the instruction in the batch and the choice of annotator in the pool.We then take the mode of the 4 annotations and compute the accuracy of the mode when predicting the mode of the 4 humanannotations.Note that this is likely an overestimate on the real bias that we would get if we had an &quot;infinite&quot; number ofcross-annotations.A low bias means that the annotator has in expectation the same preferences as humans.For the case of humans, the bias is zero by definition.Note that this is related to but not the standard statistical bias, because we take the mode instead of average overannotations and we consider 0-1 loss instead of squared loss.[//]: # ($$agreement = 1 - E[E_i[I[mode&amp;#40;{z_j}_{j \neq i} == mode&amp;#40;{z^*_j}_{j \neq i}&amp;#41;]]]$$)**Variance**: expected agreement a single automatic preference and the most likely one.We estimate it the same way as we estimated &quot;human agreement&quot; for humans, i.e., we take the expected leave one out errorwhen predicting the mode of the 3 annotations using the 4th annotation.A low variance means that the annotator is consistent with its preference, i.e., if you sample from it with differentseeds it will give the same result.As with the bias, this is not exactly the standard statistical variance, because we take the mode instead of averageover annotations and weconsider 0-1 loss instead of squared loss.Note that the &quot;human agreement&quot; is tightly related to the bias and variance. In particular, the variancemeasures the error due to the fact that we only use a single annotation while the bias aims to measure the irreducibleerrorfor the current annotator.[//]: # (More specifically we have that `agreement ≈ &amp;#40;1 - bias&amp;#41;*&amp;#40;1 - variance&amp;#41; + bias*variance`.)[//]: # (Where the first term measures the agreement due to having no errors from bias and variance, while the second term)[//]: # (measures the accuracy due to having errors caused from both the bias and variance.)[//]: # ($$agreement = 1 - E[E_i[I[z_i == mode&amp;#40;{z_j}_{j \neq i}&amp;#41;]]]$$)**Proba. prefer longer**: this is the probability that the annotator prefers the longer output when one of the twooutputs is significantly longer than the other (more than 30 characters difference).In the [full table](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/evaluators_configs/README.md) wealso provide the following metrics:**Proba. prefer lists**: this is the probability that the annotator prefers the output that contains a list/bulletpoints when one output does but not the other.**Proba. prefer 1**: this is the probability that the annotator prefers the first of the pair of outputs. All ourproposed annotators randomize over outputs in the prompt, so this should be 0.5. Prior annotators, such as `lmsys`and `aviary`, do not.**# parsed**: this is the number of examples that the annotator was able to parse.Note that if the variance and bias is empty, it means that we only performed one single annotation for each 648 exampledue to resource (time and price) constraints. This explains why the #parsed is 648, otherwise it should be 2592.&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;b&gt;Tips for choosing evaluators&lt;/b&gt;&lt;/summary&gt;Overall we recommend using `annotators_config=alpaca_eval_gpt4` if you want the highest agreement with humans,`annotators_config=claude` if you have academic (free) access to Claude and have a low budget, and`annotators_config=chatgpt_fn` if you don't have access to the other two models.When choosing an annotator we recommend you to consider the following (the first three are obvious):- `&quot;Human agreement [%]&quot;`- `&quot;Price [$/1000 examples]&quot;`- `&quot;Time [seconds/1000 examples]&quot;`- `&quot;Proba. prefer longer&quot;` approx. &lt; 0.7. Indeed, we found see that the majority of preference of human annotators have  strong bias for longer answers (as shown by the  high [performance=62.2](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/evaluators_configs/README.md)  of  the `&quot;longest&quot;` evaluator that always  prefers the longest output). This suggests that it might more of a bias with the human annotators. In order to avoid  having leaderboards with strong biases for length, we suggest using automatic annotators with less than 0.7 &quot;Proba.  prefer longer&quot;.- `&quot;Variance&quot;` approx. &lt; 0.2. We believe that a good evaluator should have as little variance as possible so that  results are mostly reproducible. Note that variance can be desirable in the case where we are simulating humans  as shown in [AlpacaFarm](https://arxiv.org/abs/2305.14387).We filtered the annotators that do not satisfy those requirements in the table above (besides humans / ChatGPT / 003 /lmsys forreference purposes). Forallresults see [here](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/evaluators_configs/README.md).In general, we found `alpaca_eval_gpt4` to be a good trade-off between quality / price / time /variance / length bias.&lt;/details&gt;The above metrics are computed with respect to annotations from crowd-workers. Although useful, those annotations arenot perfect, e.g., crowd-workers often favor styleoverfactuality. We thus recommend users to validate automatic evaluators on their own instructions and human annotations.Details in [limitations](#limitations).# Use-cases[//]: # ()[//]: # (&lt;details&gt;)[//]: # ()[//]: # (  &lt;summary&gt;&lt;b&gt;Installation from source &amp;#40;optional&amp;#41;&lt;/b&gt;&lt;/b&gt;&lt;/summary&gt;)[//]: # ()[//]: # (If you make changes to the configurations files or code, it might be easier to install `alpaca_eval` from source.)[//]: # (If so follow the following steps:)[//]: # ()[//]: # (1. clone the repository)[//]: # ()[//]: # (2. install as dev the package: `pip install -e .`)[//]: # ()[//]: # (3. &amp;#40;optional&amp;#41; export)[//]: # ()[//]: # (   all [API_KEYs]&amp;#40;https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/constants.py#L7&amp;#41;)[//]: # ()[//]: # (4. test your installation &amp;#40;assuming you have OpenAI)[//]: # ()[//]: # (   key&amp;#41; `alpaca_eval --model_outputs 'example/outputs.json' --annotators_config 'text_davinci_003' ~~--max_instances 3~~ --caching_path None`)[//]: # ()[//]: # (&lt;/details&gt;)## Evaluating a model&lt;details&gt;  &lt;summary&gt;&lt;code&gt;&gt;&gt;&gt; alpaca_eval evaluate -- --help&lt;/code&gt;&lt;/summary&gt;```NAME    alpaca_eval evaluate - Evaluate a model based on its outputs. This is the default entrypoint if no command is specified.SYNOPSIS    alpaca_eval evaluate &lt;flags&gt;DESCRIPTION    Evaluate a model based on its outputs. This is the default entrypoint if no command is specified.FLAGS    --model_outputs=MODEL_OUTPUTS        Type: Optional[Union]        Default: None        The outputs of the model to add to the leaderboard. Accepts data (list of dictionary, pd.dataframe, datasets.Dataset) or a path to read those (json, csv, tsv) or a function to generate those. Each dictionary (or row of dataframe) should contain the keys that are formatted in the prompts. E.g. by default `instruction` and `output` with optional `input`. If None, we just print the leaderboard.    -r, --reference_outputs=REFERENCE_OUTPUTS        Type: Union        Defaul...        The outputs of the reference model. Same format as `model_outputs`. If None, the reference outputs are the 003 outputs on the AlpacaEval set.    --annotators_config=ANNOTATORS_CONFIG        Type: Union        Default: 'alpaca_eval_gpt4'        The path the (or list of dict of) the annotator's config file. For details see the docstring of `PairwiseAnnotator`.    -n, --name=NAME        Type: Optional[Optional]        Default: None        The name of the model to add to the leaderboard. If None we check if `generator is in model_outputs` if not we use &quot;Current model&quot;.    -o, --output_path=OUTPUT_PATH        Type: Union        Default: 'auto'        Path to the directory where the new leaderboard and the annotations should be stored. If None we don't save. If `auto` we use `model_outputs` if it is a path, and otherwise use the directory from which we call the script.    -p, --precomputed_leaderboard=PRECOMPUTED_LEADERBOARD        Type: Union        Default: 'auto'        The precomputed leaderboard or a path to it (json, csv, or tsv). The leaderboard should contain at least the column `win_rate`. If `auto` we will try to use the corresponding leaderboard for the reference outputs (only if in CORRESPONDING_OUTPUTS_LEADERBOARDS). If `None` we won't add other models from the leaderboard.    --is_overwrite_leaderboard=IS_OVERWRITE_LEADERBOARD        Type: bool        Default: False        Whether to overwrite the leaderboard if the model is already in it.    -l, --leaderboard_mode_to_print=LEADERBOARD_MODE_TO_PRINT        Type: Optional        Default: 'minimal'        The mode of the leaderboard to use. Only used if the precomputed leaderboard has a column `mode`, in which case it will filter the leaderboard by this mode. If None keeps all.    -c, --current_leaderboard_mode=CURRENT_LEADERBOARD_MODE        Type: str        Default: 'community'        The mode of the leaderboard for the current method.    --is_return_instead_of_print=IS_RETURN_INSTEAD_OF_PRINT        Type: bool        Default: False        Whether to return the metrics instead of printing the results.    -f, --fn_metric=FN_METRIC        Type: Union        Default: 'pairwise_to_winrate'        The function or function name in `metrics.py` that will be used to convert preference to metrics. The function should take a sequence of preferences (0 for draw, 1 for base win, 2 when the model to compare wins) and return a dictionary of metrics and the key by which to sort the leaderboard.    -s, --sort_by=SORT_BY        Type: str        Default: 'win_rate'        The key by which to sort the leaderboard.    --is_cache_leaderboard=IS_CACHE_LEADERBOARD        Type: Optional        Default: None        Whether to save the result leaderboard to `precomputed_leaderboard`. If None we save only if max_instances. A preferred way of adding models to the leaderboard is to set `precomputed_leaderboard` to the previously savedleaderboard at `&lt;output_path&gt;/leaderboard.csv`.    --max_instances=MAX_INSTANCES        Type: Optional[Optional]        Default: None        The maximum number of instances to annotate. Useful for testing.    --annotation_kwargs=ANNOTATION_KWARGS        Type: Optional[Optional]        Default: None        Additional arguments to pass to `PairwiseAnnotator.annotate_head2head`.    Additional flags are accepted.        Additional arguments to pass to `PairwiseAnnotator`.```&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;code&gt;&gt;&gt;&gt; alpaca_eval evaluate_from_model -- --help&lt;/code&gt;&lt;/summary&gt;```NAME    alpaca_eval evaluate_from_model - Evaluate a model from HuggingFace or an API provider. This is a wrapper around `evaluate` which includes generating from a desired model.SYNOPSIS    alpaca_eval evaluate_from_model MODEL_CONFIGS &lt;flags&gt;DESCRIPTION    Evaluate a model from HuggingFace or an API provider. This is a wrapper around `evaluate` which includes generating from a desired model.POSITIONAL ARGUMENTS    MODEL_CONFIGS        Type: Union        A dictionary or path (relative to `models_configs`) to a yaml file containing the configuration of the model to decode from. If a directory,we search for 'configs.yaml' in it. The keys in the first dictionary should be the generator's name, and the value should be a dictionary of the generator's configuration which should have theFLAGS    -r, --reference_model_configs=REFERENCE_MODEL_CONFIGS        Type: Optional[Union]        Default: None        Same as in `model_configs` but for the reference model. If None, we use the same model as the one we are    -e, --evaluation_dataset=EVALUATION_DATASET        Type: Union        Defaul...        Path to the evaluation dataset or a function that returns a dataframe. If None, we use the default evaluation    -a, --annotators_config=ANNOTATORS_CONFIG        Type: Union        Default: 'alpaca_eval_gpt4'        Path to the annotators configuration or a dictionary. If None, we use the default annotators configuration.    -o, --output_path=OUTPUT_PATH        Type: Union        Default: 'auto'        Path to save the generations, annotations and leaderboard. If auto saves at `results/&lt;model_name&gt;`    -m, --max_instances=MAX_INSTANCES        Type: Optional[int]        Default: None        Maximum number of instances to generate and evaluate. If None, we evaluate all instances.    -i, --is_strip_output=IS_STRIP_OUTPUT        Type: bool        Default: True        Whether to strip trailing and leading whitespaces from the outputs.    Additional flags are accepted.        Other kwargs to `evaluate`NOTES    You can also use flags syntax for POSITIONAL ARGUMENTS```&lt;/details&gt;To evaluate a model you need to:1. Choose an evaluation set and compute outputs specified as `model_outputs`. By default, we use   the 805 examples from [AlpacaEval](#data-release). To compute outputs on AlpacaEval use:```pythonimport datasetseval_set = datasets.load_dataset(&quot;tatsu-lab/alpaca_eval&quot;, &quot;alpaca_eval&quot;)[&quot;eval&quot;]for example in eval_set:    # generate here is a placeholder for your models generations    example[&quot;output&quot;] = generate(example[&quot;instruction&quot;])```if your model is a HuggingFace model or from a standard API provider (OpenAI, Anthropic, Cohere). Then you candirectly use `alpaca_eval evaluate_from_model` to also take care of generating outputs.2. Compute the reference outputs `reference_outputs`. By default, we use the outputs of `text-davinci-003` on   AlpacaEval.   If you   want to use a different model or a different dataset follow the same steps as (1.).3. Choose an evaluator specified via `annotators_config`. We recommend using `alpaca_eval_gpt4` or `claude` (if you are   an   academic) or `chatgpt_fn` (if you don't have access to the other two). For options and comparisons   see [this table](#evaluators). Depending on the evaluator you might need to   set the appropriate API_KEY in your environment   or [here](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/constants.py#L7).Running all together:```bashalpaca_eval --model_outputs 'example/outputs.json' \  --annotators_config 'alpaca_eval_gpt4' \  --reference_outputs &lt;path to outputs if not text_davinci_003 on AlpacaEval&gt;```If you don't have decoded outputs, you can use `evaluate_from_model` which takes care of decoding (model and reference)for you.Here's anexample:```bash# need a GPU for local modelsexport ANTHROPIC_API_KEY=&lt;your_api_key&gt; # let's annotate with claudealpaca_eval evaluate_from_model \  --model_configs 'oasst_pythia_12b' \  --annotators_config 'claude' \  --reference_model_configs &lt;path to configs not text_davinci_003 on AlpacaEval&gt;        ```Here the `model_configs` and `reference_model_configs` (optional) are paths to a directory that specifies the prompt,the modelprovider (here HuggingFace) and decoding parameters.See [this directory](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/models_configs) for examples.For all model providers that are available out-of-the-boxsee [here](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/decoders).&lt;details&gt;  &lt;summary&gt;&lt;b&gt;Information about annotators&lt;/b&gt;&lt;/b&gt;&lt;/summary&gt;- **Caching**: by default all annotations are cached on  disk at `caching_path`. Annotations are thus never recomputed, which makes annotations faster, cheaper and allow for  reproducibility. This helps even when evaluating different models as many models  have  the same outputs.- **Output randomization** by default, we randomize over the examples of outputs, as we found that annotators tend to  prefer the first examples  they see.- **Batching** we provide code and examples to batch annotations, which decreases cost and time for annotations if the  prompt is long. See for  example [alpaca_farm_greedy_gpt4](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/evaluators_configs/alpaca_farm_greedy_gpt4).- **Pool of annotators** we provide code and examples to evaluate using a pool of automatic annotators, which is helpful  for replicating the variance of [human annotations](https://arxiv.org/abs/2305.14387). See for  example [alpaca_farm](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/evaluators_configs/alpaca_farm).- **Seeding based on instructions** For reproducibility and more fair comparison between models, we seed all  randomness (output order, order in batches,  examples for each annotator in a pool) based on the instruction.&lt;/details&gt;## Making a new leaderboard&lt;details&gt;  &lt;summary&gt;&lt;code&gt;&gt;&gt;&gt; alpaca_eval make_leaderboard -- --help&lt;/code&gt;&lt;/summary&gt;```NAME    alpaca_eval make_leaderboard - Precompute and save an entire leaderboard for a given dataset / evaluator / set of models generations.SYNOPSIS    alpaca_eval make_leaderboard LEADERBOARD_PATH &lt;flags&gt;DESCRIPTION    Precompute and save an entire leaderboard for a given dataset / evaluator / set of models generations.POSITIONAL ARGUMENTS    LEADERBOARD_PATH        Type: Union        The path to save the leaderboard to. The leaderboard will be saved as a csv file, if it already exists it willFLAGS    --annotators_config=ANNOTATORS_CONFIG        Type: Union        Default: 'alpaca_eval_gpt4'        The path the (or list of dict of) the annotator's config file.    --all_model_outputs=ALL_MODEL_OUTPUTS        Type: Union        Default: &lt;fu...        The outputs of all models to add to the leaderboard. Accepts data (list of dictionary, pd.dataframe, datasets.Dataset) or a path to read those (json, csv, tsv potentially with globbing) or a function to generate those. If the path contains a globbing pattern, we will read all files matching the pattern and concatenate them. Each dictionary (or row of dataframe) should contain the keys that are formatted in the prompts. E.g. by default `instruction` and `output` with optional `input`. It should also contain a column `generator` with the name of the currentmodel.    -r, --reference_outputs=REFERENCE_OUTPUTS        Type: Union        Defaul...        The outputs of the reference model. Same format as `all_model_outputs` but without needing `generator`. By default, the reference outputs are the 003 outputs on AlpacaEval set.    -f, --fn_add_to_leaderboard=FN_ADD_TO_LEADERBOARD        Type: Callable        Default: 'evaluate'        The function to use to add a model to the leaderboard. If a string, it should be the name of a function in `main.py`. The function should take the arguments: `model_outputs`, `annotators_config`, `name`, `precomputed_leaderboard`, `is_return_instead_of_print`, `reference_outputs`.    -i, --is_return_instead_of_print=IS_RETURN_INSTEAD_OF_PRINT        Type: bool        Default: False        Whether to return the metrics instead of printing the results.    Additional flags are accepted.        Additional arguments to pass to `fn_add_to_leaderboard`.NOTES    You can also use flags syntax for POSITIONAL ARGUMENTS```&lt;/details&gt;If you want to make a new leaderboard using a single command (rather than multiple `alpaca_eval` calls), for yourdesired evaluationset and evaluators, you can use the following:```bashalpaca_eval make_leaderboard \  --leaderboard_path &lt;path_to_save_leaderboard&gt; \  --all_model_outputs &lt;model_outputs_path&gt; \  --reference_outputs &lt;reference_outputs_path&gt; \  --annotators_config &lt;path_to_config.yaml&gt;```where:- `leaderboard_path`: path to save the leaderboard to. The leaderboard will be saved as a csv file, if it already exists  it will append.- `all_model_outputs` : The json path to the outputs of all models to add to the leaderboard (as a single file or by  globbing multiple files). Each dictionary should contain  the keys (`instruction` and `output`) that are formatted in the prompts and a column `generator` with the name of the  current model. As an example  see [this file](https://huggingface.co/datasets/tatsu-lab/alpaca_eval/blob/main/alpaca_eval_all_outputs.json).- `reference_outputs` the path to the outputs of the reference model. Each dictionary should contain  the keys (`instruction` and `output`) that are formatted in the prompts. By  default, the reference outputs are the 003 outputs on AlpacaEval set.- `annotators_config`: The path to the annotator's config file. Defaults to `alpaca_eval_gpt4`.## Making a new evaluator&lt;details&gt;  &lt;summary&gt;&lt;code&gt;&gt;&gt;&gt; alpaca_eval analyze_evaluators -- --help&lt;/code&gt;&lt;/summary&gt;```NAME    alpaca_eval analyze_evaluators - Analyze an evaluator and populates the evaluators leaderboard (agreement with human, speed, price,...).SYNOPSIS    alpaca_eval analyze_evaluators &lt;flags&gt;DESCRIPTION    Analyze an evaluator (agreement with human, speed, price,...).FLAGS    --annotators_config=ANNOTATORS_CONFIG        Type: Union        Default: 'alpaca_eval_gpt4'        The path the (or list of dict of) the annotator's config file.    -A, --Annotator=ANNOTATOR        Default: &lt;class 'alpaca_eval.annotators.pairwise_evaluator.PairwiseAn...        The annotator class to use.    --analyzer_kwargs=ANALYZER_KWARGS        Type: Optional[]        Default: None        Additional arguments to pass to the analyzer.    -p, --precomputed_leaderboard=PRECOMPUTED_LEADERBOARD        Type: Union        Default: PosixPath('/Users/yanndubois/Desktop/GitHub/alpaca_eval/src/...        The precomputed (meta)leaderboard of annotators or a path to it (json, csv, or tsv).    --is_save_leaderboard=IS_SAVE_LEADERBOARD        Type: bool        Default: False        Whether to save the leaderboard (ie analyzed results).    --is_return_instead_of_print=IS_RETURN_INSTEAD_OF_PRINT        Type: bool        Default: False        Whether to return the leaderboard (ie analyzed results). If True, it will not print the results.    --is_overwrite_leaderboard=IS_OVERWRITE_LEADERBOARD        Type: bool        Default: False        Whether to overwrite the leaderboard if it already exists.    -m, --max_instances=MAX_INSTANCES        Type: Optional[Optional]        Default: None        The maximum number of instances to analyze.    --is_single_annotator=IS_SINGLE_ANNOTATOR        Type: bool        Default: False        Whether to analyze a single annotator. If True, will not be able to estimate the annotator's bias.```&lt;/details&gt;AlpacaEval provides a simple way of making new evaluators. All you need is to make a new `configs.yaml` configurationfile, which you will then passas `--annotators_config &lt;path_to_config.yaml&gt;` to `alpaca_eval`.Here are some ways you can make a new evaluator:- **Changing the prompt**: Write a new prompt in a text file and specify the path in `prompt_template` of the  configuration file. Paths are relative to the configuration file.- **Changing decoding parameters**: Specify the desired parameters in `completions_kwargs` in the configuration file. To  see all available parameters refer to the docstrings of the corresponding  function [in this file](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/decoders/__init__.py)  specified by `fn_completions`  in the configuration file.- **Changing the model**: Specify the desired model in `model_name` and the corresponding  prompt in `prompt_template`. If the model comes from another provider you  will  have  to change `fn_completions` which maps to the corresponding function  in [this file](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/decoders/__init__.py). We  provide `fn_completions` functions to use models from OpenAI, Anthropic, Cohere, or HuggingFace. To  install packages needed for  all providers  use `pip install alpaca_eval[all]`.[//]: # (- **Using multiple annotators**: Specify a list of annotators in `annotators_config` in the configuration file. For an)[//]: # (  example)[//]: # (  see [alpaca_farm configuration]&amp;#40;https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/evaluators_configs/alpaca_farm/configs.yaml&amp;#41;.)&lt;details&gt;  &lt;summary&gt;&lt;b&gt;Other parameters in the configuration file&lt;/b&gt;&lt;/b&gt;&lt;/summary&gt;The easiest is to check the docstringsof [`SinglePairwiseAnnotator`](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/annotators/pairwise_evaluator.py#L537).Here are some important ones:```Parameters----------prompt_template : path    A prompt that will be given to `fn_prompter` or path to the prompts. Path is relative to    `evaluators_configs/`fn_completion_parser : callable or str    Function in `completion_parsers.py` to use for parsing the completions into preferences. For each completion,    the number of preferences should be equal to the batch_size if not we set all the preferences in that batch to    NaN.completion_parser_kwargs : dict    Kwargs for fn_completion_parser.fn_completions : callable or str    Function in `decoders.py` to use for decoding the output.completions_kwargs : dict    kwargs for fn_completions. E.g. model_name, max_tokens, temperature, top_p, top_k, stop_seq.is_randomize_output_order : bool    Whether to randomize output_1, output_2 when formatting.batch_size : int    Number of examples that will be added in a single prompt.```&lt;/details&gt;Once you made the evaluator you can also analyze it and add it to the _evaluator's_ [leaderboard](#evaluators) using thefollowing command:```bashalpaca_eval analyze_evaluators --annotators_config '&lt;path_to_config.yaml&gt;'    ```To estimate the bias and variance this evaluates every example with 4 seeds, i.e., 2.5Kevaluation.If you want a cheaper evaluation you can use a single seed using `--is_single_annotator True` which will skip theestimation of bias and variance.# Additional analysis and plotsAlpacaEval provides a few visualization tools to help you analyze and improve your automatic evaluation pipeline. Webriefly explainthem here and providenotebooks for more analysis.For a description of all the metrics we considerrefer to [How exactly are those metrics computed?](https://github.com/tatsu-lab/alpaca_eval#evaluators)## Analyzing an evaluator**Analyzing evaluators:**[![analyzing an evaluator](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tatsu-lab/alpaca_eval/blob/main/notebooks/analyzing_annotators.ipynb)As we saw in [the evaluator's leaderboard](#evaluators), there are many metrics to consider when selecting an evaluator,e.g. the quality, price, and speed. To assist with selection of the evaluator we provide a few functions to plot thosemetrics.The following shows for example the price/time/agreement of the different evaluators.![plot_quality_vs_price_and_time.png](figures%2Fplot_quality_vs_price_and_time.png)Here we see that `alpaca_eval_gpt4` performs very well and is better than humans on all the considered metrics.Previously we only considered the agreement with human annotators overall.An additional validation that one could do is checking whether making a leaderboard using ourautomatic annotator gives similar results as a leaderboard from humans.To enable such analysis, we release [humanannotations](#data-release) of outputs from 22 methods from [AlpacaFarm](https://github.com/tatsu-lab/alpaca_farm) =&gt;22*805 = ~18K annotations. As a result wecantestthe correlation between the win-rates of the 22 models as evaluated by the humans and our automatic annotator.Note that this is arguably a better way of selecting an automatic evaluator than using &quot;human agreement [%]&quot; but isexpensive given that it requires 18Kannotations.The plot below shows such correlation for the `alpaca_eval_gpt4` evaluator.&lt;p float=&quot;left&quot; align=&quot;middle&quot;&gt;&lt;img src=&quot;figures/plot_winrate_correlations_alpaca_eval.png&quot; alt=&quot;Correlation between humans and alpaca_eval_gpt4&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;We see that the `alpaca_eval_gpt4` leaderboard is highly correlated (0.94 Pearson correlation) to the leaderboard fromhumans, which furthersuggests that automatic evaluation is a good proxy for human evaluation.For the code and more analysis,see [this notebook](https://github.com/tatsu-lab/alpaca_eval/blob/main/notebooks/analyzing_annotators.ipynb), or thecolab notebook above.## Analyzing an eval set**Making evaluation sets:**[![analyzing an evaluator](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tatsu-lab/alpaca_eval/blob/main/notebooks/analyzing_evalset.ipynb)When creating an evaluation set there are two main factors to consider: how much data to use? and what data?One way of answering those question is by considering a leaderboard of models that you believe are of differentquality and checking what and how much data is needed to distinguish between them in a statistically significant way.We will do so below using a paired t-test to test if the difference in win-rates between every pair of modelsisstatistically significant.First, let us consider the question of how much data to use.Below we show the number of random samples needed from AlpacaEval for the paired t-test to give a p-value &lt; 0.05 foreach pair of models in the minimal `alpaca_eval_gpt4`leaderboard.Grey cells correspond to pairs that are not significantly different on the 805 samples.y- and x-axis are ordered by the win-rate of the first and second model respectively.[//]: # (![plot_paired_ttest_nsamples.png]&amp;#40;figures%2Fplot_paired_ttest_nsamples.png&amp;#41;)&lt;p float=&quot;left&quot; align=&quot;middle&quot;&gt;&lt;img src=&quot;figures/plot_paired_ttest_nsamples.png&quot; alt=&quot;Number of samples needed to distinguish pairs in the Claude leaderboard&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;We see that most models can already be distinguished with 50 samples, and that 150 samples allows distinguishing themajority of pairs (74 out of 78). This suggests that we can decrease the evaluation set size by a factor of4 when testing two models that have similar performance gaps as those on theminimal `alpaca_eval_gpt4` [leaderboard](#models).The second question is what data to use. Again we can try to answer this question from a statistical power perspective:what data allows to best distinguish between models. Let's consider this for all the datasets that are part ofAlpacaEval, but let us control for the size of the evaluation sets as we only care about the quality of the data. Thefollowing plot shows the p-values from the paired t-test of each pairs of models on 80 examples of each subset ofAlpacaEval.![plot_paired_ttests_per_dataset.png](figures%2Fplot_paired_ttests_per_dataset.png)We see for example that the self-instruct dataset yields the least statistical power, which suggests that one couldremove this dataset from the evaluation set.The exact reason should be analyzed in future work.For the code and more analysissee [this notebook](https://github.com/tatsu-lab/alpaca_eval/blob/main/notebooks/analyzing_evalset.ipynb), or thecolab notebook above.# ContributingWe are accepting PRs for new models, evaluators, and eval sets, in addition to bug fixes.We will update the [leaderboard website](https://tatsu-lab.github.io/alpaca_eval/) regularly with new communitycontributions.We have also created a [support discord](https://discord.gg/GJMxJSVZZM) for AlpacaEval in case you run into any issuesandwish to ask help from the community.To get started, please first fork the repo, and install the package from source `pip install -e .`&lt;details&gt;  &lt;summary&gt;&lt;h2 tabindex=&quot;-1&quot; dir=&quot;auto&quot;&gt;Contributing a model&lt;/h2&gt;&lt;/summary&gt;First, you'll need to add a model config definition in the [models_configs](src/alpaca_eval/models_configs/) folder. Asan example, you can look atthe [falcon-7b-instruct yaml](src/alpaca_eval/models_configs/falcon-7b-instruct/configs.yaml). Please make sure thefolder name and key name in the yaml match exactly.Then, please follow the steps in [Evaluating a model](#evaluating-a-model) to run inference on the model to produceoutputs on the eval set and score the model according to one of the evaluators.An example command may look like:```shalpaca_eval evaluate_from_model \  --model_configs 'falcon-7b-instruct' \  --annotators_config 'alpaca_eval_gpt4'```After running this command, you should have generated an outputs json and a new entry in the corresponding [leaderboardfile](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/leaderboards/data_AlpacaEval). Please make a PRwith theconfig, outputs file, and updated leaderboard.Concretely you should do something like:1. Fork the repository in github2. Clone the forked repository `git clone &lt;URL&gt;`3. Make a model config at `src/alpaca_eval/models_configs/&lt;model_name&gt;` and evaluate it `evaluate_from_model --model_configs '&lt;model_name&gt;'`4. Add the model configs, output, and leaderboard entry to the forked repository```shgit add src/alpaca_eval/models_configs/&lt;model_name&gt;git add src/alpaca_eval/leaderboards/data_AlpacaEvalgit add results/&lt;model_name&gt;/model_outputs.jsongit add results/&lt;model_name&gt;/annotations.jsongit commit -m &quot;Add &lt;model_name&gt; to AlpacaEval&quot;git push``` 5. Create a [pull request on AlpacaEval](https://github.com/tatsu-lab/alpaca_eval/pulls)&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;h2 tabindex=&quot;-1&quot; dir=&quot;auto&quot;&gt;Contributing an evaluator&lt;/h2&gt;&lt;/summary&gt;Please first follow the directions in [Making a new evaluator](#making-a-new-evaluator).Once you're created the annotator config, we ask that you create a new leaderboard for the annotator by evaluating theminimal set of models. The outputs for these models can be found bydownloading [alpaca_eval_all_outputs.json](https://huggingface.co/datasets/tatsu-lab/alpaca_eval/blob/main/alpaca_eval_all_outputs.json).```bashalpaca_eval make_leaderboard \  --leaderboard_path src/alpaca_eval/leaderboards/data_AlpacaEval/&lt;evaluator&gt;_leaderboard.csv \  --all_model_outputs alpaca_eval_all_outputs.json \  --annotators_config &lt;evaluator_config&gt;```Then, please create a PR with the annotator config and leaderboard csv.&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;h2 tabindex=&quot;-1&quot; dir=&quot;auto&quot;&gt;Contributing an eval set&lt;/h2&gt;&lt;/summary&gt;To contribute a new eval set, you'll first need to specify a set of textual instructions.Then, you'll need to specify a set of reference outputs (model win-rates are computed against this reference).For ease of use, you may use the default [text-davinci-003](src/alpaca_eval/models_configs/text_davinci_003/) referenceconfig.Place these together into a json, where each entry specifies the fields `instruction`, `output`, and `generator`. Youcan look to [alpaca_eval.json](https://huggingface.co/datasets/tatsu-lab/alpaca_eval/blob/main/alpaca_eval.json) as aguide (the `dataset` field is not necessary).Finally, we ask that you create a minimal leaderboard on this new evaluation set. You can do this with the following:```bashalpaca_eval make_leaderboard \  --leaderboard_path &lt;src/alpaca_eval/leaderboards/data_AlpacaEval/your_leaderboard_name.csv&gt; \  --all_model_outputs alpaca_eval_all_outputs.json \  --reference_outputs &lt;path_to_json_file&gt;```Please submit a PR with the eval set json and corresponding leaderboard csv.&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;h2 tabindex=&quot;-1&quot; dir=&quot;auto&quot;&gt;Contributing a completion function&lt;/h2&gt;&lt;/summary&gt;Currently, we allow different completion functions, e.g., `openai`, `anthropic`, `huggingface_local`, `huggingface_hub_api` ... If you want to contribute a new completion function / API with which to perform inference then follow those steps:1. add a file &lt;name&gt;.py with a function  `&lt;name&gt;_completions(prompts : Sequence[str], model_name :str, ... )`  in the [decoder folder](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/decoders). This function should take as argument the prompts + kwargs and return the completions. Please look at other completion functions in the directory for templates. E.g. [huggingface_local_completions](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/decoders/huggingface_local.py) or [anthropic](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/decoders/anthropic.py).2. add `&lt;name&gt;_completions` and dependencies in [__init__](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/decoders/__init__.py) . Again you can follow the example of [huggingface_local_completions](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/decoders/__init__.py#L30)3. update optional dependencies in [setup.py](https://github.com/tatsu-lab/alpaca_eval/blob/main/setup.py)4. add a model you want to evaluate in the [models configs](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/models_configs)5. evaluate your model using `alpaca_eval evaluate_from_model --model_configs '&lt;model_configs&gt;'`6. (optional) push the results from the previous model on AlpacaEval leaderboard following [those steps](https://github.com/tatsu-lab/alpaca_eval/tree/main#contributing-a-model)Feel free to start a PR early, we'll be able to provide some help in the process! &lt;/details&gt;# LimitationsThe AlpacaEval evaluation pipeline, like other current evaluators have important limitations and should therefore not beused as replacement for human evaluation in important settings, such as to decide whether a model is ready to bedeployed.Those can broadly be clustered into 3 categories:1. **Instructions might not be representative of real-usage**:  the AlpacaEval set contains examples from a variety of   datasets ([self-instruct](https://github.com/yizhongw/self-instruct),   [open-assistant](https://huggingface.co/datasets/OpenAssistant/oasst1/viewer/OpenAssistant--oasst1/validation), [vicuna](https://lmsys.org/blog/2023-03-30-vicuna/), [koala](https://github.com/arnav-gudibande/koala-test-set), [hh-rlhf](https://huggingface.co/datasets/Anthropic/hh-rlhf/viewer/Anthropic--hh-rlhf/test))   which might not be representative of real-usage and advanced applications of better models like GPT4. This likely makes the best closed models (GPT4 / Claude / ChatGPT / ...) seem more similar to the open models than what they are. Indeed, those closed models seem to be pretrained/finetuned on much more diverse data. See for   example [this blog](https://medium.com/@marcotcr/exploring-chatgpt-vs-open-source-models-on-slightly-harder-tasks-aa0395c31610)   for preliminary results on more complex instructions.   Note, however, that in [AlpacaFarm](https://arxiv.org/abs/2305.14387) we showed that win-rates on our evaluation set   are highly correlated (0.97 R2) with win-rates on instructions from user interactions with the Alpaca Demo.   Furthermore, the AlpacaEval leaderboard shows larger   gap between the open models and OpenAI models than other leaderboards (   e.g. [lmsys](https://lmsys.org/blog/2023-03-30-vicuna/)).2. **Biases of automatic annotators**: the automatic annotators seem to have implicit biases. In particular, we found   that they tend to prefer longer outputs and outputs that contain lists (e.g. 0.68 / 0.69 for `alpaca_eval_gpt4`   and 0.62 / 0.58 for `claude`).   Although we found that humans have similar biases (0.64 / 0.61), we believe that this could be more of a limitation   of human annotation pipeline we used rather than a true human bias. More generally, through qualitative analysis, we   found that automatic annotators give more importance to the style   of the output than its content (e.g. factuality).   Finally, we found that automatic evaluators tend to prefer outputs from models that are similar (likely trained on   the same data) as suggested by the big difference between ChatGPT/GPT4 on `claude`'s and `alpaca_eval_gpt4`'s   leaderboard.3. **Lack of safety evaluation**: importantly, AlpacaEval only evaluates the instruction-following capabilities of   models rather than the harm that they could cause (e.g. toxic behavior or bias). As a result the small gap between   current ChatGPT and the best open source models **should not** be interpreted as if that the latter are ready to be   deployed.Beyond those limitations about the evaluation pipelines, there are also limitations about our validation of theevaluators and our [proposed approach](#analyzing-an-eval-set) to selecting evaluation sets.&lt;details&gt;  &lt;summary&gt;&lt;b&gt;Limitations about our validation pipeline&lt;/b&gt;&lt;/b&gt;&lt;/summary&gt;First, our validation of evaluators based on human cross-annotations suffers from the following limitations: (1) wequalitatively found that our crowd-workers tend to also favor style such as length and presence of lists overfactuality;(2) this does not validate whether win-rates against a reference model is a good evaluation strategy in the first place;(3) preferences from 16 crowd-workers are not representative of preferences of all humans.Second, our suggested approach to selecting evaluation sets based on statistical power suffers from the followinglimitations: (1) statistical power does not ensure the right direction, e.g. you can have an unnatural set ofinstructions where Alpaca &quot;performs&quot; better than better model; and(2) this can push users to select data to support the hypothesis that they want to validate.&lt;/details&gt;# CitationPlease consider citing the repo if you used the automatic annotators, code, or results.```@misc{alpaca_eval,  author = {Xuechen Li and Tianyi Zhang and Yann Dubois and Rohan Taori and Ishaan Gulrajani and Carlos Guestrin and Percy Liang and Tatsunori B. Hashimoto },  title = {AlpacaEval: An Automatic Evaluator of Instruction-following Models},  year = {2023},  publisher = {GitHub},  journal = {GitHub repository},  howpublished = {\url{https://github.com/tatsu-lab/alpaca_eval}}}```If you used our human annotation data, please also consider citing the [AlpacaFarm](https://arxiv.org/abs/2305.14387)paper:```@misc{dubois2023alpacafarm,  title={AlpacaFarm: A Simulation Framework for Methods that Learn from Human Feedback},   author={Yann Dubois and Xuechen Li and Rohan Taori and Tianyi Zhang and Ishaan Gulrajani and Jimmy Ba and Carlos Guestrin and Percy Liang and Tatsunori B. Hashimoto},  year={2023},  eprint={2305.14387},  archivePrefix={arXiv},  primaryClass={cs.LG}}```If you use the AlpacaEval evaluation set, please cite each of the constituentdatasets: [self-instruct](https://github.com/yizhongw/self-instruct),[open-assistant](https://huggingface.co/datasets/OpenAssistant/oasst1/viewer/OpenAssistant--oasst1/validation), [vicuna](https://lmsys.org/blog/2023-03-30-vicuna/), [koala](https://github.com/arnav-gudibande/koala-test-set), [hh-rlhf](https://huggingface.co/datasets/Anthropic/hh-rlhf/viewer/Anthropic--hh-rlhf/test).# More information&lt;details&gt;  &lt;summary&gt;&lt;h2 tabindex=&quot;-1&quot; dir=&quot;auto&quot;&gt;Data Release&lt;/h2&gt;&lt;/summary&gt;As part of AlpacaEval, we release the following data:- **Human annotations (17701)** in order to develop and understand automatic evaluators, we release all the human  pairwise  evaluation that we collected for AlpacaFarm. This contains comparisons between 22 models with the `text-davinci-003`  reference on the AlpacaFarm evaluation set. Annotations are from a pool of 16 crowd workers on Amazon Mechanical Turk.  The different models are: 6 from OpenAI, 2 SFT models from AlpacaFarm, 13 RLHF methods from AlpacaFarm, and LLaMA 7B.- **Human cross-annotations (2596)** in order to further analyze automatic evaluators we selected (via stratified  sampling  across models and datasets) 650 examples from the AlpacaFarm evaluation set and collected 4 human annotations per  example.- **AlpacaEval set (805)** we made slight modifications/simplification of the AlpacaFarm evaluation set. In particular,  we first merged  the instruction and input fields into a single instruction field. This affects 1/4 of the examples in the AlpacaFarm  evaluation set, all of which are from the [self-instruct evaluation set](https://arxiv.org/abs/2212.10560). Second we  regenerated the text-davinci-003 reference outputs without limiting the length of its outputs.For more details about the human annotations refer to the [AlpacaFarm paper](https://arxiv.org/abs/2305.14387).&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;h2 tabindex=&quot;-1&quot; dir=&quot;auto&quot;&gt;Differences with AlpacaFarm&lt;/h2&gt;&lt;/summary&gt;AlpacaEval is an improvement and simplification of the automatic pairwise preference simulatorfrom [AlpacaFarm](https://github.com/tatsu-lab/alpaca_farm).Outside AlpacaFarm, you should be using AlpacaEval.Here are the main differences:- **AlpacaEval merges instructions and inputs**: The AlpacaEval evaluation is the same as the AlpacaFarm evaluation  except that the instruction and input fields are merged as `{instruction}\n\n{input}`. This affects 1/4 of the  examples in the AlpacaFarm evaluation set (the [self-instruct](https://arxiv.org/abs/2212.10560) subset).  This simplification provides a more fair comparison for models that were not trained by distinguishing between  the two fields.- **AlpacaEval handles longer generations**: Models in AlpacaFarm were limited to a maximum number of 300 tokens for  generations. We  change this number to 2000 for AlpacaEval. Note that this also affects the reference generations (`text-davinci-003`),  so the results on AlpacaEval are not comparable to those on AlpacaFarm even for examples that had no input  field.- **AlpacaEval removes intra- and inter-annotator variance**: The AlpacaFarm simulator replicates human annotation in  terms of both mode behavior and diversity.  In particular, AlpacaFarm's simulator uses a pool of models and prompts and adds noise to replicate human intra- and  inter-annotator variance.  If the goal is to use an automatic annotator for evaluation or simply training better models, then this variance  may not be desirable. The default annotators in AlpacaEval thus don't have this variance. We give the option to add it  back by  using `--anotators_config 'alpaca_farm'` and `--p_label_flip 0.25` when creating an evaluator.[//]: # (- **Different goals** The goal of AlpacaEval is to provide a package for fast, reproducible,cheap, and)[//]: # (  high-quality automatic evaluation of instruction-following models. As a secondary goal, we also provide simple toolkit for developing new evaluators. The goal of AlpacaFarm was to provide a simulator for studying the human-based RLHF pipeline.)&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;h2 tabindex=&quot;-1&quot; dir=&quot;auto&quot;&gt;Related work&lt;/h2&gt;&lt;/summary&gt;There have been several work that propose new automatic annotators for instruction-following models. Here we list theones that we are aware of and discuss how they differ from ours. We evaluated all of thosein [our evaluator's leaderboard](https://github.com/tatsu-lab/alpaca_eval#evaluators).- **Vicuna/lmsys** The lmsys annotator (`lmsys_gpt4`) evaluates the pair by asking the annotator a score from 1-10 for  each output, and then selecting the output with the highest score as preferred. They do not randomize over output  order and they ask an explanation _after_ the score. Overall, we found that this annotator has strong bias towards  longer outputs (0.74) and relatively low correlation with human annotations (63.2).- **AlpacaFarm** The best AlpacaFarm annotator (`alpaca_farm_greedy_gpt4`) evaluates the pair by directly asking the  annotator  which output it prefers. Furthermore, it batches 5 examples together to amortize the length of the prompt and  randomizes the order of outputs. Overall, we  found that this annotator has much less bias towards longer outputs (0.60) and is faster (878 seconds/1000 examples)  than others. It has a  slightly higher correlation with the majority of human annotations (66.4) than humans themselves (65.7).  However, it is more expensive ($15.3/1000 examples) and doesn't work with very long outputs given the batching.- **Aviary** The Aviary annotator (`aviary_gpt4`) asks the annotator to order the output by its preference, rather than  simply selecting the preferred output. It does not randomize the order of outputs and uses high temperature for  decoding (0.9). Overall, we found that this annotator has relatively strong bias towards longer outputs (0.70) and  very high  correlation with human annotations (69.1). By decreasing the temperature and randomizing the order of outputs,  we [further improved](https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/evaluators_configs/README.md)  the correlation to 69.8 (`improved_aviary_gpt4`) but this further increased the length bias to 0.73.Our `alpaca_eval_gpt4` is a mix between the AlpacaFarm and Aviary annotators. It asks the annotator to order the outputsby preference, but it uses temperature 0, randomizes over outputs, and made some modifications to the prompt to decreaselength bias to 0.68.Other related work include recent papers which analyze automatic evaluators.For example:- [AlpacaFarm Appx C](https://arxiv.org/abs/2305.14387)  and [Large Language Models are not Fair Evaluators](https://arxiv.org/abs/2305.17926v1) both found that automatic  annotators have  a position bias.- [AlpacaFarm Sec. 5.2.](https://arxiv.org/abs/2305.14387)  and [The False Promise of Imitating Proprietary LLMs](https://arxiv.org/abs/2305.15717) both found that  automatic  annotators favor style (e.g. use of list, tone, word choice, length) over factuality.&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;h2 tabindex=&quot;-1&quot; dir=&quot;auto&quot;&gt;Major updates&lt;/h2&gt;&lt;/summary&gt;- 19th June 2023: add leaderboard `chatgpt_fn` that anyone can use (no waiting lists).- 19th June 2023: update to  use [OpenAI's function calling](https://openai.com/blog/function-calling-and-other-api-updates).  Example: [`chatgpt_fn`](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/evaluators_configs/chatgpt_fn)  or [`alpaca_eval_gpt4_fn`](https://github.com/tatsu-lab/alpaca_eval/tree/main/src/alpaca_eval/evaluators_configs/alpaca_eval_gpt4_fn).&lt;/details&gt;</longdescription>
</pkgmetadata>