<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># JSON-Schema CodegenThis python library consumes JSON-Schema and generates C++ or Python code.  It generates structures to hold the values defined in the schema, restricting the values according to the schema. ## Python Requirements for Code GenerationThese requirements should be satisfied when `pip3` installing `json-schema-codegen`.* python 3.7* jinja2* stringcase## Installation```shpip3 install json-schema-codegen```## C++ Generated Code### Supported Schema Features in C++ code generationA C++ class is generated for each schema node according to the schema's `type` property.  Schemas without a `type` property, with the exception of combining operators `*Of`, are not supported.* type: string    * minLength    * maxLength    * pattern    * format=date-time (enforces ISO8601 format)    * format=uuid (enables string object to be populated with a uuid)* type: string with enum* type: integer    * maximum    * minimum    * exclusiveMaximum    * exclusiveMinimum    * multipleOf* type: number    * maximum    * minimum    * exclusiveMaximum    * exclusiveMinimum    * multipleOf * type: boolean* type: null* type: array    * items    * minItems    * maxItems* type: object    * properties    * required* allOf* anyOf* oneOf##### References`$ref` references are supported for array items, object properties, allOf, anyOf, and oneOf.  However, the caller must provide a &quot;resolver&quot; class which translates the reference into a class name and namespace. ### Dependencies of the C++ generated code* boost (boost::optional and boost::variant among others)* rapidjson 1.1* C++11### UsageSee [example_usage.py](./examples/example_usage.py) for a more elaborate example on generating C++ code.```pyimport jsonschemacodegen.cpp as cppsimpleResolver = cpp.SimpleResolver()output_dir = &quot;/tmp&quot;generator = cpp.GeneratorFromSchema(src_output_dir=output_dir,    header_output_dir=output_dir,     resolver=simpleResolver,    namespace=[],    src_usings=[])sampleSchema = {&quot;type&quot;: &quot;string&quot;}generator.Generate(sampleSchema, 'Example', 'example')```## Python Generated CodeA Python3 class is generated for each schema node; the class encapsulating the data described by the schema.  The class accepts in its constructor python primative data types that match the format described the the schema.  Each class has a `Serializable` method which returns data in a format that can be serialized.JSON (de-)serialization does not happen in the actual class.  This allows for flexibility to use other line-formats, for example, YAML.### Supported schema features for generating Python code* type: string    * minLength    * maxLength    * pattern    * enum* type: integer    * maximum    * minimum    * exclusiveMaximum    * exclusiveMinimum    * multipleOf    * enum* type: number    * maximum    * minimum    * exclusiveMaximum    * exclusiveMinimum    * multipleOf     * enum* type: boolean* type: null* type: array    * items    * minItems    * maxItems* type: object    * properties    * required* allOf* anyOf* oneOf    * Component schemas with the `title` property.### Example usage for generating Python codeFor a more elaborate example, see [example_python.py](./examples/example_python.py)```pyfrom jsonschemacodegen import python as pygenimport jsonwith open('schema.json') as fp:    generator = pygen.GeneratorFromSchema('output_dir')    generator.Generate(json.load(fp), 'Example', 'example')```This example will create the file `output_dir/example.py` containing the Python3 class `Example` and nested classes as required.Using the generated code looks like this:```pyimport exampleimport jsonjsonText = '[&quot;an example string in an array&quot;]'obj = example.Example(json.loads(jsonText))print(json.dumps(obj, default=lambda x: x.Serializable()))```## LicenseGPLv2</longdescription>
</pkgmetadata>