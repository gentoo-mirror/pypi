<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![version](https://img.shields.io/pypi/v/django-stdimage.svg)](https://pypi.python.org/pypi/django-stdimage/)[![codecov](https://codecov.io/gh/codingjoe/django-stdimage/branch/master/graph/badge.svg)](https://codecov.io/gh/codingjoe/django-stdimage)[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)# Django Standardized Image FieldThis package has been deprecated in favor of [django-pictures][django-pictures].## Migration InstructionsFirst, make sure you understand the differences between the two packages andhow to serve images in a modern web application via the [picture][picture-tag]-Element.Next, follow the setup instructions for [django-pictures][django-pictures].Once you are set up, change your models to use the new `PictureField` and provide the `aspect_ratios` you'd like to serve. Do create migrations just yet.This step should be followed by changing your templates and frontend.The new placeholders feature for local development should help youto do this almost effortlessly.Finally, run `makemigrations` and replace the `AlterField` operation with`AlterPictureField`.We highly recommend to use Django's `image_width` and `image_height` fields, to avoidunnecessary IO. If you can add these fields to your model, you can use the followingsnippet to populate them:```pythonimport django.core.files.storagefrom django.db import migrations, modelsimport pictures.modelsfrom pictures.migrations import AlterPictureFielddef forward(apps, schema_editor):    for obj in apps.get_model(&quot;my-app.MyModel&quot;).objects.all().iterator():        obj.image_width = obj.logo.width        obj.image_height = obj.logo.height        obj.save(update_fields=[&quot;image_height&quot;, &quot;image_width&quot;])def backward(apps, schema_editor):    apps.get_model(&quot;my-app.MyModel&quot;).objects.all().update(        image_width=None,        image_height=None,    )class Migration(migrations.Migration):    dependencies = [        ('my-app', '0001_initial'),    ]    operations = [        migrations.AddField(            model_name=&quot;mymodel&quot;,            name=&quot;image_height&quot;,            field=models.PositiveIntegerField(editable=False, null=True),        ),        migrations.AddField(            model_name=&quot;mymodel&quot;,            name=&quot;image_width&quot;,            field=models.PositiveIntegerField(editable=False, null=True),        ),        migrations.RunPython(forward, backward),        AlterPictureField(            model_name=&quot;mymodel&quot;,            name=&quot;image&quot;,            field=pictures.models.PictureField(                aspect_ratios=[&quot;3/2&quot;, &quot;3/1&quot;],                breakpoints={&quot;desktop&quot;: 1024, &quot;mobile&quot;: 576},                container_width=1200,                file_types=[&quot;WEBP&quot;],                grid_columns=12,                height_field=&quot;image_height&quot;,                pixel_densities=[1, 2],                storage=django.core.files.storage.FileSystemStorage(),                upload_to=&quot;pictures/&quot;,                verbose_name=&quot;image&quot;,                width_field=&quot;image_width&quot;,            ),        ),    ]```[django-pictures]: https://github.com/codingjoe/django-pictures[picture-tag]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture## Why would I want this?This is a drop-in replacement for the [Django ImageField](https://docs.djangoproject.com/en/1.8/ref/models/fields/#django.db.models.ImageField) that provides a standardized way to handle image uploads.It is designed to be as easy to use as possible, and to provide a consistent interface for all image fields.It allows images to be presented in various size variants (eg:thumbnails, mid, and hi-res versions)and it provides a way to handle images that are too large with validators.## FeaturesDjango Standardized Image Field implements the following features:* [Django-Storages](https://django-storages.readthedocs.io/en/latest/) compatible (eg: S3, Azure, Google Cloud Storage, etc)* Resizes images to different sizes* Access thumbnails on model level, no template tags required* Preserves original images* Can be rendered asynchronously (ie as a [Celery job](https://realpython.com/asynchronous-tasks-with-django-and-celery/))* Restricts acceptable image dimensions* Renames a file to a standardized name format (using a callable `upload_to` function, see below)## InstallationSimply install the latest stable package using the following command:```bashpip install django-stdimage# orpipenv install django-stdimage```and add `'stdimage'` to `INSTALLED_APP`s in your settings.py, that's it!## UsageNow it's instally you can use either: `StdImageField` or `JPEGField`.`StdImageField` works just like Django's own[ImageField](https://docs.djangoproject.com/en/dev/ref/models/fields/#imagefield)except that you can specify different size variations.The `JPEGField` is identical to the `StdImageField` but all images areconverted to JPEGs, no matter what type the original file is.### VariationsVariations are specified within a dictionary. The key will be the attribute referencing the resized image.A variation can be defined both as a tuple or a dictionary.Example:```pythonfrom django.db import modelsfrom stdimage import StdImageField, JPEGFieldclass MyModel(models.Model):    # works just like django's ImageField    image = StdImageField(upload_to='path/to/img')    # creates a thumbnail resized to maximum size to fit a 100x75 area    image = StdImageField(upload_to='path/to/img',                          variations={'thumbnail': {'width': 100, 'height': 75}})    # is the same as dictionary-style call    image = StdImageField(upload_to='path/to/img', variations={'thumbnail': (100, 75)})    # JPEGField variations are converted to JPEGs.    jpeg = JPEGField(        upload_to='path/to/img',        variations={'full': (None, None), 'thumbnail': (100, 75)},    )    # creates a thumbnail resized to 100x100 croping if necessary    image = StdImageField(upload_to='path/to/img', variations={        'thumbnail': {&quot;width&quot;: 100, &quot;height&quot;: 100, &quot;crop&quot;: True}    })    ## Full ammo here. Please note all the definitions below are equal    image = StdImageField(upload_to='path/to/img', blank=True, variations={        'large': (600, 400),        'thumbnail': (100, 100, True),        'medium': (300, 200),    }, delete_orphans=True)```To use these variations in templates use `myimagefield.variation_name`.Example:```html&lt;a href=&quot;{{ object.myimage.url }}&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;{{ object.myimage.thumbnail.url }}&quot;/&gt;&lt;/a&gt;```### Upload to functionYou can use a function for the `upload_to` argument. Using [Django Dynamic Filenames][dynamic_filenames].[dynamic_filenames]: https://github.com/codingjoe/django-dynamic-filenamesThis allows images to be given unique paths and filenames based on the model instance.Example```pythonfrom django.db import modelsfrom stdimage import StdImageFieldfrom dynamic_filenames import FilePatternupload_to_pattern = FilePattern(    filename_pattern='my_model/{app_label:.25}/{model_name:.30}/{uuid:base32}{ext}',)class MyModel(models.Model):    # works just like django's ImageField    image = StdImageField(upload_to=upload_to_pattern)```### ValidatorsThe `StdImageField` doesn't implement any size validation out-of-the-box.However, Validation can be specified using the validator attributeand using a set of validators shipped with this package.Validators can be used for both Forms and Models.Example```pythonfrom django.db import modelsfrom stdimage.validators import MinSizeValidator, MaxSizeValidatorfrom stdimage.models import StdImageFieldclass MyClass(models.Model):    image1 = StdImageField(validators=[MinSizeValidator(800, 600)])    image2 = StdImageField(validators=[MaxSizeValidator(1028, 768)])```**CAUTION:** The MaxSizeValidator should be used with caution.As storage isn't expensive, you shouldn't restrict upload dimensions.If you seek prevent users form overflowing your memory you should restrict the HTTP upload body size.### Deleting imagesDjango [dropped support](https://docs.djangoproject.com/en/dev/releases/1.3/#deleting-a-model-doesn-t-delete-associated-files)for automated deletions in version 1.3.Since version 5, this package supports a `delete_orphans` argument. It will deleteorphaned files, should a file be deleted or replaced via a Django form and the object withthe `StdImageField` be deleted. It will not delete files if the field value is changed orreassigned programatically. In these rare cases, you will need to handle proper deletionyourself.```pythonfrom django.db import modelsfrom stdimage.models import StdImageFieldclass MyModel(models.Model):    image = StdImageField(        upload_to='path/to/files',        variations={'thumbnail': (100, 75)},        delete_orphans=True,        blank=True,    )```### Async image processingTools like celery allow to execute time-consuming tasks outside of the request. If you don't wantto wait for your variations to be rendered in request, StdImage provides you the option to pass anasync keyword and a 'render_variations' function that triggers the async task.Note that the callback is not transaction save, but the file variations will be present.The example below is based on celery.`tasks.py`:```pythonfrom django.apps import appsfrom celery import shared_taskfrom stdimage.utils import render_variations@shared_taskdef process_photo_image(file_name, variations, storage):    render_variations(file_name, variations, replace=True, storage=storage)    obj = apps.get_model('myapp', 'Photo').objects.get(image=file_name)    obj.processed = True    obj.save()````models.py`:```pythonfrom django.db import modelsfrom stdimage.models import StdImageFieldfrom .tasks import process_photo_imagedef image_processor(file_name, variations, storage):    process_photo_image.delay(file_name, variations, storage)    return False  # prevent default renderingclass AsyncImageModel(models.Model):    image = StdImageField(        # above task definition can only handle one model object per image filename        upload_to='path/to/file/', # or use a function        render_variations=image_processor  # pass boolean or callable    )    processed = models.BooleanField(default=False)  # flag that could be used for view querysets```### Re-rendering variationsYou might have added or changed variations to an existing field. That means you will need to render new variations.This can be accomplished using a management command.```bashpython manage.py rendervariations 'app_name.model_name.field_name' [--replace] [-i/--ignore-missing]```The `replace` option will replace all existing files.The `ignore-missing` option will suspend 'missing source file' errors and keeprendering variations for other files. Otherwise, the command will stop on first missing file.</longdescription>
</pkgmetadata>