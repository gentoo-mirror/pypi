<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># python-newick[![Build Status](https://github.com/dlce-eva/python-newick/workflows/tests/badge.svg)](https://github.com/dlce-eva/python-newick/actions?query=workflow%3Atests)[![PyPI](https://badge.fury.io/py/newick.svg)](https://pypi.org/project/newick)python package to read and write the [Newick format](https://en.wikipedia.org/wiki/Newick_format).## Reading NewickSince Newick specifies a format for a **set of trees**, all functions to read Newick returna `list` of `newick.Node` objects.- Reading from a string:  ```python  &gt;&gt;&gt; from newick import loads  &gt;&gt;&gt; trees = loads('(A,B,(C,D)E)F;')  &gt;&gt;&gt; trees[0].name  'F'  &gt;&gt;&gt; [n.name for n in trees[0].descendants]  ['A', 'B', 'E']  ```- Reading from  a `file`-like object:  ```python  &gt;&gt;&gt; import io  &gt;&gt;&gt; from newick import load  &gt;&gt;&gt; with io.open('fname', encoding='utf8') as fp:  ...     trees = load(fp)  ```- Reading from a path:  ```python  &gt;&gt;&gt; from newick import read  &gt;&gt;&gt; trees = read('fname')  &gt;&gt;&gt; import pathlib  &gt;&gt;&gt; trees = read(pathlib.Path('fname'))  ```### Supported Newick dialectsWhile the set of reserved characters in Newick (`;(),:`) is relatively small, it's still oftenseen as too restrictive, in particular when it comes to adding more data to tree nodes. Thus, Newickprovides two mechanisms to overcome this restriction:- *quoted labels* to allow arbitrary text as node names,- *comments* enclosed in square brackets.#### Quoted node labelsNode labels in Newick may be quoted (i.e. enclosed in single quotes `'`) to make it possible toadd characters which are otherwise reserved. The `newick` package supports quoted labels.```python&gt;&gt;&gt; from newick import loads&gt;&gt;&gt; print(loads(&quot;('A:B','C''D')'E(F)'&quot;)[0].ascii_art())         ┌─'A:B'──'E(F)'─┤         └─'C''D'```When creating Newick trees programmatically, names can be quoted (if necessary) automatically:```python&gt;&gt;&gt; from newick import Node&gt;&gt;&gt; print(Node(&quot;A(F')&quot;, auto_quote=True).name)'A(F'')'&gt;&gt;&gt; print(Node(&quot;A(F')&quot;, auto_quote=True).unquoted_name)A(F')```Note: `newick` provides no support to parse structured data from node labels (as it can be foundin the trees distributed by the Genome Taxonomy Database).#### Additional information in commentsThe [&quot;Newick specification&quot;](http://biowiki.org/wiki/index.php/Newick_Format) states&gt; Comments are enclosed in square brackets and may appear anywhereThis has spawned a host of ad-hoc mechanisms to insert additional data into Newick trees.The `newick` package allows to deal with comments in two ways.- Ignoring comments:  ```python  &gt;&gt;&gt; newick.loads('[a comment](a,b)c;', strip_comments=True)[0].newick  '(a,b)c'  ```- Reading comments as node annotations: Several software packages use Newick comments to   store node annotations, e.g. *BEAST, MrBayes or TreeAnnotator. Provided there are no  comments in places where they cannot be interpreted as node annotations, `newick` supports  reading and writing these annotations:  ```python  &gt;&gt;&gt; newick.loads('(a[annotation],b)c;')[0].descendants[0].name  'a'  &gt;&gt;&gt; newick.loads('(a[annotation],b)c;')[0].descendants[0].comment  'annotation'  &gt;&gt;&gt; newick.loads('(a[annotation],b)c;')[0].newick  '(a[annotation],b)c'  ```  Annotations may come before and/or after the `:` which separates node label and length:- ```python  &gt;&gt;&gt; newick.loads('(a[annotation]:2,b)c;')[0].descendants[0].length  2.0  &gt;&gt;&gt; newick.loads('(a:[annotation]2,b)c;')[0].descendants[0].length  2.0  &gt;&gt;&gt; newick.loads('(a[annotation1]:[annotation2]2,b)c;')[0].descendants[0].comments  ['annotation1', 'annotation2']  ```Note that square brackets inside *quoted labels* will **not** be interpreted as commentsor annotations:```python&gt;&gt;&gt; newick.loads(&quot;('a[label]',b)c;&quot;)[0].descendants[0].name&quot;'a[label]'&quot;&gt;&gt;&gt; newick.loads(&quot;('a[label]',b)c;&quot;)[0].newick&quot;('a[label]',b)c&quot;```Some support for reading key-value data from node comments is available as well. If the commentformat follows the [NHX](https://en.wikipedia.org/wiki/Newick_format#New_Hampshire_X_format) specor the `&amp;&lt;key&gt;=&lt;value&gt;,...`-format used e.g. by the MrBayes or BEAST software, additional datacan be accessed from the `dict` `Node.properties`:```python&gt;&gt;&gt; newick.loads('(A,B)C[&amp;&amp;NHX:k1=v1:k2=v2];')[0].properties{'k1': 'v1', 'k2': 'v2'}```**Limitations:**- **Typed** node properties are not supported. I.e. values in `Node.properties` are  always strings. Since typed properties tend to be specific to the application writing the newick,  this level of support would require more knowledge of the creation context of the tree than can  safely be inferred from the Newick string alone.  ```python  &gt;&gt;&gt; newick.loads('(A,B)C[&amp;range={1,5},support=&quot;100&quot;];')[0].properties  {'range': '{1,5}', 'support': '&quot;100&quot;'}  ```- Node annotations in comments are not completely round-trip-safe. In particular multiple comments  per node may be lumped together (using `|` as separator) when serializing a Newick node:  ```python  &gt;&gt;&gt; newick.loads('(a,b)c[c1][c2]:3')[0].newick  '(a,b)c[c1|c2]:3'  ```## Writing NewickIn parallel to the read operations there are three functions to serialize a single `Node` object or a `list` of `Node`objects to Newick format:- `dumps(trees) -&gt; str`- `dump(trees, fp)`- `write(trees, 'fname')`A tree may be assembled using the factory methods of the `Node` class:- `Node.__init__`- `Node.create`- `Node.add_descendant`## Manipulating trees- Displaying tree topology in the terminal:  ```python  &gt;&gt;&gt; import newick  &gt;&gt;&gt; tree = newick.loads('(b,(c,(d,(e,(f,g))h)i)a)')[0]  &gt;&gt;&gt; print(tree.ascii_art())      ┌─b  ────┤      │   ┌─c      └─a─┤          │   ┌─d          └─i─┤              │   ┌─e              └─h─┤                  │   ┌─f                  └───┤                      └─g  ```- Pruning trees: The example below prunes the tree such that `b`, `c` and `i` are the only  remaining leafs.  ```python  &gt;&gt;&gt; tree.prune_by_names(['b', 'c', 'i'], inverse=True)  &gt;&gt;&gt; print(tree.ascii_art())      ┌─b  ────┤      │   ┌─c      └─a─┤          └─i  ```- Running a callable on a filtered set of nodes:  ```python  &gt;&gt;&gt; tree.visit(lambda n: setattr(n, 'name', n.name.upper()), lambda n: n.name in ['a', 'b'])  &gt;&gt;&gt; print(tree.ascii_art())      ┌─B  ────┤      │   ┌─c      └─A─┤          └─i  ```- Removing (topologically) redundant internal nodes:  ```python  &gt;&gt;&gt; tree.prune_by_names(['B', 'c'], inverse=True)  &gt;&gt;&gt; print(tree.ascii_art())      ┌─B  ────┤      └─A ──c  &gt;&gt;&gt; tree.remove_redundant_nodes(keep_leaf_name=True)  &gt;&gt;&gt; print(tree.ascii_art())      ┌─B  ────┤      └─c  ```</longdescription>
</pkgmetadata>