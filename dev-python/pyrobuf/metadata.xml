<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Pyrobuf Library### IntroductionPyrobuf is an alternative to Google's Python Protobuf library.It generates lightning-fast Cython code that's 2-4x faster than Google's PythonProtobuf library using their C++ backend and 20-40x faster than Google's pure-pythonimplementation.What's more, Pyrobuf is self-contained and easy to install.### RequirementsPyrobuf requires Cython, and Jinja2. If you want to contribute to pyrobuf youmay also want to install pytest.Pyrobuf *does not* require protoc.Pyrobuf has been tested with Python 2.7 and Python 3.5.Pyrobuf appears to be working on OSX, Linux and Windows (for the latter gettingCython to work properly is the trickiest bit especially if you are still using2.7).### ContributingPeople use protobuf in many different ways. Pyrobuf handles the use cases ofAppNexus and other contributors, but is not yet a 100% drop-in replacement towhat protoc would generate.You can help make it so!Fork and clone the repository, then run:    $ python setup.py developIt will generate the platform specific `pyrobuf_list` then compilethe `pyrobuf_list` and `pyrobuf_util` modules.### Unit TestingYou can run the test suite (a work in progress) using py.test directly:    $ py.testOr using the `test` command (which installs pytest if not already available):    $ python setup.py testEither method will automatically build all the protobuf message specs in`tests/proto` and point the `PYTHONPATH` to the built messages before runningthe tests.Re-running the `develop` or `test` commands will automatically re-build the`pyrobuf_list` and `pyrobuf_util` modules if necessary.The `clean` command does the house keeping for you:    $ python setup.py cleanIf you find that pyrobuf does not work for one of your proto files, add a minimalproto file to `tests/proto` that breaks before submitting a pull request.Pull requests including a breaking test are gold!Improving testing is in the cards.### InstallationYou may very well be able to just use pyrobuf as is... just pip it!    $ pip install pyrobufShould do the trick!To check, you may want to make sure the following command does not raise anexception:    $ python -c &quot;import pyrobuf_list&quot;If it does raise an exception try:    $ pip install pyrobuf -v -v -v --upgrade --force --no-cache### CompilingWhen you `pip install pyrobuf` you get the pyrobuf CLI tool ...:    $ pyrobuf --help    usage: pyrobuf [-h] [--out-dir OUT_DIR] [--build-dir BUILD_DIR] [--install] source    a Cython based protobuf compiler    positional arguments:      source                filename.proto or directory containing proto files    optional arguments:      -h, --help            show this help message and exit      --out-dir OUT_DIR     cythonize output directory [default: out]      --build-dir BUILD_DIR                            C compiler build directory [default: build]      --install             install the extension [default: False]      --package             the name of the package to install toIf you do not want to have to deal with setuptools entry\_points idiosyncrasiesyou can also do:    $ python -m pyrobuf --help### UseSuppose you have installed `test_message.proto` which contains a spec for themessage `Test`. In Python, you can import your new message class by running:    from test_message_proto import TestWith the message class imported, we can create a new message:    test = Test()Now that we have instantiated a message `test`, we can fill individual fields:    &gt;&gt;&gt; test.field = 5    &gt;&gt;&gt; test.req_field = 2    &gt;&gt;&gt; test.string_field = &quot;hello!&quot;    &gt;&gt;&gt; test.list_fieldx.append(12)    &gt;&gt;&gt; test.test_ref.field2 = 3.14And access those same fields:    &gt;&gt;&gt; test.string_field    'hello!'Once we have at least filled out any &quot;required&quot; fields, we can serialize to abyte array:    bytearray(b'\x10\x05\x1a\x06hello! \x0c2\t\x19\x1f\x85\xebQ\xb8\x1e\t@P\x02')We can also deserialize a protobuf message to our message instance:    &gt;&gt;&gt; test.ParseFromString('\x10\x05\x1a\x06hello! \x0c2\t\x19\x1f\x85\xebQ\xb8\x1e\t@P\x02')    25Note that the `ParseFromString` method returns the number of bytes consumed.In addition to serializing and deserializing to and from protobuf messages,Pyrobuf also allows us to serialize and deserialize to and from JSON and nativePython dictionaries:    &gt;&gt;&gt; test.SerializeToJson()    '{&quot;field&quot;: 5, &quot;req_field&quot;: 2, &quot;list_fieldx&quot;: [12], &quot;string_field&quot;: &quot;hello!&quot;, &quot;test_ref&quot;: {&quot;field2&quot;: 3.14}}'    &gt;&gt;&gt; test.ParseFromJson('{&quot;field&quot;: 5, &quot;req_field&quot;: 2, &quot;list_fieldx&quot;: [12], &quot;string_field&quot;: &quot;hello!&quot;, &quot;test_ref&quot;: {&quot;field2&quot;: 3.14}}')    &gt;&gt;&gt; test.SerializeToDict()    {'field': 5,     'list_fieldx': [12],     'req_field': 2,     'string_field': 'hello!',     'test_ref': {'field2': 3.14}}Finally, the `pyrobuf_util` module contains functions for encoding and decoding integers.    &gt;&gt;&gt; import pyrobuf_util    &gt;&gt;&gt; pyrobuf_util.to_varint(2**16-1)    bytearray(b'\xff\xff\x03')    &gt;&gt;&gt; pyrobuf_util.from_varint(b'\xff\xff\x03', offset=0)    (65535L, 3)    &gt;&gt;&gt; pyrobuf_util.to_signed_varint(-2**16)    bytearray(b'\xff\xff\x07')    &gt;&gt;&gt; pyrobuf_util.from_signed_varint(b'\xff\xff\x07', offset=0)    (-65536L, 3)The `from_varint` and `from_signed_varint` functions return both the decoded integer andthe offset of the first byte after the encoded integer in the source data.### PackagingIf you are compiling multiple messages or a directory of messages and don't want themall to be built to their own separate package but instead want a single namespacecontaining all your messages, you can specify a package name:    pyrobuf /path/to/proto/specs --install --package=my_messagesThen you can import your message classes from the `my_messages` pakcage:    &gt;&gt;&gt; from my_messages import MyMessage1, MyMessage2### Distributing a Python Package with Pyrobuf ModulesSuppose you have a Python package called 'sample' arranged on disk as follows:    sample/        proto/            my_message.proto        sample/            __init__.py        setup.pyPyrobuf adds a new setup keyword `pyrobuf_modules` which can be used to specify eitherindividual protobuf files or folders containing protobuf files. For example, the `setup.py`file could look like this:from setuptools import setup, find_packages    setup(        name=&quot;sample&quot;,        version=&quot;0.1&quot;,        packages=find_packages(),        description=&quot;A sample package&quot;,        install_requires=['pyrobuf'],        setup_requires=['pyrobuf'],        pyrobuf_modules=&quot;proto&quot;    )In addition to the package &quot;sample&quot;, setuptools will also build a package named&quot;sample\_proto&quot; which will contain the compiled Protobuf messages.Once installed this sample package can be used as follows:    &gt;&gt;&gt; from sample_proto import MyMessage    &gt;&gt;&gt; my_message = MyMessage()### PerformanceOn my development machine (Ubuntu 14.04), Pyrobuf is roughly 2.0x as fast asGoogle's library for message serialization and 2.3x as fast for messagedeserialization when using the C++ backend for Google's library:    &gt; python tests/perf_test.py    Google took 1.649168 seconds to serialize    Pyrobuf took 0.825525 seconds to serialize    Google took 1.113041 seconds to deserialize    Pyrobuf took 0.466113 seconds to deserializeWhen not using the C++ backend, Pyrobuf is roughly 25x as fast for serializationand 55x as fast for deserialization:    Google took 20.215662 seconds to serialize    Pyrobuf took 0.819555 seconds to serialize    Google took 24.990137 seconds to deserialize    Pyrobuf took 0.455732 seconds to deserialize### Differences from the Google libraryIf pyrobuf is missing a feature from protoc that you need, let us know! We aretrying to make it as easy as possible for you to help make pyrobuf better.For the most part, Pyrobuf should be a drag-and-drop replacement for the Googleprotobuf library. There are a few differences, though. First, Pyrobuf does notcurrently implement the `ListFields`, `WhichOneOf`, `HasExtension`,`ClearExtension` and `ByteSize` methods.Second, Pyrobuf simply assumes that the schema being used for a given messageis the same on the send and receive ends, so changing the type of a field onone end without changing it on the other may cause bugs; adding or removingfields will not break anything.</longdescription>
</pkgmetadata>