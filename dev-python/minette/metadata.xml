<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Minette for Python[![Downloads](https://pepy.tech/badge/minette)](https://pepy.tech/project/minette)Minette is a minimal and extensible chatbot framework. It is extremely easy to develop and the architecture preventing to be spaghetti code enables you to scale up to complex chatbot.[üáØüáµÊó•Êú¨Ë™û„ÅÆREADME„ÅØ„Åì„Å°„Çâ](https://github.com/uezo/minette-python/blob/master/README.ja.md)# üéâ version 0.4.2 is available- 0.4.3 Sep 5, 2020    - Enable to give shared objects to dialogs from main logic üëâ [PR #38](https://github.com/uezo/minette-python/pull/38)    - Add argument `tagger_max_length` to constructor of Minette üëâ [PR #42](https://github.com/uezo/minette-python/pull/42)    - Support returning generator from Tagger üëâ [PR #35](https://github.com/uezo/minette-python/pull/35)- 0.4.2 Aug 26, 2020    - Support [Janome 0.4](https://mocobeta.github.io/janome/en/)- 0.4.1 Aug 7, 2020    - SQLAlchemy is supported (experimental). See also [examples/todo.py](https://github.com/uezo/minette-python/blob/master/examples/todo.py)# üöÄ Quick startRunning echo bot is extremely easy.```pythonfrom minette import Minette, EchoDialogService# Create chatbot instance using EchoDialogServicebot = Minette(default_dialog_service=EchoDialogService)# Send and receive messageswhile True:    req = input(&quot;user&gt; &quot;)    res = bot.chat(req)    for message in res.messages:        print(&quot;minette&gt; &quot; + message.text)``````$ python echo.pyuser&gt; hellominette&gt; You said: hello```Creating LINE bot is also super easy.```pythonfrom flask import Flask, requestfrom minette import Minette, EchoDialogServicefrom minette.adapter.lineadapter import LineAdapter# Create chatbot wrapped by LINE adapterbot = LineAdapter(default_dialog_service=EchoDialogService)# Create web server and its request handlerapp = Flask(__name__)@app.route(&quot;/&quot;, methods=[&quot;POST&quot;])def handle_webhook():    bot.handle_http_request(request.data, request.headers)    return &quot;ok&quot;# Start web serverapp.run(port=12345)```See also [examples.md](https://github.com/uezo/minette-python/blob/master/examples.md) to get more examples.# üì¶ Installation```$ pip install minette```# ‚úÖ Supported PlatformsPython 3.5 or higher is supported. Mainly developed using Python 3.7.7 on Mac OSX.## Messaging Service- LINE- Clova- SymphonyYou can connect to other messaging services by extending `minette.Adapter`.## Database- SQLite- Azure SQL Database- Azure Table Storage- MySQL (Tested on 8.0.13)You can use other databases you like by extending the classes in `minette.datastore` package. (Context / User / MessageLog)Or, maybe you can use supported databases by SQLAlchemy by just setting connection string for it.## Tagger- MeCab- JanomeYou can use other morphological engines including cloud services and for other languages by extending `minette.Tagger`.To setup and use MeCab and Janome Tagger, see the Appendix at the bottom of this page.# üìö Dependencies(Required)- pytz &gt;= 2018.9- schedule &gt;= 0.6.0(Optional)- line-bot-sdk &gt;= 1.12.1 (for LINE)- clova-cek-sdk &gt;= 1.1.1- sym-api-client-python &gt;= 0.1.16 (for Symphony)- pyodbc &gt;= 4.0.26 (for Azure SQL Databsae)- azure-cosmosdb-table &gt;= 1.0.5 (for Azure Table Storage)- MySQLdb (for MySQL)- SQLAlchemy (for SQLAlchemyStores)- mecab-python3 &gt;= 1.0.1 (for MeCabTagger)- Janome &gt;= 0.3.8 (for Janome Tagger)# ‚ú® FeaturesTo create a bot, developers just implement `DialogService(s)` and `DialogRouter`.- DialogService: process the application logic and compose the response message to the user- DialogRouter: extract intents and entities from request message to route the proper DialogService[![Architecture](http://uezo.net/img/minette_architecture.png)](http://uezo.net/img/minette_architecture.png)Any other common operations (e.g. context management) are done by framework.## Context managementMinette provides a data store that enables your bot to continue conversasion accross the requests like HTTP Session.Set data```python# to use context data at the next request, set `True` to `context.topic.keep_on` in DialogServicecontext.data[&quot;pizza_name&quot;] = &quot;Seafood Pizza&quot;context.topic.keep_on = True```Get data```pythonpizza_name = context.data[&quot;pizza_name&quot;]```## User managementUsers are identified by the Channel (e.g LINE, FB Messanger etc) and the UserID for the Channel. Each users are automatically registered at the first access and each changes for user is saved automatically.```python# framework saves the updated user info automatically and keep them until the app delete themrequest.user.nickname = &quot;uezo&quot;request.user.data[&quot;horoscope&quot;] = &quot;cancer&quot;```## Natural language analyzingTaggers are the components for analyzing the text of request and the result will be automatically set to request object. Minette has 2 built-in taggers for Japanese - MeCabTagger and JanomeTagger.To use JanomeTagger, at first install Janome: a pure python Japanese morphological analyzer.```bash$ pip install janome```Check tagger like below.```python&gt;&gt;&gt; from minette.tagger.janometagger import JanomeTagger&gt;&gt;&gt; tagger = JanomeTagger()&gt;&gt;&gt; words = tagger.parse(&quot;‰ªäÊó•„ÅØËâØ„ÅÑÂ§©Ê∞ó„Åß„Åô&quot;)&gt;&gt;&gt; words[0].to_dict(){'surface': '‰ªäÊó•', 'part': 'ÂêçË©û', 'part_detail1': 'ÂâØË©ûÂèØËÉΩ', 'part_detail2': '', 'part_detail3': '', 'stem_type': '', 'stem_form': '', 'word': '‰ªäÊó•', 'kana': '„Ç≠„Éß„Ç¶', 'pronunciation': '„Ç≠„Éß„Éº'}```Sample usage in `DialogService` is here.```python# bot = Minette(tagger=JanomeTagger) &lt;- Note: create bot with JanomeTaggerdef process_request(self, request, context, connection):    # result of parsing morph is set in `request.words` automatically    nouns = [w.surface for w in request.words if w.part == &quot;ÂêçË©û&quot;]```## Task schedulerBuilt-in task scheduler is ready-to-use. Your chatbot can run periodic jobs without cron.```pythonclass MyTask(Task):    # implement periodic task in `do` method    def do(self, arg1, arg2):        # The Logger of scheduler is available in each tasks        self.logger.info(&quot;Task started!: {} / {}&quot;.format(arg1, arg2))# Create Scheculersc = Scheduler()# Register the task. This task runs every 3 secondssc.every_seconds(MyTask, seconds=3, arg1=&quot;val1&quot;, arg2=&quot;val2&quot;)# Start the schedulersc.start()```## Message LogRequest, response and context at each turns are stored as Message Log. It provides you the very useful information to debug and improve your chatbot.## Testing DialogsMinette provides a helper to test dialogs. This is an example using `pytest`.- `channel_user_id` for each test cases(functions) is set to request automatically.- `chat` method takes arguments for `Message`. This enables you `bot.chat(&quot;hello&quot;, intent=&quot;HelloIntent&quot;)` instead of `bot.chat(Message(text=&quot;hello&quot;, intent=&quot;HelloIntent&quot;))` to make your test code simple.- Response from `chat` has `text` attribute that equals to `response.messages[0].text`.```pythonimport pytestfrom minette import Message, DialogService, Priority, Payloadfrom minette.test.helper import MinetteForTest# dialogs to testclass FooDialog(DialogService):    def compose_response(self, request, context, connetion):        return &quot;foo:&quot; + request.textclass BarDialog(DialogService):    def compose_response(self, request, context, connetion):        context.topic.keep_on = True        return &quot;bar:&quot; + request.textclass PayloadDialog(DialogService):    def compose_response(self, request, context, connetion):        return &quot;payload:&quot; + str(request.payloads[0].content)# bot created for each test functions@pytest.fixture(scope=&quot;function&quot;)def bot():    # use MinetteForTest instead of Minette    return MinetteForTest(        intent_resolver={            &quot;FooIntent&quot;: FooDialog,            &quot;BarIntent&quot;: BarDialog,            &quot;PayloadIntent&quot;: PayloadDialog        },    )# test cases function using botdef test_example(bot):    # trigger intent    assert bot.chat(&quot;hello&quot;, intent=&quot;FooIntent&quot;).text == &quot;foo:hello&quot;    # empty response without intent    assert bot.chat(&quot;hello&quot;).text == &quot;&quot;    # trigger other intent    assert bot.chat(&quot;hello&quot;, intent=&quot;BarIntent&quot;).text == &quot;bar:hello&quot;    # context and topic is kept by dialog service    assert bot.chat(&quot;hi&quot;, intent=&quot;FooIntent&quot;).text == &quot;bar:hi&quot;    assert bot.chat(&quot;yo&quot;).text == &quot;bar:yo&quot;    # update topic by higher priority request    assert bot.chat(&quot;hello&quot;, intent=&quot;FooIntent&quot;, intent_priority=Priority.High).text == &quot;foo:hello&quot;def test_payload(bot):    # use Message to test your dialog with payloads, channel_message and so on    assert bot.chat(Message(        intent=&quot;PayloadIntent&quot;,        type=&quot;data&quot;,        text=&quot;hello&quot;,        payloads=[Payload(content={&quot;key1&quot;: &quot;value1&quot;})]    )).text == &quot;payload:&quot; + str({&quot;key1&quot;: &quot;value1&quot;})```# üíù ContributionSee the [Contribution Guideline](https://github.com/uezo/minette-python/blob/master/CONTRIBUTING.md)# ‚öñÔ∏è LicenseThis software is licensed under the Apache v2 License.# Appendix1. Setup MeCab Tagger## Installing MeCab- Ubuntu 16.04```$ sudo apt-get install mecab libmecab-dev mecab-ipadic$ sudo apt-get install mecab-ipadic-utf8```- Mac OSX```$ brew install mecab mecab-ipadic git curl xz```## Installing python binding```$ pip install mecab-python3==1.0.1```~~Version 0.996.1 has a bug(?) so we strongly recommend to use version 0.7.~~ Fixed at current version## Usase```pythonfrom minette.tagger.mecabtagger import MeCabTaggerbot = Minette(    tagger=MeCabTagger)```# Appendix2. Migration from version 0.3- Some packages are deprecated. All standard classes can be imported from `minette`.- The way to create instance of `Minette` is changed. (just call constructor)- `Session` is renamed to `Context`. The arguments named `session` is also changed.- `minette.user.User#save()` is deleted. Create `UserStore` and call `save(user)` instead.- `SessionStore` -&gt; `ContextStore`, `UserRepository` -&gt; `UserStore`, `MessageLogger` -&gt; `MessageLogStore`- HTTP request handler method of `LineAdapter` is changed to `handle_http_request`.If you need version 0.3 install from github.```$ pip install git+https://github.com/uezo/minette-python.git@v0.3```</longdescription>
</pkgmetadata>