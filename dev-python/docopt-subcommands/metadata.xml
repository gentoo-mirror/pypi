<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Build Status](https://travis-ci.org/abingham/docopt-subcommands.png?branch=master)](https://travis-ci.org/abingham/docopt-subcommands)# docopt-subcommandsA simple implementation of subcommands for docopt.`docopt-subcommands` allows you to create subcommand-based programsusing [docopt](https://github.com/docopt/docopt). A subcommand-based program isone in which the main program uses a &quot;subcommand&quot; argument to tell it what todo.The classic example of such a program is [git](https://git-scm.com/). The `git`command with no arguments doesn't do much of anything. Instead, it's the firstargument to `git` - the *subcommand* - that tells it what to actually do. Forexample:```git log```will give you the log for your repository. Likewise:```git rebase```is the subcommand for rebasing.`docopt-subcommands` is here to help you create similar kinds of command-linetools with `docopt`'.## QuickstartThe basic idea behind `docopt-subcommands` is simple: 1. You provide a separate *handler function* for each subcommand. 2. The docstring for each handler function defines the docopt definition for    that subcommand. 3. You register your handler functions with the names of the subcommands which    will invoke them. 4. You provide a program name and (optionally) a top-level documentation string.Then `docopt-subcommands` does the work of stitching everything together into asubcommand-driven program. Here's how it looks (from the included`exampels/basic_example.py`):```python# Basic, most common usage of docopt_subcommandsimport docopt_subcommands as dsc# 1. Use the `command` decorator to add subcommands functions.@dsc.command()def foo_handler(precommand_args, args):    &quot;&quot;&quot;usage: {program} foo &lt;name&gt;    Apply foo to a name.    &quot;&quot;&quot;    print(&quot;Foo, {}&quot;.format(args['&lt;name&gt;']))@dsc.command()def bar_handler(precommand, args):    &quot;&quot;&quot;usage: {program} bar &lt;name&gt;    Apply bar to a name.    &quot;&quot;&quot;    print(&quot;Bar, {}&quot;.format(args['&lt;name&gt;']))# 2. Pass a program name and version string to `main` to run a program with the# subcommands you defined with the decorators above.dsc.main(program='docopt-subcommand-example')```If you run this program at the command line you'll see that you have a nice,subcommand-based CLI program:```shell$ python basic_example.pyUsage: docopt-subcommand-example [options] &lt;command&gt; [&lt;args&gt; ...]$ python basic_example.py -hdocopt-subcommand-exampleUsage: docopt-subcommand-example [options] &lt;command&gt; [&lt;args&gt; ...]Options:  -h --help     Show this screen.Available commands:  bar  fooSee 'docopt-subcommand-example help &lt;command&gt;' for help on specific commands.$ python basic_example.py foousage: docopt-subcommand-example foo &lt;name&gt;$ python basic_example.py foo -husage: docopt-subcommand-example foo &lt;name&gt;Apply foo to a name.$ python basic_example.py foo BubbaFoo, Bubba```For more examples, see the `examples` directory.## Common optionsMany subcommand-based programs have a set of options that are common to all commands. A common example is `--verbose`which causes the program to print more information not matter which command is executed. With `docopt_subcommands` you specify these common options in the top-level docstring like this::  TOP_LEVEL_DOC = &quot;&quot;&quot;{program}  Usage: {program} [options] &lt;command&gt; [&lt;args&gt; ...]  Options:    -h --help   Show this screen    --verbose   Use verbose output  Available commands:     {available_commands}  &quot;&quot;&quot;With this docstring, you can provide the `--verbose` flag for any subcommand. Critically, **common options must be provided before the subcommand name.** So if `bar` was a subcommand in your program, you would write::  my_program --verbose barbut not::  my_program bar --verbose`docopt_subcommands` parses the complete command line in two passes. The first pass parses it with the top-leveldocstring while the second pass uses the docstring for the specific command and only parses the part of the command lineafter the common options. It then provides both of the parsed dicts to the subcommand handler: the first argument to thehandler is the result of the first pass, and the second argument is the result of the second pass.With this system, you can then use a single set of code to do &quot;common configuration&quot; for you program. For example,here's how a handler might look:.. code-block:: python  @dsc.command()  def bar_handler(precommand_args, args):      &quot;&quot;&quot;usage: {program} bar &lt;name&gt;      Apply bar to a name.      &quot;&quot;&quot;      handle_common_option(precommand_args)      name = args['&lt;name&gt;']      print('Bar {}'.format(name))## Advanced usageFor most users the basic usage described in &quot;Quickstart&quot; should be all you need,but some users will need more control of `docopt_subcommands`. The`docopt_subcommands.main()` that we used earlier is really just a conveniencelayer on top of the real workhorse, `docopt_subcommands.Subcommands`. You caninstantiate this class directly, bypassing `main()`, and interact with it as youneed before actually invoke command-line processing.For the most part, the arguments to the `Subcommands` initializer are verysimilar to those to `main()`. This reflects the fact that `main()` really justinstantiates a `Subcommands` instance (if you don't provide one), populates itwith commands, and calls it with the command line arguments. You can do all ofthese steps yourself if you need to.As an example, here's what the basic example above looks like if you construct a`Subcommands` instance directly.:```pythonimport docopt_subcommands as dscimport syssc = dsc.Subcommands(program='docopt-subcommand-example')@sc.command('foo')def foo_handler(args):    &quot;&quot;&quot;usage: {program} {command} &lt;name&gt;    Apply foo to a name.    &quot;&quot;&quot;    print(&quot;Foo, {}&quot;.format(args['&lt;name&gt;']))@sc.command('bar')def bar_handler(args):    &quot;&quot;&quot;usage: {program} {command} &lt;name&gt;    Apply bar to a name.    &quot;&quot;&quot;    print(&quot;Bar, {}&quot;.format(args['&lt;name&gt;']))sc(sys.argv[1:])```As you can see, it's not substantially different from the basic example.`main()` primarily just adds a layer of convenience - mostly by choosingreasonable default values for some things - that you lose with this approach.</longdescription>
</pkgmetadata>