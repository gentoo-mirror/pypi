<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. figure:: https://travis-ci.org/btimby/fulltext.png   :alt: Travis CI Status   :target: https://travis-ci.org/btimby/fulltext.. figure:: https://www.smartfile.com/assets/img/smartfile-logo-new.png   :alt: SmartFileA `SmartFile`_ Open Source project.Introduction------------Fulltext extracts texts from various document formats. It can be used as thefirst part of search indexing, document analysis etc.Fulltext differs from other libraries in that it tries to use file data in theform it is given. For most backends, a file-like object or path can be handleddirectly, removing the need to write temporary files.Fulltext uses native python libraries when possible and utilizes CLI toolswhen necessary, for example, the following CLI tools are required. * antiword - Legacy .doc (Word) format. * unrtf - .rtf format. * pdf2text (poppler-utils) - .pdf format.Supported formats-----------------* csv - Uses Python ``csv`` module.* doc - Uses ``/bin/antiword`` CLI tool.* docx - Uses Python ``docx2txt`` module.* html - Uses Python ``BeautifulSoup`` module.* ods - Uses Python ``lxml``, ``zipfile`` modules.* odt - Uses Python ``lxml``, ``zipfile`` modules.* pdf - Uses ``/bin/pdf2text`` CLI tool.* rtf - Uses ``/bin/unrtf`` CLI tool.* text - Default backend that uses various Python stdlib modules to extract         strings from arbitrary (possibly) binary files.* xls - Uses Python ``xlrd`` module.* xlsx - Uses Python ``xlrd`` module.* zip - Uses Python ``zipfile`` module.Installing tools----------------Fulltext uses a number of pure Python libraries. Fulltext also uses thecommand line tools: antiword, pdf2text and unrtf. To install the requiredlibraries and CLI tools, you can use your package manager... code:: bash    $ sudo yum install antiword unrtf poppler-utils libjpeg-devOr for debian-based systems:.. code:: bash    $ sudo apt-get install antiword unrtf poppler-utils libjpeg-devUsage-----Fulltext uses a simple dictionary-style interface. A single public function``fulltext.get()`` is provided. This function takes an optional defaultparameter which when supplied will supress errors and return that default iftext could not be extracted... code:: python    &gt; import fulltext    &gt; fulltext.get('does-not-exist.pdf', '&lt; no content &gt;')    '&lt; no content &gt;'    &gt; fulltext.get('exists.pdf', '&lt; no content &gt;'')    'Lorem ipsum...'You can pass a file-like object or a path to ``.get()`` Fulltext will try todo the right thing, using memory buffers or temp files depending on thebackend.Custom backends---------------To write a new backend, you need to do two things. First, create a pythonmodule that implements the interface that Fulltext expects. Second, define anenvironment variable that informs Fulltext where to find your module... code:: python    # Tell Fulltext what file extensions your backend supports.    EXTENSIONS = ('foo', 'bar')    def _get_file(f, **kwargs):        # Extract text from a file-like object. This should be defined when        # possible.        pass    def _get_path(path, **kwargs):        # Extract text from a path. This should only be defined if it can be        # done more efficiently than having Python open() and read() the file,        # passing it to _get_file().        passIf you only implement ``_get_file`` Fulltext will open any paths and pass themto that function. Therefore if possible, define at least this function. Ifworking with file-like objects is not possible and you only define``_get_path`` then Fulltext will save any file-like objects to a temporaryfile and use that function. Sometimes it is advantageous to define bothfunctions in cases when you can do each efficiently.If you have questions about writing a backend, see the `backends/`_ directoryfor some examples... _backends/: fulltext/backends/Once written, simply define an environment variable ``FULLTEXT_PATH`` tocontain paths to your backend modules... code:: bash    FULLTEXT_PATH=/path/to/my/module;/path/to/other/module python myprogram.py</longdescription>
</pkgmetadata>