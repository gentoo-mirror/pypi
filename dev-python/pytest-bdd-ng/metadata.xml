<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>BDD library for the pytest runner=================================.. image:: http://img.shields.io/pypi/v/pytest-bdd-ng.svg    :target: https://pypi.python.org/pypi/pytest-bdd-ng.. image:: https://codecov.io/gh/elchupanebrej/pytest-bdd-ng/branch/default/graph/badge.svg    :target: https://app.codecov.io/gh/elchupanebrej/pytest-bdd-ng.. image:: https://readthedocs.org/projects/pytest-bdd-ng/badge/?version=default    :target: https://pytest-bdd-ng.readthedocs.io/en/default/?badge=default    :alt: Documentation Status.. image:: https://badgen.net/badge/stand%20with/UKRAINE/?color=0057B8&amp;labelColor=FFD700    :target: https://savelife.in.ua/en/**pytest-bdd-ng** combine descriptive clarity of `Gherkin &lt;https://cucumber.io/docs/gherkin/reference/&gt;`_ languagewith power and fullness of `pytest &lt;https://docs.pytest.org/&gt;`_ infrastructureIt enables unifying unit and functionaltests, reduces the burden of continuous integration server configuration and allows the reuse oftest setups.Pytest fixtures written for unit tests can be reused for setup and actionsmentioned in feature steps with dependency injection. This allows a true BDDjust-enough specification of the requirements without obligatory maintaining any context objectcontaining the side effects of Gherkin imperative declarations... _behave: https://pypi.python.org/pypi/behave.. _pytest-splinter: https://github.com/pytest-dev/pytest-splinterInstall pytest-bdd-ng---------------------::    pip install pytest-bdd-ngExample-------An example test for a blog hosting software could look like this.Note that pytest-splinter_ is used to get the browser fixture.publish_article.feature:.. code-block:: gherkin    Feature: Blog        A site where you can publish your articles.        Scenario: Publishing the article            Given I'm an author user            And I have an article            When I go to the article page            And I press the publish button            Then I should not see the error message            And the article should be published  # Note: will query the databaseNote that only one feature is allowed per feature file.test_publish_article.py:.. code-block:: python    from pytest_bdd import scenario, given, when, then    @scenario('publish_article.feature', 'Publishing the article')    def test_publish():        pass    @given(&quot;I'm an author user&quot;)    def author_user(auth, author):        auth['user'] = author.user    @given(&quot;I have an article&quot;, target_fixture=&quot;article&quot;)    def article(author):        return create_test_article(author=author)    @when(&quot;I go to the article page&quot;)    def go_to_article(article, browser):        browser.visit(urljoin(browser.url, '/manage/articles/{0}/'.format(article.id)))    @when(&quot;I press the publish button&quot;)    def publish_article(browser):        browser.find_by_css('button[name=publish]').first.click()    @then(&quot;I should not see the error message&quot;)    def no_error_message(browser):        with pytest.raises(ElementDoesNotExist):            browser.find_by_css('.message.error').first    @then(&quot;the article should be published&quot;)    def article_is_published(article):        article.refresh()  # Refresh the object in the SQLAlchemy session        assert article.is_publishedScenario decorator------------------Functions decorated with the `scenario` decorator behave like a normal test function,and they will be executed after all scenario steps... code-block:: python    from pytest_bdd import scenario, given, when, then    @scenario('publish_article.feature', 'Publishing the article')    def test_publish(browser):        assert article.title in browser.html.. NOTE:: It is however encouraged to try as much as possible to have your logic only inside the Given, When, Then steps.Step aliases------------Sometimes, one has to declare the same fixtures or steps withdifferent names for better readability. In order to use the same stepfunction with multiple step names simply decorate it multiple times:.. code-block:: python    @given(&quot;I have an article&quot;)    @given(&quot;there's an article&quot;)    def article(author, target_fixture=&quot;article&quot;):        return create_test_article(author=author)Note that the given step aliases are independent and will be executedwhen mentioned.For example if you associate your resource to some owner or not. Adminuser canâ€™t be an author of the article, but articles should have adefault author... code-block:: gherkin    Feature: Resource owner        Scenario: I'm the author            Given I'm an author            And I have an article        Scenario: I'm the admin            Given I'm the admin            And there's an articleLiberal step decorator----------------------Sometimes you want use same step for all types of steps without re-defining alias;this step could be used with any keyword:.. code-block:: python    from pytest_bdd import step    @step(&quot;I'm an author user&quot;, liberal=True)    def author_user(auth, author):        auth['user'] = author.userOther steps also could be used as wildcard steps without aliases:.. code-block:: python    from pytest_bdd import given    @given(&quot;I'm an author user&quot;, liberal=True)    def author_user(auth, author):        auth['user'] = author.userThis behavior could be set globally by defining `--liberal-steps` cli option or by `liberal_steps` pytest.ini optionSteps without keyword---------------------For the next feature:.. code-block:: gherkin    Feature: Resource owner        Scenario: I'm the author            * I'm an author            * I have an articleNext step definitions have to be used (or just use liberal steps):.. code-block:: python    from pytest_bdd import step    @step(&quot;I'm an author&quot;)    def author_user(auth, author):        auth['user'] = author.user    @step(&quot;I have an article&quot;)    def author_user(auth, article):        auth['article'] = articleStep arguments--------------Often it's possible to reuse steps giving them a parameter(s).This allows to have single implementation and multiple use, so less code.Also opens the possibility to use same step twice in single scenario and with different arguments!And even more, there are several types of step parameter parsers at your disposal(idea taken from behave_ implementation):.. _pypi_parse: http://pypi.python.org/pypi/parse.. _pypi_parse_type: http://pypi.python.org/pypi/parse_type**string** (the default)    This is the default and can be considered as a `null` or `exact` parser. It parses no parameters    and matches the step name by equality of strings.**parse** (based on: pypi_parse_)    Provides a simple parser that replaces regular expressions for    step parameters with a readable syntax like ``{param:Type}``.    The syntax is inspired by the Python builtin ``string.format()``    function.    Step parameters must use the named fields syntax of pypi_parse_    in step definitions. The named fields are extracted,    optionally type converted and then used as step function arguments.    Supports type conversions by using type converters passed via `extra_types`**cfparse** (extends: pypi_parse_, based on: pypi_parse_type_)    Provides an extended parser with &quot;Cardinality Field&quot; (CF) support.    Automatically creates missing type converters for related cardinality    as long as a type converter for cardinality=1 is provided.    Supports parse expressions like:    * ``{values:Type+}`` (cardinality=1..N, many)    * ``{values:Type*}`` (cardinality=0..N, many0)    * ``{value:Type?}``  (cardinality=0..1, optional)    Supports type conversions (as above).**re**    This uses full regular expressions to parse the clause text. You will    need to use named groups &quot;(?P&lt;name&gt;...)&quot; to define the variables pulled    from the text and passed to your ``step()`` function.    Type conversion can only be done via `converters` step decorator argument (see example below).The default parser is `string`, so just plain one-to-one match to the keyword definition.Parsers except `string`, as well as their optional arguments are specified like:for `cfparse` parser:.. code-block:: python    from pytest_bdd import parsers    @given(        parsers.cfparse(&quot;there are {start:Number} cucumbers&quot;,        extra_types=dict(Number=int)),        target_fixture=&quot;start_cucumbers&quot;,    )    def start_cucumbers(start):        return dict(start=start, eat=0)or the same:.. code-block:: python    from parse_type.cfparse import Parser as cfparse    @given(        cfparse(&quot;there are {start:Number} cucumbers&quot;,        extra_types=dict(Number=int)),        target_fixture=&quot;start_cucumbers&quot;,    )    def start_cucumbers(start):        return dict(start=start, eat=0)for `re` parser.. code-block:: python    from pytest_bdd import parsers    @given(        parsers.re(r&quot;there are (?P&lt;start&gt;\d+) cucumbers&quot;),        converters=dict(start=int),        target_fixture=&quot;start_cucumbers&quot;,    )    def start_cucumbers(start):        return dict(start=start, eat=0)or the same:.. code-block:: python    from re import compile as parse_re    @given(        parse_re(r&quot;there are (?P&lt;start&gt;\d+) cucumbers&quot;),        converters=dict(start=int),        target_fixture=&quot;start_cucumbers&quot;,    )    def start_cucumbers(start):        return dict(start=start, eat=0)Example:.. code-block:: gherkin    Feature: Step arguments        Scenario: Arguments for given, when, then            Given there are 5 cucumbers            When I eat 3 cucumbers            And I eat 2 cucumbers            Then I should have 0 cucumbersThe code will look like:.. code-block:: python    import re    from parse import Parser as parse    from pytest_bdd import scenario, given, when, then    @scenario(&quot;arguments.feature&quot;, &quot;Arguments for given, when, then&quot;)    def test_arguments():        pass    @given(parse(&quot;there are {start:d} cucumbers&quot;), target_fixture=&quot;start_cucumbers&quot;)    def start_cucumbers(start):        return dict(start=start, eat=0)    @when(parse(&quot;I eat {eat:d} cucumbers&quot;))    def eat_cucumbers(start_cucumbers, eat):        start_cucumbers[&quot;eat&quot;] += eat    @then(parse(&quot;I should have {left:d} cucumbers&quot;))    def should_have_left_cucumbers(start_cucumbers, start, left):        assert start_cucumbers['start'] == start        assert start - start_cucumbers['eat'] == leftExample code also shows possibility to pass argument converters which may be useful if you need to postprocess steparguments after the parser.You can implement your own step parser. It's interface is quite simple. The code can looks like:.. code-block:: python    import re    from pytest_bdd import given, parsers    class MyParser(parsers.StepParser):        &quot;&quot;&quot;Custom parser.&quot;&quot;&quot;        def __init__(self, name, **kwargs):            &quot;&quot;&quot;Compile regex.&quot;&quot;&quot;            super().__init__(name)            self.regex = re.compile(re.sub(&quot;%(.+)%&quot;, &quot;(?P&lt;\1&gt;.+)&quot;, self.name), **kwargs)        def parse_arguments(self, name):            &quot;&quot;&quot;Get step arguments.            :return: `dict` of step arguments            &quot;&quot;&quot;            return self.regex.match(name).groupdict()        def is_matching(self, name):            &quot;&quot;&quot;Match given name with the step name.&quot;&quot;&quot;            return bool(self.regex.match(name))    @given(parsers.parse(&quot;there are %start% cucumbers&quot;), target_fixture=&quot;start_cucumbers&quot;)    def start_cucumbers(start):        return dict(start=start, eat=0)Step arguments could be defined without parsing^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^If you want specify some default values for parameters without parsing them, you could do.. code-block:: python    @given(&quot;I have default defined param&quot;, param_defaults={'default_param': 'foo'}, target_fixture='foo_fixture')    def save_fixture(default_param):        return default_paramStep arguments are fixtures as well!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Step arguments are injected into pytest `request` context as normal fixtures with the names equal to the names of thearguments by default. This opens a number of possibilities:* you can access step's argument as a fixture in other step function just by mentioning it as an argument (just like any other pytest fixture)* if the name of the step argument clashes with existing fixture, it will be overridden by step's argument value; this way you can set/override the value for some fixture deeply inside of the fixture tree in a ad-hoc way by just choosing the proper name for the step argument.This behavior is same to:.. code-block:: python    @given('I have a &quot;{foo}&quot;, &quot;{bar}&quot;, &quot;{fizz}&quot;, &quot;{buzz}&quot; parameters few of which are accepted by wild pattern',        params_fixtures_mapping={...: ...})    def step(foo, bar, fizz, buzz):        ...But this behavior could be changed; For example you want to rename some parameters and left other as-is.. code-block:: python    @given('I have a &quot;{foo}&quot;, &quot;{bar}&quot;, &quot;{fizz}&quot;, &quot;{buzz}&quot; parameters few of which are accepted by wild pattern',               params_fixtures_mapping={'foo': 'cool_foo', 'bar': 'nice_bar', ...: ...})    def step(cool_foo, nice_bar, fizz, buzz):        ...Or don't inject parameters at all.. code-block:: python    @given('I have a &quot;{foo}&quot;, &quot;{bar}&quot;, &quot;{fizz}&quot;, &quot;{buzz}&quot; parameters few of which are accepted by wild pattern',               params_fixtures_mapping={...: None})    def step(foo, bar, fizz, buzz):        ...Parameters still could be used in steps, but they are not injected!If you would like to inject just some subset of parameters - set of parameters could be used:.. code-block:: python    @given('I have a &quot;{foo}&quot;, &quot;{bar}&quot;, &quot;{fizz}&quot;, &quot;{buzz}&quot; parameters few of which are accepted by wild pattern',               params_fixtures_mapping={'fizz', 'buzz'})    def step(foo, bar, fizz, buzz):        ...Override fixtures by outgoing step results------------------------------------------Dependency injection is not a panacea if you have complex structure of your test setup data. Sometimes there's a needsuch a given step which would imperatively change the fixture only for certain test (scenario), while for other testsit will stay untouched. To allow this, special parameter `target_fixture` exists in the decorator:.. code-block:: python    from pytest_bdd import given    @pytest.fixture    def foo():        return &quot;foo&quot;    @given(&quot;I have injecting given&quot;, target_fixture=&quot;foo&quot;)    def injecting_given():        return &quot;injected foo&quot;    @then('foo should be &quot;injected foo&quot;')    def foo_is_foo(foo):        assert foo == 'injected foo'.. code-block:: gherkin    Feature: Target fixture        Scenario: Test given fixture injection            Given I have injecting given            Then foo should be &quot;injected foo&quot;In this example existing fixture `foo` will be overridden by given step `I have injecting given` only for scenario it'sused in.Sometimes it is also useful to let `when` and `then` steps to provide a fixture as well.A common use case is when we have to assert the outcome of an HTTP request:.. code-block:: python    # test_blog.py    from pytest_bdd import scenarios, given, when, then    from my_app.models import Article    scenarios(&quot;blog.feature&quot;)    @given(&quot;there is an article&quot;, target_fixture=&quot;article&quot;)    def there_is_an_article():        return Article()    @when(&quot;I request the deletion of the article&quot;, target_fixture=&quot;request_result&quot;)    def there_should_be_a_new_article(article, http_client):        return http_client.delete(f&quot;/articles/{article.uid}&quot;)    @then(&quot;the request should be successful&quot;)    def article_is_published(request_result):        assert request_result.status_code == 200.. code-block:: gherkin    # blog.feature    Feature: Blog        Scenario: Deleting the article            Given there is an article            When I request the deletion of the article            Then the request should be successfulAlso it's possible to override multiple fixtures in one step using `target_fixtures` parameter:.. code-block:: python    @given(&quot;some compound fixture&quot;, target_fixtures=[&quot;fixture_a&quot;,&quot;fixture_b&quot;])    def __():        return &quot;fixture_a_value&quot;, &quot;fixture_b_value&quot;Multiline steps---------------**Note!** This possibility not a part of Gherkin standard and is supported for legacy parser. Let use Gherkin docstrings and custom step matcher.As Gherkin, pytest-bdd-ng supports multiline steps(aka `PyStrings &lt;http://behat.org/en/v3.0/user_guide/writing_scenarios.html#pystrings&gt;`_).But in much cleaner and powerful way:.. code-block:: gherkin    Feature: Multiline steps        Scenario: Multiline step using sub indentation            Given I have a step with:                Some                Extra                Lines            Then the text should be parsed with correct indentationStep is considered as multiline one, if the **next** line(s) after it's first line, is indented relativelyto the first line. The step name is then simply extended by adding further lines with newlines.In the example above, the Given step name will be:.. code-block:: python    'I have a step with:\nSome\nExtra\nLines'You can of course register step using full name (including the newlines), but it seems more practical to usestep arguments and capture lines after first line (or some subset of them) into the argument:.. code-block:: python    import re    from pytest_bdd import given, then, scenario, parsers    @scenario(        'multiline.feature',        'Multiline step using sub indentation',    )    def test_multiline():        pass    @given(parsers.parse(&quot;I have a step with:\n{text}&quot;), target_fixture=&quot;i_have_text&quot;)    def i_have_text(text):        return text    @then(&quot;the text should be parsed with correct indentation&quot;)    def text_should_be_correct(i_have_text, text):        assert i_have_text == text == 'Some\nExtra\nLines'Note that `then` step definition (`text_should_be_correct`) in this example uses `text` fixture which is providedby a `given` step (`i_have_text`) argument with the same name (`text`). This possibility is described inthe `Step arguments are fixtures as well!`_ section.Loading whole feature files---------------------------If you have relatively large set of feature files, it's boring to manually bind scenarios to the tests using thescenario decorator. Of course with the manual approach you get all the power to be able to additionally parametrizethe test, give the test function a nice name, document it, etc, but in the majority of the cases you don't need that.Instead you want to bind `all` scenarios found in the `feature` folder(s) recursively automatically.Scenarios shortcut^^^^^^^^^^^^^^^^^^First option is `scenarios` helper... code-block:: python    from pytest_bdd import scenarios    # assume 'features' subfolder is in this file's directory    scenarios('features')That's all you need to do to bind all scenarios found in the `features` folder!Note that you can pass multiple paths, and those paths can be either feature files or feature folders... code-block:: python    from pytest_bdd import scenarios    # pass multiple paths/files    scenarios('features', 'other_features/some.feature', 'some_other_features')But what if you need to manually bind certain scenario, leaving others to be automatically bound?Just write your scenario in a `normal` way, but ensure you do it `AFTER` the call of `scenarios` helper... code-block:: python    from pytest_bdd import scenario, scenarios    # assume 'features' subfolder is in this file's directory    scenarios('features')    @scenario('features/some.feature', 'Test something')    def test_something():        passIn the example above `test_something` scenario binding will be kept manual, other scenarios found in the `features`folder will be bound automatically.Scenarios registered by `scenario` or `scenarios` are registered once per test module (and re-registered bylatest inclusions, so keep it wisely).Both `scenario` or `scenarios` could be used as decorators or as operator calls. Also they could be inlined:.. code-block:: python    from pytest_bdd import scenario, scenarios    test_features = scenarios('features', return_test_decorator=False)    test_specific_scenario = scenario('features/some.feature', 'Test something', return_test_decorator=False)Features autoload^^^^^^^^^^^^^^^^^Another possibility to load features is usage of `--feature-autoload` cli option or `feature_autoload` ini option.In this case feature files (\*.gherkin or \*.feature) have to be stored in same structure as origin pytest tests.Steps from lower directory layers overriding higher ones if step parsing collision occurs.Test project layout part could be (pay attention to symlinks):::    features/        User login.feature        User creates order.feature    steps/        user/            given.py            when.py            then.py        order/            given.py            when.py            then.py        browser/            given.py            when.py            then.py        .../    tests/        conftest.py        integration/            conftest.py            User login.feature           # -&gt; ../../features/User login.feature            User creates order.feature   # -&gt; ../../features/User creates order.feature            ...        unit/            ...tests/conftest.py:.. code-block:: python    from steps.users.given import *    from steps.users.when import *    from steps.users.then import *    from steps.order.given import *    from steps.order.when import *    from steps.order.then import *    from steps.browser.given import *    from steps.browser.when import *    from steps.browser.then import *tests/integration/conftest.py:.. code-block:: python    # Other steps specific only for integration scenarios    ...Scenario outlines-----------------Scenarios can be parametrized to cover few cases. In Gherkin the variabletemplates are written using corner braces as ``&lt;somevalue&gt;``.`Gherkin scenario outlines &lt;http://behat.org/en/v3.0/user_guide/writing_scenarios.html#scenario-outlines&gt;`_ are supported by pytest-bddexactly as it's described in be behave_ docs.Example:.. code-block:: gherkin    Feature: Scenario outlines        Scenario Outline: Outlined given, when, then            Given there are &lt;start&gt; cucumbers            When I eat &lt;eat&gt; cucumbers            Then I should have &lt;left&gt; cucumbers            Examples:            | start | eat | left |            |  12   |  5  |  7   |pytest-bdd feature file format also supports example tables in different way:.. code-block:: gherkin    Feature: Scenario outlines        Scenario Outline: Outlined given, when, then            Given there are &lt;start&gt; cucumbers            When I eat &lt;eat&gt; cucumbers            Then I should have &lt;left&gt; cucumbers            Examples: Vertical            | start | 12 | 2 |            | eat   | 5  | 1 |            | left  | 7  | 1 |This form allows to have tables with lots of columns keeping the maximum text width predictable without significantreadability change.The code will look like:.. code-block:: python    from pytest_bdd import given, when, then, scenario, parsers    @scenario(        &quot;outline.feature&quot;,        &quot;Outlined given, when, then&quot;,    )    def test_outlined():        pass    @given(parsers.parse(&quot;there are {start:d} cucumbers&quot;), target_fixture=&quot;start_cucumbers&quot;)    def start_cucumbers(start):        assert isinstance(start, int)        return dict(start=start)    @when(parsers.parse(&quot;I eat {eat:g} cucumbers&quot;))    def eat_cucumbers(start_cucumbers, eat):        assert isinstance(eat, float)        start_cucumbers[&quot;eat&quot;] = eat    @then(parsers.parse(&quot;I should have {left} cucumbers&quot;))    def should_have_left_cucumbers(start_cucumbers, start, eat, left):        assert isinstance(left, str)        assert start - eat == int(left)        assert start_cucumbers[&quot;start&quot;] == start        assert start_cucumbers[&quot;eat&quot;] == eatExample code also shows possibility to pass example converters which may be useful if you need parameter typesdifferent than strings.Feature examples^^^^^^^^^^^^^^^^**Note!** This possibility not a part of Gherkin standard and is supported for legacy parser.It's possible to declare example table once for the whole feature, and it will be sharedamong all the scenarios of that feature:.. code-block:: gherkin    Feature: Outline        Examples:        | start | eat | left |        |  12   |  5  |  7   |        |  5    |  4  |  1   |        Scenario Outline: Eat cucumbers            Given there are &lt;start&gt; cucumbers            When I eat &lt;eat&gt; cucumbers            Then I should have &lt;left&gt; cucumbers        Scenario Outline: Eat apples            Given there are &lt;start&gt; apples            When I eat &lt;eat&gt; apples            Then I should have &lt;left&gt; applesFor some more complex case, you might want to parametrize on both levels: feature and scenario.This is allowed as long as parameter names do not clash:.. code-block:: gherkin    Feature: Outline        Examples:        | start | eat | left |        |  12   |  5  |  7   |        |  5    |  4  |  1   |        Scenario Outline: Eat fruits            Given there are &lt;start&gt; &lt;fruits&gt;            When I eat &lt;eat&gt; &lt;fruits&gt;            Then I should have &lt;left&gt; &lt;fruits&gt;            Examples:            | fruits  |            | oranges |            | apples  |        Scenario Outline: Eat vegetables            Given there are &lt;start&gt; &lt;vegetables&gt;            When I eat &lt;eat&gt; &lt;vegetables&gt;            Then I should have &lt;left&gt; &lt;vegetables&gt;            Examples:            | vegetables |            | carrots    |            | tomatoes   |To not repeat steps as in example above you could want store your data in sequent Examples sections:.. code-block:: gherkin    Feature: Outline        Examples:        | start | eat | left |        |  12   |  5  |  7   |        |  5    |  4  |  1   |        Scenario Outline: Eat food            Given there are &lt;start&gt; &lt;food&gt;            When I eat &lt;eat&gt; &lt;food&gt;            Then I should have &lt;left&gt; &lt;food&gt;            Examples: Fruits            | food    |            | oranges |            | apples  |            Examples: Vegetables            | food       |            | carrots    |            | tomatoes   |Organizing your scenarios-------------------------The more features and scenarios you have, the more important becomes the question about their organization.The things you can do (and that is also a recommended way):* organize your feature files in the folders by semantic groups:::    features    â”‚    â”œâ”€â”€frontend    â”‚  â”‚    â”‚  â””â”€â”€auth    â”‚     â”‚    â”‚     â””â”€â”€login.feature    â””â”€â”€backend       â”‚       â””â”€â”€auth          â”‚          â””â”€â”€login.featureThis looks fine, but how do you run tests only for certain feature?As pytest-bdd uses pytest, and bdd scenarios are actually normal tests. But test filesare separate from the feature files, the mapping is up to developers, so the test files structure can lookcompletely different:::    tests    â”‚    â””â”€â”€functional       â”‚       â””â”€â”€test_auth.py          â”‚          â”” &quot;&quot;&quot;Authentication tests.&quot;&quot;&quot;            from pytest_bdd import scenario            @scenario('frontend/auth/login.feature')            def test_logging_in_frontend():                pass            @scenario('backend/auth/login.feature')            def test_logging_in_backend():                passFor picking up tests to run we can use`tests selection &lt;http://pytest.org/latest/usage.html#specifying-tests-selecting-tests&gt;`_ technique. The problem is thatyou have to know how your tests are organized, knowing only the feature files organization is not enough.`cucumber tags &lt;https://github.com/cucumber/cucumber/wiki/Tags&gt;`_ introduce standard way of categorizing your featuresand scenarios, which pytest-bdd supports. For example, we could have:.. code-block:: gherkin    @login @backend    Feature: Login      @successful      Scenario: Successful loginpytest-bdd uses `pytest markers &lt;http://pytest.org/latest/mark.html#mark&gt;`_ as a `storage` of the tags for the givenscenario test, so we can use standard test selection:.. code-block:: bash    pytest -m &quot;backend and login and successful&quot;The feature and scenario markers are not different from standard pytest markers, and the ``@`` symbol is stripped outautomatically to allow test selector expressions. If you want to have bdd-related tags to be distinguishable from theother test markers, use prefix like `bdd`.Note that if you use pytest `--strict` option, all bdd tags mentioned in the feature files should be also in the`markers` setting of the `pytest.ini` config. Also for tags please use names which are python-compatible variablenames, eg starts with a non-number, underscore alphanumeric, etc. That way you can safely use tags for tests filtering.You can customize how tags are converted to pytest marks by implementing the``pytest_bdd_convert_tag_to_marks`` hook and returning list of resulting marks from it:.. code-block:: python   def pytest_bdd_convert_tag_to_marks(feature, scenario, tag):       if tag == 'todo':           marker = pytest.mark.skip(reason=&quot;Not implemented yet&quot;)           return [marker]Test setup----------Test setup is implemented within the Given section. Even though these stepsare executed imperatively to apply possible side-effects, pytest-bdd is tryingto benefit of the PyTest fixtures which is based on the dependency injectionand makes the setup more declarative style... code-block:: python    @given(&quot;I have a beautiful article&quot;, target_fixture=&quot;article&quot;)    def article():        return Article(is_beautiful=True)The target PyTest fixture &quot;article&quot; gets the return value and any other step can depend on it... code-block:: gherkin    Feature: The power of PyTest        Scenario: Symbolic name across steps            Given I have a beautiful article            When I publish this articleWhen step is referring the article to publish it... code-block:: python    @when(&quot;I publish this article&quot;)    def publish_article(article):        article.publish()Many other BDD toolkits operate a global context and put the side effects there.This makes it very difficult to implement the steps, because the dependenciesappear only as the side-effects in the run-time and not declared in the code.The publish article step has to trust that the article is already in the context,has to know the name of the attribute it is stored there, the type etc.In pytest-bdd you just declare an argument of the step function that it depends onand the PyTest will make sure to provide it.Still side effects can be applied in the imperative style by design of the BDD... code-block:: gherkin    Feature: News website        Scenario: Publishing an article            Given I have a beautiful article            And my article is publishedFunctional tests can reuse your fixture libraries created for the unit-tests and upgradethem by applying the side effects... code-block:: python    @pytest.fixture    def article():        return Article(is_beautiful=True)    @given(&quot;I have a beautiful article&quot;)    def i_have_a_beautiful_article(article):        pass    @given(&quot;my article is published&quot;)    def published_article(article):        article.publish()        return articleThis way side-effects were applied to our article and PyTest makes sure that allsteps that require the &quot;article&quot; fixture will receive the same object. The valueof the &quot;published_article&quot; and the &quot;article&quot; fixtures is the same object.Fixtures are evaluated only once within the PyTest scope and their values are cached.Backgrounds-----------It's often the case that to cover certain feature, you'll need multiple scenarios. And it's logical that thesetup for those scenarios will have some common parts (if not equal). For this, there are `backgrounds`.pytest-bdd implements `Gherkin backgrounds &lt;http://behat.org/en/v3.0/user_guide/writing_scenarios.html#backgrounds&gt;`_ forfeatures... code-block:: gherkin    Feature: Multiple site support      Background:        Given a global administrator named &quot;Greg&quot;        And a blog named &quot;Greg's anti-tax rants&quot;        And a customer named &quot;Wilson&quot;        And a blog named &quot;Expensive Therapy&quot; owned by &quot;Wilson&quot;      Scenario: Wilson posts to his own blog        Given I am logged in as Wilson        When I try to post to &quot;Expensive Therapy&quot;        Then I should see &quot;Your article was published.&quot;      Scenario: Greg posts to a client's blog        Given I am logged in as Greg        When I try to post to &quot;Expensive Therapy&quot;        Then I should see &quot;Your article was published.&quot;In this example, all steps from the background will be executed before all the scenario's own givensteps, adding possibility to prepare some common setup for multiple scenarios in a single feature.About background best practices, please read`here &lt;https://github.com/cucumber/cucumber/wiki/Background#good-practices-for-using-background&gt;`_... NOTE:: There is only step &quot;Given&quot; should be used in &quot;Background&quot; section,          steps &quot;When&quot; and &quot;Then&quot; are prohibited, because their purpose are          related to actions and consuming outcomes, that is conflict with          &quot;Background&quot; aim - prepare system for tests or &quot;put the system          in a known state&quot; as &quot;Given&quot; does it.          The statement above is applied for strict Gherkin mode, which is          enabled by default.Reusing fixtures----------------Sometimes scenarios define new names for the existing fixture that can beinherited (reused). For example, if we have pytest fixture:.. code-block:: python    @pytest.fixture    def article():       &quot;&quot;&quot;Test article.&quot;&quot;&quot;       return Article()Then this fixture can be reused with other names using given():.. code-block:: python    @given('I have beautiful article')    def i_have_an_article(article):       &quot;&quot;&quot;I have an article.&quot;&quot;&quot;Reusing steps-------------It is possible to define some common steps in the parent conftest.py andsimply expect them in the child test file.common_steps.feature:.. code-block:: gherkin    Scenario: All steps are declared in the conftest        Given I have a bar        Then bar should have value &quot;bar&quot;conftest.py:.. code-block:: python    from pytest_bdd import given, then    @given(&quot;I have a bar&quot;, target_fixture=&quot;bar&quot;)    def bar():        return &quot;bar&quot;    @then('bar should have value &quot;bar&quot;')    def bar_is_bar(bar):        assert bar == &quot;bar&quot;test_common.py:.. code-block:: python    @scenario(&quot;common_steps.feature&quot;, &quot;All steps are declared in the conftest&quot;)    def test_conftest():        passThere are no definitions of the steps in the test file. They werecollected from the parent conftest.py.Default steps-------------Here is the list of steps that are implemented inside of the pytest-bdd:given    * trace - enters the `pdb` debugger via `pytest.set_trace()`when    * trace - enters the `pdb` debugger via `pytest.set_trace()`then    * trace - enters the `pdb` debugger via `pytest.set_trace()`Feature file paths------------------By default, pytest-bdd will use current module's path as base path for finding feature files, but this behaviour can be changed in the pytest configuration file (i.e. `pytest.ini`, `tox.ini` or `setup.cfg`) by declaring the new base path in the `bdd_features_base_dir` key. The path is interpreted as relative to the working directory when starting pytest.You can also override features base path on a per-scenario basis, in order to override the path for specific tests.pytest.ini:.. code-block:: ini    [pytest]    bdd_features_base_dir = features/tests/test_publish_article.py:.. code-block:: python    from pytest_bdd import scenario    @scenario(&quot;foo.feature&quot;, &quot;Foo feature in features/foo.feature&quot;)    def test_foo():        pass    @scenario(        &quot;foo.feature&quot;,        &quot;Foo feature in tests/local-features/foo.feature&quot;,        features_base_dir=&quot;./local-features/&quot;,    )    def test_foo_local():        passThe `features_base_dir` parameter can also be passed to the `@scenario` decorator.Avoid retyping the feature file name------------------------------------If you want to avoid retyping the feature file name when defining your scenarios in a test file, use ``functools.partial``.This will make your life much easier when defining multiple scenarios in a test file. For example:test_publish_article.py:.. code-block:: python    from functools import partial    import pytest_bdd    scenario = partial(pytest_bdd.scenario, &quot;/path/to/publish_article.feature&quot;)    @scenario(&quot;Publishing the article&quot;)    def test_publish():        pass    @scenario(&quot;Publishing the article as unprivileged user&quot;)    def test_publish_unprivileged():        passYou can learn more about `functools.partial &lt;http://docs.python.org/2/library/functools.html#functools.partial&gt;`_in the Python docs.Localization------------pytest-bdd supports all localizations which Gherkin `does &lt;https://cucumber.io/docs/gherkin/languages/&gt;`_Hooks-----pytest-bdd exposes several `pytest hooks &lt;http://pytest.org/latest/plugins.html#well-specified-hooks&gt;`_which might be helpful building useful reporting, visualization, etc on top of it:* pytest_bdd_before_scenario(request, feature, scenario) - Called before scenario is executed* pytest_bdd_run_scenario(request, feature, scenario) - Execution scenario protocol* pytest_bdd_after_scenario(request, feature, scenario) - Called after scenario is executed  (even if one of steps has failed)* pytest_bdd_before_step(request, feature, scenario, step, step_func) - Called before step function  is executed and it's arguments evaluated* pytest_bdd_run_step(request, feature, scenario, step, previous_step) - Execution step protocol* pytest_bdd_before_step_call(request, feature, scenario, step, step_func, step_func_args) - Called before step  function is executed with evaluated arguments* pytest_bdd_after_step(request, feature, scenario, step, step_func, step_func_args) - Called after step function  is successfully executed* pytest_bdd_step_error(request, feature, scenario, step, step_func, step_func_args, exception) - Called when step  function failed to execute* pytest_bdd_step_func_lookup_error(request, feature, scenario, step, exception) - Called when step lookup failed* pytest_bdd_match_step_definition_to_step(request, feature, scenario, step, previous_step) - Called to match step to step definition* pytest_bdd_get_step_caller(request, feature, scenario, step, step_func, step_func_args, step_definition) - Called to get step caller. For example could be used to make steps async* pytest_bdd_get_step_dispatcher(request, feature, scenario) - Provide alternative approach to execute scenario stepsFixtures--------pytest-bdd exposes several plugin fixtures to give more testing flexibility* bdd_example - The current scenario outline parametrization.* step_registry - Contains registry of all user-defined steps* step_matcher- Contains matcher to help find step definition for selected step of scenario* steps_left - Current scenario steps left to execute; Allow inject steps to execute:.. code-block:: python    from collections import deque    from pytest_bdd.model import UserStep    from pytest_bdd import when    @when('I inject step &quot;{keyword}&quot; &quot;{step_text}')    def inject_step(steps_left: deque, keyword, step_text, scenario):        steps_left.appendleft(UserStep(text=step_text, keyword=keyword, scenario=scenario))StructBDD---------Gherkin itself isn't a perfect tool to describe complex Data Driven Scenarios with alternative paths to execute test.For example it doesn't support next things:* Few backgrounds per scenario* Alternative flows for scenario to setup same state* Alternative flows to describe same behavior defined by different steps* Usage of parameters inside Backgrounds* Joining of parameter tables, so full Cartesian product of parameters has to be listed in Examples* Example tables on different scenario levelsFor such scenarios StructBDD DSL was developed. It independent on underlying data format, but supports most commonformats for DSL development: YAML, Hocon, TOML, JSON5, HJSON out the box.Steps could be defined as usual, and scenarios have different options. Let see.steps.bdd.yaml.. code-block:: yaml    Name: Steps are executed one by one    Description: |        Steps are executed one by one. Given and When sections        are not mandatory in some cases.    Steps:        - Step:            Name: Executed step by step            Description: Scenario description            Steps:                - I have a foo fixture with value &quot;foo&quot;                - And: there is a list                - When: I append 1 to the list                - Step:                    Action: I append 2 to the list                    Type: And                - Alternative:                    - Step:                        Steps:                            - And: I append 3 to the list                            - Then: foo should have value &quot;foo&quot;                            - But: the list should be [1, 2, 3]                    - Step:                        Steps:                            - And: I append 4 to the list                            - Then: foo should have value &quot;foo&quot;                            - But: the list should be [1, 2, 4]Alternative steps produce separate test launches for every of flows. If alternative steps are defined on differentlevels - there would be Cartesian product of tests for every alternative step.Scenario could be imported as usual, but with specified parser:.. code-block:: python    from textwrap import dedent    from pytest_bdd import given, when, then, scenario    from pytest_bdd.parser import StructBDDParser    kind = StructBDDParser.KIND.YAML    @scenario(f&quot;steps.bdd.{kind}&quot;, &quot;Executed step by step&quot;, parser=StructBDDParser(kind=kind))    def test_steps(feature):        passAnother option is to inject built scenario directly:.. code-block:: python    from pytest_bdd.struct_bdd.model import Step, Table    step = Step(        name=&quot;Examples are substituted&quot;,        steps=[            Step(type='Given', action='I have &lt;have&gt; cucumbers'),            Step(type='And', action='I eat &lt;eat&gt; cucumbers'),            Step(type='Then', action='I have &lt;left&gt; cucumbers')        ],        examples=[            Table(                parameters=['have', 'eat', 'left'],                values=[                    ['12', 5, 7.0],                    [&quot;8.0&quot;, 3.0, &quot;5&quot;]                ]            )        ]    )    step.inject_test()There is also an option to build Step from dict(and use your own file format/preprocessor).. code-block:: python    from pytest_bdd.struct_bdd.model import Step    step = Step.from_dict(            dict(                Name=&quot;Examples are substituted&quot;,                Steps=[                    dict(Given='I have &lt;have&gt; cucumbers'),                    dict(And='I eat &lt;eat&gt; cucumbers'),                    dict(Then='I have &lt;left&gt; cucumbers')                ],                Examples=[                    dict(                        Table=dict(                            Parameters=['have', 'eat', 'left'],                            Values=[                                ['12', 5, 7.0],                                [&quot;8.0&quot;, 3.0, &quot;5&quot;]                            ]                        )                    )                ]            )        )    @step.build_test_decorator()    def test(feature:Feature, scenario):        assert feature.name == &quot;Examples are substituted&quot;Example tables could be joined:.. code-block:: yaml    Tags:      - TopTag    Name: StepName    Action: &quot;Do first &lt;HeaderA&gt;, &lt;HeaderB&gt;, &lt;HeaderC&gt;&quot;    Examples:      - Join:        - Table:            Tags:              - ExampleTagA            Parameters:              [ HeaderA, HeaderB ]            Values:              - [ A1, B1]              - [ A2, B2]        - Table:            Tags:              - ExampleTagB            Parameters:              [ HeaderB, HeaderC ]            Values:              - [ B1, C1 ]              - [ B2, C2 ]              - [ B3, C3 ]    Steps: []Install StructBDD:::    pip install pytest-bdd-ng[struct_bdd]Reporting---------It's important to have nice reporting out of your bdd tests. Cucumber introduced some kind of standard for`json format &lt;https://www.relishapp.com/cucumber/cucumber/docs/json-output-formatter&gt;`_which can be used for, for example, by `this &lt;https://plugins.jenkins.io/cucumber-testresult-plugin/&gt;`_ Jenkinsplugin.To have an output in json format:::    pytest --cucumberjson=&lt;path to json report&gt;This will output an expanded (meaning scenario outlines will be expanded to several scenarios) cucumber format.To enable gherkin-formatted output on terminal, use::    pytest --gherkin-terminal-reporterAllure reporting is also in place https://docs.qameta.io/allure and based on`allure-pytest` https://pypi.org/project/allure-pytest/ plugin. Usage is sameTo install plugin::    pip install pytest-bdd-ng[allure]Test code generation helpers----------------------------For newcomers it's sometimes hard to write all needed test code without being frustrated.To simplify their life, simple code generator was implemented. It allows to create fully functionalbut of course empty tests and step definitions for given a feature file.It's done as a separate console script provided by pytest-bdd package:::    pytest-bdd generate &lt;feature file name&gt; .. &lt;feature file nameN&gt;It will print the generated code to the standard output so you can easily redirect it to the file:::    pytest-bdd generate features/some.feature &gt; tests/functional/test_some.pyAdvanced code generation------------------------For more experienced users, there's smart code generation/suggestion feature. It will only generate thetest code which is not yet there, checking existing tests and step definitions the same way it's done during thetest execution. The code suggestion tool is called via passing additional pytest arguments:::    pytest --generate-missing --feature features tests/functionalThe output will be like:::    ============================= test session starts ==============================    platform linux2 -- Python 2.7.6 -- py-1.4.24 -- pytest-2.6.2    plugins: xdist, pep8, cov, cache, bdd, bdd, bdd    collected 2 items    Scenario is not bound to any test: &quot;Code is generated for scenarios which are not bound to any tests&quot; in feature &quot;Missing code generation&quot; in /tmp/pytest-552/testdir/test_generate_missing0/tests/generation.feature    --------------------------------------------------------------------------------    Step is not defined: &quot;I have a custom bar&quot; in scenario: &quot;Code is generated for scenario steps which are not yet defined(implemented)&quot; in feature &quot;Missing code generation&quot; in /tmp/pytest-552/testdir/test_generate_missing0/tests/generation.feature    --------------------------------------------------------------------------------    Please place the code above to the test file(s):    @scenario('tests/generation.feature', 'Code is generated for scenarios which are not bound to any tests')    def test_Code_is_generated_for_scenarios_which_are_not_bound_to_any_tests():        &quot;&quot;&quot;Code is generated for scenarios which are not bound to any tests.&quot;&quot;&quot;    @given(&quot;I have a custom bar&quot;)    def I_have_a_custom_bar():        &quot;&quot;&quot;I have a custom bar.&quot;&quot;&quot;As as side effect, the tool will validate the files for format errors, also some of the logic bugs, for example theordering of the types of the steps.License-------This software is licensed under the `MIT license &lt;http://en.wikipedia.org/wiki/MIT_License&gt;`_.Â© 2013-2022 Oleg Pidsadnyi, Anatoly Bubenkov, Konstantin Goloveshko and othersAuthors=======`Oleg Pidsadnyi &lt;oleg.pidsadnyi@gmail.com&gt;`_    original idea, initial implementation and further improvements`Anatoly Bubenkov &lt;bubenkoff@gmail.com&gt;`_    key implementation idea and realization, many new features and improvementsThese people have contributed to `pytest-bdd`, in alphabetical order:* `Adam Coddington &lt;me@adamcoddington.net&gt;`_* `Albert-Jan Nijburg &lt;albertjan@curit.com&gt;`_* `Alessio Bogon &lt;youtux&gt;`_* `Andrey Makhnach &lt;andrey.makhnach@gmail.com&gt;`_* `Aron Curzon &lt;curzona@gmail.com&gt;`_* `Dmitrijs Milajevs &lt;dimazest@gmail.com&gt;`_* `Dmitry Kolyagin &lt;pauk-slon&gt;`_* `Florian Bruhin &lt;me@the-compiler.org&gt;`_* `Floris Bruynooghe &lt;flub@devork.be&gt;`_* `Harro van der Klauw &lt;hvdklauw@gmail.com&gt;`_* `Hugo van Kemenade &lt;https://github.com/hugovk&gt;`_* `Konstantin Goloveshko &lt;kostya.goloveshko@gmail.com&gt;`_* `Laurence Rowe &lt;l@lrowe.co.uk&gt;`_* `Leonardo Santagada &lt;santagada@github.com&gt;`_* `Milosz Sliwinski &lt;sliwinski-milosz&gt;`_* `Michiel Holtkamp &lt;github@elfstone.nl&gt;`_* `Robin Pedersen &lt;ropez@github.com&gt;`_* `Sergey Kraynev &lt;sergejyit@gmail.com&gt;`_</longdescription>
</pkgmetadata>