<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># the Caching, Highly-Available Postfix Policy Service| **requires Python 3.8.10+**| **makes use of Redis (or Sentinel) and a relational database (MariaDB)**## IntroductionThere is a need for a highly-available, high-performance, concurrent,clusterable solution for handling various aspects of email policy.Postfix farms out the job of policy decisions to a delegate over asocket, so we can provide a framework for receiving that data, makinga decision about it, and then sending a response back to Postfix.There are some projects which have provided smaller-scale solutions tothis issue.  We handle rather a large volume of email, so we needsomething more performant than a script which makes a database accesson every email.  In order to simplify the language, the term &quot;customer&quot;is used herein to mean a person who logs into an SMTP server in orderto send email.My decision was to use Redis, since with Redis Sentinel it should bepossible to achieve a degree of high-availability using Redis as acommon datastore between the various email servers in the farm(s)which will run local instances of the policy server, which will itselfuse Redis to cache data and keep track of email quotas, etc.In the first iteration, we propose to provide functionality for: - outbound quota tracking on a continuous, rolling, per-interval basis; - outbound sender domain authorization - inbound email greylisting; - inbound SPF checkingThe framework is meant to be extensible, so that any conceivable emailpolicy might be implemented in the future.## ConfigurationThe library will create a config file for itself if it does not find oneat its default config path, `/etc/chapps/chapps.ini`, or the value ofthe environment variable `CHAPPS_CONFIG` if it is set.  Note thatdefault settings for all available submodules will be produced.  Atthe time of writing, each script runs its own type of policy handler,so only the settings for the policies of that handler will be needed,plus the general CHAPPS settings and the Redis settings.It is possible to adjust the number of connections allowed to bewaiting on the CHAPPS server to answer them.  The default used by`asyncio` when none is provided is 100, so that is also the defaultvalue used by CHAPPS.  It may be adjusted in the config file under`[CHAPPS]`, and is called `listener_backlog`.  In some cases it may bedesirable to increase that number, so that exceptionally busy mailersdo not run into the problem of having their connection attemptsrejected.Policies may each specify separate listening addresses and ports, sothat they may run simultaneously on the same server.  For multi-policyhandlers, the first handler specified will be the one whose networksettings are used.  It is recommended to configure those elements onlyon that policy, or to keep them in sync on all policies which arehandled together.Example Postfix configs are included in the `postfix` directory,classified by which service they are for.  Most access control policyservices will be implemented in a very similar way in `main.cf`,probably in combination with other policies.  The examples providedare the same configs used for testing, and are necessarily strippeddown to focus just on that particular service.An example **rsyslog** config is also included; modification isencouraged.  If you wish to keep the debug logs in their specialdestination, ensure that you create a log-rotation profile for it.## Installation OverviewThe recommended Debian packages are:  - `mysqlclient`  - `redis`  - `python3-pip`  - `python3-venv`It is highly recommended to install CHAPPS into a venv.  You may needto install the system package `python3-venv` in order for this towork:```python3 -m venv chapps-venv. chapps-venv/bin/activate```The package may be installed via PyPI, using the following command:```python3 -m pip install chapps```### DB InitializationAs of this writing, it should be possible to run `apply-migrations` or`chapps-cli admin db-setup` once the venv is activated, and that shouldapply all of the necessary Alembic migrations to bring the database upto date from zero, based on the database access configuration in theCHAPPS config file.If the config file has not yet been populated with databasecredentials, do that first, and ensure that the named database exists(has been created) on the database server before attempting to installthe schema into it.**Please Note:**Databases created with earlier versions of CHAPPS (v&lt;=0.4.12) need tohave their data dumped to SQL, and the database dropped and the schemare-created via the `apply-migrations` mechanism in order for it to exactlymatch Alembic's notion of how it is built.  Once Alembic has built theschema, the data may be read back into the database.  We will be usingAlembic going forward so this should be a one-time annoyance.For convenience, here is the `mysqldump` commandline recommended fordumping the data:.. code:    mysqldump --skip-add-drop-table -tc chapps &gt; chapps-data-only.sqlThese options tell `mysqldump` not to drop the tables, not to try to createthe tables, and to use &quot;complete&quot; INSERT statements, which ensures that thetarget columns are listed in the INSERT statement, in case the native columnorder changes between dump and restore.#### Database AdaptersIn order to obtain control data from the database, CHAPPS policyobjects use a database adapter object tailored for their specificneeds.  This allows all database logic to be factored completely outof the policy layer.As of CHAPPS v0.5.5, the database adapter layer is now based onSQLAlchemy throughout.  However, it is still possible to switch tousing the MariaDB adapter instead, for the actual services.  The APIis built on SQLAlchemy and requires it.**To set CHAPPS to use MySQL/MariaDB** directly, instead ofSQLAlchemy, set the environment variable `CHAPPS_DB_MODULE` to`mysql`.  Doing so will cause the policy layer to use the adaptermodule based on `mysqlclient`, which also works just fine withMariaDB.  If it is not set or is set to something else, SQLAlchemywill be used.  This will need to be specified in the servicedescription file to take effect, unless some other method is beingused to launch CHAPPS.The ability to switch database adapter modules may be eliminated in afuture release.  However, since the application has not been tested inproduction using SQLAlchemy, it seems prudent to provide a mechanismfor switching between them.### Starting and Auto-launching ServicesWith a venv, the SystemD service files are installed to a foldercalled `chapps/install` inside the venv directory, and Postfixexample/testing configs are located in the `chapps/postfix` folder.  Scriptsand package go to `bin` and `lib/.../chapps` as expected.  Use of avenv is recommended, as the SystemD service description files providedare formatted during the install process to launch the services correctlywithin their venv.Without a venv, they go to various system locations,with the ancillary `chapps` directory usually showing up at`/usr/local/chapps`.  YMMV.  A venv will keep things organized.A Python script called `chapps_database_init.py` is includedto create the database schema required by the library.  Itdoes not create the database itself.  Before running this script,ensure that the CHAPPS configuration file contains the correctcredentials and other control data to be able to connect to thedatabase server, and also ensure that the database named in thatconfig has been created on the server.  The script will connect to thedatabase and create the tables.  It uses `IF EXISTS` and does notcontain any kind of data deletion, so it should be safe to use at anytime.For more information about installing, see the[INSTALLATION](INSTALLATION.md) file.### Redis configurationRedis is used to store the real-time state of every active user'soutbound quota, sender-domain authorization status cache, and also tokeep track of greylisting status for greylisted emails.  An activeuser is one who has sent email in the last _interval_, that intervaldefaulting to a day, since most quotas are expressed asmessages-per-day.If your Redis deployment is on a different server and/or if CHAPPS issharing a Redis instance with some other services it may be necessaryto adjust the Redis-related settings in the config file, to adjust theaddress and/or port to connect to, or what database to use.  Bydefault, CHAPPS tries to connect to Redis on localhost, using thestandard port assignment and db 0.If Sentinel is in use, populate the Sentinel-oriented configurationelements `sentinel_servers` and `sentinel_dataset`.  The servers listshould be a space-separated list of each Sentinel server half-socket;for example, &quot;10.1.9.10:26379 10.1.9.12:26379&quot;.  The dataset name isthe one you specified to Sentinel when setting up the Sentinelcluster.  Sentinel's default dataset name is `mymaster`.  We, ofcourse, recommend `chapps`, or perhaps `chapps-outbound` at a sitewith a large volume of email.  Since SPF doesn't make much use ofRedis, the inbound load may be lighter than the outbound load,depending on which things happen more at a particular site.### LoggingAt this time, CHAPPS uses **syslog**, and transmits logs on the`local0` facility.  CHAPPS sends a fair amount of debug information atthe DEBUG level.  Right now, the application's facility and level maynot be adjusted via the config file; later this may be implemented.For the time being, it seems sufficient to control logging via the**rsyslog** configuration used to control log entries on `local0`.The example provided (in the `install` directory) sends all logs to aspecial log (the path needs to exist and belong to the syslog user,whether that be `syslog` (as on Ubuntu) or `root` under Debian).  Aslong as the path exists and is writable by **rsyslog**, it will createthe log.  The example also sends logs at INFO level or above to`/var/log/mail.log`, which generally is the destination that**rsyslog** uses for mail-related logs.Of course, site operators are encouraged to alter this example configto their needs.  For those who wish to monkeypatch facility and level,it is set in one place, at the top of `chapps.logging`.## REST API ServiceStarting with version 0.4.0, a REST API service is included, based onFastAPI, and using SQLAlchemy with the MySQLclient backend.  A servicetemplate for the API is provided, as well as a socket unit and an**nginx** example config, for using a UDS to proxy between the web andthe application.  By default, Gunicorn is used to launch Uvicornworkers which serve the API directly on port 8080.  The precisedetails may be adjusted in the `chapps-api-gunicorn.service` unitfile.It is also possible that other approaches are preferred at other sites.The extra files, provided in the `install` directory, are provided inthe hope that they may be useful.The API is self-documenting.  Once it is running, visit it at`&lt;server&gt;:8080/redoc/` or `&lt;server&gt;:8080/docs/` to browse thedocumentation.The API service needs to have the same configuration as the otherCHAPPS services it is meant to manage.  Since it instantiates policyobjects, it is best to simply provide the same copy of the config toall related nodes.  Please note that the API service is completelyseparate from the policy service(s), and need not run on the sameserver -- and in fact probably _should_ not run on the same server --with the policy service.## Outbound ServicesPolicy services can be divided into those which work on outbound mail,and those which work on inbound mail.  Some, possibly, might beapplied to either flow, but none such are part of this project yet.Outbound items share some characteristics.Outbound mail, for our purposes, is assumed to originate with anauthenticated user.  That user may authenticate with Postfix using ausername/password or a client-side SSL cert, in which case theusername or subject name (of the cert) will be passed along by Postfixto the policy service.In order to allow sites to specify exactly what field of the Postfixpolicy data they would like to use to identify users, theconfiguration allows the user to specify the first field to check.### Setting the user keyPostfix submits a fairly large packet of data on each policydelegation request.  One prominent element of this data is the MAILFROM address, which is labelled as `sender`.  This is perhaps theobvious element to use to count quotas, but some other fields are moreinteresting.Current versions of the software allow the config file to specify whatelement of that delegation request payload to use, defaulting to`sasl_username`.  This is because when customers use a password authprocess, the `sasl_username` corresponds to the customer whoseemail quota is being checked.  In certain circumstances (whenauthentication fails), the `sasl_username` field is blank.  Sincev0.3.11, when we find it blank we attribute that to authenticationfailure, and we provide some extra config elements to control thisbehavior.If the config key `require_user_key` is set to **True**, then only thekey specified in `user_key` will be checked for contents to identifythe customer, and if it is empty, an `AuthenticationFailedException`will be raised, which will cause the `no_user_key_response` to be sentback via Postfix.  If `require_user_key` is **False**, then a seriesof fields will be searched as outlined below.At present, there is little sanitation on the `user_key` field.  It isnever evaluated as code, but it is used directly as the attribute namefor the value dereference.  If that yields no value, or if it is notspecified, CHAPPS looks for `sasl_username` first, then`ccert_subject`, and if there is none, it falls back to `sender`,which can also be blank. In that extreme case, CHAPPS uses`client_address`.  This will not work very well long-term if a lot ofreal customers share a mail gateway, so it is recommended to make surethat the field specified is being populated.Incidentally, this may be a reason for permitting customers whichdon't appear in the user-list, since system-generated messages whichdon't have a `sender` listed will end up quota'd on their clientaddress, and probably most of them will be denied by quota,potentially generating a large number of confusing secondary errormessages.  CHAPPS currently expects any permitted sender to appear inthe `users` table.  Note that the name which appears in this tableneeds to match what will be discovered in the specified key field.For sites which use the customer's email address as their login namefor email access, this is easy.  For cert issuers, it may simplifythings to use the email address as the subject of the cert, but anyunique string will work.## Outbound Quota Policy ServiceThe service is designed to run locally side-by-side with the Postfixserver, and connect to a Redis instance, optionally via Sentinel.  Assuch it listens on 127.0.0.1, and on port 10225 by default, thoughboth may be adjusted in the config file.  It obtains quota policy dataon a per-customer basis, from a relational database, and caches thatdata in Redis for operational use.  Once a user's quota data has beenstored, it will be cached for a day, so that database accesses may beavoided.Current quota usage is **not** kept in a relational database.There is CLI access to data about current quota usage, providingfacilities for updating quota policy information immediately: clearingquotas, upgrading them, adding new users, adding new quotas, etc.,along with a number of other useful functions.  The CLI, `chapps-cli`,is self-documenting.There is also a REST API service which can perform any of these tasks,using cURL or similar.In order to set up Postfix for policy delegation, consult [Postfixdocumentation](http://www.postfix.org/SMTPD_POLICY_README.html) togain a complete understanding of how policy delegation works.  Inshort, the `smtpd_recipient_restrictions` block should contain thesetting `check_policy_service inet:127.0.0.1:10225`.  In addition, itis necessary to ensure that the service itself, the script`chapps_outbound_quota.py` or `chapps_outbound_multi.py` is running.This should be accomplishedusing SystemD or similar; scripts/unit file assets to assist with thatare to be found in the `install` directory.  (For now, according tocurrent wisdom, Postfix's own `spawn` functionality from `master.cf`should be avoided.)### Outbound Quota Policy Configuration: Database SetupAt present, the service expects to obtain quota policy enforcementparameters from a relational database (MySQL or MariaDB).  Theframework has been designed to make it easy to write adapters to anyparticular backend datasource regarding quota information.As of CHAPPS v0.4.13, Alembic is used to maintain the database schemaas it mutates across versions.  [See above](#db-initialization) foradvice related to software upgrades and database migrations.The database schema used has been kept as simple as possible: (pleasenote that this schema may differ slightly in terms of index and keynames from the one installed by Alembic)```CREATE TABLE `users` (  `id` bigint(20) NOT NULL AUTO_INCREMENT,  `name` varchar(128) NOT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `name` (`name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;CREATE TABLE `quotas` (  `id` bigint(20) NOT NULL AUTO_INCREMENT,  `name` varchar(32) NOT NULL,  `quota` bigint(20) NOT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `name` (`name`),  UNIQUE KEY `quota` (`quota`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;CREATE TABLE `quota_user` (  `quota_id` bigint(20) NOT NULL,  `user_id` bigint(20) NOT NULL,  PRIMARY KEY (`user_id`)  KEY `fk_quota` (`quota_id`),  CONSTRAINT `fk_quota_user` FOREIGN KEY (`quota_id`) REFERENCES `quotas` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,  CONSTRAINT `fk_user_quota` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;```The `users` table contains a record for each authorized customer whois allowed to send email.  Customers without entries will not be ableto send email, despite authenticating with Postfix.The `quotas` table contains quota definitions, the `name` is meant tohold a user-readable tag for the quota and max outbound email count(`quota`) of that quota.The `quota_user` table joins the `users` table with the `quotas`table.  The `quota_user.user_id` column joins with `users.id` to mapusernames onto IDs.  Usernames may be email addresses, but they alsomay not.  How they are obtained is configurable as `user_key` -- thespecified field will be extracted from the policy request payloadpresented by Postfix.Once the `quotas` table has been populated with the desired quotapolicies, the `quota_user` table may then be populated to reflect eachuser's quota.The application sets cached quota limit data to expire after 24 hours,so it will occasionally refresh quota policy settings, in case theyget changed.  In order to flush the quota information, all that isrequired is to delete that user's policy tracking data from Redis.Routes for doing so are provided by the REST API.**Please note:** Customers with no `users` entry will not be able to sendoutbound email.### Quota policy settings (non-database)#### Counting all outbound messages against the quotaSome quota systems count any email as a single email regardless of thenumber of recipients included in the envelope recipients list(RCPT&amp;nbsp;TO).  This software can operate that way, but it can alsocount an email for each recipient in the list.  Whether it does so isgoverned by the boolean setting `counting_recipients`: setting this toTrue will cause CHAPPS OutboundQuotaPolicy to count a sent email foreach recipient.#### Outbound quota grace marginsThere is a `margin` setting which will allow for some fuzziness overthe established quota for multi-recipient emails, allowing a customerto go over their quota on a single (multi-recipient) email as long asthe total number of mails sent fits within the margin.  This obviouslyhas no meaning if recipients aren't being counted, since no email willever represent more than a single outbound message.Margins specified in **integers** are absolute message counts.Those specified as **floats** represent a proportion of the totalmargin.  If a float value is less than 1 it is assumed to be theratio.  If it is larger than 1 and less than 100, it is assumed to bea percentage, and it divided by 100.0 is used as the ratio.## Sender Domain Authorization (Outbound multi-policy service)As of CHAPPS v0.4.12 , sender-domain authorization (SDA) is onlyavailable as part of the outbound multi-policy service, consisting ofSDA followed by outbound quota.  There is a plan (TODO:) to produce astandalone SDA service script.The SDA policy allows an email service provider to specify on aper-customer basis exactly which domains may appear after the @ in theMAIL FROM address, the `sender` field in the Postfix policy delegationdata packet.  Customer identification for outbound emails is coveredin a previous section of this document (see: ['Setting the userkey'](#setting-the-user-key)).It is generally possible to configure vanilla Postfix to limitoutbound domains for users, but we encountered some difficulty gettingit to work reliably, and this method opens the door to a great deal ofadditional nuance which would not otherwise be available to us.CHAPPS stores SDA policy control data in its database, in a fairlysimple, normalized scheme.  This feature uses a table each to storesource domains and email addresses, and a new join table for each tolink customers with domains and whole-email addresses they are allowed touse for outbound mail.The domain matching is intentionally inflexible -- theentire string after the @ sign must match a domain in the table.  Thatis to say: in order to allow users to send from subdomains, thosesubdomains must have entries in the domains table, and those entriesmust be linked to the logged-in (email-sending) customer via the`domain_user` join table.Here is the schema, for reference: (please note that this schema maydiffer slightly in terms of index and key names from the one installedby Alembic)```CREATE TABLE `domains` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(64) NOT NULL,  `greylist` tinyint(1) NOT NULL,  `check_spf` tinyint(1) NOT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `ix_domains_name` (`name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;CREATE TABLE `domain_user` (  `domain_id` bigint(20) NOT NULL,  `user_id` bigint(20) NOT NULL,  PRIMARY KEY (`domain_id`,`user_id`),  KEY `fk_user_domain` (`user_id`),  CONSTRAINT `fk_domain_user`    FOREIGN KEY (`domain_id`) REFERENCES `domains` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,  CONSTRAINT `fk_user_domain`    FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;CREATE TABLE `emails` (  `id` bigint(20) NOT NULL AUTO_INCREMENT,  `name` varchar(128) NOT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `name` (`name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;CREATE TABLE `email_user` (  `email_id` bigint(20) NOT NULL,  `user_id` bigint(20) NOT NULL,  PRIMARY KEY (`email_id`,`user_id`),  KEY `fk_user_email` (`user_id`),  CONSTRAINT `fk_email` FOREIGN KEY (`email_id`) REFERENCES `emails` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,  CONSTRAINT `fk_user_email` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;```As with the quota policy, the logic used is inherently conservative.If a customer has no entry in the `users` table, that customer willnot be able to send mail (even though they have authenticated).  If acustomer is trying to send an email from an address (the `sender`address) which has a domain string (everything after the @ sign) whichdoes not appear in the `domains` table, or for which that user lacks ajoin record in `domain_user`, the email will be denied.In practice, this will mean that when a new customer signs up,the domain(s) included in that service agreement should be added tothe `domains` table.  Any users which are authorized to send emailappearing to originate from that domain should be added to the `users`table, with join records linking their IDs to the IDs of the domain(s)they can send for, in `domain_user`.### Whole-Email MatchingAs a fallback to domain authorization, the SDA module also comparesthe entire `sender` field with the whole-email entries associated tothe user.  This allows an email provider to specify specific emailaddresses which may be used for outbound masquerading.  This helps toprevent customers from pretending to be other customers, and helps tocreate a specification for possible scanning tools which mightotherwise react negatively to the logs of such activity.TODO: Currently, CHAPPS causes cached policy data to have an expirytimer of a day.  For outbound quota, this makes a great deal of sensebecause the quotas are expressed in emails per day.  However, a day'sworth of authorized email senders' Redis cache keys may actually causequite a bit of memory usage for no particular reason.  Users don'tsend an evenly-spaced stream of email throughout the day; they sendsome emails, often in clusters, separated by long pauses.  As such,the expiry time of SDA Redis caches should probably be a tunableparameter, in order to allow operators to tune how much RAM on theirRedis servers ends up devoted to SDA caching.  6 or 8 hours seems likea reasonable trade-off between Redis-RAM bloat and RDBMS latency, butdifferent sites are different.## Inbound ServicesFor inbound services, it is possible to enable either policy on aper-domain basis.  This may be accomplished via the CLI or API.### HELO WhitelistingSometimes CHAPPS may not be the first line of defense for all email;it is possible that most email needs policy enforcement, but that someparticular relay(s) already do the same job as CHAPPS, and so whateverthey relay should be whitelisted.  In such a case, the relay willprobably always fail SPF anyway, and result in a header to thateffect.In order to whitelist by **HELO**, specify the `helo_whitelist` option inthe `[CHAPPS]` section of the config file, with data about the serverto whitelist.  Due to some limitations of ConfigParser, the dataneeds to be packed into a list on a single line.  The format is asfollows:```helo_whitelist=mx.example.com[:1.2.3.4][;mx2.example.com[:5.6.7.8][;...]]```To break this down in English, provide at a minimum the HELO name usedby the server to whitelist.  In such a case, the IP will be obtainedfrom DNS and used as if it had also been supplied.  In order to supplythe IP address of the server, use a colon (`:`) after the name.  Inorder to list more than one name (optionally with IP address), usesemi-colons (`;`) to separate entries.At configuration time, the A record will be evaluated to see if itmatches the IP provided.  The PTR of the IP, whether provided orobtained by a lookup, will be obtained as well, and checked to makesure the provided name matches.  If all the elements do not match,CHAPPS will log an error and will not perform any whitelisting.Currently, if the address provided is the loopback address&quot;127.0.0.1&quot;, then no DNS lookups will be performed, and both name andaddress values will be used without any checking or cross-checking.In future versions this logic could be expanded to include all&quot;private&quot; IPv4 address ranges, v6 ranges, etc.## Greylisting Policy ServiceGreylisting is an [approach to spamprevention](https://en.wikipedia.org/wiki/Greylisting_(email)) basedon the tendency of spammers to emit emails without using gateways.Spam is typically sent _to_ one or more gateways by malware programswhich amount to viral MUAs, able to connect to SMTP servers to sendmail, but not capable of noting response codes and retrying deferreddeliveries.  Because a large proportion of spam is (or was) sent thisway, the simple act of deferring emails from unknown (untrusted)sources eliminates a large amount of spam.CHAPPS can, on a per-domain, opt-in basis, perform [RCPT or DATAgreylisting](https://datatracker.ietf.org/doc/html/rfc6647#section-2.4)at present, since it wants to use the sender's email address and IPaddress as well as the recipient list.  CHAPPS is written to expect tobe invoked during the RCPT phase, but should work in the DATA phase.That has not been tested.Emails addressed to enforcing domains will be greylisted--that is,deferred--when they are associated with source tuples which are notrecognized.  Tracking data regarding recognized tuples and domainoption setting is stored in Redis.  Config data regarding optionstatus is obtained from the database and cached in Redis.  Domainswhich do not set the `greylist` bit on their records will receive allmail addressed to them immediately, without any greylisting.The Greylisting module performs whitelisting at its own level, basedon a tally of successfully delivered deferred emails.  That is to say,emails which have been deferred and then redelivered on the requiredschedule are counted in a tally per-client (by source IP address).When that tally reaches 10, further emails with matching source IPsare whitelisted.  This threshhold may be adjusted in the`GreylistingPolicy` config, as `whitelist_threshold`.Please note that in the context of comprehensive inbound emailfiltering, SPF and greylisting have an interesting relationship whichis not entirely straightforward, and so a special combined, inboundmulti-policy service has been provided which combines the features ofgreylisting and SPF checking in a sane fashion, and provides aframework for adding further policies.## SPF Policy EnforcementThe [Sender PolicyFramework](https://en.wikipedia.org/wiki/Sender_Policy_Framework) is acomplicated and intricate beast, and so I will not try to describe itin great detail, but instead link to relevant documentation about whatSPF is.  Important to note is the fact that SPF is a framework forusing the DNS as the policy configuration source.There is no provision in the RFC for the caching of SPF results inorder to apply them to other circumstances, such as another email withthe same inputs.  It is possible that the policy itself, i.e. the TXTrecord containing the SPF policy string, could change between emails.As such, this module does not use Redis to cache operational data.Redis is used to cache the per-domain SPF-enablement option.There is a very widely-used and well-supported implementation of theSPF check itself in the Python community called[pyspf](https://pypi.org/project/pyspf/), by Stuart Gathman andTerence Way.  CHAPPS uses this library to get SPF check results.The SPF policy enforcement framework included in CHAPPS makes itpossible for an operator to specify clearly and flexibly what theywould like to have happen in response to any of the different SPFcheck results.  The [SPF specification in RFC7208](https://datatracker.ietf.org/doc/html/rfc7208) does not addressexactly what response to take in each case, saying that it is a site'sprerogative to decide the fates of those emails.Domains must opt-in to SPF checking, just as with Greylisting.Domains which opt out of both will simply receive all email addressedto them without any SPF checking or Greylisting.There is no standalone SPF service; it is part of the multipolicyinbound service.  It would be trivial to create a standalone SPFservice.  Since we intend to provide both options to our customers,creating a standalone service is a low priority.  **Please note** thatas with Greylisting, the domain-level option will be honored even bystandalone handlers, meaning that in order for a domain's incomingemail to have SPF enforced, that option will still need to be set onits record.## Inbound Multi-policy Service (SPF + Greylisting)**Please note that blanket use of Greylisting is not recommended.**What does it mean to use both greylisting and SPF?  The trivial answeris to pass one filter, and then pass the next filter.  But which comesfirst?If one greylists first, a legitimate email may be deferred for tenminutes, then pass SPF checking; should emails which pass SPF besubject to greylisting?  Conversely, a greylisted email may also comefrom a server which is not allowed by its SPF record, and then bedeferred only to be denied for an unrelated reason after ten minutesof taking up disk space and using up cycles needlessly.On the other hand, if one uses an SPF filter first, in a trivialfashion, then emails must pass muster on the SPF check first, whichseems right and proper to me, certainly.  And if greylisting is to beused also, then it makes sense for emails which get `pass` from SPF tobe deferred.  When they are sent again they will of course incuranother SPF check, and then they will pass greylisting, provided thatthe SPF record they depend on has not changed in the meantime.In the realm of SPF, there are a couple of grey areas, no punintended.  SPF can return `softfail` if it isn't sure enough about thecheck failing to indicate a hard fail.  It can also return `none` or`neutral` which are required to be treated the same way.  In suchcases, the SPF checker is saying that the SPF record either doesn'texist or might as well not exist for all the good it does in thiscase.Generally, sites are left to determine whether to accept these emails,or possibly tag them and/or quarantine them.  So far, this softwaredoes not address any of those possible outcomes.  But we can providethe interesting option of using greylisting for grey areas.By default, CHAPPS SPF policy enforcement service uses greylisting foremails which receive `softfail` and `none`/`neutral` responses ontheir SPF checks.If a domain is set to enforce SPF **and** Greylisting, that will causeCHAPPS to greylist even emails which receive `pass` from SPF, meaningthat any &quot;deliverable&quot; email will be deferred unless it is alreadycoming from a recognized source (tuple), when both are enabled.(Non-deliverable categories are: `fail`, `temperror`, `permerror`.)The messages which accompany the various rejections and deferralsindicate what the reason was.  In some cases, those messages indicatethat a message has been greylisted due to the SPF enforcement policy.## Upcoming featuresA mini-roadmap of upcoming changes:minor:  - SDA (and other) Redis keys will have tunable expiry times  - Look into specifying log facility and level in the config filemajor:  - Possibly support multiple enforcement intervals  - It seems inevitable that other features will also be added.  There    is some skeletal code in the repo for building email content    filters, which are not the same as policy delegates.  - Using Redis makes it possible to send pub/sub messages when    certain sorts of conditions occur, such as a user making a large    number of attempts to send mail in a short time while overquota,    or when a user (repeatedly?) attempts to send email as being from    a domain that user lacks authorization for.</longdescription>
</pkgmetadata>