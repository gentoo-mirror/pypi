<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Async-first dependency injection library based on python type hints## Framework integrations:- [FastAPI](/examples/fastapi.md)- [Litestar](/examples/litestar.md)- [Strawberry-Graphql](/examples/strawberry-graphql.md)## QuickstartFirst let's create a class we would be injecting:```pythonclass Service:    pass```Then we should create instance of container and register `Service` class in it using a provider:```pythonfrom aioinject import Container, providerscontainer = Container()container.register(providers.Callable(Service))```Then we can create a context and resolve our `Service` class from it:```pythonwith container.sync_context() as ctx:    service = ctx.resolve(Service)```If you need to inject something into a function just annotate it with inject:```pythonfrom aioinject import inject@injectdef awesome_function(service: Service):    print(service)```And call it within an active context:```pythonwith container.sync_conext() as ctx:    awesome_function()```Complete example (should run as-is):```pythonfrom typing import Annotatedfrom aioinject import Callable, Container, Inject, injectclass Service:    passcontainer = Container()container.register(Callable(Service))@injectdef awesome_function(    service: Annotated[Service, Inject],):    print(service)with container.sync_context() as ctx:    service = ctx.resolve(Service)    awesome_function()```## Sub dependenciesIf one of your dependencies has any sub dependenciesthey would be automatically provided based on class `__init__`or function annotations```pythonfrom aioinject import Callable, Containerclass SubDependency:    passclass Dependency:    def __init__(self, sub_dependency: SubDependency):        self.sub_dependency = sub_dependencycontainer = Container()container.register(Callable(SubDependency))container.register(Callable(Dependency))with container.sync_context() as ctx:    dependency = ctx.resolve(Dependency)    print(dependency.sub_dependency)```If you have multiple implementations for the same dependency you can specify concrete implementation in `Inject`:```pythonimport dataclassesfrom typing import Annotatedfrom aioinject import Container, providers, inject, Inject@dataclasses.dataclassclass Client:    name: strdef get_github_client() -&gt; Client:    return Client(name=&quot;GitHub Client&quot;)def get_gitlab_client() -&gt; Client:    return Client(name=&quot;GitLab Client&quot;)container = Container()container.register(providers.Callable(get_github_client))container.register(providers.Callable(get_gitlab_client))@injectdef injectee(    github_client: Annotated[Client, Inject(get_github_client)],    gitlab_client: Annotated[Client, Inject(get_gitlab_client)],) -&gt; None:    print(github_client, gitlab_client)with container.sync_context() as ctx:    injectee()```## Working with ResourcesOften you need to initialize and close a resource (file, database connection, etc...),you can do that by using a `contextlib.(async)contextmanager` that would return your resource.```pythonimport contextlibfrom aioinject import Container, providersclass Session:    pass@contextlib.contextmanagerdef get_session() -&gt; Session:    print(&quot;Startup&quot;)    yield Session()    print(&quot;Shutdown&quot;)container = Container()container.register(providers.Callable(get_session))with container.sync_context() as ctx:    session = ctx.resolve(Session) # Startup    session = ctx.resolve(Session) # Nothing is printed, Session is cached# Shutdown```## Async DependenciesYou can register async resolvers the same way as you do with other dependencies,all you need to change is to use `Container.context` instead of `Container.sync_context`:```pythonimport asynciofrom aioinject import Container, providersclass Service:    passasync def get_service() -&gt; Service:    await asyncio.sleep(1)    return Service()async def main() -&gt; None:    container = Container()    container.register(providers.Callable(get_service))    async with container.context() as ctx:        service = await ctx.resolve(Service)        print(service)if __name__ == &quot;__main__&quot;:    asyncio.run(main())```## ProvidersWhen creating a provider you should specify the type it returns, but it can be inferred from class type or functionreturn type:### Callable`Callable` (or `Factory` for convenience) provider would create instance of a class each time:```pythonfrom aioinject import Callableclass Service:    passprovider = Callable(Service)service_one = provider.provide_sync()service_two = provider.provide_sync()print(service_one is service_two)# False```### Singleton`Singleton` works the same way as `Callable` but it caches first created object:```pythonfrom aioinject import Singletonclass Service:    passprovider = Singleton(Service)first = provider.provide_sync()second = provider.provide_sync()print(first is second)# True```### Object`Object` provider just returns an object provided to it:```pythonfrom aioinject import Objectclass Service:    passprovider = Object(Service())service = provider.provide_sync()print(service)# &lt;__main__.Service&gt;```</longdescription>
</pkgmetadata>