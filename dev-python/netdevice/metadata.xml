<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>netdevice*********Python modules to execute command on remote network device.To install easily::    pip install -U netdeviceOr to install by source code::    netdevice-x.x.tar.gz        pexpect-2.3.tar.gz        xmltodict-0.10.2.tar.gz        lxml-3.8.0.tar.gz            Python-2.7.12.tgz            libxml2-2.9.4.tar.gz.. attention::    lxml-3.8.0.tar.gz has some bug if you don't install to the default path,    you must set the LD_LIBRARY_PATH enviroment varible in such case. please    refer to the detail: python第三方库lxml源码安装&amp;&amp;使用笔记,    http://blog.csdn.net/slvher/article/details/258299731. Introduction===============netdevice is a python module that allow you run shell command on local orremote host in python. It's especially useful for network test automation:When host is given, you can run the command on remote host and get the resultin the return:.. code-block:: python    from netdevice import cisco, junos, linux    pc = linux.LinuxDevice(&quot;ssh://dev:1234@10.208.72.12&quot;)    print(pc.cmd(&quot;ifconfig eth1&quot;))When the &quot;server&quot; parameter is not given, it run on local device and get theresult:.. code-block:: python    from netdevice import cisco, junos, linux    #It ack as pc = linux.LinuxDevice(&quot;ssh:127.0.0.1&quot;)    pc = linux.LinuxDevice()    print(pc.cmd(&quot;whoami&quot;))Use help command show the documents::    import from netdevice import cisco, junos, linux    help(linux)    help(junos)    help(cisco)2. Feature==========    1) Python Based: Plenty of features    2) Environmentally friendly: can run anywhere where there is python and connect to the devices.    3) Easy to Learn: Need know little about Python    4) Easy to write: One case only have several to dozens of lines.    5) Faster: run the testbed from local and is much faster.    6) object oriented: Flexible and Easy to extend3. Test architecture based on netdevice===========================================::    +---------------------------------+------------+----------------------+    |                                 |            | case1                |    |                                 |            +----------------------+    |  One case                       | Test Suite | ...                  |    |                                 |            +----------------------+    |                                 |            | caseN                |    +---------------------------------+------------+----------------------+    |  netdevice                                                          |    |                                                                     |    |  PC1                  DUT                  DUT                      |    |  +---------------+    +---------------+    +---------------+        |    |  | Linux devices |    | Junos devices |    | Cisco devices |  ...   |    |  +---------------+    +---------------+    +---------------+        |    |                       | Linux devices |    | Linux devices |  ...   |    |                       +---------------+    +---------------+        |    +---------------------------------------------------------------------+                     test Architecture based on netdevice 4. Object overview==================4.1 LinuxDevice---------------4.1.1 Constructor+++++++++++++++++LinuxDevice is a common abstraction for linux like devices. It' flexible todefine a LinuxDevice object.1) Use a url to define a netdevice, then you can execute the command and getthe result:.. code-block:: python    client = linux.LinuxDevice(&quot;ssh://root:1234@englab.ent-vm02.juniper.net&quot;)    server = linux.LinuxDevice(&quot;telnet://root:1122@10.208.172.45:7012&quot;)    print(client.cmd(&quot;ifconfig&quot;))    print(server.cmd(&quot;pwd&quot;))2) By desginating the necessary attribute such as hostname/username/password,etc... code-block:: python    client = linux.LinuxDevice(username = &quot;root&quot;, password = &quot;1234&quot;,        hostname = &quot;alg-vm11&quot;)    print(client.cmd(&quot;uname -a&quot;))3) Use the dictionary to describe the device, it's very useful for testscript. for examples:.. code-block:: python    skater = {            &quot;url&quot;: &quot;ssh://root:1234@skater.englab.juniper.net&quot;,            &quot;int0&quot;: {&quot;name&quot;: &quot;reth1.0&quot;, &quot;inet&quot;: &quot;42.0.0.11/24&quot;, &quot;inet6&quot;: &quot;2002::11/64&quot;, &quot;zone&quot;: &quot;untrust&quot; },            &quot;int1&quot;: {&quot;name&quot;: &quot;reth0.0&quot;, &quot;inet&quot;: &quot;41.0.0.11/24&quot;, &quot;inet6&quot;: &quot;2001::11/64&quot;, &quot;zone&quot;: &quot;trust&quot; },            }    ent_vm02 = {            &quot;url&quot;: &quot;ssh://root:1234@ent-vm02.englab.juniper.net&quot;,            &quot;int0&quot;: { 'name': 'eth1', 'inet': '42.0.0.2/24', 'inet6': '2002::2/64'},            }    ent_vm01 = {            &quot;scheme&quot;: &quot;ssh&quot;,            &quot;username&quot;: &quot;root&quot;,            &quot;password&quot;: &quot;1234&quot;,            &quot;hostname&quot;: &quot;ent-vm01.englab.juniper.net&quot;,            &quot;int0&quot;: { 'name': 'eth1', 'inet': '41.0.0.2/24', 'inet6': '2001::2/64'},            }    client = linux.LinuxDevice(**ent_vm02)    server = linux.LinuxDevice(**ent_vm01)    dut = junos.JunosDevice(**skater)    print(client.cmd(&quot;ifconfig&quot;))    print(client[&quot;int0&quot;][&quot;inet&quot;])    dut.cli(&quot;show security flow status&quot;)4.1.2 Attributes++++++++++++++++LinuxDevice operate based on its attributes. User input those attributes andcan use them after that. Some attributes are pre-defined and the LinuxDeviceswill use them when login, log, configuration and so on. use can change thoseattribtes. Other attrubutes are defined totally by users and user define howto use them.1) Pre-defined attributes:I list the following pre-define attributes and their default value and themeaning of them... code-block:: python    default = {        # mandtory, if not given, it will fail to construct a device        &quot;scheme&quot;:     &quot;ssh&quot;,     # login method, default is ssh, support ssh                                 # and telnet now;        &quot;username&quot;:      None,   # Usename to login;        &quot;hostname&quot;:          None,   # A ip address or hostname that can connect                 # Optional, if not given, use the default        &quot;password&quot;:      None,   # Password to login, could be omitted if use                                 # public key;        &quot;root_password&quot;: None,   # Root password is used since some configuration                                 # need root privillage. If not provided, some                                 # configurationa or command would fail since                                 # privilage.        &quot;url&quot;:       None,       # url to connect the server, use url insteading                                 # scheme/username/passowrd/hostname/port        &quot;name&quot;:       None,      # name of the devices, only used for log. if not                                 # set, the first part of hostname is used.        &quot;autologin&quot;:  True,      # If ture, will login the devices immediately.        #&quot;interfaces&quot;: [        #    #{&quot;name&quot;: &quot;ge-7/1/0.0&quot;, &quot;inet&quot;: &quot;1.1.1.1/24&quot;, &quot;inet6&quot;: &quot;2001::1/64&quot;, &quot;zone&quot;: &quot;trust&quot; },        #    #{&quot;name&quot;: &quot;ge-7/1/1.0&quot;, &quot;inet&quot;: &quot;2.2.2.1/24&quot;, &quot;inet6&quot;: &quot;2002::1/64&quot;, &quot;zone&quot;: &quot;untrust&quot; },        #    ],                   # A list of interfaces the device use; Will        #                         # configure the interface onto the devices if        #                         # autoconfig is True        &quot;preconfig&quot;:  [],        # A list of cmd/configuration the device will                                 # configure before test;        &quot;postconfig&quot;: [],        # A list of cmd/configuration the device will                                 # configure after test;        #&quot;autoconfig&quot;: False,     # If ture, will not configure the interface        #                         # and preconfig automatically.                                          # log related        &quot;log_file&quot;: &quot;test_%s.log&quot; %(time.strftime(&quot;%Y%m%d%H%M%S&quot;, time.localtime())),                                 # log files, set None to disable recording log in file.        &quot;log_level&quot;:  LOG_INFO,  # log level, 0-7, the higher it's, the more log                                 # recorded.        &quot;log_color&quot;:  None,      # log color, if not set will choose randomly;                                 # Use self.test_color() to see what each color                                 # looks like        &quot;log_time&quot;:   True,      # record the log with local time;        #&quot;log_thread&quot;: True,      # record the log with thread name;        # User can also define Whatever attributes you want.        # ...    }2) User-defined attributes:Besides the pre-defined attributes, user can define their own attributes,since those kinds of attributes are used for user only, they can be in anytype, for examples:.. code-block:: python    client = linux.LinuxDevice(&quot;telnet://root:1122@10.208.172.45:7012&quot;,                               &quot;int0&quot;: { 'name': 'eth1', 'inet': '42.0.0.2/24', 'inet6': '2002::2/64'},                               description = &quot;Beijing&quot;)    client[&quot;season&quot;] = &quot;summer&quot;    print(client[&quot;season&quot;], client[&quot;description&quot;])    print(client[&quot;int0&quot;][&quot;inet&quot;])4.1.3 Methods+++++++++++++LinuxDevice support the folowing method:    def __init__(self, server = None, \*\*kwargs)        This is the constructor for LinuxDevice, The parameter pass the        attribute that the object needs.        @server: the standard url of the server, support the query parameters.        @kwargs: attributes of the server, the parameter in this part could be used as the attribute of the object.        For example:            client = linux.LinuxDevice(&quot;telnet://root:1122@10.208.172.45:7012&quot;,                                       &quot;int0&quot;: { 'name': 'eth1', 'inet': '42.0.0.2/24', 'inet6': '2002::2/64'},                                       description = &quot;Beijing&quot;)    __del__(self):        Recycle resource when the object is destroied.    def login(self, terminal_type = 'ansi', login_timeout = 10):        Connect the object with the constructor attribute.        The defualt attribute &quot;autologin&quot; is True, so normally it will be auto        called. Set attribute &quot;autologin&quot; as False and you must call it        explictly.    def relogin(self):        Kill the current session and relogin.    def cmd(self, cmd, expect = None, timeout = 20, control = False,            format = &quot;output&quot;, command_leading = &quot;\033[0;31m$ \033[0m&quot;,            command_color = &quot;no_color&quot;, command_bg_color = &quot;no_color&quot;,            output_color = &quot;no_color&quot;, output_bg_color = &quot;no_color&quot;,            \*\*kwargs):        Execute a command provided by @cmd on remote Linuxdevice and return the        execution result, If the @expect is found, it succeed and return        immediately, or it will wait for at most @timeout seconds. The return        result will be desginated by @format:                @ expect: the prompt the execute is expected to include. If not                  provided, the self.prompt is used. For some applications,                  i.e ftp, it will not use the system's prompt so you must give                  the expected prompt.        @ timeout: Hong long to wait before it's thinked as timeout, if it                   timeout a &quot;CTRL + C&quot; will be trriggered, so please set the                   proper timeout carefully;        @ control: If it is True, send a control character to the child such as                   Ctrl-C or Ctrl-D. For example, to send a Ctrl-G (ASCII 7)::                        self.cmd('g', control = True)        @ format: If it's &quot;output&quot;, the execute output of the command will be        returned, whether it succeed or timeout.         If it's &quot;status&quot;, the execute status will be return, if return and the        @expect is found, it will return True, or it return False.                 If it's &quot;both&quot;, the tuple (status, output) will be return and you can        check both of them.        @ command_leading: Which leading chars to add before command in the log.        @ command_color: Which color to show the command in the log.        @ command_bg_color: Which background color to show the command in the log.        @ output_color: Which color to show the output in the log.        @ output_bg_color: Which background color to show the output in the log.        @ redirect: Noramlly the output would be shown on screen or log file,                    if this is set then the output of the command would be                    saved in the given file, it's especially useful for execute                    command with big output. &quot;/dev/null&quot; would redirect the                    output to a hole. For example:            pc.cmd(&quot;ifconfig&quot;, redirect = &quot;ifconfig_result.log&quot;)        [CAUTION]: please increase the timeout value if the command is        time-consuming, or it will cause failure.    def log (self, message, level = LOG_NOTICE, leading = None, color =            &quot;no_color&quot;, bg_color = &quot;no_color&quot;, log_level = None, \*\*kwargs):        record the log to file self[&quot;log_file&quot;] with the color        self[&quot;log_color&quot;], with the local time if self['log_time'] is True,        the log looks like::            [ regazara ][2017-05-16 16:02:07]: ssh login succeed.        @ message: The log text.        @ level: The log level of the text. Will not show if it's large than        the self[&quot;log_level&quot;].        @log_level: will override the level        @ color: The log color of the text.        @ bg_color: The log background color of the text.    def sleep (self, timeout, total = 50, char = '&gt;', description = &quot;sleep&quot;):        Sleep with progress bar, the granularity is 0.1 second. something like        that:        sleep 7/10[&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;               ][71%]    dumps(self):        Dump all its attributes.    get_file(self, filename, localname = '.', timeout = -1):        Get file from remote host, only support scp now, will support other        methods later.        @filename: file to get from the host.        @localname: save name after download        @timeout: How long to wait for the files to be downloaded. If the file        is very big, set it to a big value or it will fail.    put_file(self, filename, remotedir, timeout = -1):        Put local file to remote host, only support scp now, will support        other methods later.        @filename: file to put from the local. local means the host where you        execute this scriopt.        @remotedir: save name after upload.        @timeout: How long to wait for the files to be uploaded. If the file                  is very big, set it to a big value or it will fail.    def get_files (self, \*args, \*\*kwargs):        Get files from remote host. Compared @get_file, can't desgnate the        local file name, but can get files at a time.    def reboot (self):        reboot the device and reconnect to it until it bootup.    def pktsend (self, pkt, src = None, dst = None, sport = None, dport = None)        Replay the packet like tcpreplay on the linux box. The packet should        include the ip header + tcp/udp header + payload in hex format. for        example:        0x4500003077e240008006a5a50ac645c70aa8820b049f00154e372b0e        000000007002ffff27e60000020405b401010402        @pkt: the packet in hex plain text format;        @src: replace the source ip addrss in the @pkt, if none use the value              in the @pkt;        @dst: replace the destination ip addrss in the @pkt; if none use the              value in the @pkt;        Examples::            sync = '45 00 00 30 77 e2 40 00 80 06 a5 a5 0a c6 45 c7                    0a a8 82 0b 04 9f 00 15 4e 37 2b 0e 00 00 00 00                    70 02 ff ff 27 e6 00 00 02 04 05 b4 01 01 04 02'            client.pktsend(syn, src = &quot;1.1.1.2&quot;, dst = &quot;2.2.2.2&quot;)    tcpreplay (self, remote, filename, saddr = None, sport = None,            daddr = None, dport = None, proto = None, replay_range = None)        Replay the packet capture file @filename, the file could be collected        by tnpdump or wireshark.        @remote: the server which is linuxdevice object.        @filename: the packet capture file.        @saddr: the client address in the packet capture.        @daddr: the server address in the packet capture.        @sport: the client port in the packet capture.        @dport: the server port in the packet capture.        @port: the protol that to be replayed in the packet capture.        @replay_range: the list of frame number to be replayed in the packet capture.        It's based on sendip-2.5-mec-2, besides, there is some bugs to support ipv6::            Index: sendip.c            ===================================================================            RCS file: /home/ypguo/.cvsroot/sendip/sendip.c,v            retrieving revision 1.1.1.1            diff -u -p -r1.1.1.1 sendip.c            --- sendip.c3 Jan 2018 04:02:31 -00001.1.1.1            +++ sendip.c3 Jan 2018 04:04:29 -0000            @@ -686,9 +686,14 @@ int main(int argc, char *const argv[]) {                                            free(packet.data);                                            unload_modules(FALSE,verbosity);                                            return 1;            -} else {            -af_type = AF_INET;            -}            +            } else {            +                if (strchr(argv[gnuoptind], ':')) {            +                    /* the destination address is ipv6 address. */            +                    af_type = AF_INET6;            +                } else {            +                    af_type = AF_INET;            +                }            +            }                            }                            else if(first-&gt;optchar=='i') af_type = AF_INET;                            else if(first-&gt;optchar=='6') af_type = AF_INET6;    def test_color (self):        print the color name in the color.    __getitem__(self, name):        Get certain attribute, for example::            print(self[&quot;name&quot;])    __setitem__(self, name, value):        Set certain attribute, for example::            self[&quot;color&quot;] = &quot;red&quot;    The following methods combile frequently-used methods:    def x_configure_interface (self, \*args):        Re-configure the interface with the given parameters.        The interface looks like this, you can configure multi interfaces in        one time, for examples:        int0 = { 'name': 'eth1', 'inet': '41.0.0.2/24', 'inet6': '2001::2/64'}        int1 = { 'name': 'eth2', 'inet': '42.0.0.2/24', 'inet6': '2002::2/64'}        dut.x_configure_interface(int0, int1)    def x_configure_route (self, local, gateway, remote):        Re-configure the interface with the given parameters, for examples:        #int0 = { 'name': 'eth1', 'inet': '41.0.0.2/24', 'inet6': '2001::2/64'}        client.x_configure_route(client[&quot;int0&quot;], dut[&quot;int0&quot;], server[&quot;int0&quot;])    def x_get_interfaces (self, name):        Get interface configuration given a interface name.    def x_ftp (self, \*args, \*\*kwargs):        Login the remote ftp server and execute some command. Example:            client.x_ftp(&quot;pwd&quot;, &quot;ls&quot;, &quot;bye&quot;, hostname = &quot;42.0.0.2&quot;, username = &quot;root&quot;, password = &quot;Embe1mpls&quot;)        Or:            client.x_ftp(&quot;pwd&quot;, hostname = &quot;42.0.0.2&quot;, username = &quot;root&quot;, password = &quot;Embe1mpls&quot;)            client.x_ftp(&quot;ls&quot;, &quot;pwd&quot;)            client.x_ftp(&quot;bye&quot;)        @args: command list need to be executed        @kwargs: hostname/username/password parameters If need to auto logint the        remote ftp server, hostname/username/password should be given4.2 JunosDevice---------------4.2.1 Constructor+++++++++++++++++JunosDevice is a common abstraction for Juniper network devices. It derivesfrom LinuxDevice so it has every method of LinuxDevice, except some of themare overrided. Please use the similar way to define a JunosDevice, forexample:.. code-block:: python    dut = junos.JunosDevice(&quot;ssh://root:Juniper@10.219.29.61&quot;)    print(dut[&quot;username&quot;])    print(dut.cli(&quot;show security flow session&quot;))4.2.2 Methods+++++++++++++Besides all the methods derived from LinuxDevice, JunosDevice support thefolowing extra methods:    def cmd (self, cmd, mode = &quot;shell&quot;, timeout = 30, \*\*kwargs):        There are total 4 modes for junos devices:            1) shell: execute the command in shell mode and return the result,                this is the default mode and it looks like linux.cmd().            2) cli: execute the command in cli mode and return the result,                self.cmd(cmd, mode = &quot;cli&quot;) equal to self.cli(cmd), see detail                in seld.cli()            3) configure: execute the command in configure mode and return the                result, self.cmd(cmd, mode = &quot;configure&quot;) equal to                self.configure(cmd), see detail in seld.configure()            4) vty: execute the command in vty mode and return the result,                self.cmd(cmd, mode = &quot;vty&quot;) equal to self.vty(cmd), see detail                in seld.vty()        Supported options include:            timeout: time to wait for the execute command return. default is 5                     seconds    cli (self, cmd, parse = None, timeout = 30, \*\*kwargs):        equal cmd(..., mode = &quot;cli&quot;)        Execute a list of cli command and return the execution result of the        last command.        @parse: Normally, the result will be plain text or xml text. But if        the @parse is given, the result will be parsed and a list of        dictionary for @parse will be returned. It's useful to parse the xml        result. For example the following command return a list of session in        dictionary::                    sessions = dut.cli('show security flow session',                               parse = &quot;flow-session&quot;)            print sessions[0]['session-identifier']        while the following command will return the plain text result::            output = dut.cli('show security flow session')            print output    configure(self, cmd, \*\*kwargs):        equal cmd(..., mode = &quot;configure&quot;), Execute a configure command and        return the result of the last command. Sematics is like self.cli, see        detail in self.cli(), For example, Execute a configure command::            dut.configure('set security flow traceoptions flag all')            dut.configure('set security traceoptions file flow.log size 50m')            dut.configure('set security traceoptions level verbose')            dut.configure('set security traceoptions flag all')            dut.configure('commit')    def vty (self, \*args, \*\*kwargs):        equal cmd(..., mode = &quot;vty&quot;)        Execute every line in every argument on every SPU(if not given) and        return the result.        Supported options include:            timeout: time to wait for the execute command return. default is 5                     seconds            tnp_addr: tnp address to execute, if not execut the command on                      every SPU.    def get_spus (self, \*\*kwargs):            Get the spu list of the srx.    print_session (self, session):                Convert a or lists of session in dictionary to plain text. print it as        show of &quot;show security flow session&quot;.        @session: it could be a session or a list of session.    install_image (self, image):                Install a image and reboot the dut, wait until it is up with all        SPU/SPC.                @local: install a local image, first upload the image to /var/tmp/ on        the DUT and then install it.        @remote: install a image on the DUT    def x_print_session (self, sessions):        Convert a or lists of session in dictionary to plain text.    def x_configure_trace (self, \*args, \*\*kwargs):        configure trace file, For examples:            dut.x_configure_trace(&quot;flow&quot;, &quot;alg dns&quot;, &quot;dynamic-application&quot;,                                  filename = &quot;flow.log&quot;, size = &quot;50m&quot;)    def x_configure_vty_trace (self, \*args, \*\*kwargs):        configure trace file                An examples, to enable flow/policy/dynamic-application traceoption and        write the trace into one file:            dut.x_configure_vty_trace(&quot;flow&quot;, &quot;policy&quot;, &quot;fwdd&quot;,                                  filename = &quot;flow.log&quot;, size = &quot;50m&quot;)5. An example=============In this example, we login the client linux device and then ftp the server.Check if there is session generated on the Juniper SRX firewall. Then teardown the connection:.. code-block:: python    #!/usr/bin/env python    from netdevice import cisco, junos, linux    if __name__ == '__main__':        dut = junos.JunosDevice(&quot;ssh://regress:1234@regazara.englab.juniper.net&quot;,                root_password = &quot;5678&quot;)        client = linux.LinuxDevice(&quot;ssh://root:5678@ent-vm01.englab.juniper.net&quot;,                interfaces = [ { 'name': 'eth1', 'inet': '1.1.1.2/24', 'inet6': '2001::2/64'} ])        server = linux.LinuxDevice(&quot;ssh://root:5678@ent-vm02.englab.juniper.net&quot;,                interfaces = [ { 'name': 'eth1', 'inet': '2.2.2.2/24', 'inet6': '2002::2/64'} ])        client.cmd(&quot;ip route add 2.2.2.0/24 via 1.1.1.1 dev eth1&quot;)        server.cmd(&quot;ip route add 1.1.1.0/24 via 2.2.2.1 dev eth1&quot;)        dut.cli(&quot;clear security flow session application ftp&quot;)        # connect to the server and list the files.        client.cmd('ftp %s' %(server[&quot;interfaces&quot;][0][&quot;inet&quot;].split('/')[0]), expect = &quot;Name&quot;)        client.cmd(server[&quot;username&quot;], expect = &quot;Password&quot;)        client.cmd(server[&quot;password&quot;], expect = &quot;ftp&quot;)        output = client.cmd('ls', expect = &quot;ftp&gt; &quot;)        if &quot;226&quot; in output:            print(&quot;ftp output is shown.&quot;)        else:            print(&quot;ftp failed to connect the server.&quot;)        # check the session and tear down the connection.        sessions = dut.cli('show security flow session application ftp', parse = &quot;flow-session&quot;)        client.cmd('bye')        if sessions and sessions[0][&quot;flow-information&quot;][0]['pkt-cnt'] &gt; 0 and \                sessions[0][&quot;flow-information&quot;][1]['pkt-cnt'] &gt; 0:            print(&quot;Session found, pass!&quot;)        else:            print(&quot;Failed to find the session&quot;)6. Q/A======1) Why some command return timeout?For time consuming command i.g. scp, ftp get command, please set the @timeoutproperly to avoid the command timeout.Please make sure there is no command timeout since the output of the lastcommand will messup the result of the next command.If a command timeout, either send a CTRL + C to kill the current session:    client.cmd(&quot;c&quot;, control = True)or kill the current session and relogin the device to open a new session:    client.relogin()7. Changelog============1.0.0: Official release.1.0.4: For ssh, add  -o GSSAPIAuthentication=no to accelerate the login process.1.0.6: 1) When configure interface in junos, don't configure the zone.    2) print the junos specific attritue in the init.    3) remove some verbose log when login.1.0.7: 1) Change or add the some private function: x_set_interface, x_set_zone, x_set_policy, besides, we won't commit the change after the functions, users must commit the change by his own.    2) add the release version in each object, you can see what version the script run.1.0.9: 1) Fix some bugs.1.0.10: 1) Don't show the commit process in other thread. There are some issue on it.1.1: support new device: ovs1.2: support new device: ovn1.2.1: 1) LinuxDevice support non server given, then it would run sh command locally.       2) Support new device: ovn.1.2.6 fix issue when login by telnet</longdescription>
</pkgmetadata>