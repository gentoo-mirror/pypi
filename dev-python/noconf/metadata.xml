<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>======noconf======Key features============1. **Flexible configuration**: noconf allows you to configure your   Python applications using configuration files that use Python   syntax.2. **Multiple configuration files**: noconf allows you to split your   configuration across multiple files, making it easier to manage and   update your configuration as your application grows.3. **Configuration referencing**: noconf allows you to reference other   parts of your configuration from within your configuration,   avoiding duplication and keeping your configuration DRY (Don't   Repeat Yourself).4. **Component-based programming**: noconf enables you to initialize   classes using your configuration, making it easy to compose complex   systems out of smaller, reusable components. This promotes code   reuse and maintainability.Usage=====At a minimum, noconf allows us to read configuration that's stored infiles with Python syntax, where the file contains exactly one toplevel dictionary.Let's first write a very simple config file:&gt;&gt;&gt; config1_fname = folder / &quot;config1.py&quot;&gt;&gt;&gt; config1_fname.write_text(&quot;&quot;&quot;... {'key1': 'value1', 'key2': ['value2']}... &quot;&quot;&quot;)40&gt;&gt;&gt; from noconf import load&gt;&gt;&gt; load(config1_fname){'key1': 'value1', 'key2': ['value2']}We can also chain configuration files, that is, load multipleconfiguration files and merge them, where contents of the files laterin the list of files to load will take precedence:&gt;&gt;&gt; config2_fname = folder / &quot;config2.py&quot;&gt;&gt;&gt; config2_fname.write_text(&quot;&quot;&quot;... {'key1': 'new', 'key3': {'__copy__': 'key2'}}... &quot;&quot;&quot;)47&gt;&gt;&gt; load((config1_fname, config2_fname))  # a tuple of config files{'key1': 'new', 'key2': ['value2'], 'key3': ['value2']}Notice that in the above example, we also used a `'__copy__'` feature,which allows us to refer to other parts in the configuration, and toavoid duplication.We can also instantiate classes directly from the configuration.Let's create a configuration file that instantiates a Python loggingFileHandler class.  We're also going to configure the FileHandler witha filename that's passed as an environment variable.  We use thespecial `environ` variable in noconf to access environment variables:&gt;&gt;&gt; setenv(&quot;LOGFILE&quot;, str(folder / &quot;mylogfile.txt&quot;))&gt;&gt;&gt; config3_fname = folder / &quot;config3.py&quot;&gt;&gt;&gt; config3_fname.write_text(&quot;&quot;&quot;... {...     'handlers': [...         {...             '!': 'logging.FileHandler',...             'filename': environ['LOGFILE'],...         },...     ],... }... &quot;&quot;&quot;)135&gt;&gt;&gt; config = load(config3_fname)&gt;&gt;&gt; filehandler = config['handlers'][0]&gt;&gt;&gt; from pathlib import Path&gt;&gt;&gt; Path(filehandler.baseFilename).parts[-1]'mylogfile.txt'</longdescription>
</pkgmetadata>