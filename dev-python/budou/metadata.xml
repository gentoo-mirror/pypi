<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Budou 🍇===========.. image:: https://badge.fury.io/py/budou.svg   :target: https://badge.fury.io/py/budou.. image:: https://travis-ci.org/google/budou.svg?branch=master   :target: https://travis-ci.org/google/budouEnglish text has many clues, like spacing and hyphenation, that enable beautifuland legible line breaks. Some CJK languages lack these clues, and so arenotoriously more difficult to process. Without a more careful approach,breaks can occur randomly and usually in the middle of a word. This is along-standing issue with typography on the web and results in a degradationof readability.Budou automatically translates CJK sentences into HTML withlexical chunks wrapped in non-breaking markup, so as to semantically control linebreaks. Budou uses word segmenters to analyze input sentences. It can alsoconcatenate proper nouns to produce meaningful chunks utilizingpart-of-speech (pos) tagging and other syntactic information. Processed chunks arewrapped with the :code:`SPAN` tag. These semantic units will no longer be split atthe end of a line if given a CSS :code:`display` property set to :code:`inline-block`.Installation--------------The package is listed in the Python Package Index (PyPI), so you can install itwith pip:.. code-block:: sh   $ pip install budouOutput--------------Budou outputs an HTML snippet wrapping chunks with :code:`span` tags:.. code-block:: html   &lt;span&gt;&lt;span class=&quot;ww&quot;&gt;常に&lt;/span&gt;&lt;span class=&quot;ww&quot;&gt;最新、&lt;/span&gt;   &lt;span class=&quot;ww&quot;&gt;最高の&lt;/span&gt;&lt;span class=&quot;ww&quot;&gt;モバイル。&lt;/span&gt;&lt;/span&gt;Semantic chunks in the output HTML will not be split at the end of line byconfiguring each :code:`span` tag with :code:`display: inline-block` in CSS... code-block:: css   .ww {     display: inline-block;   }By using the output HTML from Budou and the CSS above, sentenceson your webpage will be rendered with legible line breaks:.. image:: https://raw.githubusercontent.com/wiki/google/budou/images/nexus_example.jpegUsing as a command-line app~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~You can process your text by running the :code:`budou` command:.. code-block:: sh   $ budou 渋谷のカレーを食べに行く。The output is:.. code-block:: html   &lt;span&gt;&lt;span class=&quot;ww&quot;&gt;渋谷の&lt;/span&gt;&lt;span class=&quot;ww&quot;&gt;カレーを&lt;/span&gt;   &lt;span class=&quot;ww&quot;&gt;食べに&lt;/span&gt;&lt;span class=&quot;ww&quot;&gt;行く。&lt;/span&gt;&lt;/span&gt;You can also configure the command with optional parameters.For example, you can change the backend segmenter to `MeCab &lt;#mecab-segmenter&gt;`_ and change theclass name to :code:`wordwrap` by running:.. code-block:: sh   $ budou 渋谷のカレーを食べに行く。 --segmenter=mecab --classname=wordwrapThe output is:.. code-block:: html   &lt;span&gt;&lt;span class=&quot;wordwrap&quot;&gt;渋谷の&lt;/span&gt;&lt;span class=&quot;wordwrap&quot;&gt;カレーを&lt;/span&gt;   &lt;span class=&quot;wordwrap&quot;&gt;食べに&lt;/span&gt;&lt;span class=&quot;wordwrap&quot;&gt;行く。&lt;/span&gt;&lt;/span&gt;Run the help command :code:`budou -h` to see other available options.Using programmatically~~~~~~~~~~~~~~~~~~~~~~~~~You can use the :code:`budou.parse` method in your Python scripts... code-block:: python   import budou   results = budou.parse('渋谷のカレーを食べに行く。')   print(results['html_code'])   # &lt;span&gt;&lt;span class=&quot;ww&quot;&gt;渋谷の&lt;/span&gt;&lt;span class=&quot;ww&quot;&gt;カレーを&lt;/span&gt;   # &lt;span class=&quot;ww&quot;&gt;食べに&lt;/span&gt;&lt;span class=&quot;ww&quot;&gt;行く。&lt;/span&gt;&lt;/span&gt;You can also make a parser instance to reuse the segmenter backend with the sameconfiguration. If you want to integrate Budou into your web developmentframework in the form of a custom filter or build process, this would be the wayto go... code-block:: python   import budou   parser = budou.get_parser('mecab')   results = parser.parse('渋谷のカレーを食べに行く。')   print(results['html_code'])   # &lt;span&gt;&lt;span class=&quot;ww&quot;&gt;渋谷の&lt;/span&gt;&lt;span class=&quot;ww&quot;&gt;カレーを&lt;/span&gt;   # &lt;span class=&quot;ww&quot;&gt;食べに&lt;/span&gt;&lt;span class=&quot;ww&quot;&gt;行く。&lt;/span&gt;&lt;/span&gt;   for chunk in results['chunks']:     print(chunk.word)   # 渋谷の 名詞   # カレーを 名詞   # 食べに 動詞   # 行く。 動詞(deprecated) :code:`authenticate` method~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~:code:`authenticate`, which had been the method used to create a parser inprevious releases, is now deprecated.The :code:`authenticate` method is now a wrapper around the :code:`get_parser` methodthat returns a parser with the`Google Cloud Natural Language API &lt;#google-cloud-natural-language-api-segmenter&gt;`_segmenter backend.The method is still available, but it may be removed in a future release... code-block:: python   import budou   parser = budou.authenticate('/path/to/credentials.json')   # This is equivalent to:   parser = budou.get_parser(       'nlapi', credentials_path='/path/to/credentials.json')Available segmenter backends------------------------------You can choose different segmenter backends depending on the needs of your environment. Currently, the segmenters below are supported... csv-table::  :header: Name, Identifier, Supported Languages  `Google Cloud Natural Language API &lt;#google-cloud-natural-language-api-segmenter&gt;`_, nlapi, &quot;Chinese, Japanese, Korean&quot;  `MeCab &lt;#mecab-segmenter&gt;`_, mecab, &quot;Japanese&quot;  `TinySegmenter &lt;#tinysegmenter-based-segmenter&gt;`_, tinysegmenter, &quot;Japanese&quot;Specify the segmenter when you run the :code:`budou` command or load a parser.For example, you can run the :code:`budou` command with the MeCab segmenter bypassing the :code:`--segmenter=mecab` parameter:.. code-block:: sh  $ budou 今日も元気です --segmenter=mecabYou can pass :code:`segmenter` parameter when you load a parser:.. code-block:: python  import budou  parser = budou.get_parser('mecab')  parser.parse('今日も元気です')If no segmenter is specified, the Google Cloud Natural Language API is used asthe default... _nlapi-segmenter:Google Cloud Natural Language API Segmenter~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~The Google Cloud Natural Language API (https://cloud.google.com/natural-language/)(NL API) analyzes input sentences usingmachine learning technology. The API can extract not only syntax but alsoentities included in the sentence, which can be used for better qualitysegmentation (see more at `Entity mode &lt;#entity-mode&gt;`_). Since this is a simpleREST API, you don't need to maintain a dictionary. You can also support multiplelanguages using one single source.Supported languages++++++++++++++++++++++- Simplified Chinese (zh)- Traditional Chinese (zh-Hant)- Japanese (ja)- Korean (ko)For those considering using Budou for Korean sentences, please refer tothe `Korean support &lt;#korean-support&gt;`_ section.Authentication+++++++++++++++The NL API requires authentication before use. First, create a Google Cloud Platformproject and enable the Cloud Natural Language API. Billing also needs to be enabledfor the project. Then, download a credentials file for a service account byaccessing the `Google Cloud Console &lt;https://console.cloud.google.com/&gt;`_and navigating through &quot;API &amp; Services&quot; &gt; &quot;Credentials&quot; &gt; &quot;Create credentials&quot; &gt;&quot;Service account key&quot; &gt; &quot;JSON&quot;.Budou will handle authentication once the path to the credentials file is setin the :code:`GOOGLE_APPLICATION_CREDENTIALS` environment variable... code-block:: sh   $ export GOOGLE_APPLICATION_CREDENTIALS='/path/to/credentials.json'You can also pass the path to the credentials file when you initialize theparser... code-block:: python   parser = budou.get_parser(       'nlapi', credentials_path='/path/to/credentials.json')The NL API segmenter uses *Syntax Analysis* and incurs costs according tomonthly usage. The NL API has free quota to start testing the feature without charge.Please refer to https://cloud.google.com/natural-language/pricing for moredetailed pricing information.Caching system++++++++++++++++Parsers using the NL API segmenter cache responses from the API in order toprevent unnecessary requests to the API and to make processing faster. If you want toforce-refresh the cache, set :code:`use_cache` to :code:`False`... code-block:: python   parser = budou.get_parser(segmenter='nlapi', use_cache=False)   result = parser.parse('明日は晴れるかな')In the `Google App Engine Python 2.7 Standard Environment &lt;https://cloud.google.com/appengine/docs/standard/python/&gt;`_,Budou tries to use the`memcache &lt;https://cloud.google.com/appengine/docs/standard/python/memcache/&gt;`_service to cache output efficiently across instances.In other environments, Budou creates a cache file in the`python pickle &lt;https://docs.python.org/3/library/pickle.html&gt;`_ format inyour file system... _entity-mode:Entity mode++++++++++++++++++The default parser only uses results from Syntactic Analysis for parsing, but youcan also utilize results from *Entity Analysis* by specifying `use_entity=True`.Entity Analysis will improve the accuracy of parsing for some phrases,especially proper nouns, so it is recommended if your target sentencesinclude names of individual people, places, organizations, and so on.Please note that Entity Analysis will result in additional pricing because itrequires additional requests to the NL API. For more details about API pricing,please refer to https://cloud.google.com/natural-language/pricing... code-block:: python  import budou  # Without Entity mode (default)  result = budou.parse('六本木ヒルズでご飯を食べます。', use_entity=False)  print(result['html_code'])  # &lt;span class=&quot;ww&quot;&gt;六本木&lt;/span&gt;&lt;span class=&quot;ww&quot;&gt;ヒルズで&lt;/span&gt;  # &lt;span class=&quot;ww&quot;&gt;ご飯を&lt;/span&gt;&lt;span class=&quot;ww&quot;&gt;食べます。&lt;/span&gt;  # With Entity mode  result = budou.parse('六本木ヒルズでご飯を食べます。', use_entity=True)  print(result['html_code'])  # &lt;span class=&quot;ww&quot;&gt;六本木ヒルズで&lt;/span&gt;  # &lt;span class=&quot;ww&quot;&gt;ご飯を&lt;/span&gt;&lt;span class=&quot;ww&quot;&gt;食べます。&lt;/span&gt;.. _mecab-segmenter:MeCab Segmenter~~~~~~~~~~~~~~~~~~~~~~~MeCab (https://github.com/taku910/mecab) is an open source text segmentationlibrary for the Japanese language. Unlike the Google Cloud Natural Language API segmenter,the MeCab segmenter does not require any billed API calls, so you can processsentences for free and without an internet connection. You can also customize thedictionary by building your own.Supported languages++++++++++++++++++++++- JapaneseInstallation+++++++++++++++++You need to have MeCab installed to use the MeCab segmenter in Budou.You can install MeCab with an IPA dictionary by running.. code-block:: sh   $ make install-mecabin the project's home directory after cloning this repository... _tinysegmenter-based-segmenter:TinySegmenter-based Segmenter~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~TinySegmenter (http://chasen.org/~taku/software/TinySegmenter/) is a compactJapanese tokenizer originally created by (c) 2008 Taku Kudo.It tokenizes sentences by matching against a combination of patterns carefullydesigned using machine learning. This means that **you can use this backendwithout any additional setup!**Supported languages++++++++++++++++++++++- Japanese.. _korean:Korean support-------------------Korean has spaces between chunks, so you can perform line breaking simply byputting `word-break: keep-all` in your CSS. We recommend that you use thistechnique instead of using Budou.Use cases---------------Budou is designed to be used mostly in eye-catching sentences such as titlesand headings on the assumption that split chunks would stand out negativelyat larger font sizes.Accessibility-------------------Some screen reader software packages read Budou's wrapped chunks one by one.This may degrade the user experience for those who need audio support.You can attach any attribute to the output chunks to enhance accessibility.For example, you can make screen readers read undivided sentences bycombining the `aria-describedby` and `aria-label` attributes in the output... code-block:: html  &lt;p id=&quot;description&quot; aria-label=&quot;やりたいことのそばにいる&quot;&gt;    &lt;span class=&quot;ww&quot; aria-describedby=&quot;description&quot;&gt;やりたい&lt;/span&gt;    &lt;span class=&quot;ww&quot; aria-describedby=&quot;description&quot;&gt;ことの&lt;/span&gt;    &lt;span class=&quot;ww&quot; aria-describedby=&quot;description&quot;&gt;そばに&lt;/span&gt;    &lt;span class=&quot;ww&quot; aria-describedby=&quot;description&quot;&gt;いる&lt;/span&gt;  &lt;/p&gt;**This functionality is currently nonfunctional** due to the html5lib sanitizer'sbehavior, which strips ARIA-related attributes from the output HTML. Progress on thisissue is tracked at https://github.com/google/budou/issues/74Author----------Shuhei Iitsuka- Website: https://tushuhei.com- Twitter: https://twitter.com/tushuheiDisclaimer-----------------This library is authored by a Googler and copyrighted by Google, but is not anofficial Google product.License-----------Copyright 2018 Google LLCLicensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.</longdescription>
</pkgmetadata>