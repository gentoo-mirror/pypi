<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># typedattr&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/gingsi/typedattr/actions/workflows/build_py37.yml&quot;&gt;  &lt;img alt=&quot;build 3.7 status&quot; title=&quot;build 3.7 status&quot; src=&quot;https://img.shields.io/github/actions/workflow/status/gingsi/typedattr/build_py37.yml?branch=main&amp;label=build%203.7&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/gingsi/typedattr/actions/workflows/build_py39.yml&quot;&gt;  &lt;img alt=&quot;build 3.9 status&quot; title=&quot;build 3.9 status&quot; src=&quot;https://img.shields.io/github/actions/workflow/status/gingsi/typedattr/build_py39.yml?branch=main&amp;label=build%203.9&quot; /&gt;&lt;/a&gt;&lt;img alt=&quot;coverage&quot; title=&quot;coverage&quot; src=&quot;docs/coverage.svg&quot; /&gt;&lt;a href=&quot;https://pypi.org/project/typedattr/&quot;&gt;  &lt;img alt=&quot;version&quot; title=&quot;version&quot; src=&quot;https://img.shields.io/pypi/v/typedattr?color=success&quot; /&gt;&lt;/a&gt;&lt;/p&gt;Typechecking and conversion utility for [attrs](https://www.attrs.org/en/stable/)Parses a dictionary into an attrs instance.Contains other generic object, type and cache utilities.## InstallRequires `python&gt;=3.7````bashpip install typedattr```## QuickstartDefine the class hierarchy and parse the input:~~~pythonfrom attrs import definefrom typing import Optionalfrom typedattr import attrs_from_dict@defineclass Cfg:    foo: int = 12    bar: Optional[int] = Noneprint(attrs_from_dict(Cfg, {&quot;foo&quot;: 1, &quot;bar&quot;: 2}))# Cfg(foo=1, bar=2)@defineclass CfgNested:    sub_cfg: Cfg = Noneprint(attrs_from_dict(CfgNested, {&quot;sub_cfg&quot;: {&quot;foo&quot;: 1, &quot;bar&quot;: 2}}))# CfgNested(sub_cfg=Cfg(foo=1, bar=2))~~~## Features* `@definenumpy` decorator for equality check if the instances contains numpy arrays* Nested checking and conversion of python standard types* Supports old and new style typing (e.g. `typing.List` and `list`)* Supports positional and keyword arguments in classes* Can also typecheck existing attrs instances* Allows custom conversions, by default converts source type `str` to target type `Path` and  `int` to `float`* Allows to redefine which objects will be recursed into, by default recurses into standard  containers (list, dict, etc.)### Strict mode (default)* Convert everything to the target type, e.g. if the input is a list and the annotation is a tuple,  the output will be a tuple* Raise errors if types cannot be matched, there are unknown fields in the input or  abstract annotation types are used (e.g. Sequence)### Non-strict modeEnabled by calling `attrs_from_dict` with `strict=False`* No conversion except for creating the attrs instance from the dict* Ignore silently if types cannot be matched or abstract annotation types are used* Unknown fields in the input will be added to the attrs instance if possible  (see the hint below about slots)### Skip unknownsSet `skip_unknowns=True` to ignore all unknown input fields.### HintsThe following behaviour stems from the `attrs` package:* New attributes cannot to be added after class definition to an attrs instance,  unless it is created with `@define(slots=False)`  [Explanation](https://www.attrs.org/en/21.2.0/glossary.html#term-slotted-classes)* Untyped fields or &quot;ClassVar&quot; typed fields will be ignored by @attrs.define  and therefore also by this library.### Possible improvements* Supports Callable but does not typecheck the signature* Not tested for NewType, Literal## Install locally and run testsClone repository and cd into, then:~~~bashpip install -e .pip install pytest pytest-cov pylintpylint typedattr# run tests for python&gt;=3.7python -m pytest --covpylint tests# run tests for python&gt;=3.9python -m pytest tests tests_py39 --covpylint tests pylint tests_py39~~~## AlternativesThis library should be useful for off-the-shelf typechecking and conversion of dicts toattrs instances.For more complex or other related use cases there are many alternatives:`cattrs`, `attrs-strict`, `pydantic`, `dataconf` to name a few.</longdescription>
</pkgmetadata>