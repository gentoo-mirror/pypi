<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p&gt;&lt;a href=&quot;https://pypi.org/project/oxalis/&quot;&gt;    &lt;img src=&quot;https://badge.fury.io/py/oxalis.svg&quot; alt=&quot;Package version&quot;&gt;&lt;/a&gt;&lt;/p&gt;# Oxalis  Distributed async task/job queue, like Celery for `asyncio` world## Feature* Redis and AMQP(RabbitMQ etc.) support* Task timeout and concurrency limit support* Delayed task(Both Redis and RabbitMQ) support* Cron task/job beater* Built-in coroutine pool with concurrency and time limit## Install```pip install oxalis```## Example with Redis backendDefine task:```pythonfrom redis.asyncio.client import Redisfrom oxalis.redis import Oxalisoxalis = Oxalis(Redis(host=os.getenv(&quot;REDIS_HOST&quot;, &quot;redis&quot;)))@oxalis.register()async def hello_task():    print(&quot;Hello oxalis&quot;)```Run worker(consumer):```pythonoxalis.run_worker_master()``````shellpython ex.pyINFO:oxalis:Registered Task: &lt;Task(hello_task)&gt;INFO:oxalis:Run worker: &lt;Oxalis(pid-101547)&gt;...INFO:oxalis:Run worker: &lt;Oxalis(pid-101548)&gt;...INFO:oxalis:Run worker: &lt;Oxalis(pid-101549)&gt;...INFO:oxalis:Run worker: &lt;Oxalis(pid-101550)&gt;...INFO:oxalis:Run worker: &lt;Oxalis(pid-101551)&gt;...INFO:oxalis:Run worker: &lt;Oxalis(pid-101552)&gt;...INFO:oxalis:Run worker: &lt;Oxalis(pid-101554)&gt;...```Run client(producer):```pythonimport asyncioasyncio.get_event_loop().run_until_complete(oxalis.connect())for i in range(10):    asyncio.get_event_loop().run_until_complete(hello_task.delay())    asyncio.get_event_loop().run_until_complete(hello_task.delay(_delay=1))  # delay execution after 1s```Run cron beater:```pythonfrom oxalis.beater import Beaterbeater = Beater(oxalis)beater.register(&quot;*/1 * * * *&quot;, hello_task)beater.run()``````shellpython exb.py INFO:oxalis:Beat task: &lt;Task(hello_task)&gt; at &lt;*/1 * * * *&gt; ...```## TaskCodecThe `TaskCodec` will encode/decode task args, default codec will use `json`Custom task codec:```pythonfrom oxalis.base import TaskCodecclass MyTaskCodec(TaskCodec):    @classmethod    def encode(        cls,        task: Task,        task_args: tp.Sequence[tp.Any],        task_kwargs: tp.Dict[str, tp.Any],    ) -&gt; bytes:        ...    @classmethod    def decode(cls, content: bytes) -&gt; TaskCodec.MESSAGE_TYPE:        ...oxalis = Oxalis(Redis(host=os.getenv(&quot;REDIS_HOST&quot;, &quot;redis&quot;)), task_codec=MyTaskCodec())...```## Task poolOxalis use one coroutine pool with concurrency limit and timeout limit to run all taskCustom pool:```pythonfrom redis.asyncio.client import Redisfrom oxalis.redis import Oxalisfrom oxalis.pool import Pooloxalis = Oxalis(Redis(host=os.getenv(&quot;REDIS_HOST&quot;, &quot;redis&quot;)), pool=Pool(concurrency=10, timeout=60))```* For Redis task, the `queue` will be blocked util `pool` is not fully loaded* For AMQP task, oxalis use AMQP's QOS to limit worker concurrency(`pool`'s concurrency will be -1 which means the pool's concurrency will not be limited)* `asyncio.TimeoutError` will be raised if one task is timeout* Every worker process has owned limited poolSpecified one task timeout limit:```python@oxalis.register(queue=custom_queue, timeout=10)def custom_task():    print(&quot;Hello oxalis&quot;)```## Custom hookOxalis defined some hook API for inherited subclass:```pythonclass MyOxalis(Oxalis):    def on_worker_init():        # will be called before worker started        pass    def on_worker_close():        # will be called after worker started        pass```Some API can be rewritten or inherited for custom usage, eg:```pythonimport sentry_sdkclass MyOxalis(Oxalis):    async def exec_task(self, task: Task, *task_args, **task_kwargs):        &quot;&quot;&quot;        capture exception to sentry        &quot;&quot;&quot;        try:            await super().exec_task(task, *task_args, **task_kwargs)        except Exception as e:            sentry_sdk.capture_exception(e)```## Redis Backend DetailOxalis use redis's `list` and `pubsub` structure as a message queue### QueueCustom queue:```pythonfrom oxalis.redis import Queue, PubsubQueuecustom_queue = Queue(&quot;custom&quot;)bus_queue = PubsubQueue(&quot;bus&quot;)```Register task:```python@oxalis.register(queue=custom_queue)def custom_task():    print(&quot;Hello oxalis&quot;)@oxalis.register(queue=bus_queue)def bus_task():    print(&quot;Hello oxalis&quot;)```* For task producer, the task will send to specified queue when call `task.delay()`* For task consumer, oxalis will listen those queues and receive task from them### Concurrency limitOxalis using coroutine pool's concurrency limit way, we can set different concurrency limit with specified pool for one task:```python@oxalis.register(pool=Pool(concurrency=1))def custom_task():    print(&quot;Hello oxalis&quot;)```### Delayed taskSupport by redis [zset](https://redis.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/6-4-2-delayed-tasks/)##  AMQP Backend Detail### Custom Queue and ExchangeOxalis using AMQP's way to define Exchange, Queue and their bindings```pythonimport asyncioimport loggingimport timefrom aio_pika import RobustConnectionfrom oxalis.amqp import Exchange, ExchangeType, Oxalis, Pool, Queuee = Exchange(&quot;test&quot;)q = Queue(&quot;test&quot;, durable=False)e2 = Exchange(&quot;testfanout&quot;, type=ExchangeType.FANOUT)q2 = Queue(&quot;testfanout&quot;, durable=False)oxalis = Oxalis(RobustConnection(&quot;amqp://root:letmein@rabbitmq:5672/&quot;))oxalis.register_binding(q, e, &quot;test&quot;)oxalis.register_binding(q2, e2, &quot;&quot;)oxalis.register_queues([q, q2])@oxalis.register(exchange=e, routing_key=&quot;test&quot;)async def task1():    await asyncio.sleep(1)    print(&quot;hello oxalis&quot;)@oxalis.register(exchange=e2)async def task2():    await asyncio.sleep(10)    print(&quot;hello oxalis&quot;)```* For producer, task `oxalis.register`  defined one task message will send to which exchange(by routing key)* For consumer, `register_queues` defined which queues oxalis will listened* Task routing defined by bindings### Concurrency limitOxalis use AMQP's QOS to limit worker concurrency(Task's `ack_later` should be true), so coroutine pool's concurrency should not be limited.Custom queue QOS:```pythonoxalis = Oxalis(RobustConnection(&quot;amqp://root:letmein@rabbitmq:5672/&quot;), default_queue=Queue(&quot;custom&quot;,consumer_prefetch_count=10))...fanout_queue = Queue(&quot;testfanout&quot;, durable=False, consumer_prefetch_count=3)oxalis.register_queues([fanout_queue])...```### Custom task behaviorDefine task how to perform `ack` and `reject` ```python# always ack even task failed(raise exception)@oxalis.register(ack_always=True, reject=False)async def task2():    await asyncio.sleep(10)    print(&quot;hello oxalis&quot;)#  reject with requeue when task failed@oxalis.register(reject_requeue=True)async def task2():    await asyncio.sleep(10)    print(&quot;hello oxalis&quot;)```### Delayed taskSupport by RabbitMq's [plugin](https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq)</longdescription>
</pkgmetadata>