<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![GitHub](https://img.shields.io/github/license/florian-huber/sparsestack)[![PyPI](https://img.shields.io/pypi/v/sparsestack?color=teal)](https://pypi.org/project/sparsestack/)[![Conda](https://img.shields.io/conda/v/conda-forge/sparsestack?color=blue)](https://anaconda.org/conda-forge/sparsestack)![GitHub Workflow Status](https://img.shields.io/github/workflow/status/florian-huber/sparsestack/CI%20Build)[![fair-software.eu](https://img.shields.io/badge/fair--software.eu-%E2%97%8F%20%20%E2%97%8F%20%20%E2%97%8F%20%20%E2%97%8F%20%20%E2%97%8B-yellow)](https://fair-software.eu)# sparsestackMemory efficient stack of multiple 2D sparse arrays.![sparsestack-overview-figure](/docs/sparsestack_overview_01.png)## Installation### RequirementsPython 3.7 or higher### Pip InstallSimply install using pip: `pip install sparsestack`## First code example```pythonimport numpy as npfrom sparsestack import StackedSparseArray# Create some fake datascores1 = np.random.random((12, 10))scores1[scores1 &lt; 0.9] = 0  # make &quot;sparse&quot;scores2 = np.random.random((12, 10))scores2[scores2 &lt; 0.75] = 0  # make &quot;sparse&quot;sparsestack = StackedSparseArray(12, 10)sparsestack.add_dense_matrix(scores1, &quot;scores_1&quot;)# Add second scores and filtersparsestack.add_dense_matrix(scores2, &quot;scores_2&quot;, join_type=&quot;left&quot;)# Scores can be accessed using (limited) slicing capabilitiessparsestack[3, 4]  # =&gt; scores_1 and scores_2 at position row=3, col=4sparsestack[3, :]  # =&gt; tuple with row, col, scores for all entries in row=3sparsestack[:, 2]  # =&gt; tuple with row, col, scores for all entries in col=2sparsestack[3, :, 0]  # =&gt; tuple with row, col, scores_1 for all entries in row=3sparsestack[3, :, &quot;scores_1&quot;]  # =&gt; same as the one before# Scores can also be converted to a dense numpy array:scores2_after_merge = sparsestack.to_array(&quot;scores_2&quot;)```## Adding data to a `sparsestack`-arraySparsestack provides three options to add data to a new layer.1) `.add_dense_matrix(input_array)`Can be used to add all none-zero elements of `input_array` to the sparsestack. Depending on the chosen `join_type` either all such values will be added (`join_type=&quot;outer&quot;` or `join_type=&quot;right&quot;`), or only those which are already present in underlying layers (&quot;left&quot; or &quot;inner&quot; join).2) `.add_sparse_matrix(input_coo_matrix)`This method will expect a COO-style matrix (e.g. scipy) which has attributes .row, .col and .data. The join type can again be specified using `join_type`.3) `.add_sparse_data(row, col, data)`This essentially does the same as `.add_sparse_matrix(input_coo_matrix)` but might in some cases be a bit more flexible because row, col and data are separate input arguments.## Accessing data from `sparsestack`-arrayThe collected sparse data can be accessed in multiple ways.1) Slicing.`sparsestack` allows multiple types of slicing (see also code example above).```pythonsparsestack[3, 4]  # =&gt; tuple with all scores at position row=3, col=4sparsestack[3, :]  # =&gt; tuple with row, col, scores for all entries in row=3sparsestack[:, 2]  # =&gt; tuple with row, col, scores for all entries in col=2sparsestack[3, :, 0]  # =&gt; tuple with row, col, scores_1 for all entries in row=3sparsestack[3, :, &quot;scores_1&quot;]  # =&gt; same as the one before```2) `.to_array()`Creates and returns a dense numpy array of size `.shape`. Can also be used to create a dense numpy array of only a single layer when used like `.to_array(name=&quot;layerX&quot;)`.  **Carefull:** Obviously by converting to a dense array, the sparse nature will be lost and all empty positions in the stack will be filled with zeros.3) `.to_coo(name=&quot;layerX&quot;)`Returns a scipy sparse COO-matrix of the specified layer.</longdescription>
</pkgmetadata>