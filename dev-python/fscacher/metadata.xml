<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://github.com/con/fscacher/workflows/Test/badge.svg?branch=master    :target: https://github.com/con/fscacher/actions?workflow=Test    :alt: CI Status.. image:: https://codecov.io/gh/con/fscacher/branch/master/graph/badge.svg    :target: https://codecov.io/gh/con/fscacher.. image:: https://img.shields.io/pypi/pyversions/fscacher.svg    :target: https://pypi.org/project/fscacher/.. image:: https://img.shields.io/github/license/con/fscacher.svg    :target: https://opensource.org/licenses/MIT    :alt: MIT License`GitHub &lt;https://github.com/con/fscacher&gt;`_| `PyPI &lt;https://pypi.org/project/fscacher/&gt;`_| `Issues &lt;https://github.com/con/fscacher/issues&gt;`_| `Changelog &lt;https://github.com/con/fscacher/blob/master/CHANGELOG.md&gt;`_``fscacher`` provides a cache &amp; decorator for memoizing functions whose outputsdepend upon the contents of a file argument.If you have a function ``foo()`` that takes a file path as its first argument,and if the behavior of ``foo()`` is pure in the *contents* of the path and thevalues of its other arguments, ``fscacher`` can help cache that function, likeso:.. code:: python    from fscacher import PersistentCache    cache = PersistentCache(&quot;insert_name_for_cache_here&quot;)    @cache.memoize_path    def foo(path, ...):        ...Now the outputs of ``foo()`` will be cached for each set of input arguments andfor a &quot;fingerprint&quot; (timestamps &amp; size) of each ``path``.  If ``foo()`` iscalled twice with the same set of arguments, the result from the first callwill be reused for the second, unless the file pointed to by ``path`` changes,in which case the function will be run again.  If ``foo()`` is called with anon-`path-like object&lt;https://docs.python.org/3/glossary.html#term-path-like-object&gt;`_ as the valueof ``path``, the cache is ignored.``memoize_path()`` optionally takes an ``exclude_kwargs`` argument, which mustbe a sequence of names of arguments of the decorated function that will beignored for caching purposes.Caches are stored on-disk and thus persist between Python runs.  To clear agiven ``PersistentCache`` and erase its data store, call the ``clear()``method.By default, caches are stored in the user-wide cache directory, under anfscacher-specific folder, with each one identified by the name passed to theconstructor (which defaults to &quot;cache&quot; if not specified).  To specify adifferent location, use the ``path`` argument to the constructor instead ofpassing a name:.. code:: python    cache = PersistentCache(path=&quot;/my/custom/location&quot;)If your code runs in an environment where different sets of libraries or thelike could be used in different runs, and these make a difference to the outputof your function, you can make the caching take them into account by passing alist of library version strings or other identifiers for the current run as the``token`` argument to the ``PersistentCache`` constructor.Finally, ``PersistentCache``'s constructor also optionally takes an ``envvar``argument giving the name of an environment variable.  If that environmentvariable is set to &quot;``clear``&quot; when the cache is constructed, the cache's``clear()`` method will be called at the end of initialization.  If theenvironment variable is set to &quot;``ignore``&quot; instead, then caching will bedisabled, and the cache's ``memoize_path`` method will be a no-op.  If thegiven environment variable is not set, or if ``envvar`` is not specified, then``PersistentCache`` will query the ``FSCACHER_CACHE`` environment variableinstead.Installation============``fscacher`` requires Python 3.7 or higher.  Just use `pip&lt;https://pip.pypa.io&gt;`_ for Python 3 (You have pip, right?) to install it andits dependencies::    python3 -m pip install fscacher</longdescription>
</pkgmetadata>