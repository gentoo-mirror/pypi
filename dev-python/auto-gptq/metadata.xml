<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;h1 align=&quot;center&quot;&gt;AutoGPTQ&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;An easy-to-use LLMs quantization package with user-friendly apis, based on GPTQ algorithm.&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://github.com/PanQiWei/AutoGPTQ/releases&quot;&gt;        &lt;img alt=&quot;GitHub release&quot; src=&quot;https://img.shields.io/github/release/PanQiWei/AutoGPTQ.svg&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://pypi.org/project/auto-gptq/&quot;&gt;        &lt;img alt=&quot;PyPI - Downloads&quot; src=&quot;https://img.shields.io/pypi/dd/auto-gptq&quot;&gt;    &lt;/a&gt;&lt;/p&gt;&lt;h4 align=&quot;center&quot;&gt;    &lt;p&gt;        &lt;b&gt;English&lt;/b&gt; |        &lt;a href=&quot;https://github.com/PanQiWei/AutoGPTQ/blob/main/README_zh.md&quot;&gt;ä¸­æ–‡&lt;/a&gt;    &lt;/p&gt;&lt;/h4&gt;&lt;details&gt;&lt;summary&gt;The path to v1.0.0&lt;/summary&gt;Hi, fellow community members, long time no see! I'm sorry that I haven't been able to update this project more frequently due to personal reasons during this period. The past few weeks have been huge in terms of my career plans. Not long ago, I officially bid farewell to the startup team that I joined for two years after graduation. I'm very grateful to the leaders and colleagues of the team for their trust and guidance, which enabled me to grow rapidly in two years; at the same time, I'm also really grateful to the team for allowing me to use the internal A100 GPU server cluster free of charge since the start of the AutoGPTQ project to complete various experiments and performance evaluations. (Of course, it can no longer be used in the future, so **it will mean a lot to me if there will be new hardware sponsorship!**) In the past two years, I have served as an AI engineer in this team, responsible for the LLM based dialogue system's architecture design and develop. We had successfully launched a product called gemsouls, but unfortunately it has ceased operations. Now, the team is about to launch a new product called [modelize](https://www.beta.modelize.ai/), which is **a LLM-native AI agent platform, where users can use multiple AI agents to build a highly automated team, allowing them to interact with each other in the workflow, collaborate to complete complex projects efficiently.**Getting back to the topic, I'm very excited to see that in the past few months, research on optimizing the inference performance of LLMs has made tremendous progress. Now we can not only complete the inference of LLMs on high-end GPUs efficiently, but also on CPUs and even edge devices. A series of technological advancements make me eager to make more contributions to the open source community. Therefore, I will first use about four weeks to gradually update AutoGPTQ to the v1.0.0 official version. During this period, there will also be 2~3 minor versions are released to allow users to experience performance optimization and new features timely. In my vision, **by the time v1.0.0 is officially released, AutoGPTQ will be able to serve as an extendable and flexible quantization backend that supports all GPTQ-like methods and automatically quantize LLMs written by Pytorch**. I detailed the development plan in [this issue](https://github.com/PanQiWei/AutoGPTQ/issues/348), feel free to drop in there for discussion and give your suggestions!&lt;/details&gt;## News or Update- 2023-08-23 - (News) - ðŸ¤— Transformers, optimum and peft have integrated `auto-gptq`, so now running and training GPTQ models can be more available to everyone! See [this blog](https://huggingface.co/blog/gptq-integration) and it's resources for more details!- 2023-08-21 - (News) - Team of Qwen officially released 4bit quantized version of Qwen-7B based on `auto-gptq`, and provided [a detailed benchmark results](https://huggingface.co/Qwen/Qwen-7B-Chat-Int4#%E9%87%8F%E5%8C%96-quantization)- 2023-08-06 - (Update) - Support exllama's q4 CUDA kernel to have at least 1.3x speed up for int4 quantized models when doing inference.- 2023-08-04 - (Update) - Support RoCm so that AMD GPU users can use auto-gptq with CUDA extensions.- 2023-07-26 - (Update) - An elegant [PPL benchmark script](examples/benchmark/perplexity.py) to get results that can be fairly compared with other libraries such as `llama.cpp`.- 2023-06-05 - (Update) - Integrate with ðŸ¤— peft to use gptq quantized model to train adapters, support LoRA, AdaLoRA, AdaptionPrompt, etc.- 2023-05-30 - (Update) - Support download/upload quantized model from/to ðŸ¤— Hub.*For more histories please turn to [here](docs/NEWS_OR_UPDATE.md)*## Performance Comparison### Inference Speed&gt; The result is generated using [this script](examples/benchmark/generation_speed.py), batch size of input is 1, decode strategy is beam search and enforce the model to generate 512 tokens, speed metric is tokens/s (the larger, the better).&gt;&gt; The quantized model is loaded using the setup that can gain the fastest inference speed.| model         | GPU           | num_beams | fp16  | gptq-int4 ||---------------|---------------|-----------|-------|-----------|| llama-7b      | 1xA100-40G    | 1         | 18.87 | 25.53     || llama-7b      | 1xA100-40G    | 4         | 68.79 | 91.30     || moss-moon 16b | 1xA100-40G    | 1         | 12.48 | 15.25     || moss-moon 16b | 1xA100-40G    | 4         | OOM   | 42.67     || moss-moon 16b | 2xA100-40G    | 1         | 06.83 | 06.78     || moss-moon 16b | 2xA100-40G    | 4         | 13.10 | 10.80     || gpt-j 6b      | 1xRTX3060-12G | 1         | OOM   | 29.55     || gpt-j 6b      | 1xRTX3060-12G | 4         | OOM   | 47.36     |### PerplexityFor perplexity comparison, you can turn to [here](https://github.com/qwopqwop200/GPTQ-for-LLaMa#result) and [here](https://github.com/qwopqwop200/GPTQ-for-LLaMa#gptq-vs-bitsandbytes)## Installation### Quick InstallationYou can install the latest stable release of AutoGPTQ from pip with pre-built wheels compatible with PyTorch 2.0.1:* For CUDA 11.7: `pip install auto-gptq`* For CUDA 11.8: `pip install auto-gptq --extra-index-url https://huggingface.github.io/autogptq-index/whl/cu118/`* For RoCm 5.4.2: `pip install auto-gptq --extra-index-url https://huggingface.github.io/autogptq-index/whl/rocm542/`**Warning:** These wheels are not expected to work on PyTorch nightly. Please install AutoGPTQ from source when using PyTorch nightly.AutoGPTQ can be installed with the Triton dependency with `pip install auto-gptq[triton]` in order to be able to use the Triton backend (currently only supports linux, no 3-bits quantization).### Install from sourceClone the source code:```shellgit clone https://github.com/PanQiWei/AutoGPTQ.git &amp;&amp; cd AutoGPTQA few packages are required in order to build from source: `pip install numpy gekko pandas`.```Then, install from source:```shellpip install -v .```You can set `BUILD_CUDA_EXT=0` to disable pytorch extension building, but this is **strongly discouraged** as AutoGPTQ then falls back on a slow python implementation.#### On RoCm systemsTo install from source for AMD GPUs supporting RoCm, please specify the `ROCM_VERSION` environment variable. Example:```ROCM_VERSION=5.6 pip install -v .```The compilation can be speeded up by specifying the `PYTORCH_ROCM_ARCH` variable ([reference](https://github.com/pytorch/pytorch/blob/7b73b1e8a73a1777ebe8d2cd4487eb13da55b3ba/setup.py#L132)) in order to build for a single target device, for example `gfx90a` for MI200 series devices.For RoCm systems, the packages `rocsparse-dev`, `hipsparse-dev`, `rocthrust-dev`, `rocblas-dev` and `hipblas-dev` are required to build.The following combinations are tested:| RoCm version | PyTorch version ||--------------|-----------------|| 5.4.2        | 2.0.1           || 5.6          | 2.1.0           || 5.7          | nightly (2.2.0.dev2023)         |## Quick Tour### Quantization and Inference&gt; warning: this is just a showcase of the usage of basic apis in AutoGPTQ, which uses only one sample to quantize a much small model, quality of quantized model using such little samples may not good.Below is an example for the simplest use of `auto_gptq` to quantize a model and inference after quantization:```pythonfrom transformers import AutoTokenizer, TextGenerationPipelinefrom auto_gptq import AutoGPTQForCausalLM, BaseQuantizeConfigimport logginglogging.basicConfig(    format=&quot;%(asctime)s %(levelname)s [%(name)s] %(message)s&quot;, level=logging.INFO, datefmt=&quot;%Y-%m-%d %H:%M:%S&quot;)pretrained_model_dir = &quot;facebook/opt-125m&quot;quantized_model_dir = &quot;opt-125m-4bit&quot;tokenizer = AutoTokenizer.from_pretrained(pretrained_model_dir, use_fast=True)examples = [    tokenizer(        &quot;auto-gptq is an easy-to-use model quantization library with user-friendly apis, based on GPTQ algorithm.&quot;    )]quantize_config = BaseQuantizeConfig(    bits=4,  # quantize model to 4-bit    group_size=128,  # it is recommended to set the value to 128    desc_act=False,  # set to False can significantly speed up inference but the perplexity may slightly bad)# load un-quantized model, by default, the model will always be loaded into CPU memorymodel = AutoGPTQForCausalLM.from_pretrained(pretrained_model_dir, quantize_config)# quantize model, the examples should be list of dict whose keys can only be &quot;input_ids&quot; and &quot;attention_mask&quot;model.quantize(examples)# save quantized modelmodel.save_quantized(quantized_model_dir)# save quantized model using safetensorsmodel.save_quantized(quantized_model_dir, use_safetensors=True)# push quantized model to Hugging Face Hub.# to use use_auth_token=True, Login first via huggingface-cli login.# or pass explcit token with: use_auth_token=&quot;hf_xxxxxxx&quot;# (uncomment the following three lines to enable this feature)# repo_id = f&quot;YourUserName/{quantized_model_dir}&quot;# commit_message = f&quot;AutoGPTQ model for {pretrained_model_dir}: {quantize_config.bits}bits, gr{quantize_config.group_size}, desc_act={quantize_config.desc_act}&quot;# model.push_to_hub(repo_id, commit_message=commit_message, use_auth_token=True)# alternatively you can save and push at the same time# (uncomment the following three lines to enable this feature)# repo_id = f&quot;YourUserName/{quantized_model_dir}&quot;# commit_message = f&quot;AutoGPTQ model for {pretrained_model_dir}: {quantize_config.bits}bits, gr{quantize_config.group_size}, desc_act={quantize_config.desc_act}&quot;# model.push_to_hub(repo_id, save_dir=quantized_model_dir, use_safetensors=True, commit_message=commit_message, use_auth_token=True)# load quantized model to the first GPUmodel = AutoGPTQForCausalLM.from_quantized(quantized_model_dir, device=&quot;cuda:0&quot;)# download quantized model from Hugging Face Hub and load to the first GPU# model = AutoGPTQForCausalLM.from_quantized(repo_id, device=&quot;cuda:0&quot;, use_safetensors=True, use_triton=False)# inference with model.generateprint(tokenizer.decode(model.generate(**tokenizer(&quot;auto_gptq is&quot;, return_tensors=&quot;pt&quot;).to(model.device))[0]))# or you can also use pipelinepipeline = TextGenerationPipeline(model=model, tokenizer=tokenizer)print(pipeline(&quot;auto-gptq is&quot;)[0][&quot;generated_text&quot;])```For more advanced features of model quantization, please reference to [this script](examples/quantization/quant_with_alpaca.py)### Customize Model&lt;details&gt;&lt;summary&gt;Below is an example to extend `auto_gptq` to support `OPT` model, as you will see, it's very easy:&lt;/summary&gt;```pythonfrom auto_gptq.modeling import BaseGPTQForCausalLMclass OPTGPTQForCausalLM(BaseGPTQForCausalLM):    # chained attribute name of transformer layer block    layers_block_name = &quot;model.decoder.layers&quot;    # chained attribute names of other nn modules that in the same level as the transformer layer block    outside_layer_modules = [        &quot;model.decoder.embed_tokens&quot;, &quot;model.decoder.embed_positions&quot;, &quot;model.decoder.project_out&quot;,        &quot;model.decoder.project_in&quot;, &quot;model.decoder.final_layer_norm&quot;    ]    # chained attribute names of linear layers in transformer layer module    # normally, there are four sub lists, for each one the modules in it can be seen as one operation,    # and the order should be the order when they are truly executed, in this case (and usually in most cases),    # they are: attention q_k_v projection, attention output projection, MLP project input, MLP project output    inside_layer_modules = [        [&quot;self_attn.k_proj&quot;, &quot;self_attn.v_proj&quot;, &quot;self_attn.q_proj&quot;],        [&quot;self_attn.out_proj&quot;],        [&quot;fc1&quot;],        [&quot;fc2&quot;]    ]```After this, you can use `OPTGPTQForCausalLM.from_pretrained` and other methods as shown in Basic.&lt;/details&gt;### Evaluation on Downstream TasksYou can use tasks defined in `auto_gptq.eval_tasks` to evaluate model's performance on specific down-stream task before and after quantization.The predefined tasks support all causal-language-models implemented in [ðŸ¤— transformers](https://github.com/huggingface/transformers) and in this project.&lt;details&gt;&lt;summary&gt;Below is an example to evaluate `EleutherAI/gpt-j-6b` on sequence-classification task using `cardiffnlp/tweet_sentiment_multilingual` dataset:&lt;/summary&gt;```pythonfrom functools import partialimport datasetsfrom transformers import AutoTokenizer, AutoModelForCausalLM, GenerationConfigfrom auto_gptq import AutoGPTQForCausalLM, BaseQuantizeConfigfrom auto_gptq.eval_tasks import SequenceClassificationTaskMODEL = &quot;EleutherAI/gpt-j-6b&quot;DATASET = &quot;cardiffnlp/tweet_sentiment_multilingual&quot;TEMPLATE = &quot;Question:What's the sentiment of the given text? Choices are {labels}.\nText: {text}\nAnswer:&quot;ID2LABEL = {    0: &quot;negative&quot;,    1: &quot;neutral&quot;,    2: &quot;positive&quot;}LABELS = list(ID2LABEL.values())def ds_refactor_fn(samples):    text_data = samples[&quot;text&quot;]    label_data = samples[&quot;label&quot;]    new_samples = {&quot;prompt&quot;: [], &quot;label&quot;: []}    for text, label in zip(text_data, label_data):        prompt = TEMPLATE.format(labels=LABELS, text=text)        new_samples[&quot;prompt&quot;].append(prompt)        new_samples[&quot;label&quot;].append(ID2LABEL[label])    return new_samples#  model = AutoModelForCausalLM.from_pretrained(MODEL).eval().half().to(&quot;cuda:0&quot;)model = AutoGPTQForCausalLM.from_pretrained(MODEL, BaseQuantizeConfig())tokenizer = AutoTokenizer.from_pretrained(MODEL)task = SequenceClassificationTask(        model=model,        tokenizer=tokenizer,        classes=LABELS,        data_name_or_path=DATASET,        prompt_col_name=&quot;prompt&quot;,        label_col_name=&quot;label&quot;,        **{            &quot;num_samples&quot;: 1000,  # how many samples will be sampled to evaluation            &quot;sample_max_len&quot;: 1024,  # max tokens for each sample            &quot;block_max_len&quot;: 2048,  # max tokens for each data block            # function to load dataset, one must only accept data_name_or_path as input            # and return datasets.Dataset            &quot;load_fn&quot;: partial(datasets.load_dataset, name=&quot;english&quot;),            # function to preprocess dataset, which is used for datasets.Dataset.map,            # must return Dict[str, list] with only two keys: [prompt_col_name, label_col_name]            &quot;preprocess_fn&quot;: ds_refactor_fn,            # truncate label when sample's length exceed sample_max_len            &quot;truncate_prompt&quot;: False        }    )# note that max_new_tokens will be automatically specified internally based on given classesprint(task.run())# self-consistencyprint(    task.run(        generation_config=GenerationConfig(            num_beams=3,            num_return_sequences=3,            do_sample=True        )    ))```&lt;/details&gt;## Learn More[tutorials](docs/tutorial) provide step-by-step guidance to integrate `auto_gptq` with your own project and some best practice principles.[examples](examples/README.md) provide plenty of example scripts to use `auto_gptq` in different ways.## Supported Models&gt; you can use `model.config.model_type` to compare with the table below to check whether the model you use is supported by `auto_gptq`.&gt;&gt; for example, model_type of `WizardLM`, `vicuna` and `gpt4all` are all `llama`, hence they are all supported by `auto_gptq`.| model type                         | quantization | inference | peft-lora | peft-ada-lora | peft-adaption_prompt                                                                            ||------------------------------------|--------------|-----------|-----------|---------------|-------------------------------------------------------------------------------------------------|| bloom                              | âœ…            | âœ…         | âœ…         | âœ…             |                                                                                                 || gpt2                               | âœ…            | âœ…         | âœ…         | âœ…             |                                                                                                 || gpt_neox                           | âœ…            | âœ…         | âœ…         | âœ…             | âœ…[requires this peft branch](https://github.com/PanQiWei/peft/tree/multi_modal_adaption_prompt) || gptj                               | âœ…            | âœ…         | âœ…         | âœ…             | âœ…[requires this peft branch](https://github.com/PanQiWei/peft/tree/multi_modal_adaption_prompt) || llama                              | âœ…            | âœ…         | âœ…         | âœ…             | âœ…                                                                                               || moss                               | âœ…            | âœ…         | âœ…         | âœ…             | âœ…[requires this peft branch](https://github.com/PanQiWei/peft/tree/multi_modal_adaption_prompt) || opt                                | âœ…            | âœ…         | âœ…         | âœ…             |                                                                                                 || gpt_bigcode                        | âœ…            | âœ…         | âœ…         | âœ…             |                                                                                                 || codegen                            | âœ…            | âœ…         | âœ…         | âœ…             |                                                                                                 || falcon(RefinedWebModel/RefinedWeb) | âœ…            | âœ…         | âœ…         | âœ…             |                                                                                                 |## Supported Evaluation TasksCurrently, `auto_gptq` supports: `LanguageModelingTask`, `SequenceClassificationTask` and `TextSummarizationTask`; more Tasks will come soon!## Running testsTests can be run with:```pytest tests/ -s```## Acknowledgement- Specially thanks **Elias Frantar**, **Saleh Ashkboos**, **Torsten Hoefler** and **Dan Alistarh** for proposing **GPTQ** algorithm and open source the [code](https://github.com/IST-DASLab/gptq).- Specially thanks **qwopqwop200**, for code in this project that relevant to quantization are mainly referenced from [GPTQ-for-LLaMa](https://github.com/qwopqwop200/GPTQ-for-LLaMa/tree/cuda).[![Star History Chart](https://api.star-history.com/svg?repos=PanQiwei/AutoGPTQ&amp;type=Date)](https://star-history.com/#PanQiWei/AutoGPTQ&amp;Date)</longdescription>
</pkgmetadata>