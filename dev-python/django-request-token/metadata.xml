<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>## Supported versionsThis project supports Django 3.2+ and Python 3.8+. The latest versionsupported is Django 4.1 running on Python 3.11.## Django Request TokenDjango app that uses JWT to manage one-time and expiring tokens toprotect URLs.This app currently requires the use of PostgreSQL.### BackgroundThis project was borne out of our experiences at YunoJuno with 'expiringlinks' - which is a common use case of providing users with a URL thatperforms a single action, and may bypass standard authentication. Awell-known use of this is the ubiquitous 'unsubscribe' link you findat the bottom of newsletters. You click on the link and it immediatelyunsubscribes you, irrespective of whether you are already authenticatedor not.If you google &quot;temporary url&quot;, &quot;one-time link&quot; or something similar youwill find lots of StackOverflow articles on supporting this in Django -it's pretty obvious, you have a dedicated token url, and you store thetokens in a model - when they are used you expire the token, and itcan't be used again. This works well, but it falls down in a number ofareas:* Hard to support multiple endpoints (views)If you want to support the same functionality (expiring links) for morethan one view in your project, you either need to have multiple modelsand token handlers, or you need to store the specific view function andargs in the model; neither of these is ideal.* Hard to debugIf you use have a single token url view that proxies view functions, youneed to store the function name, args and it then becomes hard tosupport - when someone claims that they clicked on`example.com/t/&lt;token&gt;`, you can't tell what that would resolve towithout looking it up in the database - which doesn't work for customersupport.* Hard to support multiple scenariosSome links expire, others have usage quotas - some have both. Links maybe for use by a single user, or multiple users.This project is intended to provide an easy-to-support mechanism for'tokenising' URLs without having to proxy view functions - you can buildwell-formed Django URLs and views, and then add request token supportafterwards.### Use CasesThis project supports three core use cases, each of which is modelledusing the `login_mode` attribute of a request token:1. Public link with payload2. ~~Single authenticated request~~ (DEPRECATED: use `django-visitor-pass`)3. ~~Auto-login~~ (DEPRECATED: use `django-magic-link`)**Public Link** (`RequestToken.LOGIN_MODE_NONE`)In this mode (the default for a new token), there is no authentication,and no assigned user. The token is used as a mechanism for attaching apayload to the link. An example of this might be a custom registrationor affiliate link, that renders the standard template with additionalinformation extracted from the token - e.g. the name of the affiliate,or the person who invited you to register.```python# a token that can be used to access a public url, without authenticating# as a user, but carrying a payload (affiliate_id).token = RequestToken.objects.create_token(    scope=&quot;foo&quot;,    login_mode=RequestToken.LOGIN_MODE_NONE,    data={        'affiliate_id': 1    })...@use_request_token(scope=&quot;foo&quot;)function view_func(request):    # extract the affiliate id from an token _if_ one is supplied    affiliate_id = (        request.token.data['affiliate_id']        if hasattr(request, 'token')        else None    )```**Single Request** (`RequestToken.LOGIN_MODE_REQUEST`)In Request mode, the request.user property is overridden by the userspecified in the token, but only for a single request. This is usefulfor responding to a single action (e.g. RSVP, unsubscribe). If the userthen navigates onto another page on the site, they will not beauthenticated. If the user is already authenticated, but as a differentuser to the one in the token, then they will receive a 403 response.```python# this token will identify the request.user as a given user, but only for# a single request - not the entire session.token = RequestToken.objects.create_token(    scope=&quot;foo&quot;,    login_mode=RequestToken.LOGIN_MODE_REQUEST,    user=User.objects.get(username=&quot;hugo&quot;))...@use_request_token(scope=&quot;foo&quot;)function view_func(request):    assert request.user == User.objects.get(username=&quot;hugo&quot;)```**Auto-login** (`RequestToken.LOGIN_MODE_SESSION`)This is the nuclear option, and must be treated with extreme care. Usinga Session token will automatically log the user in for an entiresession, giving the user who clicks on the link full access the tokenuser's account. This is useful for automatic logins. A good example ofthis is the email login process on medium.com, which takes an emailaddress (no password) and sends out a login link.Session tokens have a default expiry of ten minutes.```python# this token will log in as the given user for the entire session -# NB use with caution.token = RequestToken.objects.create_token(    scope=&quot;foo&quot;,    login_mode=RequestToken.LOGIN_MODE_SESSION,    user=User.objects.get(username=&quot;hugo&quot;))```### ImplementationThe project contains middleware and a view function decorator thattogether validate request tokens added to site URLs.**request_token.models.RequestToken** - stores the token detailsStep 1 is to create a `RequestToken` - this has various attributes thatcan be used to modify its behaviour, and mandatory property - `scope`.This is a text value - it can be anything you like - it is used by thefunction decorator (described below) to confirm that the token givenmatches the function being called - i.e. the `token.scope` must matchthe function decorator scope kwarg:```pythontoken = RequestToken(scope=&quot;foo&quot;)# this will raise a 403 without even calling the function@use_request_token(scope=&quot;bar&quot;)def incorrect_scope(request):    pass# this will call the function as expected@use_request_token(scope=&quot;foo&quot;)def correct_scope(request):    pass```The token itself - the value that must be appended to links as aquerystring argument - is a JWT - and comes from the`RequestToken.jwt()` method. For example, if you were sending out anemail, you might render the email as an HTML template like this:```html{% if token %}    &lt;a href=&quot;{{url}}?rt={{token.jwt}}&gt;click here&lt;/a&gt;{% else %}    &lt;a href=&quot;{{url}}&quot;&gt;click here&lt;/a&gt;{% endif %}```If you haven't come across JWT before you can find out more on the[jwt.io](https://jwt.io/) website. The token produced will include thefollowing JWT claims (available as the property `RequestToken.claims`:* `max`: maximum times the token can be used* `sub`: the scope* `mod`: the login mode* `jti`: the token id* `aud`: (optional) the user the token represents* `exp`: (optional) the expiration time of the token* `iat`: (optional) the time the token was issued* `ndf`: (optional) the not-before-time of the token**request_token.models.RequestTokenLog** - stores usage data for tokensEach time a token is used successfully, a log object is written to thedatabase. This provided an audit log of the usage, and it stores clientIP address and user agent, so can be used to debug issues. This can bedisabled using the `REQUEST_TOKEN_DISABLE_LOGS` setting. The logs tablecan be maintained using the management command as described below.**request_token.middleware.RequestTokenMiddleware** - decodes and verifies tokensThe `RequestTokenMiddleware` will look for a querystring token value(the argument name defaults to 'rt' and can overridden using the`JWT_QUERYSTRING_ARG` setting), and if it finds one it will verify thetoken (using the JWT decode verification). If the token is verified, itwill fetch the token object from the database and perform additionalvalidation against the token attributes. If the token checks out it isadded to the incoming request as a `token` attribute. This way you canadd arbitrary data (stored on the token) to incoming requests.If the token has a user specified, then the `request.user` is updated toreflect this. The middleware must run after the Django auth middleware,and before any custom middleware that inspects / monkey-patches the`request.user`.If the token cannot be verified it returns a 403.**request_token.decorators.use_request_token** - applies tokenpermissions to viewsA function decorator that takes one mandatory kwargs (`scope`) and oneoptional kwargs (`required`). The `scope` is used to match tokens toview functions - it's just a straight text match - the value can beanything you like, but if the token scope is 'foo', then thecorresponding view function decorator scope must match. The `required`kwarg is used to indicate whether the view **must** have a token inorder to be used, or not. This defaults to False - if a token **is**provided, then it will be validated, if not, the view function is calledas is.If the scopes do not match then a 403 is returned.If required is True and no token is provided the a 403 is returned.### InstallationDownload / install the app using pip:```shellpip install django-request-token```Add the app `request_token` to your `INSTALLED_APPS` Django setting:```python# settings.pyINSTALLED_APPS = (    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    'request_token',    ...)```Add the middleware to your settings, **after** the standardauthentication middleware, and before any custom middleware that usesthe `request.user`.```pythonMIDDLEWARE_CLASSES = [    # default django middleware    'django.contrib.sessions.middleware.SessionMiddleware',    'django.middleware.common.CommonMiddleware',    'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'request_token.middleware.RequestTokenMiddleware',]```You can now add `RequestToken` objects, either via the shell (or withinyour app) or through the admin interface. Once you have added a`RequestToken` you can add the token JWT to your URLs (using the `jwt()`method):```python&gt;&gt;&gt; token = RequestToken.objects.create_token(scope=&quot;foo&quot;)&gt;&gt;&gt; url = &quot;https://example.com/foo?rt=&quot; + token.jwt()```You now have a request token enabled URL. You can use this token toprotect a view function using the view decorator:```python@use_request_token(scope=&quot;foo&quot;)function foo(request):    pass```NB The 'scope' argument to the decorator is used to bind the function tothe incoming token - if someone tries to use a valid token on anotherURL, this will return a 403.**NB this currently supports only view functions - not class-based views.**### Management commandsThere is a single management command, `truncate_request_token_log` which canbe used to manage the size of the log table (each token usage is logged tothe database). It supports two arguments - `--max-count` and `--max-days` whichare self-explanatory:```$ python manage.py truncate_request_token_log --max-count=100Truncating request token log records:-&gt; Retaining last 100 request token log records-&gt; Truncating request token log records from 2021-08-01 00:00:00-&gt; Truncating 0 request token log records.$```### Settings* `REQUEST_TOKEN_QUERYSTRING`The querystring argument name used to extract the token from incomingrequests, defaults to **rt**.* `REQUEST_TOKEN_EXPIRY`Session tokens have a default expiry interval, specified in minutes. Theprimary use case (above) dictates that the expiry should be no longerthan it takes to receive and open an email, defaults to **10**(minutes).* `REQUEST_TOKEN_403_TEMPLATE`Specifying the 403-template so that for prettyfying the 403-response,in production with a setting like:```pythonFOUR03_TEMPLATE = os.path.join(BASE_DIR,'...','403.html')```* `REQUEST_TOKEN_DISABLE_LOGS`Set to `True` to disable the creation of `RequestTokenLog` objects oneach use of a token. This is not recommended in production, as theauditing of token use is a valuable part of the library.### TestsThere is a set of `tox` tests.### LicenseMIT### ContributingThis is by no means complete, however, it's good enough to be of value, hence releasing it.If you would like to contribute to the project, usual Github rules apply:1. Fork the repo to your own account2. Submit a pull request3. Add tests for any new code4. Follow coding style of existing project### Acknowledgements@jpadilla for [PyJWT](https://github.com/jpadilla/pyjwt/)</longdescription>
</pkgmetadata>