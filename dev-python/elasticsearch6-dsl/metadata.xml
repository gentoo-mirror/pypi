<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Elasticsearch DSL=================Elasticsearch DSL is a high-level library whose aim is to help with writing andrunning queries against Elasticsearch. It is built on top of the officiallow-level client (`elasticsearch-py &lt;https://github.com/elastic/elasticsearch-py&gt;`_).It provides a more convenient and idiomatic way to write and manipulatequeries. It stays close to the Elasticsearch JSON DSL, mirroring itsterminology and structure. It exposes the whole range of the DSL from Pythoneither directly using defined classes or a queryset-like expressions.It also provides an optional wrapper for working with documents as Pythonobjects: defining mappings, retrieving and saving documents, wrapping thedocument data in user-defined classes.To use the other Elasticsearch APIs (eg. cluster health) just use theunderlying client.Installation------------::  pip install elasticsearch-dslExamples--------Please see the `examples&lt;https://github.com/elastic/elasticsearch-dsl-py/tree/master/examples&gt;`_directory to see some complex examples using ``elasticsearch-dsl``.Compatibility-------------The library is compatible with all Elasticsearch versions since ``2.x`` but you**have to use a matching major version**:For **Elasticsearch 6.0** and later, use the major version 6 (``6.x.y``) of thelibrary.For **Elasticsearch 5.0** and later, use the major version 5 (``5.x.y``) of thelibrary.For **Elasticsearch 2.0** and later, use the major version 2 (``2.x.y``) of thelibrary.The recommended way to set your requirements in your `setup.py` or`requirements.txt` is::    # Elasticsearch 6.x    elasticsearch-dsl&gt;=6.0.0,&lt;7.0.0    # Elasticsearch 5.x    elasticsearch-dsl&gt;=5.0.0,&lt;6.0.0    # Elasticsearch 2.x    elasticsearch-dsl&gt;=2.0.0,&lt;3.0.0The development is happening on ``master``, older branches only get bugfix releasesSearch Example--------------Let's have a typical search request written directly as a ``dict``:.. code:: python    from elasticsearch import Elasticsearch    client = Elasticsearch()    response = client.search(        index=&quot;my-index&quot;,        body={          &quot;query&quot;: {            &quot;bool&quot;: {              &quot;must&quot;: [{&quot;match&quot;: {&quot;title&quot;: &quot;python&quot;}}],              &quot;must_not&quot;: [{&quot;match&quot;: {&quot;description&quot;: &quot;beta&quot;}}],              &quot;filter&quot;: [{&quot;term&quot;: {&quot;category&quot;: &quot;search&quot;}}]            }          },          &quot;aggs&quot; : {            &quot;per_tag&quot;: {              &quot;terms&quot;: {&quot;field&quot;: &quot;tags&quot;},              &quot;aggs&quot;: {                &quot;max_lines&quot;: {&quot;max&quot;: {&quot;field&quot;: &quot;lines&quot;}}              }            }          }        }    )    for hit in response['hits']['hits']:        print(hit['_score'], hit['_source']['title'])    for tag in response['aggregations']['per_tag']['buckets']:        print(tag['key'], tag['max_lines']['value'])The problem with this approach is that it is very verbose, prone to syntaxmistakes like incorrect nesting, hard to modify (eg. adding another filter) anddefinitely not fun to write.Let's rewrite the example using the Python DSL:.. code:: python    from elasticsearch import Elasticsearch    from elasticsearch_dsl import Search    client = Elasticsearch()    s = Search(using=client, index=&quot;my-index&quot;) \        .filter(&quot;term&quot;, category=&quot;search&quot;) \        .query(&quot;match&quot;, title=&quot;python&quot;)   \        .exclude(&quot;match&quot;, description=&quot;beta&quot;)    s.aggs.bucket('per_tag', 'terms', field='tags') \        .metric('max_lines', 'max', field='lines')    response = s.execute()    for hit in response:        print(hit.meta.score, hit.title)    for tag in response.aggregations.per_tag.buckets:        print(tag.key, tag.max_lines.value)As you see, the library took care of:  * creating appropriate ``Query`` objects by name (eq. &quot;match&quot;)  * composing queries into a compound ``bool`` query  * putting the ``term`` query in a filter context of the ``bool`` query  * providing a convenient access to response data  * no curly or square brackets everywherePersistence Example-------------------Let's have a simple Python class representing an article in a blogging system:.. code:: python    from datetime import datetime    from elasticsearch_dsl import Document, Date, Integer, Keyword, Text, connections    # Define a default Elasticsearch client    connections.create_connection(hosts=['localhost'])    class Article(Document):        title = Text(analyzer='snowball', fields={'raw': Keyword()})        body = Text(analyzer='snowball')        tags = Keyword()        published_from = Date()        lines = Integer()        class Index:            name = 'blog'            settings = {              &quot;number_of_shards&quot;: 2,            }        def save(self, ** kwargs):            self.lines = len(self.body.split())            return super(Article, self).save(** kwargs)        def is_published(self):            return datetime.now() &gt; self.published_from    # create the mappings in elasticsearch    Article.init()    # create and save and article    article = Article(meta={'id': 42}, title='Hello world!', tags=['test'])    article.body = ''' looong text '''    article.published_from = datetime.now()    article.save()    article = Article.get(id=42)    print(article.is_published())    # Display cluster health    print(connections.get_connection().cluster.health())In this example you can see:  * providing a default connection  * defining fields with mapping configuration  * setting index name  * defining custom methods  * overriding the built-in ``.save()`` method to hook into the persistence    life cycle  * retrieving and saving the object into Elasticsearch  * accessing the underlying client for other APIsYou can see more in the persistence chapter of the documentation.Migration from ``elasticsearch-py``-----------------------------------You don't have to port your entire application to get the benefits of thePython DSL, you can start gradually by creating a ``Search`` object from yourexisting ``dict``, modifying it using the API and serializing it back to a``dict``:.. code:: python    body = {...} # insert complicated query here    # Convert to Search object    s = Search.from_dict(body)    # Add some filters, aggregations, queries, ...    s.filter(&quot;term&quot;, tags=&quot;python&quot;)    # Convert back to dict to plug back into existing code    body = s.to_dict()Development-----------Activate Virtual Environment (`virtualenvs &lt;http://docs.python-guide.org/en/latest/dev/virtualenvs/&gt;`_):.. code:: bash    $ virtualenv venv    $ source venv/bin/activateTo install all of the dependencies necessary for development, run:.. code:: bash    $ pip install -e '.[develop]'To run all of the tests for ``elasticsearch-dsl-py``, run:.. code:: bash    $ python setup.py testAlternatively, it is possible to use the ``run_tests.py`` script in``test_elasticsearch_dsl``, which wraps `pytest&lt;http://doc.pytest.org/en/latest/&gt;`_, to run subsets of the test suite. Someexamples can be seen below:.. code:: bash    # Run all of the tests in `test_elasticsearch_dsl/test_analysis.py`    $ ./run_tests.py test_analysis.py    # Run only the `test_analyzer_serializes_as_name` test.    $ ./run_tests.py test_analysis.py::test_analyzer_serializes_as_name``pytest`` will skip tests from ``test_elasticsearch_dsl/test_integration``unless there is an instance of Elasticsearch on which a connection can occur.By default, the test connection is attempted at ``localhost:9200``, based onthe defaults specified in the ``elasticsearch-py`` `Connection&lt;https://github.com/elastic/elasticsearch-py/blob/master/elasticsearch/connection/base.py#L29&gt;`_ class. **Because running the integrationtests will cause destructive changes to the Elasticsearch cluster, only runthem when the associated cluster is empty.** As such, if theElasticsearch instance at ``localhost:9200`` does not meet these requirements,it is possible to specify a different test Elasticsearch server through the``TEST_ES_SERVER`` environment variable... code:: bash    $ TEST_ES_SERVER=my-test-server:9201 ./run_testsDocumentation-------------Documentation is available at https://elasticsearch-dsl.readthedocs.io.Contribution Guide------------------Want to hack on Elasticsearch DSL? Awesome! We have `Contribution-Guide &lt;https://github.com/elastic/elasticsearch-dsl-py/blob/master/CONTRIBUTING.rst&gt;`_.License-------Copyright 2013 ElasticsearchLicensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.</longdescription>
</pkgmetadata>