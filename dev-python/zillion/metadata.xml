<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Zillion: Make sense of it all=============================[![Generic badge](https://img.shields.io/badge/Status-Alpha-yellow.svg)](https://shields.io/)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)![License: MIT](https://img.shields.io/badge/license-MIT-blue)![Python 3.6+](https://img.shields.io/badge/python-3.6%2B-blue)[![Downloads](https://static.pepy.tech/badge/zillion)](https://pepy.tech/project/zillion)**Introduction**----------------`Zillion` is a data modeling and analytics tool that allows combining andanalyzing data from multiple datasources through a simple API. It acts as a semantic layeron top of your data, writes SQL so you don't have to, and easily bolts onto existingdatabase infrastructure via SQLAlchemy Core. The `Zillion` NLP extension has experimentalsupport for AI-powered natural language querying and warehouse configuration.With `Zillion` you can:* Define a warehouse that contains a variety of SQL and/or file-like  datasources* Define or reflect metrics, dimensions, and relationships in your data* Run multi-datasource reports and combine the results in a DataFrame* Flexibly aggregate your data with multi-level rollups and table pivots* Customize or combine fields with formulas* Apply technical transformations including rolling, cumulative, and rank  statistics* Apply automatic type conversions - i.e. get a &quot;year&quot; dimension for free  from a &quot;date&quot; column* Save and share report specifications* Utilize ad hoc or public datasources, tables, and fields to enrich reports* Query your warehouse with natural language (NLP extension)* Leverage AI to bootstrap your warehouse configurations (NLP extension)**Table of Contents**---------------------* [Installation](#installation)* [Primer](#primer)    * [Metrics and Dimensions](#metrics-and-dimensions)    * [Warehouse Theory](#warehouse-theory)    * [Query Layers](#query-layers)    * [Warehouse Creation](#warehouse-creation)    * [Executing Reports](#executing-reports)    * [Natural Language Querying](#natural-language-querying)    * [Zillion Configuration](#zillion-configuration)* [Example - Sales Analytics](#example-sales-analytics)    * [Warehouse Configuration](#example-warehouse-config)    * [Reports](#example-reports)* [Advanced Topics](#advanced-topics)    * [Subreports](#subreports)    * [FormulaMetrics](#formula-metrics)    * [Divisor Metrics](#divisor-metrics)    * [FormulaDimensions](#formula-dimensions)    * [DataSource Formulas](#datasource-formulas)    * [Type Conversions](#type-conversions)    * [AdHocMetrics](#adhoc-metrics)    * [AdHocDimensions](#adhoc-dimensions)    * [AdHocDataTables](#adhoc-data-tables)    * [Technicals](#technicals)    * [Config Variables](#config-variables)    * [DataSource Priority](#datasource-priority)* [Supported DataSources](#supported-datasources)* [Multiprocess Considerations](#multiprocess-considerations)* [Demo UI / Web API](#demo-ui)* [Docs](#documentation)* [How to Contribute](#how-to-contribute)&lt;a name=&quot;installation&quot;&gt;&lt;/a&gt;**Installation**----------------&gt; **Warning**: This project is in an alpha state and is subject to change. Please test carefully for production usage and report any issues.```shell$ pip install zillionor$ pip install zillion[nlp]```---&lt;a name=&quot;primer&quot;&gt;&lt;/a&gt;**Primer**----------The following is meant to give a quick overview of some theory andnomenclature used in data warehousing with `Zillion` which will be usefulif you are newer to this area. You can also skip below for a usage [example](#example-sales-analytics) or warehouse/datasource creation [quickstart](#warehouse-creation) options.In short: `Zillion` writes SQL for you and makes data accessible through a very simple API:```pythonresult = warehouse.execute(    metrics=[&quot;revenue&quot;, &quot;leads&quot;],    dimensions=[&quot;date&quot;],    criteria=[        (&quot;date&quot;, &quot;&gt;&quot;, &quot;2020-01-01&quot;),        (&quot;partner&quot;, &quot;=&quot;, &quot;Partner A&quot;)    ])```&lt;a name=&quot;metrics-and-dimensions&quot;&gt;&lt;/a&gt;### **Metrics and Dimensions**In `Zillion` there are two main types of `Fields` that will be used inyour report requests:1. `Dimensions`: attributes of data used for labelling, grouping, and filtering2. `Metrics`: facts and measures that may be broken down along dimensionsA `Field` encapsulates the concept of a column in your data. For example, youmay have a `Field` called &quot;revenue&quot;. That `Field` may occur across severaldatasources or possibly in multiple tables within a single datasource. `Zillion` understands that all of those columns represent the same concept, and it can try to use any of them to satisfy reports requesting &quot;revenue&quot;.Likewise there are two main types of tables used to structure your warehouse:1. `Dimension Tables`: reference/attribute tables containing only relateddimensions2. `Metric Tables`: fact tables that may contain metrics and some relateddimensions/attributesDimension tables are often static or slowly growing in terms of row count and containattributes tied to a primary key. Some common examples would be lists of US Zip Codes orcompany/partner directories.Metric tables are generally more transactional in nature. Some common exampleswould be records for web requests, ecommerce sales, or stock market price history.&lt;a name=&quot;warehouse-theory&quot;&gt;&lt;/a&gt;### **Warehouse Theory**If you really want to go deep on dimensional modeling and the drill-acrossquerying technique `Zillion` employs, I recommend reading Ralph Kimball's[book](https://www.kimballgroup.com/data-warehouse-business-intelligence-resources/books/data-warehouse-dw-toolkit/) on data warehousing.To summarize, [drill-acrossquerying](https://www.kimballgroup.com/data-warehouse-business-intelligence-resources/kimball-techniques/dimensional-modeling-techniques/drilling-across/)forms one or more queries to satisfy a report request for `metrics` that mayexist across multiple datasources and/or tables at a particular `dimension` grain.`Zillion` supports flexible warehouse setups such as[snowflake](https://en.wikipedia.org/wiki/Snowflake_schema) or[star](https://en.wikipedia.org/wiki/Star_schema) schemas, though it isn'tpicky about it. You can specify table relationships through a parent-childlineage, and `Zillion` can also infer acceptable joins based on the presenceof dimension table primary keys. `Zillion` does not support many-to-many relationships at this time, though most analytics-focused scenarios should be able to work around that by adding views to the model if needed.&lt;a name=&quot;query-layers&quot;&gt;&lt;/a&gt;### **Query Layers**`Zillion` reports can be thought of as running in two layers:1. `DataSource Layer`: SQL queries against the warehouse's datasources2. `Combined Layer`: A final SQL query against the combined data from theDataSource LayerThe Combined Layer is just another SQL database (in-memory SQLite by default)that is used to tie the datasource data together and apply a few additionalfeatures such as rollups, row filters, row limits, sorting, pivots, and technical computations.&lt;a name=&quot;warehouse-creation&quot;&gt;&lt;/a&gt;### **Warehouse Creation**There are multiple ways to quickly initialize a warehouse from a local or remote file:```python# Path/link to a CSV, XLSX, XLS, JSON, HTML, or Google Sheet# This builds a single-table Warehouse for quick/ad-hoc analysis.url = &quot;https://raw.githubusercontent.com/totalhack/zillion/master/tests/dma_zip.xlsx&quot;wh = Warehouse.from_data_file(url, [&quot;Zip_Code&quot;]) # Second arg is primary key# Path/link to a sqlite database# This can build a single or multi-table Warehouseurl = &quot;https://github.com/totalhack/zillion/blob/master/tests/testdb1?raw=true&quot;wh = Warehouse.from_db_file(url)# Path/link to a WarehouseConfigSchema (or pass a dict)# This is the recommended production approach!config = &quot;https://raw.githubusercontent.com/totalhack/zillion/master/examples/example_wh_config.json&quot;wh = Warehouse(config=config)```Zillion also provides a helper script to boostrap a DataSource configuration file for an existing database. See `zillion.scripts.bootstrap_datasource_config.py`. The bootstrap script requires a connection/database url and output file as arguments. See `--help` output for more options, including the optional `--nlp` flag that leverages OpenAI to infer configuration information such as column types, table types, and table relationships. The NLP feature requires the NLP extension to be installed as well as the following set in your `Zillion` config file:* OPENAI_MODEL* OPENAI_API_KEY&lt;a name=&quot;executing-reports&quot;&gt;&lt;/a&gt;### **Executing Reports**The main purpose of `Zillion` is to execute reports against a `Warehouse`.At a high level you will be crafting reports as follows:```pythonresult = warehouse.execute(    metrics=[&quot;revenue&quot;, &quot;leads&quot;],    dimensions=[&quot;date&quot;],    criteria=[        (&quot;date&quot;, &quot;&gt;&quot;, &quot;2020-01-01&quot;),        (&quot;partner&quot;, &quot;=&quot;, &quot;Partner A&quot;)    ])print(result.df) # Pandas DataFrame```When comparing to writing SQL, it's helpful to think of the dimensions as thetarget columns of a **group by** SQL statement. Think of the metrics as thecolumns you are **aggregating**. Think of the criteria as the **whereclause**. Your criteria are applied in the DataSource Layer SQL queries.The `ReportResult` has a Pandas DataFrame with the dimensions as the index andthe metrics as the columns.A `Report` is said to have a `grain`, which defines the dimensions each metricmust be able to join to in order to satisfy the `Report` requirements. The`grain` is a combination of **all** dimensions, including those referenced incriteria or in metric formulas. In the example above, the `grain` would be`{date, partner}`. Both &quot;revenue&quot; and &quot;leads&quot; must be able to join to thosedimensions for this report to be possible.These concepts can take time to sink in and obviously vary with the specificsof your data model, but you will become more familiar with them as you startputting together reports against your data warehouses.&lt;a name=&quot;natural-language-querying&quot;&gt;&lt;/a&gt;### **Natural Language Querying**With the NLP extension `Zillion` has experimental support for natural language querying of your data warehouse. For example:```pythonresult = warehouse.execute_text(&quot;revenue and leads by date last month&quot;)print(result.df) # Pandas DataFrame```This NLP feature requires a running instance of Qdrant (vector database) and the following values set in your `Zillion` config file:* QDRANT_HOST* OPENAI_API_KEYEmbeddings will be produced and stored in both Qdrant and a local cache. Thevector database will be initialized the first time you try to use this byanalyzing all fields in your warehouse. An example docker file to run Qdrant is provided in the root of this repo.You have some control over how fields get embedded. Namely in the configuration for any field you can choose whether to exclude a field from embeddings or override which embeddings map to that field. All fields areincluded by default. The following example would exclude the `net_revenue` field from being embedded and map `revenue` metric requests to the `gross_revenue` field.```javascript{    &quot;name&quot;: &quot;gross_revenue&quot;,    &quot;type&quot;: &quot;numeric(10,2)&quot;,    &quot;aggregation&quot;: &quot;sum&quot;,    &quot;rounding&quot;: 2,    &quot;meta&quot;: {        &quot;nlp&quot;: {            // enabled defaults to true            &quot;embedding_text&quot;: &quot;revenue&quot; // str or list of str        }    }},{    &quot;name&quot;: &quot;net_revenue&quot;,    &quot;type&quot;: &quot;numeric(10,2)&quot;,    &quot;aggregation&quot;: &quot;sum&quot;,    &quot;rounding&quot;: 2,    &quot;meta&quot;: {        &quot;nlp&quot;: {            &quot;enabled&quot;: false        }    }},```Additionally you may also exclude fields via the following warehouse-level configuration settings:```javascript{    &quot;meta&quot;: {        &quot;nlp&quot;: {            &quot;field_disabled_patterns&quot;: [                // list of regex patterns to exclude                &quot;rpl_ma_5&quot;            ],            &quot;field_disabled_groups&quot;: [                // list of &quot;groups&quot; to exclude, assuming you have                // set group value in the field's meta dict.                &quot;No NLP&quot;            ]        }    },    ...}```If a field is disabled at any of the aforementioned levels it will be ignored. This type of control becomes useful as your data model gets more complex and you want to guide the NLP logic in cases where it could confuse similarly named fields. Any time you adjust which fields are excluded you will want to force recreation of your embeddings collection using the `force_recreate` flag on `Warehouse.init_embeddings`.&gt; *Note:* This feature is in its infancy. It's usefulness will depend on thequality of both the input query and your data model (i.e. good field names)!&lt;a name=&quot;zillion-configuration&quot;&gt;&lt;/a&gt;### **Zillion Configuration**In addition to configuring the structure of your `Warehouse`, which will bediscussed further below, `Zillion` has a global configuration to control somebasic settings. The `ZILLION_CONFIG` environment var can point to a yaml config file. See `examples/sample_config.yaml` for more details on what values can be set. Environment vars prefixed with ZILLION_ can override config settings (i.e. ZILLION_DB_URL will override DB_URL).The database used to store Zillion report specs can be configured by setting the DB_URL value in your `Zillion` config to a valid database connection string. By default a SQLite DB in /tmp is used.---&lt;a name=&quot;example-sales-analytics&quot;&gt;&lt;/a&gt;**Example - Sales Analytics**-----------------------------Below we will walk through a simple hypothetical sales data model thatdemonstrates basic `DataSource` and `Warehouse` configuration and then showssome sample [reports](#example-reports). The data is a simple SQLite databasethat is part of the `Zillion` test code. For reference, the schema is asfollows:```sqlCREATE TABLE partners (  id INTEGER PRIMARY KEY,  name VARCHAR NOT NULL UNIQUE,  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP);CREATE TABLE campaigns (  id INTEGER PRIMARY KEY,  name VARCHAR NOT NULL UNIQUE,  category VARCHAR NOT NULL,  partner_id INTEGER NOT NULL,  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP);CREATE TABLE leads (  id INTEGER PRIMARY KEY,  name VARCHAR NOT NULL,  campaign_id INTEGER NOT NULL,  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP);CREATE TABLE sales (  id INTEGER PRIMARY KEY,  item VARCHAR NOT NULL,  quantity INTEGER NOT NULL,  revenue DECIMAL(10, 2),  lead_id INTEGER NOT NULL,  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP);```&lt;a name=&quot;example-warehouse-config&quot;&gt;&lt;/a&gt;### **Warehouse Configuration**A `Warehouse` may be created from a JSON or YAML configuration that definesits fields, datasources, and tables. The code below shows how it can be done in as little as one line of code if you have a pointer to a JSON/YAML `Warehouse` config.```pythonfrom zillion import Warehousewh = Warehouse(config=&quot;https://raw.githubusercontent.com/totalhack/zillion/master/examples/example_wh_config.json&quot;)```This example config uses a `data_url` in its `DataSource` `connect` info thattells `Zillion` to dynamically download that data and connect to it as aSQLite database. This is useful for quick examples or analysis, though in mostscenarios you would put a connection string to an existing database like yousee[here](https://raw.githubusercontent.com/totalhack/zillion/master/tests/test_mysql_ds_config.json)The basics of `Zillion's` warehouse configuration structure are as follows:A `Warehouse` config has the following main sections:* `metrics`: optional list of metric configs for global metrics* `dimensions`: optional list of dimension configs for global dimensions* `datasources`: mapping of datasource names to datasource configs or config URLsA `DataSource` config has the following main sections:* `connect`: database connection url or dict of connect params* `metrics`: optional list of metric configs specific to this datasource* `dimensions`: optional list of dimension configs specific to this datasource* `tables`: mapping of table names to table configs or config URLs&gt; Tip: datasource and table configs may also be replaced with a URL that pointsto a local or remote config file.In this example all four tables in our database are included in the config,two as dimension tables and two as metric tables. The tables are linkedthrough a parent-&gt;child relationship: partners to campaigns, and leads tosales.  Some tables also utilize the `create_fields` flag to automaticallycreate `Fields` on the datasource from column definitions. Other metrics anddimensions are defined explicitly.To view the structure of this `Warehouse` after init you can use the `print_info`method which shows all metrics, dimensions, tables, and columns that are partof your data warehouse:```pythonwh.print_info() # Formatted print of the Warehouse structure```For a deeper dive of the config schema please see the full[docs](https://totalhack.github.io/zillion/zillion.configs/).&lt;a name=&quot;example-reports&quot;&gt;&lt;/a&gt;### **Reports****Example:** Get sales, leads, and revenue by partner:```pythonresult = wh.execute(    metrics=[&quot;sales&quot;, &quot;leads&quot;, &quot;revenue&quot;],    dimensions=[&quot;partner_name&quot;])print(result.df)&quot;&quot;&quot;              sales  leads  revenuepartner_namePartner A        11      4    165.0Partner B         2      2     19.0Partner C         5      1    118.5&quot;&quot;&quot;```**Example:** Let's limit to Partner A and break down by its campaigns:```pythonresult = wh.execute(    metrics=[&quot;sales&quot;, &quot;leads&quot;, &quot;revenue&quot;],    dimensions=[&quot;campaign_name&quot;],    criteria=[(&quot;partner_name&quot;, &quot;=&quot;, &quot;Partner A&quot;)])print(result.df)&quot;&quot;&quot;               sales  leads  revenuecampaign_nameCampaign 1A        5      2       83Campaign 2A        6      2       82&quot;&quot;&quot;```**Example:** The output below shows rollups at the campaign level within eachpartner, and also a rollup of totals at the partner and campaign level.&gt; *Note:* the output contains a special character to mark DataFrame rollup rowsthat were added to the result. The[ReportResult](https://totalhack.github.io/zillion/zillion.report/#reportresult)object contains some helper attributes to automatically access or filterrollups, as well as a `df_display` attribute that returns the result withfriendlier display values substituted for special characters. Theunder-the-hood special character is left here for illustration, but may notrender the same in all scenarios.```pythonfrom zillion import RollupTypesresult = wh.execute(    metrics=[&quot;sales&quot;, &quot;leads&quot;, &quot;revenue&quot;],    dimensions=[&quot;partner_name&quot;, &quot;campaign_name&quot;],    rollup=RollupTypes.ALL)print(result.df)&quot;&quot;&quot;                            sales  leads  revenuepartner_name campaign_namePartner A    Campaign 1A      5.0    2.0     83.0             Campaign 2A      6.0    2.0     82.0             􏿿               11.0    4.0    165.0Partner B    Campaign 1B      1.0    1.0      6.0             Campaign 2B      1.0    1.0     13.0             􏿿                2.0    2.0     19.0Partner C    Campaign 1C      5.0    1.0    118.5             􏿿                5.0    1.0    118.5􏿿            􏿿               18.0    7.0    302.5&quot;&quot;&quot;```See the `Report`[docs](https://totalhack.github.io/zillion/zillion.report/#report) for moreinformation on supported rollup behavior.**Example:** Save a report spec (not the data):First you must make sure you have saved your `Warehouse`, as saved reportsare scoped to a particular `Warehouse` ID. To save a `Warehouse`you must provide a URL that points to the complete config.```pythonname = &quot;My Unique Warehouse Name&quot;config_url = &lt;some url pointing to a complete warehouse config&gt;wh.save(name, config_url) # wh.id is populated after thisspec_id = wh.save_report(    metrics=[&quot;sales&quot;, &quot;leads&quot;, &quot;revenue&quot;],    dimensions=[&quot;partner_name&quot;])```&gt; *Note*: If you built your `Warehouse` in python from a list of `DataSources`,or passed in a `dict` for the `config` param on init, there currently is nota built-in way to output a complete config to a file for reference when saving.**Example:** Load and run a report from a spec ID:```pythonresult = wh.execute_id(spec_id)```This assumes you have saved this report ID previously in the database specified by the DB_URL in your `Zillion` yaml configuration.**Example:** Unsupported GrainIf you attempt an impossible report, you will get an`UnsupportedGrainException`. The report below is impossible because itattempts to break down the leads metric by a dimension that only existsin a child table. Generally speaking, child tables can join back up toparents (and &quot;siblings&quot; of parents) to find dimensions, but not the otherway around.```python# Fails with UnsupportedGrainExceptionresult = wh.execute(    metrics=[&quot;leads&quot;],    dimensions=[&quot;sale_id&quot;])```---&lt;a name=&quot;advanced-topics&quot;&gt;&lt;/a&gt;**Advanced Topics**-------------------&lt;a name=&quot;subreports&quot;&gt;&lt;/a&gt;### **Subreports**Sometimes you need subquery-like functionality in order to filter onereport to the results of some other (that perhaps required a different grain).Zillion provides a simplistic way of doing that by using the `in report` or `not in report`criteria operations. There are two supported ways to specify the subreport: passing areport spec ID or passing a dict of report params.```python# Assuming you have saved report 1234 and it has &quot;partner&quot; as a dimension:result = warehouse.execute(    metrics=[&quot;revenue&quot;, &quot;leads&quot;],    dimensions=[&quot;date&quot;],    criteria=[        (&quot;date&quot;, &quot;&gt;&quot;, &quot;2020-01-01&quot;),        (&quot;partner&quot;, &quot;in report&quot;, 1234)    ])# Or with a dict:result = warehouse.execute(    metrics=[&quot;revenue&quot;, &quot;leads&quot;],    dimensions=[&quot;date&quot;],    criteria=[        (&quot;date&quot;, &quot;&gt;&quot;, &quot;2020-01-01&quot;),        (&quot;partner&quot;, &quot;in report&quot;, dict(            metrics=[...],            dimension=[&quot;partner&quot;],            criteria=[...]        ))    ])```The criteria field used in `in report` or `not in report` must be a dimensionin the subreport. Note that subreports are executed at `Report` object initializationtime instead of during `execute` -- as such they can not be killed using `Report.kill`.This may change down the road.&lt;a name=&quot;formula-metrics&quot;&gt;&lt;/a&gt;### **Formula Metrics**In our example above our config included a formula-based metric called &quot;rpl&quot;,which is simply `revenue / leads`. A `FormulaMetric` combines other metricsand/or dimensions to calculate a new metric at the Combined Layer ofquerying. The syntax must match your Combined Layer database, which is SQLitein our example.```json{    &quot;name&quot;: &quot;rpl&quot;,    &quot;aggregation&quot;: &quot;mean&quot;,    &quot;rounding&quot;: 2,    &quot;formula&quot;: &quot;{revenue}/{leads}&quot;}```&lt;a name=&quot;divisor-metrics&quot;&gt;&lt;/a&gt;### **Divisor Metrics**As a convenience, rather than having to repeatedly define formula metrics forrate variants of a core metric, you can specify a divisor metric configuration on a non-formula metric. As an example, say you have a `revenue` metric and want to create variants for `revenue_per_lead` and `revenue_per_sale`. You can define your revenue metric as follows:```json{    &quot;name&quot;: &quot;revenue&quot;,    &quot;type&quot;: &quot;numeric(10,2)&quot;,    &quot;aggregation&quot;: &quot;sum&quot;,    &quot;rounding&quot;: 2,    &quot;divisors&quot;: {        &quot;metrics&quot;: [            &quot;leads&quot;,            &quot;sales&quot;        ]    }}```See `zillion.configs.DivisorsConfigSchema` for more details on configuration options, such as overriding naming templates, formula templates, and rounding.&lt;a name=&quot;formula-dimensions&quot;&gt;&lt;/a&gt;### **Formula Dimensions**Experimental support exists for `FormulaDimension` fields as well. A `FormulaDimension` can only use other dimensions as part of its formula, and it also gets evaluated in the Combined Layer database. As an additional restriction, a `FormulaDimension` can not be used in report criteria as those filters are evaluated at the DataSource Layer. The following example assumes a SQLite Combined Layer database:```json{    &quot;name&quot;: &quot;partner_is_a&quot;,    &quot;formula&quot;: &quot;{partner_name} = 'Partner A'&quot;}```&lt;a name=&quot;datasource-formulas&quot;&gt;&lt;/a&gt;### **DataSource Formulas**Our example also includes a metric &quot;sales&quot; whose value is calculated viaformula at the DataSource Layer of querying. Note the following in the`fields` list for the &quot;id&quot; param in the &quot;main.sales&quot; table. These formulas arein the syntax of the particular `DataSource` database technology, which alsohappens to be SQLite in our example.```json&quot;fields&quot;: [    &quot;sale_id&quot;,    {&quot;name&quot;:&quot;sales&quot;, &quot;ds_formula&quot;: &quot;COUNT(DISTINCT sales.id)&quot;}]```&lt;a name=&quot;type-conversions&quot;&gt;&lt;/a&gt;### **Type Conversions**Our example also automatically created a handful of dimensions from the&quot;created_at&quot; columns of the leads and sales tables. Support for automatic typeconversions is limited, but for date/datetime columns in supported`DataSource` technologies you can get a variety of dimensions for free thisway.The output of `wh.print_info` will show the added dimensions, which areprefixed with &quot;lead_&quot; or &quot;sale_&quot; as specified by the optional`type_conversion_prefix` in the config for each table. Some examples ofauto-generated dimensions in our example warehouse include sale_hour,sale_day_name, sale_month, sale_year, etc. As an optimization in the where clause of underlying report queries, `Zillion` will try to apply conversions to criteria values instead of columns. For example, it is generally more efficient to query as `my_datetime &gt; '2020-01-01' and my_datetime &lt; '2020-01-02'`instead of `DATE(my_datetime) == '2020-01-01'`, because the latter can prevent indexusage in many database technologies. The ability to apply conversions to valuesinstead of columns varies by field and `DataSource` technology as well. To prevent type conversions, set `skip_conversion_fields` to `true` on your`DataSource` config.See `zillion.field.TYPE_ALLOWED_CONVERSIONS` and `zillion.field.DIALECT_CONVERSIONS`for more details on currently supported conversions.&lt;a name=&quot;adhoc-metrics&quot;&gt;&lt;/a&gt;### **Ad Hoc Metrics**You may also define metrics &quot;ad hoc&quot; with each report request. Below is anexample that creates a revenue-per-lead metric on the fly. These only existwithin the scope of the report, and the name can not conflict with any existingfields:```pythonresult = wh.execute(    metrics=[        &quot;leads&quot;,        {&quot;formula&quot;: &quot;{revenue}/{leads}&quot;, &quot;name&quot;: &quot;my_rpl&quot;}    ],    dimensions=[&quot;partner_name&quot;])```&lt;a name=&quot;adhoc-dimensions&quot;&gt;&lt;/a&gt;### **Ad Hoc Dimensions**You may also define dimensions &quot;ad hoc&quot; with each report request. Below is anexample that creates a dimension that partitions on a particular dimension value on the fly. Ad Hoc Dimensions are a subclass of `FormulaDimension`s and therefore have the same restrictions, such as not being able to use a metric as a formula field. These only exist within the scope of the report, and the name can not conflict with any existing fields:```pythonresult = wh.execute(    metrics=[&quot;leads&quot;],    dimensions=[{&quot;name&quot;: &quot;partner_is_a&quot;, &quot;formula&quot;: &quot;{partner_name} = 'Partner A'&quot;])```&lt;a name=&quot;adhoc-tables&quot;&gt;&lt;/a&gt;### **Ad Hoc Tables**`Zillion` also supports creation or syncing of ad hoc tables in your databaseduring `DataSource` or `Warehouse` init. An example of a table config thatdoes this is shown[here](https://github.com/totalhack/zillion/blob/master/tests/test_adhoc_ds_config.json).It uses the table config's `data_url` and `if_exists` params to control thesyncing and/or creation of the &quot;main.dma_zip&quot; table from a remote CSV in aSQLite database.  The same can be done in other database types too.The potential performance drawbacks to such an approach should be obvious,particularly if you are initializing your warehouse often or if the remotedata file is large. It is often better to sync and create your data ahead oftime so you have complete schema control, but this method can be very usefulin certain scenarios.&gt; **Warning**: be careful not to overwrite existing tables in your database!&lt;a name=&quot;technicals&quot;&gt;&lt;/a&gt;### **Technicals**There are a variety of technical computations that can be applied to metrics tocompute rolling, cumulative, or rank statistics. For example, to compute a 5-pointmoving average on revenue one might define a new metric as follows:```json{    &quot;name&quot;: &quot;revenue_ma_5&quot;,    &quot;type&quot;: &quot;numeric(10,2)&quot;,    &quot;aggregation&quot;: &quot;sum&quot;,    &quot;rounding&quot;: 2,    &quot;technical&quot;: &quot;mean(5)&quot;}```Technical computations are computed at the Combined Layer, whereas the &quot;aggregation&quot;is done at the DataSource Layer (hence needing to define both above). For more info on how shorthand technical strings are parsed, see the[parse_technical_string](https://totalhack.github.io/zillion/zillion.configs/#parse_technical_string)code. For a full list of supported technical types see`zillion.core.TechnicalTypes`.Technicals also support two modes: &quot;group&quot; and &quot;all&quot;. The mode controls how toapply the technical computation across the data's dimensions. In &quot;group&quot; mode,it computes the technical across the last dimension, whereas in &quot;all&quot; mode incomputes the technical across all data without any regard for dimensions.The point of this becomes more clear if you try to do a &quot;cumsum&quot; technicalacross data broken down by something like [&quot;partner_name&quot;, &quot;date&quot;]. If &quot;group&quot;mode is used (the default in most cases) it will do cumulative sums *within*each partner over the date ranges. If &quot;all&quot; mode is used, it will do acumulative sum across every data row. You can be explicit about the mode byappending it to the technical string: i.e. &quot;cumsum:all&quot; or &quot;mean(5):group&quot;---&lt;a name=&quot;config-variables&quot;&gt;&lt;/a&gt;### **Config Variables**If you'd like to avoid putting sensitive connection information directly inyour `DataSource` configs you can leverage config variables. In your `Zillion`yaml config you can specify a `DATASOURCE_CONTEXTS` section as follows:```yamlDATASOURCE_CONTEXTS:  my_ds_name:    user: user123    pass: goodpassword    host: 127.0.0.1    schema: reporting```Then when your `DataSource` config for the datasource named &quot;my_ds_name&quot; isread, it can use this context to populate variables in your connection url:```json&quot;datasources&quot;: {    &quot;my_ds_name&quot;: {        &quot;connect&quot;: &quot;mysql+pymysql://{user}:{pass}@{host}/{schema}&quot;        ...    }}```&lt;a name=&quot;datasource-priority&quot;&gt;&lt;/a&gt;### **DataSource Priority**On `Warehouse` init you can specify a default priority order for datasourcesby name. This will come into play when a report could be satisfied by multipledatasources. `DataSources` earlier in the list will be higher priority. Thiswould be useful if you wanted to favor a set of faster, aggregate tables thatare grouped in a `DataSource`.```pythonwh = Warehouse(config=config, ds_priority=[&quot;aggr_ds&quot;, &quot;raw_ds&quot;, ...])```&lt;a name=&quot;supported-datasources&quot;&gt;&lt;/a&gt;**Supported DataSources**-------------------------`Zillion's` goal is to support any database technology that SQLAlchemysupports (pictured below). That said the support and testing levels in `Zillion` vary at themoment. In particular, the ability to do type conversions, databasereflection, and kill running queries all require some database-specific codefor support. The following list summarizes known support levels. Your mileagemay vary with untested database technologies that SQLAlchemy supports (itmight work just fine, just hasn't been tested yet). Please report bugs andhelp add more support!* SQLite: supported* MySQL: supported* PostgreSQL: supported* DuckDB: supported* BigQuery, Redshift, Snowflake, SingleStore, PlanetScale, etc: not tested but would like to support theseSQLAlchemy has connectors to many popular databases. The barrier to support many of these is likelypretty low given the simple nature of the sql operations `Zillion` uses.![SQLAlchemy Connectors](https://github.com/totalhack/zillion/blob/master/docs/images/sqlalchemy_connectors.webp?raw=true)Note that the above is different than the database support for the Combined Layerdatabase. Currently only SQLite is supported there; that should be sufficient formost use cases but more options will be added down the road.&lt;a name=&quot;multiprocess-considerations&quot;&gt;&lt;/a&gt;**Multiprocess Considerations**-------------------------------If you plan to run `Zillion` in a multiprocess scenario, whether on a singlenode or across multiple nodes, there are a couple of things to consider:* SQLite DataSources do not scale well and may run into locking issues with multiple processes trying to access them on the same node.* Any file-based database technology that isn't centrally accessible would be challenging when using multiple nodes.* Ad Hoc DataSource and Ad Hoc Table downloads should be avoided as they may conflict/repeat across each process. Offload this to an externalETL process that is better suited to manage those data flows in a scalable production scenario.Note that you can still use the default SQLite in-memory Combined Layer DB without issues, as that is made on the fly with each report request andrequires no coordination/communication with other processes or nodes.&lt;a name=&quot;demo-ui&quot;&gt;&lt;/a&gt;**Demo UI / Web API**--------------------[Zillion Web UI](https://github.com/totalhack/zillion-web) is a demo UI and web API for Zillion that also includes an experimental ChatGPT plugin. See the README there for more info on installation and project structure. Please note that the code is light on testing and polish, but is expected to work in modern browsers. Also ChatGPT plugins are quite slow at the moment, so currently that is mostly for fun and not that useful.---&lt;a name=&quot;documentation&quot;&gt;&lt;/a&gt;**Documentation**-----------------More thorough documentation can be found [here](https://totalhack.github.io/zillion/).You can supplement your knowledge by perusing the [tests](https://github.com/totalhack/zillion/tree/master/tests) directoryor the [API reference](https://totalhack.github.io/zillion/).---&lt;a name=&quot;how-to-contribute&quot;&gt;&lt;/a&gt;**How to Contribute**---------------------Please See the[contributing](https://github.com/totalhack/zillion/blob/master/CONTRIBUTING.md)guide for more information. If you are looking for inspiration, adding support and tests for additional database technologies would be a great help.</longdescription>
</pkgmetadata>