<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://codecov.io/gh/pysergio/atomcache&quot;&gt;  &lt;img src=&quot;https://codecov.io/gh/pysergio/atomcache/branch/master/graph/badge.svg?token=OVZABBE1UJ&quot;/&gt; &lt;/a&gt;&lt;a href=&quot;https://pypi.org/project/atomcache&quot; target=&quot;_blank&quot;&gt;    &lt;img src=&quot;https://img.shields.io/pypi/v/atomcache?color=%2334D058&amp;label=pypi%20package&quot; alt=&quot;Package version&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://pypi.org/project/atomcache&quot; target=&quot;_blank&quot;&gt;    &lt;img src=&quot;https://img.shields.io/pypi/pyversions/atomcache.svg?color=%2334D058&quot; alt=&quot;Supported Python versions&quot;&gt;&lt;/a&gt;&lt;/p&gt;## IntroductionAsynchronous cache manager designed for horizontally scaled web applications.**NOTE:** _Currently has implementation only for FastAPI using Redis._## RequirementsPython 3.7+* &lt;a href=&quot;https://redis.readthedocs.io/en/latest/_modules/redis/asyncio/client.html?&quot; class=&quot;external-link&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt; for cache implementation.* &lt;a href=&quot;https://fastapi.tiangolo.com&quot; class=&quot;external-link&quot; target=&quot;_blank&quot;&gt;FastAPI&lt;/a&gt; for the web parts.  ## Installation&lt;div class=&quot;termy&quot;&gt;```console$ pip install atomcache---&gt; 100%```## Explanation schema![Class Diagram](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/pysergio/atomcache/master/README.md)&lt;details markdown=&quot;1&quot;&gt;&lt;summary&gt;As UML&lt;/summary&gt;```plantuml@startuml    !theme materia    participant Redis    participant Instance_A as A    participant Instance_B as B    participant Instance_N as C    B &lt;-&gt; Redis: GET: Cache=null &amp; GET: Lock=null    B &lt;-&gt; Redis: SET: Lock = true    activate B #Red    A &lt;--&gt; Redis: GET: Cache=null &amp; GET: Lock=true    activate A #Transparent    C &lt;--&gt; Redis: GET: Cache=null &amp; GET: Lock=true    activate C #Transparent    B &lt;--&gt; B: Do the computation    B -&gt; Redis: SET: Cache={...}    deactivate B    group Notify Cache SET        Redis -&gt; C        Redis -&gt; A    end    group GET Cache        Redis &lt;-&gt; C    deactivate C        Redis &lt;-&gt; A    deactivate A    end@enduml```&lt;/details&gt;## Examples:### Usage as FastAPI Dependency* Create a file `events.py` with:```Pythonfrom typing import Optional, Callablefrom redis.asyncio import Redisfrom fastapi import FastAPI, Dependsfrom atomcache import Cachedef create_start_app_handler(app: FastAPI) -&gt; Callable:    async def start_app() -&gt; None:        redis: Redis = await Redis.from_url(url=&quot;redis://localhost&quot;, encoding=&quot;utf-8&quot;)        await Cache.init(app, redis)    return start_appdef create_stop_app_handler(app: FastAPI) -&gt; Callable:    async def stop_app() -&gt; None:        await Cache.backend.close()    return stop_app```* Create a file `main.py` with:```Pythonfrom typing import Optionalfrom fastapi import FastAPI, Dependsfrom atomcache import Cachefrom .events import create_start_app_handler, create_stop_app_handlerapp = FastAPI()app.add_event_handler(&quot;startup&quot;, create_start_app_handler(app))app.add_event_handler(&quot;shutdown&quot;, create_stop_app_handler(app))@router.get(&quot;/resources&quot;, response_model=List[TheResponseModel], name=&quot;main:test-example&quot;)async def resources(offset: int = 0, items: int = 10, cache: Cache = Depends(Cache(exp=600)):    cache_id = f&quot;{offset}-{items}&quot;  # Build cache identifier    await cache.raise_try(cache_id)  # Try to respond from cache    response = await db.find(TheResponseModel, skip=offset, limit=items)    await asyncio.sleep(10)  # Do some heavy work for 10 sec, see `lock_timeout`    return cache.set(response, cache_id=cache_id)```### Direct cache usage for avoiding repetitive calling on external resources:```Pythonfrom aiohttp import ClientSessionfrom atomcache import Cachecache = Cache(exp=1200, namespace=&quot;my-namespace:&quot;)async def requesting_helper(ref: str) -&gt; List[dict]:    cached_value = await cache.get(cache_id=ref)    if cached_value is not None:        return cached_value    async with ClientSession() as session:        async with session.get(f&quot;https://external-api.io/{ref}&quot;) as response:            if response.ok:                cached_value = response.json()                return cache.set(cached_value, cache_id=ref)    return []```</longdescription>
</pkgmetadata>