<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Wefram platform===============**Wefram** is the open source platform used to create complex web projects consisting ofboth backend and frontend parts, allowing using both SSR (server-side rendering) usingtemplate renders, and CSR (client-side rendering) using *React* based SPA (single pageapplication) approach.The main point is to handle as much as possible repeating or taking much of time elementsof the development process by the platform (let's not name is &quot;framework&quot;, okay?), givingprogrammers time to make end-point code of corresponding project applications only.The another goal of using Wefram is the ability of dividing the entire project intoapplications, often independent on each other. This provides us the posibility towrite sometimes small, somethimes just funtion-resolving modules (applications) andstore them in the repository, and re-use when needed. You may see many analogies withother module-based frameworks such as *Django* or *Flask*. But Wefram takes in worka lightly much, then those frameworks, providing already pre-developed, ready touse frontend SPA platform (React-based), and programmers of the project only focuseson the target functional code of the project modules, not wasting time on thefrontend basics development, SSR &amp; CSR integration into a single project, etc.Approach--------The platform consists of itself (installed from *pypi* with *pip*) and developed andenabled project's applications. So, the final project will have a set of modules, named&quot;applications&quot;, placed in the project's directory, and a set of backend and frontendthird-party packages (both for backend &amp; frontend).Provides--------The platform itself provides some most used functionality and facilities, readyto use from the box, such as:* **Applications' management**:  the project's modules, named *application* management, allowing   to install and deinstall project's apps, enable and temporary disable, and providing the dividing  of the entire project on (most often) independent parts, with **dynamic inclusion and exclusion  in and from the final build**.* **Dependencies resolving**: application's and platform's dependencies summarizing and resolving,  both for *backend* (Python with *pip*) and *frontend* (React@TypeScript with *yarn*).* **PostgreSQL database** dialect and special types support.* **State-based migration** with no needing of any kind of migration history or scripts generating.* **In-memory database** (**Redis**) connectivity, caching facility, etc.* **ORM** (Object relating modeling) with files storage transparent integration.* **ORM history** facility with automated logging of changes in models' instances.* **Files storage** for uploadable content with ready-to-use support from the platform side, including  all routings and handlings.* **Localization** *extended* facility with domains support both on backend and frontend.* **Routing** facility for both HTTP(S) and WebSockets.* **API** functionality out of box, with ready-to-use **ORM models DTO** allowing to make any   ORM model API-ready in really two lines of code.* **Template rendering** for SSR (server-side rendering) using *Jinja2* template engine.* **Frontend** ready-to-use **React** implementation.* **Material-UI** implementation with extended set of common purpose components.* **User interface** out of box, with no need to code anything from the scratch, with the theming facility.* **Settings** ready-to-use facility (the application is not required to have the own implementation).* **Users &amp; roles facility** out of box - Authentication, Authorization and Accounting, roles' permissions  management, etc.* **Permissions** handling out of box for most entities, such as *API*, *Views*, *Screens*, *Settings*, etc.* **CLI** (command-line interface) basics to implement command line management facilities.* **Notifications** (displayed to users), messages transports between backend and frontend.* **Sidebar** and **Sidemap** automated facility.* **Screens** (client-side rendered) facility, even **managed screens** with backend runtime qualifications.* **Typo screens automatisations** to exclude needing of writting any line of the  'React @ TypeScript' code for very common cases.As been said - the platform aims to make programmers work on the corresponding project'scode.Written on----------Like any client-server project, the Wefram-based project will consist of two mainparts:* Backend, which is written in **Python 3**.* Frontend, which is written mainly in **TypeScript &amp; React** or **templated HTML**.The frontend part is lightly more interesting than just a TypeScript or just aReact. While we speak about two variants of render - SSR &amp; CSR, we about tohandle two different approachs.If we speak about regular, search engines (Google, Yandex...) indexing site - we usually speak about SSR with pre-rendered HTML code returning to the browser.Wefram uses *Jinja2* template engine to render the HTML on the server side. Toprovide assets like CSS, JS scripts and so on, the Wefram uses assets approach,which makes possible to build assets from all enabled applications into understandableand easy to use structure, which can be directly handled by the web server like*nginx* or *apache*.If we speak about site's administrative panel, about corporate portal, about some another kind of business logics, used primary on workplaces - we speak about SPA (single pageapplication), we speak about CSR (client-side rendering), about traffic economy, reusingsame pre-built program code by clients' browsers without needing of reloading everything.Here we speak about *React* which is based (in our configuration) on *TypeScript*.The Wefram combines both described above approachs into one project. This means thata single project may have both SSR and CSR applications, modules, etc. This allowsnot to divide a project into independent parts, combining all in one place.This not requires, for example, the project to have SSR pages. Wefram gives thisposibility, but only when the project needs it. For example, if we have a regularsite, for example with a set of services for the end user, and we want to makea some kind of reservation system for those services - we will make severalSSR pages (to be easyly indexed by search engines) basing on Jinja2, HTML,CSS and pure JS; and make a workspace for employee, administering those reservationsand services, with CSR using *React &amp; TypeScript*.Applications------------While many projects divides the entire project horizontally - to the &quot;all backend&quot;and &quot;all frontend&quot;, the *Wefram* uses another approach - it dividing the entireproject vertically, to &quot;modules&quot;, names &quot;applications&quot;.The every application consists of backend part (even almost empty) and optionalfrontend part. Why the frontend is optional? Because (a) the application may handlesome work without any client side control (for example, make regular integration withanother service, or give a facility on, for example, sending messages via Telegram),and (b) because Wefram gives several interesting backend-realized approachs, whosemay exclude needs of frontend programming for simple tasks (for example, theapplicaion's programmer relieved of the need to make settings, properties handling,administering simple database models on the frontend and so on).So, while the application consists of both backend and frontend, it makes mucheasier to install to the project and deinstall from the project applications,developing application outside the main project and then easily adding it tothe project, etc. **The point is that makes much easily to divide the entire projectinto reusable and often independent parts.**Localization------------One of the main our targets was to make the platform localization-ready from thebegining, as one of main goals. Because of this, everywhere, where that is possible,we made the localization interfaces and interesting localization approach. We willspeak about it in the documentation, in the separate section.Where we are------------The Wefram is in active development and about 80% ready to be published. Muchof work on documenting is still in progress (which take a lot of time), someinteresting ideas are in progress.But several really living projects are already in live, already basing on theWefram platform and successfully working.</longdescription>
</pkgmetadata>