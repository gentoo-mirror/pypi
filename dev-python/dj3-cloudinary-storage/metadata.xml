<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Django 3 Cloudinary Storage===========================Django Cloudinary Storage is a Django package that facilitates integration with [Cloudinary](http://cloudinary.com/)by implementing [Django Storage API](https://docs.djangoproject.com/en/3.0/howto/custom-file-storage/).With several lines of configuration, you can start using Cloudinary for both media and static files.Also, it provides management commands for removing unnecessary files, so any cleanup will be a breeze.It uses [pycloudinary](https://github.com/cloudinary/pycloudinary) package under the hood.[![Build Status](https://travis-ci.org/tiagocordeiro/dj3-cloudinary-storage.svg?branch=master)](https://travis-ci.org/tiagocordeiro/dj3-cloudinary-storage)[![Updates](https://pyup.io/repos/github/tiagocordeiro/dj3-cloudinary-storage/shield.svg)](https://pyup.io/repos/github/tiagocordeiro/dj3-cloudinary-storage/)[![Python 3](https://pyup.io/repos/github/tiagocordeiro/dj3-cloudinary-storage/python-3-shield.svg)](https://pyup.io/repos/github/tiagocordeiro/dj3-cloudinary-storage/)[![GitHub](https://img.shields.io/github/license/mashape/apistatus.svg)](https://github.com/tiagocordeiro/dj3-cloudinary-storage/blob/master/LICENSE)[![codecov](https://codecov.io/gh/tiagocordeiro/dj3-cloudinary-storage/branch/master/graph/badge.svg)](https://codecov.io/gh/tiagocordeiro/dj3-cloudinary-storage)Table of content------------------ [Requirements](#requirements)- [Installation](#installation)- [Usage with media files](#usage-with-media-files)    - [Usage with raw files](#usage-with-raw-files)    - [Usage with video files](#usage-with-video-files)- [Usage with static files](#usage-with-static-files)- [Management commands](#management-commands)    - [collectstatic](#collectstatic)    - [deleteorphanedmedia](#deleteorphanedmedia)    - [deleteredundantstatic](#deleteredundantstatic)- [Settings](#settings)- [How to run tests](#how-to-run-tests)Requirements------------The package requires Python 3.5+ and Django 3.0+. It has been tested on Linux and Mac OS X.Installation------------To install the package, just run:```$ pip install dj3-cloudinary-storage```If you need to upload any video files, run:```$ pip install dj3-cloudinary-storage[video]```which will additionally install [python-magic](https://github.com/ahupp/python-magic) for uploaded video validation.Also, in case you use Django `ImageField`, make sure you have Pillow installed:```$ pip install Pillow```Once you have done that, add `cloudinary` and `cloudinary_storage` to you installed apps in your `settings.py`. If youare going to use this package for static and/or media files, make sure that `cloudinary_storage` is before `django.contrib.staticfiles`:```pythonINSTALLED_APPS = [    # ...    'cloudinary_storage',    'django.contrib.staticfiles',    'cloudinary',    # ...]```because dj3-cloudinary-storage overwrites Django `collectstatic` command. If you are going to use it only for media filesthough, it is `django.contrib.staticfiles` which has to be first:```pythonINSTALLED_APPS = [    # ...    'django.contrib.staticfiles',    'cloudinary_storage',    'cloudinary',    # ...]```Next, you need to add Cloudinary credentials to `settings.py`:```pythonCLOUDINARY_STORAGE = {    'CLOUD_NAME': 'your_cloud_name',    'API_KEY': 'your_api_key',    'API_SECRET': 'your_api_secret'}```Instead of putting credentials in `settings.py`, you can provide them as `CLOUDINARY_CLOUD_NAME`,`CLOUDINARY_API_SECRET` and `CLOUDINARY_API_KEY` environment variables. It is possible as well to set only`CLOUDINARY_URL` variable, combining all the information, for example:```$ export CLOUDINARY_URL=cloudinary://your_api_key:your_api_secret@your_cloud_name```For those of you who use Heroku, that's a very good news, because you won't need to set it yourself, as Heroku sets`CLOUDINARY_URL` environment variable for you (provided you use Cloudinary as Heroku addon).Also, be aware that `settings.py` takes precedence over environment variables.Usage with media files----------------------The package provides three media storages:- `cloudinary_storage.storage.MediaCloudinaryStorage` for images- `cloudinary_storage.storage.RawMediaCloudinaryStorage` for raw files, like txt, pdf- `cloudinary_storage.storage.VideoMediaCloudinaryStorage` for videosAbove distinction if necessary as Cloudinary API needs to know resource type in many of its methods.Now, let's consider the most probable scenario that you will use Cloudinary for images uploaded by users of yourwebsite. Let's say you created a following Django model:```pythonclass TestModel(models.Model):    name = models.CharField(max_length=100)    image = models.ImageField(upload_to='images/', blank=True)```All you need to do is to add two lines to `settings.py`:```pythonMEDIA_URL = '/media/'  # or any prefix you chooseDEFAULT_FILE_STORAGE = 'cloudinary_storage.storage.MediaCloudinaryStorage'```And that's it! All your models with `ImageField` will be connected to Cloudinary.Now, in order to put this image into your template, you can just type:```django&lt;img src=&quot;{{ test_model_instance.image.url }}&quot; alt=&quot;{{ test_model_instance.image.name }}&quot;&gt;```However, doing that in this way, the image will be downloaded with its original size, as uploaded by a user.To have more control, you can use Cloudinary image transformations. For example, to change the image's size,use below code:```django{% load cloudinary %}{% cloudinary test_model_instance.image.name width=100 height=100 %}```Of cource, this only scratched the surface. Cloudinary is extremely powerful and I highly recommend you to check[pycloudinary](https://github.com/cloudinary/pycloudinary) documentation.Now, if you only need to use Cloudinary for images, you can skip the rest of this subsection.However, if you are going to use it for videos and/or raw files, let's continue.### Usage with raw filesIf your users can upload text or other raw files, but not images, you would just use different default storagein `settings.py`:```pythonDEFAULT_FILE_STORAGE = 'cloudinary_storage.storage.RawMediaCloudinaryStorage'```But what if they could upload both types? Well, not a problem! Just set `DEFAULT_FILE_STORAGE` setting to the mostcommon resource type, and for fields of different type, you will need to set a correct storage individually, like this:```pythonfrom django.db import modelsfrom cloudinary_storage.storage import RawMediaCloudinaryStorageclass TestModelWithRawFileAndImage(models.Model):    name = models.CharField(max_length=100)    raw_file = models.ImageField(upload_to='raw/', blank=True, storage=RawMediaCloudinaryStorage())    image = models.ImageField(upload_to='images/', blank=True)  # no need to set storage, field will use the default one```In above example we assumed `DEFAULT_FILE_STORAGE = 'cloudinary_storage.storage.MediaCloudinaryStorage'`,that's why we set storage explicitly only for `raw_file`.### Usage with video filesUsage with video files is analogous to raw files, but you will need to use `validate_video` validator for video fieldsto validate user's uploaded videos. If not, Cloudinary will raise an error if a user tries to upload non-video file,which will crash your website. Of cource, you could use your own validator, but if you want to use built-in one,do it like this:```pythonfrom django.db import modelsfrom cloudinary_storage.storage import VideoMediaCloudinaryStoragefrom cloudinary_storage.validators import validate_videoclass TestModelWithVideoAndImage(models.Model):    name = models.CharField(max_length=100)    video = models.ImageField(upload_to='videos/', blank=True, storage=VideoMediaCloudinaryStorage(),                              validators=[validate_video])    image = models.ImageField(upload_to='images/', blank=True)  # no need to set storage, field will use the default one```Usage with static files-----------------------In order to move your static files to Cloudinary, update your `settings.py`:```pythonSTATIC_URL = '/static/'STATICFILES_STORAGE = 'cloudinary_storage.storage.StaticHashedCloudinaryStorage'```After that, run Django `collectstatic` command:```$ python manage.py collectstatic```Please note that only files with hashed name will be uploaded by default - this behavior can be changed by adding`--upload-unhashed-files` argument to `collectstatic` command. If you are not sure why it is useful to add hash to filenames, shortly speaking, it allows static files to be safely cached by Cloudinary CDN and web browsers. Without itfiles' modification would become very problematic, because your website's users would use their private older copies.Hashing prevents this issue as any file change will change its url as well, which would force a browser to downloada new version of a file.Also, be aware that `collectstatic` will create a JSON file, which shows mapping of unhashed file names to their hashedversions. This file will be available at `./manifest/staticfiles.json` by default - you could change thatin your `settings.py`, for example:```pythonimport osBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))CLOUDINARY_STORAGE = {    # other settings, like credentials    'STATICFILES_MANIFEST_ROOT': os.path.join(BASE_DIR, 'my-manifest-directory')}```It is highly recommended to keep up-to-date version of this file in your version control system.In order to use static files from Cloudinary, make sure you write your templates in below style:```django{% load static %}&lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'css/style.css' %}&quot;&gt;&lt;img src=&quot;{% static 'images/dummy-static-image.jpg' %}&quot; alt=&quot;dummy static image&quot;&gt;```If you would like to apply Cloudinary transformations for static images or videos, please use `cloudinary_static`template tag as follows:```django{% load cloudinary_static %}{% cloudinary_static 'images/dummy-static-image.jpg' width=50 height=50 %}```You can adjust `STATIC_IMAGES_EXTENSIONS` and `STATIC_VIDEOS_EXTENSIONS` to set rules which file extensions are treatedas image or video files. Files with different extensions will be uploaded as Cloudinary raw files and no transformationscould be applied for those files. Also, please note that `cloudinary_static` is just a thin wrapper around `cloudinary`tag from [pycloudinary](https://github.com/cloudinary/pycloudinary) library, so please go to its documentationto see what transformations are possible.Please note that you must set `DEBUG` to `False` to fetch static files from Cloudinary. With `DEBUG` equal to `True`,Django `staticfiles` app will use your local files for easier and faster development (unless you use`cloudinary_static` template tag).Management commands-------------------The package provides three management commands:- `collectstatic`- `deleteorphanedmedia`- `deleteredundantstatic`### collectstaticAdds minor modifications to Django `collectstatic` to improve upload performance. It uploads only hashed filesas the default. Also, it uploads a file only when necessary, namely it won't upload the file if a file with the samename and content will be already uploaded to Cloudinary, which will save both time and bandwidth.Optional arguments:- `--upload-unhashed-files` - uploads files without hash added to their name along with hashed ones, use it onlywhen it is really necessary- `--noinput` - non-interactive mode, the command won't ask you to do any confirmations### deleteorphanedmediaDeletes needless media files, which are not connected to any model. It is possible to provide paths to prevent deletionof given files in `EXCLUDE_DELETE_ORPHANED_MEDIA_PATHS` in `settings.py`, for example:```pythonCLOUDINARY_STORAGE = {    # other settings    'EXCLUDE_DELETE_ORPHANED_MEDIA_PATHS': ('path/', 'second-path/')}```Optional arguments:- `--noinput` - non-interactive mode, the command won't ask you to do any confirmations### deleteredundantstaticDeletes needless static files.Optional arguments:- `--keep-unhashed-files` - use it if you use `collectstatic` with `--upload-unhashed-files` argument,without it this command will always delete all unhashed files- `--noinput` - non-interactive mode, the command won't ask you to do any confirmationsSettings--------Below you can see all available settings with default values:```pythonimport osfrom django.conf import settingsBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))CLOUDINARY_STORAGE = {    'CLOUD_NAME': None,  # required    'API_KEY': None,  # required    'API_SECRET': None,  # required    'SECURE': True,    'MEDIA_TAG': 'media',    'INVALID_VIDEO_ERROR_MESSAGE': 'Please upload a valid video file.',    'EXCLUDE_DELETE_ORPHANED_MEDIA_PATHS': (),    'STATIC_TAG': 'static',    'STATICFILES_MANIFEST_ROOT': os.path.join(BASE_DIR, 'manifest'),    'STATIC_IMAGES_EXTENSIONS': ['jpg', 'jpe', 'jpeg', 'jpc', 'jp2', 'j2k', 'wdp', 'jxr',                                 'hdp', 'png', 'gif', 'webp', 'bmp', 'tif', 'tiff', 'ico'],    'STATIC_VIDEOS_EXTENSIONS': ['mp4', 'webm', 'flv', 'mov', 'ogv' ,'3gp' ,'3g2' ,'wmv' ,                                 'mpeg' ,'flv' ,'mkv' ,'avi'],    'MAGIC_FILE_PATH': 'magic',    'PREFIX': settings.MEDIA_URL}````CLOUD_NAME`, `API_KEY` and `API_SECRET` are mandatory and you need to define them in `CLOUDINARY_STORAGE` dictionaryin `settings.py`, the rest could be overwritten if required, as described below:- `SECURE` - whether your Cloudinary files should be server over HTTP or HTTPS, HTTPS is the default, set it to Falseto switch to HTTP- `MEDIA_TAG` - name assigned to your all media files, it has to be different than `STATIC_TAG`, usually you don'tneed to worry about this setting, it is useful when you have several websites which use the same Cloudinary acount, whenyou should set it unique to distinguish it from other websites,- `INVALID_VIDEO_ERROR_MESSAGE` - error message which will be desplayed in user's form when one tries to upload non-videofile in video field- `EXCLUDE_DELETE_ORPHANED_MEDIA_PATHS` - looked by `deleteorphanedmedia` command, you can provide here tuple of pathswhich will never be deleted- `STATIC_TAG` - name assigned to your all static files, it has to be different than `MEDIA_TAG`, please see `MEDIA_TAG`setting to see when it is useful- `STATICFILES_MANIFEST_ROOT` - path where `staticfiles.json` will be saved after `collectstatic` command, `./manifest`is the default location- `STATIC_IMAGES_EXTENSIONS` - list of file extensions with which static files will be treated as Cloudinary images- `STATIC_VIDEOS_EXTENSIONS` - list of file extensions with which static files will be uploaded as Cloudinary videos- `MAGIC_FILE_PATH`: applicable only for Windows, needed for python-magic library for movie validation, please see[python-magic](https://github.com/ahupp/python-magic#dependencies) for reference- `PREFIX` - prefix to your all files uploaded by `MediaCloudinaryStorage`, default `MEDIA_URL`, it can be useful whenyou use `FileSystemStorage` as default and `MediaCloudinaryStorage` for some models fieldsHow to run tests----------------```$ coverage run -a --source=cloudinary_storage manage.py test -v 2```Notes-----This project is based on a fork from [django-cloudinary-storage](https://github.com/klis87/django-cloudinary-storage)Thanx!</longdescription>
</pkgmetadata>