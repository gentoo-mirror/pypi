<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># tagilA simple dependency injection library for python## Simple usageTo mark class as injectable use `@component` annotation:```pythonfrom tagil import component@componentclass InjectableClass:    def __init__(self):        pass```Now you can construct instance of this class with `InjectionManager`:```pythonfrom tagil import InjectionManagerinstance = InjectionManager().get_component(InjectableClass)```All dependent instances from `__init__` will be resolved automatically if there is class annotation and `@component` decorator:```pythonfrom tagil import component, InjectionManager@componentclass ClassWithDependency:    def __init__(self, injectable: InjectableClass):        self.injectable = injectableinstance = InjectionManager().get_component(ClassWithDependency)```Instance will be fully initialized.## Constructor decoratorYou can assign function as a constructor function for component via `@constructor` decorator:```pythonfrom tagil import constructorclass SomeDependency:    passclass SomeComponent:    def __init__(self, dep):       self.dep = dep        @constructordef some_component(dep: SomeDependency) -&gt; SomeComponent:    return SomeComponent(dep)```Function `some_component` will be added as constructor.You can get its result by function name (or by decorator parameter `name`) and by class annotation if such annotationpresent.All dependencies from constructor arguments will be resolved the same way they are resolved in `__init__` method.## Inject directiveIn some rare cases you would like to manually set injectable components.For that case use `inject` parameter of `@component` or `@constructor` decorators:```pythonfrom tagil import component, constructor@component(inject={    &quot;dependency&quot;: &quot;dependence_component_name&quot;,})class SomeComponent:    def __init__(self, dependency):        self.dependency = dependency@constructor(inject={    &quot;dependency&quot;: DependencyClass,})def some_constructor(dependency):    return SomeAnotherComponent(dependency)```In that case dependencies will be resolved by they names or classes provided in inject dictionary.## post_init and pre_destroyWhen creating components tagil build initialization stack.You can manually call `InjectionManager().post_init()` and `InjectionManager().pre_destory()` or use applicationtemplate via `Application` base class:```pythonfrom tagil import component, Application@component()class SimpleApp(Application):    def run(self) -&gt; int:        return 0if __name__ == &quot;__main__&quot;:    SimpleApp.main()```All calls for `post_init` and `pre_destroy` methods of components will be performed by base class.## Component resolving algorythmTo define which component should be injected at instance creation tagil performs following set of rules:1. If injectable component name or class is set via `inject` argument, tagil will search component or constructor with    that name or class.2. If type of argument is present:   1. Tagil will search component or constructor with this type or with subclass type.   2. In case of many of candidates tagil will try to use argument name as component or constructor name3. If no type information or decorator rules are set tagil will search component by argument name.</longdescription>
</pkgmetadata>