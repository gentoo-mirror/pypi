<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Nexus PythonThis repository contains server-side code for managing devices using Nexusprotocols, including Nexus Keycode.Learn more about about Angaza Nexus [here](https://angaza.github.io/nexus)!## InstallationNexus Keycode will be available on PyPI. Installation will be as simple as:```shellpip install nexus-keycode```This package comes with a full suite of unit tests, which you can run like so:```shellnose2```## Versioning### Package VersionThis package uses a form of [semantic versioning](semver.org). The versionnumber is comprised of three components: MAJOR.MINOR.PATCHMajor version numbers represent breaking internal API changes. You may needto modify your code to accomodate these changes. Minor version numbersrepresent feature additions or changes that do not break the library's API,and are fully backward compatible. Patch version numbers represent bug fixesor minor changes that do not add additional functionality.The package version is independent of the Nexus System Version that thepackage supports.## UsageGenerate keycodes for the full and small keypad protocols.### Full ProtocolAdd Credit```pythonsecret_key = b&quot;\xde\xad\xbe\xef&quot; * 4message = FullMessage.add_credit(    id_=42, hours=24 * 7, secret_key=secret_key).to_keycode()# outputs *599 791 493 194 43#```Set Credit```pythonmessage = FullMessage.set_credit(    id_=43, hours=24 * 10, secret_key=secret_key).to_keycode()# outputs *682 070 357 093 12#```Unlock```pythonmessage = FullMessage.unlock(id_=44, secret_key=secret_key).to_keycode()# outputs *578 396 697 305 45#```Wipe```pythonmessage = FullMessage.wipe_state(    id_=45, flags=FullMessageWipeFlags.WIPE_IDS_ALL, secret_key=secret_key).to_keycode()# outputs *356 107 776 307 38#```Enabled/Disabled Test```pythonmessage = FactoryFullMessage.oqc_test().to_keycode()# outputs *577 043 3#```Factory Test```pythonmessage = FactoryFullMessage.allow_test().to_keycode()# outputs *406 498 3#```Display PAYG ID```pythonmessage = FactoryFullMessage.display_payg_id().to_keycode()# outputs *634 776 5#```#### Nexus Channel Origin CommandsThese commands are accepted by [Nexus Channel](https://nexus.angaza.com/channel.html)&quot;Controller&quot; devices using the &quot;Full Protocol&quot;. Typically, these are usedto manage the secured link state of &quot;Controller&quot; and &quot;Accessory&quot; devices.See also: `protocols/channel_origin_commands.py`Create Nexus Channel Secured Link```pythonfrom nexus_keycode.protocols.full import FactoryFullMessagefrom nexus_keycode.protocols.channel_origin_commands import ChannelOriginActionmessage = FactoryFullMessage.passthrough_channel_origin_command(ChannelOriginAction.LINK_ACCESSORY_MODE_3,    controller_command_count=5,    accessory_command_count=2,    accessory_sym_key=b&quot;\xAB&quot; * 16,    controller_sym_key=b&quot;\xCD&quot; * 16,)message.to_keycode()# outputs *817 307 500 565 772#```Delete Nexus Channel Secured Link (All Accessory Links)```pythonfrom nexus_keycode.protocols.full import FactoryFullMessagefrom nexus_keycode.protocols.channel_origin_commands import ChannelOriginActionmessage = FactoryFullMessage.passthrough_channel_origin_command(ChannelOriginAction.UNLINK_ALL_ACCESSORIES,    controller_command_count=7,    controller_sym_key=b&quot;\xCD&quot; * 16,)message.to_keycode()# outputs *810 023 592 81#```### Small ProtocolAdd Credit```pythonSECRET_KEY = b&quot;\xde\xad\xbe\xef&quot; * 4AddCreditSmallMessage(id_=42, days=7, secret_key=secret_key).to_keycode()# outputs 135 242 422 455 244```Set Credit```pythonSetCreditSmallMessage(id_=44, days=10, secret_key=secret_key).to_keycode()# outputs 142 522 332 234 533```Unlock```pythonUnlockSmallMessage(id_=45, secret_key=secret_key).to_keycode()# outputs 152 323 254 454 322```Wipe Message IDs```pythonMaintenanceSmallMessage(type_=MaintenanceSmallMessageType.WIPE_IDS_ALL, secret_key=secret_key).to_keycode()# outputs 122 324 235 545 545```Wipe Custom &quot;Restricted Flag&quot;```pythonCustomCommandSmallMessage(id_=46, type_=CustomCommandSmallMessageType.WIPE_RESTRICTED_FLAG, secret_key=secret_key).to_keycode()# outputs 154 545 254 542 523```Set Credit + Wipe Custom &quot;Restricted Flag&quot;```python# Creating a message of this type *may* lead to a 'message ID collision',# meaning the message cannot be unambiguously interpreted by the unit# (it might be mistaken for a different message if entered into the unit).# If this occurs, an `ExtendedSmallMessageIdInvalidError` error will be raised.# Typically incrementing the ID by 1 and creating the message again will# succeed.In [25]: ExtendedSmallMessage(id_=50, days=84, type_=ExtendedSmallMessageType.SET_CREDIT_WIPE_RESTRICTED_FLAG, secret_key=secret_key).to_keycode()# raises `ExtendedSmallMessageIdInvalidError: ID 50 yields MAC collision, next valid ID is 51.`In [26]: ExtendedSmallMessage(id_=51, days=84, type_=ExtendedSmallMessageType.SET_CREDIT_WIPE_RESTRICTED_FLAG, secret_key=secret_key).to_keycode()# outputs 145 545 244 442 435```</longdescription>
</pkgmetadata>