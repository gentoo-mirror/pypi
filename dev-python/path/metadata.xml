<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://img.shields.io/pypi/v/path.svg   :target: https://pypi.org/project/path.. image:: https://img.shields.io/pypi/pyversions/path.svg.. image:: https://github.com/jaraco/path/workflows/tests/badge.svg   :target: https://github.com/jaraco/path/actions?query=workflow%3A%22tests%22   :alt: tests.. image:: https://img.shields.io/badge/code%20style-black-000000.svg   :target: https://github.com/psf/black   :alt: Code style: Black.. image:: https://readthedocs.org/projects/path/badge/?version=latest   :target: https://path.readthedocs.io/en/latest/?badge=latest.. image:: https://img.shields.io/badge/skeleton-2022-informational   :target: https://blog.jaraco.com/skeleton.. image:: https://tidelift.com/badges/package/pypi/path   :target: https://tidelift.com/subscription/pkg/pypi-path?utm_source=pypi-path&amp;utm_medium=readme``path`` (aka path pie, formerly ``path.py``) implements pathobjects as first-class entities, allowing common operations onfiles to be invoked on those path objects directly. For example:.. code-block:: python    from path import Path    d = Path(&quot;/home/guido/bin&quot;)    for f in d.files(&quot;*.py&quot;):        f.chmod(0o755)    # Globbing    for f in d.files(&quot;*.py&quot;):        f.chmod(&quot;u+rwx&quot;)    # Changing the working directory:    with Path(&quot;somewhere&quot;):        # cwd in now `somewhere`        ...    # Concatenate paths with /    foo_txt = Path(&quot;bar&quot;) / &quot;foo.txt&quot;Path pie is `hosted at Github &lt;https://github.com/jaraco/path&gt;`_.Find `the documentation here &lt;https://path.readthedocs.io&gt;`_.Guides and Testimonials=======================Yasoob wrote the Python 101 `Writing a Cleanup Script&lt;http://freepythontips.wordpress.com/2014/01/23/python-101-writing-a-cleanup-script/&gt;`_based on ``path``.Advantages==========Python 3.4 introduced`pathlib &lt;https://docs.python.org/3/library/pathlib.html&gt;`_,which shares many characteristics with ``path``. In particular,it provides an object encapsulation for representing filesystem paths.One may have imagined ``pathlib`` would supersede ``path``.But the implementation and the usage quickly diverge, and ``path``has several advantages over ``pathlib``:- ``path`` implements ``Path`` objects as a subclass of  ``str``, and as a result these ``Path``  objects may be passed directly to other APIs that expect simple  text representations of paths, whereas with ``pathlib``, one  must first cast values to strings before passing them to  APIs unaware of ``pathlib``. This shortcoming was `addressed  by PEP 519 &lt;https://www.python.org/dev/peps/pep-0519/&gt;`_,  in Python 3.6.- ``path`` goes beyond exposing basic functionality of a path  and exposes commonly-used behaviors on a path, providing  methods like ``rmtree`` (from shlib) and ``remove_p`` (remove  a file if it exists).- As a PyPI-hosted package, ``path`` is free to iterate  faster than a stdlib package. Contributions are welcome  and encouraged.- ``path`` provides a uniform abstraction over its Path object,  freeing the implementer to subclass it readily. One cannot  subclass a ``pathlib.Path`` to add functionality, but must  subclass ``Path``, ``PosixPath``, and ``WindowsPath``, even  if one only wishes to add a ``__dict__`` to the subclass  instances.  ``path`` instead allows the ``Path.module``  object to be overridden by subclasses, defaulting to the  ``os.path``. Even advanced uses of ``path.Path`` that  subclass the model do not need to be concerned with  OS-specific nuances.This path project has the explicit aim to provide compatibilitywith ``pathlib`` objects where possible, such that a ``path.Path``object is a drop-in replacement for ``pathlib.Path*`` objects.This project welcomes contributions to improve that compatibilitywhere it's lacking.Alternatives============In addition to`pathlib &lt;https://docs.python.org/3/library/pathlib.html&gt;`_, the`pylib project &lt;https://pypi.org/project/py/&gt;`_ implements a`LocalPath &lt;https://github.com/pytest-dev/py/blob/72601dc8bbb5e11298bf9775bb23b0a395deb09b/py/_path/local.py#L106&gt;`_class, which shares some behaviors and interfaces with ``path``.Development===========To install a development version, use the Github links to clone ordownload a snapshot of the latest code. Alternatively, if you have gitinstalled, you may be able to use ``pip`` to install directly fromthe repository::    pip install git+https://github.com/jaraco/path.gitTesting=======Tests are invoked with `tox &lt;https://pypi.org/project/tox&gt;`_. Afterhaving installed tox, simply invoke ``tox`` in a checkout of the repoto invoke the tests.Tests are also run in continuous integration. See the badges abovefor links to the CI runs.Releasing=========Tagged releases are automatically published to PyPI by AzurePipelines, assuming the tests pass.Origins=======The ``path.py`` project was initially released in 2003 by Jason Orendorffand has been continuously developed and supported by several maintainersover the years.For Enterprise==============Available as part of the Tidelift Subscription.This project and the maintainers of thousands of other packages are working with Tidelift to deliver one enterprise subscription that covers all of the open source you use.`Learn more &lt;https://tidelift.com/subscription/pkg/pypi-path?utm_source=pypi-path&amp;utm_medium=referral&amp;utm_campaign=github&gt;`_.Security Contact================To report a security vulnerability, please use the`Tidelift security contact &lt;https://tidelift.com/security&gt;`_.Tidelift will coordinate the fix and disclosure.</longdescription>
</pkgmetadata>