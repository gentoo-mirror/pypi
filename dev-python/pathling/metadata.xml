<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Python API for Pathling=======================This is the Python API for [Pathling](https://pathling.csiro.au). It provides a set of tools that aid the use of FHIR terminology services and FHIR data within Python applications and data science workflows.[View the API documentation &amp;rarr;](https://pathling.csiro.au/docs/python/pathling.html)## InstallationPrerequisites:- Python 3.8+ with pipTo install, run this command:```bashpip install pathling  ```## EncodersThe Python library features a set of encoders for converting FHIR data intoSpark dataframes.### Reading in NDJSON[NDJSON](http://ndjson.org) is a format commonly used for bulk FHIR data, andconsists of files (one per resource type) that contains one JSON resource perline.```pythonfrom pathling import PathlingContextpc = PathlingContext.create()# Read each line from the NDJSON into a row within a Spark data set.ndjson_dir = '/some/path/ndjson/'json_resources = pc.spark.read.text(ndjson_dir)# Convert the data set of strings into a structured FHIR data set.patients = pc.encode(json_resources, 'Patient')# Do some stuff.patients.select('id', 'gender', 'birthDate').show()```### Reading in BundlesThe FHIR [Bundle](https://hl7.org/fhir/R4/bundle.html) resource can contain acollection of FHIR resources. It is often used to represent a set of relatedresources, perhaps generated as part of the same event.```pythonfrom pathling import PathlingContextpc = PathlingContext.create()# Read each Bundle into a row within a Spark data set.bundles_dir = '/some/path/bundles/'bundles = pc.spark.read.text(bundles_dir, wholetext=True)# Convert the data set of strings into a structured FHIR data set.patients = pc.encode_bundle(bundles, 'Patient')# JSON is the default format, XML Bundles can be encoded using input type.# patients = pc.encodeBundle(bundles, 'Patient', inputType=MimeType.FHIR_XML)# Do some stuff.patients.select('id', 'gender', 'birthDate').show()```## Terminology functionsThe library also provides a set of functions for querying a FHIR terminologyserver from within your queries and transformations.### Value set membershipThe `member_of` function can be used to test the membership of a code within a[FHIR value set](https://hl7.org/fhir/valueset.html). This can be used with bothexplicit value sets (i.e. those that have been pre-defined and loaded into theterminology server) and implicit value sets (e.g. SNOMED CT[Expression Constraint Language](http://snomed.org/ecl)).In this example, we take a list of SNOMED CT diagnosis codes andcreate a new column which shows which are viral infections. We use an ECLexpression to define viral infection as a disease with a pathological processof &quot;Infectious process&quot;, and a causative agent of &quot;Virus&quot;.```pythonresult = pc.member_of(csv, to_coding(csv.CODE, 'http://snomed.info/sct'),                      to_ecl_value_set(&quot;&quot;&quot;&lt;&lt; 64572001|Disease| : (  &lt;&lt; 370135005|Pathological process| = &lt;&lt; 441862004|Infectious process|,  &lt;&lt; 246075003|Causative agent| = &lt;&lt; 49872002|Virus|)                      &quot;&quot;&quot;), 'VIRAL_INFECTION')result.select('CODE', 'DESCRIPTION', 'VIRAL_INFECTION').show()```Results in:| CODE      | DESCRIPTION               | VIRAL_INFECTION ||-----------|---------------------------|-----------------|| 65363002  | Otitis media              | false           || 16114001  | Fracture of ankle         | false           || 444814009 | Viral sinusitis           | true            || 444814009 | Viral sinusitis           | true            || 43878008  | Streptococcal sore throat | false           |### Concept translationThe `translate` function can be used to translate codes from one code system toanother using maps that are known to the terminology server. In this example, wetranslate our SNOMED CT diagnosis codes into Read CTV3.```pythonresult = pc.translate(csv, to_coding(csv.CODE, 'http://snomed.info/sct'),                      'http://snomed.info/sct/900000000000207008?fhir_cm='                      '900000000000497000',                      output_column_name='READ_CODE')result = result.withColumn('READ_CODE', result.READ_CODE.code)result.select('CODE', 'DESCRIPTION', 'READ_CODE').show()```Results in:| CODE      | DESCRIPTION               | READ_CODE ||-----------|---------------------------|-----------|| 65363002  | Otitis media              | X00ik     || 16114001  | Fracture of ankle         | S34..     || 444814009 | Viral sinusitis           | XUjp0     || 444814009 | Viral sinusitis           | XUjp0     || 43878008  | Streptococcal sore throat | A340.     |### Subsumption testingSubsumption test is a fancy way of saying &quot;is this code equal or a subtype ofthis other code&quot;.For example, a code representing &quot;ankle fracture&quot; is subsumedby another code representing &quot;fracture&quot;. The &quot;fracture&quot; code is more general,and using it with subsumption can help us find other codes representingdifferent subtypes of fracture.The `subsumes` function allows us to perform subsumption testing on codes withinour data. The order of the left and right operands can be reversed to querywhether a code is &quot;subsumed by&quot; another code.```python# 232208008 |Ear, nose and throat disorder|left_coding = Coding('http://snomed.info/sct', '232208008')right_coding_column = to_coding(csv.CODE, 'http://snomed.info/sct')result = pc.subsumes(csv, 'IS_ENT',                     left_coding=left_coding,                     right_coding_column=right_coding_column)result.select('CODE', 'DESCRIPTION', 'IS_ENT').show()```Results in:| CODE      | DESCRIPTION       | IS_ENT ||-----------|-------------------|--------|| 65363002  | Otitis media      | true   || 16114001  | Fracture of ankle | false  || 444814009 | Viral sinusitis   | true   |### Retrieving propertiesSome terminologies contain additional properties that are associated with codes.You can query these properties using the `property_of` function.There is also a `display` function that can be used to retrieve the preferreddisplay term for each code.```python# Get the parent codes for each code in the dataset.parents = csv.withColumn(    &quot;PARENTS&quot;,    property_of(to_snomed_coding(csv.CODE), &quot;parent&quot;, PropertyType.CODE),)# Split each parent code into a separate row.exploded_parents = parents.selectExpr(    &quot;CODE&quot;, &quot;DESCRIPTION&quot;, &quot;explode_outer(PARENTS) AS PARENT&quot;)# Retrieve the preferred term for each parent code.with_displays = exploded_parents.withColumn(    &quot;PARENT_DISPLAY&quot;, display(to_snomed_coding(exploded_parents.PARENT)))```Results in:| CODE      | DESCRIPTION               | PARENT    | PARENT_DISPLAY                             ||-----------|---------------------------|-----------|--------------------------------------------|| 65363002  | Otitis media              | 43275000  | Otitis                                     || 65363002  | Otitis media              | 68996008  | Disorder of middle ear                     || 16114001  | Fracture of ankle         | 125603006 | Injury of ankle                            || 16114001  | Fracture of ankle         | 46866001  | Fracture of lower limb                     || 444814009 | Viral sinusitis           | 36971009  | Sinusitis                                  || 444814009 | Viral sinusitis           | 281794004 | Viral upper respiratory tract infection    || 444814009 | Viral sinusitis           | 363166002 | Infective disorder of head                 || 444814009 | Viral sinusitis           | 36971009  | Sinusitis                                  || 444814009 | Viral sinusitis           | 281794004 | Viral upper respiratory tract infection    || 444814009 | Viral sinusitis           | 363166002 | Infective disorder of head                 |### Retrieving designationsSome terminologies contain additional display terms for codes. These can be usedfor language translations, synonyms, and more. You can query these terms using the `designation` function.```python# Get the synonyms for each code in the dataset.synonyms = csv.withColumn(    &quot;SYNONYMS&quot;,    designation(to_snomed_coding(csv.CODE), Coding.of_snomed(&quot;900000000000013009&quot;)),)# Split each synonyms into a separate row.exploded_synonyms = synonyms.selectExpr(    &quot;CODE&quot;, &quot;DESCRIPTION&quot;, &quot;explode_outer(SYNONYMS) AS SYNONYM&quot;)```Results in:| CODE      | DESCRIPTION                          | SYNONYM                                    ||-----------|--------------------------------------|--------------------------------------------|| 65363002  | Otitis media                         | OM - Otitis media                          || 16114001  | Fracture of ankle                    | Ankle fracture                             || 16114001  | Fracture of ankle                    | Fracture of distal end of tibia and fibula || 444814009 | Viral sinusitis (disorder)           | NULL                                       || 444814009 | Viral sinusitis (disorder)           | NULL                                       || 43878008  | Streptococcal sore throat (disorder) | Septic sore throat                         || 43878008  | Streptococcal sore throat (disorder) | Strep throat                               || 43878008  | Streptococcal sore throat (disorder) | Strept throat                              || 43878008  | Streptococcal sore throat (disorder) | Streptococcal angina                       || 43878008  | Streptococcal sore throat (disorder) | Streptococcal pharyngitis                  |### Terminology server authenticationPathling can be configured to connect to a protected terminology server bysupplying a set of OAuth2 client credentials and a token endpoint.Here is an example of how to authenticate tothe [NHS terminology server](https://ontology.nhs.uk/):```pythonfrom pathling import PathlingContextpc = PathlingContext.create(    terminology_server_url='https://ontology.nhs.uk/production1/fhir',    token_endpoint='https://ontology.nhs.uk/authorisation/auth/realms/nhs-digital-terminology/protocol/openid-connect/token',    client_id='[client ID]',    client_secret='[client secret]')```## Installation in DatabricksTo make the Pathling library available within notebooks, navigate to the&quot;Compute&quot; section and click on the cluster. Click on the &quot;Libraries&quot; tab, andclick &quot;Install new&quot;.Install both the `pathling` PyPI package, andthe `au.csiro.pathling:library-api`Maven package. Once the cluster is restarted, the libraries should be availablefor import and use within all notebooks.By default, Databricks uses Java 8 within its clusters, while Pathling requiresJava 11. To enable Java 11 support within your cluster, navigate to __AdvancedOptions &gt; Spark &gt; Environment Variables__ and add the following:```bashJNAME=zulu11-ca-amd64```See the Databricks documentation on[Libraries](https://docs.databricks.com/libraries/index.html) for moreinformation.## Spark cluster configurationIf you are running your own Spark cluster, or using a Docker image (such as[jupyter/pyspark-notebook](https://hub.docker.com/r/jupyter/pyspark-notebook)),you will need to configure Pathling as a Spark package.You can do this by adding the following to your `spark-defaults.conf` file:```spark.jars.packages au.csiro.pathling:library-api:[some version]```See the [Configuration](https://spark.apache.org/docs/latest/configuration.html)page of the Spark documentation for more information about `spark.jars.packages`and other related configuration options.To create a Pathling notebook Docker image, your `Dockerfile` might look likethis:```dockerfileFROM jupyter/pyspark-notebookUSER rootRUN echo &quot;spark.jars.packages au.csiro.pathling:library-api:[some version]&quot; &gt;&gt; /usr/local/spark/conf/spark-defaults.confUSER ${NB_UID}RUN pip install --quiet --no-cache-dir pathling &amp;&amp; \    fix-permissions &quot;${CONDA_DIR}&quot; &amp;&amp; \    fix-permissions &quot;/home/${NB_USER}&quot;```Pathling is copyright © 2018-2023, Commonwealth Scientific and IndustrialResearch Organisation(CSIRO) ABN 41 687 119 230. Licensed underthe [Apache License, version 2.0](https://www.apache.org/licenses/LICENSE-2.0).</longdescription>
</pkgmetadata>