<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>WebPie======WebPie (another way of spelling web-py) is a web application development framework for Python based on the WSGI standard.WebPie makes it simple to develop thread-safe object-oriented web applications.Hello World in WebPie---------------------Here is the simplest WebPie application you can write:.. code-block:: python# hello_world.pyfrom webpie import WPApp, WPHandlerclass MyHandler(WPHandler):                         # 1    def hello(self, request, relpath):              # 2        return &quot;Hello, World!\n&quot;                    # 3application = WPApp(MyHandler)                      # 4Let's go over the code line by line:1. We created class MyHandler, which will handle HTTP requests. In order to work with WebPie, it has to be a subclass of WPHandler class.2. We defined one web method &quot;hello&quot;, which will be called when a URL like http://host.org/hello is requested.3. It will always return text &quot;Hello, World!&quot;.4. Finally, we created a WSGI application as an instance of WPApp class, passing it the MyHandler class as an argument.Now we can plug our application into any WSGI framework such as uWSGI or Apache httpd, e.g.:.. code-block:: bash$ uwsgi --http :8080 --wsgi-file hello_world.pyand try it:.. code-block:: bash$ curl http://localhost:8080/helloHello world!$ If you do not want to use uWSGI or similar framework, you can use WebPie's own HTTP server to put your application on the web:.. code-block:: python# hello_world_server.pyfrom webpie import WPApp, WPHandler, run_serverimport timeclass MyHandler(WPHandler):def hello(self, request, relpath):return &quot;Hello, World!\n&quot;application = WPApp(MyHandler)application.run_server(8080)        # run the server at port 8080.. code-block:: bash$ python hello_world_server.py &amp;$ curl http://localhost:8080/helloHello world!    $URL Structure-------------Notice that MyHandler class has single method &quot;hello&quot; and it maps to the URL path &quot;hello&quot;. This is general rule in WebPie - methods of handler classes map one to one to the elements of URI path. For example, we can add another method to our server called &quot;time&quot;:.. code-block:: pythonfrom webpie import WPApp, WPHandlerimport timeclass MyHandler(WPHandler):def hello(self, request, relpath):return &quot;Hello, World!\n&quot;def time(self, request, relpath):return time.ctime()+&quot;\n&quot;application = WPApp(MyHandler)application.run_server(8080)Now our handler can handle 2 types of requests, it can say hello and it can tell local time:.. code-block:: bash$ curl http://localhost:8080/helloHello, World!$ curl http://localhost:8080/timeSun May  5 06:47:15 2019$ Notice that handler methods names automatically become parts of the URL path.If you want to split your handler into different classes to organize your code better, you can have nested handler classes in your application. For example, we may want to have one handler which focuses on reporting time and the other which says hello:.. code-block:: python# time_hello_split.pyfrom webpie import WPApp, WPHandlerimport timeclass HelloHandler(WPHandler):def hello(self, request, relpath):return &quot;Hello, World!\n&quot;class ClockHandler(WPHandler):def time(self, request, relpath):return time.ctime()+&quot;\n&quot;, &quot;text/plain&quot;class TopHandler(WPHandler):def __init__(self, *params):WPHandler.__init__(self, *params)self.greet = HelloHandler(*params)self.clock = ClockHandler(*params)application = WPApp(TopHandler)application.run_server(8080)WebPie application is given top handler class as an argument. It will create the handler instances one per eachweb request. Top handler can create child handlers recursively. This recirsive handler structure maps one-to-one to the URL structure. The URI is simply the path from the top handler through its child handlers to the method of one of them:.. code-block:: bash$ curl http://localhost:8080/greet/helloHello, World!$ curl http://localhost:8080/clock/timeSun May  5 06:49:14 2019$ For example, to find the method for URI &quot;/greet/hello&quot;, WebPie starts with top handler, finds its child handler &quot;greet&quot; of class Greeter and then calls its &quot;hello&quot; method.Non-leaf handlers in the tree can have their own methods. For example:.. code-block:: python# time_hello_split2.pyfrom webpie import WPApp, WPHandlerimport timeclass HelloHandler(WPHandler):def hello(self, request, relpath):return &quot;Hello, World!\n&quot;class ClockHandler(WPHandler):def time(self, request, relpath):return time.ctime()+&quot;\n&quot;, &quot;text/plain&quot;class TopHandler(WPHandler):def __init__(self, *params, **kv):WPHandler.__init__(self, *params, **kv)self.greet = HelloHandler(*params, **kv)self.clock = ClockHandler(*params, **kv)def version(self, request, relpath):    # non-leaf handler can have a web method    return &quot;1.0.3&quot;application = WPApp(TopHandler)application.run_server(8080).. code-block:: bash$ curl  http://localhost:8080/version1.0.2Application and Handler-----------------------The WPApp object is created *once* when the web server instance starts and it persists until the server stops whereas WPHandler object trees are created for each individual HTTP request from scratch. Handler object's App member always points to its app object. This allows the app object to keep some persistent information and let handler objects access it. For example, or clock application can also maintain number of requests it has received:.. code-block:: python# time_count.pyfrom webpie import WPApp, WPHandlerimport timeclass Handler(WPHandler):def time(self, request, relpath):self.App.Counter += 1return time.ctime()+&quot;\n&quot;, &quot;text/plain&quot;def count(self, request, relpath): return str(self.App.Counter)+&quot;\n&quot;class App(WPApp):def __init__(self, handler_class):WPApp.__init__(self, handler_class)self.Counter = 0application = App(Handler)application.run_server(8080).. code-block:: bash$ curl  http://localhost:8080/timeSun May  5 08:10:12 2019$ curl  http://localhost:8080/timeSun May  5 08:10:14 2019$ curl  http://localhost:8080/count2$ curl  http://localhost:8080/timeSun May  5 08:10:17 2019$ curl  http://localhost:8080/count3Of course the way it is written, our application is not very therad-safe, but there is an easy way to fix it.We will talk about this later.Web Methods in Details----------------------The WebPie server handler method has 2 fixed arguments and optional keyword arguments.First argiment is the request object, which encapsulates all the information about the incoming HTTP request. Currently WebPie uses WebOb library Request and Response classes to handle HTTP requests and responses.Arguments~~~~~~~~~Most generally, web method looks like this:.. code-block:: python    def method(self, request, relpath, **url_args):        # ...        return responseWeb method arguments are:request.......request is WebOb request object built from the WSGI environment. For convenience, it is also available as the handler'sRequest member.relpath.......Sometimes, while walking down the tree of handlers to find the method to handle the request, there will be someunused portion of URI after the name of the target handler method. For example, in our clock example, we may want tostructure our URL to specify the field of the current time we want to see in the following way:.. code-block::http://localhost:8080/time/month    # month onlyhttp://localhost:8080/time/minute   # minute onlyhttp://localhost:8080/time          # whole day/timeIn this case, we want the &quot;time&quot; method to hadle all types of requests and know which portion of date/time toreturn. Here is the code which does this:.. code-block:: pythonfrom webpie import WPApp, WPHandlerfrom datetime import datetimeclass MyHandler(WPHandler):def time(self, request, relpath):t = datetime.now()if not relpath:return str(t)+&quot;\n&quot;elif relpath == &quot;year&quot;:return str(t.year)+&quot;\n&quot;elif relpath == &quot;month&quot;:return str(t.month)+&quot;\n&quot;elif relpath == &quot;day&quot;:return str(t.day)+&quot;\n&quot;elif relpath == &quot;hour&quot;:return str(t.hour)+&quot;\n&quot;elif relpath == &quot;minute&quot;:return str(t.minute)+&quot;\n&quot;elif relpath == &quot;second&quot;:return str(t.second)+&quot;\n&quot;application = WPApp(MyHandler)application.run_server(8080)url_args........Anoter, perhaps more conventional way of doing this is to use so called query parameters to specify theformat of the date/time representation, e.g.:.. code-block::http://localhost:8080/time?field=minuteWebPie always parses query parameters and passes them to the handler method as if they were keyword arguments. For example, we can write the method which extracts fields from current time like this:.. code-block:: python# time_args.pyfrom webpie import WPApp, WPHandlerfrom datetime import datetimeclass MyHandler(WPHandler):def time(self, request, relpath, field=&quot;all&quot;):t = datetime.now()if field == &quot;all&quot;:return str(t)+&quot;\n&quot;elif field == &quot;year&quot;:return str(t.year)+&quot;\n&quot;elif field == &quot;month&quot;:return str(t.month)+&quot;\n&quot;elif field == &quot;day&quot;:return str(t.day)+&quot;\n&quot;elif field == &quot;hour&quot;:return str(t.hour)+&quot;\n&quot;elif field == &quot;minute&quot;:return str(t.minute)+&quot;\n&quot;elif field == &quot;second&quot;:return str(t.second)+&quot;\n&quot;WPApp(MyHandler).run_server(8080)and then call it like this:.. code-block:: bash$ curl  http://localhost:8080/time2019-05-05 08:39:49.593855$ curl  &quot;http://localhost:8080/time?field=month&quot;5$ curl  &quot;http://localhost:8080/time?field=year&quot;2019Return Value~~~~~~~~~~~~The output of a web method is a Response object. Conveniently, there is a number of ways to return something from the web method. Ultimately, all of them are used to produce and return the Response object. Here is a list of possibile returns from the web oject and how the frameworkconverts the output to the Response object:======================================  =================================== ==================================================================return                                  example                             equivalent Response object======================================  =================================== ==================================================================Response object                         Response(&quot;OK&quot;)                      same - Response(&quot;OK&quot;)text                                    &quot;hello world&quot;                       Response(&quot;hello world&quot;)text, content type                      &quot;OK&quot;, &quot;text/plain&quot;                  Response(&quot;OK&quot;, content_type=&quot;text/plain&quot;)text, status                            &quot;Error&quot;, 500                        Response(&quot;Error&quot;, status_code=500)text, status, content type              &quot;Error&quot;, 500, &quot;text/plain&quot;          Response(&quot;Error&quot;, status_code=500, content_type=&quot;text/plain&quot;)text, headers                           &quot;OK&quot;, {&quot;Content-Type&quot;:&quot;text/plain&quot;} Response(&quot;OK&quot;, headers={&quot;Content-Type&quot;:&quot;text/plain&quot;})list                                    [&quot;Hello&quot;,&quot;world&quot;]                   Response(app_iter=[&quot;Hello&quot;,&quot;world&quot;])iterable                                (x for x in [&quot;hi&quot;,&quot;there&quot;])         Response(app_iter=(x for x in [&quot;hi&quot;,&quot;there&quot;]))iterable, content_typeiterable, status, content_typeiterable, status, headers======================================  =================================== ==================================================================The response body can be returned either as a single string or bytes object, or as a list of strings orbytes objects or as an iterable (generator or iterator), producing a sequence of strings or bytes objects.If the handler method returns strings, under Python3, they will be converted to bytes using UTF-8 conversion.If you want to use some other encoding, then you must convert your strings to bytes before returningfrom the handler method.Static Content--------------Sometimes the application needs to serve static content like HTML documents, CSS stylesheets, JavaScript code.WebPie App can be configured to serve static file from certain directory in the file system... code-block:: python    class MyHandler(WPHandler):        #...    class MyApp(WPApp):        #...            application = MyApp(MyHandler,             static_enabled = True,            static_path = &quot;/static&quot;,             static_location = &quot;./scripts&quot;)                application.run_server(8002)        If you run such an application, a request for URL like &quot;http://..../static/code.js&quot; will result indelivery of file local file ./scripts/code.js. static_location can be either relative to the workingdirectory where the application runs or an absolute path.Because serving files from local file system is a potential security vulnerability, thisfunctionality must be explicitly enabled with static_enabled=True. static_path and static_locationshave defaults:.. code-block:: python    static_path = &quot;/static&quot;    static_location = &quot;./static&quot;Threaded Applications---------------------WebPie provides several mechanisms to build thread safe applications. When working in multithreaded environment, WebPie Handlerobjects are concurrently created in their own threads, one for each request, whereas WebApp object is created only once and itis shared by all the threads handling the requests. This feature makes it possible to use the App object for inter-handlersynchronization. The App object has its own lock object and threads can use it in 2 different ways:atomic decorator~~~~~~~~~~~~~~~~Decorating a web method with &quot;atomic&quot; decorator makes the web method atomic in the sense that if a handler thread enters sucha method, any other handler thread of the same application will block before entering any atomic method until the first thread returns from the method.For example:.. code-block:: python    from webpie import WPApp, WPHandler, atomic    class MyApp(WPApp):            def __init__(self, root_class):            WPApp.__init__(self, root_class)            self.Memory = {}        class Handler(WPHandler):            @atomic        def set(self, req, relpath, name=None, value=None, **args):            self.App.Memory[name]=value            return &quot;OK\n&quot;                @atomic        def get(self, req, relpath, name=None, **args):            return self.App.Memory.get(name, &quot;(undefined)&quot;)+&quot;\n&quot;            application = MyApp(Handler)    application.run_server(8002)You can also decorate methods of the App. For example:.. code-block:: pythonfrom webpie import WPApp, WPHandler, atomicclass MyApp(WPApp):        RecordSize = 10        def __init__(self, root_class):        WPApp.__init__(self, root_class)        self.Record = []            @atomic    def add(self, value):        if value in self.Record:            self.Record.remove(value)        self.Record.insert(0, value)        if len(self.Record) &gt; self.RecordSize:            self.Record = self.Record[:self.RecordSize]            @atomic    def find(self, value):        try:    i = self.Record.index(value)        except ValueError:            return &quot;not found&quot;        self.Record.pop(i)        self.Record.insert(0, value)        return str(i)        class Handler(WPHandler):        def add(self, req, relpath, **args):        return self.App.add(relpath)            def find(self, req, relpath, **args):        return self.App.find(relpath)        application = MyApp(Handler)application.run_server(8002)App object as a context manager~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Another to implement a critical section is to use the App object as the context manager:.. code-block:: python    from webpie import WPApp, WPHandler    class MyApp(WPApp):            def __init__(self, root_class):            WPApp.__init__(self, root_class)            self.Memory = {}        class Handler(WPHandler):            def set(self, req, relpath, name=None, value=None, **args):            with self.App:                self.App.Memory[name]=value            return &quot;OK\n&quot;                def get(self, req, relpath, name=None, **args):            with self.App:                return self.App.Memory.get(name, &quot;(undefined)&quot;) + &quot;\n&quot;            application = MyApp(Handler)    application.run_server(8002)Session Management------------------Jinja2 Environment------------------WebPie is aware of Jinja2 template library and provides some shortcuts in using it.To make your application work with Jinja2, you need to initialize Jinja2 environment first:.. code-block:: pythonfrom webpie import WPApp, WPHandlerclass MyHandler(WPHandler):            # ...    class MyApp(WPApp):        # ...application = MyApp(MyHandler)    application.initJinjaEnvironment(        tempdirs = [...],        filters = {...},        globals = {...}    )The initJinjaEnvironment method accepts 3 arguments:tempdirs - list of directories where to look for Jinja2 templates,  filters - dictionary with filter names and filter functions to add to the environment,  globals - dictionary with &quot;global&quot; variables, which will be added to the list of variables when a template is rendered    Here is an example of such an application and corresponding template:.. code-block:: python    # templates.py    from webpie import WPApp, WPHandler    import time    Version = &quot;1.3&quot;    def format_time(t):        return time.ctime(t)    class MyHandler(WPHandler):        def time(self, request, relpath):            return self.render_to_response(&quot;time.html&quot;, t=time.time())            application = WPApp(MyHandler)    application.initJinjaEnvironment(        [&quot;samples&quot;],         filters={ &quot;format&quot;: format_time },        globals={ &quot;version&quot;: Version }        )    application.run_server(8080)and the template samples/time.html is:.. code-block:: html    &lt;html&gt;    &lt;body&gt;    &lt;p&gt;Current time is {{t|format}}&lt;/p&gt;    &lt;p style=&quot;float:right&quot;&gt;&lt;i&gt;Version: {{version}}&lt;/i&gt;&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;In this example, the application initializes the Jinja2 environment with &quot;samples&quot; as the templates location,function &quot;format_time&quot; becomes the filter used to display numeric time as date/time string and &quot;global&quot;variable &quot;version&quot; is set to the version of the code.Then the handler calls the &quot;render_to_response&quot; method, inherited from WPHandler, to render the template &quot;time.html&quot;with current time passed as the &quot;t&quot; argument, and implicitly &quot;version&quot; passed to the rendering as a globalvariable. The &quot;render_to_response&quot; method renders the template and returns properly constructed Responseobject with content type set to &quot;text/html&quot;.Advanced Topics---------------Permissions~~~~~~~~~~~Strict Applications~~~~~~~~~~~~~~~~~~~Built-in HTTP/HTTPS Server~~~~~~~~~~~~~~~~~~~~~~~~~~</longdescription>
</pkgmetadata>