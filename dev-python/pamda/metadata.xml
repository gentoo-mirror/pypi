<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Pamda[![PyPI version](https://badge.fury.io/py/pamda.svg)](https://badge.fury.io/py/pamda)[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)Python wrapper for functional programming in object oriented structures.Inspired heavily by [Ramda](https://ramdajs.com/docs/).## Documentation for Pamda Functionshttps://connor-makowski.github.io/pamda/pamda.html## Key Features- Simplified functional programming for python- Core Functions include:  - `curry` arbitrary methods and functions  - `thunkify` arbitrary methods and functions  - `pipe` data iteratively through n functions- List based path access and features for nested dictionaries## SetupMake sure you have Python 3.6.x (or higher) installed on your system. You can download it [here](https://www.python.org/downloads/).### Installation```pip install pamda```## Getting Started### Basic Usage```pyfrom pamda import pamdadata={'a':{'b':1, 'c':2}}# Example: Select data given a path and a dictionarypamda.path(['a','b'])(data) #=&gt; 1# See documentation for all core pamda functions at# https://connor-makowski.github.io/pamda/pamda.html```### Curry Usage```pyfrom pamda import pamda# Define a function that you want to currydef myFunction(a,b,c):    return [a,b,c]# You can call pamda.curry as a function to curry your functionscurriedMyFn=pamda.curry(myFunction)# Inputs can now be passed in an async fashion# The function is evaluated when all inputs are addedx=curriedMyFn(1,2)x(3) #=&gt; [1,2,3]x(4) #=&gt; [1,2,4]# Each set of inputs returns a callable function# You can stack inputs on a single line for clean functional programmingcurriedMyFn(1,2)(3) #=&gt; [1,2,3]```For enforcing types, pamda relies on [type_enforced](https://github.com/connor-makowski/type_enforced) but curried objects do not play nice with `type_enforced` objects. To fix this, there is a special curry function, `curryType`, that enables type_enforced annotations for your curried functions:```py&gt;&gt;&gt; from pamda import pamda&gt;&gt;&gt; &gt;&gt;&gt; # Pamda CurryTyped&gt;&gt;&gt; @pamda.curryTyped... def add(a:int,b:int):...     return a+b... &gt;&gt;&gt; add(1)(1)2&gt;&gt;&gt; add(1)(1.5)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;/home/conmak/development/personal/pamda/pamda/pamda_curry.py&quot;, line 43, in __call__    results = self.__fnExecute__(*new_args, **new_kwargs)  File &quot;/home/conmak/development/personal/pamda/venv/lib/python3.10/site-packages/type_enforced/enforcer.py&quot;, line 90, in __call__    self.__check_type__(assigned_vars.get(key), value, key)  File &quot;/home/conmak/development/personal/pamda/venv/lib/python3.10/site-packages/type_enforced/enforcer.py&quot;, line 112, in __check_type__    self.__exception__(  File &quot;/home/conmak/development/personal/pamda/venv/lib/python3.10/site-packages/type_enforced/enforcer.py&quot;, line 34, in __exception__    raise TypeError(f&quot;({self.__fn__.__qualname__}): {message}&quot;)TypeError: (add): Type mismatch for typed variable `b`. Expected one of the following `[&lt;class 'int'&gt;]` but got `&lt;class 'float'&gt;` instead.```### Thunkify Usage```pyfrom pamda import pamda# Define a function that you want to thunkify# thunkify can be called as a function or decorator@pamda.thunkifydef myFunction(a,b,c):    return [a,b,c]# The function is now curried and the evaluation is lazy# This means the function is not evaluated until calledx=myFunction(1,2)x(3) #=&gt; &lt;pamda.curry_obj object at 0x7fd514e4c820&gt;x(3)() #=&gt; [1,2,3]y=x(4)y() #=&gt; [1,2,4]```Thunkified functions can be executed asynchronously.```pyfrom pamda import pamdaimport time@pamda.thunkifydef test(name, wait):    print(f'{name} start')    time.sleep(wait)    print(f'{name} end')    return waitasync_test_a = pamda.asyncRun(test('a',2))async_test_b = pamda.asyncRun(test('b',1))async_test_a.asyncWait()async_test_c = pamda.asyncRun(test('c',1))```The above code would output:```a startb startb enda endc startc end```### Pipe```pyfrom pamda import pamdadef square(x):    return x**2def half(x):    return x/2def negate(x):    return -x# You can pipe data through multiple functions for clean functional programmingpamda.pipe([square, half, negate])(args=(6,),kwargs={}) #=&gt; -18```### Use pamda as a subclass```pyfrom pamda import pamdaclass myClass(pamda):    def myFunction(self, a):        return self.inc(a)mc=myClass()mc.myFunction(2) #=&gt; 3@mc.currydef addUp(a,b):    return a+baddUp(1)(2) #=&gt; 3```## Pamda Utils- Pamda also ships with a few helpful utilities- Check out the documentation here:  - https://connor-makowski.github.io/pamda/pamda_utils.html</longdescription>
</pkgmetadata>