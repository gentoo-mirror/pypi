<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Coverage Status](https://coveralls.io/repos/github/zincware/ZnJSON/badge.svg?branch=main)](https://coveralls.io/github/zincware/ZnJSON?branch=main)[![Code Style](https://img.shields.io/badge/code%20style-black-black)](https://github.com/psf/black/)[![Tests](https://github.com/zincware/ZnJSON/actions/workflows/pytest.yaml/badge.svg)](https://coveralls.io/github/zincware/ZnJSON?branch=main)[![PyPI version](https://badge.fury.io/py/znjson.svg)](https://badge.fury.io/py/znjson)# ZnJSONPackage to Encode/Decode some common file formats to jsonAvailable via ``pip install znjson``In comparison to `pickle` this allows having readable json files combined with someserialized data.# Example````pythonimport numpy as npimport jsonimport znjsondata = json.dumps(    obj={&quot;data_np&quot;: np.arange(2), &quot;data&quot;: [x for x in range(10)]},    cls=znjson.ZnEncoder,    indent=4)_ = json.loads(data, cls=znjson.ZnDecoder)````The resulting ``*.json`` file is partially readable and looks like this:````json{    &quot;data_np&quot;: {        &quot;_type&quot;: &quot;np.ndarray_small&quot;,        &quot;value&quot;: [            0,            1        ]    },    &quot;data&quot;: [        0,        1,        2,        3,        4    ]}````# Custom ConverterZnJSON allows you to easily add custom converters.Let's write a serializer for ``datetime.datetime``. ````pythonfrom znjson import ConverterBasefrom datetime import datetimeclass DatetimeConverter(ConverterBase):    &quot;&quot;&quot;Encode/Decode datetime objects    Attributes    ----------    level: int        Priority of this converter over others.        A higher level will be used first, if there        are multiple converters available    representation: str        An unique identifier for this converter.    instance:        Used to select the correct converter.        This should fulfill isinstance(other, self.instance)        or __eq__ should be overwritten.    &quot;&quot;&quot;    level = 100    representation = &quot;datetime&quot;    instance = datetime    def encode(self, obj: datetime) -&gt; str:        &quot;&quot;&quot;Convert the datetime object to str / isoformat&quot;&quot;&quot;        return obj.isoformat()    def decode(self, value: str) -&gt; datetime:        &quot;&quot;&quot;Create datetime object from str / isoformat&quot;&quot;&quot;        return datetime.fromisoformat(value)````This allows us to use this new serializer:````pythonznjson.config.register(DatetimeConverter) # we need to register the new converter firstjson_string = json.dumps(dt, cls=znjson.ZnEncoder, indent=4)json.loads(json_string, cls=znjson.ZnDecoder)````and will result in````json{    &quot;_type&quot;: &quot;datetime&quot;,    &quot;value&quot;: &quot;2022-03-11T09:47:35.280331&quot;}````If you don't want to register your converter to be used everywhere, simply use:```pythonjson_string = json.dumps(dt, cls=znjson.ZnEncoder.from_converters(DatetimeConverter))```</longdescription>
</pkgmetadata>