<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Sveltish================&lt;!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! --&gt;`Svelte Stores` are one of the secret weapons of the [Svelteframework](https://svelte.dev/) (the recently voted [most loved webframework](https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-web-frameworks)).Stores allow easy [reactiveprogramming](https://en.wikipedia.org/wiki/Reactive_programming) bypresenting an [Observerpattern](https://en.wikipedia.org/wiki/Observer_pattern) that is assimple as necessary, but not simpler.## Install``` shpip install sveltish```## How to useSometimes, you’ll have values that need to be accessed by multipleunrelated objects.For that, you can use `stores`. It is a very simple implementation(around 100 lines of code) of the Observer/Observable pattern.A store is simply an object with a `subscribe` method that allowsinterested parties to be notified when its value changes.#### **Writable Stores**``` pythonfrom sveltish.stores import writable`````` pythoncount = writable(0)history = []  # logging for testing# subscribe returns an unsubscriberdef record(x):     history.append(x)    print(history)stop = count.subscribe(record)test_eq(history, [0])```    [0]We just created a `count` store. Its value can be accessed via a`callback` we pass in the `count.subscribe` method:A **Writable** can be set from the outside. When it happens, all itssubscribers will react.``` pythondef increment(): count.update(lambda x: x + 1)def decrement(): count.update(lambda x: x - 1)def reset(): count.set(0)count.set(3)increment()decrement()decrement()reset()count.set(42)test_eq(history, [0, 3, 4, 3, 2, 0, 42])```    [0, 3]    [0, 3, 4]    [0, 3, 4, 3]    [0, 3, 4, 3, 2]    [0, 3, 4, 3, 2, 0]    [0, 3, 4, 3, 2, 0, 42]The `unsubscriber`, in this example the `stop` function, stops thenotifications to the `subscriber`.``` pythonstop()reset()count.set(22)test_eq(history, [0, 3, 4, 3, 2, 0, 42])count```    w&lt;0&gt; $int: 22Notice that you can still change the `store` but there was no printmessage this time. There was no observer listening.&lt;div&gt;&gt; **Note**&gt;&gt; [`Observer`](https://fredguth.github.io/sveltish/signals.html#observer),&gt; `Subscriber` and&gt; [`Callback`](https://fredguth.github.io/sveltish/signals.html#callback)&gt; are used as synomyms here.&lt;/div&gt;When we subscribe new callbacks, they will be promptly informed of thecurrent state of the `store`.``` pythonstop  = count.subscribe(lambda x: print(f&quot;Count is now {x}&quot;))stop2 = count.subscribe(lambda x: print(f&quot;double of count is {2*x}&quot;))```    Count is now 22    double of count is 44``` pythonreset()```    Count is now 0    double of count is 0``` pythonstop()stop2()```You can create an empty `Writable Store`.``` pythonstore = writable()history = []unsubscribe = store.subscribe(lambda x: history.append(x))unsubscribe()test_eq(history, [None])```If you try to unsubscribe twice, it won’t break. It just does nothingthe second time… and in the third time… and…``` pythonunsubscribe(), unsubscribe(), unsubscribe()```    (None, None, None)Stores assume mutable objects.&lt;div&gt;&gt; **Note**&gt;&gt; In Python everythong is an object. Here we are calling an object&gt; something that is not a primitive (eg. int, bool, etc)&lt;/div&gt;``` pythonclass Bunch:    __init__ = lambda self, **kw: setattr(self, '__dict__', kw)obj = Bunch()called = 0store = writable(obj)def callback(x):    global called    called += 1stop = store.subscribe(callback)`````` pythontest_eq(called, 1)obj.a = 1 #type: ignorestore.set(obj)test_eq(called, 2)```#### **Readable Stores**However… It is clear that not all stores should be writable by whoeverhas a reference to them. Many times you want a single `publisher` ofchange in store that is only consumed (`subscribed`) by many otherobjects. For those cases, we have readable stores.&lt;div&gt;&gt; **Note**&gt;&gt; The `Publisher Subscriber (PubSub)` pattern is a variant of the&gt; `Observable/Observer` pattern.&lt;/div&gt;``` pythonfrom sveltish.stores import readable```A Readable store without a `start` function is a constant value and hasno meaning for us. Therefore, `start` is a required argument.``` pythontry:    c = readable(0) # shoud failexcept Exception as error:    print(error)test_fail(lambda: readable(0))```    readable() missing 1 required positional argument: 'start'``` pythonclass Publisher:    def __init__(self): self.set = lambda x: None    def set_set(self, set):         self.set = set        return lambda: None    def use_set(self, value): self.set(value)`````` pythonp = Publisher()reader = readable(0, p.set_set)reader```    r&lt;0&gt; $int: 0Ths store only starts updating after the first subscriber. Here, thepublisher does not change the store.``` pythonp.use_set(1), reader```    (None, r&lt;0&gt; $int: 0)``` pythonstop = reader.subscribe(lambda x: print(f&quot;reader is now {x}&quot;))```    reader is now 0``` pythonp.use_set(2)```    reader is now 2``` pythonstop()```Another example of Readable Store usage:``` pythonfrom threading import Event, Threadimport time`````` pythondef start(set): # the start function is the publisher    stopped = Event()    def loop(): # needs to be in a separate thread        while not stopped.wait(1): # in seconds            set(time.localtime())    Thread(target=loop).start()        return stopped.set`````` pythonnow = readable(time.localtime(), start)now```    r&lt;0&gt; $struct_time: time.struct_time(tm_year=2023, tm_mon=3, tm_mday=8, tm_hour=22, tm_min=12, tm_sec=41, tm_wday=2, tm_yday=67, tm_isdst=0)&lt;div&gt;&gt; **Note**&gt;&gt; The `loop` needs to be in its own thread, otherwise the function would&gt; never return and we would wait forever.&lt;/div&gt;While there is no subscriber, the Readable will not be updated.``` pythonnow```    r&lt;0&gt; $struct_time: time.struct_time(tm_year=2023, tm_mon=3, tm_mday=8, tm_hour=22, tm_min=12, tm_sec=41, tm_wday=2, tm_yday=67, tm_isdst=0)``` pythonOhPleaseStop = now.subscribe(lambda x: print(time.strftime(f&quot;%H:%M:%S&quot;, x), end=&quot;\r&quot;))```    22:12:41``` pythontime.sleep(2)OhPleaseStop()```    22:12:43&lt;div&gt;&gt; **Note**&gt;&gt; The Svelte Store api allow you to create a Readable Store without a&gt; Notifier. See discussion&gt; [here.](https://github.com/sveltejs/svelte/issues/8300)&lt;/div&gt;#### **Derived Stores**A `Derived Store` stores a value based on the value of another store.``` pythonfrom sveltish.stores import derived```For example:``` pythoncount = writable(1)stopCount = count.subscribe(lambda x: print(f&quot;count is {x}&quot;))double = derived(count, lambda x: x * 2)stopDouble = double.subscribe(lambda x: print(f&quot;double is {x}&quot;))test_eq(double.get(), 2*count.get())```    count is 1    double is 2``` pythoncount.set(2)test_eq(double.get(), 4)```    count is 2    double is 4``` pythonstopCount(), stopDouble()```    (None, None)Building on our previous example, we can create a store that derives theelapsed time since the original store was started.``` pythonelapsing = Nonedef calc_elapsed(now):    global elapsing    if not elapsing:         elapsing = now    return time.mktime(now) - time.mktime(elapsing)`````` pythonnow```    r&lt;0&gt; $struct_time: time.struct_time(tm_year=2023, tm_mon=3, tm_mday=8, tm_hour=22, tm_min=12, tm_sec=43, tm_wday=2, tm_yday=67, tm_isdst=0)``` pythonelapsed = derived(now, lambda x: calc_elapsed(x))elapsed```    r&lt;0&gt; $float: 0.0``` pythonstopElapsed = elapsed.subscribe(lambda x: print(f&quot;Elapsed time of source store: {x} seconds.&quot;, end=&quot;\r&quot;))```    Elapsed time of source store: 0.0 seconds.``` pythontime.sleep(1)stopElapsed()```    Elapsed time of source store: 2.0 seconds.Derived stores allow us to transform the value of a store. In RxPy theyare called `operators`. You can build several operators like: `filter`,`fold`, `map`, `zip`…Let’s build a custom `filter` operator:``` pythonuser = writable({&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 32})stopLog = user.subscribe(lambda x: print(f&quot;User: {x}&quot;))```    User: {'name': 'John', 'age': 32}``` pythonname = derived(user, lambda x: x[&quot;name&quot;])stopName = name.subscribe(lambda x: print(f&quot;Name: {x}&quot;))```    Name: John``` pythonuser.update(lambda x: x | {&quot;age&quot;: 45})```    User: {'name': 'John', 'age': 45}Updating the age does not trigger the `name subscriber`. Let’s see whathappens when we update the name.``` pythonuser.update(lambda x: x | {&quot;name&quot;: &quot;Fred&quot;})```    Name: Fred    User: {'name': 'Fred', 'age': 45}Only changes to the name of the user triggers the `name` subscriber.``` pythonstopName(), stopLog()```    (None, None)Another cool thing about Derived Stores is that you can derive from alist of stores. Let’s build a `zip` operator.``` pythona = writable([1,2,3,4])b = writable([5,6,7,8])a,b```    (w&lt;0&gt; $list: [1, 2, 3, 4], w&lt;0&gt; $list: [5, 6, 7, 8])``` pythonzipper = derived([a,b], lambda a,b: list(zip(a,b)))`````` pythontest_eq(zipper.get(), [(1, 5), (2, 6), (3, 7), (4, 8)])```While `zipper` has no subscribers, it keeps the initial value, it is`stopped`.``` pythona.set([4,3,2,1])test_eq(zipper.get(), [(1, 5), (2, 6), (3, 7), (4, 8)])```A subscription `starts` zipper and it will start to react to the changesof the stores.``` pythonu = zipper.subscribe(lambda x: None)test_eq(zipper.get(), [(4, 5), (3, 6), (2, 7), (1, 8)])`````` pythonb.set([8,7,6,5])test_eq(zipper.get(), [(4, 8), (3, 7), (2, 6), (1, 5)])`````` pythonu()```#### Store composition with pipes``` pythonwritable(1).pipe(lambda x: x + 1).pipe(lambda x: x * 2)```    r&lt;0&gt; $int: 4``` pythonwritable(1).pipe(lambda x: x+1, lambda x: x*2)```    r&lt;0&gt; $int: 4``` pythonwritable(1) | (lambda x: x+1) | (lambda x: x*2)```    r&lt;0&gt; $int: 4``` pythona = writable(1)u5 = (a       | (lambda x: x*2)       | (lambda x: x*2)       | (lambda x: x*2)).subscribe(lambda x: print(f&quot;u5: {x}&quot;))```    u5: 8``` pythona.set(2)```    u5: 16``` pythonu5()```## Missing featuresYou may have noticed that along the way we had always to subscribe andthen had to remember to unsubscribe when we were done. This is a bit ofa nuisance. Svelte has a compiler that provide some [syntaticsugar](https://svelte.dev/tutorial/auto-subscriptions) to make thiseasier. They call it `auto-subscriptions`.`Sveltish` does not have `auto-subscriptions` yet. But if you have anice idea how to implement it, please let me know.</longdescription>
</pkgmetadata>