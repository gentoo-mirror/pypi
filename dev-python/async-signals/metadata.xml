<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># async-signalsEasy library to implement the observer pattern in async code.**Note:** This library is a copy of the signals library from [Django](https://docs.djangoproject.com/en/4.1/topics/signals/). I always feltlike using the observer pattern in Django is pretty well crafted and likedthe way Django did implement this. But when switching to[FastAPI](https://fastapi.tiangolo.com/) I missed this feature. So I decidedto copy the signals library from Django and implement it for FastAPI and otherasync frameworks.  A big thanks to the nice people why built Django! And for using a BSD licenseto make this possible.## Changes from the original Django signals library* `Signal.send(...)` and `Signal.send_robust(...)` are now async functions üöÄ* I added type annotations to all functions and classes, mypy is happy now üßê* I created tests for the signals library - without using any Django models üòé## InstallationJust use `pip install async-signals` to install the library.## Usage```pythonfrom async_signals import Signal# Create a signalmy_signal = Signal()# Connect a function to the signal (can be async or sync, needs to receive **kwargs)async def my_handler(sender, **kwargs):    print(&quot;Signal received!&quot;)my_signal.connect(my_handler)# Send the signalawait my_signal.send(&quot;sender&quot;)````signal.send(...)` will return a list of all called receivers and their returnvalues.## About **kwargsThe `**kwargs` are mandatory for your receivers. This is because the signalwill pass any arguments it receives to the receivers. This is useful if youwant to pass additional information to the receivers. To allow addingadditional arguments to the signal in the future, the receivers should isrequired to accept `**kwargs`.## About weak signalsThe signal class will automatically remove signals when the receiver isgarbage collected. This is done by using weak references. This means thatyou can use signals in long running applications without having to worryabout memory leaks.If you want to disable this behaviour you can set the `weak` parameter to`False` when connecting the receiver.```pythonmy_signal.connect(my_handler, weak=False)# ormy_signal.connect(my_handler, weak=True)  # the default```## About async signalsThe signal class will automatically await async receivers. If your receiveris sync it will be executed normally.## About the senderThe sender is the object that sends the signal. It can be anything. It ispassed to the receiver as the first argument. This is useful if you want tohave multiple signals in your application and you want to know which signalwas sent. Normally the sender is the object that triggers the signal.You may also pass the sender when connecting a receiver. This is useful ifyou want to connect a receiver to a specific sender. If you do this thereceiver will only be called when the sender is the same as the one youpassed when connecting the receiver.**Note:** I normally tend to use Pydantic models as the sender in FastAPI. Butfeel free to use whatever you want.```pythonmy_signal.connect(my_handler, sender=&quot;sender&quot;)# This will not call the receiverawait my_signal.send(&quot;other_sender&quot;)```## Using the receiver decoratorYou can also use the `receiver` decorator to connect a receiver to a signal.```python@receiver(my_signal)async def my_handler(sender, **kwargs):    print(&quot;Signal received!&quot;)```Or if you want to limit the receiver to a specific sender.```python@receiver(my_signal, sender=&quot;sender&quot;)async def my_handler(sender, **kwargs):    print(&quot;Signal received!&quot;)```## Handle exceptionsBy default the signal class will raise exceptions raised by receivers. Ifyou want the signal to catch the exceptions and continue to call the otherreceivers you can use `send_robust(..)` instead of `send()`. The return valuewill be a list of tuples containing the receiver and the return or theexception raised by the receiver. You will need to check the type of thereturn value to see if it is an exception or not.```pythonawait my_signal.send_robust(&quot;sender&quot;)```# ContributingIf you want to contribute to this project, feel free to just fork the project,create a dev branch in your fork and then create a pull request (PR). If youare unsure about whether your changes really suit the project please create anissue first, to talk about this.</longdescription>
</pkgmetadata>