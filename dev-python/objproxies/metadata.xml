<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Simple Proxy Types==================The ``objproxies`` module provides some useful base classes for creatingproxies and wrappers for ordinary Python objects. Proxy objects automaticallydelegate all attribute access and operations to the proxied object. Wrappersare similar, but can be subclassed to allow additional attributes andoperations to be added to the wrapped object.Note that these proxy types are not intended to be tamper-proof; the unproxiedform of an object can be readily accessed using a proxy's ``__subject__``attribute, and some proxy types even allow this attribute to be set (This canbe handy for algorithms that lazily create circular structures and thus need tobe able to hand out &quot;forward reference&quot; proxies.).. contents:: **Table of Contents**Development status******************This is Python 3 port of `ProxyTypes&lt;http://cheeseshop.python.org/pypi/ProxyTypes&gt;`_ wrote by Phillip J. Eby aspart of `PEAK &lt;http://www.eby-sarna.com/mailman/listinfo/peak&gt;`_ for Python 2.The namespace was changed from ``peak.util.proxies`` to ``objproxies``. Otherthan that it should be a compatible replacement.So far the following was accomplished:* Streamlined files and setup* Ported unittests and doctests* Cleaned up syntaxv1.0 TODO+++++++++* Turn the module in a package, separate functionalities in different modules* Simplify code wherever possible* Get positive feedback from a couple of usersContributions and bug reports are welcome.Testing+++++++When nose is available all tests can be run using:.. code:: bash    nosetests3 --with-doctest  --doctest-extension=rst .Otherwise standard python will suffice:.. code:: bash    python -m unittest objproxies_tests.py    python -m doctest README.rstProxy Basics************Here's a quick demo of the ``ObjectProxy`` type::    &gt;&gt;&gt; from objproxies import ObjectProxy    &gt;&gt;&gt; p = ObjectProxy(42)    &gt;&gt;&gt; p    42    &gt;&gt;&gt; isinstance(p, int)    True    &gt;&gt;&gt; p.__class__    &lt;class 'int'&gt;    &gt;&gt;&gt; p*2    84    &gt;&gt;&gt; 'X' * p    'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'    &gt;&gt;&gt; hex(p)    '0x2a'    &gt;&gt;&gt; chr(p)    '*'    &gt;&gt;&gt; p ^ 1    43    &gt;&gt;&gt; p ** 2    1764As you can see, a proxy is virtually indistinguishable from the object itproxies, except via its ``__subject__`` attribute, and its ``type()``::    &gt;&gt;&gt; p.__subject__    42    &gt;&gt;&gt; type(p)    &lt;class 'objproxies.ObjectProxy'&gt;You can change the ``__subject__`` of an ``ObjectProxy``, and it will thenrefer to something else::    &gt;&gt;&gt; p.__subject__ = 99    &gt;&gt;&gt; p    99    &gt;&gt;&gt; p-33    66    &gt;&gt;&gt; p.__subject__ = &quot;foo&quot;    &gt;&gt;&gt; p    'foo'All operations are delegated to the subject, including ``setattr`` and``delattr``::    &gt;&gt;&gt; class Dummy: pass    &gt;&gt;&gt; d = Dummy()    &gt;&gt;&gt; p = ObjectProxy(d)    &gt;&gt;&gt; p.foo = &quot;bar&quot;    &gt;&gt;&gt; d.foo    'bar'    &gt;&gt;&gt; del p.foo    &gt;&gt;&gt; hasattr(d,'foo')    FalseCallback Proxies****************Sometimes, you may want a proxy's subject to be determined dynamically wheneverthe proxy is used.  For this purpose, you can use the ``CallbackProxy`` type,which accepts a callback function and creates a proxy that will invoke thecallback in order to get the target.  Here's a quick example of a counter thatgets incremented each time it's used, from zero to three::    &gt;&gt;&gt; from objproxies import CallbackProxy    &gt;&gt;&gt; callback = iter(range(4)).__next__    &gt;&gt;&gt; counter = CallbackProxy(callback)    &gt;&gt;&gt; counter    0    &gt;&gt;&gt; counter    1    &gt;&gt;&gt; str(counter)    '2'    &gt;&gt;&gt; hex(counter)    '0x3'    &gt;&gt;&gt; counter    Traceback (most recent call last):      ...    StopIterationAs you can see, the callback is automatically invoked on any attempt to use theproxy.  This is a somewhat silly example; a better one would be something likea ``thread_id`` proxy that is always equal to the ID # of the thread it'srunning in.A callback proxy's callback can be obtained or changed via the ``get_callback``and ``set_callback`` functions::    &gt;&gt;&gt; from objproxies import get_callback, set_callback    &gt;&gt;&gt; set_callback(counter, lambda: 42)    &gt;&gt;&gt; counter    42    &gt;&gt;&gt; type(get_callback(counter))    &lt;class 'function'&gt;Lazy Proxies************A ``LazyProxy`` is similar to a ``CallbackProxy``, but its callback is calledat most once, and then cached::    &gt;&gt;&gt; from objproxies import LazyProxy    &gt;&gt;&gt; def callback():    ...     print(&quot;called&quot;)    ...     return 42    &gt;&gt;&gt; lazy = LazyProxy(callback)    &gt;&gt;&gt; lazy    called    42    &gt;&gt;&gt; lazy    42You can use the ``get_callback`` and ``set_callback`` functions on lazyproxies, but it has no effect if the callback was already called::    &gt;&gt;&gt; set_callback(lazy, lambda: 99)    &gt;&gt;&gt; lazy    42But you can use the ``get_cache`` and ``set_cache`` functions to tamper withthe cached value::    &gt;&gt;&gt; from objproxies import get_cache, set_cache    &gt;&gt;&gt; get_cache(lazy)    42    &gt;&gt;&gt; set_cache(lazy, 99)    &gt;&gt;&gt; lazy    99Wrappers********The ``ObjectWrapper``, ``CallbackWrapper`` and ``LazyWrapper`` classes aresimilar to their proxy counterparts, except that they are intended to besubclassed in order to add custom extra attributes or methods.  Any attributethat exists in a subclass of these classes will be read or written from thewrapper instance, instead of the wrapped object.  For example::    &gt;&gt;&gt; from objproxies import ObjectWrapper    &gt;&gt;&gt; class NameWrapper(ObjectWrapper):    ...     name = None    ...     def __init__(self, ob, name):    ...         ObjectWrapper.__init__(self, ob)    ...         self.name = name    ...     def __str__(self):    ...         return self.name    &gt;&gt;&gt; w = NameWrapper(42, &quot;The Ultimate Answer&quot;)    &gt;&gt;&gt; w    42    &gt;&gt;&gt; print(w)    The Ultimate Answer    &gt;&gt;&gt; w * 2    84    &gt;&gt;&gt; w.name    'The Ultimate Answer'Notice that any attributes you add must be defined *in the class*.  You can'tadd arbitrary attributes at runtime, because they'll be set on the wrappedobject instead of the wrapper::    &gt;&gt;&gt; w.foo = 'bar'    Traceback (most recent call last):      ...    AttributeError: 'int' object has no attribute 'foo'Note that this means that all instance attributes must be implemented as eitherslots, properties, or have a default value defined in the class body (like the``name = None`` shown in the example above.The ``CallbackWrapper`` and ``LazyWrapper`` base classes are basically the sameas ``ObjectWrapper``, except that they use a callback or cached lazy callbackinstead of expecting an object as their subject.``LazyWrapper`` objects are particularly useful when working with expensiveresources, like connections or web browsers, to avoid their creation unlessabsolutely needed. However resources usually must be released after use by calling a &quot;``close``&quot;method of some sort. In this case the lazy creation could be triggered justwhen the object is not needed anymore, by the call to ``close`` itself. Forthis reason when extending ``LazyWrapper`` these methods can be overridden witha ``@lazymethod`` replacement::    &gt;&gt;&gt; from objproxies import LazyWrapper, lazymethod    &gt;&gt;&gt; class LazyCloseable(LazyWrapper):    ...     @lazymethod    ...     def tell(self):    ...         return 0    ...     @lazymethod    ...     def close(self):    ...         print(&quot;bye&quot;)    ...     @lazymethod    ...     def __bool__(self):    ...         return False    &gt;&gt;&gt; import tempfile    &gt;&gt;&gt; def openf():    ...     print(&quot;called&quot;)    ...     return tempfile.TemporaryFile('w')    &gt;&gt;&gt; lazyfile = LazyCloseable(openf)    &gt;&gt;&gt; lazyfile.tell()    0    &gt;&gt;&gt; lazyfile.close()    bye    &gt;&gt;&gt; bool(lazyfile)    False    &gt;&gt;&gt; lazyfile = LazyCloseable(openf)    &gt;&gt;&gt; lazyfile.write('wake up')    called    7    &gt;&gt;&gt; lazyfile.tell()    7    &gt;&gt;&gt; lazyfile.close()  # close for real    &gt;&gt;&gt; bool(lazyfile)    TrueAdvanced: custom subclasses and mixins**************************************In addition to all the concrete classes described above, there are also twoabstract base classes: ``AbstractProxy`` and ``AbstractWrapper``.  If you wantto create a mixin type that can be used with any of the concrete types, youshould subclass the abstract version and set ``__slots__`` to an empty list::    &gt;&gt;&gt; from objproxies import AbstractWrapper    &gt;&gt;&gt; class NamedMixin(AbstractWrapper):    ...     __slots__ = []    ...     name = None    ...     def __init__(self, ob, name):    ...         super(NamedMixin, self).__init__(ob)    ...         self.name = name    ...     def __str__(self):    ...         return self.nameThen, when you mix it in with the respective base class, you can add back inany necessary slots, or leave off ``__slots__`` to give the subclass instancesa dictionary of their own::    &gt;&gt;&gt; from objproxies import CallbackWrapper, LazyWrapper    &gt;&gt;&gt; class NamedObject(NamedMixin, ObjectWrapper): pass    &gt;&gt;&gt; class NamedCallback(NamedMixin, CallbackWrapper): pass    &gt;&gt;&gt; class NamedLazy(NamedMixin, LazyWrapper): pass    &gt;&gt;&gt; print(NamedObject(42, &quot;The Answer&quot;))    The Answer    &gt;&gt;&gt; n = NamedCallback(callback, &quot;Test&quot;)    &gt;&gt;&gt; n    called    42    &gt;&gt;&gt; n    called    42    &gt;&gt;&gt; n = NamedLazy(callback, &quot;Once&quot;)    &gt;&gt;&gt; n    called    42    &gt;&gt;&gt; n    42Both the ``AbstractProxy`` and ``AbstractWrapper`` base classes work byassuming that ``self.__subject__`` will be the wrapped or proxed object.  Ifyou don't want to use any of the standard three ways of defining``__subject__`` (i.e., as an object, callback, or lazy callback), you will needto subclass ``AbstractProxy`` or ``AbstractWrapper`` and provide your own wayof defining ``__subject__``.</longdescription>
</pkgmetadata>