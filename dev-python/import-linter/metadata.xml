<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=============Import Linter=============.. image:: https://img.shields.io/pypi/v/import-linter.svg    :target: https://pypi.org/project/import-linter.. image:: https://img.shields.io/pypi/pyversions/import-linter.svg    :alt: Python versions    :target: https://pypi.org/project/import-linter/.. image:: https://github.com/seddonym/import-linter/workflows/CI/badge.svg?branch=master     :target: https://github.com/seddonym/import-linter/actions?workflow=CI     :alt: CI StatusImport Linter allows you to define and enforce rules for the imports within and between Python packages.* Free software: BSD license* Documentation: https://import-linter.readthedocs.io.Overview--------Import Linter is a command line tool to check that you are following a self-imposedarchitecture within your Python project. It does this by analysing the imports between all the modules in oneor more Python packages, and compares this against a set of rules that you provide in a configuration file.The configuration file contains one or more 'contracts'. Each contract has a specifictype, which determines the sort of rules it will apply. For example, the ``forbidden``contract type allows you to check that certain modules or packages are not imported byparts of your project.Import Linter is particularly useful if you are working on a complex codebase within a team,when you want to enforce a particular architectural style. In this case you can addImport Linter to your deployment pipeline, so that any code that does not followthe architecture will fail tests.If there isn't a built in contract type that fits your desired architecture, you can definea custom one.Quick start-----------Install Import Linter::    pip install import-linterDecide on the dependency flows you wish to check. In this example, we havedecided to make sure that ``myproject.foo`` has dependencies on neither``myproject.bar`` nor ``myproject.baz``, so we will use the ``forbidden`` contract type.Create an ``.importlinter`` file in the root of your project to define your contract(s). In this case:.. code-block:: ini    [importlinter]    root_package = myproject    [importlinter:contract:1]    name=Foo doesn't import bar or baz    type=forbidden    source_modules=        myproject.foo    forbidden_modules=        myproject.bar        myproject.bazNow, from your project root, run::    lint-importsIf your code violates the contract, you will see an error message something like this:.. code-block:: text    =============    Import Linter    =============    ---------    Contracts    ---------    Analyzed 23 files, 44 dependencies.    -----------------------------------    Foo doesn't import bar or baz BROKEN    Contracts: 1 broken.    ----------------    Broken contracts    ----------------    Foo doesn't import bar or baz    -----------------------------    myproject.foo is not allowed to import myproject.bar:    -   myproject.foo.blue -&gt; myproject.utils.red (l.16)        myproject.utils.red -&gt; myproject.utils.green (l.1)        myproject.utils.green -&gt; myproject.bar.yellow (l.3)</longdescription>
</pkgmetadata>