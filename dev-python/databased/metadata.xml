<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># DatabasedDatabased is a package that wraps the standard library Sqlite3 module to make setting up and using a database quicker and easier.&lt;br&gt;Install with:&lt;pre&gt;pip install databased&lt;/pre&gt;`databased` is a package that wraps the standard library Sqlite3 module to largely avoid writing queries except for table definitions (there is a `query` function that can be used to directly excute queries).&lt;br&gt;It primarily consists of the class `DataBased`.&lt;br&gt;The DataBased class contains functions for creating databases and tables; inserting, updating, and deleting rows; as well as retrieving data and schema information.&lt;br&gt;There is also a static method called `data_to_string` which uses [tabulate](https://pypi.org/project/tabulate/) to generate a printable grid from a list of dictionaries.&lt;br&gt;By default, data_to_string will automatically wrap the width of columns to fit within the current terminal window.&lt;br&gt;&lt;br&gt;Member functions that require a database connection will automatically create one when called if one isn't already open.&lt;br&gt;If you create a class that inherits from `DataBased`, you will need to decorate member functions that access the database with `@_connect`.&lt;br&gt;Unless `DataBased` is used with a context manager, you will need to manually call the `close()` function to close the connection and save the database.&lt;br&gt;Usage:&lt;pre&gt;from databased import DataBasedfrom datetime import datetime# if the .db file specified doesn't exist, it will be created# a log file with the same name will be generated and stored in the same directorywith DataBased(dbpath=&quot;records.db&quot;) as db:    # A table will only be created if it doesn't exist. create_tables() will not overwrite an existing table.    db.create_table(&quot;kitchen_tables&quot;, [&quot;num_legs int&quot;, &quot;top_material text&quot;, &quot;shape text&quot;, &quot;date_added timestamp&quot;])    kitchen_tables = [        (4, &quot;birch&quot;, &quot;round&quot;, datetime.now()),        (3, &quot;oak&quot;, &quot;round&quot;, datetime.now()),        (6, &quot;granite&quot;, &quot;rectangle&quot;, datetime.now()),    ]    for kitchen_table in kitchen_tables:        db.add_row(&quot;kitchen_tables&quot;, kitchen_table)    print(f'number of rows: {db.count(&quot;kitchen_tables&quot;)}')    print(f'table names: {db.get_table_names()}')    print(f'column names: {db.get_column_names(&quot;kitchen_tables&quot;)}')    print(db.get_rows(&quot;kitchen_tables&quot;, [(&quot;num_legs&quot;, 6)]))    print(db.get_rows(&quot;kitchen_tables&quot;, [(&quot;shape&quot;, &quot;round&quot;)], sort_by_column=&quot;num_legs&quot;))    print(db.get_rows(&quot;kitchen_tables&quot;, [(&quot;shape&quot;, &quot;round&quot;), (&quot;num_legs&quot;, 4)]))    db.update(        &quot;kitchen_tables&quot;,        column_to_update=&quot;top_material&quot;,        new_value=&quot;glass&quot;,        match_criteria=[(&quot;num_legs&quot;, 3)],    )    print(db.get_rows(&quot;kitchen_tables&quot;, sort_by_column=&quot;num_legs&quot;))    print(db.data_to_string(db.get_rows(&quot;kitchen_tables&quot;), sort_key=&quot;top_material&quot;))&lt;/pre&gt;produces:&lt;pre&gt;number of rows: 3table names: ['kitchen_tables']column names: ['num_legs', 'top_material', 'shape', 'date_added'][{'num_legs': 6, 'top_material': 'granite', 'shape': 'rectangle', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}][{'num_legs': 3, 'top_material': 'oak', 'shape': 'round', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}, {'num_legs': 4, 'top_material': 'birch', 'shape': 'round', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}][{'num_legs': 4, 'top_material': 'birch', 'shape': 'round', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}][{'num_legs': 3, 'top_material': 'glass', 'shape': 'round', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}, {'num_legs': 4, 'top_material': 'birch', 'shape': 'round', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}, {'num_legs': 6, 'top_material': 'granite', 'shape': 'rectangle', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}]&lt;/pre&gt;and the final `print()` call on `data_to_string()` produces:&lt;pre&gt;+------------+----------------+-----------+-----------------------------+| num_legs   | top_material   | shape     | date_added                  |+============+================+===========+=============================+| 4          | birch          | round     | 2022-12-14 18:19:31.501745  |+------------+----------------+-----------+-----------------------------+| 3          | glass          | round     | 2022-12-14 18:19:31.501745  |+------------+----------------+-----------+-----------------------------+| 6          | granite        | rectangle | 2022-12-14 18:19:31.501745  |+------------+----------------+-----------+-----------------------------+&lt;/pre&gt;`databased` also comes with an interactive shell called `dbmanager`, which is built from the [argshell](https://github.com/matt-manes/argshell) package.&lt;br&gt;It can be launched from the terminal by entering `dbmanager`&lt;pre&gt;databased\tests&gt;dbmanagerSearching for database...DB options:(1) test.db (2) test_bckup.dbEnter the number of the option to use: 1Starting dbmanager (enter help or ? for arg info)...based&gt;helpDocumented commands (type help {topic}):========================================add_column  backup     dbpath      flush_log  query     search  sysadd_row     count      delete      help       quit      show    updateadd_table   customize  drop_table  info       scan_dbs  size    use_db&gt;based help updateUpdate a column to a new value.        Two required positional args: the column to update and the value to update to.        Use the -t/--tables flag to limit what tables are updated.        Use the -m/--match_pairs flag to specify which rows are updated.        &gt;&gt;&gt; based&gt;update username big_chungus -t users -m username lil_chungus        ^will update the username in the users 'table' to 'big_chungus' where the username is currently 'lil_chungus'^Parser help for update:usage: dbmanager [-h] [-t [TABLES ...]] [-m [MATCH_PAIRS ...]] [-p] -c COLUMN -v NEW_VALUEoptions:  -h, --help            show this help message and exit  -t [TABLES ...], --tables [TABLES ...]                        Limits command to a specific list of tables  -m [MATCH_PAIRS ...], --match_pairs [MATCH_PAIRS ...]                        Pairs of columns and values to use for narrowing the scope of row operations. i.e. 'find -t users -m name Bob state Alaska last_login *' will print all rows from the users table that have the name Bob, are from the state Alaska, and last logged in at any                        date.  -p, --partial_matching                        When selecting rows using a string, the string can be a substring instead of an exact match. i.e. &quot;-t names -m first theo&quot; only returns rows from names where the first name is exactly 'theo'. &quot;-t names -m first theo -p&quot; would return rows with first names                        of 'theo', but also rows with names like 'theodore'.  -c COLUMN, --column COLUMN                        The column to update.  -v NEW_VALUE, --new_value NEW_VALUE                        The new value to update with.based&gt;&lt;/pre&gt;The `customize` command can be used to generate a template file in the current directory that subclasses `DBManager`.&lt;br&gt;This allows for project specific additional commands as well as modifications of available commands.</longdescription>
</pkgmetadata>