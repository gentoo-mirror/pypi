<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>django-pytest=============This project allows you to use py.test as a django test runner, instead of thedefault test runner.To use it, add it to your python path and add `django_pytest` to your installedapps. Also set the `TEST_RUNNER = 'django_pytest.test_runner.run_tests'` setting.If you're using Django 1.3 or newer set`TEST_RUNNER = 'django_pytest.test_runner.TestRunner'` or Django will printdeprecation warnings each time you run your tests.Also create a `conftest.py` in your project directory and include:from django_pytest.conftest import pytest_funcarg__client, pytest_funcarg__django_clientYou can also use:from django_pytest.auth_funcargs import pytest_funcarg__user, pytest_funcarg__groupsto import a user or some groups with users in themNow anywhere in your project, you can create files called`test_&lt;something&gt;.py`.  These are standard py.test test files. Use the funcarg`client` in every test to both instantiate a test database that is clearedafter each test and to provide you with a django test client object identicalto the one used in django's test system. For example:def test_filter(client):    response = client.get('/browse/', {'filter': '1'})    assert response.status_code == 200Use `./manage.py test` to run the py.test test runs (ie: it replaces thestandard django test runner). You can pass py.test options to the commandand they will be forwarded to py.test. (Technically, I haven't got it passingall options, just the most common ones I use)The management command has been set up so that syncdb will use the django coresyncdb if `SOUTH_TESTS_MIGRATE` is set to False, if south is installed. Thisprevents migrations from running when running unit tests. This speeds up testsetup significantly, but it means your test db may not be identical toproduction, if you have faulty migrations.py.test automatically picks up any subclasses of `unittest.TestCase`, providedthey are in a module named `test_&lt;something&gt;.py`. Thus, all your existing djangounittests should work seemlessly with py.test, although you may have to renameyour test files if they do not conform to this convention. You can also writecustom py.test test collection hooks to pick up test modules that are named ina different directory structure.This project differs from &lt;http://github.com/bfirsh/pytest_django&gt; in that itprovides a django test runner that calls py.test, rather than creating apy.test plugin to test django projects. I believe there is overlappingfunctionality from the two projects, and also that they can be integrated intoa single project, but I have not looked at the feasibility of this yet.</longdescription>
</pkgmetadata>