<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Injector - Python dependency injection framework, inspired by Guice===================================================================|image| |Coverage Status|Introduction------------While dependency injection is easy to do in Python due to its supportfor keyword arguments, the ease with which objects can be mocked and itsdynamic nature, a framework for assisting in this process can remove alot of boiler-plate from larger applications. That’s where Injector canhelp. It automatically and transitively provides dependencies for you.As an added benefit, Injector encourages nicely compartmentalised codethrough the use of :ref:``modules &lt;module&gt;``.If you’re not sure what dependency injection is or you’d like to learnmore about it see:-  `The Clean Code Talks - Don’t Look For Things! (a talk by Miško   Hevery) &lt;https://www.youtube.com/watch?v=RlfLCWKxHJ0&gt;`__-  `Inversion of Control Containers and the Dependency Injection pattern   (an article by Martin   Fowler) &lt;https://martinfowler.com/articles/injection.html&gt;`__The core values of Injector are:-  Simplicity - while being inspired by Guice, Injector does not   slavishly replicate its API. Providing a Pythonic API trumps   faithfulness. Additionally some features are omitted because   supporting them would be cumbersome and introduce a little bit too   much “magic” (member injection, method injection).   Connected to this, Injector tries to be as nonintrusive as possible.   For example while you may declare a class’ constructor to expect some   injectable parameters, the class’ constructor remains a standard   constructor – you may instantiate the class just the same manually,   if you want.-  No global state – you can have as many   `Injector &lt;https://injector.readthedocs.io/en/latest/api.html#injector.Injector&gt;`__   instances as you like, each with a different configuration and each   with different objects in different scopes. Code like this won’t work   for this very reason:   .. code:: python        class MyClass:            @inject            def __init__(t: SomeType):                # ...        MyClass()   This is simply because there’s no global ``Injector`` to use. You   need to be explicit and use   `Injector.get &lt;https://injector.readthedocs.io/en/latest/api.html#injector.Injector.get&gt;`__,   `Injector.create_object &lt;https://injector.readthedocs.io/en/latest/api.html#injector.Injector.create_object&gt;`__   or inject ``MyClass`` into the place that needs it.-  Cooperation with static type checking infrastructure – the API   provides as much static type safety as possible and only breaks it   where there’s no other option. For example the   `Injector.get &lt;https://injector.readthedocs.io/en/latest/api.html#injector.Injector.get&gt;`__   method is typed such that ``injector.get(SomeType)`` is statically   declared to return an instance of ``SomeType``, therefore making it   possible for tools such as `mypy &lt;https://github.com/python/mypy&gt;`__   to type-check correctly the code using it.-  The client code only knows about dependency injection to the extent   it needs –    ```inject`` &lt;https://injector.readthedocs.io/en/latest/api.html#injector.inject&gt;`__,   ```Inject`` &lt;https://injector.readthedocs.io/en/latest/api.html#injector.Inject&gt;`__   and   ```NoInject`` &lt;https://injector.readthedocs.io/en/latest/api.html#injector.NoInject&gt;`__   are simple markers that don’t really do anything on their own and   your code can run just fine without Injector orchestrating things.How to get Injector?~~~~~~~~~~~~~~~~~~~~-  GitHub (code repository, issues):   https://github.com/alecthomas/injector-  PyPI (installable, stable distributions):   https://pypi.org/project/injector/. You can install it using pip:   .. code:: bash      pip install injector-  Documentation: https://injector.readthedocs.org-  Change log: https://injector.readthedocs.io/en/latest/changelog.htmlInjector works with CPython 3.7+ and PyPy 3 implementing Python 3.7+.A Quick Example---------------.. code:: python   &gt;&gt;&gt; from injector import Injector, inject   &gt;&gt;&gt; class Inner:   ...     def __init__(self):   ...         self.forty_two = 42   ...   &gt;&gt;&gt; class Outer:   ...     @inject   ...     def __init__(self, inner: Inner):   ...         self.inner = inner   ...   &gt;&gt;&gt; injector = Injector()   &gt;&gt;&gt; outer = injector.get(Outer)   &gt;&gt;&gt; outer.inner.forty_two   42Or with ``dataclasses`` if you like:.. code:: python   from dataclasses import dataclass   from injector import Injector, inject   class Inner:       def __init__(self):           self.forty_two = 42   @inject   @dataclass   class Outer:       inner: Inner   injector = Injector()   outer = injector.get(Outer)   print(outer.inner.forty_two)  # Prints 42A Full Example--------------Here’s a full example to give you a taste of how Injector works:.. code:: python   &gt;&gt;&gt; from injector import Module, provider, Injector, inject, singletonWe’ll use an in-memory SQLite database for our example:.. code:: python   &gt;&gt;&gt; import sqlite3And make up an imaginary ``RequestHandler`` class that uses the SQLiteconnection:.. code:: python   &gt;&gt;&gt; class RequestHandler:   ...   @inject   ...   def __init__(self, db: sqlite3.Connection):   ...     self._db = db   ...   ...   def get(self):   ...     cursor = self._db.cursor()   ...     cursor.execute('SELECT key, value FROM data ORDER by key')   ...     return cursor.fetchall()Next, for the sake of the example, we’ll create a configuration type:.. code:: python   &gt;&gt;&gt; class Configuration:   ...     def __init__(self, connection_string):   ...         self.connection_string = connection_stringNext, we bind the configuration to the injector, using a module:.. code:: python   &gt;&gt;&gt; def configure_for_testing(binder):   ...     configuration = Configuration(':memory:')   ...     binder.bind(Configuration, to=configuration, scope=singleton)Next we create a module that initialises the DB. It depends on theconfiguration provided by the above module to create a new DBconnection, then populates it with some dummy data, and provides a``Connection`` object:.. code:: python   &gt;&gt;&gt; class DatabaseModule(Module):   ...   @singleton   ...   @provider   ...   def provide_sqlite_connection(self, configuration: Configuration) -&gt; sqlite3.Connection:   ...     conn = sqlite3.connect(configuration.connection_string)   ...     cursor = conn.cursor()   ...     cursor.execute('CREATE TABLE IF NOT EXISTS data (key PRIMARY KEY, value)')   ...     cursor.execute('INSERT OR REPLACE INTO data VALUES (&quot;hello&quot;, &quot;world&quot;)')   ...     return conn(Note how we have decoupled configuration from our databaseinitialisation code.)Finally, we initialise an ``Injector`` and use it to instantiate a``RequestHandler`` instance. This first transitively constructs a``sqlite3.Connection`` object, and the Configuration dictionary that itin turn requires, then instantiates our ``RequestHandler``:.. code:: python   &gt;&gt;&gt; injector = Injector([configure_for_testing, DatabaseModule()])   &gt;&gt;&gt; handler = injector.get(RequestHandler)   &gt;&gt;&gt; tuple(map(str, handler.get()[0]))  # py3/py2 compatibility hack   ('hello', 'world')We can also verify that our ``Configuration`` and ``SQLite`` connectionsare indeed singletons within the Injector:.. code:: python   &gt;&gt;&gt; injector.get(Configuration) is injector.get(Configuration)   True   &gt;&gt;&gt; injector.get(sqlite3.Connection) is injector.get(sqlite3.Connection)   TrueYou’re probably thinking something like: “this is a large amount of workjust to give me a database connection”, and you are correct; dependencyinjection is typically not that useful for smaller projects. It comesinto its own on large projects where the up-front effort pays for itselfin two ways:1. Forces decoupling. In our example, this is illustrated by decoupling   our configuration and database configuration.2. After a type is configured, it can be injected anywhere with no   additional effort. Simply ``@inject`` and it appears. We don’t really   illustrate that here, but you can imagine adding an arbitrary number   of ``RequestHandler`` subclasses, all of which will automatically   have a DB connection provided.Footnote--------This framework is similar to snake-guice, but aims for simplification.© Copyright 2010-2013 to Alec Thomas, under the BSD license.. |image| image:: https://github.com/alecthomas/injector/workflows/CI/badge.svg   :target: https://github.com/alecthomas/injector/actions?query=workflow%3ACI+branch%3Amaster.. |Coverage Status| image:: https://codecov.io/gh/alecthomas/injector/branch/master/graph/badge.svg   :target: https://codecov.io/gh/alecthomas/injector</longdescription>
</pkgmetadata>