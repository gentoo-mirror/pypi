<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># About[![PyPI](https://img.shields.io/pypi/v/tcod-ecs)](https://pypi.org/project/tcod-ecs/)[![PyPI - License](https://img.shields.io/pypi/l/tcod-ecs)](https://github.com/HexDecimal/python-tcod-ecs/blob/main/LICENSE)[![Documentation Status](https://readthedocs.org/projects/python-tcod-ecs/badge/?version=latest)](https://python-tcod-ecs.readthedocs.io)[![codecov](https://codecov.io/gh/HexDecimal/python-tcod-ecs/branch/main/graph/badge.svg?token=4Ak5QpTLZB)](https://codecov.io/gh/HexDecimal/python-tcod-ecs)[![CommitsSinceLastRelease](https://img.shields.io/github/commits-since/HexDecimal/python-tcod-ecs/latest)](https://github.com/HexDecimal/python-tcod-ecs/blob/main/CHANGELOG.md)`tcod-ecs` is a [Sparse-set](https://skypjack.github.io/2020-08-02-ecs-baf-part-9/) [Entity-component-system](https://en.wikipedia.org/wiki/Entity_component_system) implemented using Python's `dict` and `set` types.See the [ECS FAQ](https://github.com/SanderMertens/ecs-faq) for more info.This implementation focuses on type-hinting, organization, and is designed to work well with Python.The following features are currently implemented:- Entities can store components which are instances of any Python object. Components are looked up by their type.- Entities can have one instance of a type, or multiple instances of a type using a hashable tag to differentiate them.- Entity relationships are supported, either as many-to-many or many-to-one relationships.- ECS Queries can be made to fetch entities having a combination of components/tags/relations or excluding such.- The ECS World object can be serialized with Python's pickle module for easy storage.A lightweight version which implements only the entity-component framework exists called [tcod-ec](https://pypi.org/project/tcod-ec/).`tcod-ec` was geared towards a dynamic-typed-dict style of syntax and is missing a lot of important features such as queries and named components.# InstallationUse pip to install this library:```pip install tcod-ecs```If `tcod` is installed and the version is less than `14.0.0` then `import tcod.ecs` will fail.Remove or update `tcod` to fix this issue.# Examples## World```py&gt;&gt;&gt; import tcod.ecs&gt;&gt;&gt; world = tcod.ecs.World()  # New empty world```## EntityEach Entity is identified by its unique id (`uid`) which can be any hashable object combined with the `world` it belongs.New unique entities can be created with `World.new_entity` which uses a new `object()` as the `uid`, this guarantees uniqueness which is not always desireable.An entity always knows about its assigned world, which can be access with the `Entity.world` property from any Entity instance.Worlds only know about their entities once the entity is assigned a name, component, tag, or relation.```py&gt;&gt;&gt; entity = world.new_entity()  # Creates a unique entity using `object()` as the uid&gt;&gt;&gt; entity&lt;Entity(uid=object at ...)&gt;&gt;&gt;&gt; entity.world is world  # Worlds can always be accessed from their entityTrue&gt;&gt;&gt; world[entity.uid] is entity  # Entities with the same world/uid are compared using `is`True# Reference an entity with the given uid, can be any hashable object:&gt;&gt;&gt; entity = world[&quot;MyEntity&quot;]&gt;&gt;&gt; entity&lt;Entity(uid='MyEntity')&gt;&gt;&gt;&gt; world[&quot;MyEntity&quot;] is entity  # Matching entities ALWAYS share a single identityTrue```Use `World.new_entity` to create unique entities and use `World[x]` to reference a global entity or relation with an id.`World[None]` is recommend for use as a global entity when you want to store components in the world itself.Do not save the `uid`'s of entities to be used later with `World[uid]`, this process is slower than holding onto the Entity instance.## SerializationWorlds are normal Python objects and can be pickled as long as all stored components are pickleable.```py&gt;&gt;&gt; import pickle&gt;&gt;&gt; pickled_data: bytes = pickle.dumps(world)&gt;&gt;&gt; world = pickle.loads(pickled_data)```Stability is a priority but changes may still break older saves.Backwards compatibility is not a priority, pickled worlds should not be unpickled with an older version of the library.This project follows [Semantic Versioning](https://semver.org/), major version increments will break the API, the save format or both, minor version increments may break backwards compatibility.Check the [changelog](https://github.com/HexDecimal/python-tcod-ecs/blob/main/CHANGELOG.md) to be aware of format changes and breaks.There should always be a transition period before a format break, so keeping up with the latest version is a good idea.## ComponentsComponents are instances of any Python type.These can be accessed, assigned, or removed from entities via the dict-like `Entity.components` attribute.The type is used as the key to access the component.The types used can be custom classes or standard Python types.```py&gt;&gt;&gt; import attrs&gt;&gt;&gt; entity = world.new_entity()&gt;&gt;&gt; entity.components[int] = 42&gt;&gt;&gt; entity.components[int]42&gt;&gt;&gt; int in entity.componentsTrue&gt;&gt;&gt; del entity.components[int]&gt;&gt;&gt; entity.components[int]  # Missing keys raise KeyErrorTraceback (most recent call last):  ...KeyError: &lt;class 'int'&gt;&gt;&gt;&gt; entity.components.get(int, &quot;default&quot;)  # Test keys with `.get()` like a dictionary'default'&gt;&gt;&gt; @attrs.define... class Vector2:...     x: int = 0...     y: int = 0&gt;&gt;&gt; entity.components[Vector2] = Vector2(1, 2)&gt;&gt;&gt; entity.components[Vector2]Vector2(x=1, y=2)&gt;&gt;&gt; entity.components |= {int: 11, Vector2: Vector2(0, 0)}  # Multiple values can be assigned like a dict&gt;&gt;&gt; entity.components[int]11&gt;&gt;&gt; entity.components[Vector2]Vector2(x=0, y=0)# Queries can be made on all entities of a world with matching components&gt;&gt;&gt; for e in world.Q.all_of(components=[Vector2]):...     e.components[Vector2].x += 10&gt;&gt;&gt; entity.components[Vector2]Vector2(x=10, y=0)# You can match components and iterate over them at the same time.  This can be combined with the above&gt;&gt;&gt; for pos, i in world.Q[Vector2, int]:...     print((pos, i))(Vector2(x=10, y=0), 11)# You can include `Entity` to iterate over entities with their components# This always iterates over the entity itself instead of an Entity component&gt;&gt;&gt; for e, pos, i in world.Q[tcod.ecs.Entity, Vector2, int]:...     print((e, pos, i))(&lt;Entity...&gt;, Vector2(x=10, y=0), 11)```## Named ComponentsOnly one component can be assigned unless that component is given a unique name.You can name components with the key syntax `(name, type)` when assigning components.Names are not limited to strings, they are a tag equivalent and can be any hashable or frozen object.The syntax `[type]` and `[(name, type)]` can be used interchangeably in all places accepting a component key.Queries on components access named components with the same syntax and must use names explicitly.```py&gt;&gt;&gt; entity = world.new_entity()&gt;&gt;&gt; entity.components[Vector2] = Vector2(0, 0)&gt;&gt;&gt; entity.components[(&quot;velocity&quot;, Vector2)] = Vector2(1, 1)&gt;&gt;&gt; entity.components[(&quot;velocity&quot;, Vector2)]Vector2(x=1, y=1)&gt;&gt;&gt; @attrs.define(frozen=True)... class Slot:...     index: int&gt;&gt;&gt; entity.components |= {  # Like a dict Entity.components can use |= to update items in-place...     (&quot;hp&quot;, int): 10,...     (&quot;max_hp&quot;, int): 12,...     (&quot;atk&quot;, int): 1,...     str: &quot;foo&quot;,...     (Slot(1), str): &quot;empty&quot;,... }&gt;&gt;&gt; entity.components[(&quot;hp&quot;, int)]10&gt;&gt;&gt; entity.components[str]'foo'&gt;&gt;&gt; entity.components[(Slot(1), str)]'empty'# Queries can be made on all named components with the same syntax as normal ones&gt;&gt;&gt; for e in world.Q.all_of(components=[(&quot;hp&quot;, int), (&quot;max_hp&quot;, int)]):...     e.components[(&quot;hp&quot;, int)] = e.components[(&quot;max_hp&quot;, int)]&gt;&gt;&gt; entity.components[(&quot;hp&quot;, int)]12&gt;&gt;&gt; for e, pos, delta in world.Q[tcod.ecs.Entity, Vector2, (&quot;velocity&quot;, Vector2)]:...     e.components[Vector2] = Vector2(pos.x + delta.x, pos.y + delta.y)&gt;&gt;&gt; entity.components[Vector2]Vector2(x=1, y=1)```## TagsTags are hashable objects stored in the set-like `Entity.tags`.These are useful as flags or to group entities together.```py&gt;&gt;&gt; entity = world.new_entity()&gt;&gt;&gt; entity.tags.add(&quot;player&quot;)  # Works well for groups&gt;&gt;&gt; &quot;player&quot; in entity.tagsTrue&gt;&gt;&gt; entity.tags.add((&quot;eats&quot;, &quot;fruit&quot;))&gt;&gt;&gt; entity.tags.add((&quot;eats&quot;, &quot;meat&quot;))&gt;&gt;&gt; set(world.Q.all_of(tags=[&quot;player&quot;])) == {entity}True```## RelationsUse `Entity.relation_components[component_key][target] = component` to associate a target entity with a component.Use `Entity.relation_tag[tag] = target` to associate a tag exclusively with a target entity.Use `Entity.relation_tags_many[tag].add(target)` to associate a tag with multiple targets.Relation queries are a little more complex than other queries.Relation tags and relation components share the same space then queried, so 'normal' tags should not be in the format of a component key.Relations are unidirectional, but you can query either end of a relation.```py&gt;&gt;&gt; @attrs.define... class OrbitOf:  # OrbitOf component...     dist: int&gt;&gt;&gt; LandedOn = &quot;LandedOn&quot;  # LandedOn tag&gt;&gt;&gt; star = world.new_entity()&gt;&gt;&gt; planet = world.new_entity()&gt;&gt;&gt; moon = world.new_entity()&gt;&gt;&gt; ship = world.new_entity()&gt;&gt;&gt; player = world.new_entity()&gt;&gt;&gt; moon_rock = world.new_entity()&gt;&gt;&gt; planet.relation_components[OrbitOf][star] = OrbitOf(dist=1000)&gt;&gt;&gt; moon.relation_components[OrbitOf][planet] = OrbitOf(dist=10)&gt;&gt;&gt; ship.relation_tag[LandedOn] = moon&gt;&gt;&gt; moon_rock.relation_tag[LandedOn] = moon&gt;&gt;&gt; player.relation_tag[LandedOn] = moon_rock&gt;&gt;&gt; set(world.Q.all_of(relations=[(OrbitOf, planet)])) == {moon}True&gt;&gt;&gt; set(world.Q.all_of(relations=[(OrbitOf, ...)])) == {planet, moon}  # Get objects in an orbitTrue&gt;&gt;&gt; set(world.Q.all_of(relations=[(..., OrbitOf, None)])) == {star, planet}  # Get objects being orbitedTrue&gt;&gt;&gt; set(world.Q.all_of(relations=[(LandedOn, ...)])) == {ship, moon_rock, player}True&gt;&gt;&gt; set(world.Q.all_of(relations=[(LandedOn, ...)]).none_of(relations=[(LandedOn, moon)])) == {player}True```You can use the following table to help with constructing relation queries.`tag` is a component key if you are querying for a component relation.| Includes                                                              | Syntax || --------------------------------------------------------------------- | :----: || Entities with a relation tag to the given target                      | `(tag, target_entity)` || Entities with a relation tag to any target                            | `(tag, ...)` (Literal dot-dot-dot) || Entities with a relation tag to the targets in the given query        | `(tag, world.Q.all_of(...))` || The target entities of a relation of a given entity                   | `(origin_entity, tag, None)` || The target entities of any entity with the given relation tag         | `(..., tag, None)` (Literal dot-dot-dot) || The target entities of the queried entities with the given relation   | `(tag, world.Q.all_of(...))` |</longdescription>
</pkgmetadata>