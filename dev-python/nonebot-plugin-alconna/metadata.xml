<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;  &lt;a href=&quot;https://v2.nonebot.dev/&quot;&gt;&lt;img src=&quot;https://v2.nonebot.dev/logo.png&quot; width=&quot;200&quot; height=&quot;200&quot; alt=&quot;nonebot&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;div align=&quot;center&quot;&gt;# NoneBot Plugin Alconna_✨ Alconna Usage For NoneBot2 ✨_&lt;/div&gt;&lt;p align=&quot;center&quot;&gt;  &lt;a href=&quot;https://raw.githubusercontent.com/nonebot/plugin-alconna/master/LICENSE&quot;&gt;    &lt;img src=&quot;https://img.shields.io/github/license/nonebot/plugin-alconna.svg&quot; alt=&quot;license&quot;&gt;  &lt;/a&gt;  &lt;a href=&quot;https://pypi.python.org/pypi/nonebot-plugin-alconna&quot;&gt;    &lt;img src=&quot;https://img.shields.io/pypi/v/nonebot-plugin-alconna.svg&quot; alt=&quot;pypi&quot;&gt;  &lt;/a&gt;  &lt;img src=&quot;https://img.shields.io/badge/python-3.8+-blue.svg&quot; alt=&quot;python&quot;&gt;&lt;/p&gt;该插件提供了 [Alconna](https://github.com/ArcletProject/Alconna) 的 [Nonebot2](https://github.com/nonebot/nonebot2) 适配版本与工具## 特性- 完整的 Alconna 特性支持- 基本的 rule, matcher 与 依赖注入- 自动回复命令帮助信息 (help, shortcut, completion) 选项- 现有全部协议的 Segment 标注- match_value, match_path 等检查函数- 补全会话支持## 讨论QQ 交流群: [链接](https://jq.qq.com/?_wv=1027&amp;k=PUPOnCSH)## 使用方法Nonebot文档: [📖这里](https://nonebot.dev/docs/advanced/matcher#alconna)详细介绍: [📦这里](/docs.md)### 消息解析```pythonfrom nonebot.adapters.onebot.v12 import Message, MessageSegmentfrom arclet.alconna import Alconna, Option, Argsmsg = Message(&quot;Hello! --foo 123&quot;)img = MessageSegment.image(&quot;1.png&quot;)print(msg)alc = Alconna(&quot;Hello!&quot;, Option(&quot;--foo&quot;, Args[&quot;foo&quot;, int]))res = alc.parse(msg)assert res.matchedassert res.query(&quot;foo.foo&quot;) == 123assert not alc.parse(Message([&quot;Hello!&quot;, img])).matched```### MessageSegment 标注特定适配器:```pythonfrom nonebot_plugin_alconna.adapters.onebot12 import Mentionfrom nonebot.adapters.onebot.v12 import Messagefrom arclet.alconna import Alconna, Argsmsg = Message([&quot;Hello!&quot;, Mention(&quot;123&quot;)])print(msg)  # Hello![mention:user_id=123]alc = Alconna(&quot;Hello!&quot;, Args[&quot;target&quot;, Mention])res = alc.parse(msg)assert res.matchedassert res.query(&quot;target&quot;).data['user_id'] == '123'```通用标注:```pythonfrom nonebot.adapters.onebot.v12 import Message as Ob12Msg, MessageSegment as Ob12MSfrom nonebot.adapters.onebot.v11 import Message as Ob11Msg, MessageSegment as Ob11MSfrom nonebot_plugin_alconna.adapters import Atfrom arclet.alconna import Alconna, Argsmsg1 = Ob12Msg([&quot;Hello!&quot;, Ob12MS.mention(&quot;123&quot;)]) # Hello![mention:user_id=123]msg2 = Ob11Msg([&quot;Hello!&quot;, Ob11MS.at(123)]) # Hello![CQ:at,qq=123]alc = Alconna(&quot;Hello!&quot;, Args[&quot;target&quot;, At])res1 = alc.parse(msg1)assert res1.matchedtarget = res1.query(&quot;target&quot;)assert isinstance(target, At)assert target.target == '123'res2 = alc.parse(msg2)assert res2.matchedtarget = res2.query(&quot;target&quot;)assert isinstance(target, At)assert target.target == '123'```### Matcher 与 依赖注入```python...from nonebot import requirerequire(&quot;nonebot_plugin_alconna&quot;)...from nonebot_plugin_alconna import (    on_alconna,     Match,    Query,    AlconnaMatch,     AlconnaQuery,    AlcMatches,    AlcResult)from arclet.alconna import Alconna, Args, Optiontest = on_alconna(    Alconna(        &quot;test&quot;,        Option(&quot;foo&quot;, Args[&quot;bar&quot;, int]),        Option(&quot;baz&quot;, Args[&quot;qux&quot;, bool, False])    ),    auto_send_output=True)@test.handle()async def handle_test1(result: AlcResult):    await test.send(f&quot;matched: {result.matched}&quot;)    await test.send(f&quot;maybe output: {result.output}&quot;)@test.handle()async def handle_test2(result: AlcMatches):    await test.send(f&quot;head result: {result.header_result}&quot;)    await test.send(f&quot;args: {result.all_matched_args}&quot;)@test.handle()async def handle_test3(bar: Match[int] = AlconnaMatch(&quot;bar&quot;)):    if bar.available:            await test.send(f&quot;foo={bar.result}&quot;)@test.handle()async def handle_test4(qux: Query[bool] = AlconnaQuery(&quot;baz.qux&quot;, False)):    if qux.available:        await test.send(f&quot;baz.qux={qux.result}&quot;)```### 条件控制```python...from nonebot import requirerequire(&quot;nonebot_plugin_alconna&quot;)...from arclet.alconna import Alconna, Subcommand, Option, Argsfrom nonebot_plugin_alconna import assign, on_alconna, AlconnaResult, CommandResult, Checkpip = Alconna(    &quot;pip&quot;,    Subcommand(        &quot;install&quot;,         Args[&quot;pak&quot;, str],        Option(&quot;--upgrade&quot;),        Option(&quot;--force-reinstall&quot;)    ),    Subcommand(        &quot;list&quot;,        Option(&quot;--out-dated&quot;)    ))pip_cmd = on_alconna(pip)@pip_cmd.handle([Check(assign(&quot;install.pak&quot;, &quot;pip&quot;))])async def update(arp: CommandResult = AlconnaResult()):    ...@pip_cmd.handle([Check(assign(&quot;list&quot;))])async def list_(arp: CommandResult = AlconnaResult()):    ...@pip_cmd.handle([Check(assign(&quot;install&quot;))])async def install(arp: CommandResult = AlconnaResult()):    ...@pip_cmd.assign(&quot;install&quot;, &quot;nonebot&quot;)async def nonebot(arp: CommandResult = AlconnaResult()):    ...```### Duplication```python...from nonebot import requirerequire(&quot;nonebot_plugin_alconna&quot;)...from nonebot_plugin_alconna import (    on_alconna,     AlconnaDuplication)from arclet.alconna import Alconna, Args, Duplication, Option, OptionStubtest = on_alconna(    Alconna(        &quot;test&quot;,        Option(&quot;foo&quot;, Args[&quot;bar&quot;, int]),        Option(&quot;baz&quot;, Args[&quot;qux&quot;, bool, False])    ),    auto_send_output=True)class MyResult(Duplication):    bar: int    qux: bool    foo: OptionStub@test.handle()async def handle_test1(result: MyResult = AlconnaDuplication(MyResult)):    await test.send(f&quot;matched: bar={result.bar}, qux={result.qux}&quot;)    await test.send(f&quot;options: foo={result.foo.origin}&quot;)```## 配置目前配置项有：- ALCONNA_AUTO_SEND_OUTPUT : 是否全局启用输出信息自动发送- ALCONNA_USE_COMMAND_START : 是否将 COMMAND_START 作为全局命令前缀- ALCONNA_AUTO_COMPLETION: 是否全局启用补全会话功能- ALCONNA_USE_ORIGIN: 是否全局使用原始消息 (即未经过 to_me 等处理的)## 参数解释```pythondef on_alconna(    command: Alconna | str,    skip_for_unmatch: bool = True,    auto_send_output: bool = False,    output_converter: Callable[[OutputType, str], Message | Awaitable[Message]] | None = None,    aliases: set[str | tuple[str, ...]] | None = None,    comp_config: CompConfig | None = None,    use_origin: bool = False,    **kwargs,) -&gt; type[Matcher]:```- `command`: Alconna 命令- `skip_for_unmatch`: 是否在命令不匹配时跳过该响应- `auto_send_output`: 是否自动发送输出信息并跳过响应- `output_converter`: 输出信息字符串转换为 Message 方法- `aliases`: 命令别名, 作用类似于 `on_command`- `comp_config`: 补全会话配置, 不传入则不启用补全会话- `use_origin`: 是否使用未经 to_me 等处理过的消息## 提供了 MessageSegment标注 的协议:| 协议名称                                                                | 路径                                   ||---------------------------------------------------------------------|--------------------------------------|| [OneBot 协议](https://onebot.dev/)                                    | adapters.onebot11, adapters.onebot12 || [Telegram](https://core.telegram.org/bots/api)                      | adapters.telegram                    || [飞书](https://open.feishu.cn/document/home/index)                    | adapters.feishu                      || [GitHub](https://docs.github.com/en/developers/apps)                | adapters.github                      || [QQ 频道](https://bot.q.qq.com/wiki/)                                 | adapters.qqguild                     || [钉钉](https://open.dingtalk.com/document/)                           | adapters.ding                        || [Console](https://github.com/nonebot/adapter-console)               | adapters.console                     || [开黑啦](https://developer.kookapp.cn/)                                | adapters.kook                        || [Mirai](https://docs.mirai.mamoe.net/mirai-api-http/)               | adapters.mirai                       || [Ntchat](https://github.com/JustUndertaker/adapter-ntchat)          | adapters.ntchat                      || [MineCraft](https://github.com/17TheWord/nonebot-adapter-minecraft) | adapters.minecraft                   || [BiliBili Live](https://github.com/wwweww/adapter-bilibili)         | adapters.bilibili                    || [Walle-Q](https://github.com/onebot-walle/nonebot_adapter_walleq)   | adapters.onebot12                    || [Villa](https://github.com/CMHopeSunshine/nonebot-adapter-villa)    | adapters.villa                       |### 便捷装饰器`funcommand` 装饰器用于将一个接受任意参数，返回 `str` 或 `Message` 或 `MessageSegment` 的函数转换为命令响应器。```pythonfrom nonebot_plugin_alconna import funcommand@funcommand()async def echo(msg: str):    return msg```## 体验[demo bot](./src/test/plugins/demo.py)</longdescription>
</pkgmetadata>