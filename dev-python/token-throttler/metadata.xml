<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Token throttler![Coverage](https://img.shields.io/gitlab/coverage/vojko.pribudic/token-throttler/main?job_name=tests)![Version](https://img.shields.io/pypi/pyversions/token-throttler)![Downloads](https://pepy.tech/badge/token-throttler)![Formatter](https://img.shields.io/badge/code%20style-black-black)![License](https://img.shields.io/pypi/l/token-throttler)**Token throttler** is an extendable rate-limiting library somewhat based on a [token bucket algorithm](https://en.wikipedia.org/wiki/Token_bucket).## Table of contents1. [ Installation ](#installation)2. [ Features ](#features)3. [ Usage ](#usage)    1. [ Manual usage example ](#usage-manual)    2. [ Decorator usage example ](#usage-decorator)    3. [ FastAPI usage example ](#usage-fastapi)4. [ Storage ](#storage)5. [ Configuration ](#configuration)   1. [ Configuration usage ](#configuration-usage)&lt;a name=&quot;installation&quot;&gt;&lt;/a&gt;## 1. InstallationToken throttler is available on PyPI:```console $ python -m pip install token-throttler```Token throttler officially supports Python &gt;= 3.7.*NOTE*: Depending on the storage engine you pick, you can install token throttler with extras:```console $ python -m pip install token-throttler[redis]```&lt;a name=&quot;features&quot;&gt;&lt;/a&gt;## 2. Features- Blocking (TokenThrottler) and non-blocking (TokenThrottlerAsync)- Global throttler(s) configuration- Configurable token throttler cost and identifier- Multiple buckets per throttler per identifier- Buckets can be added/removed manually or by a `dict` configuration- Manual usage or usage via decorator- Decorator usage supports async code too- Custom decorator can be written- Extendable storage engine (eg. Redis)&lt;a name=&quot;usage&quot;&gt;&lt;/a&gt;## 3. UsageToken throttler supports both manual usage and via decorator.Decorator usage supports both async and sync.&lt;a name=&quot;usage-manual&quot;&gt;&lt;/a&gt;### 1) Manual usage example:```pythonfrom token_throttler import TokenBucket, TokenThrottlerfrom token_throttler.storage import RuntimeStoragethrottler: TokenThrottler = TokenThrottler(cost=1, storage=RuntimeStorage())throttler.add_bucket(identifier=&quot;hello_world&quot;, bucket=TokenBucket(replenish_time=10, max_tokens=10))throttler.add_bucket(identifier=&quot;hello_world&quot;, bucket=TokenBucket(replenish_time=30, max_tokens=20))def hello_world() -&gt; None:    print(&quot;Hello World&quot;)for i in range(10):    throttler.consume(identifier=&quot;hello_world&quot;)    hello_world()if throttler.consume(identifier=&quot;hello_world&quot;):    hello_world()else:    print(&quot;bucket_one ran out of tokens&quot;)```&lt;a name=&quot;usage-decorator&quot;&gt;&lt;/a&gt;### 2) Decorator usage example:```pythonfrom token_throttler import TokenBucket, TokenThrottler, TokenThrottlerExceptionfrom token_throttler.storage import RuntimeStoragethrottler: TokenThrottler = TokenThrottler(1, RuntimeStorage())throttler.add_bucket(&quot;hello_world&quot;, TokenBucket(10, 10))throttler.add_bucket(&quot;hello_world&quot;, TokenBucket(30, 20))@throttler.enable(&quot;hello_world&quot;)def hello_world() -&gt; None:    print(&quot;Hello World&quot;)for i in range(10):    hello_world()try:    hello_world()except TokenThrottlerException:    print(&quot;bucket_one ran out of tokens&quot;)```&lt;a name=&quot;usage-fastapi&quot;&gt;&lt;/a&gt;### 3) FastAPI usage example:```pythonfrom fastapi import Depends, FastAPI, Requestfrom pydantic import BaseModelfrom token_throttler import TokenThrottler, TokenBucketfrom token_throttler.storage import RuntimeStoragefrom token_throttler.ext.fastapi import FastAPIThrottlerapp: FastAPI = FastAPI()ban_hammer: TokenThrottler = TokenThrottler(cost=1, storage=RuntimeStorage())class User(BaseModel):    id: int    name: stru1: User = User(id=1, name=&quot;Test&quot;)users: list[User] = [u1]def create_buckets() -&gt; None:    for user in users:        ban_hammer.add_bucket(            str(user.id), TokenBucket(replenish_time=10, max_tokens=10)        )# For example purposes only - feel free to load your users with the bucket(s) anywhere elseapp.add_event_handler(&quot;startup&quot;, create_buckets)# Add your auth logic heredef get_auth_user() -&gt; User:    return u1# Since this is a FastAPI dependency, you can have the `Request` object here too if needed (e.g. storing the JWT token in# a request lifecycle).# You can also use sub-dependencies like shown below - `auth_user`async def get_user_id(        request: Request, auth_user: User = Depends(get_auth_user)) -&gt; str:    return str(auth_user.id)# You can configure the dependency per route, on a router level or on global application level.# Pass your unique user identifier (e.g. JWT subject, apikey or user's ID) as a callback parameter # of the `enable` method.@app.get(    &quot;/throttle&quot;, dependencies=[Depends(FastAPIThrottler(ban_hammer).enable(get_user_id))])async def read_users():    return {&quot;detail&quot;: &quot;This is throttled URL&quot;}```For other examples see [**examples**](https://gitlab.com/vojko.pribudic/token-throttler/-/tree/main/examples) directory.&lt;a name=&quot;storage&quot;&gt;&lt;/a&gt;## 4. Storage`TokenThrottler` supports `RuntimeStorage` and `RedisStorage`.`TokenThrottlerAsync` supports `RedisStorageAsync`If you want your own storage engine, feel free to extend the `token_throttler.storage.BucketStorage` or `token_throttler.storage.BucketStorageAsync` classes.For storage examples see [**examples**](https://gitlab.com/vojko.pribudic/token-throttler/-/tree/main/examples) directory.&lt;a name=&quot;configuration&quot;&gt;&lt;/a&gt;## 5. ConfigurationToken throttler supports global configuration by making use of `ThrottlerConfig` class.Configuration params:- `IDENTIFIER_FAIL_SAFE` - if invalid identifier is given as a param for the `consume` method and `IDENTIFIER_FAIL_SAFE`is set to `True`, no `KeyError` exception will be raised and `consume` will act like a limitless bucket is being consumed.- `ENABLE_THREAD_LOCK` - if set to `True`, throttler will acquire a thread lock upon calling `consume` method and releasethe lock once the `consume` is finished. This avoids various race conditions at a slight performance cost.&lt;a name=&quot;configuration-usage&quot;&gt;&lt;/a&gt;### Configuration usage```pythonfrom token_throttler import ThrottlerConfig, TokenBucket, TokenThrottlerfrom token_throttler.storage import RuntimeStorageThrottlerConfig.set({   &quot;ENABLE_THREAD_LOCK&quot;: False,   &quot;IDENTIFIER_FAIL_SAFE&quot;: True,})throttler: TokenThrottler = TokenThrottler(1, RuntimeStorage())throttler.add_bucket(&quot;hello_world&quot;, TokenBucket(10, 10))throttler.add_bucket(&quot;hello_world&quot;, TokenBucket(30, 20))...```</longdescription>
</pkgmetadata>