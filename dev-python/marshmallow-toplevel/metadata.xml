<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># marshmallow-toplevelLoad and validate top-level lists with all the power of[marshmallow](https://github.com/marshmallow-code/marshmallow).## Installation```shpip install marshmallow-toplevel```## Usage```pythonfrom marshmallow import fieldsfrom marshmallow_toplevel import TopLevelSchemaclass BatchOfSomething(TopLevelSchema):    _toplevel = fields.Nested(        SomethingSchema,        required=True,        many=True,        validate=any_validation_logic_applied_to_list    )```## RationaleImagine that you have an API endpoint (or any other program thataccepts user input), which is intended to accept multiple blog articlesand save them to a database. Semantically, your data is a list of dictionaries:```python[    {&quot;id&quot;: 1, &quot;title&quot;: &quot;Hello World!&quot;},    {&quot;id&quot;: 2, &quot;title&quot;: &quot;Yet another awesome article.&quot;},    ...]```You describe article object schema and put constraints on your data:```pythonfrom marshmallow import Schema, fields, validateclass ArticleSchema(Schema):    id = fields.Int(required=True)    title = fields.Str(required=True, validate=validate.Length(min=2, max=256))```But you also want to put some constraints onto outer list itself, for example,you want it to have length between 1 and 10. How do you describe it interms of `marshmallow`?### Obvious solution: nest your data```pythonclass BatchOfArticles(Schema):    articles = fields.Nested(        ArticleSchema,        required=True,        many=True,        validate=validate.Length(1, 10)    )```But now a client have to send data this way, with this extra dictionary around:```python{    &quot;articles&quot;: [        {&quot;id&quot;: 1, &quot;title&quot;: &quot;Hello World!&quot;},        {&quot;id&quot;: 2, &quot;title&quot;: &quot;Yet another awesome article.&quot;},        ...    ]}```It makes your API not so beautiful and user-friendly.### Good solution: use marshmallow-toplevelWith `marshmallow-toplevel` you can describe you data this way:```pythonfrom marshmallow_toplevel import TopLevelSchemaclass BatchOfArticles(TopLevelSchema):    _toplevel = fields.Nested(        ArticleSchema,        required=True,        many=True,        validate=validate.Length(1, 10)    )```Notice that schema inherits from `TopLevelSchema` and uses thisspecial `_toplevel` key. It means that the field under this keydescribes top level object. You can define any constrains thatyou can define in `marshmallow` and it will just work:```pythonschema = BatchOfArticles()# validation should failerrors = schema.validate([])assert errors  # length &lt; 1errors = schema.validate([{&quot;id&quot;: i, &quot;title&quot;: &quot;title&quot;} for i in range(100)])assert errors  # length &gt; 10# validation should succeederrors = schema.validate([{&quot;id&quot;: i, &quot;title&quot;: &quot;title&quot;} for i in range(5)])assert not errors```You can also use `load` for this schema as usual:```pythondata = schema.load([{&quot;id&quot;: &quot;10&quot;, &quot;title&quot;: &quot;wow!&quot;}])print(data)# [{&quot;id&quot;: 10, &quot;title&quot;: &quot;wow!&quot;}]```Now a client can send data as a list without redundancy.</longdescription>
</pkgmetadata>