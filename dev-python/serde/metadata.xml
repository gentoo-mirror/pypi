<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Serde=====.. image:: https://img.shields.io/pypi/v/serde.svg?style=flat-square&amp;colorB=4c1    :target: https://pypi.org/project/serde/    :alt: PyPI Version.. image:: https://img.shields.io/badge/docs-passing-brightgreen.svg?style=flat-square    :target: https://rossmacarthur.github.io/serde/    :alt: Documentation Status.. image:: https://img.shields.io/github/workflow/status/rossmacarthur/serde/build/master?style=flat-square    :target: https://github.com/rossmacarthur/serde/actions?query=workflow%3Abuild    :alt: Build Status.. image:: https://img.shields.io/codecov/c/github/rossmacarthur/serde.svg?style=flat-square    :target: https://codecov.io/gh/rossmacarthur/serde    :alt: Code Coverage.. image:: https://img.shields.io/badge/code%20style-black-101010.svg?style=flat-square    :target: https://github.com/psf/black    :alt: Code StyleSerde is a lightweight, general-purpose framework for defining, serializing,deserializing, and validating data structures in Python... contents::    :backlinks: none    :local:    :depth: 2Getting started---------------Installation^^^^^^^^^^^^Serde is available on PyPI, you can install it using.. code-block:: sh    pip install serdeExtended features can be installed with the ``ext`` feature... code-block:: sh    pip install serde[ext]Introduction^^^^^^^^^^^^In Serde *models* are containers for *fields*. Data structures are defined bysubclassing ``Model`` and assigning ``Field`` instances as class annotations.These fields handle serialization, deserialization, normalization, andvalidation for the corresponding model attributes... code-block:: python    from datetime import date    from serde import Model, fields    class Artist(Model):        name: fields.Str()    class Album(Model):        title: fields.Str()        release_date: fields.Optional(fields.Date)        artist: fields.Nested(Artist)    album = Album(        title='Dangerously in Love',        release_date=date(2003, 6, 23),        artist=Artist(name='Beyoncé')    )    assert album.to_dict() == {        'title': 'Dangerously in Love',        'release_date': '2003-06-23',        'artist': {            'name': 'Beyoncé'        }    }    album = Album.from_json(&quot;&quot;&quot;{        &quot;title&quot;: &quot;Lemonade&quot;,        &quot;artist&quot;: {&quot;name&quot;: &quot;Beyoncé&quot;}}&quot;    &quot;&quot;&quot;)    assert album == Album(title='Lemonade', artist=Artist(name='Beyoncé'))Basic usage-----------Below we create a ``User`` model by subclassing ``Model`` and adding the``name`` and ``email`` fields... code-block:: python    &gt;&gt;&gt; from datetime import datetime    &gt;&gt;&gt; from serde import Model, fields    &gt;&gt;&gt;    &gt;&gt;&gt; class User(Model):    ...     name: fields.Str(rename='username')    ...     email: fields.Email()The corresponding attribute names are used to instantiate the model object andaccess the values on the model instance... code-block:: python    &gt;&gt;&gt; user = User(name='Linus Torvalds', email='torvalds@linuxfoundation.org')    &gt;&gt;&gt; user.name    'Linus Torvalds'    &gt;&gt;&gt; user.email    'torvalds@linuxfoundation.org'Models are validated when they are instantiated and a ``ValidationError`` israised if you provide invalid values... code-block:: python    &gt;&gt;&gt; User(name='Linus Torvalds', email='not an email')    Traceback (most recent call last):    ...    serde.exceptions.ValidationError: {'email': 'invalid email'}Models are serialized into primitive Python types using the ``to_dict()`` methodon the model instance... code-block:: python    &gt;&gt;&gt; user.to_dict()    OrderedDict([('username', 'Linus Torvalds'), ('email', 'torvalds@linuxfoundation.org')])Or to JSON using the ``to_json()`` method... code-block:: python    &gt;&gt;&gt; user.to_json()    '{&quot;username&quot;: &quot;Linus Torvalds&quot;, &quot;email&quot;: &quot;torvalds@linuxfoundation.org&quot;}'Models are also validated when they are deserialized. Models are deserializedfrom primitive Python types using the reciprocal ``from_dict()`` class method... code-block:: python    &gt;&gt;&gt; user = User.from_dict({    ...     'username': 'Donald Knuth',    ...     'email': 'noreply@stanford.edu'    ... })Or from JSON using the ``from_json()`` method... code-block:: python    &gt;&gt;&gt; user = User.from_json('''{    ...     &quot;username&quot;: &quot;Donald Knuth&quot;,    ...     &quot;email&quot;: &quot;noreply@stanford.edu&quot;    ... }''')Attempting to deserialize invalid data will result in a ``ValidationError``... code-block:: python    &gt;&gt;&gt; User.from_dict({'username': 'Donald Knuth'})    Traceback (most recent call last):    ...    serde.exceptions.ValidationError: {'email': &quot;missing data, expected field 'email'&quot;}Models------Models can be nested and used in container-like fields.  Below we create a``Blog`` with an author and a list of subscribers which must all be ``User``instances... code-block:: python    &gt;&gt;&gt; class Blog(Model):    ...     title: fields.Str()    ...     author: fields.Nested(User)    ...     subscribers: fields.List(User)When instantiating you have to supply instances of the nested models... code-block:: python    &gt;&gt;&gt; blog = Blog(    ...     title=&quot;sobolevn's personal blog&quot;,    ...     author=User(name='Nikita Sobolev', email='mail@sobolevn.me'),    ...     subscribers=[    ...         User(name='Ned Batchelder', email='ned@nedbatchelder.com')    ...     ]    ... )Serializing a ``Blog`` would serialize the entire nested structure... code-block:: python    &gt;&gt;&gt; print(blog.to_json(indent=2))    {      &quot;title&quot;: &quot;sobolevn's personal blog&quot;,      &quot;author&quot;: {        &quot;username&quot;: &quot;Nikita Sobolev&quot;,        &quot;email&quot;: &quot;mail@sobolevn.me&quot;      },      &quot;subscribers&quot;: [        {          &quot;username&quot;: &quot;Ned Batchelder&quot;,          &quot;email&quot;: &quot;ned@nedbatchelder.com&quot;        }      ]    }Similiarly deserializing a ``Blog`` would deserialize the entire nestedstructure, and create instances of all the submodels.Subclassed models^^^^^^^^^^^^^^^^^Models can be subclassed. The subclass will have all the fields of the parentand any additional ones. Consider the case where we define a ``SuperUser`` modelwhich is a subclass of a ``User``. Simply a ``User`` that has an extra ``level``field... code-block:: python    &gt;&gt;&gt; class SuperUser(User):    ...     # inherits name and email fields from User    ...     level: fields.Choice(['admin', 'read-only'])We instantiate a subclassed model as normal by passing in each field value... code-block:: python    &gt;&gt;&gt; superuser = SuperUser(    ...     name='Linus Torvalds',    ...     email='torvalds@linuxfoundation.org',    ...     level='admin'    ... )This is great for many cases, however, a commonly desired paradigm is to be ableto have the ``User.from_dict()`` class method be able to deserialize a``SuperUser`` as well. This can be made possible through *model tagging*.Model tagging-------------Model tagging is a way to mark serialized data in order to show that it is aparticular *variant* of a model. Serde provides three types of model tagging,but you can also define you own custom ``Tag``. A ``Tag`` can be thought of inthe same way as a ``Field`` but instead of deserializing data into an attributeon a model instance, it deserializes data into a model class.Internally tagged^^^^^^^^^^^^^^^^^Internally tagged data stores a tag value inside the serialized data.Let us consider an example where we define a ``Pet`` model with a ``tag``. Wecan then subclass this model and deserialize arbitrary subclasses using thetagged model... code-block:: python    &gt;&gt;&gt; from serde import Model, fields, tags    &gt;&gt;&gt;    &gt;&gt;&gt; class Pet(Model):    ...     name: fields.Str()    ...    ...     class Meta:    ...         tag = tags.Internal(tag='species')    ...    &gt;&gt;&gt; class Dog(Pet):    ...     hates_cats: fields.Bool()    ...    &gt;&gt;&gt; class Cat(Pet):    ...     hates_dogs: fields.Bool()We refer to the ``Dog`` and ``Cat`` subclasses as *variants* of ``Pet``. Whenserializing all parent model tag serialization is done after fieldserialization... code-block:: python    &gt;&gt;&gt; Cat(name='Fluffy', hates_dogs=True).to_dict()    OrderedDict([('name', 'Fluffy'), ('hates_dogs', True), ('species', '__main__.Cat')])When deserializing, tag deserialization is done first to determine which modelto use for the deserialization... code-block:: python    &gt;&gt;&gt; milo = Pet.from_dict({    ...     'name': 'Milo',    ...     'hates_cats': False,    ...     'species': '__main__.Dog'    ... })    &gt;&gt;&gt; milo.__class__    &lt;class '__main__.Dog'&gt;    &gt;&gt;&gt; milo.name    'Milo'    &gt;&gt;&gt; milo.hates_cats    FalseAn invalid or missing tag will raise a ``ValidationError``... code-block:: python    &gt;&gt;&gt; Pet.from_dict({'name': 'Milo', 'hates_cats': False})    Traceback (most recent call last):    ...    serde.exceptions.ValidationError: missing data, expected tag 'species'    &gt;&gt;&gt;    &gt;&gt;&gt; Pet.from_dict({'name': 'Duke', 'species': '__main__.Horse'})    Traceback (most recent call last):    ...    serde.exceptions.ValidationError: no variant foundExternally tagged^^^^^^^^^^^^^^^^^Externally tagged data uses the tag value as a key and nests the contentunderneath that key. All other processes behave similarly to the internallytagged example above... code-block:: python    &gt;&gt;&gt; class Pet(Model):    ...     name: fields.Str()    ...    ...     class Meta:    ...         tag = tags.External()    ...    &gt;&gt;&gt; class Dog(Pet):    ...     hates_cats: fields.Bool()    ...    &gt;&gt;&gt; Dog(name='Max', hates_cats=True).to_dict()    OrderedDict([('__main__.Dog', OrderedDict([('name', 'Max'), ('hates_cats', True)]))])Adjacently tagged^^^^^^^^^^^^^^^^^Adjacently tagged data data stores the tag value and the content underneath twoseparate keys. All other processes behave similarly to the internally taggedexample... code-block:: python    &gt;&gt;&gt; class Pet(Model):    ...     name: fields.Str()    ...    ...     class Meta:    ...         tag = tags.Adjacent(tag='species', content='data')    ...    &gt;&gt;&gt; class Dog(Pet):    ...     hates_cats: fields.Bool()    ...    &gt;&gt;&gt; Dog(name='Max', hates_cats=True).to_dict()    OrderedDict([('species', '__main__.Dog'), ('data', OrderedDict([('name', 'Max'), ('hates_cats', True)]))])Abstract models^^^^^^^^^^^^^^^By default model tagging still allows deserialization of the base model. It iscommon to have this model be abstract. You can do this by setting the``abstract`` Meta field to ``True``. This will make it uninstantiatable and itwon't be included in the variant list during deserialization... code-block:: python    &gt;&gt;&gt; class Fruit(Model):    ...     class Meta:    ...         abstract = True    ...    &gt;&gt;&gt; Fruit()    Traceback (most recent call last):    ...    TypeError: unable to instantiate abstract model 'Fruit'Custom tags^^^^^^^^^^^It is possible to create your own custom tag class by subclassing any of``tags.External``, ``tags.Internal``, ``tags.Adjacent`` or even the base``tags.Tag``. This will allow customization of how the variants are looked up,how the tag values are generated for variants, and how the data is serialized.Consider an example where we use a class attribute ``code`` as the tag value... code-block:: python    &gt;&gt;&gt; class Custom(tags.Internal):    ...     def lookup_tag(self, variant):    ...         return variant.code    ...    &gt;&gt;&gt; class Pet(Model):    ...     name: fields.Str()    ...    ...     class Meta:    ...         abstract = True    ...         tag = Custom(tag='code')    ...    &gt;&gt;&gt; class Dog(Pet):    ...     code = 1    ...     hates_cats: fields.Bool()    ...    &gt;&gt;&gt; Dog(name='Max', hates_cats=True).to_dict()    OrderedDict([('name', 'Max'), ('hates_cats', True), ('code', 1)])    &gt;&gt;&gt; max = Pet.from_dict({'name': 'Max', 'hates_cats': True, 'code': 1})    &gt;&gt;&gt; max.__class__    &lt;class '__main__.Dog'&gt;    &gt;&gt;&gt; max.name    'Max'    &gt;&gt;&gt; max.hates_cats    TrueFields------Fields do the work of serializing, deserializing, normalizing, and validatingthe input values. Fields are always assigned to a model as *instances* , andthey support extra serialization, deserialization, normalization, and validationof values without having to subclass ``Field``. For example.. code-block:: python    from serde import Model, fields, validators    class Album(Model):        title: fields.Str(normalizers=[str.strip])        released: fields.Date(            rename='release_date',            validators=[validators.Min(datetime.date(1912, 4, 15))]        )In the above example we define an ``Album`` class. The ``title`` field is oftype `str` , and we apply the ``str.strip`` normalizer to automatically stripthe input value when instantiating or deserializing the ``Album``. The``released`` field is of type ``datetime.date`` and we apply an extra validatorto only accept dates after 15th April 1912. Note: the ``rename`` argument onlyapplies to the serializing and deserializing of the data, the ``Album`` classwould still be instantiated using ``Album(released=...)``.If these methods of creating custom ``Field`` classes are not satisfactory, youcan always subclass a ``Field`` and override the relevant methods... code-block:: python    &gt;&gt;&gt; class Percent(fields.Float):    ...     def validate(self, value):    ...         super().validate(value)    ...         validators.Between(0.0, 100.0)(value)Model states and processes--------------------------In Serde, there are two states that the data can be in:* Serialized data* Model instanceThere are five different processes that the data structure can go through whenmoving between these two states.* Deserialization happens when you create a model instance from a serialized  version using ``from_dict()`` or similar.* Instantiation happens when you construct a model instance in Python using the  ``__init__()`` constructor.* Normalization happens after instantiation and after deserialization. This is  usually a way to transform things before they are validated. For example: this  is where an ``Optional`` field sets default values.* Validation is where the model and fields values are validated. This happens  after normalization.* Serialization is when you serialize a model instance to a supported  serialization format using ``to_dict()`` or similar.The diagram below shows how the stages (uppercase) and processes (lowercase) fitin with each other... code-block:: text                           +---------------+                           | Instantiation |                           +---------------+                                   |                                   v       +---------------+   +---------------+       |Deserialization|--&gt;| Normalization |       +---------------+   +---------------+               ^                   |               |                   v               |           +---------------+               |           |   Validation  |               |           +---------------+               |                   |               |                   v       +-------+-------+   +---------------+       |SERIALIZED DATA|   | MODEL INSTANCE|       +---------------+   +---------------+               ^                   |               |                   |       +-------+-------+           |       | Serialization |&lt;----------+       +---------------+License-------Serde is licensed under either of- Apache License, Version 2.0 (`LICENSE-APACHE &lt;LICENSE-APACHE&gt;`_ or https://www.apache.org/licenses/LICENSE-2.0)- MIT License (`LICENSE-MIT &lt;LICENSE-MIT&gt;`_ or https://opensource.org/licenses/MIT)at your option.</longdescription>
</pkgmetadata>