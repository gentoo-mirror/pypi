<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>startup=======The ``Startup`` class implements a function-call graph dependencyresolver for decoupling complex program initialization sequence.To use ``startup``, you annotate functions with which variables theyread or write (remainder: you **must** annotate **all** non-optionalparameters).  Then ``startup`` generates a dependency graph from theannotations, and call them in a stable and predictable order.  Eachfunction will be called exactly once, and if a function has never beencalled (due to unsatisfiable dependency), ``startup`` will raise a``StartupError``.Sample usage:.. code-block:: python    from startup import startup    # 'argv' is the variable name that parse_argv reads from, and    # 'args' is the variable name that parse_argv writes to.    # NOTE: All non-optional parameters must be annotated.    @startup    def parse_argv(argv: 'argv') -&gt; 'args':        args = {'config_path': argv[1]}        return args    @startup    def read_config(args: 'args') -&gt; 'config':        with open(args['config_path']) as config_file:            return config_file.read()    def main(argv):        # You may provide variable values to startup, like argv in this        # case, and you may read variable, like config, which will be        # returned by startup.call().        config = startup.call(argv=argv)['config']You **must** annotate **all** non-optional parameters with a variablename, but annotating return value is optional.  A parameter annotationcan be annotated in the form ``['var']``, and this function will readall values written to ``'var'`` (see below).  A return value annotationcan be a tuple of variable names, which means unpacking return value.The variables in function annotations are not real but merely ``dict``keys that ``startup`` stores internally (``startup.call()`` will returnthis ``dict`` so that you too may read these variables).NOTE: Currently the annotation formats are very strict: A parameterannotation must be either a ``str`` or an one-element list of ``str``,and a return value annotation must be either a ``str`` or a tuple of``str``.  The flexibility is reserved for future extensions.The functions that are satisfied by the same set of dependencies arecalled in lexicographical order by their module name and qualified name.This way, even if you change code layout and/or import order, thefunctions would still be called in the same order, and thus ``startup``is stable and predictable.A variable may be written multiple times (if multiple functions areannotated to write to it).  In this case, ``startup`` will call thereader functions only after all writer functions are called.  Thereader functions may choose to read the latest value or all the valueswritten to that variable (by ``['var']`` annotation form).The fact that all readers are blocked by all writers can be used toexpress common patterns of program initialization, such as joining orsequencing function calls.Why ``startup``?----------------Starting up a program could be complex but should not be complicated.For example, ``main.py`` imports ``orm.py`` and ``orm.py`` imports``db.py``.  Say you want to initialize them in the order of ``db.py``,``main.py``, and then ``orm.py``.  Then ``main.py`` has to know that ittransitively imports ``db.py`` and should initialize ``db.py`` beforeitself.  Things get even more complex when each module requires phasesof initialization.  We usually end up with ``main.py`` importing allother modules and manually order the initializations.  I think this kindof problem can be better solved with topological sort on the dependencygraphs.  Basically you annotate each module's dependencies and then``startup`` will resolve a stable and predictable function-call orderingfor you.</longdescription>
</pkgmetadata>