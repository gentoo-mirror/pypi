<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![Logo](https://github.com/mkrd/DictDataBase/blob/main/assets/logo.png?raw=true)[![Downloads](https://pepy.tech/badge/dictdatabase)](https://pepy.tech/project/dictdatabase)![Tests](https://github.com/mkrd/DictDataBase/actions/workflows/test.yml/badge.svg)![Coverage](https://github.com/mkrd/DictDataBase/blob/main/assets/coverage.svg?raw=1)DictDataBase is a fast document-based database that uses json files or compressed json files for storage.- **Multi threading and multi processing safe**. Multiple processes on the same machinecan simultaneously read and write to dicts without losing data.- **ACID** compliant. Unlike TinyDB, it is suited for concurrent environments.- **No Conflict resolution** required. Unlike with ZODB, lock-based access control is used, such that conflicts never occur.- **No database server** required. Simply import DictDataBase in your project and useit.- **Compression**. Configure if the files should be stored as raw json or as jsoncompressed with zlib.- **Fast**. Key-value pairs inside a json file can be accessed quickly and efficiently because the keys are indexed.- **Tested** with 99%+ coverage.### Why use DictDataBase- Your application concurrently reads and writes data from multiple processes or threads.- Using database server is a bit too much for your application.    - But you need [ACID](https://en.wikipedia.org/wiki/ACID) guarantees.- Your use case requires reading key-value pairs from very large json files repeatedly. (For example, DictDataBase can handle about 2000 reads per second when reading single key-value pairs from a 2.5GB json file with 20000 key-value pairs.)- You need to repeatedly read and write many smaller json files.- Your use case is suited for working with json data, or you have to work with a lot ofjson data.### Why not DictDataBase- If your storage is slow.- Your use cases requires repeatedly modifying or writing data in a single very large json file- If a relational database is better suited for your use case.- If you need to read files that are larger than your system's RAM.Install========================================================================================```shpip install dictdatabase```Configuration========================================================================================The following configuration parameters can be modified using `DDB.config`:### Storage directorySet storage_directory to the path of the directory that will contain your json files:```pythonDDB.config.storage_directory = &quot;./ddb_storage&quot; # Default value```### CompressionIf you want to use compressed files, set use_compression to `True`.This will make the db files significantly smaller and might improve performance if yourdisk is slow. However, the files will not be human readable.```pythonDDB.config.use_compression = False # Default value```### IndentationSet the way how written json files should be indented. Behaves exactly like`json.dumps(indent=...)`. It can be an `int` for the number of spaces, the tabcharacter, or `None` if you don't want the files to be indented.```pythonDDB.config.indent = &quot;\t&quot; # Default value```Notice: If `DDB.config.use_orjson = True`, then the value can only be 2 (spaces) or0/None for no indentation.### Use orjsonYou can use the orjson encoder and decoder if you need to.The standard library json module is sufficient most of the time.However, orjson is a lot more performant in virtually all cases.```pythonDDB.config.use_orjson = True # Default value```Usage========================================================================================Import----------------------------------------------------------------------------------------```pythonimport dictdatabase as DDB```Create a file----------------------------------------------------------------------------------------This library is called DictDataBase, but you can actually use any json serializable object.```pythonusers_dict = {   &quot;u1&quot;: { &quot;name&quot; : &quot;Ben&quot;, &quot;age&quot;: 30, &quot;job&quot;: &quot;Software Engineer&quot; },   &quot;u2&quot;: { &quot;name&quot; : &quot;Sue&quot;, &quot;age&quot;: 21, &quot;job&quot;: &quot;Architect&quot; },   &quot;u3&quot;: { &quot;name&quot; : &quot;Joe&quot;, &quot;age&quot;: 50, &quot;job&quot;: &quot;Manager&quot; },}DDB.at(&quot;users&quot;).create(user_data_dict)```There is now a file called `users.json` or `users.ddb` in your specified storagedirectory depending on if you use compression.Check if file or sub-key exists----------------------------------------------------------------------------------------```pythonDDB.at(&quot;users&quot;).exists()&gt;&gt;&gt; True  # File existsDDB.at(&quot;users&quot;, key=&quot;u10&quot;).exists()&gt;&gt;&gt; False # Key &quot;u10&quot; not in usersDDB.at(&quot;users&quot;, key=&quot;u2&quot;).exists()&gt;&gt;&gt; True```Read dicts----------------------------------------------------------------------------------------```pythond = DDB.at(&quot;users&quot;).read()d == users_dict # True# Only partially read Joejoe = DDB.at(&quot;users&quot;, key=&quot;u3&quot;).read()joe == users_dict[&quot;Joe&quot;] # True```&gt; Note: Doing a partial read like with `DDB.at(&quot;users&quot;, key=&quot;Joe&quot;).read()` will only&gt; return the value of the key if the key is at the root indentation level.&gt; Example: You can get &quot;a&quot; from {&quot;a&quot; : 3}, but not from {&quot;b&quot;: {&quot;a&quot;: 3}}.It is also possible to only read a subset of keys based on a filter callback:```pythonDDB.at(&quot;numbers&quot;).create({&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;: 3})above_1 = DDB.at(&quot;numbers&quot;, where=lambda k, v: v &gt; 1).read()&gt;&gt;&gt; above_1 == {&quot;b&quot;, 2, &quot;c&quot;: 3}```&gt; The `where` callback is a function that takes two parameters, the key and the value.Write dicts----------------------------------------------------------------------------------------```pythonwith DDB.at(&quot;users&quot;).session() as (session, users):   users[&quot;u3&quot;][&quot;age&quot;] = 99print(DDB.at(&quot;users&quot;, key=&quot;u3&quot;).read()[&quot;age])&gt;&gt;&gt; 99```&gt; If you do not call session.write(), changes will not be written to disk!Partial writing----------------------------------------------------------------------------------------Imagine you have a huge json file with many purchases.The json file looks like this: `{&lt;id&gt;: &lt;purchase&gt;, &lt;id&gt;: &lt;purchase&gt;, ...}`.Normally, you would have to read and parse the entire file to get a specific key.After modifying the purchase, you would also have to serialize and write theentire file again. With DDB, you can do it more efficiently:```pythonwith DDB.at(&quot;purchases&quot;, key=&quot;3244&quot;).session() as (session, purchase):    purchase[&quot;status&quot;] = &quot;cancelled&quot;    session.write()```Afterwards, the status is updated in the json file.However, DDB did only efficiently gather the one purchase with id 134425, parsedits value, and serialized that value alone before writing again. This is severalorders of magnitude faster than the naive approach when working with big files.Folders----------------------------------------------------------------------------------------You can also read and write to folders of files. Consider the same example asbefore, but now we have a folder called `purchases` that contains many files`&lt;id&gt;.json`. If you want to open a session or read a specific one, you can do:```pythonDDB.at(&quot;purchases/&lt;id&gt;&quot;).read()# Or equivalently:DDB.at(&quot;purchases&quot;, &quot;&lt;id&gt;&quot;).read()```To open a session or read all, do the following:```pythonDDB.at(&quot;purchases/*&quot;).read()# Or equivalently:DDB.at(&quot;purchases&quot;, &quot;*&quot;).read()```### Select from folderIf you have a folder containing many json files, you can read them selectivelybased on a function. The file is included if the provided function returns truewhen it get the file dict as input:To open a session or read all, do the following:```pythonfor i in range(10):    DDB.at(&quot;folder&quot;, i).create({&quot;a&quot;: i})# Now in the directory &quot;folder&quot;, 10 files existres = DDB.at(&quot;folder/*&quot;, where=lambda x: x[&quot;a&quot;] &gt; 7).read() # .session() also possibleassert ress == {&quot;8&quot;: {&quot;a&quot;: 8}, &quot;9&quot;: {&quot;a&quot;: 9}} # True```Performance========================================================================================In preliminary testing, DictDataBase showed promising performance.### SQLite vs DictDataBaseIn each case, `16` parallel processes were spawned to perform `128` incrementsof a counter in `4` tables/files. SQLite achieves `2435 operations/s` whileDictDataBase managed to achieve `3143 operations/s`.### More testsIt remains to be tested how DictDatabase performs in different scenarios, forexample when multiple processes want to perform full writes to one big file.Advanced========================================================================================Sleep Timeout----------------------------------------------------------------------------------------DictDataBase uses a file locking protocol to coordinate concurrent file accesses.While waiting for a file where another thread or process currently has exclusiveaccess rights, the status of the file lock is periodically checked. You can setthe timout between the checks:```pythonDDB.locking.SLEEP_TIMEOUT = 0.001 # 1ms, default value```A value of 1 millisecond is good and it is generally not recommended to change it,but you can still tune it to optimize performance in your use case.Lock Timeout----------------------------------------------------------------------------------------When a lock file is older than the lock timeout, it is considered orphaned and willbe removed. This could be the case when your operating terminates a thread or processwhile it holds a lock. The timeout can be adjusted:```pythonDDB.locking.LOCK_TIMEOUT = 30.0 # 30s, default value```Chose a value that is long enough where you know that your database operations willless than it.API Reference========================================================================================### `at(path) -&gt; DDBMethodChooser:`Select a file or folder to perform an operation on.If you want to select a specific key in a file, use the `key` parameter,e.g. `DDB.at(&quot;file&quot;, key=&quot;subkey&quot;)`. The key value is only returned if the keyis at the root level of the json object.If you want to select an entire folder, use the `*` wildcard,eg. `DDB.at(&quot;folder&quot;, &quot;*&quot;)`, or `DDB.at(&quot;folder/*&quot;)`. You can also usethe `where` callback to select a subset of the file or folder.If the callback returns `True`, the item will be selected. The callbackneeds to accept a key and value as arguments.Args:- `path`: The path to the file or folder. Can be a string, acomma-separated list of strings, or a list.- `key`: The key to select from the file.- `where`: A function that takes a key and value and returns `True` if thekey should be selected.Beware: If you select a folder with the `*` wildcard, you can't use the `key`parameter.Also, you cannot use the `key` and `where` parameters at the same time.DDBMethodChooser----------------------------------------------------------------------------------------### `exists() -&gt; bool:`Create a new file with the given data as the content. If the filealready exists, a FileExistsError will be raised unless`force_overwrite` is set to True.Args:- `data`: The data to write to the file. If not specified, an empty dictwill be written.- `force_overwrite`: If `True`, will overwrite the file if it alreadyexists, defaults to False (optional).### `create(data=None, force_overwrite: bool = False):`It creates a database file at the given path, and writes the given database toit:param db: The database to create. If not specified, an empty database iscreated.:param force_overwrite: If True, will overwrite the database if it alreadyexists, defaults to False (optional).### `delete()`Delete the file at the selected path.### `read(self, as_type: T = None) -&gt; dict | T | None:`Reads a file or folder depending on previous `.at(...)` selection.Args:- `as_type`: If provided, return the value as the given type.Eg. as_type=str will return str(value).### `session(self, as_type: T = None) -&gt; DDBSession[T]:`Opens a session to the selected file(s) or folder, depending on previous`.at(...)` selection. Inside the with block, you have exclusive accessto the file(s) or folder.Call `session.write()` to write the data to the file(s) or folder.Args:- `as_type`: If provided, cast the value to the given type.Eg. as_type=str will return str(value).</longdescription>
</pkgmetadata>