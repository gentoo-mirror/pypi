<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># 主要就是封装了一下asyncio 的网络# 实例1 一个tcp server```pythonfrom l0n0ltcp.tcp_server import TcpServerfrom l0n0ltcp.json_handler import JsonHandler, json_rpcfrom l0n0ltcp.tcp_simple_proto import TcpSimpleProto# TcpSimpleProto简介# 3 byte(后面的数据包大小size) + 4byte(控制字段，可自定义) + (size - 4)的数据# JsonHandler 简介# Json handler 会将 数据解析为一个json对象# 格式为{&quot;name&quot;: 函数名, args: 参数列表, serial_id: 调用ID}# 然后根据 name 获取函数，将 [会话ID] 和 args 传递给 获取的函数 然后调用# 函数的返回值 会被发送回调用方# json_rpc简介# json_rpc 用于调用远程的函数# 原理：# 1.如果调用有返回值： json_rpc(send_msg, &quot;remote_func&quot;, [123,321])# 第一步： 发送 {&quot;name&quot;: &quot;remote_func&quot;, &quot;args&quot;: [123,321], &quot;serial_id&quot;: 1}# 第二步： 生成一个future 放到一个dict里面 futures[serial_id] = future, 等待返回值# 第三步： 接收方（比如JsonHandler）收到后 执行 &quot;remote_func&quot;。#         发送返回值 {&quot;name&quot;: 1, &quot;args&quot;: &quot;返回数据&quot; }# 第四步： 调用方接收到返回数据， 根据 fu = futures.get(name) 获取到 等待的future。#           fu.set_result(args) # 第五步： 获取到结果# 2.如果没有返回值# 发送 {&quot;name&quot;: &quot;remote_func&quot;, &quot;args&quot;: [123,321]}# TCP handlerg_msg_handler = JsonHandler() # 函数对象，也可以是一个  **[异步函数]**def tcp_handle(func):  # tcp handler装饰器    g_msg_handler.regist_handler(func)    return func@tcp_handleasync def remote_func(session_id, a, b):    print(a, b)    return {&quot;aaa&quot;:&quot;bbb&quot;}loop = asyncio.get_event_loop()g_tcp_server = TcpServer(&quot;0.0.0.0&quot;,             # 监听地址                         12345,                 # 监听端口                         g_msg_handler,         # 用来处理数据的【异步】函数                         TcpSimpleProto(),      # 用来解析包的对象                         1,                     # 心跳时间间隔                         5,                     # 当有~次心跳检测没有检测到数据包，就认定为该链接已经断开。                         loop)                  # asyncio loop```## 如何自定义协议```pythonimport structfrom l0n0ltcp.tcp_proto_base import TcpProtoBase, StreamReaderclass TcpSimpleProto(TcpProtoBase):    def make_heart_msg(self) -&gt; bytes:        return b&quot;\x00\x00\x00&quot;    def build_msg(self, data: bytes) -&gt; bytes:        data_len = len(data) + 4        size = data_len &amp; 0xFFFF        count = (data_len &gt;&gt; 16) &amp; 0xFF        header = struct.pack(&quot;!HBI&quot;, size, count, 0)        return header + data    async def read_msg(self, reader: StreamReader):        header = await reader.readexactly(3)        size, count = struct.unpack(&quot;!HB&quot;, header)        size = (count &lt;&lt; 16) | size        if size &lt;= 0:            return        return await reader.readexactly(size)```## 穿越GFW```1.服务器执行usage: l0n0ltranssocks5 [-h] listenhost listenport password sock5port创建SOCKS5服务器,并使用加密通道代理positional arguments:  listenhost  监听host  listenport  监听端口  password    密钥  sock5port   socks5监听端口(并不需要再启动一个socks5,自动启动一个socks5)optional arguments:  -h, --help  show this help message and exit2.本地主机执行 usage: l0n0ltransclient [-h] serverhost serverport localhost localport password创建本地代理服务器positional arguments:  serverhost  服务器监听host  serverport  服务器监听端口  localhost   本地服务host  localport   本地服务端口  password    密钥optional arguments:  -h, --help  show this help message and exit```## socks5 服务器### 代码```pythonfrom l0n0ltcp.tcp_server import TcpServerfrom l0n0ltcp.socks5_callback import Socks5ServerCallbackfrom l0n0ltcp.socks5_proto import Socks5ServerProtoserver = TcpServer('0.0.0.0', 1080,                   Socks5ServerCallback(),                   Socks5ServerProto(),                   loop=asyncio.get_event_loop())server.start()asyncio.get_event_loop().run_forever()```### 命令行```usage: l0n0lsocks5 [-h] listenhost listenport创建SOCKS5服务器(目前仅支持CONNECT命令)positional arguments:  listenhost  监听host  listenport  监听端口optional arguments:  -h, --help  show this help message and exit```## 加密信道### 代码```pythonfrom l0n0ltcp.tcp_simple_proto import TcpSimpleProtofrom l0n0ltcp.trans_callback import TransServerCallback, TransLocalServerCallbackfrom l0n0ltcp.tcp_server import TcpServerfrom l0n0ltcp.tcp_proto_base import TcpProtoBasefrom l0n0ltcp.sym_enc_chacha20 import SymEncChaCha20# 远端服务器serverremote = TcpServer('0.0.0.0', 12343,                    TransServerCallback('baidu.com', 443, SymEncChaCha20(&quot;123&quot;)),                    TcpSimpleProto(),loop=asyncio.get_event_loop())serverremote.start()# 本地服务器serverlocal = TcpServer('0.0.0.0', 12345,                    TransLocalServerCallback('127.0.0.1', 12343, SymEncChaCha20(&quot;123&quot;)),                    TcpProtoBase(),                    loop=asyncio.get_event_loop())serverlocal.start()asyncio.get_event_loop().run_forever()# 访问 localhost:12345 相当于访问 baidu.com 443 中间的过程是chacha20加密的```### 命令行```1.服务器usage: l0n0ltransserver [-h] listenhost listenport password targethost targetport创建加密信道服务器positional arguments:  listenhost  监听host  listenport  监听端口  password    密钥  targethost  要代理的host  targetport  要代理的端口optional arguments:  -h, --help  show this help message and exit2.客户端usage: l0n0ltransclient [-h] serverhost serverport localhost localport password创建本地代理服务器positional arguments:  serverhost  服务器监听host  serverport  服务器监听端口  localhost   本地服务host  localport   本地服务端口  password    密钥optional arguments:  -h, --help  show this help message and exit```</longdescription>
</pkgmetadata>