<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![PyPI](https://img.shields.io/pypi/v/vagd?style=flat)](https://pypi.org/project/vagd/) [![docs](https://img.shields.io/badge/docs-passing-success)](https://vagd.gfelber.dev)# VAGDVirtuAlization GDb integrations in pwntools## Installation```bashpip install vagd```or from repo with```bashgit clone https://github.com/gfelber/vagdpip install ./vagd/```## Usage+ `vagd template [OPTIONS] [BINARY] [IP] [PORT]` to generate a template, list OPTIONS with help `-h````python#!/usr/bin/env pythonfrom pwn import *IP = ''         # remote IPPORT = 0        # remote PORTBINARY = ''     # PATH to local binary e.g. ./chalARGS = []       # ARGS supplied to binary ENV = {}        # ENVs supplied to binary# GDB SCRIPT, executed at start of GDB session (set breakpoint here)GDB = f&quot;&quot;&quot;c&quot;&quot;&quot;context.binary = exe = ELF(BINARY, checksec=False)# enable disable ASLR (works for GDB)context.aslr = Falsevm = Nonedef get_target(**kw):    global vm    if args.REMOTE:        context.log_level = 'debug'        return remote(IP, PORT)    from vagd import Dogd, Qegd, Vagd, Shgd    if not vm:        # Docker         vm = Dogd(exe.path, image=&quot;ubuntu:jammy&quot;, ex=True, fast=True)        # or Qemu        vm = Qegd(exe.path, img=&quot;https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img&quot;, ex=True, fast=True)        # or Vagrant        vm = Vagd(exe.path, vbox=&quot;ubuntu/jammy64&quot;, ex=True, fast=True)        # or SSH        vm = Shgd(exe.path, user='user', host='localhost', port=22, ex=True, fast=True)    return vm.start(argv=ARGS, env=ENV, gdbscript=GDB, **kw) # returns a pwn.process (similar to pwn.process())t = get_target()t.interactive()```+ `vagd info BINARY` to print info about binary```bash# run as process in VM./exploit.py# run as gdb server in VM requires tmux./exploit.py GDB# run on remote IP:PORT./exploit.py REMOTE```I recommend using [pwndbg](https://github.com/pwndbg/pwndbg). ## FilesAll created files ares stored in the local `./.vagd/` directory. Additional large files (e.g. cloudimages) are stored in the home directory `~/.vagd/` or handled by tools themselfs (e.g. Vagrant, Docker).## CLI```bashalias vagd=&quot;python -m vagd&quot; # or install with pip / pipx# help messagevagd -h# analyses the binary, prints checksec and .comment (often includes Distro and Compiler info)vagd info BINARY# creates template, for more info use: vagd template -hvagd template [OPTIONS] [BINARY] [IP] [PORT]# ssh to current vagd instance, for more info use: vagd ssh -hvagd ssh [OPTIONS]# scp file to/from vagd instance, for more info use: vagd scp -h# e.g. vagd scp ./test_file vagd:./ # vagd:./ is default targetvagd scp [OPTIONS] SOURCE [TARGET]# stop and remove current vagd instance, for more info use: vagd clean -hvagd clean [OPTIONS]```## [Documentation](https://vagd.gfelber.dev)## BoxesA listed of known working Boxes can be found in the [Documentation](http://vagd.gfelber.dev/autoapi/vagd/box/index.html#module-vagd.box).Other images might also work but currently only distributions that use `apt` and alpine for Docker are supported.This limitation may be circumvented by creating a target yourself (with the dependencies gdbserver, python, openssh) and creating a ssh connection via Shgd.## Troubleshooting### background processesall instances continue to run in the background (after a vagd object has been started), this improves the runtime greatly after the first execution of the exploit. But this means that instances must be killed manually e.g.: `vagd clean`### gdb &amp; gdbserverBecause gdbserver is used to run binaries on the instances it is advised to use [pwndbg](https://github.com/pwndbg/pwndbg). Other well known gdb plugins like [peda](https://github.com/longld/peda) and [gef](https://github.com/hugsy/gef) aren't compatible with gdbserver and therefore won't work.### filesfiles on the virtual instance are never overwritten this has performance reason (so files aren't always copied if the exploit is run). If you need to updated files on the remote either use `vagd scp` or create use temporary directories `Dogd(..., tmp=True)`### gdb performanceUsing gdbserver and gdb to index libraries can be very slow. Therefore an experimental feature is available that mounts libraries locally: `Dogd(..., ex=True, fast=True)` ## Future plans### pre configured Vagrant boxes / QEMU Images / Docker Imagecreated pre configured environments with preinstalled lib debug symbols and gdbserver to lower init runtime.### Better Docker integrationcreated a Docker integration that allows loading existing Dockerfiles (maybe docker-compose), also add a feature that additionally virtualizes (Vagrant/Qemu) them to change the used kernel.</longdescription>
</pkgmetadata>