<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>====fisx====Main development website: https://github.com/vasole/fisx.. image:: https://travis-ci.org/vasole/fisx.svg?branch=master    :target: https://travis-ci.org/vasole/fisx.. image:: https://ci.appveyor.com/api/projects/status/github/vasole/fisx?branch=master&amp;svg=true    :target: https://ci.appveyor.com/project/vasole/fisxThis software library implements formulas to calculate, given an experimental setup, the expected x-ray fluorescence intensities. The library accounts for secondary and tertiary excitation, K, L and M shell emission lines and de-excitation cascade effects. The basic implementation is written in C++ and a Python binding is provided.Account for secondary excitation is made via the reference:D.K.G. de Boer, X-Ray Spectrometry 19 (1990) 145-154with the correction mentioned in:D.K.G. de Boer et al, X-Ray Spectrometry 22 (1993) 33-28Tertiary excitation is accounted for via an appproximation.The accuracy of the corrections has been tested against experimental data and Monte Carlo simulations.License-------This code is relased under the MIT license as detailed in the LICENSE file.Installation------------To install the library for Python just use ``pip install fisx``. If you want build the library for python use from the code source repository, just use one of the ``pip install .`` or the ``python setup.py install`` approaches. It is convenient (but not mandatory) to have cython &gt;= 0.17 installed for it.Testing-------To run the tests **after installation** run::    python -m fisx.tests.testAllExample-------There is a `web application &lt;http://fisxserver.esrf.fr&gt;`_ using this library for calculating expected x-ray count rates.This piece of Python code shows how the library can be used via its python binding... code-block:: python  from fisx import Elements  from fisx import Material  from fisx import Detector  from fisx import XRF  elementsInstance = Elements()  elementsInstance.initializeAsPyMca()  # After the slow initialization (to be made once), the rest is fairly fast.  xrf = XRF()  xrf.setBeam(16.0) # set incident beam as a single photon energy of 16 keV  xrf.setBeamFilters([[&quot;Al1&quot;, 2.72, 0.11, 1.0]]) # Incident beam filters  # Steel composition of Schoonjans et al, 2012 used to generate table I  steel = {&quot;C&quot;:  0.0445,            &quot;N&quot;:  0.04,           &quot;Si&quot;: 0.5093,           &quot;P&quot;:  0.02,           &quot;S&quot;:  0.0175,           &quot;V&quot;:  0.05,           &quot;Cr&quot;:18.37,           &quot;Mn&quot;: 1.619,           &quot;Fe&quot;:64.314, # calculated by subtracting the sum of all other elements           &quot;Co&quot;: 0.109,           &quot;Ni&quot;:12.35,           &quot;Cu&quot;: 0.175,           &quot;As&quot;: 0.010670,           &quot;Mo&quot;: 2.26,           &quot;W&quot;:  0.11,           &quot;Pb&quot;: 0.001}  SRM_1155 = Material(&quot;SRM_1155&quot;, 1.0, 1.0)  SRM_1155.setComposition(steel)  elementsInstance.addMaterial(SRM_1155)  xrf.setSample([[&quot;SRM_1155&quot;, 1.0, 1.0]]) # Sample, density and thickness  xrf.setGeometry(45., 45.)               # Incident and fluorescent beam angles  detector = Detector(&quot;Si1&quot;, 2.33, 0.035) # Detector Material, density, thickness  detector.setActiveArea(0.50)            # Area and distance in consistent units  detector.setDistance(2.1)               # expected cm2 and cm.  xrf.setDetector(detector)  Air = Material(&quot;Air&quot;, 0.0012048, 1.0)  Air.setCompositionFromLists([&quot;C1&quot;, &quot;N1&quot;, &quot;O1&quot;, &quot;Ar1&quot;, &quot;Kr1&quot;],                              [0.0012048, 0.75527, 0.23178, 0.012827, 3.2e-06])  elementsInstance.addMaterial(Air)  xrf.setAttenuators([[&quot;Air&quot;, 0.0012048, 5.0, 1.0],                      [&quot;Be1&quot;, 1.848, 0.002, 1.0]]) # Attenuators  fluo = xrf.getMultilayerFluorescence([&quot;Cr K&quot;, &quot;Fe K&quot;, &quot;Ni K&quot;],                                       elementsInstance,                                       secondary=2,                                       useMassFractions=1)  print(&quot;Element   Peak          Energy       Rate      Secondary  Tertiary&quot;)  for key in fluo:      for layer in fluo[key]:          peakList = list(fluo[key][layer].keys())          peakList.sort()          for peak in peakList:              # energy of the peak              energy = fluo[key][layer][peak][&quot;energy&quot;]              # expected measured rate              rate = fluo[key][layer][peak][&quot;rate&quot;]              # primary photons (no attenuation and no detector considered)              primary = fluo[key][layer][peak][&quot;primary&quot;]              # secondary photons (no attenuation and no detector considered)              secondary = fluo[key][layer][peak][&quot;secondary&quot;]              # tertiary photons (no attenuation and no detector considered)              tertiary = fluo[key][layer][peak].get(&quot;tertiary&quot;, 0.0)              # correction due to secondary excitation              enhancement2 = (primary + secondary) / primary              enhancement3 = (primary + secondary + tertiary) / primary              print(&quot;%s   %s    %.4f     %.3g     %.5g    %.5g&quot; % \                                 (key, peak + (13 - len(peak)) * &quot; &quot;, energy,                                 rate, enhancement2, enhancement3))</longdescription>
</pkgmetadata>