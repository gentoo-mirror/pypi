<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>## tengu-pyBelow we’ll walk through the process of building and running a drugdiscovery workflow using tengu!First, install the following modules via pip - we require Python \&gt; 3.10    pip install tengu-py pdb-tools&lt;!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! --&gt;``` pythonimport jsonimport osimport sysimport tarfileimport base64from pdbtools import *import requestsfrom datetime import datetimefrom pathlib import Pathimport tengu```### 0) Setup``` python# Set our token - ensure you have exported TENGU_TOKEN in your shell; or just replace the os.getenv with your tokenTOKEN = os.getenv(&quot;TENGU_TOKEN&quot;)# You might have a custom deployment url, by default it will use https://tengu.qdx.aiURL = os.getenv(&quot;TENGU_URL&quot;) or &quot;https://tengu.qdx.ai&quot;`````` python# Define our project informationDESCRIPTION = &quot;tengu-py demo notebook&quot;TAGS = [&quot;qdx&quot;, &quot;tengu-py&quot;, &quot;demo&quot;, &quot;cdk2&quot;, &quot;atp&quot;, &quot;caps&quot;]WORK_DIR = Path.home() / &quot;qdx&quot; / &quot;tengu-py-demo&quot;OUT_DIR = WORK_DIR / &quot;runs&quot;OUT_DIR.mkdir(parents=True, exist_ok=True)MODULE_LOCK = WORK_DIR / &quot;lock.json&quot;# Set our inputsSYSTEM_PDB_PATH = WORK_DIR / &quot;test.pdb&quot;PROTEIN_PDB_PATH = WORK_DIR / &quot;test_P.pdb&quot;LIGAND_SMILES_STR = &quot;c1nc(c2c(n1)n(cn2)[C@H]3[C@@H]([C@@H]([C@H](O3)CO[P@@](=O)(O)O[P@](=O)(O)OP(=O)(O)O)O)O)N&quot;LIGAND_PDB_PATH = WORK_DIR / &quot;test_L.pdb&quot;`````` python# fetch datafilescomplex = list(pdb_fetch.fetch_structure(&quot;1B39&quot;))protein = pdb_delhetatm.remove_hetatm(pdb_selchain.select_chain(complex, &quot;A&quot;))ligand = pdb_keepcoord.keep_coordinates(pdb_rplresname.rename_residues(pdb_selresname.filter_residue_by_name(complex, &quot;ATP&quot;), &quot;ATP&quot;, &quot;UNL&quot;))with open(SYSTEM_PDB_PATH, 'w') as f:    for l in complex:        f.write(str(l))with open(PROTEIN_PDB_PATH, 'w') as f:    for l in protein:        f.write(str(l))with open(LIGAND_PDB_PATH, 'w') as f:    for l in ligand:        f.write(str(l))`````` python# Get our client, for calling modules and using the tengu APIclient = tengu.Provider(access_token=TOKEN, url=URL)`````` python# Get our latest modules as a dict[module_name, module_path]# If a lock file exists, load it so that the run is reproducableif MODULE_LOCK.exists():    modules = client.load_module_paths(MODULE_LOCK)else:     modules = client.get_latest_module_paths()    client.save_module_paths(modules, MODULE_LOCK)`````` pythonmodules[&quot;hermes_energy&quot;]```- `module_name` is a descriptive string and indicates the “function” the  module is calling;- `module_path` is a versioned tengu “endpoint” for a module accessible  via the client.Using the same `module_path` string across multiple runs providesreproducibility.The following is an example of how save and load frozen modules:``` pythonfrozen_modules_filepath = client.save_module_paths(modules)frozen_modules = client.load_module_paths(frozen_modules_filepath)assert(modules == frozen_modules)```You could save modules and provide a fixed string to load_module_paths:``` pythonFROZEN_MODULES_FILEPATH = 'tengu-modules-20231006T132244.json'frozen_modules = client.load_module_paths(FROZEN_MODULES_FILEPATH)```Below we’ll call modules using `client.run2()`.The parameters to `client.run2()` are as follows:- `module_path`: The endpoint of the module we’ll be running;- `args`: A list of the arguments to the module; an argument can be one  of the following:  1.  A `pathlib.Path` or a file-like object like `BufferedReader`,      `FileIO`, `StringIO` etc.:        Loads the data in the file as an argument.        **NOTE**: The uploaded value isn’t just the string of the file, so      don’t pass the string directly; pass the path or wrap in StringIO.  2.  An tengu ArgId returned by a previous call to `client.run2()`:        The `ArgId` type wraps data for use within tengu. It may refer to      an object already uploaded to tengu storage, such as outputs of      other run calls.        See below for more details. It’s easier to understand when you see      an example.  3.  A parameter, i.e. a value of any other type, including `None`:        Tengu modules take configs as json in the backend; we’ll convert      for you.        Just pass arguments directly, as per the schema for the module      you’re running.- `target`: The machine we want to run on (`NIX_SSH` for a cluster,  `GADI` for a supercomputer).- `resources`: The resources to use on the target.- `tags`: Tags to associate with our run, so we can easily look up our  runs.The return value is a dict that contains:- key `&quot;module_instance_id&quot;` -\&gt; val is a `ModuleInstanceId` for the run  itself;- key `&quot;output_ids&quot;` -\&gt; val is a list of `ArgId`s, one for each output.Both of these ID types have the form of a UUID. This ID lets youmanipulate the output of this module without having to:1.  Wait for the module to finish its computation, or2.  Download the actual value corresponding to this output.You can pass it to subsequent modules as if it were the value itself, oryou can wait on it to obtain the value itself.&gt; \[!NOTE\]  &gt; A coming improvement will provide explicit naming and type info for&gt; the inputs and outputs of each module, which will improve clarity and&gt; discoverability.### 1.1) Prep the protein``` pythonpdb2pqr_result = client.run2(    modules[&quot;prepare_protein_tengu&quot;],    [        PROTEIN_PDB_PATH,    ],    target=&quot;NIX_SSH_3&quot;,    resources={&quot;gpus&quot;: 1, &quot;storage&quot;: 1_024_000_000, &quot;walltime&quot;: 15},    tags=TAGS,    restore = True)pdb2pqr_run_id = pdb2pqr_result.get(&quot;module_instance_id&quot;)prepped_protein_id = pdb2pqr_result[&quot;output_ids&quot;][0]print(f&quot;{datetime.now().time()} | Running protein prep!&quot;)`````` pythonwith open(OUT_DIR / f&quot;01-pdb2pqr-{pdb2pqr_run_id}.json&quot;, &quot;w&quot;) as f:    json.dump(pdb2pqr_result, f, default=str, indent=2)`````` pythonclient.poll_module_instance(pdb2pqr_run_id)client.download_object(prepped_protein_id, OUT_DIR / &quot;01-prepped-protein.pdb&quot;)print(f&quot;{datetime.now().time()} | Downloaded prepped protein!&quot;)```### 1.2) Prep the ligand``` pythonligand_prep_config = {    &quot;source&quot;: &quot;&quot;,    &quot;output_folder&quot;: &quot;./&quot;,    &quot;job_manager&quot;: &quot;multiprocessing&quot;,    &quot;num_processors&quot;: -1,    &quot;max_variants_per_compound&quot;: 1,    &quot;thoroughness&quot;: 3,    &quot;separate_output_files&quot;: True,    &quot;min_ph&quot;: 6.4,    &quot;max_ph&quot;: 8.4,    &quot;pka_precision&quot;: 1.0,    &quot;skip_optimize_geometry&quot;: True,    &quot;skip_alternate_ring_conformations&quot;: True,    &quot;skip_adding_hydrogen&quot;: False,    &quot;skip_making_tautomers&quot;: True,    &quot;skip_enumerate_chiral_mol&quot;: True,    &quot;skip_enumerate_double_bonds&quot;: True,    &quot;let_tautomers_change_chirality&quot;: False,    &quot;use_durrant_lab_filters&quot;: True,}ligand_prep_result = client.run2(    modules[&quot;prepare_ligand_tengu&quot;],    [        LIGAND_SMILES_STR,        LIGAND_PDB_PATH,        ligand_prep_config,    ],    target=&quot;NIX_SSH_3&quot;,    resources={&quot;gpus&quot;: 1, &quot;storage&quot;: 16 * 1024, &quot;walltime&quot;: 5},    tags=TAGS,    restore=True)ligand_prep_run_id = ligand_prep_result[&quot;module_instance_id&quot;]prepped_ligand_pdb_id = ligand_prep_result[&quot;output_ids&quot;][0]prepped_ligand_sdf_id = ligand_prep_result[&quot;output_ids&quot;][1]print(f&quot;{datetime.now().time()} | Running ligand prep!&quot;)`````` pythonwith open(OUT_DIR / f&quot;01-prepare-ligand-{ligand_prep_run_id}.json&quot;, &quot;w&quot;) as f:    json.dump(ligand_prep_result, f, default=str, indent=2)`````` pythonprint(&quot;Checking ligand prep instance&quot;, ligand_prep_run_id)client.poll_module_instance(ligand_prep_run_id)client.download_object(prepped_ligand_pdb_id, OUT_DIR / &quot;01-prepped-ligand.pdb&quot;)client.download_object(prepped_ligand_sdf_id, OUT_DIR / &quot;01-prepped-ligand.sdf&quot;)print(f&quot;{datetime.now().time()} | Downloaded prepped ligand!&quot;)```### 2) Run GROMACS (module: gmx_tengu / gmx_tengu_pdb)``` pythongmx_config = {    &quot;param_overrides&quot;: {        &quot;md&quot;: [(&quot;nsteps&quot;, &quot;5000&quot;)],        &quot;em&quot;: [(&quot;nsteps&quot;, &quot;1000&quot;)],        &quot;nvt&quot;: [(&quot;nsteps&quot;, &quot;1000&quot;)],        &quot;npt&quot;: [(&quot;nsteps&quot;, &quot;1000&quot;)],        &quot;ions&quot;: [],    },    &quot;num_gpus&quot;: 0,    &quot;num_replicas&quot;: 1,    &quot;ligand_charge&quot;: None,    &quot;frame_sel&quot;: {        &quot;begin_time&quot;: 1,        &quot;end_time&quot;: 10,        &quot;delta_time&quot;: 2,    },}gmx_result = client.run2(    # TODO: Should be using qdxf conformer verions of these modules    modules[&quot;gmx_tengu_pdb&quot;],    [        prepped_protein_id,        prepped_ligand_pdb_id,        gmx_config,    ],    target=&quot;NIX_SSH_3&quot;,    resources={&quot;gpus&quot;: 0, &quot;storage&quot;: 1, &quot;storage_units&quot;: &quot;GB&quot;, &quot;cpus&quot;: 48, &quot;walltime&quot;: 60},    tags=TAGS,    restore=True)gmx_run_id = gmx_result[&quot;module_instance_id&quot;]gmx_output_id = gmx_result[&quot;output_ids&quot;][0]gmx_ligand_gro_id = gmx_result[&quot;output_ids&quot;][3]print(f&quot;{datetime.now().time()} | Running GROMACS simulation!&quot;)`````` pythonwith open(OUT_DIR / f&quot;02-gmx-{gmx_run_id}.json&quot;, &quot;w&quot;) as f:    json.dump(gmx_result, f, default=str, indent=2)`````` pythonprint(&quot;Fetching gmx results&quot;, gmx_run_id)client.poll_module_instance(gmx_run_id, n_retries=60, poll_rate=60)client.download_object(gmx_output_id, OUT_DIR / &quot;02-gmx-output.tar.gz&quot;)print(f&quot;{datetime.now().time()} | Downloaded GROMACS output!&quot;)`````` python# Extract the &quot;dry&quot; (i.e. non-solvated) frames we asked forwith tarfile.open(OUT_DIR / &quot;02-gmx-output.tar.gz&quot;, &quot;r&quot;) as tf:    selected_frame_pdbs = [        tf.extractfile(member).read()        for member in sorted(tf, key=lambda m: m.name)        if (&quot;dry&quot; in member.name and &quot;pdb&quot; in member.name)    ]    for i, frame in enumerate(selected_frame_pdbs):        with open(OUT_DIR/f&quot;02-gmx-output-frame{i}.pdb&quot;, &quot;w&quot;) as pf:            print(frame.decode(&quot;utf-8&quot;), file=pf)    gmx_gro_base64_str = base64.b64encode(tf.extractfile([f for f in tf if f.name == &quot;outputs/ligand_in_GMX.gro&quot;][0]).read()).decode(&quot;utf-8&quot;)#client.download_object(gmx_ligand_gro_id, OUT_DIR / &quot;02-gmx-ligand.gro&quot;)pdb_base64_str = base64.b64encode(selected_frame_pdbs[0]).decode(&quot;utf-8&quot;)```### 3.1) Run quantum energy calculation (modules: qp_gen_inputs, hermes_energy, qp_collate)``` python# We have a helper function for this, as it combines 3 modules without much need# to inspect the intermediate results.(_, _, qp_result) = client.run_qp(    modules[&quot;qp_gen_inputs&quot;],    modules[&quot;hermes_energy&quot;],    modules[&quot;qp_collate&quot;],    pdb=tengu.Arg(value=pdb_base64_str),    gro=tengu.Arg(value=gmx_gro_base64_str),    lig=tengu.Arg(id= str(prepped_ligand_sdf_id)),    lig_type=tengu.Arg(value=&quot;sdf&quot;),    lig_res_id=tengu.Arg(value=&quot;UNL&quot;),  # The ligand's residue code in the PDB file; this is what our prep uses    use_new_fragmentation_method=False,    target=&quot;NIX_SSH_3&quot;,    resources={&quot;storage&quot;: 1_024_000_000, &quot;walltime&quot;: 600},    tags=TAGS,    restore=True)qp_run_id = qp_result[&quot;module_instance_id&quot;]qp_interaction_energy_id = qp_result[&quot;output_ids&quot;][0]print(f&quot;{datetime.now().time()} | Running QP energy calculation!&quot;)`````` pythonwith open(OUT_DIR / f&quot;03-qp-{qp_run_id}.json&quot;, &quot;w&quot;) as f:    json.dump(qp_result, f, default=str, indent=2)`````` pythonclient.poll_module_instance(qp_run_id)client.download_object(qp_interaction_energy_id, OUT_DIR / &quot;03-qp-interaction-energy.json&quot;)print(f&quot;{datetime.now().time()} | Downloaded qp interaction energy!&quot;)```### 3.2) Run MM-PBSA``` pythonmmpbsa_config = {    &quot;start_frame&quot;: 1,    &quot;end_frame&quot;: 2,    &quot;num_cpus&quot;: 1,  # cannot be greater than number of frames}mmpbsa_result = client.run2(    modules[&quot;gmx_mmpbsa_tengu&quot;],    [        gmx_output_id,        mmpbsa_config,    ],    target=&quot;GADI&quot;,    resources={&quot;storage&quot;: 100, &quot;storage_units&quot;: &quot;MB&quot;, &quot;walltime&quot;: 600},    tags=TAGS,    restore=True)mmpbsa_run_id = mmpbsa_result[&quot;module_instance_id&quot;]mmpbsa_output_id = mmpbsa_result[&quot;output_ids&quot;][0]print(f&quot;{datetime.now().time()} | Running GROMACS MM-PBSA calculation!&quot;)`````` pythonwith open(OUT_DIR / f&quot;03-mmpbsa-{mmpbsa_run_id}.json&quot;, &quot;w&quot;) as f:    json.dump(mmpbsa_result, f, default=str, indent=2)`````` pythonclient.poll_module_instance(mmpbsa_run_id)client.download_object(mmpbsa_output_id, OUT_DIR / &quot;03-mmpbsa-output.zip&quot;)print(f&quot;{datetime.now().time()} | Downloaded MM-PBSA results!&quot;)```</longdescription>
</pkgmetadata>