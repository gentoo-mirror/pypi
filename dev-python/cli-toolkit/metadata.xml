<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![Unit Tests](https://github.com/hile/cli-toolkit/actions/workflows/unittest.yml/badge.svg)![Style Checks](https://github.com/hile/cli-toolkit/actions/workflows/lint.yml/badge.svg)# CLI toolkit for shell command utilitiesThis module contains modules to implement CLI scripts by wrappingpython argparse.ArgumentParser to user friendly utility classes.## Create a script classMain class to use is the Script class. It will get it's name fromsys.argv[0].Example:```pythonfrom cli_toolkit.script import Scriptif __name__ == '__main__':    script = Script()    script.add_argument('files', nargs='*', help='Files to process')    args = script.parse_args()    for filename in args.files:        script.debug('PROCESSING', filename)        script.message(filename)```Running the example:```&gt; python test.py foo barfoobar```This is pretty straightforward ArgumentParser, except it* sets SIGINT handler* adds --debug and --quiet flags* adds `debug` and `message` functions which honor the debug and quiet flags## Using script with subcommandsMore useful is using a script with subcommands. The subcommands requireat least `name` class variable and should have `usage`, `description` and`epilog`.You also should implement `run` method and call script.run() to run correctsubcommand. Arguments for subcommand parser are registered with method`register_parser_arguments`.```pythonfrom cli_toolkit.script import Scriptfrom cli_toolkit.command import Commandclass ListCommand(Command):    name = 'list'    usage = 'List files'    description = 'Lists files specified on command line'    def register_parser_arguments(self, parser):        parser.add_argument('files', nargs='*', help='Files to process')    def run(self, args):        for filename in args.files:            self.debug('PROCESSING', filename)            self.message(filename)if __name__ == '__main__':    script = Script()    script.add_subcommand(ListCommand(script))    script.run()```Running the example:```bash&gt; python test.py list foo barfoobar```## Using nested subcommandsThe subcommands can be nested. You need to pass the parser in paren'tregister_parser_subcommand to add_subcommand.```pythonfrom cli_toolkit.script import Scriptfrom cli_toolkit.command import Commandclass FilesCommand(Command):    name = 'demo'    usage = 'Run nested demo subcommands'    def register_parser_arguments(self, parser):        &quot;&quot;&quot;        Register 'list' command under demo subcommand        &quot;&quot;&quot;        self.add_subcommand(ListCommand(self), parser)        return parserclass ListCommand(Command):    name = 'list'    usage = 'List files'    description = 'Lists files specified on command line'    def register_parser_arguments(self, parser):        &quot;&quot;&quot;        Register 'list' command arguments        &quot;&quot;&quot;        parser.add_argument('files', nargs='*', help='Files to process')        return parser    def run(self, args):        if not args.files:            self.exit(1, 'No files provided')        for filename in args.files:            self.debug('PROCESSING', filename)            self.message(filename)if __name__ == '__main__':    script = Script()    script.add_subcommand(FilesCommand(script))    script.run()```Running the example:```bash&gt; python test.py demo list foo barfoobar```</longdescription>
</pkgmetadata>