<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Django Magic LinkOpinionated Django app for managing &quot;magic link&quot; logins.**WARNING**If you send a login link to the wrong person, they will gain full access to the user's account. Usewith extreme caution, and do not use this package without reading the source code and ensuring thatyou are comfortable with it. If you have an internal security team, ask them to look at it beforeusing it. If your clients have security sign-off on your application, ask them to look at it beforeusing it.**/WARNING**This app is not intended for general purpose URL tokenisation; it is designed to support a singleuse case - so-called &quot;magic link&quot; logins.There are lots of alternative apps that can support this use case, including the project from whichthis has been extracted -[`django-request-token`](https://github.com/yunojuno/django-request-token). The reason for yetanother one is to handle the real-world challenge of URL caching / pre-fetch, where intermediariesuse URLs with unintended consequences.This packages supports a very specific model:1. User is sent a link to log them in automatically.2. User clicks on the link, and which does a GET request to the URL.3. User is presented with a confirmation page, but is _not_ logged in.4. User clicks on a button and performs a POST to the same page.5. The POST request authenticates the user, and deactivates the token.The advantage of this is the email clients do not support POST links, and any prefetch that attemptsa POST will fail the CSRF checks.The purpose is to ensure that someone actively, purposefully, clicked on a link to authenticatethemselves. This enables instant deactivation of the token, so that it can no longer be used.In practice, without this check, valid magic links may be requested a number of times via GETrequest before the intended recipient even sees the link. If you use a &quot;max uses&quot; restriction tolock down the link you may find this limit is hit, and the end user then finds that the link isinactive. The alternative to this is to remove the use limit and rely instead on an expiry window.This risks leaving the token active even after the user has logged in. This package is targeted atthis situation.## Use### Prerequisite: Update settings.py and urls.pyAdd `magic_link` to INSTALLED_APPS in settings.py:```pythonINSTALLED_APPS = [    ...    'magic_link',]```Add the `magic_link` urls to urls.py:```pythonfrom magic_link import urls as magic_link_urlsurlpatterns = [    ...    url(r'^magic_link/', include(magic_link_urls)),]```### Prerequisite: Override the default templates.This package has two HTML templates that must be overridden in your local application.**templates/magic_link/logmein.html**This is the landing page that a user sees when they click on the magic link. You can add any contentyou like to this page - the only requirement is that must contains a simple form with a csrf tokenand a submit button. This form must POST back to the link URL. The template render context includesthe `link` which has a `get_absolute_url` method to simplify this:```html&lt;form method=&quot;POST&quot; action=&quot;{{ link.get_absolute_url }}&quot;&gt;    {% csrf_token %}    &lt;button type=&quot;submit&quot;&gt;Log me in&lt;/button&gt;&lt;/form&gt;```**templates/magic_link/error.html**If the link has expired, been used, or is being accessed by someone who is already logged in, thenthe `error.html` template will be rendered. The template context includes `link` and `error`.```html&lt;p&gt;Error handling magic link {{ link }}: {{ error }}.&lt;/p&gt;```### 1. Create a new login linkThe first step in managing magic links is to create one. Links are bound to a user, and can have acustom post-login redirect URL.```python# create a link with the default expiry and redirectlink = MagicLink.objects.create(user=user)# create a link with a specific redirectlink = MagicLink.objects.create(user=user, redirect_to=&quot;/foo&quot;)# construct a full URL from a MagicLink object and a Django HttpResponseurl = request.build_absolute_uri(link.get_absolute_url())```### 2. Send the link to the userThis package does not handle the sending on your behalf - it is your responsibility to ensure thatyou send the link to the correct user. If you send the link to the wrong user, they will have fullaccess to the link user's account. **YOU HAVE BEEN WARNED**.## AuditingA core requirement of this package is to be able to audit the use of links - for monitoring andanalysis. To enable this we have a second model, `MagicLinkUse`, and we create a new object forevery request to a link URL, _regardless of outcome_. Questions that we want to have answers forinclude:-   How long does it take for users to click on a link?-   How many times is a link used before the POST login?-   How often is a link used _after_ a successful login?-   How often does a link expire before a successful login?-   Can we identify common non-user client requests (email caches, bots, etc)?-   Should we disable links after X non-POST requests?In order to facilitate this analysis we denormalise a number of timestamps from the `MagicLinkUse`object back onto the `MagicLink` itself:-   `created_at` - when the record was created in the database-   `accessed_at` - the first GET request to the link URL-   `logged_in_at` - the successful POST-   `expires_at` - the link expiry, set when the link is created.Note that the expiry timestamp is **not** updated when the link is used. This is by design, toretain the original expiry timestamp.### Link validationIn addition to the timestamp fields, there is a separate boolean flag, `is_active`. This acts as a&quot;kill switch&quot; that overrides any other attribute, and it allows a link to be disabled without havingto edit (or destroy) existing timestamp values. You can deactivate all links in one hit by calling`MagicLink.objects.deactivate()`.A link's `is_valid` property combines both `is_active` and timestamp data to return a bool valuethat defines whether a link can used, based on the following criteria:1. The link is active (`is_active`)2. The link has not expired (`expires_at`)3. The link has not already been used (`logged_in_at`)In addition to checking the property `is_valid`, the `validate()` method will raise an exceptionbased on the specific condition that failed. This is used by the link view to give feedback to theuser on the nature of the failure.### Request authorizationIf the link's `is_valid` property returns `True`, then the link _can_ be used. However, this doesnot mean that the link can be used by anyone. We do not allow authenticated users to login usingsomeone else's magic link. The `authorize()` method takes a `User` argument and determines whetherthey are authorized to use the link. If the user is authenticated, and does not match the`link.user`, then a `PermissionDenied` exception is raised.### Putting it togetherCombining the validation, authorization and auditing, we get a simplified flow that looks somethinglike this:```pythondef get(request, token):    &quot;&quot;&quot;Render login page.&quot;&quot;&quot;    link = get_object_or_404(MagicLink, token=token)    link.validate()    link.authorize(request.user)    link.audit()    return render(&quot;logmein.html&quot;)def post(request, token):    &quot;&quot;&quot;Handle the login POST.&quot;&quot;&quot;    link = get_object_or_404(MagicLink, token=token)    link.validate()    link.authorize(request.user)    link.login(request)    link.disable()    return redirect(link.redirect_to)```## SettingsSettings are read from a `django.conf.settings` settings dictionary called `MAGIC_LINK`.Default settings show below:```python# settings.pyMAGIC_LINK = {    # link expiry, in seconds    &quot;DEFAULT_EXPIRY&quot;: 300,    # default link redirect    &quot;DEFAULT_REDIRECT&quot;: &quot;/&quot;,    # the preferred authorization backend to use, in the case where you have more    # than one specified in the `settings.AUTHORIZATION_BACKENDS` setting.    &quot;AUTHENTICATION_BACKEND&quot;: &quot;django.contrib.auth.backends.ModelBackend&quot;,    # SESSION_COOKIE_AGE override for magic-link logins - in seconds (default is 1 week)    &quot;SESSION_EXPIRY&quot;: 7 * 24 * 60 * 60}```## Screenshots**Default landing page (`logmein.html`)**&lt;img src=&quot;https://raw.githubusercontent.com/yunojuno/django-magic-link/master/screenshots/landing-page.png&quot; width=600 alt=&quot;Screenshot of default landing page&quot; /&gt;**Default error page (`error.html`)**&lt;img src=&quot;https://raw.githubusercontent.com/yunojuno/django-magic-link/master/screenshots/error-page.png&quot; width=600 alt=&quot;Screenshot of default error page&quot; /&gt;**Admin view of magic link uses**&lt;img src=&quot;https://raw.githubusercontent.com/yunojuno/django-magic-link/master/screenshots/admin-inline.png&quot; width=600 alt=&quot;Screenshot of MagicLinkUseInline&quot; /&gt;</longdescription>
</pkgmetadata>