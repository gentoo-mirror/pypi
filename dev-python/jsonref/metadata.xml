<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># jsonref[![image](https://github.com/gazpachoking/jsonref/actions/workflows/test.yml/badge.svg?branch=master)](https://github.com/gazpachoking/jsonref/actions/workflows/test.yml?query=branch%3Amaster)[![image](https://readthedocs.org/projects/jsonref/badge/?version=latest)](https://jsonref.readthedocs.io/en/latest/)[![image](https://coveralls.io/repos/gazpachoking/jsonref/badge.png?branch=master)](https://coveralls.io/r/gazpachoking/jsonref)[![image](https://img.shields.io/pypi/v/jsonref?color=%2334D058&amp;label=pypi%20package)](https://pypi.org/project/jsonref)`jsonref` is a library for automatic dereferencing of [JSONReference](https://datatracker.ietf.org/doc/html/draft-pbryan-zyp-json-ref-03)objects for Python (supporting Python 3.7+).This library lets you use a data structure with JSON reference objects,as if the references had been replaced with the referent data.```python console&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt; import jsonref&gt;&gt;&gt; # An example json document&gt;&gt;&gt; json_str = &quot;&quot;&quot;{&quot;real&quot;: [1, 2, 3, 4], &quot;ref&quot;: {&quot;$ref&quot;: &quot;#/real&quot;}}&quot;&quot;&quot;&gt;&gt;&gt; data = jsonref.loads(json_str)&gt;&gt;&gt; pprint(data)  # Reference is not evaluated until here{'real': [1, 2, 3, 4], 'ref': [1, 2, 3, 4]}```# Features-   References are evaluated lazily. Nothing is dereferenced until it is    used.-   Recursive references are supported, and create recursive python data    structures.References objects are actually replaced by lazy lookup proxy objectswhich are almost completely transparent.```python console&gt;&gt;&gt; data = jsonref.loads('{&quot;real&quot;: [1, 2, 3, 4], &quot;ref&quot;: {&quot;$ref&quot;: &quot;#/real&quot;}}')&gt;&gt;&gt; # You can tell it is a proxy by using the type function&gt;&gt;&gt; type(data[&quot;real&quot;]), type(data[&quot;ref&quot;])(&lt;class 'list'&gt;, &lt;class 'jsonref.JsonRef'&gt;)&gt;&gt;&gt; # You have direct access to the referent data with the __subject__&gt;&gt;&gt; # attribute&gt;&gt;&gt; type(data[&quot;ref&quot;].__subject__)&lt;class 'list'&gt;&gt;&gt;&gt; # If you need to get at the reference object&gt;&gt;&gt; data[&quot;ref&quot;].__reference__{'$ref': '#/real'}&gt;&gt;&gt; # Other than that you can use the proxy just like the underlying object&gt;&gt;&gt; ref = data[&quot;ref&quot;]&gt;&gt;&gt; isinstance(ref, list)True&gt;&gt;&gt; data[&quot;real&quot;] == refTrue&gt;&gt;&gt; ref.append(5)&gt;&gt;&gt; del ref[0]&gt;&gt;&gt; # Actions on the reference affect the real data (if it is mutable)&gt;&gt;&gt; pprint(data){'real': [2, 3, 4, 5], 'ref': [2, 3, 4, 5]}```</longdescription>
</pkgmetadata>