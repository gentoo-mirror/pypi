<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;div align=&quot;center&quot;&gt;  &lt;h1 align=&quot;center&quot;&gt;gql_schema_codegen&lt;/h1&gt;  &lt;h4 align=&quot;center&quot;&gt;Easily generate Python typings from a GrapqhQL schema.&lt;/h4&gt;&lt;/div&gt;&lt;div align=&quot;center&quot;&gt;  &lt;a align=&quot;center&quot; href=&quot;https://github.com/sauldom102?tab=followers&quot;&gt;    &lt;img src=&quot;https://img.shields.io/github/followers/sauldom102?label=Follow%20%40sauldom102&amp;style=social&quot; /&gt;  &lt;/a&gt;&lt;/div&gt;&lt;br /&gt;Let's go straight to the point, here you can see a very simple input schema content and its corresponding output:&lt;details&gt;&lt;summary&gt;&lt;b&gt;Input GraphQL schema&lt;/b&gt;&lt;/summary&gt;```graphqlschema {  query: Query  mutation: Mutation}enum UserType {  STAFF  ADMIN}type User {  id: ID!  email: String  username: String!  first_name: String!  last_name: String!  full_name: String!  dob: String @date(format: &quot;%Y-%m-%d&quot;)  type: UserType!  people: [String]}type Query {  me: User!}input SignUpInput {  email: String!  username: String!  first_name: String!  last_name: String!  password: String!}input LoginInput {  identifier: String!  password: String!}type Mutation {  login(input: LoginInput!): User!  signUp(input: SignUpInput!): User!  logout: Boolean}```&lt;/details&gt;&lt;details&gt;  &lt;summary&gt;&lt;b&gt;Output Python typings&lt;/b&gt;&lt;/summary&gt;```pythonfrom enum import Enumfrom typing import ClassVar, List, Optional, TypedDictUserType = Enum('UserType', 'STAFF ADMIN')User = TypedDict('User', {  'id': str,  'email': Optional[str],  'username': str,  'first_name': str,  'last_name': str,  'full_name': str,  'dob': Optional[str],  'type': 'UserType',  'people': Optional[List[str]],})Query = TypedDict('Query', {  'me': 'MeQueryResult',})MeQueryResult = ClassVar['User']Mutation = TypedDict('Mutation', {  'login': 'LoginMutationResult',  'signUp': 'SignUpMutationResult',  'logout': 'LogoutMutationResult',})LoginParams = TypedDict('LoginParams', {  'input': 'LoginInput',})LoginMutationResult = ClassVar['User']SignUpParams = TypedDict('SignUpParams', {  'input': 'SignUpInput',})SignUpMutationResult = ClassVar['User']LogoutMutationResult = boolSignUpInput = TypedDict('SignUpInput', {  'email': str,  'username': str,  'first_name': str,  'last_name': str,  'password': str,})LoginInput = TypedDict('LoginInput', {  'identifier': str,  'password': str,})```&lt;/details&gt;There are some more complex examples available under [tests](tests) if you are curious about how accurate is this tool.## MotivationWhile I was trying out [Ariadne](https://ariadnegraphql.org/) (a library for implementing GraphQL servers using schema-first approach) and writing the resolvers for the queries and mutations that I defined in my GraphQL schema, I was missing the ability to define the types for the params and the return values.I hope this library helps some devs to write better typed resolvers for their projects, while keeping the resolvers code synced with the schema definition.&lt;details&gt;  &lt;summary&gt;&lt;b&gt;Ariadne example with typed resolvers&lt;/b&gt;&lt;/summary&gt;    ```pythonfrom typing_extensions import Unpackfrom graphql import GraphQLResolveInfofrom ..snapshots.test_schema import LoginParams, LoginMutationResult, MeQueryResult, SignUpParams, SignUpMutationResult, LogoutMutationResult, User, UserTypefrom ariadne import QueryType, MutationTypemocked_user: User = {    'id': '1',    'email': 'saulydominguez@gmail.com',    'dob': '28/05/1999',    'first_name': 'Saul',    'last_name': 'Dominguez',    'full_name': 'Saul Dominguez',    'username': 'saulydominguez',    'people': [],    'type': UserType.ADMIN}query = QueryType()@query.field('me')def resolve_me(obj, info: GraphQLResolveInfo) -&gt; MeQueryResult:    # implementation to obtain current user    return mocked_usermutation = MutationType()@mutation.field('login')def resolve_login(_, info: GraphQLResolveInfo, **params: Unpack[LoginParams]) -&gt; LoginMutationResult:    _input = params['input']    # you can use typed _input var down here    # login implementation    return mocked_user@mutation.field('signUp')def resolve_sign_up(_, info: GraphQLResolveInfo, **params: Unpack[SignUpParams]) -&gt; SignUpMutationResult:    # login implementation    return mocked_user@mutation.field('logout')def resolve_logout(_, info: GraphQLResolveInfo) -&gt; LogoutMutationResult:    # logout implementation    return True```&lt;/details&gt;## InstallationYou can easily install it via pip:```bash$ pip install gql_schema_codegen```## UsageThree use cases depending on where the GraphQL schema is defined:### 1. Generate types from a single schema fileThis is the simplest case, you have just a single file with all the types declared there.```bash$ python -m gql_schema_codegen -p ./schema.graphql -t ./schema_types.py```###  2. Generate types from a remote GraphQL serverYou have deployed a GraphQL server with introspection enabled, you can just provide a link to that server and this tool will do its job.```bash$ python -m gql_schema_codegen -u https://gitlab.com/api/graphql -t ./schema_types.py```⚠️ For now, it only works with public schemas, without any authentication required. I will be adding support for this soon.###  3. Generate types from different schema files in a directoryIt's a common thing that you don't have your schema definition centralized in a single file but in multiple ones instead, if that's your case you can provide that directory path where all the graphql/gql files are located and this tool will find them and merge them into a single schema to process it later on.```bash$ python -m gql_schema_codegen -p ./dir_with_gql_types -t ./schema_types.py```If you just need more info about how to run it:```bash$ python -m gql_schema_codegen --helpusage: __main__.py [-h] [--schema-path SCHEMA_PATH] [--schema-url SCHEMA_URL] [--to-path TO_PATH] [--config-file CONFIG_FILE]Generate python file with types from a GraphQL schema file.optional arguments:  -h, --help            show this help message and exit  --schema-path SCHEMA_PATH, -p SCHEMA_PATH                        path of the schema file (default: schema.graphql)  --schema-url SCHEMA_URL, -u SCHEMA_URL                        url of the schema  --to-path TO_PATH, -t TO_PATH                        wanted output file path (default: schema_types.py)  --config-file CONFIG_FILE, -c CONFIG_FILE                        path of the config file in yaml format (default: gql_schema_codegen.config.yml)```#### Custom scalars supportBy default, scalars found in your schema will be generated as `Any`, if you already know the types for these scalars you can create a custom config file and define these types there:```yamlscalars:  DateTime: str  Time: str  BigInt: int  BoardID: int  Duration: DesignFields```Notice how you can also set another type from your schema (or a Python class) as custom value for your scalar.## TestsThey are simple snapshot tests, they work by comparing the output with the expected output, each test corresponds to a file stored under `tests/snapshots`.You will find different tests declared in the `tests` directory.If you want to run them you need to install the [`pytest-snapshot`](https://pypi.org/project/pytest-snapshot/) module first. Then, you can run them with:```bash$ pytest --snapshot-update```You can also run a specific test this way:```bash$ pytest --snapshot-update -k &quot;test_pokeapi_schema_snapshot&quot;```##  ContributionFeel free to open some issues and/or pull requests if you want to participate in the development of this module, either just by proposing changes or by actively participating with code. At the moment of writing this, I have at least a couple of ideas planned to improve the way this generator works. ✨## SupportIf you like the work I do and want to support me, you can do it below:&lt;a href=&quot;https://www.buymeacoffee.com/sauldom102&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png&quot; alt=&quot;Buy Me A Coffee&quot; style=&quot;height: 60px !important;width: 217px !important;&quot; &gt;&lt;/a&gt;##  LicenseMIT</longdescription>
</pkgmetadata>