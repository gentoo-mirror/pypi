<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>==============HTML sanitizer==============This is a allowlist-based and very opinionated HTML sanitizer thatcan be used both for untrusted and trusted sources. It attempts to cleanup the mess made by various rich text editors and or copy-pasting tomake styling of webpages simpler and more consistent. It builds on theexcellent HTML cleaner in lxml_ to make the result both valid and safe.HTML sanitizer goes further than e.g. bleach_ in that it not onlyensures that content is safe and tags and attributes conform to a givenallowlist, but also applies additional transforms to HTML fragments.Goals=====- Clean up HTML fragments using a very restricted set of allowed tags  and attributes.- Convert *some* tags (such as ``&lt;span style=&quot;...&quot;&gt;``, ``&lt;b&gt;`` and  ``&lt;i&gt;``) into either ``&lt;strong&gt;`` or ``&lt;em&gt;`` (but never both).- Absolutely disallow all inline styles.- Normalize whitespace by removing repeated line breaks, empty  paragraphs and other empty elements.- Merge adjacent tags of the same type (such as several ``&lt;strong&gt;`` or  ``&lt;h3&gt;`` directly after each other.- Automatically remove redundant list markers inside ``&lt;li&gt;`` tags.- Clean up some uglyness such as paragraphs inside paragraphs or list  elements etc.- Normalize unicode.Usage=====    &gt;&gt;&gt; from html_sanitizer import Sanitizer    &gt;&gt;&gt; sanitizer = Sanitizer()  # default configuration    &gt;&gt;&gt; sanitizer.sanitize('&lt;span style=&quot;font-weight:bold&quot;&gt;some text&lt;/span&gt;')    '&lt;strong&gt;some text&lt;/strong&gt;'Settings========- Bold spans and ``b`` tags are converted into ``strong`` tags, italic  spans and ``i`` tags into ``em`` tags (if ``strong`` and ``em`` are  allowed at all)- Inline styles and scripts will always be dropped.- A ``div`` element is used to wrap the HTML fragment for the parser,  therefore ``div`` tags are not allowed.The default settings are::    DEFAULT_SETTINGS = {        &quot;tags&quot;: {            &quot;a&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;strong&quot;, &quot;em&quot;, &quot;p&quot;, &quot;ul&quot;, &quot;ol&quot;,            &quot;li&quot;, &quot;br&quot;, &quot;sub&quot;, &quot;sup&quot;, &quot;hr&quot;,        },        &quot;attributes&quot;: {&quot;a&quot;: (&quot;href&quot;, &quot;name&quot;, &quot;target&quot;, &quot;title&quot;, &quot;id&quot;, &quot;rel&quot;)},        &quot;empty&quot;: {&quot;hr&quot;, &quot;a&quot;, &quot;br&quot;},        &quot;separate&quot;: {&quot;a&quot;, &quot;p&quot;, &quot;li&quot;},        &quot;whitespace&quot;: {&quot;br&quot;},        &quot;keep_typographic_whitespace&quot;: False,        &quot;add_nofollow&quot;: False,        &quot;autolink&quot;: False,        &quot;sanitize_href&quot;: sanitize_href,        &quot;element_preprocessors&quot;: [            # convert span elements into em/strong if a matching style rule            # has been found. strong has precedence, strong &amp; em at the same            # time is not supported            bold_span_to_strong,            italic_span_to_em,            tag_replacer(&quot;b&quot;, &quot;strong&quot;),            tag_replacer(&quot;i&quot;, &quot;em&quot;),            tag_replacer(&quot;form&quot;, &quot;p&quot;),            target_blank_noopener,        ],        &quot;element_postprocessors&quot;: [],        &quot;is_mergeable&quot;: lambda e1, e2: True,    }The keys' meaning is as follows:- ``tags``: A ``set()`` of allowed tags.- ``attributes``: A ``dict()`` mapping tags to their allowed attributes.- ``empty``: Tags which are allowed to be empty. By default, empty tags  (containing no text or only whitespace) are dropped.- ``separate``: Tags which are not merged if they appear as siblings. By  default, tags of the same type are merged.- ``whitespace``: Tags which are treated as whitespace and removed from  the beginning or end of other tags' content.- ``keep_typographic_whitespace``: Keep typographically used space  characters like non-breaking space etc.- ``add_nofollow``: Whether to add ``rel=&quot;nofollow&quot;`` to all links.- ``autolink``: Enable lxml_'s autolinker_. May be either a boolean or a  dictionary; a dictionary is passed as keyword arguments to  ``autolink``.- ``sanitize_href``: A callable that gets anchor's ``href`` value and  returns a sanitized version. The default implementation checks whether  links start with a few allowed prefixes, and if not, returns a single  hash (``#``).- ``element_preprocessors`` and ``element_postprocessors``: Additional  filters that are called on all elements in the tree. The tree is  processed in reverse depth-first order. Under certain circumstances  elements are processed more than once (search the code for  ``backlog.append``). Preprocessors are run before whitespace  normalization, postprocessors afterwards.- ``is_mergeable``: Adjacent elements which aren't kept ``separate`` are  merged by default. This callable can be used to prevent merging of  adjacent elements e.g. when their classes do not match  (``lambda e1, e2: e1.get('class') == e2.get('class')``)Settings can be specified partially when initializing a sanitizerinstance, but are still checked for consistency. For example, it is notallowed to have tags in ``empty`` that are not in ``tags``, that is,tags that are allowed to be empty but at the same time not allowed atall. The ``Sanitizer`` constructor raises ``TypeError`` exceptions whenit detects inconsistencies.An example for an even more restricted configuration might be::    &gt;&gt;&gt; from html_sanitizer import Sanitizer    &gt;&gt;&gt; sanitizer = Sanitizer({    ...     'tags': ('h1', 'h2', 'p'),    ...     'attributes': {},    ...     'empty': set(),    ...     'separate': set(),    ... })The rationale for such a restricted set of allowed tags (e.g. noimages) is documented in the `design decisions`_ section ofdjango-content-editor_'s documentation.Django======HTML sanitizer does not depend on Django, but ships with a module whichmakes configuring sanitizers using Django settings easier. Usage is asfollows::    &gt;&gt;&gt; from html_sanitizer.django import get_sanitizer    &gt;&gt;&gt; sanitizer = get_sanitizer([name=...])Different sanitizers can be configured. The default configuration isaptly named ``'default'``. Example settings follow::    HTML_SANITIZERS = {        'default': {          'tags': ...,        },        ...    }The ``'default'`` configuration is special: If it isn't explicitlydefined, the default configuration above is used instead. Non-existingconfigurations will lead to ``ImproperlyConfigured`` exceptions.The ``get_sanitizer`` function caches sanitizer instances, so feel freeto call it as often as you want to.Security issues===============Please report security issues to me directly at mk@feinheit.ch... _bleach: https://bleach.readthedocs.io/.. _Django: https://www.djangoproject.com/.. _django-content-editor: http://django-content-editor.readthedocs.io/.. _FeinCMS: https://pypi.python.org/pypi/FeinCMS.. _feincms-cleanse: https://pypi.python.org/pypi/feincms-cleanse.. _design decisions: http://django-content-editor.readthedocs.io/en/latest/#design-decisions.. _lxml: http://lxml.de/.. _autolinker: http://lxml.de/api/lxml.html.clean-module.html</longdescription>
</pkgmetadata>