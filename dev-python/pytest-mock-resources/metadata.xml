<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![CircleCI](https://img.shields.io/circleci/build/gh/schireson/pytest-mock-resources/master)[![codecov](https://codecov.io/gh/schireson/pytest-mock-resources/branch/master/graph/badge.svg)](https://codecov.io/gh/schireson/pytest-mock-resources)[![DocumentationStatus](https://readthedocs.org/projects/pytest-mock-resources/badge/?version=latest)](https://pytest-mock-resources.readthedocs.io/en/latest/?badge=latest)## IntroductionCode which depends on external resources such a databases (postgres, redshift, etc) can be difficultto write automated tests for. Conventional wisdom might be to mock or stub out the actual databasecalls and assert that the code works correctly before/after the calls.However take the following, _simple_ example:```pythondef serialize(users):    return [        {            'user': user.serialize(),            'address': user.address.serialize(),            'purchases': [p.serialize() for p in user.purchases],        }        for user in users    ]def view_function(session):    users = session.query(User).join(Address).options(selectinload(User.purchases)).all()    return serialize(users)```Sure, you can test `serialize`, but whether the actual **query** did the correct thing _truly_requires that you execute the query.## The PitchHaving tests depend upon a **real** postgres instance running somewhere is a pain, very fragile, andprone to issues across machines and test failures.Therefore `pytest-mock-resources` (primarily) works by managing the lifecycle of docker containersand providing access to them inside your tests.As such, this package makes 2 primary assumptions:- You're using `pytest` (hopefully that's appropriate, given the package name)- For many resources, `docker` is required to be available and running (or accessible through remote  docker).If you aren't familiar with Pytest Fixtures, you can read up on them in the [Pytestdocumentation](https://docs.pytest.org/en/latest/fixture.html).In the above example, your test file could look something like```pythonfrom pytest_mock_resources import create_postgres_fixturefrom models import ModelBasepg = create_postgres_fixture(ModelBase, session=True)def test_view_function_empty_db(pg):  response = view_function(pg)  assert response == ...def test_view_function_user_without_purchases(pg):  pg.add(User(...))  pg.flush()  response = view_function(pg)  assert response == ...def test_view_function_user_with_purchases(pg):  pg.add(User(..., purchases=[Purchase(...)]))  pg.flush()  response = view_function(pg)  assert response == ...```## Existing Resources (many more possible)- SQLite  ```python  from pytest_mock_resources import create_sqlite_fixture  ```- Postgres  ```python  from pytest_mock_resources import create_postgres_fixture  ```- Redshift  **note** Uses postgres under the hood, but the fixture tries to support as much redshift  functionality as possible (including redshift's `COPY`/`UNLOAD` commands).  ```python  from pytest_mock_resources import create_redshift_fixture  ```- Mongo  ```python  from pytest_mock_resources import create_mongo_fixture  ```- Redis  ```python  from pytest_mock_resources import create_redis_fixture  ```- MySQL  ```python  from pytest_mock_resources import create_mysql_fixture  ```- Moto  ```python  from pytest_mock_resources import create_moto_fixture  ```## FeaturesGeneral features include:- Support for &quot;actions&quot; which pre-populate the resource you're mocking before the test- [Async fixtures](https://pytest-mock-resources.readthedocs.io/en/latest/async.html)- Custom configuration for container/resource startup## Installation```bash# Basic fixture support i.e. SQLitepip install &quot;pytest-mock-resources&quot;# General, docker-based fixture supportpip install &quot;pytest-mock-resources[docker]&quot;# Mongo fixture support, installs `pymongo`pip install &quot;pytest-mock-resources[mongo]&quot;# Moto fixture support, installs non-driver extras specific to moto supportpip install &quot;pytest-mock-resources[moto]&quot;# Redis fixture support, Installs `redis` clientpip install &quot;pytest-mock-resources[redis]&quot;# Redshift fixture support, installs non-driver extras specific to redshift supportpip install &quot;pytest-mock-resources[redshift]&quot;```Additionally there are number of **convenience** extras currently providedfor installing drivers/clients of specific features. However in most cases,you **should** already be installing the driver/client used for that fixtureas as first-party dependency of your project.As such, we recommend against using these extras, and instead explcitly dependingon the package in question in your own project's 1st party dependencies.```bash# Installs psycopg2/psycopg2-binary driverpip install &quot;pytest-mock-resources[postgres-binary]&quot;pip install &quot;pytest-mock-resources[postgres]&quot;# Installs asyncpg driverpip install &quot;pytest-mock-resources[postgres-async]&quot;# Installs pymysql driverpip install &quot;pytest-mock-resources[mysql]&quot;```## Possible Future Resources- Rabbit Broker- AWS PrestoFeel free to file an [issue](https://github.com/schireson/pytest-mock-resources/issues) if you findany bugs or want to start a conversation around a mock resource you want implemented!## Python 2Releases in the 1.x series were supportive of python 2. However starting from 2.0.0, support forpython 2 was dropped. We may accept bugfix PRs for the 1.x series, however new development andfeatures will not be backported.</longdescription>
</pkgmetadata>