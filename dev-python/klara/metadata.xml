<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># KlaraKlara is a static analysis tools to automatic generate test case, basedon SMT (z3) solver, with a powerful ast level inference system. Klarawill take python file as input and generate corresponding test file inpytest format, that attempt to cover all return values. For example,following function in file `test.py```` pythondef triangle(x: int, y: int, z: int) -&gt; str:    if x == y == z:        return &quot;Equilateral triangle&quot;    elif x == y or y == z or x == z:        return &quot;Isosceles triangle&quot;    else:        return &quot;Scalene triangle&quot;```will generate``` pythonimport testdef test_triangle_0():    assert test.triangle(0, 0, 0) == 'Equilateral triangle'    assert test.triangle(0, 0, 1) == 'Isosceles triangle'    assert test.triangle(2, 0, 1) == 'Scalene triangle'```See the Klara\'s documentation at &lt;https://klara-py.readthedocs.io&gt;**Note**: Klara is still in early experimental stage, notable missing features are loop, comprehension, module import, exceptions and many more.See [limitations](https://klara-py.readthedocs.io/en/latest/limitation.html) for full list. It probably will not run on real world projects, so it's bestto cherry-pick a few interesting functions to generate the corresponding test case.## InstallingKlara can be installed via `pip` tool by using:    pip install klara## UsageWe can invoke `klara` on any python source file, and it will generate acorresponding pytest test file.``` shell$ cat source.pydef foo(x: int, y: int, z: str):    if x + y &gt; 2:        return x + y + 12    elif x &lt; y:        return x + y    elif (z + &quot;me&quot;) == &quot;some&quot;:        return z + &quot;thing&quot;    else:        return x - y$ klara source.py$ cat test_source.pyimport contract_testdef test_foo_0():    assert contract_test.foo(0, 3, \'\') == 15    assert contract_test.foo(0, 1, \'\') == 1    assert contract_test.foo(0, 0, \'so\') == \'sothing\'    assert contract_test.foo(0, 0, \'\') == 0```Consult the [quick start](https://klara-py.readthedocs.io/en/latest/quick_start.html) manual for more examples andguidance. To use it as a static analysis library, go to[Inference](https://klara-py.readthedocs.io/en/latest/inference.html).## Why Klara?Klara works on ast level and it doesn\'t execute user code in any way,which is a very important difference compared to similar tool like[Crosshair](https://github.com/pschanely/CrossHair) and[Pynguin](https://github.com/se2p/pynguin) that utilize concolicsymbolic execution that required user code execution that might causeunwanted side effects. Klara work on ast level, combine with data flow analysisthat utilize Control Flow Graph(CFG), Static Single Assignment(SSA), use-def chain, etc\... to build apowerful python inference system that leverages Z3-solver forconstraints solving and path feasibility check. Because of this, Klarais able to operate on both python2/3 source code with the help of[typed_ast](https://github.com/python/typed_ast). To specify the sourcecode is in python 2, pass in `-py 2` argument. It\'s python 3 bydefault.Klara can also be used as a static analysis tool, allow user to definecustom rule to identify programming bugs, error or enforcing codingstandard. With SMT solver support, analysis will be more accurate andgreatly reduce false-positive case. For example``` pythonimport klaratree = klara.parse(&quot;&quot;&quot;    def foo(v1: int):        if v1 &gt; 4:            if v1 &lt; 3:                z = 1            else:                z = 2        else:            z = 3        s = z&quot;&quot;&quot;)with klara.MANAGER.initialize_z3_var_from_func(tree.body[0]):    print(list(tree.body[0].body[-1].value.infer()))```Will print out:    [2, 3]Because `z = 1` is not possible due to `v1 &gt; 4` and `v1 &lt; 3` is unsatisfiableThe inference system architecture and api is largely inspired by[Astroid](https://github.com/PyCQA/astroid), a static inference libraryused by [Pylint](https://github.com/PyCQA/pylint).Klara utilize the inference system to generate test case, in otherwords, it **generate test case for all possible return values of thefunction**, instead of generate test case for all control path of thefunction.To illustrate the point, consider the function below, with `divide byzero` vulnerabilities at line 3``` pythondef foo(v1: int, v2: float):    if v1 &gt; 10000:        s = v1 / 0  # unused statement    if v1 &gt; v2:        s = v1    else:        s = v2    return s```Klara will generate test inputs below``` pythonimport contract_testdef test_foo_0():    assert contract_test.foo(0, -1.0) == 0    assert contract_test.foo(0, 0.0) == 0.0```It doesn\'t generate input `v1 &gt; 10000`, so the test case would not beable to find out the exceptions. This is because the `s` atline 3 is unused in the return value.If we modify the second if statement to `elif`, which we\'llbe able to return the [s]{.title-ref} at line 3, klara will generatetest inputs that cover `v1 &gt; 10000` case.This is an important distinction with other automatic test casegeneration available now, because by only generate test case for returnvalues, we can generate a minimal test case, and it\'s easier tocustomize how do Klara cover the function.For example, say we are composing a complex system``` python    def main(number: int, cm: int, dc: int, wn: int):        mc = 0        if wn &gt; 2:            if number &gt; 2 and number &gt; 2 or number &gt; 2:                if number &gt; 0:                    if wn &gt; 2 or wn &gt; 2:                        mc = 2                    else:                        mc = 5                else:                    mc = 100        else:            mc = 1        nnn = number * cm        if cm &lt;= 4:            num_incr = 4        else:            num_incr = cm        n_num_incr = nnn / num_incr        nnn_left = dc * num_incr * (n_num_incr / 2 + n_num_incr % 2)        nnn_right = nnn - nnn_left        is_flag = nnn_right        if is_flag:            cell = Component(nnn_right, options=[mc])        else:            cell = Component(nnn_right)        return cell```It isn\'t immediately clear to us how many possible return values thereare. But we can utilize Klara to generate inputs instantly, below is thegenerated test``` pythonimport contract_testdef test_main_0():    assert contract_test.main(2, 4, 1, 3) is not None    assert contract_test.main(2, 4, -1, 6) is not None    assert contract_test.main(2, 4, 1, 4) is not None    assert contract_test.main(-2, 4, 3, 4) is not None    assert contract_test.main(-1, -1, -1, 2) is not None    assert contract_test.main(0, 0, 0, 3) is not None    assert contract_test.main(0, 0, 0, 6) is not None    assert contract_test.main(0, 0, 0, 4) is not None    assert contract_test.main(-2, 0, 0, 4) is not None    assert contract_test.main(0, 0, 0, 0) is not None```Above generated 10 total results, which is product of`nnn_right` which have 2 possibilities and `mc` which have 5 possibilities.Suppose that 10 tests input is too much, and we have determine that the`options` argument to `Component` is redundant to test, wecan use Klara\'s custom plugin to selectively determine which part toignore in test generation. Go to [customize coveragestrategy](https://klara-py.readthedocs.io/en/latest/customize_coverage_strategy.html) for more information.After we have setup the plugin, Klara will generate following test``` pythonimport contract_testdef test_main_0():    assert contract_test.main(1, 3, 0, 0) is not None    assert contract_test.main(0, 0, 0, 0) is not None```Which is only 2 combinations of `nnn_right`Because Klara can't dynamically execute the code, it will provide extension to specify how to infer specific ast node or user defined type to make Klara \'smarter\'. It\'s described in[extending](https://klara-py.readthedocs.io/en/latest/extending.html), [extending usertype](https://klara-py.readthedocs.io/en/latest/extending_user_type.html) and [customize coveragestrategy](https://klara-py.readthedocs.io/en/latest/customize_coverage_strategy.html).## ContributingWe use [Poetry](https://python-poetry.org/docs/) to manage dependencies.After poetry is installed, run:    $ poetry shell    $ poetry installTo run the test case, do:    $ poetry run pytest test## Acknowledgements- The architecture of the inference system is largely inspired by [Astroid](https://github.com/PyCQA/astroid).- Special thanks to Dr. Poh for guiding the early stages of the project.## LicenseThis project is licensed under the terms of the GNU Lesser GeneralPublic License.</longdescription>
</pkgmetadata>