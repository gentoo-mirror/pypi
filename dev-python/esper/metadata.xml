<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![pypi](https://badge.fury.io/py/esper.svg)](https://pypi.python.org/pypi/esper)[![rtd](https://readthedocs.org/projects/esper/badge/?version=latest)](https://esper.readthedocs.io)[![PyTest](https://github.com/benmoran56/esper/actions/workflows/unit-tests.yml/badge.svg)](https://github.com/benmoran56/esper/actions/workflows/unit-tests.yml)Esper is a lightweight Entity System module for Python, with a focus on performance===================================================================================Esper is an MIT licensed Entity System, or, Entity Component System (ECS).The design is based on the Entity System concepts outlined by Adam Martin in his blog athttp://t-machine.org/, and others. The primary focus is on keeping it as lightweight andperformant as possible, while handling common use cases.The following Wikipedia article provides a summary of the ECS pattern:https://en.wikipedia.org/wiki/Entity_component_systemAPI documentation is hosted at ReadTheDocs: https://esper.readthedocs.ioDue to the small size of the project, this README currently serves as general usagedocumentation.&gt; :warning: **Esper 3.0 introduces breaking changes**. Version 3.0 removes the&gt; World object, and migrates its methods to module level functions. Multiple &gt; contexts can be created and switched between. The v2.x README can be found&gt; here: https://github.com/benmoran56/esper/blob/v2_maintenance/README.md- [Compatibility](#compatibility)- [Installation](#installation)- [Design](#design)- [Quick Start](#quick-start)- [General Usage](#general-usage)  * [Adding and Removing Processors](#adding-and-removing-processors)  * [Adding and Removing Components](#adding-and-removing-components)  * [Querying Specific Components](#querying-specific-components)  * [Boolean and Conditional Checks](#boolean-and-conditional-checks)  * [More Examples](#more-examples)- [Event Dispatching](#event-dispatching)- [Contributing](#contributing)Compatibility=============Esper attempts to target all currently supported Python releases (not EOL). Esper is written in100% pure Python, so *any* compliant interpreter should work. Automated testing is currentlydone for both CPython and PyPy3.Installation============No installation is necessary. Esper is a Python package with no dependencies.Simply copy the *esper* folder into your project folder, and *import esper*.Esper is also available on PyPI for easy installation via pip::    pip install --user --upgrade esperDesign======* WorldA World is the main point of interaction in Esper. After creating a World object, you will usethat object to create Entities and assigning Components to them. A World is also assigned all ofyour Processor instances, and handles smoothly running everything with a single call per frame.Of course, Entities, Components and Processors can be created and assigned, or deleted whileyour application is running.* Entities Entities are simple integer IDs (1, 2, 3, 4, etc.).Entities are &quot;created&quot;, but they are generally not used directly. Instead, they aresimply used as IDs in the internal Component database to track collections of Components.Creating an Entity is done with the `esper.create_entity()` function.* ComponentsComponents are defined as simple Python classes. In keeping with a pure Entity Systemdesign philosophy, they should not contain any logic. They might have initializationcode, but no processing logic whatsoever. A simple Component can be defined as::    class Position:        def __init__(self, x=0.0, y=0.0):            self.x = x            self.y = yIn addition, the excellent `dataclass` decorator is available in Python 3.7+.https://docs.python.org/3/library/dataclasses.html#module-dataclassesThis decorator simplifies defining your Component classes. The attribute names don't need tobe repeated, and you can still instantiate the Component with positional or keyword arguments::    from dataclasses import dataclass as component    @component    class Position:        x: float = 0.0        y: float = 0.0* ProcessorsProcessors, also commonly known as &quot;Systems&quot;, are where all processing logic is defined and executed.All Processors must inherit from the *esper.Processor* class, and have a method called *process*.Other than that, there are no restrictions. All Processors will have access to the World instance,which is how you query Components to operate on. A simple Processor might look like::    class MovementProcessor(esper.Processor):        def process(self):            for ent, (vel, pos) in esper.get_components(Velocity, Position):                pos.x += vel.x                pos.y += vel.yIn the above code, you can see the standard usage of the *esper.get_components()* function. Thisfunction allows efficient iteration over all Entities that contain the specified Component types.This function can be used for querying two or more components at once. Note that tuple unpackingis necessary for the return component pairs: *(vel, pos)*.  In addition the Components, you alsoget a reference to the Entity ID (the *ent* object) for the current pair of Velocity/PositionComponents. This entity ID can be useful in a variety of cases. For example, if your Processorwill need to delete certain Entites, you can call the *esper.delete_entity()* function onthis Entity ID. Another common use is if you wish to add or remove a Component on this Entityas a result of some condition being met. Quick Start===========The first step after importing Esper is to create a World instance. You can have a single Worldinstance for your entire game, or you can have a separate instance for each of your game scenes.Whatever makes sense for your design. Create a World instance like this::    world = esper.World()Create some Processor instances, and assign them to the World. You can specify anoptional processing priority (higher numbers are processed first). All Processors arepriority &quot;0&quot; by default::    movement_processor = MovementProcessor()    collision_processor = CollisionProcessor()    rendering_processor = RenderingProcessor()    world.add_processor(movement_processor, priority=2)    world.add_processor(collision_processor, priority=3)    world.add_processor(rendering_processor)    # or just add them in one line:     world.add_processor(SomeProcessor())Create an Entity, and assign some Component instances to it::    player = world.create_entity()    world.add_component(player, Velocity(x=0.9, y=1.2))    world.add_component(player, Position(x=5, y=5))Optionally, Component instances can be assigned directly to the Entity on creation::    player = world.create_entity(Velocity(x=0.9, y=1.2), Position(x=5, y=5))Executing all Processors is done with a single call to world.process(). This will call theprocess method on all assigned Processors, in order of their priority. This is usually calledonce per frame update of your game.::    world.process()**Note:** You can pass any args you need to *world.process()*, but you must also make sure to receivethem properly in the *process()* methods of your Processors. For example, if you pass a delta timeargument as *esper.process(dt)*, your Processor's *process()* methods should all receive it as:*def process(self, dt):*This is appropriate for libraries such as **pyglet**, which automatically pass a delta time valueinto scheduled functions.  General Usage=============Adding and Removing Processors------------------------------You have already seen examples of adding Processors in an earlier section. There is also a *remove_processor*function available:* esper.add_processor(processor_instance)* esper.remove_processor(ProcessorClass)Depending on the structure of your game, you may want to add or remove certain Processors when changingscenes, etc. Adding and Removing Components------------------------------In addition to adding Components to Entities when you're creating them, it's a common pattern to add orremove Components inside your Processors. The following functions are available for this purpose: * esper.add_component(entity_id, component_instance)* esper.remove_component(entity_id, ComponentClass)As an example of this, you could have a &quot;Blink&quot; component with a *duration* attribute. This can be usedto make certain things blink for s specific period of time, then disappear. For example, the code belowshows a simplified case of adding this Component to an Entity when it takes damage in one processor. A dedicated *BlinkProcessor* handles the effect, and then removes the Component after the duration expires::    class BlinkComponent:        def __init__(self, duration):            self.duration = duration    .....    class CollisionProcessor(esper.Processor):        def process(self, dt):            for ent, enemy in esper.get_component(Enemy):                ...                is_damaged = self._some_method()                if is_damaged:                    esper.add_component(ent, BlinkComponent(duration=1))                ...    class BlinkProcessor(esper.Processor):        def process(self, dt):            for ent, (rend, blink) in esper.get_components(Renderable, BlinkComponent):                if blink.duration &lt; 0:                    # Times up. Remove the Component:                    rend.sprite.visible = True                    esper.remove_component(ent, BlinkComponent)                else:                    blink.duration -= dt                    # Toggle between visible and not visible each frame:                    rend.sprite.visible = not rend.sprite.visibleQuerying Specific Components----------------------------If you have an Entity ID and wish to query one specific, or ALL Components that are assignedto it, the following functions are available: * esper.component_for_entity* esper.components_for_entityThe *component_for_entity* function is useful in a limited number of cases where you know a specificEntity ID, and wish to get a specific Component for it. An error is raised if the Component does notexist for the Entity ID, so it may be more useful when combined with the *has_component*function that is explained in the next section. For example::    if esper.has_component(ent, SFX):        sfx = esper.component_for_entity(ent, SFX)        sfx.play()The *components_for_entity* function is a special function that returns ALL the Components that areassigned to a specific Entity, as a tuple. This is a heavy operation, and not something you wouldwant to do each frame or inside your `Processor.process` method. It can be useful, however, ifyou wanted to transfer all of a specific Entity's Components between two separate World instances(such as when changing Scenes, or Levels). For example::        player_components = old_world.components_for_entity(player_entity_id)    ...    player_entity_id = new_world.create_entity(player_components)Boolean and Conditional Checks------------------------------In some cases you may wish to check if an Entity has a specific Component before performingsome action. The following functions are available for this task:* esper.has_component(entity, ComponentType)* esper.has_components(entity, ComponentTypeA, ComponentTypeB)* esper.try_component(entity, ComponentType)* esper.try_components(entity, ComponentTypeA, ComponentTypeB)For example, you may want projectiles (and only projectiles) to disappear when hitting a wall inyour game. We can do this by checking if the Entity has a `Projectile` Component. We don't  wantto do anything to this Component, simply check if it's there. Consider this example::    class CollisionProcessor(esper.Processor):        def process(self, dt):            for ent, body in esper.get_component(PhysicsBody):                ...                colliding_with_wall = self._some_method(body):                if colliding_with_wall and esper.has_component(ent, Projectile):                    esper.delete_entity(ent)                ...In a different scenario, we may want to perform some action on an Entity's Component, *if* it hasone. For example, a MovementProcessor that skips over Entities that have a `Stun` Component::    class MovementProcessor(esper.Processor):        def process(self, dt):            for ent, (body, vel) in esper.get_components(PhysicsBody, Velocity):                if esper.has_component(ent, Stun):                    stun = esper.component_for_entity(ent, Stun)                    stun.duration -= dt                    if stun.duration &lt;= 0:                        esper.remove_component(ent, Stun)                    continue    # Continue to the next Entity                movement_code_here()                ...Let's look at the core part of the code::    if esper.has_component(ent, Stun):        stun = esper.component_for_entity(ent, Stun)        stun.duration -= dtThis code works fine, but the *try_component* function can accomplish the same thing with oneless function call. The following example will get a specific Component if it exists, orreturn None if it does not::    stun = esper.try_component(ent, Stun)    if stun:        stun.duration -= dtWith Python 3.8+, the new &quot;walrus&quot; operator (`:=`) can also be used, making the `try_component`functions even more concise ::    if stun :=  esper.try_component(ent, Stun):        stun.duration -= dtMore Examples-------------See the **/examples** folder to get an idea of how the basic structure of a game might look.Event Dispatching=================Esper includes basic support for event dispatching and handling. This functionality isprovided by three functions to set (register), remove, and dispatch events. Minimal errorchecking is done, so it's left up to the user to ensure correct naming and number ofarguments are used when dispatching and receiving events.Events are dispatched by name::    esper.dispatch_event('event_name', arg1, arg2)In order to receive the above event, you must register handlers. An event handler can be afunction or class method. Registering a handler is also done by name::    esper.set_handler('event_name', my_func)    # or    esper.set_handler('event_name', self.my_method)**Note:** Only weak-references are kept to the registered handlers. If a handler is garbagecollected, it will be automatically un-registered by an internal callback.Handlers can also be removed at any time, if you no longer want them to receive events::    esper.remove_handler('event_name', my_func)    # or    esper.remove_handler('event_name', self.my_method)Registered events and handlers are part of the current `World` context. Contributing============Contributions to Esper are always welcome, but there are some specific project goals to keep in mind:- Pure Python code only: no binary extensions, Cython, etc.- Try to target all non-EOL Python versions. Exceptions can be made if there is a compelling reason.- Avoid bloat as much as possible. New features will be considered if they are commonly useful. Generally speaking, we don't want to add functionality that is better handled in another module or library. - Performance is preferrable to readability.If you have any questions before contributing, feel free to [open an issue].[open an issue]: https://github.com/benmoran56/esper/issues</longdescription>
</pkgmetadata>