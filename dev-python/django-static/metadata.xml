<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>About django-static===================.. contents::What it does------------``django_static`` is a Django app that enables as various template tagsfor better serving your static content. It basically rewritesreferences to static files and where applicable it does whitespaceoptmization of the content. By making references to static contentunique (timestamp included in the name) you can be very aggressivewith your cache-control settings without ever having to worry aboutupgrading your code and worrying about visitors using an older version.The five template tags it enables are the following:1. ``staticfile`` Takes the timestamp of the file, and makes a copy by   symlinking as you define. You use it like this::        &lt;img src=&quot;{% staticfile &quot;/images/foo.png&quot; %}&quot;/&gt;   and the following is rendered::        &lt;img src=&quot;/images/foo.123456789.png&quot;/&gt;   ...assuming the epoch timestamp of the file is 123456789.2. ``slimfile`` Works the same as ``staticfile`` but instead of copying   the file as a symlink it actually rewrites the file and compresses   it through `slimmer &lt;https://pypi.python.org/pypi/slimmer/&gt;`__. This of   course only works for ``.js`` and ``.css`` files but it works   wonderfully fast and is careful enough to not break things. The   cool thing about doing this for ``.css`` files it finds all relative   images inside and applies ``staticfile`` for all of them too. You use   it just like ``staticfile``::        &lt;script type=&quot;text/javascript&quot;          src=&quot;{% slimfile &quot;/javascript/myscript.js&quot; %}&quot;&gt;&lt;/script&gt;3. ``slimcontent`` is used to whitespace compress content right in the   template. It requires a format parameter which can be ``&quot;js&quot;``,   ``&quot;css&quot;`` or ``&quot;html&quot;``. So, for example for some inline CSS content   you do this::        &lt;style type=&quot;text/css&quot;&gt;        {% slimcontent &quot;css&quot; %}        h1, h2, h3 {            font-face: 'Trebuchet MS', Verdana, Arial;        }        {% endslimcontent %}        &lt;/style&gt;   ...and you get this::        &lt;style type=&quot;text/css&quot;&gt;        h1,h2,h3{font-face:'Trebuchet MS',Verdana,Arial}        &lt;/style&gt;4. ``staticall`` combines all files between the tags into one and   makes the same symlinking as ``staticfile``. Write this::        {% staticall %}        &lt;script src=&quot;/javascript/foo.js&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;/javascript/bar.js&quot;&gt;&lt;/script&gt;        {% endstaticall %}   ...and you get this::        &lt;script src=&quot;/javascript/foo_bar.123456789.js&quot;&gt;&lt;/script&gt;5. ``slimall`` does the same compression ``slimfile`` does but also   combines the files as ``staticall``. Use it like ``staticall``::        {% slimall %}        &lt;script src=&quot;/javascript/foo.js&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;/javascript/bar.js&quot;&gt;&lt;/script&gt;        {% endslimall %}``staticall`` and ``slimall`` fully support ``async`` or ``defer``JavaScript attributes. Meaning this::        {% slimall %}        &lt;script defer src=&quot;/javascript/foo.js&quot;&gt;&lt;/script&gt;        &lt;script defer src=&quot;/javascript/bar.js&quot;&gt;&lt;/script&gt;        {% endslimall %}...will give you this::        &lt;script defer src=&quot;/javascript/foo_bar.123456789.js&quot;&gt;&lt;/script&gt;Be careful not to mix the two attributes within the same blocksor you might get unexpected results.Configuration-------------``django_static`` will be disabled by default. It's not until you set``DJANGO_STATIC = True`` in your settings module that it actually startsto work for you.By default, when ``django_static`` slims files or makes symlinks withtimestamps in the filename, it does this into the same directory aswhere the original file is. If you don't like that you can overridethe save location by setting``DJANGO_STATIC_SAVE_PREFIX = &quot;/tmp/django-static&quot;``If you, for the sake of setting up your nginx/varnish/apache2, wantchange the name the files get you can set``DJANGO_STATIC_NAME_PREFIX = &quot;/cache-forever&quot;`` as this will make it easierto write a rewrite rule/regular expression that innginx/varnish/apache2 deliberately sets extra aggressive caching.Another option is to let django_static take care of setting your``MEDIA_URL``. You could do this::        &lt;img src=&quot;{{ MEDIA_URL }}{% staticfile &quot;/foo.png&quot; %}&quot;/&gt;But if you're feeling lazy and what django_static to automaticallytake care of it set ``DJANGO_STATIC_MEDIA_URL``. In settings.py::        DJANGO_STATIC_MEDIA_URL = &quot;//static.example.com&quot;In your template::        &lt;img src=&quot;{% staticfile &quot;/foo.png&quot; %}&quot;/&gt;And you get this result::        &lt;img src=&quot;//static.example.com/foo.1247785534.png&quot;/&gt;Right out of the box, ``DJANGO_STATIC_MEDIA_URL`` will not be activeif ``DJANGO_STATIC = False``. If you want it to be, set``DJANGO_STATIC_MEDIA_URL_ALWAYS = True``.By default django_static will look for source files in ``MEDIA_ROOT``,but it is possible tell django_static to look in all directories listedin ``DJANGO_STATIC_MEDIA_ROOTS``. The first match will be used.There is also a setting ``DJANGO_STATIC_USE_SYMLINK`` that can be set to``False`` to force django_static to copy files instead of symlinking them.Advanced configuration with DJANGO_STATIC_USE_MANIFEST_FILE-----------------------------------------------------------If you enable, in your settings, a variable called``DJANGO_STATIC_USE_MANIFEST_FILE`` you can save filenames tomanifest.json which is stored in the first match directory in``DJANGO_STATIC_MEDIA_ROOTS``. This is for the usecase where we want tomanually upload css and javascript files to CDN. On production, where DEBUG=False,django-static will pick the filenames from manifest.json file instead ofdoing all the calculations.Advanced configuration with DJANGO_STATIC_FILE_PROXY----------------------------------------------------If you enable, in your settings, a variable called``DJANGO_STATIC_FILE_PROXY`` you can make all static URIs that``django_static`` generates go though one function. So that you, forexample, can do something with the information such as uploading to aCDN. To get started set the config::        DJANGO_STATIC_FILE_PROXY = 'mycdn.cdn_uploader_file_proxy'This is expected to be the equivalent of this import statement::        from mycdn import cdn_uploader_file_proxyWhere ``mycdn`` is a python module (e.g. ``mycdn.py``) and``cdn_uploader_file_proxy`` is a regular python function. Here's theskeleton for that function::        def cdn_uploader_file_proxy(uri, **kwargs):            return uriNow, it's inside those keyword arguments that you get the juicy gossipabout what ``django_static`` has done with the file. These are thepieces of information you will always get inside those keywordargments::        new = False        checked = False        changed = False        notfound = FalseThe names hopefully speak for themselves. They become ``True`` dependingon what ``django_static`` has done. For example, if you change your``foo.js`` and re-run the template it's not ``new`` but it will be ``checked``and ``changed``. The possibly most important keyword argument you mightget is ``filepath``. This is set whenever ``django_static`` actually doesits magic on a static file. So, for example you might write a functionlike this::        on_my_cdn = {}        def cdn_uploader_file_proxy(uri, filepath=None, new=False,                                    changed=False, **kwargs):            if filepath and (new or changed):                on_my_cdn[uri] = upload_to_my_cdn(filepath)            return on_my_cdn.get(uri, uri)Advanced configuration with DJANGO_STATIC_FILENAME_GENERATOR------------------------------------------------------------By default, django-static generates filenames for your combined filesusing timestamps. You can use your own filename generating functionby setting it in settings, like so::        DJANGO_STATIC_FILENAME_GENERATOR = 'myapp.filename_generator'This is expected to be the equivalent of this import statement::        from myapp import filename_generatorWhere ``myapp`` is a python module, and ``filename_generator`` is a regularpython function. Here's the skeleton for that function::  def filename_generator(file_parts, new_m_time):      return ''.join([file_parts[0], '.%s' % new_m_time, file_parts[1]])Advanced configuration with DJANGO_STATIC_COMBINE_FILENAMES_GENERATOR---------------------------------------------------------------------By default, django-static generates filenames for your combined filesby concatenating the file names. You can also use your own filenamegenerating function by setting it in settings, like so::        DJANGO_STATIC_COMBINE_FILENAMES_GENERATOR = 'myapp.combine_filenames'This is expected to be the equivalent of this import statement::        from myapp import combine_filenamesWhere ``myapp`` is a python module, and ``combine_filenames`` is a regularpython function. Here's the skeleton for that function::  path = None  names = []  extension = None  timestamps = []  for filename in filenames:      name = os.path.basename(filename)      if not extension:          extension = os.path.splitext(name)[1]      elif os.path.splitext(name)[1] != extension:          raise ValueError(&quot;Can't combine multiple file extensions&quot;)      for each in re.finditer('\.\d{10}\.', name):          timestamps.append(int(each.group().replace('.','')))          name = name.replace(each.group(), '.')      name = os.path.splitext(name)[0]      names.append(name)      if path is None:          path = os.path.dirname(filename)      else:          if len(os.path.dirname(filename)) &lt; len(path):              path = os.path.dirname(filename)  new_filename = '_'.join(names)  if timestamps:      new_filename += &quot;.%s&quot; % max(timestamps)  new_filename = new_filename[:max_length]  new_filename += extension  return os.path.join(path, new_filename)Compression Filters-------------------Default (cssmin)~~~~~~~~~~~~~~~~django-static uses cssmin by default if it is installed.Get the source here: https://github.com/zacharyvoase/cssminUsing jsmin~~~~~~~~~~~If you would like to use jsmin instead of default js_slimmer, you just need to setthe variable in your settings.py file::    DJANGO_STATIC_JSMIN = TrueUsing Google Closure Compiler~~~~~~~~~~~~~~~~~~~~~~~~~~~~~If you want to use the `Google ClosureCompiler &lt;https://code.google.com/closure/compiler/&gt;`__ to optimize yourJavascript files you first have to download the compiler.jar file andmake sure your systam can run java. Suppose you download it in/usr/local/bin, the set this variable in your settings.py file::    DJANGO_STATIC_CLOSURE_COMPILER = '/usr/local/bin/compiler.jar'If for some reason the compiler chokes on your Javascript it won'thalt the serving of the file but it won't be whitespace optimized andthe error will be inserted into the resulting Javascript file as a bigcomment block.Using the YUI Compressor~~~~~~~~~~~~~~~~~~~~~~~~The `YUI Compressor &lt;https://developer.yahoo.com/yui/compressor/&gt;`__ isboth a Javascript and CSS compressor which requires a java runtime.Just like the Google Closure Compiler, you need to download the jarfile and then set something like this in your settings.py::    DJANGO_STATIC_YUI_COMPRESSOR = '/path/to/yuicompressor-2.4.2.jar'If you configure the Google Closure Compiler **and** YUI Compressor,the Google Closure Compiler will be first choice for Javascriptcompression.Using the slimmer~~~~~~~~~~~~~~~~~`slimmer &lt;https://pypi.python.org/pypi/slimmer/&gt;`__ is an all pythonpackage that is capable of whitespace optimizing CSS, HTML, XHTML andJavascript. It's faster than the YUI Compressor and Google Closure butthat speed difference is due to the start-stop time of bridging theJava files.How to hook this up with nginx------------------------------Read `this blog entry onpeterbe.com &lt;https://www.peterbe.com/plog/serve-your-static-stuff-in-django-with-nginx&gt;`__</longdescription>
</pkgmetadata>