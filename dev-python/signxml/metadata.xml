<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>SignXML: XML Signature and XAdES in Python==========================================*SignXML* is an implementation of the W3C `XML Signature &lt;http://en.wikipedia.org/wiki/XML_Signature&gt;`_ standard inPython. This standard (also known as &quot;XMLDSig&quot;) is used to provide payload security in `SAML 2.0&lt;http://en.wikipedia.org/wiki/SAML_2.0&gt;`_, `XAdES &lt;https://en.wikipedia.org/wiki/XAdES&gt;`_, and `WS-Security&lt;https://en.wikipedia.org/wiki/WS-Security&gt;`_, among other uses. The standard is defined in the `W3C Recommendation&lt;https://www.w3.org/standards/types#REC&gt;`_ `XML Signature Syntax and Processing Version 1.1&lt;http://www.w3.org/TR/xmldsig-core1/&gt;`_. *SignXML* implements all of the required components of the Version 1.1standard, and most recommended ones. Its features are:* Use of a libxml2-based XML parser configured to defend against  `common XML attacks &lt;https://docs.python.org/3/library/xml.html#xml-vulnerabilities&gt;`_ when verifying signatures* Extensions to allow signing with and verifying X.509 certificate chains, including hostname/CN validation* Extensions to sign and verify `XAdES &lt;https://en.wikipedia.org/wiki/XAdES&gt;`_ signatures* Support for exclusive XML canonicalization with inclusive prefixes (`InclusiveNamespaces PrefixList  &lt;http://www.w3.org/TR/xml-exc-c14n/#def-InclusiveNamespaces-PrefixList&gt;`_, required to verify signatures generated by  some SAML implementations)* Modern Python compatibility (3.7-3.11+ and PyPy)* Well-supported, portable, reliable dependencies: `lxml &lt;https://github.com/lxml/lxml&gt;`_,  `cryptography &lt;https://github.com/pyca/cryptography&gt;`_, `pyOpenSSL &lt;https://github.com/pyca/pyopenssl&gt;`_* Comprehensive testing (including the XMLDSig interoperability suite) and `continuous integration  &lt;https://github.com/XML-Security/signxml/actions&gt;`_* Simple interface with useful, ergonomic, and secure defaults (no network calls, XSLT or XPath transforms)* Compactness, readability, and extensibilityInstallation------------::    pip install signxmlNote: SignXML depends on `lxml &lt;https://github.com/lxml/lxml&gt;`_ and `cryptography&lt;https://github.com/pyca/cryptography&gt;`_, which in turn depend on `OpenSSL &lt;https://www.openssl.org/&gt;`_, `LibXML&lt;http://xmlsoft.org/&gt;`_, and Python tools to interface with them. You can install those as follows:+--------------+----------------------------------------------------------------------------------------------------------------------+| OS           | Command                                                                                                              |+==============+======================================================================================================================+| Ubuntu       | ``apt-get install --no-install-recommends python3-pip python3-wheel python3-setuptools python3-openssl python3-lxml``|+--------------+----------------------------------------------------------------------------------------------------------------------+| Red Hat,     | ``yum install python3-pip python3-pyOpenSSL python3-lxml``                                                           || Amazon Linux,|                                                                                                                      || CentOS       |                                                                                                                      |+--------------+----------------------------------------------------------------------------------------------------------------------+| Mac OS       | Install `Homebrew &lt;https://brew.sh&gt;`_, then run ``brew install python``.                                             |+--------------+----------------------------------------------------------------------------------------------------------------------+Synopsis--------SignXML uses the `lxml ElementTree API &lt;https://lxml.de/tutorial.html&gt;`_ to work with XML data... code-block:: python    from lxml import etree    from signxml import XMLSigner, XMLVerifier    data_to_sign = &quot;&lt;Test/&gt;&quot;    cert = open(&quot;cert.pem&quot;).read()    key = open(&quot;privkey.pem&quot;).read()    root = etree.fromstring(data_to_sign)    signed_root = XMLSigner().sign(root, key=key, cert=cert)    verified_data = XMLVerifier().verify(signed_root).signed_xmlTo make this example self-sufficient for test purposes:- Generate a test certificate and key using  ``openssl req -x509 -nodes -subj &quot;/CN=test&quot; -days 1 -newkey rsa -keyout privkey.pem -out cert.pem``  (run ``yum install openssl`` on Red Hat).- Pass the ``x509_cert=cert`` keyword argument to ``XMLVerifier.verify()``. (In production, ensure this is replaced with  the correct configuration for the trusted CA or certificate - this determines which signatures your application trusts.).. _verifying-saml-assertions:Verifying SAML assertions~~~~~~~~~~~~~~~~~~~~~~~~~Assuming ``metadata.xml`` contains SAML metadata for the assertion source:.. code-block:: python    from lxml import etree    from base64 import b64decode    from signxml import XMLVerifier    with open(&quot;metadata.xml&quot;, &quot;rb&quot;) as fh:        cert = etree.parse(fh).find(&quot;//ds:X509Certificate&quot;).text    assertion_data = XMLVerifier().verify(b64decode(assertion_body), x509_cert=cert).signed_xml.. admonition:: Signing SAML assertions The SAML assertion schema specifies a location for the enveloped XML signature (between ``&lt;Issuer&gt;`` and ``&lt;Subject&gt;``). To sign a SAML assertion in a schema-compliant way, insert a signature placeholder tag at that location before calling XMLSigner: ``&lt;ds:Signature Id=&quot;placeholder&quot;&gt;&lt;/ds:Signature&gt;``... admonition:: See what is signed It is important to understand and follow the best practice rule of &quot;See what is signed&quot; when verifying XML signatures. The gist of this rule is: if your application neglects to verify that the information it trusts is what was actually signed, the attacker can supply a valid signature but point you to malicious data that wasn't signed by that signature. Failure to follow this rule can lead to vulnerability against attacks like `SAML signature wrapping &lt;https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf&gt;`_. In SignXML, you can ensure that the information signed is what you expect to be signed by only trusting the data returned by the ``verify()`` method. The ``signed_xml`` attribute of the return value is the XML node or string that was signed. **Recommended reading:** `W3C XML Signature Best Practices for Applications &lt;http://www.w3.org/TR/xmldsig-bestpractices/#practices-applications&gt;`_, `On Breaking SAML: Be Whoever You Want to Be &lt;https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf&gt;`_, `Duo Finds SAML Vulnerabilities Affecting Multiple Implementations &lt;https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations&gt;`_.. admonition:: Establish trust If you do not supply any keyword arguments to ``verify()``, the default behavior is to trust **any** valid XML signature generated using a valid X.509 certificate trusted by your system's CA store. This means anyone can get an SSL certificate and generate a signature that you will trust. To establish trust in the signer, use the ``x509_cert`` argument to specify a certificate that was pre-shared out-of-band (e.g. via SAML metadata, as shown in *Verifying SAML assertions*), or ``cert_subject_name`` to specify a subject name that must be in the signing X.509 certificate given by the signature (verified as if it were a domain name), or ``ca_pem_file``/``ca_path`` to give a custom CA.XML signature construction methods: enveloped, detached, enveloping~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~The XML Signature specification defines three ways to compose a signature with the data being signed: enveloped,detached, and enveloping signature. Enveloped is the default method. To specify the type of signature that you want togenerate, pass the ``method`` argument to ``sign()``:.. code-block:: python    signed_root = XMLSigner(method=signxml.methods.detached).sign(root, key=key, cert=cert)    verified_data = XMLVerifier().verify(signed_root).signed_xmlFor detached signatures, the code above will use the ``Id`` or ``ID`` attribute of ``root`` to generate a relative URI(``&lt;Reference URI=&quot;#value&quot;``). You can also override the value of ``URI`` by passing a ``reference_uri`` argument to``sign()``. To verify a detached signature that refers to an external entity, pass a callable resolver in``XMLVerifier().verify(data, uri_resolver=...)``.See the `API documentation &lt;https://xml-security.github.io/signxml/#id5&gt;`_ for more details.XML representation details: Configuring namespace prefixes and whitespace~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Some applications require a particular namespace prefix configuration - for example, a number of applications assumethat the ``http://www.w3.org/2000/09/xmldsig#`` namespace is set as the default, unprefixed namespace instead of usingthe customary ``ds:`` prefix. While in normal use namespace prefix naming is an insignificant representation detail,it can be significant in some XML canonicalization and signature configurations. To configure the namespace prefix mapwhen generating a signature, set the ``XMLSigner.namespaces`` attribute:.. code-block:: python    signer = signxml.XMLSigner(...)    signer.namespaces = {None: signxml.namespaces.ds}    signed_root = signer.sign(...)Similarly, whitespace in the signed document is significant for XML canonicalization and signature purposes. Do notpretty-print the XML after generating the signature, since this can unfortunately render the signature invalid.XML parsing security and compatibility with ``xml.etree.ElementTree``~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~SignXML uses the `lxml &lt;https://github.com/lxml/lxml&gt;`_ ElementTree library, not the`ElementTree from Python's standard library &lt;https://docs.python.org/3.8/library/xml.etree.elementtree.html&gt;`_,to work with XML. lxml is used due to its superior resistance to XML attacks, as well as XML canonicalization andnamespace organization features. It is recommended that you pass XML string input directly to signxml before furtherparsing, and use lxml to work with untrusted XML input in general. If you do pass ``xml.etree.ElementTree`` objects toSignXML, you should be aware of differences in XML namespace handling between the two libraries. See the followingreferences for more information:* `How do I use lxml safely as a web-service endpoint?  &lt;https://lxml.de/FAQ.html#how-do-i-use-lxml-safely-as-a-web-service-endpoint&gt;`_* `ElementTree compatibility of lxml.etree &lt;https://lxml.de/compatibility.html&gt;`_* `XML Signatures with Python ElementTree &lt;https://technotes.shemyak.com/posts/xml-signatures-with-python-elementtree&gt;`_XAdES signatures~~~~~~~~~~~~~~~~`XAdES (&quot;XML Advanced Electronic Signatures&quot;) &lt;https://en.wikipedia.org/wiki/XAdES&gt;`_ is a standard for attachingmetadata to XML Signature objects. This standard is endorsed by the European Union as the implementation for its`eSignature &lt;https://ec.europa.eu/digital-building-blocks/wikis/display/DIGITAL/eSignature+Overview&gt;`_ regulations.SignXML supports signing and verifying documents using `XAdES &lt;https://en.wikipedia.org/wiki/XAdES&gt;`_ signatures:.. code-block:: python    from signxml import DigestAlgorithm    from signxml.xades import (XAdESSigner, XAdESVerifier, XAdESVerifyResult,                               XAdESSignaturePolicy, XAdESDataObjectFormat)    signature_policy = XAdESSignaturePolicy(        Identifier=&quot;MyPolicyIdentifier&quot;,        Description=&quot;Hello XAdES&quot;,        DigestMethod=DigestAlgorithm.SHA256,        DigestValue=&quot;Ohixl6upD6av8N7pEvDABhEL6hM=&quot;,    )    data_object_format = XAdESDataObjectFormat(        Description=&quot;My XAdES signature&quot;,        MimeType=&quot;text/xml&quot;,    )    signer = XAdESSigner(        signature_policy=signature_policy,        claimed_roles=[&quot;signer&quot;],        data_object_format=data_object_format,        c14n_algorithm=&quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315&quot;,    )    signed_doc = signer.sign(doc, key=private_key, cert=certificate).. code-block:: python    verifier = XAdESVerifier()    verify_results = verifier.verify(        signed_doc, x509_cert=certificate, expect_references=3, expect_signature_policy=signature_policy    )    for verify_result in verify_results:        if isinstance(verify_result, XAdESVerifyResult):            verify_result.signed_properties  # use this to access parsed XAdES propertiesAuthors-------* `Andrey Kislyuk &lt;https://github.com/kislyuk&gt;`_ and SignXML contributors.Links-----* `Project home page (GitHub) &lt;https://github.com/XML-Security/signxml&gt;`_* `Documentation &lt;https://xml-security.github.io/signxml/&gt;`_* `Package distribution (PyPI) &lt;https://pypi.python.org/pypi/signxml&gt;`_* `Change log &lt;https://github.com/XML-Security/signxml/blob/master/Changes.rst&gt;`_* `List of W3C XML Signature standards and drafts &lt;https://www.w3.org/TR/?title=xml%20signature&gt;`_* `W3C Recommendation: XML Signature Syntax and Processing Version 1.1 &lt;http://www.w3.org/TR/xmldsig-core1&gt;`_* `W3C Working Group Note: XML Signature Best Practices &lt;http://www.w3.org/TR/xmldsig-bestpractices/&gt;`_* `XML-Signature Interoperability &lt;http://www.w3.org/Signature/2001/04/05-xmldsig-interop.html&gt;`_* `W3C Working Group Note: Test Cases for C14N 1.1 and XMLDSig Interoperability &lt;http://www.w3.org/TR/xmldsig2ed-tests/&gt;`_* `W3C Working Group Note: XML Signature Syntax and Processing Version 2.0 &lt;http://www.w3.org/TR/xmldsig-core2&gt;`_  (This draft standard proposal was never finalized and is not in general use.)* `Intelligence Community Technical Specification: Web Service Security Guidance for Use of XML Signature and XML  Encryption &lt;https://github.com/XML-Security/signxml/blob/develop/docs/dni-guidance.pdf&gt;`_* `XMLSec: Related links &lt;https://www.aleksey.com/xmlsec/related.html&gt;`_* `OWASP SAML Security Cheat Sheet &lt;https://www.owasp.org/index.php/SAML_Security_Cheat_Sheet&gt;`_* `Okta Developer Docs: SAML &lt;https://developer.okta.com/standards/SAML/&gt;`_Bugs~~~~Please report bugs, issues, feature requests, etc. on `GitHub &lt;https://github.com/XML-Security/signxml/issues&gt;`_.Versioning~~~~~~~~~~This package follows the `Semantic Versioning 2.0.0 &lt;http://semver.org/&gt;`_ standard. To control changes, it isrecommended that application developers pin the package version and manage it using `pip-tools&lt;https://github.com/jazzband/pip-tools&gt;`_ or similar. For library developers, pinning the major version isrecommended.License-------Copyright 2014-2023, Andrey Kislyuk and SignXML contributors. Licensed under the terms of the`Apache License, Version 2.0 &lt;http://www.apache.org/licenses/LICENSE-2.0&gt;`_. Distribution of the LICENSE and NOTICEfiles with source copies of this package and derivative works is **REQUIRED** as specified by the Apache License... image:: https://github.com/XML-Security/signxml/workflows/Test%20suite/badge.svg        :target: https://github.com/XML-Security/signxml/actions.. image:: https://codecov.io/github/XML-Security/signxml/coverage.svg?branch=master        :target: https://codecov.io/github/XML-Security/signxml?branch=master.. image:: https://img.shields.io/pypi/v/signxml.svg        :target: https://pypi.python.org/pypi/signxml.. image:: https://img.shields.io/pypi/l/signxml.svg        :target: https://pypi.python.org/pypi/signxml</longdescription>
</pkgmetadata>