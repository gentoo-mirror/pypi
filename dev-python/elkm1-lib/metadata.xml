<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Python ElkM1 library[![PyPI version](https://badge.fury.io/py/elkm1-lib.svg)](https://badge.fury.io/py/elkm1-lib)[![CI](https://github.com/gwww/elkm1/actions/workflows/code-quality.yml/badge.svg)](https://github.com/gwww/elkm1/actions/workflows/code-quality.yml)[![Downloads](https://pepy.tech/badge/elkm1-lib)](https://pepy.tech/project/elkm1-lib)[![License](https://img.shields.io/github/license/mashape/apistatus.svg)](https://pypi.org/project/elkm1_lib/)Library for interacting with ElkM1 alarm/automation panel.https://github.com/gwww/elkm1## Requirements- Python 3.9 (or higher)## DescriptionThis package is created as a library to interact with an ElkM1 alarm/automationpattern. The motivation to write this was to use with the Home Assistantautomation platform. The library can be used for writing other ElkM1 integrationapplications. The IO with the panel is asynchronous over TCP or over theserial port.## Installation```bash    $ pip install elkm1_lib```## OverviewBasic connection to the Elk panel:```python    from elkm1_lib import Elk    import logging    # Print to STDOUT    LOG = logging.getLogger(__name__)    logging.basicConfig(level=logging.DEBUG, format='%(message)s')    # Connect to elk    elk = Elk({'url': 'elk://192.168.1.100'})    elk.connect()    elk.run()```The above will connect to the Elk panel at IP address 192.168.1.100. the `elk://`prefix specifies that the connect is plaintext. Alternatively, `elks://` willconnect over TLS. In this case a userid and password must be specifiedand the call to `Elk` changes to:```python    elk = Elk(        {'url': 'elks://192.168.1.100', 'userid': 'test', 'password': 'pass'}    )```The following ElkM1 connection protocols are supported:- serial:// - Serial port;- elk:// - Elk M1XEP Ethernet, non-secure- elks:// - Elk M1XEP Ethernet, secure, TLS 1.0- elksv1_0:// - Elk M1XEP Ethernet, secure, TLS 1.0, supported on M1XEP version &lt; 2.0.46- elksv1_2:// - Elk M1XEP Ethernet, secure, TLS 1.2, supported on M1XEP version = 2.0.46- elksv1_3:// - Elk M1XEP Ethernet, secure, TLS 1.2, not yet supported on M1XEP, reserved for futureA username and password are required for any of the secure modes.To see working example code take a look at the script `bin/simple`.The `Elk` object supports the concept of `Elements`. An `Element`is the base class representation of `Zones`, `Lights`, etc. So, forexample there is a list of zones: `elk.zones` and each zone can beaccessed by `elk.zones[index]`. Each element has a `__str__`representation so that it is easy to print its contents.All `Elements` are referenced starting at 0. Even though the Elk panelrefers to, for example, zones 1-208, the library references themas zones 0-207. All translation from base 0 to 1 and vice-versa ishandled internally in the `elkm1_lib.message` module.After creating the `Elk` object and connecting to the panel thelibrary code will synchronize all the elements to the data from the Elk panel.Many Elk messages are handled by the library, caching their contents. When amessage causes a change to an attribute of an `Element`, registeredcallbacks are called so that user use of the library can be notifiedof changing elements. The following user code shows registering a callback:```python    def call_me(element, changeset):       print(changeset)    for zone_number in range(Max.ZONES.value):      elk.zones[zone_number].add_callback(call_me)```The library encodes, decodes, and processes messages to/from theElk panel. All the encoding and decoding is done in `elkm1_lib.message` module.Messages received are handled with callbacks. The libraryinternally registers callbacks so that decoded messagescan be used to update an `Element`. The user of thelibrary may also register callbacks. Any particular messagemay have multiple callbacks.When the message is received it is decodedand some validation is done. The message handler is calledwith the fields of from the decoded message. Each type ofmessage has parameters that match the message type. All handler parametersare named parameters.Here is an example of a message handler being registered and how it is called:```python    def zone_status_change_handler(zone_number, zone_status):      print(zone_number, zone_status)    elk.add_handler('ZC', zone_status_change_handler)```The above code registers a callback for 'ZC' (Elk zone status change)messages. When a ZC message is received the handler functions are calledwith the zone_number and zone_status.There are a number of pseudo-handlers that act like the handlers. These arecalled when events happen. The pseudo-handlers are:- `connect`: When a successful connection to the ElkM1 is completed.- `disconnect`: When a connection to a panel is disconnected.- `login`: When a login is made to the panel (using `elks://` connection mode.  A single boolean parameter is passed `succeeded`.- `sync_complete`: When the panel has completed synchonizing all its elements.- `timeout`: When a send of a message to the ElkM1 times out (fails to send).- `unknown`: When a message from the ElkM1 is received and the library does  not have a method to decode the message. The message is passed to this handler  and can be decoded outside of the library.## UtilitiesThe `bin` directory of the library has one utility program anda couple of example uses of the library.### `mkdoc`The utility `mkdoc` creates a Markdown table of the list of Elkmessages with a check mark for those messages have encoders/decodersand an X for those messages are not planned to be implemented.There are no parameters to `mkdoc`. It outputs to stdout.The data for the report comes from the ElkM1 library code mostly.A couple of things are hard coded in the mkdoc script, notablythe &quot;no plans to implement&quot; list.### `simple`The `simple` Python script is a trivial use of the ElkM1 library.It connects to the panel, syncs to internal memory, and continueslistening for any messages from the panel. The URL of the ElkM1 toconnect to is retrieved from an environment variable named `ELKM1_URL`.### `elk`The `elk` Python script is a bit of a command interpretor. It can run intwo modes. Non-interactive mode is the default. Just run the `elk` command.The non-interactive mode is similar to `simple` except there are acouple of message handlers (`timeout` and `unknown` handlers).The `elk` can also be run in interactive mode by invoking it by`elk -i`. In this mode is uses curses (full screen use of the terminal)that has a command line and an output window. `TAB` switches betweenthe command line and output windows. In the output window the arrow keysand scrollwheel scroll the contents of the window.In the command line when running `elk -i` there are anumber of commands. Start with `help`. Then `help &lt;command&gt;` fordetails on each command. In general there are commands to dump the internalstate of elements and to invoke any of the encoders to send a messageto the Elk panel.For example, `light &lt;4, 8, 12-14` would invoke the `__str__` methodfor the light element to print the cached info for lights 0-3, 8, and 12-14.Another example would be `pf 3` which issues the pf (Turn light off)command for light number 3 (light 4 on the panel -- remember 0versus 1 base).All of the commands that send messages to the panel are automaticallydiscovered and are all the XX_encode functions in the ``elkm1_lib.message``module. The docstring and the XX_encode's parameters are shown as partof the help.## DevelopmentThis project uses [poetry](https://poetry.eustace.io/) for development dependencies. Installation instructions are on their website.To get started developing:```git clone https://github.com/gwww/elkm1.gitcd elkm1poetry installpoetry shell # Or activate the created virtual environmentmake test # to ensure everything installed properly```There is a `Makefile` in the root directory as well. The `make` commandfollowed by one of the targets in the `Makefile` can be used. If you don'thave or wish to use `make` the `Makefile` serves as examples of commoncommands that can be run.## Reporting a BugNo problem ;) â€” report the bugs! But, logs are most often required. If youare using Home Assistant, which is about the only use I'm aware of forthis library, then add the following to your `configuration.yaml`:```logger:  default: info  logs:    custom_components.elkm1: debug    elkm1_lib: debug```Do everything in your power to trim to logs down to their smallest. One way isto reproduce your problem quickly so that few other logs are not generated inbetween. Another recommendation is to use the simplest configuration that youcan think of to reproduce the problem.Can you reproduce the problem in other ways? If this is a problem that isbeing experienced while using Home Assistant try using the `Services` in `Developer Tools`.Sometime logs may have sensitive information in them. You may want toscan your logs for that info and &quot;X&quot; it out. In addition, you can send logsdirectly to me. Support email is in the `pyproject.toml` file. You may alsosend a link to somewhere you've stored/shared the file (DropBox for example).</longdescription>
</pkgmetadata>