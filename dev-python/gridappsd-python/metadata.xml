<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Run All Pytests](https://github.com/GRIDAPPSD/gridappsd-python/actions/workflows/run-pytest.yml/badge.svg)](https://github.com/GRIDAPPSD/gridappsd-python/actions/workflows/run-pytest.yml)# gridappsd-pythonPython library for developing applications and services against the gridappsd api## RequirementsThe gridappsd-python library requires a  python version &gt;= 3.6 and &lt; 4 in order to work properly (Note no testinghas been done with python 4 to date).## InstallationThe recommended installation of `gridappsd-python` is in a separate virtual environment.  Executing the followingwill create an environment called `griddapps-env`.```shellpython3 -m venv gridappsd-env```Sourcing the gridappsd-env activates the newly created python environment.```shellsource gridappsd-env/bin/activate```Upgrade pip to the latest (some packages require 19.0+ version of pip).```shellpython -m pip install pip --upgrade```Install the latest `gridappsd-python` and its dependencies in the virtual environment.```shellpip install gridappsd-python```### Verifying things are working properlyThe following code snippet assumes you have created a gridappsd instance using the steps inhttps://github.com/GRIDAPPSD/gridappsd-docker.Create a test script (tester.py) with the following content.```pythonfrom gridappsd import GridAPPSDdef on_message_callback(header, message):    print(f&quot;header: {header} message: {message}&quot;)# Note these should be changed on the server in a cyber secure environment!username = &quot;app_user&quot;password = &quot;1234App&quot;# Note: there are other parameters for connecting to# systems other than localhostgapps = GridAPPSD(username=username, password=password)assert gapps.connectedgapps.send('send.topic', {&quot;foo&quot;: &quot;bar&quot;})# Note we are sending the function not executing the function in the second parametergapps.subscribe('subscribe.topic', on_message_callback)gapps.send('subcribe.topic', 'A message about subscription')time.sleep(5)gapps.close()```Start up the gridappsd-docker enabled platform.  Then run the following to execute the tester.py script```shellpython tester.py```## Application Developers### DeploymentPlease see [DOCKER_CONTAINER.md](DOCKER_CONTAINER.md) for working within the docker application base container.### Local DevelopmentDeveloping applications against gridappsd using the `gridappsd-python` library should follow the same stepsas above, however with a couple of environmental variables specified.  The following environmental variables areavailable to provide the same context that would be available from inside the application docker container.  Theseare useful to know for developing your application outside of the docker context (e.g. in a python notebook).***NOTE: you can also define these your ~./bashrc file so you don't have to specify them all the time***```shell# export allows all processes started by this shell to have access to the global variable# address where the gridappsd server is running - default localhostexport GRIDAPPSD_ADDRESS=localhost# port to connect to on the gridappsd server (the stomp client port)export GRIDAPPSD_PORT=61613# username to connect to the gridappsd serverexport GRIDAPPSD_USER=app_user# password to connect to the gridappsd serverexport GRIDAPPSD_PASSWORD=1234App# Note these should be changed on the server in a cyber secure environment!```The following is the same tester code as above, but with the environment variables set.  The environment variablesshould be set in your environment when running the application inside our docker container.```pythonfrom gridappsd import GridAPPSDdef on_message_callback(header, message):    print(f&quot;header: {header} message: {message}&quot;)# Create GridAPPSD object and connect to the gridappsd server.gapps = GridAPPSD()assert gapps.connectedgapps.send('send.topic', {&quot;foo&quot;: &quot;bar&quot;})# Note we are sending the function not executing the function in the second parametergapps.subscribe('subscribe.topic', on_message_callback)gapps.send('subcribe.topic', 'A message about subscription')time.sleep(5)gapps.close()```## DevelopersThis project uses poetry to build the environment for execution.  Follow the instructionshttps://python-poetry.org/docs/#installation to install poetry.  As a developer I prefer not to have poetry installedin the same virtual environment that my projects are in.Clone the github repository:```shellgit clone https://github.com/GRIDAPPSD/gridappsd-python -b developcd gridappsd-python```The following commands build and install a local wheel into an environment created just for this package.```shell# Build the project (stores in dist directory both .tar.gz and .whl file)poetry build# Install the wheel into the environment and the dev dependenciespoetry install# Install only the library dependenciespoetry install --no-dev```***Note:*** Poetry does not have a setup.py that you can install in editable mode like with pip install -e ., howeveryou can extract the generated setup.py file from the built tar.gz file in the dist directory.  Just extract the.tar.gz file and copy the setup.py file from the extracted directory to the root of gridappsd-python.  Then you canenable editing through pip install -e. as normal.## TestingTesting has become an integral part of the software lifecycle.  The `gridappsd-python` library has both unit andintegration tests available to be run.  In order to execute these, you must have installed the gridappsd-python libraryas above with dev-dependencies.During the testing phase the docker containers required for the tests are downloaded fromdockerhub and started.  By default the `develop` tag is used to test the library using pytest.  One can customize the docker image tag by setting the environmentalvariable `GRIDAPPSD_TAG_ENV` either by `export GRIDAPPSD_TAG_ENV=other_tag` or by executing pytest with the following:```shell script# Export environmental variables and all tests will use the same tag (other_tag) to pull from docker hub.# Default tag is developexport GRIDAPPSD_TAG_ENV=other_tagpytest# Tests also require the username and password to be avaialable as environmental variables # in order for them to properly run these testsexport GRIDAPPSD_USER=userexport GRIDAPPSD_PASSWORD=passpytest``` ***NOTE: the first running the tests will download all of the docker images associated with the [GOSS-GridAPPS-D](http://github.com/GRIDAPPSD/GOSS-GridAPPS-D) repository.  This process may take some time.*** ### Running tests created in a new projectThe `gridappsd-python` library exposes a testing environment through the `gridappsd.docker_handler` module.  Including the following`conftest.py` in the root of your base test directory allows tests to reference these.  Using these fixtures will start all of thebase containers required for `gridappsd` to run.  ```python# conftest.py# Create a conftest.py file in the root of the tests directory to enable usage throughout the tests directory and below. # # Tested project structure an layout## project-folder\#   mainmodule\#     __init__.py#     myapplication.py#   tests\#     conftest.py#     test_myapplication.py#   README.mdimport loggingimport osimport sysimport pytestfrom gridappsd import GridAPPSD, GOSSfrom gridappsd.docker_handler import run_dependency_containers, run_gridappsd_container, Containerslevels = dict(    CRITICAL=50,    FATAL=50,    ERROR=40,    WARNING=30,    WARN=30,    INFO=20,    DEBUG=10,    NOTSET=0)# Get string representation of the log level passedLOG_LEVEL = os.environ.get(&quot;LOG_LEVEL&quot;, &quot;INFO&quot;)# Make sure the level passed is one of the valid levels.if LOG_LEVEL not in levels.keys():    raise AttributeError(&quot;Invalid LOG_LEVEL environmental variable set.&quot;)# Set the numeric version of log level to pass to the basicConfig functionLOG_LEVEL = levels[LOG_LEVEL]logging.basicConfig(stream=sys.stdout, level=LOG_LEVEL,                    format=&quot;%(asctime)s|%(levelname)s|%(name)s|%(message)s&quot;)logging.getLogger(&quot;urllib3.connectionpool&quot;).setLevel(logging.INFO)logging.getLogger(&quot;docker.utils.config&quot;).setLevel(logging.INFO)logging.getLogger(&quot;docker.auth&quot;).setLevel(logging.INFO)STOP_CONTAINER_AFTER_TEST = os.environ.get('GRIDAPPSD_STOP_CONTAINERS_AFTER_TESTS', True)@pytest.fixture(scope=&quot;module&quot;)def docker_dependencies():    print(&quot;Docker dependencies&quot;)    # Containers.reset_all_containers()    with run_dependency_containers(stop_after=STOP_CONTAINER_AFTER_TEST) as dep:        yield dep    print(&quot;Cleanup docker dependencies&quot;)@pytest.fixturedef gridappsd_client(request, docker_dependencies):    with run_gridappsd_container(stop_after=STOP_CONTAINER_AFTER_TEST):        gappsd = GridAPPSD()        gappsd.connect()        assert gappsd.connected        models = gappsd.query_model_names()        assert models is not None        if request.cls is not None:            request.cls.gridappsd_client = gappsd        yield gappsd        gappsd.disconnect()@pytest.fixturedef goss_client(docker_dependencies):    with run_gridappsd_container(stop_after=STOP_CONTAINER_AFTER_TEST):        goss = GOSS()        goss.connect()        assert goss.connected        yield goss```Using the above fixtures from inside a test module and test function looks like the following:```python# Example test function using the gridappsd_client fixture @mock.patch.dict(os.environ, {&quot;GRIDAPPSD_APPLICATION_ID&quot;: &quot;helics_goss_bridge.py&quot;})def test_gridappsd_status(gridappsd_client):    gappsd = gridappsd_client    assert &quot;helics_goss_bridge.py&quot; == gappsd.get_application_id()    assert gappsd.get_application_status() == ProcessStatusEnum.STARTING.value    assert gappsd.get_service_status() == ProcessStatusEnum.STARTING.value    gappsd.set_application_status(&quot;RUNNING&quot;)    assert gappsd.get_service_status() == ProcessStatusEnum.RUNNING.value    assert gappsd.get_application_status() == ProcessStatusEnum.RUNNING.value    gappsd.set_service_status(&quot;COMPLETE&quot;)    assert gappsd.get_service_status() == ProcessStatusEnum.COMPLETE.value    assert gappsd.get_application_status() == ProcessStatusEnum.COMPLETE.value    # Invalid    gappsd.set_service_status(&quot;Foo&quot;)    assert gappsd.get_service_status() == ProcessStatusEnum.COMPLETE.value    assert gappsd.get_application_status() == ProcessStatusEnum.COMPLETE.value```</longdescription>
</pkgmetadata>