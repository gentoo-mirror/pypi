<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Task Assembly ClientTools for working with the Task Assembly service for managing crowdwork projects.## Initial SetupStart by installing the task-assembly client by running the following command.```shellpip install task-assembly```Note that the task-assembly client uses some AWS resources. If you haven't done so already, you will need to installthe AWS CLI and configure it with your credentials (`aws configure`) before using the client. Next, run the following command to configure your Task Assembly API key:```shelltask-assembly configure --key &lt;api-key&gt;```At any point, you can run the following command to check that your account has been correctly configured:```shelltask-assembly configure --validate```## Example projectIf you are new to Task Assembly, you can start with a small sample project by running `task-assembly example` to copy a set of files to your working directory. These can be used with the instructions below to set up your firstproject and help you build familiarity with how Task Assembly works.## Project setupFirst, we'll need to create a task-type for this project. This is just a placeholder and will be removed infuture updates to Task Assembly. Simply run the following command and capture the id that is generated.When building the example application, use `NumbersExample` as the type name.```shelltask-assembly create_task_type &lt;type_name&gt;```Now, we'll want to create a new Task Definition for our task using the Task Type created in the previous step.When building the example application, use `Numbers` as the definition name.```shelltask-assembly create_task_definition &lt;definition_name&gt; &lt;task_type_id&gt;```This will generate a new definition for our project and write a definition.json file that we will use to captureour task attributes.## Build the Task DefinitionNow we can update the `definition.json` file with the appropriate attributes for our task. We've includedthe core attributes for the example task below:```yamlDefinitionId: &lt;your_definition_id&gt;TaskType: &lt;your_task_type_id&gt;Title: Convert number to textDescription: Write out a number as textRewardCents: 10Lifetime: 3600AssignmentDuration: 300DefaultAssignments: 2MaxAssignments: 5AutoApprovalDelay: 0```You can now run the following command to update the definition in Task Assembly:```shelltask-assembly update_task_definition```The task interface for our project is in the `template.html` file, and you will note that it uses a very similar templating language as Amazon SageMaker Ground Truth and the Amazon MTurk website. In most cases you can simplycopy/paste existing task templates from those tools and update the variable names within the `{{ name }}` values.To apply this new task template to our definition, we can simply add a reference to it in our `definition.json` file:```yamlTemplateFile: template.html```Then run the `update_task_defintion` command again.```shelltask-assembly update_task_definition```The `update_task_definition` command can be used to submit any future changes you make to your definition.json.## Create a task in the sandboxNow that we've completed the setup for our task, we should start by creating a test task in the *Sandbox* environment.The Sandbox is a mirror of the Production environment but no money changes hands and work isn't generally completedunless you do it yourself. This is a great way to validate that your task is set up correctly before putting it in thehands of *real* Workers.Note: The MTurk Sandbox is distinct from the Production environment, you will want to create a new account athttps://requestersandbox.mturk.com with the same email address as your Production account and also link it to the sameAWS account.To create a single MTurk task in the Sandbox, you can use the following command. The `--sandbox` flag lets TaskAssembly know to create the task in the appropriate environment and the `--assignments 1` flag indicates that weonly need to ask one Worker to provide an answer to the task (just you). Finally, `number=4` provides the inputdata to our task interface which refers to `{{ number }}` from the html template.```shelltask-assembly create_task --sandbox --assignments 1 number=4```Take note of the task ID that is returned. You'll need that to retrieve the results.This will create a new task for you in the Worker Sandbox, which you can view and work on by visitinghttps://workersandbox.mturk.com. You'll likely need to create an account there, feel free to use your personal Amazon account or any other account you wish. Once you're logged in, you can search for your username orthe title of the task. Then you can accept and complete the task.After you've completed your task, give MTurk and Task Assembly a few moments to process the result. Then run the following to get the output.```shelltask-assembly get_task &lt;task_id&gt;```## Create a *real* taskNow we can repeat the same process to create a task in the Production environment by simply removing the`--sandbox` and `--assignments` flags.```shelltask-assembly create_task number=4```The same `get_task` command can be used to retrieve results of the created task.## Result ProcessingYou may have noticed that the task result above includes `Result` and `Responses` values that looks a bit like this:```json{  &quot;Result&quot;: {    &quot;default&quot;: [      {        &quot;WorkerId&quot;: &quot;A12NBGVI9QN3DQ&quot;,        &quot;Result&quot;: {          &quot;default&quot;: {            &quot;numberAsText&quot;: &quot;Four&quot;          }        },        &quot;AssignmentId&quot;: &quot;3ERMJ6L4DYRPC5L5VMTQ0TYQKQG7M2&quot;      },      {        &quot;WorkerId&quot;: &quot;ACKG8OU1KHKO2&quot;,        &quot;Result&quot;: {          &quot;default&quot;: {            &quot;numberAsText&quot;: &quot;four&quot;          }        },        &quot;AssignmentId&quot;: &quot;3FTYUGLFSUK7L719U0FQJJX0K6T5D3&quot;      }    ]  },  &quot;Responses&quot;: [    {      &quot;WorkerId&quot;: &quot;A12NBGVI9QN3DQ&quot;,      &quot;Result&quot;: {        &quot;default&quot;: {          &quot;numberAsText&quot;: &quot;Four&quot;        }      },      &quot;AssignmentId&quot;: &quot;3ERMJ6L4DYRPC5L5VMTQ0TYQKQG7M2&quot;    },    {      &quot;WorkerId&quot;: &quot;ACKG8OU1KHKO2&quot;,      &quot;Result&quot;: {        &quot;default&quot;: {          &quot;numberAsText&quot;: &quot;four&quot;        }      },      &quot;AssignmentId&quot;: &quot;3FTYUGLFSUK7L719U0FQJJX0K6T5D3&quot;    }  ]}```This output is the `default` structure that Task Assembly uses and ensures that all the relevant data is included.Of course, simplifying this output is preferred and will greatly simplify downstream data processing. To do this, we'lluse `handlers` that will perform data processing on each response and completed task. In most cases, AWS Lambda functions are the best option for these steps and Task Assembly helps this process by generating the Lambdas on your behalf if you wish. This tutorial will use Task Assembly to manage the Lambdas, but you're welcome to create and deploythem normally using your preferred approach (Console, Cloud Formation, CDK, etc).If building the example application you'll find the handler code for this tutorial in the `handlers.py` file. The first function `process_response` simply retrieves the `numberAsText` form field and returns it. We can pull it into our project adding the following to our `definition.json`:```yamlHandlerFile: handlers.pySubmissionHandlers:- Name:  value  FunctionName:  process_response```This tells Task Assembly to run the `process_response` on the form outputs and return it in an attribute name `value`.To test how this impacts task results, run the following to update the task definition and then *redrive* the taskresults to reprocess the results:```shelltask-assembly update_task_definitiontask-assembly redrive_task &lt;task-id&gt;```Now the `Responses` list should be the following, simpler, representation of the Worker responses.```json[  {    &quot;WorkerId&quot;: &quot;A12NBGVI9QN3DQ&quot;,    &quot;Result&quot;: {      &quot;value&quot;: &quot;Four&quot;    },    &quot;AssignmentId&quot;: &quot;3ERMJ6L4DYRPC5L5VMTQ0TYQKQG7M2&quot;  },  {    &quot;WorkerId&quot;: &quot;ACKG8OU1KHKO2&quot;,    &quot;Result&quot;: {      &quot;value&quot;: &quot;four&quot;    },    &quot;AssignmentId&quot;: &quot;3FTYUGLFSUK7L719U0FQJJX0K6T5D3&quot;  }]```Next, we want to consolidate these two responses into a single value as a result for this task. To do that, we'll add a *consolidation* handler. The `consolidate_result` function in the example handles this step by simply looking for agreement between Workers. If two Workers agree, then we'll use that result. If not, we'll return `{'extend': True}` which will prompt Task Assembly to ask an additional Worker to provide a response, up to the `MaxAssignments`. To addthis function to our task definition, we simply include the following in our `definition.json`.```yamlHandlerFile: handlers.pySubmissionHandlers:- Name:  value  FunctionName:  process_responseConsolidationHandlers: - Name: value  FunctionName: consolidate_result```Running `update_task_definition` and `redrive_task` will invoke this new consolidation logic, and we will now have asingle value result for our task.```json{  &quot;value&quot;: &quot;four&quot;}```## Create a batchNow that our task is set up, we can run it on a larger set of data. If using the example, the `batch.csv` file contains a small batch of data. It is simply a single column CSV with column header `number` that corresponds to our task input, but multiple values can be used for more complex projects. To submit the batch, the following command can be used. The first parameter is the name we want to give the batch `numbers1`, followed by the source data file for the batch, `batch.csv`. Finally, we provide an S3 location we will use to store the input and output files created by Task Assembly.```shelltask-assembly submit_batch numbers1 batch.csv s3://taskassembly-test/batches```The result is a batch_id we can use to monitor progress and retrieve the results. To get batch status, the followingcan be used:```shelltask-assembly get_batch_status &lt;batch_id&gt;```This command can be used to monitor your batch progress. When the batch is complete, running the followingto retrieve the results to a CSV file.```shelltask-assembly get_batch_results &lt;batch_id&gt; output.csv```## Improving QualityThe last step is to establish some test tasks that we can use to ensure we're getting Workers who will do a good job on our task. For the example we've created a data file of known or *gold* answers in `gold.json`.When Workers first start working on this task they will be prompted to answer at least two of these beforethey can work on our *real* data.To evaluate accuracy, we'll add a new handler `score_response` that scores each Worker's response. Forthis we'll use a very simple comparison and give them a score of 100 if they provide an exact match,80 if they don't match on the inclusion of &quot;and&quot; or &quot;-&quot; in their answer (i.e. &quot;twenty-four&quot; or &quot;one hundred and six&quot;), and 0 if they still don't match.The following statements can be added to our `definition.json` file to enable scoring of new workers.As you can see, Workers will need to complete at least two tests with an average score of 80 before they can begin working on the *real* tasks. Note that because it generally takes at least 10-15 seconds before scoring is complete so Workers will often be asked to do a third test if they quickly accept anothertask after completing their second test.```yamlScoringHandler:   FunctionName: score_responseGoldAnswersFile: gold.jsonTestPolicy:  MinTests: 2  MinScore: 80```We can now create a new batch to begin using the new scoring that we've created. However, because scoringdoesn't work well with small batches, expand the size of your `batch.csv` file to at least 20 numbersbefore submitting a new batch to Workers. This limitation is a result of how MTurk handles HITs withfewer than 10 Assignments and will be addressed in a future release of Task Assembly.Even with a larger set items in this test batch, you may not get responses for all of your items, howeversubsequent batches should have higher yield.Once you've submitted a new batch, you'll note that `get_batch_results` will now show test responses inthe results. Because this is the first time we've run a batch with scoring enabled, all Workers will needto complete 2-3 test tasks. This means that we'll see a larger number of test responses and fewer *Task*responses in our counts. In future batches the portion of responses associated with tests will steadilydecline.``` - Response Counts:     Task: 36     Test: 109     Total: 145```To see how Workers did on your tests and their relative contribution to the final output, run`task_assembly list_workers workers.csv` to generate a report on how many responseseach Worker has provided for this task definition and their scores on the test tasks.### Additional test optionsThere are two additional policy options you can use to better control how tests are assigned, `ConsumeAssignments` and `MinTestPercentage`.The `ConsumeAssignments` flag can be set to modify how Task Assembly decides to assign tasks to Workers.By default, Task Assembly will assign the *real* task to a Worker who hasn't completed all of their tests yet if there aren't enough available Assignments to meet the requested `DefaultAssignments`. For example,if we have `DefaultAssignments` of 2 and 7 Workers have already completed tests using this HIT, then TaskAssembly will ensure we get a result, regardless of whether they have completed any tests. *MTurk will not allow a HIT to have more than 9 Assignments if it starts with less than 10.*By setting `ConsumeAssignments` to true, we let TaskAssembly know that it should enforce the test policy,regardless of available Assignments.```yamlTestPolicy:  ConsumeAssignments: true  MinTests: 2  MinScore: 80  MinTestPercentage: 3```The `MinTestPercentage` tells Task Assembly to continually test Workers to ensure that their work continues to be of good quality. In this case, setting the value to *3* tells Task Assembly that 3% of a Worker's tasksshould be tests.### Building *gold* dataA good practice for building a set of gold data you can use for testing is to do the work yourself in the MTurk Sandbox and then using your test responses as gold. To start simply create a test batch using a sampleof your input data.```shelltask-assembly submit_batch numbers_sample sample_data.csv s3://taskassembly-test/batches --sandbox --assignments 1```You can now complete this batch in the MTurk Worker Sandbox (https://workersandbox.mturk.com/). When the workis complete you can run the following command to generate a gold.json file containing a formatted gold setbased on your responses.```shelltask-assembly build_gold_from_batch &lt;batch-id&gt;```</longdescription>
</pkgmetadata>