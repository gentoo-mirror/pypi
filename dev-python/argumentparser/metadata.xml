<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>A utility class for parsing command-line arguments.Constructor: | @param names list&lt;string&gt; - This is a list of &quot;names&quot; which should reflect each argument. | @param shortOptions list&lt;string&gt;  - This is a list of short (-x val) options. Length should match names. If no short option is available, use 'None'. Omit the leading - | @param longOptions  list&lt;string&gt;  - This is a list of long (--xyz val or --xyz= val) options. If no long option is available, use 'None'. Omit the leading -- | @param staticOptions list&lt;string&gt; - This is a list of static options (arguments that have meaning just being present, without taking an additional value). |                                           Any members of this list will be present in the results of #parse, set to True is present, otherwise False. | @param multipleStaticOptions &lt;dict&gt; - A dictionary for multiple static arguments that resolve to one value. Key is the &quot;name&quot;, values are all potential values. Ex: {'cheese' : ['--cheddar', 'gouda'] } presence of either 'gouda' or '--cheddar' in results would set cheese to True, otherwise False. | @param allowOtherArguments &lt;bool&gt; default False - if False, consider non-specified arguments as errors. Regardless of value, unmatched params will be in 'unmatched' key of return value.Functions: | def parse(args) |    parse - Parses provided arguments and returns information on them. If using sys.argv, omit the first argument. | @return - dict keys are |            'result' =&gt; dictionary of result name-&gt;value |            'errors'  =&gt; list of strings of errors or empty list |            'warnings' =&gt; list of strings of warnings, or empty list |            'unmatched' =&gt; list of strings of unmatched params, in orderExample: | In [1]: from ArgumentParser import ArgumentParser | In [2]: parser = ArgumentParser(['firstName', 'lastName', 'birthday'],  |   ...:     ['f', 'l', 'b'],  |   ...:     ['first-name', 'last-name', 'birthday'],  |   ...:     ['--citizen']  |   ) | | In [3]: parser.parse('-f Tim --last-name=savannah --birthday 6/28'.split(' ')) | Out[3]: | {'errors': [], |  'result': {'--citizen': False, |  'birthday': '6/28', |  'firstName': 'Tim', |  'lastName': 'savannah'}, |  'warnings': [], |  'unmatched' : []} | | In [4]: parser.parse('-f Tim --last-name=savannah --citizen'.split(' ')) | Out[4]: | {'errors': [], |  'result': {'--citizen': True, 'firstName': 'Tim', 'lastName': 'savannah'}, |  'warnings': [], |  'unmatched': []}Example2: |  &gt;&gt;&gt; from ArgumentParser import ArgumentParser |  &gt;&gt;&gt; parser = ArgumentParser(['name'], ['n'], ['name'], None, False) |  &gt;&gt;&gt; parser.parse('-n hello some other args'.split(' ')) |  {'errors': [&quot;Unknown argument 'some' (at position 2)&quot;, &quot;Unknown argument 'other' (at position 3)&quot;, &quot;Unknown argument 'args' (at position 4)&quot;], 'result': {'name': 'hello'}, 'unmatched': ['some', 'other', 'args'], 'warnings': []} |  &gt;&gt;&gt; parser = ArgumentParser(['name'], ['n'], ['name'], None, True) |  &gt;&gt;&gt; parser.parse('-n hello some other args'.split(' ')) |  {'errors': [], 'result': {'name': 'hello'}, 'unmatched': ['some', 'other', 'args'], 'warnings': []}Example3: |  &gt;&gt;&gt; import ArgumentParser |  &gt;&gt;&gt; parser = ArgumentParser.ArgumentParser( ('one', 'two'), ('o', 't'), ('uno', 'dos'), ('x'), {'cheese' : ['cheddar', 'gouda'], 'baby' : {'child', 'infant'}} ) |  &gt;&gt;&gt; parser.parse(['-o', '1', 'cheddar']) |  {'errors': [], 'result': {'baby': False, 'cheese': True, 'x': False, 'one': '1'}, 'unmatched': [], 'warnings': []}</longdescription>
</pkgmetadata>