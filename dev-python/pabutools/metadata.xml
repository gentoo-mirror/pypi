<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pabutools[![Build badge](https://github.com/pbvoting/pabutools/workflows/build/badge.svg?branch=main)](https://github.com/pbvoting/pabutoolsactions?query=workflow%3Abuild)[![codecov](https://codecov.io/gh/pbvoting/pabutools/branch/main/graphs/badge.svg)](https://codecov.io/gh/pbvoting/pabutools/tree/main)## OverviewThe pabutools are a complete set of tools work withparticipatory budgeting instances.Participatory budgeting (PB) is a democratic tool used to allocatea given amount of money to a collection of projects based on agroup of individuals' preferences over the projects. It has been inventedin Brazil in the late 80's and is now a widely implemented. See the[Wikipedia page](https://en.wikipedia.org/wiki/Participatory_budgeting)for more details.In this library we provide the tools to handle PB instances of differentkinds, together with voting rules to determine the outcome of the electionsand some analytic tools. In particular, we provide full support for theinstances taken from [pabulib](http://pabulib.org), the reference librarywhen it comes to PB data.## InstallationUltimately, the goal is to host this library on pip. For now, use thesource code provided here.## DocumentationThe complete documentation is available [here](https://pbvoting.github.io/pabutools/).## Usage### InstancesA PB instance describes all the elements that define the elections.It includes the projects that are being voted on, together with thebudget limit.The main class here is `Instance`. This class inheritsfrom the Python class `set` and behaves as a set of projects,with additional information. Projects are instantiations of theclass `Project` that stores a project' name and cost(and potential additional information). Let's see an example.```pythonfrom pabutools.election import Instance, Projectinstance = Instance()   # There are many optional parametersp1 = Project(&quot;p1&quot;, 1)   # The constructor takes name and cost of the projectinstance.add(p1)   # Use the set methods to add/delete projects to an instancep2 = Project(&quot;p2&quot;, 1)instance.add(p2)p3 = Project(&quot;p3&quot;, 3)instance.add(p3)```Importantly, any Python comparison between two projects (equality etc...) isdone on the name of the projects. Since an instance is a set, adding aproject `Project(&quot;p&quot;, 1)` and another project `Project(&quot;p&quot;, 3)`will only lead to an instance with one element.An instance also stores additional information such as the budget limitof the election, and additional metadata.```pythoninstance.budget_limit = 3   # The budget limitinstance.meta   # dict storing metadata on the instanceinstance.project_meta   # dict of (project, dict) storing metadata on the projects```Several methods can be called on an instance to run through all thebudget allocations, test the feasiblity of a set of projects etc...```pythonfor b in instance.budget_allocations():    print(str(b) + &quot; is a feasible budget allocation&quot;)instance.is_feasible([p1, p2, p3])   # Returns Falseinstance.is_exhaustive([p1, p2])   # Returns True```### ProfilesA profile is the second basic component of a PB election, it storesthe ballots of the voters.We provide one general class `Profile` that inherits from the Python`list` and that is inherited from by all specific profile types. Itis really meant to be an abstract class and should not really be used forany other purpose than inheritance. Similarly, we provide a class`Ballot` that will be inherited by specific ballot formats.A profile is linked to an instance, which is given as a parameter, and thenstored in an attribute. It also implements a validation of the ballots toensure consistency of the ballots in a profile.```pythonfrom pabutools.election import Instance, Profile, Ballotinstance = Instance()profile = Profile(instance=instance)profile.ballot_validation = True   # Boolean (de)activating the validation of the ballot typeprofile.ballot_type = Ballot   # The type used for the ballot validationb = {1, 2, 3}profile.validate_ballot(b)   # The validator, would raise a TypeError here```#### Approval ProfilesWhen submitting approval ballots, voters submit a set of projects theyapprove of. Approval ballots are represented through the class`ApprovalBallot` that inherits both from `set` and from`Ballot`.A profile of approval ballots, i.e., an approval profile, is instantiatedfrom the class `ApprovalProfile`. It inherits from `Profile`.The type for the ballot validator is by default set to `ApprovalBallot`.```pythonfrom pabutools.election import Project, ApprovalBallot, ApprovalProfileprojects = [Project(&quot;p{}&quot;.format(i), 1) for i in range(10)]b1 = ApprovalBallot(projects[:3])   # Approval ballot containing the first 3 projectsb1.add(projects[4])   # Add project to approval ballotb2 = ApprovalBallot(projects[1:5])profile = ApprovalProfile([b1, b2])b3 = ApprovalBallot({projects[0], projects[8]})profile.append(b3)b1 in profile   # Tests membership, returns True here```Several additional methods are provided in the `ApprovalProfile` class.```pythonprofile.approval_score(p1)   # The approval score of a project, i.e., the number of approversprofile.is_party_list()   # Boolean indicating if the profile is party_list```#### Cardinal ProfilesWhen asked for cardinal ballots, voters are asked to associate each projectwith a score. Cardinal ballots are represented using the class`CardinalBallot`. It inherits directly from the Python`dict` class and our `Ballot` class.A profile of cardinal ballots, i.e., a cardinal profile, is instantiatedthrough the `CardinalProfile` class. It inherits from the`Profile` class and validates ballot types using`CardinalBallot`.```pythonfrom pabutools.election import Project, CardinalBallot, CardinalProfileprojects = [Project(&quot;p{}&quot;.format(i), 1) for i in range(10)]b1 = CardinalBallot({projects[1]: 5, projects[2]: 0})   # Cardinal ballot scoring 5 for p1 and 0 for p2b2 = CardinalBallot()b2[projects[0]] = 9   # Assign score to p0profile = CardinalProfile([b1, b2])```#### Cumulative ProfilesCumulative ballots correspond to a specific type of cardinal ballots wherethe voters are allocated a specific number of points that they candistribute among the projects. The class `CumulativeBallot`is used to deal with cumulative ballots. It inherits from`CardinalBallot` and thus also from the Python class`dict`.As before, a profile of cumulative ballots is defined in the class`CumulativeProfile` that inherits from the `Profile` class(and act thus as a list).#### Ordinal ProfilesWhen ordinal ballots are used, voters are asked to order the projectsbased on their preferences. The class `OrdinalBallot` representssuch ballots. It inherits from the Python class `list` and ourclass `Ballot`.Ordinal profiles are handled by the class `OrdinalProfile`.```pythonfrom pabutools.election import Project, OrdinalBallot, OrdinalProfileprojects = [Project(&quot;p{}&quot;.format(i), 1) for i in range(10)]b1 = OrdinalBallot((projects[0], projects[4], projects[2]))   # Ordinal ballot ranking p0 &gt; p4 &gt; p2b1.append(projects[1])   # The ballot becomes p0 &gt; p4 &gt; p2 &gt; p1profile = OrdinalProfile()profile.append(b1)```#### PabulibWe provide full support of the PB data hosted on the[pabulib](http://pabulib.org) website. The function`pabutools.election.parse_pabulib` can be used to parse a fileformatted according to the pabulib format. It returns the instanceand the profile, using the suitable profile class given the ballotformat in the data.```pythonfrom pabutools.election import parse_pabulibinstance, profile = parse_pabulib(&quot;path_to_the_file&quot;)```Pabulib files provide a whole range of metadata, not all of which arerelevant to everyone. These metadata are stored in the `meta`members of the instance and profile classes.```pythonfrom pabutools.election import parse_pabulibinstance, profile = parse_pabulib(&quot;path_to_the_file&quot;)instance.meta   # The meta dict is populated with all the metadata described in the fileinstance.project_meta    # The project_meta dict is populated with the metadata related to the projectsfor ballot in profile:    ballot.meta    # The meta dict populated with the metadata corresponding to the ballot```There are several metadata that are stored as members of the relevantclasses. These for instance include all the constraints (when known)the voters faced when submitting their ballots. It includes the minimumlength of a ballot, or the number of points that have to be distributedfor instance.```python### For ApprovalProfile, CardinalProfile, CumulativeProfile and OrdinalProfileprofile.legal_min_length   # Imposed minimum length of the ballots in the profileprofile.legal_max_length   # Imposed maximum length of the ballots in the profile### For ApprovalProfile onlyprofile.legal_min_cost   # Imposed minimum total cost of the ballots in the profileprofile.legal_max_cost   # Imposed maximum total cost of the ballots in the profile### For CardinalProfile and CumulativeProfileprofile.legal_min_score   # Imposed minimum score assigned to a project for the ballots in the profileprofile.legal_max_score   # Imposed maximum score assigned to a project for the ballots in the profile### For CumulativeProfile onlyprofile.legal_min_total_score   # Imposed minimum total scores for the ballots in the profileprofile.legal_max_total_score   # Imposed maximum total scores for the ballots in the profile```### SatisfactionMany concepts, including celebrated PB rules, are not using the ballotsdirectly but rather proxies for the satisfaction of the voters that arededuced from the ballots.We provide many satifaction functions, and flexible ways to create new ones.A satisfaction function is a class that inherits from `Satisfaction`,i.e., a class initialised for a given instance, profile, and ballot andthat implements a `sat` method that is used to compute thesatisfaction. Since a satisfaction function corresponds to a single ballot,we also provide a `SatisfactionProfile` class. This class inheritsfrom the Python class `list` and implements a satisfaction profile.The typical workflow is thus to gather the ballots in a profile, thenconvert it into a collection of satisfaction functions, that are finallyprovided as input of a rule.```pythonfrom pabutools.election import SatisfactionProfile, SatisfactionMeasurefrom pabutools.election import parse_pabulibinstance, profile = parse_pabulib(&quot;path_to_the_file&quot;)sat_profile = SatisfactionProfile(instance=instance)# We define a satisfaction function:class MySatisfaction(SatisfactionMeasure):    def sat(self, projects):        return 100 if &quot;p1&quot; in projects else len(projects)# We populate the satisfaction profilefor ballot in profile:    sat_profile.append(MySatisfaction(instance, profile, ballot))# The satisfaction profile is ready for useoutcome = rule(sat_profile)```Because the above can be tedious, we provide simpler ways to define thesatisfaction profile. Several widely used satisfaction functions are alsodirectly provided.```pythonfrom pabutools.election import SatisfactionProfile, Cardinality_Satfrom pabutools.election import parse_pabulibinstance, profile = parse_pabulib(&quot;path_to_the_file&quot;)# If a profile and a sat_class are given to the constructor, the satisfaction profile# is directly initialised with one instance of the sat_class per ballot in the profile.sat_profile = SatisfactionProfile(instance=instance, profile=profile, sat_class=Cardinality_Sat)# The satisfaction profile is ready for useoutcome = rule(sat_profile)```We now present useful tools we provide to define satisfaction functions.#### Functional Satisfaction FunctionsWe also provide more specific ways of defining satisfaction function.The class `FunctionalSatisfaction` corresponds to satisfactionfunction that are defined by a function taking as argument an instance,a profile, a ballot and a set of projects. We illustrate its use bydefining the Chamberlin-Courant satisfaction function with approval(equals to 1 if at least one approved project is selected and0 otherwise).```pythonfrom pabutools.election import FunctionalSatisfactiondef cc_sat_func(instance, profile, ballot, projects):    return int(any(p in ballot for p in projects))class CC_Sat(FunctionalSatisfaction):        def __init__(self, instance, profile, ballot):            super(CC_Sat, self).__init__(instance, profile, ballot, cc_sat_func)```#### Additive Satisfaction FunctionsAnother important set of satisfaction functions are the additive ones,i.e., the ones for which the satisfaction for a set of projects isequal to the satisfaction of each individual project. The class`AdditiveSatisfaction` implements them. It inherits from the`Satisfaction` class and its constructor takes as a parametera function mapping instance, profile, ballot and project to a score.We illustrate its use by presenting how to define the cardinalitysatisfaction function.```pythonfrom pabutools.election import AdditiveSatisfactiondef cardinality_sat_func(instance, profile, ballot, project):    return int(project in ballot)class Cardinality_Sat(AdditiveSatisfaction):    def __init__(self, instance, profile, ballot):        super(Cardinality_Sat, self).__init__(instance, profile, ballot, cardinality_sat_func)```#### Positional Satisfaction FunctionsPositional satisfaction functions are to be used with ordinal ballots.When using them, the satisfaction of a voter is a function of theposition of the projects in the ballot of the voter. The class`PositionalSatisfaction` implements them. The constructor takesas parameters two functions: one mapping ballots and projects to a score,and a second one aggregating the individual scores for sets of projects.We illustrate its usage by defining the additive Borda satisfactionfunction.```pythonfrom pabutools.election import PositionalSatisfactiondef borda_sat_func(ballot, project):    if project not in ballot:        return 0    return len(ballot) - ballot.index(project)class Additive_Borda_Sat(PositionalSatisfaction):    def __init__(self, instance, profile, ballot):        super(Additive_Borda_Sat, self).__init__(instance, profile, ballot, borda_sat_func, sum)```#### Satisfaction Functions Already DefinedAs we have seen above, several satisfaction functions are already definedin the library and can be imported from `pabutools.election`. We listthem below.- `CC_Sat` implements the Chamberlin-Courant satisfaction function for approval ballots.- `Cost_Sqrt_Sat` defines the satisfaction as the square root of the total cost of the selected and approed projects.- `Cost_Log_Sat` defines the satisfaction as the log of the total cost of the approved and selected projects.- `Cardinality_Sat` defines the satisfaction as the number of approved and selected projects.- `Cost_Sat` defines the satisfaction as the total cost of the approved and selected projects.- `Effort_Sat` defines the satisfaction as the total share of a voter- `Additive_Cardinal_Sat` defines the satisfaction as the sum of the scores of the selected projects, where the scores are taken from the cardinal ballot of the voter.- `Additive_Borda_Sat` defines the satisfaction as the sum of the Borda scores of the selected projects.### RulesSee the module `pabutools.rules`.#### Approximation of Social Welfare OptimumSee the module `pabutools.rules.greedywelfare`.#### Method of equal sharesSee the module `pabutools.rules.mes`.#### Tie-BreakingSee the module `pabutools.tiebreaking`.## DevelopmentWe are more than happy to receive help with the development of the package.If you want to contribute, here are some elements to take into account.First, install the development dependencies by running the following command:```shellpip install -e &quot;.[dev]&quot;```You can run the unit tests with the following:```shellpython -m unittest```The doc is generated using sphinx. We use the [numpy style guide](https://numpydoc.readthedocs.io/en/latest/format.html).The [napoleon](https://www.sphinx-doc.org/en/master/usage/extensions/napoleon.html) extension for Sphinx is usedand the HTML style is defined by the [Book Sphinx Theme](https://sphinx-book-theme.readthedocs.io/en/stable/).To generate the doc, first move inside the `docs-source` folder and run the following:```shellmake clean make html```This will generate the documentation locally (in the folder `docs-source/build`). If you want the documentation to also be updated when pushing, run:```shellmake github```After having pushed, the documentation will automatically be updated.Note that a large part of the documentation is done by hand (to ensure proper display and correct ordering). This means that if you create new class of functions that should appear in the documentation, you may haveto add they yourself using to autodoc directives (take inspiration from the files in `docs-source/source`). </longdescription>
</pkgmetadata>