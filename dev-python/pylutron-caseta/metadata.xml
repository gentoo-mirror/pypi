<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pylutron-casetaA Python API to control Lutron Caséta devices.[![Coverage Status](https://coveralls.io/repos/github/gurumitts/pylutron-caseta/badge.svg?branch=dev)](https://coveralls.io/github/gurumitts/pylutron-caseta?branch=dev)## Getting startedIf you don't know the IP address of the bridge, the `leap-scan` tool (requires the cli extra, `pip install pylutron_caseta[cli]`) will search for LEAP devices on the local network and display their address and LEAP port number.### AuthenticationIn order to communicate with the bridge device, you must complete the pairing process. This generates certificate files for authentication. pylutron_caseta can do this two ways.#### lap-pairIf pylutron_caseta is installed with the cli extra (`pip install pylutron_caseta[cli]`), the `lap-pair` tool can be used to generate the certificate files. Simply running `lap-pair &lt;BRIDGE HOST&gt;` (note the LEAP port number should not be included) will begin the pairing process. The certificate files will be saved in `$XDG_CONFIG_HOME/pylutron_caseta` (normally `~/.config/pylutron_caseta`) in the files `[BRIDGE HOST]-bridge.crt`, `[BRIDGE HOST].crt`,  `[BRIDGE HOST].key`. Check `lap-pair --help` if you want to use different files.#### The pairing moduleIf pylutron_caseta is being integrated into a larger application, the pairing functionality can be reused to allow pairing from within that application.```pyasync def pair(host: str):    def _ready():        print(&quot;Press the small black button on the back of the bridge.&quot;)    data = await async_pair(host, _ready)    with open(&quot;caseta-bridge.crt&quot;, &quot;w&quot;) as cacert:        cacert.write(data[&quot;ca&quot;])    with open(&quot;caseta.crt&quot;, &quot;w&quot;) as cert:        cert.write(data[&quot;cert&quot;])    with open(&quot;caseta.key&quot;, &quot;w&quot;) as key:        key.write(data[&quot;key&quot;])    print(f&quot;Successfully paired with {data['version']}&quot;)```### Connecting to the bridgeOnce you have the certificate files, you can connect to the bridge and start controlling devices.```pyimport asynciofrom pylutron_caseta.smartbridge import Smartbridgeasync def example():    # `Smartbridge` provides an API for interacting with the Caséta bridge.    bridge = Smartbridge.create_tls(        &quot;YOUR_BRIDGE_IP&quot;, &quot;caseta.key&quot;, &quot;caseta.crt&quot;, &quot;caseta-bridge.crt&quot;    )    await bridge.connect()    # Get the first light.    # The device is represented by a dict.    device = bridge.get_devices_by_domain(&quot;light&quot;)[0]    # Turn on the light.    # Methods that act on devices expect to be given the device id.    await bridge.turn_on(device[&quot;device_id&quot;])    await bridge.close()# Because pylutron_caseta uses asyncio,# it must be run within the context of an asyncio event loop.loop = asyncio.get_event_loop()loop.run_until_complete(example())```### The leap toolFor development and testing of new features, there is a `leap` command in the cli extras (`pip install pylutron_caseta[cli]`) which can be used for communicating directly with the bridge, similar to using `curl`.Getting information about the bridge:```$ leap 192.168.86.49/server | jq{  &quot;Servers&quot;: [    {      &quot;href&quot;: &quot;/server/1&quot;,      &quot;Type&quot;: &quot;LEAP&quot;,      &quot;NetworkInterfaces&quot;: [        {          &quot;href&quot;: &quot;/networkinterface/1&quot;        }      ],      &quot;EnableState&quot;: &quot;Enabled&quot;,      &quot;LEAPProperties&quot;: {        &quot;PairingList&quot;: {          &quot;href&quot;: &quot;/server/leap/pairinglist&quot;        }      },      &quot;Endpoints&quot;: [        {          &quot;Protocol&quot;: &quot;TCP&quot;,          &quot;Port&quot;: 8081,          &quot;AssociatedNetworkInterfaces&quot;: null        }      ]    }  ]}```Turning on the first dimmer:```$ ip=192.168.86.49$ device=$(leap &quot;${ip}/zone/status/expanded?where=Zone.ControlType:\&quot;Dimmed\&quot;&quot; | jq -r '.ZoneExpandedStatuses[0].Zone.href')$ leap -X CreateRequest &quot;${ip}${device}/commandprocessor&quot; -d '{&quot;Command&quot;:{&quot;CommandType&quot;:&quot;GoToLevel&quot;,&quot;Parameter&quot;:[{&quot;Type&quot;:&quot;Level&quot;,&quot;Value&quot;:100}]}}'```</longdescription>
</pkgmetadata>