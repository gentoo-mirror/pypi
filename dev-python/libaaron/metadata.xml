<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>libaaron========Just my library of handy functions I like to bring along. Other peoplemay feel free to copy this library, but they should not depend on it.The content and APIs are subject to change without notice... contents::``reify`` ----------``reify`` is a decorator I stole from the Pylons project that I like touse frequently.from the docstring:    Use as a class method decorator.  It operates almost exactly like the    Python ``@property`` decorator, but it puts the result of the method it    decorates into the instance dict after the first call, effectively    replacing the function it decorates with an instance variable.  It is, in    Python parlance, a non-data descriptor.``cached``----------``cached`` is a decorator that makes a property but caches its results.It's functionally similar to reify, but it dynamically creates a&quot;private&quot; attribute to cache the result instead of messing withdescriptors. This approach is comppatible with slots. I love slots.``w``-----``w`` is a function that takes an iterable with a context manager (likea file object) and yields from that iterable inside its context manager... code:: python  &gt;&gt;&gt; # instead of this:  &gt;&gt;&gt; with open('myfile.txt') as mf:  ...     for line in mf:  ...         # do something  ...  &gt;&gt;&gt; # you can do this:  &gt;&gt;&gt; for line in w(open('myfile.txt')):  ...     # do something  ... ``flatten``-----------``flatten`` is a function that takes an iterable as an arguments andrecursively yields all contents from nested iterables (except strings,which are yielded as strings). The optional second argument is afunction that will be used to convert any mappings into iterables beforeyielding from them (in the event you want to yield from their values orsomething else).``deepupdate``--------------Updates a dictionary from another dictionary, but doesn't overwriteentire branches of a tree in the case of nested dictionaries. I use itto combine the content from the system configuration file with a userconfiguration file... code:: python   &gt;&gt;&gt; import libaaron   &gt;&gt;&gt; a = {   ...     &quot;type&quot;: &quot;foo&quot;,   ...     &quot;content&quot;: {   ...         &quot;bar&quot;: &quot;baz&quot;,   ...         &quot;eggs&quot;: &quot;spam&quot;   ...     }   ... }   &gt;&gt;&gt; b = {   ...     &quot;content&quot;: {   ...         &quot;ham&quot;: &quot;sausage&quot;,   ...         &quot;bar&quot;: &quot;lol&quot;   ...     }   ... }   &gt;&gt;&gt; libaaron.deepupdate(a, b)   &gt;&gt;&gt; a   {       'type': 'foo',       'content': {           'bar': 'lol',           'eggs': 'spam',           'ham': 'sausage'        }   }There's also a ``listextend`` flag, which, when set to ``True``, ifthe value in both dictionaries are sequences, the sequence in ``a``will be extended with the contents of ``b``. This function can crashif dictionary a ``b`` has a mapping somewhere that ``a`` simply hasa string.``pipe``------------``pipe`` is a trivial function that takes an initial value and anynumber of functions as arguments applies them in a compositional manner.It is defined thusly:.. code:: python   def pipe(value, *functions):       for function in functions:           value = function(value)       return valueTherefore:.. code:: python   pipe(value, f, g, h) == h(g(f(value)))This is to avoid having to come up with a lot of intermediate variablenames on the one hand, or deeply nested function calls on the other.``pipeline``------------``pipeline`` is a wrapper on pipe that curries the functions and letsyou apply the initial arguments later... code:: python   pipline(f, g, h)(*args, **kwargs) == h(g(f(*args, **kwargs)))``fcompose``------------``fcompose`` gives math-like function composition. It's basicallyidentical to ``pipeline``, but with reverse application order... code:: python   # in math, this would look like `f ∘ g ∘ h`   fcompose(f, g, h)(*args, **kwargs) == f(g(h(*args, **kwargs)Note that there is nothing clever about how ``pipeline`` and``fcompose`` work. They aren't classes that simulate high-orderfunctions like ``functools.partial``, they are just normal high orderfunctions, and building pipelines upon pipelines isn't going to optimizeout the call stack.``pmap``, ``pfilter`` and ``preduce``-------------------------------------.. code:: python   pmap(f) == functools.partial(map, f)   pfilter(f) == functools.partial(filter, f)   preduce(f) == functools.partial(functools.reduce, f)Just convenience functions for currying ``map``, ``filter`` and``reduce``, which is something which freequently helpful when using theabove function composition functions.Allows stuff like this:.. code:: python   import sys   from libaaron import pipe, pmap, pfilter   shout_about_dogs = pipe(       sys.stdin,       pfilter(lambda line: &quot;dog&quot; in line.lower()),       pmap(str.upper)   )   # similar to:   shout_about_dogs = (l.upper() for l in sys.stdin if dog in l.lower())The comprehension syntax is obviously clearer in this case. ``pipe`` isuseful for longer iteration pipelines which can become unclear iffactored with comprehensions.``quiteinterrupt``------------------``quiteinterrupt`` is a function that adds a signal handler whichsilences the stacktrace when the a script is stopped with a keyboardinterrupt. It can optionally print a message on interrupt.``lxml_little_iter``--------------------``lxml_little_iter`` is only available if ``lxml`` is in theenvironment. It's for iterating over very large xml files with many ofthe same kinds of records at the top level (something that would be anarray in JSON). It is for iterating on data that is too large to fit inmemory.This generator function passes all ``*args`` an ``**kwargs`` to``lxml.etree.iterparse`` and yields the same ``(even, element)`` tuple.However, when the next item is retrieved, the previous element will becleared and all previous nodes are deleted. Thus, the ram is saved.``DotDict``-----------``DotDict`` is a subclass of dict which allows fetching items with dotsyntax. Useful as an ``object_hook`` when deserializing JSON, perhaps.``PBytes``----------``PBytes`` is a subclass of ``int`` which has a ``__str__`` that showsinterprets it as a number of bytes and make a human readable format. Itcan also parse a number of bytes from a string... code:: python  &gt;&gt;&gt; print(PBytes(2134963))  2.0 MiB  &gt;&gt;&gt; PBytes.from_str('35.8 KB')  PBytes(36659)  &gt;&gt;&gt; PBytes.from_str('35.8 KB', decimal=True)  PBytes(35800)Internally, it's just an integer, so you can do any integer operationswith it. Note that ``from_str`` does not attempt to determine whether itis a binary or decimal format. Default is binary. Use ``decimal=True``to explicitely change the behavior.It also has a ``human_readable`` method which returns a number and theunits for easily constructing alterative representations:.. code:: python  &gt;&gt;&gt; PBytes(83629).human_readable()  (81.6689453125, 'K')  &gt;&gt;&gt; '%d%s' % PBytes(83629).human_readable()  '81K'  &gt;&gt;&gt; '%d%s' % PBytes(83629).human_readable(decimal=True)  '83K'</longdescription>
</pkgmetadata>