<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;    &lt;img src=&quot;https://github.com/annotation/stam/raw/master/logo.png&quot; alt=&quot;stam logo&quot; width=&quot;320&quot; /&gt;&lt;/p&gt;[![Docs](https://readthedocs.org/projects/stam-python/badge/?version=latest&amp;style=flat)](https://stam-python.readthedocs.io)[![PyPI](https://img.shields.io/pypi/v/stam.svg)](https://pypi.org/project/stam/)[![PyPI](https://img.shields.io/pypi/dm/stam.svg)](https://pypi.org/project/stam/)[![GitHub build](https://github.com/annotation/stam-rust/actions/workflows/stam.yml/badge.svg?branch=master)](https://github.com/annotation/stam-rust/actions/)[![GitHub release](https://img.shields.io/github/release/annotation/stam-rust.svg)](https://GitHub.com/annotation/stam-rust/releases/)[![Project Status: Active â€“ The project has reached a stable, usable state and is being actively developed.](https://www.repostatus.org/badges/latest/active.svg)](https://www.repostatus.org/#active)# STAM Python binding[STAM](https://github.com/annotation/stam) is a data model for stand-off textannotation and described in detail [here](https://github.com/annotation/stam).This is a python library (to be more specific; a python binding written inRust) to work with the model.**What can you do with this library?*** Keep, build and manipulate an efficient in-memory store of texts and annotations on texts* Search in annotations, data and text:    * Search annotations by data, textual content, relations between text fragments (overlap, embedding, adjacency, etc),    * Search in text (incl. via regular expressions) and find annotations targeting found text selections.    * Search in data (set,key,value) and find annotations that use the data.    * Elementary text operations with regard for text offsets (splitting text on a delimiter, stripping text).    * Convert between different kind of offsets (absolute, relative to other structures, UTF-8 bytes vs unicode codepoints, etc)* Read and write resources and annotations from/to STAM JSON, STAM CSV, or an optimised binary (CBOR) representation    * The underlying [STAM model](https://github.com/annotation/stam) aims to be clear and simple. It is flexible and       does not commit to any vocabulary or annotation paradigm other than stand-off annotation.This STAM library is intended as a foundation upon which further applicationscan be built that deal with stand-off annotations on text. We implement all the low-level logic in dealing this so you no longer have to and can focus on your actual application.## Installation``$ pip install stam``Or if you feel adventurous and have the necessary build-time dependenciesinstalled (Rust), you can try the latest development release from Github:``$ pip install git+https://github.com/annotation/stam-python``## Documentation* [STAM Specification](https://github.com/annotation/stam) - the STAM specification itself* [API Reference](https://stam-python.readthedocs.io)* [STAM Tutorial: Standoff Text Annotation for Pythonistas](tutorial.ipynb) - An extensive tutorial showing how to work with this Python library, in the form of a Jupyter Notebook. **Recommended!**## Usage Import the library```pythonimport stam```Loading a STAM JSON (or CSV) file containing an annotation store:```pythonstore = stam.AnnotationStore(file=&quot;example.stam.json&quot;)```The annotation store is your workspace, it holds all resources, annotation sets(i.e. keys and annotation data) and of course the actual annotations. It is amemory-based store and you can put as much as you like into it (as long as it fitsin memory).You can optionally pass configuration parameters upon loading a store, as follows:```pythonstore = stam.AnnotationStore(file=&quot;example.stam.json&quot;, config={&quot;debug&quot;: True})```Once loaded, you can retrieve anything by its public ID:```pythonannotation = store.annotation(&quot;my-annotation&quot;)resource = store.resource(&quot;my-resource&quot;)dataset = store.dataset(&quot;my-annotationset&quot;)key = dataset.key(&quot;my-key&quot;)data = dataset.annotationdata(&quot;my-data&quot;)```You can also iterate through all annotations in the store, and output a simple tab separated format:```pythonfor annotation in store.annotations():    # get the text to which this annotation refers (if any)    try:        text = str(annotation)    except stam.StamError:        text = &quot;n/a&quot;    for data in annotation:        print(&quot;\t&quot;.join(( annotation.id(), data.key().id(), str(data.value()), text)))```Adding a resource:```pythonresource = store.add_resource(filename=&quot;my-text.txt&quot;)```Create a store and annotations from scratch:```pythonfrom stam import AnnotationStore, Selector, AnnotationDataBuilderstore = AnnotationStore(id=&quot;test&quot;)resource = store.add_resource(id=&quot;testres&quot;, text=&quot;Hello world&quot;)store.annotate(id=&quot;A1&quot;,                 target=Selector.textselector(resource, Offset.simple(6,11)),                data={ &quot;id&quot;: &quot;D1&quot;, &quot;key&quot;: &quot;pos&quot;, &quot;value&quot;: &quot;noun&quot;, &quot;set&quot;: &quot;testdataset&quot;})```In the above example, the `AnnotationDataSet` , `DataKey` and `AnnotationData`are created on-the-fly. You can also create them explicitly within the set first, as shown in thenext snippet, resulting in the exact same store:```pythonstore = AnnotationStore(id=&quot;test&quot;)resource = store.add_resource(id=&quot;testres&quot;, text=&quot;Hello world&quot;)dataset = store.add_dataset(id=&quot;testdataset&quot;)dataset.add_key(&quot;pos&quot;)data = dataset.add_data(&quot;pos&quot;,&quot;noun&quot;,&quot;D1&quot;)store.annotate(id=&quot;A1&quot;,     target=Selector.textselector(resource, Offset.simple(6,11)),    data=data)```Providing the full data dictionary as in the earlier example would havealso worked fine, with the same end result, but would be less performant than passing an `AnnotationData` instance directly.The implementation will always ensure any already existing `AnnotationData` will be reused ifpossible, as not duplicating data is one of the core characteristics of theSTAM model.You can serialize the entire annotation store (including all sets and annotations) to a STAM JSON file:```pythonstore.set_filename(&quot;example.stam.json&quot;)store.save()```For more documentation, please read: [STAM Tutorial: Standoff Text Annotation for Pythonistas](tutorial.ipynb).## Differences between the rust library and python library and performance considerationsAlthough this Python binding builds on the Rust library, the API it exposesdiffers in certain aspects to make it more pythonic and easier to work with.This results in a higher-level API that hides some of the lower-level detailsthat are present in the Rust library. This approach does come at the cost of causingsome additional runtime overhead. The Rust methods will often return iterators, references or handles whenever theycan, moreover it will do so safely. The Python API is often forced to make alocal copy. For iterators we often decide to let the entire underlying Rustiterator run its course and then return the result as a whole as a tuple, rather thanreturn a Python generator. Here you gain some speed at the cost of some memory.Probably needless to say, but using Rust directly will always be moreperformant than using this Python binding. However, using this Python bindingshould still be way more performant than if the whole thing were implemented innative Python. The trick is in letting the binding work for you as much aspossible, use higher-level methods whenever they are available rather thanimplementing your logic in Python.## AcknowledgementsThis work is conducted at the [KNAW Humanities Cluster](https://huc.knaw.nl/)'s [Digital Infrastructure department](https://di.huc.knaw.nl/), and funded by the [CLARIAH](https://clariah.nl) project (CLARIAH-PLUS, NWO grant 184.034.023) as part of the FAIR Annotations track.</longdescription>
</pkgmetadata>