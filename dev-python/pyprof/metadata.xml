<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># PyProf[![PyPI version](https://badge.fury.io/py/pyprof.svg)](https://badge.fury.io/py/pyprof)![Build Status](https://github.com/lizeyan/pyprof/actions/workflows/pythonpackage.yml/badge.svg)![Coverage](https://coveralls.io/repos/github/lizeyan/pyprof/badge.svg?branch=dev&amp;t=VBgxyx)A pure python time profiler## Installation```bashpip install pyprof```## Example``` pythonfrom pyprof import profile, Profiler, reportimport timefrom concurrent.futures import ThreadPoolExecutorfrom tests.test_utils import close# `profile` can be used as a decorator directly.# In such cases, the name of the Profiler is automatically extracted@profiledef f():    time.sleep(0.1)    # `profile` can be used as a context manager    with profile(&quot;sleep&quot;):        time.sleep(0.03)# `profile` can be used as a decorator with a specified name@profile('single-thread')def h():    for i in range(10):        f()@profile('multi-thread')def g():    with ThreadPoolExecutor() as executor:        for i in range(10):            executor.submit(f)def test_main():    h()    assert Profiler.get(&quot;/single-thread&quot;).count == 1    assert close(Profiler.get(&quot;/single-thread&quot;).total, 10 * 0.13)    # Profiler automatically find parent Profiler    assert Profiler.get(&quot;/single-thread/f&quot;).count == 10    assert close(Profiler.get(&quot;/single-thread/f&quot;).total, 10 * 0.13)    assert close(Profiler.get(&quot;/single-thread/f&quot;).average, 0.13)    assert close(Profiler.get(&quot;/single-thread/f&quot;).standard_deviation, 0.)    assert close(Profiler.get(&quot;/single-thread/f/sleep&quot;).total, 10 * 0.03)    assert close(Profiler.get(&quot;/single-thread/f/sleep&quot;).average, 0.03)    assert close(Profiler.get(&quot;/single-thread/f/sleep&quot;).standard_deviation, 0.)    g()    assert Profiler.get(&quot;/multi-thread&quot;).count == 1    # Profiler cannot automatically find parent Profiler in other threads    assert Profiler.get(&quot;/f&quot;).count == 10    assert close(Profiler.get(&quot;/f&quot;).total, 10 * 0.13)    assert close(Profiler.get(&quot;/f&quot;).average, 0.13)    assert close(Profiler.get(&quot;/f&quot;).standard_deviation, 0.)    assert close(Profiler.get(&quot;/f/sleep&quot;).total, 10 * 0.03)    assert close(Profiler.get(&quot;/f/sleep&quot;).average, 0.03)    assert close(Profiler.get(&quot;/f/sleep&quot;).standard_deviation, 0.)    # print a formatted time usage report    print(report())    # filter components    print(report(min_total_percent=0.1, min_parent_percent=0.5))    # `profile` automatically print report if `report_printer` is given    with profile('auto-print', report_printer=print):        f()    with profile('auto-print', report_printer=print):        f()    assert Profiler.get(&quot;/auto-print&quot;).count == 2    # use `flush=True` to reset a Profiler and all its children    with profile('auto-print', report_printer=print, flush=True):        f()    assert Profiler.get(&quot;/auto-print&quot;).count == 1if __name__ == '__main__':    test_main()```Output```markdown|path                  |%total     |%parent    |count   |total      |mean(±std)              |min-max              ||                      |    100.00%|    100.00%|      12|     2.862s|     0.238(±     0.334)s|     0.137~     1.345||/f                    |     48.14%|     48.14%|      10|     1.378s|     0.138(±     0.000)s|     0.137~     0.138||/f/sleep              |     11.85%|     24.63%|      10|     0.339s|     0.034(±     0.001)s|     0.032~     0.035||/multi-thread         |      4.87%|      4.87%|       1|     0.139s|     0.139(±     0.000)s|     0.139~     0.139||/single-thread        |     47.00%|     47.00%|       1|     1.345s|     1.345(±     0.000)s|     1.345~     1.345||/single-thread/f      |     46.98%|     99.97%|      10|     1.345s|     0.134(±     0.002)s|     0.130~     0.138||/single-thread/f/sleep|     11.30%|     24.05%|      10|     0.323s|     0.032(±     0.002)s|     0.030~     0.035||path               |%total     |%parent    |count   |total      |mean(±std)              |min-max              ||/auto-print        |      4.63%|      4.63%|       1|     0.139s|     0.139(±     0.000)s|     0.139~     0.139||/auto-print/f      |      4.63%|     99.97%|       1|     0.139s|     0.139(±     0.000)s|     0.139~     0.139||/auto-print/f/sleep|      1.17%|     25.37%|       1|     0.035s|     0.035(±     0.000)s|     0.035~     0.035||path               |%total     |%parent    |count   |total      |mean(±std)              |min-max              ||/auto-print        |      8.71%|      8.71%|       2|     0.273s|     0.137(±     0.002)s|     0.134~     0.139||/auto-print/f      |      8.71%|     99.97%|       2|     0.273s|     0.136(±     0.002)s|     0.134~     0.139||/auto-print/f/sleep|      2.09%|     23.99%|       2|     0.065s|     0.033(±     0.002)s|     0.030~     0.035||path               |%total     |%parent    |count   |total      |mean(±std)              |min-max              ||/auto-print        |      4.25%|      4.25%|       1|     0.139s|     0.139(±     0.000)s|     0.139~     0.139||/auto-print/f      |      4.24%|     99.98%|       1|     0.139s|     0.139(±     0.000)s|     0.139~     0.139||/auto-print/f/sleep|      1.06%|     24.90%|       1|     0.035s|     0.035(±     0.000)s|     0.035~     0.035|```## OverheadThe average overhead is less than 0.1ms.```python3import timefrom pyprof import profile, Profilerreal_time = 0.@profiledef f():    tic = time.perf_counter()    time.sleep(1e-2)    global real_time    real_time += time.perf_counter() - ticdef test_overhead():    n_times = 100    for i in range(n_times):        f()    total_time = Profiler.get(&quot;/f&quot;).total    print(f'total={total_time:.4f}s real_time={real_time:.4f}s')    average_overhead = (total_time - real_time) / n_times    assert average_overhead &lt; 1e-4  # 0.1ms    print(f'average overhead={average_overhead * 1000:.4f}ms')```## Roadmap- [ ] Automatically decide column width for more columns in `report`- [ ] Support capture parent profiler in a multi-thread context- [ ] Support multi-process (currently Profilers in subprocesses are all detached)</longdescription>
</pkgmetadata>