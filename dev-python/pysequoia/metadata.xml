<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;img src=&quot;https://codeberg.org/wiktor/pysequoia/raw/branch/main/doc/logo.png&quot; align=&quot;right&quot; width=&quot;150&quot; height=&quot;150&quot; /&gt;# PySequoia[![PyPI version](https://badge.fury.io/py/pysequoia.svg)](https://pypi.org/project/pysequoia/)[![PyPI Downloads](https://img.shields.io/pypi/dm/pysequoia.svg?label=PyPI%20downloads)](https://pypi.org/project/pysequoia/)[![status-badge](https://ci.codeberg.org/api/badges/wiktor/pysequoia/status.svg)](https://ci.codeberg.org/wiktor/pysequoia)This library provides [OpenPGP][] facilities in Python through the[Sequoia PGP][SQ] library. If you need to work with encryption anddigital signatures using an [IETF standardized protocol][4880], thispackage is for you![OpenPGP]: https://en.wikipedia.org/wiki/Pretty_Good_Privacy#OpenPGP[SQ]: https://sequoia-pgp.org/[4880]: https://www.rfc-editor.org/rfc/rfc4880Note: This is a work in progress. The API is **not** stable!## Building```bashset -euxo pipefailpython -m venv .envsource .env/bin/activatepip install maturinmaturin develop```## InstallingPySequoia can be installed through `pip`:```shpip install pysequoia```Note that since `pysequoia` is implemented largely in Rust, a [Rusttoolchain][RUSTUP] is necessary for the installation to succeed.[RUSTUP]: https://rustup.rs/## TestingThis entire document is used for end-to-end integration tests thatexercise the package's API surface.The tests assume that these keys and cards exist:```bash# generate a key with passwordgpg --batch --pinentry-mode loopback --passphrase hunter22 --quick-gen-key passwd@example.comgpg --batch --pinentry-mode loopback --passphrase hunter22 --export-secret-key passwd@example.com &gt; passwd.pgp# generate a key without passwordgpg --batch --pinentry-mode loopback --passphrase '' --quick-gen-key no-passwd@example.com future-defaultgpg --batch --pinentry-mode loopback --passphrase '' --export-secret-key no-passwd@example.com &gt; no-passwd.pgp# initialize dummy OpenPGP Cardsh /start.shecho 12345678 &gt; pinopgpcard admin --card 0000:00000000 --admin-pin pin import no-passwd.pgp```## FunctionsAll examples assume that these basic classes have been imported:```pythonfrom pysequoia import Cert```### encryptSigns and encrypts a string to one or more recipients:```pythonfrom pysequoia import encrypts = Cert.from_file(&quot;passwd.pgp&quot;)r = Cert.from_bytes(open(&quot;wiktor.asc&quot;, &quot;rb&quot;).read())bytes = &quot;content to encrypt&quot;.encode(&quot;utf8&quot;)encrypted = encrypt(signer = s.secrets.signer(&quot;hunter22&quot;), recipients = [r], bytes = bytes).decode(&quot;utf8&quot;)print(f&quot;Encrypted data: {encrypted}&quot;)```### decryptDecrypts data:```pythonfrom pysequoia import decryptsender = Cert.from_file(&quot;no-passwd.pgp&quot;)receiver = Cert.from_file(&quot;passwd.pgp&quot;)content = &quot;Red Green Blue&quot;encrypted = encrypt(signer = sender.secrets.signer(), recipients = [receiver], bytes = content.encode(&quot;utf8&quot;))decrypted = decrypt(decryptor = receiver.secrets.decryptor(&quot;hunter22&quot;), bytes = encrypted)assert content == decrypted.bytes.decode(&quot;utf8&quot;);```### signSigns data and returns armored output:```pythonfrom pysequoia import signs = Cert.from_file(&quot;signing-key.asc&quot;)signed = sign(s.secrets.signer(), &quot;data to be signed&quot;.encode(&quot;utf8&quot;))print(f&quot;Signed data: {signed}&quot;)```## CertificatesThe `Cert` class represents one OpenPGP certificate (commonly called a&quot;public key&quot;).This package additionally verifies the certificate using Sequoia PGP's[`StandardPolicy`][SP]. This means that certificates using weakcryptography can fail to load, or present a different view than inother OpenPGP software (e.g. if a User ID uses SHA-1 in itsback-signature, it may be missing from the list of User IDs returnedby this package).Checking certificates for problems (&quot;linting&quot;) [is planned][LINT] butnot yet implemented.[SP]: https://docs.rs/sequoia-openpgp/latest/sequoia_openpgp/policy/struct.StandardPolicy.html[LINT]: https://codeberg.org/wiktor/pysequoia/issues/52Certificates have two forms, one is ASCII armored and one is raw bytes:```pythoncert = Cert.generate(&quot;Test &lt;test@example.com&gt;&quot;)print(f&quot;Armored cert: {cert}&quot;)print(f&quot;Bytes of the cert: {cert.bytes()}&quot;)```### ParsingCertificates can be parsed from files (`Cert.from_file`) or bytes inmemory (`Cert.from_bytes`).```pythoncert1 = Cert.generate(&quot;Test &lt;test@example.com&gt;&quot;)buffer = cert1.bytes()parsed_cert = Cert.from_bytes(buffer)assert str(parsed_cert.user_ids[0]) == &quot;Test &lt;test@example.com&gt;&quot;```They can also be picked from &quot;keyring&quot; files (`Cert.split_file`) orbytes in memory (`Cert.split_bytes`) which are collections of binarycertificates.```pythoncert1 = Cert.generate(&quot;Test 1 &lt;test-1@example.com&gt;&quot;)cert2 = Cert.generate(&quot;Test 2 &lt;test-2@example.com&gt;&quot;)cert3 = Cert.generate(&quot;Test 3 &lt;test-3@example.com&gt;&quot;)buffer = cert1.bytes() + cert2.bytes() + cert3.bytes()certs = Cert.split_bytes(buffer)assert len(certs) == 3```### generateCreates a new general purpose key with a given User ID:```pythonalice = Cert.generate(&quot;Alice &lt;alice@example.com&gt;&quot;)fpr = alice.fingerprintprint(f&quot;Generated cert with fingerprint {fpr}:\n{alice}&quot;)```Multiple User IDs can be passed as a list to the `generate` function:```pythoncert = Cert.generate(user_ids = [&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;])assert len(cert.user_ids) == 3```Newly generated certificates are usable in both encryption and signingcontexts:```pythonalice = Cert.generate(&quot;Alice &lt;alice@example.com&gt;&quot;)bob = Cert.generate(&quot;Bob &lt;bob@example.com&gt;&quot;)bytes = &quot;content to encrypt&quot;.encode(&quot;utf8&quot;)encrypted = encrypt(signer = alice.secrets.signer(), recipients = [bob], bytes = bytes)print(f&quot;Encrypted data: {encrypted}&quot;)```### mergeMerges packets from a new version into an old version of a certificate:```pythonold = Cert.from_file(&quot;wiktor.asc&quot;)new = Cert.from_file(&quot;wiktor-fresh.asc&quot;)merged = old.merge(new)print(f&quot;Merged, updated cert: {merged}&quot;)```### User IDsListing existing User IDs:```pythoncert = Cert.from_file(&quot;wiktor.asc&quot;)user_id = cert.user_ids[0]assert str(user_id).startswith(&quot;Wiktor Kwapisiewicz&quot;)```Adding new User IDs:```pythoncert = Cert.generate(&quot;Alice &lt;alice@example.com&gt;&quot;)assert len(cert.user_ids) == 1;cert = cert.add_user_id(value = &quot;Alice &lt;alice@company.invalid&gt;&quot;, certifier = cert.secrets.certifier())assert len(cert.user_ids) == 2;```Revoking User IDs:```pythoncert = Cert.generate(&quot;Bob &lt;bob@example.com&gt;&quot;)cert = cert.add_user_id(value = &quot;Bob &lt;bob@company.invalid&gt;&quot;, certifier = cert.secrets.certifier())assert len(cert.user_ids) == 2# create User ID revocationrevocation = cert.revoke_user_id(user_id = cert.user_ids[1], certifier = cert.secrets.certifier())# merge the revocation with the certcert = Cert.from_bytes(cert.bytes() + revocation.bytes())assert len(cert.user_ids) == 1```### NotationsNotations are small pieces of data that can be attached to signatures (and, indirectly, to User IDs).The following example reads and displays a [Keyoxide][KX] proof URI:[KX]: https://keyoxide.org/```pythoncert = Cert.from_file(&quot;wiktor.asc&quot;)user_id = cert.user_ids[0]notation = user_id.notations[0]assert notation.key == &quot;proof@metacode.biz&quot;;assert notation.value == &quot;dns:metacode.biz?type=TXT&quot;;```Notations can also be added:```pythonfrom pysequoia import Notationcert = Cert.from_file(&quot;signing-key.asc&quot;)# No notations initiallyassert len(cert.user_ids[0].notations) == 0;cert = cert.set_notations(cert.secrets.certifier(), [Notation(&quot;proof@metacode.biz&quot;, &quot;dns:metacode.biz&quot;)])# Has one notation nowprint(str(cert.user_ids[0].notations))assert len(cert.user_ids[0].notations) == 1;# Check the notation datanotation = cert.user_ids[0].notations[0]assert notation.key == &quot;proof@metacode.biz&quot;;assert notation.value == &quot;dns:metacode.biz&quot;;```### Key expirationCerts have an `expiration` getter for retrieving the current keyexpiry time:```pythoncert = Cert.from_file(&quot;signing-key.asc&quot;)# Cert does not have any expiration date:assert cert.expiration is Nonecert = Cert.from_file(&quot;wiktor.asc&quot;)# Cert expires on New Year's Eveassert str(cert.expiration) == &quot;2022-12-31 12:00:02+00:00&quot;```Key expiration can also be adjusted with `set_expiration`:```pythonfrom datetime import datetimecert = Cert.from_file(&quot;signing-key.asc&quot;)# Cert does not have any expiration date:assert cert.expiration is None# Set the expiration to some specified point in timeexpiration = datetime.fromisoformat(&quot;2021-11-04T00:05:23+00:00&quot;)cert = cert.set_expiration(expiration = expiration, certifier = cert.secrets.certifier())assert str(cert.expiration) == &quot;2021-11-04 00:05:23+00:00&quot;```### Key revocationCerts can be revoked. While [expiration makes the key unusabletemporarily][EXP] to encourage the user to refresh a copy revocation isirreversible.[EXP]: https://blogs.gentoo.org/mgorny/2018/08/13/openpgp-key-expiration-is-not-a-security-measure/```pythoncert = Cert.generate(&quot;Test Revocation &lt;revoke@example.com&gt;&quot;)revocation = cert.revoke(certifier = cert.secrets.certifier())# creating revocation signature does not revoke the keyassert not cert.is_revoked# importing revocation signature marks the key as revokedrevoked_cert = Cert.from_bytes(cert.bytes() + revocation.bytes())assert revoked_cert.is_revoked```## Secret keysCertificates generated through `Cert.generate()` contain secret keysand can be used for signing and decryption.To avoid accidental leakage secret keys are never directly printedwhen the Cert is written to a string. To enable this behavior use`Cert.secrets`. `secrets` returns `None` on certificates which donot contain any secret key material (&quot;public keys&quot;).```pythonc = Cert.generate(&quot;Testing key &lt;test@example.com&gt;&quot;)assert c.has_secret_keys# by default only public parts are exportedpublic_parts = Cert.from_bytes(f&quot;{c}&quot;.encode(&quot;utf8&quot;))assert not public_parts.has_secret_keysassert public_parts.secrets is None# to export secret parts use the following:private_parts = Cert.from_bytes(f&quot;{c.secrets}&quot;.encode(&quot;utf8&quot;))assert private_parts.has_secret_keys```## Certificate management### WKDFetching certificates via Web Key Directory:```pythonfrom pysequoia import WKDimport asyncioasync def fetch_and_display():    certs = await WKD.search(email = &quot;test-wkd@metacode.biz&quot;)    assert len(certs) == 1    print(f&quot;Cert found via WKD: {certs[0]}&quot;)    assert certs[0].fingerprint == &quot;5b7abe660d5c62a607fe2448716b17764e3fcaca&quot;asyncio.run(fetch_and_display())```### Key serverKey servers let people search and store OpenPGP certificates.#### HKPS[HKPS][HKP] is a popular protocol implemented by most key servers.[HKP]: https://datatracker.ietf.org/doc/html/draft-shaw-openpgp-hkp-00Fetching certificates via the HKPS protocol:```pythonfrom pysequoia import KeyServerimport asyncioasync def fetch_and_display():    ks = KeyServer(&quot;hkps://keyserver.ubuntu.com&quot;)    cert = await ks.get(&quot;653909a2f0e37c106f5faf546c8857e0d8e8f074&quot;)    print(f&quot;Cert found via HKPS: {cert}&quot;)    assert cert.fingerprint == &quot;653909a2f0e37c106f5faf546c8857e0d8e8f074&quot;asyncio.run(fetch_and_display())```Search by e-mail returns multiple certificates:```pythonfrom pysequoia import KeyServerimport asynciofrom uuid import uuid4async def fetch_and_display():    ks = KeyServer(&quot;hkps://keyserver.ubuntu.com&quot;)    certs = await ks.search(email = f&quot;{uuid4()}@metacode.biz&quot;)    print(f&quot;Found {len(certs)} via HKPS: {certs}&quot;)    assert len(certs) == 0asyncio.run(fetch_and_display())```Keys can also be uploaded:```pythonfrom pysequoia import KeyServerimport asyncioasync def upload_key(cert):    ks = KeyServer(&quot;hkps://keyserver.ubuntu.com&quot;)    await ks.put(cert)    print(&quot;Cert uploaded successfully&quot;)asyncio.run(upload_key(Cert.from_file(&quot;wiktor.asc&quot;)))```#### VKS[Verifying Key Server protocol][VKS] is a custom protocol currentlyonly used by the keys.openpgp.org key server. Keys retrieved via thisprotocol will contain only User IDs that have been verified (viae-mail) by the server operator.[VKS]: https://keys.openpgp.org/about/api```pythonfrom pysequoia import KeyServerimport asyncioasync def fetch_and_display():    ks = KeyServer(&quot;vks://keys.openpgp.org&quot;)    cert = await ks.get(&quot;653909a2f0e37c106f5faf546c8857e0d8e8f074&quot;)    print(f&quot;Cert found via HKPS: {cert}&quot;)    assert cert.fingerprint == &quot;653909a2f0e37c106f5faf546c8857e0d8e8f074&quot;asyncio.run(fetch_and_display())```Search by e-mail always returns zero or one certificates via the VKSprotocol but to keep the interface consistent with HKPS the returnvalue is a list:```pythonfrom pysequoia import KeyServerimport asynciofrom uuid import uuid4async def fetch_and_display():    ks = KeyServer(&quot;vks://keys.openpgp.org&quot;)    certs = await ks.search(email = &quot;test-wkd@metacode.biz&quot;)    print(f&quot;Found {len(certs)} via HKPS: {certs}&quot;)    assert len(certs) == 1asyncio.run(fetch_and_display())```Keys can also be uploaded:```pythonfrom pysequoia import KeyServerimport asyncioasync def upload_key(cert):    ks = KeyServer(&quot;vks://keys.openpgp.org&quot;)    await ks.put(cert)    print(&quot;Cert uploaded successfully&quot;)asyncio.run(upload_key(Cert.from_file(&quot;wiktor.asc&quot;)))```### CertD integrationThis library exposes [OpenPGP Certificate Directory][CERT-D]integration, which allows storing and retrieving OpenPGP certificatesin a persistent way directly in the file system.Note that this will *not* allow you to read GnuPG-specific keydirectories. Cert-D [does not allow certificate removal][NO-REMOV].[CERT-D]: https://sequoia-pgp.gitlab.io/pgp-cert-d/[NO-REMOV]: https://gitlab.com/sequoia-pgp/pgp-cert-d/-/issues/33```pythonfrom pysequoia import Storecert = Cert.from_file(&quot;wiktor.asc&quot;)s = Store(&quot;/tmp/store&quot;)s.put(cert)assert s.get(cert.fingerprint) != None```The certificate is now stored in the given directory and can beretrieved later by its fingerprint:```pythons = Store(&quot;/tmp/store&quot;)assert s.get(&quot;653909a2f0e37c106f5faf546c8857e0d8e8f074&quot;) != None```## OpenPGP CardsThere's an experimental feature allowing communication with OpenPGPCards (like YubiKey or Nitrokey).```pythonfrom pysequoia import Card# enumerate all cardsall = Card.all()# open card by card identcard = Card.open(&quot;0000:00000000&quot;)print(f&quot;Card ident: {card.ident}&quot;)print(f&quot;Cardholder: {card.cardholder}&quot;)```Cards can be used for signing data:```pythonsigner = card.signer(&quot;123456&quot;)signed = sign(signer, &quot;data to be signed&quot;.encode(&quot;utf8&quot;))print(f&quot;Signed data: {signed}&quot;)```As well as for decryption:```pythondecryptor = card.decryptor(&quot;123456&quot;)sender = Cert.from_file(&quot;passwd.pgp&quot;)receiver = Cert.from_file(&quot;no-passwd.pgp&quot;)content = &quot;Red Green Blue&quot;encrypted = encrypt(signer = sender.secrets.signer(&quot;hunter22&quot;), recipients = [receiver], bytes = content.encode(&quot;utf8&quot;))print(f&quot;Encrypted data: {encrypted}&quot;)decrypted = decrypt(decryptor = decryptor, bytes = encrypted)assert content == decrypted.bytes.decode(&quot;utf8&quot;);```Note that while this package allows using cards for signing anddecryption, the provisioning process is not supported.  [OpenPGP cardtools][] can be used to initialize the card.[OpenPGP card tools]: https://crates.io/crates/openpgp-card-tools## LicenseThis project is licensed under [Apache License, Version 2.0][APL].[APL]: https://www.apache.org/licenses/LICENSE-2.0.html## ContributionUnless you explicitly state otherwise, any contribution intentionallysubmitted for inclusion in the package by you shall be under the termsand conditions of this license, without any additional terms orconditions.## SponsorsMy work is supported by these generous organizations (alphabeticalorder):  - [nlnet.nl](https://nlnet.nl/)  - [pep.foundation](https://pep.foundation/)  - [sovereigntechfund.de](https://sovereigntechfund.de/en.html)</longdescription>
</pkgmetadata>