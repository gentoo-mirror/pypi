<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># DatabasedDatabased is a package that wraps the standard library Sqlite3 module to make setting up and using a database quicker and easier.&lt;br&gt;Install with:&lt;pre&gt;pip install databased&lt;/pre&gt;databased is a package that wraps the standard library Sqlite3 module to largely avoid writing queries except for table definitions.&lt;br&gt;It consists of the class DataBased and an additional function for displaying information in a grid called data_to_string.&lt;br&gt;The DataBased class contains functions for creating databases and tables; inserting, updating, and deleting rows; as well as retrieving data and schema information.&lt;br&gt;The data_to_string function uses the [tabulate](https://pypi.org/project/tabulate/) to generate a grid as a string from a list of dictionaries.&lt;br&gt;By default, data_to_string will automatically wrap the width of columns to fit within the current terminal window.&lt;br&gt;&lt;br&gt;Member functions that require a database connection willautomatically create one when called if one isn't already open,but a manual call to self.close() needs to be called in order tosave the database file and release the connection.&lt;br&gt;If a context manager is used, like in the following example, you don't need to worry about manually opening, saving, or closing the database.&lt;br&gt;&lt;br&gt;Usage:&lt;pre&gt;from databased import DataBased, data_to_stringfrom datetime import datetime# if the .db file specified doesn't exist, it will be created# a log file with the same name will be generated and stored in the same directorywith DataBased(dbpath=&quot;records.db&quot;) as db:    tables = [        &quot;kitchen_tables(num_legs int, top_material text, shape text, date_added timestamp)&quot;    ]    # A table will only be created if it doesn't exist. create_tables() will not overwrite an existing table.    db.create_tables(tables)    kitchen_tables = [        (4, &quot;birch&quot;, &quot;round&quot;, datetime.now()),        (3, &quot;oak&quot;, &quot;round&quot;, datetime.now()),        (6, &quot;granite&quot;, &quot;rectangle&quot;, datetime.now()),    ]    for kitchen_table in kitchen_tables:        db.add_row(&quot;kitchen_tables&quot;, kitchen_table)    print(f'number of rows: {db.count(&quot;kitchen_tables&quot;)}')    print(f'table names: {db.get_table_names()}')    print(f'column names: {db.get_column_names(&quot;kitchen_tables&quot;)}')    print(db.get_rows(&quot;kitchen_tables&quot;, [(&quot;num_legs&quot;, 6)]))    print(db.get_rows(&quot;kitchen_tables&quot;, [(&quot;shape&quot;, &quot;round&quot;)], sort_by_column=&quot;num_legs&quot;))    print(db.get_rows(&quot;kitchen_tables&quot;, [(&quot;shape&quot;, &quot;round&quot;), (&quot;num_legs&quot;, 4)]))    db.update(        &quot;kitchen_tables&quot;,        column_to_update=&quot;top_material&quot;,        new_value=&quot;glass&quot;,        match_criteria=[(&quot;num_legs&quot;, 3)],    )    print(db.get_rows(&quot;kitchen_tables&quot;, sort_by_column=&quot;num_legs&quot;))    print(data_to_string(db.get_rows(&quot;kitchen_tables&quot;), sort_key=&quot;top_material&quot;))&lt;/pre&gt;produces:&lt;pre&gt;number of rows: 3table names: ['kitchen_tables']column names: ['num_legs', 'top_material', 'shape', 'date_added'][{'num_legs': 6, 'top_material': 'granite', 'shape': 'rectangle', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}][{'num_legs': 3, 'top_material': 'oak', 'shape': 'round', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}, {'num_legs': 4, 'top_material': 'birch', 'shape': 'round', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}][{'num_legs': 4, 'top_material': 'birch', 'shape': 'round', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}][{'num_legs': 3, 'top_material': 'glass', 'shape': 'round', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}, {'num_legs': 4, 'top_material': 'birch', 'shape': 'round', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}, {'num_legs': 6, 'top_material': 'granite', 'shape': 'rectangle', 'date_added': datetime.datetime(2022, 12, 9, 15, 56, 56, 543549)}]&lt;/pre&gt;and the final print() call on the data_to_string() function produces:&lt;pre&gt;+------------+----------------+-----------+-----------------------------+| num_legs   | top_material   | shape     | date_added                  |+============+================+===========+=============================+| 4          | birch          | round     | 2022-12-14 18:19:31.501745  |+------------+----------------+-----------+-----------------------------+| 3          | glass          | round     | 2022-12-14 18:19:31.501745  |+------------+----------------+-----------+-----------------------------+| 6          | granite        | rectangle | 2022-12-14 18:19:31.501745  |+------------+----------------+-----------+-----------------------------+&lt;/pre&gt;When a DataBased object is created, if there is no file named &quot;dbmanager.py&quot;in the same directory as the specified database file, one will be created froma template.&lt;br&gt;&quot;dbmanager.py&quot; is a command line script that provides basic database commands,but can be tailored to a given database(s).&lt;br&gt;Instead of invoking the script over and over with new commands,the script is invoked once and will repetedly prompt the user for commands.&lt;br&gt;Invoking the script and then passing the &quot;-h/--help&quot; command:&lt;pre&gt;&gt;dbmanager.pyEnter command: -husage: dbmanager.py [-h] [-db DB_NAME] [-i] [-t [TABLES ...]] [-c [COLUMNS ...]] [-f FIND] [-sco] [-d [DELETE ...]] [-u UPDATE UPDATE] [-sb SORT_BY]options:  -h, --help            show this help message and exit  -db DBNAME, --dbname DBNAME                        Name of database file to use. Required on the first loop if no default is set, but subsequent loops will resuse the same database unless a new one is provided through this arg.  -i, --info            Display table names, their respective columns, and how many records they contain. If a -t/--tables arg is passed, just the columns and row count for those tables will be shown.  -t [TABLES ...], --tables [TABLES ...]                        Limits commands to a specific list of tables. Optional for some commands, required for others. If this is the only arg given (besides -db if not already set), the whole table will be printed to the terminal.  -c [COLUMNS ...], --columns [COLUMNS ...]                        Limits commands to a specific list of columns. Optional for some commands, required for others. If this and -t are the only args given (besides -db if not already set), the whole table will be printed to the                        terminal, but with only the columns provided with this arg.  -f FIND, --find FIND  A substring to search the database for. If a -c/--columns arg(s) is not given, the values will be matched against all columns. Similarly, if a -t/--tables arg(s) is not given, the values will be searched for in                        all tables.  -sco, --show_count_only                        Show the number of results returned by -f/--find, but don't print the results to the terminal.  -d [DELETE ...], --delete [DELETE ...]                        A list of values to be deleted from the database. A -c/--columns arg must be supplied. A -t/--tables arg must be supplied.  -u UPDATE UPDATE, --update UPDATE UPDATE                        Update a record in the database. Expects two arguments: the current value and the new value. A -c/--columns arg must be supplied. A -t/--tables arg must be supplied.  -sb SORT_BY, --sort_by SORT_BY                        Column to sort results by.Enter command:&lt;/pre&gt;</longdescription>
</pkgmetadata>