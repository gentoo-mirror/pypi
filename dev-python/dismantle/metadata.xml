<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Dismantle**Dismantle** is a module created for Python programs to provide the ability to provide additional functionality using packages listed within local or remote indices and installed during runtime.Dismantle does this by checking a package index and using that index to manage package versions. Packages then contain plugins (using decorators) and extensions (using a custom module loader) to add the additional functionality to the application.## Installing DismantleDismantle is available on PyPI:```console$ python -m pip install dismantle```NOTE: *Dismantle officially supports Python from 3.7 up## Supported Features &amp; Bestâ€“PracticesDismantle provides the flexibility within applications allowing developers to build rich ecosystems around core applications. It does this by providing the following:### Index ManagementIndex files are used to provide list of available packages and provide information on packages andthe versions of said packages available.- support for multiple index files that cascade- easy to create custom index handlers providing additional ways to define package indices- local index file support using json built in- url based index file support using json built in- etag based caching for url based index### PackagingPackages listed in index files provide the ability to bundle features and act as a transportmechanism for additional functionality while providing security.- easy to create custom package handlers providing additional ways to define package sources- easy to create custom package formats compression types and structures- support for zip, tar.gz, tgz, and local directories as package formats built in- support for local and url based (http/https) package handlers built in- hash validation for packages with the ability to verify package integrity### ExtensionsExtensions contained within packages provide a way to dynamically load modules at runtime forPython modules as needed.  Packages can replace or extend application functionality at runtime byreplacing or adding modules in Pythons global modules manager.- Categorized extension groups to filter extension types (eg. loggers, parsers, ...)- Support for __init__ or .py based module loading.- Extension activation and deactivation management.- Module name collision avoidance- Hierarchical module naming### PluginsPlugins contained within packages provide a way to intercept function parameters and return valuesin order to manipulate data on the fly.  Plugins can be used for data validation, manipilation, orto provide additional logging or auditing functionality.- Decorator based plugins with pre and post value interceptions and/or modification- Multiple plugins per function with ability to set execution order- Activation management## Example implementations### Plugin```python&quot;&quot;&quot;Simple plugin example&quot;&quot;&quot;from dismantle import pluginclass Chat():    @plugin.register('chat.message')    def show(self, message):        print(message)@plugin.plugin('chat.message', order=-1)def make_uppercase(message):    return message.upper()```### Extension```python&quot;&quot;&quot;Full example using all aspects.&quot;&quot;&quot;from dismantle.extension import Extensions, IExtensionfrom dismantle.index import JsonFileIndexHandlerfrom dismantle.package import LocalPackageHandlerclass ColorExtension(IExtension):    _category = 'color'    def color(self) -&gt; None:        ...class GreenColorExtension(ColorExtension):    _name = 'green'    def color(self) -&gt; None:        print(f'color is {self._name}')packages = {}index = JsonFileIndexHandler('index.json')for pkg_meta in index:    meta = index[pkg_meta]    package = LocalPackageHandler(meta['name'], 'foo/path')    package._meta = {**package._meta, **meta}    package.install()    packages[package.name] = packageextensions = Extensions([ColorExtension], packages, 'ext_')assert extensions.types == ['color']assert list(extensions.category('color').keys()) == [    '@scope-one/package-one.extension.green.GreenColorExtension',    '@scope-one/package-two.extension.red.RedColorExtension',    '@scope-one/package-three.extension.blue.BlueColorExtension',]assert list(extensions.extensions.keys()) == ['color']assert list(extensions.imports.keys()) == [    '@scope-one/package-one.extension.green',    '@scope-one/package-two.extension.red',    '@scope-one/package-three.extension.blue']```</longdescription>
</pkgmetadata>