<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># graphene-permissions**Permission system for graphene-django apps.**[![Build Status](https://travis-ci.org/redzej/graphene-permissions.svg?branch=master)](https://travis-ci.org/redzej/graphene-permissions)[![PyPI version](https://badge.fury.io/py/graphene-permissions.svg)](https://badge.fury.io/py/graphene-permissions)[![Python 3.6](https://img.shields.io/badge/python-3.6-green.svg)](https://www.python.org/downloads/release/python-360/)[![codecov](https://codecov.io/gh/redzej/graphene-permissions/branch/master/graph/badge.svg)](https://codecov.io/gh/redzej/graphene-permissions)[![Maintainability](https://api.codeclimate.com/v1/badges/12b39435f888adf2370b/maintainability)](https://codeclimate.com/github/redzej/graphene-permissions/maintainability)## OverviewDRF-inspired permission system based on classes for graphene-django. Allows easy customization of permission classes forfor queries and mutations.## Requirements* Python 3.5+* Django 2.0+* graphene-django 2.0+## InstallationInstall using pip:```commandlinepip install graphene-permissions```## ExampleTo enforce permission system, add appropriate mixin and set attribute `permission_classes`.```python### models.pyfrom django.db import modelsclass Pet(models.Model):    name = models.CharField(max_length=32)    race = models.CharField(max_length=64)``````python### schema.pyfrom graphene import relayfrom graphene_django import DjangoObjectTypefrom graphene_permissions.mixins import AuthNodefrom graphene_permissions.permissions import AllowAuthenticatedclass PetNode(AuthNode, DjangoObjectType):    permission_classes = (AllowAuthenticated,)    class Meta:        model = Pet        filter_fields = ('name',)        interfaces = (relay.Node,)```## Docs### Setting up permission checkFor queries use `AuthNode` mixin and inherite from `AuthFilter` class.```pythonclass AllowAuthenticatedPetNode(AuthNode, DjangoObjectType):    permission_classes = (AllowAuthenticated,)    class Meta:        model = Pet        filter_fields = ('name',)        interfaces = (relay.Node,)class AllowAuthenticatedFilter(AuthFilter):    permission_classes = (AllowAuthenticated,)class PetsQuery:    user_pet = relay.Node.Field(AllowAuthenticatedPetNode)    all_user_pets = AllowAuthenticatedFilter(AllowAuthenticatedPetNode)```For mutations use `AuthMutation` mixin.```pythonclass AuthenticatedAddPet(AuthMutation, ClientIDMutation):    permission_classes = (AllowAuthenticated,)    pet = graphene.Field(AllowAuthenticatedPetNode)    class Input:        name = graphene.String()        race = graphene.String()        owner = graphene.ID()    @classmethod    def mutate_and_get_payload(cls, root, info, **input):        if cls.has_permission(root, info, input):            owner = User.objects.get(pk=from_global_id(input['owner'])[1])            pet = Pet.objects.create(name=input['name'], race=input['race'], owner=owner)            return AuthenticatedAddPet(pet=pet)        return AuthenticatedAddPet(pet=None)class PetsMutation:    authenticated_add_pet = AuthenticatedAddPet.Field()```### Customizing permission classesDefault permission classes are: `AllowAny`, `AllowAuthenticated`, `AllowStaff`.You can set up equal permission for both queries and mutations with one class, simply subclass one of these classesand to limit access for given object, override appropriate method. Remember to return `true` if user should be givenaccess and `false`, if denied.```pythonclass AllowMutationForStaff(AllowAuthenticated):    @staticmethod    def has_node_permission(info, id):        # logic here        # return boolean    @staticmethod    def has_mutation_permission(root, info, input):        if info.request.user.is_staff:            return True        return False    @staticmethod    def has_filter_permission(info):        # logic here        # return boolean```### Multiple permissionsYou can set up multiple permissions checks, simply adding more classes. Permission is evaluated for every class.If one of the checks fails, access is denied.```pythonclass CustomPetNode(AuthNode, DjangoObjectType):    permission_classes = (AllowAuthenticated, AllowStaff, AllowCustom)    class Meta:        model = Pet        interfaces = (relay.Node,)```</longdescription>
</pkgmetadata>