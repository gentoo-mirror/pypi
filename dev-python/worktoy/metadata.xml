<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![wakatime](https://wakatime.com/badge/github/AsgerJon/WorkToy.svg)](https://wakatime.com/badge/github/AsgerJon/WorkToy)# WorkToy v0.40.28```pip install worktoy```## Table of Contents1. [WorkToyClass](#WorkToyClass)    1. [maybe](#WorkToyClassmaybe)    2. [maybeType](#WorkToyClassmaybeType)    3. [maybeTypes](#WorkToyClassmaybeTypes)    4. [searchKey](#WorkToyClasssearchKey)    5. [searchKeys](#WorkToyClasssearchKeys)    6. [maybeKey](#WorkToyClassmaybeKey)    7. [maybeKeys](#WorkToyClassmaybeKeys)2. [WorkToyClass.Guards](#WorkToyClass---Guards)    1. [noneGuard](#WorkToyClassnoneGuard)    2. [someGuard](#WorkToyClasssomeGuard)    3. [overRideGuard](#WorkToyClassoverRideGuard)    4. [functionGuard](#WorkToyClassfunctionGuard)    5. [intGuard](#WorkToyClassintGuard)    6. [strGuard](#WorkToyClassstrGuard)3. [Descriptors](#Descriptors)    1. [Attribute](#Attribute)4. [Metaclass](#MetaClass)    1. [type](#type)    2. [NameSpace](#NameSpace)5. [Wait A Minute!](#Wait-A-Minute)    1. [MetaXcept](#MetaXcept)    2. [MetaTypeSupportError](#MetaTypeSupportError)    3. [FieldDecoderException](#FieldDecoderException)    4. [FieldEncoderException](#FieldEncoderException)    5. [MissingArgumentException](#MissingArgumentException)    6. [RecursiveCreateGetError](#RecursiveCreateGetError)    7. [TypeSupportError](#TypeSupportError)    8. [UnavailableNameException](#UnavailableNameException)    9. [UnexpectedEventException](#UnexpectedEventException)    10. [UnsupportedSubclassException](#UnsupportedSubclassException)6. [Core](#Core)## WorkToyClassParent class providing general utility functions on the class itself.```pythonfrom worktoy.worktoyclass import WorkToyClassclass MyClass(WorkToyClass):  &quot;&quot;&quot;Example class&quot;&quot;&quot;  def __init__(self, *args, **kwargs) -&gt; None:    WorkToyClass.__init__(self, *args, **kwargs)```By inheriting from the ``WorkToyClass``, instances now have access to acollection of utility functions:### WorkToyClass.maybe```pythonfrom typing import Anyfrom worktoy.worktoyclass import WorkToyClassclass MyClass(WorkToyClass):  &quot;&quot;&quot;Example class&quot;&quot;&quot;  def instanceMethod(self, *args) -&gt; Any:    &quot;&quot;&quot;Instance method using ``maybe`` use a default argument value.&quot;&quot;&quot;    return self.maybe(*args)myInstance = MyClass()myInstance.instanceMethod(None, [], )  # &gt;&gt;&gt; []  ```### WorkToyClass.maybeType```pythonfrom worktoy.worktoyclass import WorkToyClassclass MyClass(WorkToyClass):  &quot;&quot;&quot;Example class&quot;&quot;&quot;  def instanceMethod(self, *args, **kwargs) -&gt; int:    &quot;&quot;&quot;Instance method using ``maybeType`` to extract an integer from the     positional arguments. &quot;&quot;&quot;    return self.maybeType(int, *args)myInstance = MyClass()myInstance.instanceMethod('one', 2, '3', 4, 5)  # &gt;&gt;&gt; 2  ```### WorkToyClass.maybeTypes```pythonfrom worktoy.worktoyclass import WorkToyClassclass MyClass(WorkToyClass):  &quot;&quot;&quot;Example class&quot;&quot;&quot;  def instanceMethod(self, *args, **kwargs) -&gt; int:    &quot;&quot;&quot;Instance method using 'maybeTypes' to extract every integer from the     positional arguments.&quot;&quot;&quot;    out = self.maybeTypes(int, *args)    if isinstance(out, int):      return outmyInstance = MyClass()myInstance.instanceMethod('one', 2, '3', 4, 5)  # &gt;&gt;&gt; [2, 4, 5] ```### WorkToyClass.searchKey```pythonfrom worktoy.worktoyclass import WorkToyClassclass MyClass(WorkToyClass):  &quot;&quot;&quot;Example class&quot;&quot;&quot;  def instanceMethod(self, *keys, **kwargs) -&gt; int:    &quot;&quot;&quot;Instance method using ``searchKey`` to search for keyword argument     value.&quot;&quot;&quot;    return self.searchKey(*keys, **kwargs)myInstance = MyClass()myInstance.instanceMethod('count', 'Count', 'amount', count=7)  # &gt;&gt;&gt; 7 ```### WorkToyClass.searchKeys```pythonfrom worktoy.worktoyclass import WorkToyClassclass MyClass(WorkToyClass):  &quot;&quot;&quot;Example class&quot;&quot;&quot;  def instanceMethod(self, *keys, **kwargs) -&gt; int:    &quot;&quot;&quot;Instance method using ``searchKeys`` to search for every keyword     argument.&quot;&quot;&quot;    return self.searchKeys(*keys, **kwargs)myInstance = MyClass()myInstance.instanceMethod('a', 'd', 'e', a=1, b=2, c=3, d=4)  # &gt;&gt;&gt; [1, 4] ```### WorkToyClass.maybeKey```pythonfrom worktoy.worktoyclass import WorkToyClassclass MyClass(WorkToyClass):  &quot;&quot;&quot;Example class&quot;&quot;&quot;  def instanceMethod(self, *args, **kwargs) -&gt; int:    &quot;&quot;&quot;Instance method using ``maybeKey`` to search for a keyword argument     value with a type restriction argument.&quot;&quot;&quot;    return self.maybeKey(*args, **kwargs)myInstance = MyClass()myInstance.instanceMethod('a', 'b', int, a='1', b=2, c=3, d=4)  # &gt;&gt;&gt; 2 ```### WorkToyClass.maybeKeys```pythonfrom worktoy.worktoyclass import WorkToyClassclass MyClass(WorkToyClass):  &quot;&quot;&quot;Example class&quot;&quot;&quot;  def instanceMethod(self, *args, **kwargs) -&gt; int:    &quot;&quot;&quot;Instance method using ``maybeKeys`` to search for every keyword     argument restricted to a certain type.&quot;&quot;&quot;    return self.maybeKeys(*args, **kwargs)myInstance = MyClass()myInstance.instanceMethod('a', 'b', int, a=1, b=2, c=3, d=4)  # &gt;&gt;&gt; [1, 2] ```## WorkToyClass - GuardsThe following methods are various type guards.### WorkToyClass.noneGuardRaises ``UnavailableNameException`` if the given object is not None.### WorkToyClass.someGuardRaises ``MissingArgumentException`` if given object is None### WorkToyClass.overRideGuardRaises ``UnavailableNameException`` if given object is not None### WorkToyClass.functionGuardRaises ``TypeSupportError`` if given object is not a function### WorkToyClass.intGuardRaises ``TypeSupportError`` if given object is None or not an integer### WorkToyClass.floatGuardRaises ``TypeSupportError`` if given object is None or not a float### WorkToyClass.strGuardRaises ``TypeSupportError`` if given object is None or not a string## DescriptorsThe ``Attribute`` class implements flexible descriptors.```pythonclass Attribute(WorkToyClass):  &quot;&quot;&quot;WorkToy - Fields - Field  Basic descriptor implementation.&quot;&quot;&quot;  def __init__(self, defVal: Any = None, *args, **kwargs) -&gt; None:    WorkToyClass.__init__(self, *args, **kwargs)    self._defaultValue = None    self._defaultType = None```#### case 1:Receives a default value that is not a type```pythonif defVal is not None and not isinstance(defVal, type):  self._setDefaultValue(defVal)  self._defaultType = type(self._defaultValue)```#### case 2:Receives a default value that is a type. This is taken tomean that the attribute is to hold a value of that type. The typeis then called without argument to attempt to create a default value.```pythonif isinstance(defVal, type):  self._setDefaultValue(defVal)  self._defaultValue = defVal()```#### case 3Receives no argument. In this case, the instance isresponsible for providing a default value. For example in theinstance `__init__` method using the public setter.Please note, that fields must do one of the following:1. Provide a default value in the Field creation call (RECOMMENDED)2. Define a Field type in the creation call. (NOT RECOMMENDED)3. Have the owning class defer default instance creation to the   first call to the getter-function. This advanced use case allows   the owning class to control specifically when and how to create   instances. This is supported and encouraged, for advanced owning   classes. (ADVANCED USE CASE)4. Subclass attribute to the specific type. (ADVANCED USE CASE)#### ATTENTION!Doing none of the above leads to HIGHLY UNDEFINED BEHAVIOUR!The Attribute is intended to raise MissingArgumentException in suchcases.```pythonself._fieldName = Noneself._fieldOwner = Noneself._getterFunctionName = Noneself._setterFunctionName = Noneself._deleterFunctionName = None```## MetaClassMetaclasses are certainly the most powerful tool available in Pythondevelopment. The WorkToy package provides a basic skeleton forimplementing custom metaclasses in the form of ``AbstractMetaClass`` and``AbstractNameSpace``. Before explaining the merits of these, aexamination of how metaclasses work seem appropriate.### Introduction to metaclassesYou are already familiar with the default baseclass: ``type``. In asomewhat unfortunate choice of nomenclature, we face an ambiguity here:do we mean ``type`` as in: ``isinstance(int, type)`` or do we mean:``type(int)``? The first treats ``type`` as a ``type``, but the secondtreats ``type`` as a function. To illustrate how unfortunate thisnomenclature is, consider this expression:``type(type) is type`` or ``isinstance(type, type) &gt;&gt;&gt; True``A ``metaclass`` is a custom ``type``. Consider ``TestClass`` defined below:```pythonfrom worktoy.worktoyclass import WorkToyClassclass TestClass(WorkToyClass):  &quot;&quot;&quot;Created with traditional class body.&quot;&quot;&quot;  def __init__(self, *args, **kwargs) -&gt; None:    WorkToyClass.__init__(self, *args, **kwargs)  def instanceMethod(self, *args, **kwargs) -&gt; int:    &quot;&quot;&quot;Instance method&quot;&quot;&quot;    return self.maybeType(int, *args)```The above is entirely equivalent to:```pythonfrom typing import Anyfrom worktoy.worktoyclass import WorkToyClassdef initFunc(instance: Any, *args, **kwargs) -&gt; None:  &quot;&quot;&quot;Init function&quot;&quot;&quot;  WorkToyClass.__init__(instance, *args, **kwargs)def someFunc(self, *args, **kwargs) -&gt; int:  &quot;&quot;&quot;Instance Method&quot;&quot;&quot;  return self._maybeType(int, *args)name = 'TestClass'bases = (WorkToyClass,)nameSpace = dict(__init__=initFunc, instanceMethod=someFunc)TestClass = type(name, bases, nameSpace)```### ``type``The ``type`` object used above specifies the creation of new classes. Bycreating a custom ``metaclass``, we are able to define our own classcreation. Below we define a ``metaclass`` that behaves entirely like``type`` allowing us to recognize the class creation we are familiar withand see how we can change this behaviour.(Please note, the naming convention: ``mcls``: metaclass, ``cls``: newclass, ``self`` new instance).```pythonfrom typing import Anyclass BaseMeta(type):  # metaclasses inherit from type  &quot;&quot;&quot;Base metaclass behaving line ``type``&quot;&quot;&quot;  @classmethod  def __prepare__(mcls, name: str, bases: tuple[type], **kwargs) -&gt; dict:    &quot;&quot;&quot;The prepare method creates the empty mapping object providing the     namespace for the newly created class. The base implementation     returns an empty instance of ``dict``.&quot;&quot;&quot;    return {}  def __new__(mcls, name: str, bases: tuple[type], nameSpace: dict,              **kwargs) -&gt; type:    &quot;&quot;&quot;The ``__new__`` method createds the new class,&quot;&quot;&quot;    cls = type.__new__(mcls, name, bases, nameSpace, **kwargs)    return cls  def __init__(cls, name: str, bases: tuple[type], nameSpace: dict,               **kwargs) -&gt; None:    &quot;&quot;&quot;Once the new class is created it is initialised by this method. &quot;&quot;&quot;    type.__init__(cls, name, bases, nameSpace, **kwargs)  def __call__(cls: type, *args, **kwargs) -&gt; Any:    &quot;&quot;&quot;This method specifies how the newly creatd class creates instances     of itself. The default behaviour is as shown below: The instance is     created with the __new__ method on the newly created class, and then     it is initialized with the __init__ on the newly created class.&quot;&quot;&quot;    self = cls.__new__(cls, )    cls.__init__(self, *args, **kwargs)    return self```By introducing custom metaclasses, we are free to customize the abovesteps to achieve any imaginable functionality. People say that Pythondoes not support function overloading. What they mean is that functionoverloading in Python must be implemented at the metaclass level. (Thatis dumb, function overloading should not require custom metaclasses, butthe point stands).### ``NameSpace``Customizing the ``__prepare__`` method gives the greatestopportunity to customize the class creation. Let us examine therequirements for the namespace object returned by the ``__prepare__``method. When attempting to use a custom class for this purppose, one islikely to encounter errors like:```python&quot;&quot;&quot;TypeError: type.__new__() argument 3 must be dict, not NameSpace&quot;&quot;&quot;&quot;&quot;&quot;TypeError: META.__prepare__() must return a mapping, not NameSpace&quot;&quot;&quot;&quot;&quot;&quot;TypeError: ``NameSpace`` object does not support item assignment&quot;&quot;&quot;```It is possible to create a custom class that does not trigger any such``TypeError``, which is able to create classes without any problem. Untilone day, you introduce a ``staticmethod`` and then receive:```python&quot;&quot;&quot;    @staticmethod     ^^^^^^^^^^^^TypeError: ``NoneType`` object is not callable&quot;&quot;&quot;```What even is that error message? The above happens if the ``__getitem__``method on the namespace object does not raise a KeyError when receiving amissing key. The expected behaviour from the namespace object receiving amissing key is to raise a KeyError with the missing key as the message.For example:```pythonfrom typing import Anydef __getitem__(self, key: str, ) -&gt; Any:  try:    dict.__getitem__(self, key)  except KeyError as e:    print(key)    raise e```By including the print statement, we can see that the problems occurwhere the class body has a valid expression without an equal sign. Forexample when decorating a function. Consider the following example:```pythonfrom typing import Any, Callableclass NameSpace(dict, ):  &quot;&quot;&quot;NameSpace custom class&quot;&quot;&quot;  def __getitem__(self, key: str, ) -&gt; Any:    &quot;&quot;&quot;Prints missing keys that are encountered.&quot;&quot;&quot;    try:      return dict.__getitem__(self, key)    except KeyError as e:      print(key)      raise eclass META(type):  &quot;&quot;&quot;Metaclass implementing the __prepare__ method which returns an  instance of the NameSpace class.&quot;&quot;&quot;  @classmethod  def __prepare__(mcls, name, bases, **kwargs) -&gt; Any:    nameSpace = NameSpace()    return nameSpacedef func(f: Callable) -&gt; None:  &quot;&quot;&quot;Decorator&quot;&quot;&quot;  return fclass TestClass(metaclass=META):  &quot;&quot;&quot;TestClass &quot;&quot;&quot;  @staticmethod  @func  def a(self) -&gt; None:    passif __name__ == '__main__':  TestClass()```When running the above script, we see the following printed to the console:```python'__name__''staticmethod''func'```Fortunately, WorkToy provides the ``AbstractNameSpace`` class whichimplements all required mapping functionality. Besides implementing``dict`` methods, it logs every line in the class body.## Wait A Minute!In this module, WorkToy provides the custom exceptions used throughoutthe entire package.### MetaXceptJust like the SYM module, the custom exceptionsimplement a custom metaclass inheriting from ``AbstractMetaClass``. Thismetaclass ``MetaXcept`` uses a custom namespace class inheriting from the``AbstractNameSpace`` in its ``__prepare__`` method.Below is a reference list of the custom exceptions currently implemented:### MetaTypeSupportError#### DescriptionIndicates that an instance is not a member of class derived from thecorrect metaclass.#### Signature```pythonfrom typing import AnyexpMetaClass: type  # The expected metaclassactualValue: Any  # The actual value receivedargName: str  # Argument name```### FieldDecoderExceptionCustom exception raised when an instance of ``DataField`` attempts to decodewith default JSON decoder. The exception catches the ``JSONDecodeError`` andbrings additional information.### FieldEncoderExceptionCustom exception raised when an instance of ``DataField`` attempts toserialize its value to ``JSON`` format, but where the value is notserializable.### MissingArgumentException#### DescriptionInvoked when a function is called before it is ready.#### Signature```pythonfrom typing import AnymissingArgument: str  # Argument name```### RecursiveCreateGetError#### DescriptionRaised when a getter function calls a creator function a second time.#### Signature```pythonfrom worktoy.core import Functionfrom typing import Anycreator: Function  # The expected typevariableType: type  # The type of the variablevariableName: str  # Argument name```### TypeSupportError#### DescriptionThis exception should be raised when the argument type is not supported.#### Signature```pythonfrom typing import AnyexpectedType: type  # The expected typeactualValue: Any  # The actual value receivedargName: str  # Argument name```### UnavailableNameException#### DescriptionException raised when a name is already occupied. Meaning that the namedargument were expected to be ``None``.#### Signature```pythonfrom typing import AnyargName: str  # The unavailable nameexistingValue: Any  # The present value at the namenewValue: str  # The new value attempted to set```### UnexpectedEventException#### DescriptionRaised when receiving a ``QEvent`` of the wrong ``QEvent.Type``. (Please notethat this exception is intended for use with the companion ``WorkSide``module.)#### Signature```pythonfrom typing import AnyexpectedQEventType: str  # The expected QEvent.TypeactualEvent: Any  # The actual instance of QEvent receivedargumentName: str  # The argument name```### UnsupportedSubclassException#### DescriptionThis exception should be raised when encountering a variable of correcttype, but of incorrect subclass.#### Signature```pythonfrom typing import AnyargumentName: str  # The argument nameexpectedParent: type  # The actual instance of QEvent receivedactualValue: str  # The actual value of the variable```## CoreThis module provides common types and constants.</longdescription>
</pkgmetadata>