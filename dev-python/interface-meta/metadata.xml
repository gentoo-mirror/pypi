<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># InterfaceMeta[![PyPI - Version](https://img.shields.io/pypi/v/interface_meta.svg)](https://pypi.org/project/interface_meta/)![PyPI - Python Version](https://img.shields.io/pypi/pyversions/interface_meta.svg)![PyPI - Status](https://img.shields.io/pypi/status/interface_meta.svg)[![build](https://img.shields.io/github/workflow/status/matthewwardrop/interface_meta/Run%20Tox%20Tests)](https://github.com/matthewwardrop/interface_meta/actions?query=workflow%3A%22Run+Tox+Tests%22)[![codecov](https://codecov.io/gh/matthewwardrop/interface_meta/branch/master/graph/badge.svg?token=W4LD72EQMM)](https://codecov.io/gh/matthewwardrop/interface_meta)[![Code Style](https://img.shields.io/badge/code%20style-black-black)](https://github.com/psf/black)`interface_meta` provides a convenient way to expose an extensible API withenforced method signatures and consistent documentation.- **Documentation:** See below (full documentation will come at some point).- **Source:** https://github.com/matthewwardrop/interface_meta- **Bug reports:** https://github.com/matthewwardrop/interface_meta/issues## OverviewThis library has been extracted (with some modifications) from[`omniduct`](https://github.com/airbnb/omniduct), a library also principallywritten by this author, where it was central to the extensible pluginarchitecture. It places an emphasis on the functionality required to create awell-documented extensible plugin system, whereby the act of subclassing issufficient to register the plugin and ensure compliance to the parent API. Assuch, this library boasts the following features:- All subclasses of an interface must conform to the parent's API.- Hierarchical runtime property existence and method signature checking. Methods  are permitted to add additional *optional* arguments, but otherwise must  conform to the API of their parent class (which themselves may have extended  the API of the interface).- Subclass definition time hooks (e.g. for registration of subclasses into a  library of plugins, etc).- Optional requirement for methods in subclasses to explicity decorate methods  with an `override` decorator when replacing methods on an interface, making  it clearer as to when a class is introducing new methods versus replacing  those that form the part of the interface API.- Generation of clear docstrings on implementations that stitches together the  base interface documentation with any downstream extensions and quirks.- Support for extracting the quirks documentation for a method from other method  docstrings, in the event that subclass implementations are done in an internal  method.- Compatibility with ABCMeta from the standard library.## Example code```pythonfrom abc import abstractmethod, abstractpropertyfrom interface_meta import InterfaceMeta, override, quirk_docsclass MyInterface(metaclass=InterfaceMeta):    &quot;&quot;&quot;    An example interface.    &quot;&quot;&quot;    INTERFACE_EXPLICIT_OVERRIDES = True    INTERFACE_RAISE_ON_VIOLATION = False    INTERFACE_SKIPPED_NAMES = {'__init__'}    def __init__(self):        &quot;&quot;&quot;        MyInterface constructor.        &quot;&quot;&quot;        pass    @abstractproperty    def name(self):        &quot;&quot;&quot;        The name of this interface.        &quot;&quot;&quot;        pass    @quirk_docs(method='_do_stuff')    def do_stuff(self, a, b, c=1):        &quot;&quot;&quot;        Do things with the parameters.        &quot;&quot;&quot;        return self._do_stuff(a, b, c)    @abstractmethod    def _do_stuff(self, a, b, c):        passclass MyImplementation(MyInterface):    &quot;&quot;&quot;    This implementation of the example interface works nicely.    &quot;&quot;&quot;    @quirk_docs(method='_init', mro=False)    def __init__(self, a):        &quot;&quot;&quot;        MyImplementation constructor.        &quot;&quot;&quot;        self._init(a)    def _init(self, a):        &quot;&quot;&quot;        In this instance, we do nothing with a.        &quot;&quot;&quot;        pass    @property    @override    def name(self):        return &quot;Peter&quot;    @override    def _do_stuff(self, a, b, c):        &quot;&quot;&quot;        In this implementation, we sum the parameters.        &quot;&quot;&quot;        return a + b + c```Running `help(MyImplementation)` reveals how the documentation is generated:```pythonclass MyImplementation(MyInterface) |  This implementation of the example interface works nicely. | |  Method resolution order: |      MyImplementation |      MyInterface |      builtins.object | |  Methods defined here: | |  __init__(self, a) |      MyImplementation constructor. | |      In this instance, we do nothing with a. | |  do_stuff(self, a, b, c=1) |      Do things with the parameters. | |      MyImplementation Quirks: |          In this implementation, we sum the parameters. ...```## Related projects and prior artThis library is released into an already crowded space, and the author wouldlike to recognise some of the already wonderful work done by others. The primarydifference between this and other libraries is typically these other librariesfocus more on abstracting interface definitions and compliance, and less on thedocumentation and plugin registration work. While this work overlaps with theseprojects, its approach is sufficiently different (in the author's opinion)to warrant a separate library.- [`pure_interface`](https://github.com/seequent/pure_interface)- [`python-interface`](https://github.com/ssanderson/interface)`python-interface` has an emphasis on ensuring that implementations of variousinterfaces *strictly* adhere to the methods and properties associated withthe interface, and that helpful errors are raised when this is violated.Bycomparison this library focusses on functional comformance to parent classes,whereby methods on subclasses are allowed to include additional parameters. Italso focusses on ensuring that documentation for such quirks in method signatures are correctly composed into the final documentation rendered for that method.</longdescription>
</pkgmetadata>