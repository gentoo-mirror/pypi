<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. This work is licensed under a Creative Commons Attribution 4.0 International License... SPDX-License-Identifier: CC-BY-4.0.. Copyright (C) 2020 AT&amp;T Intellectual PropertyFramework Overview==================This package is a framework for writing RAN Intelligent Controller(RIC) Xapps in python. The framework reduces the amount of coderequired in an Xapp by providing common features needed by allPython-based Xapps including communication with the RIC message router(RMR) and the Shared Data Layer (SDL).The framework was designed to suport many types of Xapps, includingapplications that are purely reactive to RMR messages, and generalapplications that initiate actions according to other criteria.For complete documentation see the ReadTheDocs site for`xapp-frame-py &lt;https://docs.o-ran-sc.org/projects/o-ran-sc-ric-plt-xapp-frame-py&gt;`_.Reactive Xapps--------------A reactive Xapp acts on messages that are delivered (pushed) via RMR.The Xapp only takes action upon receipt of an RMR message. The Xappnever takes action at another time.This type of application is constructed by creating callback functionsand registering them with the framework by message type.  When an RMRmessage arrives, the appropriate callback is invoked based on themessage type.  An Xapp may define and register a separate callback foreach expected message type.  Every Xapp must define a default callbackfunction, which is invoked when a message arrives for which notype-specific callback was registered.  An analogy of this is AWSLambda: &quot;execute this code every time an event comes in&quot; (the code toexecute can depend on the type of event).General Xapps-------------A general Xapp acts according to its own criteria, which may includereceipt of RMR messages.This type of application is constructed by creating a single functionthat is invoked by the framework after initialization.  Typically thatfunction contains a `while (something)` event loop.  When the functionreturns, the Xapp stops.  In this usage, the Xapp must fetch its owndata, either from RMR, SDL or other source.  The framework does lesswork for a general application compared to a reactive application; theframework only sets up an RMR thread and an SDL connection beforeinvoking the client-provided function.Threading in the Framework--------------------------RMR interactions are processed in a thread started by the framework.This implementation detail is documented here for transparency, butmost users will not have to worry about this.In both types of Xapp, the framework launches a separate thread whoseonly job is to read from RMR and deposit all messages (and theirsummaries) into a thread-safe queue.  When the client Xapp reads fromRMR using the framework (this read is done by the framework itself inthe RMR Xapp, but by the client in a general Xapp), the read is donefrom the framework-managed queue.  The framework is implemented thisway so that a long-running client function (e.g., consume) will notblock RMR reads.  This is important because RMR is *not* a persistentmessage bus; if an RMR client does not read fast enough, messages canbe lost.  So in this framework the client code is not in the samethread as the RMR reads, to ensure that long-running client code willnot cause message loss.In the case of RMR Xapps, there are currently 3 potential threads; thethread that reads from RMR directly, and the user can optionally havethe RMR queue read run in a thread, returning execution back to theuser thread.  The default is only two threads however, where `.run`does not return back execution and the user code is finished at thatpoint.Healthchecks------------The framework provides a default RMR healthcheck probe handler forreactive Xapps.  When an RMR healthcheck message arrives, this handlerchecks that the RMR thread is healthy (of course the Xapp cannot evenreply if the thread is not healthy!), and that the SDL connection ishealthy.  The handler responds accordingly via RMR.  The Xapp canoverride this probe handler by registering a new callback for thehealthcheck message type.The framework provides no healthcheck handler for general Xapps. Thoseapplications must handle healthcheck probe messages appropriately whenthey read their RMR mailboxes.There is no http service in the framework, so there is no support forHTTP-based healthcheck probes, such as what a deployment manager likeKubernetes may use.Examples--------Two sample Xapps using this framework are provided in the `examples`directory of the`git repository &lt;https://gerrit.o-ran-sc.org/r/gitweb?p=ric-plt/xapp-frame.git;a=tree&gt;`_.The first, `ping`, is a general Xappthat defines a main function that reads its RMR mailbox in addition toother work.  The second, `pong`, is a reactive Xapp that only takesaction when a message is received.To run a demonstration, build the Docker images for both examplesusing the supplied Dockerfiles.  Then start the Pong container (thelistener) followed by the Ping container (the sender).  The Pingapplication sends a message, the pong application receives the messageand use RMR's return-to-sender feature to reply.  Ping then reads itsown mailbox and demonstrates other functionality.</longdescription>
</pkgmetadata>