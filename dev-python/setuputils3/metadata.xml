<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>setuputils3===========A utility module to automate building setup configuration files.The latest official release is available on PyPI athttps://pypi.org/project/setuputils3/and the latest source code is available on Gitlab athttps://gitlab.com/pdonis/setuputils3.Running ``setuputils`` in the root of your source tree will builda ``setup.cfg`` file for you from inputs that you supply and fromits ability to auto-discover the things that typically go into adistribution of your Python application or library. The main toolthat uses ``setup.cfg``, ``setuptools``, also has much the sameauto-discovery capability, but the advantage with ``setuputils`` isthat you get to see all the output of the auto-discovery logic inthe final ``setup.cfg`` file *before* using it to build yourdistribution. With ``setuptools``, you have no way of getting anadvance look at what the tool thinks should go into yourdistribution; you only see what is in the distribution after itis built.Using setuputils in this mode is simple: for each section of``setup.cfg``, you put options that you want to specify in advancein the root of your source tree in files with an ``.in`` extension,one for each section that will end up in ``setup.cfg``. For example,you would put metadata in the file ``metadata.in``, options in thefile ``options.in``, etc. For subsections, just use the subsectionname as it would appear in ``setup.cfg`` as the base file name, so,for example, entry points would appear in ``options.entry_points.in``.Do not include anything in the ``.in`` files that you want``setuputils`` to auto-discover, so, for example, if you want``setuputils`` to auto-discover your packages, you would not include&quot;packages&quot; in your ``options.in`` file at all (whereas with``setuptools`` you would include &quot;packages = find:&quot; in your``setup.cfg``).Once you have created your ``.in`` files, then you simply execute    $ python3 -m setuputilsin the root of your source tree. This will build the ``setup.cfg``file for you. You can then look at it to make sure it is correctbefore using a build backend to build your distribution.With this mode, if you are using a PEP 517 compliant build backend, youdo not need a ``setup.py`` script at all. You can use ``setuptools`` assuch a backend as long as you include a ``pyproject.toml file`` and specify``setuptools`` in it, as described in the Python packaging documentation.If you do have a ``setup.py`` script, all it would need to contain isan import of ``setuptools`` and call to ``setuptools.setup()`` with noarguments (since all of the information needed is in ``setup.cfg``).You can also use ``setuputils`` itself as a PEP 517 compliant buildbackend. In this mode, you can still run ``setuputils`` as described abovebefore doing your build to make sure ``setup.cfg`` is correct. But using``setuputils`` as your build backend ensures that ``setup.cfg`` will berebuilt on every build to ensure consistency with the current state ofyour source tree. To use ``setuputils`` as your build backend, your``pyproject.toml`` should look like this:    [build-system]    requires = [&quot;setuputils3 &gt;= 2.1&quot;, &quot;setuptools &gt;= 40.8.0&quot;, &quot;wheel&quot;]    build-backend = &quot;setuputils_build&quot;You still need to include ``setuptools`` and ``wheel`` as buildrequirements, since ``setuputils`` depends on them; the ``setuputils``build backend is just a thin wrapper around ``setuptools.build_meta``that ensures that ``setup.cfg`` is built and up to date before the``setuptools`` build runs.Note that if you have a ``setup.py`` script that was used with previousversions of ``setuputils``, you do not have to transition it to thenew format using ``.in`` files all at once. ``Setuputils`` will read anyglobal variables that are defined in your ``setup.py``, as you would havedone in previous ``setuputils`` versions, and include them in what itoutputs to ``setup.cfg`` after processing them just as it would have inprevious versions, so you can transition things incrementally if that worksbetter for your project. (However, you should remove any calls to``setup_vars`` in your ``setup.py`` script, leaving only the call to``setuptools.setup()`` with no arguments, since all the informationit needs will be in ``setup.cfg``.) Note that if you have a ``setup.py``script, you cannot use ``setuputils`` as a build backend; you can onlyuse it to generate ``setup.cfg`` before doing a build. Also note that ifyou are using ``setuputils`` in this &quot;legacy&quot; mode, you will have toinclude it in your source distributions (instead of just listing it as arequirement in ``pyprojects.toml``), since &quot;legacy&quot; mode builds have noway of specifying build requirements other than setuptools itself.See the module docstrings for more information.SETUPUTILS3 is Copyright (C) 2012-2022 by Peter A. Donis.Released under the Python Software Foundation License.</longdescription>
</pkgmetadata>