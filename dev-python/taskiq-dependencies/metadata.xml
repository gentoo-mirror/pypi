<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Taskiq dependenciesThis project is used to add FastAPI-like dependency injection to projects.This project is a part of the taskiq, but it doesn't have any dependencies,and you can easily integrate it in any project.# Installation```bashpip install taskiq-dependencies```# UsageLet's imagine you want to add DI in your project. What should you do?At first we need to create a dependency graph, check if there any cyclesand compute the order of dependencies. This can be done with DependencyGraph.It does all of those actions on create. So we can remember all graphs at the start ofour program for later use. Or we can do it when needed, but it's less optimal.```pythonfrom taskiq_dependencies import Dependsdef dep1() -&gt; int:    return 1def target_func(some_int: int = Depends(dep1)):    print(some_int)    return some_int + 1```In this example we have a function called `target_func` and as you can see, it depends on `dep1` dependency.To create a dependnecy graph have to write this:```pythonfrom taskiq_dependencies import DependencyGraphgraph = DependencyGraph(target_func)```That's it. Now we want to resolve all dependencies and call a function. It's simple as this:```pythonwith graph.sync_ctx() as ctx:    graph.target(**ctx.resolve_kwargs())```Voila! We resolved all dependencies and called a function with no arguments.The `resolve_kwargs` function will return a dict, where keys are parameter names, and values are resolved dependencies.### Async usageIf your lib is asynchronous, you should use async context, it's similar to sync context, but instead of `with` you should use `async with`. But this way your users can use async dependencies and async generators. It's not possible in sync context.```pythonasync with graph.async_ctx() as ctx:    kwargs = await ctx.resolve_kwargs()```## Q&amp;A&gt; Why should I use `with` or `async with` statements?Becuase users can use generator functions as dependencies.Everything before `yield` happens before injecting the dependency, and everything after `yield` is executed after the `with` statement is over.&gt; How to provide default dependencies?It maybe useful to have default dependencies for your project.For example, taskiq has `Context` and `State` classes that can be used as dependencies. `sync_context` and `async_context` methods have a parameter, where you can pass a dict with precalculated dependencies.```pythonfrom taskiq_dependencies import Depends, DependencyGraphclass DefaultDep:    ...def target_func(dd: DefaultDep = Depends()):    print(dd)    return 1graph = DependencyGraph(target_func)with graph.sync_ctx({DefaultDep: DefaultDep()}) as ctx:    print(ctx.resolve_kwargs())```You can run this code. It will resolve dd dependency into a `DefaultDep` variable you provide.## Getting parameters informationIf you want to get the information about how this dependency was specified,you can use special class `ParamInfo` for that.```pythonfrom taskiq_dependencies import Depends, DependencyGraph, ParamInfodef dependency(info: ParamInfo = Depends()) -&gt; str:    assert info.name == &quot;dd&quot;    return info.namedef target_func(dd: str = Depends(dependency)):    print(dd)    return 1graph = DependencyGraph(target_func)with graph.sync_ctx() as ctx:    print(ctx.resolve_kwargs())```The ParamInfo has the information about name and parameters signature. It's useful if you want to create a dependency that changes based on parameter name, or signature.## Exception propagationBy default if error happens within the context, we send this error to the dependency,so you can close it properly. You can disable this functionality by setting `exception_propagation` parameter to `False`.Let's imagine that you want to get a database session from pool and commit after the function is done.```pythonasync def get_session():    session = sessionmaker()    yield session    await session.commit()```But what if the error happened when the dependant function was called? In this case you want to rollback, instead of commit.To solve this problem, you can just wrap the `yield` statement in `try except` to handle the error.```pythonasync def get_session():    session = sessionmaker()    try:        yield session    except Exception:        await session.rollback()        return    await session.commit()```**Also, as a library developer, you can disable exception propagation**. If you do so, then no exception will ever be propagated to dependencies and no such `try except` expression will ever work.Example of disabled propogation.```pythongraph = DependencyGraph(target_func)with graph.sync_ctx(exception_propagation=False) as ctx:    print(ctx.resolve_kwargs())```</longdescription>
</pkgmetadata>