<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># mflog[//]: # (automatically generated from https://github.com/metwork-framework/github_organization_management/blob/master/common_files/README.md)**Status (master branch)**[![GitHub CI](https://github.com/metwork-framework/mflog/workflows/CI/badge.svg?branch=master)](https://github.com/metwork-framework/mflog/actions?query=workflow%3ACI&amp;branch=master)[![Maintenance](https://github.com/metwork-framework/resources/blob/master/badges/maintained.svg)]()## What is it ?It is an opinionated python (structured) logging library built on [structlog](https://www.structlog.org/)for the [MetWork Framework](http://metwork-framework.org) (but it can be used in any context).&gt; Structured logging means that you donâ€™t write hard-to-parse and hard-to-keep-consistent prose in your logs but that you log events that happen in a context instead.&gt; - https://www.structlog.org/en/stable/why.htmlExample:```pythonfrom mflog import get_logger# Get a loggerlog = get_logger(&quot;foo.bar&quot;)# Bind some attributes to the logger depending on the contextlog = log.bind(user=&quot;john&quot;)log = log.bind(user_id=123)# [...]# Log somethinglog.warning(&quot;user logged in&quot;, happy=True, another_key=42)```On `stderr`, you will get:```2019-01-28T07:52:42.903067Z  [WARNING] (foo.bar#7343) user logged in {another_key=42 happy=True user=john user_id=123}```On `json output file`, you will get:```json{    &quot;timestamp&quot;: &quot;2019-01-28T08:16:40.047710Z&quot;,    &quot;level&quot;: &quot;warning&quot;,    &quot;name&quot;: &quot;foo.bar&quot;,    &quot;pid&quot;: 29317,    &quot;event&quot;: &quot;user logged in&quot;,    &quot;another_key&quot;: 42,    &quot;happy&quot;: true,    &quot;user&quot;: &quot;john&quot;,    &quot;user_id&quot;: 123}```If the [python/rich library](https://github.com/willmcgugan/rich) is installed (this is not amandatory requirement) and if the output is a real terminal (and not a redirection or a pipe),the library will automatically configure a fancy color output (of course you can disable it ifyou don't like):With following demo python program:```pythonimport mflog# Get a loggerlogger = mflog.get_logger(&quot;foobar&quot;)# Bind two context variables to this loggerlogger = logger.bind(user_id=1234, is_logged=True)# Log somethinglogger.info(&quot;This is an info message&quot;, special_value=&quot;foo&quot;)logger.critical(&quot;This is a very interesting critical message&quot;)# Let's play with exceptiontry:    # Just set a variable to get a demo of locals variable dump    var = {&quot;key1&quot;: [1, 2, 3], &quot;key2&quot;: &quot;foobar&quot;}    1/0except Exception:    logger.exception(&quot;exception raised (a variables dump should follow)&quot;)```You will get this color ouput:![color output](./demo/demo.png)## (opinionated) Choices and Features- we use main ideas from `structlog` library- we log `[DEBUG]` and `[INFO]` messages on `stdout` (in a human friendly way)- we log `[WARNING]`, `[ERROR]` and `[CRITICAL]` on `stderr` (in a human friendly way)- (and optionally) we log all messages (worse than a minimal configurable level) in a configurable file in `JSON` (for easy automatic parsing)- (and optionally) we send all messages (worse than a minimal configurable level) to an UDP syslog server (in JSON or in plain text)- we can configure a global minimal level to ignore all messages below- we reconfigure automatically python standard logging library to use `mflog`- Unicode and Bytes messages are supported (in Python2 and Python3)- good support for exceptions (with backtraces)- override easily minimal levels (for patterns of logger names) programmatically or with plain text configuration files- if the [python/rich library](https://github.com/willmcgugan/rich) is installed (this is not a mandatory requirement) and if the output is a real terminal (and not a redirection), the library will automatically configure a fancy color output (can be really useful but of course you can disable this feature if you don't like it)## How to use ?A `mflog` logger can be used as a standard `logging` logger.For example:```python# Importfrom mflog import get_logger# Get a loggerx = get_logger(&quot;foo.bar&quot;)# Usagex.warning(&quot;basic message&quot;)x.critical(&quot;message with templates: %i, %s&quot;, 2, &quot;foo&quot;)x.debug(&quot;message with key/values&quot;, foo=True, bar=&quot;string&quot;)try:    1/0except Exception:    x.exception(&quot;we catched an exception with automatic traceback&quot;)x = x.bind(context1=&quot;foo&quot;)x = x.bind(context2=&quot;bar&quot;)x.info(&quot;this is a contexted message&quot;, extra_var=123)```## How to configure ?### In python```pythonimport mflog# Configuremflog.set_config(minimal_level=&quot;DEBUG&quot;, json_minimal_level=&quot;WARNING&quot;,                 json_file=&quot;/foo/bar/my_output.json&quot;)# Get a loggerx = mflog.get_logger(&quot;foo.bar&quot;)# [...]```### With environment variables```bash$ export MFLOG_MINIMAL_LEVEL=&quot;DEBUG&quot;$ export MFLOG_JSON_MINIMAL_LEVEL=&quot;WARNING&quot;$ export MFLOG_JSON_FILE=&quot;/foo/bar/my_output.json&quot;$ python&gt;&gt;&gt; import mflog&gt;&gt;&gt;&gt;&gt;&gt; # Get a logger&gt;&gt;&gt; x = mflog.get_logger(&quot;foo.bar&quot;)&gt;&gt;&gt;&gt;&gt;&gt; # [...]```### NoteWhen you get a `mflog` logger, if default configuration is applied automaticallyif not set manually before.## How to override minimal level for a specific loggerIf you have a &quot;noisy&quot; specific logger, you can override its minimal log level.The idea is to configure this in a file like this:```# lines beginning with # are comments# this line say 'foo.bar' logger will have a minimal level of WARNINGfoo.bar =&gt; WARNING# this line say 'foo.*' loggers will have a minimal level of DEBUG# (see python fnmatch for accepted wildcards)foo.* =&gt; DEBUG# The first match wins```Then, you can use```python# yes we use a list here because you can use several files# (the first match wins)mflog.set_config([...], override_files=[&quot;/full/path/to/your/override.conf&quot;])```or```# if you want to provide multiple files, use ';' as a separatorexport MFLOG_MINIMAL_LEVEL_OVERRIDE_FILES=/full/path/to/your/override.conf```## Link with standard python logging libraryWhen you get a `mflog` logger or when you call `set_config()` function,the standard python `logging` library is reconfigured to use `mflog`.Example:```pythonimport loggingimport mflog# standard use of logging libraryx = logging.getLogger(&quot;standard.logger&quot;)print(&quot;&lt;output of the standard logging library&gt;&quot;)x.warning(&quot;foo bar&quot;)print(&quot;&lt;/output of the standard logging library&gt;&quot;)# we set the mflog configurationmflog.set_config()# now logging library use mflogprint()print(&quot;&lt;output of the standard logging library through mflog&gt;&quot;)x.warning(&quot;foo bar&quot;)print(&quot;&lt;/output of the standard logging library through mflog&gt;&quot;)```Output:```&lt;output of the standard logging library&gt;foo bar&lt;/output of the standard logging library&gt;&lt;output of the standard logging library through mflog&gt;2019-01-29T09:32:37.093240Z  [WARNING] (standard.logger#15809) foo bar&lt;/output of the standard logging library through mflog&gt;```## mflog loggers API### `.debug(message, *args, **kwargs)`Log the given message as `[DEBUG]`.- `*args` can be used for placeholders (to format the given message)- `**kwargs` can be used for key/values (log context).Examples:```pythonfrom mflog import get_loggerx = get_logger('my.logger')x.debug(&quot;my debug message with placeholders: %s and %i&quot;, &quot;foo&quot;, 123,        key1=&quot;value1, key2=True, key5=123)```### `.info(message, *args, **kwargs)`Same as `.debug` but with `[INFO]` severity level.### `.warning(message, *args, **kwargs)`Same as `.debug` but with `[WARNING]` severity level.### `.error(message, *args, **kwargs)`Same as `.debug` but with `[ERROR]` severity level.### `.critical(message, *args, **kwargs)`Same as `.debug` but with `[CRITICAL]` severity level.### `.exception(message, *args, **kwargs)`Same as `.error` (so with `[ERROR]` severity level) but we automatically addthe current stacktrace in the message through special key/values.### `.bind(**new_values)`Return a new logger with `**new_values` added to the existing ones(see examples at the beginning).### `.unbind(*keys)`Return a new logger with `*keys` removed from the context.It raises `KeyError` if the key is not part of the context.### `.try_unbind(*keys)`Like `.unbind` but best effort:  missing keys are ignored.### `.die(optional_message, *args, **kwargs)`Same as `.exception()` but also do a `.dump_locals()` call and exit the programwith `sys.exit(1)`.### `.dump_locals()`Dump locals variables on `stderr` (for debugging).### `mflog.*`All previous loggers method are also available in `mflog` module.Example:```pythonimport mflogmflog.warning(&quot;this is a warning message&quot;, context1=&quot;foobar&quot;, user_id=123)```## FAQ## If I want to use mflog inside my library ?If you write a library and if you want to use `mflog`, use `mflog` normally.You just should avoid to call `set_config()` inside your library.## Do you have &quot;thread local context mode&quot; ?This mode is explained [here](https://www.structlog.org/en/stable/thread-local.html).You have to understand what you are doing.If you want to use it, just add `thread_local_context=True` to your `set_config()`call. And you can use `.new(**new_values)` on mflog loggers to clear contextand binds some initial values.## Can I globally add an extra context to each log line ?If you add `extra_context_func=your_python_func` to your `set_config()` call,and if `your_python_func` returns a dict of key/values as strings when calledwith no argument, these key/values will be added to your log context.Another way to do that without even calling `set_config()` is to definean environment variable called `MFLOG_EXTRA_CONTEXT_FUNC` containing thefull path to your python func.Full example:```bash# in shellexport MFLOG_EXTRA_CONTEXT_FUNC=&quot;mflog.unittests.extra_context&quot;```then, in your python interpreter:```python&gt;&gt;&gt; from mflog import get_logger&gt;&gt;&gt; get_logger(&quot;foo&quot;).info(&quot;bar&quot;)2019-04-11T07:32:53.517260Z     [INFO] (foo#15379) bar {extra_context_key1=extra_context_value1 extra_context_key2=extra_context_value2}```Here is the code of `mflog.unittests.extra_context`:```pythondef extra_context():    return {&quot;extra_context_key1&quot;: &quot;extra_context_value1&quot;,            &quot;extra_context_key2&quot;: &quot;extra_context_value2&quot;}```## Can I filter some context keys in stdout/stderr output (but keep them in json output) ?Yes, add `json_only_keys=[&quot;key1&quot;, &quot;key2&quot;]` to your `set_config()` call or use`MFLOG_JSON_ONLY_KEYS=key1,key2` environment variable.## What about if I don't want to redirect standard python `logging` to `mflog` ?You can add `standard_logging_redirect=False` in your `set_config()` callof set `MFLOG_STANDARD_LOGGING_REDIRECT=0` environment variable.## Can I silent a specific noisy logger?You can use `override_files` feature to do that or you can also use the`mflog.add_override` function.For example:```pythonimport mflog# for all mylogger.* loggers (fnmatch pattern), the minimal level is CRITICALmflog.add_override(&quot;mylogger.*&quot;, CRITICAL)# Not very interesting but this call will be ignoredmflog.get_logger(&quot;mylogger.foo&quot;).warning(&quot;foo&quot;)```## How can I use syslog logging?You can configure it with these keyword arguments during `set_config()` call:- `syslog_minimal_level`: `WARNING`, `CRITICAL`...- `syslog_address`: `null` (no syslog (defaut)), `127.0.0.1:514` (send packets to 127.0.0.1:514), `/dev/log` (unix socket)...- `syslog_format`: `msg_only` (default) or `json`or with corresponding env vars:- `MFLOG_SYSLOG_MINIMAL_LEVEL`- `MFLOG_SYSLOG_ADDRESS`- `MFLOG_SYSLOG_FORMAT`## How to disable the fancy color output?This feature is automatically enabled when:- [python/rich](https://github.com/willmcgugan/rich) library is installed- the corresponding output (stdout, stderr) is a real terminal (and not a redirection to a file)But you can manually disable it by adding `fancy_output=False` to your `set_config()`.## CoverageSee [Coverage report](https://metwork-framework.org/pub/misc/mflog/coverage/)## Contributing guideSee [CONTRIBUTING.md](CONTRIBUTING.md) file.## Code of ConductSee [CODE_OF_CONDUCT.md](CODE_OF_CONDUCT.md) file.## Sponsors*(If you are officially paid to work on MetWork Framework, please contact us to add your company logo here!)*[![logo](https://raw.githubusercontent.com/metwork-framework/resources/master/sponsors/meteofrance-small.jpeg)](http://www.meteofrance.com)</longdescription>
</pkgmetadata>