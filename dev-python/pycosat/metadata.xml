<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>===========================================pycosat: bindings to picosat (a SAT solver)===========================================`PicoSAT &lt;http://fmv.jku.at/picosat/&gt;`_ is a popular`SAT &lt;http://en.wikipedia.org/wiki/Boolean_satisfiability_problem&gt;`_ solverwritten by Armin Biere in pure C.This package provides efficient Python bindings to picosat on the C level,i.e. when importing pycosat, the picosat solver becomes part of thePython process itself.  For ease of deployment, the picosat source (namelypicosat.c and picosat.h) is included in this project.  These files havebeen extracted from the picosat source (picosat-965.tar.gz).Usage-----The ``pycosat`` module has two functions ``solve`` and ``itersolve``,both of which take an iterable of clauses as an argument. Each clauseis itself represented as an iterable of (non-zero) integers.The function ``solve`` returns one of the following:  * one solution (a list of integers)  * the string &quot;UNSAT&quot; (when the clauses are unsatisfiable)  * the string &quot;UNKNOWN&quot; (when a solution could not be determined within the    propagation limit)The function ``itersolve`` returns an iterator over solutions.  When thepropagation limit is specified, exhausting the iterator may not yield allpossible solutions.Both functions take the following keyword arguments:  * ``prop_limit``: the propagation limit (integer)  * ``vars``: number of variables (integer)  * ``verbose``: the verbosity level (integer)Example-------Let us consider the following clauses, represented usingthe DIMACS `cnf &lt;http://en.wikipedia.org/wiki/Conjunctive_normal_form&gt;`_format::   p cnf 5 3   1 -5 4 0   -1 5 3 4 0   -3 -4 0Here, we have 5 variables and 3 clauses, the first clause being(x\ :sub:`1`  or not x\ :sub:`5` or x\ :sub:`4`).Note that the variable x\ :sub:`2` is not used in any of the clauses,which means that for each solution with x\ :sub:`2` = True, we mustalso have a solution with x\ :sub:`2` = False.  In Python, each clause ismost conveniently represented as a list of integers.  Naturally, it makessense to represent each solution also as a list of integers, where the signcorresponds to the Boolean value (+ for True and - for False) and theabsolute value corresponds to i\ :sup:`th` variable::   &gt;&gt;&gt; import pycosat   &gt;&gt;&gt; cnf = [[1, -5, 4], [-1, 5, 3, 4], [-3, -4]]   &gt;&gt;&gt; pycosat.solve(cnf)   [1, -2, -3, -4, 5]This solution translates to: x\ :sub:`1` = x\ :sub:`5` = True,x\ :sub:`2` = x\ :sub:`3` = x\ :sub:`4` = FalseTo find all solutions, use ``itersolve``::   &gt;&gt;&gt; for sol in pycosat.itersolve(cnf):   ...     print sol   ...   [1, -2, -3, -4, 5]   [1, -2, -3, 4, -5]   [1, -2, -3, 4, 5]   ...   &gt;&gt;&gt; len(list(pycosat.itersolve(cnf)))   18In this example, there are a total of 18 possible solutions, which had tobe an even number because x\ :sub:`2` was left unspecified in the clauses.The fact that ``itersolve`` returns an iterator, makes it very elegantand efficient for many types of operations.  For example, usingthe ``itertools`` module from the standard library, here is how onewould construct a list of (up to) 3 solutions::   &gt;&gt;&gt; import itertools   &gt;&gt;&gt; list(itertools.islice(pycosat.itersolve(cnf), 3))   [[1, -2, -3, -4, 5], [1, -2, -3, 4, -5], [1, -2, -3, 4, 5]]Implementation of itersolve---------------------------How does one go from having found one solution to another solution?The answer is surprisingly simple.  One adds the *inverse* of the alreadyfound solution as a new clause.  This new clause ensures that anothersolution is searched for, as it *excludes* the already found solution.Here is basically a pure Python implementation of ``itersolve`` in termsof ``solve``::   def py_itersolve(clauses): # don't use this function!       while True:            # (it is only here to explain things)           sol = pycosat.solve(clauses)           if isinstance(sol, list):               yield sol               clauses.append([-x for x in sol])           else: # no more solutions -- stop iteration               returnThis implementation has several problems.  Firstly, it is quite slow as``pycosat.solve`` has to convert the list of clauses over and over and overagain.  Secondly, after calling ``py_itersolve`` the list of clauses willbe modified.  In pycosat, ``itersolve`` is implemented on the C level,making use of the picosat C interface (which makes it much, much fasterthan the naive Python implementation above).</longdescription>
</pkgmetadata>