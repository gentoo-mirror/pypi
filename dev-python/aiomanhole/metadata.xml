<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>aiomanhole==========Manhole for accessing asyncio applications. This is useful for debuggingapplication state in situations where you have access to the process, but needto access internal application state.Adding a manhole to your application is simple::    from aiomanhole import start_manhole    start_manhole(namespace={        'gizmo': application_state_gizmo,        'whatsit': application_state_whatsit,    })Quick example, in one shell, run this::    $ python -m aiomanholeIn a secondary shell, run this::    $ nc -U /var/tmp/testing.manhole    Well this is neat    &gt;&gt;&gt; f = 5 + 5    &gt;&gt;&gt; f    10    &gt;&gt;&gt; import os    &gt;&gt;&gt; os.getpid()    4238    &gt;&gt;&gt; import sys    &gt;&gt;&gt; sys.exit(0)And you'll see the manhole you started has exited.The package provides both a threaded and non-threaded interpreter, and allowsyou to share the namespace between clients if you want.I'm getting &quot;Address is already in use&quot; when I start! Help!===========================================================Unlike regular TCP/UDP sockets, UNIX domain sockets are entries in thefilesystem. When your process shuts down, the UNIX socket that is created isnot cleaned up. What this means is that when your application starts up again,it will attempt to bind a UNIX socket to that path again and fail, as it isalready present (it's &quot;already in use&quot;).The standard approach to working with UNIX sockets is to delete them before youtry to bind to it again, for example::    import os    try:        os.unlink('/path/to/my.manhole')    except FileNotFoundError:        pass    start_manhole('/path/to/my.manhole')You may be tempted to try and clean up the socket on shutdown, but don't. Whatif your application crashes? What if your computer loses power? There are lotsof things that can go wrong, and hoping the previous run was successful, whileadmirably positive, is not something you can do.Can I specify what is available in the manhole?===============================================Yes! When you call `start_manhole`, just pass along a dictionary of what youwant to provide as the namespace parameter::    from aiomanhole import start_manhole    start_manhole(namespace={        'gizmo': application_state_gizmo,        'whatsit': application_state_whatsit,        'None': 5,  # don't do this though    })When should I use threaded=True?================================Specifying threaded=True means that statements in the interactive session areexecuted in a thread, as opposed to executing them in the event loop.Say for example you did this in a non-threaded interactive session::    &gt;&gt;&gt; while True:    ...  pass    ...You've just broken your application! You can't abort that without restartingthe application. If however you ran that in a threaded application, you'd'only' have a thread trashing the CPU, slowing down your application, asopposed to making it totally unresponsive.By default, a threaded interpreter will time out commands after 5 seconds,though this is configurable. Not that this will **not** kill the thread, butallow you to keep running commands.Change History==============0.7.0 (23rd January 2022) - Added support for Python 3.10. Thank you to Peter BÃ¡bics for contributing this! - Removed support for Python 3.5.0.6.0 (30th April 2019) - Don't use the global loop. Thanks Timothy Fitz! - Allow a port of 0. Thanks Timothy Fitz! - Fix unit test failure.0.5.0 (6th August 2018) - Fix syntax error in 3.7 - Drop 3.4 support.0.4.2 (3rd March 2017) - Handle clients putting the socket into a half-closed state when an EOF   occurs.0.4.1 (3rd March 2017) - Ensure prompts are bytes, broken in 0.4.0.0.4.0 (3rd March 2017) - Ensure actual syntax errors get reported to the client.0.3.0 (23rd August 2016) - **Behaviour change** aiomanhole no longer attempts to remove the UNIX socket   on shutdown. This was flakey behaviour and does not match best practice   (i.e. removing the UNIX socket on startup before you start your server). As   a result, errors creating the manhole will now be logged instead of silently   failing. - `start_manhole` now returns a Future that you can wait on. - Giving a loop to `start_manhole` now works more reliably. This won't matter   for most people. - Feels &quot;snappier&quot;0.2.1 (14th September 2014) - Handle a banner of None. - Fixed small typo in MANIFEST.in for the changelog. - Feels &quot;snappier&quot;0.2.0 (25th June 2014) - Handle multiline statements much better. - setup.py pointed to wrong domain for project URL - Removed pointless insertion of '_' into the namespace. - Added lots of tests. - Feels &quot;snappier&quot;0.1.1 (19th June 2014) - Use setuptools as a fallback when installing. - Feels &quot;snappier&quot;0.1 (19th June 2014) - Initial release - Feels &quot;snappier&quot;</longdescription>
</pkgmetadata>