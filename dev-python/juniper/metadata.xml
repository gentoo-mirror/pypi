<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Juniper: Package lambda functions=================================|circle| |pypi version| |apache license|Juniper is a packaging tool to stream and standardize the creation of a zipartifact for a set of AWS Lambda functions.The zip artifacts generated include the source code of the dependencies definedin a given requirements.txt file as well as any shared libraries the functiondepends on. With the generated artifact, a developer can deploy a lambda functioneither manually, through the awscli or using a cloudformation/sam template.Quickstart**********With Python==3.6 and Docker installed, install juniper:.. code-block:: text    &gt; pip install juniperIn order to package your lambda functions with juniper, you need to create amanifest file... code-block:: yaml    functions:      # Name the zip file you want juni to create      router:        # The dependencies of the router function.        requirements: ./src/requirements.txt        # Include this file in the generated zip artifact.        include:        - ./src/lambda_function.pyThe folder structure this manifest refers to looks like:::    .    â”œâ”€â”€ manifest.yml    â”œâ”€â”€ src    â”‚Â Â  â”œâ”€â”€ requirements.txt    â”‚Â Â  â”œâ”€â”€ lambda_function.pyBuild it!.. code-block:: text    &gt; juni buildJuniper creates the following artifact `./dist/router.zip`  ðŸŽ‰For a more comprehensive example, please take a look at our `tutorial`_.The juni build command will generate the lambda artifact for all the functions andlayers defined in the manifest file. However, during the development process, it may bedesired to only build the lambda functions that a developer is actively working on.To build only a subset of the resources defined in the manifest use the followingcommand:.. code-block:: text    &gt; juni build --skip-clean -f &lt;target_fn_name&gt;This command will build all the functions that partially match the given target_fn_name.When using a naming convention a developer has the ability to build a subset ofthe lambdas defined in the manifest.The skip-clean flag will prevent the previously built artifacts from being deletedbefore the build is executed... _`tutorial`: https://eabglobal.github.io/juniper/tutorial.htmlPython3.7 and Beyond********************By default juniper uses docker containers to package your lambda functions. Behindthe scenes, juniper creates a docker-compose file from your manifest. This file isused by the `build` command to spawn a build container per function definition.Since the AWS Lambda service supports multiple python runtimes, it makes sense forjuniper to give you the ability to specify a docker image. With the followingmanifest file, you can package the router lambda using a python3.7 image... code-block:: yaml    functions:      router:        # Use this docker image        image: lambci/lambda:build-python3.7        requirements: ./src/router/requirements.txt        # Include these local modules in the artifact        include:        - ./src/commonlib/mylib        - ./src/router_function/routerKeep in mind that not every single docker image works, for more information onthe type of images supported read `juniper and docker`_... _`juniper and docker`: https://eabglobal.github.io/juniper/features.htmlLambda Layers*************AWS Lambda layers is a recent service that gives a developer the ability topre-package a set of dependencies. A lambda function can be built on top of multiplelayers, either packaged by the developer, by AWS or by a third party.To build a layer, the juniper manifest uses a new block:.. code-block:: yaml  layers:    base:      requirements: ./src/requirements/base.txt    pg:      requirements: ./src/requirements/postgres.txtWith this manifest, running **juni build** creates two layer artifacts: one with thename base and another one named pg. Lambda layers are packaged along the lambdafunctions defined in the manifest and the zip files are stored in the artifacts directory.The generated artifact includes the dependencies defined in the requirements fileof the lambda layer.Each individual section supports the definition of a custom docker image. With thisfeature, a layer can be built using python3.7 and another one can be built using thedefault python interpreter; python3.6... code-block:: yaml  layers:    base:      image: lambci/lambda:build-python3.7      requirements: ./src/requirements/base.txtJuniper builds the artifact for you, you can either use the `layers aws cli`_ toupload it to AWS or you can use a SAM template definition. While using a SAM template,make sure you use the `AWS::Serverless::LayerVersion` resource.To see an example on how to package lambda functions with layers, juniper includesan example in the codebase called `ridge`_... _`layers aws cli`: https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html#configuration-layers-manage.. _`ridge`: https://github.com/eabglobal/juniper/tree/master/examples/ridgeConfiguration*************To update the default configuration of juniper, can use the the global sectionof the manifest. A sample configuration looks like:.. code-block:: yaml    global:      image: lambci/lambda:build-python3.7      output: ./build    functions:      router:        requirements: ./src/router/requirements.txt        include:        - ./src/router_function/router/lambda_function.pySetting a docker image at a global level tells juniper to package everylambda function using that image. In this example, the zip artifacts will be stored inthe ./build folder instead of the ./dist; which is the default.Include Binaries****************Using the lambci build images to create the zip artifacts for a given set of lambdafunctions is sufficient for most use cases. However, there are times when the base containerdoes not have all the build libraries necessary to install a python package. In this casesrunning `juni build` fails while trying to pip install the dependencies of the function.In addition, once the libraries are installed in the container some packages require a set ofbinaries to work properly at runtime.The recommended procedure to install OS libraries and include missing dependenciesis to use a dockerfile to build a local docker image. The strategy is illustrated as follows:* Create a dockerfile using one of the lambci images as a starting point* Build a local docker image from the docker file* Use the local image in the juniper manifestWith this startegy, the juniper manifest will look like this:.. code-block:: yaml    functions:      router:        image: custom/local_docker_image        requirements: ./src/router/requirements.txt        include:        - ./src/router_function/router/lambda_function.pyIn this case, a developer needs to build the docker image before executing thejuni build command.At this point, the developer can push the docker image to the docker hub and usethe hosted version instead of the local one. This strategy separates the build ofa custom image from the build of the artifacts.If you need binaries in the final artifact, you can place these files either in the**/var/task/lambda_lib/** or the **/var/task/lambda_bin/** depending on your use case.Files added to the bin folder are included in the PATH, files added to the lib,are included in the LD_LIBRARY_PATH. For more information view `aws layer config`_.Juniper is in charge of putting the files in the lambda_bin and lambda_lib inthe right place when building an artifact.A concrete example of the configuration is outlined in the `advanced`_ sectionof our documentation... _`advanced`: https://eabglobal.github.io/juniper/advanced.html.. _`aws layer config`: https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html#configuration-layers-pathPIP Configuration*****************To set any pip configuration parameters, create a pip.conf file and add the pathto the manifest. The **pipconf** setting is only available at a global level andit will apply to the packaging of all the functions defined in the manifest... code-block:: yaml  global:    pipconf: ./pip.conf  functions:    sample:      requirements: ./requirements.txt      include:        - ./lambda_function.pyA sample pip.conf file can be seen bellow, to see the entire list of parametersvisit the official `pip documentation`_... code-block:: yaml  [global]  timeout = 5  index-url = https://download.zope.org/ppix.. _`pip documentation`: https://pip.pypa.io/en/stable/user_guide/#config-fileFeatures********This list defines the entire scope of Juniper. Nothing more, nothing else.* Minimal manifest file to define packaging* Using docker containers as a way to install dependencies and generate the artifacts* Ability to tailor the requirements.txt per lambda* Create an individual zip artifact for multiple lambda functions* Ability to include shared dependencies (python modules relative to the function  being packaged)* Specify docker image to package lamdba functions using different python runtimes* Define pip command line arguments using a pip.conf file* Packaging of lambda layersContributing************For guidance on setting up a development environment and how to make acontribution to Juniper, see the `contributing guidelines`_... _contributing guidelines: https://github.com/eabglobal/juniper/blob/master/CONTRIBUTING.rstLinks****** Documentation: https://eabglobal.github.io/juniper/* License: `Apache Software License`_* Code: https://github.com/eabglobal/juniper* Issue tracker: https://github.com/eabglobal/juniper/issues* Test status:  * Linux, Mac: https://circleci.com/gh/eabglobal/juniper.. _Apache Software License: https://github.com/eabglobal/juniper/blob/master/LICENSE.. |circle| image:: https://circleci.com/gh/eabglobal/juniper/tree/master.svg?style=shield    :target: https://circleci.com/gh/eabglobal/juniper/tree/master.. |pypi version| image:: https://img.shields.io/pypi/v/juniper.svg    :target: https://pypi.org/project/juniper/.. |apache license| image:: https://img.shields.io/github/license/eabglobal/juniper.svg    :target: https://github.com/eabglobal/juniper/blob/master/LICENSE</longdescription>
</pkgmetadata>