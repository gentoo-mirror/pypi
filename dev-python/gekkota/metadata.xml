<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/courage-tci/gekkota/build.yml?branch=pub)](https://github.com/courage-tci/gekkota/actions/workflows/build.yml)[![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/courage-tci/gekkota/test.yml?branch=pub&amp;label=tests)](https://github.com/courage-tci/gekkota/actions/workflows/test.yml)[![PyPI](https://img.shields.io/pypi/v/gekkota)](https://pypi.org/project/gekkota/)![PyPI - Downloads](https://pepy.tech/badge/gekkota)![PyPI - Python Version](https://img.shields.io/pypi/pyversions/gekkota)[![Coveralls](https://img.shields.io/coverallsCoverage/github/courage-tci/gekkota?label=test%20coverage)](https://coveralls.io/github/courage-tci/gekkota?branch=pub)![License](https://img.shields.io/github/license/courage-tci/gekkota)![Badge Count](https://img.shields.io/badge/badges-8-important)This is a Python code-generation module.    - Generates any Python statement/expression- Places parens to ensure expression priorities are unchanged- Places extra newlines before/after class/function definitions to conform with PEP 8- 100% coverage of type hints, passing MyPy with `--disallow-any-expr`- Meaningful type hierarchy inspired by Python grammar- Covered with ~~diamonds~~ tests completely ## InstallationJust install `gekkota` package, e.g. with `python -m pip install gekkota` (or any other package manager of your choice)## Rendering and configurationTo render any `Renderable` into a string, you could use a few approaches:- `str(renderable)`: renders a Renderable with default configuration (check below)- `renderable.render_str()`: also default configuration- `renderable.render_str(config)`: overrides default config options with provided in `config` mapping. Unspecified keys remain at default valuesHere is current default config:```pythondefault_config: Config = {    &quot;tab_size&quot;: 4,  # how much chars to use in indentation    &quot;compact&quot;: False,  # if True, renders without redundant whitespace (e.g &quot;for [i, e] in enumerate(a)&quot; renders as &quot;for[i,e]in enumerate(a)&quot;)    &quot;tab_char&quot;: &quot; &quot;,  # character used for indentation    # &quot;place_semicolons&quot; and &quot;inline_small_stmts&quot; options have some performance impact, since those require checking for newlines in token stream before re-streaming tokens.    # this impact is probably negligible, but be aware of it    &quot;place_semicolons&quot;: False,  # if True, semicolons are placed after one-line statements    &quot;inline_small_stmts&quot;: False,  # if True, one-line statements are inlined. Overrides &quot;place_semicolons&quot; if True.}```## Expressions### Basic expressionsYour starting points would be `to_expression` and `Name`:```pythonfrom gekkota import Name, to_expression# Name(name: str, annotation: Optional[Expression] = None)# to_expression(value: int | float | complex | str | bytes | bool | None)a = Name(&quot;a&quot;)b = Name(&quot;b&quot;)six = to_expression(6)# prints 'a + b * 6'print(    (a + b * six))````Name`, as many other classes in the module, is an `Expression` instanceExpressions support most operations to combine with other expressions.    Exceptions are:- Attribute reference: for that you should use `Expression.getattr(other: str)`- Indexing: `Expression.index(index: Expression)`- Slicing: `Expression.index(index: Union[SliceExpr, Sequence[SliceExpr]])`- Equality / Inequality: `Expression.eq(right_hand_side)` and `Expression.neq(right_hand_side)` respectively- `is`: `Expression.is_(right_hand_side)`,- `is not`: `Expression.is_not(right_hand_side)`- `in`: `Expression.in_(right_hand_side)`- `not in`: `Expression.not_in(right_hand_side)`- `and`: `Expression.and_(right_hand_side)`- `or`: `Expression.or_(right_hand_side)`- `await`: `Expression.await_()`- `:=` assignment: `Expression.assign(value)`- Ternary operator: `Expression.if_(condition, alternative)`For example:```pythonfrom gekkota import Namea = Name(&quot;a&quot;)b = Name(&quot;b&quot;)expression = a.await_().in_(b)print(expression) # await a in b```For any other operation on expressions you can just use familiar Python syntax:```pythonfrom gekkota import Namea = Name(&quot;a&quot;)b = Name(&quot;b&quot;)c = Name(&quot;c&quot;)print(    (a + b * c / a(b, c)) # 'a + b * c / a(b, c)')```### SequencesMost convenient way to create sequence literals is, again, `to_expression`:```pythonfrom gekkota import to_expression, Namea = Name(&quot;a&quot;)b = Name(&quot;b&quot;)print(    to_expression( (a, b, 6) ), # '(a, b, 6)' (notice that to_expression is recursive)    to_expression( (a, ) ),     # '(a, )'    to_expression([a, b]),      # '[a, b]'    to_expression([]),          # '[]'    to_expression({a: b}),      # '{a: b}'    to_expression(set()),       # 'set()'    to_expression([a, [a, b]]), # '[a, [a, b]]')```If you want to have more precise control, you can use `TupleExpr`, `ListExpr`, `SetExpr` and `DictExpr` for this.All have same constructor signature: `(values: Sequence[Expression])` (except `DictExpr`, which has `KeyValue` values)To create comprehensions:```pythonfrom gekkota import Name, GeneratorFor, GeneratorIffrom gekkota import (    ListComprehension,    DictComprehension,    KeyValue,    SetComprehension, # same usage as ListComprehension)a, b, c, d = map(Name, &quot;abcd&quot;)# ListComprehension(generator_or_expr: GeneratorBase | Expression, parts: Sequence[GeneratorPart] = ())print(    ListComprehension(        a,         [            # GeneratorFor(target: AssignmentTarget, iterator: Expression, *, is_async: bool = False)            GeneratorFor(b, c),                         # GeneratorIf(condition: Expression)            GeneratorIf(b.eq(d))        ]    )) # [a for b in c if b == d]# DictComprehension(generator_or_expr: GeneratorBase | KeyValue, parts: Sequence[GeneratorPart] = ())# GeneratorPart == GeneratorFor | GeneratorIfprint(    DictComprehension(KeyValue(a, b), [GeneratorFor(c, d), GeneratorIf(b.eq(d))])) # {a: b for c in d if b == d}```### Keyword call argsUse `CallArg` to provide keyword call args:```pythonfrom gekkota import Name, to_expressionprint_ = Name(&quot;print&quot;)# CallArg(name: str, value: Optional[Expression] = None)print(    print_(        Name(&quot;a&quot;),        CallArg(&quot;b&quot;),        CallArg(&quot;sep&quot;, to_expression(&quot;, &quot;))    )) # print(a, b, sep=', ')```### Type hintsTo annotate a name, just pass an additional parameter to `Name`:```pythonfrom gekkota import Namea = Name(&quot;a&quot;, Name(&quot;int&quot;))print(a) # a: int```Be aware that this usage is not restricted to valid places at the moment. For example:```pythonfrom gekkota import Namea = Name(&quot;a&quot;, Name(&quot;int&quot;))# doesn't produce any typecheck errorsprint(a + a) # a: int + a: intprint(Name(&quot;b&quot;, Name(&quot;a&quot;, Name(&quot;int&quot;)))) # b: a: int```This would probably be fixed in the future in some way.Annotations for other code (namely function args and return types) is described in relevant sections.## StatementsTo render program code (with multiple statements), use `Code`:```pythonfrom gekkota import Code, Assignment, Namea = Name(&quot;a&quot;)six = Literal(6)create_variable = Assignment(    [Name(&quot;a&quot;)],     six + six)print_variable = Name(&quot;print&quot;)(a)print(    Code([        create_variable,        print_variable,    ]))# prints:# a = 6 + 6# print(a)```To render a block of code, use `Block`:```pythonfrom gekkota import Block, IfStmt, Assignment, Namea = Name(&quot;a&quot;)b = Name(&quot;b&quot;)six = Literal(6)create_variable = Assignment(    [Name(&quot;a&quot;)],     six + six)print_variable = Name(&quot;print&quot;)(a)print(    IfStmt(        b,         Block([            create_variable,            print_variable,        ])    ))# prints:# if b:#     a = 6 + 6#     print(a)```If the difference between two is not obvious: `Code` just renders statements on separate lines, while block also adds a newline before the first statement and indentation to every line.Moreover, `Code([])` renders into `&quot;&quot;`, while `Block([])` â€” into `&quot;\n    pass&quot;`### Small statementsHere is an example of a few small statements:```pythonfrom gekkota import Name, SequenceExprfrom gekkota import (    ReturnStmt,     DelStmt,     AssertStmt,     BreakStmt,     ContinueStmt,     YieldStmt,     YieldFromStmt,     NonLocalStmt,     GlobalStmt,     PassStmt,     RaiseStmt,     AsyncStmt)a, b, c = map(Name, &quot;abc&quot;)print(ReturnStmt(a)) # 'return a'print(YieldStmt(a)) # 'yield a'print(YieldFromStmt(b)) # 'yield from b'print(DelStmt(a, b)) # 'del a, b'print(AssertStmt(a)) # 'assert a'print(BreakStmt()) # 'break'print(ContinueStmt()) # 'continue'print(GlobalStmt(a, b)) # 'global a, b'print(NonLocalStmt(a, b)) # 'nonlocal a, b'print(PassStmt()) # 'pass'print(RaiseStmt()) # 'raise' print(RaiseStmt(a)) # 'raise a'print(RaiseStmt(a, b)) # 'raise a from b'```### AssignmentFor common assigment use `Assignment`:```pythonfrom gekkota import Assignment, Namea, b, c = map(Name, &quot;abc&quot;)# Assignment(targets: Sequence[AssignmentTarget] | AnnotatedTarget, value: Expression)print(    Assignment([a], b), # a = b    Assignment([a.index(b)], c) # a[b] = c    Assignment([a, b], c), # a = b = c)```To annotate assignment (or just annotate a variable), use `AnnotatedTarget`:```pythonfrom gekkota import Assignment, AnnotatedTarget, Namea, b, c = map(Name, &quot;abc&quot;)D = Name(&quot;D&quot;)# AnnotatedTarget(target: AssignmentTarget, annotation: Expression)print(    Assignment(AnnotatedTarget(a, D), b), # a: D = b    Assignment(AnnotatedTarget(a.index(b), D), c) # a[b]: D = c    Assignment([a, b], c), # a = b = c)```For augmented assignment (e.g. `+=`) use `AugmentedAssignment`:```pythonfrom gekkota import Assignment, Namea, b, c = map(Name, &quot;abc&quot;)# AugmentedAssignment(target: AugAssignmentTarget, op: str, expression: Expression)print(    AugmentedAssignment(a, &quot;+=&quot;, b), # a += b    AugmentedAssignment(a.index(b), &quot;*=&quot;, c) # a *= c)```### Control flowFor control flow you can use `IfStmt`, `ElifStmt` and `ElseStmt`:```pythonfrom gekkota import Name, IfStmt, ElifStmt, ElseStmt, Codea, b, c = map(Name, &quot;abc&quot;)# IfStmt(condition: Expression, body: Statement)# ElifStmt(condition: Expression, body: Statement)# ElseStmt(body: Statement)code = Code([    IfStmt(a, b),    ElifStmt(b, a),    ElseStmt(c)])print(code)&quot;&quot;&quot;if a: belif b: aelse: c&quot;&quot;&quot;```### LoopsUse `ForStmt` and `WhileStmt` for loops:```pythonfrom gekkota import ForStmt, WhileStmt, Namea, b, c = map(Name, &quot;abc&quot;)# ForStmt(target: Expression, iterator: Expression, body: Statement, *, is_async: bool = False)print(    ForStmt(a, b, c)) # for a in b: c# WhileStmt(condition: Expression, body: Statement)print(    WhileStmt(a, b)) # while a: b```### FunctionsTo render a function definition, you will need a `FuncDef`:```pythonfrom gekkota import Name, FuncDefa, b, c = map(Name, &quot;abc&quot;)# FuncDef(name: str, args: Sequence[FuncArg], body: Statement, *, rtype: Optional[Expression] = None, is_async: bool = False)print(    FuncDef(        &quot;cool_func&quot;,        [a],        b,        rtype=c,    )) # def cool_func(a) -&gt; c: b```To provide a default value and/or annotations to arguments, use `FuncArg`:```pythonfrom gekkota import Name, FuncDef, FuncArg, to_expressiona, b, c = map(Name, &quot;abc&quot;)# FuncDef(name: str, args: Sequence[FuncArg], body: Statement, *, rtype: Optional[Expression] = None, is_async: bool = False)# FuncArg(name: str, annotation: Optional[Expression] = None, default_value: Optional[Expression] = None)print(    FuncDef(        &quot;cool_func&quot;,        [            FuncArg(                &quot;a&quot;,                 Name(&quot;int&quot;),                 to_expression(0)            )        ],        b,        rtype=c,    )) # def cool_func(a: int = 0) -&gt; c: b```Other argument types are:- `StarArg(value: T = None)`: generates `*value`, `*` by default- `DoubleStarArg(value)`: same as `StarArg`, but with `**`- `Slash()` is `/` (a mark of positional-only arguments in Python 3.8+)Lambda functions are generated using `LambDef`:```pythonfrom gekkota import Name, LambDefa, b, c = map(Name, &quot;abc&quot;)# LambDef(args: Sequence[FuncArg], body: Expression)print(    LambDef(        [a],        b,    )) # lambda a: b```To decorate a function/class, use `Decorated`:```pythonfrom gekkota import Name, FuncDef, Decorateddecorator = Name(&quot;decorator&quot;)a, b, c = map(Name, &quot;abc&quot;)# Decorated(decorator: Expression, statement: ClassDef | FuncDef)# FuncDef(name: str, args: Sequence[FuncArg], body: Statement, *, rtype: Optional[Expression] = None, is_async: bool = False)print(    Decorated(        decorator,        FuncDef(            &quot;cool_func&quot;,            [a],            b,            rtype=c,        )    ))# @decorator# def cool_func(a) -&gt; c: b```### ClassesTo define a class, use `ClassDef`:```pythonfrom gekkota import Name, ClassDefa, b, c = map(Name, &quot;abc&quot;)# ClassDef(name: str, args: Sequence[CallArg | Expression], body: Statement)print(    ClassDef(&quot;MyClass1&quot;, [], a)) # class MyClass1: aprint(    ClassDef(&quot;MyClass2&quot;, [b], c)) # class MyClass2(b): c```### ImportsTo render imports, use `ImportStmt` and `FromImportStmt`:```pythonfrom gekkota import Name, StarArg, ImportDots, ImportSource, ImportStmt, FromImportStmt, ImportAlias# ImportStmt(names: Sequence[ImportAlias | Name | StarArg[None]])print(    ImportStmt([Name(&quot;a&quot;)])) # import aprint(    ImportStmt([Name(&quot;a&quot;), Name(&quot;b&quot;)])) # import a, b# FromImportStmt(source: ImportSource | Name, names: Sequence[ImportAlias | Name | StarArg[None]])# ImportAlias(name: Name, alias: Name | None = None)print(    FromImportStmt(        Name(&quot;math&quot;),         [            Name(&quot;cos&quot;),             ImportAlias(Name(&quot;sin&quot;), Name(&quot;tan&quot;)) # we do a little trolling        ]    )) # from math import cos, sin as tanprint(    FromImportStmt(        Name(&quot;gekkota&quot;),        [StarArg()]    )) # from gekkota import *# ImportDots(length: int = 1)print(    FromImportStmt(        ImportDots(),        [StarArg()]    )) # from . import *# ImportSource(parts: Sequence[str])print(    FromImportStmt(        ImportSource([&quot;&quot;, &quot;values&quot;]),        [Name(&quot;Name&quot;)]    )) # from .values import Name```### Exceptions```pythonfrom gekkota import Name, TryStmt, ExceptStmt, FinallyStmt, Blocka, b, e = map(Name, &quot;abe&quot;)# TryStmt(body: Statement)print(    TryStmt(a)) # try: a# ExceptStmt(exceptions: Sequence[Expression] | None, alias: Name | None, body: Statement)print(    ExceptStmt(None, None, a)) # except: aprint(    ExceptStmt(None, None, Block([]))) # except:#     passprint(    ExceptStmt([a], None, b)) # except a: bprint(    ExceptStmt([a], e, b)) # except a as e: b# FinallyStmt(body: Statement)print(    FinallyStmt(a)) # finally: a```### Context Managers```pythonfrom gekkota import Name, WithStmt, WithTargeta, b, e = map(Name, &quot;abe&quot;)# WithStmt(targets: Sequence[WithTarget | Expression], body: Statement, *, is_async: bool = False,)print(    WithStmt([a], b)) # with a: b# WithTarget(expression: Expression, alias: str | None = None)print(    WithStmt([WithTarget(a, &quot;aaaa&quot;)], b)) # with a as aaaa: bprint(    WithStmt([a], b, is_async=True)) # async with a: b```### Pattern matchingThis section is currently unfinished, check [pattern_matching.py](https://github.com/courage-tci/gekkota/blob/pub/gekkota/pattern_matching.py)## Custom renderingIf your custom element can be meaningfully represented as a combination of existing elements, you can use a function instead of a class:```pythonfrom gekkota import Expressiondef Square(e: Expression) -&gt; Expression:    return e * e```This is a pretty obvious approach, but often it works best.---While being aimed at Python code generation, `gekkota` is pretty extensible, and can be used to render different things.    You can build custom renderables, statements, expressions, and so on.    The simplest example of a custom renderable would be:```pythonfrom gekkota import Renderable, StrGen, Configclass RenderString(Renderable):    &quot;&quot;&quot;It renders whatever is passed to it&quot;&quot;&quot;    def __init__(self, value: str):        self.value = value    def render(self, config: Config) -&gt; StrGen:        yield self.value```Let's suppose you want to render a custom expression: a custom sequence literal (obviously isn't valid in Python, but you need it for some reason).    Suppose your custom literal would be in form of `&lt;|value1, value2, ...|&gt;`.You can extend `SequenceExpr` for that:```pythonfrom gekkota import SequenceExpr, Nameclass MyCoolSequence(SequenceExpr):    parens = &quot;&lt;|&quot;, &quot;|&gt;&quot;seq = MyCoolSequence([Name(&quot;a&quot;), Name(&quot;b&quot;)])print(seq) # &lt;|a,b|&gt;```That's it, you're ready to render this literal (which, again, isn't valid in Python but anyway).Or you could go further and write rendering by yourself (it's easier than it sounds):```pythonfrom gekkota import Expression, Configclass MyCoolSequence(Expression):    def __init__(self, values: Sequence[Expression]):        self.values = values    # could be rewritten to be simpler, check `Useful utils` section below    def render(self, config: Config) -&gt; StrGen:        yield &quot;&lt;|&quot;        for i, item in enumerate(self.values):            yield from item.render(config)            if i + 1 &lt; len(self.values): # no comma after last element                yield &quot;,&quot;                yield &quot; &quot;        yield &quot;|&gt;&quot;```It's fairly easy, just render every part in the right order:- To render a string, use `yield string`- To render a `Renderable`, use `yield from renderable.render(config)`### Choosing a right base classTo choose a right base class, think in what context you want to use your renderable.    If there is a similar context in Python (e.g. your renderable is a block statement, like `for` or `if`), extend that class.    After choosing a right base class, check if it has a predefined render, maybe you won't need to write everything by yourself.    For example, with `BlockStmt` you need to provide `render_head` instead:```python# that's the actual source from module, not an exampleclass BlockStmt(Statement):    body: Statement    def render_head(self, config: Config) -&gt; StrGen:        return NotImplemented    def render(self, config: Config) -&gt; StrGen:        yield from self.render_head(config)        yield &quot;:&quot;        yield &quot; &quot;        yield from self.body.render(config)[...]class ElseStmt(BlockStmt):    def __init__(self, body: Statement):        self.body = body    def render_head(self, config: config) -&gt; StrGen:        yield &quot;else&quot;```### Useful utils`gekkota.utils` provides `Utils` class which is useful for custom renderables. For example, custom `MyCoolSequence` could be implemented as:```pythonfrom gekkota import Expression, Utilsclass MyCoolSequence(Expression):    def __init__(self, values: Sequence[Expression]):        self.values = values    def render(self, config: config) -&gt; StrGen:        yield from Utils.wrap(            [&quot;&lt;|&quot;, &quot;|&gt;&quot;],            Utils.comma_separated(self.values, config)        )```Methods provided in `Utils`:- `add_tab(generator: StrGen, config: Config) -&gt; StrGen`        Adds indentation to a stream of tokens, using provided `config`        For example, `Utils.add_tab(Name(&quot;a&quot;).render(config), config)` -&gt; Iterable of ['    ', 'a']- `separated(separator: Sequence[str], renderables: Sequence[Renderable], config: Config) -&gt; StrGen`        Inserts separator between renderables (and renders them in stream)        For example: `Utils.separated([&quot;,&quot;, &quot; &quot;], self.values, config)` - inserts &quot;, &quot; between elements of `self.values`    - `separated_str(separator: Sequence[str], strings: Sequence[str], config: Config)`        Same as previous, but for `str` sequences- `comma_separated(renderables: Sequence[Renderable], config: Config) -&gt; StrGen`        Alias for `Utils.separated([&quot;,&quot;, &quot; &quot;], renderables, config)`- `make_compact(generator: StrGen, config: Config) -&gt; StrGen`        Filters all unneccessary whitespace from stream (doesn't respect `config[&quot;compact&quot;]`). Config is unused at the moment, but provided for compatibility with future updates- `wrap(parens: Sequence[str], generator: StrGen) -&gt; StrGen`        Wraps a token stream with strings from `parens` array (should have 2 elements).        In other words, inserts `parens[0]` at the start of the stream, and `parens[1]` at the end</longdescription>
</pkgmetadata>