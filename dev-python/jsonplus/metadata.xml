<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>JSON+=====.. image:: https://img.shields.io/pypi/v/jsonplus.svg    :target: https://pypi.python.org/pypi/jsonplus.. image:: https://img.shields.io/pypi/l/jsonplus.svg    :target: https://pypi.python.org/pypi/jsonplus.. image:: https://img.shields.io/pypi/wheel/jsonplus.svg    :target: https://pypi.python.org/pypi/jsonplus.. image:: https://img.shields.io/pypi/pyversions/jsonplus.svg    :target: https://pypi.python.org/pypi/jsonplus.. image:: https://api.travis-ci.org/randomir/jsonplus.svg?branch=master    :target: https://travis-ci.org/randomir/jsonplusSerialization of Python types to JSON that &quot;just works&quot;.Forget errors like::    TypeError: datetime.datetime(...) is not JSON serializableIn addition to (de-)serialization of basic types (provided by simplejson_), jsonplus_provides support for **exact** (de-)serialization of other commonly used types, like:``tuple``/``namedtuple``, ``set``/``frozenset``, ``complex``/``decimal.Decimal``/``fractions.Fraction``,and ``datetime``/``date``/``time``/``timedelta``.If the exact representation of types is not your cup of tea, and all you wishfor is the ``json.dumps`` to work on your data structure with non-basic types,accepting the loss of &quot;type-precision&quot; along the way, than you can use the**compatibility** mode (thread-local ``jsonplus.prefer_compat()``, orper-call override ``jsonplus.dumps(..., exact=False)``)... _simplejson: https://simplejson.readthedocs.io/en/latest/#encoders-and-decoders.. _jsonplus: https://pypi.python.org/pypi/jsonplus/Installation------------``jsonplus`` is available as a Python package. To install it, simply type::    $ pip install jsonplusUsage-----You can treat ``jsonplus`` as a friendly *drop-in* replacement for ``json``/``simplejson``... code-block:: python    &gt;&gt;&gt; import jsonplus as json    &gt;&gt;&gt; x = json.loads('{&quot;a&quot;:1,&quot;b&quot;:2}')    &gt;&gt;&gt; y = json.dumps(x, indent=4)    &gt;&gt;&gt; z = json.pretty(x)Examples--------Let's start with that beloved ``datetime``... code-block:: python    &gt;&gt;&gt; import jsonplus as json    &gt;&gt;&gt; from datetime import datetime    &gt;&gt;&gt; json.dumps({    ...     &quot;x&quot;: [4,3],    ...     &quot;t&quot;: datetime.now()    ... })    '{&quot;x&quot;:[4,3],&quot;t&quot;:{&quot;__class__&quot;:&quot;datetime&quot;,&quot;__value__&quot;:&quot;2013-09-06T23:38:55.819791&quot;}}'        &gt;&gt;&gt; json.loads(_)    {u'x': [4, 3], u't': datetime.datetime(2013, 9, 6, 23, 38, 55, 819791)}Similarly for other ``datetime.*`` types, like ``timedelta``, ``date``, and ``time``:.. code-block:: python    &gt;&gt;&gt; from datetime import timedelta, date, time    &gt;&gt;&gt; print(json.pretty({&quot;dt&quot;: timedelta(0, 1234567, 123), &quot;d&quot;: date.today(), &quot;t&quot;: datetime.now().time()}))    {        &quot;d&quot;: {            &quot;__class__&quot;: &quot;date&quot;,            &quot;__value__&quot;: &quot;2013-09-22&quot;        },        &quot;dt&quot;: {            &quot;__class__&quot;: &quot;timedelta&quot;,            &quot;__value__&quot;: {                &quot;days&quot;: 14,                &quot;microseconds&quot;: 123,                &quot;seconds&quot;: 24967            }        },        &quot;t&quot;: {            &quot;__class__&quot;: &quot;time&quot;,            &quot;__value__&quot;: &quot;23:33:16.335360&quot;        }    }Also, ``set`` and ``complex``:.. code-block:: python    &gt;&gt;&gt; json.dumps([set(range(3)), 1+2j])    '[{&quot;__class__&quot;:&quot;set&quot;,&quot;__value__&quot;:[0,1,2]},{&quot;__class__&quot;:&quot;complex&quot;,&quot;__value__&quot;:{&quot;real&quot;:1.0,&quot;imag&quot;:2.0}}]'        &gt;&gt;&gt; json.loads(_)    [set([0, 1, 2]), (1+2j)]``tuple`` and ``namedtuple`` are also preserved:.. code-block:: python    &gt;&gt;&gt; from collections import namedtuple    &gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])    &gt;&gt;&gt; data = json.pretty({&quot;vect&quot;: (1, 2, 3), &quot;dot&quot;: Point(3, 4)})    &gt;&gt;&gt; print(data)    {        &quot;dot&quot;: {            &quot;__class__&quot;: &quot;namedtuple&quot;,            &quot;__value__&quot;: {                &quot;fields&quot;: [                    &quot;x&quot;,                    &quot;y&quot;                ],                &quot;name&quot;: &quot;Point&quot;,                &quot;values&quot;: [                    3,                    4                ]            }        },        &quot;vect&quot;: {            &quot;__class__&quot;: &quot;tuple&quot;,            &quot;__value__&quot;: [                1,                2,                3            ]        }    }    &gt;&gt;&gt; json.loads(data)    {'vect': (1, 2, 3), 'dot': Point(x=3, y=4)}Compatibility mode------------------All types supported in the exact mode are also supported in the compatibilitymode. JSON representation differs, however.In the exact mode, *type* and *value* are encoded with ``JSON Object``'s``__class__`` and ``__value__`` keys, while in the compatibility mode, **values are &quot;rounded off&quot; to the closest JSON type**.For example, ``tuple`` and ``set`` are represented with ``JSON Array``, and``namedtuple`` is coded as a plain ``JSON Object``. ``Decimal`` isrepresented as ``JSON Number`` with arbitrary precision (which is lost ifdecoded as ``float``).To switch between the **exact** and **compatibility** modes, use the (thread-local) functions ``prefer_exact()`` and ``prefer_compat()``, or call``dumps(..., exact=False)``:.. code-block:: python    &gt;&gt;&gt; import jsonplus as json    &gt;&gt;&gt; json.prefer_compat()    # or:    &gt;&gt;&gt; json.prefer(json.COMPAT)    # per-instance override:    &gt;&gt;&gt; json.dumps(obj, exact=False)    # to go back to (default) exact coding:    &gt;&gt;&gt; json.prefer_exact()The above ``tuple``/``namedtuple``/``datetime`` examples run in the compatibility coding mode result with:.. code-block:: python    &gt;&gt;&gt; json.prefer_compat()    &gt;&gt;&gt; print(json.pretty({&quot;vect&quot;: (1, 2, 3), &quot;dot&quot;: Point(3, 4)}))    {        &quot;point&quot;: {            &quot;x&quot;: 3,            &quot;y&quot;: 4        },        &quot;vector&quot;: [            1,            2,            3        ]    }    &gt;&gt;&gt; json.dumps({&quot;now&quot;: datetime.now()})    '{&quot;now&quot;:&quot;2017-01-26T00:37:40.293963&quot;}'So, to be able to properly decode values in the compatibility mode, some additional context will have to be provided to the decoder.Adding user types-----------------Support for user/custom types can easily be added with `@jsonplus.encoder` and`@jsonplus.decoder` decorators.For example, to enable serialization of your type named ``mytype`` in exact mode(to add compat-mode serialization, append ``exact=False`` in decorator):.. code-block:: python    @jsonplus.encoder('mytype')    def mytype_exact_encoder(myobj):        return myobj.to_json().. code-block:: python    @jsonplus.decoder('mytype')    def mytype_decoder(value):        return mytype(value, reconstruct=True, ...)If detection of object class is more complex than a simple classname comparison,if you need to use a predicate function, simply add ``predicate=...`` to the ``encoder``decorator. For example:.. code-block:: python    @jsonplus.encoder('BaseClass', lambda obj: isinstance(obj, BaseClass))    def all_derived_classes_encoder(derived):        return derived.base_encoder()</longdescription>
</pkgmetadata>