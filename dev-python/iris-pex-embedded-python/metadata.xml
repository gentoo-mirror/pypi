<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># 1. interoperability-embedded-pythonThis proof of concept aims to show how the **iris interoperability framework** can be use with **embedded python**.## 1.1. Table of Contents- [1. interoperability-embedded-python](#1-interoperability-embedded-python)  - [1.1. Table of Contents](#11-table-of-contents)  - [1.2. Example](#12-example)  - [1.3. Register a component](#13-register-a-component)- [2. Demo](#2-demo)- [3. Prerequisites](#3-prerequisites)- [4. Installation](#4-installation)  - [4.1. With Docker](#41-with-docker)  - [4.2. Without Docker](#42-without-docker)  - [4.3. With ZPM](#43-with-zpm)  - [4.4. With PyPI](#44-with-pypi)    - [4.4.1. Known issues](#441-known-issues)- [5. How to Run the Sample](#5-how-to-run-the-sample)  - [5.1. Docker containers](#51-docker-containers)  - [5.2. Management Portal and VSCode](#52-management-portal-and-vscode)  - [5.3. Open the production](#53-open-the-production)- [6. What's inside the repository](#6-whats-inside-the-repository)  - [6.1. Dockerfile](#61-dockerfile)  - [6.2. .vscode/settings.json](#62-vscodesettingsjson)  - [6.3. .vscode/launch.json](#63-vscodelaunchjson)  - [6.4. .vscode/extensions.json](#64-vscodeextensionsjson)  - [6.5. src folder](#65-src-folder)- [7. How it works](#7-how-it-works)  - [7.1. The `__init__.py`file](#71-the-__init__pyfile)  - [7.2. The `common` class](#72-the-common-class)  - [7.3. The `business_host` class](#73-the-business_host-class)  - [7.4. The `inbound_adapter` class](#74-the-inbound_adapter-class)  - [7.5. The `outbound_adapter` class](#75-the-outbound_adapter-class)  - [7.6. The `business_service` class](#76-the-business_service-class)  - [7.7. The `business_process` class](#77-the-business_process-class)  - [7.8. The `business_operation` class](#78-the-business_operation-class)    - [7.8.1. The dispacth system](#781-the-dispacth-system)    - [7.8.2. The methods](#782-the-methods)  - [7.9. The `director` class](#79-the-director-class)  - [7.10. The `objects`](#710-the-objects)  - [7.11. The `messages`](#711-the-messages)  - [7.12. How to regsiter a component](#712-how-to-regsiter-a-component)    - [7.12.1. register\_component](#7121-register_component)    - [7.12.2. register\_file](#7122-register_file)    - [7.12.3. register\_folder](#7123-register_folder)    - [7.12.4. migrate](#7124-migrate)      - [7.12.4.1. setting.py file](#71241-settingpy-file)        - [7.12.4.1.1. CLASSES section](#712411-classes-section)        - [7.12.4.1.2. Productions section](#712412-productions-section)  - [7.13. Direct use of Grongier.PEX](#713-direct-use-of-grongierpex)- [8. Command line](#8-command-line)  - [8.1. help](#81-help)  - [8.2. default](#82-default)  - [8.3. lists](#83-lists)  - [8.4. start](#84-start)  - [8.5. kill](#85-kill)  - [8.6. stop](#86-stop)  - [8.7. restart](#87-restart)  - [8.8. migrate](#88-migrate)  - [8.9. export](#89-export)  - [8.10. status](#810-status)  - [8.11. version](#811-version)  - [8.12. log](#812-log)- [9. Credits](#9-credits)## 1.2. Example```pythonfrom grongier.pex import BusinessOperation,Messageclass MyBusinessOperation(BusinessOperation):        def on_init(self):        #This method is called when the component is becoming active in the production        self.log_info(&quot;[Python] ...MyBusinessOperation:on_init() is called&quot;)        return    def on_teardown(self):        #This method is called when the component is becoming inactive in the production        self.log_info(&quot;[Python] ...MyBusinessOperation:on_teardown() is called&quot;)        return    def on_message(self, message_input:MyRequest):        # called from service/process/operation, message is of type MyRequest with property request_string        self.log_info(&quot;[Python] ...MyBusinessOperation:on_message() is called with message:&quot;+message_input.request_string)        response = MyResponse(&quot;...MyBusinessOperation:on_message() echos&quot;)        return response@dataclassclass MyRequest(Message):    request_string:str = None@dataclassclass MyResponse(Message):    my_string:str = None```## 1.3. Register a component Thanks to the method grongier.pex.Utils.register_component() : Start an embedded python shell :```sh/usr/irissys/bin/irispython```Then use this class method to add a python class to the component list for interoperability.```pythonfrom grongier.pex import UtilsUtils.register_component(&lt;ModuleName&gt;,&lt;ClassName&gt;,&lt;PathToPyFile&gt;,&lt;OverWrite&gt;,&lt;NameOfTheComponent&gt;)```e.g :```pythonfrom grongier.pex import UtilsUtils.register_component(&quot;MyCombinedBusinessOperation&quot;,&quot;MyCombinedBusinessOperation&quot;,&quot;/irisdev/app/src/python/demo/&quot;,1,&quot;PEX.MyCombinedBusinessOperation&quot;)```This is a hack, this not for production.# 2. DemoThe demo can be found inside `src/python/demo/reddit/` and is composed of :- An `adapter.py` file that holds a `RedditInboundAdapter` that will, given a service, fetch Reddit recent posts.&lt;br&gt;- A `bs.py` file that holds three `services` that does the same thing, they will call our `Process` and send it reddit post. One work on his own, one use the `RedditInBoundAdapter` we talked about earlier and the last one use a reddit inbound adapter coded in ObjectScript.&lt;br&gt;- A `bp.py` file that holds a `FilterPostRoutingRule` process that will analyze our reddit posts and send it to our `operations` if it contains certain words.&lt;br&gt;- A `bo.py` file that holds :    - Two **email operations** that will send a mail to a certain company depending on the words analyzed before, one works on his own and the other one works with an OutBoundAdapter.    - Two **file operations** that will write in a text file depending on the words analyzed before, one works on his own and the other one works with an OutBoundAdapter.&lt;br&gt;New json trace for python native messages :&lt;img width=&quot;910&quot; alt=&quot;json-message-trace&quot; src=&quot;https://user-images.githubusercontent.com/47849411/131305211-b8beb2c0-438d-4afc-a6d2-f94d854373ae.png&quot;&gt;# 3. PrerequisitesMake sure you have [git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) and [Docker desktop](https://www.docker.com/products/docker-desktop) installed.# 4. Installation ## 4.1. With DockerClone/git pull the repo into any local directory```shgit clone https://github.com/grongierisc/interpeorability-embedded-python```Open the terminal in this directory and run:```shdocker-compose build```Run the IRIS container with your project:```shdocker-compose up -d```## 4.2. Without DockerInstall the *grongier_pex-1.2.4-py3-none-any.whl* on you local iris instance :```sh/usr/irissys/bin/irispython -m pip install grongier_pex-1.2.4-py3-none-any.whl```Then load the ObjectScript classes :```ObjectScriptdo $System.OBJ.LoadDir(&quot;/opt/irisapp/src&quot;,&quot;cubk&quot;,&quot;*.cls&quot;,1)```## 4.3. With ZPM ```objectscriptzpm &quot;install pex-embbeded-python&quot; ```## 4.4. With PyPI```shpip3 install iris_pex_embedded_python```Import the ObjectScript classes, open an embedded python shell and run :```pythonfrom grongier.pex import UtilsUtils.setup()```### 4.4.1. Known issuesIf the module is not updated, make sure to remove the old version :```shpip3 uninstall iris_pex_embedded_python```or manually remove the `grongier` folder in `&lt;iris_installation&gt;/lib/python/`or force the installation with pip :```shpip3 install --upgrade iris_pex_embedded_python --target &lt;iris_installation&gt;/lib/python/```# 5. How to Run the Sample## 5.1. Docker containersIn order to have access to the InterSystems images, we need to go to the following url: http://container.intersystems.com. After connecting with our InterSystems credentials, we will get our password to connect to the registry. In the docker VScode addon, in the image tab, by pressing connect registry and entering the same url as before (http://container.intersystems.com) as a generic registry, we will be asked to give our credentials. The login is the usual one but the password is the one we got from the website.From there, we should be able to build and compose our containers (with the `docker-compose.yml` and `Dockerfile` files given).## 5.2. Management Portal and VSCodeThis repository is ready for [VS Code](https://code.visualstudio.com/).Open the locally-cloned `interoperability-embedeed-python` folder in VS Code.If prompted (bottom right corner), install the recommended extensions.**IMPORTANT**: When prompted, reopen the folder inside the container so you will be able to use the python components within it. The first time you do this it may take several minutes while the container is readied.By opening the folder remote you enable VS Code and any terminals you open within it to use the python components within the container. Configure these to use `/usr/irissys/bin/irispython`&lt;img width=&quot;1614&quot; alt=&quot;PythonInterpreter&quot; src=&quot;https://user-images.githubusercontent.com/47849411/145864423-2de24aaa-036c-4beb-bda0-3a73fe15ccbd.png&quot;&gt;## 5.3. Open the productionTo open the production you can go to [production](http://localhost:52773/csp/irisapp/EnsPortal.ProductionConfig.zen?PRODUCTION=PEX.Production).&lt;br&gt;You can also click on the bottom on the `127.0.0.1:52773[IRISAPP]` button and select `Open Management Portal` then, click on [Interoperability] and [Configure] menus then click [productions] and [Go].The production already has some code sample.Here we can see the production and our pure python services and operations:&lt;img width=&quot;1177&quot; alt=&quot;interop-screenshot&quot; src=&quot;https://user-images.githubusercontent.com/47849411/131305197-d19511fd-6e05-4aec-a525-c88e6ebd0971.png&quot;&gt;&lt;br&gt;New json trace for python native messages :&lt;img width=&quot;910&quot; alt=&quot;json-message-trace&quot; src=&quot;https://user-images.githubusercontent.com/47849411/131305211-b8beb2c0-438d-4afc-a6d2-f94d854373ae.png&quot;&gt;# 6. What's inside the repository## 6.1. DockerfileA dockerfile which install some python dependancies (pip, venv) and sudo in the container for conviencies.Then it create the dev directory and copy in it this git repository.It starts IRIS and activates **%Service_CallIn** for **Python Shell**.Use the related docker-compose.yml to easily setup additional parametes like port number and where you map keys and host folders.This dockerfile ends with the installation of requirements for python modules.Use .env/ file to adjust the dockerfile being used in docker-compose.## 6.2. .vscode/settings.jsonSettings file to let you immedietly code in VSCode with [VSCode ObjectScript plugin](https://marketplace.visualstudio.com/items?itemName=daimor.vscode-objectscript)## 6.3. .vscode/launch.jsonConfig file if you want to debug with VSCode ObjectScript[Read about all the files in this article](https://community.intersystems.com/post/dockerfile-and-friends-or-how-run-and-collaborate-objectscript-projects-intersystems-iris)## 6.4. .vscode/extensions.jsonRecommendation file to add extensions if you want to run with VSCode in the container.[More information here](https://code.visualstudio.com/docs/remote/containers)![Archiecture](https://code.visualstudio.com/assets/docs/remote/containers/architecture-containers.png)This is very useful to work with embedded python.## 6.5. src folder```src├── Grongier│   └── PEX // ObjectScript classes that wrap python code│       ├── BusinessOperation.cls│       ├── BusinessProcess.cls│       ├── BusinessService.cls│       ├── Common.cls│       ├── Director.cls│       ├── InboundAdapter.cls│       ├── Message.cls│       ├── OutboundAdapter.cls│       ├── Python.cls│       ├── Test.cls│       └── _utils.cls├── PEX // Some example of wrapped classes│   └── Production.cls└── python    ├── demo // Actual python code to run this demo    |   `-- reddit    |       |-- adapter.py    |       |-- bo.py    |       |-- bp.py    |       |-- bs.py    |       |-- message.py    |       `-- obj.py    ├── dist // Wheel used to implement python interoperability components    │   └── grongier_pex-1.2.4-py3-none-any.whl    ├── grongier    │   └── pex // Helper classes to implement interoperability components    │       ├── _business_host.py    │       ├── _business_operation.py    │       ├── _business_process.py    │       ├── _business_service.py    │       ├── _common.py    │       ├── _director.py    │       ├── _inbound_adapter.py    │       ├── _message.py    │       ├── _outbound_adapter.py    │       ├── __init__.py    │       └── _utils.py    └── setup.py // setup to build the wheel```# 7. How it works## 7.1. The `__init__.py`fileThis file will allow us to create the classes to import in the code.&lt;br&gt;It gets from the multiple files seen earlier the classes and make them into callable classes.That way, when you wish to create a business operation, for example, you can just do:```pythonfrom grongier.pex import BusinessOperation```## 7.2. The `common` classThe common class shouldn't be called by the user, it defines almost all the other classes.&lt;br&gt;This class defines:`on_init`: The on_init() method is called when the component is started.&lt;br&gt; Use the on_init() method to initialize any structures needed by the component.`on_tear_down`: Called before the component is terminated.&lt;br&gt; Use it to free any structures.`on_connected`: The on_connected() method is called when the component is connected or reconnected after being disconnected.&lt;br&gt;Use the on_connected() method to initialize any structures needed by the component.`log_info`: Write a log entry of type &quot;info&quot;. :log entries can be viewed in the management portal.`log_alert`: Write a log entry of type &quot;alert&quot;. :log entries can be viewed in the management portal.`log_warning`: Write a log entry of type &quot;warning&quot;. :log entries can be viewed in the management portal.`log_error`: Write a log entry of type &quot;error&quot;. :log entries can be viewed in the management portal.## 7.3. The `business_host` classThe business host class shouldn't be called by the user, it is the base class for all the business classes.&lt;br&gt;This class defines:`send_request_sync`: Send the specified message to the target business process or business operation synchronously.            **Parameters**:&lt;br&gt;- **target**: a string that specifies the name of the business process or operation to receive the request. &lt;br&gt;    The target is the name of the component as specified in the Item Name property in the production definition, not the class name of the component.- **request**: specifies the message to send to the target. The request is either an instance of a class that is a subclass of Message class or of IRISObject class.&lt;br&gt;    If the target is a build-in ObjectScript component, you should use the IRISObject class. The IRISObject class enables the PEX framework to convert the message to a class supported by the target.- **timeout**: an optional integer that specifies the number of seconds to wait before treating the send request as a failure. The default value is -1, which means wait forever.&lt;br&gt;description: an optional string parameter that sets a description property in the message header. The default is None.**Returns**:    the response object from target.**Raises**:TypeError: if request is not of type Message or IRISObject.&lt;br&gt;&lt;br&gt;`send_request_async`: Send the specified message to the target business process or business operation asynchronously.**Parameters**:&lt;br&gt;- **target**: a string that specifies the name of the business process or operation to receive the request. &lt;br&gt;    The target is the name of the component as specified in the Item Name property in the production definition, not the class name of the component.- **request**: specifies the message to send to the target. The request is an instance of IRISObject or of a subclass of Message.&lt;br&gt;    If the target is a built-in ObjectScript component, you should use the IRISObject class. The IRISObject class enables the PEX framework to convert the message to a class supported by the target.- **description**: an optional string parameter that sets a description property in the message header. The default is None.**Raises**:TypeError: if request is not of type Message or IRISObject.&lt;br&gt;&lt;br&gt;`get_adapter_type`: Name of the registred Adapter.## 7.4. The `inbound_adapter` classInbound Adapter in Python are subclass from grongier.pex.InboundAdapter in Python, that inherit from all the functions of the [common class](#72-the-common-class).&lt;br&gt;This class is responsible for receiving the data from the external system, validating the data, and sending it to the business service by calling the BusinessHost process_input method.This class defines:`on_task`: Called by the production framework at intervals determined by the business service CallInterval property.&lt;br&gt;The message can have any structure agreed upon by the inbound adapter and the business service.Example of an inbound adapter ( situated in the src/python/demo/reddit/adapter.py file ):```pythonfrom grongier.pex import InboundAdapterimport requestsimport irisimport jsonclass RedditInboundAdapter(InboundAdapter):    &quot;&quot;&quot;    This adapter use requests to fetch self.limit posts as data from the reddit    API before calling process_input for each post.    &quot;&quot;&quot;    def on_init(self):                if not hasattr(self,'feed'):            self.feed = &quot;/new/&quot;                if self.limit is None:            raise TypeError('no Limit field')                self.last_post_name = &quot;&quot;                return 1    def on_task(self):        self.log_info(f&quot;LIMIT:{self.limit}&quot;)        if self.feed == &quot;&quot; :            return 1                tSC = 1        # HTTP Request        try:            server = &quot;https://www.reddit.com&quot;            request_string = self.feed+&quot;.json?before=&quot;+self.last_post_name+&quot;&amp;limit=&quot;+self.limit            self.log_info(server+request_string)            response = requests.get(server+request_string)            response.raise_for_status()            data = response.json()            updateLast = 0            for key, value in enumerate(data['data']['children']):                if value['data']['selftext']==&quot;&quot;:                    continue                post = iris.cls('dc.Reddit.Post')._New()                post._JSONImport(json.dumps(value['data']))                post.OriginalJSON = json.dumps(value)                if not updateLast:                    self.LastPostName = value['data']['name']                    updateLast = 1                response = self.BusinessHost.ProcessInput(post)        except requests.exceptions.HTTPError as err:            if err.response.status_code == 429:                self.log_warning(err.__str__())            else:                raise err        except Exception as err:             self.log_error(err.__str__())            raise err        return tSC```## 7.5. The `outbound_adapter` classOutbound Adapter in Python are subclass from grongier.pex.OutboundAdapter in Python, that inherit from all the functions of the [common class](#72-the-common-class).&lt;br&gt;This class is responsible for sending the data to the external system.The Outbound Adapter gives the Operation the possibility to have a heartbeat notion.To activate this option, the CallInterval parameter of the adapter must be strictly greater than 0.&lt;img width=&quot;301&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/47849411/178230243-39806602-a63d-4a89-9563-fcf6836d0515.png&quot;&gt;Example of an outbound adapter ( situated in the src/python/demo/reddit/adapter.py file ):```pythonclass TestHeartBeat(OutboundAdapter):    def on_keepalive(self):        self.log_info('beep')    def on_task(self):        self.log_info('on_task')```## 7.6. The `business_service` classThis class is responsible for receiving the data from external system and sending it to business processes or business operations in the production.&lt;br&gt;The business service can use an adapter to access the external system, which is specified overriding the get_adapter_type method.&lt;br&gt;There are three ways of implementing a business service:&lt;br&gt;- Polling business service with an adapter - The production framework at regular intervals calls the adapter’s OnTask() method,     which sends the incoming data to the the business service ProcessInput() method, which, in turn calls the OnProcessInput method with your code.- Polling business service that uses the default adapter - In this case, the framework calls the default adapter's OnTask method with no data.     The OnProcessInput() method then performs the role of the adapter and is responsible for accessing the external system and receiving the data.- Nonpolling business service - The production framework does not initiate the business service. Instead custom code in either a long-running process     or one that is started at regular intervals initiates the business service by calling the Director.CreateBusinessService() method.Business service in Python are subclass from grongier.pex.BusinessService in Python, that inherit from all the functions of the [business host](#73-the-business_host-class).&lt;br&gt;This class defines:`on_process_input`: Receives the message from the inbond adapter via the PRocessInput method and is responsible for forwarding it to target business processes or operations.&lt;br&gt;If the business service does not specify an adapter, then the default adapter calls this method with no message and the business service is responsible for receiving the data from the external system and validating it.**Parameters**:&lt;br&gt;- **message_input**: an instance of IRISObject or subclass of Message containing the data that the inbound adapter passes in.&lt;br&gt;The message can have any structure agreed upon by the inbound adapter and the business service. &lt;br&gt;&lt;br&gt;Example of a business service ( situated in the src/python/demo/reddit/bs.py file ):```pythonfrom grongier.pex import BusinessServiceimport irisfrom message import PostMessagefrom obj import PostClassclass RedditServiceWithPexAdapter(BusinessService):    &quot;&quot;&quot;    This service use our python Python.RedditInboundAdapter to receive post    from reddit and call the FilterPostRoutingRule process.    &quot;&quot;&quot;    def get_adapter_type():        &quot;&quot;&quot;        Name of the registred Adapter        &quot;&quot;&quot;        return &quot;Python.RedditInboundAdapter&quot;    def on_process_input(self, message_input):        msg = iris.cls(&quot;dc.Demo.PostMessage&quot;)._New()        msg.Post = message_input        return self.send_request_sync(self.target,msg)    def on_init(self):                if not hasattr(self,'target'):            self.target = &quot;Python.FilterPostRoutingRule&quot;                return```## 7.7. The `business_process` classTypically contains most of the logic in a production.&lt;br&gt;A business process can receive messages from a business service, another business process, or a business operation.&lt;br&gt;It can modify the message, convert it to a different format, or route it based on the message contents.&lt;br&gt;The business process can route a message to a business operation or another business process.&lt;br&gt;Business processes in Python are subclass from grongier.pex.BusinessProcess in Python, that inherit from all the functions of the [business host](#73-the-business_host-class).&lt;br&gt;This class defines:`on_request`: Handles requests sent to the business process. A production calls this method whenever an initial request for a specific business process arrives on the appropriate queue and is assigned a job in which to execute.&lt;br&gt;**Parameters**:&lt;br&gt;- **request**: An instance of IRISObject or subclass of Message that contains the request message sent to the business process.**Returns**:An instance of IRISObject or subclass of Message that contains the response message that this business process can returnto the production component that sent the initial message.&lt;br&gt;&lt;br&gt;`on_response`: Handles responses sent to the business process in response to messages that it sent to the target.&lt;br&gt;A production calls this method whenever a response for a specific business process arrives on the appropriate queue and is assigned a job in which to execute.&lt;br&gt;Typically this is a response to an asynchronous request made by the business process where the responseRequired parameter has a true value.&lt;br&gt;**Parameters**:&lt;br&gt;- **request**: An instance of IRISObject or subclass of Message that contains the initial request message sent to the business process.- **response**: An instance of IRISObject or subclass of Message that contains the response message that this business process can return to the production component that sent the initial message.- **callRequest**: An instance of IRISObject or subclass of Message that contains the request that the business process sent to its target.- **callResponse**: An instance of IRISObject or subclass of Message that contains the incoming response.- **completionKey**: A string that contains the completionKey specified in the completionKey parameter of the outgoing SendAsync() method.**Returns**:An instance of IRISObject or subclass of Message that contains the response message that this business process can returnto the production component that sent the initial message.&lt;br&gt;&lt;br&gt;`on_complete`: Called after the business process has received and handled all responses to requests it has sent to targets.&lt;br&gt;**Parameters**: - **request**: An instance of IRISObject or subclass of Message that contains the initial request message sent to the business process.&lt;br&gt;- **response**: An instance of IRISObject or subclass of Message that contains the response message that this business process can return to the production component that sent the initial message.**Returns**:An instance of IRISObject or subclass of Message that contains the response message that this business process can return to the production component that sent the initial message.&lt;br&gt;&lt;br&gt;Example of a business process ( situated in the src/python/demo/reddit/bp.py file ):```pythonfrom grongier.pex import BusinessProcessfrom message import PostMessagefrom obj import PostClassclass FilterPostRoutingRule(BusinessProcess):    &quot;&quot;&quot;    This process receive a PostMessage containing a reddit post.    It then understand if the post is about a dog or a cat or nothing and    fill the right infomation inside the PostMessage before sending it to    the FileOperation operation.    &quot;&quot;&quot;    def on_init(self):                if not hasattr(self,'target'):            self.target = &quot;Python.FileOperation&quot;                return    def on_request(self, request):        if 'dog'.upper() in request.post.selftext.upper():            request.to_email_address = 'dog@company.com'            request.found = 'Dog'        if 'cat'.upper() in request.post.selftext.upper():            request.to_email_address = 'cat@company.com'            request.found = 'Cat'        if request.found is not None:            return self.send_request_sync(self.target,request)        else:            return```## 7.8. The `business_operation` classThis class is responsible for sending the data to an external system or a local system such as an iris database.&lt;br&gt;The business operation can optionally use an adapter to handle the outgoing message which is specified overriding the get_adapter_type method.&lt;br&gt;If the business operation has an adapter, it uses the adapter to send the message to the external system.&lt;br&gt;The adapter can either be a PEX adapter, an ObjectScript adapter or a [python adapter](#75-the-outbound_adapter-class).&lt;br&gt;Business operation in Python are subclass from grongier.pex.BusinessOperation in Python, that inherit from all the functions of the [business host](#73-the-business_host-class).&lt;br&gt;### 7.8.1. The dispacth systemIn a business operation it is possbile to create any number of function [similar to the on_message method](#782-the-methods) that will take as argument a [typed request](#711-the-messages) like this `my_special_message_method(self,request: MySpecialMessage)`.The dispatch system will automatically analyze any request arriving to the operation and dispacth the requests depending of their type. If the type of the request is not recognized or is not specified in any **on_message like function**, the dispatch system will send it to the `on_message` function.### 7.8.2. The methodsThis class defines:`on_message`: Called when the business operation receives a message from another production component [that can not be dispatched to another function](#781-the-dispacth-system).&lt;br&gt;Typically, the operation will either send the message to the external system or forward it to a business process or another business operation.If the operation has an adapter, it uses the Adapter.invoke() method to call the method on the adapter that sends the message to the external system.If the operation is forwarding the message to another production component, it uses the SendRequestAsync() or the SendRequestSync() method.&lt;br&gt;**Parameters**:- **request**: An instance of either a subclass of Message or of IRISObject containing the incoming message for the business operation.**Returns**:The response objectExample of a business operation ( situated in the src/python/demo/reddit/bo.py file ):```pythonfrom grongier.pex import BusinessOperationfrom message import MyRequest,MyMessageimport irisimport osimport datetimeimport smtplibfrom email.mime.text import MIMETextclass EmailOperation(BusinessOperation):    &quot;&quot;&quot;    This operation receive a PostMessage and send an email with all the    important information to the concerned company ( dog or cat company )    &quot;&quot;&quot;    def my_message(self,request:MyMessage):        sender = 'admin@example.com'        receivers = 'toto@example.com'        port = 1025        msg = MIMEText(request.toto)        msg['Subject'] = 'MyMessage'        msg['From'] = sender        msg['To'] = receivers        with smtplib.SMTP('localhost', port) as server:            server.sendmail(sender, receivers, msg.as_string())            print(&quot;Successfully sent email&quot;)    def on_message(self, request):        sender = 'admin@example.com'        receivers = [ request.to_email_address ]        port = 1025        msg = MIMEText('This is test mail')        msg['Subject'] = request.found+&quot; found&quot;        msg['From'] = 'admin@example.com'        msg['To'] = request.to_email_address        with smtplib.SMTP('localhost', port) as server:                        # server.login('username', 'password')            server.sendmail(sender, receivers, msg.as_string())            print(&quot;Successfully sent email&quot;)```If this operation is called using a MyRequest message, the my_message function will be called thanks to the dispatcher, otherwise the on_message function will be called.## 7.9. The `director` classThe Director class is used for nonpolling business services, that is, business services which are not automatically called by the production framework (through the inbound adapter) at the call interval.&lt;br&gt;Instead these business services are created by a custom application by calling the Director.create_business_service() method.&lt;br&gt;This class defines:`create_business_service`: The create_business_service() method initiates the specified business service.&lt;br&gt;**Parameters**:- **connection**: an IRISConnection object that specifies the connection to an IRIS instance for Java.- **target**: a string that specifies the name of the business service in the production definition.**Returns**:an object that contains an instance of IRISBusinessService`start_production`: The start_production() method starts the production.&lt;br&gt;**Parameters**:- **production_name**: a string that specifies the name of the production to start.`stop_production`: The stop_production() method stops the production.&lt;br&gt;**Parameters**:- **production_name**: a string that specifies the name of the production to stop.`restart_production`: The restart_production() method restarts the production.&lt;br&gt;**Parameters**:- **production_name**: a string that specifies the name of the production to restart.`list_productions`: The list_productions() method returns a dictionary of the names of the productions that are currently running.&lt;br&gt;## 7.10. The `objects`We will use `dataclass` to hold information in our [messages](#711-the-messages) in a `obj.py` file.Example of an object ( situated in the src/python/demo/reddit/obj.py file ):```pythonfrom dataclasses import dataclass@dataclassclass PostClass:    title: str    selftext : str    author: str    url: str    created_utc: float = None    original_json: str = None```## 7.11. The `messages`The messages will contain one or more [objects](#710-the-objects), located in the `obj.py` file.&lt;br&gt;Messages, requests and responses all inherit from the `grongier.pex.Message` class.These messages will allow us to transfer information between any business service/process/operation.Example of a message ( situated in the src/python/demo/reddit/message.py file ):```pythonfrom grongier.pex import Messagefrom dataclasses import dataclassfrom obj import PostClass@dataclassclass PostMessage(Message):    post:PostClass = None    to_email_address:str = None    found:str = None```WIP It is to be noted that it is needed to use types when you define an object or a message.## 7.12. How to regsiter a component You can register a component to iris in many way :* Only one component with `register_component` * All the component in a file with `register_file` * All the component in a folder with `register_folder` ### 7.12.1. register_componentStart an embedded python shell :```sh/usr/irissys/bin/irispython```Then use this class method to add a new py file to the component list for interoperability.```pythonfrom grongier.pex import UtilsUtils.register_component(&lt;ModuleName&gt;,&lt;ClassName&gt;,&lt;PathToPyFile&gt;,&lt;OverWrite&gt;,&lt;NameOfTheComponent&gt;)```e.g :```pythonfrom grongier.pex import UtilsUtils.register_component(&quot;MyCombinedBusinessOperation&quot;,&quot;MyCombinedBusinessOperation&quot;,&quot;/irisdev/app/src/python/demo/&quot;,1,&quot;PEX.MyCombinedBusinessOperation&quot;)```### 7.12.2. register_fileStart an embedded python shell :```sh/usr/irissys/bin/irispython```Then use this class method to add a new py file to the component list for interoperability.```pythonfrom grongier.pex import UtilsUtils.register_file(&lt;File&gt;,&lt;OverWrite&gt;,&lt;PackageName&gt;)```e.g :```pythonfrom grongier.pex import UtilsUtils.register_file(&quot;/irisdev/app/src/python/demo/bo.py&quot;,1,&quot;PEX&quot;)```### 7.12.3. register_folderStart an embedded python shell :```sh/usr/irissys/bin/irispython```Then use this class method to add a new py file to the component list for interoperability.```pythonfrom grongier.pex import UtilsUtils.register_folder(&lt;Path&gt;,&lt;OverWrite&gt;,&lt;PackageName&gt;)```e.g :```pythonfrom grongier.pex import UtilsUtils.register_folder(&quot;/irisdev/app/src/python/demo/&quot;,1,&quot;PEX&quot;)```### 7.12.4. migrateStart an embedded python shell :```sh/usr/irissys/bin/irispython```Then use this static method to migrate the settings file to the iris framework.```pythonfrom grongier.pex import UtilsUtils.migrate()```#### 7.12.4.1. setting.py fileThis file is used to store the settings of the interoperability components.It has two sections :* `CLASSES` : This section is used to store the classes of the interoperability components.* `PRODUCTIONS` : This section is used to store the productions of the interoperability components.e.g :```pythonimport bpfrom bo import *from bs import *CLASSES = {    'Python.RedditService': RedditService,    'Python.FilterPostRoutingRule': bp.FilterPostRoutingRule,    'Python.FileOperation': FileOperation,    'Python.FileOperationWithIrisAdapter': FileOperationWithIrisAdapter,}PRODUCTIONS = [    {        'dc.Python.Production': {        &quot;@Name&quot;: &quot;dc.Demo.Production&quot;,        &quot;@TestingEnabled&quot;: &quot;true&quot;,        &quot;@LogGeneralTraceEvents&quot;: &quot;false&quot;,        &quot;Description&quot;: &quot;&quot;,        &quot;ActorPoolSize&quot;: &quot;2&quot;,        &quot;Item&quot;: [            {                &quot;@Name&quot;: &quot;Python.FileOperation&quot;,                &quot;@Category&quot;: &quot;&quot;,                &quot;@ClassName&quot;: &quot;Python.FileOperation&quot;,                &quot;@PoolSize&quot;: &quot;1&quot;,                &quot;@Enabled&quot;: &quot;true&quot;,                &quot;@Foreground&quot;: &quot;false&quot;,                &quot;@Comment&quot;: &quot;&quot;,                &quot;@LogTraceEvents&quot;: &quot;true&quot;,                &quot;@Schedule&quot;: &quot;&quot;,                &quot;Setting&quot;: {                    &quot;@Target&quot;: &quot;Host&quot;,                    &quot;@Name&quot;: &quot;%settings&quot;,                    &quot;#text&quot;: &quot;path=/tmp&quot;                }            },            {                &quot;@Name&quot;: &quot;Python.RedditService&quot;,                &quot;@Category&quot;: &quot;&quot;,                &quot;@ClassName&quot;: &quot;Python.RedditService&quot;,                &quot;@PoolSize&quot;: &quot;1&quot;,                &quot;@Enabled&quot;: &quot;true&quot;,                &quot;@Foreground&quot;: &quot;false&quot;,                &quot;@Comment&quot;: &quot;&quot;,                &quot;@LogTraceEvents&quot;: &quot;false&quot;,                &quot;@Schedule&quot;: &quot;&quot;,                &quot;Setting&quot;: [                    {                        &quot;@Target&quot;: &quot;Host&quot;,                        &quot;@Name&quot;: &quot;%settings&quot;,                        &quot;#text&quot;: &quot;limit=10\nother&lt;10&quot;                    }                ]            },            {                &quot;@Name&quot;: &quot;Python.FilterPostRoutingRule&quot;,                &quot;@Category&quot;: &quot;&quot;,                &quot;@ClassName&quot;: &quot;Python.FilterPostRoutingRule&quot;,                &quot;@PoolSize&quot;: &quot;1&quot;,                &quot;@Enabled&quot;: &quot;true&quot;,                &quot;@Foreground&quot;: &quot;false&quot;,                &quot;@Comment&quot;: &quot;&quot;,                &quot;@LogTraceEvents&quot;: &quot;false&quot;,                &quot;@Schedule&quot;: &quot;&quot;            }        ]    }    }]```##### 7.12.4.1.1. CLASSES sectionThis section is used to store the classes of the interoperability components.It aims to help to register the components.This dictionary has the following structure :* Key : The name of the component* Value :   * The class of the component (you have to import it before)  * The module of the component (you have to import it before)  * Another dictionary with the following structure :    * `module` : Name of the module of the component (optional)    * `class` : Name of the class of the component (optional)    * `path` : The path of the component (mandatory)e.g :When Value is a class or a module:```pythonimport boimport bpfrom bs import RedditServiceCLASSES = {    'Python.RedditService': RedditService,    'Python.FilterPostRoutingRule': bp.FilterPostRoutingRule,    'Python.FileOperation': bo,}```When Value is a dictionary :```pythonCLASSES = {    'Python.RedditService': {        'module': 'bs',        'class': 'RedditService',        'path': '/irisdev/app/src/python/demo/'    },    'Python.Module': {        'module': 'bp',        'path': '/irisdev/app/src/python/demo/'    },    'Python.Package': {        'path': '/irisdev/app/src/python/demo/'    },}```##### 7.12.4.1.2. Productions sectionThis section is used to store the productions of the interoperability components.It aims to help to register a production.This list has the following structure :* A list of dictionary with the following structure :  * `dc.Python.Production` : The name of the production    * `@Name` : The name of the production    * `@TestingEnabled` : The testing enabled of the production    * `@LogGeneralTraceEvents` : The log general trace events of the production    * `Description` : The description of the production    * `ActorPoolSize` : The actor pool size of the production    * `Item` : The list of the items of the production      * `@Name` : The name of the item      * `@Category` : The category of the item      * `@ClassName` : The class name of the item      * `@PoolSize` : The pool size of the item      * `@Enabled` : The enabled of the item      * `@Foreground` : The foreground of the item      * `@Comment` : The comment of the item      * `@LogTraceEvents` : The log trace events of the item      * `@Schedule` : The schedule of the item      * `Setting` : The list of the settings of the item        * `@Target` : The target of the setting        * `@Name` : The name of the setting        * `#text` : The value of the settingThe minimum structure of a production is :```pythonPRODUCTIONS = [        {            'UnitTest.Production': {                &quot;Item&quot;: [                    {                        &quot;@Name&quot;: &quot;Python.FileOperation&quot;,                        &quot;@ClassName&quot;: &quot;Python.FileOperation&quot;,                    },                    {                        &quot;@Name&quot;: &quot;Python.EmailOperation&quot;,                        &quot;@ClassName&quot;: &quot;UnitTest.Package.EmailOperation&quot;                    }                ]            }        }     ]```You can also set in `@ClassName` an item from the CLASSES section.e.g :```pythonfrom bo import FileOperationPRODUCTIONS = [        {            'UnitTest.Production': {                &quot;Item&quot;: [                    {                        &quot;@Name&quot;: &quot;Python.FileOperation&quot;,                        &quot;@ClassName&quot;: FileOperation,                    }                ]            }        }     ]```As the production is a dictionary, you can add in value of the production dictionary an environment variable.e.g :```pythonimport osPRODUCTIONS = [        {            'UnitTest.Production': {                &quot;Item&quot;: [                    {                        &quot;@Name&quot;: &quot;Python.FileOperation&quot;,                        &quot;@ClassName&quot;: &quot;Python.FileOperation&quot;,                        &quot;Setting&quot;: {                            &quot;@Target&quot;: &quot;Host&quot;,                            &quot;@Name&quot;: &quot;%settings&quot;,                            &quot;#text&quot;: os.environ['SETTINGS']                        }                    }                ]            }        }     ]```## 7.13. Direct use of Grongier.PEXIf you don't want to use the register_component util. You can add a Grongier.PEX.BusinessService component directly into the management portal and configure the properties :- %module :  - Module name of your python code- %classname :  - Classname of you component- %classpaths  - Path where you component is.    - This can one or more Classpaths (separated by '|' character) needed in addition to PYTHON_PATHe.g :&lt;img width=&quot;800&quot; alt=&quot;component-config&quot; src=&quot;https://user-images.githubusercontent.com/47849411/131316308-e1898b19-11df-433b-b1c6-7f69d5cc9974.png&quot;&gt;# 8. Command lineSince version 2.3.1, you can use the command line to register your components and productions.To use it, you have to use the following command :```bashiop ```output :```bashusage: python3 -m grongier.pex [-h] [-d DEFAULT] [-l] [-s START] [-k] [-S] [-r] [-M MIGRATE] [-e EXPORT] [-x] [-v] [-L]optional arguments:  -h, --help            display help and default production name  -d DEFAULT, --default DEFAULT                        set the default production  -l, --lists           list productions  -s START, --start START                        start a production  -k, --kill            kill a production (force stop)  -S, --stop            stop a production  -r, --restart         restart a production  -M MIGRATE, --migrate MIGRATE                        migrate production and classes with settings file  -e EXPORT, --export EXPORT                        export a production  -x, --status          status a production  -v, --version         display version  -L, --log             display logdefault production: PEX.Production```## 8.1. helpThe help command display the help and the default production name.```bashiop -h```output :```bashusage: python3 -m grongier.pex [-h] [-d DEFAULT] [-l] [-s START] [-k] [-S] [-r] [-M MIGRATE] [-e EXPORT] [-x] [-v] [-L]...default production: PEX.Production```## 8.2. defaultThe default command set the default production.With no argument, it display the default production.```bashiop -d```output :```bashdefault production: PEX.Production```With an argument, it set the default production.```bashiop -d PEX.Production```## 8.3. listsThe lists command list productions.```bashiop -l```output :```bash{    &quot;PEX.Production&quot;: {        &quot;Status&quot;: &quot;Stopped&quot;,        &quot;LastStartTime&quot;: &quot;2023-05-31 11:13:51.000&quot;,        &quot;LastStopTime&quot;: &quot;2023-05-31 11:13:54.153&quot;,        &quot;AutoStart&quot;: 0    }}```## 8.4. startThe start command start a production.To exit the command, you have to press CTRL+C.```bashiop -s PEX.Production```output :```bash2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting production2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.FileOperation2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.EmailOperation...```## 8.5. killThe kill command kill a production (force stop).Kill command is the same as stop command but with a force stop.Kill command doesn't take an argument because only one production can be running.```bashiop -k ```## 8.6. stopThe stop command stop a production.Stop command doesn't take an argument because only one production can be running.```bashiop -S ```## 8.7. restartThe restart command restart a production.Restart command doesn't take an argument because only one production can be running.```bashiop -r ```## 8.8. migrateThe migrate command migrate a production and classes with settings file.Migrate command must take the absolute path of the settings file.Settings file must be in the same folder as the python code.```bashiop -M /tmp/settings.py```## 8.9. exportThe export command export a production.If no argument is given, the export command export the default production.```bashiop -e```If an argument is given, the export command export the production given in argument.```bashiop -e PEX.Production```output :```bash{    &quot;Production&quot;: {        &quot;@Name&quot;: &quot;PEX.Production&quot;,        &quot;@TestingEnabled&quot;: &quot;true&quot;,        &quot;@LogGeneralTraceEvents&quot;: &quot;false&quot;,        &quot;Description&quot;: &quot;&quot;,        &quot;ActorPoolSize&quot;: &quot;2&quot;,        &quot;Item&quot;: [            {                &quot;@Name&quot;: &quot;Python.FileOperation&quot;,                &quot;@Category&quot;: &quot;&quot;,                &quot;@ClassName&quot;: &quot;Python.FileOperation&quot;,                &quot;@PoolSize&quot;: &quot;1&quot;,                &quot;@Enabled&quot;: &quot;true&quot;,                &quot;@Foreground&quot;: &quot;false&quot;,                &quot;@Comment&quot;: &quot;&quot;,                &quot;@LogTraceEvents&quot;: &quot;true&quot;,                &quot;@Schedule&quot;: &quot;&quot;,                &quot;Setting&quot;: [                    {                        &quot;@Target&quot;: &quot;Adapter&quot;,                        &quot;@Name&quot;: &quot;Charset&quot;,                        &quot;#text&quot;: &quot;utf-8&quot;                    },                    {                        &quot;@Target&quot;: &quot;Adapter&quot;,                        &quot;@Name&quot;: &quot;FilePath&quot;,                        &quot;#text&quot;: &quot;/irisdev/app/output/&quot;                    },                    {                        &quot;@Target&quot;: &quot;Host&quot;,                        &quot;@Name&quot;: &quot;%settings&quot;,                        &quot;#text&quot;: &quot;path=/irisdev/app/output/&quot;                    }                ]            }        ]    }}```## 8.10. statusThe status command status a production.Status command doesn't take an argument because only one production can be running.```bashiop -x ```output :```bash{    &quot;Production&quot;: &quot;PEX.Production&quot;,    &quot;Status&quot;: &quot;stopped&quot;}```Status can be :- stopped- running- suspended- troubled## 8.11. versionThe version command display the version.```bashiop -v```output :```bash2.3.0```## 8.12. logThe log command display the log.To exit the command, you have to press CTRL+C.```bashiop -L```output :```bash2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting production2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.FileOperation2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.EmailOperation...```# 9. CreditsMost of the code came from PEX for Python by Mo Cheng and Summer Gerry.Works only on IRIS 2021.2 +</longdescription>
</pkgmetadata>