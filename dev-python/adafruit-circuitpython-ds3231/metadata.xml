<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Introduction=============.. image:: https://readthedocs.org/projects/adafruit-micropython-ds3231/badge/?version=latest    :target: https://docs.circuitpython.org/projects/ds3231/en/latest/    :alt: Documentation Status.. image:: https://raw.githubusercontent.com/adafruit/Adafruit_CircuitPython_Bundle/main/badges/adafruit_discord.svg    :target: https://adafru.it/discord    :alt: Discord.. image:: https://github.com/adafruit/Adafruit_CircuitPython_DS3231/workflows/Build%20CI/badge.svg    :target: https://github.com/adafruit/Adafruit_CircuitPython_DS3231/actions/    :alt: Build Status.. image:: https://img.shields.io/badge/code%20style-black-000000.svg    :target: https://github.com/psf/black    :alt: Code Style: BlackThe datasheet for the DS3231 explains that this part is an&quot;Extremely Accurate IÂ²C-Integrated RTC/TCXO/Crystal&quot;. And,hey, it does exactly what it says on the tin! This Real TimeClock (RTC) is the most precise you can get in a small, lowpower package.Most RTCs use an external 32kHz timing crystal that is usedto keep time with low current draw. And that's all well andgood, but those crystals have slight drift, particularly whenthe temperature changes (the temperature changes the oscillationfrequency very very very slightly but it does add up!) ThisRTC is in a beefy package because the crystal is inside thechip! And right next to the integrated crystal is a temperaturesensor. That sensor compensates for the frequency changes byadding or removing clock ticks so that the timekeeping stayson schedule.This is the finest RTC you can get, and now we have it in acompact, breadboard-friendly breakout. With a coin cellplugged into the back, you can get years of precisiontimekeeping, even when main power is lost. Great fordatalogging and clocks, or anything where you need toreally know the time... image:: ../docs/_static/3013-01.jpg    :alt: DS3231 Product ImageDependencies=============This driver depends on:* `Adafruit CircuitPython &lt;https://github.com/adafruit/circuitpython&gt;`_* `Bus Device &lt;https://github.com/adafruit/Adafruit_CircuitPython_BusDevice&gt;`_* `Register &lt;https://github.com/adafruit/Adafruit_CircuitPython_Register&gt;`_Please ensure all dependencies are available on the CircuitPython filesystem.This is easily achieved by downloading`the Adafruit library and driver bundle &lt;https://github.com/adafruit/Adafruit_CircuitPython_Bundle&gt;`_.Installing from PyPI====================On supported GNU/Linux systems like the Raspberry Pi, you can install the driver locally `fromPyPI &lt;https://pypi.org/project/adafruit-circuitpython-ds3231/&gt;`_. To install for current user:.. code-block:: shell    pip3 install adafruit-circuitpython-ds3231To install system-wide (this may be required in some cases):.. code-block:: shell    sudo pip3 install adafruit-circuitpython-ds3231To install in a virtual environment in your current project:.. code-block:: shell    mkdir project-name &amp;&amp; cd project-name    python3 -m venv .venv    source .venv/bin/activate    pip3 install adafruit-circuitpython-ds3231Usage Notes===========Basics------Of course, you must import the library to use it:.. code:: python3    import adafruit_ds3231    import timeAll the Adafruit RTC libraries take an instantiated and active I2C object(from the ``board`` library) as an argument to their constructor. The way tocreate an I2C object depends on the board you are using. For boards with labeledSCL and SDA pins, you can:.. code:: python3    import boardNow, to initialize the I2C bus:.. code:: python3    i2c = board.I2C()  # uses board.SCL and board.SDAOnce you have created the I2C interface object, you can use it to instantiatethe RTC object:.. code:: python3    rtc = adafruit_ds3231.DS3231(i2c)Date and time-------------To set the time, you need to set ``datetime`` to a ``time.struct_time`` object:.. code:: python3    rtc.datetime = time.struct_time((2017,1,9,15,6,0,0,9,-1))After the RTC is set, you retrieve the time by reading the ``datetime``attribute and access the standard attributes of a struct_time such as ``tm_year``,``tm_hour`` and ``tm_min``... code:: python3    t = rtc.datetime    print(t)    print(t.tm_hour, t.tm_min)Alarm-----To set the time, you need to set ``alarm1`` or ``alarm2`` to a tuple with a``time.struct_time`` object and string representing the frequency such as &quot;hourly&quot;:.. code:: python3    rtc.alarm1 = (time.struct_time((2017,1,9,15,6,0,0,9,-1)), &quot;daily&quot;)After the RTC is set, you retrieve the alarm status by reading the corresponding``alarm1_status`` or ``alarm2_status`` attributes. Once True, set it back to Falseto reset... code:: python3    if rtc.alarm1_status:        print(&quot;wake up!&quot;)        rtc.alarm1_status = FalseDocumentation=============API documentation for this library can be found on `Read the Docs &lt;https://docs.circuitpython.org/projects/ds3231/en/latest/&gt;`_.For information on building library documentation, please check out `this guide &lt;https://learn.adafruit.com/creating-and-sharing-a-circuitpython-library/sharing-our-docs-on-readthedocs#sphinx-5-1&gt;`_.Contributing============Contributions are welcome! Please read our `Code of Conduct&lt;https://github.com/adafruit/Adafruit_CircuitPython_DS3231/blob/main/CODE_OF_CONDUCT.md&gt;`_before contributing to help this project stay welcoming.</longdescription>
</pkgmetadata>