<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>wavio=====``wavio`` is a Python module that defines two functions:* ``wavio.read`` reads a WAV file and returns an object that holds the  sampling rate, sample width (in bytes), and a numpy array containing the  data.* ``wavio.write`` writes a numpy array to a WAV file, optionally using a  specified sample width.The functions can read and write 8-, 16-, 24- and 32-bit integer WAV files.The module uses the ``wave`` module in Python's standard library, so it hasthe same limitations as that module.  In particular, the ``wave`` moduledoes not support compressed WAV files, and it does not handle floatingpoint WAV files.  When floating point data is passed to ``wavio.write`` itis converted to integers before being written to the WAV file.``wavio`` requires Python 3.7 or later.``wavio`` depends on numpy (http://www.numpy.org).  NumPy version 1.19.0 orlater is required.    The unit tests in ``wavio`` require ``pytest``.The API of the functions in ``wavio`` should not be considered stable.  Theremay be backwards-incompatible API changes between releases.*Important notice*In version 0.0.5, the data handling in ``wavio.write`` has been changed ina backwards-incompatible way.  The API for scaling the input in 0.0.4 wasa flexible interface that only its creator could love.  The new API issimpler, and it is hoped that it does the right thing by default inmost cases.  In particular:* When the input data is an integer type, the values are not scaled or  shifted.  The only change that might happen is the data will be clipped  if the values do not fit in the output integer type.* If the input data is a floating point type, ``sampwidth`` must be given.  The default behavior is to scale input values in the range [-1.0, 1.0]  to the output range [min_int+1, max_int], where min_int and max_int are  the minimum and maximum values of the output data type determined by  ``sampwidth``.  See the description of ``scale`` in the docstring of  ``wavio.write`` for more options.  Regardless of the value of ``scale``,  the float input 0.0 is always mapped to the midpoint of the output type;  ``wavio.write`` will not translate the values up or down.* A warning is now generated if any data values are clipped.  A parameter  allows the generation of the warning to be disabled or converted to an  exception.Examples--------The following examples are also found in the docstring of ``wavio.write``.Create a 3 second 440 Hz sine wave, and save it in a 24-bit WAV file.    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; import wavio    &gt;&gt;&gt; rate = 22050           # samples per second    &gt;&gt;&gt; T = 3                  # sample duration (seconds)    &gt;&gt;&gt; n = int(rate*T)        # number of samples    &gt;&gt;&gt; t = np.arange(n)/rate  # grid of time values    &gt;&gt;&gt; f = 440.0              # sound frequency (Hz)    &gt;&gt;&gt; x = np.sin(2*np.pi * f * t)`x` is a single sine wave with amplitude 1, so we can use the default`scale`.    &gt;&gt;&gt; wavio.write(&quot;sine24.wav&quot;, x, rate, sampwidth=3)Create a file that contains the 16 bit integer values -10000 and 10000repeated 100 times.  Use a sample rate of 8000.    &gt;&gt;&gt; x = np.empty(200, dtype=np.int16)    &gt;&gt;&gt; x[::2] = -10000    &gt;&gt;&gt; x[1::2] = 10000    &gt;&gt;&gt; wavio.write(&quot;foo.wav&quot;, x, 8000)Check that the file contains what we expect.  The values are checkedfor exact equality.  The input was an integer array, so the values arenot scaled.    &gt;&gt;&gt; w = wavio.read(&quot;foo.wav&quot;)    &gt;&gt;&gt; np.all(w.data[:, 0] == x)    TrueWrite floating point data to a 16 bit WAV file.  The floating pointvalues are assumed to be within the range [-2, 2], and we want thevalues 2 and -2 to correspond to the full output range, even if theactual values in the data do not fill this range.  We do that byspecifying `scale=2`.`T`, `rate` and `t` are from above.  The data is the sum of twosinusoids, with frequencies 440 and 880 Hz, modulated by a paraboliccurve that is zero at the start and end of the data.    &gt;&gt;&gt; envelope = (4/T**2)*(t * (T - t))    &gt;&gt;&gt; omega1 = 2*np.pi*440    &gt;&gt;&gt; omega2 = 2*np.pi*880    &gt;&gt;&gt; y = envelope*(np.sin(omega1*t) + 0.3*np.sin(omega2*t + 0.2))    &gt;&gt;&gt; y.min(), y.max()    (-1.1745469775555515, 1.093833464065767)Write the WAV file, with `scale=2`.    &gt;&gt;&gt; wavio.write('harmonic.wav', y, rate, sampwidth=2, scale=2)Check the minimum and maximum integers that were actually writtento the file:    &gt;&gt;&gt; w = wavio.read(&quot;harmonic.wav&quot;)    &gt;&gt;&gt; w.data.min(), w.data.max()    (-19243, 17921)If we want the WAV file to use as much of the range of the outputinteger type as possible (while still mapping 0.0 in the input to 0 inthe output), we set `scale=&quot;auto&quot;`.    &gt;&gt;&gt; wavio.write('harmonic_full.wav', y, rate, sampwidth=2, scale=&quot;auto&quot;)    &gt;&gt;&gt; w = wavio.read('harmonic_full.wav')    &gt;&gt;&gt; w.data.min(), w.data.max()    (-32768, 30517)-----Author:     Warren WeckesserRepository: https://github.com/WarrenWeckesser/wavioLicense:    BSD 2-clause (http://opensource.org/licenses/BSD-2-Clause)</longdescription>
</pkgmetadata>