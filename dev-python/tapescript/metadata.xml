<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># TapescriptSimple script system loosely inspired by Bitcoin script but also hopefully moreuseful for other applications. The idea is to programmatically ensure accesscontrols in a distributed system.## Status- [x] OPs- [x] Interpreter functions and classes- [x] Byte-code compiler- [x] Decompiler- [x] Unit tests- [x] E2e tests- [x] Merkleval test vectors- [x] Omega e2e test with all ops and nops- [x] Plugin architecture: new ops with compiler, decompiler, interpreter- [x] Half-decent docs- [x] Decent docs- [x] Package published- [x] Added try...except## Usage### Installation```bashpip install tapescript```### Write, compile, decompileSee the[langauge_spec.md](https://github.com/k98kurz/tapescript/blob/master/language_spec.md)and [docs.md](https://github.com/k98kurz/tapescript/blob/master/docs.md) filesfor syntax and operation specifics.Once you have a script written, use the `compile_script(code: str) -&gt; bytes`function to turn it into the byte code that the interpreter runs.#### Merklized scriptsThere is an included tool for making merklized branching scripts. To use it,write the desired branches, then pass them to the `create_merklized_script`function. For example:```pyfrom tapescript import create_merklized_scriptbranches = [    'OP_PUSH xb26d10053b4b25497081561f529e42da9ccfac860a7b3d1ec932901c2a70afce\nOP_CHECK_SIG x00',    'OP_PUSH x9e477d55a62fc1ecc6b7c89d69c4f9cba94d5173f0d59f971951ff46acb9017b\nOP_CHECK_SIG x00',    'OP_PUSH xdd86edfbcfd5ac3e8c1acb527cc4178a14af0755aea1e447dc2b278f52fcedbf\nOP_CHECK_SIG x00',]locking_script, unlocking_scripts = create_merklized_script(branches)```This function returns a tuple containing the locking script that uses`OP_MERKLEVAL` to enforce the cryptographic commitment to the branches and alist of unlocking scripts that fulfill the cryptographic commitment and executethe individual script branches. The unlocking scripts are ordered identically tothe input branches. In the above example, each branch expects a signature fromthe given public key. To use as an auth script, the locking script would becompiled and used as the locking condition. A signature would be prepended tothe unlocking script with an `OP_PUSH x&lt;hex signature&gt; `, and this would then becompiled to become the unlocking bytes. Then concatenate the locking script tothe unlocking script (i.e. script = unlock + lock) and run through the`run_auth_script` function, which will return a `True` if it executedsuccessfully and `False` otherwise.### Run a scriptRun a script by compiling it to byte code (if it wasn't already) and run witheither `run_script(script: bytes, cache_vals: dict = {}, contracts: dict = {})`or `run_auth_script(script: bytes, cache_vals: dict = {}, contracts: dict = {})`.The `run_script` function returns `tuple` of length 3 containing a `Tape`, a`LifoQueue`, and the final state of the `cache` dict. The `run_auth_script`instead returns a bool that is `True` if the script ran without error andresulted in a single `True` value on the queue; otherwise it returns `False`.In the case where a signature is expected to be validated, the message parts forthe signature must be passed in via the `cache_vals` dict at keys `sigfield[1-8]`.In the case where `OP_CHECK_TRANSFER` might be called, the contracts must bepassed in via the `contracts` dict. See the[section in the language_spec.md](https://github.com/k98kurz/tapescript/blob/master/language_spec.md#op_check_transfer-count)file for more informaiton about `OP_CHECK_TRANSFER`.#### Changing flagsThe interpreter flags can be changed by changing the `functions.flags` dict.#### Adding opsThe ops can be updated via a plugin system.```pyfrom queue import LifoQueuefrom tapescript import Tape, add_opcode, add_opcode_parsing_handlersdef OP_SOME_NONSENSE(tape: Tape, queue: LifoQueue, cache: dict) -&gt; None:    count = tape.read(1)[0]    for _ in range(count):        queue.put(b'some nonsense')def OP_SOME_NONSENSE_compiler(opname: str, symbols: list[str],        symbols_to_advance: int, symbol_index: int):    symbols_to_advance += 1    if symbols[0][0] != 'd':        raise SyntaxError(f'{opname} - int argument must begin with d - {symbol_index}')    val = int(symbols[0][1:]).to_bytes(1, 'big)    return (symbols_to_advance, (val,))def OP_SOME_NONSENSE_decompiler(opname: str, tape: Tape):    val = tape.read(1)[0]    return [f'{opname} d{val}']# add opcode to bytecode interpreteradd_opcode(255, 'OP_SOME_NONSENSE', OP_SOME_NONSENSE)# add opcode to compiler and decompileradd_opcode_parsing_handlers(    'OP_SOME_NONSENSE',    OP_SOME_NONSENSE_compiler,    OP_SOME_NONSENSE_decompiler)```### ContractsThe interpreter includes a system for including contracts for greaterextensibility. For example, the bundled `CanCheckTransfer` interface is usedto check that contracts can be used with the `OP_CHECK_TRANSFER` operation. Toadd an interface for checking loaded contracts, call `add_contract_interface`and pass a `runtime_checkable` subclass of `typing.Protocol` as the argument. Toremove an interface, call `remove_contract_interface` and pass the interface asthe argument.To add a contract, use `add_contract(contract_id: bytes, contract: object)`. Toremove a contract, use `remove_contract(contract_id: bytes)`.Each contract will be checked against each interface when added and again atruntime when an op that uses a contract is executed. All contracts added via the`add_contract` function will be included in the runtime environment of scriptsrun thereafter. Additionally, contracts can be passed into the `run_script` and`run_auth_script` functions, and these will override any contracts in the globalruntime environment in case of a contract_id conflict.To use a contract in a custom op, find it in the `tape.contracts` dict by itscontract_id.### Signature checkingNotes for the `OP_CHECK_SIG` and `OP_CHECK_SIG_VERIFY` functions:1. The body of the message to be used in checking the signature is comprised ofthe `sigfield[1-8]` cache items.2. Each signature can have an additional (33rd) byte attached which encodes upto 8 bit flags. Each bit flag encoded will exclude the associated `sigfield{n}`cache item from the message body during signature checks.3. These ops take a 1 byte param from the tape that encodes the allowable flags.If a signature is passed to a signature checker that uses a disallowed sigflag,a `ScriptExecutionError` will be raised.### Soft ForksA soft fork is a protocol upgrade such that all scripts written under the newprotocol also validate under the old version -- older versions do not break whenencountering use of the new feature. Tapescript was designed with soft-forksupport in mind, and the helper function `add_soft_fork` is included tostreamline the process and reduce the use of boilerplate.To enable a soft fork, a NOP code must be replaced with an op that reads thenext byte as an unsigned int, pulls that many values from the queue, runs anychecks on the data, and raises an error in case any check fails. This maintainsthe behavior of the original NOP such that any nodes that did not activate thesoft fork will not have any errors parsing scripts using the new OP.Example soft fork:```pythonfrom tapescript import (    Tape,    ScriptExecutionError,    add_soft_fork)from queue import LifoQueuedef OP_CHECK_ALL_EQUAL_VERIFY(tape: Tape, queue: LifoQueue, cache: dict) -&gt; None:    &quot;&quot;&quot;Replacement for NOP255: read the next byte as uint count, take        that many items from queue, run checks, and raise an error if        any check fails.    &quot;&quot;&quot;    count = tape.read(1)[0]    items = []    for i in range(count):        items.append(queue.get(False))    compare = items.pop()    while len(items):        if items.pop() != compare:            raise ScriptExecutionError('not all the same')add_soft_fork(255, 'OP_CHECK_ALL_EQUAL_VERIFY', OP_CHECK_ALL_EQUAL_VERIFY)```Scripts written with the new op will always execute successfully on nodesrunning the old version of the interpreter. Example script:```s# locking script #OP_CHECK_ALL_EQUAL_VERIFY d3OP_TRUE# locking script as decompiled by old nodes #NOP255 d3OP_TRUE# unlocking script that validates on both versions #OP_PUSH x0123OP_PUSH x0123OP_PUSH x0123# unlocking script that fails validation on the new version #OP_PUSH x0123OP_PUSH x0123OP_PUSH x3210```Additionally, conditional programming can be accomplished with soft fork ops byusing `OP_TRY_EXCEPT`. The `EXCEPT` clause will never be executed by nodes thathave not activated the soft fork, but it will be executed by nodes that haveactivated the soft fork and encountered an exception during execution of the newop.Note that any new language features added to the interpreter will be hard forksreplacing lower value NOPs. (For example, `OP_TRY_EXCEPT` was a hard fork thatreplaced `NOP61`.) To opt-in to hard fork compatibility in this package whileimplementing soft-forks for an application using tapescript as a dependency,start by soft forking `NOP255` and count down with each additional soft fork.### TestingFirst, clone the repo, set up the virtualenv, and install requirements.```bashgit clone ...python -m venv venv/source venv/bin/activatepip install -r requirements.txt```For windows, replace `source venv/bin/activate` with `source venv/Scripts/activate`.Then run the test suite with the following:```bashpython test/test_classes.pypython test/test_functions.pypython test/test_parsing.pypython test/test_tools.py```There are currently 159 tests and 32 test vectors used for validating thecompiler, decompiler, and script running functions.## ISC LicenseCopyleft (c) 2023 k98kurzPermission to use, copy, modify, and/or distribute this softwarefor any purpose with or without fee is hereby granted, providedthat the above copyleft notice and this permission notice appear inall copies.Exceptions: this permission is not granted to Alphabet/Google, Amazon,Apple, Microsoft, Netflix, Meta/Facebook, Twitter, or Disney; nor ispermission granted to any company that contracts to supply weapons orlogistics to any national military; nor is permission granted to anynational government or governmental agency; nor is permission granted toany employees, associates, or affiliates of these designated entities.Notwithstanding the above exceptions, the code may be used withoutconstraint for demonstration, educational, or entertainment purposes.THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALLWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIEDWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THEAUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, ORCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSSOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR INCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</longdescription>
</pkgmetadata>