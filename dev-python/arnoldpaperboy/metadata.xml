<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Arnold the Paperboy===================Delivers the Daily Slab. As a python package, it also facilitateslogging from python in kubernetes to stackdriver.Arnoldpaperboy is developed by Satelligence (&quot;S11&quot;) to aid proper logging to Stackdriver from pythonprocesses running in Kubernetes. With as little influence on existing code as possible.TL;DR:------Assume there is existing code which uses::    logger = logging.getLogger(__name__)everywhere on top of the python files, and uses this `logger` object throught the rest of the codeto do logging calls. To enable Stackdriver enhanced logging and profiling, just add::    from arnoldpaperboy.helpers import autologin the imports section, and annotate every function or method from which you want to have betterStackdriver logging, or which you'd want to have profile information in Stackdriver logs with the::    @autolog(level=logging.LEVEL)and suddenly* every ``logger.info|warning|debug|...`` call will send a properly formatted log message to  Stackdriver, with a k8s_container resource with all labels filled, with information on from which  file, function and line the logger was called, and with additional items in the ``labels`` section  for every arg or kwarg the decorated function was called with;* a log message will be sent to Stackdriver right before calling the decorated function (&quot;Starting  &lt;package.module.function&gt;&quot;);* a log message will be sent to Stackdriver when the decorated function is finished, with additional  temporal profiling information (the function call duration): &quot;Finished &lt;package.module.function&gt;  in h:mm:ss&quot;.How does it work?-----------------Currently, the package contains 3 parts, which, when tied together, enable (Stackdriver) logging andprofiling for existing code by simply adding an import and a decorator call.StackdriverLoggingHandler~~~~~~~~~~~~~~~~~~~~~~~~~StackdriverLoggingHandler class in logging_handlers.py: this is a customized logging handler whichderives from the google.cloud.logging.handlers.CloudLoggingHandler. The StackdriverLoggingHandleradds a properly formatted and filled Stackdriver `resource` object, adds some extra information tothe Stackdriver ``labels``, and adds any extra attributes from the python LogRecord object to``labels``. When using the StackdriverLoggingHandler as-is, you would add these extra attributes tothe LogRecord by specifying an ``extra={'somekey':'somevalue', ...:...}`` to a logging statement. Dueto how python logging works, these ``extra`` attributes automatically end up as attributes on theLogRecord instance.AnnotatedLogger~~~~~~~~~~~~~~~AnnotatedLogger in helpers.py is a context manager (so it can be used in a ``with`` statement) whichmagically picks up an earlier defined logger instance (by name, default='logger'), and for thenew context replaces that with a (slightly enhanced) LoggerAdapter instance. This is very useful ifthere already is code with ``logger = logging.getLogger(__name__)`` on top of the files, and the useof this ``logger`` throughout the code. Without the trick to get a logger from a global scope, the newannotated logger cannot have the same name as the existing (global) logger.The new annotated logger is annotated with all the kwargs it is instantiated with, and so iteliminates the ugly need for an ``extra={...}`` keyword. Instead, within the new context, the existinglogger can be used as is, and every keyword that was specified in the ``AnnotatedLogger(...)`` callwill be added to every logging call.autolog~~~~~~~Autolog is a decorator function which replaces an existing global logger with a new annotated loggerwhile the decorated function is being called. The caller's arguments and keyword arguments areautomatically added to the annotated logger (with an extra &quot;arg\_&quot; prefix). Profiling is enabledthrough the ``log_before`` and ``log_after`` keywords, which when True will automatically send a logmessage before and after calling the decorated function, the last one enriched with profilinginformation (duration in seconds and formatted as human readable time).Usage example-------------Use case: existing code base, running on k8s, using Django framework. Wish: proper logging toStackdriver while keeping the existing code base intact as much as possible.First, enable proper formatted logging to Stackdriver. Configure django logging by extending theexisting django logconfig like this::    from google.cloud.logging import Client    STACKDRIVER_CLIENT = Client(project=GOOGLE_PROJECT_ID)    LOG_HANDLERS = ['stackdriver']    LOG_HANDLER_CONFIG['stackdriver'] = {        'class': 'arnoldpaperboy.logging_handlers.StackdriverLoggingHandler',        'client': STACKDRIVER_CLIENT,        'tier': 'your-tier-name',        'app': 'your-app-name',    }    logging.config.dictConfig({        'version': 1,        'disable_existing_loggers': False,        'handlers': LOG_HANDLER_CONFIG,        'loggers': {            # root logger            '': {                'level': LOGLEVEL_ROOT,                'name': TIER,                'handlers': LOG_HANDLERS,            },        },    })then to enable enhanced logging to Stackdriver, Just add::    from arnoldpaperboy.helpers import autologand decorate each function or method from where the enhanced logging to stackdriver should beenabled with the autolog decorator::    @autolog(level=...)Magic!</longdescription>
</pkgmetadata>