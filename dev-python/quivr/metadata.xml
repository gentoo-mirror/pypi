<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># quivrQuivr is a Python library which provides great containers for Arrow data.Quivr's `Table`s are like DataFrames, but with strict schemas toenforce types and expectations. They are backed by thehigh-performance Arrow memory model, making them well-suited forstreaming IO, RPCs, and serialization/deserialization to Parquet.## why?Data engineering involves taking analysis code and algorithms whichwere prototyped, often on pandas DataFrames, and shoring them up forproduction use.While DataFrames are great for ad-hoc exploration, visualization, andprototyping, they aren't as great for building sturdy applications: - Loose and dynamic typing makes it difficult to be sure that code is   correct without lots of explicit checks of the dataframe's state. - Performance of Pandas operations can be unpredictable and have   surprising characteristics, which makes it harder to provision   resources. - DataFrames can use an extremely large amount of memory (typical   numbers cited are between 2x and 10x the &quot;raw&quot; data's size), and   often are forced to copy data in intermediate computations, which   poses unnecessarily heavy requirements. - The mutability of DataFrames can make debugging difficult and lead   to confusing state.We don't want to throw everything out, here. Vectorized computationsare often absolutely necessary for data work. But what if we couldhave those vectorized computations, but with: - Types enforced at runtime, with no dynamically column information. - Relatively uniform performance due to a no-copy orientation - Immutable data, allowing multiple views at very fast speedThis is what Quivr's Tables try to provide.## InstallationCheck out this repo, and `pip install` it.## UsageYour main entrypoint to Quivr is through defining classes whichrepresent your tables. You write a subclass of quivr.Table, annotatingit with Columns that describe the data you're working with, and quivrwill handle the rest.```pythonfrom quivr import Table, Float64Columnimport pyarrow as paclass Coordinates(Table):x = Float64Column()y = Float64Column()z = Float64Column()vx = Float64Column()vy = Float64Column()vz = Float64Column()```Then, you can construct tables from data:```pythoncoords = Coordinates.from_data(    x=np.array([ 1.00760887, -2.06203093,  1.24360546, -1.00131722]),    y=np.array([-2.7227298 ,  0.70239707,  2.23125432,  0.37269832]),    z=np.array([-0.27148738, -0.31768623, -0.2180482 , -0.02528401]),    vx=np.array([ 0.00920172, -0.00570486, -0.00877929, -0.00809866]),    vy=np.array([ 0.00297888, -0.00914301,  0.00525891, -0.01119134]),    vz=np.array([-0.00160217,  0.00677584,  0.00091095, -0.00140548]))# Sort the table by the z column. This returns a copy.coords_z_sorted = coords.sort_by(&quot;z&quot;)print(len(coords))# prints 4# Access any of the columns as a numpy array with zero copy:xs = coords.x.to_numpy()# Present the table as a pandas DataFrame, with zero copy if possible:df = coords.to_dataframe()```### Embedded definitions and nullable columnsYou can embed one table's definition within another, and you can make columns nullable:```pythonclass AsteroidOrbit(Table):designation = StringColumn()mass = Float64Column(nullable=True)radius = Float64Column(nullable=True)coords = Coordinates.as_column()# You can construct embedded columns from Arrow StructArrays, which you can get from# other Quivr tables using the to_structarray() method with zero copy.orbits = AsteroidOrbit.from_data(    designation=np.array([&quot;Ceres&quot;, &quot;Pallas&quot;, &quot;Vesta&quot;, &quot;2023 DW&quot;]),    mass=np.array([9.393e20, 2.06e21, 2.59e20, None]),    radius=np.array([4.6e6, 2.7e6, 2.6e6, None]),    coords=coords.to_structarray(),)```### Computing#### Using NumpyWhen you reference columns, you'll get numpy arrays which you can use to do computations:```pythonimport numpy as npprint(np.quantile(orbits.mass + 10, 0.5)```#### Using pyarrow.computeYou can also use access columns of the data as Arrow Arrays to docomputations using the Pyarrow compute kernels:```pythonimport pyarrow.compute as pcmedian_mass = pc.quantile(pc.add(orbits.column(mass, as_numpy=False), 10), q=0.5)# median_mass is a pyarrow.Scalar, which you can get the value of with .as_py()print(median_mass.as_py())```There is a very extensive set of functions available in the`pyarrow.compute` package, which you can see[here](https://arrow.apache.org/docs/python/compute.html). Thesecomputations will, in general, use all cores available and dovectorized computations which are very fast.### Customizing behavior with methodsBecause Quivr tables are just Python classes, you can customize thebehavior of your tables by adding or overriding methods. For example, if you want to add amethod to compute the total mass of the asteroids in the table, youcan do so like this:```pythonclass AsteroidOrbit(Table):designation = StringColumn()mass = Float64Column(nullable=True)radius = Float64Column(nullable=True)coords = Coordinates.as_column()    def total_mass(self):        return pc.sum(self.mass)```You can also use this to add &quot;meta-columns&quot; which are combinations of other columns. For example:```pythonclass CoordinateCovariance(Table):matrix_values = ListColumn(pa.float64(), 36)    @property    def matrix(self):        # This is a numpy array of shape (n, 6, 6)        return self.matrix_values.to_numpy().reshape(-1, 6, 6)class AsteroidOrbit(Table):designation = StringColumn()mass = Float64Column(nullable=True)radius = Float64Column(nullable=True)coords = Coordinates.as_column()covariance = CoordinateCovariance.as_column()orbits = load_orbits() # Analogous to the example above# Compute the determinant of the covariance matrix for each asteroiddeterminants = np.linalg.det(orbits.covariance.matrix)```### Adding instance attributesYou can also add more attributes (that is, non-Column ones) to yourclass and its instances, but doing so requires a bit more attention.You can override `__init__` to add instance-level attributes. However,if you do this, there are a few rules: 1. Your `__init__` method must have an attribute called `table`, with    type `pyarrow.Table`, and you must pass this to Table's `__init__`    (via `super().__init__(table)`). 2. You must implement a `with_table(self, table: pa.Table) -&gt; Self`    method which returns a **new** instance with the provided table,    bringing along the current values of all instance attributes.For example:```pythonfrom typing import Selfclass AsteroidOrbit(Table):    designation = StringColumn()mass = Float64Column(nullable=True)def __init__(self, table: pa.Table, mu: float):    super().__init__(table)self.mu = mudef with_table(self, table: pa.Table) -&gt; Self:        return AsteroidOrbit(table, self.mu)```The `with_table` method will be used in iteration, slicing andindexing operations, so try to make it pretty quick.In addition, note that serialization methods (`to_csv`, `to_feather`,and `to_parquet`) will not, by default, bring along your instanceattributes. If you would like to serialize the instance attributes,either override those methods or add additional serialization methodsof your own, and similarly implement deserializers.### Data ValidationYou can validate that the data inside a Table matches constraints youdefine. Only a small number of validators are currently implemented,mostly for numeric checks, but as use cases emerge, more will beadded.To add data validation, use the `validator=` keyword insidecolumns. For example:```pythonfrom quivr import Table, Int64Column, Float64Column, StringColumnfrom quivr.validators import gt, ge, le, and_, is_inclass Observation(Table):    id = Int64Column(validator=gt(0))    ra = Float64Column(validator=and_(ge(0), le(360))    dataset_id = StringColumn(validator=is_in([&quot;ztf&quot;, &quot;nsc&quot;, &quot;skymapper&quot;])))    unvalidated = Int64Column()```This `Observation` table has validators that- the `id` column's values are greater than 0- the `ra` column's values are between 0 and 360, inclusive- the `dataset_id` column only has strings in the set `{&quot;ztf&quot;, &quot;nsc&quot;, &quot;skymapper&quot;}`When an `Observation` instance is created using the `from_data`method, these validation checks will be run, by default. This can bedisabled by calling `Observation.from_data(..., validate=False)`.In addition, an instance can be explicitly validated by calling the`.validate()` method, which will raise a `quivr.ValidationError` ifthere are any failures.Also, tables have a `.is_valid()` method which returns a boolean toindicate whether they pass validation.### FilteringYou can also filter by expressions on the data. See [Arrowdocumentation](https://arrow.apache.org/docs/python/compute.html) formore details. You can use this to construct a quivr Table using anappropriately-schemaed Arrow Table:```pythonbig_orbits = AsteroidOrbit(orbits.table.filter(orbits.table[&quot;mass&quot;] &gt; 1e21))```If you're plucking out rows that match a single value, you can use the&quot;select&quot; method on the Table:```python# Get the orbit of Ceresceres_orbit = orbits.select(&quot;designation&quot;, &quot;Ceres&quot;)```#### Indexes for Fast LookupsIf you're going to be doing a lot of lookups on a particular column,it can be useful to create an index for that column. You can do usingthe `quivr.StringIndex` class to build an index for string values:```python# Build an index for the designation columndesignation_index = quivr.StringIndex(orbits, &quot;designation&quot;)# Get the orbit of Ceresceres_orbit = designation_index.lookup(&quot;Ceres&quot;)```The `lookup` method on the StringIndex returns Quivr Tables, or Noneif there is no match. Keep in mind that the returned tables might havemultiple rows if there are multiple matches._TODO: Add numeric and time-based indexes._### Serialization#### FeatherFeather is a fast, zero-copy serialization format for Arrow tables. Itcan be used for interprocess communication, or for working with dataon disk via memory mapping.```pythonorbits.to_feather(&quot;orbits.feather&quot;)orbits_roundtripped = AsteroidOrbit.from_feather(&quot;orbits.feather&quot;)# use memory mapping to work with a large file without copying it into memoryorbits_mmap = AsteroidOrbit.from_feather(&quot;orbits.feather&quot;, memory_map=True)```#### ParquetYou can serialize your tables to Parquet files, and read them back:```pythonorbits.to_parquet(&quot;orbits.parquet&quot;)orbits_roundtripped = AsteroidOrbit.from_parquet(&quot;orbits.parquet&quot;)```See the [Arrowdocumentation](https://arrow.apache.org/docs/python/parquet.html) formore details on the Parquet format used.</longdescription>
</pkgmetadata>