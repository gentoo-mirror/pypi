<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>statprof - statistical profiling for Python===========================================This package provides a simple statistical profiler for Python.Python's default profiler has been `lsprof` for several years. This isan *instrumenting* profiler, which means that it saves data on everyaction of interest.  In the case of lsprof, it runs at function entryand exit.  This has problems: it can be expensive due to frequentsampling, and it is blind to hot spots *within* a function.In contrast, `statprof` samples the call stack periodically (bydefault, 1000 times per second), and it correctly tracks line numbers*inside* a function.  This means that if you have a 50-line functionthat contains two hot loops, `statprof` is likely to report them bothaccurately.&lt;b&gt;Note&lt;/b&gt;: This package does not yet work on Windows! See theimplementation and portability notes below for details.Basic usage-----------It's easy to get started with `statprof`:    import statprof    statprof.start()try:    my_questionable_function()    finally:    statprof.stop()statprof.display()For more comprehensive help, run `pydoc statprof`.Portability-----------Because `statprof` uses the Unix `itimer` signal facility, it does notcurrently work on Windows. (Patches to improve portability would bemost welcome.)Implementation notes--------------------The `statprof` profiler works by setting the Unix profiling signal`ITIMER_PROF` to go off after the interval you define in the call to`reset()`. When the signal fires, a sampling routine is run whichlooks at the current procedure that's executing, and then crawls upthe stack, and for each frame encountered, increments that frame'scode object's sample count.  Note that if a procedure is encounteredmultiple times on a given stack, it is only counted once. After thesampling is complete, the profiler resets profiling timer to fireagain after the appropriate interval.Meanwhile, the profiler keeps track, via `os.times()`, how much CPUtime (system and user -- which is also what `ITIMER_PROF` tracks), haselapsed while code has been executing within a `start()`/`stop()`block.The profiler also tries (as much as possible) to avoid counting ortiming its own code.History-------This package was originally[written and released by Andy Wingo](http://wingolog.org/archives/2005/10/28/profiling).It was ported to modern Python by Alex Frazer, and posted to github byJeff Muizelaar.  The current maintainer is Bryan O'Sullivan&lt;bos@serpentine.com&gt;.Reporting bugs, contributing patches------------------------------------The current maintainer of this package is Bryan O'Sullivan&lt;bos@serpentine.com&gt;.Please report bugs using the[github issue tracker](https://github.com/bos/statprof.py/issues).If you'd like to contribute patches, please do - the source is ongithub, so please just issue a pull request.    $ git clone git://github.com/bos/statprof.py</longdescription>
</pkgmetadata>