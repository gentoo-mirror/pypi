<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># FlaskCBV Installation manual## IntroductionFlaskCBV is Alternative Framework for working with flask with the class Based Views approach (CBV)The platform allows to implement a clear architecture based on the using of all the benefits of this approach;These framework are made in a style similar to Django:* to simplify its study* because the architecture of the Django looks elegant.We tried to make the minimum loaded wrapper for the flask, which does not require any special dependencies.## Features of use:Instead of the route decorator to define handlers we are using urls.py with the description of the scheme and with ability: * using includes* the splitting of the namespace for each applicationAs a configuration file for flaskcbv used the &quot;settings&quot; module;There's also a separate settings module is specifically flask;## Dependences:*  setuptools*  Flask*  Werkzeug*  Jinja2*  MarkupSafe## Installation and setup:1. Install framework using pip:$ sudo pip install flaskcbv  The required dependencies will be installed automatically.2. Create a directory of your project:$ mkdir project; cd project3. Create project using flaskcbv utility:$ flaskcbv initproject  The project will be created in the current directory4. Start server:$ cd apps;$ python start.py  The server starts by default on port 55555. Try the server using your browser or telnet(in a separate shell), for e.g:$ telnet localhost 5555Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.GET / HTTP/1.0HTTP/1.0 200 OKContent-Type: text/html; charset=utf-8Content-Length: 22server: my WEB ServerDate: Fri, 10 Jun 2016 21:57:46 GMTIt works on FlaskCBV! Connection closed by foreign host.Project is works, have fun:)## THE DIRECTORY STRUCTUREIn the generated project by default there are two directories:*  apps/ - there are placed the applications of project and modules required to run*  settings/ - flaskcbv settings moduleLet us consider separately each of the directories:### Directory: settings/*  __init__.py - this module contains the base settings of the framework*  local.py    - this module is included to the __init__.py, it is necessary for that would allocate the settings concerning the used development instance.#### For example:In __init__ you can set up base settings such as the application set, the default headers and so on;In local.py you can set/override the database connection settings, the paths to templates, etc...Then if you move project to other instance you can change local.py using a Makefile or other method of automatic creating from prototypes;it is convenient to push &quot;__init__&quot; into the repository.If desired, the entire directory of settings can be replaced by settings.py, this is not affect to the framework working;### Directory: apps/*  start.py - it is a runnable program, it is necessary to start the server in test mode.             in this program, are automatically assigned port, and absolute path to the project;             based on this program you can easily create the front-end wsgi.py*  project.py - module which creates a flask app using flaskcbv;*  flaskconfig.py - a module which sets configuration variables of the Flask;*  urls.py - module which describes the main namespaces and handlers(urls) of the projectHere placed the default app: &quot;main&quot;, which makes output on request:  &quot;It works on FlaskCBV!&quot;*  main/urls.py - included to the main urls.py module*  main/views.py - the module contains a view mainView, here also sets the template which is used to output to the user.*  main/templates/main/index.tpl - template of &quot;main&quot; application;For the successful work of application &quot;main&quot; it placed to the settings module in the APPLICATIONS tuple;Try to play with project, to withdraw its templates and to write any mixins.Now you can use Flask with CBV approachHave fun!:)regards, procool@## FlaskCBV Examples:### Simple implementation of json server:from flaskcbv.response import Responsefrom flaskcbv.view.mixins import JSONMixinfrom flaskcbv.view import Viewclass JSONView(JSONMixin, View):    def get_json_indent(self):        return self.__json_indent    def dispatch(self, request, *args, **kwargs):        try: self.__json_indent = int(request.args['json_indent'])        except: self.__json_indent = None        r = super(JSONView, self).dispatch(request, *args, **kwargs)        ## Return context as json         return Response(self.get_as_json())class myJsonView(JSONView):    def get_context_data(self, **kwargs):        return {'some': 'var'}&quot;&quot;&quot;when processing myJsonView the client will receive:{    &quot;errno&quot;: 0,    &quot;error&quot;: &quot;OK&quot;,    &quot;details&quot;: &quot;&quot;,    &quot;some&quot;: &quot;var&quot;}&quot;&quot;&quot;### Example of checking user session (implementation LoginRequiredMixin):import loggingimport werkzeug.exceptions as exfrom flask import request, session, abortfrom flaskcbv.view.mixins import JSONMixin, getArgumentMixinfrom flaskcbv.response import Responsefrom .models import Auth## Mixin with session validate methods:class AuthedMixin(object):    def test_for_user(self):        ## Try to get session from query parameters:        try: session_= self.request.args['session']        except: session_ = None        ## Try to get session from flask.session (cookies)        if session_ is None:            try: session_=session['session']            except: session_= None        ## No session, return 401:        if session_ is None:            abort(401)        ## Check the session, find the user:        try:            request.user = Auth.session(session_)            session['session'] = session_        except Exception as err:            request.user = None## Check session Mixinclass _LoginRequiredMixin(object):    def prepare(self, *args, **kwargs):        ## The only type of exception - abort        self.test_for_user()        ## The session was found but it's wrong(or user not found):        if request.user is None:            abort(403)        return super(_LoginRequiredMixin, self).prepare(*args, **kwargs)class LoginRequiredMixin(_LoginRequiredMixin, AuthedMixin):    passNow, mixing in LoginRequiredMixin to any view, before the dispatch we have carried out the test of session### An example of a forwarding context variables to the template:import loggingimport datetimefrom flaskcbv.view import TemplateViewfrom settings import STATIC_URL## Provide context varialbes from project settingsclass defaultSettingsMixin(object):    def get_context_data(self, **kwargs):        context = super(defaultSettingsMixin, self).get_context_data(**kwargs)        context['STATIC_URL'] = STATIC_URL        return contextclass myTemplateView(defaultSettingsMixin, TemplateView):    passNow, inheriting myTemplateView in context variables STATIC_URL is set from the settings;### Example of creating and using the template tag(jinja extention):The classes of template tags should be placed into the directory templatetags located in the root directory of the project;*Create a directory:$ cd myproject$ lsapps  assets  settings  templates$ mkdir templatetags; cd templatetags$ touch __init__.pyLet us create, for example, mytags.py in which:# encoding: utf8from jinja2 import nodesfrom jinja2.ext import Extension## This extension will return the type of the given attribute any of the specified objectclass ObjectAttrTypeExtension(Extension):    ## If this attribute is not defined or is False or None, the extension will not be taken into account when running:    enabled=True    tags = set(['attrtype'])    def __init__(self, environment):        super(ListSortedExtension, self).__init__(environment)        # add the defaults to the environment        environment.extend(            fragment_cache_prefix='',            fragment_cache=None        )    def parse(self, parser):        lineno = next(parser.stream).lineno        # now we parse a single expression that is used as cache key.        args = [parser.parse_expression()]        if parser.stream.skip_if('comma'):            args.append(parser.parse_expression())        else:            args.append(nodes.Const(None))        return nodes.CallBlock(self.call_method('_empty', args),                               [], [], &quot;&quot;).set_lineno(lineno)    def _empty(self, obj, attr, caller):        try:            return &quot;%s&quot; % type(getattr(obj, attr))        except Exception as err:            pass        return u''At the start flaskcbv will automatically load the tag and it will be available for using in templates;There is an Example:{% attrtype request, 'method' %} - returns: &quot;&lt;type 'str'&gt;&quot;Read more about jinja2 extentions:http://jinja.pocoo.org/docs/dev/extensions/### Example of FlaskCBV Forms:## Simple form:from flaskcbv.forms import Formclass myFormClass(Form):    def clean_test_passed(self, val):        ## self.cleaned_data['test_passed'] value will be 'passed'         ## self.data['test_passed'] value will be val        return 'passed'          def clean_test_error(self, val):        ## self.data['test_error'] value will be val        ## there is no key 'test_error' in self.cleaned_data        ## self.errors['test_error'] will be: 'Some Error' Exception        raise Exception('Some Error')from flaskcbv.view.crud import FormViewMixinfrom flaskcbv.view import TemplateViewclass myFormView(FormViewMixin, TemplateView):    template='index/some.tpl'    form_class = myFormClass    ## Uncomment this, if you want default redirect:    #form_success_url = '/action/success/'    #form_unsuccess_url = '/action/unsuccess/'    ## Custom url for form success action:    #def get_from_success_url(self):    #    return &quot;/some/other/success/url&quot;    ## Here, on GET client recv's our template, where in context var.: 'form' we can access to cleaned form variables;    ## Let's Redefine POST processing:    def post(self, *args, **kwargs):        ## Create our form object:        form = self.get_form()         ## Check form, this will run form.clean that will start 'clean_ATTR' methods, like in django        if form.validate():            ## By default it's a redirect to self.form_success_url or self.get_from_success_url():             return self.form_valid(form)        else:            ## By default returns template with 'form' context variable:            return self.form_invalid(form)</longdescription>
</pkgmetadata>