<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># CIDR-Bottle![Release Badge](https://gitlab.com/geoip.network/cidr_bottle/-/badges/release.svg)![Pipeline Badge](https://gitlab.com/geoip.network/cidr_bottle/badges/main/pipeline.svg)CIDR-Bottle is yet another implementation of a Patricia Trie for handling network routing information (such as ROAs &amp; Routing Tables) for reconciliation.However, unlike other implementations it supports both sub-tree checking and longest-prefix matching.![An attractive screenshot of the example code below](https://gitlab.com/geoip.network/cidr_bottle/-/raw/a57fe64864d8b05d71dde9ba32687319ca4fdbb8/screenshots/screenshot.png)CIDR-Bottle was designed specifically to be used for reconciling RIR Allocation &amp; Assignment records with actual BGP Announcements.It isn't designed to be the fastest (it's written in pure python), but it should be the most full-featured implementation. That said, unless you're writing a routing engine in python (in which case I'd be really interested to know why), speed shouldn't be a significant issue.## Dependencies* [CIDR-Man](https://pypi.org/project/cidr-man/) *Thwip, Thwip!*## Usage### InitialisationBy default, a CIDR-Bottle is in IPv4 mode, to use IPv6 mode you must supply an IPv6 CIDR.The root Bottle does not need to be the entire IP space, it can be any subnet.```pythonfrom cidr_bottle import Bottlefrom ipaddress import IPv4Network, IPv6Network## Defaults to IPv4root = Bottle()  # 0.0.0.0/0## IPv6 mode is initialised by passing an IPv6 CIDR (either as an instance of ipaddress.IPv6Network) root6 = Bottle(prefix=IPv6Network(&quot;::/0&quot;))  # ::/0## Supports detached (not starting at either 0.0.0.0/0 or ::/0) rootsdetached_root = Bottle(prefix=IPv4Network(&quot;198.51.100.0/24&quot;))```### Racking a Bottle (Inserting a node)```python## Supports insert with strroot.insert(&quot;198.51.100.0/24&quot;)## Supports insert with instances of ipaddress.IPv4Networkroot.insert(IPv4Network(&quot;198.51.100.0/24&quot;))## Supports insert with instances of ipaddress.IPv6Networkroot.insert(IPv6Network(&quot;2001:db8::/48&quot;))## Supports attaching any json serializable objects to nodes **This is important for future planned releases**root.insert(&quot;198.51.100.0/24&quot;, {&quot;example&quot;: &quot;dict&quot;})root.insert(&quot;198.51.100.0/24&quot;, &quot;string example&quot;)## Supports automatic aggregation on insert.root.insert(CIDR(&quot;192.0.2.128/25&quot;), value=&quot;a&quot;)root.insert(CIDR(&quot;192.0.2.0/25&quot;), value=&quot;b&quot;, aggregate=True)root.insert(CIDR(&quot;192.0.3.0/24&quot;), value=&quot;c&quot;, aggregate=True)if root.get(CIDR(&quot;192.0.2.0/23&quot;)).value == &quot;c&quot;:      ## This will evaluate as True as the two /25's will trigger the creation of the /24 and the addition of the other adjacent /24    ## will trigger the creation of the /23 ## Supports dict-style indexingroot[&quot;198.51.100.0/24&quot;] = &quot;string example&quot;```*Note: Setting `aggregate=True` will (if`node.parent.left` and `node.parent.right` are populated) insert the node as normal, automatically set the parent object to `passing=False`, and copy the `value` from the current insert to the `parent`.* ### Contains CIDR?Returns `True` where there is a covering prefix, otherwise false.*NOTE: This means that it returns true 100% of the time when the root is `0.0.0.0/0` or `::/0`*```pythonif &quot;198.51.100.0/24&quot; in root:    ## do something### orif root.contains(&quot;198.51.100.0/24&quot;):    ## do something```You can enforce exact matches by passing `exact=True` to the `contains` method.```pythonif not root.contains(&quot;198.51.100.128/25&quot;, exact=True):    ## do something```### Drinking a Bottle (Get node)This will return a matching covering prefix if present. In the case of a detached root, this means that it can return `None` if no such covering prefix exists.*NOTE: This is longest prefix matching*```pythonprint(root[&quot;198.51.100.0/24&quot;])### orprint(root.get(&quot;198.51.100.0/24&quot;))```Similar to the `.contains(...)` method, you can enforce exact matches by passing `exact=True` to the `get` method. This will raise a `KeyError` if there is no exact match.```pythonprint(root.get(&quot;198.51.100.128/25&quot;), exact=True)  # will raise a KeyError(&quot;no exact match found&quot;)```### Children / Sub-Tree checkingWith CIDR-Bottle you can retrieve all the defined children of a bottle(node).```pythonroot.insert(&quot;198.51.100.0/25&quot;)root.insert(&quot;198.51.100.128/25&quot;)print(root[&quot;198.51.100.0/24&quot;].children())```### Smashing bottles (Deleting Nodes)Deleting an edge node removes it completely.Deleting an intermediate node, converts it into a &quot;passing&quot; node, and does not affect any descendants of that node.```pythondel root[&quot;198.51.100.0/24&quot;]### orroot.delete(&quot;198.51.100.0/24&quot;)```## *More Speed*If you want to squeeze out every last drop of performance and don't mind the limitation of being forced to use [CIDR-Man's](https://pypi.org/project/cidr-man/) `CIDR` then you can use `FastBottle` instead of `Bottle`.## Installation (from pip):```shellpip install cidr_bottle```## Installation (from source):```shellgit clone https://gitlab.com/geoip.network/cidr_bottlepoetry install```</longdescription>
</pkgmetadata>