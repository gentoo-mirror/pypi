<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Data Spec=========.. image:: https://img.shields.io/pypi/v/dataspec.svg?style=flat-square   :target: https://pypi.org/project/dataspec/   :alt: Package (on PyPI).. image:: https://img.shields.io/pypi/pyversions/dataspec.svg?style=flat-square   :target: https://pypi.org/project/dataspec/   :alt: Supported Python Versions.. image:: https://img.shields.io/pypi/implementation/dataspec.svg?style=flat-square   :target: https://pypi.org/project/dataspec/   :alt: Supported Python Implementations.. image:: https://img.shields.io/circleci/project/github/coverahealth/dataspec/master.svg?style=flat-square   :target: https://circleci.com/gh/coverahealth/dataspec   :alt: Build Status (on CircleCI).. image:: https://img.shields.io/readthedocs/dataspec?style=flat-square   :target: https://dataspec.readthedocs.io/   :alt: Documentation (on ReadTheDocs).. image:: https://img.shields.io/github/license/coverahealth/dataspec.svg?style=flat-square   :target: https://github.com/coverahealth/dataspec/blob/master/LICENSE   :alt: MIT LicenseDataspec is a data specification and normalization toolkit written in pure Python.With Dataspec, you can create Specs to validate and normalize data of almost anyshape. Dataspec is inspired by Clojure's `spec &lt;https://clojure.org/guides/spec&gt;`_library.What are Specs?---------------Specs are declarative data specifications written in pure Python code. Specs can becreated using the generic Spec constructor function ``s``. Specs provide two useful andrelated functions. The first is to evaluate whether an arbitrary data structuresatisfies the specification. The second function is to conform (or normalize) validdata structures into a canonical format.The simplest Specs are based on common predicate functions, such as``lambda x: isinstance(x, str)`` which asks &quot;Is the object x an instance of ``str``?&quot;.Fortunately, Specs are not limited to being created from single predicates. Specs canalso be created from groups of predicates, composed in a variety of useful ways, andeven defined for complex data structures. Because Specs are ultimately backed bypure Python code, any question that you can answer about your data in code can beencoded in a Spec.Features--------* Simple API using primarily native Python types and data structures* Stateless, immutable Spec objects are designed to be created once, reused, and composed* Rich error objects point to the exact location of the error in the input value* Builtin factories for many common validationsInstallation------------Dataspec is developed on `GitHub &lt;https://github.com/coverahealth/dataspec&gt;`_ and hostedon `PyPI &lt;https://pypi.org/project/dataspec/&gt;`_. You can fetch Dataspec using ``pip``:.. code-block:: bash   pip install dataspecTo enable support for phone number specs or arbitrary date strings, you can choose theextras when you install:.. code-block:: bash   pip install dataspec[dates]   pip install dataspec[phonenumbers]Getting Started---------------To begin using the ``dataspec`` library, you can simply import the ``s`` object:.. code-block:: python   from dataspec import s``s`` is a generic constructor for creating new Specs. Many useful Specs can becomposed from basic Python objects like types, functions, and data structures. The&quot;Hello, world!&quot; equivalent for creating new Specs might be a simple Spec that validatesthat an input is a string (a Python ``str`` ). We can do this by simply passing thePython ``str`` type directly to ``s``. When ``s`` receives an instance of a ``type``object, it assumes you want to create a Spec that validates input values are of thattype:.. code-block:: python   spec = s(str)   spec.is_valid(&quot;a string&quot;)  # True   spec.is_valid(3)           # FalseOften you want to assert more than one condition on an input value. After all, it'sfairly trivial to assert type checks on a value. In fact, this may even be done bya deserialization library on your behalf. Perhaps you're interested in checking thatyour input is a string and that it contains only numbers and hyphens. ``dataspec`` letsyou define Specs with boolean logic, which can be useful for asserting multipleconditions on your input:.. code-block:: python   spec = s.all(str, lambda s: all(c.isdecimal() or c == &quot;-&quot; for c in s))   spec.is_valid(&quot;212-867-5309&quot;)     # True   spec.is_valid(&quot;Philip Jennings&quot;)  # FalseComposition is at the heart of ``dataspec`` 's design. In the previous example, welearned a few useful things. First, ``s`` is actually a callable object with staticmethods which help produce other sorts of Specs. Second, we can see that when wepass objects understood to ``s`` into various Spec constructors, they are automaticallycoerced into the appropriate Spec type. Here, we passed a ``type``, which we usedpreviously. We also passed in a function of one argument returning a boolean; in``dataspec``, these are called predicates and they are turned into Specs which validateinput values if the function returns ``True`` and fail otherwise. Finally, we learnedthat ``s.all`` can be used to produce ``and`` -type boolean logic between differentSpecs. (You can produce ``or`` Specs using ``s.any``).In the previous example, we used the ``and`` logic to check for our conditions to showvarious different features of ``dataspec``. However, in real code you'd likely takeadvantage of ``dataspec`` 's builtin ``s.str`` factory, which can assert several usefulproperties of strings (in addition to the basic ``isinstance`` check). In the caseabove, perhaps we really wanted to check for a US ZIP code (with the trailing 4 digits).We can perform that check using a simple regex string validator:.. code-block:: python   spec = s.str(&quot;us_zip_plus_4&quot;, regex=r&quot;\d{5}\-\d{4}&quot;)   spec.is_valid(&quot;10001-3093&quot;)  # True   spec.is_valid(&quot;10001&quot;)       # False   spec.is_valid(&quot;N0L 1E0&quot;)     # FalseScalar Specs like the one above are trivially different from the same checks you couldwrite in raw Python. The real power of ``dataspec`` comes from its ability to composeSpecs for larger, nested data structures. Suppose you were accepting a physicianprofile object via a JSON API and you wanted to validate that the physician licenseswere valid in all of the states you operate in:.. code-block:: python   operating_states = s(&quot;operating_states&quot;, {&quot;CA&quot;, &quot;GA&quot;, &quot;NY&quot;})   license_states = s(&quot;license_states&quot;, [operating_states, {&quot;kind&quot;: list}])   license_states.is_valid([&quot;CA&quot;, &quot;NY&quot;])  # True   license_states.is_valid([&quot;SD&quot;, &quot;GA&quot;])  # False, you do not operate in South Dakota   license_states.is_valid({&quot;CA&quot;})        # False, as the input collection is a setIn the previous example, we learned a bit more about ``dataspec``. First, we can seethat Spec objects are designed to be reused. We declared ``operating_states`` as aseparate Spec from ``license_states`` with the intent that we could use it as acomponent of other Specs. Specs are immutable and stateless, so they can be reused inother Specs without issue. Next, we can see that we're expecting a collection, indicatedby the Python ``list`` wrapping ``operating_states`` in the ``license_states`` Spec.In particular, we are expecting exactly a ``list``, not a ``set`` or ``tuple``.Third, we are expecting a limited set of enumerated values, indicated by``operating_states`` being a ``set``. Values not in the set are rejected. ``dataspec``also supports using Python's ``Enum`` objects for defining enumerated types.We did declare two separate Specs and pass both to ``s`` directly. However, we couldhave declared the entire Spec inline and ``s`` would have converted each child valueinto a Spec automatically: ``s([{&quot;CA&quot;, &quot;GA&quot;, &quot;NY&quot;}, {&quot;kind&quot;: list}])`` .Building on the previous example, let's suppose we want to validate a simplifiedversion of that physician profile object. Spec is great for validating data at yourapplication boundaries. You can pass it your deserialized input values and it willhelp you ensure that you're receiving data in the shape your internal servicesexpect:.. code-block:: python   spec = s(       &quot;user-profile&quot;,       {           &quot;id&quot;: s.str(&quot;id&quot;, format_=&quot;uuid&quot;),           &quot;first_name&quot;: s.str(&quot;first_name&quot;),           &quot;last_name&quot;: s.str(&quot;last_name&quot;),           &quot;date_of_birth&quot;: s.str(&quot;date_of_birth&quot;, format_=&quot;iso-date&quot;),           s.opt(&quot;gender&quot;): s(&quot;gender&quot;, {&quot;M&quot;, &quot;F&quot;}),           &quot;license_states&quot;: license_states,  # using the previously defined Spec       }   )   spec.is_valid(  # True       {           &quot;id&quot;: &quot;e1bc9fb2-a4d3-4683-bfef-3acc61b0edcc&quot;,           &quot;first_name&quot;: &quot;Carl&quot;,           &quot;last_name&quot;: &quot;Sagan&quot;,           &quot;date_of_birth&quot;: &quot;1996-12-20&quot;,           &quot;license_states&quot;: [&quot;CA&quot;],       }   )   spec.is_valid(  # False; the optional &quot;gender&quot; key included an invalid value       {           &quot;id&quot;: &quot;e1bc9fb2-a4d3-4683-bfef-3acc61b0edcc&quot;,           &quot;first_name&quot;: &quot;Carl&quot;,           &quot;last_name&quot;: &quot;Sagan&quot;,           &quot;date_of_birth&quot;: &quot;1996-12-20&quot;,           &quot;gender&quot;: &quot;O&quot;,           &quot;license_states&quot;: [&quot;CA&quot;],       }   )   spec.is_valid(  # True; note that extra keys _are ignored_       {           &quot;id&quot;: &quot;958e2f55-5fdf-4b84-a522-a0765299ba4b&quot;,           &quot;first_name&quot;: &quot;Marie&quot;,           &quot;last_name&quot;: &quot;Curie&quot;,           &quot;date_of_birth&quot;: &quot;1867-11-07&quot;,           &quot;gender&quot;: &quot;F&quot;,           &quot;license_states&quot;: [&quot;NY&quot;, &quot;GA&quot;],           &quot;occupation&quot;: &quot;Chemist&quot;,       }   )   spec.is_valid(  # False; the &quot;license_states&quot; includes the invalid value &quot;TX&quot;       {           &quot;id&quot;: &quot;958e2f55-5fdf-4b84-a522-a0765299ba4b&quot;,           &quot;first_name&quot;: &quot;Marie&quot;,           &quot;last_name&quot;: &quot;Curie&quot;,           &quot;date_of_birth&quot;: &quot;1867-11-07&quot;,           &quot;license_states&quot;: [&quot;TX&quot;],       }   )``dataspec`` includes plenty of additional functionality which is not discussed above.Read more at `Read the Docs &lt;https://dataspec.readthedocs.io&gt;`_.Why not X?----------Python's ecosystem features a rich collection of data validation and normalizationtools, so a new entrant in the space naturally begs the question &quot;why didn't you justuse X instead?&quot;. Before creating Dataspec, we surveyed a wide variety of differenttools and had even used one or two in our production service. All of these tools aregenerally successful at validating data, but each had some issue that caused us topass.* Many of the libraries in this space primarily help validate data, but do not always  help you normalize or conform that data after it has been validated. Dataspec  provides validation and conformation out of the box.* Libraries which do feature validation and normalization often complect these two  steps. Dataspec validation is a discrete step that occurs before conformation, so  it is easy to reason about failures in validation.* Some of the libraries we tried were stateful or leaned too heavily on mutability.  We tend to prefer immutable and stateless objects where mutability and state is not  required. Specs in Dataspec are completely stateless and conformation always produces  a new value. This is certainly more costly than mutating inputs, but mutating code  is harder to reason about and is a major source of bugs, so we prefer to avoid it.* Many libraries we surveyed focused on defining validations from the top-down, rather  than encouraging composition. Specs in Dataspec are designed to be created once,  reused, and composed, rather than requiring a separate definition for each usage.License-------MIT License</longdescription>
</pkgmetadata>