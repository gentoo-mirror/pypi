<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># marshmallow-pyspark[![Build Status](https://travis-ci.com/ketgo/marshmallow-pyspark.svg?token=oCVxhfjJAa2zDdszGjoy&amp;branch=master)](https://travis-ci.com/ketgo/marshmallow-pyspark)[![codecov.io](https://codecov.io/gh/ketgo/marshmallow-pyspark/coverage.svg?branch=master)](https://codecov.io/gh/ketgo/marshmallow-pyspark/coverage.svg?branch=master)[![Apache 2.0 licensed](https://img.shields.io/badge/License-Apache%202.0-yellow.svg)](https://raw.githubusercontent.com/ketgo/marshmallow-pyspark/master/LICENSE)[Marshmallow](https://marshmallow.readthedocs.io/en/stable/) is a popular package used for data serialization and validation. One defines data schemas in marshmallow containing rules on how input data should be marshalled. Similar to marshmallow, [pyspark](https://spark.apache.org/docs/latest/api/python/index.html) also comes with its own schema definitions used to process data frames. This package enables users to utilize marshmallow schemas and its powerful data validation capabilities in pyspark applications. Such capabilities can be utilized in data-pipeline ETL jobs where data consistency and quality is of importance.## InstallThe package can be install using `pip`:```bash$ pip install marshmallow-pyspark```## UsageData schemas can can define the same way as you would using marshmallow. A quick example is shown below:```pythonfrom marshmallow_pyspark import Schemafrom marshmallow import fields# Create data schema.class AlbumSchema(Schema):    title = fields.Str()    release_date = fields.Date()# Input data frame to validate.df = spark.createDataFrame([    {&quot;title&quot;: &quot;valid_1&quot;, &quot;release_date&quot;: &quot;2020-1-10&quot;},    {&quot;title&quot;: &quot;valid_2&quot;, &quot;release_date&quot;: &quot;2020-1-11&quot;},    {&quot;title&quot;: &quot;invalid_1&quot;, &quot;release_date&quot;: &quot;2020-31-11&quot;},    {&quot;title&quot;: &quot;invalid_2&quot;, &quot;release_date&quot;: &quot;2020-1-51&quot;},])# Get data frames with valid rows and error prone rows # from input data frame by validating using the schema.valid_df, errors_df = AlbumSchema().validate_df(df)# Output of valid data framevalid_df.show()#    +-------+------------+#    |  title|release_date|#    +-------+------------+#    |valid_1|  2020-01-10|#    |valid_2|  2020-01-11|#    +-------+------------+# Output of errors data frameerrors_df.show()#    +--------------------+#    |             _errors|#    +--------------------+#    |{&quot;row&quot;: {&quot;release...|#    |{&quot;row&quot;: {&quot;release...|#    +--------------------+```### More OptionsOn top of marshmallow supported options, the `Schema` class comes with two additional initialization arguments:- `error_column_name`: name of the column to store validation errors. Default value is `_errors`.- `split_errors`: split rows with validation errors as a separate data frame from valid rows. When set to `False` the    rows with errors are returned together with valid rows as a single data frame. The field values of all error rows are    set to `null`. For user convenience the original field values can be found in the `row` attribute of the error JSON.    Default value is `True`. An example is shown below:```pythonfrom marshmallow import EXCLUDEschema = AlbumSchema(    error_column_name=&quot;custom_errors&quot;,     # Use 'custom_errors' as name for errors column    split_errors=False,                     # Don't split the input data frame into valid and errors    unkown=EXCLUDE                          # Marshmallow option to exclude fields not present in schema)# Input data frame to validate.df = spark.createDataFrame([    {&quot;title&quot;: &quot;valid_1&quot;, &quot;release_date&quot;: &quot;2020-1-10&quot;, &quot;garbage&quot;: &quot;wdacfa&quot;},    {&quot;title&quot;: &quot;valid_2&quot;, &quot;release_date&quot;: &quot;2020-1-11&quot;, &quot;garbage&quot;: &quot;5wacfa&quot;},    {&quot;title&quot;: &quot;invalid_1&quot;, &quot;release_date&quot;: &quot;2020-31-11&quot;, &quot;garbage&quot;: &quot;3aqf&quot;},    {&quot;title&quot;: &quot;invalid_2&quot;, &quot;release_date&quot;: &quot;2020-1-51&quot;, &quot;garbage&quot;: &quot;vda&quot;},])valid_df, errors_df = schema.validate_df(df)# Output of valid data frame. Contains rows with errors as# the option 'split_errors' was set to False.valid_df.show()#    +-------+------------+--------------------+#    |  title|release_date|             _errors|#    +-------+------------+--------------------+#    |valid_1|  2020-01-10|                    |#    |valid_2|  2020-01-11|                    |#    |       |            |{&quot;row&quot;: {&quot;release...|#    |       |            |{&quot;row&quot;: {&quot;release...|#    +-------+------------+--------------------+# The errors data frame will be set to Noneassert errors_df is None        # True```Lastly, on top of passing marshmallow specific options in the schema, you can also pass them in the `validate_df` method.These are options are passed to the marshmallow's `load` method:```pythonschema = AlbumSchema(    error_column_name=&quot;custom_errors&quot;,     # Use 'custom_errors' as name for errors column    split_errors=False,                     # Don't split the input data frame into valid and errors)valid_df, errors_df = schema.validate_df(df, unkown=EXCLUDE)```### DuplicatesMarshmallow-pyspark comes with the ability to validate one or more schema fields for duplicate values. This is achievedby adding the field names to the `UNIQUE` attribute of the schema as shown:```pythonclass AlbumSchema(Schema):    # Unique valued field &quot;title&quot; in the schema    UNIQUE = [&quot;title&quot;]    title = fields.Str()    release_date = fields.Date()# Input data frame to validate.df = spark.createDataFrame([        {&quot;title&quot;: &quot;title_1&quot;, &quot;release_date&quot;: &quot;2020-1-10&quot;},        {&quot;title&quot;: &quot;title_2&quot;, &quot;release_date&quot;: &quot;2020-1-11&quot;},        {&quot;title&quot;: &quot;title_2&quot;, &quot;release_date&quot;: &quot;2020-3-11&quot;},  # duplicate title        {&quot;title&quot;: &quot;title_3&quot;, &quot;release_date&quot;: &quot;2020-1-51&quot;},    ])# Validate data framevalid_df, errors_df = AlbumSchema().validate_df(df)    # List of valid rowsvalid_rows = [row.asDict(recursive=True) for row in valid_df.collect()]##   [#        {'title': 'title_1', 'release_date': datetime.date(2020, 1, 10)},#        {'title': 'title_2', 'release_date': datetime.date(2020, 1, 11)}#   ]## Rows with errorserror_rows = [row.asDict(recursive=True) for row in errors_df.collect()]# #   [#        {'_errors': '{&quot;row&quot;: {&quot;release_date&quot;: &quot;2020-3-11&quot;, &quot;title&quot;: &quot;title_2&quot;, &quot;__count__title&quot;: 2}, '#                    '&quot;errors&quot;: [&quot;duplicate row&quot;]}'},#        {'_errors': '{&quot;row&quot;: {&quot;release_date&quot;: &quot;2020-1-51&quot;, &quot;title&quot;: &quot;title_3&quot;, &quot;__count__title&quot;: 1}, '#                    '&quot;errors&quot;: {&quot;release_date&quot;: [&quot;Not a valid date.&quot;]}}'}#    ]#``` The technique to drop duplicates but keep first is discussed in this [link](https://stackoverflow.com/questions/38687212/spark-dataframe-drop-duplicates-and-keep-first).In case there are multiple unique fields in the schema just add them to the `UNIQUE`, e.g. `UNIQUE=[&quot;title&quot;, &quot;release_date&quot;]`. You can even specify uniqueness for combination of fields by grouping them in a list:```pythonclass AlbumSchema(Schema):    # Combined values of &quot;title&quot; and &quot;release_date&quot; should be unique    UNIQUE = [[&quot;title&quot;, &quot;release_date&quot;]]    title = fields.Str()    release_date = fields.Date()# Input data frame to validate.df = spark.createDataFrame([        {&quot;title&quot;: &quot;title_1&quot;, &quot;release_date&quot;: &quot;2020-1-10&quot;},        {&quot;title&quot;: &quot;title_2&quot;, &quot;release_date&quot;: &quot;2020-1-11&quot;},        {&quot;title&quot;: &quot;title_2&quot;, &quot;release_date&quot;: &quot;2020-3-11&quot;},        {&quot;title&quot;: &quot;title_3&quot;, &quot;release_date&quot;: &quot;2020-1-21&quot;},        {&quot;title&quot;: &quot;title_3&quot;, &quot;release_date&quot;: &quot;2020-1-21&quot;},        {&quot;title&quot;: &quot;title_4&quot;, &quot;release_date&quot;: &quot;2020-1-51&quot;},    ])# Validate data framevalid_df, errors_df = AlbumSchema().validate_df(df)    # List of valid rowsvalid_rows = [row.asDict(recursive=True) for row in valid_df.collect()]##   [#        {'title': 'title_1', 'release_date': datetime.date(2020, 1, 10)},#        {'title': 'title_2', 'release_date': datetime.date(2020, 1, 11)},#        {'title': 'title_3', 'release_date': datetime.date(2020, 1, 21)}#   ]## Rows with errorserror_rows = [row.asDict(recursive=True) for row in errors_df.collect()]# #   [#        {'_errors': '{&quot;row&quot;: {&quot;release_date&quot;: &quot;2020-1-21&quot;, &quot;title&quot;: &quot;title_3&quot;, '#                    '&quot;__count__title&quot;: 2, &quot;__count__release_date&quot;: 2}, '#                    '&quot;errors&quot;: [&quot;duplicate row&quot;]}'},#        {'_errors': '{&quot;row&quot;: {&quot;release_date&quot;: &quot;2020-1-51&quot;, &quot;title&quot;: &quot;title_4&quot;, '#                    '&quot;__count__title&quot;: 1, &quot;__count__release_date&quot;: 1}, '#                    '&quot;errors&quot;: {&quot;release_date&quot;: [&quot;Not a valid date.&quot;]}}'},#        {'_errors': '{&quot;row&quot;: {&quot;release_date&quot;: &quot;2020-3-11&quot;, &quot;title&quot;: &quot;title_2&quot;, '#                    '&quot;__count__title&quot;: 2, &quot;__count__release_date&quot;: 1}, '#                    '&quot;errors&quot;: [&quot;duplicate row&quot;]}'}#    ]#```**WARNING**: Duplicate check requires data shuffle per unique field. Having large number of unique fields will effect spark job performance. By default `UNIQUE` is set to an empty list preventing any duplicate checks. ### FieldsMarshmallow comes with a variety of different fields that can be used to define schemas. Internally marshmallow-pyspark convert these fields into pyspark SQL data types. The following table lists the supported marshmallow fields and their equivalent spark SQL data types:| Marshmallow | PySpark || --- | --- || `Raw` | user specified || `String` | `StringType` || `DateTime` | `TimestampType` || `Date` | `DateType` || `Boolean` | `BooleanType` || `Integer` | `IntegerType` || `Float` | `FloatType` || `Number` | `DoubleType` || `List` | `ArrayType` || `Dict` | `MapType` || `Nested` | `StructType` |By default the `StringType` data type is used for marshmallow fields not in the above table. The `spark_schema` propertyof your defined schema can be used to check the converted spark SQL schema:```python# Gets the spark schema for the Album schemaAlbumSchema().spark_schema# StructType(List(StructField(title,StringType,true),StructField(release_date,DateType,true),StructField(_errors,StringType,true)))```#### Custom FieldsMarshmallow_pyspark comes with support for an additional `Raw` field. The `Raw` field does not perform any formattingand requires the user to specify the spark data type associated with the field. See the following example:```pythonfrom marshmallow_pyspark import Schemafrom marshmallow_pyspark.fields import Rawfrom marshmallow import fieldsfrom pyspark.sql.types import DateTypefrom datetime import dateclass AlbumSchema(Schema):    title = fields.Str()    # Takes python datetime.date objects and treats them as pyspark DateType    release_date = Raw(spark_type=DateType())# Input data frame to validate.df = spark.createDataFrame([        {&quot;title&quot;: &quot;title_1&quot;, &quot;release_date&quot;: date(2020, 1, 10)},        {&quot;title&quot;: &quot;title_2&quot;, &quot;release_date&quot;: date(2020, 1, 11)},        {&quot;title&quot;: &quot;title_3&quot;, &quot;release_date&quot;: date(2020, 3, 10)},    ])# Validate data framevalid_df, errors_df = AlbumSchema().validate_df(df)    # List of valid rowsvalid_rows = [row.asDict(recursive=True) for row in valid_df.collect()]##   [#        {'title': 'title_1', 'release_date': datetime.date(2020, 1, 10)},#        {'title': 'title_2', 'release_date': datetime.date(2020, 1, 11)},#        {'title': 'title_3', 'release_date': datetime.date(2020, 3, 10)}#   ]## Rows with errorserror_rows = [row.asDict(recursive=True) for row in errors_df.collect()]# #   []#```It is also possible to add support for custom marshmallow fields, or those missing in the above table. In order to do so, you would need to create a converter for the custom field. The converter can be built using the `ConverterABC` interface:```pythonfrom marshmallow_pyspark import ConverterABCfrom pyspark.sql.types import StringTypeclass EmailConverter(ConverterABC):    &quot;&quot;&quot;        Converter to convert marshmallow's Email field to a pyspark         SQL data type.    &quot;&quot;&quot;    def convert(self, ma_field):        return StringType()```  The `ma_field` argument in the `convert` method is provided to handle nested fields. For an example you can checkout `NestedConverter`. Now the final step would be to add the converter to the `CONVERTER_MAP` attribute of your schema:```pythonfrom marshmallow_pyspark import Schemafrom marshmallow import fieldsclass User(Schema):    name = fields.String(required=True)    email = fields.Email(required=True)# Adding email converter to schema.User.CONVERTER_MAP[fields.Email] = EmailConverter# You can now use your schema to validate the input data frame.valid_df, errors_df = User().validate_df(input_df)```## DevelopmentTo hack marshmallow-pyspark locally run:```bash$ pip install -e .[dev]# to install all dependencies$ pytest --cov-config .coveragerc --cov=./# to get coverage report$ pylint marshmallow_pyspark# to check code quality with PyLint```Optionally you can use `make` to perform development tasks.## LicenseThe source code is licensed under Apache License Version 2.## ContributionsPull requests always welcomed! :)</longdescription>
</pkgmetadata>