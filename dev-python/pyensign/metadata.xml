<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># PyEnsignPyEnsign is the official Python SDK for [Ensign](https://rotational.io/ensign), a distributed event store and stream-processing platform. This library allows you to interact with the Ensign API directly from Python in order to create [publishers](https://ensign.rotational.dev/eventing/glossary/#publisher) and [subscribers](https://ensign.rotational.dev/eventing/glossary/#subscriber).## Installation```pip install pyensign```## UsageCreate a client from a client ID and client secret. If not provided, these will be obtained from the `ENSIGN_CLIENT_ID` and `ENSIGN_CLIENT_SECRET` variables.```pythonfrom pyensign.ensign import Ensignclient = Ensign(client_id=&lt;your client ID&gt;, client_secret=&lt;your client secret&gt;)```The `Event` class can be used to create events from the raw data and mimetype.```pythonfrom pyensign.events import Eventevent = Event(b'{&quot;temp&quot;: 72, &quot;units&quot;: &quot;fahrenheit&quot;}', &quot;application/json&quot;)```Publish events to a topic. This coroutine accepts one or more events, so the following uses are all valid.```pythonawait client.publish(&quot;weather&quot;, event)await client.publish(&quot;weather&quot;, event1, event2)await client.publish(&quot;weather&quot;, [event1, event2])```Publish is asynchronous. You should generally call `flush()` before your program exits to ensure that all events are published to the server.```python# Wait for events to be published with a default timeout of 2 seconds.await client.flush()```For more precision, you can wait for individual events to be acked by the server.```pythonack = await event.wait_for_ack()print(ack)```Subscribe to one or more topics by providing the topic name(s) or ID(s).```pythonasync for event in client.subscribe(&quot;weather&quot;):    print(&quot;Received event with data: {}&quot;.format(event.data))    await event.ack()```## Advanced UsageThe `publish` coroutine accepts asynchronous callbacks so the client can distinguish between committed and uncommitted events. Callbacks are invoked when acks and nacks are received from the server and the first argument passed to the callback is the `Ack` or `Nack` itself. An `Ack` contains a committed timestamp. A `Nack` is returned if the event couldn't be committed and contains the ID of the event along with an error describing what went wrong.```pythonasync def handle_ack(self, ack):    ts = datetime.fromtimestamp(ack.committed.seconds + ack.committed.nanos / 1e9)    print(f&quot;Event committed at {ts}&quot;)async def handle_nack(self, nack):    print(f&quot;Could not commit event {nack.id} with error {nack.code}: {nack.error}&quot;)await client.publish(&quot;weather&quot;, event, on_ack=handle_ack, on_nack=handle_nack)```</longdescription>
</pkgmetadata>