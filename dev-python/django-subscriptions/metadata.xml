<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># django-subscriptionsA django package for managing the status and terms of a subscription.[![PyPI version](https://badge.fury.io/py/django-subscriptions.svg)](https://badge.fury.io/py/django-subscriptions)[![CircleCI (all branches)](https://img.shields.io/circleci/project/github/kogan/django-subscriptions.svg)](https://circleci.com/gh/kogan/django-subscriptions)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)![PyPI - License](https://img.shields.io/pypi/l/django-subscriptions.svg?style=popout)## Compatibility- Django: 2.2 (LTS versions only)- Python: 3.6+Other Django or Python versions **may** work, but that is totally cooincidentaland no effort is made to maintain compatibility with versions other than thoselisted above.## Installation```bash$ pip install django-subscriptions```Then add the following packages to `INSTALLED_APPS` in your settings:```INSTALLED_APPS = [    ...    &quot;django_fsm_log&quot;,    &quot;subscriptions.apps.SubscriptionsConfig&quot;,    ...]```And of course, you'll need to run the migrations:```$ python manage.py migrate```You'll also need to setup the triggers, which can be scheduled with celery orrun from a management task. See the [Triggers](#triggers) section below.## DesignManages subscriptions in a single table. Pushes events (signals) so thatconsumers can do the actual work required for that subscription, like billing.Subscriptions are built around a Finite State Machine model, where states andallowed transitions between states are well defined on the Model. To update fromone state to another, the user calls methods on the Subscription instance. Thisway, all side-effects and actions are contained within the state methods.Subscription State must not be modified directly.When a state change is triggered, the subscription will publish relevant signalsso that interested parties can, themselves, react to the state changes.![State Diagram](subscriptions-state-diagram.png)## APIThere are 3 major API components. State change methods, signals/events, and thetriggers used to begin the state changes.### State Methods| Method                                         | Source States                   | Target State | Signal Emitted       ||------------------------------------------------|---------------------------------|--------------|----------------------|| `cancel_autorenew()`                           | ACTIVE                          | EXPIRING     | `autorenew_canceled` || `enable_autorenew()`                           | EXPIRING                        | ACTIVE       | `autorenew_enabled`  || `renew()`                                      | ACTIVE,SUSPENDED                | RENEWING     | `subscription_due`   || `renewed(new_end, new_ref, description=None)`  | ACTIVE,RENEWING,ERROR            | ACTIVE       | `subscription_renewed`|| `renewal_failed(description=None)`         | RENEWING,ERROR                  | SUSPENDED    | `renewal_failed`     || `end_subscription(description=None)`           | ACTIVE,SUSPENDED,EXPIRING,ERROR | ENDED        | `subscription_ended` || `state_unknown(description=None)`             | RENEWING                        | ERROR        | `subscription_error` |Example:`subscription.renew()` may only be called if `subscription.state` is either `ACTIVE` or `SUSPENDED`,and will cause `subscription.state` to move into the `RENEWING` state.The `description` argument is a string that can be used to persist the reason for a statechange in the `StateLog` table (and admin inlines).### TriggersThere are a bunch of triggers that are used to update subscriptions as they becomedue or expire. Nothing is configured to run these triggers by default. You caneither call them as part of your own process, or use `celery beat` to executethe triggers using the tasks provided in `subscriptions.tasks`.Create a new subscription:```Subscription.objects.add_subscription(start_date, end_date, reference) -&gt; Subscription```Trigger subscriptions that are due for renewal:```Subscription.objects.trigger_renewals() -&gt; int  # number of renewals sent```Trigger subscriptions that are due to expire:```Subscription.objects.trigger_expiring() -&gt; int  # number of expirations```Trigger subscriptions that are suspended:```Subscription.objects.trigger_suspended() -&gt; int  # number of renewals```Trigger subscriptions that have been suspended for longer than `timeout_hours` toend (uses `subscription.end` date, not `subscription.last_updated`):```Subscription.objects.trigger_suspended_timeout(timeout_hours=48) -&gt; int  # number of suspensions```Trigger subscriptions that have been stuck in renewing state for longer than `timeout_hours`to be marked as an error (uses `subscription.last_updated` to determine the timeout):```Subscription.objects.trigger_stuck(timeout_hours=2) -&gt; int  # number of error subscriptions```If `settings.SUBSCRIPTIONS_STUCK_RETRY` is `True`, then subscriptions are moved back intothe `SUSPENDED` state, ready to be retried. This can be useful when you have an offlineprocess that can resolve stuck subscription issues, and there is no issue retrying thesubscription.### TasksThe following tasks are defined but are not scheduled:```subscriptions.tasks.trigger_renewalssubscriptions.tasks.trigger_expiringsubscriptions.tasks.trigger_suspendedsubscriptions.tasks.trigger_suspended_timeoutsubscriptions.tasks.trigger_stuck```If you'd like to schedule the tasks, do so with a celery beat configuration like this:```# settings.pyCELERYBEAT_SCHEDULE = {    &quot;subscriptions_renewals&quot;: {        &quot;task&quot;: &quot;subscriptions.tasks.trigger_renewals&quot;,        &quot;schedule&quot;: crontab(hour=0, minute=10),    },    &quot;subscriptions_expiring&quot;: {        &quot;task&quot;: &quot;subscriptions.tasks.trigger_expiring&quot;,        &quot;schedule&quot;: crontab(hour=0, minute=15),    },    &quot;subscriptions_suspended&quot;: {        &quot;task&quot;: &quot;subscriptions.tasks.trigger_suspended&quot;,        &quot;schedule&quot;: crontab(hour=&quot;3,6,9&quot;, minute=30),    },    &quot;subscriptions_suspended_timeout&quot;: {        &quot;task&quot;: &quot;subscriptions.tasks.trigger_suspended_timeout&quot;,        &quot;schedule&quot;: crontab(hour=0, minute=40),        &quot;kwargs&quot;: {&quot;hours&quot;: 48},    },    &quot;subscriptions_stuck&quot;: {        &quot;task&quot;: &quot;subscriptions.tasks.trigger_stuck&quot;,        &quot;schedule&quot;: crontab(hour=&quot;*/2&quot;, minute=50),        &quot;kwargs&quot;: {&quot;hours&quot;: 2},    },}```## ContributingWe use `pre-commit &lt;https://pre-commit.com/&gt;` to enforce our code style ruleslocally before you commit them into git. Once you install the pre-commit library(locally via pip is fine), just install the hooks::    pre-commit install -f --install-hooksThe same checks are executed on the build server, so skipping the local linting(with `git commit --no-verify`) will only result in a failed test build.Current style checking tools:- flake8: python linting- isort: python import sorting- black: python code formattingNote:    You must have python3.6 available on your path, as it is required for some    of the hooks.## Generating MigrationsAfter installing all dependencies, you can generate required migration fileslike so:```bash$ poetry run ipython migrate.py &lt;nameofmigration&gt;```## Publishing a new version1. Bump the version number in pyproject.toml and src/subscriptions/init.py2. Commit and push to master3. From github, [create a new release](https://github.com/kogan/django-subscriptions/releases)4. Name the release &quot;v&lt;maj.minor.patch&gt;&quot; using the version number from step 1.5. Publish the release6. If the release successfully builds, circleci will publish the new package to pypi</longdescription>
</pkgmetadata>