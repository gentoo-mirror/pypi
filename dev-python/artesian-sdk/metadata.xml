<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Artesian.SDKThis Library provides read access to the Artesian API## Getting Started### InstallationYou can install the package directly from [pip](https://pypi.org/project/artesian-sdk/).```Pythonpip install artesian-sdk```Alternatively, to install this package go to the [release page](https://github.com/ARKlab/Artesian.SDK-Python/releases) .### How to useThe Artesian.SDK instance can be configured using API-Key authentication```Pythonfrom Artesian import ArtesianConfigcfg = ArtesianConfig(&quot;https://arkive.artesian.cloud/{tenantName}/&quot;, &quot;{api-key}&quot;)```## BREAKING CHANGES: Upgrade v2-&gt;v3The following breaking changes has been introduced in v3 respect to v2.### Python Version &gt;=3.8Python &gt;=3.8 is **required**.Python 3.7 is not supported due missing 'typing' features.### SubPackagingWith Artesian-SDK v3 we introduced SubPkg to split the different part of the library. The new SubPkg are:- Artesian.Query: contains all classes for querying Artesian data.- Artesian.GMEPublicOffers: contains all classes for querying GME Public Offers- **(NEW)** Artesian.MarketData: contains all classes to interact with the MarketData registry of Artesian. Register a new MarketData, change its Tags, etc. See documentation below.To upgrade is enough to prefix the QueryService with 'Query.' or import it from Artesian.Query.Were was used:```Pythonfrom Artesian import *cfg = ArtesianConfig(&quot;https://arkive.artesian.cloud/{tenantName}/&quot;, &quot;{api-key}&quot;)qs = QueryService(cfg)```now you have to:```Pythonfrom Artesian import ArtesianConfigfrom Artesian.Query import QueryServicecfg = ArtesianConfig(&quot;https://arkive.artesian.cloud/{tenantName}/&quot;, &quot;{api-key}&quot;)qs = QueryService(cfg)```### Enum entries CasingTo align the casing of the entries of the Enum, we adopted PascalCase to align it with the Artesian API.Where before was used```Python  .inGranularity(Granularity.HOUR) \```now is```Python  .inGranularity(Granularity.Hour) \```## MarketData QueryServiceUsing the ArtesianConfig `cfg` we create an instance of the QueryService which is used to create Actual, Versioned and Market Assessment time series queries### Actual Time Series Extraction```Pythonfrom Artesian import ArtesianConfig, Granularityfrom Artesian.Query import QueryService, RelativeIntervalcfg = ArtesianConfig(&quot;https://arkive.artesian.cloud/{tenantName}/&quot;, &quot;{api-key}&quot;)qs = QueryService(cfg)data = qs.createActual() \    .forMarketData([100011484,100011472,100011477,100011490,100011468,100011462,100011453]) \    .inAbsoluteDateRange(&quot;2018-01-01&quot;,&quot;2018-01-02&quot;) \    .inTimeZone(&quot;UTC&quot;) \    .inGranularity(Granularity.Hour) \    .execute()print(data)```To construct an Actual Time Series Extraction the following must be provided.&lt;table&gt;  &lt;tr&gt;&lt;th&gt;Actual Query&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Market Data ID&lt;/td&gt;&lt;td&gt;Provide a market data id or set of market data id's to query&lt;/td&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Time Granularity&lt;/td&gt;&lt;td&gt;Specify the granularity type&lt;/td&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Time Extraction Window&lt;/td&gt;&lt;td&gt;An extraction time window for data to be queried&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;[Go to Time Extraction window section](#artesian-sdk-extraction-windows)### Versioned Time Series Extraction```Pythonfrom Artesian import ArtesianConfig, Granularityfrom Artesian.Query import QueryService, RelativeIntervalqs = QueryService(cfg)q = qs.createVersioned() \    .forMarketData([100042422,100042283,100042285,100042281,100042287,100042291,100042289]) \    .inAbsoluteDateRange(&quot;2018-01-01&quot;,&quot;2018-01-02&quot;) \    .inTimeZone(&quot;UTC&quot;) \    .inGranularity(Granularity.Hour)print(q)ret = q.forMUV().execute()print(ret)ret = q.forLastNVersions(2).execute()print(ret)ret = q.forLastOfDays(&quot;2019-03-12&quot;,&quot;2019-03-16&quot;).execute()print(ret)ret = q.forLastOfDays(&quot;P0Y0M-2D&quot;,&quot;P0Y0M2D&quot;).execute()print(ret)ret = q.forLastOfDays(&quot;P0Y0M-2D&quot;).execute()print(ret)ret = q.forLastOfMonths(&quot;2019-03-12&quot;,&quot;2019-03-16&quot;).execute()print(ret)ret = q.forLastOfMonths(&quot;P0Y-1M0D&quot;,&quot;P0Y1M0D&quot;).execute()print(ret)ret = q.forLastOfMonths(&quot;P0Y-1M0D&quot;).execute()print(ret)ret = q.forVersion(&quot;2019-03-12T14:30:00&quot;).execute()print(ret)ret = q.forMostRecent(&quot;2019-03-12&quot;,&quot;2019-03-16&quot;).execute()print(ret)ret = q.forMostRecent(&quot;2019-03-12T12:30:05&quot;,&quot;2019-03-16T18:42:30&quot;).execute()print(ret)ret = q.forMostRecent(&quot;P0Y0M-2D&quot;,&quot;P0Y0M2D&quot;).execute()print(ret)ret = q.forMostRecent(&quot;P0Y0M-2D&quot;).execute()print(ret)ret = q.forMostRecent(&quot;2019-03-12&quot;,&quot;2019-03-16&quot;).execute()print(ret)ret = q.forMostRecent(&quot;P0Y-1M0D&quot;,&quot;P0Y1M0D&quot;).execute()print(ret)ret = q.forMostRecent(&quot;P0Y-1M0D&quot;).execute()print(ret)```To construct a Versioned Time Series Extraction the following must be provided.&lt;table&gt;  &lt;tr&gt;&lt;th&gt;Versioned Query&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Market Data ID&lt;/td&gt;&lt;td&gt;Provide a market data id or set of market data id's to query&lt;/td&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Time Granularity&lt;/td&gt;&lt;td&gt;Specify the granularity type&lt;/td&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Versioned Time Extraction Window&lt;/td&gt;&lt;td&gt;Versioned extraction time window&lt;/td&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Time Extraction Window&lt;/td&gt;&lt;td&gt;An extraction time window for data to be queried&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;[Go to Time Extraction window section](#artesian-sdk-extraction-windows)### Market Assessment Time Series Extraction```Pythonfrom Artesian import ArtesianConfigfrom Artesian.Query import QueryService, RelativeIntervalqs = QueryService(cfg)data = qs.createMarketAssessment() \    .forMarketData([100000032,100000043]) \    .forProducts([&quot;D+1&quot;,&quot;Feb-18&quot;]) \    .inAbsoluteDateRange(&quot;2018-01-01&quot;,&quot;2018-01-02&quot;) \    .execute()print(data)```To construct a Market Assessment Time Series Extraction the following must be provided.&lt;table&gt;  &lt;tr&gt;&lt;th&gt;Mas Query&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Market Data ID&lt;/td&gt;&lt;td&gt;Provide a market data id or set of market data id's to query&lt;/td&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;Provide a product or set of products&lt;/td&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Time Extraction Window&lt;/td&gt;&lt;td&gt;An extraction time window for data to be queried &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;[Go to Time Extraction window section](#artesian-sdk-extraction-windows)### Bid Ask Time Series Extraction```Pythonfrom Artesian import ArtesianConfigfrom Artesian.Query import QueryService, RelativeIntervalqs = QueryService(cfg)data = qs.createBidAsk() \    .forMarketData([100000032,100000043]) \    .forProducts([&quot;D+1&quot;,&quot;Feb-18&quot;]) \    .inAbsoluteDateRange(&quot;2018-01-01&quot;,&quot;2018-01-02&quot;) \    .execute()print(data)```To construct a Bid Ask Time Series Extraction the following must be provided.&lt;table&gt;  &lt;tr&gt;&lt;th&gt;Mas Query&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Market Data ID&lt;/td&gt;&lt;td&gt;Provide a market data id or set of market data id's to query&lt;/td&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;Provide a product or set of products&lt;/td&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Time Extraction Window&lt;/td&gt;&lt;td&gt;An extraction time window for data to be queried &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;[Go to Time Extraction window section](#artesian-sdk-extraction-windows)### Auction Time Series Extraction```Pythonfrom Artesian import ArtesianConfigfrom Artesian.Query import QueryService, RelativeIntervalqs = QueryService(cfg)data = qs.createAuction() \    .forMarketData([100011484,100011472,100011477,100011490,100011468,100011462,100011453]) \    .inAbsoluteDateRange(&quot;2018-01-01&quot;,&quot;2018-01-02&quot;) \    .inTimeZone(&quot;UTC&quot;) \    .execute()print(data)```To construct an Auction Time Series Extraction the following must be provided.&lt;table&gt;  &lt;tr&gt;&lt;th&gt;Auction Query&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Market Data ID&lt;/td&gt;&lt;td&gt;Provide a market data id or set of market data id's to query&lt;/td&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Time Extraction Window&lt;/td&gt;&lt;td&gt;An extraction time window for data to be queried&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;[Go to Time Extraction window section](#artesian-sdk-extraction-windows)### Extraction WindowsExtraction window types for queries.Date Range```Python .inAbsoluteDateRange(&quot;2018-08-01&quot;, &quot;2018-08-10&quot;)```Relative Interval```Python .inRelativeInterval(RelativeInterval.RollingWeek)```Period```Python .inRelativePeriod(&quot;P5D&quot;)```Period Range```Python .inRelativePeriodRange(&quot;P-3D&quot;, &quot;P10D&quot;)```### Filler StrategyAll extraction types (Actual,Versioned, Market Assessment and BidAsk) have an optional filler strategy.```pythonvar versionedSeries = qs  .createVersioned() \  .forMarketData([100000001]) \  .forLastNVersions(1) \  .inGranularity(Granularity.Day) \  .inAbsoluteDateRange(new Date(&quot;2018-1-1&quot;), new Date(&quot;2018-1-10&quot;)) \  .withFillLatestValue(&quot;P5D&quot;) \  .execute()```Use 'Null' to fill the missing timepoint with 'None' values.```python .withFillNull()```Use 'None' to not fill at all: timepoints are not returned if not present.```python .withFillNone()```Custom Value can be provided for each MarketDataType.Custom Value for Actual extraction type.```python.withFillCustomValue(123)```Custom Value for BidAsk extraction type.```python.withFillCustomValue(  bestBidPrice = 15.0,  bestAskPrice = 20.0,  bestBidQuantity = 30.0,  bestAskQuantity = 40.0,  lastPrice = 50.0,  lastQuantity = 60.0)```Custom Value for Market Assessment extraction type.```python.withFillCustomValue(settlement = 10.0,open = 20.0,close = 30.0,high = 40.0,low = 50.0,volumePaid = 60.0,volueGiven = 70.0,volume = 80.0)```Custom Value for Versioned extraction type.```python.withFillCustomValue(123)```Latest Value to propagate the latest value, not older than a certain threshold only if there is a value at the end of the period.```python .withFillLatestValue(&quot;P5D&quot;)``````python .withFillLatestValue(&quot;P5D&quot;, &quot;False&quot;)```Latest Value to propagate the latest value, not older than a certain threshold even if there's no value at the end.```python .withFillLatestValue(&quot;P5D&quot;, &quot;True&quot;)```## GME Public OfferArtesian support Query over GME Public Offers which comes in a custom and dedicated format.### Extract GME Public Offer```Pythonfrom Artesian.GMEPublicOffers import GMEPublicOfferService, Market, Purpose, Status, Zone, Scope, UnitType, GenerationType, BATypeqs = GMEPublicOfferService(cfg)data = qs.createQuery() \    .forDate(&quot;2020-04-01&quot;) \    .forMarket([Market.MGP]) \    .forStatus(Status.ACC) \    .forPurpose(Purpose.BID) \    .forZone([Zone.NORD]) \    .withPagination(1,100) \    .execute()print(data)```To construct a GME Public Offer Extraction the following must be provided.&lt;table&gt;  &lt;tr&gt;&lt;th&gt;GME Public Offer Query&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Time Extraction Window&lt;/td&gt;&lt;td&gt;An extraction time window for data to be queried&lt;/td&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;Market&lt;/td&gt;&lt;td&gt;Provide a market or set of markets to query&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;&lt;td&gt;Status&lt;/td&gt;&lt;td&gt;Provide a status or set of statuses to query&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td&gt;Purpose&lt;/td&gt;&lt;td&gt;Provide a purpose or set of purposes to query&lt;/td&gt;&lt;/tr&gt;     &lt;tr&gt;&lt;td&gt;Zone&lt;/td&gt;&lt;td&gt;Provide a zone to query&lt;/td&gt;&lt;/tr&gt;     &lt;/table&gt;### Extraction OptionsExtraction options for GME Public Offer queries.#### Date```Python .forDate(&quot;2020-04-01&quot;)```#### Purpose```Python .forPurpose(Purpose.BID)```#### Status```Python .forStatus(Status.ACC)```#### Operator```Python .forOperator([&quot;Operator_1&quot;, &quot;Operator_2&quot;])```#### Unit```Python .forUnit([&quot;UP_1&quot;, &quot;UP_2&quot;])```#### Market```Python .forMarket([Market.MGP])```#### Scope```Python .forScope([Scope.ACC, Scope.RS])```#### BAType```Python .forBAType([BAType.NETT, BAType.NERV])```#### Zone```Python .forZone([Zone.NORD])```#### UnitType```Python .forUnitType([UnitType.UCV, UnitType.UPV])```#### Generation Type```Python .forGenerationType(GenerationType.GAS)```#### Pagination```Python .withPagination(1,10)```## Write Data in ArtesianUsing the MarketDataService is possible to register MarketData and write curves into it using the UpsertData method.Depending on the Type of the MarketData, the UpsertData should be composed as per example below.### Write Data in an Actual Time Series```Pythonfrom Artesian import ArtesianConfig, Granularity, MarketDatafrom Artesian.MarketData import AggregationRulefrom datetime import datetimefrom dateutil import tzcfg = ArtesianConfg()mkservice = MarketData.MarketDataService(cfg)mkdid = MarketData.MarketDataIdentifier('PROVIDER', 'MARKETDATANAME')mkd = MarketData.MarketDataEntityInput(      providerName = mkdid.provider,      marketDataName = mkdid.name,      originalGranularity=Granularity.Day,      type=MarketData.MarketDataType.ActualTimeSerie,      originalTimezone=&quot;CET&quot;,      aggregationRule=AggregationRule.AverageAndReplicate,      tags={        'TestSDKPython': ['PythonValue2']      }  )registered = mkservice.readMarketDataRegistryByName(mkdid.provider, mkdid.name)if (registered is None):  registered = mkservice.registerMarketData(mkd)data = MarketData.UpsertData(mkdid, 'CET',  rows=  {      datetime(2020,1,1): 42.0,      datetime(2020,1,2): 43.0,  },  downloadedAt=datetime(2020,1,3).replace(tzinfo=tz.UTC)  )mkservice.upsertData(data)```In case we want to write an hourly (or lower) time series the timezone for the upsert data must be UTC:```Pythonmkservice = MarketData.MarketDataService(cfg)mkdid = MarketData.MarketDataIdentifier('PROVIDER', 'MARKETDATANAME')mkd = MarketData.MarketDataEntityInput(      providerName = mkdid.provider,      marketDataName = mkdid.name,      originalGranularity=Granularity.Hour,      type=MarketData.MarketDataType.ActualTimeSerie,      originalTimezone=&quot;CET&quot;,      aggregationRule=AggregationRule.AverageAndReplicate,      tags={        'TestSDKPython': ['PythonValue2']      }  )registered = mkservice.readMarketDataRegistryByName(mkdid.provider, mkdid.name)if (registered is None):  registered = mkservice.registerMarketData(mkd)data = MarketData.UpsertData(mkdid, 'UTC',  rows=  {      datetime(2020,1,1,5,0,0): 42.0,      datetime(2020,1,2,6,0,0): 43.0,      datetime(2020,1,2,7,0,0): 44.0,      datetime(2020,1,2,8,0,0): 45.0,      datetime(2020,1,2,9,0,0): 46.0,  },  downloadedAt=datetime(2020,1,3).replace(tzinfo=tz.UTC)  )mkservice.upsertData(data)```### Write Data in a Versioned Time Series```Pythonfrom Artesian import ArtesianConfig, Granularity, MarketDatafrom Artesian.MarketData import AggregationRulefrom datetime import datetimefrom dateutil import tzcfg = ArtesianConfg()mkservice = MarketData.MarketDataService(cfg)mkdid = MarketData.MarketDataIdentifier('PROVIDER', 'MARKETDATANAME')mkd = MarketData.MarketDataEntityInput(      providerName = mkdid.provider,      marketDataName = mkdid.name,      originalGranularity=Granularity.Day,      type=MarketData.MarketDataType.VersionedTimeSerie,      originalTimezone=&quot;CET&quot;,      aggregationRule=AggregationRule.AverageAndReplicate,      tags={        'TestSDKPython': ['PythonValue2']      }  )registered = mkservice.readMarketDataRegistryByName(mkdid.provider, mkdid.name)if (registered is None):  registered = mkservice.registerMarketData(mkd)data = MarketData.UpsertData(mkdid, 'CET',  rows=  {      datetime(2020,1,1): 42.0,      datetime(2020,1,2): 43.0,  },  version= datetime(2020,1,3,12,0),  downloadedAt=datetime(2020,1,3).replace(tzinfo=tz.UTC)  )mkservice.upsertData(data)```### Write Data in a Market Assessment Time Series```Pythonfrom Artesian import ArtesianConfig, Granularity, MarketDatafrom datetime import datetimefrom dateutil import tzcfg = ArtesianConfg()mkservice = MarketData.MarketDataService(cfg)mkdid = MarketData.MarketDataIdentifier('PROVIDER', 'MARKETDATANAME')mkd = MarketData.MarketDataEntityInput(      providerName = mkdid.provider,      marketDataName = mkdid.name,      originalGranularity=Granularity.Day,      type=MarketData.MarketDataType.MarketAssessment,      originalTimezone=&quot;CET&quot;,      tags={        'TestSDKPython': ['PythonValue2']      }  )registered = mkservice.readMarketDataRegistryByName(mkdid.provider, mkdid.name)if (registered is None):  registered = mkservice.registerMarketData(mkd)marketAssessment = MarketData.UpsertData(MarketData.MarketDataIdentifier('PROVIDER', 'MARKETDATANAME'), 'CET',  marketAssessment=  {      datetime(2020,1,1):      {         &quot;Feb-20&quot;: MarketData.MarketAssessmentValue(open=10.0, close=11.0),         &quot;Mar-20&quot;: MarketData.MarketAssessmentValue(open=20.0, close=21.0)      },          datetime(2020,1,2):          {              &quot;Feb-20&quot;: MarketData.MarketAssessmentValue(open=11.0, close=12.0),              &quot;Mar-20&quot;: MarketData.MarketAssessmentValue(open=21.0, close=22.0)          }  },  downloadedAt=datetime(2020,1,3).replace(tzinfo=tz.UTC)  )mkservice.upsertData(marketAssessment)```### Write Data in a Bid Ask Time Series```Pythonfrom Artesian import ArtesianConfig,Granularity,MarketDatafrom datetime import datetimefrom dateutil import tzcfg = ArtesianConfg()mkservice = MarketData.MarketDataService(cfg)mkdid = MarketData.MarketDataIdentifier('PROVIDER', 'MARKETDATANAME')mkd = MarketData.MarketDataEntityInput(      providerName = mkdid.provider,      marketDataName = mkdid.name,      originalGranularity=Granularity.Day,      type=MarketData.MarketDataType.BidAsk,      originalTimezone=&quot;CET&quot;,      tags={        'TestSDKPython': ['PythonValue2']      }  )registered = mkservice.readMarketDataRegistryByName(mkdid.provider, mkdid.name)if (registered is None):  registered = mkservice.registerMarketData(mkd)bidAsk = MarketData.UpsertData(MarketData.MarketDataIdentifier('PROVIDER', 'MARKETDATANAME'), 'CET',  bidAsk={      datetime(2020,1,1):      {          &quot;Feb-20&quot;:MarketData.BidAskValue(bestBidPrice=15.0, lastQuantity=14.0),          &quot;Mar-20&quot;:MarketData.BidAskValue(bestBidPrice=25.0, lastQuantity=24.0)      },      datetime(2020,1,2):      {          &quot;Feb-20&quot;:MarketData.BidAskValue(bestBidPrice=15.0, lastQuantity=14.0),          &quot;Mar-20&quot;:MarketData.BidAskValue(bestBidPrice=25.0, lastQuantity=24.0)      }  },  downloadedAt=datetime(2020,1,3).replace(tzinfo=tz.UTC)  )mkservice.upsertData(bidAsk)```### Write Data in an Auction Time Series```Pythonfrom Artesian import ArtesianConfig,Granularity,MarketDatafrom datetime import datetimefrom dateutil import tzcfg = ArtesianConfg()mkservice = MarketData.MarketDataService(cfg)mkdid = MarketData.MarketDataIdentifier('PROVIDER', 'MARKETDATANAME')mkd = MarketData.MarketDataEntityInput(      providerName = mkdid.provider,      marketDataName = mkdid.name,      originalGranularity=Granularity.Day,      type=MarketData.MarketDataType.Auction,      originalTimezone=&quot;CET&quot;,      tags={        'TestSDKPython': ['PythonValue2']      }  )registered = mkservice.readMarketDataRegistryByName(mkdid.provider, mkdid.name)if (registered is None):  registered = mkservice.registerMarketData(mkd)auctionRows = MarketData.UpsertData(MarketData.MarketDataIdentifier('PROVIDER', 'MARKETDATANAME'), 'CET',  auctionRows={      datetime(2020,1,1): MarketData.AuctionBids(datetime(2020,1,1),          bid=[              MarketData.AuctionBidValue(11.0, 12.0),              MarketData.AuctionBidValue(13.0, 14.0),          ],          offer=[              MarketData.AuctionBidValue(21.0, 22.0),              MarketData.AuctionBidValue(23.0, 24.0),          ]      )  },  downloadedAt=datetime(2020,1,3).replace(tzinfo=tz.UTC)  )  mkservice.upsertData(auctionRows)```### Delete MarketData in ArtesianUsing the MarketDataService is possible to delete MarketData and its curves.```Pythonfrom Artesian import ArtesianConfigfrom Artesian.MarketData import MarketDataServicecfg = ArtesianConfg()mkservice = MarketDataService(cfg)mkservice.deleteMarketData(100042422)```### Query written Versions or ProductsUsing MarketDataService is possible to query all the Versions and all the Products curves which has been written in a MarketData.```Pythonfrom Artesian.MarketData import MarketDataServicemds = MarketDataService(cfg)```To list MarketData curves```Pythonpage = 1pageSize = 100res = mds.readCurveRange(100042422, page, pageSize, versionFrom=&quot;2016-12-20&quot; , versionTo=&quot;2019-03-12&quot;)```## Jupyter SupportArtesian SDK uses asyncio internally, this causes a conflict with Jupyter. You can work around this issue by add the following at the beginning of the notebook.```python!pip install nest_asyncioimport nest_asyncionest_asyncio.apply()```[Issue #3397 with workaround](https://github.com/jupyter/notebook/issues/3397#issuecomment-419386811)## Links- [Github](https://github.com/ARKlab/Artesian.SDK-Python)- [Ark Energy](http://www.ark-energy.eu/)- [Artesian Portal](https://portal.artesian.cloud)</longdescription>
</pkgmetadata>