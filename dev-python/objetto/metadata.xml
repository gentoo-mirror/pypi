<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Objetto=======.. image:: https://github.com/brunonicko/objetto/workflows/MyPy/badge.svg   :target: https://github.com/brunonicko/objetto/actions?query=workflow%3AMyPy.. image:: https://github.com/brunonicko/objetto/workflows/Lint/badge.svg   :target: https://github.com/brunonicko/objetto/actions?query=workflow%3ALint.. image:: https://github.com/brunonicko/objetto/workflows/Tests/badge.svg   :target: https://github.com/brunonicko/objetto/actions?query=workflow%3ATests.. image:: https://readthedocs.org/projects/objetto/badge/?version=stable   :target: https://objetto.readthedocs.io/en/stable/.. image:: https://img.shields.io/github/license/brunonicko/objetto?color=light-green   :target: https://github.com/brunonicko/objetto/blob/master/LICENSE.. image:: https://static.pepy.tech/personalized-badge/objetto?period=total&amp;units=international_system&amp;left_color=grey&amp;right_color=brightgreen&amp;left_text=Downloads   :target: https://pepy.tech/project/objetto.. image:: https://img.shields.io/pypi/pyversions/objetto?color=light-green&amp;style=flat   :target: https://pypi.org/project/objetto/`Objetto` is an opinionated object-oriented framework for building modular applicationsand APIs.Overview--------`Objetto` allows for the creation of an `Application`_ that consists of high-levelmutable structures referred to as `Objects &lt;Object_&gt;`_.  - `Objects &lt;Object_&gt;`_ are associated with an `Application`_ when initialized.  - `Objects &lt;Object_&gt;`_ are part of a parent-children `Hierarchy`_ tree.  - `Objects &lt;Object_&gt;`_ have their schema defined by `Attributes &lt;Attribute&gt;`_.  - `Objects &lt;Object_&gt;`_ encase an immutable subset version of themselves referred to    as `Data`_.  - `Objects &lt;Object_&gt;`_ will send an `Action`_ to themselves, their parent, and    grandparents everytime a `Change`_ happens.  - `Objects &lt;Object_&gt;`_ can perform `Reactions &lt;Reaction&gt;`_ in response to `Actions    &lt;Action&gt;`_ received from themselves, their children, and grandchildren.  - `Objects &lt;Object_&gt;`_ can be observed by external `Observers &lt;Action Observer&gt;`_ such    as GUI widgets.  - `Objects &lt;Object_&gt;`_ feature built-in human-readable `Serialization`_ and    `Deserialization`_ capabilities.  - `Objects &lt;Object_&gt;`_ can be automatically tracked by a    `History &lt;Undo/Redo History&gt;`_, which allows for easy and selective undo/redo    functionality.How to install--------------You can install `Objetto` by using `pip &lt;https://pypi.org/&gt;`_:``pip install objetto``Application-----------An `Application`_ oversees all `Objects &lt;Object_&gt;`_ that are meant to work together. Itprovides different contexts for managing and keeping track of their `Changes &lt;Change&gt;`_.`Objects &lt;Object_&gt;`_ that are part of different `Applications &lt;Application&gt;`_ see eachother as regular values and can never be part of the same `Hierarchy`_.An `Application`_ can have `Root Objects &lt;Roots&gt;`_, which are `Objects &lt;Object_&gt;`_ thatare always available at the top of the hierarchy, and cannot be parented under other`Objects &lt;Object_&gt;`_.**Example**: Instantiate a new `Application`_... code:: python    &gt;&gt;&gt; from objetto import Application    &gt;&gt;&gt; app = Application()  # instantiate a new applicationRead Context************While in a `Read Context`_, all `Objects &lt;Object&gt;`_ in the `Application`_ are guaranteednot to be modified.**Example**: Enter a `Read Context`_... code:: python    &gt;&gt;&gt; from objetto import Application    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; with app.read_context():    ...     pass  # read access only, no changes allowed    ...Write Context*************While in a `Write Context`_, `Actions &lt;Action&gt;`_ are only sent internally until theoutermost `Write Context`_ exits without errors, after which external `Observers&lt;Action Observer&gt;`_ will then receive them.If an unhandled exception gets raised, all changes are reverted to the moment thecontext was entered, and external `Observers &lt;Action Observer&gt;`_ will not receive any`Actions &lt;Action&gt;`_. This behavior is similar to `transactions` in a database... note::    You cannot enter a `Write Context`_ while in a `Read Context`_.**Example**: Enter a `Write Context`_... code:: python    &gt;&gt;&gt; from objetto import Application    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; with app.write_context():    ...     pass  # send actions to external observers only at the end, revert if errors    ...Roots*****Root `Objects &lt;Object_&gt;`_ can be declared when creating a subclass of an `Application`_by using a root descriptor and specifying the `Object`_ type and initializationarguments.**Example**: Define `Root Objects &lt;Roots&gt;`_ when subclassing `Application`_... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute, root    &gt;&gt;&gt; class Document(Object):    ...     title = attribute(str)    ...    &gt;&gt;&gt; class CustomApplication(Application):  # inherit from Application    ...     document = root(Document, title=&quot;untitled&quot;)  # specify object type and args    ...    &gt;&gt;&gt; app = CustomApplication()    &gt;&gt;&gt; type(app.document).__name__    'Document'Object------`Objects &lt;Object_&gt;`_ are the building blocks of an `Application`_. An `Object`_ ismutable, has state, and can be a parent/child of another `Object`_.To define our own `Object`_, we have to inherit from `objetto.Object` and use`Attributes &lt;Attribute&gt;`_ to define its schema. You need to instantiate it by passing an`Application`_, which can later be accessed through the `.app` property:**Example**: Make our own `Object`_ subclass and instantiate it... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute    &gt;&gt;&gt; class Hobby(Object):  # inherit from Object    ...     description = attribute(str)  # example attribute called 'description'    ...    &gt;&gt;&gt; app = Application()  # we need an application    &gt;&gt;&gt; hobby = Hobby(app, description=&quot;biking&quot;)  # instantiate our object    &gt;&gt;&gt; hobby.app is app    TrueAttribute---------`Attributes &lt;Attribute&gt;`_ describe the schema of an `Object`_. When defining one, we canspecify relationship parameters between the `Object`_ that owns it and the value beingstored, such as a `Value Type`_, `Hierarchy`_ settings, `History &lt;Undo/Redo History&gt;`_propagation, `Serialization`_ and `Deserialization`_ options, etc.**Example**: Define custom `Objects &lt;Object_&gt;`_ with multiple `Attributes &lt;Attribute&gt;`_... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute    &gt;&gt;&gt; class Hobby(Object):    ...     description = attribute(str)  # specify value type, only takes strings    ...    &gt;&gt;&gt; class Person(Object):    ...     name = attribute(str, default=&quot;Phil&quot;)  # specify a default value    ...     hobby = attribute(Hobby)  # specify value type, only takes 'Hobby' objects    ...     busy = attribute(bool, serialized=False, default=False)  # not serialized    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; hobby = Hobby(app, description=&quot;biking&quot;)    &gt;&gt;&gt; person = Person(app, hobby=hobby)    &gt;&gt;&gt; person.name    'Phil'    &gt;&gt;&gt; person.name = &quot;Gaimon&quot;    &gt;&gt;&gt; person.name    'Gaimon'Value Type**********When defining an `Attribute`_, we can specify its `Value Type`_. This is leveraged bythe runtime type checking and by static ones such as `mypy &lt;http://mypy-lang.org/&gt;`_.Defining types is also helpful to inform `Objetto` about the schema of our`Objects &lt;Object&gt;`_, which is needed for proper `Serialization`_ and `Deserialization`_.Import strings are also valid (using the syntax `module.submodule|Class.NestedClass`),and they will be imported lazily during runtime. It's also possible to use multiple`Types &lt;Value Type&gt;`_ by specifying them in a tuple... note::    Static type checkers such as `mypy &lt;http://mypy-lang.org/&gt;`_ might not understand    types correctly when multiple/lazy types are declared. In that case, you can help    the type checker by adding a type hint/comment using the `Attribute`_ base like so:    **Example**: Helping static type checkers with a type hint for the attribute.    .. code:: python        &gt;&gt;&gt; from typing import Union        &gt;&gt;&gt; from objetto.objects import Attribute  # use 'Attribute' base for type hint        &gt;&gt;&gt; from objetto import Object, attribute        &gt;&gt;&gt; class Example(Object):        ...     foo = attribute(        ...         (str, int, &quot;__main__|Example&quot;)        ...     )  # type: Attribute[Union[str, int, Example]]        ...The types are interpreted 'exactly' by default. This means they are checked and comparedby identity, so instances of subclasses are not accepted. However that behavior can bechanged by specifying `subtypes=True` when defining an `Attribute`_.If `None` is also accepted as a value, we can specify `None` as a valid type.**Example**: Define the `Value Types &lt;Value Type&gt;`_ of `Attributes &lt;Attribute&gt;`_... code:: python    &gt;&gt;&gt; from objetto import Object, attribute    &gt;&gt;&gt; class Person(Object):    ...     name = attribute(str)  # single exact value type    ...     friend = attribute((&quot;__main__|Person&quot;, None))  # import path, accepts None    ...     hobby = attribute(&quot;module.hobby|Hobby&quot;) # import path with module path    ...     points = attribute((int, float))  # multiple basic types    ...     _status = attribute(serialized=False)  # no value type, not serialized    ...     _pet = attribute(    ...         &quot;pets|AbstractPet&quot;, subtypes=True    ...     )  # accepts instances of 'AbstractPet' subclassesValue Factory*************An `Attribute`_ can conform and/or verify new values by using a `Value Factory`_, whichis simply a function or callable that takes the newly input value, does something to it,and then return the actual value that gets stored in the `Object`_... note::    There's a very important thing to note when it comes to defining your own    `&lt;Value Factory&gt;`_, which is that any value returned by the factory should always    produce itself in case it's fed again through the same factory. Also, the    `&lt;Value Factory&gt;`_ needs to be deterministic.You can use simple functions or callable types as `Value Factories &lt;Value Factory&gt;`_,but `Objetto` offers some very useful pre-defined ones that can be easily configuredwith parameters.Here are some of those built-in `Value Factories &lt;Value Factory&gt;`_, which can beimported from `objetto.factories`:  - `Integer`  - `FloatingPoint`  - `RegexMatch`  - `RegexSub`  - `String`  - `Curated`  - `Boolean`**Example**: Use `Value Factories &lt;Value Factory&gt;`_ to conform/verify attribute values... code:: python    &gt;&gt;&gt; from objetto import Object, attribute    &gt;&gt;&gt; from objetto.factories import RegexMatch, Integer, Curated, String, Boolean    &gt;&gt;&gt; class Person(Object):    ...     name = attribute(str, factory=RegexMatch(r&quot;^[a-z ,.'-]+$&quot;))  # regex match    ...     age = attribute(int, factory=Integer(minimum=1))  # minimum integer    ...     pet = attribute(str, factory=Curated((&quot;cat&quot;, &quot;dog&quot;))) # curated values    ...     job = attribute(str, factory=String())  # force string    ...     happy = attribute(bool, factory=Boolean(), default=True)  # force booleanAuxiliary Attribute*******************These are special `Attributes &lt;Attribute&gt;`_ that will hold multiple values instead ofjust one.The most basic `Auxiliary Attributes &lt;Auxiliary Attribute&gt;`_ are:  - `list_attribute`  - `dict_attribute`  - `set_attribute`**Example**: Use `Auxiliary Attributes &lt;Auxiliary Attribute&gt;`_ to hold values... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute, list_attribute    &gt;&gt;&gt; class Hobby(Object):    ...     description = attribute(str)    ...    &gt;&gt;&gt; class Person(Object):    ...     hobbies = list_attribute(Hobby)  # holds multiple 'hobbies'    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; hobby_a = Hobby(app, description=&quot;biking&quot;)    &gt;&gt;&gt; hobby_b = Hobby(app, description=&quot;gaming&quot;)    &gt;&gt;&gt; person = Person(app, hobbies=(hobby_a, hobby_b))  # initialize with iterable    &gt;&gt;&gt; person.hobbies[0] is hobby_a    TrueDelegated Attribute*******************`Attributes &lt;Attribute&gt;`_ can have delegate methods that will get, set and/or deletethe values of other `Attributes &lt;Attribute&gt;`_ in the same `Object`_.When defining delegates, you have to specify which `Attributes &lt;Attribute&gt;`_ they willread from as `dependencies`... note::    The results of delegate methods are cached, and because of that they should never    rely on mutable external objects. Think of delegates as 'pure functions' in the    context of the `Object`_ they belong to.    If an `Attribute`_ value needs to change according to external factors,    `Reactions &lt;Reaction&gt;`_ or regular methods are encouraged to be used instead of    delegates.**Example**: Define a `Delegated Attribute`_ with a `getter` and a `setter`... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute    &gt;&gt;&gt; class Person(Object):    ...     first_name = attribute(str)    ...     last_name = attribute(str)    ...     name = attribute(    ...         str, delegated=True, dependencies=(first_name, last_name)    ...     )  # delegated attribute with read dependencies    ...    ...     @name.getter  # define a getter delegate    ...     def name(self):    ...         return self.first_name + &quot; &quot; + self.last_name    ...    ...     @name.setter  # define a setter delegate    ...     def name(self, value):    ...         self.first_name, self.last_name = value.split()    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; person = Person(app, first_name=&quot;Katherine&quot;, last_name=&quot;Johnson&quot;)    &gt;&gt;&gt; person.name    'Katherine Johnson'    &gt;&gt;&gt; person.name = &quot;Grace Hopper&quot;    &gt;&gt;&gt; person.name    'Grace Hopper'    &gt;&gt;&gt; person.first_name    'Grace'    &gt;&gt;&gt; person.last_name    'Hopper'Attribute Helper****************There are patterns that come up very often when defining `Attributes &lt;Attribute&gt;`_.Instead of re-writing those patterns everytime, it's possible to use helper functionsknown as `Attribute Helpers &lt;Attribute Helper&gt;`_ to get the same effect.Here are some examples of `Attribute Helpers &lt;Attribute Helper&gt;`_:  - `constant_attribute`  - `protected_attribute_pair`  - `protected_list_attribute_pair`  - `protected_dict_attribute_pair`  - `protected_set_attribute_pair`**Example**: Define a simple `Attribute Helper`_... code:: python    &gt;&gt;&gt; from objetto import Application, Object, protected_attribute_pair    &gt;&gt;&gt; class Person(Object):    ...     _name, name = protected_attribute_pair(str, default=&quot;King&quot;)  # helper    ...    ...     def set_name(self, name):    ...         self._name = name.upper()  # set the changeable private attribute    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; person = Person(app)    &gt;&gt;&gt; person.name    'King'    &gt;&gt;&gt; person.name = &quot;bb king&quot;  # can't set non-changeable public attribute    Traceback (most recent call last):    AttributeError: attribute 'name' is read-only    &gt;&gt;&gt; person.set_name(&quot;bb king&quot;)  # we have to use the method instead    &gt;&gt;&gt; person.name    'BB KING'Hierarchy---------An `Object`_ can have one parent and/or multiple children.The parent-children hierarchy is central to the way `Objetto` works, as it provides anelegant way to structure our `Application`_. It's essential for features like:  - Preventing cyclic references: `Objects &lt;Object_&gt;`_ can only have one parent  - Immutable `Data`_ 'mirroring': The `Data`_ structure will replace child `Objects    &lt;Object_&gt;`_ with their `Data`_ according to the hierarchy  - Human-readable `Serialization`_: The `.serialize()` and `.deserialize()` methods    utilize the hierarchy to format their input/output  - `Action`_ sending and subsequent `Reaction`_\ response: `Actions &lt;Action&gt;`_ will    propagate from where the `Change`_ happened all the way up the hierarchy to the    topmost grandparent, triggering `Reactions &lt;Reaction&gt;`_ along the way  - Automatic `History &lt;Undo/Redo History&gt;`_ propagation: Children can automatically be    assigned to the same `History &lt;Undo/Redo History&gt;`_ of the parent if desired... note::    The hierarchical relationship can be turned off selectively at the expense of those    features by specifying `child=False` when we define an `Attribute`_.    Also note that the hierarchical relationship will only work between    `Objects &lt;Object_&gt;`_ within the same `Application`_.**Example**: Access `._parent` and `._children` properties... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute    &gt;&gt;&gt; class Hobby(Object):    ...     description = attribute(str)    ...    &gt;&gt;&gt; class Person(Object):    ...     name = attribute(str)    ...     hobby = attribute(Hobby)  # child=True is the default behavior    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; hobby = Hobby(app, description=&quot;animation&quot;)    &gt;&gt;&gt; person = Person(app, name=&quot;Hayao Miyazaki&quot;, hobby=hobby)    &gt;&gt;&gt; hobby._parent is person  # 'person' is the parent of 'hobby'    True    &gt;&gt;&gt; hobby in person._children  # 'hobby' is a child of 'person'    TrueUndo/Redo History-----------------Objetto has built-in support for a undo/redo `History &lt;Undo/Redo History&gt;`_. It takescare of managing its validity for internal changes by flushing itself automatically whennecessary, and it is extremely easy to implement.A history can be associated with an `Object`_ by adding a `history_descriptor` to theclass definition. Accessing that attribute from an `Object`_'s instance will give us thehistory itself.A history will be propagated to children/grandchildren of the `Object`_ which definesit, however it's possible to prevent that behavior by specifying `history=False` when wedefine an `Attribute`_.Undo/redo can be triggered by running the history's methods `.undo()` and `.redo()`.Histories are `Objects &lt;Object_&gt;`_ too, so they do send `Actions &lt;Action&gt;`_ that can beobserved by `Observers &lt;Action Observer&gt;`_.**Example**: Associate a `History &lt;Undo/Redo History&gt;`_ with an `Object`_... code:: python    &gt;&gt;&gt; from objetto import Application, Object, history_descriptor, attribute    &gt;&gt;&gt; class Person(Object):    ...     history = history_descriptor()  # specify a history    ...     name = attribute(str)    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; person = Person(app, name=&quot;Dave&quot;)    &gt;&gt;&gt; person.name    'Dave'    &gt;&gt;&gt; person.name = &quot;Dave Grohl&quot;    &gt;&gt;&gt; person.name    'Dave Grohl'    &gt;&gt;&gt; person.history.undo()  # undo the name change    &gt;&gt;&gt; person.name    'Dave'Batch Context*************An `Object`_ can enter a `Batch Context`_, which will group multiple `Changes &lt;Change&gt;`_happening to itself and/or to other `Objects &lt;Object&gt;`_ into one single entry in theassociated `History &lt;Undo/Redo History&gt;`_.A special `Action`_ carrying the the name and the metadata of the batch context will besent when entering (`PRE` `Phase`_) and when exiting the context (`POST` `Phase`_).**Example**: Enter a `Batch Context`_... code:: python    &gt;&gt;&gt; from objetto import Application, Object, history_descriptor, attribute    &gt;&gt;&gt; class Hobby(Object):    ...     description = attribute(str)    ...    &gt;&gt;&gt; class Person(Object):    ...     history = history_descriptor()  # specify a history    ...     name = attribute(str)    ...     hobby = attribute(Hobby)  # history will propagate by default    ...    ...     def set_info(self, name, hobby_description):    ...         with self._batch_context(&quot;Set Person Info&quot;):  # enter batch    ...             self.name = name  # single change    ...             self.hobby.description = hobby_description  # single change    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; hobby = Hobby(app, description=&quot;sailing&quot;)    &gt;&gt;&gt; person = Person(app, name=&quot;Albert&quot;, hobby=hobby)    &gt;&gt;&gt; person.name, person.hobby.description    ('Albert', 'sailing')    &gt;&gt;&gt; person.set_info(&quot;Einstein&quot;, &quot;physics&quot;)  # batch change    &gt;&gt;&gt; person.name, person.hobby.description    ('Einstein', 'physics')    &gt;&gt;&gt; person.history.undo()  # single undo will revert both changes    &gt;&gt;&gt; person.name, person.hobby.description    ('Albert', 'sailing')Data----`Data`_ are analog structures to `Objects &lt;Object_&gt;`_, but they are immutable.Everytime an `Object`_ changes, their internal `Data`_ and all of its parent's andgrandparents' `Data`_ get replaced with a new one that reflects those changes.By default, every `Object`_ class/subclass with automatically generate it's `Data`_class based on its attributes and schema. You can access the data type of an `Object`_through its `.Data` class property.The `Data`_ instance for an `Object`_ can be accessed through its `.data` property.**Example**: Access internal `Data`_ of an `Object`_... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute    &gt;&gt;&gt; class Hobby(Object):    ...     description = attribute(str)    ...    &gt;&gt;&gt; class Person(Object):    ...     hobby = attribute(Hobby)    ...    &gt;&gt;&gt; Person.Data.__fullname__  # access to automatically generated 'Data' class    'Person.Data'    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; hobby = Hobby(app, description=&quot;biking&quot;)    &gt;&gt;&gt; person = Person(app, hobby=hobby)    &gt;&gt;&gt; hobby_data = person.data.hobby  # access 'hobby' data through 'person' data    &gt;&gt;&gt; hobby_data is hobby.data    True    &gt;&gt;&gt; hobby_data.description    'biking'If you want to bind methods from the `Object`_ to the `Data`_ as well, you can use the`data_method` decorator.**Example**: Using the `data_method` decorator... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute, data_method    &gt;&gt;&gt; class Hobby(Object):    ...     description = attribute(str)    ...    ...     @data_method    ...     def get_description(self):    ...         return &quot;Description: {}&quot;.format(self.description)    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; hobby = Hobby(app, description=&quot;biking&quot;)    &gt;&gt;&gt; hobby.get_description()    'Description: biking'    &gt;&gt;&gt; hobby.data.get_description()  # 'hobby' data also has the method    'Description: biking'And finally, if you want more control, you can define a custom `Data`_ class for an`Object`_, but this only recommended for advanced behavior. Keep in mind that the classmust match the schema of the `Object &lt;Object&gt;`_'s `Attributes &lt;Attribute&gt;`_.**Example**: Defining a custom `Data`_ class for an `Object &lt;Object&gt;`_... code:: python    &gt;&gt;&gt; from objetto import Application, Object, Data, attribute, data_attribute    &gt;&gt;&gt; class Hobby(Object):    ...     description = attribute(str)    ...    ...     class Data(Data):    ...         description = data_attribute(str, factory=lambda v, **_: v.upper())    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; hobby = Hobby(app, description=&quot;biking&quot;)    &gt;&gt;&gt; hobby.description    'biking'    &gt;&gt;&gt; hobby.data.description  # data attribute has a custom factory    'BIKING'It's also possible to use `Data`_ on its own, without an encasing `Object`_. Rememberthat `Data`_ instances are immutable, so the only way to produce changes is by callingmethods that return a new version of the data when subclassing from an *interactive*`Data`_ class.**Example**: Using an interactive `Data`_ on its own... code:: python    &gt;&gt;&gt; from objetto import InteractiveData, data_attribute    &gt;&gt;&gt; class HobbyData(InteractiveData):  # inherit from InteractiveData    ...     description = data_attribute(str)  # use data attributes    ...    &gt;&gt;&gt; class PersonData(InteractiveData):    ...     hobby = data_attribute((HobbyData, None))  # specify data types    ...    &gt;&gt;&gt; hobby_data = HobbyData(description=&quot;biking&quot;)    &gt;&gt;&gt; new_hobby_data = hobby_data.set(&quot;description&quot;, &quot;programming&quot;)  # make new    &gt;&gt;&gt; person_data = PersonData(hobby=hobby_data)    &gt;&gt;&gt; person_data.hobby = None  # data is immutable    Traceback (most recent call last):    AttributeError: 'PersonData' object attribute 'hobby' is read-onlyAction------Every time an `Object`_ changes, it will automatically send an `Action`_ up the`Hierarchy`_ to its parent and grandparents.The `Action`_ carries information such as:  - The description of the `Change`_ (`change`)  - A reference to the `Object`_ receiving the `Action`_ (`receiver`)  - A reference to the `Object`_ where the change originated from (`sender`)  - A list of relative indexes/keys from the `receiver` to the `sender` (`locations`)Phase*****A constant value that tells whether the change in the state is about to happen (`PRE`)or if the change already happened (`POST`).Change******A `Change`_ describes what exactly changed in the state of an `Object`_.Here are some of the `Changes &lt;Change&gt;`_ provided by `Objects &lt;Object&gt;`_:  - `Batch`  - `Update`  - `DictUpdate`  - `ListInsert`  - `ListDelete`  - `ListUpdate`  - `ListMove`  - `SetUpdate`  - `SetRemove`Reaction********`Objects &lt;Object_&gt;`_ can define `Reactions &lt;Reaction&gt;`_ that will get triggered once`Actions &lt;Action&gt;`_ are received.`Reactions &lt;Reaction&gt;`_ are special methods of `Objects &lt;Object_&gt;`_ that respond to`Actions &lt;Action&gt;`_ received from themselves, their children, and grandchildren... note::    While an `Object`_ can react to its own changes, its triggered `Reaction`_ cannot    perform any further changes to the same `Object`_, only to its children and    grandchildren.    If an `Attribute`_ value needs to change when another `Attribute`_ in the same    `Object`_ changes, `Delegated Attributes &lt;Delegated Attribute&gt;`_ should be used    instead of `Reactions &lt;Reaction&gt;`_.**Example**: Define `Reaction`_ methods... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute, reaction, POST    &gt;&gt;&gt; class MyObject(Object):    ...     value = attribute(int, default=0)    ...    ...     @reaction    ...     def __on_received(self, action, phase):    ...         if not self._initializing and phase is POST:    ...             print((&quot;LAST -&quot;, action.change.name, phase))    ...    ...     @reaction(priority=1)    ...     def __on_received_first(self, action, phase):    ...         if not self._initializing and phase is POST:    ...             print((&quot;FIRST -&quot;, action.change.name, phase))    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; my_obj = MyObject(app)    &gt;&gt;&gt; my_obj.value = 42    ('FIRST -', 'Update Attributes', &lt;Phase.POST: 'POST'&gt;)    ('LAST -', 'Update Attributes', &lt;Phase.POST: 'POST'&gt;)Action Observer***************After all internal `Reactions &lt;Reaction&gt;`_ within an `Write Context`_ run without anyerrors, the `Actions &lt;Action&gt;`_ are then finally sent to external`Action Observers &lt;Action Observer&gt;`_ so they have a chance to synchronize.Graphical user interface widgets are a good example of`Action Observers &lt;Action Observer&gt;`_.**Example**: Register an external `Action Observer`_... code:: python    &gt;&gt;&gt; from objetto import Application, Object, ActionObserver, attribute    &gt;&gt;&gt; class Person(Object):    ...     name = attribute(str, default=&quot;Nina&quot;)    ...    &gt;&gt;&gt; class PersonObserver(ActionObserver):    ...    ...     def __observe__(self, action, phase):    ...         print((action.change.name, phase.value))    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; person = Person(app)    &gt;&gt;&gt; observer = PersonObserver()    &gt;&gt;&gt; token = observer.start_observing(person)    &gt;&gt;&gt; person.name = &quot;Simone&quot;    ('Update Attributes', 'PRE')    ('Update Attributes', 'POST')Auxiliary Attribute Reaction****************************It is possible to specify `Reactions &lt;Reaction&gt;`_ methods/callables when defining`Auxiliary Attributes &lt;Auxiliary Attribute&gt;`_. `Objetto` offers configurable reactionsthat can be used for that purpose.Here are some of them:  - `UniqueAttributes`  - `LimitChildren`  - `Limit`**Example**: Ensure unique names... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute, list_attribute    &gt;&gt;&gt; from objetto.reactions import UniqueAttributes    &gt;&gt;&gt; class Person(Object):    ...     name = attribute(str)    ...    &gt;&gt;&gt; class Band(Object):    ...     musicians = list_attribute(Person, reactions=UniqueAttributes(&quot;name&quot;))    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; person_a = Person(app, name=&quot;Paul&quot;)    &gt;&gt;&gt; person_b = Person(app, name=&quot;John&quot;)    &gt;&gt;&gt; band = Band(app, musicians=(person_a, person_b))    &gt;&gt;&gt; person_c = Person(app, name=&quot;Paul&quot;)    &gt;&gt;&gt; band.musicians.append(person_c)    Traceback (most recent call last):    ValueError: another object already has 'name' set to 'Paul'Serialization-------------`Objects &lt;Object&gt;`_ support human-readable serialization out of the box.**Example**: Serialize an `Object`_... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute, list_attribute    &gt;&gt;&gt; class Person(Object):    ...     name = attribute(str)    ...    &gt;&gt;&gt; class Band(Object):    ...     musicians = list_attribute(Person)    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; person_a = Person(app, name=&quot;Oscar&quot;)    &gt;&gt;&gt; person_b = Person(app, name=&quot;Ray&quot;)    &gt;&gt;&gt; band = Band(app, musicians=(person_a, person_b))    &gt;&gt;&gt; band.serialize()    {'musicians': [{'name': 'Oscar'}, {'name': 'Ray'}]}Deserialization***************`Objects &lt;Object&gt;`_ support human-readable deserialization out of the box.**Example**: Deserialize an `Object`_... code:: python    &gt;&gt;&gt; from objetto import Application, Object, attribute, list_attribute    &gt;&gt;&gt; class Person(Object):    ...     name = attribute(str)    ...    &gt;&gt;&gt; class Band(Object):    ...     musicians = list_attribute(Person)    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; Band.deserialize({&quot;musicians&quot;: [{&quot;name&quot;: &quot;Oscar&quot;}, {&quot;name&quot;: &quot;Ray&quot;}]}, app=app)    Band(musicians=[&lt;Person at ...&gt;, &lt;Person at ...&gt;])Custom Serializer/Deserializer******************************You can specify custom serializer/deserializer functions for attributes.**Example**: Serialize an `Enum` using lambdas... code:: python    &gt;&gt;&gt; from enum import Enum    &gt;&gt;&gt; from objetto import Application, Object, attribute    &gt;&gt;&gt; class Hobby(Enum):    ...     GUITAR = 1    ...     BIKING = 2    ...    &gt;&gt;&gt; class Person(Object):    ...     hobby = attribute(    ...         Hobby,    ...         serializer=lambda value, **_: value.name.lower(),    ...         deserializer=lambda value, **_: Hobby[value.upper()],    ...     )    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; person = Person(app, hobby=Hobby.GUITAR)    &gt;&gt;&gt; person.serialize()    {'hobby': 'guitar'}    &gt;&gt;&gt; Person.deserialize({&quot;hobby&quot;: &quot;biking&quot;}, app=app)    Person(hobby=&lt;Hobby.BIKING: 2&gt;)**Example**: Serialize an `Enum` using provided serializer/deserializer... code:: python    &gt;&gt;&gt; from enum import Enum    &gt;&gt;&gt; from objetto import Application, Object, attribute    &gt;&gt;&gt; from objetto.serializers import EnumSerializer    &gt;&gt;&gt; from objetto.deserializers import EnumDeserializer    &gt;&gt;&gt; class Hobby(Enum):    ...     GUITAR = 1    ...     BIKING = 2    ...    &gt;&gt;&gt; class Job(Enum):    ...     PROGRAMMER = 1    ...     TEACHER = 2    ...    &gt;&gt;&gt; class Person(Object):    ...     hobby = attribute(    ...         Hobby,    ...         serializer=EnumSerializer(),    ...         deserializer=EnumDeserializer(Hobby),    ...     )    ...     job = attribute(    ...         Job,    ...         serializer=EnumSerializer(by_name=True),    ...         deserializer=EnumDeserializer(Job, by_name=True),    ...     )    ...    &gt;&gt;&gt; app = Application()    &gt;&gt;&gt; person = Person(app, hobby=Hobby.GUITAR, job=Job.PROGRAMMER)    &gt;&gt;&gt; serialized = person.serialize()    &gt;&gt;&gt; serialized[&quot;hobby&quot;]    1    &gt;&gt;&gt; serialized[&quot;job&quot;]    'PROGRAMMER'    &gt;&gt;&gt; Person.deserialize({&quot;hobby&quot;: 2, &quot;job&quot;: &quot;TEACHER&quot;}, app=app)    Person(hobby=&lt;Hobby.BIKING: 2&gt;, job=&lt;Job.TEACHER: 2&gt;)... And More!*************Take a look at the API documentation to learn more about `Objetto`.</longdescription>
</pkgmetadata>