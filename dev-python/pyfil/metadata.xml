<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>pyfil=====Python one-liners in the spirit of Perl and AWK.``pyfil`` stands for PYthon FILter. One of the tenants of the `Unixdesign`_ is that every program is a filter. It's especially obvious ofprograms, like ``grep``, ``sed``, ``sort``, ``tr``, etc.One notable example is ``awk`` -- a Turing-complete, interpretedlanguage for parsing text. While AWK scripts are still in use and it's afine language, it has been superseded for parsing scripts by moregeneral languages like Perl and later Python and Ruby. However, AWK wasdesigned to be especially useful in the shell as a filter, and it isstill in very commonly used for that today (in part because it is onevery \*nix system, but also because it's great at what it does). AWK isable to be any arbitrary text filter that doesn't come as a coreutil.``perl -e`` is also quite good as a filter, and Ruby has made a valiantattempt to do so as well.While Python does have a few good one-line uses (``python -mhttp.server``), some elements of its design make it less suited than theafore-mentioned languages. ``pyfil`` is one of several attempts toaddress this issue. In particular, it takes a lot of cues in thedesign of its CLI from AWK and Perl, and aims fundamentally to be acapable text filter, though it will evaluate any arbitrary Pythonexpression and print its value (with modules being imported implicitlyas required).As a more modern touch, it also has a special emphasis oninteroperability with JSON. If the return value of the evaluatedexpression is a container type, Python will attempt to serialize it asJSON before printing, so you can pipe output into other tools that dealwith JSON, store it to a file for later use, or send it over http. This,combined with the ability to read JSON from stdin (with --json) make``pyfil`` a good translator between the web, which tends to speak JSONthese days, and the POSIX environment, which tends to think about datain terms of lines in a file (frequently with multiple fields per line).pyfil is in pypi (i.e. you can get it easily with pip, if you want)note:  pyfil has only been tested with python3, and only has wheels available  for python3.. _unix design: https://en.wikipedia.org/wiki/Unix_philosophy.. contents::similar projects----------------pyfil ain't the first project to try something like this. Here are someother cracks at this problem:- oneliner_- pyp_- pyle_- funcpy_- red_- pyeval_- quickpy_Don't worry. I've stolen some of their best ideas already, and I will goon stealing as long as it takes!.. _oneliner: http://python-oneliner.readthedocs.io/en/latest/.. _pyp: http://code.google.com/p/pyp.. _pyle: https://github.com/aljungberg/pyle.. _funcpy: http://www.pixelbeat.org/scripts/funcpy.. _red: https://bitbucket.org/johannestaas/red.. _pyeval: https://bitbucket.org/nejucomo/pyeval/wiki/Home.. _quickpy: https://github.com/slezica/quick-pyusage-----.. code:: pyfil [-h] [-l] [-x] [-q] [-j] [-o] [-b PRE] [-e POST] [-s] [-F PATTERN]       [-n STRING] [-R] [-S] [-H EXCEPTION_HANDLER]       expression [expression ...]positional arguments:  expression            expression(s) to be executed. If multiple expression                        arguments are given, and --exec is not used, the value                        of the previous expression is available as 'x' in the                        following expression. if --exec is used, all                        assignment must be explicit.optional arguments:  -h, --help            show this help message and exit  -l, --loop            for n, i in enumerate(stdin): expressions  -x, --exec            use exec instead of eval. statements are allowed, but                        automatic printing is lost. doesn't affect --post  -q, --quiet           suppress automatic printing. doesn't affect --post  -j, --json            load stdin as json into object 'j'; If used with                        --loop, treat each line of stdin as a new object  -J, --real-dict-json  like -j, but creates real dictionaries instead of the                        wrapper that allows dot syntax.  -o, --force-oneline-json                        outside of loops and iterators, objects serialzed to                        json print with two-space indent. this forces this                        forces all json objects to print on a single line.  -b PRE, --pre PRE     statement to evaluate before expression args. multiple                        statements may be combined with ';'. no automatic                        printing  -e POST, --post POST  expression to evaluate after the loop. always handeled                        by eval, even if --exec, and always prints return                        value, even if --quiet. implies --loop  -s, --split           split lines from stdin on whitespace into list 'f'.                        implies --loop  -F PATTERN, --field-sep PATTERN                        regex used to split lines from stdin into list 'f'.                        implies --loop  -n STRING, --join STRING                        join items in iterables with STRING  -R, --raise-errors    raise errors in evaluation and stop execution                        (default: print message to stderr and continue)  -S, --silence-errors  suppress error messages  -H EXCEPTION_HANDLER, --exception-handler EXCEPTION_HANDLER                        specify exception handler with the format 'Exception:                        alternative expression to eval'available objects~~~~~~~~~~~~~~~~~``pyfil`` automatically imports any modules used in expressions.If you'd like to create any other objects to use in the executionenvironment ``~/.config/pyfil-env.py`` and put things in it.default objects:- l = []- d = {}These are empty containers you might wish to add items to duringiteration, for example.- x is the value of the previous expression unless --exec was used.The execution environment also has a special object for stdin,creatively named ``stdin``. This differs from sys.stdin in that itstrips trailing newlines when you iterate over it, and it hasa property, ``stdin.l``, which returns a list of the lines (withoutnewlines). If you do want the newlines, access sys.stdin directly.stdin inherits the rest of its methods from sys.stdin, so you can usestdin.read() to get a string of all lines, if that's what you need.Certain other flags may create additional objects in the evaluationcontext.- --loop (or anything that implies --loop) create ``n`` and ``i``.- --json creates ``j``.- --split or --field_sep create ``f``  Check the flag descriptions for further details.output~~~~~~automatic printing..................By default, pyfil prints the return value of expressions. Differenttypes of objects use different printing conventions.- ``None`` does not print (as in the REPL)- strings are sent directly to to ``print()``- iterators (not other iterables) print each item on a new line.- other objects are serialized as json. If an object cannot be  serialized as json, it is sent directly to print().- all of these are overridden by --joinIterators will also try to serialize each returned object as json ifthey are not strings. json objects will be indented if only one objectis being printed. If --loop is set or several of objects are beingserialzed from an iterator, it will be one object per-line.--force-oneline-json extends this policy to printing single json objectsas well.examples:.. code:: bash  $ # None gets skipped  $ pyfil None  $ # strings and numbers just print  $ pyfil sys.platfrom  linux  $ pyfil math.pi  3.141592653589793  $ # objects try to print as json  $ pyfil sys.path  [    &quot;/home/ninjaaron/.local/bin&quot;,    &quot;/usr/lib/python35.zip&quot;,    &quot;/usr/lib/python3.5&quot;,    &quot;/usr/lib/python3.5/plat-linux&quot;,    &quot;/usr/lib/python3.5/lib-dynload&quot;,    &quot;/home/ninjaaron/.local/lib/python3.5/site-packages&quot;,    &quot;/usr/lib/python3.5/site-packages&quot;  ]  $ pyfil '{i: n for n, i in enumerate(sys.path)}'  {    &quot;/usr/lib/python3.5/plat-linux&quot;: 3,    &quot;/usr/lib/python35.zip&quot;: 1,    &quot;/usr/lib/python3.5&quot;: 2,    &quot;/usr/lib/python3.5/lib-dynload&quot;: 4,    &quot;/usr/lib/python3.5/site-packages&quot;: 6,    &quot;/home/ninjaaron/.local/lib/python3.5/site-packages&quot;: 5,    &quot;/home/ninjaaron/.local/bin&quot;: 0  }  $ # unless they can't  $ pyfil '[list, print, re]'  [&lt;class 'list'&gt;, &lt;built-in function print&gt;, &lt;module 're' from '/usr/lib/python3.5/re.py'&gt;]  $ # iterators print each item on a new line, applying the same conventions  $ pyfil 'iter(sys.path)'  /home/ninjaaron/src/py/pyfil/venv/bin  /home/ninjaaron/src/py/pyfil  /usr/lib/python35.zip  /usr/lib/python3.5  /usr/lib/python3.5/plat-linux  /usr/lib/python3.5/lib-dynload  /home/ninjaaron/src/py/pyfil/venv/lib/python3.5/site-package  $ pyfil 'i.split(&quot;/&quot;)[1:] for i in sys.path'  [&quot;home&quot;, &quot;ninjaaron&quot;, &quot;src&quot;, &quot;py&quot;, &quot;pyfil&quot;, &quot;venv&quot;, &quot;bin&quot;]  [&quot;home&quot;, &quot;ninjaaron&quot;, &quot;src&quot;, &quot;py&quot;, &quot;pyfil&quot;]  [&quot;usr&quot;, &quot;lib&quot;, &quot;python35.zip&quot;]  [&quot;usr&quot;, &quot;lib&quot;, &quot;python3.5&quot;]  [&quot;usr&quot;, &quot;lib&quot;, &quot;python3.5&quot;, &quot;plat-linux&quot;]  [&quot;usr&quot;, &quot;lib&quot;, &quot;python3.5&quot;, &quot;lib-dynload&quot;]  [&quot;home&quot;, &quot;ninjaaron&quot;, &quot;src&quot;, &quot;py&quot;, &quot;pyfil&quot;, &quot;venv&quot;, &quot;lib&quot;, &quot;python3.5&quot;, &quot;site-packages&quot;]Most JSON is also valid Python, but be aware that you may occasionallysee ``null`` instead of ``None`` along with ``true`` and ``false``instead of ``True`` and ``False``, and your tuples will look like list.I guess that's a risk I'm willing to take. (The rational for this isthat pyfil is more about composability in the shell than printing validPython literals. JSON is becoming the defacto standard forserialization.)suppressing output and using statements.......................................Because these defaults use eval() internally to get value ofexpressions, statements may not be used. exec() supports statements, butit does not return the value of expressions when they are evaluated.When the -x/--exec flag is used, automatic printing is suppressed, andexpressions are evaluated with exec, so statements, such as assignments,may be used. Values may still be printed explicitly.--quite suppresses automatic printing, but eval is still used.The --post option is immune from --quiet and --exec. It will always beevaluated with ``eval()``, and it will always try to print. The onlydifference is that if --quiet or --exec was used, json will be printedwith indentation unless --force-oneline-json is used.If the -b/--pre option is used, its argument will always be run with``exec``.using files for input and output~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``pyfil`` doesn't have any parameters for input and output files. Instead,use redirection... code:: bash  pyfil -s 'i.upper()' &gt; output.txt &lt; input.txtusing multiple expression arguments~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``pyfil`` can take as many expressions as desired as arguments. When usedwith --exec, this works pretty much as expected, and assignment must bedone manually.Without --exec, the return value of each expression is assigned to thevariable ``x``, which can be used in the next expression. The finalvalue of ``x`` is what is ultimately printed, not any intermediatevalues... code:: bash  $ pyfil 'reversed(&quot;abcd&quot;)' 'i.upper() for i in x'  D  C  B  Alooping over stdin~~~~~~~~~~~~~~~~~~one can do simple loops with a generator expression. (note that anyexpression that evaluates to an iterator will print each item on a newline unless the ``--join`` option is specified.).. code:: bash    $ ls / | pyfil 'i.upper() for i in stdin'    BIN@    BOOT/    DEV/    ETC/    HOME/    ...However, with the ``-l``/``--loop`` flag, pyfil loops over stdin in acontext like this:.. code:: python    for n, i in enumerate(stdin):        expressionsTherefore, the above loop can also be written thusly:.. code:: bash    $ ls / | pyfil -l 'i.upper()'``--pre`` and ``--post`` (-b and -e) options can be used to specifyactions to run before or after the loop. Note that the --pre option isrun with exec instead of eval, and therefore output is never printed,and statements may be used. This is for things like initializingcontainer types. --post is automatically printed and statements are notallowed (even if --exec is used). --loop is implied if ``--post`` isused. ``--pre`` can be used without a --loop to do assignments (orwhatever else you may want to do with a statement).Using ``-s``/``--split`` or ``-F``/``--field-sep`` for doing awk thingsalso implies --loop. The resulting list is named ``f`` in the executionenvironment, in quazi-Perl fashion. (oh, and that list is actually asubclass of collections.UserList that returns an empty string if theindex doesn't exist, so it acts more like awk with empty fields, ratherthan throwing and error).json input~~~~~~~~~~``pyfil`` can parse json objects from stdin with the ``-j``/``--json``flag. They are passed into the environment as the ``j`` object.combining with the --loop flag will treat stdin as one json object perline. json objects support dot syntax for attribute access, e.g.``j.someattr.attr_of_someattr``There are occasionally functions that require &quot;real&quot; dictionaries andwon't work with this special subclass that supports dot access. Insuch cases, use ``-J``/``--real-dict-json`` to get unadultered Pythondictionaries.formatting output (and 'awk stuff')~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~It's probably obvious that the most powerful way to format strings iswith Python's str.format method and the ``-F`` or ``-s`` options... code:: bash  $ ls -l /|pyfil -s '&quot;{0}\t{2}\t{8}&quot;.format(*f)'  IndexError: tuple index out of range  lrwxrwxrwxrootbin  drwxr-xr-xrootboot/  drwxr-xr-xrootdev/  drwxr-xr-xrootetc/  drwxr-xr-xroothome/  lrwxrwxrwxrootlib  ...However, you will note that using ``string.format(*f)`` produces anerror and does not print anything to stdout (error message is sent tostderr; see error handling for more options) for lines without enoughfields, which may not be the desired behavior when dealing with linescontaining arbitrary numbers of fields.For simpler cases, you may wish to use the ``-n``/``--join`` option,which will join any iterables with the specified string before printing,and, in the case of the ``f`` list, will replace any none-existentfields with an empty string... code:: bash  $ ls -l /|pyfil -sn '\t' 'f[0], f[2], f[8]'  total  lrwxrwxrwxrootbin  drwxr-xr-xrootboot/  drwxr-xr-xrootdev/  drwxr-xr-xrootetc/  drwxr-xr-xroothome/  lrwxrwxrwxrootlibIn this case, the first line of ``ls -l /`` provides values for allavailable fields.Technical note:    The separator specified with the ``--join`` option is implemented    internally as ``ast.literal_eval(&quot;'''&quot;+STRING.replace(&quot;'&quot;,    r&quot;\'&quot;)+&quot;'''&quot;)``. If one works hard at it, it is possible to pass    values which will cause pyfil to crash; i.e. patterns ending with a    backslash. Keep in mind rules about escape sequences in the shell and    in python if you absolutely must have a pattern that terminates with    a backslash. (The reason it is implemented this way is to allow the    use of escape sequences that are meaningful to the python, but not    the shell, such as \\n, \\t, \\x, \\u, etc.)examples~~~~~~~~*I realize that it's much better to do most of these things with theoriginal utility. This is just to give some ideas of how to use `pyfil`*replace ``wc -l``:.. code:: bash  $ ls / | pyfil 'len(stdin.l)'  20replace ``fgrep``:.. code:: bash  $ ls / | pyfil '(i for i in stdin if &quot;v&quot; in i)'  $ ls / | pyfil -l 'i if &quot;v&quot; in i else None'replace ``grep``:.. code:: bash  $ ls / | pyfil 'filter(lambda x: re.search(&quot;^m&quot;, x), stdin)'  $ ls / | pyfil -lS 're.search(&quot;^m&quot;, i).string)'  $ # using the -S option to suppress a ton of error messagesreplace ``sed 's/...``:.. code:: bash  $ ls / | pyfil -l 're.sub(&quot;^([^aeiou][aeiou][^aeiou]\W)&quot;, lambda m: m.group(0).upper(), i)'  BIN@  boot/  data/  DEV/  etc/  ...This example illustrates that, while you might normally prefer ``sed``for replacement tasks, the ability to define a replacement function with``re.sub`` does offer some interesting possibilities. Indeed, someonefamiliar with coreutils should never prefer to do something they alreadycomfortable doing the traditional way with ``pyfil`` (coreutils areheavily optimized). Python is interesting for this use-case because itoffers great logic, anonymous functions and all kinds of other goodiesthat only full-fledged, modern programming language can offer. Usecoreutiles for the jobs they were designed to excel in. Use ``pyfil`` todo whatever they can't... and seriously, how will coreutils do this?:.. code:: bash  $ wget -qO- http://pypi.python.org/pypi/pyfil/json/ | pyfil -j 'j.urls[0].filename'  pyfil-0.5-py3-none-any.whl  $ ls -l | pyfil -qSs \  &quot;d.update({f[8]: {'permissions': f[0], 'user': f[2], 'group': f[3],                    'size': int(f[4]), 'timestamp': ' '.join(f[5:8])}})&quot; \  --post 'd'.. code:: json  {    &quot;README.rst&quot;: {      &quot;group&quot;: &quot;users&quot;,      &quot;user&quot;: &quot;ninjaaron&quot;,      &quot;permissions&quot;: &quot;-rw-r--r--&quot;,      &quot;timestamp&quot;: &quot;Sep 6 20:55&quot;,      &quot;size&quot;: 18498    },    &quot;pyfil/&quot;: {      &quot;group&quot;: &quot;users&quot;,      &quot;user&quot;: &quot;ninjaaron&quot;,      &quot;permissions&quot;: &quot;drwxr-xr-x&quot;,      &quot;timestamp&quot;: &quot;Sep 6 20:20&quot;,      &quot;size&quot;: 16    },    &quot;setup.py&quot;: {      &quot;group&quot;: &quot;users&quot;,      &quot;user&quot;: &quot;ninjaaron&quot;,      &quot;permissions&quot;: &quot;-rw-r--r--&quot;,      &quot;timestamp&quot;: &quot;Sep 6 20:30&quot;,      &quot;size&quot;: 705    },    &quot;LICENSE&quot;: {      &quot;group&quot;: &quot;users&quot;,      &quot;user&quot;: &quot;ninjaaron&quot;,      &quot;permissions&quot;: &quot;-rw-r--r--&quot;,      &quot;timestamp&quot;: &quot;Sep 3 13:32&quot;,      &quot;size&quot;: 1306    }  }Other things which might be difficult with coreutils:.. code:: bash  $ ls / | pyfil -n '  ' 'reversed(stdin.l)'  var/  usr/  tmp/  sys/  srv/  sbin@  run/  root/  proc/  opt/  ...  $ # ^^ also, `ls /|pyfil -n '  ' 'stdin.l[::-1]'error handling~~~~~~~~~~~~~~If pyfil encounters an exception while evaluating user input the defaultis to print the error message to stderr and continue (if looping overstdin), as we saw in the section on formatting output. However, errorscan also be silenced entirely with the ``-S``/``--silence-errors``option. In the below example, the first line produces an error, but wedon't hear about it... code:: bash  $ ls -l /|pyfil -sS '&quot;{0}\t{2}\t{8}&quot;.format(*f)'   lrwxrwxrwxrootbin  drwxr-xr-xrootboot/  drwxr-xr-xrootdev/  drwxr-xr-xrootetc/  drwxr-xr-xroothome/  lrwxrwxrwxrootlib  ...Alternatively, errors may be raised when encountered, which will stopexecution and give a (fairly useless, in this case) traceback. This isdone with the ``-R``/``--raise-errors`` flag... code:: bash  $ ls -l /|pyfil -sR '&quot;{0}\t{2}\t{8}&quot;.format(*f)'  Traceback (most recent call last):    File &quot;/home/ninjaaron/src/py/pyfil/venv/bin/pyfil&quot;, line 9, in &lt;module&gt;      load_entry_point('pyfil', 'console_scripts', 'pyfil')()    File &quot;/home/ninjaaron/src/py/pyfil/pyfil/pyfil.py&quot;, line 242, in main      run(expressions, a, namespace)    File &quot;/home/ninjaaron/src/py/pyfil/pyfil/pyfil.py&quot;, line 164, in run      handle_errors(e, args)    File &quot;/home/ninjaaron/src/py/pyfil/pyfil/pyfil.py&quot;, line 134, in handle_errors      raise exception    File &quot;/home/ninjaaron/src/py/pyfil/pyfil/pyfil.py&quot;, line 162, in run      value = func(expr, namespace)    File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;  IndexError: tuple index out of rangeIn addition to these two handlers, it is possible to specify arudimentary custom handler with the ``-H``/``--exception-handler``flags. The syntax is ``-H 'Exception: expression'``, where ``Exception``can be any builtin exception class (including Exception, to catch allerrors), and ``expression`` is the alternative expression to evaluate(and print, if not --quiet)... code:: bash  $ ls -l /|pyfil -sH 'IndexError: i' '&quot;{0}\t{2}\t{8}&quot;.format(*f)'  total 32  lrwxrwxrwxrootbin  drwxr-xr-xrootboot/  drwxr-xr-xrootdev/  drwxr-xr-xrootetc/  drwxr-xr-xroothome/  lrwxrwxrwxrootlib  ...In this case, we've chosen to print line without any additionalformatting. If other errors are encountered, it will fall back to otherhandlers (``-S``, ``-R``, or the default). For more sophisticated errorhandling... write a real Python script, where you can handle to yourheart's content.Also note that this case is possible to handle with a test instead of anexception handler because ``f`` is a special list that will return anempty string instead of throw an index error if the index is out ofrange:``ls -l / | pyfil -s '&quot;{0}\t{2}\t{8}&quot;.format(*f) if f[2] else i'``Easy-peasy.</longdescription>
</pkgmetadata>