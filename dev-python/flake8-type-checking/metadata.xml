<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Package version](https://img.shields.io/pypi/v/flake8-type-checking.svg)](https://pypi.org/project/flake8-type-checking/)[![Code coverage](https://codecov.io/gh/sondrelg/flake8-type-checking/branch/main/graph/badge.svg)](https://codecov.io/gh/sondrelg/flake8-type-checking)[![Test status](https://github.com/sondrelg/flake8-type-checking/actions/workflows/testing.yml/badge.svg)](https://github.com/snok/flake8-type-checking/actions/workflows/testing.yml)[![Supported Python versions](https://img.shields.io/badge/python-3.8%2B-blue)](https://pypi.org/project/flake8-type-checking/)[![Checked with mypy](http://www.mypy-lang.org/static/mypy_badge.svg)](http://mypy-lang.org/)# flake8-type-checkingLets you know which imports to move in or out of[type-checking](https://docs.python.org/3/library/typing.html#typing.TYPE_CHECKING) blocks.The plugin assumes that the imports you only use for type hinting*are not* required at runtime. When imports aren't strictly required at runtime, it means we can guard them.Guarding imports provides 3 major benefits:- 🔧&amp;nbsp;&amp;nbsp;It reduces import circularity issues,- 🧹&amp;nbsp;&amp;nbsp;It organizes imports, and- 🚀&amp;nbsp;&amp;nbsp;It completely eliminates the overhead of type hint imports at runtime&lt;br&gt;Essentially, this code:```pythonimport pandas  # 15mb libraryx: pandas.DataFrame```becomes this:```pythonfrom typing import TYPE_CHECKINGif TYPE_CHECKING:    import pandas  # &lt;-- no longer imported at runtimex: &quot;pandas.DataFrame&quot;```More examples can be found in the [examples](#examples) section.&lt;br&gt;If you're using [pydantic](https://pydantic-docs.helpmanual.io/),[fastapi](https://fastapi.tiangolo.com/), or [cattrs](https://github.com/python-attrs/cattrs)see the [configuration](#configuration) for how to enable support.## Primary featuresThe plugin will:- Tell you when an import should be moved into a type-checking block- Tell you when an import should be moved out againAnd depending on which error code range you've opted into, it will tell you- Whether you need to add a `from __future__ import annotations` import- Whether you need to quote an annotation- Whether you can unquote a quoted annotation## Error codes| Code  | Description                                                                        ||-------|------------------------------------------------------------------------------------|| TC001 | Move application import into a type-checking block                                 || TC002 | Move third-party import into a type-checking block                                 || TC003 | Move built-in import into a type-checking block                                    || TC004 | Move import out of type-checking block. Import is used for more than type hinting. || TC005 | Found empty type-checking block                                                    || TC006 | Annotation in typing.cast() should be a string literal                             |## Choosing how to handle forward referencesYou need to choose whether to opt-into using the`TC100`- or the `TC200`-range of error codes.They represent two different ways of solving the same problem, so please only choose one.`TC100` and `TC101` manage forward references by taking advantage of[postponed evaluation of annotations](https://www.python.org/dev/peps/pep-0563/).| Code  | Description                                         ||-------|-----------------------------------------------------|| TC100 | Add 'from \_\_future\_\_ import annotations' import || TC101 | Annotation does not need to be a string literal     |`TC200` and `TC201` manage forward references using [string literals](https://www.python.org/dev/peps/pep-0484/#forward-references).| Code  | Description                                         ||-------|-----------------------------------------------------|| TC200 | Annotation needs to be made into a string literal   || TC201 | Annotation does not need to be a string literal     |## Enabling error rangesAdd `TC` and `TC1` or `TC2` to your flake8 config like this:```ini[flake8]max-line-length = 80max-complexity = 12...ignore = E501# You can use 'extend-select' (new in flake8 v4):extend-select = TC, TC2# OR 'select':select = C,E,F..., TC, TC2  # or TC1# OR 'enable-extensions':enable-extensions = TC, TC2  # or TC1```If you are unsure which `TC` range to pick, see the [rationale](#rationale) for more info.## Installation```shellpip install flake8-type-checking```## ConfigurationThese options are configurable, and can be set in your flake8 config.### Exempt modulesIf you wish to exempt certain modules fromneeding to be moved into type-checking blocks, you can specify whichmodules to ignore.- **setting name**: `type-checking-exempt-modules`- **type**: `list````ini[flake8]type-checking-exempt-modules = typing_extensions  # default []```### StrictThe plugin, by default, will report TC00[1-3] errorsfor imports if there aren't already other imports from the same module.When there are other imports from the same module,the import circularity and performance benefits no longerapply from guarding an import.When strict mode is enabled, the plugin will flag allimports that *can* be moved.- **setting name**: `type-checking-strict`- **type**: `bool````ini[flake8]type-checking-strict = true  # default false```### Pydantic supportIf you use Pydantic models in your code, you should enable Pydantic support.This will treat any class variable annotation as being needed during runtime.- **name**: `type-checking-pydantic-enabled`- **type**: `bool````ini[flake8]type-checking-pydantic-enabled = true  # default false```### Pydantic support base-class passlistDisabling checks for all class annotations is a little aggressive.If you feel comfortable that all base classes named, e.g., `NamedTuple` are *not* Pydantic models,then you can pass the names of the base classes in this setting, to re-enable checking for classeswhich inherit from them.- **name**: `type-checking-pydantic-enabled-baseclass-passlist`- **type**: `list````ini[flake8]type-checking-pydantic-enabled-baseclass-passlist = NamedTuple, TypedDict  # default []```### FastAPI supportIf you're using the plugin for a FastAPI project,you should enable support. This will treat the annotationsof any decorated function as needed at runtime.Enabling FastAPI support will also enable Pydantic support.- **name**: `type-checking-fastapi-enabled`- **type**: `bool````ini[flake8]type-checking-fastapi-enabled = true  # default false```One more thing to note for FastAPI users is that dependencies(functions used in `Depends`) will produce false positives, unlessyou enable dependency support as described below.### FastAPI dependency supportIn addition to preventing false positives for decorators, we *can*prevent false positives for dependencies. We are making a pretty badtrade-off however: by enabling this option we treat every annotationin every function definition across your entire project as a possibledependency annotation. In other words, we stop linting all functionannotations completely, to avoid the possibility of false positives.If you prefer to be on the safe side, you should enable this - otherwiseit might be enough to be aware that false positives can happen for functionsused as dependencies.Enabling dependency support will also enable FastAPI and Pydantic support.- **name**: `type-checking-fastapi-dependency-support-enabled`- **type**: `bool````ini[flake8]type-checking-fastapi-dependency-support-enabled = true  # default false```### Cattrs supportIf you're using the plugin in a project which uses `cattrs`,you can enable support. This will treat the annotationsof any decorated `attrs` class as needed at runtime, since`cattrs.unstructure` calls will fail when loadingclasses where types are not available at runtime.Note: the cattrs support setting does not yet detect andignore class var annotations on dataclasses or other non-attrs class types.This can be added in the future if needed.- **name**: `type-checking-cattrs-enabled`- **type**: `bool````ini[flake8]type-checking-cattrs-enabled = true  # default false```## RationaleWhy did we create this plugin?Good type hinting typically requires a lot of project imports, which can increasethe risk of [import cycles](https://mypy.readthedocs.io/en/stable/runtime_troubles.html?#import-cycles)in a project. The recommended way of preventing this problem is to use `typing.TYPE_CHECKING` blocksto guard these types of imports. In particular, `TC001` helps protect against this issue.Once imports are guarded, they will no longer be evaluated/imported during runtime. Theconsequence of this is that these imports can no longer be treated as if theywere imported outside the block. Instead we need to use [forward references](https://www.python.org/dev/peps/pep-0484/#forward-references).For Python version `&gt;= 3.7`, there are actually two ways of solving this issue.You can either make your annotations string literals, or you can use a `__futures__` import to enable [postponed evaluation of annotations](https://www.python.org/dev/peps/pep-0563/).See [this](https://stackoverflow.com/a/55344418/8083459) excellent stackoverflow answerfor a great explanation of the differences.## Examples&lt;details&gt;&lt;summary&gt;&lt;b&gt;Performance example&lt;/b&gt;&lt;/summary&gt;Imports for type hinting can have a performance impact.```pythonimport pandasdef dataframe_length(df: pandas.DataFrame) -&gt; int:    return len(df)```In this example, we import a 15mb library, for a single type hint.We don't need to perform this operation at runtime, *at all*.If we know that the import will not otherwise be needed by surrounding code,we can simply guard it, like this:```pythonfrom typing import TYPE_CHECKINGif TYPE_CHECKING:    import pandas  # &lt;-- no longer imported at runtimedef dataframe_length(df: &quot;pandas.DataFrame&quot;) -&gt; int:    return len(df)```Now the import is no longer made at runtime. If you're unsure about how this works, see the [mypy docs](https://mypy.readthedocs.io/en/stable/runtime_troubles.html?#typing-type-checking) for a basic introduction.&lt;/details&gt;&lt;details&gt;&lt;summary&gt;&lt;b&gt;Import circularity example&lt;/b&gt;&lt;/summary&gt;**Bad code**`models/a.py````pythonfrom models.b import Bclass A(Model):    def foo(self, b: B): ...````models/b.py````pythonfrom models.a import Aclass B(Model):    def bar(self, a: A): ...```Will result in these errors```shell&gt;&gt; a.py: TC002 Move third-party import 'models.b.B' into a type-checking block&gt;&gt; b.py: TC002 Move third-party import 'models.a.A' into a type-checking block```and consequently trigger these errors if imports are purely moved into type-checking block, without proper forward reference handling```shell&gt;&gt; a.py: TC100 Add 'from __future__ import annotations' import&gt;&gt; b.py: TC100 Add 'from __future__ import annotations' import```or```shell&gt;&gt; a.py: TC200 Annotation 'B' needs to be made into a string literal&gt;&gt; b.py: TC200 Annotation 'A' needs to be made into a string literal```**Good code**`models/a.py````python# TC1from __future__ import annotationsfrom typing import TYPE_CHECKINGif TYPE_CHECKING:    from models.b import Bclass A(Model):    def foo(self, b: B): ...```or```python# TC2from typing import TYPE_CHECKINGif TYPE_CHECKING:    from models.b import Bclass A(Model):    def foo(self, b: 'B'): ...````models/b.py````python# TC1from __future__ import annotationsfrom typing import TYPE_CHECKINGif TYPE_CHECKING:    from models.a import Aclass B(Model):    def bar(self, a: A): ...```or```python# TC2from typing import TYPE_CHECKINGif TYPE_CHECKING:    from models.a import Aclass B(Model):    def bar(self, a: 'A'): ...```&lt;/details&gt;&lt;details&gt;&lt;summary&gt;&lt;b&gt;Examples from the wild&lt;/b&gt;&lt;/summary&gt;Here are a few examples of public projects that use `flake8-type-checking`:- [Example from the Poetry codebase](https://github.com/python-poetry/poetry/blob/714c09dd845c58079cff3f3cbedc114dff2194c9/src/poetry/factory.py#L1:L33)- [Example from the asgi-correlation-id codebase](https://github.com/snok/asgi-correlation-id/blob/main/asgi_correlation_id/middleware.py#L1:L12)&lt;/details&gt;## Running the plugin as a pre-commit hookYou can run this flake8 plugin as a [pre-commit](https://github.com/pre-commit/pre-commit) hook:```yaml- repo: https://github.com/pycqa/flake8  rev: 4.0.1  hooks:    - id: flake8      additional_dependencies:        - flake8-type-checking```## ContributingPlease feel free to open an issue or a PR 👏</longdescription>
</pkgmetadata>