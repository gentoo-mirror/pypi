<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Always wanted to add custom operators to your functions ?```pythona = 2 + (1,2,3) /dot/ (4,5,6)                 # a = 2 + dot((1,2,3), (4,5,6))Y = [1,2,7,0,2,0] |no_zero |plus(1) |to(set)  # Y == {2,3,8}square = elipartial(pow, ..., 2)              # square = lambda x: pow(x, 2)display = hex *compose* ord                   # display = lambda x: hex(ord(x))```This example shows how infix operators can be created,the library also introduces bash like _pipes_ andshortcuts to create partial functions or functioncomposition inspired by functional languages.# Using infixInfix operators can be created using the `infix` class.It works for existing functions, like `numpy.dot`:```pythonimport numpydot = infix(numpy.dot)a = (1,2,3) /dot/ (4,5,6)  # use as an infix```If you already have `dot` in your namespace, don't worry, it still works as a function:```pythona = dot((1,2,3), (4,5,6))  # still works as a function```Or for custom functions as a decorator:```python@infixdef crunch(x,y):    &quot;&quot;&quot;    Do a super crunchy operation between two numbers.    &quot;&quot;&quot;    return x + 2 * ya = 1 |crunch| 2  # a = crunch(1, 2)a = crunch(1, 2)  # still workshelp(crunch.function)  # to get help about the initial function```Any binary operator can be used, `1 |f| 2` can be written `1 *f* 2`, `1 %f% 2` or `1 &lt;&lt; f &lt;&lt; 2` but `/` or `|` should be clean for all use cases.Beware if you use `**`, the operator is right to left:    ```pythonb = 1 **f** 2  # a = f(2, 1)```# Useful for dot and cross productDot and cross products are used heavily in mathematics and physics as an infix operator `·` or `×`.```pythonimport numpydot = infix(numpy.dot)a = (1,2,3) /dot/ (4,5,6)a = (1,2,3) |dot| (4,5,6)  # same r = 2 + (1,2,3) /dot/ (4,5,6)  # here &quot;/&quot; has priority over &quot;+&quot; like in normal pythonr = 2 + (1,2,3) *dot* (4,5,6)  # for a dot PRODUCT, &quot;*&quot; seems logicalr = 2 + dot((1,2,3), (4,5,6))  # still works as a functioncross = infix(numpy.cross)tau = (1,2) /cross/ (3,4)Z = (1,2,3) /cross/ (4,5,6)```# Using `|` for low priorityIn some use cases, one want to mix classic operators with function operators,the `|` operator may be used as a low priority operator.```pythonY = A + B |dot| C  # is parsed as Y = (A + B) |dot| CY = A + B /dot/ C  # is parsed as Y = A + (B /dot/ C)```# Useful for fractionsWhen using the `fractions` module, often you want to transition from `float` to `Fraction`.Your current code uses `/` for division and you can just replace the slashes with `/frac/`, the expression stays natural to read.```pythonfrom fractions import Fractionfrac = infix(Fraction)a = 1 + 1 / 3  # 1.3333...a = 1 + 1 /frac/ 3  # Fraction(4, 3)b = 2 * Fraction(a + 3, a + 1)  # very different from '(a + 3) / (a + 1)'b = 2 * (a + 3) /frac/ (a + 1)  # almost identical to '(a + 3) / (a + 1)'```# Useful for ranges, do you like `2..5` in ruby?In many languages, iterating over a range has a notational shortcut, like `2..5` in ruby.Now you can even write `for i in 1 /inclusive/ 5` in python.```python@infixdef inclusive(a,b):    return range(a, b+1)for i in 2 /inclusive/ 5:    print(i)  # 2 3 4 5for i in inclusive(2, 5):    print(i)  # 2 3 4 5```However, redefining `range = infix(range)` is a bad idea because it would break code like `isinstance(x, range)`.In that particuliar example, I would choose `exclusive = infix(range)`.# Useful for isinstance, do you like `instanceof` in Java and Js?In Java and Javascript, testing the class of an object is done via `x instanceof Class`,the python builtin `isinstance` could be enhanced with infix notation or be renamed to `instanceof`.```pythonisinstance = infix(isinstance)assert 1 /isinstance/ intassert [] /isinstance/ (list, tuple)assert 1 / 2 |isinstance| float```# Useful for pipes: postfix (alias to)In bash, a functionality called _pipes_ is useful to reuse an expression and change the behavior by just adding code _at the end_.The library can be used for that.```python@postfixdef no_zero(L):    return [x for x in L if x != 0]@postfixdef plus_one(L):    return [x+1 for x in L]Y = [1,2,7,0,2,0] |no_zero |plus_one  # Y == [2,3,8,3]Y = plus_one(no_zero([1,2,7,0,2,0]))  # Y == [2,3,8,3]```Using `to = postfix` makes it quite readable in a pipe.```python&gt;&gt;&gt; from funcoperators import postfix as to  # funcoperators version 0.x&gt;&gt;&gt; from funcoperators import to             # funcoperators version 1.x&gt;&gt;&gt; 'hello' |to(str.upper) |to(lambda x:x + '!') |to('I said &quot;{}&quot;'.format) |to(print)I said &quot;HELLO!&quot;&gt;&gt;&gt; print('I said &quot;{}&quot;'.format('hello'.upper() + '!'))I said &quot;HELLO!&quot;```# Pipes with arguments: pipe factorySometimes, pipes want extra information, for example in our last example, `no_zero` is a special case of a pipe that filters out a value,use the _pipe factory_ recipe like so:```pythondef filter_out(x):    @postfix    def f(L):        return [y for y in L if y != x]    return f# shorter with a lambdadef filter_out(x):    return postfix(lambda L:[y for y in L if y != x])L = [1,2,7,0,2,0] | filter_out(0)  # L == [2,3,8,3]from funcoperators import mapwiths = '1 2 7 2'.split() | mapwith(int) | to(sum)  # s = 12 = sum(map(int, '1 2 7 2'.split()))from funcoperators import mapwith as Mapfrom funcoperators import filterwith as FilterS = '1 2 7 2'.split() | Map(int) | Filter(lambda x:x &lt; 5) | to(set)```# Useful for format and join```python&gt;&gt;&gt; 42 | format /curryright/ 'x''2a'&gt;&gt;&gt; formatwith = lambda fmt: postfix(lambda value: format(value, fmt))&gt;&gt;&gt; 52 |formatwith('x')'2a'&gt;&gt;&gt; from funcoperators import to&gt;&gt;&gt; 3.1415 |to('{:.02}'.format)'3.1'&gt;&gt;&gt; [1, 2, 7, 2] |mapwith(str) |to('/'.join) |to(print)1/2/7/2```# Function composition (compose, alias circle)In mathematics and functional programming languages, [function composition](https://en.wikipedia.org/wiki/Function_composition) is naturally used using a `circle` operator to write things like `h = f ∘ g`.```pythons = hex(ord('A'))  # s = '0x41'from funcoperators import composedisplay = hex /compose/ ords = display('A')  # s = '0x41'display = hex *circle* ordfrom funcoperators import compose as odisplay = hex -o- ord  # looks like a dot````compose` can have more than two functions.```pythonf = compose(str.upper, hex, lambda x:x+1, ord)  # simple functionf = str.upper /compose/ hex /compose/ (lambda x:x+1) /compose/ ord  # operator```## Using call for inline compose```python&gt;&gt;&gt; print(5 + 2 * 10, 'B', sep='/')25&gt;&gt;&gt; print |call(5 + 2 * 10, 'B', sep='/')25/B&gt;&gt;&gt; print(','.join('abcdef' + 3 * 'x'))a,b,c,d,e,f,x,x,x&gt;&gt;&gt; print *compose* ' '.join |call('abcdef' + 3 * 'x')a,b,c,d,e,f,x,x,x&gt;&gt;&gt; compose(print, ','.join) |call('abcdef' + 3 * 'x')a,b,c,d,e,f,x,x,x``````python&gt;&gt;&gt; len |infixcall| 'hallo' * 315``````python&gt;&gt;&gt; print |callargs| ('a', 5)a 5```# More partial syntaxThe library adds sugar to functools.partial, using functions called `curry` (and variants like `curryright`, `simplecurry`) and `partially`. The name `curry` comes from other languages.```pythondef f(x,y,z):    return x + y + zfrom funcoperators import curryg = f /curry/ 5y = f(2,1)  # y = 8from funcoperators import curryrightsquare = pow /curryright/ 2  # square(x) = x ** 2square = curryright(pow, 2)  # square(x) = x ** 2from funcoperators import provide_right  # alias provide_right = curryrightsquare = provide_right(pow, 2)  # square(x) = x ** 2square = pow /provide_right/ 2  # square(x) = x ** 2from funcoperators import simplecurryg = f |simplecurry(1, z=3)y = g(2)````partially` allows to _upgrade_ a function to provide methods like `f.partial` and provides `f[arg]` to curry.```pythonfrom funcoperators import partially@partiallydef f(x,y,z):    return x - y + 2 * zr = f(1,2,3)g = f[1]  # g = a function with two arguments: y,zr = g(2,3)r = f[1](2,3)r = f[1][2][3]()# Notice that &quot;f[1,2]&quot; doesn't work because it gives only one argument: a tuple (@see partiallymulti)g = f[1]  # gives positional argumentsg = f.val(1)  # gives positional argumentsg = f.key(z=3)  # gives keyword argumentsg = f.partial(1, z=3)  # gives positional and keyword arguments# alias part = assuming = given = where = partialg = f.part(1, z=3)g = f.where(1, z=3)g = f.given(1, z=3)````partiallymulti` allows `f[arg1, arg2]`.   ```pythonfrom funcoperators import partiallymulti@partiallymultidef f(x,y,z):    return x - y + 2 * zr = f(1,2,3)g = f[1,2]  # g = a function with one argument: zr = g(3)```# Using partiallyautoIn functional languages, function composition is sometimes not dissociable from function call,`partiallyauto` only works for methods with N fixed positional arguments.```python@partiallyautodef f(x,y,z):    return x - y + 2 * zr = f(1,2,3)    # r = 6r = f(1)(2)(3)  # r = 6r = f(1)(2,3)   # r = 6g = f(1)    # g = a function with two arguments r = g(2,3)  # r = 6k = g(2)    # k = a function with one argument```# Using Ellipsis    Python's `functools.partial` only works for arguments that will be provided later, one must use keywords arguments.However, not all functions accept keywords arguments, like the builtin `pow`, one can use `curryright` because pow only has two arguments.```pythonsquare = curryright(pow, 2)  # square(x) = x ** 2```The library also proposes to use Python's `...` (`Ellipsis`) as a natural placeholder for arguments.The functions using this convention have a name beginning with `eli`.   ```pythontenexp = elipartial(pow, 10)  # = pow(10, something)y = tenexp(2)  # 10 ** 2square = elipartial(pow, ..., 2)  # = pow(something, 2)y = square(5)  # 5 ** 2square = pow |elicurry(..., 2)  # = pow(something, 2)y = square(5)  # 5 ** 2```If you like the `partially` and `partiallymulti` syntax, there is `bracket` that has all the concepts in one class.```python@bracketdef f(x,y,z):    return x - y + 2 * zr = f(1,2,3)g = f[1, ..., 3]  # g = a function with one argument: yr = g(2)g = f.partial(1, ..., 3)  # as a methodg = f.partial(1, z=3)     # allowing keyword arguments```Here is a more complex example using `elicurry`, we define `show` to be the `print` function with arguments `1`, _something_, `3` and keyword argument `sep='/'`.```pythonshow = print |elicurry(1, ..., 3, sep='/')show(2)  # prints 1/2/3```Let's note that `elicurry` has many aliases:```pythonshow = print |elicurry(1, ..., 3, sep='/')show = print |with_arguments(1, ..., 3, sep='/')show = print |deferredcall(1, ..., 3, sep='/')show = print |latercall(1, ..., 3, sep='/')```    # More examplesSee more examples in the test cases in [source code](https://github.com/robertvandeneynde/python/blob/master/funcoperators.py).# Release NotesVersion 1.0 created some non backward-compatible change (`call`) and included useful use cases (`to`, `mapwith`)</longdescription>
</pkgmetadata>