<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>========Overview========Serialization library for Exceptions and Tracebacks.* Free software: BSD licenseIt allows you to:* `Pickle &lt;https://docs.python.org/3/library/pickle.html&gt;`_ tracebacks and raise exceptions  with pickled tracebacks in different processes. This allows better error handling when running  code over multiple processes (imagine multiprocessing, billiard, futures, celery etc).* Create traceback objects from strings (the ``from_string`` method). *No pickling is used*.* Serialize tracebacks to/from plain dicts (the ``from_dict`` and ``to_dict`` methods). *No pickling is used*.* Raise the tracebacks created from the aforementioned sources.* Pickle an Exception together with its traceback and exception chain  (``raise ... from ...``) *(Python 3 only)***Again, note that using the pickle support is completely optional. You are solely responsible forsecurity problems should you decide to use the pickle support.**Installation============::    pip install tblibDocumentation=============.. contents::   :local:Pickling tracebacks~~~~~~~~~~~~~~~~~~~**Note**: The traceback objects that come out are stripped of some attributes (like variables). But you'll be able to raise exceptions withthose tracebacks or print them - that should cover 99% of the usecases.::    &gt;&gt;&gt; from tblib import pickling_support    &gt;&gt;&gt; pickling_support.install()    &gt;&gt;&gt; import pickle, sys    &gt;&gt;&gt; def inner_0():    ...     raise Exception('fail')    ...    &gt;&gt;&gt; def inner_1():    ...     inner_0()    ...    &gt;&gt;&gt; def inner_2():    ...     inner_1()    ...    &gt;&gt;&gt; try:    ...     inner_2()    ... except:    ...     s1 = pickle.dumps(sys.exc_info())    ...    &gt;&gt;&gt; len(s1) &gt; 1    True    &gt;&gt;&gt; try:    ...     inner_2()    ... except:    ...     s2 = pickle.dumps(sys.exc_info(), protocol=pickle.HIGHEST_PROTOCOL)    ...    &gt;&gt;&gt; len(s2) &gt; 1    True    &gt;&gt;&gt; try:    ...     import cPickle    ... except ImportError:    ...     import pickle as cPickle    &gt;&gt;&gt; try:    ...     inner_2()    ... except:    ...     s3 = cPickle.dumps(sys.exc_info(), protocol=pickle.HIGHEST_PROTOCOL)    ...    &gt;&gt;&gt; len(s3) &gt; 1    TrueUnpickling tracebacks~~~~~~~~~~~~~~~~~~~~~::    &gt;&gt;&gt; pickle.loads(s1)    (&lt;...Exception'&gt;, Exception('fail'...), &lt;traceback object at ...&gt;)    &gt;&gt;&gt; pickle.loads(s2)    (&lt;...Exception'&gt;, Exception('fail'...), &lt;traceback object at ...&gt;)    &gt;&gt;&gt; pickle.loads(s3)    (&lt;...Exception'&gt;, Exception('fail'...), &lt;traceback object at ...&gt;)Raising~~~~~~~::    &gt;&gt;&gt; from six import reraise    &gt;&gt;&gt; reraise(*pickle.loads(s1))    Traceback (most recent call last):      ...      File &quot;&lt;doctest README.rst[14]&gt;&quot;, line 1, in &lt;module&gt;        reraise(*pickle.loads(s2))      File &quot;&lt;doctest README.rst[8]&gt;&quot;, line 2, in &lt;module&gt;        inner_2()      File &quot;&lt;doctest README.rst[5]&gt;&quot;, line 2, in inner_2        inner_1()      File &quot;&lt;doctest README.rst[4]&gt;&quot;, line 2, in inner_1        inner_0()      File &quot;&lt;doctest README.rst[3]&gt;&quot;, line 2, in inner_0        raise Exception('fail')    Exception: fail    &gt;&gt;&gt; reraise(*pickle.loads(s2))    Traceback (most recent call last):      ...      File &quot;&lt;doctest README.rst[14]&gt;&quot;, line 1, in &lt;module&gt;        reraise(*pickle.loads(s2))      File &quot;&lt;doctest README.rst[8]&gt;&quot;, line 2, in &lt;module&gt;        inner_2()      File &quot;&lt;doctest README.rst[5]&gt;&quot;, line 2, in inner_2        inner_1()      File &quot;&lt;doctest README.rst[4]&gt;&quot;, line 2, in inner_1        inner_0()      File &quot;&lt;doctest README.rst[3]&gt;&quot;, line 2, in inner_0        raise Exception('fail')    Exception: fail    &gt;&gt;&gt; reraise(*pickle.loads(s3))    Traceback (most recent call last):      ...      File &quot;&lt;doctest README.rst[14]&gt;&quot;, line 1, in &lt;module&gt;        reraise(*pickle.loads(s2))      File &quot;&lt;doctest README.rst[8]&gt;&quot;, line 2, in &lt;module&gt;        inner_2()      File &quot;&lt;doctest README.rst[5]&gt;&quot;, line 2, in inner_2        inner_1()      File &quot;&lt;doctest README.rst[4]&gt;&quot;, line 2, in inner_1        inner_0()      File &quot;&lt;doctest README.rst[3]&gt;&quot;, line 2, in inner_0        raise Exception('fail')    Exception: failPickling Exceptions together with their traceback and chain (Python 3 only)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~::    &gt;&gt;&gt; try:  # doctest: +SKIP    ...     try:    ...         1 / 0    ...     except Exception as e:    ...         raise Exception(&quot;foo&quot;) from e    ... except Exception as e:    ...     s = pickle.dumps(e)    &gt;&gt;&gt; raise pickle.loads(s)  # doctest: +SKIP    Traceback (most recent call last):      File &quot;&lt;doctest README.rst[16]&gt;&quot;, line 3, in &lt;module&gt;        1 / 0    ZeroDivisionError: division by zero    The above exception was the direct cause of the following exception:    Traceback (most recent call last):      File &quot;&lt;doctest README.rst[17]&gt;&quot;, line 1, in &lt;module&gt;        raise pickle.loads(s)      File &quot;&lt;doctest README.rst[16]&gt;&quot;, line 5, in &lt;module&gt;        raise Exception(&quot;foo&quot;) from e    Exception: fooBaseException subclasses defined after calling ``pickling_support.install()`` will**not** retain their traceback and exception chain pickling.To cover custom Exceptions, there are three options:1. Use ``@pickling_support.install`` as a decorator for each custom Exception    .. code-block:: python        &gt;&gt;&gt; from tblib import pickling_support        &gt;&gt;&gt; # Declare all imports of your package's dependencies        &gt;&gt;&gt; import numpy  # doctest: +SKIP        &gt;&gt;&gt; pickling_support.install()  # install for all modules imported so far        &gt;&gt;&gt; @pickling_support.install        ... class CustomError(Exception):        ...     pass   Eventual subclasses of ``CustomError`` will need to be decorated again.2. Invoke ``pickling_support.install()`` after all modules have been imported and all   Exception subclasses have been declared    .. code-block:: python        &gt;&gt;&gt; # Declare all imports of your package's dependencies        &gt;&gt;&gt; import numpy  # doctest: +SKIP        &gt;&gt;&gt; from tblib import pickling_support        &gt;&gt;&gt; # Declare your own custom Exceptions        &gt;&gt;&gt; class CustomError(Exception):        ...     pass        &gt;&gt;&gt; # Finally, install tblib        &gt;&gt;&gt; pickling_support.install()3. Selectively install tblib for Exception instances just before they are pickled    .. code-block:: python       pickling_support.install(&lt;Exception instance&gt;, [Exception instance], ...)   The above will install tblib pickling for all listed exceptions as well as any other   exceptions in their exception chains.   For example, one could write a wrapper to be used with   `ProcessPoolExecutor &lt;https://docs.python.org/3/library/concurrent.futures.html&gt;`_,   `Dask.distributed &lt;https://distributed.dask.org/&gt;`_, or similar libraries:::    &gt;&gt;&gt; from tblib import pickling_support    &gt;&gt;&gt; def wrapper(func, *args, **kwargs):    ...     try:    ...         return func(*args, **kwargs)    ...     except Exception as e:    ...         pickling_support.install(e)    ...         raiseWhat if we have a local stack, does it show correctly ?-------------------------------------------------------Yes it does::    &gt;&gt;&gt; exc_info = pickle.loads(s3)    &gt;&gt;&gt; def local_0():    ...     reraise(*exc_info)    ...    &gt;&gt;&gt; def local_1():    ...     local_0()    ...    &gt;&gt;&gt; def local_2():    ...     local_1()    ...    &gt;&gt;&gt; local_2()    Traceback (most recent call last):      File &quot;...doctest.py&quot;, line ..., in __run        compileflags, 1) in test.globs      File &quot;&lt;doctest README.rst[24]&gt;&quot;, line 1, in &lt;module&gt;        local_2()      File &quot;&lt;doctest README.rst[23]&gt;&quot;, line 2, in local_2        local_1()      File &quot;&lt;doctest README.rst[22]&gt;&quot;, line 2, in local_1        local_0()      File &quot;&lt;doctest README.rst[21]&gt;&quot;, line 2, in local_0        reraise(*exc_info)      File &quot;&lt;doctest README.rst[11]&gt;&quot;, line 2, in &lt;module&gt;        inner_2()      File &quot;&lt;doctest README.rst[5]&gt;&quot;, line 2, in inner_2        inner_1()      File &quot;&lt;doctest README.rst[4]&gt;&quot;, line 2, in inner_1        inner_0()      File &quot;&lt;doctest README.rst[3]&gt;&quot;, line 2, in inner_0        raise Exception('fail')    Exception: failIt also supports more contrived scenarios-----------------------------------------Like tracebacks with syntax errors::    &gt;&gt;&gt; from tblib import Traceback    &gt;&gt;&gt; from examples import bad_syntax    &gt;&gt;&gt; try:    ...     bad_syntax()    ... except:    ...     et, ev, tb = sys.exc_info()    ...     tb = Traceback(tb)    ...    &gt;&gt;&gt; reraise(et, ev, tb.as_traceback())    Traceback (most recent call last):      ...      File &quot;&lt;doctest README.rst[58]&gt;&quot;, line 1, in &lt;module&gt;        reraise(et, ev, tb.as_traceback())      File &quot;&lt;doctest README.rst[57]&gt;&quot;, line 2, in &lt;module&gt;        bad_syntax()      File &quot;...tests...examples.py&quot;, line 18, in bad_syntax        import badsyntax      File &quot;...tests...badsyntax.py&quot;, line 5        is very bad         ^    SyntaxError: invalid syntaxOr other import failures::    &gt;&gt;&gt; from examples import bad_module    &gt;&gt;&gt; try:    ...     bad_module()    ... except:    ...     et, ev, tb = sys.exc_info()    ...     tb = Traceback(tb)    ...    &gt;&gt;&gt; reraise(et, ev, tb.as_traceback())    Traceback (most recent call last):      ...      File &quot;&lt;doctest README.rst[61]&gt;&quot;, line 1, in &lt;module&gt;        reraise(et, ev, tb.as_traceback())      File &quot;&lt;doctest README.rst[60]&gt;&quot;, line 2, in &lt;module&gt;        bad_module()      File &quot;...tests...examples.py&quot;, line 23, in bad_module        import badmodule      File &quot;...tests...badmodule.py&quot;, line 3, in &lt;module&gt;        raise Exception(&quot;boom!&quot;)    Exception: boom!Or a traceback that's caused by exceeding the recursion limit (here we'reforcing the type and value to have consistency across platforms)::    &gt;&gt;&gt; def f(): f()    &gt;&gt;&gt; try:    ...    f()    ... except RuntimeError:    ...    et, ev, tb = sys.exc_info()    ...    tb = Traceback(tb)    ...    &gt;&gt;&gt; reraise(RuntimeError, RuntimeError(&quot;maximum recursion depth exceeded&quot;), tb.as_traceback())    Traceback (most recent call last):      ...      File &quot;&lt;doctest README.rst[32]&gt;&quot;, line 1, in f        def f(): f()      File &quot;&lt;doctest README.rst[32]&gt;&quot;, line 1, in f        def f(): f()      File &quot;&lt;doctest README.rst[32]&gt;&quot;, line 1, in f        def f(): f()      ...    RuntimeError: maximum recursion depth exceededReference~~~~~~~~~tblib.Traceback---------------It is used by the ``pickling_support``. You can use it too if you want more flexibility::    &gt;&gt;&gt; from tblib import Traceback    &gt;&gt;&gt; try:    ...     inner_2()    ... except:    ...     et, ev, tb = sys.exc_info()    ...     tb = Traceback(tb)    ...    &gt;&gt;&gt; reraise(et, ev, tb.as_traceback())    Traceback (most recent call last):      ...      File &quot;&lt;doctest README.rst[21]&gt;&quot;, line 6, in &lt;module&gt;        reraise(et, ev, tb.as_traceback())      File &quot;&lt;doctest README.rst[21]&gt;&quot;, line 2, in &lt;module&gt;        inner_2()      File &quot;&lt;doctest README.rst[5]&gt;&quot;, line 2, in inner_2        inner_1()      File &quot;&lt;doctest README.rst[4]&gt;&quot;, line 2, in inner_1        inner_0()      File &quot;&lt;doctest README.rst[3]&gt;&quot;, line 2, in inner_0        raise Exception('fail')    Exception: failtblib.Traceback.to_dict```````````````````````You can use the ``to_dict`` method and the ``from_dict`` classmethod toconvert a Traceback into and from a dictionary serializable by the stdlibjson.JSONDecoder::    &gt;&gt;&gt; import json    &gt;&gt;&gt; from pprint import pprint    &gt;&gt;&gt; try:    ...     inner_2()    ... except:    ...     et, ev, tb = sys.exc_info()    ...     tb = Traceback(tb)    ...     tb_dict = tb.to_dict()    ...     pprint(tb_dict)    {'tb_frame': {'f_code': {'co_filename': '&lt;doctest README.rst[...]&gt;',                             'co_name': '&lt;module&gt;'},                  'f_globals': {'__name__': '__main__'},                  'f_lineno': 5},     'tb_lineno': 2,     'tb_next': {'tb_frame': {'f_code': {'co_filename': ...,                                         'co_name': 'inner_2'},                              'f_globals': {'__name__': '__main__'},                              'f_lineno': 2},                 'tb_lineno': 2,                 'tb_next': {'tb_frame': {'f_code': {'co_filename': ...,                                                     'co_name': 'inner_1'},                                          'f_globals': {'__name__': '__main__'},                                          'f_lineno': 2},                             'tb_lineno': 2,                             'tb_next': {'tb_frame': {'f_code': {'co_filename': ...,                                                                 'co_name': 'inner_0'},                                                      'f_globals': {'__name__': '__main__'},                                                      'f_lineno': 2},                                         'tb_lineno': 2,                                         'tb_next': None}}}}tblib.Traceback.from_dict`````````````````````````Building on the previous example::    &gt;&gt;&gt; tb_json = json.dumps(tb_dict)    &gt;&gt;&gt; tb = Traceback.from_dict(json.loads(tb_json))    &gt;&gt;&gt; reraise(et, ev, tb.as_traceback())    Traceback (most recent call last):      ...      File &quot;&lt;doctest README.rst[21]&gt;&quot;, line 6, in &lt;module&gt;        reraise(et, ev, tb.as_traceback())      File &quot;&lt;doctest README.rst[21]&gt;&quot;, line 2, in &lt;module&gt;        inner_2()      File &quot;&lt;doctest README.rst[5]&gt;&quot;, line 2, in inner_2        inner_1()      File &quot;&lt;doctest README.rst[4]&gt;&quot;, line 2, in inner_1        inner_0()      File &quot;&lt;doctest README.rst[3]&gt;&quot;, line 2, in inner_0        raise Exception('fail')    Exception: failtblib.Traceback.from_string```````````````````````````::    &gt;&gt;&gt; tb = Traceback.from_string(&quot;&quot;&quot;    ... File &quot;skipped.py&quot;, line 123, in func_123    ... Traceback (most recent call last):    ...   File &quot;tests/examples.py&quot;, line 2, in func_a    ...     func_b()    ...   File &quot;tests/examples.py&quot;, line 6, in func_b    ...     func_c()    ...   File &quot;tests/examples.py&quot;, line 10, in func_c    ...     func_d()    ...   File &quot;tests/examples.py&quot;, line 14, in func_d    ... Doesn't: matter    ... &quot;&quot;&quot;)    &gt;&gt;&gt; reraise(et, ev, tb.as_traceback())    Traceback (most recent call last):      ...      File &quot;&lt;doctest README.rst[42]&gt;&quot;, line 6, in &lt;module&gt;        reraise(et, ev, tb.as_traceback())      File &quot;...examples.py&quot;, line 2, in func_a        func_b()      File &quot;...examples.py&quot;, line 6, in func_b        func_c()      File &quot;...examples.py&quot;, line 10, in func_c        func_d()      File &quot;...examples.py&quot;, line 14, in func_d        raise Exception(&quot;Guessing time !&quot;)    Exception: failIf you use the ``strict=False`` option then parsing is a bit more lax::    &gt;&gt;&gt; tb = Traceback.from_string(&quot;&quot;&quot;    ... File &quot;bogus.py&quot;, line 123, in bogus    ... Traceback (most recent call last):    ...  File &quot;tests/examples.py&quot;, line 2, in func_a    ...   func_b()    ...    File &quot;tests/examples.py&quot;, line 6, in func_b    ...     func_c()    ...    File &quot;tests/examples.py&quot;, line 10, in func_c    ...   func_d()    ...  File &quot;tests/examples.py&quot;, line 14, in func_d    ... Doesn't: matter    ... &quot;&quot;&quot;, strict=False)    &gt;&gt;&gt; reraise(et, ev, tb.as_traceback())    Traceback (most recent call last):      ...      File &quot;&lt;doctest README.rst[42]&gt;&quot;, line 6, in &lt;module&gt;        reraise(et, ev, tb.as_traceback())      File &quot;bogus.py&quot;, line 123, in bogus      File &quot;...examples.py&quot;, line 2, in func_a        func_b()      File &quot;...examples.py&quot;, line 6, in func_b        func_c()      File &quot;...examples.py&quot;, line 10, in func_c        func_d()      File &quot;...examples.py&quot;, line 14, in func_d        raise Exception(&quot;Guessing time !&quot;)    Exception: failtblib.decorators.return_error-----------------------------::    &gt;&gt;&gt; from tblib.decorators import return_error    &gt;&gt;&gt; inner_2r = return_error(inner_2)    &gt;&gt;&gt; e = inner_2r()    &gt;&gt;&gt; e    &lt;tblib.decorators.Error object at ...&gt;    &gt;&gt;&gt; e.reraise()    Traceback (most recent call last):      ...      File &quot;&lt;doctest README.rst[26]&gt;&quot;, line 1, in &lt;module&gt;        e.reraise()      File &quot;...tblib...decorators.py&quot;, line 19, in reraise        reraise(self.exc_type, self.exc_value, self.traceback)      File &quot;...tblib...decorators.py&quot;, line 25, in return_exceptions_wrapper        return func(*args, **kwargs)      File &quot;&lt;doctest README.rst[5]&gt;&quot;, line 2, in inner_2        inner_1()      File &quot;&lt;doctest README.rst[4]&gt;&quot;, line 2, in inner_1        inner_0()      File &quot;&lt;doctest README.rst[3]&gt;&quot;, line 2, in inner_0        raise Exception('fail')    Exception: failHow's this useful? Imagine you're using multiprocessing like this::    # Note that Python 3.4 and later will show the remote traceback (but as a string sadly) so we skip testing this.    &gt;&gt;&gt; import traceback    &gt;&gt;&gt; from multiprocessing import Pool    &gt;&gt;&gt; from examples import func_a    &gt;&gt;&gt; pool = Pool()  # doctest: +SKIP    &gt;&gt;&gt; try:  # doctest: +SKIP    ...     for i in pool.map(func_a, range(5)):    ...         print(i)    ... except:    ...     print(traceback.format_exc())    ...    Traceback (most recent call last):      File &quot;&lt;doctest README.rst[...]&gt;&quot;, line 2, in &lt;module&gt;        for i in pool.map(func_a, range(5)):      File &quot;...multiprocessing...pool.py&quot;, line ..., in map        ...      File &quot;...multiprocessing...pool.py&quot;, line ..., in get        ...    Exception: Guessing time !    &lt;BLANKLINE&gt;    &gt;&gt;&gt; pool.terminate()  # doctest: +SKIPNot very useful is it? Let's sort this out::    &gt;&gt;&gt; from tblib.decorators import apply_with_return_error, Error    &gt;&gt;&gt; from itertools import repeat    &gt;&gt;&gt; pool = Pool()    &gt;&gt;&gt; try:    ...     for i in pool.map(apply_with_return_error, zip(repeat(func_a), range(5))):    ...         if isinstance(i, Error):    ...             i.reraise()    ...         else:    ...             print(i)    ... except:    ...     print(traceback.format_exc())    ...    Traceback (most recent call last):      File &quot;&lt;doctest README.rst[...]&gt;&quot;, line 4, in &lt;module&gt;        i.reraise()      File &quot;...tblib...decorators.py&quot;, line ..., in reraise        reraise(self.exc_type, self.exc_value, self.traceback)      File &quot;...tblib...decorators.py&quot;, line ..., in return_exceptions_wrapper        return func(*args, **kwargs)      File &quot;...tblib...decorators.py&quot;, line ..., in apply_with_return_error        return args[0](*args[1:])      File &quot;...examples.py&quot;, line 2, in func_a        func_b()      File &quot;...examples.py&quot;, line 6, in func_b        func_c()      File &quot;...examples.py&quot;, line 10, in func_c        func_d()      File &quot;...examples.py&quot;, line 14, in func_d        raise Exception(&quot;Guessing time !&quot;)    Exception: Guessing time !    &lt;BLANKLINE&gt;    &gt;&gt;&gt; pool.terminate()Much better !What if we have a local call stack ?````````````````````````````````````::    &gt;&gt;&gt; def local_0():    ...     pool = Pool()    ...     try:    ...         for i in pool.map(apply_with_return_error, zip(repeat(func_a), range(5))):    ...             if isinstance(i, Error):    ...                 i.reraise()    ...             else:    ...                 print(i)    ...     finally:    ...         pool.close()    ...    &gt;&gt;&gt; def local_1():    ...     local_0()    ...    &gt;&gt;&gt; def local_2():    ...     local_1()    ...    &gt;&gt;&gt; try:    ...     local_2()    ... except:    ...     print(traceback.format_exc())    Traceback (most recent call last):      File &quot;&lt;doctest README.rst[...]&gt;&quot;, line 2, in &lt;module&gt;        local_2()      File &quot;&lt;doctest README.rst[...]&gt;&quot;, line 2, in local_2        local_1()      File &quot;&lt;doctest README.rst[...]&gt;&quot;, line 2, in local_1        local_0()      File &quot;&lt;doctest README.rst[...]&gt;&quot;, line 6, in local_0        i.reraise()      File &quot;...tblib...decorators.py&quot;, line 20, in reraise        reraise(self.exc_type, self.exc_value, self.traceback)      File &quot;...tblib...decorators.py&quot;, line 27, in return_exceptions_wrapper        return func(*args, **kwargs)      File &quot;...tblib...decorators.py&quot;, line 47, in apply_with_return_error        return args[0](*args[1:])      File &quot;...tests...examples.py&quot;, line 2, in func_a        func_b()      File &quot;...tests...examples.py&quot;, line 6, in func_b        func_c()      File &quot;...tests...examples.py&quot;, line 10, in func_c        func_d()      File &quot;...tests...examples.py&quot;, line 14, in func_d        raise Exception(&quot;Guessing time !&quot;)    Exception: Guessing time !    &lt;BLANKLINE&gt;Other weird stuff`````````````````Clearing traceback works (Python 3.4 and up)::    &gt;&gt;&gt; tb = Traceback.from_string(&quot;&quot;&quot;    ... File &quot;skipped.py&quot;, line 123, in func_123    ... Traceback (most recent call last):    ...   File &quot;tests/examples.py&quot;, line 2, in func_a    ...     func_b()    ...   File &quot;tests/examples.py&quot;, line 6, in func_b    ...     func_c()    ...   File &quot;tests/examples.py&quot;, line 10, in func_c    ...     func_d()    ...   File &quot;tests/examples.py&quot;, line 14, in func_d    ... Doesn't: matter    ... &quot;&quot;&quot;)    &gt;&gt;&gt; import traceback, sys    &gt;&gt;&gt; if sys.version_info &gt; (3, 4):    ...     traceback.clear_frames(tb)Credits=======* `mitsuhiko/jinja2 &lt;https://github.com/mitsuhiko/jinja2&gt;`_ for figuring a way to create traceback objects.Changelog=========3.0.0 (2023-10-22)~~~~~~~~~~~~~~~~~~* Added support for  ``__context__``, ``__suppress_context__`` and ``__notes__``.  Contributed by Tim Maxwell in `#72 &lt;https://github.com/ionelmc/python-tblib/pull/72&gt;`_.* Added the ``get_locals`` argument to ``tblib.pickling_support.install()``, ``tblib.Traceback`` and ``tblib.Frame``.  Fixes `#41 &lt;https://github.com/ionelmc/python-tblib/issues/41&gt;`_.* Dropped support for now-EOL Python 3.7 and added 3.12 in the test grid.2.0.0 (2023-06-22)~~~~~~~~~~~~~~~~~~* Removed support for legacy Pythons (2.7 and 3.6) and added Python 3.11 in the test grid.* Some cleanups and refactors (mostly from ruff).1.7.0 (2020-07-24)~~~~~~~~~~~~~~~~~~* Add more attributes to ``Frame`` and ``Code`` objects for pytest compatibility. Contributed by Ivanq in  `#58 &lt;https://github.com/ionelmc/python-tblib/pull/58&gt;`_.1.6.0 (2019-12-07)~~~~~~~~~~~~~~~~~~* When pickling an Exception, also pickle its traceback and the Exception chain  (``raise ... from ...``). Contributed by Guido Imperiale in  `#53 &lt;https://github.com/ionelmc/python-tblib/issues/53&gt;`_.1.5.0 (2019-10-23)~~~~~~~~~~~~~~~~~~* Added support for Python 3.8. Contributed by Victor Stinner in  `#42 &lt;https://github.com/ionelmc/python-tblib/issues/42&gt;`_.* Removed support for end of life Python 3.4.* Few CI improvements and fixes.1.4.0 (2019-05-02)~~~~~~~~~~~~~~~~~~* Removed support for end of life Python 3.3.* Fixed tests for Python 3.7. Contributed by Elliott Sales de Andrade in  `#36 &lt;https://github.com/ionelmc/python-tblib/issues/36&gt;`_.* Fixed compatibility issue with Twised (``twisted.python.failure.Failure`` expected a ``co_code`` attribute).1.3.2 (2017-04-09)~~~~~~~~~~~~~~~~~~* Add support for PyPy3.5-5.7.1-beta. Previously ``AttributeError:  'Frame' object has no attribute 'clear'``  could be raised. See PyPy  issue `#2532 &lt;https://foss.heptapod.net/pypy/pypy/-/issues/2532&gt;`_.1.3.1 (2017-03-27)~~~~~~~~~~~~~~~~~~* Fixed handling for tracebacks due to exceeding the recursion limit.  Fixes `#15 &lt;https://github.com/ionelmc/python-tblib/issues/15&gt;`_.1.3.0 (2016-03-08)~~~~~~~~~~~~~~~~~~* Added ``Traceback.from_string``.1.2.0 (2015-12-18)~~~~~~~~~~~~~~~~~~* Fixed handling for tracebacks from generators and other internal improvements  and optimizations. Contributed by DRayX in `#10 &lt;https://github.com/ionelmc/python-tblib/issues/10&gt;`_  and `#11 &lt;https://github.com/ionelmc/python-tblib/pull/11&gt;`_.1.1.0 (2015-07-27)~~~~~~~~~~~~~~~~~~* Added support for Python 2.6. Contributed by Arcadiy Ivanov in  `#8 &lt;https://github.com/ionelmc/python-tblib/pull/8&gt;`_.1.0.0 (2015-03-30)~~~~~~~~~~~~~~~~~~* Added ``to_dict`` method and ``from_dict`` classmethod on Tracebacks.  Contributed by beckjake in `#5 &lt;https://github.com/ionelmc/python-tblib/pull/5&gt;`_.</longdescription>
</pkgmetadata>