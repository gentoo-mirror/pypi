<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Milksnake&lt;a href=&quot;https://pypi.python.org/pypi/milksnake&quot;&gt;&lt;img src=&quot;https://img.shields.io/pypi/v/milksnake.svg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://travis-ci.org/getsentry/milksnake&quot;&gt;&lt;img src=&quot;https://travis-ci.org/getsentry/milksnake.svg?branch=master&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/getsentry/milksnake/blob/master/LICENSE&quot;&gt;&lt;img src=&quot;https://img.shields.io/pypi/l/milksnake.svg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;Milksnake is an extension for setuptools that allows you to distributedynamic linked libraries in Python wheels in the most portable way imaginable.It gives you a hook to invoke your own build process and to then take theresulting dynamic linked library.## Why?There are already other projects that make Python and native libraries playalong but this one is different.  Unlike other projects that build Pythonextension modules the goal of this project is to build regular native librariesthat are then loaded with CFFI at runtime.  Why not just use CFFI?  BecauseCFFI's setuptools support alone does not properly work with such wheels (itdoes not provide a way to build and properly tag wheels for shared libraries) andit does not provide a good way to invoke an external build process (like amakefile, cargo to build rust binaries etc.)In particular you will most likely only need two wheels for Linux, one for macsand soon one for Windows independently of how many Python interpreters you wantto target.## What is supported?* Platforms: Linux, Mac, Windows* setuptools commands: `bdist_wheel`, `build`, `build_ext`, `develop`* `pip install --editable .`* Universal wheels (`PACKAGE-py2.py3-none-PLATFORM.whl`); this can be disabled  with `milksnake_universal=False` in `setup()` in case the package also contains  stuff that does link against libpython.## How?This example shows how to build a rust project with it:This is what a `setup.py` file looks like:```pythonfrom setuptools import setupdef build_native(spec):    # build an example rust library    build = spec.add_external_build(        cmd=['cargo', 'build', '--release'],        path='./rust'    )    spec.add_cffi_module(        module_path='example._native',        dylib=lambda: build.find_dylib('example', in_path='target/release'),        header_filename=lambda: build.find_header('example.h', in_path='target'),        rtld_flags=['NOW', 'NODELETE']    )setup(    name='example',    version='0.0.1',    packages=['example'],    zip_safe=False,    platforms='any',    setup_requires=['milksnake'],    install_requires=['milksnake'],    milksnake_tasks=[        build_native    ])```You then need a `rust/` folder that has a Rust library (with a crate typeof `cdylib`) and a `example/` python package.Example `example/__init__.py` file:```pythonfrom example._native import ffi, libdef test():    return lib.a_function_from_rust()```And a `rust/src/lib.rs`:```rust#[no_mangle]pub unsafe extern &quot;C&quot; fn a_function_from_rust() -&gt; i32 {    42}```And the `rust/Cargo.toml`:```toml[package]name = &quot;example&quot;version = &quot;0.1.0&quot;build = &quot;build.rs&quot;[lib]name = &quot;example&quot;crate-type = [&quot;cdylib&quot;][build-dependencies]cbindgen = &quot;0.19&quot;```And finally the build.rs file:```rustextern crate cbindgen;use std::env;fn main() {    let crate_dir = env::var(&quot;CARGO_MANIFEST_DIR&quot;).unwrap();    let mut config: cbindgen::Config = Default::default();    config.language = cbindgen::Language::C;    cbindgen::generate_with_config(&amp;crate_dir, config)      .unwrap()      .write_to_file(&quot;target/example.h&quot;);}```</longdescription>
</pkgmetadata>