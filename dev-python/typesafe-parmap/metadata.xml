<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Typesafe parmap[![pypi](https://img.shields.io/pypi/v/typesafe-parmap.svg)](https://pypi.org/project/typesafe-parmap)[![python](https://img.shields.io/pypi/pyversions/typesafe-parmap.svg)](https://pypi.org/project/typesafe-parmap)[![Build Status](https://github.com/thejaminator/typesafe_parmap/actions/workflows/dev.yml/badge.svg)](https://github.com/thejaminator/typesafe_parmap/actions/workflows/dev.yml)```pip install typesafe-parmap```Run functions in parallel safely with your type checkers* GitHub: &lt;https://github.com/thejaminator/typesafe_parmap&gt;## FeaturesEasy run different functions in parallel```pythonfrom typesafe_parmap import par_map_2import timefrom concurrent.futures import ThreadPoolExecutortp = ThreadPoolExecutor(5)def long_running_int(param: int) -&gt; int:    time.sleep(5)  # long IO task here    return 123def long_running_str(param: str) -&gt; str:    time.sleep(5)  # long IO task here    return &quot;hello world&quot;int_result, str_result = par_map_2(                        lambda: long_running_int(5),                        lambda: long_running_str(&quot;test&quot;),                        executor=tp)assert int_result == 123, str_result == &quot;hello world&quot;  # should finish in around 5 seconds```Function return types are inferred correctly by mypy / pycharm```pythonreveal_type(int_result) # mypy infers intreveal_type(str_result) # mypy infers str```Accidentally unpacked too many / little values? Type inference checks that for you!```pythonone, two, three, four = par_map_3(        lambda: long_running_int(5), lambda: long_running_str(&quot;test&quot;), lambda: &quot;something&quot;, executor=tp    ) # Error: Need more than 3 values to unapck, (4 expected)```Got more than a few functions to run? We got you covered...```pythonfrom typesafe_parmap import par_map_4 # ... all the way to par_map_22!```Want to change the number of functions to run in parallel? Hate having to import a different one each time?Use par_map_n!```pythonfrom typesafe_parmap import par_map_2, par_map_3, par_map_na = par_map_2(lambda: long_running_int(5), lambda: long_running_str(&quot;test&quot;), executor=executor)b = par_map_n(lambda: long_running_int(5), lambda: long_running_str(&quot;test&quot;), executor=executor)assert a == bc = par_map_3(    lambda: long_running_int(5),    lambda: long_running_str(&quot;test&quot;),    lambda: long_running_str(&quot;test&quot;),    executor=executor,)d = par_map_n(    lambda: long_running_int(5),    lambda: long_running_str(&quot;test&quot;),    lambda: long_running_str(&quot;test&quot;),    executor=executor,)assert c == d```## TimeoutsSuppose you want to run a bunch of functions that might take a long time, but you don't want to wait forever.Use par_map_timeout_n!```pythonfrom concurrent.futures import ThreadPoolExecutorfrom datetime import timedeltafrom typesafe_parmap import par_map_timeout_n# Since there are 3 threads, we should be able to run 3 functions at onceexecutor = ThreadPoolExecutor(3)int_result, str_result_1, str_result_2 = par_map_timeout_n(    lambda: long_running_int(5),    lambda: short_running_str(&quot;test 1&quot;),    lambda: short_running_str(&quot;test 2&quot;),    executor=executor,    timeout=timedelta(seconds=5),)assert int_result is None # This function timed outassert str_result_1 == &quot;test 1&quot; # This still finished in timeassert str_result_2 == &quot;test 2&quot; # This still finished in time```Note that as a result of the timeout, the return types of the int_result and str_result_1 are now Optional[str] and Optional[int] respectively.### Logging timeoutspar_map_timeout_n accepts a logger parameter.We also provide a class `NamedThunk`, which allows you to name your thunks so that the name is not just `&lt;lambda&gt;` in the logs.```pythonfrom concurrent.futures import ThreadPoolExecutorfrom datetime import timedeltafrom typesafe_parmap import par_map_timeout_n, NamedThunkexecutor = ThreadPoolExecutor(2)par_map_timeout_n(    NamedThunk(lambda: long_running_int(5), name=&quot;Long Running Int&quot;),    lambda: short_running_str(&quot;test 2&quot;),    executor=executor,    timeout=timedelta(seconds=3),    logger=print,)# Prints:# par_map func1: Long Running Int timed out after 3 seconds```</longdescription>
</pkgmetadata>