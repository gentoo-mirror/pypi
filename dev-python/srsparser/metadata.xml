<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;h1&gt;Semi-structured document parser&lt;/h1&gt;srsparser is a library that translates semi-structured text documents (files with .docx extension) into a structuredform in accordance with JSON templates and contains natural language processing algorithms to analyze the resultingstructures.## The main ideaLet's consider the application of this library on the example of the technical assignment for developing of automatedsystem.Based on the structure of the technical assignment described inthe [GOST standard 34.602-89](http://protect.gost.ru/default.aspx/document1.aspx?control=31&amp;baseC=6&amp;page=0&amp;month=4&amp;year=-1&amp;search=&amp;id=241754)the necessary sections are selected, and on their basis the tree structure of sections is compiled in JSON format. Eachsection is represented by name and content (children — if it has subsections, otherwise — text). This step is donemanually.The compiled section structure is transferred to the parser as a *template*. Example of the template:```json{  &quot;name&quot;: &quot;Техническое задание&quot;,  &quot;children&quot;: [    {      &quot;text&quot;: &quot;&quot;,      &quot;name&quot;: &quot;Общие сведения&quot;    },    {      &quot;text&quot;: &quot;&quot;,      &quot;name&quot;: &quot;Назначение и цели создания (развития) системы&quot;    },    {      &quot;text&quot;: &quot;&quot;,      &quot;name&quot;: &quot;Характеристика объектов автоматизации&quot;    },    {      &quot;name&quot;: &quot;Требования к системе&quot;,      &quot;children&quot;: [        {          &quot;name&quot;: &quot;Требования к системе в целом&quot;,          &quot;children&quot;: [            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к структуре и функционированию системы&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к численности и квалификации персонала системы и режиму его работы&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Показатели назначения&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к надежности&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к безопасности&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к эргономике и технической эстетике&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к транспортабельности для подвижных АС&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к эксплуатации, техническому обслуживанию, ремонту и хранению компонентов системы&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к защите информации от несанкционированного доступа&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования по сохранности информации при авариях&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к защите от влияния внешних воздействий&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к патентной чистоте&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования по стандартизации и унификации&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Дополнительные требования&quot;            }          ]        },        {          &quot;text&quot;: &quot;&quot;,          &quot;name&quot;: &quot;Требования к функциям (задачам)&quot;        },        {          &quot;name&quot;: &quot;Требования к видам обеспечения&quot;,          &quot;children&quot;: [            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к математическому обеспечению&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к информационному обеспечению&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к лингвистическому обеспечению&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к программному обеспечению&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к техническому обеспечению&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к метрологическому обеспечению&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к организационному обеспечению&quot;            },            {              &quot;text&quot;: &quot;&quot;,              &quot;name&quot;: &quot;Требования к методическому обеспечению&quot;            }          ]        }      ]    },    {      &quot;text&quot;: &quot;&quot;,      &quot;name&quot;: &quot;Состав и содержание работ по созданию системы&quot;    },    {      &quot;text&quot;: &quot;&quot;,      &quot;name&quot;: &quot;Порядок контроля и приемки системы&quot;    },    {      &quot;text&quot;: &quot;&quot;,      &quot;name&quot;: &quot;Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие&quot;    },    {      &quot;text&quot;: &quot;&quot;,      &quot;name&quot;: &quot;Требования к документированию&quot;    },    {      &quot;text&quot;: &quot;&quot;,      &quot;name&quot;: &quot;Источники разработки&quot;    }  ]}```The parser reads the contents of a text document and tries to detect in it exactly those sections that are present inthe template. If the text document contains content corresponding to a section of the template, then it is entered inthe &quot;text&quot; field of the corresponding section of the template.After filling the template with the contents of a text document, sections with empty &quot;text&quot; fields are removed from it,and the filled template is converted to JSON format. Example of the filled template in JSON format:```json{  &quot;name&quot;: &quot;Техническое задание&quot;,  &quot;children&quot;: [    {      &quot;text&quot;: &quot;Полное наименование системы и ее условное обозначение: Конфигурация «Бухгалтерия предприятия» в среде «1С: Предприятие 8.1»....&quot;,      &quot;name&quot;: &quot;Общие сведения&quot;    },    {      &quot;text&quot;: &quot;Подсистема оперативного учета должна содержать механизмы...&quot;,      &quot;name&quot;: &quot;Назначение и цели создания (развития) системы&quot;    },    {      &quot;text&quot;: &quot;Объектом автоматизации является процесс учета расчетов с работниками по оплате труда в организации...&quot;,      &quot;name&quot;: &quot;Характеристика объектов автоматизации&quot;    },    {      &quot;name&quot;: &quot;Требования к системе&quot;,      &quot;children&quot;: [        {          &quot;name&quot;: &quot;Требования к системе в целом&quot;,          &quot;children&quot;: [            {              &quot;text&quot;: &quot;Для наиболее эффективного функционирования системы помимо пользователя...&quot;,              &quot;name&quot;: &quot;Требования к численности и квалификации персонала системы и режиму его работы&quot;            },            {              &quot;text&quot;: &quot;Система должна предусматривать возможность масштабирования по производительности...&quot;,              &quot;name&quot;: &quot;Показатели назначения&quot;            },            {              &quot;text&quot;: &quot;Система должна сохранять работоспособность и обеспечивать восстановление своих функций при возникновении следующих внештатных ситуаций...&quot;,              &quot;name&quot;: &quot;Требования к защите от влияния внешних воздействий&quot;            }          ]        },        {          &quot;text&quot;: &quot;Подсистема оперативного учета должна осуществлять ввод и хранение оперативных данных системы...&quot;,          &quot;name&quot;: &quot;Требования к функциям (задачам)&quot;        },        {          &quot;name&quot;: &quot;Требования к видам обеспечения&quot;,          &quot;children&quot;: [            {              &quot;text&quot;: &quot;Не предъявляются;&quot;,              &quot;name&quot;: &quot;Требования к математическому обеспечению&quot;            },            {              &quot;text&quot;: &quot;Уровень хранения данных в системе должен быть построен на основе современных СУБД...&quot;,              &quot;name&quot;: &quot;Требования к информационному обеспечению&quot;            },            {              &quot;text&quot;: &quot;Система создана на основе языка программирования «1С 8.1»;&quot;,              &quot;name&quot;: &quot;Требования к лингвистическому обеспечению&quot;            },            {              &quot;text&quot;: &quot;Для эффективного функционирования системы помимо пользователя необходим специалист по технической поддержке...&quot;,              &quot;name&quot;: &quot;Требования к метрологическому обеспечению&quot;            },            {              &quot;text&quot;: &quot;Для эффективного функционирования системы помимо пользователя необходим специалист по технической поддержке...&quot;,              &quot;name&quot;: &quot;Требования к организационному обеспечению&quot;            },            {              &quot;text&quot;: &quot;Для обеспечения целостности данных должны использоваться встроенные механизмы СУБД...&quot;,              &quot;name&quot;: &quot;Требования к методическому обеспечению&quot;            }          ]        }      ]    },    {      &quot;text&quot;: &quot;Перечень стадий и этапов работ, а так же сроки их исполнения представлены в Таблице 2...&quot;,      &quot;name&quot;: &quot;Состав и содержание работ по созданию системы&quot;    },    {      &quot;text&quot;: &quot;Приемочные испытания должны включать проверку: полноты и качества реализации необходимых функций...&quot;,      &quot;name&quot;: &quot;Порядок контроля и приемки системы&quot;    },    {      &quot;text&quot;: &quot;Для подготовки объекта автоматизации к вводу системы в действие необходимо при помощи специалиста технической поддержки...&quot;,      &quot;name&quot;: &quot;Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие&quot;    },    {      &quot;text&quot;: &quot;Разработке подлежит следующая документация: Инструкция пользователю; Инструкция программисту.&quot;,      &quot;name&quot;: &quot;Требования к документированию&quot;    }  ]}```The last step is to save the filled template in JSON format in order to access the necessary sections of the technicalassignment without spending time searching for relevant information.## PreparingCreate the tree structure of sections in JSON format. The created JSON will act as a template. The required element isthe root element, so make sure that the entire structure is contained inside the children field of the root element.```{  &quot;root element name&quot;: &quot;root&quot;,  &quot;children&quot;: [    *here is the sections*  ]}```## InstallationTo install srsparser:`pip install srsparser`To update srsparser:`pip install srsparser --upgrade`## Usage### Parser```pythonimport jsonfrom srsparser import ParserTEMPLATE_PATH = &quot;/path/to/template.json&quot;# read the template (a JSON file created at the preparation stage)with open(TEMPLATE_PATH, encoding=&quot;UTF-8&quot;) as f:    template = json.load(f)DOCX_PATH = &quot;/path/to/doc1.docx&quot;parser = Parser(template)structure = parser.parse_docx(DOCX_PATH)print(structure)# Output:# {#   'name': 'Техническое задание',#   'children': [#     {#       'text': 'Полное наименование системы и ее условное обозначение...',#       'name': 'Общие сведения'#     },#     {#       'name': 'Требования к системе',#       'children': [#         {#           'name': 'Требования к системе в целом',#           'children': [#             {#               'text': 'Для наиболее эффективного функционирования системы помимо пользователя...',#               'name': 'Требования к численности и квалификации персонала системы и режиму его работы'#             },#             ...#           ]#         },#         ...#       ]#     },#     ...#   ]# }```### LanguageProcessor```pythonimport jsonfrom srsparser import Parser, LanguageProcessor, SectionsTreeTEMPLATE_PATH = &quot;/path/to/template.json&quot;  # see the main idea section (README.md) for example# read the template (a JSON file created at the preparation stage)with open(TEMPLATE_PATH, encoding=&quot;UTF-8&quot;) as f:    template = json.load(f)parser = Parser(template)parsed_documents = []for docx_path in [&quot;/path/to/doc1.docx&quot;, &quot;/path/to/doc2.docx&quot;, &quot;/path/to/doc2.docx&quot;]:    structure = parser.parse_docx(docx_path)    parsed_documents.append({        &quot;name&quot;: docx_path,        &quot;structure&quot;: structure    })# a class that contains NLP methods.# when reused, you may not initialize pullenti: LanguageProcessor(init_pullenti=False)langproc = LanguageProcessor()# KEYWORD EXTRACTION (using the pullenti library)# ======================================================================================================================# 1. extract keywords from a specific section of the selected structurekeywords = langproc.get_structure_keywords_pullenti(documents=parsed_documents,                                                    document_name=parsed_documents[1][&quot;name&quot;],                                                    section_name=&quot;Общие сведения&quot;)  # default: root sectionprint(keywords)# Output:# ['РАБОЧИЙ', 'ПОЛНОЕ НАИМЕНОВАНИЕ СИСТЕМЫ', 'АВТОМАТИЗИРОВАННОЕ РАБОЧЕЕ МЕСТО', 'ОКОНЧАНИЕ РАБОТ', 'СИСТЕМА',# 'ПЛАНОВЫЙ СРОК НАЧАЛА', 'Ульяновск', 'ЗАКАЗЧИК', 'ПОЛНОЕ НАИМЕНОВАНИЕ', 'ПРОДАВЕЦ-КОНСУЛЬТАНТ',# 'НАИМЕНОВАНИЕ', 'ШИФР ТЕМЫ', 'ПРЕДПРИЯТИЕ', 'НАИМЕНОВАНИЕ ПРЕДПРИЯТИЯ', 'ЗАКАЗЧИК СИСТЕМЫ', 'ПЛАНОВЫЙ СРОК', ...]# 2. extract keywords from the text (to read the contents of the structure, the SectionsTree data structure is used)tree = SectionsTree(parsed_documents[1][&quot;structure&quot;])structure_contents = tree.get_content(section_name=&quot;Характеристика объектов автоматизации&quot;)  # default: root sectionkeywords = langproc.get_keywords_pullenti(structure_contents)print(keywords)# Output:# ['ТОРГОВЫЙ ЗАЛ САЛОНА', 'СИСТЕМА', 'ОБЪЕКТ АВТОМАТИЗАЦИИ', 'ТОРГОВЫЙ ЗАЛ', 'ПРОДАЖА ФОТОТОВАРОВ', 'РЕАЛИЗАЦИЯ УСЛУГ',# 'ТРЕБОВАНИЕ', 'ФУНКЦИОНИРОВАНИЕ СИСТЕМЫ', 'ПРОГРАММНЫЙ ПРОДУКТ', 'ЕДИНАЯ СИСТЕМА', 'МОНОПОЛЬНЫЙ РЕЖИМ', 'ОБЪЕКТ',# 'АВТОМАТИЗАЦИЯ', 'ТОРГОВЫЙ', 'ЗАЛ', 'САЛОН', 'ФОТОУСЛУГА', 'ОСУЩЕСТВЛЯТЬ', 'ПРОДАЖА', 'ФОТОТОВАРЫ', ...]# ======================================================================================================================# TF-IDF PAIRS EXTRACTION (using the gensim library)# ======================================================================================================================# 1. extract pairs of words and their corresponding TF-IDF weights from a specific section of the selected structurepairs = langproc.get_structure_tf_idf_pairs(documents=parsed_documents,                                            document_name=parsed_documents[0][&quot;name&quot;],                                            section_name=&quot;Требования к функциям (задачам)&quot;,  # default: root section                                            part_of_speech=&quot;NOUN&quot;,  # default: all parts of speech                                            smartirs=&quot;ntc&quot;)  # default: ntc (see: SMART Information Retrieval System)print(pairs)# Output:# [['документ', 0.313], ['диск', 0.242], ['жесткия', 0.242], ['просмотр', 0.242], ['список', 0.242],# ['удаление', 0.242], ['установка', 0.242], ['учёт', 0.205], ['мбаит', 0.179], ['основа', 0.16], ['процессор', 0.134],# ['сервер', 0.134], ['субд', 0.134], ['бухгалтер', 0.121], ['версия', 0.121], ['главное', 0.121], ...]# 2. extract pairs of words and their corresponding TF-IDF weights of all documentsdocuments = [    &quot;Подсистема оперативного учета должна содержать механизмы, позволяющие вводить в систему и хранить в ней &quot;    &quot;информацию о текущей деятельности организации.&quot;,    &quot;Объектом автоматизации является процесс учета расчетов с работниками по оплате труда в организации, имеющей &quot;    &quot;специфические принципы формирования расчетных сумм, в части расчета этих сумм и сбора данных из документов &quot;    &quot;оперативного учета для проведения расчета.&quot;,    &quot;Система должна сохранять работоспособность и обеспечивать восстановление своих функций при возникновении &quot;    &quot;внештатных ситуаций.&quot;]pairs = langproc.get_tf_idf_pairs(documents=documents,                                  part_of_speech=&quot;ADJF&quot;,  # default: all parts of speech                                  smartirs=&quot;lfc&quot;)  # default: ntc (see: SMART Information Retrieval System)print(pairs)# Output:# [[['текущей', 0.887], ['должный', 0.327], ['оперативный', 0.327]], [['расчётный', 0.565], ['специфический', 0.565], # ['этот', 0.565], ['оперативный', 0.208]], [['внештатный', 0.684], ['свой', 0.684], ['должный', 0.253]]]# 3. extract pairs of keywords and their corresponding TF-IDF weightspairs = langproc.get_structure_rationized_keywords(documents=parsed_documents,                                                   document_name=parsed_documents[2][&quot;name&quot;],                                                   section_name=&quot;Требования к системе&quot;,  # default: root section                                                   smartirs=&quot;dnu&quot;)  # default: ntcprint(pairs)# Output:# [['ЭФФЕКТИВНОЕ ФУНКЦИОНИРОВАНИЕ СИСТЕМЫ', 0.023], ['ИМЕЮЩИЙ НАВЫК РАБОТЫ', 0.023],# ['ТЕХНИЧЕСКАЯ ХАРАКТЕРИСТИКА КОМПЬЮТЕРА', 0.022], ['СОСТАВ МЕТОДИЧЕСКОГО ОБЕСПЕЧЕНИЯ', 0.021],# ['КОМПЬЮТЕР КОНЕЧНОГО ПОЛЬЗОВАТЕЛЯ', 0.0209], ['НЕСКОЛЬКО НЕЗАВИСИМЫЙ ПРОЕКТ', 0.02], ... ]# ======================================================================================================================# OTHER FEATURES# ======================================================================================================================# 1. string similarityratio = langproc.strings_similarity(documents[0], documents[1])print(ratio)# Output:# 0.16151457061744964# 2. sentence segmentation (using rusenttokenize)sentences = langproc.sentenize(&quot; &quot;.join(documents))print(sentences)# Output:# ['Подсистема оперативного учета должна содержать механизмы,#   позволяющие вводить в систему и хранить в ней информацию о текущей деятельности организации',#  'Объектом автоматизации является процесс учета расчетов с работниками по оплате труда в организации,#   имеющей специфические принципы формирования расчетных сумм, в части расчета этих сумм и сбора данных из документов#   оперативного учета для проведения расчета',#  'Система должна сохранять работоспособность и обеспечивать восстановление своих функций при возникновении#   внештатных ситуаций']# 3. tokenization (using gensim)tokens = langproc.tokenize(text=documents[0],                           part_of_speech=&quot;NOUN&quot;)  # default: all parts of speechprint(tokens)# Output:# ['подсистема', 'учёт', 'механизм', 'система', 'нея', 'информация', 'деятельность', 'организация']# 4. lemmatisationwords = [&quot;Подсистема&quot;, &quot;оперативного&quot;, &quot;учета&quot;, &quot;должна&quot;, &quot;содержать&quot;, &quot;механизмы&quot;, &quot;позволяющие&quot;, &quot;вводить&quot;, &quot;систему&quot;,         &quot;хранить&quot;, &quot;ней&quot;, &quot;информацию&quot;, &quot;текущей&quot;, &quot;деятельности&quot;, &quot;организации&quot;]lemmas = langproc.lemmatize(words)print(lemmas)# Output:# ['подсистема', 'оперативный', 'учёт', 'должный', 'содержать', 'механизм', 'позволять', 'вводить', 'система', # 'хранить', 'она', 'информация', 'текущий', 'деятельность', 'организация']# ======================================================================================================================```## References- https://github.com/RaRe-Technologies/gensim- https://github.com/pullenti/PullentiPython- https://github.com/deepmipt/ru_sentence_tokenizer</longdescription>
</pkgmetadata>