<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># vitya**WARNING**: This library is still in development stage.Validators for different russian banking values.  Values you can validate:- ИНН ```validate_inn```    - ИНН для ИП/Физ.Лица ```validate_inn_ip```    - ИНН для Юр.Лица ```validate_inn_le```- КПП ```validate_kpp```- БИК ```validate_bic```- ОГРН ```validate_ogrn```    - ОГРНИП ```validate_ogrnip```- СНИЛС ```validate_snils```- ОКТМО ```validate_oktmo```You should pass value as ```str```, otherwise exception will be raised.  If passed value is wrong, all functions will raise ```ValidationError```.Also, optionally, you can use validators as Pydantic fields### Examples:```pythonvalidate_inn(&quot;3664069397&quot;)try:    validate_inn(&quot;770708389&quot;)except ValidationError as e:    print(f&quot;wrong inn: {e}&quot;)``````pythonvalidate_kpp(&quot;616401001&quot;)validate_bic(&quot;044525901&quot;)validate_ogrn(&quot;1027700132195&quot;)validate_snils(&quot;11223344595&quot;)validate_oktmo(&quot;69701000001&quot;)``````pythonfrom pydantic import BaseModel, ValidationErrorfrom vitya.pydantic_fields import INNclass InnModel(BaseModel):    inn: INNinn_model = InnModel(inn=&quot;302502032671&quot;)assert inn_model.inn == &quot;302502032671&quot;try:    InnModel(inn=&quot;3664069398&quot;)except ValidationError as e:    print(e.errors())```# Валидация платежей по реквизитам (Russian)Для валидации платежей используется следующий базовый класс, от которого необходимо наследоваться:  ```pythonclass BaseModelChecker````У наследников этого класса есть переменная класса:  ```python__checkers__: ClassVar[List[Tuple[Type[BaseChecker], List[str]]]] = []````В этой переменной содержится список чекеров (наследников BaseChecker),которые будут вызваны (вызовется метод check) при инициализации инстансов BaseModelChecker  Класс чекеров наследуется от BaseChecker```pythonclass BaseChecker(ABC):    @abstractmethod    def check(self) -&gt; None:  # pragma: no cover        pass```  При инициализации инстансов класса BaseModelChecker, когда появляется проверка чекеров не выполняется успешно, выбрасывается ошибка CheckerError, которая затем оборачивается в pydantic.ValidationError```pythonclass CheckerError(ValueError):    def __init__(self, errors: Sequence[Exception]):        self._errors = errors    @property    def errors(self) -&gt; Sequence[Exception]:        return self._errors```### Пример работыДля примера разберем базовую ситуацию: ключевание номера счёта и БИКа банка. Чтобы это проверить, нам нужно создать класс наследник BaseModelChecker, со встроенным чекером ключевания счёта и БИКа. Такой чекер есть в базовых реализациях и называется AccountBicChecker. Пример кода:```pythonclass MyPayment(BaseModelChecker):    account_number: AccountNumber    bic: BIC    __checkers__ = [        (AccountBicChecker, ['account_number', 'bic'])    ]try:    payment = MyPayment(account_number='40802810722200035222', bic='045004861')except ValidationError as e:    print('ой, что-то не так с данными: ', str(e))else:    print('все отлично!')```Результат выполнения:```ой, что-то не так с данными:  1 validation error for TestAccountBicModelChecker__root__  [AccountValidationBICValueError()] (type=value_error.checker; _errors=[AccountValidationBICValueError()])```Поменяем БИК на корректный (последнюю цифру)```pythontry:    payment = MyPayment(account_number='40802810722200035222', bic='045004864')except ValidationError as e:    print('ой, что-то не так с данными: ', str(e))else:    print('все отлично!')```Результат выполнения:```все отлично!```</longdescription>
</pkgmetadata>