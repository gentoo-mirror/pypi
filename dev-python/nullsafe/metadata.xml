<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Null Safe PythonNull safe support for Python.## Installation```bashpip install nullsafe```## Quick StartDummy Class```pythonclass Dummy:    pass```Normal Python code:```pythono = Dummy()try:    value = o.inexistent    print(&quot;accessed&quot;)except AttributeError:    value = None```With nullsafe:```pythonfrom nullsafe import undefined, _o = Dummy()value = _(o).inexistentif value is not undefined:    print(&quot;accessed&quot;)```# Documentation## BasicsThere are 5 values importable in nullsafe root:### class `NullSafeProxy: (o: T)`Receives an object `o` on instantiation.Proxy class for granting nullsafe abilities to an object.### class `NullSafe: ()`No argument needed.Nullish class with with nullsafe abilities. Instances will have a falsy boolean evaluation, equity comparison (`==`) to `None` and instance of `NullSafe` returns `True`, otherwise `False`. Identity comparison (`is`) to `None` will return `False`. It also has a `__call__` method that always returns `undefined`.### variable `undefined: NullSafe`Instance of `Nullsafe`, this instance will be returned for all nullish access in a proxied object, enabling identity comparison `value is undefined` for code clarity.### function `nullsafe: (o: T) -&gt; T | NullSafe | NullSafeProxy[T]`Receives an object `o` as argument.Helper function that checks if object is nullish and return the proxied object.return `undefined` if `o` is `None` or `undefined`, otherwise return the proxied object `NullSafeProxy[T]`.This function is **generic typed** (`(o: T) -&gt; T`), code autocompletions and linters functionalities will remain. Disclaimer: If the object was not typed before proxy, it obviously won't come out typed out of the blue.### function `_: (o: T) -&gt; T | NullSafe | NullSafeProxy[T]` (alias to `nullsafe`)Alias to `nullsafe`, used for better code clarity.The examples shown will be using `_` instead of `nullsafe` for code clarity. For better understanding, the Javascript equivalents will be shown as comments.## ImplementationNullsafe abilities are granted after proxying an object through `NullSafeProxy`. To proxy an object pass it through `_()` or `nullsafe()`. Due to language limitation, the implementation does not follow the &quot;return the first nullish value in chain&quot;, instead it &quot;extend `undefined` (custom nullish value) until the end of chain&quot;. Inexistent values of a proxied object and its subsequent values in chain will return `undefined`.## Import```pythonfrom nullsafe import undefined, _```## UsageThere are various way to get a nullsafe proxied object.### Null safe attribute accessProxied object doing a possibly `AttributeError` access.```pythono = Dummy()# o.inexistentassert _(o).inexistent is undefinedassert _(o).inexistent == None   # undefined == Noneassert not _(o).inexistent       # bool(undefined) == False# o.inexistent?.nestedassert _(o).inexistent.nested is undefined# o.existent.inexistent?.nestedassert _(o.existent).inexistent.nested is undefined# o.maybe?.inexistent?.nestedassert _(_(o).maybe).inexistent.nested is undefined# o.inexistent?.inexistcall(&quot;anything&quot;).inexistent.nested().finalassert _(o).inexistent.inexistcall(&quot;anything&quot;).inexistent.nested().final is undefined```### Null safe item accessProxied object doing a possibly `KeyError` access.```pythono = Dummy() # dict works too !# o.inexistentassert _(o)[&quot;inexistent&quot;] is undefinedassert _(o)[&quot;inexistent&quot;] == None    # undefined == Noneassert not _(o)[&quot;inexistent&quot;]        # bool(undefined) == False# o.inexistent?.nestedassert _(o)[&quot;inexistent&quot;][&quot;nested&quot;] is undefined# o.existent.inexistent?.nestedassert _(o[&quot;existent&quot;])[&quot;inexistent&quot;][&quot;nested&quot;] is undefined# o.maybe?.inexistent?.nestedassert _(_(o)[&quot;maybe&quot;])[&quot;inexistent&quot;][&quot;nested&quot;] is undefined# o.inexistent?.inexistcall(&quot;anything&quot;).inexistent.nested().finalassert _(o)[&quot;inexistent&quot;][&quot;inexistcall&quot;](&quot;anything&quot;)[&quot;inexistent&quot;][&quot;nested&quot;]()[&quot;final&quot;] is undefined```### Null safe post evaluationPossibly `None` or `undefined` object doing possibly `AttributeError` or `KeyError` access.Note: This only works if the seeking value is accessible, see [limitations](#post-evaluation)```pythono = Dummy() # dict works too !o.nay = None# o.nay?.inexistentassert _(o.nay).inexistent is undefinedassert _(o.nay).inexistent == None   # undefined == Noneassert not _(o.nay).inexistent       # bool(undefined) == False# o.nay?.inexistent.nestedassert _(o.nay).inexistent.nested is undefined# o.nay?.inexistent().nestedassert _(o.nay).inexistent().nested is undefined``````pythono = Dummy() # dict works too !o[&quot;nay&quot;] = None# o.nay?.inexistentassert _(o[&quot;nay&quot;])[&quot;inexistent&quot;] is undefined# o.nay?.inexistent.nestedassert _(o[&quot;nay&quot;])[&quot;inexistent&quot;][&quot;nested&quot;] is undefined# o.nay?.inexistent().nestedassert _(o[&quot;nay&quot;])[&quot;inexistent&quot;]()[&quot;nested&quot;] is undefined```### Combined usageOf course you can combine different styles.```pythonassert _(o).inexistent[&quot;inexistent&quot;].inexistent.inexistent[&quot;inexistent&quot;][&quot;inexistent&quot;] is undefined```## LimitationsList of limitations that you may encounter.### `undefined` behavior`undefined` is actually an instance of `NullSafe`, the actual mechanism used for nullsafe chaining, it cannot self rip the nullsafe functionality when the chain ends (because it doesn't know), so the following instruction is technically correct but probably not the wanted behavior.```pythonval = _(o).inexistentassert val.another_inexistent is undefined```### Post evaluationIn other languages like Javascript, it checks for each item in the chain and return `undefined` on the first nullish value, which in fact is post-evaluated. This is not possible in python because it raises an `AttributeError` or `KeyError` on access attempt, unless it returns `None` (see [one of the available usage](#null-safe-post-evaluation)), so it must proxy the instance that may contain the attr or key before accessing.```pythontry:    val = _(o.inexistent).nested # AttributeError: '&lt;type&gt;' object has no attribute 'inexistent'except AttributeError:    assert Trueassert _(o).inexistent.nested is undefined```## ContributingContributions welcomed ! Make sure it passes current tests tho.</longdescription>
</pkgmetadata>