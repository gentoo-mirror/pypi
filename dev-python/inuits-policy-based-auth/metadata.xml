<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># inuits_policy_based_authinuits_policy_based_auth is a python package for securing API endpoints based on policies.## InstallationInstall inuits_policy_based_auth as follows:```pip install inuits-policy-based-auth```## Getting StartedInstantiate the PolicyFactory in you app, for example in app.py (all examples given are based on a Python Flask app).```pythonfrom inuits_policy_based_auth import PolicyFactorypolicy_factory = PolicyFactory()```### Manually loading policiesImporting and registering policies can be done manually. Don't forget to set a fallback key, this ensures that policies of a specific app are applied when the app cannot be determined automatically.```pythonfrom inuits_policy_based_auth.authentication.policies.token_based_policies.authlib_flask_oauth2_policy import (    AuthlibFlaskOauth2Policy,)from inuits_policy_based_auth.authorization.policies.super_admin_policy import (    SuperAdminPolicy,)policy_factory.register_authentication_policy(&quot;apps.[app_name]&quot;, AuthlibFlaskOauth2Policy(...))policy_factory.register_authorization_policy(&quot;apps.[app_name]&quot;, SuperAdminPolicy())policy_factory.set_fallback_key_for_policy_mapping(&quot;apps.[app_name]&quot;)```However, it is recommended to load policies dynamically as this will allow you to make use of the full potential of this package.### Dynamically loading policiesYou can write a loader which loads policies dynamically based on a configuration file.Example configuration file:```json{  &quot;[app_name_1]&quot;: {    &quot;policies&quot;: {      &quot;authentication&quot;: [        &quot;token_based_policies.authlib_flask_oauth2_policy&quot;,        &quot;token_based_policies.default_tenant_policy&quot;      ],      &quot;authorization&quot;: [        &quot;super_admin_policy&quot;,        &quot;scope_based_policy&quot;      ]    }  },  &quot;[app_name_2]&quot;: {    &quot;policies&quot;: {      &quot;authentication&quot;: [        &quot;token_based_policies.authlib_flask_oauth2_policy&quot;,        &quot;token_based_policies.default_tenant_policy&quot;      ],      &quot;authorization&quot;: [        &quot;super_admin_policy&quot;,        &quot;open_data_policy&quot;      ]    }  }}```Example policy_loader.py:```pythonimport jsonimport osfrom importlib import import_modulefrom inuits_policy_based_auth import PolicyFactoryfrom inuits_policy_based_auth.exceptions import (    PolicyFactoryException,)from logging import Loggerdef load_policies(policy_factory: PolicyFactory, logger: Logger):    apps = {}    with open(str(os.getenv(&quot;[CONFIGURATION_FILE_NAME]&quot;)), &quot;r&quot;) as configuration_file:        apps = json.load(configuration_file)    for app in apps:        try:            auth_type = &quot;authentication&quot;            for policy_module_name in apps[app][&quot;policies&quot;].get(auth_type):                policy = __get_class(app, auth_type, policy_module_name)                policy = __instantiate_authentication_policy(                    policy_module_name, policy, logger                )                policy_factory.register_authentication_policy(                    f&quot;apps.{app}&quot;, policy                )            auth_type = &quot;authorization&quot;            for policy_module_name in apps[app][&quot;policies&quot;].get(auth_type):                policy = __get_class(app, auth_type, policy_module_name)                policy_factory.register_authorization_policy(                    f&quot;apps.{app}&quot;, policy()                )        except Exception as error:            raise PolicyFactoryException(                f&quot;Policy factory was not configured correctly: {str(error)}&quot;            ).with_traceback(error.__traceback__)    policy_factory.set_fallback_key_for_policy_mapping(&quot;apps.[app_name]&quot;)def __get_class(app, auth_type, policy_module_name):    module = None    try:        module = import_module(f&quot;apps.{app}.policies.{auth_type}.{policy_module_name}&quot;)    except:        module = import_module(            f&quot;inuits_policy_based_auth.{auth_type}.policies.{policy_module_name}&quot;        )    policy_class_name = module.__name__.split(&quot;.&quot;)[-1].title().replace(&quot;_&quot;, &quot;&quot;)    policy = getattr(module, policy_class_name)    return policydef __instantiate_authentication_policy(policy_module_name, policy, logger: Logger):    token_schema = __load_token_schema()    if policy_module_name == &quot;token_based_policies.authlib_flask_oauth2_policy&quot;:        allow_anonymous_users = (            True            if os.getenv(&quot;ALLOW_ANONYMOUS_USERS&quot;, &quot;false&quot;).lower() == &quot;true&quot;            else False        )        return policy(            logger,            token_schema,            os.getenv(&quot;STATIC_ISSUER&quot;),            os.getenv(&quot;STATIC_PUBLIC_KEY&quot;),            None,            allow_anonymous_users,        )    if policy_module_name == &quot;token_based_policies.default_tenant_policy&quot;:        return policy(            token_schema, os.getenv(&quot;ROLE_SCOPE_MAPPING&quot;, os.getenv(&quot;API_SCOPES&quot;))        )    return policy()def __load_token_schema() -&gt; dict:    token_schema_path = os.getenv(        &quot;TOKEN_SCHEMA&quot;, &quot;path/to/token_schema.json&quot;    )    with open(token_schema_path, &quot;r&quot;) as token_schema:        return json.load(token_schema)```Now you can import the loader in app.py and pass ```policy_factory``` as an argument to it.```pythonfrom apps.policy_loader import load_policiesfrom logging import Loggerload_policies(policy_factory, Logger(&quot;&quot;))```As you can see in these examples, dynamically loading policies will allow you to add new policies and override existing ones, which makes this package highly customizable and generic.### Custom policiesContinuing from the examples above, you can make a custom authorization policy by creating a folder ```policies``` within a specific app. Here you should create the folders ```authentication``` and ```authorization``` that will contain custom policies which you can add to your configuration. In this case we name our new policy the same as an existing one, which will override it. Each authentication policy must inherit from BaseAuthenticationPolicy and implement the abstract method ```authenticate```, while each authorization policy must inherit from BaseAuthorizationPolicy and implement the abstract method ```authorize```.Example folder structure:```api├── apps│  ├── [app_name]│  │  ├── policies│  │  │  ├── authentication│  │  │  └── authorization│  │  │     └── open_data_policy.py│  │  ├── ......│  ├── configuration.json│  └── policy_loader.py...└── app.py```Example custom open_data_policy.py:```pythonfrom inuits_policy_based_auth import BaseAuthorizationPolicyclass OpenDataPolicy(BaseAuthorizationPolicy):    def authorize(self, policy_context, _, request_context):        request = request_context.http_request        if request.method == &quot;GET&quot;:            policy_context.access_verdict = True        return policy_context```## UsageIf everything is set up correctly, you can use the ```apply_policies``` decorator as follows:```pythonfrom app import policy_factoryfrom flask import requestfrom inuits_policy_based_auth import RequestContextclass Entity():    @policy_factory.apply_policies(        RequestContext(request, [&quot;[scope_1]&quot;, &quot;[scope_2]&quot;])    )    def get(self):        ...```You can also use the ```authenticate``` decorator to only apply authentication policies:```pythonfrom app import policy_factoryfrom flask import requestfrom inuits_policy_based_auth import RequestContextclass Entity():    @policy_factory.authenticate(RequestContext(request))    def get(self):        ...```## ContributingDo not hesitate to open issues and create pull requests.</longdescription>
</pkgmetadata>