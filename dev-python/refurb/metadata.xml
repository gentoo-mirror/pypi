<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># RefurbA tool for refurbishing and modernizing Python codebases.## Example```python# main.pyfor filename in [&quot;file1.txt&quot;, &quot;file2.txt&quot;]:    with open(filename) as f:        contents = f.read()    lines = contents.splitlines()    for line in lines:        if not line or line.startswith(&quot;# &quot;) or line.startswith(&quot;// &quot;):            continue        for word in line.split():            print(f&quot;[{word}]&quot;, end=&quot;&quot;)        print(&quot;&quot;)```Running:```$ refurb main.pymain.py:3:17 [FURB109]: Use `in (x, y, z)` instead of `in [x, y, z]`main.py:4:5 [FURB101]: Use `y = Path(x).read_text()` instead of `with open(x, ...) as f: y = f.read()`main.py:10:40 [FURB102]: Replace `x.startswith(y) or x.startswith(z)` with `x.startswith((y, z))`main.py:16:9 [FURB105]: Use `print() instead of `print(&quot;&quot;)````## Installing```$ pipx install refurb$ refurb file.py folder/```&gt; **Note**&gt; Refurb only supports Python 3.10. It can check Python 3.6 code and up, but Refurb&gt; itself must be ran through Python 3.10.## Explanations For ChecksYou can use `refurb --explain FURB123`, where `FURB123` is the error code you are trying to look up.For example:````$ refurb --explain FURB123Don't cast a variable or literal if it is already of that type. Forexample:Bad:```name = str(&quot;bob&quot;)num = int(123)```Good:```name = &quot;bob&quot;num = 123```````An online list of all available checks can be viewed [here](./docs/checks.md).## Ignoring ErrorsUse `--ignore 123` to ignore error 123. The error code can be in the form `FURB123` or `123`.This flag can be repeated.&gt; The `FURB` prefix indicates that this is a built-in error. The `FURB` prefix is optional,&gt; but for all other errors (ie, `ABC123`), the prefix is required.You can also use inline comments to disable errors:```pythonx = int(0)  # noqa: FURB123y = list()  # noqa```Here, `noqa: FURB123` specifically ignores the FURB123 error for that line, and `noqa` ignoresall errors on that line.You can also specify multiple errors to ignore by separating them with a comma/space:```pythonx = not not int(0)  # noqa: FURB114, FURB123x = not not int(0)  # noqa: FURB114 FURB123```## Enabling/Disabling ChecksCertain checks are disabled by default, and need to be enabled first. You can do this using the`--enable ERR` flag, where `ERR` is the error code of the check you want to enable. A disabledcheck differs from an ignored check in that a disabled check will never be loaded, whereas anignored check will be loaded, an error will be emitted, and the error will be suppressed.Use the `--verbose` flag to get a full list of enabled checks.The opposite of `--enable` is `--disable`, which will disable a check. When `--enable` and `--disable`are both specified via the command line, whichever one comes last will take precedence. When using`enable` and `disable` via the config file, `disable` will always take precedence.Use the `--disable-all` flag to disable all checks. This allows you to incrementally `--enable` checksas you see fit, as opposed to adding a bunch of `--ignore` flags. To use this in the config file,set `disable_all` to `true`.Use the `--enable-all` flag to enable all checks by default. This allows you to opt into all checksthat Refurb (and Refurb plugins) have to offer. This is a good option for new codebases. To use thisin a config file, set `enable_all` to `true`.In the config file, `disable_all`/`enable_all` is applied first, and then the `enable` and `disable`fields are applied afterwards.&gt; Note that `disable_all` and `enable_all` are mutually exclusive, both on the command line and in&gt; the config file. You will get an error if you try to specify both.You can also disable checks by category using the `#category` syntax. For example, `--disable &quot;#readability&quot;`will disable all checks with the `readability` category. The same applies for `enable` and `ignore`.Also, if you disable an entire category you can still explicitly re-enable a check in that category.&gt; Note that `#readability` is wrapped in quotes because your shell will interpret the `#` as the&gt; start of a comment.## Setting Python VersionUse the `--python-version` flag to tell Refurb which version of Python your codebase is using. Thisshould allow for better detection of language features, and allow for better error messages. The argumentfor this flag must be in the form `x.y`, for example, `3.10`.The syntax for using this in the config file is `python_version = &quot;3.10&quot;`.## Changing Output FormatsBy default everything is outputted as plain text:```file.py:1:5 [FURB123]: Replace `int(x)` with `x````Here are all of the available formats:* `text`: The default* `github`: Print output for use with [GitHub Annotations](https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions)* More to come!To change the default format use `--format XYZ` on the command line, or `format = &quot;XYZ&quot;` in the config file.## Changing Sort OrderBy default errors are sorted by filename, then by error code. To change this, use the `--sort XYZ` flag onthe command line, or `sort_by = &quot;XYZ&quot;` in the config file, where `XYZ` is one of the following sort modes:* `filename`: Sort files in alphabetical order (the default)* `error`: Sort by error first, then by filename## Overriding Mypy FlagsThis is typically used for development purposes, but can also be used to better fine-tune Mypy fromwithin Refurb. Any command line arguments after `--` are passed to Mypy. For example:```$ refurb files -- --show-traceback```This tells Mypy to show a traceback if it crashes.You can also use this in the config file by assigning an array of values to the `mypy_args` field.Note that any Mypy arguments passed via the command line arguments will override the `mypy_args`field in the config file.## Configuring RefurbIn addition to the command line arguments, you can also add your settings in the `pyproject.toml` file.For example, the following command line arguments:```refurb file.py --ignore 100 --load some_module --quiet```Corresponds to the following in your `pyproject.toml` file:```toml[tool.refurb]ignore = [100]load = [&quot;some_module&quot;]quiet = true```Now all you need to type is `refurb file.py`!Note that the values in the config file will be merged with the values specified via thecommand line. In the case of boolean arguments like `--quiet`, the command line argumentstake precedence. All other arguments (such as `ignore` and `load`) will be combined.You can use the `--config-file` flag to tell Refurb to use a different config file from thedefault `pyproject.toml` file. Note that it still must be in the same form as the normal`pyproject.toml` file.### Ignore Checks Per File/FolderIf you have a large codebase you might want to ignore errors for certain files or folders,which allows you to incrementally fix errors as you see fit. To do that, add the followingto your `pyproject.toml` file:```toml# these settings will be applied globally[tool.refurb]enable_all = true# these will only be applied to the &quot;src&quot; folder[[tool.refurb.amend]]path = &quot;src&quot;ignore = [&quot;FURB123&quot;, &quot;FURB120&quot;]# these will only be applied to the &quot;src/util.py&quot; file[[tool.refurb.amend]]path = &quot;src/util.py&quot;ignore = [&quot;FURB125&quot;, &quot;FURB148&quot;]```&gt; Note that only the `ignore` field is available in the `amend` sections. This is because&gt; a check can only be enabled/disabled for the entire codebase, and cannot be selectively&gt; enabled/disabled on a per-file basis. Assuming a check is enabled though, you can simply&gt; `ignore` the errors for the files of your choosing.## Using Refurb With `pre-commit`You can use Refurb with [pre-commit](https://pre-commit.com/) by adding the followingto your `.pre-commit-config.yaml` file:```yaml  - repo: https://github.com/dosisod/refurb    rev: REVISION    hooks:      - id: refurb```Replacing `REVISION` with a version or SHA of your choosing (or leave it blank tolet `pre-commit` find the most recent one for you).## PluginsInstalling plugins for Refurb is very easy:```$ pip install refurb-plugin-example```Where `refurb-plugin-example` is the name of the plugin. Refurb will automatically loadany installed plugins.To make your own Refurb plugin, see the [`refurb-plugin-example` repository](https://github.com/dosisod/refurb-plugin-example)for more info.## Writing Your Own CheckIf you want to extend Refurb but don't want to make a full-fledged plugin,you can easily create a one-off check file with the `refurb gen` command.&gt; Note that this command uses the `fzf` fuzzy-finder for getting user input,&gt; so you will need to [install fzf](https://github.com/junegunn/fzf#installation) before continuing.Here is the basic overview for creating a new check using the `refurb gen` command:1. First select the node type you want to accept2. Then type in where you want to save the auto generated file3. Add your code to the new fileTo get an idea of what you need to add to your check, use the `--debug` flag to see theAST representation for a given file (ie, `refurb --debug file.py`). Take a look at thefiles in the `refurb/checks/` folder for some examples.Then, to load your new check, use `refurb file.py --load your.path.here`&gt; Note that when using `--load`, you need to use dots in your argument, just like&gt; importing a normal python module. If `your.path.here` is a directory, all checks&gt; in that directory will be loaded. If it is a file, only that file will be loaded.## Developing / Contributing### SetupTo setup locally run:```$ git clone https://github.com/dosisod/refurb$ cd refurb$ make install```Tests can be ran all at once using `make`, or you can run each tool on its own using`make black`, `make flake8`, and so on.Unit tests can be ran with `pytest` or `make test`.&gt; Since the end-to-end (e2e) tests are slow, they are not ran when running `make`.&gt; You will need to run `make test-e2e` to run them.### Updating DocumentationWe encourage people to update the documentation when they see typos and other issues!With that in mind though, don't directly modify the `docs/checks.md` file. It is auto-generatedand will be overridden when new checks are added. The documentation for checks can be updatedby changing the docstrings of in the checks themselves. For example, to update `FURB100`,change the docstring of the `ErrorInfo` class in the `refurb/checks/pathlib/with_suffix.py` file.You can find the file for a given check by grep-ing for `code = XYZ`, where `XYZ` is the checkyou are looking for but with the `FURB` prefix removed.Use the `--verbose` flag with `--explain` to find the filename for a given check. For example:```$ refurb --explain FURB123 --verboseFilename: refurb/checks/readability/no_unnecessary_cast.pyFURB123: no-redundant-cast [readability]...```## Why Does This Exist?I love doing code reviews: I like taking something and making it better, faster, moreelegant, and so on. Lots of static analysis tools already exist, but none of them seemto be focused on making code more elegant, more readable, or more modern. That is whereRefurb comes in.Refurb is heavily inspired by [clippy](https://rust-lang.github.io/rust-clippy/master/index.html),the built-in linter for Rust.## What Refurb Is NotRefurb is not a style/type checker. It is not meant as a first-line of defense forlinting and finding bugs, it is meant for making good code even better.## Comparison To Other ToolsThere are already lots of tools out there for linting and analyzing Python code, soyou might be wondering why Refurb exists (skepticism is good!). As mentioned above,Refurb checks for code which can be made more elegant, something that no other linters(that I have found) specialize in. Here is a list of similar linters and analyzers,and how they differ from Refurb:[Black](https://github.com/psf/black): is more focused on the formatting andstyling of the code (line length, trailing comas, indentation, and so on). Itdoes a really good job of making other projects using Black look more or lessthe same. It doesn't do more complex things such as type checking or codesmell/anti-pattern detection.[flake8](https://github.com/pycqa/flake8): flake8 is also a linter, is very extensible,and performs a lot of semantic analysis-related checks as well, such as &quot;unusedvariable&quot;, &quot;break outside of a loop&quot;, and so on. It also checks PEP8conformance. Refurb won't try and replace flake8, because chances are youare already using flake8 anyways.[Pylint](https://github.com/PyCQA/pylint) has [a lot of checks](https://pylint.pycqa.org/en/latest/user_guide/messages/messages_overview.html)which cover a lot of ground, but in general, are focused on bad or buggycode, things which you probably didn't mean to do. Refurb assumes that youknow what you are doing, and will try to cleanup what is already there the bestit can.[Mypy](https://github.com/python/mypy), [Pyright](https://github.com/Microsoft/pyright),[Pyre](https://github.com/facebook/pyre-check), and [Pytype](https://github.com/google/pytype)are all type checkers, and basically just enforce types, ensures arguments match,functions are called in a type safe manner, and so on. They do much more then that, butthat is the general idea. Refurb actually is built on top of Mypy, and uses its ASTparser so that it gets good type information.[pyupgrade](https://github.com/asottile/pyupgrade): Pyupgrade has a lot of goodchecks for upgrading your older Python code to the newer syntax, which is reallyuseful. Where Refurb differs is that Pyupgrade is more focused on upgrading yourcode to the newer version, whereas Refurb is more focused on cleaning up andsimplifying what is already there.In conclusion, Refurb doesn't want you to throw out your old tools, sincethey cover different areas of your code, and all serve a different purpose.Refurb is meant to be used in conjunction with the above tools.</longdescription>
</pkgmetadata>