<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># SQL Views for Postgres[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)Adds first-class support for [PostgreSQL Views][pg-views] in the Django ORM.Fork of the original [django-pgviews][django-pgviews] by [mypebble][mypebble] with support for Django 3.2+.[pg-views]: http://www.postgresql.org/docs/9.1/static/sql-createview.html[django-pgviews]: https://github.com/mypebble/django-pgviews[mypebble]: https://github.com/mypebble## InstallationInstall via pip:    pip install django-pgviews-reduxAdd to installed applications in settings.py:```pythonINSTALLED_APPS = (  # ...  'django_pgviews',)```## Examples```pythonfrom django.db import modelsfrom django_pgviews import view as pgclass Customer(models.Model):    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)    is_preferred = models.BooleanField(default=False)    class Meta:        app_label = 'myapp'class PreferredCustomer(pg.View):    projection = ['myapp.Customer.*',]    dependencies = ['myapp.OtherView',]    sql = &quot;&quot;&quot;SELECT * FROM myapp_customer WHERE is_preferred = TRUE;&quot;&quot;&quot;    class Meta:      app_label = 'myapp'      db_table = 'myapp_preferredcustomer'      managed = False```**NOTE** It is important that we include the `managed = False` in the `Meta` soDjango 1.7 migrations don't attempt to create DB tables for this view.The SQL produced by this might look like:```postgresqlCREATE VIEW myapp_preferredcustomer ASSELECT * FROM myapp_customer WHERE is_preferred = TRUE;```To create all your views, run ``python manage.py sync_pgviews``You can also specify field names, which will map onto fields in your View:```pythonfrom django_pgviews import view as pgVIEW_SQL = &quot;&quot;&quot;    SELECT name, post_code FROM myapp_customer WHERE is_preferred = TRUE&quot;&quot;&quot;class PreferredCustomer(pg.View):    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)    sql = VIEW_SQL```## UsageTo map onto a View, simply extend `pg_views.view.View`, assign SQL to the`sql` argument and define a `db_table`. You must _always_ set `managed = False`on the `Meta` class.Views can be created in a number of ways:1. Define fields to map onto the VIEW output2. Define a projection that describes the VIEW fields### Define FieldsDefine the fields as you would with any Django Model:```pythonfrom django_pgviews import view as pgVIEW_SQL = &quot;&quot;&quot;    SELECT name, post_code FROM myapp_customer WHERE is_preferred = TRUE&quot;&quot;&quot;class PreferredCustomer(pg.View):    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)    sql = VIEW_SQL    class Meta:      managed = False      db_table = 'my_sql_view'```### Define Projection`django-pgviews` can take a projection to figure out what fields it needs tomap onto for a view. To use this, set the `projection` attribute:```pythonfrom django_pgviews import view as pgclass PreferredCustomer(pg.View):    projection = ['myapp.Customer.*',]    sql = &quot;&quot;&quot;SELECT * FROM myapp_customer WHERE is_preferred = TRUE;&quot;&quot;&quot;    class Meta:      db_table = 'my_sql_view'      managed = False```This will take all fields on `myapp.Customer` and apply them to`PreferredCustomer`## Features### Updating ViewsSometimes your models change and you need your Database Views to reflect the newdata. Updating the View logic is as simple as modifying the underlying SQL andrunning:```python manage.py sync_pgviews --force```This will forcibly update any views that conflict with your new SQL.### DependenciesYou can specify other views you depend on. This ensures the other views areinstalled beforehand. Using dependencies also ensures that your views getrefreshed correctly when using `sync_pgviews --force`.**Note:** Views are synced after the Django application has migrated and addingmodels to the dependency list will cause syncing to fail.Example:```pythonfrom django_pgviews import view as pgclass PreferredCustomer(pg.View):    dependencies = ['myapp.OtherView',]    sql = &quot;&quot;&quot;SELECT * FROM myapp_customer WHERE is_preferred = TRUE;&quot;&quot;&quot;    class Meta:      app_label = 'myapp'      db_table = 'myapp_preferredcustomer'      managed = False```### Materialized ViewsPostgres 9.3 and up supports [materialized views](http://www.postgresql.org/docs/current/static/sql-creatematerializedview.html)which allow you to cache the results of views, potentially allowing themto load faster.However, you do need to manually refresh the view. To do this automatically,you can attach [signals](https://docs.djangoproject.com/en/1.8/ref/signals/)and call the refresh function.Example:```pythonfrom django_pgviews import view as pgVIEW_SQL = &quot;&quot;&quot;    SELECT name, post_code FROM myapp_customer WHERE is_preferred = TRUE&quot;&quot;&quot;class Customer(models.Model):    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)    is_preferred = models.BooleanField(default=True)class PreferredCustomer(pg.MaterializedView):    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)    sql = VIEW_SQL@receiver(post_save, sender=Customer)def customer_saved(sender, action=None, instance=None, **kwargs):    PreferredCustomer.refresh()```#### Concurrent refreshPostgres 9.4 and up allow materialized views to be refreshed concurrently, without blocking reads, as long as aunique index exists on the materialized view. To enable concurrent refresh, specify the name of a column that can beused as a unique index on the materialized view. Unique index can be defined on more than one column of a materialized view. Once enabled, passing `concurrently=True` to the model's refresh method will result in postgres performing the refresh concurrently. (Note that the refresh method itself blocks until the refresh is complete; concurrent refresh is most useful when materialized views are updated in another process or thread.)Example:```pythonfrom django_pgviews import view as pgVIEW_SQL = &quot;&quot;&quot;    SELECT id, name, post_code FROM myapp_customer WHERE is_preferred = TRUE&quot;&quot;&quot;class PreferredCustomer(pg.MaterializedView):    concurrent_index = 'id, post_code'    sql = VIEW_SQL    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)@receiver(post_save, sender=Customer)def customer_saved(sender, action=None, instance=None, **kwargs):    PreferredCustomer.refresh(concurrently=True)```#### IndexesAs the materialized view isn't defined through the usual Django model fields, any indexes defined there won't be created on the materialized view. Luckily Django provides a Meta option called `indexes` which can be used to add customindexes to models. `pg_views` supports defining indexes on materialized views using this option.In the following example, one index will be created, on the `name` column. The `db_index=True` on the field definitionfor `post_code` will get ignored.```pythonfrom django_pgviews import view as pgVIEW_SQL = &quot;&quot;&quot;    SELECT id, name, post_code FROM myapp_customer WHERE is_preferred = TRUE&quot;&quot;&quot;class PreferredCustomer(pg.MaterializedView):    sql = VIEW_SQL    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20, db_index=True)        class Meta:        managed = False  # don't forget this, otherwise Django will think it's a regular model        indexes = [             models.Index(fields=[&quot;name&quot;]),        ]```#### WITH NO DATAMaterialized views can be created either with or without data. By default, they are created with data, however`pg_views` supports creating materialized views without data, by defining `with_data = False` for the`pg.MaterializedView` class. Such views then do not support querying until the first refresh (raising `django.db.utils.OperationalError`).Example:```pythonfrom django_pgviews import view as pgclass PreferredCustomer(pg.MaterializedView):    concurrent_index = 'id, post_code'    sql = &quot;&quot;&quot;        SELECT id, name, post_code FROM myapp_customer WHERE is_preferred = TRUE    &quot;&quot;&quot;    with_data = False    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)```#### Conditional materialized views recreateSince all materialized views are recreated on running `migrate`, it can lead to obsolete recreations even if therewere no changes to the definition of the view. To prevent this, version 0.7.0 and higher contain a feature whichchecks existing materialized view definition in the database (if the mat. view exists at all) and compares thedefinition with the one currently defined in your `pg.MaterializedView` subclass. If the definition matchesexactly, the re-create of materialized view is skipped.This feature is enabled by setting the `MATERIALIZED_VIEWS_CHECK_SQL_CHANGED` in your Django settings to `True`, which enables the feature when running `migrate`. The command `sync_pgviews` uses this setting as well,however it also has switches `--enable-materialized-views-check-sql-changed` and`--disable-materialized-views-check-sql-changed` which override this setting for that command.This feature also takes into account indexes. When a view is deemed not needing recreating, the process will stillcheck the indexes on the table and delete any extra indexes and create any missing indexes. This reconciliationis done through the index name, so if you use custom names for your indexes, it might happen that it won't get updatedon change of the content but not the name.### Custom SchemaYou can define any table name you wish for your views. They can even live inside your own custom[PostgreSQL schema](http://www.postgresql.org/docs/current/static/ddl-schemas.html).```pythonfrom django_pgviews import view as pgclass PreferredCustomer(pg.View):    sql = &quot;&quot;&quot;SELECT * FROM myapp_customer WHERE is_preferred = TRUE;&quot;&quot;&quot;    class Meta:      db_table = 'my_custom_schema.preferredcustomer'      managed = False```### Dynamic View SQLIf you need a dynamic view SQL (for example if it needs a value from settings in it), you can override the `run_sql`classmethod on the view to return the SQL. The method should return a namedtuple `ViewSQL`, which contains the queryand potentially the params to `cursor.execute` call. Params should be either None or a list of parameters for the query.```pythonfrom django.conf import settingsfrom django_pgviews import view as pgclass PreferredCustomer(pg.View):    @classmethod    def get_sql(cls):        return pg.ViewSQL(            &quot;&quot;&quot;SELECT * FROM myapp_customer WHERE is_preferred = TRUE and created_at &gt;= %s;&quot;&quot;&quot;,            [settings.MIN_PREFERRED_CUSTOMER_CREATED_AT]        )    class Meta:      db_table = 'preferredcustomer'      managed = False```### Sync Listenersdjango-pgviews 0.5.0 adds the ability to listen to when a `post_sync` event hasoccurred.#### `view_synced`Fired every time a VIEW is synchronised with the database.Provides args:* `sender` - View Class* `update` - Whether the view to be updated* `force` - Whether `force` was passed* `status` - The result of creating the view e.g. `EXISTS`, `FORCE_REQUIRED`* `has_changed` - Whether the view had to change#### `all_views_synced`Sent after all Postgres VIEWs are synchronised.Provides args:* `sender` - Always `None`### Multiple databasesdjango-pgviews can use multiple databases.  Similar to Django's `migrate`management command, our commands (`clear_pgviews`, `refresh_pgviews`,`sync_pgviews`) operate on one database at a time. You can specify whichdatabase to synchronize by providing the `--database` option. For example:```shellpython manage.py sync_pgviews  # uses default dbpython manage.py sync_pgviews --database=myotherdb```Unless using custom routers, django-pgviews will sync all views to the specifieddatabase. If you want to interact with multiple databases automatically, you'llneed to take some additional steps. Please refer to Django's [Automatic databaserouting](https://docs.djangoproject.com/en/3.2/topics/db/multi-db/#automatic-database-routing)to pin views to specific databases.## Django Compatibility&lt;table&gt;  &lt;thead&gt;    &lt;tr&gt;      &lt;th&gt;Django Version&lt;/th&gt;      &lt;th&gt;Django-PGView Version&lt;/th&gt;    &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr&gt;      &lt;td&gt;1.4 and down&lt;/td&gt;      &lt;td&gt;Unsupported&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1.5&lt;/td&gt;      &lt;td&gt;0.0.1&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1.6&lt;/td&gt;      &lt;td&gt;0.0.3&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1.7&lt;/td&gt;      &lt;td&gt;0.0.4&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1.9&lt;/td&gt;      &lt;td&gt;0.1.0&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1.10&lt;/td&gt;      &lt;td&gt;0.2.0&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;2.2&lt;/td&gt;      &lt;td&gt;0.6.0&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;3.0&lt;/td&gt;      &lt;td&gt;0.6.0&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;3.1&lt;/td&gt;      &lt;td&gt;0.6.1&lt;/td&gt;    &lt;tr&gt;      &lt;td&gt;3.2&lt;/td&gt;      &lt;td&gt;0.7.1&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;4.0&lt;/td&gt;      &lt;td&gt;0.8.1&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;4.1&lt;/td&gt;      &lt;td&gt;0.8.4&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;4.2&lt;/td&gt;      &lt;td&gt;0.9.2&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;5.0&lt;/td&gt;      &lt;td&gt;0.9.4&lt;/td&gt;    &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;## Python 3 SupportDjango PGViews Redux only officially supports Python 3.7+, it might work on 3.6, but there's no guarantees.</longdescription>
</pkgmetadata>