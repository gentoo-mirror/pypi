<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;h1 align=&quot;center&quot;&gt; pyding üõé &lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;PyDing is a (very) simple but effective event handler.&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://twitter.com/jaobernard&quot;&gt;        &lt;img alt=&quot;Feito por Jo√£o Bernardi&quot; src=&quot;https://img.shields.io/badge/feito%20por-%40jaobernard-39013C&quot;&gt;    &lt;/a&gt;    &lt;a&gt;        &lt;img src=&quot;https://img.shields.io/github/last-commit/jaobernardi/pyding?color=39013C&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://pypi.org/project/pyding&quot;&gt;        &lt;img src=&quot;https://img.shields.io/pypi/dm/pyding?color=39013C&quot;&gt;    &lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2 align=&quot;center&quot;&gt; Usage &lt;/h2&gt;```python# Import the moduleimport pyding# Attach a handler to an event.@pyding.on(&quot;greetings&quot;)def greeter(event):    print(&quot;Hello there from pyding!&quot;)# Call the eventpyding.call(&quot;greetings&quot;)# Hello there from pyding!```&lt;h3 align=&quot;center&quot;&gt; Async handlers &lt;/h2&gt;```python# Import the moduleimport pydingimport asyncio# Attach a handler to an event.@pyding.on(&quot;greetings&quot;, is_async=True)async def greeter(event):    print(&quot;Hello there from pyding!&quot;)# Call the eventasyncio.run(pyding.async_call('greetings'))# Hello there from pyding!```&lt;h3 align=&quot;center&quot;&gt; Waiting for events &lt;/h3&gt;&lt;p align=&quot;center&quot;&gt; You can wait for events to be called from another part from your code without having to create a handler by using &lt;code&gt;pyding.wait_for&lt;/code&gt;&lt;/p&gt;```python# Import the moduleimport pydingfrom threading import Threadfrom time import sleepdef random_calls():    # Keep calling the event every 10 seconds.    while True:        pyding.call(&quot;random_event&quot;)        sleep(10)# Start the threadthread = Thread(target=random_calls, daemon=True)thread.start()# Wait for the event to be calledevent_inputs = pyding.wait_for(&quot;random_event&quot;)# event_inputs = {'event': EventCall object, ... any other keyargs here ... }```&lt;h3 align=&quot;center&quot;&gt; Cancellable events &lt;/h3&gt;&lt;p align=&quot;center&quot;&gt; You can also make events that can be cancelled, using the &lt;code&gt;cancellable&lt;/code&gt; keyword for &lt;code&gt;pyding.call&lt;/code&gt;&lt;/p&gt;&gt; ‚ö†Ô∏è - Cancelling an event which cannot be cancelled will raise `pyding.exceptions.UncancellableEvent````pythonimport pyding# Attach the handler to an event@pyding.on(&quot;check&quot;)def checker(event):    # Do stuff        # Cancel the event    event.cancel()# Call the eventevent = pyding.call(&quot;check&quot;, cancellable=True)event.cancelled# will return True```&lt;h3 align=&quot;center&quot;&gt; Hierarchy &lt;/h3&gt;&lt;p align=&quot;center&quot;&gt; Event handlers can have an priority attached to them. If the event is cancelled, it will not execute the next handlers. This behavior can be changed by the &lt;code&gt;blocking&lt;/code&gt; keyword for &lt;code&gt;pyding.call&lt;/code&gt;&lt;/p&gt;```pythonimport pyding# Attach the handler to an event@pyding.on(&quot;check&quot;, priority=10)def checker_one(event):    print(&quot;I got executed!&quot;)@pyding.on(&quot;check&quot;, priority=0)def checker_two(event):    print(&quot;Me too&quot;)# Call the eventevent = pyding.call(&quot;check&quot;)# I got executed!# Me too``````pythonimport pyding# Attach the handler to an event@pyding.on(&quot;check&quot;, priority=10)def checker_one(event):    print(&quot;I got executed!&quot;)    event.cancel()@pyding.on(&quot;check&quot;, priority=0)def checker_two(event):    # This won't be executed at first since it got cancelled by checker_one    print(&quot;Me too&quot;)# Call the eventpyding.call(&quot;check&quot;, cancellable=True)# I got executed!# Call the event and do not break if the event is cancelled.event = pyding.call(&quot;check&quot;, cancellable=True, blocking=False)# I got executed!# Me tooevent.cancelled# True```&gt; üõë - You can also stop the event execution by using `event.stop()`&lt;h3 align=&quot;center&quot;&gt;  Dealing with the response &lt;/h3&gt;&lt;p align=&quot;center&quot;&gt; Events can return values, which will be attributed to &lt;code&gt;event.response&lt;/code&gt; and &lt;code&gt;event.responses&lt;/code&gt;&lt;/p&gt;```pythonimport pyding# Attach the handler to an event@pyding.on(&quot;greetings&quot;)def greeter(event):    return &quot;Hello World!&quot;# Call the eventevent = pyding.call(&quot;greetings&quot;)event.response# Hello World!event.responses# ['Hello World!']```&lt;h3 align=&quot;center&quot;&gt;  Using arguments &lt;/h3&gt;&lt;p align=&quot;center&quot;&gt; Arguments can be passed onto the handlers through &lt;code&gt;pyding.call&lt;/code&gt; &lt;/p&gt;```pythonimport pyding# Attach the handler to an event@pyding.on(&quot;greetings&quot;)def greeter(event, name):    return f&quot;Hello {name}!&quot;# Call the eventevent = pyding.call(&quot;greetings&quot;, name=&quot;John Doe&quot;)event.response# Hello John Doe!```&lt;p align=&quot;center&quot;&gt; Essential arguments can be passed to &lt;code&gt;@pyding.on&lt;/code&gt; to make sure the handler only will be called if they're met.&lt;/p&gt;```pythonimport pyding# Attach the handler to an event@pyding.on(&quot;greetings&quot;, name=&quot;John Doe&quot;)def john_doe_greeter(event, name, time):    return f&quot;Hello {name}! It's currently {time}&quot;# Call the eventevent_two = pyding.call(&quot;greetings&quot;, name=&quot;John Bar&quot;, time=&quot;10 AM&quot;)# There won't be any response since the handler won't be called since the 'name' essential keyword wasn't equal to 'John Doe'.event_two.response# None# Call the eventevent = pyding.call(&quot;greetings&quot;, name=&quot;John Doe&quot;, time=&quot;10 AM&quot;)event.response# &quot;Hello John Doe! It's currently 10 AM&quot;# You can also raise pyding.exceptions.UnfulfilledException if you add requirement_exceptions=True to pyding.on decorator.```&lt;h3 align=&quot;center&quot;&gt; Events within classes &lt;/h3&gt;&lt;p align=&quot;center&quot;&gt; Objects can have methods that act as an event handler. &lt;/p&gt;```pythonimport pydingclass MyClass(pyding.EventSupport):    def __init__(self, name):        self.register_events()        self.name = name    @pyding.on(&quot;my_event&quot;)    def event_handler(self, event):        print(f&quot;Hello World from MyClass! My name is {self.name}.&quot;)# Nothing will happen because there is no instance of MyClasspyding.call(&quot;my_event&quot;)myclass = MyClass(&quot;foo&quot;)pyding.call(&quot;my_event&quot;)# &quot;Hello world from MyClass! My name is foo.&quot;```&lt;h3 align=&quot;center&quot;&gt; Dealing with Event Spaces &lt;/h3&gt;&lt;p align=&quot;center&quot;&gt; Event spaces allow to separate event handlers. &lt;/p&gt;```python# Import the moduleimport pyding# Create an Event Spacemyspace = pyding.EventSpace()# Attach a handler to an event.@myspace.on(&quot;greetings&quot;)def greeter(event):    print(&quot;Hello there from myspace's event space!&quot;)# Calling the event from the global space won't trigger any handler from myspace.pyding.call(&quot;greetings&quot;)# Calling the event from myspace will trigger the &quot;greeter&quot; handler.myspace.call(&quot;greetings&quot;)# Hello there from myspace's event space!```&lt;h3 align=&quot;center&quot;&gt; Removing handlers &lt;/h3&gt;&lt;p align=&quot;center&quot;&gt; Event spaces allow you to unregister handlers. &lt;/p&gt;```python# Import the moduleimport pyding# Attach a handler to an event.@on(&quot;greetings&quot;)def greeter(event):    print(&quot;Hello there from myspace's event space!&quot;)# Unregister eventpyding.unregister_handler(greeter)# Orgreeter.unregister()# You can also remove handlers from other modules by using pyding.unregister_from_module(module)```</longdescription>
</pkgmetadata>