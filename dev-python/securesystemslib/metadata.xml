<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Secure Systems Library----------------------.. image:: https://github.com/secure-systems-lab/securesystemslib/workflows/Run%20Securesystemslib%20tests/badge.svg   :target: https://github.com/secure-systems-lab/securesystemslib/actions?query=workflow%3A%22Run+Securesystemslib+tests%22+branch%3AmainA library that provides cryptographic and general-purpose functions for SecureSystems Lab projects at NYU.  The routines are general enough to be usable byother projects.Overview++++++++securesystemslib supports public-key and general-purpose cryptography, such as`ECDSA&lt;https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm&gt;`_,`Ed25519 &lt;http://ed25519.cr.yp.to/&gt;`_, `RSA&lt;https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29&gt;`_, SHA256, SHA512, etc.Most of the cryptographic operations are performed by the `cryptography&lt;https://cryptography.io/en/latest/&gt;`_ and `PyNaCl&lt;https://github.com/pyca/pynacl&gt;`_ libraries, but verification of Ed25519signatures can be done in pure Python.The `cryptography` library is used to generate keys and signatures with theECDSA and RSA algorithms, and perform general-purpose cryptography such asencrypting keys.  The PyNaCl library is used to generate Ed25519 keys andsignatures.  PyNaCl is a Python binding to the Networking and CryptographyLibrary.  For key storage, RSA keys may be stored in PEM or JSON format, andEd25519 keys in JSON format.  Generating, importing, and loading cryptographickey files can be done with functions available in securesystemslib.securesystemslib also provides an interface to the `GNU Privacy Guard (GPG)&lt;https://gnupg.org/&gt;`_ command line tool, with functions to create RSA and DSAsignatures using private keys in a local gpg keychain; to export thecorresponding public keys in a *pythonic* format; and to verify the createdsignatures using the exported keys. The latter does not require the gpg commandline tool to be installed, instead the `cryptography` library is used.Installation++++++++++++::    $ pip install securesystemslibThe default installation only supports Ed25519 keys and signatures (in purePython).  Support for RSA, ECDSA, and E25519 via the `cryptography` and`PyNaCl` libraries is available by installing the `crypto` and `pynacl` extras:::    $ pip install securesystemslib[crypto]    $ pip install securesystemslib[pynacl]Usage++++++++++++Create RSA Keys~~~~~~~~~~~~~~~Note:  In the instructions below, lines that start with *&gt;&gt;&gt;* denote commandsthat should be entered by the reader, *#* begins the start of a comment, andtext without prepended symbols is the output of a command.::    &gt;&gt;&gt; from securesystemslib.interface import *    # The following function creates an RSA key pair, where the private key is    # saved to &quot;rsa_key1&quot; and the public key to &quot;rsa_key1.pub&quot; (both saved to    # the current working directory).  A full directory path may be specified    # instead of saving keys to the current working directory.  If specified    # directories do not exist, they will be created.    &gt;&gt;&gt; generate_and_write_rsa_keypair(            password=&quot;password&quot;, filepath=&quot;rsa_key1&quot;, bits=2048)    # If the key length is unspecified, it defaults to 3072 bits. A length of    # less than 2048 bits raises an exception. A similar function is available    # to supply a password on the prompt. If an empty password is entered, the    # private key is saved unencrypted.    &gt;&gt;&gt; generate_and_write_rsa_keypair_with_prompt(&quot;rsa_key2&quot;)    enter password to encrypt private key file '/path/to/rsa_key2'    (leave empty if key should not be encrypted):    Confirm:The following four key files should now exist:1.  rsa_key12.  rsa_key1.pub3.  rsa_key24.  rsa_key2.pubImport RSA Keys~~~~~~~~~~~~~~~::    # Continuing from the previous section . . .    # Import an existing public key.    &gt;&gt;&gt; public_rsa_key1 = import_rsa_publickey_from_file(&quot;rsa_key1.pub&quot;)    # Import an existing private key.  If your private key is encrypted,    # which it should be, you either have to pass a 'password' or enter one    # on the prompt.    &gt;&gt;&gt; private_rsa_key1 = import_rsa_privatekey_from_file(&quot;rsa_key1&quot;, password=&quot;some passphrase&quot;)    # OR:    &gt;&gt;&gt; private_rsa_key1 = import_rsa_privatekey_from_file(&quot;rsa_key1&quot;, prompt=True)    enter password to decrypt private key file '/path/to/rsa_key1'    (leave empty if key not encrypted):**import_rsa_privatekey_from_file()** raises a*securesystemslib.exceptions.CryptoError* exception if the key / password isinvalid:::    securesystemslib.exceptions.CryptoError: RSA (public, private) tuple cannot    be generated from the encrypted PEM string: Bad decrypt. Incorrect password?Note: The specific message provided by the exception might differ depending onwhich cryptography library is used.Create and Import Ed25519 Keys~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~::    # Continuing from the previous section . . .    # The same generation and import functions as for rsa keys exist for ed25519    &gt;&gt;&gt; generate_and_write_ed25519_keypair_with_prompt('ed25519_key')    enter password to encrypt private key file '/path/to/ed25519_key'    (leave empty if key should not be encrypted):    Confirm:    # Import the Ed25519 public key just created . . .    &gt;&gt;&gt; public_ed25519_key = import_ed25519_publickey_from_file('ed25519_key.pub')    # and its corresponding private key.    &gt;&gt;&gt; private_ed25519_key = import_ed25519_privatekey_from_file('ed25519_key', prompt=True)    enter password to decrypt private key file '/path/to/ed25519_key'    (leave empty if key should not be encrypted):Create and Import ECDSA Keys~~~~~~~~~~~~~~~~~~~~~~~~~~~~::    # The same generation and import functions as for rsa and ed25519 keys    # exist for ecdsa    &gt;&gt;&gt; generate_and_write_ecdsa_keypair_with_prompt('ecdsa_key')    enter password to decrypt private key file '/path/to/ecdsa_key'    (leave empty if key should not be encrypted):    &gt;&gt;&gt; public_ecdsa_key = import_ecdsa_publickey_from_file('ecdsa_key.pub')    &gt;&gt;&gt; private_ecdsa_key = import_ecdsa_privatekey_from_file('ecdsa_key', prompt=True)    enter password to decrypt private key file '/path/to/ecdsa_key'    (leave empty if key should not be encrypted):Generate ECDSA, Ed25519, and RSA Signatures~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Note: Users may also access the crypto functions directly to performcryptographic operations.::    &gt;&gt;&gt; from securesystemslib.keys import *    &gt;&gt;&gt; data = b'The quick brown fox jumps over the lazy dog'    &gt;&gt;&gt; ed25519_key = generate_ed25519_key()    &gt;&gt;&gt; signature = create_signature(ed25519_key, data)    &gt;&gt;&gt; rsa_key = generate_rsa_key(2048)    &gt;&gt;&gt; signature = create_signature(rsa_key, data)    &gt;&gt;&gt; ecdsa_key = generate_ecdsa_key()    &gt;&gt;&gt; signature = create_signature(ecdsa_key, data)Verify ECDSA, Ed25519, and RSA Signatures~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~::    # Continuing from the previous sections . . .    &gt;&gt;&gt; data = b'The quick brown fox jumps over the lazy dog'    &gt;&gt;&gt; ed25519_key = generate_ed25519_key()    &gt;&gt;&gt; signature = create_signature(ed25519_key, data)    &gt;&gt;&gt; verify_signature(ed25519_key, signature, data)    True    &gt;&gt;&gt; verify_signature(ed25519_key, signature, 'bad_data')    False    &gt;&gt;&gt; rsa_key = generate_rsa_key()    &gt;&gt;&gt; signature = create_signature(rsa_key, data)    &gt;&gt;&gt; verify_signature(rsa_key, signature, data)    True    &gt;&gt;&gt; ecdsa_key = generate_ecdsa_key()    &gt;&gt;&gt; signature = create_signature(ecdsa_key, data)    &gt;&gt;&gt; verify_signature(ecdsa_key, signature, data)    TrueMiscellaneous functions~~~~~~~~~~~~~~~~~~~~~~~**create_rsa_encrypted_pem()**::    # Continuing from the previous sections . . .    &gt;&gt;&gt; rsa_key = generate_rsa_key()    &gt;&gt;&gt; private = rsa_key['keyval']['private']    &gt;&gt;&gt; passphrase = 'secret'    &gt;&gt;&gt; encrypted_pem = create_rsa_encrypted_pem(private, passphrase)**import_rsakey_from_public_pem()**::    &gt;&gt;&gt; rsa_key = generate_rsa_key()    &gt;&gt;&gt; public = rsa_key['keyval']['public']    &gt;&gt;&gt; rsa_key2 = import_rsakey_from_public_pem(public)**import_rsakey_from_pem()**::    &gt;&gt;&gt; rsa_key = generate_rsa_key()    &gt;&gt;&gt; public = rsa_key['keyval']['public']    &gt;&gt;&gt; private = rsa_key['keyval']['private']    &gt;&gt;&gt; rsa_key2 = import_rsakey_from_pem(public)    &gt;&gt;&gt; rsa_key3 = import_rsakey_from_pem(private)**extract_pem()**::    &gt;&gt;&gt; rsa_key = generate_rsa_key()    &gt;&gt;&gt; private_pem = extract_pem(rsakey['keyval']['private'], private_pem=True)    &gt;&gt;&gt; public_pem = extract_pem(rsakey['keyval']['public'], private_pem=False)**encrypt_key()**::    &gt;&gt;&gt; ed25519_key = generate_ed25519_key()    &gt;&gt;&gt; password = 'secret'    &gt;&gt;&gt; encrypted_key = encrypt_key(ed25519_key, password)**decrypt_key()**::    &gt;&gt;&gt; ed25519_key = generate_ed25519_key()    &gt;&gt;&gt; password = 'secret'    &gt;&gt;&gt; encrypted_key = encrypt_key(ed25519_key, password)    &gt;&gt;&gt; decrypted_key = decrypt_key(encrypted_key.encode('utf-8'), password)    &gt;&gt;&gt; decrypted_key == ed25519_key    True**create_rsa_encrypted_pem()**::  &gt;&gt;&gt; rsa_key = generate_rsa_key()  &gt;&gt;&gt; private = rsa_key['keyval']['private']  &gt;&gt;&gt; passphrase = 'secret'  &gt;&gt;&gt; encrypted_pem = create_rsa_encrypted_pem(private, passphrase)**is_pem_public()**::    &gt;&gt;&gt; rsa_key = generate_rsa_key()    &gt;&gt;&gt; public = rsa_key['keyval']['public']    &gt;&gt;&gt; private = rsa_key['keyval']['private']    &gt;&gt;&gt; is_pem_public(public)    True    &gt;&gt;&gt; is_pem_public(private)    False**is_pem_private()**::    &gt;&gt;&gt; rsa_key = generate_rsa_key()    &gt;&gt;&gt; private = rsa_key['keyval']['private']    &gt;&gt;&gt; public = rsa_key['keyval']['public']    &gt;&gt;&gt; is_pem_private(private)    True    &gt;&gt;&gt; is_pem_private(public)    False**import_ecdsakey_from_private_pem()**::    &gt;&gt;&gt; ecdsa_key = generate_ecdsa_key()    &gt;&gt;&gt; private_pem = ecdsa_key['keyval']['private']    &gt;&gt;&gt; ecdsa_key2 = import_ecdsakey_from_private_pem(private_pem)**import_ecdsakey_from_public_pem()**::    &gt;&gt;&gt; ecdsa_key = generate_ecdsa_key()    &gt;&gt;&gt; public = ecdsa_key['keyval']['public']    &gt;&gt;&gt; ecdsa_key2 = import_ecdsakey_from_public_pem(public)**import_ecdsakey_from_pem()**::    &gt;&gt;&gt; ecdsa_key = generate_ecdsa_key()    &gt;&gt;&gt; private_pem = ecdsa_key['keyval']['private']    &gt;&gt;&gt; ecdsa_key2 = import_ecdsakey_from_pem(private_pem)    &gt;&gt;&gt; public_pem = ecdsa_key['keyval']['public']    &gt;&gt;&gt; ecdsa_key2 = import_ecdsakey_from_pem(public_pem)GnuPG interface~~~~~~~~~~~~~~~Signature creation and public key export requires installation of the `gpg` or`gpg2` command line tool, which may be downloaded from`https://gnupg.org/download &lt;https://gnupg.org/&gt;`_.It is also needed to generate the supported RSA or DSA signing keys (see `gpg` manpages for detailed instructions). Sample keys are available in a test keyringat `tests/gpg_keyrings/rsa`, which may be passed to the signing and exportfunctions using the `homedir` argument (if not passed the default keyring isused). The GPG client to use can be also specified with the help of environmentvariable `GNUPG`.::    &gt;&gt;&gt; import securesystemslib.gpg.functions as gpg    &gt;&gt;&gt; data = b&quot;The quick brown fox jumps over the lazy dog&quot;    &gt;&gt;&gt; signing_key_id = &quot;8465A1E2E0FB2B40ADB2478E18FB3F537E0C8A17&quot;    &gt;&gt;&gt; keyring = &quot;tests/gpg_keyrings/rsa&quot;    &gt;&gt;&gt; signature = gpg.create_signature(data, signing_key_id, homedir=keyring)    &gt;&gt;&gt; public_key = gpg.export_pubkey(non_default_signing_key, homedir=keyring)    &gt;&gt;&gt; gpg.verify_signature(signature, public_key, data)    TrueTesting++++++++++++Testing is done with `tox &lt;https://testrun.org/tox/&gt;`_, which can be installed with pip:::    $ pip install toxSecure Systems Library supports multiple versions of Python.For that reason, the project is tested against multiple virtual environments with different Python versions.If you run::$ toxthis will run all tests creating virtual environments for all python versions described in the *tox.ini* file.If you want to run the tests against specific python version, for example Python 3.7, you will use:::$ tox -e py37</longdescription>
</pkgmetadata>