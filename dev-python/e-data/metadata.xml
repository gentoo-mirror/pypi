<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Downloads](https://pepy.tech/badge/e-data)](https://pepy.tech/project/e-data)[![Downloads](https://pepy.tech/badge/e-data/month)](https://pepy.tech/project/e-data)[![Downloads](https://pepy.tech/badge/e-data/week)](https://pepy.tech/project/e-data)# python-edataEste paquete proporciona herramientas para la descarga de tus datos de consumo eléctrico (desde Datadis.es) y su posterior procesado. La motivación principal es que conocer el consumo puede ayudarnos a reducirlo, e incluso a elegir una tarifa que mejor se adapte a nuestras necesidades. A día de hoy sus capacidades de facturación (€) son limitadas, soporta PVPC (según disponibilidad de datos de REData) y tarificación fija por tramos. Es el corazón de la integración [homeassistant-edata](https://github.com/uvejota/homeassistant-edata)._**Esta herramienta no mantiene ningún tipo de vinculación con los proveedores de datos anteriormente mencionados, simplemente consulta la información disponible y facilita su posterior análisis.**_## InstalaciónPuedes instalar la última versión estable mediante:``` bashpip install e-data```Si quieres probar la versión `dev` o contribuir a su desarrollo, clona este repositorio e instala manualmente las dependencias:``` bashpip install -r requirements.txt```## EstructuraEl paquete consta de tres módulos diferenciados:* **Conectores** (módulo `connectors`), para definir los métodos de consulta a los diferentes proveedores: Datadis y REData.* **Procesadores** (módulo `processors`), para procesar datos de consumo, maxímetro, o coste (tarificación). Ahora mismo consta de tres procesadores: `billing`, `consumption` y `maximeter`, además de algunas utilidades ubicadas en `utils`. Los procesadores deben heredar de la clase Processor definida en `base.py`* **Ayudantes** (módulo `helpers`), para ayudar en el uso y gestión de los anteriores, presentando de momento un único ayudante llamado `EdataHelper` que te permite recopilar `X` días de datos (por defecto 365) y automáticamente procesarlos. Los datos son almacenados en la variable `data`, mientras que los atributos autocalculados son almacenados en la variable `attributes`. Por lo general, primero utilizan los conectores y luego procesan los datos, gestionando varias tareas de recuperación (principalmente para Datadis).Estos módulos corresponden a la siguiente estructura del paquete:```edata/    · __init__.py    · connectors/        · __init__.py        · datadis.py        · redata.py    · processors/        · __init__.py        · base.py        · billing.py        · consumption.py        · maximeter.py        · utils.py    · helpers.py```## Ejemplo de usoPartimos de que tenemos credenciales en Datadis.es. Algunas aclaraciones:* No es necesario solicitar API pública en el registro (se utilizará la API privada habilitada por defecto)* El username suele ser el NIF del titular* Copie el CUPS de la web de Datadis, algunas comercializadoras adhieren caracteres adicionales en el CUPS mostrado en su factura.* La herramienta acepta el uso de NIF autorizado para consultar el suministro de otro titular.``` pythonfrom datetime import datetimeimport json# importamos definiciones de datos que nos interesenfrom edata.definitions import PricingRules# importamos el ayudantefrom edata.helpers import EdataHelper# importamos el procesador de utilidadesfrom edata.processors import utils# Preparar reglas de tarificación (si se quiere)PRICING_RULES_PVPC = PricingRules(    p1_kw_year_eur=30.67266,    p2_kw_year_eur=1.4243591,    meter_month_eur=0.81,    market_kw_year_eur=3.113,    electricity_tax=1.0511300560,    iva_tax=1.05,    # podemos rellenar los siguientes campos si quisiéramos precio fijo (y no pvpc)    p1_kwh_eur=None,    p2_kwh_eur=None,    p3_kwh_eur=None,)# Instanciar el helper# 'authorized_nif' permite indicar el NIF de la persona que nos autoriza a consultar su CUPS.# 'data' permite &quot;cargar&quot; al helper datos anteriores (resultado edata.data de una ejecución anterior), para evitar volver a consultar los mismos.edata = EdataHelper(            &quot;datadis_user&quot;,            &quot;datadis_password&quot;,            &quot;cups&quot;,            datadis_authorized_nif=None,            pricing_rules=PRICING_RULES_PVPC, # si se le pasa None, no aplica tarificación            data=None, # aquí podríamos cargar datos anteriores        )# Solicitar actualización de todo el histórico (se almacena en edata.data)edata.update(date_from=datetime(1970, 1, 1), date_to=datetime.today())# volcamos todo lo obtenido a un ficherowith open(&quot;backup.json&quot;, &quot;w&quot;) as file:    json.dump(utils.serialize_dict(edata.data), file) # se puede utilizar deserialize_dict para la posterior lectura del backup# Imprimir atributosprint(edata.attributes)```</longdescription>
</pkgmetadata>