<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![CI](https://github.com/lmignon/extendable/actions/workflows/ci.yml/badge.svg)](https://github.com/lmignon/extendable/actions/workflows/ci.yml)[![codecov](https://codecov.io/gh/lmignon/extendable/branch/master/graph/badge.svg?token=LXD34T420H)](https://codecov.io/gh/lmignon/extendable)# Extendable## AboutExtendable is a module that aims to provide a way to define extensible pythonclasses. It is designed to provide developers with a convenient and flexible wayto extend the functionality of their Python applications. By leveraging the &quot;extendable&quot;library, developers can easily create modular and customizable components thatcan be added or modified without modifying the core codebase. This library utilizesPython's object-oriented programming features and provides a simple and intuitiveinterface for extending and customizing applications. It aims to enhance codereusability, maintainability, and overall development efficiency. It implementsthe extension by inheritance and composition pattern. It's inspired by the wayodoo implements its models. Others patterns can be used to make your code pluggableand this library doesn't replace them.## Quick startLet's define a first python class.```pythonfrom extendable import ExtendableMetaclass Person(metaclass=ExtendableMeta):    def __init__(self, name: str):        self.name = name    def __repr__(self) -&gt; str:        return self.name```Someone using the module where the class is defined would need to extend theperson definition with a firstname field.```pythonfrom extendable import ExtendableMetaclass PersonExt(Person, extends=Person):    def __init__(self, name: str):        super().__init__(name)        self._firstname = None    @property    def firstname(self) -&gt; str:        return self._firstname    @firstname.setter    def firstname(self, value:str) -&gt; None:        self._firstname = value    def __repr__(self) -&gt; str:        res = super().__repr__()        return f&quot;{res}, {self.firstname or ''}&quot;```At this time we have defined that `PersonExt` extends the initial definitionof `Person`. To finalyse the process, we need to instruct the runtime thatall our class declarations are done by building the final class definitions andmaking it available into the current execution context.```pythonfrom extendable import context, registry_registry = registry.ExtendableClassesRegistry()context.extendable_registry.set(_registry)_registry.init_registry()```Once it's done the `Person` and `PersonExt` classes can be used interchangeablyinto your code since both represent the same class...```pythonp = Person(&quot;Mignon&quot;)p.firstname = &quot;Laurent&quot;print (p)#&gt; Mignon, Laurent```&gt; :warning: This way of extending a predefined behaviour must be used carefully and in&gt; accordance with the [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)&gt; It doesn't replace others design patterns that can be used to make your code pluggable.## How it works Behind the scenes, the &quot;extendable&quot; library utilizes several key concepts and mechanisms to enable its functionality. Overall, the &quot;extendable&quot; library leverages metaclasses, registry initialization, and dynamic loading to provide a flexible and modular approach to extending Python classes. By utilizing these mechanisms, developers can easily enhance the functionality of their applications without the need for extensive modifications to the core codebase.### MetaclassesThe metaclass do 2 things.* It collects the definitions of the declared class and gathers information about  its attributes, methods, and other characteristics. These definitions are stored  in a global registry by module. This registry is a map of module name to a list  of class definitions.* This information is then used to build a class object that acts as a proxy or  blueprint for the actual concrete class that will be created later when the registry  is initialized based on the aggregated definition of all the classes declared  to extend the initial class...### Registry initializationThe registry initialization is the process that build the final class definition.To make your blueprint class work, you need to initialize the registry. This isdone by calling the `init_registry` method of the registry object. This methodwill build the final class definition by aggregating all the definitions of theclasses declared to extend the initial class through a class hierarchy. Theorder of the classes in the hierarchy is important. This order is by defaultthe order in which the classes are loaded by the python interpreter. For advancedusage, you can change this order or even the list of definitions used to build thefinal class definition. This is done by calling the `init_registry` method withthe list of modules[^1] to load as argument.[^1]: When you specify a module into the list of modules to load, the wildcart      character `*` is allowed at the end of the module name to load all the      submodules of the module. Otherwise, only the module itself is loaded.```pythonfrom extendable import registry_registry = registry.ExtendableClassesRegistry()_registry.init_registry([&quot;module1&quot;, &quot;module2.*&quot;])```Once the registry is initialized, it must be made available into the currentexecution context so the blueprint class can use it. To do so you must set theregistry into the `extendable_registry` context variable. This is done bycalling the `set` method of the `extendable_registry` context variable.```pythonfrom extendable import context, registry_registry = registry.ExtendableClassesRegistry()context.extendable_registry.set(_registry)_registry.init_registry()```### Dynamic loadingAll of this is made possible by the dynamic loading capabilities of Python.The concept of dynamic loading in Python refers to the ability to load and executecode at runtime, rather than during the initial compilation or execution phase.It allows developers to dynamically import and use modules, classes, functionsor variables based on certain conditions or user input. The dynamic loadingcan also be applied at class instantiation time. This is the mechanism used bythe &quot;extendable&quot; library to instantiate the final class definition when you callthe constructor of the blueprint class. This is done by implementing the`__call__` method into the metaclass to return the final class definition insteadof the blueprint class itself. The same applies to pretend that the blueprintclass is the final class definition through the implementation of the `__subclasscheck__`method into the metaclass.## DevelopmentTo run tests, use `tox`. You will get a test coverage report in `htmlcov/index.html`.An easy way to install tox is `pipx install tox`.This project uses pre-commit to enforce linting (among which black for code formating,isort for sorting imports, and mypy for type checking).To make sure linters run locally on each of your commits, install pre-commit(`pipx install pre-commit` is recommended), and run `pre-commit install` in yourlocal clone of the extendable repository.To release: * run ``bumpversion patch|minor|major` --list` * Check the `new_version` value returned by the previous command * run `towncrier build`. * Inspect and commit the updated HISTORY.rst. * `git tag {new_version} ; git push --tags`.## ContributingAll kind of contributions are welcome.</longdescription>
</pkgmetadata>