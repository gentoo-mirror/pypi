<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># cmdy&quot;Shell language&quot; to run command in python[![pypi][1]][2] [![tag][3]][4] [![travis][5]][6] [![codacy quality][7]][8] [![codacy quality][9]][8] ![pyver][10]## Installation```shellpip install cmdy```## UsageSee [Demo](./demo.ipynb)### Basic usage```pythonfrom cmdy import lsprint(ls())``````pythonfor line in ls().iter():    print('Got:', line, end='')```#### With non-keyword arguments```pythonfrom cmdy import tarprint(tar(&quot;cvf&quot;, &quot;/tmp/test.tar&quot;, &quot;./cmdy&quot;))```#### With keyword arguments```pythonfrom cmdy import curlcurl(&quot;http://duckduckgo.com/&quot;, o=&quot;/tmp/page.html&quot;, silent=True)# curl http://duckduckgo.com/ -o /tmp/page.html --silent```#### Order keyword arguments```pythoncurl(&quot;http://duckduckgo.com/&quot;, &quot;-o&quot;, &quot;/tmp/page.html&quot;, &quot;--silent&quot;)# orfrom diot import OrderedDiotkwargs = OrderedDiot()kwargs.silent = Truekwargs.o = '/tmp/page.html'curl(&quot;http://duckduckgo.com/&quot;, kwargs)# You can also use collections.OrderedDict```#### Prefix and separator for keyword arguments```pythonfrom cmdy import bedtools, bcftoolsbedtools.intersect(wa=True, wb=True,                   a='query.bed', b=['d1.bed', 'd2.bed', 'd3.bed'],                   names=['d1', 'd2', 'd3'], sorted=True,                   _prefix='-').h().strcmd# 'bedtools intersect -wa -wb -a query.bed \# -b d1.bed d2.bed d3.bed -names d1 d2 d3 -sorted'``````python# default prefix is autobcftools.query(_=['a.vcf', 'b.vcf'], H=True,               format='%CHROM\t%POS\t%REF\t%ALT\n').h().strcmd# &quot;bcftools query -H --format '%CHROM\t%POS\t%REF\t%ALT\n' a.vcf b.vcf&quot;ls(l=True, block_size='KB', _sep='auto').h().cmd['ls', '-l', '--block-size=KB']```#### Mixed combinations of prefices and separators in one command```pythonfrom cmdy import java# Note this is just an example for old verion picard.# Picard is changing it's stylepicard = java(jar='picard.jar', _prefix='', _sep='=', _sub=True)c = picard.SortSam(I='input.bam', O='sorted.bam',               SORTED_ORDER='coordinate',               _prefix='', _sep='=', _deform=None).hprint(c.cmd)# same as the abovejava({'jar': 'picard.jar', '_prefix': '-', '_sep': ' '},     'SortSam', I='input.bam', O='sorted.bam',     SORTED_ORDER='coordinate', _prefix='', _sep='=', _deform=None).h().cmd# _deform prevents SORTED_ORDER to be deformed to SORTED-ORDER# ['java', 'jar=picard.jar',#  'SortSam', 'I=input.bam', 'O=sorted.bam', 'SORTED_ORDER=coordinate']```#### Subcommands```pythonfrom cmdy import gitgit.branch(v=True).fg# &lt;CmdyResult: ['git', 'branch', '-v']&gt;``````python# What if I have separate arguments for main and sub-command?git(git_dir='.', _sub=True).branch(v=True).h# &lt;CmdyHolding: ['git', '--git-dir', '.', 'branch', '-v']&gt;```#### Duplicated keys for list arguments:```pythonfrom cmdy import sortprint(sort(k=['1,1', '2,2'], t='_', _='./.editorconfig', _dupkey=True))# sort -k 1,1 -k 2,2 ./.editorconfig```### Return code and exception```pythonfrom cmdy import xx()``````python consoleTraceback (most recent call last):  File &quot;&lt;ipython-input-16-092cc5b72e61&gt;&quot;, line 2, in &lt;module&gt;    x()/path/.../to/cmdy/__init__.py&quot;, line 146, in __call__    ready_cfgargs, ready_popenargs, _will())/path/.../to/cmdy/__init__.py&quot;, line 201, in __new__    result = holding.run()/path/.../to/cmdy/__init__.py&quot;, line 854, in run    return orig_run(self, wait)/path/.../to/cmdy/__init__.py&quot;, line 717, in run    return orig_run(self, wait)/path/.../to/cmdy/__init__.py&quot;, line 327, in run    ret = CmdyResult(self._run(), self)/path/.../to/cmdy/__init__.py&quot;, line 271, in _run    raise CmdyExecNotFoundError(str(fnfe)) from Nonecmdy.cmdy_util.CmdyExecNotFoundError: [Errno 2] No such file or directory: 'x': 'x'``````pythonfrom cmdy import lsls('non-existing-file')``````python consoleTraceback (most recent call last):  File &quot;&lt;ipython-input-17-132683fc2227&gt;&quot;, line 2, in &lt;module&gt;    ls('non-existing-file')/path/.../to/cmdy/__init__.py&quot;, line 146, in __call__    ready_cfgargs, ready_popenargs, _will())/path/.../to/cmdy/__init__.py&quot;, line 204, in __new__    return result.wait()/path/.../to/cmdy/__init__.py&quot;, line 407, in wait    raise CmdyReturnCodeError(self)cmdy.cmdy_util.CmdyReturnCodeError: Unexpected RETURN CODE 2, expecting: [0]  [   PID] 167164  [   CMD] ['ls non-existing-file']  [STDOUT]  [STDERR] ls: cannot access non-existing-file: No such file or directory```#### Don't raise exception but store the return code```pythonfrom cmdy import lsresult = ls('non-existing-file', _raise=False)result.rc # 2```#### Tolerance on return code```pythonfrom cmdy import ls# or _okcode=[0,2]ls('non-existing-file', _okcode='0,2').rc # 2```### Timeouts```pythonfrom cmdy import sleepsleep(3, _timeout=1)``````python consoleTraceback (most recent call last):  File &quot;&lt;ipython-input-20-47b0ec7af55f&gt;&quot;, line 2, in &lt;module&gt;    sleep(3, _timeout=1)/path/.../to/cmdy/__init__.py&quot;, line 146, in __call__    ready_cfgargs, ready_popenargs, _will())/path/.../to/cmdy/__init__.py&quot;, line 204, in __new__    return result.wait()/path/.../to/cmdy/__init__.py&quot;, line 404, in wait    ) from Nonecmdy.cmdy_util.CmdyTimeoutError: Timeout after 1 seconds.```### Redirections```pythonfrom cmdy import catcat('./pytest.ini').redirect &gt; '/tmp/pytest.ini'print(cat('/tmp/pytest.ini'))```#### Appending```python# r short for redirectcat('./pytest.ini').r &gt;&gt; '/tmp/pytest.ini'print(cat('/tmp/pytest.ini')) # content doubled```#### Redirecting to a file handler```pythonwith open('/tmp/pytest.ini', 'w') as f    cat('./pytest.ini').r &gt; fprint(cat('/tmp/pytest.ini'))```#### STDIN, STDOUT and/or STDERR redirections```pythonfrom cmdy import STDIN, STDOUT, STDERR, DEVNULLc = cat().r(STDIN) &lt; '/tmp/pytest.ini'print(c)``````python# Mixedc = cat().r(STDIN, STDOUT) ^ '/tmp/pytest.ini' &gt; DEVNULL# we can't fetch result from a redirected pipeprint(c.stdout)# Why not '&lt;' for STDIN?# Because the priority of the operator is not in sequential order.# We can use &lt; for STDIN, but we need to ensure it runs firstc = (cat().r(STDIN, STDOUT) &lt; '/tmp/pytest.ini') &gt; DEVNULLprint(c.stdout)# A simple rule for multiple redirections to always use &quot;&gt;&quot; in the last place``````python# Redirect stderr to stdoutfrom cmdy import bashc = bash(c=&quot;cat 1&gt;&amp;2&quot;).r(STDIN, STDERR) ^ '/tmp/pytest.ini' &gt; STDOUTprint(c.stdout)``````python# Redirect the worldc = bash(c=&quot;cat 1&gt;&amp;2&quot;).r(STDIN, STDOUT, STDERR) ^ '/tmp/pytest.ini' ^ DEVNULL &gt; STDOUTprint(c.stdout) # Noneprint(c.stderr) # None```### Pipings```pythonfrom cmdy import grepc = ls().p | grep('README')print(c)# README.md# README.rst``````python# p short for pipec = ls().p | grep('README').p | grep('md')print(c) # README.mdprint(c.piped_strcmds) # ['ls', 'grep README', 'grep md']``````pythonfrom cmdy import _CMDY_EVENT# !!! Pipings should be consumed immediately!# !!! DO NOT do thisls().pls() # &lt;- Will not run as expected# All commands will be locked as holding until pipings are consumed_CMDY_EVENT.clear()print(ls()) # runs# See Advanced/Holdings if you want to hold a piping command for a while```### Running command in foreground```pythonls().fg``````pythonfrom cmdy import tailtail('/tmp/pytest.ini', f=True, _timeout=3).fg# This mimics the `tail -f` program# You will see the content comes out one after another# and then program hangs for 3s```You can also write an `echo-like` program easily. See '[echo.py](./echo.py)'### Iterating on output```pythonfor line in ls().iter():    print(line, end='')```#### Iterating on stderr```pythonfor line in bash(c=&quot;cat /tmp/pytest.ini 1&gt;&amp;2&quot;).iter(STDERR):    print(line, end='')```#### Getting live output```python# Like we did for `tail -f` program# This time, we can do something with each output line# Let's use a thread to write content to a file# And we try to get the live contents using cmdyimport timefrom threading import Threaddef live_write(file, n):    with open(file, 'w', buffering=1) as f:        # Let's write something every half second        for i in range(n):            f.write(str(i) + '\n')            time.sleep(.5)test_file = '/tmp/tail-f.txt'Thread(target=live_write, args=(test_file, 10)).start()from cmdy import tailtail_iter = tail(f=True, _=test_file).iter()for line in tail_iter:    # Do whatever you want with the line    print('We got:', line, end='')    if line.strip() == '8':        break# make sure thread endstime.sleep(2)``````python# What about timeout?# Of course you can use a timer to check inside the loop# You can also set a timeout for each fetch# Terminate after 10 queriesThread(target=live_write, args=(test_file, 10)).start()from cmdy import tailtail_iter = tail(f=True, _=test_file).iter()for i in range(10):    print('We got:', tail_iter.next(timeout=1), end='')```### Advanced#### Baking the `cmdy` objectSometimes, you may want to run the same program a couple of times, with the same set of arguments or configurations, and you don't want to type those arguments every time, then you can bake the Cmdy object with that same arguments or configurations.For example, if you want to run ls as ls -l all the time:```pythonfrom cmdy import lsll = ls._(l=True)print(ll().h.cmd) # ['ls', '-l']print(ll(a=True).h.cmd) # ['ls', '-l', '-a']# I don't want the l flag for some commands occasionallyprint(ll(l=False).h.cmd) # ['ls']# Bake a baked commandlla = ll._(a=True)print(lla().h.cmd) # ['ls', '-l', '-a']``````python# I know git is always gonna run with subcommandgit = git._(_sub=True)# don't bother to pass _sub=True every timeprint(git(git_dir='.').branch(v=True).h)# &lt;CmdyHolding: ['git', '--git-dir', '.', 'branch', '-v']&gt;print(git().status().h)# &lt;CmdyHolding: ['git', 'status']&gt;``````python# What if I have a subcommand call bake?from cmdy import git, CmdyActionErrorprint(git.branch().h.cmd) # ['git', 'branch']print(type(git._())) # &lt;class 'cmdy.Cmdy'&gt;# run the git with _subprint(git(_sub=True).bake().h.cmd) # ['git', 'bake']```#### Baking the whole module```pythonimport cmdy# run version of the whole worldsh = cmdy(version=True)# anything under sh directly will be supposed to have subcommandfrom sh import git, gccprint(git().h)# &lt;CmdyHolding: ['git', '--version']&gt;print(gcc().h)# &lt;CmdyHolding: ['gcc', '--version']&gt;```Note that module baking is deep copying, except the exception classes and some utils. This means, you would expect following behavior:```pythonimport cmdyfrom cmdy import CmdyHolding, CmdyExecNotFoundErrorsh = cmdy()c = sh.echo().hprint(type(c)) # &lt;class 'cmdy.CmdyHolding'&gt;print(isinstance(c, CmdyHolding)) # Falseprint(isinstance(c, sh.CmdyHolding)) # Truetry:    sh.notexisting()except CmdyExecNotFoundError:    # we can catch it, as CmdyExecNotFoundError is sh.CmdyExecNotFoundError    print('Catched!')```#### Holding objectsYou may have noticed that we have a couple of examples above with a final call .h or .h(), which is holding the command from running.You can do that, too, if you have multiple operations```pythonprint(ls().h) # &lt;CmdyHolding: ['ls']&gt;# however, you cannot hold after some actionsls().r.h# CmdyActionError: Should be called in the first place: .h() or .hold()```Once a command is on hold (by .h, .hold, .h() or .hold())You have to explictly call run() to set the command running```pythonfrom time import timetic = time()c = sleep(2).hprint(f'Time elapsed: {time() - tic:.3f} s')# Time elapsed: 0.022 s# not running even with fgc.fgprint(f'Time elapsed: {time() - tic:.3f} s')# Time elapsed: 0.034 sc.run()print(f'Time elapsed: {time() - tic:.3f} s')# Time elapsed: 2.043 s```#### Reuse of command```python# After you set a command running,# you can retrieve the holding object,# and reuse itfrom cmdy import lsc = ls().fg# nothing will be producedc.holding.reset().r &gt; DEVNULL```#### Async mode```pythonimport curiofrom cmdy import lsa = ls().a # async command is never blocking!async def main():    async for line in a:        print(line, end='')curio.run(main())```#### Extending `cmdy`All those actions for holding/result objects were implemented internally as plugins. You can right your own plugins, too.A plugin has to be defined as a class and then instantiated.**There are 5 APIs for developing a plugin for `cmdy`**- `cmdy._plugin_factory.register`: A decorator for the plugin class- `cmdy._plugin_factory.hold_then`: A decorator to decorate methods in the plugin class, which define actions after a holding object. Arguments:  - `alias`: The alias of this action (e.g. `r/redir` for `redirect`)  - `final`: Whether this is a final action, meaning no other actions should be followed  - `prop`: Whether this action can be called as a property  - `hold_right`: Should I put right following action on hold? This is useful when we have connectors which then can set the command running. (e.g `&gt;` for redirect and `|` for pipe)- `cmdy._plugin_factory.run_then`: A decorator to decorate methods in the plugin class, which define actions after a sync result object. Arguments are similar as `cmdy._plugin_factory.hold_then` except that `prop` and `hold_right` are not avaialbe.- `async_run_then.add_method`: A decorator to decorate methods in the plugin class, which add methods to the `CmdyHolding`, `CmdyResult` or `CmdyAsyncResult` class. `cls` is the only argument that specifies which class we are hacking.- `async_run_then.add_property`: Property version of `cmdy_plugin_add_method`**Notes on name conflicts:**If we need to add the methods to multiple classes in the plugin with the same name, you can define a different name with extra underscore suffix(es).**Notes on module baking:**- Always use the baked module to get those classes    ```pytho    import cmdy    cmdy2 = cmdy()    @cmdy2._plugin_factory.register    class MyPlugin:        ...    ```- Plugin enable and disable only take effect within the same module. For example:    ```python    import cmdy    sh = cmdy()    # only affects cmdy not sh    sh._plugins.fg.disable()    # to disable this plugin for sh as well:    sh._plugins.fg.disable()    ``````python# An example to define a pluginimport cmdy@cmdy._plugin_factory.registerclass MyPlugin:    @cmdy._plugin_factory.add_method(cmdy.CmdyHolding)    def say_hello(self):        return 'Hello world!'    @cmdy._plugin_factory.hold_then('hello')    def helloworld(self):        print(self.say_hello())        # keep chaining        return selfmyplugin = MyPlugin()# command will never run,# because we didn't do self.run() in helloworld(self)ls().helloworld()  # prints Hello world!# property calls enabled by defaultls().helloworld  # prints Hello world!# we have aliasls().hello  # prints Hello world!```[1]: https://img.shields.io/pypi/v/cmdy?style=flat-square[2]: https://pypi.org/project/cmdy/[3]: https://img.shields.io/github/tag/pwwang/cmdy?style=flat-square[4]: https://github.com/pwwang/cmdy[5]: https://img.shields.io/travis/pwwang/cmdy?style=flat-square[6]: https://travis-ci.org/pwwang/cmdy[7]: https://img.shields.io/codacy/grade/fa12f06d39404f98b94c19e83865fd4e?style=flat-square[8]: https://app.codacy.com/project/pwwang/cmdy/dashboard[9]: https://img.shields.io/codacy/coverage/fa12f06d39404f98b94c19e83865fd4e?style=flat-square[10]: https://img.shields.io/pypi/pyversions/cmdy?style=flat-square</longdescription>
</pkgmetadata>