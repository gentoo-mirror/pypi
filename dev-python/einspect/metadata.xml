<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># einspect&lt;!-- start badges --&gt;[![Build](https://github.com/ionite34/einspect/actions/workflows/build.yml/badge.svg)](https://github.com/ionite34/einspect/actions/workflows/build.yml)[![codecov](https://codecov.io/gh/ionite34/einspect/branch/main/graph/badge.svg?token=v71SdG5Bo6)](https://codecov.io/gh/ionite34/einspect)[![security](https://snyk-widget.herokuapp.com/badge/pip/einspect/badge.svg)](https://security.snyk.io/package/pip/einspect)[![PyPI](https://img.shields.io/pypi/v/einspect)][pypi][![PyPI - Python Version](https://img.shields.io/pypi/pyversions/einspect)][pypi][pypi]: https://pypi.org/project/einspect/&lt;!-- end badges --&gt;&gt; Extended Inspections for CPython## [Documentation](https://docs.ionite.io/einspect)- [View and modify memory structures of live objects.](#check-detailed-states-of-built-in-objects)- [Able to mutate immutable objects like tuples and ints.](#mutate-tuples-strings-ints-or-other-immutable-types)- [Modify slot functions or attributes of built-in types.](#modify-attributes-of-built-in-types-get-original-attributes-with-orig)- [Fully typed, extensible framework in pure Python.](#move-objects-in-memory)&lt;!-- start intro --&gt;## Check detailed states of built-in objects```pythonfrom einspect import viewls = [1, 2, 3]v = view(ls)print(v.info())``````pythonPyListObject(at 0x2833738):   ob_refcnt: Py_ssize_t = 5   ob_type: *PyTypeObject = &amp;[list]   ob_item: **PyObject = &amp;[&amp;[1], &amp;[2], &amp;[3]]   allocated: Py_ssize_t = 4```[doc_tuple_view]: https://docs.ionite.io/einspect/api/views/view_tuple.html#einspect.views.view_tuple[doc_str_view]: https://docs.ionite.io/einspect/api/views/view_str.html#einspect.views.view_str[py_doc_mutable_seq]: https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types## Mutate tuples, strings, ints, or other immutable types&gt; [TupleView][doc_tuple_view] and [StrView][doc_str_view] supports all [MutableSequence][py_doc_mutable_seq] methods (append, extend, insert, pop, remove, reverse, clear).&gt; ⚠️ A note on [safety.](#safety)```pythonfrom einspect import viewtup = (1, 2)v = view(tup)v[1] = 500print(tup)      # (1, 500)v.append(3)print(tup)      # (1, 500, 3)del v[:2]print(tup)      # (3,)print(v.pop())  # 3v.extend([1, 2])print(tup)      # (1, 2)v.clear()print(tup)      # ()``````pythonfrom einspect import viewtext = &quot;hello&quot;v = view(text)v[1] = &quot;3&quot;v[4:] = &quot;o~&quot;v.append(&quot;!&quot;)print(text)  # h3llo~!v.reverse()print(text)  # !~oll3h``````pythonfrom einspect import viewn = 500view(n).value = 10print(500)        # 10print(500 == 10)  # True```## Modify attributes of built-in types, get original attributes with `orig````pythonfrom einspect import view, origv = view(int)v[&quot;__name__&quot;] = &quot;custom_int&quot;v[&quot;__iter__&quot;] = lambda s: iter(range(s))v[&quot;__repr__&quot;] = lambda s: &quot;custom: &quot; + orig(int).__repr__(s)print(int)for i in 3:    print(i)``````&lt;class 'custom_int'&gt;custom: 0custom: 1custom: 2```## Implement methods on built-in types&gt; See the [Extending Types](https://docs.ionite.io/einspect/extending_types.html) docs page for more information.```pythonfrom einspect import impl, orig@impl(int)def __add__(self, other):    other = int(other)    return orig(int).__add__(self, other)print(50 + &quot;25&quot;)  # 75```## Move objects in memory```pythonfrom einspect import views = &quot;meaning of life&quot;v = view(s)with v.unsafe():    v &lt;&lt;= 42print(&quot;meaning of life&quot;)        # 42print(&quot;meaning of life&quot; == 42)  # True```## CPython Struct bindings and API methods- Easily make calls to CPython stable ABI (`ctypes.pythonapi`) as bound methods on `PyObject` instances.```pythonfrom einspect.structs import PyDictObjectd = {&quot;a&quot;: (1, 2), &quot;b&quot;: (3, 4)}res = PyDictObject(d).GetItem(&quot;a&quot;)if res:    print(res.contents.NewRef())```&gt; Equivalent to the following with ctypes:```pythonfrom ctypes import pythonapi, py_object, c_void_p, castd = {&quot;a&quot;: (1, 2), &quot;b&quot;: (3, 4)}PyDict_GetItem = pythonapi[&quot;PyDict_GetItem&quot;]# Can't use auto cast py_object for restype,# since missing keys return NULL and causes segmentation fault with no set errorPyDict_GetItem.restype = c_void_pPyDict_GetItem.argtypes = [py_object, py_object]res = PyDict_GetItem(d, &quot;a&quot;)res = cast(res, py_object)Py_NewRef = pythonapi[&quot;Py_NewRef&quot;]Py_NewRef.restype = py_objectPy_NewRef.argtypes = [py_object]try:    print(Py_NewRef(res.value))except ValueError:    pass```- Create new instances of PyObject structs with field values, from existing objects, or from address.```pythonfrom einspect.structs import PyLongObject, PyTypeObjectx = PyLongObject(    ob_refcnt=1,    ob_type=PyTypeObject(int).as_ref(),    ob_size=1,    ob_item=[15],).into_object()print(x)        # 15print(x == 15)  # Trueprint(x is 15)  # False```&lt;!-- end intro --&gt;## Fully typed interface&lt;img width=&quot;551&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/13956642/211129165-38a1c405-9d54-413c-962e-6917f1f3c2a1.png&quot;&gt;## Safety This project is mainly for learning purposes or inspecting and debugging CPython internals for development and fun. You should not violate language conventions like mutability in production software and libraries.The interpreter makes assumptions regarding types that are immutable, and changing them causes all those usages to be affected. While the intent of the project is to make a memory-correct mutation without further side effects, there can be very significant runtime implications of mutating interned strings with lots of shared references, including interpreter crashes.For example, some strings like &quot;abc&quot; are interned and used by the interpreter. Changing them changes all usages of them, even attribute calls like `collections.abc`.&gt; The spirit of safety maintained by einspect is to do with memory layouts, not functional effects.### For example, appending to tuple views (without an unsafe context) will check that the resize can fit within allocated memory```pythonfrom einspect import viewtup = (1, 2)v = view(tup)v.append(3)print(tup)  # (1, 2, 3)v.append(4)# UnsafeError: insert required tuple to be resized beyond current memory allocation. Enter an unsafe context to allow this.```- Despite this, mutating shared references like empty tuples can cause issues in interpreter shutdown and other runtime operations.```pythonfrom einspect import viewtup = ()view(tup).append(1)``````Exception ignored in: &lt;module 'threading' from '/lib/python3.11/threading.py'&gt;Traceback (most recent call last):  File &quot;/lib/python3.11/threading.py&quot;, line 1563, in _shutdown    _main_thread._stop()  File &quot;/lib/python3.11/threading.py&quot;, line 1067, in _stop    with _shutdown_locks_lock:TypeError: 'str' object cannot be interpreted as an integer```### Similarly, memory moves are also checked for GC-header compatibility and allocation sizes```pythonfrom einspect import viewv = view(101)v &lt;&lt;= 2print(101)  # 2v &lt;&lt;= &quot;hello&quot;# UnsafeError: memory move of 54 bytes into allocated space of 32 bytes is out of bounds. Enter an unsafe context to allow this.```- However, this will not check the fact that small integers between (-5, 256) are interned and used by the interpreter. Changing them may cause issues in any library or interpreter Python code.```pythonfrom einspect import viewview(0) &lt;&lt; 100exit()# sys:1: ImportWarning: can't resolve package from __spec__ or __package__, falling back on __name__ and __path__# IndexError: string index out of range```## Table of Contents- [Views](#views)  - [Using the `einspect.view` constructor](#using-the-einspectview-constructor)  - [Inspecting struct attributes](#inspecting-struct-attributes)## Views### Using the `einspect.view` constructorThis is the recommended and simplest way to create a `View` onto an object. Equivalent to constructing a specific `View` subtype from `einspect.views`, except the choice of subtype is automatic based on object type.```pythonfrom einspect import viewprint(view(1))print(view(&quot;hello&quot;))print(view([1, 2]))print(view((1, 2)))```&gt; ```&gt; IntView(&lt;PyLongObject at 0x102058920&gt;)&gt; StrView(&lt;PyUnicodeObject at 0x100f12ab0&gt;)&gt; ListView(&lt;PyListObject at 0x10124f800&gt;)&gt; TupleView(&lt;PyTupleObject at 0x100f19a00&gt;)&gt; ```### Inspecting struct attributesAttributes of the underlying C Struct of objects can be accessed through the view's properties.```pythonfrom einspect import viewls = [1, 2]v = view(ls)# Inherited from PyObjectprint(v.ref_count)  # ob_refcntprint(v.type)       # ob_type# Inherited from PyVarObjectprint(v.size)       # ob_size# From PyListObjectprint(v.item)       # ob_itemprint(v.allocated)  # allocated```&gt; ```&gt; 4&gt; &lt;class 'tuple'&gt;&gt; 3&gt; &lt;einspect.structs.c_long_Array_3 object at 0x105038ed0&gt;&gt; ```## 2. Writing to view attributesWriting to these attributes will affect the underlying object of the view.Note that most memory-unsafe attribute modifications require entering an unsafe context manager with `View.unsafe()````pythonwith v.unsafe():    v.size -= 1print(obj)```&gt; `(1, 2)`Since `items` is an array of integer pointers to python objects, they can be replaced by `id()` addresses to modifyindex items in the tuple.```pythonfrom einspect import viewtup = (100, 200)with view(tup).unsafe() as v:    s = &quot;dog&quot;    v.item[0] = id(s)print(tup)```&gt; ```&gt; ('dog', 200)&gt;&gt; &gt;&gt; Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)&gt; ```So here we did set the item at index 0 with our new item, the string `&quot;dog&quot;`, but this also caused a segmentation fault.Note that the act of setting an item in containers like tuples and lists &quot;steals&quot; a reference to the object, evenif we only supplied the address pointer.To make this safe, we will have to manually increment a ref-count before the new item is assigned. To do this we caneither create a `view` of our new item, and increment its `ref_count += 1`, or use the apis from `einspect.api`, whichare pre-typed implementations of `ctypes.pythonapi` methods.```pythonfrom einspect import viewfrom einspect.api import Pytup = (100, 200)with view(tup).unsafe() as v:    a = &quot;bird&quot;    Py.IncRef(a)    v.item[0] = id(a)    b = &quot;kitten&quot;    Py.IncRef(b)    v.item[1] = id(b)print(tup)```&gt; `('bird', 'kitten')`🎉 No more seg-faults, and we just successfully set both items in an otherwise immutable tuple.To make the above routine easier, you can access an abstraction by simply indexing the view.```pythonfrom einspect import viewtup = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)v = view(tup)v[0] = 123v[1] = &quot;hm&quot;v[2] = &quot;🤔&quot;print(tup)```&gt; `(123, 'hm', '🤔')`</longdescription>
</pkgmetadata>