<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Taskiq + FastAPIThis repository has a code to integrate FastAPI with taskiq easily.Taskiq and FastAPI both have dependencies and this library makes it possible to depend on`fastapi.Request` or `starlette.requests.HTTPConnection` in taskiq tasks.With this library you can easily re-use your fastapi dependencies in taskiq functions.## How does it work?It adds startup functions to broker so it imports your fastapi applicationand creates a single worker-wide Request and HTTPConnection objects that you depend on.THIS REQUEST IS NOT RELATED TO THE ACTUAL REQUESTS IN FASTAPI!This request won't have actual data about the request you were handling while sending task.## UsageHere we have an example of function that is being used by both taskiq's task andfastapi's handler function.I have a script called `test_script.py` so my app can be found at `test_script:app`.We use strings to resolve application to bypass circular imports.Also, as you can see, we use `TaskiqDepends` for Request. That's becausetaskiq dependency resolver must know that this type must be injected. FastAPI disallowDepends for Request type. That's why we use `TaskiqDepends`.```pythonfrom fastapi import FastAPI, Requestfrom pydantic import BaseModelfrom redis.asyncio import ConnectionPool, Redisfrom fastapi import Depends as FastAPIDependsfrom taskiq import TaskiqDependsimport taskiq_fastapifrom taskiq import ZeroMQBrokerbroker = ZeroMQBroker()app = FastAPI()@app.on_event(&quot;startup&quot;)async def app_startup():    #####################    # IMPORTANT NOTE    #    #####################    # If you won't check that this is not    # a worker process, you'll    # create an infinite recursion. Because in worker processes    # fastapi startup will be called.    if not broker.is_worker_process:        print(&quot;Starting broker&quot;)        await broker.startup()    print(&quot;Creating redis pool&quot;)    app.state.redis_pool = ConnectionPool.from_url(&quot;redis://localhost&quot;)@app.on_event(&quot;shutdown&quot;)async def app_shutdown():    #####################    # IMPORTANT NOTE    #    #####################    # If you won't check that this is not    # a worker process, you'll    # create an infinite recursion. Because in worker processes    # fastapi startup will be called.    if not broker.is_worker_process:        print(&quot;Shutting down broker&quot;)        await broker.shutdown()    print(&quot;Stopping redis pool&quot;)    await app.state.redis_pool.disconnect()# Here we call our magic function.taskiq_fastapi.init(broker, &quot;test_script:app&quot;)# We use TaskiqDepends here, because if we use FastAPIDepends fastapi# initialization will fail.def get_redis_pool(request: Request = TaskiqDepends()) -&gt; ConnectionPool:    return request.app.state.redis_pool@broker.taskasync def my_redis_task(    key: str,    val: str,    # Here we depend using TaskiqDepends.    # Please use TaskiqDepends for all tasks to be resolved correctly.    # Or dependencies won't be injected.    pool: ConnectionPool = TaskiqDepends(get_redis_pool),):    async with Redis(connection_pool=pool) as redis:        await redis.set(key, val)        print(&quot;Value set.&quot;)class MyVal(BaseModel):    key: str    val: str@app.post(&quot;/val&quot;)async def setval_endpoint(val: MyVal) -&gt; None:    await my_redis_task.kiq(        key=val.key,        val=val.val,    )    print(&quot;Task sent&quot;)@app.get(&quot;/val&quot;)async def getval_endpoint(    key: str,    pool: ConnectionPool = FastAPIDepends(get_redis_pool),) -&gt; str:    async with Redis(connection_pool=pool, decode_responses=True) as redis:        return await redis.get(key)```## Manually update dependency contextWhen using `InMemoryBroker` it may be required to update the dependency context manually. This may also be useful when setting up tests.```pyimport taskiq_fastapifrom taskiq import InMemoryBrokerbroker = InMemoryBroker()app = FastAPI()taskiq_fastapi.init(broker, &quot;test_script:app&quot;)taskiq_fastapi.populate_dependency_context(broker, app)```</longdescription>
</pkgmetadata>