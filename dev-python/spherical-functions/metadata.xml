<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Test Status](https://github.com/moble/spherical_functions/workflows/tests/badge.svg)](https://github.com/moble/spherical_functions/actions)[![PyPI Version](https://img.shields.io/pypi/v/spherical-functions?color=)](https://pypi.org/project/spherical-functions/)[![Conda Version](https://img.shields.io/conda/vn/conda-forge/spherical_functions.svg?color=)](https://anaconda.org/conda-forge/spherical_functions)[![MIT License](https://img.shields.io/github/license/moble/spherical_functions.svg)](https://github.com/moble/spherical_functions/blob/main/LICENSE)[![DOI](https://zenodo.org/badge/25589782.svg)](https://zenodo.org/badge/latestdoi/25589782)# Spherical Functions| NOTE: This package will still be maintained, but *active* development has moved to the [`spherical`](https://github.com/moble/spherical) package.  While this package works well for ‚Ñì (aka ell, L, j, or J) values up to around 25, errors start to build rapidly and turn into NaNs around 30.  The `spherical` package can readily handle values up to at least 1000, with accuracy close to ‚Ñì times machine precision.  ‚ÄîMike || --- |Python/numba package for evaluating and transforming Wigner's ùîá matrices,Wigner's 3-j symbols, and spin-weighted (and scalar) spherical harmonics.These functions are evaluated directly in terms of quaternions, as well as inthe more standard forms of spherical coordinates and Eulerangles.&lt;sup&gt;[1](#1-euler-angles-are-awful)&lt;/sup&gt;The conventions for this package are described in detail on[this page](http://moble.github.io/spherical_functions/).## DependenciesThe only true requirements for this code are `python` and the python package`numpy`, as well as my accompanying[`quaternion`](https://github.com/moble/quaternion) package (installation ofwhich is shown below).However, this package can automatically use[`numba`](http://numba.pydata.org/), which uses [LLVM](http://llvm.org/) tocompile python code to machine code, accelerating most numerical functions byfactors of anywhere from 2 to 2000.  It is *possible* to run the code without`numba`, but the most important functions are roughly 10 times slower withoutit.The only drawback of `numba` is that it is nontrivial to install on its own.Fortunately, the best python installer,[`anaconda`](http://continuum.io/downloads), makes it trivial.  Just installthe main `anaconda` package.If you prefer the smaller download size of[`miniconda`](http://conda.pydata.org/miniconda.html) (which comes with noextras beyond python), you may also have to run this command:```shconda install pip numpy numba```## InstallationAssuming you use `conda` to manage your python installation (like any sanepython user), you can install this package simply as```shconda install -c conda-forge spherical_functions```This should automatically download and install the package[`quaternion`](https://github.com/moble/quaternion), on which this packagedepends.Alternatively, if you prefer to use `pip` (whether or not you use `conda`), youcan also do```shpython -m pip install spherical-functions```Finally, there's also the fully manual option of just downloading both coderepositories, changing to the code directory, and issuing```shpython -m pip install .```This should work regardless of the installation method, as long as you have acompiler hanging around.  However, this may be more likely to try to compilethe dependencies, including numpy and/or spinsfast, which can be much morecomplicated.## UsageFirst, we show a very simple example of usage with Euler angles, though itbreaks my heart to do so:&lt;sup&gt;[1](#euler-angles-are-awful)&lt;/sup&gt;```python&gt;&gt;&gt; import spherical_functions as sf&gt;&gt;&gt; alpha, beta, gamma = 0.1, 0.2, 0.3&gt;&gt;&gt; ell,mp,m = 3,2,1&gt;&gt;&gt; sf.Wigner_D_element(alpha, beta, gamma, ell, mp, m)```Of course, it's always better to use unit quaternions to describe rotations:```python&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import quaternion&gt;&gt;&gt; R = np.quaternion(1,2,3,4).normalized()&gt;&gt;&gt; ell,mp,m = 3,2,1&gt;&gt;&gt; sf.Wigner_D_element(R, ell, mp, m)```If you need to calculate values of the ùîá&lt;sup&gt;(‚Ñì)&lt;/sup&gt; matrix elements for manyvalues of (‚Ñì, m', m), it is more efficient to do so all at once.  The followingcalculates all modes for ‚Ñì from 2 to 8 (inclusive):```python&gt;&gt;&gt; indices = np.array([[ell,mp,m] for ell in range(2,9)... for mp in range(-ell, ell+1) for m in range(-ell, ell+1)])&gt;&gt;&gt; sf.Wigner_D_element(R, indices)```Finally, if you really need to put the pedal to the metal, and are willing toguarantee that the input arguments are correct, you can use a special hiddenform of the function:```python&gt;&gt;&gt; sf._Wigner_D_element(R.a, R.b, indices, elements)```Here, `R.a` and `R.b` are the two complex parts of the quaternion defined on[this page](http://moble.github.io/spherical_functions/) (though the user neednot care about that).  The `indices` variable is assumed to be atwo-dimensional array of integers, where the second dimension has size three,representing the (‚Ñì, m', m) indices.  This avoids certain somewhat slowerpure-python operations involving argument checking, reshaping, etc.  The`elements` variable must be a one-dimensional array of complex numbers (can beuninitialized), which will be replaced with the corresponding values on return.Again, however, there is no input dimension checking here, so if you give badinputs, behavior could range from silently wrong to exceptions to segmentationfaults.  Caveat emptor.## AcknowledgmentsI very much appreciate Barry Wardell's help in sorting out the relationshipsbetween my conventions and those of other people and software packages(especially Mathematica's crazy conventions).This code is, of course, hosted on github.  Because it is an open-sourceproject, the hosting is free, and all the wonderful features of github areavailable, including free wiki space and web page hosting, pull requests, anice interface to the git logs, etc.Finally, the code is automatically compiled, and the binaries hosted fordownload by `conda` on [anaconda.org](https://anaconda.org/moble/spherical_functions).This is also a free service for open-source projects like this one.The work of creating this code was supported in part by the Sherman FairchildFoundation and by NSF Grants No. PHY-1306125 and AST-1333129.&lt;br/&gt;---###### &lt;sup&gt;1&lt;/sup&gt; Euler angles are awfulEuler angles are pretty much[the worst things ever](http://moble.github.io/spherical_functions/#euler-angles)and it makes me feel bad even supporting them.  Quaternions arefaster, more accurate, basically free of singularities, moreintuitive, and generally easier to understand.  You can work entirelywithout Euler angles (I certainly do).  You absolutely never needthem.  But if you're so old fashioned that you really can't give themup, they are fully supported.</longdescription>
</pkgmetadata>