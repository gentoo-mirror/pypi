<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>py-tree-sitter==================This module provides Python bindings to the [tree-sitter](https://github.com/tree-sitter/tree-sitter) parsing library.## InstallationThis package currently only works with Python 3. There are no library dependencies, but you do need to have a C compiler installed.```shpip3 install tree_sitter```## AcknowledgmentsThis is a fork of [py-tree-sitter](https://github.com/tree-sitter/py-tree-sitter) by Max Brunsfeld with UTF-16 support added and distributed as CPython-compiled wheels.## Usage#### SetupFirst you'll need a Tree-sitter language implementation for each language that you want to parse. You can clone some of the [existing language repos](https://github.com/tree-sitter) or [create your own](http://tree-sitter.github.io/tree-sitter/creating-parsers):```shgit clone https://github.com/tree-sitter/tree-sitter-gogit clone https://github.com/tree-sitter/tree-sitter-javascriptgit clone https://github.com/tree-sitter/tree-sitter-python```Use the `Language.build_library` method to compile these into a library that's usable from Python. This function will return immediately if the library has already been compiled since the last time its source code was modified:```pythonfrom tree_sitter import Language, ParserLanguage.build_library(  # Store the library in the `build` directory  'build/my-languages.so',  # Include one or more languages  [    'vendor/tree-sitter-go',    'vendor/tree-sitter-javascript',    'vendor/tree-sitter-python'  ])```Load the languages into your app as `Language` objects:```pythonGO_LANGUAGE = Language('build/my-languages.so', 'go')JS_LANGUAGE = Language('build/my-languages.so', 'javascript')PY_LANGUAGE = Language('build/my-languages.so', 'python')```#### Basic ParsingCreate a `Parser` and configure it to use one of the languages:```pythonparser = Parser()parser.set_language(PY_LANGUAGE)```Parse some source code:```pythontree = parser.parse(bytes(&quot;&quot;&quot;def foo():    if bar:        baz()&quot;&quot;&quot;, &quot;utf8&quot;))```If you have your source code in some data structure other than a bytes object,you can pass a &quot;read&quot; callable to the parse function.The read callable can use either the byte offset or point tuple to read frombuffer and return source code as bytes object. An empty bytes object or Noneterminates parsing for that line. The default encoding is utf8.For example, to use the byte offset:```pythonsrc = bytes(&quot;&quot;&quot;def foo():    if bar:        baz()&quot;&quot;&quot;, &quot;utf8&quot;)def read_callable(byte_offset, point):    return src[byte_offset:byte_offset+1]tree = parser.parse(read_callable)```And to use the point:```pythonsrc_lines = [&quot;def foo():\n&quot;, &quot;    if bar:\n&quot;, &quot;        baz()&quot;]def read_callable(byte_offset, point):    row, column = point    if row &gt;= len(src_lines) or column &gt;= len(src_lines[row]):        return None    return src_lines[row][column:].encode('utf8')tree = parser.parse(read_callable)```Or with utf16 encoding:```pythontree = parser.parse(bytes(&quot;&quot;&quot;def foo():    if bar:        baz()&quot;&quot;&quot;, &quot;utf16&quot;), encoding=&quot;utf16&quot;)``````pythonsrc = bytes(&quot;&quot;&quot;def foo():    if bar:        baz()&quot;&quot;&quot;, &quot;utf16&quot;)def read_callable(byte_offset, point):    return src[byte_offset:byte_offset+2]tree = parser.parse(read_callable, encoding=&quot;utf16&quot;)``````pythonsrc_lines = [&quot;def foo():\n&quot;, &quot;    if bar:\n&quot;, &quot;        baz()&quot;]def read_callable(byte_offset, point):    row, column = point    if row &gt;= len(src_lines) or column &gt;= len(src_lines[row].encode(&quot;utf-16-le&quot;)):        return None    ret = src_lines[row].encode(&quot;utf-16-le&quot;)[column:]    return rettree = parser.parse(read_callable, encoding=&quot;utf16&quot;)```Inspect the resulting `Tree`:```pythonroot_node = tree.root_nodeassert root_node.type == 'module'assert root_node.start_point == (1, 0)assert root_node.end_point == (3, 13)function_node = root_node.children[0]assert function_node.type == 'function_definition'assert function_node.child_by_field_name('name').type == 'identifier'function_name_node = function_node.children[1]assert function_name_node.type == 'identifier'assert function_name_node.start_point == (1, 4)assert function_name_node.end_point == (1, 7)assert root_node.sexp() == &quot;(module &quot;    &quot;(function_definition &quot;        &quot;name: (identifier) &quot;        &quot;parameters: (parameters) &quot;        &quot;body: (block &quot;            &quot;(if_statement &quot;                &quot;condition: (identifier) &quot;                &quot;consequence: (block &quot;                    &quot;(expression_statement (call &quot;                        &quot;function: (identifier) &quot;                        &quot;arguments: (argument_list))))))))&quot;```#### Walking Syntax TreesIf you need to traverse a large number of nodes efficiently, you can usea `TreeCursor`:```pythoncursor = tree.walk()assert cursor.node.type == 'module'assert cursor.goto_first_child()assert cursor.node.type == 'function_definition'assert cursor.goto_first_child()assert cursor.node.type == 'def'# Returns `False` because the `def` node has no childrenassert not cursor.goto_first_child()assert cursor.goto_next_sibling()assert cursor.node.type == 'identifier'assert cursor.goto_next_sibling()assert cursor.node.type == 'parameters'assert cursor.goto_parent()assert cursor.node.type == 'function_definition'```#### EditingWhen a source file is edited, you can edit the syntax tree to keep it in sync with the source:```pythontree.edit(    start_byte=5,    old_end_byte=5,    new_end_byte=5 + 2,    start_point=(0, 5),    old_end_point=(0, 5),    new_end_point=(0, 5 + 2),)```Then, when you're ready to incorporate the changes into a new syntax tree,you can call `Parser.parse` again, but pass in the old tree:```pythonnew_tree = parser.parse(new_source, tree)```This will run much faster than if you were parsing from scratch.The `Tree.get_changed_ranges` method can be called on the *old* tree to returnthe list of ranges whose syntactic structure has been changed:```pythonfor changed_range in tree.get_changed_ranges(new_tree):    print('Changed range:')    print(f'  Start point {changed_range.start_point}')    print(f'  Start byte {changed_range.start_byte}')    print(f'  End point {changed_range.end_point}')    print(f'  End byte {changed_range.end_byte}')```#### Pattern-matchingYou can search for patterns in a syntax tree using a *tree query*:```pythonquery = PY_LANGUAGE.query(&quot;&quot;&quot;(function_definition  name: (identifier) @function.def)(call  function: (identifier) @function.call)&quot;&quot;&quot;)captures = query.captures(tree.root_node)assert len(captures) == 2assert captures[0][0] == function_name_nodeassert captures[0][1] == &quot;function.def&quot;```The `Query.captures()` method takes optional `start_point`, `end_point`,`start_byte` and `end_byte` keyword arguments which can be used to restrict thequery's range. Only one of the `..._byte` or `..._point` pairs need to be givento restrict the range. If all are omitted, the entire range of the passed nodeis used.</longdescription>
</pkgmetadata>