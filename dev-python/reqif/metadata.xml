<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># ReqIFReqIF is a Python library for working with ReqIF format.## Supported features- Parsing/unparsing ReqIF- Formatting (pretty-printing) ReqIF- Basic validation of ReqIF- Anonymizing ReqIF files to safely exchange the problematic ReqIF files.To be implemented:- Converting from/to Excel and other formats## Getting started```bashpip install reqif```## Using ReqIF as a library### Parsing ReqIF```pyfrom reqif.parser import ReqIFParserinput_file_path = &quot;input.reqif&quot;reqif_bundle = ReqIFParser.parse(input_file_path)for specification in reqif_bundle.core_content.req_if_content.specifications:    print(specification.long_name)    for current_hierarchy in reqif_bundle.iterate_specification_hierarchy(specification):        print(current_hierarchy)```or for ReqIFz files:```pyfrom reqif.parser import ReqIFZParserinput_file_path = &quot;input.reqifz&quot;reqifz_bundle = ReqIFZParser.parse(input_file_path)for reqif_bundle in reqifz_bundle.reqif_bundles:    for specification in reqif_bundle.core_content.req_if_content.specifications:        print(specification.long_name)for attachment in reqifz_bundle.attachments:    print(attachment)```### Unparsing ReqIF```pyfrom reqif.parser import ReqIFParserfrom reqif.unparser import ReqIFUnparserinput_file_path = &quot;input.sdoc&quot;output_file_path = &quot;output.sdoc&quot;reqif_bundle = ReqIFParser.parse(input_file_path)reqif_xml_output = ReqIFUnparser.unparse(reqif_bundle)with open(output_file_path, &quot;w&quot;, encoding=&quot;UTF-8&quot;) as output_file:    output_file.write(reqif_xml_output)```The contents of `reqif_xml_output` should be the same as the contents of the `input_file`.## Using ReqIF as a command-line tool### Passthrough commandBefore using the ReqIF library, it is useful to check if it fully understands aparticular ReqIF file format that a user has in hand. The `passthrough` commandfirst parses the ReqIF XML into in-memory Python objects and then unparsesthese Python objects back to an output ReqIF file.If everything goes fine, the output of the passthrough command should beidentical to the contents of the input file.`tests/integration/examples` contains samples of ReqIF files found on the internet. The integration tests ensure that for these samples, the passthroughcommand always produces outputs that are identical to inputs. ### Formatting ReqIFThe `format` command is similar to `clang-format` for C/C++ files or `cmake-format` for CMake files. The input file is parsed and then pretty-printedback to an output file.This command is useful when dealing with ReqIF files that are hand-written orReqIF files produced by the ReqIF tools that do not generate a well-formed XMLwith consistent indentation.  The `tests/integration/commands/format` contains typical examples ofincorrectly formatted ReqIF files. The integration tests ensure that the`format` command fixes these issues.### Anonymizing ReqIFThe anonymization helps when exchanging ReqIF documents between different ReqIFtools including this `reqif` library. If a particular file is not recognizedcorrectly by a tool, a user can send their anonymized file to a developer forfurther inspection.The anonymize command accepts an input `.reqif` file and produces an anonymizedversion of that file to the output `.reqif` file.```usage: reqif anonymize [-h] input_file output_filemain.py anonymize: error: the following arguments are required: input_file, output_file```Examples of anonymization:```xml...&lt;ATTRIBUTE-VALUE-STRING THE-VALUE=&quot;...Anonymized-2644691225...&quot;&gt;...&lt;ATTRIBUTE-VALUE-XHTML&gt;  &lt;DEFINITION&gt;    &lt;ATTRIBUTE-DEFINITION-XHTML-REF&gt;rmf-7d0ed062-e964-424c-8305-45067118d959&lt;/ATTRIBUTE-DEFINITION-XHTML-REF&gt;  &lt;/DEFINITION&gt;  &lt;THE-VALUE&gt;...Anonymized-141441514...&lt;/THE-VALUE&gt;...```The anonymization algorithm preserves the uniqueness of the anonymized stringsin the document. This way, if the requirement UID identifiers are anonymized,they will still be unique strings in an anonymized document.## Implementation detailsThe core of the library is a **ReqIF first-stage parser** that only transformsthe contents of a ReqIF XML file into a ReqIF in-memory representation. Thein-memory representation is a tree of Python objects that map directly to the objects of the ReqIF XML file structure (e.g, Spec Objects, Spec Types, DataTypes, Specifications, etc.).### Parsing: Converting from ReqIF to other formatsThe first-stage parser (implemented by the class `ReqIFParser`) can be used byuser's second-stage parser/converter scripts that convert the ReqIF in-memorystructure into a desired format such as Excel, HTML or other formats. Thetwo-stage process allows the first stage parsing to focus solely on creating anin-memory ReqIF object tree, while the second stage parsing can further parsethe ReqIF object tree according to the logical structure of user's documents asencoded in the ReqIF XML file that was produced by user's requirementsmanagement tool.### Unparsing: Converting from other formats to ReqIFThe reverse process is also possible. A user's script converts another format'scontents into a ReqIF in-memory representation. The ReqIF un-parser(implemented by the class `ReqIFUnparser`) can be used to render the in-memoryobjects to the ReqIF XML file.### ToleranceThe first-stage parser is made tolerant against possible issues in ReqIF.It should be possible to parse a ReqIF file even if it is missing importantinformation.A minimum ReqIF parsed by the `reqif`:```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;REQ-IF xmlns=&quot;http://www.omg.org/spec/ReqIF/20110401/reqif.xsd&quot; xmlns:configuration=&quot;http://eclipse.org/rmf/pror/toolextensions/1.0&quot;&gt;&lt;/REQ-IF&gt;```A separate validation command shall be used to confirm the validityof the ReqIF contents.### Printing of the attributesThe `reqif` library uses a simple convention for printing the XML attributes: theattributes are always printed in the alphabetic order of their attribute names.```xml&lt;DATATYPE-DEFINITION-REAL ACCURACY=&quot;10&quot; IDENTIFIER=&quot;ID_TC1000_DatatypeDefinitionReal&quot; LAST-CHANGE=&quot;2012-04-07T01:51:37.112+02:00&quot; LONG-NAME=&quot;TC1000 DatatypeDefinitionReal&quot; MAX=&quot;1234.5678&quot; MIN=&quot;-1234.5678&quot;/&gt;```Some tools do not respect this rule: for example some tools will printthe attribute `ACCURACY=&quot;10&quot;` after the `LONG-NAME` attribute but the `reqif`library does not provide support for preserving a non-alphabetic order of theattributes.### A bottom-up overview of the ReqIF format- ReqIF is a standard. See reference document [RD01](#rd01-reqif-standard).- ReqIF has a fixed structure (see &quot;What is common for all ReqIF documents&quot; below)- ReqIF standard does not define a document structure for every documents soa ReqIF tool implementor is free to choose between several implementation approaches. There is a[ReqIF Implementation Guide](#rd02-reqif-implementation-guide)that attempts to harmonize ReqIF tool developments. See also&quot;What is left open by the ReqIF standard&quot; below.- ReqIF files produced by various tool often have incomplete schemas. ### What is common for all ReqIF documents- All documents have ReqIF tags:  - Document metadata is stored inside tags of `REQ-IF-HEADER` tag.  - Requirements are stored as `&lt;SPEC-OBJECT&gt;`s  - Requirements types are stored as `&lt;SPEC-TYPE&gt;`s  - Supported data types are stored as `&lt;DATATYPE&gt;`  - Relationships such as 'Parent-Child' as stored as `&lt;SPEC-RELATIONS&gt;`### What is left open by the ReqIF standard - How to distinguish requirements from headers/sections?  - One way: create separate `SPEC-TYPES`: one or more for requirements and    one for sections.  - Another way: have one spec type but have it provide a `TYPE` field that can    be used to distinguish between `REQUIREMENT` or `SECTION`.  - Yet another way: Check if the &quot;ReqIF.ChapterName&quot; is present on the spec object.    When present, it is a section. When not, it is a requirement.## Reference documents### [RD01] ReqIF standardThe latest version is 1.2:[Requirements Interchange Format](https://www.omg.org/spec/ReqIF)### [RD02] ReqIF Implementation Guide [ReqIF Implementation Guide v1.8](https://www.prostep.org/fileadmin/downloads/prostep-ivip_ImplementationGuide_ReqIF_V1-8.pdf)</longdescription>
</pkgmetadata>