<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>===================================================sqlitedict -- persistent ``dict``, backed by SQLite===================================================|GithubActions|_|License|_.. |GithubActions| image:: https://github.com/RaRe-Technologies/sqlitedict/actions/workflows/python-package.yml/badge.svg.. |Downloads| image:: https://img.shields.io/pypi/dm/sqlitedict.svg.. |License| image:: https://img.shields.io/pypi/l/sqlitedict.svg.. _GithubActions: https://github.com/RaRe-Technologies/sqlitedict/actions/workflows/python-package.yml.. _Downloads: https://pypi.python.org/pypi/sqlitedict.. _License: https://pypi.python.org/pypi/sqlitedictA lightweight wrapper around Python's sqlite3 database with a simple, Pythonicdict-like interface and support for multi-thread access:Usage=====Write-----.. code-block:: python    &gt;&gt;&gt; from sqlitedict import SqliteDict    &gt;&gt;&gt; db = SqliteDict(&quot;example.sqlite&quot;)    &gt;&gt;&gt;    &gt;&gt;&gt; db[&quot;1&quot;] = {&quot;name&quot;: &quot;first item&quot;}    &gt;&gt;&gt; db[&quot;2&quot;] = {&quot;name&quot;: &quot;second item&quot;}    &gt;&gt;&gt; db[&quot;3&quot;] = {&quot;name&quot;: &quot;yet another item&quot;}    &gt;&gt;&gt;    &gt;&gt;&gt; # Commit to save the objects.    &gt;&gt;&gt; db.commit()    &gt;&gt;&gt;    &gt;&gt;&gt; db[&quot;4&quot;] = {&quot;name&quot;: &quot;yet another item&quot;}    &gt;&gt;&gt; # Oops, forgot to commit here, that object will never be saved.    &gt;&gt;&gt; # Always remember to commit, or enable autocommit with SqliteDict(&quot;example.sqlite&quot;, autocommit=True)    &gt;&gt;&gt; # Autocommit is off by default for performance.    &gt;&gt;&gt;    &gt;&gt;&gt; db.close()Read----.. code-block:: python    &gt;&gt;&gt; from sqlitedict import SqliteDict    &gt;&gt;&gt; db = SqliteDict(&quot;example.sqlite&quot;)    &gt;&gt;&gt;    &gt;&gt;&gt; print(&quot;There are %d items in the database&quot; % len(db))    There are 3 items in the database    &gt;&gt;&gt;    &gt;&gt;&gt; # Standard dict interface. items() values() keys() etc...    &gt;&gt;&gt; for key, item in db.items():    ...     print(&quot;%s=%s&quot; % (key, item))    1={'name': 'first item'}    2={'name': 'second item'}    3={'name': 'yet another item'}    &gt;&gt;&gt;    &gt;&gt;&gt; db.close()Efficiency----------By default, sqlitedict's exception handling favors verbosity over efficiency.It extracts and outputs the outer exception stack to the error logs.If you favor efficiency, then initialize the DB with outer_stack=False... code-block:: python    &gt;&gt;&gt; from sqlitedict import SqliteDict    &gt;&gt;&gt; db = SqliteDict(&quot;example.sqlite&quot;, outer_stack=False)  # True is the default    &gt;&gt;&gt; db[1]    {'name': 'first item'}Context Manager---------------.. code-block:: python    &gt;&gt;&gt; from sqlitedict import SqliteDict    &gt;&gt;&gt;    &gt;&gt;&gt; # The database is automatically closed when leaving the with section.    &gt;&gt;&gt; # Uncommitted objects are not saved on close. REMEMBER TO COMMIT!    &gt;&gt;&gt;    &gt;&gt;&gt; with SqliteDict(&quot;example.sqlite&quot;) as db:    ...     print(&quot;There are %d items in the database&quot; % len(db))    There are 3 items in the databaseTables------A database file can store multiple tables.A default table is used when no table name is specified.Note: Writes are serialized, having multiple tables does not improve performance... code-block:: python    &gt;&gt;&gt; from sqlitedict import SqliteDict    &gt;&gt;&gt;    &gt;&gt;&gt; products = SqliteDict(&quot;example.sqlite&quot;, tablename=&quot;product&quot;, autocommit=True)    &gt;&gt;&gt; manufacturers = SqliteDict(&quot;example.sqlite&quot;, tablename=&quot;manufacturer&quot;, autocommit=True)    &gt;&gt;&gt;    &gt;&gt;&gt; products[&quot;1&quot;] = {&quot;name&quot;: &quot;first item&quot;,  &quot;manufacturer_id&quot;: &quot;1&quot;}    &gt;&gt;&gt; products[&quot;2&quot;] = {&quot;name&quot;: &quot;second item&quot;, &quot;manufacturer_id&quot;: &quot;1&quot;}    &gt;&gt;&gt;    &gt;&gt;&gt; manufacturers[&quot;1&quot;] = {&quot;manufacturer_name&quot;: &quot;afactory&quot;, &quot;location&quot;: &quot;US&quot;}    &gt;&gt;&gt; manufacturers[&quot;2&quot;] = {&quot;manufacturer_name&quot;: &quot;anotherfactory&quot;, &quot;location&quot;: &quot;UK&quot;}    &gt;&gt;&gt;    &gt;&gt;&gt; tables = products.get_tablenames('example.sqlite')    &gt;&gt;&gt; print(tables)    ['unnamed', 'product', 'manufacturer']    &gt;&gt;&gt;    &gt;&gt;&gt; products.close()    &gt;&gt;&gt; manufacturers.close()In case you're wondering, the unnamed table comes from the previous examples,where we did not specify a table name.Serialization-------------Keys are strings. Values are any serializeable object.By default Pickle is used internally to (de)serialize the values.It's possible to use a custom (de)serializer, notably for JSON and for compression... code-block:: python    &gt;&gt;&gt; # Use JSON instead of pickle    &gt;&gt;&gt; import json    &gt;&gt;&gt; with SqliteDict(&quot;example.sqlite&quot;, encode=json.dumps, decode=json.loads) as mydict:    ...     pass    &gt;&gt;&gt;    &gt;&gt;&gt; # Apply zlib compression after pickling    &gt;&gt;&gt; import zlib, pickle, sqlite3    &gt;&gt;&gt;    &gt;&gt;&gt; def my_encode(obj):    ...     return sqlite3.Binary(zlib.compress(pickle.dumps(obj, pickle.HIGHEST_PROTOCOL)))    &gt;&gt;&gt;    &gt;&gt;&gt; def my_decode(obj):    ...     return pickle.loads(zlib.decompress(bytes(obj)))    &gt;&gt;&gt;    &gt;&gt;&gt; with SqliteDict(&quot;example.sqlite&quot;, encode=my_encode, decode=my_decode) as mydict:    ...     passIt's also possible to use a custom (de)serializer for keys to allow non-string keys... code-block:: python    &gt;&gt;&gt; # Use key encoding instead of default string keys only    &gt;&gt;&gt; from sqlitedict import encode_key, decode_key    &gt;&gt;&gt; with SqliteDict(&quot;example.sqlite&quot;, encode_key=encode_key, decode_key=decode_key) as mydict:    ...     passMore----Functions are well documented, see docstrings directly in ``sqlitedict.py`` or call ``help(sqlitedict)``.**Beware**: because of Python semantics, ``sqlitedict`` cannot know when a mutableSqliteDict-backed entry was modified in RAM. You'll need toexplicitly assign the mutated object back to SqliteDict:.. code-block:: python    &gt;&gt;&gt; from sqlitedict import SqliteDict    &gt;&gt;&gt; db = SqliteDict(&quot;example.sqlite&quot;)    &gt;&gt;&gt; db[&quot;colors&quot;] = {&quot;red&quot;: (255, 0, 0)}    &gt;&gt;&gt; db.commit()    &gt;&gt;&gt;    &gt;&gt;&gt; colors = db[&quot;colors&quot;]    &gt;&gt;&gt; colors[&quot;blue&quot;] = (0, 0, 255) # sqlite DB not updated here!    &gt;&gt;&gt; db[&quot;colors&quot;] = colors  # now updated    &gt;&gt;&gt;    &gt;&gt;&gt; db.commit() # remember to commit (or set autocommit)    &gt;&gt;&gt; db.close()Features========* Values can be **any picklable objects** (uses ``pickle`` with the highest protocol).* Support for **multiple tables** (=dicts) living in the same database file.* Support for **access from multiple threads** to the same connection (needed by e.g. Pyro).  Vanilla sqlite3 gives you ``ProgrammingError: SQLite objects created in a thread can  only be used in that same thread.``  Concurrent requests are still serialized internally, so this &quot;multithreaded support&quot;  **doesn't** give you any performance benefits. It is a work-around for sqlite limitations in Python.* Support for **custom serialization or compression**:.. code-block:: python  # use JSON instead of pickle  &gt;&gt;&gt; import json  &gt;&gt;&gt; mydict = SqliteDict('./my_db.sqlite', encode=json.dumps, decode=json.loads)  # apply zlib compression after pickling  &gt;&gt;&gt; import zlib, pickle, sqlite3  &gt;&gt;&gt; def my_encode(obj):  ...     return sqlite3.Binary(zlib.compress(pickle.dumps(obj, pickle.HIGHEST_PROTOCOL)))  &gt;&gt;&gt; def my_decode(obj):  ...     return pickle.loads(zlib.decompress(bytes(obj)))  &gt;&gt;&gt; mydict = SqliteDict('./my_db.sqlite', encode=my_encode, decode=my_decode)* sqlite is efficient and can work effectively with large databases (multi gigabytes), not limited by memory.* sqlitedict is mostly a thin wrapper around sqlite.* ``items()`` ``keys()`` ``values()`` are iterating one by one, the rows are loaded in a worker thread and queued in memory.* ``len()`` is calling sqlite to count rows, that is scanning the whole table.* For better performance, write objects in batch and ``commit()`` once.Installation============The module has no dependencies beyond Python itself.The minimum supported Python version is 3.7, continuously tested on Python 3.7, 3.8, 3.9, and 3.10 `on Travis &lt;https://travis-ci.org/RaRe-Technologies/sqlitedict&gt;`_.Install or upgrade with::    pip install -U sqlitedictor from the `source tar.gz &lt;http://pypi.python.org/pypi/sqlitedict&gt;`_::    python setup.py installContributions=============Testing-------Install::    $ pip install pytest coverage pytest-coverageTo perform all tests::    $ mkdir -p tests/db    $ pytest tests    $ python -m doctest README.rstTo perform all tests with coverage::    $ pytest tests --cov=sqlitedictComments, bug reports---------------------``sqlitedict`` resides on `github &lt;https://github.com/RaRe-Technologies/sqlitedict&gt;`_. You can fileissues or pull requests there.License=======``sqlitedict`` is open source software released under the `Apache 2.0 license &lt;http://opensource.org/licenses/apache2.0.php&gt;`_.Copyright (c) 2011-now `Radim Řehůřek &lt;http://radimrehurek.com&gt;`_ and contributors.Housekeeping============Clean up the test database to keep each doctest run idempotent:.. code-block:: python   &gt;&gt;&gt; import os   &gt;&gt;&gt; if __name__ == '__main__':   ...     os.unlink('example.sqlite')</longdescription>
</pkgmetadata>