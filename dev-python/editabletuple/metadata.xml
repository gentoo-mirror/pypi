<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># editabletuple- [Overview](#overview)- [Examples](#examples)- [API](#api)    - [Notes](#notes)## OverviewThis module provides the `editabletuple()` and `editableobject()` functions.The `editabletuple()` function is used tor creating classes with a fixedsequence of fields, similar to a namedtuple, except editable.Each instance of a class created by the `editabletuple()` function's fieldscan be accessed by index `et[i]` (or by slice), or by fieldname `et.name`.Although fields can be read and written, they cannot be added or deleted.Since instances are mutable they can't be used in sets or as dict keys.If you provide a validator, it will be used when new instances are createdand updated.The `editableobject()` function creates classes very similar to thosecreated by `editabletuple()`. The essential difference is that``editableobject()``'s class's instances don't support indexing oriteration, so support only fieldname access. They also have an addtional`totuple` property (not needed for ``editabletuple()``s since `tuple(et)` issufficient due to their iteration support).See the function docstrings for examples and more about the editabletupleand editableobject APIs.To install just use `python3 -m pip install editabletuple`. (See[PyPI](https://pypi.org/project/editabletuple/).)Or just copy the `editabletuple.py` file which is self-contained and dependsonly on the standard library.## Examples### Example #1: no defaults; no validator    &gt;&gt;&gt; Options = editabletuple('Options', 'maxcolors shape zoom restore')    &gt;&gt;&gt; options = Options(5, 'square', 0.9, True)    &gt;&gt;&gt; options    Options(maxcolors=5, shape='square', zoom=0.9, restore=True)    &gt;&gt;&gt; options.maxcolors = 7    &gt;&gt;&gt; options[-1] = False    &gt;&gt;&gt; options[2] -= 0.1    &gt;&gt;&gt; options    Options(maxcolors=7, shape='square', zoom=0.8, restore=False)### Example #2: with defaults but no validator    &gt;&gt;&gt; Rgb = editabletuple('Rgb', 'red green blue', defaults=(0, 0, 0))    &gt;&gt;&gt; black = Rgb()    &gt;&gt;&gt; black    Rgb(red=0, green=0, blue=0)    &gt;&gt;&gt; navy = Rgb(blue=128)    &gt;&gt;&gt; navy    Rgb(red=0, green=0, blue=128)    &gt;&gt;&gt; violet = Rgb(238, 130, 238)    &gt;&gt;&gt; violet    Rgb(red=238, green=130, blue=238)### Example #3: with defaults and a validatorIf you provide a validator function, it will be called whenever an attemptis made to set a value, whether at construction time or later by `et[i] =value` or `et.fieldname = value`. It is passed an attribute `name` and anattribute `value`. It should check the value and either return the value (oran acceptable alternative value) which will be the one actually set, orraise a `ValueError`.    &gt;&gt;&gt; def validate_rgba(name, value):    ...     if name == 'alpha':    ...         if not (0.0 &lt;= value &lt;= 1.0):    ...             return 1.0 # silently default to opaque    ...     elif not (0 &lt;= value &lt;= 255):    ...         raise ValueError(f'color value must be 0-255, got {value}')    ...     return value # must return a valid value or raise ValueError    &gt;&gt;&gt;    &gt;&gt;&gt; Rgba = editabletuple('Rgba', 'red', 'green', 'blue', 'alpha',    ...                      defaults=(0, 0, 0, 1.0), validator=validate_rgba)    &gt;&gt;&gt; black = Rgba()    &gt;&gt;&gt; black    Rgba(red=0, green=0, blue=0, alpha=1.0)    &gt;&gt;&gt; seminavy = Rgba(blue=128, alpha=0.5)    &gt;&gt;&gt; seminavy    Rgba(red=0, green=0, blue=128, alpha=0.5)    &gt;&gt;&gt; violet = Rgba(238, 130, 238, alpha=2.5) # alpha too big    &gt;&gt;&gt; violet    Rgba(red=238, green=130, blue=238, alpha=1.0)    &gt;&gt;&gt;    &gt;&gt;&gt; color = Rgba(green=99)    &gt;&gt;&gt; color    Rgba(red=0, green=99, blue=0, alpha=1.0)    &gt;&gt;&gt; assert color.green == 99    &gt;&gt;&gt; color.red = 128    &gt;&gt;&gt; assert color[2] == 0    &gt;&gt;&gt; color[2] = 240    &gt;&gt;&gt; assert color[2] == 240    &gt;&gt;&gt; color[-1] = 0.5    &gt;&gt;&gt; color    Rgba(red=128, green=99, blue=240, alpha=0.5)    &gt;&gt;&gt; color[1] = 299    Traceback (most recent call last):        ...    ValueError: color value must be 0-255, got 299    &gt;&gt;&gt; color.blue = -65    Traceback (most recent call last):        ...    ValueError: color value must be 0-255, got -65These examples—and several others—are in the module's function'sdocstrings.### API**`def editabletuple(classname, *fieldnames, defaults=None, validator=None,                    doc=None):`**Creates a new class called `classname` with the given `fieldnames`, optional``defaults``, optional ``validator``, and optional ``doc`` docstring.Instances of the class behave almost exactly like``collections.namedtuple``'s except that fields may be set as well as getusing their index position or fieldname. They support `len()`, `in`, thecomparison operators, and are iterable—which means they can be converted toa `list` or `tuple` by passing to either's eponymous factory function. Theyalso provide an `.asdict` property, and also an `update()` method thataccepts _`name=value`_ arguments.**`def editableobject(classname, *fieldnames, defaults=None, validator=None,                     doc=None):`**Creates a new class called `classname` with the given `fieldnames`, optional``defaults``, optional ``validator``, and optional ``doc`` docstring.Instances of the class have fields which can get and set by fieldname. Theysupport the comparison operators and `.astuple` and `.asdict` properties,the former returning a `tuple` of the instance's values, the latter a `dict`of fielname-value  items. It also has an `update()` method that accepts_`name=value`_ arguments.#### NotesI can't work out how to make `editabletuple` and `editableobject`_instances_ picklable. Patches or suggestions on how to do this would bewelcome.---**License: GPLv3**</longdescription>
</pkgmetadata>