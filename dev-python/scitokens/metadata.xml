<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>SciTokens Library=================|pypi| |downloads| |license|This library aims to be a reference implementation of the SciTokens'JSON Web Token (JWT) token format.SciTokens is built on top of the`PyJWT &lt;https://github.com/jpadilla/pyjwt&gt;`__ and`cryptography &lt;https://cryptography.io/en/latest/&gt;`__ libraries. We aimto provide a safe, high-level interface for token manipulation, avoidingcommon pitfalls of using the underling libraries directly.*NOTE*: SciTokens (the format and this library) is currently beingdesigned; this README describes how we would like it to work, notnecessarily current functionality. Particularly, we do not foresee thechained tokens described here as part of the first release'sfunctionality. The ideas behind the separate ``Validator`` in thislibrary is taken from`libmacaroons &lt;https://github.com/rescrv/libmacaroons&gt;`__.Generating Tokens-----------------Usage revolves around the ``SciToken`` object. This can be generateddirectly:::    &gt;&gt;&gt; import scitokens    &gt;&gt;&gt; token = scitokens.SciToken() # Create token and generate a new private key    &gt;&gt;&gt; token2 = scitokens.SciToken(key=private_key) # Create token using existing keywhere ``key`` is a private key object (more later on generating privatekeys). Direct generation using a private key will most often be done todo a *base token*. SciTokens can be chained, meaning one token can beappended to another:::    &gt;&gt;&gt; token = scitokens.SciToken(parent=parent_token)The generated object, ``token``, will default to having all theauthoriations of the parent token - but is mutable and can add furtherrestrictions.Tokens contain zero or more claims, which are facts about the token thattypically indicate some sort of authorization the bearer of the tokenhas. A token has a list of key-value pairs; each token can only have asingle value per key, but multiple values per key can occur in a tokenchain.To set a claim, one can use dictionary-like setter:::    &gt;&gt;&gt; token['claim1'] = 'value2'The value of each claim should be a Python object that can be serializedto JSON.Token Serialization-------------------Parent tokens are typically generated by a separate server and sent as aresponse to a successful authentication or authorization request.SciTokens are built on top of JSON Web Tokens (JWT), which define auseful base64-encoded serialization format. A serialized token may looksomething like this:::    eyJhbGciOiJFUzI1NiIsImN3ayI6eyJ5IjoiazRlM1FFeDVjdGJsWmNrVkhINlkzSFZoTzFadUxVVWNZQW5ON0xkREV3YyIsIngiOiI4TkU2ZEE2T1g4NHBybHZEaDZUX3kwcWJOYmc5a2xWc2pYQnJnSkw5aElBIiwiY3J2IjoiUC0yNTYiLCJrdHkiOiJFQyJ9LCJ0eXAiOiJKV1QiLCJ4NXUiOiJodHRwczovL3ZvLmV4YW1wbGUuY29tL0pXUyJ9.eyJyZWFkIjoiL2xpZ28ifQ.uXVzbcOBCK4S4W89HzlWNmnE9ZcpuRHKTrTXYv8LZL9cDy3Injf97xNPm756fKcYwBO5KykYngFrUSGa4owglA.eyJjcnYiOiAiUC0yNTYiLCAia3R5IjogIkVDIiwgImQiOiAieWVUTTdsVXk5bGJEX2hnLVVjaGp0aXZFWHZxSWxoelJQVEVaZDBaNFBpOCJ9This is actually 4 separate base64-encoded strings, separated by the``.`` character. The four pieces are:-  A *header*, implementing the JSON Web Key standard, specifying the   cryptographic properties of the token.-  A *payload*, specifying the claims (key-value pairs) encoded by the   token and asserted by the VO.-  A *signature* of the header and payload, ensuring authenticity of the   payload.-  A *key*, utilized to sign any derived tokens. The key is an optional   part of the token format, but may be required by some remote   services.Given a serialized token, the ``scitokens`` library can deserialize it:::    &gt;&gt;&gt; token = scitokens.SciToken.deserialize(token_serialized_bytes)As part of the deserialization, the ``scitokens`` library will throw anexception if token verification failed.The existing token can be serialized with the ``serialize`` method:::    &gt;&gt;&gt; token_serialized_bytes = token.serialize()Validating Tokens-----------------In SciTokens, we try to distinguish between *validating* and *verifying*tokens. Here, verification refers to determining the integrity andauthenticity of the token: can we validate the token came from a knownsource without tampering? Can we validate the chain of trust? Validationis determining whether the claims of the token are satisfied in a givencontext.For example, if a token contains the claims``{vo: ligo, op: read, path: /ligo}``, we would first verify that thetoken is correctly signed by a known public key associated with LIGO.When presented to a storage system along with an HTTP request, thestorage system would validate the token authorizes the correspondingrequest (is it a GET request? Is it for a sub-path of /ligo?).Within the ``scitokens`` module, validation is done by the ``Validator``object:::    &gt;&gt;&gt; val = scitokens.Validator()This object can be reused for multiple validations. All SciToken claimsmust be validated. There are no &quot;optional&quot; claim attributes or values.To validate a specific claim, provide a callback function to the``Validator`` object:::    &gt;&gt;&gt; def validate_op(value):    ...     return value == True    &gt;&gt;&gt; val.add_validator(&quot;op&quot;, validate_op)Once all the known validator callbacks have been registered, use the``validate`` method with a token:::    &gt;&gt;&gt; val.validate(token)This will throw a ``ValidationException`` if the token could not bevalidated.Enforcing SciTokens Logic-------------------------For most users of SciTokens, determining that a token is valid is insufficient.Rather, most will be asking &quot;does this token allow the current resourcerequest?&quot;  The valid token must be compared to some action the user isattempting to take.To assist in the authorization enforcement, the SciTokens library providesthe ``Enforcer`` class.An unique Enforcer object is needed for each thread and issuer:::    &gt;&gt;&gt; enf = scitokens.Enforcer(&quot;https://scitokens.org/dteam&quot;)This object will accept tokens targetted to any audience; a more typicaluse case will look like the following:::    &gt;&gt;&gt; enf = scitokens.Enforcer(&quot;https://scitokens.org/dteam&quot;,                                 audience=&quot;https://example.com&quot;)This second enforcer would not accept tokens that are intended forhttps://google.com.The enforcer can then test authorization logic against a valid token:::    &gt;&gt;&gt; token = &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtp...&quot;    &gt;&gt;&gt; stoken = scitokens.SciToken.deserialize(token)    &gt;&gt;&gt; enf.generate_acls(stoken)    [(u'write', u'/store/user/bbockelm'), (u'read', u'/store')]    &gt;&gt;&gt; enf.test(stoken, &quot;read&quot;, &quot;/store/foo&quot;)    True    &gt;&gt;&gt; enf.test(stoken, &quot;write&quot;, &quot;/store/foo&quot;)    False    &gt;&gt;&gt; enf.test(stoken, &quot;write&quot;, &quot;/store/user/foo&quot;)    False    &gt;&gt;&gt; enf.test(stoken, &quot;write&quot;, &quot;/store/user/bbockelm/foo&quot;)    TrueThe ``test`` method uses the SciTokens built-in path parsing to validate theauthorization.  The ``generate_acls`` method allows the caller to cachethe ACL information from the token.Configuration-------------An optional configuration file can be provided that will alter the behavior of the SciTokens library.  Configuration options include:================== ========================================================================================Key                Description================== ========================================================================================log_level          The log level for which to use.  Options include: CRITICAL, ERROR, WARNING, INFO, DEBUG.                   Default: WARNINGlog_file           The full path to the file to log.                   Default: Nonecache_lifetime     The minimum lifetime (in seconds) of keys in the keycache.                   Default: 3600 secondscache_location     The directory to store the KeyCache, used to store public keys across executions.                   Default: $HOME/.cache/scitokens================== ========================================================================================The configuration file is in the ini format, and will look similar to:::    [scitokens]    log_level = DEBUG    cache_lifetime = 60You may set the configuration by passing a file name to ``scitokens.set_config`` function:::        &gt;&gt; import scitokens    &gt;&gt; scitokens.set_config(&quot;/etc/scitokens/scitokens.ini&quot;)    Project Status==============|pypi| |build| |coverage| |quality| |docs|.. |pypi| image:: https://badge.fury.io/py/scitokens.svg   :target: https://pypi.org/project/scitokens/.. |downloads| image:: https://img.shields.io/pypi/dd/scitokens   :target: https://pypi.org/project/scitokens   :alt: Downloads per month.. |license| image:: https://img.shields.io/github/license/scitokens/scitokens   :target: https://choosealicense.com/licenses/apache-2.0/   :alt: License information.. |build| image:: https://img.shields.io/github/workflow/status/scitokens/scitokens/Python%20package   :target: https://github.com/scitokens/scitokens/actions/workflows/python-package.yml   :alt: Build pipeline status.. |coverage| image:: https://app.codacy.com/project/badge/Coverage/753108a9f8ab450d8f5598e1b639ecfd        :target: https://www.codacy.com/gh/scitokens/scitokens/dashboard?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=scitokens/scitokens&amp;amp;utm_campaign=Badge_Coverage    :alt: Code coverage.. |quality| image:: https://app.codacy.com/project/badge/Grade/753108a9f8ab450d8f5598e1b639ecfd        :target: https://www.codacy.com/gh/scitokens/scitokens/dashboard?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=scitokens/scitokens&amp;amp;utm_campaign=Badge_Grade    :alt: Code Quality.. |docs| image:: https://readthedocs.org/projects/scitokens/badge/?version=latest    :target: https://scitokens.readthedocs.io/en/latest/?badge=latest    :alt: Documentation Status</longdescription>
</pkgmetadata>