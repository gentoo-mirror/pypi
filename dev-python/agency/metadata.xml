<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># `agency`A fast and minimal actor model framework for building agent-integrated systems## What is `agency`?`agency` defines a common communication and action framework for integratingAI agents with traditional computing systems, and even humans in a way whereall can easily communicate.`agency` allows you to create shared environments called &quot;spaces&quot; where anynumber of humans, artificial, or other computing systems may equally addresseach other as individual &quot;agents&quot; that you may perform &quot;actions&quot; on.`agency` handles the details of the common messaging protocol and allowsdiscovering and invoking actions across all parties, automatically handlingthings such as reporting exceptions, enforcing access restrictions, and more.The API accommodates agent integration with systems as varied as:- UI driven applications- terminal environments- software APIs- other AI agents- people- ...- anything# Install&gt; **WARNING:**\&gt; Running `agency` may result in exposing your computer to access by any connected `Agent` class. Please understand the risks before using this software and configure your environment safely.&gt;&gt; If, for example, you want to enable OS access, I HIGHLY RECOMMEND running your project within a Docker container to prevent direct access to your host, allowing you to limit the resources and directories that may be accessed.&gt;&gt; If you need it, an example Dockerfile can be found in the [examples/demo](./examples/demo) directory.```shpip install agency```# API Overview`agency` is an implementation of the [Actormodel](https://en.wikipedia.org/wiki/Actor_model) intended for integrating AI,human, and traditional computing systems.In `agency`, all entities are called &quot;agents&quot; and represented as instancesof the `Agent` class. This includes all humans, software, and AI-driven agents.The `Agent` class is a base class similar to &quot;Object&quot; in many object-orientedlanguages. All agents may expose &quot;actions&quot; that other agents can discover andinvoke at run time. Actions also specify an access policy, allowing you tomonitor and control actions to ensure safety.A `Space` is also an `Agent` and is used to group multiple agents together. Aspace can be thought of as both a collection of agents and a facilitator fortheir communication. An agent cannot communicate with others until it is firstadded to a space. Spaces may be nested, allowing for namespacing andhierarchical organization of the agents in your application.To summarize, the two classes of `Agent` and `Space` together create a simpleAPI for creating applications that may mix AI, human, and traditional computingsystems, in a way that is intended for all to equally understand and use.Let's walk through a thorough example to see how this works in practice.# Example WalkthroughThe snippet below is an example application taken from the demo located at[./examples/demo/](./examples/demo/). A Dockerfile and basic instructions forhow to run the demo are located in that directory.The demo includes two OpenAI agent classes, the HuggingFace based `ChattyAI`,operating system access, and a web application hosted at`http://localhost:8080`. Note that `Space.run()` starts a thread, so we simplykeep the application alive with a while loop.The walkthrough that follows details how this demo application works.```python# demo.pyif __name__ == '__main__':    space = Space(&quot;DemoSpace&quot;)    space.add(        ChattyAI(&quot;Chatty&quot;,            model=&quot;EleutherAI/gpt-neo-125m&quot;))    space.add(        WebApp(&quot;WebApp&quot;,            demo_user_id=&quot;Dan&quot;, # hardcoded for simplicity            port='8080'))    space.add(        Host(&quot;Host&quot;))    space.add(        OpenAIFunctionAgent(&quot;FunctionAI&quot;,            model=&quot;gpt-3.5-turbo-16k&quot;,            openai_api_key=os.getenv(&quot;OPENAI_API_KEY&quot;),            # user_id determines the &quot;user&quot; role in the OpenAI chat            user_id=&quot;Dan.WebApp.DemoSpace&quot;))    space.add(        OpenAICompletionAgent(&quot;CompletionAI&quot;,            model=&quot;text-davinci-003&quot;,            openai_api_key=os.getenv(&quot;OPENAI_API_KEY&quot;)))    space.run()    print(&quot;pop!&quot;)    # keep alive    while True:        time.sleep(1)```## Creating a `Space`Now let's see how this is implemented. Let's start by instantiating the demospace.```pythonspace = Space(&quot;DemoSpace&quot;)````Space`'s, like all `Agent`'s, must be given an `id`. So the line aboveinstantiates a single space called `&quot;DemoSpace&quot;` that we can now add agents to.## Adding an `Agent` to a `Space`Now, let's add our first agent to the space, a simple transformers librarybacked chatbot class named `ChattyAI`. You can browse the source code for`ChattyAI` [here](./agency/agents/chattyai.py).```pythonspace.add(ChattyAI(&quot;Chatty&quot;, model=&quot;EleutherAI/gpt-neo-125m&quot;))```The line above adds a new `ChattyAI` instance to the space, with the `id` of`&quot;Chatty&quot;`. It also passes the `model` argument to the constructor, which isused to initialize the HuggingFace transformers language model.At this point &quot;Chatty&quot; has a fully qualified `id` of `&quot;Chatty.DemoSpace&quot;`.  Thisis because `&quot;Chatty&quot;` is a member of the `&quot;DemoSpace&quot;` space.This way, spaces establish a namespace for their member agents which can laterbe used to address them.## Defining ActionsLooking at `ChattyAI`'s source code, you'll see that it is a subclass of`Agent`, and that it exposes a single action called `say`.The `say` action is defined as a method on the `ChattyAI` class, using thefollowing signature:```pythondef _action__say(self, content: str):    &quot;&quot;&quot;Use this action to say something to Chatty&quot;&quot;&quot;    ...```The prefix `_action__` is used to indicate that this is an action that can beinvoked by other agents. The suffix `say` is the name of the action.The `say` action takes a single string argument `content`. This action isintended to allow other agents to chat with Chatty, as expressed in itsdocstring.When `ChattyAI` receives a `say` action, it will generate a response using itsprompt format with the language model, and return the result to the sender.## Invoking ActionsAt the end of the `ChattyAI._action__say()` method, we see an example of using`agency`'s messaging protocol. `ChattyAI` returns a response to the senderby calling:```python...self._send({    &quot;to&quot;: self._current_message['from'],    &quot;thoughts&quot;: &quot;&quot;,    &quot;action&quot;: &quot;say&quot;,    &quot;args&quot;: {      &quot;content&quot;: response_content,    }})```This is a simple implementation that demonstrates the basic idea of how toinvoke an action on another agent.When an agent receives a message, it invokes the action method specified by the`&quot;action&quot;` field of the message, passing the `&quot;args&quot;` to the action method askeyword arguments.So here we see that Chatty is invoking the `say` action on the sender of theoriginal message, passing the response as the `&quot;content&quot;` argument.## The Common Message SchemaIn the example above, we see the format that is used when sending actions.In describing the messaging format, there are two terms that are used similarly:&quot;action&quot; and &quot;message&quot;.An &quot;action&quot; is the format you use when sending, as seen in the `_send()` callabove. You do not specify the `&quot;from&quot;` field, as it will be automatically addedwhen routing.A &quot;message&quot; then, is a &quot;received action&quot; which includes the additional`&quot;from&quot;` field containing the sender's fully qualified `id`.Continuing the example above, the original sender would receive a responsemessage from Chatty that would look something like:```python{    &quot;from&quot;: &quot;Chatty.DemoSpace&quot;,    &quot;to&quot;: &quot;Sender.DemoSpace&quot;,    &quot;thoughts&quot;: &quot;&quot;,    &quot;action&quot;: &quot;say&quot;,    &quot;args&quot;: {      &quot;content&quot;: &quot;Whatever Chatty said&quot;,    }}```This is an example of the full message schema that is used for all messages sentbetween agents in `agency`. This format is intended to be simple and extensibleenough to support any use case while remaining human readable.Note that the `&quot;thoughts&quot;` field is defined as a distinct argument for providinga natural language explanation to accompany any action, but as of this writing`ChattyAI` does not make use of it. `OpenAICompletionAgent` discussed below,does.## Access ControlAll actions must declare an access policy like the following example seen abovethe `ChattyAI._action__say()` method:```python@access_policy(ACCESS_PERMITTED)def _action__say(self, content: str):    &quot;&quot;&quot;Use this action to say something to Chatty&quot;&quot;&quot;    ...```Access policies are used to control what actions can be invoked by other agents.An access policy can currently be one of three values:- `ACCESS_PERMITTED` - which permits any agent to use that action atany time- `ACCESS_DENIED` - which prevents use- `ACCESS_REQUESTED` - which will prompt the receiving agent for permissionwhen access is attempted. Access will await approval or denial. If denied, thesender is notified of the denial.If `ACCESS_REQUESTED` is used, the receiving agent will be prompted at runtime to approve the action.If any actions require permission, you must implement the`_request_permission()` method with the following signature:```pythondef _request_permission(self, proposed_message: MessageSchema) -&gt; bool:    ...```This method is called when an agent attempts to invoke an action that has beenmarked as `ACCESS_REQUESTED`. Your method should inspect `proposed_message` andreturn a boolean indicating whether or not to permit the action.You can use this approach to protect against dangerous actions being taken. Forexample if you allow terminal access, you may want to review commands beforethey are invoked.This implementation of access control is just a start, and further developmentof the functionality is a priority for this project.## Adding Human Users With the `WebApp` ClassA single chatting AI wouldn't be useful without someone to chat with, so nowlet's add humans into the space so that they can chat with &quot;Chatty&quot;. To dothis, we'll use the `WebApp` class, which is a subclass of `Space`.Why choose to subclass `Space` and not `Agent`? This is an arbitrary choice upto the developer, and may depend on what they want to accomplish.We could implement `WebApp` as a subclass of `Agent`. This would represent theweb application as a single agent within the system. Users of the webapplication would not be able to be addressed individually by other agents.But since a typical web application serves multiple users, it may make sense toimplement it as a `Space` subclass, so that individual users of the webapplication can be addressed by other agents using a namespace associated withthe web application, as we'll see below.So this is _not_ the only way this could be accomplished but is intended as acomplex example to showcase why one might want to define a `Space` subclass togroup agents when it makes sense.### Examining the `WebApp` ClassThe implementation located [here](./agency/spaces/web_app.py) defines a simple`Flask` based web application that hosts a single page `React` based chat UI.The implementation takes some shortcuts, but in it you'll see that we actuallydefine two classes, one for the web application which extends `Space`, called`WebApp`, and a second class to represent users of the web app which extends`Agent` and is called `WebAppUser`.The `WebAppUser` class is where we define the actions that an individual web appuser may expose to others.Using the `asyncio` library you'll see that we simply forward messages as-is tothe `React` frontend, and allow the client code to handle rendering and parsingof input as actions back to the `Flask` application, which forwards them totheir intended receiver in the space.## Namespacing and Adding the Web ApplicationNow that we've defined our new `WebApp` class, we can add it to `DemoSpace`with:```pythonspace.add(    WebApp(&quot;WebApp&quot;, port='8080'))```Whenever any agent is added to a space, its fully qualified `id` becomesnamespaced with the space's `id`.For example, after running the line above the `WebApp` being an agent as well,receives an `id` of `&quot;WebApp.DemoSpace&quot;`.At this point, we have integrated the following agents listed using their fullyqualified `id`'s:- `&quot;DemoSpace&quot;` - The root space- `&quot;ChattyAI.DemoSpace&quot;` - ChattyAI's fully qualified `id`- `&quot;WebApp.DemoSpace&quot;` - the root of the `&quot;WebApp&quot;` spaceUsers of the web application, as they log in or out, may be added dynamicallyunder the `&quot;WebApp&quot;` namespace allowing them to be addressed with a fullyqualified `id` of, for example:- `&quot;Dan.WebApp.DemoSpace&quot;`.This way, we allow individual web users to appear as individual agents to othersin the space._(Note that login/out functionality is not implemented as of this writing.)_## Adding OS Access with the `Host` classAt this point, we have a system where human users of the web application canchat with `ChattyAI`, using just a single action called `&quot;say&quot;` that both`Agent` classes implement.Now we'll add an agent that exposes many different actions, the[`Host`](./agency/agents/host.py) class.```pythonspace.add(Host(&quot;Host&quot;))```The `Host` class allows access to the host operating system where the pythonapplication is running. It exposes actions such as `read_file` and`shell_command` which allow other agents to interact with the host.This class is a good example of one with potentially dangerous actions that mustbe accessed with care. You'll notice that all the methods in the `Host` classhave been given the access policy:```python@access_policy(ACCESS_REQUESTED)```By declaring this access policy, all actions on the host will require aconfirmation from the terminal where the application is being run. This isthanks to the implementation of `_request_permission()` in the `Host` class.Note that this implementation of `_request_permission()` is just onepossibility. We could have implemented, for example, a phone notification for ahuman to review from elsewhere.## Discovering ActionsAt this point, we can demonstrate how discovery works from the perspective ofa human user of the web application.Once added to a space, each agent may send a `help` message to discover otheragents and actions that are available in the space.The `WebApp` application hosts a simple chat UI that supports a &quot;slash&quot; syntaxsummarized here:```python/actionname arg1:val1 arg2:val2 ...```So a person using the chat UI can discover available actions by typing:```/help```This will broadcast a `help` action to all other agents, who will individuallyrespond with a list of their available actions. The returned list of actionswould look something like:```python[    {        &quot;to&quot;: &quot;Host.DemoSpace&quot;,        &quot;action&quot;: &quot;delete_file&quot;,        &quot;thoughts&quot;: &quot;Delete a file&quot;,        &quot;args&quot;: {          &quot;filepath&quot;: &quot;str&quot;        }    },    {        &quot;to&quot;: &quot;Host.DemoSpace&quot;,        &quot;action&quot;: &quot;list_files&quot;,        &quot;thoughts&quot;: &quot;List files in a directory&quot;,        &quot;args&quot;: {          &quot;directory_path&quot;: &quot;str&quot;        }    },    ...]```Notice that each action lists the fully qualified `id` of the agent in the`&quot;to&quot;` field, the docstring of the action's method in the `&quot;thoughts&quot;` field,and each argument along with its type in the `&quot;args&quot;` field.So a person using the web app UI can invoke the `list_files` action on`&quot;Host.DemoSpace&quot;` with the following syntax:```/list_files to:Host.DemoSpace directory_path:/app```This will send the `list_files` action to the `Host` agent who will (after beinggranted permission) return the results back to `&quot;Dan.WebApp.DemoSpace&quot;`rendering it to the web user interface as a message.## Broadcast vs Point-to-Point MessagingNote the use of the fully qualified `id` of `Host.DemoSpace` used with the `to:`field.If we omit the `to:Host.DemoSpace` portion of the command above, the messagewill be broadcast, and any agents who implement a `list_files` action willrespond.This is also how the `/help` command works. If you want to request help fromjust a single agent you can use something like:```/help to:Host.DemoSpace```Note that point-to-point messages (messages that define the `&quot;to&quot;` field) willresult in an error if the action is not defined on the target agent.Broadcast messages will _not_ return an error, but will silently be ignored byagents who do not implement the given action.## Adding an Environment-Aware AgentFinally we get to the good part!We'll now add an intelligent agent into this environment and see that it is ableto understand and interact with any of the systems or humans we've connectedthus far.&gt; Note that the following `OpenAIFunctionAgent` class uses the newly released[openai function callingAPI](https://platform.openai.com/docs/guides/gpt/function-calling).To add the [`OpenAIFunctionAgent`](./agency/agents/demo_agent.py) class to theenvironment:```pythonspace.add(    OpenAIFunctionAgent(&quot;FunctionAI&quot;,        model=&quot;gpt-3.5-turbo-16k&quot;,        openai_api_key=os.getenv(&quot;OPENAI_API_KEY&quot;),        # user_id determines the &quot;user&quot; role in the chat API        user_id=&quot;Dan.WebApp.DemoSpace&quot;))```The `user_id` argument determines which agent is represented as the &quot;user&quot; roleto the chat API. Since the chat API is limited to a predefined set of roles, weneed to indicate which is the main &quot;user&quot;.For an implementation that uses a plain text completion API, see[`OpenAICompletionAgent`](./agency/agents/openai_completion_agent.py).## Running the ExampleIf you run the python script provided at the beginning of this walkthrough,after a short boot time you can visit the web app at `http://localhost:8080` andyou should see a simple chat interface.The following is a screenshot of a conversation that showcases all the agentsintelligently interacting and following orders.Note that my messages are broadcasted in the below conversation, which explainswhy all three respond to each message. There is an obvious difference inquality, of course.I also demonstrate the results of rejecting an action and directing an agent touse a different approach.After I explained my rejection of the `read_file` action (which happened behindthe scenes on the terminal), &quot;FunctionAI&quot; appropriately used the `shell_command`action with `wc -l Dockerfile`. The Dockerfile indeed had 73 lines.CompletionAI used that command on the first try. Anecdotally as of this writing,`CompletionAI` seems to be more accurate, even though it is using the textcompletion API vs the function calling feature of the chat API. This may be dueto the implementation or issues arising from the translation into rolesdiscussed elsewhere.&lt;p align=&quot;center&quot;&gt;  &lt;img src=&quot;https://i.ibb.co/nbvLJvg/Screenshot-2023-06-14-at-3-59-01-AM.png&quot;       alt=&quot;Screenshot-2023-06-14-at-3-59-01-AM&quot; border=&quot;0&quot; width=500&gt;&lt;/p&gt;# Hypothetical ExamplesThe following examples are not implemented, but are presented as additionalideas for integrations that `agency` could support.```pythonSpace([    # Integrate access to a remote server    Server(&quot;Ubuntu&quot;,        ip=&quot;192.168.1.100&quot;),    # Add a voice assistant interface    VoiceAssistant(&quot;VoiceyAI&quot;)    # Use email to send/receive messages from others    Email(&quot;Dan&quot;, address=&quot;dan@example.com&quot;),    # Integrate other ML services, like for images    DiffusionModel(&quot;ImageAI&quot;),    # Horizontal scaling could be achieved by simply duplicating agents    # (notice we repeat the last one)    DiffusionModel(&quot;ImageAI&quot;),    # Existing AI agents may integrate as well    LangChainAgent(&quot;MyLangChainAgent&quot;))    # Development related tasks like model training may also be accomplished.    # You would only need to add one new `Agent` that reads a data set and sends    # it as messages to the `Agent` class used for inference, provided the    # underlying model is first switched to a training mode. For example:    DatasetTrainer(&quot;DatasetTrainer&quot;,      trainee: &quot;ChattyAIInTraining&quot;    )    ChattyAI(&quot;ChattyAIInTraining&quot;,      training_mode: True,      ...    )    # Network and share your LMs and Agents with others    RemoteAgent(&quot;AgentHelperDude&quot;,      url: &quot;https://agent.helper.dude:2023&quot;,      ...    )    # You get the idea...    AnySystemOrPersonOrFunctionAtAllThatYouWantToShareChannel(      &quot;Guest&quot;,      ...    )]).create()```# FAQ## How does `agency` compare to agent libraries like LangChain?Though you could entirely create a simple agent using only the primitives in`agency` (see [`agents/`](./agency/agents/)), it is not intended to be afull-fledged agent toolset. It can be thought of as an &quot;agent integrationframework&quot;.Projects like LangChain and others are exploring how to create purpose-builtagents that solve diverse problems using tools.`agency` is concerned with creating a safe and dynamic _environment_ for thesetypes of agents to work, where they can freely discover and communicate with thetools, each other, and any humans available in their environment.`agency` provides a simple means for defining actions, callbacks, and accesspolicies that you can use to monitor and ensure safety for the systems youexpose to your agents.A central part of the design is that humans and other systems can easilyintegrate as well, using a simple common format for messages. You can even use`agency` to set up a basic chat room to use with friends or other systems andnot use AI-driven agents at all!An additional benefit of its general design is that `agency` may also simplifysome agent development workflows. See the hypothetical examples above.So, `agency` is a more general framework intended to support agent developmentand to ultimately enable agents to safely integrate with anything, in any wayimaginable.## What are some known limitations or issues?* It's a new project, so keep that in mind in terms of completeness, but see  [the issues page](https://github.com/operand/agency/issues) for what is  currently planned. Core functionality is pretty well tested at the moment.* This library makes use of threads for each individual agent. Multithreading  is limited by python's GIL, meaning if you run a CPU bound model other agents  will have to wait for their &quot;turn&quot;. This goes for anything else you might  define as an &quot;agent&quot;, if it is CPU heavy it will block other agents. Note that  I/O does not block, so networked backends or services will execute in  parallel.  Other multiprocessing approaches to avoid the GIL are  [in development](https://github.com/operand/agency/issues/25).* This API does NOT assume or enforce predefined roles like &quot;user&quot;, &quot;system&quot;,  &quot;assistant&quot;, etc. This is an intentional decision and is not likely to change.  `agency` is intended to allow potentially large numbers of agents, systems,  and people to come together. A small predefined set of roles gets in the way  of representing many things uniquely and independently. This is a core feature  of `agency`: that all things are treated the same and may be interacted with  through common means.  The lack of roles introduces some challenges in integrating with role based  APIs. See the implementation of  [`OpenAIFunctionAgent`](./agency/agents/openai_function_agent.py) for an  example.* There is not much by way of storage support. That is mostly left up to you and  I'd suggest looking at the many technologies that focus on that. The `Agent`  class implements a simple `_message_log` array which you can make use of or  overwrite to back it with longer term storage. More direct support for storage  APIs may be considered in the future.# ContributingPlease do!## Development Installation```bashgit clone git@github.com:operand/agency.gitcd agencypoetry install```## Test SuiteYou can run the test suite with:```bashpoetry run pytest```The test suite is currently set up to run on pull requests to the `main` branch.# RoadmapThe goal is to maintain a minimal and practical API for bringing human,artificial, and other computing systems together, with the following priorities.## Priorities- **Speed**:  Performance is always a concern. If it's not performant, it's not practical.  Currently the limitations of python multi-threading are a bottleneck and a  priority to address.- **Access Control and Safety**:  An effective access control solution for agent-integrated systems is  fundamental to ensure safety. I believe I've included a sane first step at  such a pattern, but further development will be a focus of this project.- **Compatibility and Usability**:  In general, I believe this is a fair start in defining a set of patterns for  creating agent systems. I hope to ensure the API is kept small, and  compatible with a wide variety of use cases.- **Documentation**:  I hope to ensure documentation is kept organized, clear, and accurate. This  readme serves as a start.## Planned Work[Please see the issues page.](https://github.com/operand/agency/issues)If you have any suggestions or otherwise, feel free to add an issue!</longdescription>
</pkgmetadata>