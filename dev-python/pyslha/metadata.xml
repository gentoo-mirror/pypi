<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>A simple but flexible handler of the SUSY Les Houches Accord (SLHA) data format.pyslha is a parser/writer module for particle physics SUSY Les Houches Accord(SLHA) supersymmetric spectrum/decay files, and a collection of scripts whichuse the interface, e.g. for conversion to and from the legacy ISAWIG format, orto plot the mass spectrum and decay chains.The current release supports SLHA version 1, and as far as I'm aware is alsofully compatible with SLHA2: the block structures are read and accessedgenerically. If you have any problems, please provide an example input file andI'll happily investigate. SLHA3 is not yet supported (or standardised) but inrecent releases the new structures will not crash the parser. Support will beadded once the format is standardised (and in response to demand!)The plotting script provides output in PDF, EPS and PNG via LaTeX and the TikZgraphics package, and as LaTeX/TikZ source for direct embedding into documents oruser-tweaking of the generated output.Users of version 2.x should note that the interface has changed a little inversion 3.x: there are now generic read()/write() functions whichcan operate on filenames or file objects, and all I/O functions nowreturn/accept a single Doc object rather than a tuple of blocks, decays,etc. dicts. This single-object interface to the SLHA document allows for morecoherent handling of the data, as well as better robustness against futurechanges in the format and planned support for documentation comments.API example-----------&gt;&gt;&gt; import pyslha&gt;&gt;&gt; # generic read from file:&gt;&gt;&gt; d = pyslha.read('spcfiles/sps1a.spc')&gt;&gt;&gt; d&lt;PySLHA Doc: 22 blocks, 35 decays, 0 xsections&gt;&gt;&gt;&gt; # or, to ignore blocks known to be e.g. badly formatted:&gt;&gt;&gt; d = pyslha.read('spcfiles/sps1a.spc', ignoreblocks=['DCINFO'])&gt;&gt;&gt; d&lt;PySLHA Doc: 21 blocks, 35 decays, 0 xsections&gt;&gt;&gt;&gt; d.blocksBlocks  SPINFO { 1 : SOFTSUSY; 2 : 2.0.5 }  MODSEL { 1,1 : sugra }  SMINPUTS { 1 :  1.27934000e+02; 2 :  1.16637000e-05; ...  ...&gt;&gt;&gt; 'MODSEL' in d.blocksTrue&gt;&gt;&gt; d.blocks['MODSEL']MODSEL { 1,1 : sugra }&gt;&gt;&gt; d.blocks['MODSEL'][1,1]'sugra'&gt;&gt;&gt; d.blocks['MODSEL'][1,2] = 'foo'&gt;&gt;&gt; d.blocks['MODSEL']MODSEL { 1,1 : sugra; 1,2 : foo }Blocks------The Block interface also supplies dict-like keys(), values(), and items()methods, as well as more specialised value(), set_value() and is_single_valued()methods for improved access to ALPHA and any other unindexed blocks.Decays------The decay system has a similar interface to that of the generic Block foraccessing particle decay channel information:&gt;&gt;&gt; d.decays.keys()[23, 24, 6, 25, 35, 36, 37, 1000021, 1000006, 2000006, 1000005, 2000005, ...&gt;&gt;&gt; d.decays[1000021]1000021 : mass = 6.07713704e+02 GeV : total width = 5.50675438e+00 GeV   1.05840237e-01 [1000005, -5]   1.05840237e-01 [-1000005, 5]   ...The DECAY blocks in SLHA files are in fact mapped into Particle objects, each ofwhich contains multiple Decay objects. Check the Python documentation for Doc,Block, Particle and Decay, plus the pyslha module free functions for I/O.Cross-sections--------------Cross-section information, cf. the new XSECTION block type, is available viaDoc.xsections. As for decays, the API structure is a bit different from the textformat: xsections is a dict of Process objects, each of which contains allXSECTION lines for a given list of (sorted) initial + final state particleIDs. This is different from the text format in that a single Process containscross-sections, as XSec objects, for multiple centre-of-mass energies(sqrts). For example:&gt;&gt;&gt; print d.xsections[(2212, 2212, 1000001, 1000003), (2212, 2212, -1000002, 2000002), ...]&gt;&gt;&gt; myproc = d.xsections[2212,2212,1000001,1000003]The Process interface supplies a convenient method for filtering thecontained XSecs on any of their defining attributes, including scale scheme, QCDand EW orders, multiplicative scale factors, PDF ID code, andgenerator/integrator.&gt;&gt;&gt; myproc.get_xsecs(sqrts=13000., kappa_r=2., code='Prospino')Citation--------If you use PySLHA, for either model data handling or spectrum visualisation,please cite the paper: http://arxiv.org/abs/1305.4194TODOs:  For 3.2.x:   * In set_value, if first item is non-int, treat as None-indexed.   * Refine value string heuristic for strings with ints in them?  For 3.3.0:   * Use Doc to handle document-level header comments.   * Use _dict to handle block and decay summary comments.   * Preserve _inline_ comments from read -&gt; write (needs full-line/inline     comment separation). Can use separate comment dicts in Block, Decay,     etc. and attach a multiline .comment attr to the returned/written dicts.  Later, maybe:   * Identify HERWIG decay matrix element to use in ISAWIG.   * Handle RPV SUSY in ISAWIG.</longdescription>
</pkgmetadata>