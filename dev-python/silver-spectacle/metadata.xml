<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>## What is this?Silver Spectacle is a python library for displaying data. Its designed as a (superior) alternative to **matplotlib**.  - [Well designed](https://ryxcommar.com/2020/04/11/why-you-hate-matplotlib/) one liners that do everything  - [Beautiful](https://www.reddit.com/r/learnpython/comments/gaxpbp/does_anyone_else_find_matplotlib_a_bit_ugly_are/) by default  - Easy to customize, with [total control](https://github.com/jeff-hykin/silver_spectacle/blob/master/README.md#additional-documentation) over every visual element  - Lightweight and reliable (no X11, QT, or tkinter dependencies)  - Useful documentation (basic use-cases don't require [stack overflow questions with hundreds of upvotes](https://stackoverflow.com/questions/22276066/how-to-plot-multiple-functions-on-the-same-figure-in-matplotlib))## How do I use it?Install just like any other pip module`pip install silver_spectacle`Then inside a python file (or python repl) ```pythonimport silver_spectacle as ssss.DisplayCard(&quot;quickScatter&quot;, [    # [x,y]    [ 1   , 2   ],    [ 2   , 3   ],    [ 5   , 5   ],    [ 1.5 , 2.3 ],    [ 2   , 3.2 ]])# &gt;&gt;&gt; Server started at: http://0.0.0.0:9900ss.DisplayCard(&quot;quickLine&quot;, [    # [x,y]    [ 1,   2   ],    [ 1.5, 2.3 ],    [ 2,   3   ],    [ 5,   5   ],    # for quickLine: dont forget to sort them by x value!    # (otherwise it'll look like an etch-a-sketch)])```Open the address in a browser and you should see something like:&lt;br&gt;&lt;img width=&quot;1412&quot; alt=&quot;charts&quot; src=&quot;https://user-images.githubusercontent.com/17692058/146709458-cccaca78-b937-4cf5-90b1-b39a23c94053.png&quot;&gt;You can display images```pythonimport silver_spectacle as ssimport numpygrayscale_or_rgb = numpy.ones((100, 200, 3)) * (127) # doesn't even need to be a numpy arraycard = ss.DisplayCard(&quot;quickImage&quot;, grayscale_or_rgb) card = ss.DisplayCard(&quot;quickImage&quot;, &quot;./your_image.png&quot;)```You can also perform live/progressive updates on the charts.```pythonimport silver_spectacle as sscard = ss.DisplayCard(&quot;quickScatter&quot;, [    [1,2],    [2,3.2]])# live / progressive updatescard.send([5,5])card.send([1.5, 2.3])card.send([2,3.2])```NOTE: Currently live updates are not stored to disk. So if the browser window isn't open, then that data will be sent nowhere. This behavior will be improved in the future, but requires a bit of effort to be done in a performant way.Multiline update example```pythonimport silver_spectacle as sscard = ss.DisplayCard(&quot;multiLine&quot;,    dict(        # name : [ [x1,y1], [x2,y2],  ]        Line1Name=[            [ 1,   2   ],            [ 1.5, 2.3 ],            [ 2,   3   ],            [ 5,   5   ],        ],        Line2Name=[            [ 1+1,   2   ],            [ 1+1.5, 2.3 ],            [ 1+2,   3   ],            [ 1+5,   5   ],        ],    ),    dict(        title=&quot;Howdy!&quot;,        horizonal_label=&quot;horizonal_label here&quot;    ),)# Live updatecard.send(dict(    Line1Name=[        [ 1,   2   ],        [ 1.5, 2.3 ],        [ 2,   3   ],        [ 5,   5   ],    ],    Line2Name=[        [ 1+1,   2   ],        [ 1+1.5, 2.3 ],        [ 1+2,   3   ],        [ 1+5,   5   ],    ],))```&lt;br&gt;NOTE: Currently each `.send()` depends on the type of card (the interface). For example the arguments for `quickScatter` can be different from `chartjs`.## What are the available cards?```pythonss.DisplayCard(&quot;quickScatter&quot;, list_of_x_y_pairs)ss.DisplayCard(&quot;quickLine&quot;, list_of_x_y_pairs)ss.DisplayCard(&quot;quickImage&quot;, numpy_image_or_filepath)ss.DisplayCard(&quot;quickMarkdown&quot;, markdown_text)ss.DisplayCard(&quot;chartjs&quot;, config) # does tons: see https://www.chartjs.org/docs/latest/general/data-structures.htmlss.DisplayCard(&quot;multiLine&quot;, dict_to_x_y_pairs, options)```## What kind of plots are possible?If [Chart JS](https://www.chartjs.org/docs/latest/general/data-structures.html) has it, then it is already available in this library. (More visualization libraries like [plotly](https://plotly.com/javascript/3d-charts/) will be added to enable additional 2D plots, 3D charts, video/image integration, etc.)&lt;br&gt;To use a ChartJS chart:- Go to [their website](https://www.chartjs.org/docs/latest/general/data-structures.html)- Find a plot, such as [this line chart](https://www.chartjs.org/docs/latest/charts/line.html)- Then do a near 1-to-1 mapping to pythonFor example, with that line chart, look at their `setup` tab![setup_tab](https://user-images.githubusercontent.com/17692058/127252596-90333d78-8cd1-43ee-8764-c92ff90697b6.png)Look at the `config` tab![config_tab](https://user-images.githubusercontent.com/17692058/127252590-8542b31b-4f86-44f6-858a-0a89cfdc5fe0.png)&lt;br&gt;Then make a *very* similar structure with a python dictionary```python## setup tab part#labels = [ &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, ]data = {  &quot;labels&quot;: labels,  &quot;datasets&quot;: [{    &quot;label&quot;: 'My First Dataset',    &quot;data&quot;: [65, 59, 80, 81, 56, 55, 40],    &quot;fill&quot;: False,    &quot;borderColor&quot;: 'rgb(75, 192, 192)',    &quot;tension&quot;: 0.1  }]}## config tag part#config = {  &quot;type&quot;: 'line',  &quot;data&quot;: data,}## display the data#import silver_spectacle as ssss.DisplayCard(&quot;chartjs&quot;, config)```Here's another example of how that might look```pythonimport silver_spectacle as ssss.DisplayCard(&quot;chartjs&quot;, {    &quot;type&quot;: 'line',    &quot;data&quot;: {        &quot;datasets&quot;: [            {                &quot;label&quot;: 'Approach 1',                &quot;data&quot;: [ 85, 90, 89, 91, 92, 88 ],                &quot;fill&quot;: True,                &quot;tension&quot;: 0.1,                &quot;backgroundColor&quot;: 'rgb(75, 192, 192, 0.5)',            },            {                &quot;label&quot;: 'Approach 2',                &quot;data&quot;: [ 75, 80, 78, 81, 82, 77 ],                &quot;fill&quot;: True,                &quot;tension&quot;: 0.1,                &quot;backgroundColor&quot;: 'rgb(0, 292, 192, 0.5)',            },            {                &quot;label&quot;: 'Approach 3',                &quot;data&quot;: [ 95, 90, 99, 91, 92, 99 ],                &quot;fill&quot;: True,                &quot;tension&quot;: 0.1,                &quot;backgroundColor&quot;: 'rgb(0, 92, 192, 0.5)',            },        ]    },    &quot;options&quot;: {        &quot;pointRadius&quot;: 3, # the size of the dots        &quot;scales&quot;: {            &quot;y&quot;: {                &quot;min&quot;: 50,                &quot;max&quot;: 100,            },        }    }})```## What kind of features does it have?- **Works everywhere**: You can run this on your Raspberry Pi and view the results on your phone. It works whether it's WSL, Docker, or ssh over a VPN. No more 5 page tutorials about X11 forwarding, display variables, and editing config files.- **Non-blocking**: No more [hacky/painful workarounds](https://stackoverflow.com/questions/28269157/plotting-in-a-non-blocking-way-with-matplotlib#33050617) to get both code to execute, and a graph to update at the same time. `ss.display` is non-blocking by default, so use it without worrying if your overnight computation is going to stop in the middle because its waiting for user input.- **Multiple plots are effortless**: Graphs are displayed in a stream with the most recent one at the top. Just call display and forget about it. No more complex mashing of graphs together, or hassle of closing window after window, only to realize you meant to screenshot the one you just closed. - **Independent runtime**: If your main python program crashes that's fine, the cleanup function will intentionally leave the graph server running instead of killing it so you can still access your data. As long as you don't manually kill the server process, your data will be there.- **Interactive**: I'm not saying its impossible for tools like matplotlib to have custom interactivity, but lets just say nobody is doing it unless they have an unusual level of determination. Silver Spectacles let's you add custom buttons, effects, etc with ease.## Documentation?There is some additional documentation below for fully fledged customization of the javascript and css. However, this readme is currently all of the documentation. The power is in the flexibilty, not in the quantity of methods. Don't be afraid to open an issue asking for examples.## Whats the status of the library?There are many planned features. This library is under active development. However, the API is stable, and effectively all changes will only be adding tools to the toolbox. Some of the planned features are small:  - adding a button for clearing the screen of existing graphs  - an option to save/load all visual data to a file  - better interfaces for graphs that incrementally update  - working with numpy/pytorch/tensorflow tensors without needing to convertOther features will be a major additions   - tools for displaying videos  - integration with 3D plot libraries  - a simple system for combining/shaping graphs  - a theming system  - better visual notifications for errors  - a simple interface for graphical plugins (buttons/sliders)Development will, more than likely, be sporadic, PR's are welcome.## How can I contribute?- All the dependencies / setup instuctions are in `documentation/SETUP.md`.- That^ will automatically create a venv environment for testing/development- You can modify the files under `./main/silver_spectacle/`    - `./main/silver_spectacle/library.py` is the code that actually gets imported    - `./main/silver_spectacle/server.py` is the code that is run inside of a subprocess- After modification, you can use the `commands/project/local_install` command to install the local version you've created## How does it work? - Everytime the `display` function is called the library checks if the display server is running (using an http request). If the server is not running, then it starts the server as a subprocess in the background. It waits until the server is responding, then it uses http requests to tell the server about the data it wants to display.- The server does two things    1. It embeds this data into the html as JSON data. This way any newly-opened pages already have all the available data. In terms of files, the server only serves the one html+js+css file.    2. When the backend gets a http display request from the python process, it uses socket.io to notify all existing browser windows about the new data. - For live updates, the system uses `socket.io` and `aiohttp` to get a push notification-like effect within browser windows.- This seems trivial, but it is important: existing browser windows do not overwrite existing data with incoming data. That would be bad because browser windows can be open longer than both the server process or python process. So, the browser window can have more information than the server does. For that reason, all data is timestamped and stored inside the global `displayRequests` variable. Those timestamps are used as keys, allowing the browser windows to simply merge incoming data without duplication and without losing old information.- On the graphical side, the browser iterates over all the display commands, creating a chart for each one, and places them into a vertical list. This vertical list is displayed in reverse; the most-recent graph is at the top.- Thats it!## Additional documentationHere's the basic configuration for full customization.```pythonimport silver_spectacle as ssss.configure(    port=9900,    # Note: until version 1.0.0 is released    # make sure to pin the exact version number of silver_spectacle to keep your code reliable     # interactions inside JavaScript and CSS     # (e.g. variable and class names) will be unstable.     custom_css=&quot;&quot;,    custom_js=&quot;&quot;,    # Note2: currently custom CSS and JS only get applied when the server starts.    # Meaning, if the server is still running from an old process    # (a zombie server beacuse the python program crashed suddenly),    # then it will look like your custom CSS and javascript are not being applied    server_start_timeout=10, # this is not very important)```Here's a more full example.```pythonimport silver_spectacle as ssss.configure(    port=69420,    custom_css=&quot;&quot;&quot;        body .card {            background-color: gray;            color: whitesmoke; /* font color */        }        body #stream-container {            flex-direction: column; /* makes oldest graphs be at the top */        }        body {            background: slategray !important; /* needs to be important to override other values */         }    &quot;&quot;&quot;,    custom_js=&quot;&quot;&quot;        window.onload = ()=&gt;{            //            // main API            //            silverSpectacle.log(&quot;string&quot;)      // add information to the graphical log            silverSpectacle.cards              // dict with cardId's as keys            silverSpectacle.cards[0].element   // html element of card with ID of 0            silverSpectacle.cards[0].createdAt // unix time in seconds            silverSpectacle.cards[0].interface // name of interface as string            silverSpectacle.cards[0].arguments // array of json values            silverSpectacle.interface          // dict of fuctions that create card elements            silverSpectacle.libraries          // dict of libraries, like ChartJS that you can use            silverSpectacle.libraries.lodash   // if you like lodash, its available            //            // add your own card/interface            //                // step 1, create a function like the one below (an interface)                silverSpectacle.interface[&quot;myCustomUi&quot;] = async (args) =&gt; {                    let message = args[0]                    let myComponent = document.createElement(&quot;div&quot;)                    myComponent.innerHTML = &quot;Python says:&lt;br&gt;&quot;+message                    // silverSpectacle.createCard() wraps the component to give it the white background and shadow                    let card = silverSpectacle.createCard({ children: [ myComponent ], })                    // (optional) add a handler for dyanmic data                    card.receive = function (data) {                        // update the component                        myComponent.innerHTML += `&lt;br&gt; python also wanted to say: {JSON.stringify(data)}`                        // warning / error checking                        if (typeof data != 'string') {                            silverSpectacle.log(&quot;[warning] data was dynamically sent to myCustomUi, but it wasn't a string&quot;)                        }                    }                    // needs to return an html element                    return card                }                // step 2, call it from python!                //                //     import silver_spectacle as ss                //     # create card                //     custom_card = ss.DisplayCard(&quot;myCustomUi&quot;, &quot;hello world&quot;)                //     import time                //     time.sleep(5)                //     # add more data after the fact                //     custom_card.send(&quot;I waited 5 sec to send this&quot;)        }    &quot;&quot;&quot;,    server_start_timeout=10, # (seconds)    # this^ is not very important    # the value is how long to wait if the server doesn't start at all    # designed to fail without throwing an error encase the user     # is performing important computations)```Right now, there is still a lot of room for improving/expanding the javascript interface with events, tools, and encapsulation.</longdescription>
</pkgmetadata>