<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># CDK Pipelines for GitHub Workflows![cdk-constructs: Experimental](https://img.shields.io/badge/cdk--constructs-experimental-important.svg?style=for-the-badge)[![View on Construct Hub](https://constructs.dev/badge?package=cdk-pipelines-github)](https://constructs.dev/packages/cdk-pipelines-github)&gt; The APIs in this module are experimental and under active development.&gt; They are subject to non-backward compatible changes or removal in any future version. These are&gt; not subject to the [Semantic Versioning](https://semver.org/) model and breaking changes will be&gt; announced in the release notes. This means that while you may use them, you may need to update&gt; your source code when upgrading to a newer version of this package.A construct library for painless Continuous Delivery of CDK applications,deployed via[GitHub Workflows](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).The CDK already has a CI/CD solution,[CDK Pipelines](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.pipelines-readme.html),which creates an AWS CodePipeline that deploys CDK applications. This moduleserves the same surface area, except that it is implemented with GitHubWorkflows.## Table of Contents* [CDK Pipelines for GitHub Workflows](#cdk-pipelines-for-github-workflows)  * [Table of Contents](#table-of-contents)  * [Usage](#usage)  * [Initial Setup](#initial-setup)  * [AWS Credentials](#aws-credentials)    * [GitHub Action Role](#github-action-role)      * [`GitHubActionRole` Construct](#githubactionrole-construct)    * [GitHub Secrets](#github-secrets)    * [Runners with Preconfigured Credentials](#runners-with-preconfigured-credentials)    * [Using Docker in the Pipeline](#using-docker-in-the-pipeline)      * [Authenticating to Docker registries](#authenticating-to-docker-registries)  * [Runner Types](#runner-types)    * [GitHub Hosted Runner](#github-hosted-runner)    * [Self Hosted Runner](#self-hosted-runner)  * [Escape Hatches](#escape-hatches)  * [Additional Features](#additional-features)    * [GitHub Action Step](#github-action-step)    * [Configure GitHub Environment](#configure-github-environment)      * [Waves for Parallel Builds](#waves-for-parallel-builds)      * [Manual Approval Step](#manual-approval-step)    * [Pipeline YAML Comments](#pipeline-yaml-comments)  * [Tutorial](#tutorial)  * [Not supported yet](#not-supported-yet)  * [Contributing](#contributing)  * [License](#license)## UsageAssuming you have a[`Stage`](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.Stage.html)called `MyStage` that includes CDK stacks for your app and you want to deploy itto two AWS environments (`BETA_ENV` and `PROD_ENV`):```pythonfrom aws_cdk.pipelines import ShellStepapp = App()pipeline = GitHubWorkflow(app, &quot;Pipeline&quot;,    synth=ShellStep(&quot;Build&quot;,        commands=[&quot;yarn install&quot;, &quot;yarn build&quot;        ]    ),    aws_creds=AwsCredentials.from_open_id_connect(        git_hub_action_role_arn=&quot;arn:aws:iam::&lt;account-id&gt;:role/GitHubActionRole&quot;    ))# Build the stagesbeta_stage = MyStage(app, &quot;Beta&quot;, env=BETA_ENV)prod_stage = MyStage(app, &quot;Prod&quot;, env=PROD_ENV)# Add the stages for sequential build - earlier stages failing will stop later ones:pipeline.add_stage(beta_stage)pipeline.add_stage(prod_stage)# OR add the stages for parallel building of multiple stages with a Wave:wave = pipeline.add_wave(&quot;Wave&quot;)wave.add_stage(beta_stage)wave.add_stage(prod_stage)app.synth()```When you run `cdk synth`, a `deploy.yml` workflow will be created under`.github/workflows` in your repo. This workflow will deploy your applicationbased on the definition of the pipeline. In the example above, it will deploythe two stages in sequence, and within each stage, it will deploy all thestacks according to their dependency order and maximum parallelism. If your appuses assets, assets will be published to the relevant destination environment.The `Pipeline` class from `cdk-pipelines-github` is derived from the base CDKPipelines class, so most features should be supported out of the box. See the[CDK Pipelines](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.pipelines-readme.html)documentation for more details.To express GitHub-specifc details, such as those outlined in [Additional Features](#additional-features), you have a few options:* Use a `GitHubStage` instead of `Stage` (or make a `GitHubStage` subclass instead of a `Stage` subclass) - this adds the `GitHubCommonProps` to the `Stage` properties  * With this you can use `pipeline.addStage(myGitHubStage)` or `wave.addStage(myGitHubStage)` and the properties of the    stage will be used* Using a `Stage` (or subclass thereof) or a `GitHubStage` (or subclass thereof) you can call `pipeline.addStageWithGitHubOptions(stage, stageOptions)` or `wave.addStageWithGitHubOptions(stage, stageOptions)`  * In this case you're providing the same options along with the stage instead of embedded in the stage.  * Note that properties of a `GitHubStage` added with `addStageWithGitHubOptions()` will override the options provided to `addStageWithGitHubOptions()`**NOTES:*** Environments must be bootstrapped separately using `cdk bootstrap`. See [CDK  Environment  Bootstrapping](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.pipelines-readme.html#cdk-environment-bootstrapping)  for details.## Initial SetupAssuming you have your CDK app checked out on your local machine, here are the suggested stepsto develop your GitHub Workflow.* Set up AWS Credentials your local environment. It is highly recommended to authenticate via an OpenId  Connect IAM Role. You can set one up using the [`GithubActionRole`](#github-action-role) class provided  in this module. For more information (and alternatives), see [AWS Credentials](#aws-credentials).* When you've updated your pipeline and are ready to deploy, run `cdk synth`. This creates a workflow file  in `.github/workflows/deploy.yml`.* When you are ready to test your pipeline, commit your code changes as well as the `deploy.yml` file to  GitHub. GitHub will automatically try to run the workflow found under `.github/workflows/deploy.yml`.* You will be able to see the result of the run on the `Actions` tab in your repository:  ![Screen Shot 2021-08-22 at 12 06 05](https://user-images.githubusercontent.com/598796/130349345-a10a2f75-0848-4de8-bc4c-f5a1418ee228.png)For an in-depth run-through on creating your own GitHub Workflow, see the[Tutorial](#tutorial) section.## AWS CredentialsThere are two ways to supply AWS credentials to the workflow:* GitHub Action IAM Role (recommended).* Long-lived AWS Credentials stored in GitHub Secrets.The GitHub Action IAM Role authenticates via the GitHub OpenID Connect providerand is recommended, but it requires preparing your AWS account beforehand. Thisapproach allows your Workflow to exchange short-lived tokens directly from AWS.With OIDC, benefits include:* No cloud secrets.* Authentication and authorization management.* Rotating credentials.You can read more[here](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).### GitHub Action RoleAuthenticating via OpenId Connect means you do not need to store long-livedcredentials as GitHub Secrets. With OIDC, you provide a pre-provisioned IAMrole with optional role session name to your GitHub Workflow via the `awsCreds.fromOpenIdConnect` API:```pythonfrom aws_cdk.pipelines import ShellStepapp = App()pipeline = GitHubWorkflow(app, &quot;Pipeline&quot;,    synth=ShellStep(&quot;Build&quot;,        commands=[&quot;yarn install&quot;, &quot;yarn build&quot;        ]    ),    aws_creds=AwsCredentials.from_open_id_connect(        git_hub_action_role_arn=&quot;arn:aws:iam::&lt;account-id&gt;:role/GitHubActionRole&quot;,        role_session_name=&quot;optional-role-session-name&quot;    ))```There are two ways to create this IAM role:* Use the `GitHubActionRole` construct (recommended and described below).* Manually set up the role ([Guide](https://github.com/cdklabs/cdk-pipelines-github/blob/main/GITHUB_ACTION_ROLE_SETUP.md)).#### `GitHubActionRole` ConstructBecause this construct involves creating an IAM role in your account, it mustbe created separate to your GitHub Workflow and deployed via a normal`cdk deploy` with your local AWS credentials. Upon successful deployment, thearn of your newly created IAM role will be exposed as a `CfnOutput`.To utilize this construct, create a separate CDK stack with the following codeand `cdk deploy`:```pythonclass MyGitHubActionRole(Stack):    def __init__(self, scope, id, *, description=None, env=None, stackName=None, tags=None, synthesizer=None, terminationProtection=None, analyticsReporting=None):        super().__init__(scope, id, description=description, env=env, stackName=stackName, tags=tags, synthesizer=synthesizer, terminationProtection=terminationProtection, analyticsReporting=analyticsReporting)        provider = GitHubActionRole(self, &quot;github-action-role&quot;,            repos=[&quot;myUser/myRepo&quot;]        )app = App()MyGitHubActionRole(app, &quot;MyGitHubActionRole&quot;)app.synth()```Note: If you have previously created the GitHub identity provider with url`https://token.actions.githubusercontent.com`, the above example will failbecause you can only have one such provider defined per account. In thiscase, you must provide the already created provider into your `GithubActionRole`construct via the `provider` property.&gt; Make sure the audience for the provider is `sts.amazonaws.com` in this case.```pythonclass MyGitHubActionRole(Stack):    def __init__(self, scope, id, *, description=None, env=None, stackName=None, tags=None, synthesizer=None, terminationProtection=None, analyticsReporting=None):        super().__init__(scope, id, description=description, env=env, stackName=stackName, tags=tags, synthesizer=synthesizer, terminationProtection=terminationProtection, analyticsReporting=analyticsReporting)        provider = GitHubActionRole(self, &quot;github-action-role&quot;,            repos=[&quot;myUser/myRepo&quot;],            provider=GitHubActionRole.existing_git_hub_actions_provider(self)        )```### GitHub SecretsAuthenticating via this approach means that you will be manually creating AWScredentials and duplicating them in GitHub secrets. The workflow expects theGitHub repository to include secrets with AWS credentials under`AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`. You can override these defaultsby supplying the `awsCreds.fromGitHubSecrets` API to the workflow:```pythonfrom aws_cdk.pipelines import ShellStepapp = App()pipeline = GitHubWorkflow(app, &quot;Pipeline&quot;,    synth=ShellStep(&quot;Build&quot;,        commands=[&quot;yarn install&quot;, &quot;yarn build&quot;        ]    ),    aws_creds=AwsCredentials.from_git_hub_secrets(        access_key_id=&quot;MY_ID&quot;,  # GitHub will look for the access key id under the secret `MY_ID`        secret_access_key=&quot;MY_KEY&quot;    ))```### Runners with Preconfigured CredentialsIf your runners provide credentials themselves, you can configure `awsCreds` toskip passing credentials:```pythonfrom aws_cdk.pipelines import ShellStepapp = App()pipeline = GitHubWorkflow(app, &quot;Pipeline&quot;,    synth=ShellStep(&quot;Build&quot;,        commands=[&quot;yarn install&quot;, &quot;yarn build&quot;        ]    ),    aws_creds=AwsCredentials.runner_has_preconfigured_creds())```### Using Docker in the PipelineYou can use Docker in GitHub Workflows in a similar fashion to CDK Pipelines.For a full discussion on how to use Docker in CDK Pipelines, see[Using Docker in the Pipeline](https://github.com/aws/aws-cdk/blob/master/packages/@aws-cdk/pipelines/README.md#using-docker-in-the-pipeline).Just like CDK Pipelines, you may need to authenticate to Docker registries toavoid being throttled.#### Authenticating to Docker registriesYou can specify credentials to use for authenticating to Docker registries aspart of the Workflow definition. This can be useful if any Docker image assets —in the pipeline or any of the application stages — require authentication, eitherdue to being in a different environment (e.g., ECR repo) or to avoid throttling(e.g., DockerHub).```pythonfrom aws_cdk.pipelines import ShellStepapp = App()pipeline = GitHubWorkflow(app, &quot;Pipeline&quot;,    synth=ShellStep(&quot;Build&quot;,        commands=[&quot;yarn install&quot;, &quot;yarn build&quot;        ]    ),    docker_credentials=[        # Authenticate to ECR        DockerCredential.ecr(&quot;&lt;account-id&gt;.dkr.ecr.&lt;aws-region&gt;.amazonaws.com&quot;),        # Authenticate to DockerHub        DockerCredential.docker_hub(            # These properties are defaults; feel free to omit            username_key=&quot;DOCKERHUB_USERNAME&quot;,            personal_access_token_key=&quot;DOCKERHUB_TOKEN&quot;        ),        # Authenticate to Custom Registries        DockerCredential.custom_registry(&quot;custom-registry&quot;,            username_key=&quot;CUSTOM_USERNAME&quot;,            password_key=&quot;CUSTOM_PASSWORD&quot;        )    ])```## Runner TypesYou can choose to run the workflow in either a GitHub hosted or [self-hosted](https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners) runner.### GitHub Hosted RunnerThe default is `Runner.UBUNTU_LATEST`. You can override this as shown below:```pythonfrom aws_cdk.pipelines import ShellStepapp = App()pipeline = GitHubWorkflow(app, &quot;Pipeline&quot;,    synth=ShellStep(&quot;Build&quot;,        commands=[&quot;yarn install&quot;, &quot;yarn build&quot;        ]    ),    runner=Runner.WINDOWS_LATEST)```### Self Hosted RunnerThe following example shows how to configure the workflow to run on a self-hosted runner. Note that you do not need to pass in `self-hosted` explicitly as a label.```pythonfrom aws_cdk.pipelines import ShellStepapp = App()pipeline = GitHubWorkflow(app, &quot;Pipeline&quot;,    synth=ShellStep(&quot;Build&quot;,        commands=[&quot;yarn install&quot;, &quot;yarn build&quot;        ]    ),    runner=Runner.self_hosted([&quot;label1&quot;, &quot;label2&quot;]))```## Escape HatchesYou can override the `deploy.yml` workflow file post-synthesis however you like.```pythonfrom aws_cdk.pipelines import ShellStepapp = App()pipeline = GitHubWorkflow(app, &quot;Pipeline&quot;,    synth=ShellStep(&quot;Build&quot;,        commands=[&quot;yarn install&quot;, &quot;yarn build&quot;        ]    ))deploy_workflow = pipeline.workflow_file# add `on: workflow_call: {}` to deploy.ymldeploy_workflow.patch(JsonPatch.add(&quot;/on/workflow_call&quot;, {}))# remove `on: workflow_dispatch` from deploy.ymldeploy_workflow.patch(JsonPatch.remove(&quot;/on/workflow_dispatch&quot;))```## Additional FeaturesBelow is a compilation of additional features available for GitHub Workflows.### GitHub Action StepIf you want to call a GitHub Action in a step, you can utilize the `GitHubActionStep`.`GitHubActionStep` extends `Step` and can be used anywhere a `Step` type is allowed.The `jobSteps` array is placed into the pipeline job at the relevant `jobs.&lt;job_id&gt;.steps` as [documented here](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsteps).In this example,```pythonfrom aws_cdk.pipelines import ShellStepapp = App()pipeline = GitHubWorkflow(app, &quot;Pipeline&quot;,    synth=ShellStep(&quot;Build&quot;,        commands=[&quot;yarn install&quot;, &quot;yarn build&quot;        ]    ))# &quot;Beta&quot; stage with a pre-check that uses code from the repo and an actionstage = MyStage(app, &quot;Beta&quot;, env=BETA_ENV)pipeline.add_stage(stage,    pre=[GitHubActionStep(&quot;PreBetaDeployAction&quot;,        job_steps=[JobStep(            name=&quot;Checkout&quot;,            uses=&quot;actions/checkout@v3&quot;        ), JobStep(            name=&quot;pre beta-deploy action&quot;,            uses=&quot;my-pre-deploy-action@1.0.0&quot;        ), JobStep(            name=&quot;pre beta-deploy check&quot;,            run=&quot;npm run preDeployCheck&quot;        )        ]    )])app.synth()```### Configure GitHub EnvironmentYou can run your GitHub Workflow in select[GitHub Environments](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment).Via the GitHub UI, you can configure environments with protection rules and secrets, and referencethose environments in your CDK app. A workflow that references an environment must follow anyprotection rules for the environment before running or accessing the environment's secrets.Assuming (just like in the main [example](#usage)) you have a[`Stage`](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.Stage.html)called `MyStage` that includes CDK stacks for your app and you want to deploy itto two AWS environments (`BETA_ENV` and `PROD_ENV`) as well as GitHub Environments`beta` and `prod`:```pythonfrom aws_cdk.pipelines import ShellStepapp = App()pipeline = GitHubWorkflow(app, &quot;Pipeline&quot;,    synth=ShellStep(&quot;Build&quot;,        commands=[&quot;yarn install&quot;, &quot;yarn build&quot;        ]    ),    aws_creds=AwsCredentials.from_open_id_connect(        git_hub_action_role_arn=&quot;arn:aws:iam::&lt;account-id&gt;:role/GitHubActionRole&quot;    ))pipeline.add_stage_with_git_hub_options(Stage(self, &quot;Beta&quot;,    env=BETA_ENV),    git_hub_environment=GitHubEnvironment(name=&quot;beta&quot;))pipeline.add_stage_with_git_hub_options(MyStage(self, &quot;Prod&quot;,    env=PROD_ENV),    git_hub_environment=GitHubEnvironment(name=&quot;prod&quot;))app.synth()```#### Waves for Parallel BuildsYou can add a Wave to a pipeline, where each stage of a wave will build in parallel.&gt; **Note**: The `pipeline.addWave()` call will return a `Wave` object that is actually a `GitHubWave` object, but&gt; due to JSII rules the return type of `addWave()` cannot be changed. If you need to use&gt; `wave.addStageWithGitHubOptions()` then you should call `pipeline.addGitHubWave()` instead, or you can&gt; use `GitHubStage`s to carry the GitHub properties.When deploying to multiple accounts or otherwise deploying mostly-unrelated stacks, using waves can be a huge win.Here's a relatively large (but real) example, **without** a wave:&lt;img width=&quot;1955&quot; alt=&quot;without-waves-light-mode&quot; src=&quot;https://user-images.githubusercontent.com/386001/217436992-d8e46c23-6295-48ec-b139-add60b1f5a14.png&quot;&gt;You can see how dependencies get chained unnecessarily, where the `cUrl` step should be the final step (a test) for an account:&lt;img width=&quot;1955&quot; alt=&quot;without-waves-deps-light-mode&quot; src=&quot;https://user-images.githubusercontent.com/386001/217437074-3c86d88e-6be7-4b10-97b1-6b51b100e4d6.png&quot;&gt;Here's the exact same stages deploying the same stacks to the same accounts, but **with** a wave:&lt;img width=&quot;1955&quot; alt=&quot;with-waves&quot; src=&quot;https://user-images.githubusercontent.com/386001/217437228-72f6c278-7e97-4a88-91fa-089628ea0381.png&quot;&gt;And the dependency chains are reduced to only what is actually needed, with the `cUrl` calls as the final stage for each account:&lt;img width=&quot;1955&quot; alt=&quot;deps&quot; src=&quot;https://user-images.githubusercontent.com/386001/217437265-1c10cd5f-3c7d-4e3a-af5c-acbdf3acff1b.png&quot;&gt;For additional information and a code example see [here](docs/waves.md).#### Manual Approval StepOne use case for using GitHub Environments with your CDK Pipeline is to create amanual approval step for specific environments via Environment protection rules.From the GitHub UI, you can specify up to 5 required reviewers that must approvebefore the deployment can proceed:&lt;img width=&quot;1134&quot; alt=&quot;require-reviewers&quot; src=&quot;https://user-images.githubusercontent.com/7248260/163494925-627f5ca7-a34e-48fa-bec7-1e4924ab6c0c.png&quot;&gt;For more information and a tutorial for how to set this up, see this[discussion](https://github.com/cdklabs/cdk-pipelines-github/issues/162).### Pipeline YAML CommentsAn &quot;AUTOMATICALLY GENERATED FILE...&quot; comment will by default be added to the topof the pipeline YAML. This can be overriden as desired to add additional contextto the pipeline YAML.```declare const pipeline: GitHubWorkflow;pipeline.workflowFile.commentAtTop = `AUTOGENERATED FILE, DO NOT EDIT DIRECTLY!Deployed stacks from this pipeline:${STACK_NAMES.map((s)=&gt;`- ${s}\n`)}`;```This will generate the normal `deploy.yml` file, but with the additional comments:```yaml# AUTOGENERATED FILE, DO NOT EDIT DIRECTLY!# Deployed stacks from this pipeline:# - APIStack# - AuroraStackname: deployon:  push:    branches:&lt; the rest of the pipeline YAML contents&gt;```## TutorialYou can find an example usage in [test/example-app.ts](./test/example-app.ts)which includes a simple CDK app and a pipeline.You can find a repository that uses this example here: [eladb/test-app-cdkpipeline](https://github.com/eladb/test-app-cdkpipeline).To run the example, clone this repository and install dependencies:```shellcd ~/projects # or some other playground spacegit clone https://github.com/cdklabs/cdk-pipelines-githubcd cdk-pipelines-githubyarn```Now, create a new GitHub repository and clone it as well:```shellcd ~/projectsgit clone https://github.com/myaccount/my-test-repository```You'll need to set up AWS credentials in your environment. Note that this tutorial useslong-lived GitHub secrets as credentials for simplicity, but it is recommended to set upa GitHub OIDC role instead.```shellexport AWS_ACCESS_KEY_ID=xxxxexport AWS_SECRET_ACCESS_KEY=xxxxx```Bootstrap your environments:```shellexport CDK_NEW_BOOTSTRAP=1npx cdk bootstrap aws://ACCOUNTID/us-east-1npx cdk bootstrap aws://ACCOUNTID/eu-west-2```Now, run the `manual-test.sh` script when your working directory is the new repository:```shellcd ~/projects/my-test-repository~/projects/cdk-piplines/github/test/manual-test.sh```This will produce a `cdk.out` directory and a `.github/workflows/deploy.yml` file.Commit and push these files to your repo and you should see the deploymentworkflow in action. Make sure your GitHub repository has `AWS_ACCESS_KEY_ID` and`AWS_SECRET_ACCESS_KEY` secrets that can access the same account that yousynthesized against.&gt; In this tutorial, you are supposed to commit `cdk.out` (i.e. the code is pre-synthed).&gt; Do not do this in your app; you should always synth during the synth step of the GitHub&gt; workflow. In the example app this is achieved through the `preSynthed: true` option.&gt; It is for example purposes only and is not something you should do in your app.&gt;&gt; ```python&gt; from aws_cdk.pipelines import ShellStep&gt;&gt; pipeline = GitHubWorkflow(App(), &quot;Pipeline&quot;,&gt;     synth=ShellStep(&quot;Build&quot;,&gt;         commands=[&quot;echo \&quot;nothing to do (cdk.out is committed)\&quot;&quot;]&gt;     ),&gt;     # only the example app should do this. your app should synth in the synth step.&gt;     pre_synthed=True&gt; )&gt; ```## Not supported yetMost features that exist in CDK Pipelines are supported. However, as the CDK Pipelinesfeature are expands, the feature set for GitHub Workflows may lag behind. If you see afeature that you feel should be supported by GitHub Workflows, please open a GitHub issueto track it.## ContributingSee [CONTRIBUTING](CONTRIBUTING.md) for more information.## LicenseThis project is licensed under the Apache-2.0 License.</longdescription>
</pkgmetadata>