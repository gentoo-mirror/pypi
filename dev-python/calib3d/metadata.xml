<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Python camera calibration and projective geometry libraryThis library offers several tools for manipulation of calibrated cameras, projective geometry and computations using homogenous coordinates.Camera calibration allows to determine the relation between the camera's pixels (2D coordinates) and points in the real world(3D coordinates). It implies computation using homogenous coordinates. This python library aims at simplifying implementationsof projective geometry computations, building on top of `numpy` and `cv2`.## InstallationInstallation using the package manager pip```shellpip install calib3d```## UsageFull API documentation is available in [here](https://ispgroupucl.github.io/calib3d).### 2D and 3D points implementationThe `Point2D` (and `Point3D`) class represent 2D (and 3D) points extending `numpy.ndarray`. Access to y coordinate of `point` is `point.y`, and access to homogenous coordinates is made easy with `point.H`, while it is still possible to use `point` with any `numpy` operators.```python&gt;&gt;&gt; Point2D(1,2) == Point2D(2,4,2)True&gt;&gt;&gt; points = Point2D(np.array([[0, 0, 1, 2, 3],   # x coordinates                               [1, 2, 3, 4, 5]])) # y coordinates&gt;&gt;&gt; points.xarray([0., 0., 1., 2., 3.])&gt;&gt;&gt; points.Harray([[0., 0., 1., 2., 3.],       [1., 2., 3., 4., 5.],       [1., 1., 1., 1., 1.]])```### Camera calibrationThe `Calib` class represents a calibrated camera. It has a serie of methods to handle 3D to 2D projections, 2D to 3D liftings, image transformations, and more.```python&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; from calib3d import Calib, Point3D, compute_rotation_matrix&gt;&gt;&gt; f = 0.035                                      # lens focal length [m]      35 mm lens&gt;&gt;&gt; w, h = np.array([4000, 3000])                  # sensor size       [px.px]  12 Mpx sensor&gt;&gt;&gt; d = w/0.01                                     # pixel density     [px.m⁻¹] with a 1 cm sensor width&gt;&gt;&gt; K = np.array([[ d*f,  0 , w/2 ],               # Camera matrix (intrinsic parameters)...               [  0 , d*f, h/2 ],...               [  0 ,  0 ,  1  ]])&gt;&gt;&gt; C = Point3D(10,10,10)                          # Camera position in the 3D space&gt;&gt;&gt; R = compute_rotation_matrix(Point3D(0,0,0), C) # Camera pointing towards origin&gt;&gt;&gt; calib = Calib(K=K, T=-R@C, R=R, width=w, height=h)&gt;&gt;&gt; calib.project_3D_to_2D(Point3D(0,0,0))Point2D([[2000.],         [1500.]])```Cropping or scaling a calib is made easy with the following operations (for more operations, check the documentation)```python&gt;&gt;&gt; new_calib = calib.crop(x_slice=slice(10, 110, None), y_slice=slice(500, 600, None))&gt;&gt;&gt; new_calib = calib.scale(output_width=2000, output_height=1500)```Other useful methods```python&gt;&gt;&gt; calib.projects_in(Point3D(0, 20, 20))False&gt;&gt;&gt; calib.compute_length2D(Point3D(0, 0, 0), .42)  # Number of pixels that represent a length of .42 in the 3D spacearray([339.48195828])```## ContributingPull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.## AuthorsThis library is developed and maintained by [Gabriel Van Zandycke](https://github.com/gabriel-vanzandycke). If you use this repository, please consider citing my work.</longdescription>
</pkgmetadata>