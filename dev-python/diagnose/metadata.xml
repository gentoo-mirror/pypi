<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># DiagnoseA library for instrumenting Python code at runtime.## ProbesStructured logs and metrics and observability are great, but almost alwaysrequire you to alter your code, which interrupts the flow when reading code.It also typically requires a build cycle to alter; it's no fun making a ticket,getting review, waiting for a build and deploy, and then doing it all againto back out your temporary additions. This is doubly true when doing research,where you might perform a dozen small experiments to measure your live code.This library allows you to dynamically add probes at runtime instead.Probes are:* reliable: errors will never affect your production code* ephemeral: set a &quot;lifespan&quot; (in minutes) for each instrument* comprehensive: all references to the target function are instrumented* fast: measure most functions with fast local lookups; uses hunter (in Cython) for more invasive internal probes.Individual probes can be created directly by calling `attach_to(target)`:```#python&gt;&gt;&gt; from path.to.module import myclass&gt;&gt;&gt; myclass().add13(arg=5)18&gt;&gt;&gt; p = diagnose.probes.attach_to(&quot;path.to.module.myclass.add13&quot;)&gt;&gt;&gt; p.instruments[&quot;foo&quot;] = diagnose.LogInstrument(&quot;foo&quot;, &quot;arg&quot;)&gt;&gt;&gt; p.start()&gt;&gt;&gt; myclass().add13(arg=5)Probe (foo) = 518```Instruments aren't limited to recording devices! Use probes to fire off any kind of event handler. Instruments are free to maintain state themselves, or read it from somewhere else, to control their own behavior or even implement feedback mechanisms. A truly evil instrument could even alter the args/kwargs passed to a function on the fly, or call arbitrary Python code to do any number of crazy things. Consequently, it's up to you to govern what instruments are added to your environment.## ManagersIn a running system, we want to add, remove, start, and stop probes and instruments without having to code at an interactive prompt or restart the system; we do this with an InstrumentManager. Start by configuring the global diagnose.manager:```#python&gt;&gt;&gt; diagnose.manager.instrument_classes = {    &quot;log&quot;: LogInstrument,    &quot;hist&quot;: MyHistogramInstrument,    &quot;incr&quot;: MyIncrementInstrument,}&gt;&gt;&gt; diagnose.manager.global_namespace.update({&quot;foo&quot;: foo})```Later, you can define instruments:```#python&gt;&gt;&gt; diagnose.manager.specs[&quot;instr-1&quot;] = {    &quot;target&quot;: &quot;myapp.module.file.class.method&quot;,    &quot;instrument&quot;: {        &quot;type&quot;: &quot;log&quot;,        &quot;name&quot;: &quot;myapp.method&quot;,        &quot;value&quot;: &quot;result&quot;,        &quot;event&quot;: &quot;return&quot;,        &quot;custom&quot;: {},    },    &quot;lifespan&quot;: 10,    &quot;lastmodified&quot;: datetime.datetime.utcnow(),    &quot;applied&quot;: {},}```Then call `diagnose.manager.apply()`, either when you add an instrument, or on a schedule if your store is in MongoDB and the process defining probes is not the target process.The `applied` dictionary will be filled with information about which processeshave applied the probe, and whether they encountered any errors.## BreakpointsBreakpoints allow you to perform tests that involve concurrency, or that must trigger specific actions at specific times, by setting specificbreakpoints at which the execution must stop waiting for some conditions to happen.```#python        with Breakpoint(S3Archive, &quot;unarchive&quot;) as bp:            bp.start_thread(object.unarchive)  # Start something in the background that will invoke S3Archive.unarchive            bp.wait()  # wait for S3Archive.unarchive to start            # perform what has to be done once S3Archive.unarchive            # has been started.            # Note: you can get at the unarchive's stack frame using            # bp.stackframe            bp.release()  # let S3Archive.unarchive proceed.```</longdescription>
</pkgmetadata>