<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># PyleroWelcome to Pylero, the Python wrapper for the Polarion WSDL API. The Pylerowrapper enables native python access to Polarion objects and functionalityusing object oriented structure and functionality. This allows the developers touse Pylero in a natural fashion without being concerned about the Polariondetails.All Pylero objects inherit from BasePolarion. The objects used in the libraryare all generated from the SOAP factory class, using the python-suds library.The Pylero class attributes are generated dynamically as properties, based ona mapping dict between the pylero naming convention and the Polarion attributenames.The use of properties allows the pylero object attributes to be virtual with noneed for syncing between them and the Polarion objects they are based on.The Polarion WSDL API does not implement validation/verification of data passedin, so the Pylero library takes care of this itself. All enums are validatedbefore being sent to the server and raise an error if not using a valid value.A number of workflow implementations are also included, for example whencreating a Document, it automatically creates the Heading work item at the sametime.Polarion Work Items are configured per installation, to give native workitemobjects (such as TestCase), the library connects to the Polarion server,downloads the list of workitems and creates them.## Installation-----------------------------### Install from PypiPylero package have been published to Pypi:`https://pypi.org/project/pylero/`Install Pylero Pypi package with:`$ pip install pylero`By default the latest package and dependencies will be installed.### Install from repoPylero is located in a git repository and can be cloned from:`$ git clone https://github.com/RedHatQE/pylero.git`From the root of the project, run:`$ pip install .`### Build pip packageAfter cloned the repo and in the dir:`$ python -m build`both wheel and bdist format will be built and the package could be found underdist directory.Then both files could be used to install the package with pip install locally.Pylero must be configured (see next section) before it can be used.## Configuration-----------------A configuration file must be filled out, which must be located either in thecurrent dir (the dir where the script is executed from) named **.pylero** or inthe user's home dir **~/.pylero**Default settings are stored in **LIBDIR/pylero.cfg**. This file should notbe modified, as it will be overwritten with any future updates.  Certificatesshould be verified automatically, but if they aren't, you can add the path toyour CA to the cert_path config option.  These are the configurable values:```    [webservice]    url=https://{your polarion web URL}/polarion    svn_repo=https://{your polarion web URL}/repo    user={your username}    password={your password}    token={your personal access token}    default_project={your default project}    #cert_path=/dir/with/certs    #disable_manual_auth=False```If the token is given it will be used for login by default, else if both user andpassword are given the password will be used for login, else if user is providedand password value is blank, it will prompt you for a password, else if none ofthem are provided it will prompt you for the token to login and access any of thepylero objects.These can also be overridden with the following environment variables:```    POLARION_URL    POLARION_REPO    POLARION_USERNAME    POLARION_PASSWORD    POLARION_TOKEN    POLARION_TIMEOUT    POLARION_PROJECT    POLARION_CERT_PATH    POLARION_DISABLE_MANUAL_AUTH```## Requirements----------------The install_requires attribute in setup.py installs the following requirements:```    suds; python_version &lt; '3.0'    suds-py3; python_version &gt;= '3.0'    click    readline; python_version &lt;= '3.6'```## Usage---------There is a pylero script installed that opens a python shell with all theobjects in the library already loaded:```    $ pylero    &gt;&gt;&gt; tr = TestRun(&quot;example&quot;, project_id=&quot;project_name&quot;)```Alternatively, you can open a python shell and import the objects that you wantto use:```    $ python    Python 2.6.6 (r266:84292, Nov 21 2013, 10:50:32)    [GCC 4.4.7 20120313 (Red Hat 4.4.7-4)] on linux2    Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.    &gt;&gt;&gt; from pylero.test_run import TestRun    &gt;&gt;&gt; tr = TestRun(&quot;example&quot;, project_id=&quot;project_name&quot;)```## Examples------------```pythonimport datetimefrom pylero.test_run import TestRunfrom pylero.test_record import TestRecordfrom pylero.work_item import TestCase, Requirementfrom pylero.document import Document# Creating a Test Run Template:tr = TestRun.create_template(&quot;myproj&quot;,                             &quot;Static Query Test&quot;,                             parent_template_id=&quot;Empty&quot;,                             select_test_cases_by=&quot;staticQueryResult&quot;,                             query=&quot;type:testcase AND status:approved&quot;)# Creating a Test Run:tr = TestRun.create(&quot;myproj&quot;, &quot;My Test Run&quot;, &quot;Static Query Test&quot;)# changing statustr.status = &quot;inprogress&quot;# getting and changing a custom attribute in TestRunarch = tr.get_custom_field(&quot;arch&quot;)arch = &quot;i386&quot;tr.set_custom_field(&quot;arch&quot;, arch)# saving the data to the servertr.update()# Adding a test recordtr.add_test_record_by_fields(test_case_id=&quot;MYPROJ-1813&quot;,                             test_result=&quot;passed&quot;,                             test_comment=&quot;went smoothly&quot;,                             executed_by=&quot;user1&quot;,                             executed=datetime.datetime.now(),                             duration=10.50,                             defect_work_item_id=&quot;MYPROJ-1824&quot;)# Getting specific WorkItemstc = TestCase(project_id=&quot;myproj&quot;, work_item_id=&quot;MYPROJ-2015&quot;)req = Requirement(project_id=&quot;myproj&quot;, work_item_id=&quot;MYPROJ-2019&quot;)# Getting required custom fields for specific Work Itemsreqs = TestCase.custom_fields(&quot;myproj&quot;)[1]# returns [u'caseimportance', u'caselevel', u'caseautomation', u'caseposneg']reqs = Requirement.custom_fields(&quot;myproj&quot;)[1]# returns [u'reqtype']# Getting the valid values for the custom enumerationstc.get_valid_field_values(&quot;caseimportance&quot;)# returns [critical, high, medium, low]# Creating a specific Work Itemtc = TestCase.create(&quot;myproj&quot;,                     &quot;Title&quot;,                     &quot;Description&quot;,                     caseimportance=&quot;high&quot;,                     caselevel=&quot;component&quot;,                     caseautomation=&quot;notautomated&quot;,                     caseposneg=&quot;positive&quot;)# Note if the custom required fields are not specified, an exception will be raised# Custom field for work items are accessed like regular attributestc.caseimportance = &quot;critical&quot;# to save changestc.update()# Creating a documentdoc = Document.create(&quot;myproj&quot;, &quot;Testing&quot;, &quot;API doc&quot;, &quot;The API Document&quot;,                      [&quot;testcase&quot;])# Adding a Functional Test Case work item to the documentwi = TestCase()wi.tcmscaseid = &quot;12345&quot;wi.title = &quot;[GUI] Host Network QoS-'named'&quot;wi.author = &quot;user1&quot;wi.tcmscategory = &quot;Functional&quot;wi.caseimportance = &quot;critical&quot;wi.status = &quot;proposed&quot;wi.setup = &quot;DC/Cluster/Host&quot;wi.teardown = &quot;&quot;&quot;Proceed with the VM Network QoS paradigm, that is creating Network QoSentities that can be shared between different networks - let's refer to thisas &quot;&quot;named&quot;&quot; QoS. This QoS entities are created via DC&gt; QoS &gt; Host Network&quot;&quot;&quot;&quot;steps = TestSteps()steps.keys = [&quot;step&quot;, &quot;expectedResult&quot;]step1 = TestStep()step1.values = [&quot;This is step 1&quot;, &quot;Step 1 expected result&quot;]step2 = TestStep()step2.values = [&quot;This is step 2&quot;, &quot;Step 2 expected result&quot;]arr_step = [step1, step2]steps.steps = arr_stepwi.test_steps = stepswi.caseautomation = &quot;notautomated&quot;wi.caseposneg = &quot;positive&quot;wi.caselevel = &quot;component&quot;new_wi = doc.create_work_item(None, wi)# Getting a list of documents in a space.docs = Document.get_documents(proj=&quot;myproj&quot;, space=&quot;Testing&quot;)# Create template from documentTestRun.create_template(&quot;myproj&quot;,                        &quot;tpl_tp_12071&quot;,                        select_test_cases_by=&quot;staticLiveDoc&quot;,                        doc_with_space=&quot;Testing/tp_12071&quot;)# create a test run based on the templatetr = TestRun.create(&quot;myproj&quot;, &quot;tp_12071_1&quot;, &quot;tpl_tp_12071&quot;)# process a recordrec = tr.records[0]rec.duration = &quot;10.0&quot;rec.executed_by = &quot;user1&quot;rec.executed = datetime.datetime.now()rec.result = &quot;passed&quot;wi = _WorkItem(uri=rec.test_case_id)steps = wi.get_test_steps()res1 = TestStepResult()res1.comment = &quot;This is the 1st result&quot;res1.result = &quot;passed&quot;res2 = TestStepResult()res2.comment = &quot;This is the 2nd result&quot;res2.result = &quot;failed&quot;rec.test_step_results = [res1, res2]tr.add_test_record_by_object(rec)# update the test record statustr.status = &quot;inprogress&quot;tr.update()# Adding a linked Item# TestCase MYPROJ-2828 verifies Requirement MYPROJ-11tc = TestCase(project_id=&quot;MYPROJ&quot;, work_item_id=&quot;MYPROJ-2828&quot;)tc.add_linked_item(&quot;MYPROJ-11&quot;, &quot;verifies&quot;)# Verify it on both objects:tc = TestCase(project_id=&quot;myproj&quot;, work_item_id=&quot;MYPROJ-2828&quot;)for linked in tc.linked_work_items:    print &quot;%s - %s&quot; % (linked.work_item_id, linked.role)req = Requirement(project_id=&quot;myproj&quot;, work_item_id=&quot;MYPROJ-11&quot;)for linked in req.linked_work_items_derived:    print &quot;%s - %s&quot; % (linked.work_item_id, linked.role)```## Before you commitIn order to ensure you are able to pass the GitHub CI build, it is recommended that you run the following commands in the base of your pylero directory``` python$ pip install pre-commit$ pre-commit autoupdate &amp;&amp; pre-commit run -a```Pre-commit will ensure that the changes you made are not in violation of PEP8 standards and automatically apply black fixes.We recommend `black` to automatically fix any pre-commit failures.``` python$ pip install black$ black &lt;edited_file.py&gt;```## Fedora RPM package build### Tito[Tito](https://github.com/rpm-software-management/tito) is a tool for managing RPM based projects using git for their source code repository.The tito config dir is [.tito](./.tito)To create a new tag and automaticlly update pylero.spec with all changelog:`$ tito tag`After tag need push the tag:`git push --follow-tags`After tag been pushed a new Copr build will be automatically triggered.### CoprFedora [Copr](https://copr.fedorainfracloud.org/) Build System help make building and managing third party package repositories easy.Each pylero new release will trigger new copr build to fedora-all, EPEL8 and EPEL9.The build is triggered by webhook defined in the project configuration.The build project on Copr is [pylero](https://copr.fedorainfracloud.org/coprs/waynesun20/pylero/).Check the target rpm package in the build to test locally.</longdescription>
</pkgmetadata>