<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![pipeline status](https://gitlab.com/biomedit/gpg-lite/badges/master/pipeline.svg)](https://gitlab.com/biomedit/gpg-lite/-/commits/master)[![coverage report](https://gitlab.com/biomedit/gpg-lite/badges/master/coverage.svg)](https://gitlab.com/biomedit/gpg-lite/-/commits/master)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![python version](https://img.shields.io/pypi/pyversions/gpg-lite.svg)](https://pypi.org/project/gpg-lite)[![license](https://img.shields.io/badge/License-LGPLv3-blue.svg)](https://www.gnu.org/licenses/lgpl-3.0)[![latest version](https://img.shields.io/pypi/v/gpg-lite.svg)](https://pypi.org/project/gpg-lite)# gpg-lite: a cross-platform python binding for GnuPG`gpg-lite` is a python API for [GPG / GnuPG](https://gnupg.org/) that offersthe following functionalities:* PGP key management: create and delete keys. Search for keys in the local  keyring.* Data encryption: encrypt and sign files.* Data decryption: decrypt files.* Signature verification: verify signatures attached to files.* Keyserver interactions: query, download and upload keys to keyservers.The design objectives behind `gpg-lite` are the following:* Cross-plateform: support for üêß, üçè, Windows.* Multi-version: support as many gpg versions as possible.* Provide custom functions for keyserver access, as the behavior of the gpg  binary is inconsistent across versions.* Reduce functionality to the most useful and frequent operations to reduce  maintenance costs.## Installation### From `PyPI`It's simple, just do:```bash[sudo] pip install [--user] gpg-lite```### From gitTo install `gpg-lite` from this git repository:```bashgit clone https://gitlab.com/biomedit/gpg-lite.gitcd gpg-lite./setup.py install [--user]```## Using gpg-liteNote that in order to use `gpg-lite` you will need to have [GnuPG](https://gnupg.org/)installed on your local machine.To get started using `gpg-lite` import the module as follows:```pythonimport gpg_lite as gpg```Most of the functionality of `gpg-lite` is provided via methods of the`GPGStore` object class. This class aims to represents an instance of a**GnuPG home directory**, the directory on your local machine that containsthe GPG keyrings and other related database files.Here is how a `GPGStore` instance is created if your GnuPG installation is*standard*. Here *standard* means that your GnuPG executable is named either`gpg` or `gpg2`, that it is part of your PATH, and that the GnuPG homedirectory is at its default location (e.g. `~/.gnupg` on Linux):```pythongpg_store = gpg.GPGStore()print(&quot;The GnuPG home directory is set to:&quot;, gpg_store.gnupg_home_dir)print(&quot;The GnuPG executable is:&quot;, gpg_store.gnupg_binary)```For **non-standard** GnuPG installations, the optional `gnupg_home_dir` and`gnupg_binary` arguments of `GPGStore()` can be used: the former allows tospecify the path of a custom GnuPG home directory, while the later allows tospecify a non-standard GnuPG executable name and/or path. Using a leading `~`character in the `gnupg_home_dir` argument is supported and expands to theuser's home directory.```pythongpg_store = gpg.GPGStore(    gnupg_home_dir=&quot;~/custom/path/gnupg_home_dir&quot;,    gnupg_binary=&quot;/usr/bin/gpg&quot;)print(&quot;The GnuPG home directory is set to:&quot;, gpg_store.gnupg_home_dir)print(&quot;The GnuPG executable is:&quot;, gpg_store.gnupg_binary)```### Generate a new key```pythongpg_store = gpg.GPGStore()key_fingerprint = gpg_store.gen_key(    key_type='RSA',    key_length=4096,    full_name=&quot;Chuck Norris&quot;,    email=&quot;chuck.norris@roundhouse.gov&quot;,    passphrase=&quot;Chuck Norris does not need one - the password needs him&quot;)print(&quot;Created new key with fingerprint:&quot;, key_fingerprint)```### Retrieve public and secret keys from local keyringRetrieving one or more keys from the local keyring is done using the`list_pub_keys()` (for public keys) and `list_sec_keys()` (for secret/privatekeys) methods:* If no `search_terms` argument is passed, all keys are returned.* If an iterable - typically a tuple or a list - of strings is passed as  `search_terms` argument, only keys whose fingerprint, key ID or user ID  matches one of the items in the iterable are returned.  Note that passing directly a string to `search_terms` is unlikely to return  the expected keys, as individual characters in the string will be iterated  over and matched).  **Important:** if multiple matching keys are found, they are **not** returned  in any particular order.* When using `list_pub_keys()`, the `sigs=True` argument can be optionally  passed to return keys with their signatures.```pythonkeys = gpg_store.list_pub_keys()for key in keys:    print(key.uids[0], key.fingerprint)key = gpg_store.list_pub_keys(search_terms=(&quot;chuck.norris&quot;,))[0]key = gpg_store.list_pub_keys(search_terms=(&quot;chuck.norris@roundhouse.gov&quot;,), sigs=True)[0]fingerprint = key.fingerprintkey = gpg_store.list_pub_keys(search_terms=(fingerprint,), sigs=True)[0]```### Export public and secret keys from local keyringKeys can be exported in both ascii-armored and binary format using`export()` and `export_secret` methods.**Important**: secret keys, when exported, are encrypted with the provided password.However, it is critical to store them in a safe, private space.```pythonfingerprint = &quot;55C5314BB9EFD19AE7CC4774D892C41917B20115&quot;pub_key_ascii = gpg_store.export(fingerprint, armor=True)pub_key_binary = gpg_store.export(fingerprint, armor=False)priv_key_ascii = gpg_store.export_secret(fingerprint, passphrase=&quot;secret&quot;, armor=True)priv_key_binary = gpg_store.export_secret(fingerprint, passphrase=&quot;secret&quot;, armor=False)```### Encrypt and sign dataData decryption is performed using the `encrypt()` method of the `GPGStore`class.```pythonimport tempfileencrypted_file = tempfile.NamedTemporaryFile(    prefix=&quot;gpg-lite_test_&quot;, suffix=&quot;.gpg&quot;, delete=False).namewith open(encrypted_file, &quot;w&quot;) as f:    gpg_store.encrypt(        source=b&quot;When Chuck Norris throws exceptions, it's across the room.\n&quot;,        recipients=[&quot;chuck.norris@roundhouse.gov&quot;],        output=f)```Optionally, the encrypted file can also be signed with a private key. Thisrequires to pass the passphrase associated with the private key.```pythonwith open(encrypted_file, &quot;w&quot;) as f:    gpg_store.encrypt(        source=b&quot;When Chuck Norris throws exceptions, it's across the room.\n&quot;,        recipients=[&quot;chuck.norris@roundhouse.gov&quot;],        output=f,        sign=&quot;chuck.norris@roundhouse.gov&quot;,        passphrase=&quot;Chuck Norris does not need one - the password needs him&quot;)```Please see `help(gpg.GPGStore.encrypt)` for more details.### Decrypt dataData decryption is performed using the `decrypt()` method of the `GPGStore`class. Here is an example, reading from the file we encrypted earlier, andoutputting the result to a new unencrypted file:```pythondecrypted_file = encrypted_file[:-4]with open(encrypted_file, &quot;rb&quot;) as f, open(decrypted_file, &quot;w&quot;) as f_out:    gpg_store.decrypt(      source=f,      output=f_out,      passphrase=&quot;Chuck Norris does not need one - the password needs him&quot;)with open(decrypted_file, &quot;r&quot;) as f:    print(&quot;Decrypted message:&quot;, &quot;&quot;.join(f.readlines()))# Delete files created in this demo:import osos.remove(encrypted_file)os.remove(decrypted_file)```### Make and verify detached signaturesA so-called detached signature is a file that contains information to verifyboth the hash of the file who was signed and the signee, i.e. the person whosigned the file.Detached signatures can be created as follows:```pythonwith tempfile.NamedTemporaryFile(delete=False) as input_file, \     tempfile.NamedTemporaryFile(delete=False) as signed_file:    # Create a new file with some text.    with open(input_file.name, mode=&quot;w&quot;) as f:        f.write(&quot;When Chuck Norris throws exceptions, it's across the room.\n&quot;)    # Sign the existing file. Note that the file must be opened in binary mode.    with open(input_file.name, mode=&quot;rb&quot;) as f_in, open(signed_file.name, mode=&quot;wb&quot;) as f_out:        with gpg_store.detach_sig(            src=f_in,            signee=fingerprint,            passphrase=&quot;Chuck Norris does not need one - the password needs him&quot;        ) as stream:            f_out.write(stream.read())    # Verify the signature.    with open(input_file.name, mode=&quot;rb&quot;) as f, open(signed_file.name, mode=&quot;rb&quot;) as f_signature:        signee_fingerprint = gpg_store.verify_detached_sig(src=f, sig=f_signature.read())print(&quot;Signee fingerprint is&quot;, signee_fingerprint)```Same as above, but using a bytestring as input instead of a file:```pythoncontent_to_sign = b&quot;Chuck Norris doesn't use web standards. The web conforms to him.\n&quot;with gpg_store.detach_sig(    src=content_to_sign,    signee=fingerprint,    passphrase=&quot;Chuck Norris does not need one - the password needs him&quot;) as stream:    signee_fingerprint = gpg_store.verify_detached_sig(src=content_to_sign, sig=stream.read())print(&quot;Signee fingerprint is&quot;, signee_fingerprint)```### Delete keys from local keyringPublic and secret/private keys**Warning:** deleted secret keys cannot be recovered or re-generated from theirpublic counterpart. Only delete secret keys if you are sure you will neverneed them again.```pythonkey = gpg_store.list_pub_keys(search_terms=(&quot;chuck.norris@roundhouse.gov&quot;,), sigs=True)[0]fingerprint = key.fingerprintgpg_store.delete_sec_keys(fingerprint)gpg_store.delete_pub_keys(fingerprint)```### Specific exceptions raised by gpg-lite`gpg-lite` has the following exceptions:* `GPGError`: exception raised when the local GnuPG executable returns an error.* `KeyserverError`: exception that is raised when a specified keyserver is not  responding, e.g. because a wrong URL was given or the keyserver is currently  not available.* `KeyserverKeyNotFoundError`: exception that is raised when given key is not  found on a specified keyserver.## Bug Reports / Feature Requests / ContributingOur bug tracker can be found on **GitLab** https://gitlab.com/biomedit/gpg-lite/issues.Public comments and discussions are also welcome on the bug tracker.Patches are always welcome ü§ó!Take into account that we use a special format for commit messages.This is due to our release management and to auto generate ourchangelog.Here are our [guidelines](./CONTRIBUTING.md).Also each change has to pass our CI [pipeline](.gitlab-ci.yml)including:* [black](https://pypi.org/project/black/) code formatting* [pylint](https://pylint.org/) lints* [unit](./test/) / [integration](./integration_test/) tests* [bandit](https://pypi.org/project/bandit/) vulnerability checks (each security warning which cannot be  avoided has to be justified)* [mypy](http://mypy-lang.org/) type checking## Supported GPG versionsWe officially support all **GPG** versions starting from _v2.2.8_.Unofficially, we also try to support _v2.0.22_.## Running the unit testsRun the following commands in `gpg-lite`'s root directory. To also run teststhat require the presence of `GnuPG` on the machine running the tests, set the`WITH_GPG=true` environment variable.```shellpython3 -m unittest discover -s ./test -vWITH_GPG=true python3 -m unittest discover -s ./test -v```</longdescription>
</pkgmetadata>