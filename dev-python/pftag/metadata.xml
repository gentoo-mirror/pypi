<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>pftag=====|Version| |MIT License| |ci|Abstract--------This software provides a string token parser, useful in cases where afixed *a priori* template string is to be resolved at run time by someprocess.Overview--------``pftag`` is a simple app that is both a stand alone client as well as apython module. Its main purpose is to parse *template strings*. Atemplate string is one where sub-parts of the string are *tokenized* bya token marker. These tokens are resolved at execution time.From a taxonomy perspective, ``pftag`` is an example of a string-based(somewhat opinionated) SGMLish parser.Installation------------Local python venv~~~~~~~~~~~~~~~~~For *on the metal* installations, ``pip`` it:.. code:: bash   pip install pftagdocker container~~~~~~~~~~~~~~~~.. code:: bash   docker pull fnndsc/pftagRunnning--------Script mode~~~~~~~~~~~To use ``pftag`` in script mode simply call the script with appropriateCLI arguments.. code:: bash   pftag --tag &quot;run-%timestamp-on-%platform-%arch.log&quot;   run-2023-03-10T13:41:58.921660-05:00-on-Linux-64bit-ELF.logModule mode~~~~~~~~~~~There are several ways to use ``pftag`` in python module mode. Perhapsthe simplest is just to declare an object and instantiate with an emptydictionary, and then call the object with the ``tag`` to process.If additional values need to be set in the declaration, use anappropriate dictionary. The dictionary keys are *identical* to thescript CLI keys (*sans* the leading ``--``):.. code:: python   from pftag import pftag   str_tag:str = r'run-%timestamp-on-%platform-%arch.log'   tagger:pftag.Pftag      = pftag.Pftag({})   d_tag:dict              = tagger(str_tag)   # The result is in the   print(d_tag['results'])Arguments---------The set of CLI arguments can also be passed in a dictionary of.. code:: python   {           &quot;CLIkey1&quot;: &quot;value1&quot;,           &quot;CLIkey2&quot;: &quot;value2&quot;,   }.. code:: html          --tag &lt;tagString&gt;           The tag string to process.           [--lookupDictAdd &lt;listOfDictionaryString&gt;]           A string list of additional named lookup dictionary tags and values to           add.           [--tagMarker &lt;mark&gt;]           The marker string that identifies a tag (default &quot;%&quot;)           [--funcMarker &lt;mark&gt;]           The marker string that pre- and post marks a function (default &quot;_&quot;).           [--funcArgMarker &lt;mark&gt;]           The marker string between function arguments and also between arg list           and function (default &quot;|&quot;).           [--funcSep &lt;mark&gt;]           The marker string separating successive function/argument constructs           (default &quot;,&quot;).           [--inputdir &lt;inputdir&gt;]           An optional input directory specifier. Reserverd for future use.           [--outputdir &lt;outputdir&gt;]           An optional output directory specifier. Reserved for future use.           [--man]           If specified, show this help page and quit.           [--verbosity &lt;level&gt;]           Set the verbosity level. The app is currently chatty at level 0 and level 1           provides even more information.           [--debug]           If specified, toggle internal debugging. This will break at any breakpoints           specified with 'Env.set_trace()'           [--debugTermsize &lt;253,62&gt;]           Debugging is via telnet session. This specifies the &lt;cols&gt;,&lt;rows&gt; size of           the terminal.           [--debugHost &lt;0.0.0.0&gt;]           Debugging is via telnet session. This specifies the host to which to connect.           [--debugPort &lt;7900&gt;]           Debugging is via telnet session. This specifies the port on which the telnet           session is listening.Available tags and functions----------------------------Adding New Tags and Lookups~~~~~~~~~~~~~~~~~~~~~~~~~~~Additional tag lookup structures can be added with either the CLI ordirectly using the python API, for example:::   # CLI   pftag --lookupDictAdd '[{&quot;credentials&quot;: {&quot;user&quot;: &quot;Jack Johnson&quot;, &quot;password&quot;: &quot;123456&quot;}}]' \         --tag &quot;At time %timestamp, user '%user' has password '%password'.&quot;or equivalently in python:.. code:: python   from pftag  import pftag   # Declare the tag processor   tagger:pftag.Pftag   = pftag.Pftag({})   # Add the &quot;credentials&quot; lookup   status:bool = tagger.lookupDict_add(     [       {&quot;credentials&quot;:           {             &quot;user&quot;:  &quot;Jack Johnson&quot;,             &quot;password&quot;: &quot;1234567&quot;           }       }     ]   )   str_tag:str = r&quot;At time %timestamp, user '%user' has password '%password'.&quot;   # and... run it!   d_tag:dict = tagger.run(str_tag)   if d_tag['status']: print(d_tag['result'])both should result in something similar to:::   At time 2023-04-28T11:36:19.448559-04:00, user 'Jack Johnson' has password '1234567'.For kicks, let’s hash the password to 10 chars:::   # CLI   pftag --lookupDictAdd '[{&quot;credentials&quot;: {&quot;user&quot;: &quot;Jack Johnson&quot;, &quot;password&quot;: &quot;123456&quot;}}]' \         --tag &quot;At time %timestamp, user '%user' has password '%password' with password hash %password_md5|10_.&quot;resulting in::   At time 2023-04-28T11:57:45.217532-04:00, user 'Jack Johnson' has password '123456' with password hash e10adc3949.The following tags are internal/reserved:::               %literal   : simply replace the tag with the word 'literal'.                            This tag is only useful in conjunction with the                            'echo' function and together they provide a means                            to inject arbitary text typically for md5 hashing.               %name      : return the os.name               %platform  : return the platform.system()               %release   : return the platform.release()               %machine   : return the platform.machine()               %arch      : return the '%s' % platform.architecture()               %timestamp : return the current timestampFunctions~~~~~~~~~The lookup from any tagged string can be further processed by thefollowing functions::           md5|&lt;chars&gt;         : perform an md5hash on the upstream, limit result                                 to &lt;chars&gt; characters                                   eg: &quot;%timestamp_md5|4_&quot;                                 replace the %timestamp in the input string with                                 an md5 hash of 4 chars of the actual timestamp.           chrplc|&lt;t&gt;|&lt;n&gt;      : replace &lt;t&gt; with &lt;n&gt; in the upstream input.                                   eg: &quot;%timestamp_chrplc|:|-_&quot;                                 replace the %timestamp in the input string with                                 the actual timestamp where all &quot;:&quot; are replaced with                                 &quot;-&quot;.           strmsk|&lt;mask&gt;       : for each '*' in mask pattern use ups tream char                                 otherwise replace with &lt;mask&gt; char .                                   eg: &quot;%platform_strmsk|l****_&quot;                                 replace the %platform in the input string with                                 a string that starts with an 'l' and don't change                                 the subsequent 4 characters. If the %platform                                 has more than 4 characters, only return the 5                                 chars as masked.           dcmname|&lt;s&gt;|&lt;tail&gt;  : replace any upstream %VAR with a DICOM formatted                                 name. If &lt;s&gt; is passed, the seed the faker module                                 with &lt;s&gt; (any string) -- this guarantees that calls                                 with that same &lt;s&gt; result in the same name. If                                 &lt;tail&gt; is passed, then append &lt;tail&gt; to the name.                                   eg: %NAME_dcmname_                                 may produce &quot;BROOKS^JOHN&quot;. Each call will have                                 a different name. However,                                   %NAME_dcmname|foobar_                                 will always generate &quot;SCHWARTZ^THOMAS&quot;. While                                   %NAME_dcmname|foobar|^ANON                                 will generate &quot;SCHWARTZ^THOMAS^ANON&quot;           echo|&lt;something&gt;    : Best used with the %literal tag for legibility, will                                 replace the tag with &lt;something&gt;. Be careful of commas                                 in the &lt;something&gt;. If they are to be preserved you                                 will need to set --funcSep to something other than a                                 comma.                                   %literal_echo|why-are-we-here?_                                 will replace the %literal with &quot;why-are-we-here&quot;.                                 This is most useful when literal data is to obscured                                 in a template. For instance:                                   %literal_echo|Subject12345,md5|5_                                 where say &quot;Subject12345&quot; is privileged information but                                 important to add to the string. In this case, we can                                 add and then hash that literal string. In future,                                 if we know all the privileged strings, we can easily                                 hash and then and lookup in any `pftag` generated                                 strings to resolve which hashes belong to which                                 subjects.Function detail---------------.. _overview-1:Overview~~~~~~~~In addition to performing a lookup on a template string token, thispackage can also process the lookup value in various ways. These processfunctions follow a Reverse Polish Notation (RPN) schema of::   tag func1(args1) func2(args2) func3(args3) ...which reading from left to right is taken as a heap from top to bottom:::   tag   func1(args1)   func2(args2)   func3(args3)where first the ``&lt;tag&gt;`` is looked up, then this lookup is processed by``&lt;func1&gt;``. The result is then processed by ``&lt;func2&gt;``, and so on andso forth, each functional optionally with a set a arguments. This RPNapproach also mirrors the standard UNIX piping schema.Syntax~~~~~~A function (or function list) that is to be applied to a ``&lt;tag&gt;`` isconnected to the tag with a ``&lt;funcMarker&gt;`` string, usually ’\_’. Thefinal function should end with the same ``&lt;funcMarker&gt;``, so::   %tag_func1,func2,...,funcN_will apply the function list in order to the tag value lookup called“tag”; each successive evaluation consuming the result of itspredecessor as input.Some functions can accept arguments. Arguments are passed to a functionwith a ``&lt;funcArgMarker&gt;`` string, typically ``|``, that also separatesarguments:::   %tag_func|a1|a2|a3_will pass ``a1``, ``a2``, and ``a3`` as parameters to “func”.Finally, several functions can be chained within the ``_``\ …\ ``_`` byseparating the ``&lt;func&gt;|&lt;argList&gt;`` constructs with commas, sopedantically::   %tag_func1|a1|a2|a3,func2|b1|b2|b3_All these special characters (tag marker, function pre- and post, argseparation, function separation) can be overriden. For instance, with aselection of::   --tagMarker &quot;@&quot; --funcMarker &quot;[&quot; --funcArgMarker &quot;,&quot; --funcSep &quot;|&quot;strings can be specified as::   @tag[func,a1,a2,a3|func2,b1,b2,b3[where preference/legibilty is left to the user.Development-----------Instructions for developers.~~~~~~~~~~~~~~~~~~~~~~~~~~~~To debug, the simplest mechanism is to trigger the internal remotetelnet session with the ``--debug`` CLI. Then, in the code, simply add``Env.set_trace()`` calls where appropriate. These can remain in thecodebase (i.e. you don’t need to delete/comment them out) since they areonly *live* when a ``--debug`` flag is passed.Testing~~~~~~~Run unit tests using ``pytest``... code:: bash   # In repo root dir:   pytest*-30-*.. |Version| image:: https://img.shields.io/docker/v/fnndsc/pftag?sort=semver   :target: https://hub.docker.com/r/fnndsc/pftag.. |MIT License| image:: https://img.shields.io/github/license/fnndsc/pftag   :target: https://github.com/FNNDSC/pftag/blob/main/LICENSE.. |ci| image:: https://github.com/FNNDSC/pftag/actions/workflows/build.yml/badge.svg   :target: https://github.com/FNNDSC/pftag/actions/workflows/build.yml</longdescription>
</pkgmetadata>