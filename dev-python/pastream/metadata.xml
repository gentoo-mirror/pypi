<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://badge.fury.io/py/pastream.svg    :target: https://badge.fury.io/py/pastream.. image:: https://travis-ci.org/tgarc/pastream.svg?branch=master    :target: https://travis-ci.org/tgarc/pastream.. image:: https://ci.appveyor.com/api/projects/status/wk52r5jy9ri7dsi9/branch/master?svg=true    :target: https://ci.appveyor.com/project/tgarc/pastream/branch/masterGIL-less Portaudio Streams for Python=====================================`pastream` builds on top of `portaudio &lt;http://www.portaudio.com/&gt;`__ and theexcellent `sounddevice &lt;http://github.com/spatialaudio/python-sounddevice&gt;`__python bindings to provide some more advanced functionality right out of thebox. Note that in addition to the pastream *library*, pastream includes a`command line application`_ for playingand recording audio files.Documentation:   http://pastream.readthedocs.io/Source code repository and issue tracker:   http://github.com/tgarc/pastream/Features========GIL-less Audio Callbacks    Having the portaudio callback implemented in C means audio interrupts can    be serviced quickly and reliably without ever needing to acquire the Python    Global Interpreter Lock (GIL). This is crucial when working with libraries    like `Pillow &lt;https://python-pillow.org/&gt;`__ which may greedily grab and    hold the GIL subsequently causing audio overruns/underruns.Input Stream iterators    Efficiently retrieve live audio capture data through an iterable. As simple as:    .. code-block:: python       import pastream as ps       for chunk in ps.chunks():           process(chunk)    See ``pastream.chunks`` and ``pastream.InputStream.chunks`` method.Built-in support for working with SoundFiles and numpy ndarrays    Seamless support for playback/recording of numpy ndarrays, generic buffer    types, and SoundFiles.Reader/Writer Threads    pastream simplifies the process of implementing stream reader and writer    threads to manipulate and/or generate data in the background while leaving    the main thread free for higher level management tasks.External Dependencies=====================There are a few compiled libraries pastream requires which *may* need to beinstalled separately depending on your operating system. Windows users areluckiest, they can skip this section entirely.`libffi &lt;https://sourceware.org/libffi/&gt;`__ (Linux/Unix/MacOSX):   Under Linux/Unix/MacOSX platforms you'll need to install the ffi   library. (For Windows users, ffi is already included with the python cffi   package.)  libffi is available through most package managers::     $ yum install libffi-devel # Red-hat/CentOS Linux     $ apt-get install libffi-dev # Ubuntu/debian derivatives     $ brew install libffi # Homebrew on OSX   More information on installing ``libffi`` is available in the cffi   documentation `here   &lt;https://cffi.readthedocs.io/en/latest/installation.html#platform-specific-instructions&gt;`__.`PortAudio &lt;http://www.portaudio.com&gt;`__ and `libsndfile &lt;http://www.mega-nerd.com/libsndfile/&gt;`__ (Linux/Unix):   Linux and Unix users will also need to install a recent version of the   ``PortAudio`` and ``libsndfile`` libraries. (For Windows and OSX, the   sounddevice and soundfile python packages include prebuilt versions for   you.) You can either install the latest available from your package manager   (e.g. ``apt-get install libportaudio2 libsndfile`` for debian/raspbian) or   install the latest stable build from the package website (Recommended).Installation============Once the above dependencies have been resolved, you can install pastream usingpip::    $ pip install pastreamBuilding From Source=====================Clone pastream with the ``--recursive`` flag::    $ git clone --recursive http://github.com/tgarc/pastreamOr, if you already have a checkout::    $ cd &lt;path/to/checkout&gt;    $ git submodule update --initFinally, do a pip install from your local working copy::    $ pip install &lt;path/to/checkout&gt;Building Documentation======================Documentation for pastream can be easily generated in a wide variety of formatsusing Sphinx. Just follow the steps below. Checkout the repository and cd into it::    $ git clone http://github.com/tgarc/pastream    $ cd pastreamInstall documentation dependencies using requirements file::    $ pip install -r docs/requirements.txtThen use the included Makefile/make.bat to generate documentation. (Here weoutput to the html format)::    $ cd docs    $ make htmlExamples========Record one second of audio to memory, then play it back:.. code-block:: python   import pastream as ps   # Use *with* statements to auto-close the stream   with ps.DuplexStream() as stream:       out = stream.record(int(stream.samplerate), blocking=True)       stream.play(out, blocking=True)Playback 10 seconds of a file, adding zero padding if the file is shorter, andrecord the result to memory:.. code-block:: python   import pastream as ps, soundfile as sf   with sf.SoundFile('my-file.wav') as infile, ps.DuplexStream.from_file(infile) as stream:       out = stream.playrec(infile, frames=10 * int(stream.samplerate), pad=-1, blocking=True)Grab (real) frequency transformed live audio stream with 50% overlap:.. code-block:: python   import pastream as ps, numpy as np   chunksize = 1024   window = np.hanning(chunksize)   for x_l in ps.chunks(chunksize, overlap=chunksize//2, channels=1):       X_l = np.fft.rfft(x_l * window)Generate a pure tone on-the-fly.. code-block:: python   import time   import pastream as ps   import numpy as np   # A simple tone generator   def tone_generator(stream, buffer, f, loop=False):       fs = stream.samplerate       # Create a time index       t = 2*np.pi*f*np.arange(len(buffer), dtype=stream.dtype) / fs       # Loop until the stream stops       while not stream.finished:           frames = buffer.write_available           if not frames:               time.sleep(0.010)               continue           # Get the write buffers directly to avoid making any extra copies           frames, part1, part2 = buffer.get_write_buffers(frames)           out = np.frombuffer(part1, dtype=stream.dtype)           np.sin(t[:len(out)], out=out)           if len(part2):               # part2 will be nonempty whenever we wrap around the end of the ring buffer               out = np.frombuffer(part2, dtype=stream.dtype)               np.sin(t[:len(out)], out=out)           # flag that we've added data to the buffer           buffer.advance_write_index(frames)           # advance the time index           t += 2*np.pi*f*frames / fs   with ps.OutputStream(channels=1) as stream:       # Set our tone generator as the source and pass along the frequency       freq = 1000       stream.set_source(tone_generator, args=(freq,))       # Busy-wait to allow for keyboard interrupt       stream.start()       while stream.active:           time.sleep(0.1)See also the included examples under `/examples`.Command Line Application========================Once installed, the pastream application should be callable from your commandline. If you're familiar with `SoX &lt;http://sox.sourceforge.net/&gt;`__ you'llnotice that some of the command line syntax is quite similar. Here are a fewexamples to help get you started.Display the help file::    $ pastream -hList available audio devices::    $ pastream -lSimultaneous play and record from the default audio device::    $ pastream input.wav output.wavPipe input from sox using the AU format and record the playback::    $ sox -n -t au - synth sine 440 | pastream - output.wavPlay a RAW file::    $ pastream -c1 -r48k -e=pcm_16 output.rawRecord 10 minutes of audio at 48kHz::    $ pastream null output.wav -r48k -d10:00</longdescription>
</pkgmetadata>