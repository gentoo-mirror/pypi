<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># GTIRBThe GrammaTech Intermediate Representation for Binaries (GTIRB) is amachine code analysis and rewriting data structure.  It is intended tofacilitate the communication of binary IR between programs performingbinary disassembly, analysis, transformation, and pretty printing.GTIRB is modeled on LLVM-IR, and seeks to serve a similarfunctionality of encouraging communication and interoperabilitybetween tools.The remainder of this file describes various aspects of GTIRB:- [Structure](#structure)- [Installing](#installing)- [Building](#building)- [Usage](#usage)# StructureGTIRB has the following structure.  Solid lines denote inheritance.Dotted lines denote reference by UUID.![GTIRB Data Structure](https://raw.githubusercontent.com/GrammaTech/gtirb/master/.gtirb.svg)## IRAn instance of GTIRB may include multiple modules (`Module`) whichrepresent loadable objects such as executables or libraries, aninter-procedural control flow graph (`IPCFG`), and Auxiliary Data tables(`AuxData`) which can hold arbitrary analysis results in user-definedformats which can easily reference other elements of the IR.  Eachmodule holds information such as symbols (`Symbol`) and sections whichthemselves hold the actual bytes and data and code blocks of themodule.  The CFG consists of basic blocks (`Block`) and control flowedges between these blocks.  Each data or code block references arange of bytes in a byte interval (`ByteInterval`).  A section mayhold one large byte interval holding all blocks---if the relativepositions of blocks in that section are defined---or may hold one byteinterval per block---if the relative positions of blocks is notdefined, e.g. for the code blocks in the `.text` section duringprogram rewriting.  Each symbol holds a pointer to the block or datumit references.## InstructionsGTIRB explicitly does NOT represent instructions or instructionsemantics but does provide symbolic operand information and access tothe bytes.  There are many *intermediate languages* (IL)s forrepresentation of instruction semantics (e.g., [BAP][]'s [BIL][],[Angr][]'s [Vex][], or [Ghidra][]'s P-code).  GTIRB works with theseor any other IL by storing instructions generally and efficiently as*raw machine-code bytes* and separately storing the symbolic andcontrol flow information.  The popular [Capstone][]/[Keystone][]decoder/encoder provide an excellent option to read and writeinstructions from/to GTIRB's machine-code byte representation withoutcommitting to any particular semantic IL.  By supporting multiple ILsand separate storage of analysis results in auxiliary data tablesGTIRB enables collaboration between independent binary analysis andrewriting teams and tools.[BAP]: https://github.com/BinaryAnalysisPlatform/bap[BIL]: https://github.com/BinaryAnalysisPlatform/bil/releases/download/v0.1/bil.pdf[Angr]: http://angr.io[Vex]: https://github.com/angr/pyvex[Ghidra]: https://www.nsa.gov/resources/everyone/ghidra/[Capstone]: https://www.capstone-engine.org[Keystone]: https://www.keystone-engine.org## Auxiliary DataGTIRB provides for the sharing of additional information,e.g. analysis results, in the form of `AuxData` objects.  These canstore maps and vectors of basic GTIRB types in a portable way. The[GTIRB manual][] describes the structure for common types of auxiliarydata such as function boundary information, type information, orresults of common analyses in [Standard AuxData Schemata][].[GTIRB manual]: https://grammatech.github.io/gtirb/[Standard AuxData Schemata]: https://grammatech.github.io/gtirb/md__aux_data.html## UUIDsEvery element of GTIRB---e.g., modules (`Module`), symbols (`Symbol`),and blocks (`Block`)---has a universally unique identifier (UUID).UUIDs allow both first-class IR components and AuxData tables toreference elements of the IR.Instructions and symbolic operands can be addressed by the class`Offset` which encapsulates a UUID (that refers to the instruction'sblock) and an offset.# InstallingPackages currently exist for easily installing GTIRB (and attendanttooling including the [ddisasm][] disassembler and [gtirb-pprinter][]pretty printer) on Windows, and Ubuntu 20. See below forinstructions. Additionally, a public Docker image exists at[grammatech/ddisasm][] with all of these tools installed. GTIRB isversioned with Major.Minor.Patch versioning where Major versionincrements will require significant source changes but should be veryrare, Minor version increments may require small source changes, andPatch version increments shouldn't break any downstream builds. We donot yet provide ABI compatibility across any version changes.[ddisasm]: https://github.com/GrammaTech/ddisasm[gtirb-pprinter]: https://github.com/GrammaTech/gtirb-pprinter[grammatech/ddisasm]: https://hub.docker.com/r/grammatech/ddisasm## Python APIThe latest stable GTIRB Python API may be installed from PyPI using pip:```shpip install gtirb```The latest unstable version of the Python API can be installed from aprebuilt wheel:```shpip install https://download.grammatech.com/gtirb/files/python/gtirb-unstable-py3-none-any.whl```It is critical that the choice of a `stable` or `unstable` package matches theinstalled ddisasm and gtirb-pprinter packages.## WindowsWindows releases are packaged as .zip files and are available athttps://download.grammatech.com/gtirb/files/windows-release/.## UbuntuPackages for Ubuntu 20 are available in the GTIRB apt repository and maybe installed per the following instructions.First, add GrammaTech's APT key.```shwget -O - https://download.grammatech.com/gtirb/files/apt-repo/conf/apt.gpg.key | apt-key add -```Next update your sources.list file.```shecho &quot;deb https://download.grammatech.com/gtirb/files/apt-repo [distribution] [component]&quot;| sudo tee -a /etc/apt/sources.list```Where:- `[distribution]` is `focal` (currently, only Ubuntu 20 packages are available)- `[component]` is either `stable`, which holds the last versioned release, or`unstable`, which holds the HEAD of the repository.Finally update your package database and install the core GTIRB tools:```shsudo apt-get updatesudo apt-get install gtirb-pprinter ddisasm```**Warning**:  There is a problem with the packages in the stable repositorythat will cause conflicts if you try `apt-get upgrade`.  In this case,uninstall and reinstall the packages you got from the GTIRB repository.  Youmay need to use `dpkg --remove` to remove the metapackages (e.g. `ddisasm`)before removing the concrete versioned packages (e.g. `ddisasm-1.5.1`).# BuildingGTIRB's C++ API should successfully build in 64-bits with GCC, Clang,and Visual Studio compilers supporting at least C++17.  GTIRB usesCMake which must be installed with at least version 3.10.The common build process looks like this:```shmkdir buildcd build# Note: You may wish to add some -D arguments to the next command. See below.cmake &lt;path/to/gtirb&gt;cmake --build .# Run the test suite.ctest```For customizing the GTIRB build, you can get a list of customization options bynavigating to your build directory and running:```shcmake -LH```## RequirementsTo build and install GTIRB, the following requirements should be installed:- [CMake][], version 3.10.0 or higher.   - Ubuntu 18 provides this version via the APT package `cmake`.   - Ubuntu 16 and earlier provide out of date versions; build from     source on those versions.- [Protobuf][], version  3.0.0 or later.  - Ubuntu 18 provides this version via the APT packages    `libprotobuf-dev` and `protobuf-compiler`.  - Ubuntu 16 and earlier provide out of date versions; build from    source on those versions.- Boost [(non-standard Ubuntu package from launchpad.net)][], version 1.67 or later.  - Ubuntu 18 only has version 1.65 in the standard repository.  See Ubuntu instructions above.[CMake]: https://cmake.org/[Protobuf]: https://developers.google.com/protocol-buffers/[(non-standard Ubuntu package from launchpad.net)]: https://launchpad.net/~mhier/+archive/ubuntu/libboost-latest# UsageGTIRB is designed to be serialized using [Google protocol buffers][](i.e., [protobuf][]), enabling [easy and efficient use from anyprogramming language](#using-serialized-gtirb-data).GTIRB may also be used through a dedicated API implemented in multiplelanguages. The APIs provide efficient data structures suitable for useby binary analysis and rewriting applications; see[below](#gtirb-api-implementations) for details.[Google protocol buffers]: https://developers.google.com/protocol-buffers/[protobuf]: https://github.com/google/protobuf/wiki## Using Serialized GTIRB DataGTIRB uses a serialized format that consists of an 8-byte signaturefollowed by serialized [protobuf][] data. The protobuf data allowsfor exploration and manipulation in the language of your choice.The [Google protocol buffers][] homepage lists the languages in whichprotocol buffers can be used directly; users of other languages canconvert the protobuf-formatted data to JSON format and then use theJSON data in their applications.The `proto` directory in this repository contains the protocol buffermessage type definitions for GTIRB. You can inspect these `.proto`files to determine the structure of the various GTIRB messagetypes. The top-level message type is `IR`.For more details, see [Using Serialized GTIRB Data](PROTOBUF.md).## GTIRB API ImplementationsThe GTIRB API is currently available in C++, Python, and Common Lisp.There is a *partial* Java API which is not ready for external use.For language-independent API information, see [GTIRBComponents](doc/general/ComponentsIndex.md). For information about thedifferent API implementations, see:  - [C++ API](doc/cpp/README.md)  - [Python API](python/README.md)  - [Common Lisp API](cl/README.md)  - Java API **incomplete**</longdescription>
</pkgmetadata>