<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># PibbleThe Pibble framework turbocharges Python web applications with a huge array of features and easy-to-use interface.# InstallationThe `pibble` package is available on PYPI. Simply run:```pip install pibble```# Features## API Integration LayerAPIs are broken up into server and client modules.### ServerAll web server APIs should be extended from `pibble.api.server.webservice.base.WebServiceAPIServerBase`. For the most part, each implementation must only register some handlers using the `pibble.api.server.webservice.base.WebServiceAPIHandlerRegistry`, which will handle all requests using a method and path. A class is not recommended to use the parent handler function, as this will provider handlers for all classes in this module that extend from `pibble.api.webservice.base.WebServiceAPIServerBase`, instead defining their own. For example, if we simply wanted to serve files from a directory over HTTP, we could use something like this:```python3import osfrom typing import Optionalfrom webob import Request, Responsefrom pibble.api.exceptions import NotFoundErrorfrom pibble.api.server.webservice.base import (    WebServiceAPIServerBase,    WebServiceAPIHandlerRegistry)class HelloWorldServer(WebServiceAPIServerBase):    &quot;&quot;&quot;    This class provides a single endpoint at the root URL displaying a simple message.    It creates a handler registry, then uses the registries decorators to configure the handler.    &quot;&quot;&quot;    handlers = WebServiceAPIHandlerRegistry()    @handlers.path(&quot;^$&quot;)    @handlers.methods(&quot;GET&quot;)    def hello_world(self, request: Request, response: Response) -&gt; None:        &quot;&quot;&quot;        Handles the request at the root and sends a simple message.          :param request webob.Request: The request object.        :param response webob.Response: The response object.        &quot;&quot;&quot;        response.text = &quot;&lt;!DOCTYPE html&gt;&lt;html lang='en_US'&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;class SimpleFileServer(HelloWorldServer):    &quot;&quot;&quot;    This class creates a more complicated handler than allows for downloading files.    It also extends the class above, inheriting the handlers above.    Classes should always name their handler registry 'handlers'. If you want to name your registry    something else, you need to add a `get_handlers()` classmethod that returns the registry for it    to be recognized by the dispatcher.    &quot;&quot;&quot;    handlers = WebServiceAPIHandlerRegistry()    base_directory = &quot;/var/www/html&quot;    @handlers.path(&quot;(?P&lt;file_path&gt;.*)&quot;)    @handlers.methods(&quot;GET&quot;)    def retrieve_file(self, request: Request, response: Response, file_path: Optional[str] = None) -&gt; None:        &quot;&quot;&quot;        Handles the request by looking for the path in ``self.base_directory``.          :param request webob.Request: The request object.        :param response webob.Response: The response object.        :param file_path str: The file path, captured from the URI.        :throws: :class:`pibble.api.exceptions.NotFoundError`        &quot;&quot;&quot;          file_path = os.path.join(self.base_directory, file_path)        if not os.path.isfile(file_path):            raise NotFoundError(&quot;Could not find file at {0}&quot;.format(file_path))          response.body = open(file_path, &quot;r&quot;).read()```The request and response parameters are webob.Request and webob.Response objects, respectively. See [The WebOb Documentation](https://docs.pylonsproject.org/projects/webob/en/stable/) for help with their usage. Note the method name does not matter, so use a naming schema relevant to your project.Deploying the API can be done using anything that conforms to wsgi standards. For development, we can deploy a server using werkzeug or gunicorn, binding to a local port with a configured listening host. Using the above server definition, we can do this with::```pythonserver = SimpleFileServer()server.configure(server = {&quot;driver&quot;: &quot;werkzeug&quot;, &quot;host&quot;: &quot;0.0.0.0&quot;, &quot;port&quot;: 9090})# Serve synchronouslyserver.serve()# Serve asynchronouslyserver.start()# Use the serverserver.stop()```For production, most servers will simply import a file and look for a globally-available `application` that conforms to WSGI standards. The easiest way to configure this is thusly:```python# wsgi.pyfrom mypackage.server import SimpleFileServerserver = SimpleFileServer()application = server.wsgi()```Pointing something like Apache's `mod_wsgi` to this `wsgi.py` file will allow Pibble to be ran through Apache.#### RPCUsing one of the RPC servers is as simple as defining functions and registering them to the server:```pythonfrom pibble.api.server.webservice.rpc.xml.server import XMLRPCServerserver = XMLRPCServer()@server.register@server.sign_request(int, int)@server.sign_response(int)def add(x, y):    return x + y@server.register@server.sign_request(int, int)@server.sign_response(int)def subtract(x, y):    return x - y@server.register@server.sign_request(int, int)@server.sign_response(int)def multiply(x, y):    return x * y@server.register@server.sign_request(int, int)@server.sign_response(float)def divide(x, y):    return x / yserver.configure(server = {&quot;driver&quot;: &quot;werkzeug&quot;, &quot;host&quot;: &quot;0.0.0.0&quot;, &quot;port&quot;: 9090})print(&quot;Running server, listening on 0.0.0.0:9090. Hit Ctrl+C to exit.&quot;)server.serve()```The base server defines methods for registration and dispatching of requests. The two implementations (XML and JSON) are responsible for parsing and formatting of requests and responses.### ClientThe simplest client possible is one that simply communicates with a webserver, and doesn't need to parse the response in any meaningful way. Unlike with servers, the base webservice API client is instantiable.```pythonfrom pibble.api.client.webservice.base import WebServiceAPIClientBasebase = WebServiceAPIClientBase(&quot;google.com&quot;)print(base.get().text)```When executing any methods via .get(), .post(), etc., you will receive a `requests.models.Response` object. See the the requests documentation for assistance with these objects. Clients use a session (r`equests.models.Session`) object to maintain some state (cookies, etc.), but should generally assume themselves to be stateless.#### RPCUsing an XML RPC Client is very simple. Once a client is instantiated, it will queue up a call to system.listMethods, a built-in RPC function that will list the methods of a client. After that, calling them is as simple as calling the method with the appropriate variables```pythonfrom pibble.api.client.webservice.rpc.xml.client import XMLRPCClientfrom pibble.api.exceptions import (    BadRequestError,    UnsupportedMethodError)client = XMLRPCClient(&quot;127.0.0.1&quot;)# Use a method with reserved charactersmethods = client[&quot;system.listMethods&quot;]()for method in methods:    # Get method signature - note this is automatically retrieved and checked when calling any function, but you can retrieve it for yourself if you need to.    signature = client[&quot;system.methodSignature&quot;](method)    return_type, parameter_types = signature[0], signature[1:] # RPC specification    print(&quot;Method {0} takes ({1}) and returns ({2})&quot;.format(method, &quot;, &quot;.join(parameter_types), return_type))try:    method.pow(1, 2, 3)except BadRequestError:    # Wrong parametersexcept BadResponseError:    # Wrong response timeexcept UnsupportedMethodError:    # Method does not exist```The base client has handlers for introspection and dispatching requests. Implementations are responsible for formatting requests and parsing responses.</longdescription>
</pkgmetadata>