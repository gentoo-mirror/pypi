<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># fastapi-limiter[![pypi](https://img.shields.io/pypi/v/fastapi-limiter.svg?style=flat)](https://pypi.python.org/pypi/fastapi-limiter)[![license](https://img.shields.io/github/license/long2ice/fastapi-limiter)](https://github.com/long2ice/fastapi-limiter/blob/master/LICENCE)[![workflows](https://github.com/long2ice/fastapi-limiter/workflows/pypi/badge.svg)](https://github.com/long2ice/fastapi-limiter/actions?query=workflow:pypi)[![workflows](https://github.com/long2ice/fastapi-limiter/workflows/ci/badge.svg)](https://github.com/long2ice/fastapi-limiter/actions?query=workflow:ci)## IntroductionFastAPI-Limiter is a rate limiting tool for [fastapi](https://github.com/tiangolo/fastapi) routes with lua script.## Requirements- [redis](https://redis.io/)## InstallJust install from pypi```shell script&gt; pip install fastapi-limiter```## Quick StartFastAPI-Limiter is simple to use, which just provide a dependency `RateLimiter`, the following example allow `2` timesrequest per `5` seconds in route `/`.```pyimport redis.asyncio as redisimport uvicornfrom fastapi import Depends, FastAPIfrom fastapi_limiter import FastAPILimiterfrom fastapi_limiter.depends import RateLimiterapp = FastAPI()@app.on_event(&quot;startup&quot;)async def startup():    redis = redis.from_url(&quot;redis://localhost&quot;, encoding=&quot;utf-8&quot;, decode_responses=True)    await FastAPILimiter.init(redis)@app.get(&quot;/&quot;, dependencies=[Depends(RateLimiter(times=2, seconds=5))])async def index():    return {&quot;msg&quot;: &quot;Hello World&quot;}if __name__ == &quot;__main__&quot;:    uvicorn.run(&quot;main:app&quot;, debug=True, reload=True)```## UsageThere are some config in `FastAPILimiter.init`.### redisThe `redis` instance of `aioredis`.### prefixPrefix of redis key.### identifierIdentifier of route limit, default is `ip`, you can override it such as `userid` and so on.```pyasync def default_identifier(request: Request):    forwarded = request.headers.get(&quot;X-Forwarded-For&quot;)    if forwarded:        return forwarded.split(&quot;,&quot;)[0]    return request.client.host + &quot;:&quot; + request.scope[&quot;path&quot;]```### callbackCallback when access is forbidden, default is raise `HTTPException` with `429` status code.```pyasync def default_callback(request: Request, response: Response, pexpire: int):    &quot;&quot;&quot;    default callback when too many requests    :param request:    :param pexpire: The remaining milliseconds    :param response:    :return:    &quot;&quot;&quot;    expire = ceil(pexpire / 1000)    raise HTTPException(        HTTP_429_TOO_MANY_REQUESTS, &quot;Too Many Requests&quot;, headers={&quot;Retry-After&quot;: str(expire)}    )```## Multiple limitersYou can use multiple limiters in one route.```py@app.get(    &quot;/multiple&quot;,    dependencies=[        Depends(RateLimiter(times=1, seconds=5)),        Depends(RateLimiter(times=2, seconds=15)),    ],)async def multiple():    return {&quot;msg&quot;: &quot;Hello World&quot;}```Not that you should note the dependencies orders, keep lower of result of `seconds/times` at the first.## Rate limiting within a websocket.While the above examples work with rest requests, FastAPI also allows easy usageof websockets, which require a slightly different approach.Because websockets are likely to be long lived, you may want to rate limit inresponse to data sent over the socket.You can do this by rate limiting within the body of the websocket handler:```py@app.websocket(&quot;/ws&quot;)async def websocket_endpoint(websocket: WebSocket):    await websocket.accept()    ratelimit = WebSocketRateLimiter(times=1, seconds=5)    while True:        try:            data = await websocket.receive_text()            await ratelimit(websocket, context_key=data)  # NB: context_key is optional            await websocket.send_text(f&quot;Hello, world&quot;)        except WebSocketRateLimitException:  # Thrown when rate limit exceeded.            await websocket.send_text(f&quot;Hello again&quot;)```## Lua scriptThe lua script used.```lualocal key = KEYS[1]local limit = tonumber(ARGV[1])local expire_time = ARGV[2]local current = tonumber(redis.call('get', key) or &quot;0&quot;)if current &gt; 0 then    if current + 1 &gt; limit then        return redis.call(&quot;PTTL&quot;, key)    else        redis.call(&quot;INCR&quot;, key)        return 0    endelse    redis.call(&quot;SET&quot;, key, 1, &quot;px&quot;, expire_time)    return 0end```## LicenseThis project is licensed under the[Apache-2.0](https://github.com/long2ice/fastapi-limiter/blob/master/LICENCE) License.</longdescription>
</pkgmetadata>