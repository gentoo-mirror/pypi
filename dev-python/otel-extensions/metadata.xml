<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># otel-extensions-python: OpenTelemetry Extensions for PythonOpenTelemetry Extensions for Python is a collection of helper classes, functions, and decorators to facilitate the use of the [OpenTelemetry Python API &amp; SDK packages](https://opentelemetry.io/docs/instrumentation/python/)## Version SupportPython &gt;= 3.6## Installation### pip installYou can install through pip using:```shpip install otel-extensions```(you may need to run `pip` with root permission: `sudo pip install otel-extensions`)### SetuptoolsInstall via [Setuptools](http://pypi.python.org/pypi/setuptools).```shpython setup.py install --user```(or `sudo python setup.py install` to install the package for all users)## Features### Tracer Provider Initialization```pythonfrom otel_extensions import init_telemetry_provider, TelemetryOptions# Provide options for telemetry provider# Alternatively, any of the following options can be specified through# environment variables with the equivalent nameoptions = TelemetryOptions(    # OTLP receiver endpoint    OTEL_EXPORTER_OTLP_ENDPOINT=&quot;http://localhost:4317/&quot;,    # CA bundle for TLS verification of endpoint (if endpoint scheme is https)    OTEL_EXPORTER_OTLP_CERTIFICATE=&quot;/path/to/ca/bundle&quot;,    # protocol for OTLP receiver (supported: gprc | http/protobuf | custom)    OTEL_EXPORTER_OTLP_PROTOCOL=&quot;grpc&quot;,    # Custom span exporter class name (needed if protocol set to 'custom')    OTEL_EXPORTER_CUSTOM_SPAN_EXPORTER_TYPE=&quot;pkg.ClassName&quot;,    # Name of service    OTEL_SERVICE_NAME=&quot;My Service&quot;,    # Processor type    #   batch:  use BatchSpanProcessor    #   simple: use SimpleSpanProcessor    OTEL_PROCESSOR_TYPE=&quot;batch&quot;,    # Optional parent span id.  Will be injected into current context    TRACEPARENT=&quot;001233454656....&quot;)# Initialize the global tracer providerinit_telemetry_provider(options)```### Instrumentation DecoratorYou can use the `@instrumented` decorator to automatically wrap a span around a function or method.(As of version 0.2.0, the decorator can support coroutine functions defined as `async def` as well as normal functions)```pythonfrom otel_extensions import init_telemetry_provider, instrumentedimport asyncioasync def main():    foo()    await async_foo()    @instrumenteddef foo():    &quot;&quot;&quot;Creates a span named 'foo'&quot;&quot;&quot;    bar()@instrumented(span_name=&quot;custom span name&quot;)def bar():    &quot;&quot;&quot;Creates a span named 'custom span name'&quot;&quot;&quot;    print(&quot;Hello World&quot;)    @instrumented(span_attributes={&quot;attr1&quot;: &quot;val1&quot;, &quot;attr2&quot;: &quot;val2&quot;})def fn_with_attrs():    &quot;&quot;&quot;Creates a span named 'fn_with_attrs' and sets key/value pairs    from `span_attributes` as span attributes&quot;&quot;&quot;    print(&quot;Hello World&quot;)@instrumentedasync def async_foo():    &quot;&quot;&quot;Creates a span named 'async_foo'&quot;&quot;&quot;    await async_bar()@instrumented(span_name=&quot;custom span name&quot;)async def async_bar():    &quot;&quot;&quot;Creates a span named 'custom span name'&quot;&quot;&quot;    print(&quot;Hello World&quot;)    @instrumented(span_name=&quot;custom span name&quot;)async def async_bar():    &quot;&quot;&quot;Creates a span named 'custom span name'&quot;&quot;&quot;    print(&quot;Hello World&quot;)    @instrumented(span_attributes={&quot;attr1&quot;: &quot;val1&quot;, &quot;attr2&quot;: &quot;val2&quot;})async def async_fn_with_attrs():    &quot;&quot;&quot;Creates a span named 'async_fn_with_attrs' and sets key/value pairs    from `span_attributes` as span attributes&quot;&quot;&quot;    print(&quot;Hello World&quot;)    if __name__ == '__main__':    # init telemetry provider (using options from environment variables)    init_telemetry_provider()    asyncio.run(main())```### Trace Context helper classThe `TraceContextCarrier` class is useful when propagating context across process or thread boundaries```pythonfrom otel_extensions import TraceContextCarrierfrom threading import Threaddef main_program():    ...    # capture current context    ctx = TraceContextCarrier()    thread = Thread(thread_func, args=(ctx))    thread.start()    ...def thread_func(ctx: TraceContextCarrier):    # attach to context stored in ctx    ctx.attach()    ...```Also, the `TraceContextCarrier` class can attach to context stored in the `TRACEPARENT` environment variable.Note that this is done automatically when calling the `init_telemetry_provider()` function.```pythonfrom otel_extensions import TraceContextCarrierTraceContextCarrier.attach_from_env()````TraceContextCarrier` can also inject the current context into the `TRACEPARENT` environment variable.This is useful for context propagation when using `Popen` to create a subprocess```pythonfrom otel_extensions import TraceContextCarrierfrom subprocess import PopenTraceContextCarrier.inject_to_env()process = Popen(...)```### Log messages as eventsThe `TraceEventLogHandler` class is a `logging.Handler` class that creates events for any log message that occurs in a span.```pythonfrom otel_extensions import TraceEventLogHandler, init_telemetry_provider, get_tracerimport logginginit_telemetry_provider()logging.basicConfig()logging.getLogger(__name__).addHandler(TraceEventLogHandler())with get_tracer(__name__).start_as_current_span(&quot;foo&quot;) as span:    logging.getLogger(__name__).warning(&quot;Some log message&quot;)    # 'Some Log message' will be created as an event in 'span',    # as if you had called    # span.add_event('Some Log message')```</longdescription>
</pkgmetadata>