<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>========================================================================    GC3Pie |gitter|========================================================================.. |gitter| image:: https://badges.gitter.im/gc3pie/chat.svg   :alt: Join the chat at https://gitter.im/gc3pie/chat   :target: https://gitter.im/gc3pie/chat?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge.. This file follows reStructuredText markup syntax; see   http://docutils.sf.net/rst.html for more informationGC3Pie is a python package for executing computational workflowsconsisting of tasks with complex inter-dependencies. GC3Pie accomplishesthis by defining a run-time task list in which a task can only beexecuted once all upstream task dependencies have been successfulllycompleted. In contrast to other workflow managers, GC3Pie accplicationsare written in python and not a markup language. The advantage is thatthis makes it trivial to write highly complex workflows. GC3Pies rootsare in shared-nothing achitectures (server-less for example) and can beconfigured to use backends such as batch clusters or clouds.GC3Pie is a suite of Python classes (and command-line tools builtupon them) to aid in submitting and controlling batch jobs to clustersand grid resources seamlessly. GC3Pie aims at providing thebuilding blocks by which Python scripts that combine severalapplications in a dynamic workflow can be quickly developed.The GC3Pie suite is comprised of three main components: * GC3Libs: A python package for controlling the life-cycle of a Grid or batch computational job * GC3Utils: Command-line tools exposing the main functionality provided by GC3Libs * GC3Apps: Driver scripts to run large job campaignsGC3Libs=======GC3Libs provides services for submitting computational jobs to Gridsand batch systems and controlling their execution, persisting jobinformation, and retrieving the final output.GC3Libs takes an application-oriented approach to batch computing. Ageneric ``Application`` class provides the basic operations forcontrolling remote computations, but different ``Application``subclasses can expose adapted interfaces, focusing on the mostrelevant aspects of the application being represented. Specificinterfaces are already provided for the GAMESS_ and Rosetta_ suites;new ones can be easily created by subclassing the generic``Application`` class.GC3Utils========Most of the time users have lots of different accounts on severaldiverse resources. The idea underlying GC3Utils is that a user cansubmit and control a computational job from one single place with a fewsimple commands.Commands are provided to submit a job (``gsub``), check its runningstatus (``gstat``), get a snapshot of the output files (``gget``,``gtail``), or cancel it (``gkill``).GC3Apps=======There is a need in some scientific communities, to run large jobcampaigns to analyze a vast number of data files with the sameapplication. The single-job level of control implemented by GC3Utilsin this case is not enough: you would have to implement &quot;glue scripts&quot;to control hundreds or thousand scripts at once. GC3Pie has provisonsfor this, in the form of re-usable Python classes that implement asingle point of control for job families.The GC3Apps scripts are driver scripts that run job campaigns usingthe supported applications on a large set of input data. They can beused in production as-is, or adapted to suit your data processing needs.A Simple Example================There are several examples and a tutorial in the examples directory... code-block:: python    import sys    import time    import gc3libs    class GdemoSimpleApp(gc3libs.Application):        &quot;&quot;&quot;        This simple application will run `/bin/hostname`:file: on the remote host,        and retrieve the output in a file named `stdout.txt`:file: into a        directory `GdemoSimpleApp_output`:file: inside the current directory.        &quot;&quot;&quot;        def __init__(self):            gc3libs.Application.__init__(                self,                # the following arguments are mandatory:                arguments = [&quot;/bin/hostname&quot;],                inputs = [],                outputs = [],                output_dir = &quot;./GdemoSimpleApp_output&quot;,                # the rest is optional and has reasonable defaults:                stdout = &quot;stdout.txt&quot;,)    # Create an instance of GdemoSimpleApp    app = GdemoSimpleApp()    # Create an instance of `Engine` using the configuration file present    # in your home directory.    engine = gc3libs.create_engine()    # Add your application to the engine. This will NOT submit your    # application yet, but will make the engine awere *aware* of the    # application.    engine.add(app)    # in case you want to select a specific resource, call    # `Engine.select_resource(&lt;resource_name&gt;)`    if len(sys.argv)&gt;1:        engine.select_resource(sys.argv[1])    # Periodically check the status of your application.    while app.execution.state != gc3libs.Run.State.TERMINATED:        print &quot;Job in status %s &quot; % app.execution.state        # `Engine.progress()` will do the GC3Pie magic:        # submit new jobs, update status of submitted jobs, get        # results of terminating jobs etc...        engine.progress()        # Wait a few seconds...        time.sleep(1)    print &quot;Job is now terminated.&quot;    print &quot;The output of the application is in `%s`.&quot; %  app.output_dirThis is what it looks like when the code is run:.. code-block:: text    $ python gdemo_simple.py localhost    gdemo_simple.py: [2019-01-21 14:37:53] INFO    : Computational resource 'localhost' initialized successfully.    Job in status NEW    gdemo_simple.py: [2019-01-21 14:37:55] INFO    : Successfully submitted GdemoSimpleApp@7f07aa094a90 to: localhost    Job in status SUBMITTED    Job is now terminated.    The output of the application is in `./GdemoSimpleApp_output`.The output file looks as follows:.. code-block:: text    $ cat GdemoSimpleApp_output/stdout.txt    93607d089233Installation instructions and further reading=============================================For up-to-date information, please read the GC3Pie documentation at:http://gc3pie.readthedocs.io/Installation instructions are in the `INSTALL.rst`_ file (in thissame directory), or can be read online at:http://gc3pie.readthedocs.io/en/latest/users/install.html.. _`INSTALL.rst`: https://github.com/uzh/gc3pie/blob/master/docs/users/install.rstLicense=======The GC3Pie library is free software; you can redistribute it and/ormodify it under the terms of the GNU Lesser General PublicLicense as published by the Free Software Foundation; eitherversion 2.1 of the License, or (at your option) any later version.This library is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the `GNULesser General Public License`_ for more details.A copy of the GNU Lesser General Public License is in file `LICENSE.md`_... References.. _GC3Pie: http://gc3pie.googlecode.com/.. _GAMESS: http://www.msg.chem.iastate.edu/gamess/.. _Rosetta: http://www.rosettacommons.org/.. _`GNU Lesser General Public License`: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.. _`LICENSE.md`: https://github.com/uzh/gc3pie/blob/master/LICENSE.md.. (for Emacs only)..  Local variables:  mode: rst  End:</longdescription>
</pkgmetadata>