<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pytest-flask-sqlalchemy[![Build Status](https://travis-ci.org/jeancochrane/pytest-flask-sqlalchemy.svg?branch=master)](https://travis-ci.org/jeancochrane/pytest-flask-sqlalchemy) ![PyPI - Python Version](https://img.shields.io/pypi/pyversions/Django.svg)A [pytest](https://docs.pytest.org/en/latest/) plugin providing fixtures for running tests intransactions using [Flask-SQLAlchemy](http://flask-sqlalchemy.pocoo.org/latest/).## Contents- [**Motivation**](#motivation)- [**Quick examples**](#quick-examples)- [**Usage**](#usage)    - [Installation](#installation)        - [From PyPi](#from-pypi)        - [Development version](#development-version)        - [Supported backends](#supported-backends)    - [Configuration](#configuration)        - [Conftest setup](#conftest-setup)        - [Test configuration](#test-configuration)            - [`mocked-engines`](#mocked-engines)            - [`mocked-sessions`](#mocked-sessions)            - [`mocked-sessionmakers`](#mocked-sessionmakers)        - [Writing transactional tests](#writing-transactional-tests)    - [Fixtures](#fixtures)        - [`db_session`](#db_session)        - [`db_engine`](#db_engine)    - [Enabling transactions without fixtures](#enabling-transactions-without-fixtures)- [**Development**](#development)    - [Running the tests](#running-the-tests)    - [Acknowledgements](#acknowledgements)    - [Copyright](#copyright)## &lt;a name=&quot;motivation&quot;&gt;&lt;/a&gt;MotivationInspired by [Django's built-in support for transactionaltests](https://jeancochrane.com/blog/django-test-transactions), this plugin seeks to provide comprehensive, easy-to-use Pytest fixtures for wrapping tests indatabase transactions for [Flask-SQLAlchemy](http://flask-sqlalchemy.pocoo.org/latest/)apps. The goal is to make testing stateful Flask-SQLAlchemy applications easier byproviding fixtures that permit the developer to **make arbitrary database updateswith the confidence that any changes made during a test will roll back** once the test exits.## &lt;a name=&quot;quick-examples&quot;&gt;&lt;/a&gt;Quick examplesUse the [`db_session` fixture](#db_session) to make **database updates that won't persist beyondthe body of the test**:```pythondef test_a_transaction(db_session):   row = db_session.query(Table).get(1)    row.name = 'testing'   db_session.add(row)   db_session.commit()def test_transaction_doesnt_persist(db_session):   row = db_session.query(Table).get(1)    assert row.name != 'testing'```The [`db_engine` fixture](#db_engine) works the same way, but **copies the API ofSQLAlchemy's [Engineobject](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine)**:```pythondef test_a_transaction_using_engine(db_engine):    with db_engine.begin() as conn:        row = conn.execute('''UPDATE table SET name = 'testing' WHERE id = 1''')def test_transaction_doesnt_persist(db_engine):    row_name = db_engine.execute('''SELECT name FROM table WHERE id = 1''').fetchone()[0]    assert row_name != 'testing' ```Use [configuration properties](#test-configuration) to**mock database connections in an app and enforce nested transactions**,allowing any method from the codebase to run inside a test with the assurancethat any database changes made will be rolled back at the end of the test:```ini# In setup.cfg[tool:pytest]mocked-sessions=database.db.sessionmocked-engines=database.engine``````python# In database.pydb = flask_sqlalchemy.SQLAlchemy()engine = sqlalchemy.create_engine('DATABASE_URI')``````python# In models.pyclass Table(db.Model):    __tablename__ = 'table'    id = db.Column(db.Integer, primary_key=True)    name = db.Column(db.String(80))    def set_name(new_name):        self.name = new_name        db.session.add(self)        db.session.commit()``````python# In tests/test_set_name.pydef test_set_name(db_session):    row = db_session.query(Table).get(1)    row.set_name('testing')    assert row.name == 'testing'def test_transaction_doesnt_persist(db_session):   row = db_session.query(Table).get(1)    assert row.name != 'testing'```# &lt;a name=&quot;usage&quot;&gt;&lt;/a&gt;Usage## &lt;a name=&quot;installation&quot;&gt;&lt;/a&gt;Installation### &lt;a name=&quot;from-pypi&quot;&gt;&lt;/a&gt;From PyPiInstall using pip:```pip install pytest-flask-sqlalchemy```Once installed, pytest will detect the plugin automatically during test collection.For basic background on using third-party plugins with pytest, see the [pytestdocumentation](https://docs.pytest.org/en/latest/plugins.html?highlight=plugins).### &lt;a name=&quot;development-version&quot;&gt;&lt;/a&gt;Development versionClone the repo from GitHub and switch into the new directory:```git clone git@github.com:jeancochrane/pytest-flask-sqlalchemy.gitcd pytest-flask-sqlalchemy```You can install using pip:```pip install .```### &lt;a name=&quot;supported-backends&quot;&gt;&lt;/a&gt;Supported backendsSo far, pytest-flask-sqlalchemy has been most extensively tested againstPostgreSQL 9.6. It should theoretically work with any backend that is supportedby SQLAlchemy, but Postgres is the only backend that is currently tested by thetest suite.Official support for SQLite and MySQL is [planned for a futurerelease](https://github.com/jeancochrane/pytest-flask-sqlalchemy/issues/3).In the meantime, if you're using one of those backends and you run in toproblems, we would greatly appreciate your help! [Open anissue](https://github.com/jeancochrane/pytest-flask-sqlalchemy/issues/new) ifsomething isn't working as you expect.## &lt;a name=&quot;configuration&quot;&gt;&lt;/a&gt;Configuration### &lt;a name=&quot;conftest-setup&quot;&gt;&lt;/a&gt;Conftest setupThis plugin assumes that a fixture called `_db` has beendefined in the root conftest file for your tests. The `_db` fixture shouldexpose access to a valid [SQLAlchemy `Session` object](http://docs.sqlalchemy.org/en/latest/orm/session_api.html?highlight=session#sqlalchemy.orm.session.Session) that can interact with your database,for example via the [`SQLAlchemy` initialization class](http://flask-sqlalchemy.pocoo.org/2.3/api/#flask_sqlalchemy.SQLAlchemy)that configures Flask-SQLAlchemy.The fixtures in this plugin depend on this `_db` fixture to access yourdatabase and create nested transactions to run tests in. **You must definethis fixture in your `conftest.py` file for the plugin to work.**An example setup that will produce a valid `_db` fixture could look like this(this example comes from the [test setup](./tests/_conftest.py#L25-L61) for this repo):```python@pytest.fixture(scope='session')def database(request):    '''    Create a Postgres database for the tests, and drop it when the tests are done.    '''    pg_host = DB_OPTS.get(&quot;host&quot;)    pg_port = DB_OPTS.get(&quot;port&quot;)    pg_user = DB_OPTS.get(&quot;username&quot;)    pg_db = DB_OPTS[&quot;database&quot;]    init_postgresql_database(pg_user, pg_host, pg_port, pg_db)    @request.addfinalizer    def drop_database():        drop_postgresql_database(pg_user, pg_host, pg_port, pg_db, 9.6)@pytest.fixture(scope='session')def app(database):    '''    Create a Flask app context for the tests.    '''    app = Flask(__name__)    app.config['SQLALCHEMY_DATABASE_URI'] = DB_CONN    return app@pytest.fixture(scope='session')def _db(app):    '''    Provide the transactional fixtures with access to the database via a Flask-SQLAlchemy    database connection.    '''    db = SQLAlchemy(app=app)    return db```Alternatively, if you already have a fixture that sets up database access foryour tests, you can define `_db` to return that fixture directly:```python@pytest.fixture(scope='session')def database():    # Set up all your database stuff here    # ...    return db@pytest.fixture(scope='session')def _db(database):    return database```### &lt;a name=&quot;test-configuration&quot;&gt;&lt;/a&gt;Test configurationThis plugin allows you to configure a few different properties in a `setup.cfg` test configuration file in order to handle the specific database connection needsof your app. For basic background on setting up pytest configuration files, seethe [pytest docs](https://docs.pytest.org/en/latest/customize.html#adding-default-options).All three configuration properties ([`mocked-engines`](#mocked-engines),[`mocked-sessions`](#mocked-sessions), and [`mocked-sessionmakers`](#mocked-sessionmakers))work by **[patching](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch)one or more specified objects during a test**, replacing them with equivalent objects whosedatabase interactions will run inside of a transaction and ultimately berolled back when the test exits. Using these patches, you can call methods fromyour codebase that alter database state with the knowledge that no changes will persistbeyond the body of the test.The configured patches are only applied in tests where a transactional fixture(either [`db_session`](#db_session) or [`db_engine`](#db_engine)) is includedin the test function arguments.#### &lt;a name=&quot;mocked-engines&quot;&gt;&lt;/a&gt;`mocked-engines`The `mocked-engines` property directs the plugin to [patch](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch)objects in your codebase, typically SQLAlchemy [Engine](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine)instances, replacing them with the [`db_engine` fixture](#db_engine) such thatany database updates performed by the objects get rolled back at the end of the test. The value for this property should be formatted as a whitespace-separated list of standard Python import paths, like `database.engine`. This property is **optional**.Example:```python# In database.pyengine = sqlalchemy.create_engine(DATABASE_URI)``````ini# In setup.cfg[tool:pytest]mocked-engines=database.engine```To patch multiple objects at once, separate the paths with a whitespace:```ini# In setup.cfg[tool:pytest]mocked-engines=database.engine database.second_engine```#### &lt;a name=&quot;mocked-sessions&quot;&gt;&lt;/a&gt;`mocked-sessions`The `mocked-sessions` property directs the plugin to [patch](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch)objects in your codebase, typically SQLAlchemy [Session](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine)instances, replacing them with the [`db_session`](#db_session) fixture such thatany database updates performed by the objects get rolled back at the end of the test. The value for this property should be formatted as a whitespace-separated list of standard Python import paths, like `database.db.session`. This property is **optional**.Example:```python# In database.pydb = SQLAlchemy()``````ini# In setup.cfg[tool:pytest]mocked-sessions=database.db.session```To patch multiple objects at once, separate the paths with a whitespace:```ini# In setup.cfg[tool:pytest]mocked-sessions=database.db.session database.second_db.session```#### &lt;a name=&quot;mocked-sessionmakers&quot;&gt;&lt;/a&gt;`mocked-sessionmakers`The `mocked-sessionmakers` property directs the plugin to [patch](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch)objects in your codebase, typically instances of [SQLAlchemy's `sessionmaker`factory](http://docs.sqlalchemy.org/en/latest/orm/session_api.html?highlight=sessionmaker#sqlalchemy.orm.session.sessionmaker),replacing them with a mocked class that will return the transactional[`db_session`](#db_session) fixture. This can be useful if you havepre-configured instances of sessionmaker objects that you import in the codeto spin up sessions on the fly.The value for this property should be formatted as a whitespace-separated list of standard Python import paths, like `database.WorkerSessionmaker`. This property is **optional**.Example:```python# In database.pyWorkerSessionmaker = sessionmaker()``````ini[tool:pytest]mocked-sessionmakers=database.WorkerSessionmaker```To patch multiple objects at once, separate the paths with a whitespace.```ini[tool:pytest]mocked-sessionmakers=database.WorkerSessionmaker database.SecondWorkerSessionmaker```### &lt;a name=&quot;writing-transactional-tests&quot;&gt;&lt;/a&gt;Writing transactional testsOnce you have your [conftest file set up](#conftest-setup) and you've [overrided thenecessary connectables in your test configuration](#test-configuration), you're readyto write some transactional tests. Simply import one of the module's [transactionalfixtures](#fixtures) in your test signature, and the test will be wrapped in a transaction.Note that by default, **tests are only wrapped in transactions if they import one ofthe [transactional fixtures](#fixtures) provided by this module.** Tests that do notimport the fixture will interact with your database without opening a transaction:```python# This test will be wrapped in a transaction.def transactional_test(db_session):    ...    # This test **will not** be wrapped in a transaction, since it does not import a# transactional fixture.def non_transactional_test():    ...```The fixtures provide a way for you to control which tests require transactions andwhich don't. This is often useful, since avoiding transaction setup can speed uptests that don't interact with your database.For more information about the transactional fixtures provided by this module, read onto the [fixtures section](#fixtures). For guidance on how to automatically enabletransactions without having to specify fixtures, see the section on [enabling transactionswithout fixtures](#enabling-transactions-without-fixtures).## &lt;a name=&quot;fixtures&quot;&gt;&lt;/a&gt;FixturesThis plugin provides two fixtures for performing database updates inside nestedtransactions that get rolled back at the end of a test: [`db_session`](#db_session) and[`db_engine`](#db_engine). The fixtures provide similar functionality, butwith different APIs.### &lt;a name=&quot;db_session&quot;&gt;&lt;/a&gt;`db_session`The `db_session` fixture allows you to perform direct updates that will berolled back when the test exits. It exposes the same API as [SQLAlchemy's`scoped_session` object](http://docs.sqlalchemy.org/en/latest/orm/contextual.html#sqlalchemy.orm.scoping.scoped_session).Including this fixture as a function argument of a test will activate any mocks that are definedby the configuration properties [`mocked-engines`](#mocked-engines), [`mocked-sessions`](#mocked-sessions),or [`mocked-sessionmakers`](#mocked-sessionmakers) in the test configuration file forthe duration of that test.Example:```pythondef test_a_transaction(db_session):   row = db_session.query(Table).get(1)    row.name = 'testing'   db_session.add(row)   db_session.commit()def test_transaction_doesnt_persist(db_session):   row = db_session.query(Table).get(1)    assert row.name != 'testing'```### &lt;a name=&quot;db_engine&quot;&gt;&lt;/a&gt;`db_engine`Like [`db_session`](#db_session), the `db_engine` fixture allows you to perform direct updatesagainst the test database that will be rolled back when the test exits. It isan instance of Python's built-in [`MagicMock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock)class, with a spec set to match the API of [SQLAlchemy's`Engine`](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine) object.Only a few `Engine` methods are exposed on this fixture:- `db_engine.begin`: begin a new nested transaction ([API docs](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine.begin))- `db_engine.execute`: execute a raw SQL query ([API docs](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine.execute)) - `db_engine.raw_connection`: return a raw DBAPI connection ([API docs](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine.raw_connection)) Since `db_engine` is an instance of `MagicMock` with an `Engine` spec, othermethods of the `Engine` API can be called, but they will not perform any usefulwork.Including this fixture as a function argument of a test will activate any mocks that are definedby the configuration properties [`mocked-engines`](#mocked-engines), [`mocked-sessions`](#mocked-sessions),or [`mocked-sessionmakers`](#mocked-sessionmakers) in the test configuration file forthe duration of that test.Example:```pythondef test_a_transaction_using_engine(db_engine):    with db_engine.begin() as conn:        row = conn.execute('''UPDATE table SET name = 'testing' WHERE id = 1''')def test_transaction_doesnt_persist(db_engine):    row_name = db_engine.execute('''SELECT name FROM table WHERE id = 1''').fetchone()[0]    assert row_name != 'testing' ```## &lt;a name=&quot;enabling-transactions-without-fixtures&quot;&gt;&lt;/a&gt;Enabling transactions without fixturesIf you know you want to make all of your tests transactional, it can be annoying to haveto specify one of the [fixtures](#fixtures) in every test signature.The best way to automatically enable transactions without having to include an extra fixturein every test is to wire up an[autouse fixture](https://docs.pytest.org/en/latest/fixture.html#autouse-fixtures-xunit-setup-on-steroids)for your test suite. This can be as simple as:```python# Automatically enable transactions for all tests, without importing any extra fixtures.@pytest.fixture(autouse=True)def enable_transactional_tests(db_session):    pass```In this configuration, the `enable_transactional_tests` fixture will be automatically used inall tests, meaning that `db_session` will also be used. This way, all tests will be wrappedin transactions without having to explicitly require either `db_session` or `enable_transactional_tests`.# &lt;a name=&quot;development&quot;&gt;&lt;/a&gt;Development## &lt;a name=&quot;running-the-tests&quot;&gt;&lt;/a&gt;Running the testsTo run the tests, start by installing a development version of the plugin thatincludes test dependencies:```pip install -e .[tests]```Next, export a [database connection string](http://docs.sqlalchemy.org/en/latest/core/engines.html#database-urls)that the tests can use (the database referenced by the string will be createdduring test setup, so it does not need to exist):```export TEST_DATABASE_URL=&lt;db_connection_string&gt;```Finally, run the tests using pytest:```pytest```## &lt;a name=&quot;acknowledgements&quot;&gt;&lt;/a&gt;AcknowledgementsThis plugin was initially developed for testing[Dedupe.io](https://dedupe.io), a web app for record linkage and entityresolution using machine learning. Dedupe.io is built and maintainedby [DataMade](https://datamade.us).The code is greatly indebted to [Alex Michael](https://github.com/alexmic),whose blog post [&quot;Delightful testing with pytest andFlask-SQLAlchemy&quot;](http://alexmic.net/flask-sqlalchemy-pytest/) helpedestablish the basic approach on which this plugin builds.Many thanks to [Igor Ghisi](https://github.com/igortg/), who donated the PyPipackage name. Igor had been working on a similar plugin and proposed combiningefforts. Thanks to Igor, the plugin name is much stronger.## &lt;a name=&quot;copyright&quot;&gt;&lt;/a&gt;CopyrightCopyright (c) 2019 Jean Cochrane and DataMade. Released under the MIT License.Third-party copyright in this distribution is noted where applicable.</longdescription>
</pkgmetadata>