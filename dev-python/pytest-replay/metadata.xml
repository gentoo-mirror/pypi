<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=============pytest-replay=============.. image:: http://img.shields.io/pypi/v/pytest-replay.svg    :target: https://pypi.python.org/pypi/pytest-replay.. image:: https://anaconda.org/conda-forge/pytest-replay/badges/version.svg    :target: https://anaconda.org/conda-forge/pytest-replay.. image:: https://github.com/ESSS/pytest-replay/workflows/build/badge.svg    :target: https://github.com/ESSS/pytest-replay/actions?query=workflow%3Abuild.. image:: https://img.shields.io/pypi/pyversions/pytest-replay.svg    :target: https://pypi.python.org/pypi/pytest-replay.. image:: https://img.shields.io/badge/code%20style-black-000000.svg    :target: https://github.com/psf/blackSaves previous test runs and allow re-execute previous pytest runs to reproduce crashes or flaky tests----This `pytest`_ plugin was generated with `Cookiecutter`_ along with `@hackebrot`_'s `Cookiecutter-pytest-plugin`_ template.Features--------This plugin helps to reproduce random or flaky behavior when running tests with xdist. ``pytest-xdist`` executes testsin a non-predictable order, making it hard to reproduce a behavior seen in CI locally because there's no convenient wayto track which test executed in which worker.This plugin records the executed node ids by each worker in the directory given by ``--replay-record-dir=&lt;dir&gt;`` flag,and a ``--replay=&lt;file&gt;`` can be used to re-run the tests from a previous run. For example::    $ pytest -n auto --replay-record-dir=build/tests/replayThis will generate files with each line being a ``json`` with the following content:node identification, start time, end time and outcome. It is interesting to notethat usually the node id is repeated twice, that is necessary in case of a testsuddenly crashes we will still have the record of that test started. After thetest finishes, ``pytest-replay`` will add another ``json`` line with thecomplete information.That is also useful to analyze concurrent tests which might have some kind ofrace condition and interfere in each other.For example worker ``gw1`` will generate a file``.pytest-replay-gw1.txt`` with contents like this::    {&quot;nodeid&quot;: &quot;test_foo.py::test[1]&quot;, &quot;start&quot;: 0.000}    {&quot;nodeid&quot;: &quot;test_foo.py::test[1]&quot;, &quot;start&quot;: 0.000, &quot;finish&quot;: 1.5, &quot;outcome&quot;: &quot;passed&quot;}    {&quot;nodeid&quot;: &quot;test_foo.py::test[3]&quot;, &quot;start&quot;: 1.5}    {&quot;nodeid&quot;: &quot;test_foo.py::test[3]&quot;, &quot;start&quot;: 1.5, &quot;finish&quot;: 2.5, &quot;outcome&quot;: &quot;passed&quot;}    {&quot;nodeid&quot;: &quot;test_foo.py::test[5]&quot;, &quot;start&quot;: 2.5}    {&quot;nodeid&quot;: &quot;test_foo.py::test[5]&quot;, &quot;start&quot;: 2.5, &quot;finish&quot;: 3.5, &quot;outcome&quot;: &quot;passed&quot;}    {&quot;nodeid&quot;: &quot;test_foo.py::test[7]&quot;, &quot;start&quot;: 3.5}    {&quot;nodeid&quot;: &quot;test_foo.py::test[7]&quot;, &quot;start&quot;: 3.5, &quot;finish&quot;: 4.5, &quot;outcome&quot;: &quot;passed&quot;}    {&quot;nodeid&quot;: &quot;test_foo.py::test[8]&quot;, &quot;start&quot;: 4.5}    {&quot;nodeid&quot;: &quot;test_foo.py::test[8]&quot;, &quot;start&quot;: 4.5, &quot;finish&quot;: 5.5, &quot;outcome&quot;: &quot;passed&quot;}If there is a crash or a flaky failure in the tests of the worker ``gw1``, one can take that file from the CI server andexecute the tests in the same order with::    $ pytest --replay=.pytest-replay-gw1.txtHopefully this will make it easier to reproduce the problem and fix it.FAQ~~~1. ``pytest`` has its own `cache &lt;https://docs.pytest.org/en/latest/cache.html&gt;`_, why use a different mechanism?   The internal cache saves its data using ``json``, which is not suitable in the advent of a crash because the file   will not be readable.2. Shouldn't the ability of selecting tests from a file be part of the ``pytest`` core?   Sure, but let's try to use this a bit as a separate plugin before proposing   its inclusion into the core.Installation------------You can install ``pytest-replay`` via `pip`_ from `PyPI`_::    $ pip install pytest-replayOr with conda::    $ conda install -c conda-forge pytest-replayContributing------------Contributions are very welcome.Tests can be run with `tox`_ if you are using a native Python installation.To run tests with `conda &lt;https://conda.io/docs/&gt;`_, first create a virtual environment and execute tests from there(conda with Python 3.5+ in the root environment)::    $ python -m venv .env    $ .env\scripts\activate    $ pip install -e . pytest-xdist    $ pytest testsReleases~~~~~~~~Follow these steps to make a new release:1. Create a new branch ``release-X.Y.Z`` from ``master``;2. Update ``CHANGELOG.rst``;3. Open a PR;4. After it is **green** and **approved**, push a new tag in the format ``X.Y.Z``;GitHub Actions will deploy to PyPI automatically.Afterwards, update the recipe in `conda-forge/pytest-replay-feedstock &lt;https://github.com/conda-forge/pytest-replay-feedstock&gt;`_.License-------Distributed under the terms of the `MIT`_ license.Issues------If you encounter any problems, please `file an issue`_ along with a detailed description... _`Cookiecutter`: https://github.com/audreyr/cookiecutter.. _`@hackebrot`: https://github.com/hackebrot.. _`MIT`: http://opensource.org/licenses/MIT.. _`BSD-3`: http://opensource.org/licenses/BSD-3-Clause.. _`GNU GPL v3.0`: http://www.gnu.org/licenses/gpl-3.0.txt.. _`Apache Software License 2.0`: http://www.apache.org/licenses/LICENSE-2.0.. _`cookiecutter-pytest-plugin`: https://github.com/pytest-dev/cookiecutter-pytest-plugin.. _`file an issue`: https://github.com/ESSS/pytest-replay/issues.. _`pytest`: https://github.com/pytest-dev/pytest.. _`tox`: https://tox.readthedocs.io/en/latest/.. _`pip`: https://pypi.python.org/pypi/pip/.. _`PyPI`: https://pypi.python.org/pypi</longdescription>
</pkgmetadata>