<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Morphology is a Python data validation library[![Build Status](https://travis-ci.org/nathanielford/morphology.png)](https://travis-ci.org/nathanielford/morphology)[![Coverage Status](https://coveralls.io/repos/github/nathanielford/morphology/badge.svg?branch=master)](https://coveralls.io/github/nathanielford/morphology?branch=master) [![Gitter chat](https://badges.gitter.im/nathanielford.png)](https://gitter.im/nathanielford/Lobby)Morphology is a Python data validation library. It is primarily intended for validating data coming into Python as JSON,YAML, etc.It has three goals:1.  Simplicity.2.  Support for complex data structures.3.  Provide useful error messages.## ContactTo file a bug, create a [new issue](https://github.com/nathanielford/morphology/issues/new) on GitHub with a short example of how to replicate the issue.## DocumentationThe documentation is provided [here](http://nathanielford.github.io/morphology/).## ChangelogSee [CHANGELOG.md](https://github.com/nathanielford/morphology/blob/master/CHANGELOG.md).## Show me an exampleTwitter's [user search API](https://dev.twitter.com/rest/reference/get/users/search) acceptsquery URLs like:```$ curl 'https://api.twitter.com/1.1/users/search.json?q=python&amp;per_page=20&amp;page=1'```To validate this we might use a schema like:```pycon&gt;&gt;&gt; from morphology import Schema&gt;&gt;&gt; schema = Schema({...   'q': str,...   'per_page': int,...   'page': int,... })```This schema very succinctly and roughly describes the data required bythe API, and will work fine. But it has a few problems. Firstly, itdoesn't fully express the constraints of the API. According to the API,`per_page` should be restricted to at most 20, defaulting to 5, forexample. To describe the semantics of the API more accurately, ourschema will need to be more thoroughly defined:```pycon&gt;&gt;&gt; from morphology import Required, All, Length, Range&gt;&gt;&gt; schema = Schema({...   Required('q'): All(str, Length(min=1)),...   Required('per_page', default=5): All(int, Range(min=1, max=20)),...   'page': All(int, Range(min=0)),... })```This schema fully enforces the interface defined in Twitter'sdocumentation, and goes a little further for completeness.&quot;q&quot; is required:```pycon&gt;&gt;&gt; from morphology import MultipleInvalid, Invalid&gt;&gt;&gt; try:...   schema({})...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;required key not provided @ data['q']&quot;True```...must be a string:```pycon&gt;&gt;&gt; try:...   schema({'q': 123})...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;expected str for dictionary value @ data['q']&quot;True```...and must be at least one character in length:```pycon&gt;&gt;&gt; try:...   schema({'q': ''})...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;length of value must be at least 1 for dictionary value @ data['q']&quot;True&gt;&gt;&gt; schema({'q': '#topic'}) == {'q': '#topic', 'per_page': 5}True```&quot;per\_page&quot; is a positive integer no greater than 20:```pycon&gt;&gt;&gt; try:...   schema({'q': '#topic', 'per_page': 900})...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;value must be at most 20 for dictionary value @ data['per_page']&quot;True&gt;&gt;&gt; try:...   schema({'q': '#topic', 'per_page': -10})...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;value must be at least 1 for dictionary value @ data['per_page']&quot;True```&quot;page&quot; is an integer \&gt;= 0:```pycon&gt;&gt;&gt; try:...   schema({'q': '#topic', 'per_page': 'one'})...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc)&quot;expected int for dictionary value @ data['per_page']&quot;&gt;&gt;&gt; schema({'q': '#topic', 'page': 1}) == {'q': '#topic', 'page': 1, 'per_page': 5}True```## Defining schemasSchemas are nested data structures consisting of dictionaries, lists,scalars and *validators*. Each node in the input schema is patternmatched against corresponding nodes in the input data.### LiteralsLiterals in the schema are matched using normal equality checks:```pycon&gt;&gt;&gt; schema = Schema(1)&gt;&gt;&gt; schema(1)1&gt;&gt;&gt; schema = Schema('a string')&gt;&gt;&gt; schema('a string')'a string'```### TypesTypes in the schema are matched by checking if the corresponding valueis an instance of the type:```pycon&gt;&gt;&gt; schema = Schema(int)&gt;&gt;&gt; schema(1)1&gt;&gt;&gt; try:...   schema('one')...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;expected int&quot;True```### URL'sURL's in the schema are matched by using `urlparse` library.```pycon&gt;&gt;&gt; from morphology import Url&gt;&gt;&gt; schema = Schema(Url())&gt;&gt;&gt; schema('http://w3.org')'http://w3.org'&gt;&gt;&gt; try:...   schema('one')...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;expected a URL&quot;True```### ListsLists in the schema are treated as a set of valid values. Each elementin the schema list is compared to each value in the input data:```pycon&gt;&gt;&gt; schema = Schema([1, 'a', 'string'])&gt;&gt;&gt; schema([1])[1]&gt;&gt;&gt; schema([1, 1, 1])[1, 1, 1]&gt;&gt;&gt; schema(['a', 1, 'string', 1, 'string'])['a', 1, 'string', 1, 'string']```However, an empty list (`[]`) is treated as is. If you want to specify a list that cancontain anything, specify it as `list`:```pycon&gt;&gt;&gt; schema = Schema([])&gt;&gt;&gt; try:...   schema([1])...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;not a valid value @ data[1]&quot;True&gt;&gt;&gt; schema([])[]&gt;&gt;&gt; schema = Schema(list)&gt;&gt;&gt; schema([])[]&gt;&gt;&gt; schema([1, 2])[1, 2]```### Validation functionsValidators are simple callables that raise an `Invalid` exception whenthey encounter invalid data. The criteria for determining validity isentirely up to the implementation; it may check that a value is a validusername with `pwd.getpwnam()`, it may check that a value is of aspecific type, and so on.The simplest kind of validator is a Python function that raisesValueError when its argument is invalid. Conveniently, many builtinPython functions have this property. Here's an example of a datevalidator:```pycon&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; def Date(fmt='%Y-%m-%d'):...   return lambda v: datetime.strptime(v, fmt)``````pycon&gt;&gt;&gt; schema = Schema(Date())&gt;&gt;&gt; schema('2013-03-03')datetime.datetime(2013, 3, 3, 0, 0)&gt;&gt;&gt; try:...   schema('2013-03')...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;not a valid value&quot;True```In addition to simply determining if a value is valid, validators maymutate the value into a valid form. An example of this is the`Coerce(type)` function, which returns a function that coerces itsargument to the given type:```pythondef Coerce(type, msg=None):    &quot;&quot;&quot;Coerce a value to a type.    If the type constructor throws a ValueError, the value will be marked as    Invalid.    &quot;&quot;&quot;    def f(v):        try:            return type(v)        except ValueError:            raise Invalid(msg or ('expected %s' % type.__name__))    return f```This example also shows a common idiom where an optional human-readablemessage can be provided. This can vastly improve the usefulness of theresulting error messages.### DictionariesEach key-value pair in a schema dictionary is validated against eachkey-value pair in the corresponding data dictionary:```pycon&gt;&gt;&gt; schema = Schema({1: 'one', 2: 'two'})&gt;&gt;&gt; schema({1: 'one'}){1: 'one'}```#### Extra dictionary keysBy default any additional keys in the data, not in the schema willtrigger exceptions:```pycon&gt;&gt;&gt; schema = Schema({2: 3})&gt;&gt;&gt; try:...   schema({1: 2, 2: 3})...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;extra keys not allowed @ data[1]&quot;True```This behaviour can be altered on a per-schema basis. To allowadditional keys use`Schema(..., extra=ALLOW_EXTRA)`:```pycon&gt;&gt;&gt; from morphology import ALLOW_EXTRA&gt;&gt;&gt; schema = Schema({2: 3}, extra=ALLOW_EXTRA)&gt;&gt;&gt; schema({1: 2, 2: 3}){1: 2, 2: 3}```To remove additional keys use`Schema(..., extra=REMOVE_EXTRA)`:```pycon&gt;&gt;&gt; from morphology import REMOVE_EXTRA&gt;&gt;&gt; schema = Schema({2: 3}, extra=REMOVE_EXTRA)&gt;&gt;&gt; schema({1: 2, 2: 3}){2: 3}```It can also be overridden per-dictionary by using the catch-all markertoken `extra` as a key:```pycon&gt;&gt;&gt; from morphology import Extra&gt;&gt;&gt; schema = Schema({1: {Extra: object}})&gt;&gt;&gt; schema({1: {'foo': 'bar'}}){1: {'foo': 'bar'}}```#### Required dictionary keysBy default, keys in the schema are not required to be in the data:```pycon&gt;&gt;&gt; schema = Schema({1: 2, 3: 4})&gt;&gt;&gt; schema({3: 4}){3: 4}```Similarly to how extra\_ keys work, this behaviour can be overriddenper-schema:```pycon&gt;&gt;&gt; schema = Schema({1: 2, 3: 4}, required=True)&gt;&gt;&gt; try:...   schema({3: 4})...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;required key not provided @ data[1]&quot;True```And per-key, with the marker token `Required(key)`:```pycon&gt;&gt;&gt; schema = Schema({Required(1): 2, 3: 4})&gt;&gt;&gt; try:...   schema({3: 4})...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;required key not provided @ data[1]&quot;True&gt;&gt;&gt; schema({1: 2}){1: 2}```#### Optional dictionary keysIf a schema has `required=True`, keys may be individually marked asoptional using the marker token `Optional(key)`:```pycon&gt;&gt;&gt; from morphology import Optional&gt;&gt;&gt; schema = Schema({1: 2, Optional(3): 4}, required=True)&gt;&gt;&gt; try:...   schema({})...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;required key not provided @ data[1]&quot;True&gt;&gt;&gt; schema({1: 2}){1: 2}&gt;&gt;&gt; try:...   schema({1: 2, 4: 5})...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;extra keys not allowed @ data[4]&quot;True``````pycon&gt;&gt;&gt; schema({1: 2, 3: 4}){1: 2, 3: 4}```### Recursive / nested schemaYou can use `morphology.Self` to define a nested schema:```pycon&gt;&gt;&gt; from morphology import Schema, Self&gt;&gt;&gt; recursive = Schema({&quot;more&quot;: Self, &quot;value&quot;: int})&gt;&gt;&gt; recursive({&quot;more&quot;: {&quot;value&quot;: 42}, &quot;value&quot;: 41}) == {'more': {'value': 42}, 'value': 41}True```### Extending an existing SchemaOften it comes handy to have a base `Schema` that is extended with morerequirements. In that case you can use `Schema.extend` to create a new`Schema`:```pycon&gt;&gt;&gt; from morphology import Schema&gt;&gt;&gt; person = Schema({'name': str})&gt;&gt;&gt; person_with_age = person.extend({'age': int})&gt;&gt;&gt; sorted(list(person_with_age.schema.keys()))['age', 'name']```The original `Schema` remains unchanged.### ObjectsEach key-value pair in a schema dictionary is validated against eachattribute-value pair in the corresponding object:```pycon&gt;&gt;&gt; from morphology import Object&gt;&gt;&gt; class Structure(object):...     def __init__(self, q=None):...         self.q = q...     def __repr__(self):...         return '&lt;Structure(q={0.q!r})&gt;'.format(self)...&gt;&gt;&gt; schema = Schema(Object({'q': 'one'}, cls=Structure))&gt;&gt;&gt; schema(Structure(q='one'))&lt;Structure(q='one')&gt;```### Allow None valuesTo allow value to be None as well, use Any:```pycon&gt;&gt;&gt; from morphology import Any&gt;&gt;&gt; schema = Schema(Any(None, int))&gt;&gt;&gt; schema(None)&gt;&gt;&gt; schema(5)5```## Error reportingValidators must throw an `Invalid` exception if invalid data is passedto them. All other exceptions are treated as errors in the validator andwill not be caught.Each `Invalid` exception has an associated `path` attribute representingthe path in the data structure to our currently validating value, as wellas an `error_message` attribute that contains the message of the originalexception. This is especially useful when you want to catch `Invalid`exceptions and give some feedback to the user, for instance in the context ofan HTTP API.```pycon&gt;&gt;&gt; def validate_email(email):...     &quot;&quot;&quot;Validate email.&quot;&quot;&quot;...     if not &quot;@&quot; in email:...         raise Invalid(&quot;This email is invalid.&quot;)...     return email&gt;&gt;&gt; schema = Schema({&quot;email&quot;: validate_email})&gt;&gt;&gt; exc = None&gt;&gt;&gt; try:...     schema({&quot;email&quot;: &quot;whatever&quot;})... except MultipleInvalid as e:...     exc = e&gt;&gt;&gt; str(exc)&quot;This email is invalid. for dictionary value @ data['email']&quot;&gt;&gt;&gt; exc.path['email']&gt;&gt;&gt; exc.msg'This email is invalid.'&gt;&gt;&gt; exc.error_message'This email is invalid.'```The `path` attribute is used during error reporting, but also during matchingto determine whether an error should be reported to the user or if the nextmatch should be attempted. This is determined by comparing the depth of thepath where the check is, to the depth of the path where the error occurred. Ifthe error is more than one level deeper, it is reported.The upshot of this is that *matching is depth-first and fail-fast*.To illustrate this, here is an example schema:```pycon&gt;&gt;&gt; schema = Schema([[2, 3], 6])```Each value in the top-level list is matched depth-first in-order. Giveninput data of `[[6]]`, the inner list will match the first element ofthe schema, but the literal `6` will not match any of the elements ofthat list. This error will be reported back to the user immediately. Nobacktracking is attempted:```pycon&gt;&gt;&gt; try:...   schema([[6]])...   raise AssertionError('MultipleInvalid not raised')... except MultipleInvalid as e:...   exc = e&gt;&gt;&gt; str(exc) == &quot;not a valid value @ data[0][0]&quot;True```If we pass the data `[6]`, the `6` is not a list type and so will notrecurse into the first element of the schema. Matching will continue onto the second element in the schema, and succeed:```pycon&gt;&gt;&gt; schema([6])[6]```## Running tests.Morphology is using nosetests:    $ nosetests## Why use Morphology over another validation library?**Validators are simple callables**:   No need to subclass anything, just use a function.**Errors are simple exceptions.**:   A validator can just `raise Invalid(msg)` and expect the user to getuseful messages.**Schemas are basic Python data structures.**:   Should your data be a dictionary of integer keys to strings?`{int: str}` does what you expect. List of integers, floats orstrings? `[int, float, str]`.**Designed from the ground up for validating more than just forms.**:   Nested data structures are treated in the same way as any othertype. Need a list of dictionaries? `[{}]`**Consistency.**:   Types in the schema are checked as types. Values are compared asvalues. Callables are called to validate. Simple.## LineageMorphology is an almost-direct branch of [this library](https://github.com/alecthomas/voluptuous). [This issue](https://github.com/alecthomas/voluptuous/issues/287) was opened, addressing the inappropriate nature of the name, but was summarily closed by the original author. Sadly, this prevents an otherwise great library from being utilized in professional, inclusive settings, and the only solution was to fork it to address this specific issue. It is important to recognize that Alec Thomas and the other contributers there should receive all the credit for the functionality here.   In the future I intend to port any significant upgrades over, and will attempt to keep versions in sync such that one isinterchangeable with the other with a simple replace-all. For various build mishagus reasons, morphology minor versionswill be equivalent to `10x(parent minor version)+c`, where `c` is 0-9 and just has to do with integration fixes.</longdescription>
</pkgmetadata>