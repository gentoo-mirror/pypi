<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Danio&lt;p&gt;&lt;a href=&quot;https://github.com/strongbugman/danio/actions&quot;&gt;    &lt;img src=&quot;https://github.com/strongbugman/danio/workflows/UnitTest/badge.svg&quot; alt=&quot;UnitTest&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://pypi.org/project/danio/&quot;&gt;    &lt;img src=&quot;https://badge.fury.io/py/danio.svg&quot; alt=&quot;Package version&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codecov.io/gh/strongbugman/danio&quot;&gt;    &lt;img src=&quot;https://codecov.io/gh/strongbugman/danio/branch/main/graph/badge.svg&quot; alt=&quot;Code coverage&quot;&gt;&lt;/a&gt;&lt;/p&gt;Danio is a ORM for python asyncio world.It is designed to make getting easy and clearly.It builds on python's dataclass and encode's [databases](https://github.com/encode/databases)## Features* keep OOM in mind, custom your Field and Model behavior easily* type hints any where, no more need to memorize words your field names any more* base CRUD operation, transactions, lock and so on* signals like before save, after save and so on* complex operation like bulk create, upsert, create or update and so on* assist model schema migration* support MySQL/PostgreSQL/SQLite* hints generation## install`pip install danio`## Documents[Danio Document](https://strongbugman.github.io/danio/)## Glance```pythondb = danio.Database(    &quot;mysql://root:letmein@server:3306/test&quot;,    maxsize=3,    charset=&quot;utf8mb4&quot;,    use_unicode=True,    connect_timeout=60,)@dataclasses.dataclassclass User(danio.Model):    # auto generated by danio:    # --------------------Danio Hints--------------------    # TABLE NAME: user    # TABLE IS MIGRATED!    ID: typing.ClassVar[danio.Field]  # &quot;id&quot; serial PRIMARY KEY NOT NULL    NAME: typing.ClassVar[danio.Field]  # &quot;name&quot; varchar(255)  NOT NULL    AGE: typing.ClassVar[danio.Field]  # &quot;age&quot; int  NOT NULL    CREATED_AT: typing.ClassVar[        danio.Field    ]  # &quot;created_at&quot; timestamp without time zone  NOT NULL    UPDATED_AT: typing.ClassVar[        danio.Field    ]  # &quot;updated_at&quot; timestamp without time zone  NOT NULL    GENDER: typing.ClassVar[danio.Field]  # &quot;gender&quot; int  NOT NULL    # --------------------Danio Hints--------------------    class Gender(enum.Enum):        MALE = 0        FEMALE = 1        OTHER = 2    id: typing.Annotated[int, danio.IntField(primary=True, type=&quot;serial&quot;)] = 0    name: typing.Annotated[str, danio.CharField(comment=&quot;User name&quot;)] = &quot;&quot;    age: typing.Annotated[int, danio.IntField] = 0    created_at: typing.Annotated[        datetime.datetime,        danio.DateTimeField(type=&quot;timestamp without time zone&quot;, comment=&quot;when created&quot;),    ] = dataclasses.field(default_factory=datetime.datetime.now)    updated_at: typing.Annotated[        datetime.datetime,        danio.DateTimeField(type=&quot;timestamp without time zone&quot;, comment=&quot;when updated&quot;),    ] = dataclasses.field(default_factory=datetime.datetime.now)    gender: typing.Annotated[Gender, danio.IntField(enum=Gender)] = Gender.MALE    async def before_create(self, validate=True):        await super().before_create(validate=True)    async def before_update(self, validate=True):        self.updated_at = datetime.datetime.now()        await super().before_update(validate=True)    async def validate(self):        await super().validate()        if not self.name:            raise danio.ValidateException(&quot;Empty name!&quot;)    @classmethod    def get_database(        cls, operation: danio.Operation, table: str, *args, **kwargs    ) -&gt; danio.Database:        return db# base CRUDuser = await User(name=&quot;batman&quot;).save()user = await User.where(User.NAME == &quot;batman&quot;).fetch_one()user.gender = User.Gender.MALEawait user.save()await user.delete()# sql chainawait User.where(User.NAME != &quot;&quot;).limit(10).fetch_all()# multi where conditionawait User.where(User.ID != 1, User.NAME != &quot;&quot;).fetch_all()await User.where(User.ID != 1).where(User.NAME != &quot;&quot;).fetch_all()await User.where(User.ID &lt;= 10, User.ID &gt;= 20, is_and=False).fetch_all()# complicated expressionawait User.where(User.ID == 1).update(age=(User.AGE + 1) / (User.AGE / 12) - 2)await User.where((User.AGE + 1) == 3).fetch_all()# complicated sql operationawait User.where(User.ID == u.id).update(    age=User.AGE.case(User.AGE &gt; 10, 1, default=18).case(User.AGE &lt;= 0, 10))created, updated = await UserProfile.upsert(    [        dict(id=1, name=&quot;upsert&quot;),    ],    update_fields=[&quot;name&quot;],)# bulk operationawait User.bulk_create([User(name=f&quot;user_{i}&quot;) for i in range(10)])await User.bulk_update(await User.fetch_all())await User.bulk_delete(await User.fetch_all())# shortcutuser, created = await User(id=1, name=&quot;created?&quot;).get_or_create(    key_fields=(User.ID,))user, created, updated = await User(id=2, name=&quot;updated?&quot;).create_or_update(    key_fields=(User.ID,))```</longdescription>
</pkgmetadata>