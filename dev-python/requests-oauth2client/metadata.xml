<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>`requests_oauth2client` is an OAuth 2.x client for Python, able to obtain, refresh and revoke tokens from anyOAuth2.x/OIDC compliant Authorization Server. It sits upon and extends the famous [requests] HTTP client module.It can act as an [OAuth 2.0](https://tools.ietf.org/html/rfc6749) /[2.1](https://datatracker.ietf.org/doc/draft-ietf-oauth-v2-1) client, to automatically get and renew Access Tokens,based on the[Client Credentials](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-07.html#name-client-credentials),[Authorization Code](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-07.html#name-authorization-code),[Refresh token](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-07.html#name-refresh-token),[Token Exchange](https://www.rfc-editor.org/rfc/rfc8693.html),[JWT Bearer](https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1),[Device Authorization](https://www.rfc-editor.org/rfc/rfc8628.html),[Resource Owner Password](https://www.rfc-editor.org/rfc/rfc6749#section-4.3) or[CIBA](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html) grants. Additionalgrant types are easy to add if needed.It also supports [OpenID Connect 1.0](https://openid.net/specs/openid-connect-core-1_0.html),[PKCE](https://www.rfc-editor.org/rfc/rfc7636.html),[Client Assertions](https://www.rfc-editor.org/rfc/rfc7523.html#section-2.2),[Token Revocation](https://www.rfc-editor.org/rfc/rfc7009.html), and[Introspection](https://www.rfc-editor.org/rfc/rfc7662.html),[Resource Indicators](https://www.rfc-editor.org/rfc/rfc8707.html),[JWT-secured Authorization Requests](https://datatracker.ietf.org/doc/rfc9101/),[Pushed Authorization Requests](https://datatracker.ietf.org/doc/rfc9126/),[Authorization Server Issuer Identification](https://www.rfc-editor.org/rfc/rfc9207.html), as well as using customparams to any endpoint, and other important features that are often overlooked in other client libraries.And it also includes a [wrapper][apiclient] around [requests.Session] that makes it super easy to use REST-style APIs,with or without OAuth 2.x.Please note that despite the name, this library has no relationship with Google[oauth2client](https://github.com/googleapis/oauth2client) library.[![made-with-python](https://img.shields.io/badge/Made%20with-Python-1f425f.svg)](https://www.python.org/)[![Downloads](https://pepy.tech/badge/requests_oauth2client/month)](https://pepy.tech/project/requests_oauth2client)[![Supported Versions](https://img.shields.io/pypi/pyversions/requests_oauth2client.svg)](https://pypi.org/project/requests_oauth2client)[![PyPi license](https://badgen.net/pypi/license/requests_oauth2client/)](https://pypi.com/project/requests_oauth2client/)[![PyPI status](https://img.shields.io/pypi/status/requests_oauth2client.svg)](https://pypi.python.org/pypi/requests_oauth2client/)[![GitHub commits](https://badgen.net/github/commits/guillp/requests_oauth2client)](https://github.com/guillp/requests_oauth2client/commit/)[![GitHub latest commit](https://badgen.net/github/last-commit/guillp/requests_oauth2client)](https://github.com/guillp/requests_oauth2client/commit/)# DocumentationFull module documentation is available at https://guillp.github.io/requests_oauth2client/# Installation`requests_oauth2client` is [available from PyPi](https://pypi.org/project/requests-oauth2client/), so installing it isas easy as:```shellpip install requests_oauth2client```# UsageEverything from `requests_oauth2client` is available from the root module, so you can import it like this:```pythonfrom requests_oauth2client import *```Or you can import individual objects from this package as usual. Note that importing `*` automatically imports`requests`, so no need to import it yourself.## Calling APIs with Access TokensIf you already managed to obtain an access token for the API you want to call, you can simply use the [BearerAuth] AuthHandler for [requests]:```pythonimport requestsfrom requests_oauth2client import BearerAuthtoken = &quot;an_access_token&quot;resp = requests.get(&quot;https://my.protected.api/endpoint&quot;, auth=BearerAuth(token))```This authentication handler will add a properly formatted `Authorization: Bearer &lt;access_token&gt;` header in the request,with your access token according to [RFC6750](https://datatracker.ietf.org/doc/html/rfc6750#section-2.1).## Using an OAuth2Client[OAuth2Client] offers several methods that implement the communication to the various endpoints that are standardised byOAuth 2.0 and its extensions. Those endpoints include the Token Endpoint, the Revocation, Introspection, UserInfo,BackChannel Authentication and Device Authorization Endpoints.You have to provide the URLs for those endpoints if you intend to use them. Otherwise, only the Token Endpoint ismandatory to initialize an `OAuth2Client`.To initialize an [OAuth2Client], you only need a Token Endpoint URI from your AS, and the credentials for yourapplication, which are often a `client_id` and a `client_secret`, usually also provided by the AS:```pythonfrom requests_oauth2client import OAuth2Clientoauth2client = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endpoint&quot;,    client_id=&quot;my_client_id&quot;,    client_secret=&quot;my_client_secret&quot;,)```The Token Endpoint is the only endpoint that is mandatory to obtain tokens. Credentials are used to authenticate theclient everytime it sends a request to its Authorization Server. Usually, those are a static Client ID and Secret, whichare the direct equivalent of a username and a password, but meant for an application instead of for a human user. Thedefault authentication method used by `OAuth2Client` is *Client Secret Post*, but other standardised methods such as*Client Secret Basic*, *Client Secret JWT* or *Private Key JWT* are supported as well. See[more about client authentication methods below](#supported-client-authentication-methods).## Obtaining tokens[OAuth2Client] has dedicated methods to send requests to the Token Endpoint using the different standardised (and/orcustom) grants. Since the Token Endpoint URL and Client Authentication Method to use are already declared for the clientat init time, the only required parameters for those methods are those that will be sent in the request to the TokenEndpoint.Those methods directly return a [BearerToken] if the request is successful, or raise an exception if it fails.[BearerToken] contains all the data as returned by the Token Endpoint, including the Access Token. It will:- keep track of the Access Token expiration date (based on the `expires_in` hint as returned by the AS). This date is  accessible with the `expires_at` attribute.- contain the Refresh Token, if returned by the AS, accessible with the `refresh_token` attribute.- contain the ID Token, if returned by the AS, accessible with the `Ã¬d_token` attribute (when using the Authorization  Code flow).- keep track of other associated metadata as well, also accessible as attributes with the same name:  `token.custom_attr`, or with subscription syntax `token[&quot;my.custom.attr&quot;]`.You can create such a [BearerToken] yourself if you need:```pythonfrom requests_oauth2client import BearerTokenbearer_token = BearerToken(access_token=&quot;an_access_token&quot;, expires_in=60)print(bearer_token)# {'access_token': 'an_access_token',#  'expires_in': 55,#  'token_type': 'Bearer'}print(bearer_token.expires_at)# datetime.datetime(2021, 8, 20, 9, 56, 59, 498793)assert not bearer_token.is_expired()print(bearer_token.expires_in)# 40```Note that the `expires_in` indicator here is not static. It keeps track of the token lifetime, in seconds, and iscalculated as the time flies. The actual static expiration date is accessible with the `expires_at` property. You cancheck if a token is expired with[bearer_token.is_expired()](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.tokens.BearerToken.is_expired).You can use a [BearerToken] instance anywhere you can use an access_token as string.### Using OAuth2Client as a requests Auth HandlerWhile using [OAuth2Client] directly is great for testing or debugging OAuth2.x flows, it is not a viable option foractual applications where tokens must be obtained, used during their lifetime then obtained again or refreshed once theyare expired. `requests_oauth2client` contains several [requests] compatible Auth Handlers (as subclasses of[requests.auth.AuthBase](https://requests.readthedocs.io/en/latest/user/advanced/#custom-authentication)), that willtake care of obtaining tokens when required, then will cache those tokens until they are expired, and will obtain newones (or refresh them, when possible), once the initial token is expired. Those are best used with a [requests.Session],or an [ApiClient], which is a wrapper around `Session` with a few enhancements as described below.### Client Credentials grantTo send a request using the Client Credentials grant, use the aptly named[.client_credentials()](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client.OAuth2Client.client_credentials)method, with the parameters to send in the token request as keyword parameters:```pythonfrom requests_oauth2client import OAuth2Clientoauth2client = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endpoint&quot;,    auth=(&quot;client_id&quot;, &quot;client_secret&quot;),)token = oauth2client.client_credentials(scope=&quot;myscope&quot;)# or, if your AS uses resource indicator:token = oauth2client.client_credentials(scope=&quot;myscope&quot;, resource=&quot;https://myapi.local&quot;)# or, if your AS uses 'audience' as parameter to identify the requested API (Auth0 style):token = oauth2client.client_credentials(audience=&quot;https://myapi.local&quot;)# or, if your AS uses custom parameters:token = oauth2client.client_credentials(scope=&quot;myscope&quot;, custom_param=&quot;custom_value&quot;)```Parameters such as `scope`, `resource` or `audience` or any other parameter that may be required by the AS can be passedas keyword parameters. Those will be included in the token request that is sent to the AS. `scope` is not mandatory atclient level (but it might be required by your AS to serve your request).#### As Auth HandlerYou can use the[OAuth2ClientCredentialsAuth](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth)auth handler. It takes an [OAuth2Client] as parameter, and the additional kwargs to pass to the token endpoint:```pythonimport requestsfrom requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuthoauth2client = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endpoint&quot;,    auth=(&quot;client_id&quot;, &quot;client_secret&quot;),)auth = OAuth2ClientCredentialsAuth(    oauth2client, scope=&quot;myscope&quot;, resource=&quot;https://myapi.local&quot;)# use it like this:requests.get(&quot;https://myapi.local/resource&quot;, auth=auth)# or like this:session = requests.Session()session.auth = authresp = session.get(&quot;https://myapi.local/resource&quot;)```Once again, extra parameters such as `scope`, `resource` or `audience` are allowed if required.When you send your first request,[OAuth2ClientCredentialsAuth](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth)will automatically retrieve an access token from the AS using the Client Credentials grant, then will include it in therequest. Next requests will use the same token, as long as it is valid. A new token will be automatically retrieved oncethe previous one is expired.### Authorization Code GrantObtaining tokens with the Authorization code grant is made in 3 steps:1. your application must open a specific url called the *Authentication Request* in a browser.2. your application must obtain and validate the *Authorization Response*, which is a redirection back to your   application that contains an *Authorization Code* as parameter. This redirect back (often called &quot;callback&quot;) is   initiated by the Authorization Server after any necessary interaction with the user is complete (Registration, Login,   Profile completion, Multi-Factor Authentication, Authorization, Consent, etc.)3. your application must then exchange this Authorization Code for an *Access Token*, with a request to the Token   Endpoint.`requests_oauth2client`, and more specifically [OAuth2Client] will help you with all those steps, as described below.#### Generating Authorization RequestsTo be able to use the Authorization Code grant, you need two urls:- the URL for Authorization Endpoint, which is the url where you must send your Authorization Requests- the Redirect URI, which is the url pointing to your application, where the Authorization Server will reply with  Authorization ResponseYou can declare those urls when initializing your OAuth2Client instance. Then you can generate valid AuthorizationRequests by calling the method `.authorization_request()`:```pythonfrom requests_oauth2client import OAuth2Clientclient = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endoint&quot;,    authorization_endpoint=&quot;https://url.to.the/authorization_endpoint&quot;,    redirect_uri=&quot;https://url.to.my.application/redirect_uri&quot;,    client_id=&quot;client_id&quot;,    client_secret=&quot;client_secret&quot;,)az_request = client.authorization_request(scope=&quot;openid email profile&quot;)print(az_request)# this will look like this, with line feeds for display purposes only:# https://url.to.the/authorization_endpoint# ?client_id=client_id# &amp;redirect_uri=https%3A%2F%2Furl.to.my.application%2Fredirect_uri# &amp;response_type=code# &amp;scope=openid+email+profile# &amp;state=FBx9mWeLwoKGgG76vhi6v61-4mgxmgZhtWIa7aTffdY# &amp;nonce=iHZJokhkGOAojff1tdknRyz9mPZyy5vq9JDlVaUHyqk# &amp;code_challenge=TG7qgdyKnwUPuoQ6NNJRlLMoHbeVmJlB8g0VOcfQEkc# &amp;code_challenge_method=S256# you can send the user to that url with:import webbrowserwebbrowser.open(az_request.uri)```Note that the `state`, `nonce` and `code_challenge` parameters are generated with secure random values by default.Should you wish to use your own values, you can pass them as parameters to `OAuth2Client.authorization_request()`. ForPKCE, you need to pass your generated `code_verifier`, and the `code_challenge` will automatically be derived from it.If you don't want to use PKCE, you can pass `code_challenge_method=None` when initializing your `OAuth2Client`.#### Validating the Authorization ResponseOnce you have redirected the user browser to the Authorization Request URI, and after the user is successfullyauthenticated and authorized, plus any other extra interactive step is complete, the AS will respond with a redirectionto your redirect_uri. That is the *Authorization Response*. It contains several parameters that must be retrieved byyour client. The *Authorization Code* is one of those parameters, but you must also validate that the *state* matchesyour request. You can do this with:```python# using the `az_request` as defined aboveresponse_uri = input(    &quot;Please enter the full url and/or params obtained on the redirect_uri: &quot;)az_response = az_request.validate_callback(response_uri)```This auth_response is an `AuthorizationResponse` instance and contains everything that is needed for your application tocomplete the authentication and get its tokens from the AS.#### Exchanging code for tokensOnce you have obtained the AS response, containing an authorization code, your application must exchange it for actualToken(s).To exchange a code for Access and/or ID tokens, use the[OAuth2Client.authorization_code()](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client.OAuth2Client.authorization_code)method. If you have obtained an AuthorizationResponse as described above, you can simply do:```pythontoken = oauth2client.authorization_code(az_response)```This will automatically include the `code`, `redirect_uri` and `code_verifier` parameters in the Token Request, asexpected by the AS. You may include extra parameters if required, or you may pass your own parameters, without using an`AuthorizationResponse` instance, like this:```pythontoken = oauth2client.authorization_code(    code=code,    code_verifier=code_verifier,    redirect_uri=redirect_uri,    custom_param=custom_value,)```#### As Auth HandlerThe[OAuth2AuthorizationCodeAuth](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth)handler takes an [OAuth2Client] and an authorization code as parameter, plus whatever additional keyword parameters arerequired by your Authorization Server:```pythonfrom requests_oauth2client import OAuth2Client, ApiClient, OAuth2AuthorizationCodeAuthoauth2client = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endpoint&quot;,    authorization_endpoint=&quot;https://url.to.the/authorization_endpoint&quot;,    auth=(&quot;client_id&quot;, &quot;client_secret&quot;),)api_client = ApiClient(    &quot;https://your.protected.api/endpoint&quot;,    auth=OAuth2AuthorizationCodeAuth(        oauth2client,        &quot;my_authorization_code&quot;,    ),)# any request using api_client will trigger exchanging the code for an access_token, which is then cached, and refreshed later if neededresp = api_client.post(data={...})```[OAuth2AuthorizationCodeAuth](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth)will take care of refreshing the token automatically once it is expired, using the refresh token, if available.### Note on AuthorizationRequestAuthorization Requests generated by `OAuth2Client.authorization_request()` are instance of the class[`AuthorizationRequest`](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.authorization_request.AuthorizationRequest).You can also use that class directly to generate your requests, but in that case you need to supply your AuthorizationEndpoint URI, your `client_id`, `redirect_uri`, etc. You can access every parameter from an `AuthorizationRequest`instance, as well as the generated `code_verifier`, as attributes of this instance. Once an Authorization Request URL isgenerated, it your application responsibility to redirect or otherwise send the user to that URL. You may use the`webbrowser` module from Python standard library to do so. Here is an example for generating Authorization Requests:```pythonfrom requests_oauth2client import AuthorizationRequestaz_request = AuthorizationRequest(    &quot;https://url.to.the/authorization_endpoint&quot;,    client_id=&quot;my_client_id&quot;,    redirect_uri=&quot;http://localhost/callback&quot;,  # this redirect_uri is specific to your app    scope=&quot;openid email profile&quot;,    # extra parameters such as `resource` can be included as well if required by your AS    resource=&quot;https://my.resource.local/api&quot;,)print(    az_request)  # this request will look like this, with line breaks for display purposes only# https://url.to.the/authorization_endpoint# ?client_id=my_client_id# &amp;redirect_uri=http%3A%2F%2Flocalhost%callback# &amp;response_type=code# &amp;state=kHWL4VwcbUbtPR4mtht6yMAGG_S-ZcBh5RxI_IGDmJc# &amp;nonce=mSGOS1M3LYU9ncTvvutoqUR4n1EtmaC_sQ3db4dyMAc# &amp;scope=openid+email+profile# &amp;code_challenge=W3n02f6xUKoDVbmhWEWz3h780b-Ci6ucnBS_d7nogmQ# &amp;code_challenge_method=S256# &amp;resource=https%3A%2F%2Fmy.resource.local%2Fapiprint(az_request.code_verifier)# 'gYK-ZnQfoat2bghwed7oEz--wvn4D70ksJ5GuWO9sXXygZ7PMnUlSpBmMCcNRHxdgTS9m_roYwGxF6HQxIqZVwXmxRJUziFHUFxDrNuUIjCJCx6gBhPlpFbUXulB1fo2'```### Device Authorization GrantHelpers for the Device Authorization Grant are also included. To get device and user codes, read the response attributes(including Device Code, User Code, Verification URI, etc.), then pooling the Token Endpoint:```pythonfrom requests_oauth2client import (    OAuth2Client,    DeviceAuthorizationPoolingJob,    BearerToken,)client = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endpoint&quot;,    device_authorization_endpoint=&quot;https://url.to.the/device_authorization_endpoint&quot;,    auth=(&quot;client_id&quot;, &quot;client_secret&quot;),)da_resp = client.authorize_device()# `da_resp` contains the Device Code, User Code, Verification URI and other info returned by the AS:da_resp.device_codeda_resp.user_codeda_resp.verification_urida_resp.verification_uri_completeda_resp.expires_at  # just like for BearerToken, expiration is tracked by requests_oauth2clientda_resp.interval# Send/show the Verification Uri and User Code to the user. He must use a browser to visit that url, authenticate and# input the User Code.# You can then request the Token endpoint to check if the user successfully authorized your device like this:pool_job = DeviceAuthorizationPoolingJob(client, da_resp)resp = Nonewhile resp is None:    resp = pool_job()assert isinstance(resp, BearerToken)```[DeviceAuthorizationPoolingJob](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob)will automatically obey the pooling period. Everytime you call `pool_job()`, it will wait the appropriate number ofseconds as indicated by the AS, and will apply slow_down requests.#### As Auth HandlerUse[OAuth2DeviceCodeAuth](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth)as auth handler to exchange a device code for an access token:```pythonfrom requests_oauth2client import ApiClient, OAuth2DeviceCodeAuth, OAuth2Clientclient = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endpoint&quot;,    device_authorization_endpoint=&quot;https://url.to.the/device_authorization_endpoint&quot;,    auth=(&quot;client_id&quot;, &quot;client_secret&quot;),)device_auth_resp = client.authorize_device()# expose user_code and verification_uri or verification_uri_complete to the userdevice_auth_resp.user_codedevice_auth_resp.verification_uridevice_auth_resp.verification_uri_complete# then try to send your request with a OAuth2DeviceCodeAuth handler# this will pool the token endpoint until the user authorize the deviceapi_client = ApiClient(    &quot;https://your.protected.api/endpoint&quot;,    auth=OAuth2DeviceCodeAuth(client, device_auth_resp),)resp = api_client.post(    data={...})  # first call will hang until the user authorizes your app and the token endpoint returns a token.```### Client-Initiated BackChannel Authentication (CIBA)To initiate a BackChannel Authentication against the dedicated endpoint, read the response attributes, and pool theToken Endpoint until the end-user successfully authenticates:```pythonfrom requests_oauth2client import (    OAuth2Client,    BearerToken,    BackChannelAuthenticationPoolingJob,)client = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endpoint&quot;,    backchannel_authentication_endpoint=&quot;https://url.to.the/backchannel_authorization_endpoint&quot;,    auth=(&quot;client_id&quot;, &quot;client_secret&quot;),)ba_resp = client.backchannel_authentication_request(    scope=&quot;openid email profile&quot;,    login_hint=&quot;user@example.net&quot;,)# `ba_resp` will contain the response attributes as returned by the AS, including an `auth_req_id`:ba_resp.auth_req_idba_resp.expires_in  # decreases as times flyba_resp.expires_at  # a datetime to keep track of the expiration date, based on the &quot;expires_in&quot; returned by the ASba_resp.interval  # the pooling interval indicated by the ASba_resp.custom  # if the AS respond with additional attributes, they are also accessiblepool_job = BackChannelAuthenticationPoolingJob(client, ba_resp)resp = Nonewhile resp is None:    resp = pool_job()assert isinstance(resp, BearerToken)```Hints by the AS to slow down pooling will automatically be obeyed.### Token ExchangeTo send a token exchange request, use the[OAuth2Client.token_exchange()](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client.OAuth2Client.token_exchange)method:```pythonfrom requests_oauth2client import OAuth2Client, ClientSecretJwtclient = OAuth2Client(    &quot;https://url.to.the/token_endpoint&quot;,    auth=ClientSecretJwt(&quot;client_id&quot;, &quot;client_secret&quot;),)token = client.token_exchange(    subject_token=&quot;your_token_value&quot;,    subject_token_type=&quot;urn:ietf:params:oauth:token-type:access_token&quot;,)```As with the other grant-type specific methods, you may specify additional keyword parameters, that will be passed to thetoken endpoint, including any standardised attribute like `actor_token` or `actor_token_type`, or any custom parameter.There are short names for token types, that will be automatically translated to standardised types:```pythontoken = client.token_exchange(    subject_token=&quot;your_token_value&quot;,    subject_token_type=&quot;access_token&quot;,  # will be automatically replaced by &quot;urn:ietf:params:oauth:token-type:access_token&quot;    actor_token=&quot;your_actor_token&quot;,    actor_token_type=&quot;id_token&quot;,  # will be automatically replaced by &quot;urn:ietf:params:oauth:token-type:id_token&quot;)```Or to make it even easier, types can be guessed based on the supplied subject or actor token:```pythonfrom requests_oauth2client import BearerToken, ClientSecretJwt, IdToken, OAuth2Clientclient = OAuth2Client(    &quot;https://url.to.the/token_endpoint&quot;,    auth=ClientSecretJwt(&quot;client_id&quot;, &quot;client_secret&quot;),)token = client.token_exchange(    subject_token=BearerToken(        &quot;your_token_value&quot;    ),  # subject_token_type will be &quot;urn:ietf:params:oauth:token-type:access_token&quot;    actor_token=IdToken(        &quot;your_actor_token&quot;    ),  # actor_token_type will be &quot;urn:ietf:params:oauth:token-type:id_token&quot;)```## Supported Client Authentication Methods`requests_oauth2client` supports several client authentication methods, as defined in multiple OAuth2.x standards. Youselect the appropriate method to use when initializing your [OAuth2Client], with the `auth` parameter. Once initialized,a client will automatically use the configured authentication method every time it sends a requested to an endpoint thatrequires client authentication. You don't have anything else to do afterwards.### Client Secret BasicWith **client_secret_basic**, `client_id` and `client_secret` are included in clear-text in the `Authorization` headerwhen sending requests to the Token Endpoint. To use it, just pass a[`ClientSecretBasic(client_id, client_secret)`](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client_authentication.ClientSecretBasic)as `auth` parameter:```pythonfrom requests_oauth2client import OAuth2Client, ClientSecretBasicclient = OAuth2Client(    &quot;https://url.to.the/token_endpoint&quot;,    auth=ClientSecretBasic(&quot;client_id&quot;, &quot;client_secret&quot;),)```### Client Secret PostWith **client_secret_post**, `client_id` and `client_secret` are included as part of the body form data. To use it, passa[`ClientSecretPost(client_id, client_secret)`](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client_authentication.ClientSecretPost)as `auth` parameter. This is the default when you pass a tuple `(client_id, client_secret)` as `auth` when initializingan `OAuth2Client`:```pythonfrom requests_oauth2client import OAuth2Client, ClientSecretPostclient = OAuth2Client(    &quot;https://url.to.the/token_endpoint&quot;,    auth=ClientSecretPost(&quot;client_id&quot;, &quot;client_secret&quot;),)# orclient = OAuth2Client(    &quot;https://url.to.the/token_endpoint&quot;, auth=(&quot;client_id&quot;, &quot;client_secret&quot;))# oroauth2client = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endpoint&quot;,    client_id=&quot;my_client_id&quot;,    client_secret=&quot;my_client_secret&quot;,)```### Client Secret JWTWith **client_secret_jwt**, the client generates an ephemeral JWT assertion including information about itself(client_id), the AS (url of the endpoint), and an expiration date a few seconds in the future. To use it, pass a[`ClientSecretJwt(client_id, client_secret)`](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client_authentication.ClientSecretJwt)as `auth` parameter. Assertion generation is entirely automatic, you don't have anything to do:```pythonfrom requests_oauth2client import OAuth2Client, ClientSecretJwtclient = OAuth2Client(    &quot;https://url.to.the/token_endpoint&quot;,    auth=ClientSecretJwt(&quot;client_id&quot;, &quot;client_secret&quot;),)```This method is more secure than the 2 previous, because only ephemeral credentials are transmitted, which limits thepossibility for interception and replay of the Client Secret. But that Client Secret still needs to be shared betweenthe AS and Client owner(s).### Private Key JWTWith **private_key_jwt**, client uses a JWT assertion that is just like the one for _client_secret_jwt_, but it issigned with an _asymmetric_ key. To use it, you need a private signing key, in a `dict` that matches the JWK format, oras an instance of `jwskate.Jwk`. The matching public key must be registered for your client on AS side. Once you havethat, using this auth method is simple with the[`PrivateKeyJwt(client_id, private_jwk)`](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client_authentication.PrivateKeyJwt)auth handler:```pythonfrom requests_oauth2client import OAuth2Client, PrivateKeyJwtprivate_jwk = {    &quot;kid&quot;: &quot;mykid&quot;,    &quot;kty&quot;: &quot;RSA&quot;,    &quot;e&quot;: &quot;AQAB&quot;,    &quot;n&quot;: &quot;...&quot;,    &quot;d&quot;: &quot;...&quot;,    &quot;p&quot;: &quot;...&quot;,    &quot;q&quot;: &quot;...&quot;,    &quot;dp&quot;: &quot;...&quot;,    &quot;dq&quot;: &quot;...&quot;,    &quot;qi&quot;: &quot;...&quot;,}client = OAuth2Client(    &quot;https://url.to.the/token_endpoint&quot;, auth=PrivateKeyJwt(&quot;client_id&quot;, private_jwk))# orclient = OAuth2Client(    &quot;https://url.to.the/token_endpoint&quot;, auth=(&quot;client_id&quot;, private_jwk))# orclient = OAuth2Client(    &quot;https://url.to.the/token_endpoint&quot;, client_id=&quot;client_id&quot;, private_jwk=private_jwk)```This method can be considered more secure than those relying on a client secret, because only ephemeral credentials aresent over the wire, and it uses asymmetric cryptography: the signing key is generated by the client, and only the publickey is known by the AS. Transmitting that public key between owner(s) of the client and of the AS is much easier thantransmitting the Client Secret, which is a shared key that must be considered as confidential.### NoneThe latest Client Authentication Method, **none**, is for Public Clients which do not authenticate to the TokenEndpoint. Those clients only include their `client_id` in body form data, without any authentication credentials. Use[`PublicApp(client_id)`](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client_authentication.PublicApp):```pythonfrom requests_oauth2client import OAuth2Client, PublicAppclient = OAuth2Client(    &quot;https://url.to.the/token_endpoint&quot;, auth=PublicApp(&quot;app_client_id&quot;))```## Token Revocation[OAuth2Client] can send revocation requests to a Revocation Endpoint. You need to provide a Revocation Endpoint URI whencreating the [OAuth2Client]. The[OAuth2Client.revoke_token()](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client.OAuth2Client.revoke_token)method and its specialized aliases[.revoke_access_token()](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client.OAuth2Client.revoke_access_token)and[.revoke_refresh_token()](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client.OAuth2Client.revoke_refresh_token)are then available:```pythonfrom requests_oauth2client import OAuth2Client, ClientSecretJwtoauth2client = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endpoint&quot;,    revocation_endpoint=&quot;https://url.to.the/revocation_endpoint&quot;,    auth=ClientSecretJwt(&quot;client_id&quot;, &quot;client_secret&quot;),)oauth2client.revoke_token(&quot;mytoken&quot;, token_type_hint=&quot;access_token&quot;)oauth2client.revoke_access_token(    &quot;mytoken&quot;)  # will automatically add token_type_hint=access_tokenoauth2client.revoke_refresh_token(    &quot;mytoken&quot;)  # will automatically add token_type_hint=refresh_token```Because Revocation Endpoints usually don't return meaningful responses, those methods return a boolean. This booleanindicates that a request was successfully sent and no error was returned. If the Authorization Server returns anon-successful HTTP code, but no standardised error message, it will return `False`. If the Authorization Serveractually returns a standardised error, an exception will be raised instead, like the other methods from `OAuth2Client`.## Token Introspection[OAuth2Client] can send requests to a Token Introspection Endpoint. You need to provide an Introspection Endpoint URIwhen creating the `OAuth2Client`. The[OAuth2Client.introspect_token()](&lt;https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client.OAuth2Client.instrospect_token()&gt;)method is then available:```pythonfrom requests_oauth2client import OAuth2Client, ClientSecretJwtoauth2client = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endpoint&quot;,    introspection_endpoint=&quot;https://url.to.the/introspection_endpoint&quot;,    auth=ClientSecretJwt(&quot;client_id&quot;, &quot;client_secret&quot;),)resp = oauth2client.introspect_token(&quot;mytoken&quot;, token_type_hint=&quot;access_token&quot;)```It returns whatever data is returned by the introspection endpoint (if it is a JSON, its content is returned decoded).## UserInfo Requests[OAuth2Client] can send requests to an UserInfo Endpoint. You need to provide an UserInfo Endpoint URI when creating the`OAuth2Client`. The[OAuth2Client.userinfo()](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client.OAuth2Client.userinfo))method is then available:```pythonfrom requests_oauth2client import OAuth2Client, ClientSecretJwtoauth2client = OAuth2Client(    token_endpoint=&quot;https://url.to.the/token_endpoint&quot;,    userinfo_endpoint=&quot;https://url.to.the/userinfo_endpoint&quot;,    auth=ClientSecretJwt(&quot;client_id&quot;, &quot;client_secret&quot;),)resp = oauth2client.userinfo(&quot;mytoken&quot;)```It returns whatever data is returned by the userinfo endpoint (if it is a JSON, its content is returned decoded).## Initializing an OAuth2Client from a discovery documentYou can initialize an [OAuth2Client] with the endpoint URIs mentioned in a standardised discovery document with the[OAuth2Client.from_discovery_endpoint()](https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client.OAuth2Client.from_discovery_document)class method:```pythonfrom requests_oauth2client import OAuth2Client, ClientSecretJwtoauth2client = OAuth2Client.from_discovery_endpoint(    &quot;https://url.to.the/.well-known/openid-configuration&quot;,    auth=ClientSecretJwt(&quot;client_id&quot;, &quot;client_secret&quot;),)```This will fetch the document from the specified URI, then will decode it and initialize an [OAuth2Client] pointing tothe appropriate endpoint URIs.## Specialized API ClientUsing APIs usually involves multiple endpoints under the same root url, with a common authentication method. To make iteasier, `requests_oauth2client` includes a [requests.Session] wrapper called [ApiClient], which takes the root API urlas parameter on initialization. You can then send requests to different endpoints by passing their relative path insteadof the full url. [ApiClient] also accepts an `auth` parameter with an AuthHandler. You can pass any of the OAuth2 AuthHandler from this module, or any [requests]-compatible[Authentication Handler](https://requests.readthedocs.io/en/latest/user/advanced/#custom-authentication). Which makes itvery easy to call APIs that are protected with an OAuth2 Client Credentials Grant:```pythonfrom requests_oauth2client import OAuth2Client, ApiClient, OAuth2ClientCredentialsAuthoauth2client = OAuth2Client(    &quot;https://url.to.the/token_endpoint&quot;, (&quot;client_id&quot;, &quot;client_secret&quot;))api = ApiClient(    &quot;https://myapi.local/root&quot;, auth=OAuth2ClientCredentialsAuth(oauth2client))# will actually send a GET to https://myapi.local/root/resource/fooresp = api.get(&quot;/resource/foo&quot;)```Note that [ApiClient] will never send requests &quot;outside&quot; its configured root url, unless you specifically give it a fullurl at request time. The leading `/` in `/resource` above is optional. A leading `/` will not &quot;reset&quot; the url path toroot, which means that you can also write the relative path without the `/` and it will automatically be included:```pythonapi.get(&quot;resource/foo&quot;)  # will also send a GET to https://myapi.local/root/resource/foo```You may also pass the path as an iterable of strings (or string-able objects), in which case they will be joined with a`/` and appended to the url path:```python# will send a GET to https://myapi.local/root/resource/fooapi.get([&quot;resource&quot;, &quot;foo&quot;])# will send a GET to https://myapi.local/root/users/1234/detailsapi.get([&quot;users&quot;, 1234, &quot;details&quot;])```You can also use a syntax based on `__getattr__` or `__getitem__`:```pythonapi.resource.get()  # will send a GET to https://myapi.local/root/resourceapi[&quot;my-resource&quot;].get()  # will send a GET to https://myapi.local/root/my-resource```Both `__getattr__` and `__getitem__` return a new `ApiClient` initialised on the new base_url. So you can easily callmultiple sub-resources on the same API this way:```pythonfrom requests_oauth2client import ApiClientapi = ApiClient(&quot;https://myapi.local&quot;)users_api = api.usersuser = users_api.get(&quot;userid&quot;)  # GET https://myapi.local/users/useridother_user = users_api.get(&quot;other_userid&quot;)  # GET https://myapi.local/users/other_useridresources_api = api.resourcesresources = resources_api.get()  # GET https://myapi.local/resources```[ApiClient] will, by default, raise exceptions whenever a request returns an error status. You can disable that bypassing `raise_for_status=False` when initializing your [ApiClient]:```pythonfrom requests_oauth2client import ApiClientapi = ApiClient(    &quot;http://httpstat.us&quot;, raise_for_status=False)  # raise_for_status defaults to Trueresp = api.get(&quot;500&quot;)assert resp is not None# without raise_for_status=False, a requests.exceptions.HTTPError exception would be raised instead```You may override this at request time:```python# raise_for_status at request-time overrides the value defined at init-timeresp = api.get(&quot;500&quot;, raise_for_status=True)```You can access the underlying `requests.Session` with the session attribute, and you can provide an already existing andconfigured `Session` instance at init time:```pythonimport requestsfrom requests_oauth2client import ApiClientsession = requests.Session()session.proxies = {&quot;https&quot;: &quot;http://localhost:3128&quot;}api = ApiClient(&quot;https://myapi.local/resource&quot;, session=session)assert api.session == session```## Vendor-Specific clients`requests_oauth2client` being flexible enough to handle most use cases, you should be able to use any AS by any vendoras long as it supports OAuth 2.0.You can however create a subclass of [OAuth2Client] or [ApiClient] to make it easier to use with specific AuthorizationServers or APIs. The sub-module `requests_oauth2client.vendor_specific` includes such classes for[Auth0](https://auth0.com):```pythonfrom requests_oauth2client.vendor_specific import Auth0Client, Auth0ManagementApiClienta0client = Auth0Client(&quot;mytenant.eu&quot;, (&quot;client_id&quot;, &quot;client_secret&quot;))# this will automatically initialize the token endpoint to https://mytenant.eu.auth0.com/oauth/token# and other endpoints accordinglytoken = a0client.client_credentials(audience=&quot;audience&quot;)# this is a wrapper around Auth0 Management APIa0mgmt = Auth0ManagementApiClient(&quot;mytenant.eu&quot;, (&quot;client_id&quot;, &quot;client_secret&quot;))myusers = a0mgmt.get(&quot;users&quot;)```[apiclient]: https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.api_client.ApiClient[bearerauth]: https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.auth.BearerAuth[bearertoken]: https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.tokens.BearerToken[oauth2client]: https://guillp.github.io/requests_oauth2client/api/#requests_oauth2client.client.OAuth2Client[requests]: https://requests.readthedocs.io/en/latest/[requests.session]: https://requests.readthedocs.io/en/latest/api/#requests.Session</longdescription>
</pkgmetadata>