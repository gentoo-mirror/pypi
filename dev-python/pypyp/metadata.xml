<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pyp[![Build Status](https://github.com/hauntsaninja/pyp/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/hauntsaninja/pyp/actions/workflows/tests.yml)[![Coverage Status](https://coveralls.io/repos/github/hauntsaninja/pyp/badge.svg?branch=master)](https://coveralls.io/github/hauntsaninja/pyp?branch=master)[![Checked with mypy](http://www.mypy-lang.org/static/mypy_badge.svg)](http://mypy-lang.org/)Easily run Python at the shell! Magical, but never mysterious.## InstallationRun `pip install pypyp` &lt;sup&gt;(note the extra &quot;yp&quot;!)&lt;/sup&gt;pyp requires Python 3.6 or above.## How it workspyp will statically analyse the input code to detect undefined variables. Based on what it finds,it will proceed to transform the AST of the input code as needed. We then compile and execute theresult, or if using `--explain`, unparse the AST back to source code.## ExamplesThis section will walk you through the details of using pyp, and hopefully replace your needsfor many common shell utilities. For a cheatsheet / tldr, run `pyp --help`.#### pyp can easily be used to apply Python code to each line in the input.Just use one of the magic variables `x`, `l` or `line` to refer to the current line.```sh# pyp like cutls | pyp 'x[:3]'ps x | pyp 'line.split()[4]'```#### pyp can be used to easily apply Python code to the entire input as well.Use the magic variable `lines` for a list of rstripped lines or `stdin` for `sys.stdin`.```sh# pyp like wc -ccat /usr/share/dict/words | pyp 'len(stdin.read())'# pyp like awkseq 1 5 | pyp 'sum(map(int, lines))'```#### pyp will automatically import modules you use.```sh# pyp like shecho echo echo | pyp 'subprocess.run(lines[0], shell=True); pass'# pyp like jqcurl -s 'https://api.github.com/repos/hauntsaninja/pyp/commits?per_page=1' | pyp 'json.load(stdin)[0][&quot;commit&quot;][&quot;author&quot;]'# pyp like egrepcat /usr/share/dict/words | pyp 'x if re.search(&quot;(p|m)yth&quot;, x) else None'```For `collections`, `math`, `itertools`, `pathlib.Path`, `pprint.pp`, pyp will figure it out evenif you don't use the qualified name.```sh# pyp like bcpyp 'sqrt(5)'# pyp like ${x##*.}ls | pyp 'Path(x).suffix'```#### pyp can give you access to loop indices using the magic variables `i`, `idx` or `index`.```sh# pyp like line numberscat setup.py | pyp 'f&quot;{idx+1: &gt;3} {x}&quot;'```#### Note so far you haven't had to call `print`!By default, pyp will print the last expression in your code â€” except if it evaluates to `None`(or the last statement is `pass`).And you can always explicitly call `print` yourself, in which case pyp will stay out of your way.```sh# pyp like grepcat /usr/share/dict/words | pyp 'x if &quot;python&quot; in x else None'cat /usr/share/dict/words | pyp 'if &quot;python&quot; in x: print(x); &quot;this will not be printed&quot;'```#### pyp will attempt to intelligently print dicts and iterables.This makes the output of pyp easier to compose with shell tools.Again, explicit printing will stop this magic, but pyp makes the function `pypprint` available ifyou do want to explicitly opt back in.```sh# pyp like taills | pyp 'lines[-10:]'# pyp like sortls | pyp 'sorted(lines)'ls | pyp 'print(f&quot;Sorting {len(lines)} lines&quot;); pypprint(sorted(lines))'# pyp like sort | uniqls | pyp 'sorted(set(lines))'```#### pyp lets you run snippets of Python before and after processing input.Note if you run into trouble with semicolons and want a new line (without using a multiline stringin your shell), you can just pass another string to pyp. You can also always pipe pyp to pyp!```sh# pyp like anything!ps aux | pyp -b 'd = defaultdict(list)' 'user, pid, *_ = x.split()' 'd[user].append(pid)' -a 'del d[&quot;root&quot;]' -a 'd'```#### pyp can be magical, but it doesn't have to be mysterious!Use `--explain` or `--script` and pyp will output a script equivalent to what it would run. This can also serve as auseful starting point for more complex scripts.```shpyp --explain -b 'd = defaultdict(list)' 'user, pid, *_ = x.split()' 'd[user].append(pid)' -a 'del d[&quot;root&quot;]' -a 'd'``````py#!/usr/bin/env python3from collections import defaultdictfrom pyp import pypprintimport sysd = defaultdict(list)for x in sys.stdin:    x = x.rstrip('\n')    (user, pid, *_) = x.split()    d[user].append(pid)del d['root']if d is not None:    pypprint(d)```And if your command hits an exception, pyp will reconstruct a traceback into the generated code.#### pyp is configurable.Point the environment variable `PYP_CONFIG_PATH` to a file containing, for example:```pyimport numpy as npimport tensorflow as tffrom pipetools import *def p95(data):    return np.percentile(data, 95)class PotentiallyUsefulClass: ...```When attempting to define undefined names, pyp will statically\* analyse this file as a source ofpossible definitions. This means that if you don't use `tf`, we won't import `tensorflow`! And ofcourse, `--explain` will show you exactly what gets run (and hence what doesn't!):```shpyp --explain 'print(p95(list(map(float, stdin))))'``````py#!/usr/bin/env python3import sysimport numpy as npdef p95(data):    return np.percentile(data, 95)stdin = sys.stdinprint(p95(list(map(float, stdin))))```Note, importing things from libraries like [pipetools](https://0101.github.io/pipetools/doc/index.html)in your configuration can allow you to achieve high levels of syntax sugar:```shseq 1 110 | pyp 'lines &gt; foreach(int) | where(X &gt; 100) | group_by(X % 3) | sort_by(X[0])'```&lt;sub&gt;\*If you use wildcard imports, we will need to import those modules if there remain undefinednames, though we skip this in the happy path. If this matters to you, definitely don't`from tensorflow import *` in your config! &lt;/sub&gt;#### pyp lets you configure your own magic!If definitions in your config file depend on magic variables, pyp will substitute them in theway that makes sense. For example, put the following in your config...```pyn = int(x)f = x.split()j = json.load(stdin)import pandas as pdcsv = pd.read_csv(stdin)```...to make pyp easier than ever for your custom use cases:```shps | pyp 'f[3]'cat commits.json | pyp 'j[0][&quot;commit&quot;][&quot;author&quot;]'&lt; cities.csv pyp 'csv.to_string()'```#### I have questions!There's additional documentation and examples at [FAQ](https://github.com/hauntsaninja/pyp/blob/master/FAQ.md).If that doesn't answer your question, please open an issue!## Related projects### [Pyed Piper](https://code.google.com/archive/p/pyp/) aka  Python Power at the Promptpyp takes inspiration (and the command name!) from here.However, Pyed Piper appears to be unmaintained, Python 2 only, and further away from Python syntaxthan pyp aims to be. Github mirror [here](https://github.com/yuvadm/pyp/).### [Pyped](https://github.com/ksamuel/Pyped)I discovered Pyped while making this project! It's actually very similar, probably similar enoughthat I wouldn't have written this had I known. However, Pyped doesn't do the AST introspectionand manipulation that we do. This means:- It's less magical! It relies on you to pass in flags to tell it what to do, when intention canbe inferred from the input.- It doesn't provide easy automatic printing, or smart printing of iterables and dicts.- It hardcodes a list of imports and installs some libraries on your system. This project'sautomatic import will work for any library you use.- It doesn't have anything like `--explain`/`--script`.However,- It has some conveniences, like regex splitting of input, that you'd have to do for yourself here.- It supports Python 2 and early versions of Python 3.- It's been around for much longer.### [piep](http://gfxmonk.net/dist/doc/piep/) / [spy](https://github.com/edk0/spy) / [pyfil](https://github.com/ninjaaron/pyfil) / [pythonpy](https://github.com/fish2000/pythonpy-fork) / [oneliner](https://python-oneliner.readthedocs.io/en/latest/)Since writing pyp, it turns out there are more alternatives out there than I thought :-) Some quicknotes:- Most of them rely on the user passing in flags, like Pyped.- Most of them have limitations around automatic printing, like only being able to automaticallyprint single expressions or not handling iterables and dicts well.- Some of them have custom syntax for in-process command chaining, which can be convenient.- Some of them have specialised support for things like JSON input or running shell commands.- Some of them expose the input in interesting ways with custom line / file / stream objects.- Some of them have more advanced options for error handling.- None of them have powerful configuration like pyp.- None of them have anything like `--explain`.For whatever it's worth, I've listed these projects in approximate order of my personal preference.### [mario](https://github.com/python-mario/mario)`mario` is a featureful take on shell processing with Python. It doesn't use undefined namedetection, instead relying on a pluggable subcommand system. While the subcommands can be moreverbose than pyp, `mario` makes up some ground by automatic application of functions and a customcommand chaining syntax. The result can feel a little DSL-like, while pyp tries to feel very closeto writing Python.Consider using `mario` if:- You find yourself stringing together long sequences of pyp commands and want to be able tocommand chain within a single process out of the box.- You find yourself often needing to reuse complex pyp commands or doing a lot of domain specificshell processing that you wish you could reuse with a single command.- You want more builtin support for things like processing CSV or TOML.- You want to easily be able to use async functions to process your input concurrently.Consider pyp if:- You want to minimise keystrokes for things that should be quick and easy.- You want something minimal and lightweight that feels very close to Python. You don't want to haveto remember commands.- You're happy using Python libraries to do domain specific heavy lifting, for easy command chainingor syntax sugar. You don't mind (or want to be able to) fall back to a script via `--script` to dealwith complexity.### [xonsh](https://xon.sh/)`xonsh` is a shell whose language is a superset of Python; this is more ambitious and prettydifferent from pyp. pyp is easier to use for the one-liner piping use case, but if you needmore Python in your shell, check out `xonsh`.### [awk](https://www.gnu.org/software/gawk/manual/gawk.html)If `awk` works for you, how did you end up here?</longdescription>
</pkgmetadata>