<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://pypip.in/d/pysendfile/badge.png    :target: https://crate.io/packages/pysendfile/    :alt: Download this month.. image:: https://pypip.in/v/pysendfile/badge.png    :target: https://pypi.python.org/pypi/pysendfile/    :alt: Latest version.. image:: https://pypip.in/license/pysendfile/badge.png    :target: https://pypi.python.org/pypi/pysendfile/    :alt: License.. image:: https://api.travis-ci.org/giampaolo/pysendfile.png?branch=master    :target: https://travis-ci.org/giampaolo/pysendfile    :alt: Travis===========Quick links===========- `Home page &lt;https://github.com/giampaolo/pysendfile&gt;`_- `Mailing list &lt;http://groups.google.com/group/py-sendfile&gt;`_- `Blog &lt;http://grodola.blogspot.com/search/label/pysendfile&gt;`_- `What's new &lt;https://github.com/giampaolo/pysendfile/blob/master/HISTORY.rst&gt;`_=====About=====`sendfile(2) &lt;http://linux.die.net/man/2/sendfile&gt;`__ is a system call whichprovides a &quot;zero-copy&quot; way of copying data from one file descriptor to another(a socket). The phrase &quot;zero-copy&quot; refers to the fact that all of the copyingof data between the two descriptors is done entirely by the kernel, with nocopying of data into userspace buffers. This is particularly useful whensending a file over a socket (e.g. FTP).The normal way of sending a file over a socket involves reading data from thefile into a userspace buffer, then write that buffer to the socket via`send() &lt;http://docs.python.org/library/socket.html#socket.socket.send&gt;`__ or`sendall() &lt;http://docs.python.org/library/socket.html#socket.socket.sendall&gt;`__:.. code-block:: python    # how a file is tipically sent    import socket    file = open(&quot;somefile&quot;, &quot;rb&quot;)    sock = socket.socket()    sock.connect((&quot;127.0.0.1&quot;, 8021))    while True:        chunk = file.read(65536)        if not chunk:            break  # EOF        sock.sendall(chunk)This copying of the data twice (once into the userland buffer, and once outfrom that userland buffer) imposes some performance and resource penalties.`sendfile(2) &lt;http://linux.die.net/man/2/sendfile&gt;`__ syscall avoids thesepenalties by avoiding any use of userland buffers; it also results in a singlesystem call (and thus only one context switch), rather than the series of`read(2) &lt;http://linux.die.net/man/2/read&gt;`__ /`write(2) &lt;http://linux.die.net/man/2/write&gt;`__ system calls (each system callrequiring a context switch) used internally for the data copying... code-block:: python    import socket    from sendfile import sendfile    file = open(&quot;somefile&quot;, &quot;rb&quot;)    blocksize = os.path.getsize(&quot;somefile&quot;)    sock = socket.socket()    sock.connect((&quot;127.0.0.1&quot;, 8021))    offset = 0    while True:        sent = sendfile(sock.fileno(), file.fileno(), offset, blocksize)        if sent == 0:            break  # EOF        offset += sent==================A simple benchmark==================This `benchmark script &lt;https://github.com/giampaolo/pysendfile/blob/master/test/benchmark.py&gt;`__implements the two examples above and compares plain socket.send() andsendfile() performances in terms of CPU time spent and bytes transmitted persecond resulting in sendfile() being about **2.5x faster**. These are theresults I get on my Linux 2.6.38 box, AMD dual-core 1.6 GHz:*send()*+---------------+-----------------+| CPU time      | 28.84 usec/pass |+---------------+-----------------+| transfer rate | 359.38 MB/sec   |+---------------+-----------------+*sendfile()*+---------------+-----------------+| CPU time      | 11.28 usec/pass |+---------------+-----------------+| transfer rate | 860.88 MB/sec   |+---------------+-----------------+===========================When do you want to use it?===========================Basically any application sending files over the network can take advantage ofsendfile(2). HTTP and FTP servers are a typical example.`proftpd &lt;http://www.proftpd.org/&gt;`__ and`vsftpd &lt;https://security.appspot.com/vsftpd.html&gt;`__ are known to use it, so is`pyftpdlib &lt;http://code.google.com/p/pyftpdlib/&gt;`__.=================API documentation=================sendfile module provides a single function: sendfile().- ``sendfile.sendfile(out, in, offset, nbytes, header=&quot;&quot;, trailer=&quot;&quot;, flags=0)``  Copy *nbytes* bytes from file descriptor *in* (a regular file) to file  descriptor *out* (a socket) starting at *offset*. Return the number of  bytes just being sent. When the end of file is reached return 0.  On Linux, if *offset* is given as *None*, the bytes are read from the current  position of *in* and the position of *in* is updated.  *headers* and *trailers* are strings that are written before and after the  data from *in* is written. In cross platform applications their usage is  discouraged  (`send() &lt;http://docs.python.org/library/socket.html#socket.socket.send&gt;`__ or  `sendall() &lt;http://docs.python.org/library/socket.html#socket.socket.sendall&gt;`__  can be used instead). On Solaris, _out_ may be the file descriptor of a  regular file or the file descriptor of a socket. On all other platforms,  *out* must be the file descriptor of an open socket.  *flags* argument is only supported on FreeBSD.- ``sendfile.SF_NODISKIO``- ``sendfile.SF_MNOWAIT``- ``sendfile.SF_SYNC``  Parameters for the _flags_ argument, if the implementation supports it. They  are available on FreeBSD platforms. See `FreeBSD's man sendfile(2) &lt;http://www.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&gt;`__.=======================Differences with send()=======================- sendfile(2) works with regular (mmap-like) files only (e.g. you can't use it  with a `StringIO &lt;http://docs.python.org/library/stringio.html&gt;`__ object).- Also, it must be clear that the file can only be sent &quot;as is&quot; (e.g. you  can't modify the content while transmitting).  There might be problems with non regular filesystems such as NFS,  SMBFS/Samba and CIFS. For this please refer to  `proftpd documentation &lt;http://www.proftpd.org/docs/howto/Sendfile.html&gt;`__.- `OSError &lt;http://docs.python.org/library/exceptions.html#exceptions.OSError&gt;`__  is raised instead of `socket.error &lt;http://docs.python.org/library/socket.html#socket.error&gt;`__.  The accompaining `error codes &lt;http://docs.python.org/library/errno.html&gt;`__  have the same meaning though: EAGAIN, EWOULDBLOCK, EBUSY meaning you are  supposed to retry, ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED in case of  disconnection. Some examples:  `benchmark script &lt;https://github.com/giampaolo/pysendfile/blob/release-2.0.1/test/benchmark.py#L182&gt;`__,  `test suite &lt;https://github.com/giampaolo/pysendfile/blob/release-2.0.1/test/test_sendfile.py#L202&gt;`__,  `pyftpdlib wrapper &lt;http://code.google.com/p/pyftpdlib/source/browse/tags/release-0.7.0/pyftpdlib/ftpserver.py#1035&gt;`__.===================Supported platforms===================This module works with Python versions from **2.5** to **3.4**. The supported platforms are:- **Linux**- **Mac OSX**- **FreeBSD**- **Dragon Fly BSD**- **Sun OS**- **AIX** (not properly tested)=======Support=======Feel free to mail me at *g.rodola [AT] gmail [DOT] com* or post on the themailing list: http://groups.google.com/group/py-sendfile.======Status======As of now the code includes a solid `test suite &lt;https://github.com/giampaolo/pysendfile/blob/master/test/test_sendfile.py&gt;`__ and its ready for production use.It's been included in `pyftpdlib &lt;http://code.google.com/p/pyftpdlib/&gt;`__project and used in production environments for almost a year now without anyproblem being reported so far.=======Authors=======pysendfile was originally written by *Ben Woolley* including Linux, FreeBSD andDragonFly BSD support. Later on *Niklas Edmundsson* took over maintenance andadded AIX support. After a couple of years of project stagnation`Giampaolo Rodola' &lt;http://grodola.blogspot.com/p/about.html&gt;`__ took overmaintenance and rewrote it from scratch adding support for:- Python 3- non-blocking sockets- `large file &lt;http://docs.python.org/library/posix.html#large-file-support&gt;`__ support- Mac OSX- Sun OS- FreeBSD flag argument- multiple threads (release GIL)- a simple benchmark suite- unit tests- documentation</longdescription>
</pkgmetadata>