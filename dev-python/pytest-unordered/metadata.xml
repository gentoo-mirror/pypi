<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pytest-unordered: Test collection content, ignoring order[![Build Status](https://github.com/utapyngo/pytest-unordered/actions/workflows/test.yml/badge.svg?branch=master)](https://github.com/utapyngo/pytest-unordered/actions/workflows/test.yml?query=branch%3Amaster)[![Coverage Status](https://codecov.io/gh/utapyngo/pytest-unordered/branch/master/graph/badge.svg)](https://codecov.io/gh/utapyngo/pytest-unordered)![Language](https://img.shields.io/github/languages/top/utapyngo/pytest-unordered)[![Python Compatibility](https://img.shields.io/pypi/pyversions/pytest-unordered)](https://pypi.python.org/pypi/pytest-unordered)[![PyPI](https://img.shields.io/pypi/v/pytest-unordered?color=rgb%2852%2C%20208%2C%2088%29)](https://pypi.org/project/pytest-unordered/)`pytest_unordered` allows you to write simple (pytest) assertionsto test whether collections have the same content, regardless of order.For example:    assert [1, 20, 300] == unordered([20, 300, 1])It is especially useful when testing APIs that return some complex data structures in an arbitrary order, e.g.:    assert response.json() == {        &quot;people&quot;: unordered(            # Here we test that the collection type is list            [                {                    &quot;name&quot;: &quot;Alice&quot;,                    &quot;age&quot;: 20,                    &quot;children&quot;: unordered(                        # Here the collection type is not important                        {&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 2},                         {&quot;name&quot;: &quot;Carol&quot;, &quot;age&quot;: 3},                    ),                },                {                    &quot;name&quot;: &quot;Dave&quot;,                    &quot;age&quot;: 30,                    &quot;children&quot;: unordered(                        {&quot;name&quot;: &quot;Eve&quot;, &quot;age&quot;: 5},                         {&quot;name&quot;: &quot;Frank&quot;, &quot;age&quot;: 6},                    ),                },            ]        ),    }## Installation    pip install pytest-unordered## Usage### BasicsIn most cases you just need the `unordered()` helper function:    from pytest_unordered import unorderedCompare list or tuples by wrapping your expected value with `unordered()`:    assert [1, 20, 300] == unordered([20, 300, 1])  # Pass    assert (1, 20, 300) == unordered((20, 300, 1))  # PassExcessive/missing items will be reported by pytest:    assert [1, 20, 300] == unordered([20, 300, 1, 300])      E         Extra items in the right sequence:      E         300By default, the container type has to match too:    assert (1, 20, 300) == unordered([20, 300, 1])      E         Type mismatch:      E         &lt;class 'tuple'&gt; != &lt;class 'list'&gt;### NestingA seasoned developer will notice that the simple use cases abovecan also be addressed with appropriate usageof builtins like `set()`, `sorted()`, `isinstance()`, `repr()`, etc,but these solutions scale badly (in terms of boilerplate code)with the complexity of your data structures.For example: naively implementing order ignoring comparisonwith `set()` or `sorted()` does not work with lists of dictionariesbecause dictionaries are not hashable or sortable.`unordered()` supports this out of the box however:    assert [{&quot;bb&quot;: 20}, {&quot;a&quot;: 1}] == unordered([{&quot;a&quot;: 1}, {&quot;bb&quot;: 20}])  # PassThe true value of `unordered()` lies in the fact that youcan apply it inside large nested data structures to skip order checkingonly in desired places with surgical precisionand without a lot of boilerplate code.For example:    expected = unordered([        {&quot;customer&quot;: &quot;Alice&quot;, &quot;orders&quot;: unordered([123, 456])},        {&quot;customer&quot;: &quot;Bob&quot;, &quot;orders&quot;: [789, 1000]},    ])    actual = [        {&quot;customer&quot;: &quot;Bob&quot;, &quot;orders&quot;: [789, 1000]},        {&quot;customer&quot;: &quot;Alice&quot;, &quot;orders&quot;: [456, 123]},    ]    assert actual == expectedIn this example we wrapped the outer customer list and the order list of Alicewith `unordered()`, but didn't wrap Bob's order list.With the `actual` value of above (where customer order is differentand Alice's orders are reversed), the assertion will pass.But if the orders of Bob would be swapped in `actual`, the assertionwill fail and pytest will report:    E         Differing items:    E         {'orders': [1000, 789]} != {'orders': [789, 1000]}### Container type checkingAs noted, the container types should be (by default) equal to pass theassertion. If you don't want this type check, call `unordered()`in a variable argument fashion (instead of passinga container as single argument):    assert [1, 20, 300] == unordered(20, 300, 1)  # Pass    assert (1, 20, 300) == unordered(20, 300, 1)  # PassThis pattern also allows comparing with iterators, generators and alike:    assert iter([1, 20, 300]) == unordered(20, 300, 1)  # Pass    assert unordered(i for i in range(3)) == [2, 1, 0]  # PassIf you want to enforce type checking when passing a single generator expression,pass `check_type=True`:    assert unordered((i for i in range(3)), check_type=True) == [2, 1, 0]  # Fail    assert unordered((i for i in range(3)), check_type=True) == (i for i in range(2, -1, -1))  # Pass</longdescription>
</pkgmetadata>