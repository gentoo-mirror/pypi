<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Decorators## The problemPython has a few forms for decorators, you can have a plain simple decorator, with no arguments:```python@mydecoratordef foo(): pass```Or a decorator with some arguments:```python@mydecorator(1, 2)def foo(): pass```You can even decorate a class:```python@mydecoratorclass Foo(object): pass```and each form is a little different to implement. This was frustrating if you wanted to create easy to use decorators where the developer didn't need to worry about `@mydecorator()` working differently than `@mydecorator`.## decorators moduleThe `decorators.Decorator` class allows you to easily create broad decorators that encompass all forms and all types (functions, methods, classes) using the same interface:```pythonimport decoratorsclass mydecorator(decorators.Decorator):    def decorate_func(self, func, *dec_args, **dec_kwargs):        def decorator(*args, *kwargs):            print(&quot;You passed into the decorator these arguments&quot;, dec_args, dec_kwargs)            print(&quot;You passed into your function these arguments&quot;, args, kwargs)            print(&quot;Your function is&quot;, func)            return func(*args, **kwargs)        return decorator    def decorate_class(self, klass, *dec_args, **dec_kwargs):        print(&quot;You passed into the decorator these arguments&quot;, dec_args, dec_kwargs)        print(&quot;Your class is&quot;, klass)        return klass```You can then use this decorator:```python@mydecoratordef foo(): print &quot;foo()&quot;@mydecorator(1, 2, boom=&quot;blam&quot;)def bar(*args, **kwargs): print &quot;bar()&quot;@mydecoratorclass Baz(object): pass@mydecorator(1, 2, boom=&quot;blam&quot;)class Che(object): pass```Now, your decorator can decorate functions or classes, pass in arguments, or not, and you never have to worry about the subtle differences between the decorators, and best of all, you don't have to duplicate code.## Other decorators### FuncDecorator, ClassDecorator, and InstanceDecoratorThe `Decorator` class is good if you want to create a decorator that is totally flexible, if you want to enforce your decorator only being used for a function/method, you can use `FuncDecorator`. If you want to only decorate a class, use `ClassDecorator`, and if you want to decorate every instance of a class, use `InstanceDecorator`.Whatever child class you use, you override the `decorate` method to return your decorator function:```pythonimport decoratorsclass only_func(FuncDecorator):    def decorate(self, func, *dec_a, **dec_kw):        def decorator(*args, **kwargs):            return func(*args, **kwargs)        return decorator# this will work@only_funcdef foo(): pass# this will fail@only_funcclass Foo(object): pass```### Property DecoratorThe `property` decorator is a drop-in replacement for Python's built-in `property` decorator, with additional functionality:```pythonfrom decorators import propertyclass Foo(object):    @property    def bar(self):        &quot;&quot;&quot;This will act just like python's built-in @property decorator&quot;&quot;&quot;        return 1            @property(cached=&quot;_che&quot;)    def che(self):        &quot;&quot;&quot;This will cache the return value into _che and add a setter/deleter&quot;&quot;&quot;        return 1```### Classproperty DecoratorAllows you to create a property on the class:```pythonfrom decorators import classpropertyclass Foo(object):    @classproperty    def bar(cls):        &quot;&quot;&quot;Available as Foo.bar&quot;&quot;&quot;        return 1        print(Foo.bar) # 1```## InstallationUse pip:    pip install decoratorsOr, to get the latest and greatest from source:    pip install -U &quot;git+https://github.com/Jaymon/decorators#egg=decorators&quot;</longdescription>
</pkgmetadata>