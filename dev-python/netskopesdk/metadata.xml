<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Netskope SDKNeskope SDK is Python library for dealing with API's to download the Netskope events. ## InstallationUse the package manager [pip](https://pip.pypa.io/en/stable/) to install NetskopeSDK.```bashpip install netskopesdk```## Rest sdk Usage to pull the Alert &amp; Events ```pythonfrom netskope_api.iterator.netskope_iterator import NetskopeIteratorfrom netskope_api.iterator.const import Constfrom requests.exceptions import RequestExceptionimport time# Construct the params dict to pass the authentication details params = {        Const.NSKP_TOKEN : &quot;&lt;REST-API-TOKEN&gt;&quot;,        Const.NSKP_TENANT_HOSTNAME : &quot;&lt;HOSTNAME&gt;&quot;,        # Optional param to pass the proxy hosts.        Const.NSKP_PROXIES : {&quot;&lt;PROXY-HOSTS&gt;&quot;},        Const.NSKP_EVENT_TYPE : &quot;&lt;EVENT-TYPE&gt;&quot;,        Const.NSKP_ITERATOR_NAME : &quot;&lt;ITERATOR-NAME&gt;&quot;,        Const.NSKP_USER_AGENT : &quot;&lt;SPLUNK-TENANT-HOSTNAME&gt;&quot;            # To query specific alert pass the NSKP_EVENT_TYPE as &quot;alert&quot; and the alert type.        # Const.NSKP_EVENT_TYPE : Const.EVENT_TYPE_ALERT,        # Const.NSKP_ALERT_TYPE : Const.ALERT_TYPE_DLP    }DEFAULT_WAIT_TIME = 30RESULT = &quot;result&quot;WAIT_TIME = &quot;wait_time&quot;# Create an Iteratoriterator = NetskopeIterator(params)# Use the next() iterator to download the logs. # Consume the message indefinitely in a loop and ingest the data to SIEMwhile True:    response = (iterator.next())    try:        if response:            data = response.json()            if RESULT in data and len(data[RESULT]) != 0:                # processData()                 # sleep() the thread to avoid constant polling                if WAIT_TIME in data:                    time.sleep(data[WAIT_TIME])                else:                    time.sleep(DEFAULT_WAIT_TIME)            else:                print(&quot;No response received from the iterator&quot;)                time.sleep(DEFAULT_WAIT_TIME)    except Exception as e:        time.sleep(DEFAULT_WAIT_TIME)        raise RequestException(e)```## Rest sdk Usage to retrieve tokens used for subscribing to transaction events from PSL.```pythonfrom requests.exceptions import RequestExceptionfrom netskope_api.iterator.const import Constfrom netskope_api.token_management.netskope_management import NetskopeTokenManagementif __name__ == '__main__':    params = {        Const.NSKP_TOKEN: &quot;&quot;,        Const.NSKP_TENANT_HOSTNAME: &quot;netskope.goskope.com&quot;        # Optional param to pass the proxy hosts.        Const.NSKP_PROXIES : {&quot;&lt;PROXY-HOSTS&gt;&quot;}    }    sub_path_response = None    sub_key_response = None    try:        # Create token_management client        token_management = NetskopeTokenManagement(params)        token_management_response = token_management.get()        if token_management_response:            if &quot;subscription&quot; in token_management_response:                sub_path_response = token_management_response[&quot;subscription&quot;]            if &quot;subscription-key&quot; in token_management_response:                sub_key_response = token_management_response[&quot;subscription-key&quot;]    except Exception as e:        raise RequestException(e)``````1. 401 response code means Customer is not authorized to create/get subscription key and path.2. 403 response code means Subscription key and path are already present for the customer which is explained in the following section.```## Onboard existing customers using the API.    regenerate_and_get() func can be used for onboarding existing customers who already downloaded the subscription key using tools â†’ event streaming section.    Regenerating subscription key will invalidate the existing key but subscription path will not be updated so that clients can continue consuming events where they left off while being onboarded using the API.## Note: Regenerating subscription key will invalidate the existing key.```pythonfrom requests.exceptions import RequestExceptionfrom netskope_api.iterator.const import Constfrom netskope_api.token_management.netskope_management import NetskopeTokenManagementif __name__ == '__main__':    params = {        Const.NSKP_TOKEN: &quot;&quot;,        Const.NSKP_TENANT_HOSTNAME: &quot;netskope.goskope.com&quot;        # Optional param to pass the proxy hosts.        Const.NSKP_PROXIES : {&quot;&lt;PROXY-HOSTS&gt;&quot;}    }    sub_path_response = None    sub_key_response = None    try:        # Create token_management client        token_management = NetskopeTokenManagement(params)        token_management_response = token_management.regenerate_and_get()        if token_management_response:            if &quot;subscription&quot; in token_management_response:                sub_path_response = token_management_response[&quot;subscription&quot;]            if &quot;subscription-key&quot; in token_management_response:                sub_key_response = token_management_response[&quot;subscription-key&quot;]    except Exception as e:        raise RequestException(e)```## Example usage of web txn tokens using Pubsublite client libraryPlease install Pubsublite client library if not present.```bashpip install google-cloud-pubsublite``````pythonimport concurrent.futuresimport loggingimport osfrom concurrent.futures._base import TimeoutErrorfrom google.cloud.pubsublite.cloudpubsub import SubscriberClientfrom google.cloud.pubsublite.types import FlowControlSettings, MessageMetadatafrom google.pubsub_v1 import PubsubMessagefrom requests.exceptions import RequestExceptionfrom netskope_api.iterator.const import Constfrom netskope_api.token_management.netskope_management import NetskopeTokenManagement_logger = logging.getLogger()def callback(message: PubsubMessage):    message_data = message.data.decode(&quot;utf-8&quot;)    metadata = MessageMetadata.decode(message.message_id)    _logger.info(        f&quot;Received {message_data} of ordering key {message.ordering_key} with id {metadata}.&quot;    )    message.ack()class PSLSubscriberClient:    def __init__(self):        configs = {            &quot;messages_outstanding&quot;: 1000,            &quot;bytes_outstanding&quot;: 3.5 * 1024 * 1024,            &quot;timeout&quot;: 60,            &quot;thread_count&quot;: 1        }        self.configs = configs    def make_default_thread_pool_executor(self):        return concurrent.futures.ThreadPoolExecutor(self.configs.get(&quot;thread_count&quot;))    def stream(self, subscription_path):        global streaming_pull_future        per_partition_flow_control_settings = FlowControlSettings(            # Must be &gt;0.            messages_outstanding=self.configs.get(&quot;messages_outstanding&quot;),            # Must be greater than the allowed size of the largest message.            bytes_outstanding=self.configs.get(&quot;bytes_outstanding&quot;),        )        executor = self.make_default_thread_pool_executor()        with SubscriberClient(executor=executor) as subscriber_client:            _logger.info(                &quot;Listening for messages on the pub sub lite subscription {}&quot;.format(subscription_path))            streaming_pull_future = subscriber_client.subscribe(                subscription_path,                callback=callback,                per_partition_flow_control_settings=per_partition_flow_control_settings,            )            try:                timeout = self.configs.get(&quot;timeout&quot;)                if timeout:                    streaming_pull_future.result(timeout=self.configs.get(&quot;timeout&quot;))                else:                    streaming_pull_future.result()            except TimeoutError or KeyboardInterrupt:                streaming_pull_future.cancel()                assert streaming_pull_future.done()if __name__ == '__main__':    params = {        Const.NSKP_TOKEN: &quot;&quot;,        Const.NSKP_TENANT_HOSTNAME: &quot;netskope.goskope.com&quot;        # Optional param to pass the proxy hosts.        Const.NSKP_PROXIES : {&quot;&lt;PROXY-HOSTS&gt;&quot;}    }    sub_path_response = None    sub_key_response = None    try:        # Create token_management client        token_management = NetskopeTokenManagement(params)        token_management_response = token_management.get()        if token_management_response:            if &quot;subscription&quot; in token_management_response:                sub_path_response = token_management_response[&quot;subscription&quot;]            if &quot;subscription-key&quot; in token_management_response:                sub_key_response = token_management_response[&quot;subscription-key&quot;]    except Exception as e:        raise RequestException(e)    os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = sub_key_response    psl_client = PSLSubscriberClient()    psl_client.stream(subscription_path=sub_path_response)```</longdescription>
</pkgmetadata>