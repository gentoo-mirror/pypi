<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Timeplus Python Client[Timeplus](https://www.timeplus.com/) is a real-time streaming data analytic platform.  Timeplus python client provides basic functionalities to interact with Timeplus cloud, to manage the streaming analytic work loads.## Installation```bashpip install timeplus```## DB APITimeplus python client support DB API defined in [Python Database API Specification v2.0](https://peps.python.org/pep-0249/).  ```pythonfrom timeplus.dbapi import connectapi_key = &quot;your_timeplus_apikey&quot;api_address = &quot;us.timeplus.cloud&quot;workspace = &quot;your_timeplus_workspace_id&quot;# create a connection using host/password/workspaceconn = connect(host=api_address, password=api_key, path=workspace)# run a streaming querycursor = conn.execute(&quot;select * from car_live_data&quot;)# get first result from the qeurynext_result = cusor.next()# get next one result from the qeuryrow1 = cursor.fetchone()# get next three resultrows = cursor.fetchmany(3)```Note, as the streaming query result is unbounded, the cursor will not end, fetch will be blocked is there is no new query result.## SQLAchamyTimeplus python client has implemeted a [SQLAlchemy](https://www.sqlalchemy.org/) dialect to run queries, so user can use it with SQLAlchemy API.```pythonimport osfrom sqlalchemy import create_engine, text, select, MetaData, Tablefrom sqlalchemy.dialects import registry# register timeplus dialectregistry.register(&quot;timeplus&quot;, &quot;timeplus.sqlalchemy&quot;, &quot;TimeplusDialect&quot;)api_key = os.environ.get(&quot;TIMEPLUS_API_KEY&quot;)api_address = &quot;dev.timeplus.cloud&quot;port = 443workspace = os.environ.get(&quot;TIMEPLUS_WORKSPACE&quot;) or &quot;tp-demo&quot;# create a new engineengine = create_engine(    f&quot;timeplus://:{api_key}@{api_address}:{port}/{workspace}&quot;)# execute streaming sqlwith engine.connect() as connection:    result = connection.execute(text(&quot;select * from car_live_data&quot;))    count = 0    max = 10    for row in result:        print(f&quot;got one row : {row}&quot;)        count += 1        if count &gt;= max:            break# execute statement using table from metadatametadata_obj = MetaData()car_table = Table(table_name, metadata_obj, autoload_with=engine)print(f&quot;reflected table is {car_table}&quot;)print(f&quot;cols is {[ (c.name, c.type) for c in car_table.columns]}&quot;)stmt = select(car_table).where(car_table.c.cid == &quot;c00001&quot;)print(stmt)with engine.connect() as conn:    count = 0    max = 3    for row in conn.execute(stmt):        print(f&quot;got one row from query {row}&quot;)        count += 1        if count &gt;= max:            break```## REST APITimeplus python client also provides resources wrapper which can be used to call the [Timeplus REST API](https://docs.timeplus.com/rest.html) through python object.here is a list of all supported resources| Resource              |  Supported Methods                                    ||-----------------------|--------------------------------------------|| [Stream](https://docs.timeplus.com/working-with-streams)| create,list,get,delete,ingest,exist        || [Query](https://docs.timeplus.com/stream-query)| create,list,get,delete,cancel,analyze      || [Source](https://docs.timeplus.com/source) | create,list,get,delete,start,stop          || [Sink](https://docs.timeplus.com/destination)| create,list,get,delete,start,stop          || [View](https://docs.timeplus.com/view)| create,list,get,delete,exist               || [UDF](https://docs.timeplus.com/udf)|  list                                       || [Alert](https://docs.timeplus.com/alert)| list                                       || [Dashboard](https://docs.timeplus.com/viz#dashboard) | list                                       |### queryRun streaming query and fetch the query result with query metrics.```pythonimport osimport tracebackimport jsonfrom pprint import pprintfrom timeplus import Query, Environmentapi_key = os.environ.get(&quot;TIMEPLUS_API_KEY&quot;)api_address = os.environ.get(&quot;TIMEPLUS_HOST&quot;)workspace = os.environ.get(&quot;TIMEPLUS_WORKSPACE&quot;)# Configure API key and addressenv = Environment().address(api_address).workspace(workspace).apikey(api_key)try:    # list all qeuries    query_list = Query(env=env).list()    pprint(f&quot;there are {len(query_list)} queries &quot;)    # create a new query    query = (        Query(env=env).sql(query=&quot;SELECT * FROM car_live_data&quot;)        # .batching_policy(1000, 1000)        .create()    )    pprint(f&quot;query with metadata {json.dumps(query.metadata())}&quot;)    # query header is the colume definitions of query result table    # it is a list of name/value pair    # for example : [{'name': 'in_use', 'type': 'bool'}, {'name': 'speed', 'type': 'float32'}]    query_header = query.header()    pprint(f&quot;query with header {query.header()}&quot;)    # iterate query result    limit = 3    count = 0    # query.result() is an iterator which will pull all the query result in small batches    # the iterator will continously pulling query result    # for streaming query, the iterator will not end until user cancel the query    for event in query.result():        # metric event return result time query metrics        # a sample metrics event:        # {'count': 117, 'eps': 75, 'processing_time': 1560,        # 'last_event_time': 1686237113265, 'response_time': 861,        # 'scanned_rows': 117, 'scanned_bytes': 7605}        if event.event == &quot;metrics&quot;:            pprint(json.loads(event.data))        # message event contains query result which is an array of arrays        # representing multiple query result rows        # a sample message event:        # [[True,-73.857],[False, 84.1]]        if event.event == &quot;message&quot;:            pprint(json.loads(event.data))        count += 1        if count &gt;= limit:            break    query.cancel()    query.delete()except Exception as e:    pprint(e)    traceback.print_exc()```### streamCreate/list/get/delete of streams```pythonimport osimport tracebackimport jsonfrom pprint import pprintfrom timeplus import Stream, Environmentapi_key = os.environ.get(&quot;TIMEPLUS_API_KEY&quot;)api_address = os.environ.get(&quot;TIMEPLUS_HOST&quot;)worksapce = os.environ.get(&quot;TIMEPLUS_WORKSAPCE&quot;)# Configure API key and addressenv = Environment().address(api_address).apikey(api_key).workspace(worksapce)try:    # list all streams    stream_list = Stream(env=env).list()    pprint(f&quot;there are {len(stream_list)} streams &quot;)    # create a new stream    stream = (        Stream(env=env)        .name(&quot;test&quot;)        .column(&quot;time&quot;, &quot;datetime64(3)&quot;)        .column(&quot;data&quot;, &quot;string&quot;)        .create()    )    stream_list = Stream(env=env).list()    pprint(f&quot;there are {len(stream_list)} streams after create&quot;)    pprint(f&quot;created stream is {stream.metadata()}; type is {type(stream.metadata())}&quot;)    a_stream = Stream(env=env).name(&quot;test&quot;).get()    pprint(f&quot;get stream is {a_stream.metadata()} ; type is {type(a_stream.metadata())}&quot;)    stream.delete()    stream_list = Stream(env=env).list()    pprint(f&quot;there are {len(stream_list)} streams after delete&quot;)except Exception as e:    pprint(e)    traceback.print_exc()```### ingestIngest data into streams#### default ingest```pythonstream = (        Stream(env=env)        .name(&quot;test_ingest&quot;)        .column(&quot;time&quot;, &quot;datetime64(3)&quot;)        .column(&quot;data&quot;, &quot;string&quot;)        .create()    )stream.ingest([&quot;time&quot;, &quot;data&quot;], [[datetime.datetime.now(), &quot;abcd&quot;]])```#### ingest json streams```pythonstream = (        Stream(env=env)        .name(&quot;test_ingest&quot;)        .column(&quot;a&quot;, &quot;integer&quot;)        .column(&quot;b&quot;, &quot;string&quot;)        .create()    )payload = &quot;&quot;&quot;{&quot;a&quot;:2,&quot;b&quot;:&quot;hello&quot;}{&quot;a&quot;:1,&quot;b&quot;:&quot;world&quot;}&quot;&quot;&quot;stream.ingest(payload=payload, format=&quot;streaming&quot;)```#### ingest one raw event with multiple lines```pythonstream = Stream(env=env).name(&quot;test_ingest_raw&quot;).column(&quot;raw&quot;, &quot;string&quot;).create()payload = &quot;&quot;&quot;first linesecond line&quot;&quot;&quot;stream.ingest(payload=payload, format=&quot;raw&quot;)```#### ingest multiple lines json```pythonstream = Stream(env=env).name(&quot;test_ingest_lines&quot;).column(&quot;raw&quot;, &quot;string&quot;).create()payload = '{&quot;a&quot;:1,&quot;b&quot;:&quot;world&quot;}\n{&quot;a&quot;:2,&quot;b&quot;:&quot;hello&quot;}'stream.ingest(payload=payload, format=&quot;lines&quot;)```## ExamplesMore sample code can be found [here](../examples/helloworld/)</longdescription>
</pkgmetadata>