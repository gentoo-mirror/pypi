<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;img width=&quot;616&quot; alt=&quot;scrapbook logo&quot; src=&quot;https://user-images.githubusercontent.com/836375/52512549-31260f00-2bba-11e9-9556-515ba5ff0b4b.png&quot;&gt;# scrapbook&lt;!---(binder links generated at https://mybinder.readthedocs.io/en/latest/howto/badges.html and compressed at https://tinyurl.com) --&gt;[![Travis Build Status](https://travis-ci.org/nteract/scrapbook.svg?branch=main)](https://travis-ci.org/nteract/scrapbook)[![image](https://codecov.io/github/nteract/scrapbook/coverage.svg?branch=main)](https://codecov.io/github/nteract/scrapbook=main)[![Documentation Status](https://readthedocs.org/projects/nteract-scrapbook/badge/?version=latest)](https://nteract-scrapbook.readthedocs.io/en/latest/?badge=latest)[![badge](https://tinyurl.com/y3moqkmc)](https://mybinder.org/v2/gh/nteract/scrapbook/main?filepath=binder%2Freglue_highlight_dates.ipynb)[![badge](https://tinyurl.com/ybk8qa3j)](https://mybinder.org/v2/gh/nteract/scrapbook/main?filepath=binder%2FResultsDemo.ipynb)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)The **scrapbook** library records a notebookâ€™s data values and generated visualcontent as &quot;scraps&quot;. Recorded scraps can be read at a future time.[See the scrapbook documentation](https://nteract-scrapbook.readthedocs.io/) formore information on how to use scrapbook.## Use CasesNotebook users may wish to record data produced during a notebook's execution.This recorded data, **scraps**, can be used at a later time or passed in aworkflow to another notebook as input.Namely, scrapbook lets you:- **persist** data and visual content displays in a notebook as scraps- **recall** any persisted scrap of data- **summarize collections** of notebooks## Python Version SupportThis library's long term support target is Python 3.5+. It currently alsosupports Python 2.7 until Python 2 reaches end-of-life in 2020. After thisdate, Python 2 support will halt, and only 3.x versions will be maintained.## InstallationInstall using `pip`:```{.sourceCode .bash}pip install scrapbook```For installing optional IO dependencies, you can specify individual store bundles,like `s3` or `azure`:```{.sourceCode .bash}pip install scrapbook[s3]```or use `all`:```{.sourceCode .bash}pip install scrapbook[all]```---## Models and TerminologyScrapbook defines the following items:- **scraps**: serializable data values and visualizations such as strings, lists of  objects, pandas dataframes, charts, images, or data references.- **notebook**: a wrapped nbformat notebook object with extra methods for interacting  with scraps.- **scrapbook**: a collection of notebooks with an interface for asking questions of  the collection.- **encoders**: a registered translator of data to/from notebook  storage formats.### `scrap` modelThe `scrap` model houses a few key attributes in a tuple, including:- **name**: The name of the scrap- **data**: Any data captured by the scrapbook api call- **encoder**: The name of the encoder used to encode/decode data to/from the notebook- **display**: Any display data used by IPython to display visual content---## APIScrapbook adds a few basic api commands which enable saving and retrieving dataincluding:- `glue` to persist scraps with or without _display output_- `read_notebook` reads one notebook- `scraps` provides a searchable dictionary of all scraps by name- `reglue` which copies a scrap from another notebook to the current notebook- `read_notebooks` reads many notebooks from a given path- `scraps_report` displays a report about collected scraps- `papermill_dataframe` and `papermill_metrics` for backward compatibility  for two deprecated papermill featuresThe following sections provide more detail on these api commands.### `glue` to persist scrapsRecords a `scrap` (data or display value) in the given notebook cell.The `scrap` (recorded value) can be retrieved during later inspection of theoutput notebook.```python&quot;&quot;&quot;glue example for recording data values&quot;&quot;&quot;import scrapbook as sbsb.glue(&quot;hello&quot;, &quot;world&quot;)sb.glue(&quot;number&quot;, 123)sb.glue(&quot;some_list&quot;, [1, 3, 5])sb.glue(&quot;some_dict&quot;, {&quot;a&quot;: 1, &quot;b&quot;: 2})sb.glue(&quot;non_json&quot;, df, 'arrow')```The scrapbook library can be used later to recover `scraps` from the outputnotebook:```python# read a notebook and get previously recorded scrapsnb = sb.read_notebook('notebook.ipynb')nb.scraps```**scrapbook** will imply the storage format by the value type of any registereddata encoders. Alternatively, the implied encoding format can be overwritten bysetting the `encoder` argument to the registered name (e.g. `&quot;json&quot;`) of aparticular encoder.This data is persisted by generating a display output with a special media typeidentifying the content encoding format and data. These outputs are not alwaysvisible in notebook rendering but still exist in the document. Scrapbook canthen rehydrate the data associated with the notebook in the future by readingthese cell outputs.#### With _display output_To display a named scrap with visible display outputs, you need to indicate thatthe scrap is directly renderable.This can be done by toggling the `display` argument.```python# record a UI message along with the input stringsb.glue(&quot;hello&quot;, &quot;Hello World&quot;, display=True)```The call will save the data and the display attributes of the Scrap object,making it visible as well as encoding the original data. This leans on the`IPython.core.formatters.format_display_data` function to translate the dataobject into a display and metadata dict for the notebook kernel to parse.Another pattern that can be used is to specify that **only the display data**should be saved, and not the original object. This is achieved by settingthe encoder to be `display`.```python# record an image without the original input objectsb.glue(&quot;sharable_png&quot;,  IPython.display.Image(filename=&quot;sharable.png&quot;),  encoder='display')```Finally the media types that are generated can be controlled by passinga list, tuple, or dict object as the display argument.```pythonsb.glue(&quot;media_as_text_only&quot;,  media_obj,  encoder='display',  display=('text/plain',) # This passes [text/plain] to format_display_data's include argument)sb.glue(&quot;media_without_text&quot;,  media_obj,  encoder='display',  display={'exclude': 'text/plain'} # forward to format_display_data's kwargs)```Like data scraps, these can be retrieved at a later time be accessing the scrap's`display` attribute. Though usually one will just use Notebook's `reglue` method(described below).### `read_notebook` reads one notebookReads a Notebook object loaded from the location specified at `path`.You've already seen how this function is used in the above api call examples,but essentially this provides a thin wrapper over an `nbformat`'s NotebookNodewith the ability to extract scrapbook scraps.```pythonnb = sb.read_notebook('notebook.ipynb')```This Notebook object adheres to the [nbformat's json schema](https://github.com/jupyter/nbformat/blob/master/nbformat/v4/nbformat.v4.schema.json),allowing for access to its required fields.```pythonnb.cells # The cells from the notebooknb.metadatanb.nbformatnb.nbformat_minor```There's a few additional methods provided, most of which are outlined in more detailbelow:```pythonnb.scrapsnb.reglue```The abstraction also makes saved content available as a dataframe referencing eachkey and source. More of these methods will be made available in later versions.```python# Produces a data frame with [&quot;name&quot;, &quot;data&quot;, &quot;encoder&quot;, &quot;display&quot;, &quot;filename&quot;] as columnsnb.scrap_dataframe # Warning: This might be a large object if data or display is large```The Notebook object also has a few legacy functions for backwards compatibilitywith papermill's Notebook object model. As a result, it can be used to readpapermill execution statistics as well as scrapbook abstractions:```pythonnb.cell_timing # List of cell execution timings in cell ordernb.execution_counts # List of cell execution counts in cell ordernb.papermill_metrics # Dataframe of cell execution counts and timesnb.papermill_record_dataframe # Dataframe of notebook records (scraps with only data)nb.parameter_dataframe # Dataframe of notebook parametersnb.papermill_dataframe # Dataframe of notebook parameters and cell scraps```The notebook reader relies on [papermill's registered iorw](https://papermill.readthedocs.io/en/latest/reference/papermill-io.html)to enable access to a variety of sources such as -- but not limited to -- S3,Azure, and Google Cloud.### `scraps` provides a name -&gt; scrap lookupThe `scraps` method allows for access to all of the scraps in a particular notebook.```pythonnb = sb.read_notebook('notebook.ipynb')nb.scraps # Prints a dict of all scraps by name```This object has a few additional methods as well for convenient conversion andexecution.```pythonnb.scraps.data_scraps # Filters to only scraps with `data` associatednb.scraps.data_dict # Maps `data_scraps` to a `name` -&gt; `data` dictnb.scraps.display_scraps # Filters to only scraps with `display` associatednb.scraps.display_dict # Maps `display_scraps` to a `name` -&gt; `display` dictnb.scraps.dataframe # Generates a dataframe with [&quot;name&quot;, &quot;data&quot;, &quot;encoder&quot;, &quot;display&quot;] as columns```These methods allow for simple use-cases to not require digging through modelabstractions.### `reglue` copys a scrap into the current notebookUsing `reglue` one can take any scrap glue'd into one notebook and glue into thecurrent one.```pythonnb = sb.read_notebook('notebook.ipynb')nb.reglue(&quot;table_scrap&quot;) # This copies both data and displays```Any data or display information will be copied verbatim into the currentlyexecuting notebook as though the user called `glue` again on the original source.It's also possible to rename the scrap in the process.```pythonnb.reglue(&quot;table_scrap&quot;, &quot;old_table_scrap&quot;)```And finally if one wishes to try to reglue without checking for existence the`raise_on_missing` can be set to just display a message on failure.```pythonnb.reglue(&quot;maybe_missing&quot;, raise_on_missing=False)# =&gt; &quot;No scrap found with name 'maybe_missing' in this notebook&quot;```### `read_notebooks` reads many notebooksReads all notebooks located in a given `path` into a Scrapbook object.```python# create a scrapbook named `book`book = sb.read_notebooks('path/to/notebook/collection/')# get the underlying notebooks as a listbook.notebooks # Or `book.values````The path reuses [papermill's registered `iorw`](https://papermill.readthedocs.io/en/latest/reference/papermill-io.html)to list and read files form various sources, such that non-local urls can load data.```python# create a scrapbook named `book`book = sb.read_notebooks('s3://bucket/key/prefix/to/notebook/collection/')```The Scrapbook (`book` in this example) can be used to recall all scraps acrossthe collection of notebooks:```pythonbook.notebook_scraps # Dict of shape `notebook` -&gt; (`name` -&gt; `scrap`)book.scraps # merged dict of shape `name` -&gt; `scrap````### `scraps_report` displays a report about collected scrapsThe Scrapbook collection can be used to generate a `scraps_report` on all thescraps from the collection as a markdown structured output.```pythonbook.scraps_report()```This display can filter on scrap and notebook names, as well as enable or disablean overall header for the display.```pythonbook.scraps_report(  scrap_names=[&quot;scrap1&quot;, &quot;scrap2&quot;],  notebook_names=[&quot;result1&quot;], # matches `/notebook/collections/result1.ipynb` pathed notebooks  header=False)```By default the report will only populate with visual elements. To alsoreport on data elements set include_data.```pythonbook.scraps_report(include_data=True)```### papermill supportFinally the scrapbook provides two backwards compatible features for deprecated`papermill` capabilities:```pythonbook.papermill_dataframebook.papermill_metrics```## EncodersEncoders are accessible by key names to Encoder objects registeredagainst the `encoders.registry` object. To register new data encoderssimply call:```pythonfrom encoder import registry as encoder_registry# add encoder to the registryencoder_registry.register(&quot;custom_encoder_name&quot;, MyCustomEncoder())```The encode class must implement two methods, `encode` and `decode`:```pythonclass MyCustomEncoder(object):    def encode(self, scrap):        # scrap.data is any type, usually specific to the encoder name        pass  # Return a `Scrap` with `data` type one of [None, list, dict, *six.integer_types, *six.string_types]    def decode(self, scrap):        # scrap.data is one of [None, list, dict, *six.integer_types, *six.string_types]        pass  # Return a `Scrap` with `data` type as any type, usually specific to the encoder name```This can read transform scraps into a json object representing their contents orlocation and load those strings back into the original data objects.### `text`A basic string storage format that saves data as python strings.```pythonsb.glue(&quot;hello&quot;, &quot;world&quot;, &quot;text&quot;)```### `json````pythonsb.glue(&quot;foo_json&quot;, {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: 1}, &quot;json&quot;)```### `pandas````pythonsb.glue(&quot;pandas_df&quot;,pd.DataFrame({'col1': [1, 2], 'col2': [3, 4]}), &quot;pandas&quot;)```## papermill's deprecated `record` feature**scrapbook** provides a robust and flexible recording schema. This library replaces [papermill](https://papermill.readthedocs.io)'s existing`record` functionality.[Documentation for papermill `record`](https://papermill.readthedocs.io/en/latest/usage-recording.html?#recording-values-to-the-notebook) exists on ReadTheDocs.In brief, the deprecated `record` function:`pm.record(name, value)`: enables values to be savedwith the notebook [[API documentation]](https://papermill.readthedocs.io/en/latest/reference/papermill.html#papermill.api.record)```pythonpm.record(&quot;hello&quot;, &quot;world&quot;)pm.record(&quot;number&quot;, 123)pm.record(&quot;some_list&quot;, [1, 3, 5])pm.record(&quot;some_dict&quot;, {&quot;a&quot;: 1, &quot;b&quot;: 2})````pm.read_notebook(notebook)`: pandas could be used later to recover recordedvalues by reading the output notebook into a dataframe. For example:```pythonnb = pm.read_notebook('notebook.ipynb')nb.dataframe```### Rationale for Papermill `record` deprecationPapermill's `record` function was deprecated due to these limitations and challenges:- The `record` function didn't follow papermill's pattern of linear execution  of a notebook. It was awkward to describe `record` as an additional  feature of papermill, and really felt like describing a second less  developed library.- Recording / Reading required data translation to JSON for everything. This is  a tedious, painful process for dataframes.- Reading recorded values into a dataframe would result in unintuitive dataframe  shapes.- Less modularity and flexiblity than other papermill components where custom  operators can be registered.To overcome these limitations in Papermill, a decision was made to create**Scrapbook**.</longdescription>
</pkgmetadata>