<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># docx2pythonExtract docx headers, footers, text, footnotes, endnotes, properties, and images to a Python object.`README_DOCX_FILE_STRUCTURE.md` may help if you'd like to extend docx2python.For a summary of what's new in docx2python 2, scroll down to **New in docx2python Version 2**The code is an expansion/contraction of [python-docx2txt](https://github.com/ankushshah89/python-docx2txt) (Copyright (c) 2015 Ankush Shah). The original code is mostly gone, but some of the bones may still be here.__shared features__:* extracts text from docx files* extracts images from docx files__additions:__* extracts footnotes and endnotes* converts bullets and numbered lists to ascii with indentation* converts hyperlinks to ``&lt;a href=&quot;http:/...&quot;&gt;link text&lt;/a&gt;``* retains some structure of the original file (more below)* extracts document properties (creator, lastModifiedBy, etc.)* inserts image placeholders in text (``'----image1.jpg----'``)* inserts plain text footnote and endnote references in text (``'----footnote1----'``)* (optionally) retains font size, font color, bold, italics, and underscore as html* extract math equations* extract user selections from checkboxes and dropdown menus__subtractions:__* no command-line interface* will only work with Python 3.8+## Installation```bashpip install docx2python```## Use``` pythonfrom docx2python import docx2python# extract docx contentwith docx2python('path/to/file.docx') as docx_content:    print(docx_content.text)docx_content = docx2python('path/to/file.docx')print(docx_content.text)docx_content.close()# extract docx content, write images to image_directorywith docx2python('path/to/file.docx', 'path/to/image_directory') as docx_content:    print(docx_content.text)# extract docx content with basic font styles converted to htmlwith docx2python('path/to/file.docx', html=True) as docx_content:    print(docx_content.text)````docx2python` opens a zipfile object and (lazily) reads it. Use context management (`with ... as`) to close this zipfile object or explicitly close with `docx_content.close()`.Note on html feature:* supports ``&lt;i&gt;``italic, ``&lt;b&gt;``bold, ``&lt;u&gt;``underline, ``&lt;s&gt;``strike, ``&lt;sup&gt;``superscript, ``&lt;sub&gt;``subscript, ``&lt;span style=&quot;font-variant: small-caps&quot;&gt;``small caps, ``&lt;span style=&quot;text-transform:uppercase&quot;&gt;``all caps, ``&lt;span style=&quot;background-color: yellow&quot;&gt;``highlighted, ``&lt;span style=&quot;font-size:32&quot;&gt;``font size, ``&lt;span style=&quot;color:#ff0000&quot;&gt;``colored text.* hyperlinks will always be exported as html (``&lt;a href=&quot;http:/...&quot;&gt;link text&lt;/a&gt;``), even if ``html=False``, because I couldn't think of a more canonical representation.* every tag open in a paragraph will be closed in that paragraph (and, where appropriate, reopened in the next paragraph). If two subsequenct paragraphs are bold, they will be returned as `&lt;b&gt;paragraph a&lt;/b&gt;`, `&lt;b&gt;paragraph b&lt;/b&gt;`. This is intentional to make  each paragraph its own entity.* if you specify `html=True`, `&amp;`, `&gt;` and `&lt;` in your docx text will be encoded as `&amp;amp`, `&amp;gt;` and `&amp;lt;`## Return ValueFunction `docx2python` returns a DocxContent instance with several attributes.__header__ - contents of the docx headers in the return format described herein__footer__ - contents of the docx footers in the return format described herein__body__ - contents of the docx in the return format described herein__footnotes__ - contents of the docx in the return format described herein__endnotes__ - contents of the docx in the return format described herein__document__ - header  + body + footer (read only)__text__ - all docx text as one string, similar to what you'd get from `python-docx2txt`__properties__ - docx property names mapped to values (e.g., `{&quot;lastModifiedBy&quot;: &quot;Shay Hill&quot;}`)__images__ - image names mapped to images in binary format. Write to filesystem with```for name, image in result.images.items():    with open(name, 'wb') as image_destination:        write(image_destination, image)# orwith docx2python('path/to/file.docx', 'path/to/image/directory') as docx_content:    ...# orwith docx2python('path/to/file.docx') as docx_content:    docx_content.save_images('path/to/image/directory')```__docx_reader__ - a DocxReader (see `docx_reader.py`) instance with several methods for extracting xml portions.## Arguments    def docx2python(        docx_filename: str | Path | BytesIO,        image_folder: str | None = None,        html: bool = False,        paragraph_styles: bool = False,        extract_image: bool | None = None,        duplicate_merged_cells: bool = False    ) -&gt; DocxContent:        &quot;&quot;&quot;        Unzip a docx file and extract contents.        :param docx_filename: path to a docx file        :param image_folder: optionally specify an image folder            (images in docx will be copied to this folder)        :param html: bool, extract some formatting as html        :param paragraph_styles: prepend the paragraphs style (if any, else &quot;&quot;) to each            paragraph. This will only be useful with ``*_runs`` attributes.        :param duplicate_merged_cells: bool, duplicate merged cells to return a mxn            nested list for each table (default False)        :return: DocxContent object        &quot;&quot;&quot;## Return FormatSome structure will be maintained. Text will be returned in a nested list, with paragraphs always at depth 4 (i.e., `output.body[i][j][k][l]` will be a paragraph).If your docx has no tables, output.body will appear as one a table with all content in one cell:```python[  # document    [  # table        [  # row            [  # cell                &quot;Paragraph 1&quot;,                &quot;Paragraph 2&quot;,                &quot;-- bulleted list&quot;,                &quot;-- continuing bulleted list&quot;,                &quot;1)  numbered list&quot;,                &quot;2)  continuing numbered list&quot;                &quot;    a)  sublist&quot;,                &quot;        i)  sublist of sublist&quot;,                &quot;3)  keeps track of indention levels&quot;,                &quot;    a)  resets sublist counters&quot;            ]        ]     ] ]```Table cells will appear as table cells. Text outside tables will appear as table cells.A docx document can be tables within tables within tables. Docx2Python flattens most of this to more easily navigatewithin the content.## Working with outputThis package provides several documented helper functions in [the ``docx2python.iterators`` module](https://docx2python.readthedocs.io/en/latest/docx2python.html#module-iterators). Here are a few recipes possible with these functions:```pythonfrom docx2python.iterators import enum_cellsdef remove_empty_paragraphs(tables):    for (i, j, k), cell in enum_cells(tables):        tables[i][j][k] = [x for x in cell if x]``````&gt;&gt;&gt; tables = [[[['a', 'b'], ['a', '', 'd', '']]]]&gt;&gt;&gt; remove_empty_paragraphs(tables)    [[[['a', 'b'], ['a', 'd']]]]``````pythonfrom docx2python.iterators import enum_at_depthdef html_map(tables) -&gt; str:    &quot;&quot;&quot;Create an HTML map of document contents.    Render this in a browser to visually search for data.    :tables: value could come from, e.g.,        * docx_to_text_output.document        * docx_to_text_output.body    &quot;&quot;&quot;    # prepend index tuple to each paragraph    for (i, j, k, l), paragraph in enum_at_depth(tables, 4):        tables[i][j][k][l] = &quot; &quot;.join([str((i, j, k, l)), paragraph])    # wrap each paragraph in &lt;pre&gt; tags    for (i, j, k), cell in enum_at_depth(tables, 3):        tables[i][j][k] = &quot;&quot;.join([&quot;&lt;pre&gt;{x}&lt;/pre&gt;&quot;.format(x) for x in cell])    # wrap each cell in &lt;td&gt; tags    for (i, j), row in enum_at_depth(tables, 2):        tables[i][j] = &quot;&quot;.join([&quot;&lt;td&gt;{x}&lt;/td&gt;&quot;.format(x) for x in row])    # wrap each row in &lt;tr&gt; tags    for (i,), table in enum_at_depth(tables, 1):        tables[i] = &quot;&quot;.join(&quot;&lt;tr&gt;{x}&lt;/tr&gt;&quot;.format(x) for x in table)    # wrap each table in &lt;table&gt; tags    tables = &quot;&quot;.join(['&lt;table border=&quot;1&quot;&gt;{x}&lt;/table&gt;'.format(x) for x in tables])    return [&quot;&lt;html&gt;&lt;body&gt;&quot;] + tables + [&quot;&lt;/body&gt;&lt;/html&gt;&quot;]``````&gt;&gt;&gt; tables = [[[['a', 'b'], ['a', 'd']]]]&gt;&gt;&gt; html_map(tables)&lt;html&gt;    &lt;body&gt;        &lt;table border=&quot;1&quot;&gt;            &lt;tr&gt;                &lt;td&gt;                    '(0, 0, 0, 0) a'                    '(0, 0, 0, 1) b'                &lt;/td&gt;                &lt;td&gt;                    '(0, 0, 1, 0) a'                    '(0, 0, 1, 1) d'                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;```[See helper functions.](https://docx2python.readthedocs.io/en/latest/index.html)Some fine print about checkboxes:MS Word has checkboxes that can be checked any time, and others that can only be checked when the form is locked.The previous print as. ``\u2610`` (open checkbox) or ``\u2612`` (crossed checkbox). Which this module, the latter willtoo. I gave checkboxes a bailout value of ``----checkbox failed----`` if the xml doesn't look like I expect it to,because I don't have several-thousand test files with checkboxes (as I did with most of the other form elements).Checkboxes *should* work, but please let me know if you encounter any that do not.# New in docx2python Version 2## merge consecutive runs with identical formattingMS Word will break up text runs arbitrarily, often in the middle of a word.    &lt;w:r&gt;        &lt;w:t&gt;work to im&lt;/w:t&gt;    &lt;/w:r&gt;    &lt;w:r&gt;        &lt;w:t&gt;prove docx2python&lt;/w:t&gt;    &lt;/w:r&gt;This makes things like algorithmic search-and-replace problematic. Docx2python does not currently write docx files,but I often use docx templates with placeholders (e.g., `#CATEGORY_NAME#`) then replace those placeholders with data.This won't work if your placeholders are broken up (e.g, `#CAT`, `E`, `GORY_NAME#`).Docx2python v1 merges such runs together when exporting text. Docx2python v2 will merge such runs in the XML as apre-processing step. This will allow saving such &quot;repaired&quot; XML later on.## merge consecutive links with identical hrefsMS Word will break up links, giving each link a different `rId`, even when these `rIds` point to the same address.    &lt;w:hyperlink r:id=&quot;rId13&quot;&gt;  # rID13 points to https://github.com/ShayHill/docx2python        &lt;w:r&gt;            &lt;w:t&gt;docx2py&lt;/w:t&gt;        &lt;/w:r&gt;    &lt;/w:hyperlink&gt;    &lt;w:hyperlink r:id=&quot;rId14&quot;&gt;  # rID14 ALSO points to https://github.com/ShayHill/docx2python        &lt;w:r&gt;            &lt;w:t&gt;thon&lt;/w:t&gt;        &lt;/w:r&gt;    &lt;/w:hyperlink&gt;This is similar to the broken-up runs, but the cause is a little deeper in. Docx2python v1 makes a mess of these.    &lt;a href=&quot;https://github.com/ShayHill/docx2python&quot;&gt;docx2py&lt;/a&gt;    &lt;a href=&quot;https://github.com/ShayHill/docx2python&quot;&gt;thon&lt;/a&gt;Docx2python v2 will merge such links together in the XML as a pre-processing step. As above, this will allow savingsuch &quot;repaired&quot; XML later on.## correctly handle nested paragraphsMS Word will nest paragraphs    &lt;w:p&gt;        &lt;w:r&gt;            &lt;w:t&gt;text&lt;/w:t&gt;        &lt;/w:r&gt;        &lt;w:p&gt;  # paragraph inside a paragraph            &lt;w:r&gt;                &lt;w:t&gt;text&lt;/w:t&gt;            &lt;/w:r&gt;        &lt;/w:p&gt;        &lt;w:r&gt;            &lt;w:t&gt;text&lt;/w:t&gt;        &lt;/w:r&gt;    &lt;/w:p&gt;I haven't been able to create such a paragraph, but I've found a few files that have them. Docx2pyhon v1 will omitclosing html tags when a new paragraph is opened before the old paragraph is closed.    &lt;b&gt;outer par bold text    &lt;i&gt;This text is in nested par (not bold)&lt;/i&gt;    outer par bold text&lt;/b&gt;Docx2python v2 will correctly handle such cases, but this will require substantial internal changes to the waydocx2python opens and closes paragraphs.    &lt;b&gt;outer par bold text&lt;/b&gt;    &lt;i&gt;This text is in nested par (not bold)&lt;/i&gt;    &lt;/b&gt;outer par bold text&lt;/b&gt;## paragraph stylesThe internal changes allow for easy access to paragraph styles (e.g., `Heading 1`). Docx2python v1 ignores these, evenwith `html=True`. Docx2python v2 will capture paragraph styles.    &lt;h1&gt;h1 is a paragraph style&lt;b&gt;bold is a run style&lt;/b&gt;&lt;/h1&gt;## export xmlTo allow above-described light editing (e.g., search and replace), docx2python v2 will give the user access to    1. extracted xml files    2. the functions used to write these files to a docxThe user can only go so far with this. A docx file is built from folders full of xml files. None of these xmlfiles are self contained. But search and replace is enough to make document templates (documents with placeholders fordata), and that's pretty useful in itself.## expose some intermediate functionalityNavigating through XML is straightforward with `lxml`. It is a separate step to take whatever you find and bring it*out* of the XML. For instance, you may want to iterate over a document, looking for paragraphs with a particularformat, then pull the text out of those paragraphs. Docx2python v1 did not separate or expose &quot;iter the document&quot; and&quot;pull the content&quot;. Docx2python v2 separates and exposes these steps. This will allow easier extension.See the `docx_reader.py` module and simple examples in the `utilities.py` module.## see utilities.py for examples of major new features.</longdescription>
</pkgmetadata>