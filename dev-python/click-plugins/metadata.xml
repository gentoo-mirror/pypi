<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=============click-plugins=============.. image:: https://travis-ci.org/click-contrib/click-plugins.svg?branch=master    :target: https://travis-ci.org/click-contrib/click-plugins?branch=master.. image:: https://coveralls.io/repos/click-contrib/click-plugins/badge.svg?branch=master&amp;service=github    :target: https://coveralls.io/github/click-contrib/click-plugins?branch=masterAn extension module for `click &lt;https://github.com/mitsuhiko/click&gt;`_ to registerexternal CLI commands via setuptools entry-points.Why?----Lets say you develop a commandline interface and someone requests a new featurethat is absolutely related to your project but would have negative consequenceslike additional dependencies, major refactoring, or maybe its just too domainspecific to be supported directly.  Rather than developing a separate standaloneutility you could offer up a `setuptools entry point &lt;https://pythonhosted.org/setuptools/setuptools.html#dynamic-discovery-of-services-and-plugins&gt;`_that allows others to use your commandline utility as a home for their relatedsub-commands.  You get to choose where these sub-commands or sub-groups CAN beregistered but the plugin developer gets to choose they ARE registered.  Youcould have all plugins register alongside the core commands, in a specialsub-group, across multiple sub-groups, or some combination.Enabling Plugins----------------For a more detailed example see the `examples &lt;https://github.com/click-contrib/click-plugins/tree/master/example&gt;`_ section.The only requirement is decorating ``click.group()`` with ``click_plugins.with_plugins()``which handles attaching external commands and groups.  In this case the core CLI developerregisters CLI plugins from ``core_package.cli_plugins``... code-block:: python    from pkg_resources import iter_entry_points    import click    from click_plugins import with_plugins    @with_plugins(iter_entry_points('core_package.cli_plugins'))    @click.group()    def cli():        &quot;&quot;&quot;Commandline interface for yourpackage.&quot;&quot;&quot;    @cli.command()    def subcommand():        &quot;&quot;&quot;Subcommand that does something.&quot;&quot;&quot;Developing Plugins------------------Plugin developers need to register their sub-commands or sub-groups to anentry-point in their ``setup.py`` that is loaded by the core package... code-block:: python    from setuptools import setup    setup(        name='yourscript',        version='0.1',        py_modules=['yourscript'],        install_requires=[            'click',        ],        entry_points='''            [core_package.cli_plugins]            cool_subcommand=yourscript.cli:cool_subcommand            another_subcommand=yourscript.cli:another_subcommand        ''',    )Broken and Incompatible Plugins-------------------------------Any sub-command or sub-group that cannot be loaded is caught and converted toa ``click_plugins.core.BrokenCommand()`` rather than just crashing the entireCLI.  The short-help is converted to a warning message like:.. code-block:: console    Warning: could not load plugin. See ``&lt;CLI&gt; &lt;command/group&gt; --help``.and if the sub-command or group is executed the entire traceback is printed.Best Practices and Extra Credit-------------------------------Opening a CLI to plugins encourages other developers to independently extendfunctionality independently but there is no guarantee these new features willbe &quot;on brand&quot;.  Plugin developers are almost certainly already using featuresin the core package the CLI belongs to so defining commonly used arguments andoptions in one place lets plugin developers reuse these flags to produce a morecohesive CLI.  If the CLI is simple maybe just define them at the top of``yourpackage/cli.py`` or for more complex packages something like``yourpackage/cli/options.py``.  These common options need to be easy to findand be well documented so that plugin developers know what variable to give totheir sub-command's function and what object they can expect to receive.  Don'tforget to document non-obvious callbacks.Keep in mind that plugin developers also have access to the parent group's``ctx.obj``, which is very useful for passing things like verbosity levels orconfig values around to sub-commands.Here's some code that sub-commands could re-use:.. code-block:: python    from multiprocessing import cpu_count    import click    jobs_opt = click.option(        '-j', '--jobs', metavar='CORES', type=click.IntRange(min=1, max=cpu_count()), default=1,        show_default=True, help=&quot;Process data across N cores.&quot;    )Plugin developers can access this with:.. code-block:: python    import click    import parent_cli_package.cli.options    @click.command()    @parent_cli_package.cli.options.jobs_opt    def subcommand(jobs):        &quot;&quot;&quot;I do something domain specific.&quot;&quot;&quot;Installation------------With ``pip``:.. code-block:: console    $ pip install click-pluginsFrom source:.. code-block:: console    $ git clone https://github.com/click-contrib/click-plugins.git    $ cd click-plugins    $ python setup.py installDeveloping----------.. code-block:: console    $ git clone https://github.com/click-contrib/click-plugins.git    $ cd click-plugins    $ pip install -e .\[dev\]    $ pytest tests --cov click_plugins --cov-report term-missingChangelog---------See ``CHANGES.txt``Authors-------See ``AUTHORS.txt``License-------See ``LICENSE.txt``</longdescription>
</pkgmetadata>