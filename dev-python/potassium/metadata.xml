<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Potassium![Potassium (1)](https://user-images.githubusercontent.com/44653944/222016748-ca2c6905-8fd5-4ee5-a68e-7aed48f23436.png)[Potassium](https://github.com/bananaml/potassium) is an open source web framework, built to tackle the unique challenges of serving custom models in production.The goal of this project is to:- Provide a familiar web framework similar to Flask/FastAPI- Bake in best practices for handling large, GPU-bound ML models- Provide a set of primitives common in ML serving, such as:    - POST request handlers    - Websocket / streaming connections    - Async handlers w/ webhooks- Maintain a standard interface, to allow the code and models to compile to specialized hardware (ideally on [Banana Serverless GPUs](https://banana.dev) ðŸ˜‰)### Stability Notes:Potassium uses Semantic Versioning, in that major versions imply breaking changes, and v0 implies instability even between minor/patch versions. Be sure to lock your versions, as we're still in v0!---## Quickstart: Serving a Huggingface BERT modelThe fastest way to get up and running is to use the [Banana CLI](https://github.com/bananaml/banana-cli), which downloads and runs your first model.[Here's a demo video](https://www.loom.com/share/86d4e7b0801549b9ab2f7a1acce772aa)1. Install the CLI with pip```bashpip3 install banana-cli```This downloads boilerplate for your potassium app, and automatically installs potassium into the venv.2. Create a new project directory with ```bashbanana init my-appcd my-app```3. Start the dev server```bash. ./venv/bin/activatepython3 app.py```4. Call your API (from a separate terminal)```bashcurl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;prompt&quot;: &quot;Hello I am a [MASK] model.&quot;}' http://localhost:8000/``` ---## Or do it yourself:1. Install the potassium package```bashpip3 install potassium```Create a python file called `app.py` containing:```pythonfrom potassium import Potassium, Request, Responsefrom transformers import pipelineimport torchimport timeapp = Potassium(&quot;my_app&quot;)# @app.init runs at startup, and initializes the app's context@app.initdef init():    device = 0 if torch.cuda.is_available() else -1    model = pipeline('fill-mask', model='bert-base-uncased', device=device)       context = {        &quot;model&quot;: model,        &quot;hello&quot;: &quot;world&quot;    }    return context# @app.handler is an http post handler running for every call@app.handler()def handler(context: dict, request: Request) -&gt; Response:        prompt = request.json.get(&quot;prompt&quot;)    model = context.get(&quot;model&quot;)    outputs = model(prompt)    return Response(        json = {&quot;outputs&quot;: outputs},         status=200    )if __name__ == &quot;__main__&quot;:    app.serve()```This runs a Huggingface BERT model.For this example, you'll also need to install transformers and torch.```pip3 install transformers torch```Start the server with:```bashpython3 app.py```Test the running server with:```bashcurl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;prompt&quot;: &quot;Hello I am a [MASK] model.&quot;}' http://localhost:8000```---# Documentation## potassium.Potassium```pythonfrom potassium import Potassiumapp = Potassium(&quot;server&quot;)```This instantiates your HTTP app, similar to popular frameworks like [Flask](https://flask.palletsprojects.com/en/2.2.x/_)---## @app.init```python@app.initdef init():    device = 0 if torch.cuda.is_available() else -1    model = pipeline('fill-mask', model='bert-base-uncased', device=device)    return {        &quot;model&quot;: model    }```The `@app.init` decorated function runs once on server startup, and is used to load any reuseable, heavy objects such as:- Your AI model, loaded to GPU- Tokenizers- Precalculated embeddingsThe return value is a dictionary which saves to the app's `context`, and is used later in the handler functions.There may only be one `@app.init` function.---## @app.handler()```python@app.handler(&quot;/&quot;)def handler(context: dict, request: Request) -&gt; Response:        prompt = request.json.get(&quot;prompt&quot;)    model = context.get(&quot;model&quot;)    outputs = model(prompt)    return Response(        json = {&quot;outputs&quot;: outputs},         status=200    )```The `@app.handler` decorated function runs for every http call, and is used to run inference or training workloads against your model(s).You may configure as many `@app.handler` functions as you'd like, with unique API routes.The context dict passed in is a mutable reference, so you can modify it in-place to persist objects between warm handlers.---## @app.background(path=&quot;/background&quot;)```python@app.background(&quot;/background&quot;)def handler(context: dict, request: Request) -&gt; Response:    prompt = request.json.get(&quot;prompt&quot;)    model = context.get(&quot;model&quot;)    outputs = model(prompt)    send_webhook(url=&quot;http://localhost:8001&quot;, json={&quot;outputs&quot;: outputs})    return```The `@app.background()` decorated function runs a nonblocking job in the background, for tasks where results aren't expected to return clientside. It's on you to forward the data to wherever you please. Potassium supplies a `send_webhook()` helper function for POSTing data onward to a url, or you may add your own custom upload/pipeline code.When invoked, the server immediately returns a `{&quot;success&quot;: true}` message.You may configure as many `@app.background` functions as you'd like, with unique API routes.The context dict passed in is a mutable reference, so you can modify it in-place to persist objects between warm handlers.---## app.serve()`app.serve` runs the server, and is a blocking operation.---# StorePotassium includes a key-value storage primative, to help users persist data between calls.Example usage: your own Redis backend (encouraged)```from potassium.store import Store, RedisConfigstore = Store(    backend=&quot;redis&quot;,    config = RedisConfig(        host = &quot;localhost&quot;,        port = 6379    ))# in one handlerstore.set(&quot;key&quot;, &quot;value&quot;, ttl=60)# in another handlervalue = store.get(&quot;key&quot;)```Example usage: using local storage - Note: not encouraged on Banana serverless or multi-replica environments, as data is stored only on the single replica```from potassium.store import Store, RedisConfigstore = Store(    backend=&quot;local&quot;)# in one handlerstore.set(&quot;key&quot;, &quot;value&quot;, ttl=60)# in another handlervalue = store.get(&quot;key&quot;)```</longdescription>
</pkgmetadata>