<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># DeepChainMap[![PyPI](https://img.shields.io/pypi/v/deep-chainmap)](https://pypi.org/project/deep-chainmap/)[![codecov](https://codecov.io/gh/neutrinoceros/deep_chainmap/branch/main/graph/badge.svg)](https://codecov.io/gh/neutrinoceros/deep_chainmap)[![pre-commit.ci status](https://results.pre-commit.ci/badge/github/neutrinoceros/deep_chainmap/main.svg)](https://results.pre-commit.ci/latest/github/neutrinoceros/deep_chainmap/main)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)A recursive subclass of [`collections.ChainMap`](https://docs.python.org/3/library/collections.html#collections.ChainMap).## Installation```shellpip install deep-chainmap```## UsageThe canonical use case for `collections.ChainMap` is to aggregate configurationdata from layered mapping (basically dictionaries) sources. However, it is notsuited for non-flat (nested) mappings, since the lookup mechanism only works forthe top level of a mapping.`deep_chainmap.DeepChainMap` provides a simple solution to this problem by makingrecurive lookups in arbitrarily deeply nested mappings. Let's illustrate thiswith a simple example. We will simulate 3 layers of mapping, and pretend theywere obtained from different sources (a default configuration, a configurationfile and parameters configured at runtime).```pythonfrom deep_chainmap import DeepChainMapdefault_layer = {    &quot;architecture&quot;: &quot;gpu&quot;,    &quot;logging_level&quot;: &quot;warning&quot;,    &quot;solver&quot;: &quot;RK4&quot;,    &quot;database&quot;: {        &quot;url&quot;: &quot;unset&quot;,        &quot;keep_in_sync&quot;: False,    },    &quot;mesh&quot;: {        &quot;type&quot;: &quot;rectangular&quot;,        &quot;resolution&quot;: {            &quot;x&quot;: {                &quot;npoints&quot;: 100,                &quot;spacing&quot;: &quot;linear&quot;,            },            &quot;y&quot;: {                &quot;npoints&quot;: 100,                &quot;spacing&quot;: &quot;linear&quot;,            },            &quot;z&quot;: {                &quot;npoints&quot;: 100,                &quot;spacing&quot;: &quot;linear&quot;,            },        },    },}config_file_layer = {    &quot;architecture&quot;: &quot;cpu&quot;,    &quot;mesh&quot;: {        &quot;resolution&quot;: {            &quot;x&quot;: {                &quot;spacing&quot;: &quot;log&quot;,            },            &quot;z&quot;: {                &quot;npoints&quot;: 1,            },        },    },}runtime_layer = {    &quot;logging_level&quot;: &quot;debug&quot;,    &quot;database&quot;: {        &quot;url&quot;: &quot;https://my.database.api&quot;,        &quot;keep_in_sync&quot;: True    },}# now building a DeepChainMapcm = DeepChainMap(runtime_layer, config_file_layer, default_layer)```Now when a single parameter is requested, it is looked up in each layer until avalue is found, by order of insertion. Here the `runtime_layer` takes priorityover the `config_file_layer`, which in turns takes priority over the`default_layer`.```python&gt;&gt;&gt; cm[&quot;logging_level&quot;]'debug'&gt;&gt;&gt; cm[&quot;mesh&quot;][&quot;resolution&quot;][&quot;x&quot;][&quot;spacing&quot;]'log'&gt;&gt;&gt; cm[&quot;mesh&quot;][&quot;resolution&quot;][&quot;x&quot;][&quot;npoints&quot;]100```Note that submappings at any level can be retrieved as new`DeepChainMap` instances```python&gt;&gt;&gt; cm[&quot;mesh&quot;]DeepChainMap({'resolution': {'x': {'spacing': 'log'}, 'z': {'npoints': 1}}},             {'resolution': {'x': {'npoints': 100, 'spacing': 'linear'},                             'y': {'npoints': 100, 'spacing': 'linear'},                             'z': {'npoints': 100, 'spacing': 'linear'}},              'type': 'rectangular'})```The other important feature is the `to_dict` method, which constructs a builtin`dict` from a `DeepChainMap````python&gt;&gt;&gt; cm.to_dict(){    'architecture': 'cpu',    'logging_level': 'debug',    'solver': 'RK4',    'database': {        'url': 'https://my.database.api',        'keep_in_sync': True    },    'mesh': {        'type': 'rectangular',        'resolution': {            'x': {'npoints': 100, 'spacing': 'log'},            'y': {'npoints': 100, 'spacing': 'linear'},            'z': {'npoints': 1, 'spacing': 'linear'}        }    }}```An important implication is that the `DeepChainMap` class enables a very simple,functional implementation of a depth-first dict-merge algorithm as```pythonfrom deep_chainmap import DeepChainMapdef depth_first_merge(*mappings) -&gt; dict:    return DeepChainMap(*mappings).to_dict()```## LimitationsAs the standard `collections.ChainMap` class, `DeepChainMap` does not, bydesign, perform any kind of data validation. Rather, it is _assumed_ that theinput mappings are similar in structure, meaning that a key which maps to a dictin one of the input mappings is assumed to map to dict instances as well inevery other input mapping. Use the excellent[schema](https://pypi.org/project/schema/) library or similar projects for thistask.:warning: An important difference with `collections.ChainMap` is that, whensetting a (key, value) pair in a `DeepChainMap` instance, the new value isstored in the first mapping _which already contains the parent map_. For exampleif we run```python&gt;&gt;&gt; cm[&quot;mesh&quot;][&quot;resolution&quot;][&quot;x&quot;][&quot;spacing&quot;] = &quot;exp&quot;```The affected layer is `config_file_layer` rather than `runtime_layer`, as onecan see```python&gt;&gt;&gt; config_file_layer{    'architecture': 'cpu',    'mesh': {        'resolution': {            'x': {'spacing': 'exp'},            'z': {'npoints': 1}        }    }}&gt;&gt;&gt; runtime_layer{    'logging_level': 'debug',    'database': {        'url': 'https://my.database.api',        'keep_in_sync': True    }}```This behaviour is a side effect on an implementation detail and subject tochange in a future version. Please do not rely on it.</longdescription>
</pkgmetadata>