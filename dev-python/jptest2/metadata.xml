<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># JPTest2JPTest is a unit testing framework for Jupyter Notebooks and aims for fast test writing in less lines of code. Itcreates the possibility to score and automatically grade exams with separate notebook (`.ipynb`) and test (`.py`) files.## Quick StartJPTest relies on [Jupyter](https://jupyter.org/). If you need any other libraries for executing your notebook cells theycan be installed in your environment the usual way.The preferred way to use JPTest is in a virtual environment:```bashpython -m venv venvsource venv/bin/activate```Use `pip` to download and install JPTest. Make sure not to install the first version of JPTest, which is missing the `2`at the end of the package name, as it is only available for compatibility reasons.```bashpip install jptest2```Now imagine that your student has to implement a Fibonacci function called `fibonacci`, which accepts a single parameter`n` and returns the n-th fibonacci number. Inside the notebook to submit, you prepared a cell with the tag `task-1`. Asimple test could look like the following example:```pythonfrom jptest2 import *import asyncio# Create test with name &quot;Task 1&quot; and a maximum score of 1.# Execute *all* cells with tag &quot;task-1&quot; prior to executing the test function.# Please note: Every test function must be async!@JPTest('Task 1', max_score=1, execute=('task-1',))async def test_task1(nb: Notebook):    # Create a reference to the function `fibonacci` inside the notebook.    fib_fun_in_nb = nb.ref('fibonacci')    # Receive five results from the fibonacci function.    result = await asyncio.gather(        fib_fun_in_nb(1),        fib_fun_in_nb(2),        fib_fun_in_nb(3),        fib_fun_in_nb(4),        fib_fun_in_nb(5)    )    # Yield a tuple containing a condition, an award, a comment in case the    # condition is false and a comment in case the condition is true.    yield result == [1, 1, 2, 3, 5], 1, 'fib fun incorrect', 'fib fun correct'```Let us assume the notebook file is called `notebook.ipynb` and the test file is called `tests.py`. Call JPTest with thefollowing command:```bashpython -m jptest2 notebook.ipynb tests.py```Please note the test function is an `async` function!## Table of Contents- [Contexts and Processes](#contexts-and-processes)- [The Execute Parameter](#the-execute-parameter )- [Execute Code](#execute-code)- [References](#references)- [Annotations and Parameters](#annotations-and-parameters)- [Function Injection](#function-injection)- [Function Replacing](#function-replacing)- [Function Tracking](#function-tracking)- [Setup and Teardown Methods](#setup-and-teardown-methods)- [Output Formats](#output-formats)- [Parallelization](#parallelization)- [Running Without Tests](#running-without-tests)- [Live Preview](#live-preview)- [Other Kernels](#other-kernels)## Contexts and ProcessesJPTest manages different processes. The first process that is started collects all annotations like `@JPTest` andstores them together with their respecting test functions. Later, this process will control the startup of notebooksand take over the evaluation. We refer to this process as the test context.Jupyter uses kernels that are started in a separate process. JPTest supports Python3 kernels and does not sharethem between tests, so for each test at least one independent kernel process is started to run the contents of thenotebook. However, as we will see later, it is also possible to start multiple kernels per test. We refer to this setof processes as the notebook context.JPTest always runs on an in-memory copy of the notebook and does not modify files, but tests and code in the notebookstill have the possibility to do so.## The Execute ParameterOne can control in detail what code is executed prior to a test. Therefore, the `execute` parameter accepts differenttypes, which can also be nested recursively:**String.**If the parameter is of type `str`, the value is considered as code and injected into the notebook.**Tuple.**If the parameter is of type `tuple`, the value is considered as tags. If there is one element in the tuple, every cellwith this tag is executed. If there are two elements in the tuple, every cell between the first appearance of the firsttag and the first appearence of the second tag (including) is executed.**Function.**If the parameter is a function (`Callable`), it will be executed in the notebook context using `execute_fun`.**List.**If the parameter is of type `list`, every element will be executed in the order of its appearence, following the rulesstated above. Even though it is not actually needed because of list operations in Python, nested statements are possiblewith it.## Execute CodeThe easiest way to execute code in the notebook is via the `cells` property. It returns a list of all cells present inthe notebook and allows to filter and execute them one by one.```pythonfor cell in nb.cells:    print(cell.tags)    if cell.type == 'code':        await cell.execute()```The function `execute_cells` represents a shortcut to select only code cells by tags prior to executing them in theirorder of appearance.```python# execute all cells with tag `task-1`await nb.execute_cells('task-1')# execute all cells from `task-3` to `task-5`await nb.execute_cells(from_tag='task-3', to_tag='task-5')```It is also possible to inject code into the notebook context. `execute_code` creates a new code cell from the givenstring, inserts it at the end of the notebook and executes it. Additional indentation of otherwise correct code ispossible.```pythonawait nb.execute_code('''    a = 5    b = 10''')```Please note that there are functions `store` and `stores` to store values in the notebook. Unlike the previous examplethis also works with non-primitive types and references.```pythonref1 = await nb.store(5, 'a')ref2 = await nb.store(6)await nb.store(ref1, 'copy_of_ref1')ref3, ref4 = await nb.stores(b=10, c={'tiger': 'dangerous'})```## ReferencesIt is possible to interact with objects and code in the notebook context. The most important class in this regard is`NotebookReference`. References are returned, for example, by the `ref` and `get` functions, represent objects in thenotebook context and may be used for interaction in various ways:- `receive` serializes the referenced object and transfers it from the notebook context to the test context. `execute`,  on the other hand, executes a statement without processing the result and transferring it to the test context.- Calling `await` on a `NotebookReference` object directly triggers a call to `receive`.- Access to an object's attributes or items is possible with the usual syntax. Note that the result is not evaluated  immediately and thus errors due to missing attributes or keys are carried over until the actual execution.- References may be called like functions. The parameters are either other references, then these are resolved within  the notebook context, or local variables from the test context, then these are transferred into the notebook context  and used for the call. Function calls are also not executed immediately.- For references to lists and other sequences there is a function `len` to determine the length. The built-in `len`  function, however, cannot be used with the `async`/`await` syntax.```pythonmy_fun_in_nb = nb.my_funmy_fun_return = my_fun_in_nb()my_dict_in_nb = nb.my_dictval_of_x = my_dict_in_nb['x']# Raises an exception if `my_fun` does not exist# or if it raises an exception itself.print(await my_fun_return.receive())# You can omit the call to `receive`.print(await my_fun_return)# Raises an exception if `my_dict` does not `x` is not a key in `my_dict`.print(await val_of_x)```Pickle is used to serialize and deserialize objects. Therefore, it is also possible to transfer more complex objectslike Pandas DataFrames or NumPy Arrays.References to a notebook's objects can be used as parameters to call a function within another notebook. JPTest willtransfer the value to the notebook containing the function prior to calling it. This means the used reference has to beserializable.## Annotations and ParametersPreviously you have already seen the annotation `@JPTest`. It has two additional optional parameters. `timeout`specifies a timeout in seconds **per cell**. As you may have noticed, the notebook is passed as a parameter to the testfunction **after** the `execute` parameter is executed. You can set `prepare_second` to `True` to get a second notebookwith the same settings as a second parameter.```python@JPTest('Task 1', max_score=1, execute=('task-1',), prepare_second=True)async def test_task1(nb1: Notebook, nb2: Notebook):    # `nb1` equals `nb2`, but they were created and prepared independently!    pass```Furthermore, there is `@JPTestGet` if you are only interested in data stored within the notebook. To this annotationyou pass a name, a maximum score, a timeout and an execute command. It further accepts a list of names that arevariables inside the notebook. All of these are transferred to the test context and used as parameters for your testfunction. You can not access the notebook using this annotation!```python@JPTestGet('Task 1', max_score=1, execute=('task-1',), get=['first_var', 'second_var'])async def test_task1(first_value, second_value):    # `first_value` and `second_value` are the received values.    pass```The last annotation is `@JPTestComparison`. It allows using two notebooks prepared in different ways inside the testfunction. We use this mainly to compare the student's results with those from a sample solution.```pythondef import_pandas():    # noinspection PyUnresolvedReferences    import pandas as pddef sample_solution():    correct_df = pd.read_csv('my_dataset.csv')# Everything passed to `prepare` is executed in both notebooks independently.# Everything passed to `execute_left` is executed in the first notebook.# `execute_right` does the same in the second notebook.# `hold_left` expects a list of variable names to copy to the test context# from the first notebook. `hold_right` does the same to the second notebook.# Every received value is used as a parameter for the test function.@JPTestComparison('Task 1', max_score=1, execute=import_pandas,                  prepare_left=('task-1',), hold_left='students_df',                  prepare_right=sample_solution, hold_right='correct_df')async def test_task1(students_val, correct_val):    pass```## Function InjectionThere are two ways to inject functions:The first method `inject_fun` transfers a function to the notebook context and returns a reference. This can be calledas described before or passed as a parameter to another function.```pythondef fun(i: int):    return i + 1injected = await nb.inject_fun(fun)result = await injected(5)# `result` equals `6`.```You can also send classes to the notebook context. But there is no way to transfer needed superclasses automaticallyas well.The second method `execute_fun` executes a function's body in the notebook context while the header is only used in thetest context. This makes it possible to write syntactically correct code with alle benefits of analysis within an IDE,although it is later executed in the notebook context.```pythondef fun(i: int):    k = i + 1# `i` has to be available in the notebook context!await nb.execute_fun(fun)# `k` is defined globally in the notebook context# after the execution.```## Function ReplacingFunctions in the notebook context can be replaced with others, for example to skip network requests and return a fixedresponse instead to speed them up.```pythonawait nb.execute_code('''    from time import sleep    def my_fun():        sleep(10)        return 1                ''')def replacement():    return 2async with nb.replace_fun('my_fun', replacement):    # executes `replacement` in notebook context.    result = await nb.ref('my_fun')()    # prints `2`    print(result)```## Function TrackingFurthermore, it is possible to track function calls. This may be used to check if an implementation uses recursion.In addition, the parameters and return values used can be extracted.```pythonawait nb.execute_code('''    def fib(i):        return i if i &lt;= 1 else fib(i-1) + fib(i-2)''')async with nb.track_fun('fib') as calls:    await nb.ref('fib')(15).execute()print(len(await calls) &gt; 1000)```## Setup and Teardown MethodsUse `@JPSetup` and `@JPTeardown` to annotate `async` functions. Setup functions are run prior to all tests and teardownfunctions after all tests have completed.```python@JPSetupasync def setup():    print('setup')@JPTeardownasync def teardown():    print('teardown')```Multiple setup or teardown functions are run in parallel.## Output FormatsThe default output format is JSON. You can switch it to Markdown using the command line flag `--md`.## ParallelizationSince all notebook kernels are started in different processes, multicore processors can be fully utilized. However,there are a few things to keep in mind:- The test context can become a bottleneck because it uses only one thread. Therefore, the notebooks should work as  independently as possible and the test context should only be used for coordination and evaluation.- Keep inter-process communication to a minimum and outsource computationally intensive operations to the notebook  context.- Use the parameter `--tests` to limit the number of concurrently running tests.## Running Without TestsIf no test file is given on startup, JPTest will choose a default test set. It executes all cells once in the correctorder, does not score and passes exceptions. This can be used to check notebooks for syntax errors, determine iflibraries are missing within an image or if data sets have not been shipped.Use the command line parameter `--quiet` to suppress any output other than exceptions and stacktraces.## Live PreviewThe live preview is activated with the `--live` switch. It monitors changes to the given files and automatically rerunsthe evaluation as soon as one of them is modified. This mode is useful for developing tests or for demonstrations.Install the package `jptest2[demo]` to receive the optional dependencies. The `clear` command is used to clear theterminal window and therefore must be available.## Other KernelsWhile the main focus is on Python notebooks, development to support other kernels is possible. Set the `kernel`parameter to specify which language is used in the notebook. Besides Python3, two databases are supported at the moment.However, they do not start an actual Jupyter Kernel but send the queries directly to a connected database.1. **SQLite** using `jptest2[sqlite]`2. **DuckDB** using `jptest2[duckdb]`</longdescription>
</pkgmetadata>