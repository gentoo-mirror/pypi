<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)[![PyPI package version](https://img.shields.io/pypi/v/shared)](https://pypi.org/project/shared)[![Downloads](https://pepy.tech/badge/shared)](https://pepy.tech/project/shared)&lt;!-- Cover --&gt;&lt;div align=&quot;center&quot;&gt;    &lt;img src=&quot;https://raw.githubusercontent.com/pyrustic/misc/master/assets/shared/cover.png&quot; alt=&quot;Cover&quot; width=&quot;541&quot;&gt;    &lt;p align=&quot;center&quot;&gt;    &lt;i&gt; &lt;/i&gt;    &lt;/p&gt;&lt;/div&gt;# Pyrustic Shared**Data exchange and persistence**This project is part of the [Pyrustic Open Ecosystem](https://pyrustic.github.io).&gt; [Installation](#installation) . [Latest](https://github.com/pyrustic/shared/tags) . [Modules](https://github.com/pyrustic/shared/tree/master/docs/modules#readme)## Table of contents- [Overview](#overview) - [Document](#document) - [Dossier](#dossier)- [Database](#database)- [Command line interface](#command-line-interface)- [Miscellaneous](#miscellaneous)- [Installation](#installation) # Overview**Shared** is a Python package created to be the programmer's companion when it comes to storing application data, managing configuration files, caching data, and exchanging data with other programs.Although a lightweight package, **Shared** smoothly handles collections (**dict**, **list**, **set**), **binary** data, and **SQL** queries.## Designed as a triptych**Shared**'s intuitive application programming interface is designed as a  [triptych](https://en.wikipedia.org/wiki/Triptych). Thus, three classes with similar interfaces are created to cover the needs of data exchange and persistence: `Document`, `Dossier`, and `Database`.|Class|Relevance||---|---||`Document`|For individual access to [Jesth](https://github.com/pyrustic/jesth#readme) and [JSON](https://en.wikipedia.org/wiki/JSON) files that are likely to be **manually edited by a human**.||`Dossier`|To store collections and binary data in a dossier **without worrying about how they are actually saved**.||`Database`|For an intuitive interaction with [SQLite](https://www.sqlite.org) **databases**.|&gt; **Note:** The `Document` class is not intended to be used directly. Instead, depending on the requirement, one will use the `JsonDoc` or `JesthDoc` class which subclasses the `Document` class.## Some characteristicsSince all three classes share similar interfaces, some handy functionality has been replicated in all of them with a few exceptions.### InitializationAll three classes emphasize **initialization**:- `Document` and `Dossier` give the possibility to define **default data**.- `Database` allows the definition of an **initialization SQL script** which is only executed to create a new database.### Data accessAll three classes provide an optional **read-only** access to data and also allow the creation of **temporary data** which is automatically deleted when the user closes the application.`Document` and `Dossier` provide **Autosave** functionality, while `Database` automatically closes the underlying database connection when the user closes the application.### Command-line interfaceAmong the three classes, `Dossier` is the class of which a single instance can handle multiple underlying files. The `Dossier` class has its own protocol for organizing data. For this reason, `Dossier` offers a simple yet powerful **command-line interface** that allows other programs or a human to read and write the contents of a dossier.&lt;br&gt;Let's explore the [Document](#document), [Dossier](#dossier), and [Database](#database) classes in the next sections !# DocumentThe `Document` class represents an interface for reading and writing an underlying file whose format is either [Jesth](https://github.com/pyrustic/jesth#readme) or [JSON](https://en.wikipedia.org/wiki/JSON).As stated previously in the [Overview](#overview) section, the `Document` class is not intended to be used directly. Instead, depending on the requirement, one will use the `JsonDoc` or `JesthDoc` class which subclasses the `Document` class. Since **JSON** is very popular, we will focus on the `JsonDoc` class in the following examples.Accessing a document or creating a new one is as simple as this:```pythonfrom shared import JsonDoc# Create a new document instance which will be linked to the 'my-data.json' file.# If this file doesn't exist yet, it will be automatically createddocument = JsonDoc(&quot;my-data.json&quot;)# From now, we can use 'document' to read and write the contents of 'my-data.json' !# ...```The string `my-data.json` is the base name of a file that will be created if it does not yet exist. This string is called **Target** and can be an absolute path or an instance of [pathlib.Path](https://docs.python.org/3/library/pathlib.html). The `Document` class exposes the `read` and `write` methods, respectively, to read and write the underlying document.## InitializationA document can be initialized with a conditional statement or by defining default data. By default, the `Document` class will assign a `dict` to the null parameter `default_data`.### Use a conditional statementIt's as simple as testing a boolean to check if the underlying document file is newly created or not:```pythonfrom shared import JsonDoc# access 'my-data.json'document = JsonDoc(&quot;my-data.json&quot;)# let's initialize the content of 'my-data.json'if document.new:    data = {&quot;name&quot;: &quot;alex&quot;, &quot;job&quot;: &quot;evangelist&quot;}    document.write(data)  # persisted !```### Set default dataThe most elegant, less verbose and recommended way to initialize a document is to set some default data to the `default` parameter:```pythonfrom shared import JsonDoc# default data to init the file 'my-data.json'DEFAULT_DATA = {&quot;name&quot;: &quot;alex&quot;, &quot;job&quot;: &quot;evangelist&quot;}# access 'my-data.json'document = JsonDoc(&quot;my-data.json&quot;, default=DEFAULT_DATA)# From now, thanks to the initialization functionality, the underlying# document contains the default data, assuming that 'my-data.json'# did not exist before the `Document` class was instantiated```## Data locationThe only mandatory argument to be supplied to the `Document` class constructor is the `target`. For convenience, the `target` is either the absolute path or the base name of a file. Its data type is either a string or an instance of [pathlib.Path](https://docs.python.org/3/library/pathlib.html).The optional `directory` parameter exists to supplement the `target` value when that value is not an absolute path.### Default directoryBy default, document files are saved in `$HOME/PyrusticHome/shared`. You can change the location according to your needs:```pythonfrom shared import JsonDocDIRECTORY = &quot;/home/alex/private&quot;# access 'my-data.json'document = JsonDoc(&quot;my-data.json&quot;, directory=DIRECTORY)# From now, you can access these properties:#   document.name == &quot;my-data.json&quot;#   document.directory == &quot;/home/alex/private&quot;#   document.target == &quot;my-data.json&quot;```### Absolute pathnameYou can set an absolute path as the target. In this case, the `Document` class ignores the `directory` parameter.```pythonfrom shared import JsonDocpathname = &quot;/home/alex/private/my-data.json&quot;# access 'my-data.json'document = JsonDoc(pathname)# From now, you can access these properties:#   document.name == &quot;my-data.json&quot;#   document.directory == &quot;/home/alex/private&quot;#   document.target == &quot;/home/alex/private/my-data.json&quot;```### Temporary dataSetting the `temporary` boolean can enable temporary mode, so a document can only be created and used while the application is running, and then safely deleted when the application closes:```pythonfrom shared import JsonDoc# access 'my-data.json'document = JsonDoc(&quot;my-data.json&quot;, temporary=True)# This document will be created in a temporary directory# then it will be safely deleted when the application closes# or when the developer explicitly calls the 'close' or 'delete' method```The `Document` class uses [tempfile.TemporaryDirectory](https://docs.python.org/3/library/tempfile.html#tempfile.TemporaryDirectory) to implement this functionality.## AutosaveThanks to [atexit](https://docs.python.org/3/library/atexit.html) module, `Document` can autosave content when the application is closed:```pythonimport sysfrom shared import JsonDoc# access 'my-config.json' with `autosave` mode enableddocument = JsonDoc(&quot;my-config.json&quot;, autosave=True, default=[])# load the datadata = document.read()# few lines of code later...data.append(&quot;batman&quot;)  # data modifiedsys.exit()  # data automatically saved !```Along with `atexit` module, the `Document` class also uses a caching mechanism to implement the `autosave` functionality.## CachingBy default, `caching` mode is enabled, so the user can access cached data through the `cache` property of an instance of the `Document` class:```pythonfrom shared import JsonDocDEFAULT_DATA = {&quot;name&quot;: &quot;alex&quot;, &quot;job&quot;: &quot;evangelist&quot;}# access 'my-config.json'document = JsonDoc(&quot;my-config.json&quot;, caching=True, default=DEFAULT_DATA)data = document.read()if data is document.cache:    print(&quot;Same same !&quot;)```## ReadonlySetting the `readonly` parameter to `True` prevents the running application from accidentally modifying the content of a document:```pythonfrom shared import JsonDoc# access 'my-data.json'document = JsonDoc(&quot;my-data.json&quot;, readonly=True)# when you set readonly to True, you can no longer edit the content !# shared.ReadonlyError will be raised if you try to mess with a readonly document```## Clear dataYou can delete the underlying file of a document (assuming the file isn't in readonly mode):```pythonfrom shared import JsonDoc# access 'my-data.json'document = JsonDoc(&quot;my-data.json&quot;)# delete 'my-data.json'document.delete()if document.deleted:    print(&quot;Successfully deleted !&quot;)```## Convenience functionsFour convenience functions are available for the `JsonDoc` class (also for the `JesthDoc` class):```pythonfrom shared import json_create, json_readonly, json_write, json_autosave# quickly create a documentDEFAULT = [&quot;red&quot;, &quot;violet&quot;]json_create(&quot;my-data.json&quot;, default=DEFAULT)# quickly open a document in readonly modedata = json_readonly(&quot;my-data.json&quot;)# quickly change the content of a documentdata = [&quot;red&quot;, &quot;green&quot;]json_write(&quot;my-data.json&quot;, data)# quickly read the content of a document in autosave modedata = json_autosave(&quot;my-data.json&quot;)data.append(&quot;blue&quot;)  # data will be automatically saved on exit```## RecapitulationFor individual access to [Jesth](https://github.com/pyrustic/jesth#readme) and [JSON](https://en.wikipedia.org/wiki/JSON) files that are likely to be **manually edited by a human**, the `Document` class is the recommended interface.For more technical details about this class and the subclasses `JesthDoc` and `JsonDoc`, read the [reference documentation](https://github.com/pyrustic/shared/tree/master/docs/modules#readme).# DossierThe `Dossier` class stores collections (**list**, **dict**, **set**) and **binary data** with a unified interface inside a [dossier](https://dictionary.cambridge.org/dictionary/english/dossier). **Shared** allows to read and write a dossier not only programmatically but also from the [command line](#command-line-interface).This class shares a similar interface with the `Document` class. Thus, the `Dossier` class constructor has `target`, `directory`, `autosave`, `readonly` and `temporary` as parameters. These parameters are already covered in the `Document` class [section](#document).Under the hood, `Dossier` uses [files](https://en.wikipedia.org/wiki/Computer_file) and [JSON](https://en.wikipedia.org/wiki/JSON) to store data.## ExampleLet's create a dossier with **script_1.py**:```python# script_1.pyfrom shared import Dossier# datapeople = {&quot;Jack&quot;: &quot;male&quot;, &quot;Jane&quot;: &quot;female&quot;}  # dictplanets = [&quot;Mars&quot;, &quot;Venus&quot;, &quot;Jupiter&quot;]  # listcolors = {&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;}  # set# let's persist the data in 'my-dossier'dossier = Dossier(&quot;my-dossier&quot;)dossier.set(&quot;people&quot;, people)  # set the 'people' entrydossier.set(&quot;planets&quot;, planets)  # set the 'planets' entrydossier.set(&quot;colors&quot;, colors)  # set the 'colors' entry# Done ! The data is persisted !```From **script_2.py**, let's access the dossier created with **script_1.py**:```python# script_2.pyfrom shared import Dossier# let's access the shared dossierdossier = Dossier(&quot;my-dossier&quot;)# get data from the shared dossierpeople = dossier.get(&quot;people&quot;) # get the 'people' entryplanets = dossier.get(&quot;planets&quot;) # get the 'planets' entry'colors = dossier.get(&quot;colors&quot;) # get the 'colors' entryprint(people)# output: {'Jack': 'male', 'Jane': 'female'}print(planets)# output: ['Mars', 'Venus', 'Jupiter']print(set(colors)) # there is nothing called 'set' in JSON [1]# output: {'red', 'green', 'blue'}# [1] the value of 'colors' is this dictionary:# {'red': None, 'green': None, 'blue': None}```## Binary dataYou can store binary data with the same unified interface:```python# script_1.pyfrom shared import Dossierdossier = Dossier(&quot;my-dossier&quot;)with open(&quot;/home/alex/selfie.png&quot;, &quot;rb&quot;) as file:    data = file.read()    dossier.set(&quot;selfie&quot;, data)  # set the 'selfie' entry# the 'set' method returns the path to the binary file that stores the binary entry```The above code can also be expressed like this:```python# script_1.pyimport pathlibfrom shared import Dossierdossier = Dossier(&quot;my-dossier&quot;)path = pathlib.Path(&quot;/home/alex/selfie.png&quot;)dossier.set(&quot;selfie&quot;, path)  # set the 'selfie' entry# the 'set' method returns the path to the binary file that stores the binary entry```You can retrieve your binary data from another script:```python# script_2.pyfrom shared import Dossierfrom shutil import copyfiledossier = Dossier(&quot;my-dossier&quot;)source_path = dossier.get(&quot;selfie&quot;)  # get the filename of the 'selfie' bin entrydestination_path = &quot;/home/alex/new.png&quot;# copy the content from source to destinationcopyfile(source_path, destination_path)```## CheckUse the `check` method to check the contents of a dossier or a specific entry:```pythonfrom shared import Dossierdossier = Dossier(&quot;my-dossier&quot;)# check a specific entryinfo = dossier.check(&quot;entry&quot;)if info:    # info is a 3-tuple (name, container, filename).    # The name is simply the entry name.    # The container is a string that represents the type of the entry.    # containers: &quot;dict&quot;, &quot;list&quot;, &quot;set&quot;, and &quot;bin&quot;    # The filename is either the path to a JSON file or a binary file    name, container, filename = info# check the contents of the dossierdossier_info = dossier.check()  # returns a dict, keys are entries and values are 3-tuplesfor entry, info in dossier_info.items():    print(&quot;Entry:&quot;, info.name) # the entry name    print(&quot;Container:&quot;, info.container)  # 'dict', 'set', 'list', or 'bin'    print(&quot;Filename:&quot;, info.filename) # the underlying file in which the data is stored    print()```## Clear dataYou can decide to delete a specific entry, a group of entries, or the dossier:```pythonfrom shared import Dossierdossier = Dossier(&quot;my-dossier&quot;)# delete a specific entrydossier.delete(&quot;entry_1&quot;)# delete a group of entriesdossier.delete(&quot;entry_2&quot;, &quot;entry_3&quot;)# delete the dossierdossier.delete()  # collections, binary data, and meta data are gone```## RecapitulationTo store collections and binary data in a dossier **without worrying about how they are actually saved**, the `Dossier` class is the interface to use.For more technical details about this class, read its [documentation](https://github.com/pyrustic/shared/blob/master/docs/modules/content/shared/content/classes/Dossier.md#class-dossier).# DatabaseIntuitive interaction with **SQLite** databases.## ExampleThe following example shows how nice it is to work with the `Database` class:```pythonfrom shared import Database# Initialization script# This SQL script will create two tables: friends and projectsINIT_SCRIPT = &quot;&quot;&quot;\CREATE TABLE friends (name TEXT PRIMARY KEY,                      age INTEGER NOT NULL);CREATE TABLE projects (name TEXT PRIMARY KEY,                       language TEXT NOT NULL);&quot;&quot;&quot;# If this database doesn't exist yet,# it will be created with the initialization scriptdatabase = Database(&quot;my-database&quot;, init_script=INIT_SCRIPT)# This will only be executed once !# So you can safely restart this script again and again...if database.new:    # Populate this database    sql = &quot;&quot;&quot;INSERT INTO friends VALUES (&quot;Jack&quot;, 20)&quot;&quot;&quot;    database.edit(sql)    # few lines of code later...    # Populate this database    sql = &quot;&quot;&quot;INSERT INTO friends VALUES (?, ?)&quot;&quot;&quot;    parameters = (&quot;Jane&quot;, 21)    database.edit(sql, param=parameters)# Read datasql = &quot;SELECT * FROM friends&quot;columns, data = database.query(sql)  # returns a shared.dto.QueryResult namedtupleprint(columns)# output: ['name', 'age']print(data)# output: [('Jack', 20), ('Jane', 21)]```For more technical details about this class, read its [documentation](https://github.com/pyrustic/shared/blob/master/docs/modules/content/shared/content/classes/Database.md#class-database).# Command line interface**Shared** comes with an intuitive command line interface for the `Dossier` class. Type `help` in the command line interface to display a short manual.For the following subsections, assume we have a pre-populated dossier named `my-dossier` and located in `/home/alex/dossiers`.## Check the contentCheck the contents of `my-dossier` or a specific entry:```bash$ cd /home/alex/dossiers/my-dossier$ shared check- 'colors' set 56B- 'people' dict 44B- 'planets' list 42B$ shared check people'people' dict 44B$ shared check colors'colors' set 56B```## Read the content of a specific entry```bash$ cd /home/alex/dossiers/my-dossier$ shared get people{    &quot;Jack&quot;: &quot;male&quot;,    &quot;Jane&quot;: &quot;female&quot;}$ shared get planets[    &quot;Mars&quot;,    &quot;Venus&quot;,    &quot;Jupiter&quot;]shared get colors{    &quot;red&quot;: null,    &quot;blue&quot;: null,    &quot;green&quot;: null}```The output text is the exact **JSON** representation as stored in a file. So the **output can be consumed as is** by another program and deserialized with a **JSON** library. Note that the `colors` entry is a `set` but represented as a `dict` in **JSON**.## Store binary data```bash$ shared set selfie bin: '/home/alex/selfie.png'Entry successfully updated !```You can copy a binary entry into an arbitrary file from the command line:```bash$ shared get selfie &gt; '/home/alex/selfie-copy.png'```## Store a collection```bash$ shared set countries list: '/home/alex/countries.json'Entry successfully updated !$ shared set my_config dict: '/home/alex/app_config.json'Entry successfully updated !```## Delete an entry```bash$ shared del &quot;selfie&quot;Entry successfully deleted !$ shared check selfieThis entry doesn't exist.```## Delete a dossierRight-click on the folder with your mouse, then send it safely to the trash... ;)# Miscellaneous# Installation**Shared** is **cross platform** and versions under **1.0.0** will be considered **Beta** at best. It should work on **Python 3.5** or [newer](https://www.python.org/downloads/).## For the first time```bash$ pip install shared```## Upgrade```bash$ pip install shared --upgrade --upgrade-strategy eager```## Show information```bash$ pip show shared```&lt;br&gt;&lt;br&gt;&lt;br&gt;[Back to top](#readme)</longdescription>
</pkgmetadata>