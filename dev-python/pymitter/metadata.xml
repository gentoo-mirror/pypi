<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pymitter[![Package status](https://img.shields.io/pypi/v/pymitter.svg?style=flat)](https://pypi.python.org/pypi/pymitter)[![License](https://img.shields.io/github/license/riga/pymitter.svg)](https://github.com/riga/pymitter/blob/master/LICENSE)[![Lint and test](https://github.com/riga/pymitter/actions/workflows/lint_and_test.yml/badge.svg)](https://github.com/riga/pymitter/actions/workflows/lint_and_test.yml)[![Code coverage](https://codecov.io/gh/riga/pymitter/branch/master/graph/badge.svg?token=MePbStZF7U)](https://codecov.io/gh/riga/pymitter)[![PyPI downloads](https://img.shields.io/pypi/dm/pymitter.svg)](https://pypi.python.org/pypi/pymitter)Python port of the extended Node.js EventEmitter 2 approach of https://github.com/asyncly/EventEmitter2 providing namespaces, wildcards and TTL.## Features- Namespaces with wildcards- Times to listen (TTL)- Usage via decorators or callbacks- Coroutine support- Lightweight implementation, good performance## Installation*pymitter* is a registered [PyPI module](https://pypi.python.org/pypi/pymitter), so the installation with *pip* is quite easy:```shellpip install pymitter```The last version with Python 2 support was [v0.3.2](https://github.com/riga/pymitter/tree/v0.3.2) ([PyPI](https://pypi.org/project/pymitter/0.3.2)).## Examples### Basic usage```pythonfrom pymitter import EventEmitteree = EventEmitter()# decorator usage@ee.on(&quot;my_event&quot;)def handler1(arg):    print(&quot;handler1 called with&quot;, arg)# callback usagedef handler2(arg):    print(&quot;handler2 called with&quot;, arg)ee.on(&quot;my_other_event&quot;, handler2)# support for coroutine functions@ee.on(&quot;my_third_event&quot;)async def handler3(arg):    print(&quot;handler3 called with&quot;, arg)# emitee.emit(&quot;my_event&quot;, &quot;foo&quot;)# -&gt; &quot;handler1 called with foo&quot;ee.emit(&quot;my_other_event&quot;, &quot;bar&quot;)# -&gt; &quot;handler2 called with bar&quot;ee.emit(&quot;my_third_event&quot;, &quot;baz&quot;)# -&gt; &quot;handler3 called with baz&quot;```### CoroutinesWrapping `async` functions outside an event loop will start an internal event loop and calls to `emit` return synchronously.```pythonfrom pymitter import EventEmitteree = EventEmitter()# register an async function@ee.on(&quot;my_event&quot;)async def handler1(arg):    print(&quot;handler1 called with&quot;, arg)# emitee.emit(&quot;my_event&quot;, &quot;foo&quot;)# -&gt; &quot;handler1 called with foo&quot;```Wrapping `async` functions inside an event loop will use the same loop and `emit_async` is awaitable.```pythonfrom pymitter import EventEmitteree = EventEmitter()async def main():    # emit_async    awaitable = ee.emit_async(&quot;my_event&quot;, &quot;foo&quot;)    # -&gt; nothing printed yet    await awaitable    # -&gt; &quot;handler1 called with foo&quot;```Use `emit_future` to not return awaitable objects but to place them at the end of the existing event loop (using `asyncio.ensure_future` internally).### TTL (times to listen)```pythonfrom pymitter import EventEmitteree = EventEmitter()@ee.once(&quot;my_event&quot;)def handler1():    print(&quot;handler1 called&quot;)@ee.on(&quot;my_event&quot;, ttl=2)def handler2():    print(&quot;handler2 called&quot;)ee.emit(&quot;my_event&quot;)# -&gt; &quot;handler1 called&quot;# -&gt; &quot;handler2 called&quot;ee.emit(&quot;my_event&quot;)# -&gt; &quot;handler2 called&quot;ee.emit(&quot;my_event&quot;)# nothing called anymore```### Wildcards```pythonfrom pymitter import EventEmitteree = EventEmitter(wildcard=True)@ee.on(&quot;my_event.foo&quot;)def handler1():    print(&quot;handler1 called&quot;)@ee.on(&quot;my_event.bar&quot;)def handler2():    print(&quot;handler2 called&quot;)@ee.on(&quot;my_event.*&quot;)def hander3():    print(&quot;handler3 called&quot;)ee.emit(&quot;my_event.foo&quot;)# -&gt; &quot;handler1 called&quot;# -&gt; &quot;handler3 called&quot;ee.emit(&quot;my_event.bar&quot;)# -&gt; &quot;handler2 called&quot;# -&gt; &quot;handler3 called&quot;ee.emit(&quot;my_event.*&quot;)# -&gt; &quot;handler1 called&quot;# -&gt; &quot;handler2 called&quot;# -&gt; &quot;handler3 called&quot;```## API### `EventEmitter(*, wildcard=False, delimiter=&quot;.&quot;, new_listener=False, max_listeners=-1)`EventEmitter constructor. **Note**: always use *kwargs* for configuration.When *wildcard* is *True*, wildcards are used as shown in [this example](#wildcards).*delimiter* is used to seperate namespaces within events.If *new_listener* is *True*, the *&quot;new_listener&quot;* event is emitted every time a new listener is registered.Functions listening to this event are passed `(func, event=None)`.*max_listeners* defines the maximum number of listeners per event.Negative values mean infinity.- #### `on(event, func=None, ttl=-1)`    Registers a function to an event.    When *func* is *None*, decorator usage is assumed.    *ttl* defines the times to listen. Negative values mean infinity.    Returns the function.- #### `once(event, func=None)`    Registers a function to an event with `ttl = 1`.    When *func* is *None*, decorator usage is assumed.    Returns the function.- #### `on_any(func=None)`    Registers a function that is called every time an event is emitted.    When *func* is *None*, decorator usage is assumed.    Returns the function.- #### `off(event, func=None)`    Removes a function that is registered to an event.    When *func* is *None*, decorator usage is assumed.    Returns the function.- #### `off_any(func=None)`    Removes a function that was registered via `on_any()`.    When *func* is *None*, decorator usage is assumed.    Returns the function.- #### `off_all()`    Removes all functions of all events.- #### `listeners(event)`    Returns all functions that are registered to an event.    Wildcards are not applied.- #### `listeners_any()`    Returns all functions that were registered using `on_any()`.- #### `listeners_all()`    Returns all registered functions.- #### `emit(event, *args, **kwargs)`    Emits an event.    All functions of events that match *event* are invoked with *args* and *kwargs* in the exact order of their registeration.    Async functions are called in a new event loop.    There is no return value.- #### `(async) emit_async(event, *args, **kwargs)`    Emits an event.    All functions of events that match *event* are invoked with *args* and *kwargs* in the exact order of their registeration.    Awaitable objects returned by async functions are awaited in the outer event loop.    Returns an `Awaitable`.- #### `emit_future(event, *args, **kwargs)`    Emits an event.    All functions of events that match *event* are invoked with *args* and *kwargs* in the exact order of their registeration.    Awaitable objects returned by async functions are placed at the end of the event loop using `asyncio.ensure_future`.    There is no return value.## Development- Source hosted at [GitHub](https://github.com/riga/pymitter)- Python module hosted at [PyPI](https://pypi.python.org/pypi/pymitter)- Report issues, questions, feature requests on [GitHub Issues](https://github.com/riga/pymitter/issues)</longdescription>
</pkgmetadata>