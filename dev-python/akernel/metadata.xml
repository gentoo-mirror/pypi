<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Build Status](https://github.com/davidbrochart/akernel/workflows/CI/badge.svg)](https://github.com/davidbrochart/akernel/actions)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/davidbrochart/akernel/HEAD?urlpath=lab%2Ftree%2Fexamples%2Freactivity.ipynb)# akernelA Python Jupyter kernel, with different flavors:- concurrent cell execution,- reactive programming,- cell execution caching,- multi-kernel emulation.## Install```bashpip install akernel# pip install akernel[react]  # if you want to be able to use reactive programming# pip install akernel[cache]  # if you want to be able to use cell execution caching```You can parameterize akernel's execution mode:```bashakernel install  # default (chained cell execution mode)akernel install concurrent  # concurrent cell execution modeakernel install react  # reactive programming modeakernel install cache  # cell execution caching  modeakernel install multi  # multi-kernel emulation modeakernel install cache-multi-react-concurrent  # you can combine several modes```## Motivation[ipykernel](https://github.com/ipython/ipykernel) offers the ability to[run asynchronous code from the REPL](https://ipython.readthedocs.io/en/stable/interactive/autoawait.html).This means you can `await` at the top-level, outside of an async function. Unfortunately, this will stillblock the kernel.akernel changes this behavior by launching each cell in a task. By default, cell tasks are chained, whichmeans that a cell will start executing after the previous one is done. You might wonder, is it not the sameas ipykernel then? Well, not quite. In ipykernel, when an async cell is executing, it also blocks theprocessing of[Comm messages](https://jupyter-client.readthedocs.io/en/stable/messaging.html#custom-messages), whichprevents the kernel from interacting with e.g. JupyterLab widgets (see[here](https://github.com/ipython/ipykernel/issues/646) and[there](https://github.com/ipython/ipykernel/issues/696)). In akernel, it will not be the case.If you want to go all the way and have cells execute concurrently, you can also do so (see below).## Features### Asynchronous executionFirst, set the concurrent execution mode in order to have async cells execute concurrently(you could also do that at install-time with `akernel install concurrent`):```python__unchain_execution__()# __chain_execution__()```akernel allows for asynchronous code execution. What this means is that when used in a Jupyternotebook, you can run cells concurrently if the code is cooperative. For instance, you can run acell with the following code:```python# cell 1for i in range(10):    print(&quot;cell 1:&quot;, i)    await asyncio.sleep(1)```Since this cell is `async` (it has an `await`), it will not block the execution of other cells.So you can run another cell concurrently, provided that this cell is also cooperative:```python# cell 2for j in range(10):    print(&quot;cell 2:&quot;, j)    await asyncio.sleep(1)```If cell 2 was blocking, cell 1 would pause until cell 2 was finished. You can see that by changing`await asyncio.sleep(1)` into `time.sleep(1)` in cell 2.You can make a cell wait for the previous one to be finished with:```python# cell 3await __task__()  # wait for cell 2 to be finishedprint(&quot;cell 2 has run&quot;)```### Reactive programmingOne feature other notebooks offer is the ability to have variables react to other variables'changes. [Observable notebooks](https://observablehq.com/@observablehq/how-observable-runs) are agood example of this, and it can give a whole new user experience. For instance, you can run cellsout of order:```python# cell 1a = b + 1  # &quot;b&quot; is not defined yeta```Executing cell 1 won't result in an &quot;undefined variable&quot; error. Instead, the *result* of theoperation is undefined, and the output of cell 1 is `None`. You can then continue with thedefinition of `b`:```python# cell 2b = 2  # triggers the computation of &quot;a&quot; in cell 1```Now `a`, which depends on `b`, is automatically updated, and the output of cell 1 is `3`.You can of course define much more complex data flows, by defining variables on top of other ones.![screencast](https://user-images.githubusercontent.com/591645/131855258-35118507-6be2-44cb-9329-143ad8509405.gif)### Cell execution cachingWith this mode, cell execution is cached so that the next time a cell is run, its outputs are retrieved from cache (if its inputs didn't change). Inputs and outputs are inferred from the cell code.### Multi-kernel emulation modeThis mode emulates multiple kernels inside the same kernel. Kernel isolation is achieved by using the session ID of execution requests. You can thus connect multiple notebooks to the same kernel, and they won't share execution state.This is particularly useful if cells are async, because they won't block the kernel. The same kernel can thus be &quot;shared&quot; and used by potentially a lot of notebooks, greatly reducing resource usage.## LimitationsIt is still a work in progress, in particular:- `stdout`/`stderr` redirection to the cell output is only supported through the `print` function.- No rich representation for now, only the standard `__repr__` is supported. This means no  matplotlib figure yet :-( But since ipywidgets work, why not using  [ipympl](https://github.com/matplotlib/ipympl)? :-)</longdescription>
</pkgmetadata>