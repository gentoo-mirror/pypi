<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Bloom filters-------------[![PyPI version](https://badge.fury.io/py/shaped-bloom-filter.svg)](https://badge.fury.io/py/shaped-bloom-filter)[![CircleCI](https://dl.circleci.com/status-badge/img/gh/shaped-ai/bloom/tree/master.svg?style=svg)](https://dl.circleci.com/status-badge/redirect/gh/shaped-ai/bloom/tree/master)## Source project &amp; considerationsThis implementation of the Bloom filter is ported from the https://github.com/bits-and-blooms/bloom ([![Test](https://github.com/bits-and-blooms/bloom/actions/workflows/test.yml/badge.svg)](https://github.com/bits-and-blooms/bloom/actions/workflows/test.yml)[![Go Report Card](https://goreportcard.com/badge/github.com/bits-and-blooms/bloom)](https://goreportcard.com/report/github.com/bits-and-blooms/bloom)[![Go Reference](https://pkg.go.dev/badge/github.com/bits-and-blooms/bloom.svg)](https://pkg.go.dev/github.com/bits-and-blooms/bloom/v3)) project. The reason for porting this project from Go is due to the fact that there are no high-performance implementations of the Bloom filter in Python. All Bloom filter packages we found on PyPi are just too slow for our real-time inference pipeline.The Godoc documentation of the ported library can be found here: https://pkg.go.dev/github.com/bits-and-blooms/bloom/v3## BenchmarkThe following PyPi libraries have been benchmarked on a filter configuration of 1 mil elements and an error rate of 1%. The following shows the time needed to evaluate all elements. These are the results of running the benchmark on an Apple M1 chip. The clear winner is this library.```text           shaped-bloom-filter  bloom-filter2  fastbloom-rs  easy-bloom-filtercount               100.000000     100.000000    100.000000         100.000000mean (ms)            62.859311    2508.295782    464.162710        2201.442912std (ms)              2.300990      25.811489      6.834798          19.279795min (ms)             61.051130    2488.384008    457.671881        2177.66499525% (ms)             61.701119    2496.009886    459.175646        2190.25141050% (ms)             62.229514    2502.063990    462.151527        2196.18547075% (ms)             63.203335    2506.640196    466.094494        2205.390155max (ms)             76.441765    2666.959047    485.892057        2307.396173speedup               1.000000      39.903329      7.384152          35.021747```## DescriptionA Bloom filter is a concise/compressed representation of a set, where the mainrequirement is to make membership queries; _i.e._, whether an item is amember of a set. A Bloom filter will always correctly report the presenceof an element in the set when the element is indeed present. A Bloom filter can use much less storage than the original set, but it allows for some 'false positives':it may sometimes report that an element is in the set whereas it is not.When you construct, you need to know how many elements you have (the desired capacity), and what is the desired false positive rate you are willing to tolerate. A common false-positive rate is 1%. Thelower the false-positive rate, the more memory you are going to require. Similarly, the higher thecapacity, the more memory you will use.You may construct the Bloom filter capable of receiving 1 million elements with a false-positiverate of 1% in the following manner. ```pythonfrom shaped_bloom_filter import BloomFilterfilter = BloomFilter(1000000, 0.01)```Operations like the following can be done:```python# single member additionassert filter.is_member(10) == Falsefilter.add(10)assert filter.is_member(10) == True# multiple member additionassert filter.are_members([1, 5, 9]) == [0, 0, 0]filter.add_batch([5, 9])assert filter.are_members([1, 5, 9]) == [0, 1, 1]# serializationserialized = filter.serialize()new_filter = BloomFilter(restore_from_serialized=serialized)assert new_filter.are_members([1, 5, 9]) == [0, 1, 1]```For composing your own keys using Python-serializable objects, you can use the following method:```pythonfrom shaped_bloom_filter import BloomFilterExtendedfilter = BloomFilterExtended(1000000, 0.01)assert filter.is_one_member(&quot;Emma is writing a letter.&quot;.encode(&quot;utf-8&quot;)) == Falsefilter.add_one_member(&quot;Emma is writing a letter.&quot;.encode(&quot;utf-8&quot;))assert filter.is_one_member(&quot;Emma is writing a letter.&quot;.encode(&quot;utf-8&quot;)) == True```You should call the `BloomFilter`/`BloomFilterExtended` constructors conservatively: if you specify a number of elements that it istoo small, the false-positive bound might be exceeded. A Bloom filter is not a dynamic data structure:you must know ahead of time what your desired capacity is.## Installation```bashpip install shaped-bloom-filter```***Note: On MacOS/Windows machines, you also need Go as the Python package will be built from source.***## Reference&lt;!-- markdownlint-disable --&gt;&lt;a href=&quot;python/shaped_bloom_filter/filter.py#L0&quot;&gt;&lt;img align=&quot;right&quot; style=&quot;float:right;&quot; src=&quot;https://img.shields.io/badge/-source-cccccc?style=flat-square&quot;&gt;&lt;/a&gt;### &lt;kbd&gt;module&lt;/kbd&gt; `filter.py`---#### &lt;kbd&gt;class&lt;/kbd&gt; `BloomFilter`&lt;a href=&quot;python/shaped_bloom_filter/filter.py#L12&quot;&gt;&lt;img align=&quot;right&quot; style=&quot;float:right;&quot; src=&quot;https://img.shields.io/badge/-source-cccccc?style=flat-square&quot;&gt;&lt;/a&gt;##### &lt;kbd&gt;function&lt;/kbd&gt; `__init__````python__init__(    max_elements: Optional[int] = None,    error_rate: Optional[float] = None,    restore_from_serialized: bytes = None)```---&lt;a href=&quot;python/shaped_bloom_filter/filter.py#L32&quot;&gt;&lt;img align=&quot;right&quot; style=&quot;float:right;&quot; src=&quot;https://img.shields.io/badge/-source-cccccc?style=flat-square&quot;&gt;&lt;/a&gt;##### &lt;kbd&gt;function&lt;/kbd&gt; `add````pythonadd(var: int)```Add a single 32-bit integer key to the filter. ---&lt;a href=&quot;python/shaped_bloom_filter/filter.py#L38&quot;&gt;&lt;img align=&quot;right&quot; style=&quot;float:right;&quot; src=&quot;https://img.shields.io/badge/-source-cccccc?style=flat-square&quot;&gt;&lt;/a&gt;##### &lt;kbd&gt;function&lt;/kbd&gt; `add_batch````pythonadd_batch(var: List[int])```Add a list of 32-bit integer keys to the filter. ---&lt;a href=&quot;python/shaped_bloom_filter/filter.py#L62&quot;&gt;&lt;img align=&quot;right&quot; style=&quot;float:right;&quot; src=&quot;https://img.shields.io/badge/-source-cccccc?style=flat-square&quot;&gt;&lt;/a&gt;##### &lt;kbd&gt;function&lt;/kbd&gt; `are_members````pythonare_members(var: List[int]) → List[bool]```Check if a given list of 32-bit integer keys have been set. A boolean list is returned. ---&lt;a href=&quot;python/shaped_bloom_filter/filter.py#L56&quot;&gt;&lt;img align=&quot;right&quot; style=&quot;float:right;&quot; src=&quot;https://img.shields.io/badge/-source-cccccc?style=flat-square&quot;&gt;&lt;/a&gt;##### &lt;kbd&gt;function&lt;/kbd&gt; `is_member````pythonis_member(var: int) → bool```Check if a given 32-bit integer key has been set. ---&lt;a href=&quot;python/shaped_bloom_filter/filter.py#L86&quot;&gt;&lt;img align=&quot;right&quot; style=&quot;float:right;&quot; src=&quot;https://img.shields.io/badge/-source-cccccc?style=flat-square&quot;&gt;&lt;/a&gt;##### &lt;kbd&gt;function&lt;/kbd&gt; `serialize````pythonserialize() → bytes```Serialize the filter for storing purposes. To restore it, pass the returned bytes into the constructor's restore_from_serialized parameter. ---&lt;a href=&quot;python/shaped_bloom_filter/filter.py#L99&quot;&gt;&lt;img align=&quot;right&quot; style=&quot;float:right;&quot; src=&quot;https://img.shields.io/badge/-source-cccccc?style=flat-square&quot;&gt;&lt;/a&gt;##### &lt;kbd&gt;function&lt;/kbd&gt; `load````pythonload(serialized_bloom_filter: bytes)```Restore a serialized bloom filter into the existing context. Computationally faster than creating a new filter from scratch.---&lt;a href=&quot;python/shaped_bloom_filter/filter.py#L123&quot;&gt;&lt;img align=&quot;right&quot; style=&quot;float:right;&quot; src=&quot;https://img.shields.io/badge/-source-cccccc?style=flat-square&quot;&gt;&lt;/a&gt;##### &lt;kbd&gt;function&lt;/kbd&gt; `__contains__````python__contains__(var: int) → bool```Check if a given 32-bit integer key has been set.---#### &lt;kbd&gt;class&lt;/kbd&gt; `BloomFilterExtended(BloomFilter)`&lt;a href=&quot;python/shaped_bloom_filter/filter.py#L160&quot;&gt;&lt;img align=&quot;right&quot; style=&quot;float:right;&quot; src=&quot;https://img.shields.io/badge/-source-cccccc?style=flat-square&quot;&gt;&lt;/a&gt;##### &lt;kbd&gt;function&lt;/kbd&gt; `add_one_member````pythonadd_one_member(var: Union[List[int], int, bytes])```Add a single key to the filter. Examples of keys: serialized Python objects, strings, 64-digit integers, etc. ---&lt;a href=&quot;python/shaped_bloom_filter/filter.py#L176&quot;&gt;&lt;img align=&quot;right&quot; style=&quot;float:right;&quot; src=&quot;https://img.shields.io/badge/-source-cccccc?style=flat-square&quot;&gt;&lt;/a&gt;##### &lt;kbd&gt;function&lt;/kbd&gt; `is_one_member````pythonis_one_member(var: Union[List[int], int, bytes]) → bool```Check if a single key has been set. Examples of keys: serialized Python objects, strings, 64-digit integers, etc. ---_This file was automatically generated via [lazydocs](https://github.com/ml-tooling/lazydocs)._## ContributingIf you wish to contribute to this project, please branch and issue a pull request against master (&quot;[GitHub Flow](https://guides.github.com/introduction/flow/)&quot;)This project includes a Makefile that allows you to test and build the project with simple commands.To see all available options:```bashmake help```## Running all testsBefore committing the code, please check if it passes all tests using (note: this will install some dependencies):```bashmake python-environmentmake python-buildmake python-installmake python-tests```## DesignA Bloom filter has two parameters: _m_, the number of bits used in storage, and _k_, the number of hashing functions on elements of the set. (The actual hashing functions are important, too, but this is not a parameter for this implementation). A Bloom filter is backed by a [BitSet](https://github.com/bits-and-blooms/bitset); a key is represented in the filter by setting the bits at each value of the  hashing functions (modulo _m_). Set membership is done by _testing_ whether the bits at each value of the hashing functions (again, modulo _m_) are set. If so, the item is in the set. If the item is actually in the set, a Bloom filter will never fail (the true positive rate is 1.0); but it is susceptible to false positives. The art is to choose _k_ and _m_ correctly.In this implementation, the hashing functions used is [murmurhash](github.com/twmb/murmur3), a non-cryptographic hashing function.Given the particular hashing scheme, it's best to be empirical about this. Notethat estimating the FP rate will clear the Bloom filter.</longdescription>
</pkgmetadata>