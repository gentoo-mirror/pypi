<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pyctdev: python packaging common tasks for developersTools (and documentation) to support common tasks across many similarprojects, focusing on those making up [HoloViz.org](http://holoviz.org).**Note: documentation is draft/currently being written**## What is pyctdev?The main part of pyctdev is a cross-platform, make-like tool plus libraryof common tasks to allow project admin tasks to be run equally welllocally or on various CI systems, on different platforms, or to supportdifferent python package 'ecosystems' (pip and conda):```$ doit listbuild_docs        build docsdevelop_install   python develop install with specified optional groups of dependencies.ecosystem_setup   Common pip setupenv_capture       Report all information required to recreate current environment.env_create        TODO: create named environment if it doesn't already exist.env_export        TODOlist_envspackage_build     Build pip package, then install and test all_quick (or otherpackage_upload    Upload pip packages to pypitest_all          Run &quot;all&quot; teststest_examples     Run &quot;examples&quot; teststest_flakes       Run &quot;flakes&quot; teststest_unit         Run &quot;unit&quot; tests$ doit ecosystem=conda listbuild_docs           build docsdevelop_install      python develop install, with specified optional groups of dependencies (installed by conda only).ecosystem_setup      Common conda setup (must be run in base env).env_capture          Report all information required to recreate current conda environmentenv_create           Create named environment if it doesn't already existenv_export           Generate a pinned environment.yaml from specified env, filtering against specified groups of deps.list_envsminiconda_download   Download Miniconda3-latestminiconda_install    Install Miniconda3-latest to location if not already presentpackage_build        Build and then test conda.recipe/ (or specified alternative).package_upload       Upload package built from conda.recipe/ (or specified alternative).test_all             Run &quot;all&quot; teststest_examples        Run &quot;examples&quot; teststest_flakes          Run &quot;flakes&quot; teststest_unit            Run &quot;unit&quot; tests```Although doit+pyctdev must be installed to run these tasks, the approachis trying to call standard python and/or conda tools where possible,so that people can run commands independently without installingdoit+pyctdev. This means pyctdev can be viewed as:  * documentation of what all the common tasks are  * documentation of the commands necessary to perform those tasks  * a way to expose gaps in underlying tools that we might like to    fill (or exposes our lack of knowledge of how to use them, so we    can be corrected :) )  * a way to map relatively unchanging &quot;high level tasks&quot; (e.g. &quot;run    the unit tests&quot;) to underlying specific commands that might change over    time (e.g. as the python packaging ecosystem changes) or that vary    between projects (e.g. run tests with nose or with pytest).  * our current best understanding of how to perform the various tasks    (balancing the best possible way with what's practically possible    in general, given what tools are currently widely available).The accompanying [background](background.md) document (even more draftthan this one!) contains more details, along with explanations forchoices. It's broken into the same sections, so can be read alongsidethis document.There's also an [instructions](instructions.md) document for settingup a new project (but it's only a placeholder right now...).If you have a question, please feel free to open an issue (after firstchecking the [FAQ](FAQ.md).## What does pyctdev cover?pyctdev is a work in progress, and when it stabilizes we will need toexpand this description to include a clear mission statement aboutwhat is intended to be covered by pyctdev and which aspects of packagemanagement are out of scope.### 0. What are all the tasks? How to run a task?pyctdev shows what tasks there are, e.g. &quot;run unit tests&quot;, &quot;build condapackage&quot;, &quot;upload conda package&quot;, &quot;install as a developer&quot;, and so on.pyctdev also documents how to perform those tasks, i.e. what thenecessary command(s) are for a task, or what tasks should be runbefore others.To see all the tasks, you can type `doit list` in a project using pyctdevto get a list of the tasks with descriptions. `doit info` gives moredetail on any particular task. Alternatively, you can read the pyctdevsource code; most tasks are straightforward commands.### 1. Can run project admin tasks locally, on CI, and across platformsdoit/pyctdev are written in python so should work everywhere python'savailable (not just on Unix-like systems, unlike many projectconfiguration files). (And once any python's available, doit can beused to install other pythons if necessary - currently miniconda andanaconda.) Having the same command to run on each platform helps ensurethat testing, package building, and related tasks are done consistentlyacross platforms, which is particularly important when developers useone platform but users will download packages for another.Other suggested tools used by pyctdev are also cross platform: tox,conda, pip, etc.### 2. support python and conda ecosystemspyctdev supports performing most tasks with either the python/pip or theconda ecosystem. E.g. `doit develop_install` will typically run `pipinstall -e .[tests]`, which installs the dependencies using pip andthen does an editable install. Alternatively, `doit ecosystem=condadevelop install` will install dependencies using conda, followed by aneditable install. Projects can set a default ecosystem.The ability to install with pip or conda, create reproducible/isolatedenvironments with python tools (virtualenv+pip, or pipenv) or withconda tools (conda env), package for pip or conda, helps developersusing primarily one ecosystem to still support the other (e.g. via CIsystems).### 3. support multiple versions of pythonSimilarly to allowing developers to support both pip and condaecosystems, pyctdev allows developers to support multiple versions ofpython. For python, doit uses tox to run same tests over multipleenvironments using tox. For conda, pyctdev runs conda build over multipleversions of python.### 4. dependencies in one placepyctdev allows developers to express their project's &quot;abstract&quot;dependencies in one place. Currently this place is setup.py, as it'swidely supported by both python and conda tools. The dependencieslisted in setup.py are used for:  * end-user pip packages  * end-user conda packages  * developers using conda  * developers using pip  * generating environment files (e.g. examples environment.yml)The abstract dependencies may be transformed to more concrete ones,e.g. for a tutorial examples environment, versions of all dependenciesmay be pinned to ensure reproducibility (see 10/environment files,below).pyctdev supports transforming dependencies and generating environment.yml(and possibly pipenv or similar).### 5. dependencies labelled for different purposespyctdev supports expressing build and install/runtime dependencies, plusvarious optional groups of dependencies (e.g. for running examples,building docs, etc).pyctdev uses standard/generally supported python/pip/setuptools setup.pyarguments to do this (`install_requires` and `extras_require`). pipunderstands these, so the same optional dependency groups areavailable to users (e.g. a user can run `pip installpackage[examples]` to get package and the dependencies necessary torun its examples.To support 'options' in the conda ecosystem, multiple packages aregenerated - though typically our projects just have &quot;base&quot; and&quot;examples&quot; packages. `package-examples` depends on a specific pinned`package` (pinned at build time).### 6. testing of what users installpyctdev encourages testing of the packages that users will install,rather than focusing only on testing what developers work with.In the python ecosystem, tox is used to build a package, create aclean virtual environment, installs the package, and then run thetests. tox additionally supports running the same tests over multipleversions of python, in multiple environments (e.g. with different setsof dependencies installed), etc.In the conda ecosystem, conda build is called multiple times toachieve the same.### 7. testing of what developers doIt's often difficult to contribute to a project, because setting it upto the point of being able to run the tests is difficult. Seasonedproject developers know what they are doing, but it's less obvious tooccasional developers.pyctdev ensures the dependencies required to develop a project areobvious, and encourages developers to keep them up to date (e.g. bytesting `doit develop_install` on neutral CI machines).pyctdev also tries to capture how developers set up their environment.E.g. dependencies installed by conda, with a `python setup.py develop--no-deps` on top.### 8. Testing in different environmentsE.g. `doit package_build --test-python=py36 --test_requires=with_xarray --test-group=unit`will build a package then install it into a python 3.6 environment,and will then further install `with_xarray` dependencies, and thenwill run the unit tests. The dependencies for `with_xarray` arespecified in tox.ini (as are the unit test commands). This works withecosystem=pip and ecosystem=conda. It's also possible to have extratest commands that only run in a particular test environment(e.g. `with_xarray`).`doit test_unit` will run the unit tests in your current environment.If there are extra commands for a particular environment, they will berun if you select it. E.g. `doit test_unit --test-groupwith_xarray`. However, your current environment is not altered by testcommands, so you would need to have installed `with_xarray`dependencies if necessary.### 9. packages on demand? simplify packaging recipes?As well as specifying dependencies once, pyct attempts to express otherpackage metadata only once. Currently this is in setup.py. Templatingis then used for conda build. This prevents the common situation wheredescriptions, URLs, licenses, etc, are mismatched.pyctdev expects project is being released first on pypi and on ananaconda.org channel. From these sources, conda-forge can be updated, followed byanaconda defaults (but we are not necessarily the maintainers of thosechannels).pyctdev is currently primarily supporting pure Python packages. Whilethey may often have complex, platform specific dependencies, thepackages controlled by pyct are so far all pure Python. Thereforewe build noarch:python conda packages where possible.  If we startmaintaining packages with binary code, pyct will be extendedto support platform-specific packages, but for now none of ourpackages require that.### 10. Channels/sources of dependenciesFor python/pip: typically just pypi.org. But other 'channels' can bespecified. E.g. test.pypi.org, or a private server.The conda packages we maintain for HoloViz.org can usually be installedon top of either anaconda defaults or conda-forge. We currently putthem on anaconda.org pyviz (releases) and pyviz/label/dev (devversions), and only our specific packages are on this channel. For avariety of reasons we recommend that any one install should not mixconda-forge and defaults. For a project with tricky requirements, werecommend one above the other. Or if a project suffers inperformance on one or the other, we make a recommendation.Our dev builds and dev package releases of projects on Travis CI usepyviz/label/dev to get other packages, while release package buildsjust use pyviz. And then if devs are happy with those packages,conda-forge and defaults should be updated.### 11. How to structure projectAlthough it's not necessary, a common structure simplifies thingsacross multiple similar projects. HoloViz projects typically haverepositories that look like:```package/package/testspackage/tests/datapackage/examples/package/examples/datapackage/examples/assetsexamples -&gt; package/examplesdoc/       # minimal nbsite skeleton onlydoc/assets # e.g. favicon - not relevant to notebooks```We try to limit differences between what's in the repository andwhat's in the package shipped to users, to avoid creating custompackage building code.### 12. Unify how various tools are runOften, it's not clear how to run the tests for a project. Pyct alreadyhelps with this by having high level tasks such as &quot;run unittests&quot;. However, pyctdev also encourages internal command definitions toappear only once.Currently, setup.cfg is used to store global options for commands(e.g. flake8 rules), while tox.ini is used to store the various actualcommands used for different things (e.g. running unit tests, runningtests in different environments, etc). (TODO: what is shared acrossprojects, and how? Would rather not have a config file for pyctdev...)### 13. What's tested, and how.There are various tools for running tests (e.g. pytest, nose). An aimof pyctdev is for our HoloViz projects to all end up using the samedeveloper tools where possible. And to configure those tools in thesame kind of way.* unit tests: pytest* flakes: pyflakes* examples:    * notebooks run without error: pytest plugin nbsmoke    * notebooks flakes: pytest plugin nbsmoke    * notebooks &quot;data tests&quot;: pytest plugin nbva* performance/benchmark tests: (pytest-benchmark, custom stuff,  airspeed velocity, ??)* ...?pytest has features for defining (&quot;marking&quot;) and then selecting groupsof tests to run. So pyctdev expects there to be:  * &quot;slow tests&quot; (`pytest -m slow`)  * ...?### 14. docs#### website  * nbsite for examples -&gt; website#### live docs  * Live/browser way for users to try examples: mybinder### 15. versioningVersion via git tag. Version is stored only in one place in therepository (a git tag), and is written into packages. Every place thatneeds to know version (`__init__.py`; packaging: `setup.py`,`meta.yaml`; docs) reads it from the single source.Storing in one place, and it being the tag rather than in the git reposource code, makes it easier to automate various other 'release time'tasks. Our projects generally use[autover](https://github.com/pyviz/autover) (via param).Versioning scheme:  * we use `vX.Y.Z`  * post 1.0, (TODO: copy hv's scheme?)### 16. automate release type tasks on travisAs far as possible, just by running one or a couple of doit commands,we avoid CI-provided magic except where it's truly unavoidable or veryuseful (e.g. parallelizing builds, etc), because we need to supportmultiple CI systems (Travis CI for Linux and Mac, plus Appveyor forWindows).#### automatically generated packagesEvery (dev) release:  * conda packages are built and uploaded to anaconda.org    (pyviz/label/dev) pyviz/label/main  * pip packages (sdist zip, universal wheel) are built and uploaded    to (test.pypi.org) pypi.orgA release happens when a `vX.Y.Z` tag is pushed. Dev releases caneither be defined as &quot;every merge to master&quot; (e.g. for a matureproject), or &quot;every time a `vX.Y.ZaN` style tag is pushed (for arapidly changing project).Note: &quot;package build&quot; means generate package, install package intoclean environment, run tests.#### automatically generated websiteTwo main options:  1. for young, fast-moving projects: a single main website (default:     https://package.github.io/) updated on releases (plus maybe also     special post-release tags where we're fixing minor docs issues     without changing code, which presumably must be tagged     specially), with a separate dev website (default:     https://pyviz-docs.github.io/package-master) updated on every     push to master (or every time an alpha/beta/rc format tag is     pushed ?).  2. Same as 1, but also archiving websites for each major release     (i.e. one copy for X.Y, updated for each new .Z) over time until     we eventually delete them.  Presumably could actually just make 2     the default, with the definition that only versions 1.0 or     greater count as a major release, in which case it would follow     policy 1 until reaching 1.0, then policy 2, thereby acting as     appropriate for a young, fast-moving project until release 1.0,     then archiving each x.y version.Note: for e.g. datashader, using Travis CI isn't currently feasible(build takes too long/uses too much memory/requires too-largedata). But Travis is just using doit commands, so same can be runlocally at release time.### 17. Extra CI things#### platforms* Ubuntu (Travis CI)* MacOS (Travis CI)* Windows (appveyor)#### cachingInstalling miniconda and dependencies from scratch every time takes upquite a lot of build time for some projects.Caching of miniconda/conda environments is thereforesupported. (Supported also for python/pip, although speed is not anissue there).In many ways, this could be a better test than installing fromscratch, since many devs/users will be updating existing condainstallations/environments rather than starting from scratch.#### build stages/parallelization of buildsRather than running tasks sequentially (wall clock time consuming; atask might affect subsequent ones), tasks can be run independently inparallel.### To add to docs* generating pinned conda package* generating environment.yml</longdescription>
</pkgmetadata>