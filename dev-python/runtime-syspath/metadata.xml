<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>`runtime-syspath` is a package to ease programmatically adding src rootpaths to `sys.path`. This is targeted at python test code that needs todiscover a project's solution source to test.&gt; :exclamation: It is generally **frowned upon** to alter the `sys.path`&gt; programmatically as it confuses development, especially refactoring.&gt; Python IDEs can statically determine if a dependent package's import&gt; statement is left wanting whether a PyPi installation in needed or&gt; source cannot be discovered through standard Python paths. A static&gt; analysis tool's *missing import* detection will end up registering&gt; false-negatives if the import is discovered via dynamic (programmatic)&gt; additions to `sys.path` at runtime.*The following description assumes the use of `pytest` unit testingsupport and a project file structuring that includes project rootdirectories named `src` (project solution) and `tests` (project tests ofproject source under `src`. Both `src` and `tests` are not intended tohave package initializers (`__init__.py`). Packages therein willtypically have package initializers allowing for test modules to havethat same name (in separate packages). However, as a general rule, testmodules are not intended to import other test modules. Therefore, thereshould be no need for `__init__.py`-enabled, relative importationbetween test cases or sub-package test cases. `pytest`'s[default test discovery](https://docs.pytest.org/en/latest/goodpractices.html#test-discovery)and intended design use negates the need for :*```├─ src│  └─ __init__.py|  └─ foo.py├─ tests│  └─ test_foo.py│     └─ foo_and_goo│        └─ __init__.py│        └─ test_foo.py│        └─ test_goo.py└─ setup.py```*That structure is based upon[this guidance](https://blog.ionelmc.ro/2014/05/25/python-packaging/#the-structure).*When testing solution source in a project, the test cases _could_statically access the solution source by importing with the `src`package prefix:```import src.packagename.foo```Not only does that not feel right at all, that solution implies thattests are run **only** from the project root, not within the `tests`directory itself. If the test is run within the `tests` directory, the`src` package won't be found at runtime.So, using:```import packagename.foo```... the `src` directory would need to be programmatically added to the`sys.path`. This will allow for tests to be run form any workingdirectory under the `tests` sub-tree.`runtime_syspath.add_srcdirs_to_syspath()` will discover all `src`directories under `&lt;project root&gt;/src`. The reason that there may bemore is if your project may be leveraging `git subprojects` under`&lt;project root&gt;/src` that have their own `src` directories. Those needto be added to `sys.path` also.To leverage `runtime-syspath` to add the `src` directory everytime atest is run, import `runtime-syspath` and run`add_srcdirs_to_syspath()` in `tests/conftest.py`. (If `tests`contain more `conftest.py` under its directory tree, the call still onlyneed appear in the root `test/conftest.py`!): ``` from runtime_syspath import add_srcdirs_to_syspath  add_srcdirs_to_syspath()  ````add_srcdirs_to_syspath()` will recursively discover **all** `src`subdirectories under the &lt;project root&gt;. For projects that use `gitsubmodules`, their `src` directories need to be added to `src.path` forimport access. `git subprojects` could be added to `src` or `tests`directory trees:```├─ src│  └─ __init__.py|  └─ projectpackage│     └─ __init__.py|     └─ foo.py|  └─ subproject|     └─ src│       └─ __init__.py|       └─ bar.py|     └─ tests├─ tests│  └─ test_foo.py|  └─ test_subproject|     └─ src│       └─ __init__.py|       └─ unfoobarrator.py|     └─ tests└─ setup.py```&gt; :exclamation: Due to the code maintenance and grok'ing mayhem caused&gt; by indiscriminate runtime additions to `sys.path`, your goal should be&gt; to limit that anti-pattern to this discovery-of-source aspect for&gt; import discovery.&gt; :bulb: Since programmatically adding to a `sys.path` impairs an IDE's&gt; ability to do static import discovery and leveraging IDE refactoring&gt; features between the solution source and the test code, an IDE user&gt; would need to manually mark all `src` directories as such.  &gt; PyCharm example:&gt;&gt; ![image](docs/images/IDE_SetSrc.png)#### SysPathSleuth; runtime reporting of programmatic `sys.path` accessOn a project riddled with programmatically appending source paths to`sys.path`, a tool to discover which modules are mucking with `sys.path`and when could prove useful. This discovery can assist with manuallyeradicating `sys.path` access in favor of updating imports withfully-qualified (anchored at but, not including `src`), absolutemodule/package names. static tools would then be able to discover themodules/packages imported.&gt; Relative paths: There is a place for relative paths when importing&gt; intra-package modules. But, when importing inter-package modules,&gt; leveraging fully-qualified, absolute module/package names is a wiser&gt; play.SysPathSleuth is a monkey-patch of `sys.path` to report on `sys.path`access that comes with an installer to install/uninstall SysPathSleuthinto either the user or system site's _customize_ modules(`~/pathto/user_site/usercustomize.py` or`/pathto/python/site-packages/sitecustomize.py`). SysPathSleuth can beinstalled/uninstalled using one of following option:1. `python -m syspath_sleuth \[--install _or_ --uninstall]`2. `syspath_sleuth_injector \[--install _or_ --uninstall]`3. at the start within a running programAt the start of a running program prior:```import atexitimport syspath_sleuthfrom runtime-syspath import syspath_sluethsyspath_sleuth.inject_sleuth()def uninstall_syspath_sleuth():    syspath_sleuth.uninstall_sleuth()atexit.register(uninstall_syspath_sleuth)if __name__ == &quot;__main__&quot;:    go_main_go()```It is possible to provide your own SysPathSleuth for more interestingdata gathering using the CLI:```syspath_sleuth_injector --install --custom my_custom_syspath_sleuth.py```That file must have a class named `SysPathSleuth` and wrap the`sys.path` or the `syspath_sleuth_injector` will reject it. _See`src/runtime_syspath/syspath_sleuth/syspath_sleuth.py` for out-of-boximplementation._Think along the lines of providing telemetry as long-running programswheedle there ways over their execution paths using logger `Handler`that sending data to a service.See example uses in the [`examples` subdirectory of this project](https://github.com/gkedge/runtime-syspath/tree/master/examples) .</longdescription>
</pkgmetadata>