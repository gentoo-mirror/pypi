<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>* New in 0.8: Source and tests are compatible with Python 3 (w/o ``setup.py``)  * 0.8.1: setup.py is now compatible with Python 3 as well* New in 0.7: `Multiple Types or Objects`_* New in 0.6: `Inspection and Extension`_, and thread-safe method registrationThe ``simplegeneric`` module lets you define simple single-dispatchgeneric functions, akin to Python's built-in generic functions like``len()``, ``iter()`` and so on.  However, instead of usingspecially-named methods, these generic functions use simple lookuptables, akin to those used by e.g. ``pickle.dump()`` and othergeneric functions found in the Python standard library.As you can see from the above examples, generic functions are actuallyquite common in Python already, but there is no standard way to createsimple ones.  This library attempts to fill that gap, as genericfunctions are an `excellent alternative to the Visitor pattern`_, aswell as being a great substitute for most common uses of adaptation.This library tries to be the simplest possible implementation of genericfunctions, and it therefore eschews the use of multiple or predicatedispatch, as well as avoiding speedup techniques such as C dispatchingor code generation.  But it has absolutely no dependencies, other thanPython 2.4, and the implementation is just a single Python module ofless than 100 lines.Usage-----Defining and using a generic function is straightforward::    &gt;&gt;&gt; from simplegeneric import generic    &gt;&gt;&gt; @generic    ... def move(item, target):    ...     &quot;&quot;&quot;Default implementation goes here&quot;&quot;&quot;    ...     print(&quot;what you say?!&quot;)    &gt;&gt;&gt; @move.when_type(int)    ... def move_int(item, target):    ...     print(&quot;In AD %d, %s was beginning.&quot; % (item, target))    &gt;&gt;&gt; @move.when_type(str)    ... def move_str(item, target):    ...     print(&quot;How are you %s!!&quot; % item)    ...     print(&quot;All your %s are belong to us.&quot; % (target,))    &gt;&gt;&gt; zig = object()    &gt;&gt;&gt; @move.when_object(zig)    ... def move_zig(item, target):    ...     print(&quot;You know what you %s.&quot; % (target,))    ...     print(&quot;For great justice!&quot;)    &gt;&gt;&gt; move(2101, &quot;war&quot;)    In AD 2101, war was beginning.    &gt;&gt;&gt; move(&quot;gentlemen&quot;, &quot;base&quot;)    How are you gentlemen!!    All your base are belong to us.    &gt;&gt;&gt; move(zig, &quot;doing&quot;)    You know what you doing.    For great justice!    &gt;&gt;&gt; move(27.0, 56.2)    what you say?!Inheritance and Allowed Types-----------------------------Defining multiple methods for the same type or object is an error::    &gt;&gt;&gt; @move.when_type(str)    ... def this_is_wrong(item, target):    ...     pass    Traceback (most recent call last):    ...    TypeError: &lt;function move...&gt; already has method for type &lt;...'str'&gt;    &gt;&gt;&gt; @move.when_object(zig)    ... def this_is_wrong(item, target): pass    Traceback (most recent call last):      ...    TypeError: &lt;function move...&gt; already has method for object &lt;object ...&gt;And the ``when_type()`` decorator only accepts classes or types::    &gt;&gt;&gt; @move.when_type(23)    ... def move_23(item, target):    ...     print(&quot;You have no chance to survive!&quot;)    Traceback (most recent call last):      ...    TypeError: 23 is not a type or classMethods defined for supertypes are inherited following MRO order::    &gt;&gt;&gt; class MyString(str):    ...     &quot;&quot;&quot;String subclass&quot;&quot;&quot;    &gt;&gt;&gt; move(MyString(&quot;ladies&quot;), &quot;drinks&quot;)    How are you ladies!!    All your drinks are belong to us.Classic class instances are also supported (although the lookup processis slower than for new-style instances)::    &gt;&gt;&gt; class X: pass    &gt;&gt;&gt; class Y(X): pass    &gt;&gt;&gt; @move.when_type(X)    ... def move_x(item, target):    ...     print(&quot;Someone set us up the %s!!!&quot; % (target,))    &gt;&gt;&gt; move(X(), &quot;bomb&quot;)    Someone set us up the bomb!!!    &gt;&gt;&gt; move(Y(), &quot;dance&quot;)    Someone set us up the dance!!!Multiple Types or Objects-------------------------As a convenience, you can now pass more than one type or object to theregistration methods::    &gt;&gt;&gt; @generic    ... def isbuiltin(ob):    ...     return False    &gt;&gt;&gt; @isbuiltin.when_type(int, str, float, complex, type)    ... @isbuiltin.when_object(None, Ellipsis)    ... def yes(ob):    ...     return True        &gt;&gt;&gt; isbuiltin(1)    True    &gt;&gt;&gt; isbuiltin(object)    True    &gt;&gt;&gt; isbuiltin(object())    False    &gt;&gt;&gt; isbuiltin(X())    False    &gt;&gt;&gt; isbuiltin(None)    True    &gt;&gt;&gt; isbuiltin(Ellipsis)    TrueDefaults and Docs-----------------You can obtain a function's default implementation using its ``default``attribute::    &gt;&gt;&gt; @move.when_type(Y)    ... def move_y(item, target):    ...     print(&quot;Someone set us up the %s!!!&quot; % (target,))    ...     move.default(item, target)    &gt;&gt;&gt; move(Y(), &quot;dance&quot;)    Someone set us up the dance!!!    what you say?!``help()`` and other documentation tools see generic functions as normalfunction objects, with the same name, attributes, docstring, and module asthe prototype/default function::    &gt;&gt;&gt; help(move)    Help on function move:    ...    move(*args, **kw)        Default implementation goes here    ...Inspection and Extension------------------------You can find out if a generic function has a method for a type or object usingthe ``has_object()`` and ``has_type()`` methods::    &gt;&gt;&gt; move.has_object(zig)    True    &gt;&gt;&gt; move.has_object(42)    False    &gt;&gt;&gt; move.has_type(X)    True    &gt;&gt;&gt; move.has_type(float)    FalseNote that ``has_type()`` only queries whether there is a method registered forthe *exact* type, not subtypes or supertypes::    &gt;&gt;&gt; class Z(X): pass    &gt;&gt;&gt; move.has_type(Z)    FalseYou can create a generic function that &quot;inherits&quot; from an existing genericfunction by calling ``generic()`` on the existing function::    &gt;&gt;&gt; move2 = generic(move)    &gt;&gt;&gt; move(2101, &quot;war&quot;)    In AD 2101, war was beginning.Any methods added to the new generic function override *all* methods in the&quot;base&quot; function::    &gt;&gt;&gt; @move2.when_type(X)    ... def move2_X(item, target):    ...     print(&quot;You have no chance to survive make your %s!&quot; % (target,))    &gt;&gt;&gt; move2(X(), &quot;time&quot;)    You have no chance to survive make your time!    &gt;&gt;&gt; move2(Y(), &quot;time&quot;)    You have no chance to survive make your time!Notice that even though ``move()`` has a method for type ``Y``, the methoddefined for ``X`` in ``move2()`` takes precedence.  This is because the``move`` function is used as the ``default`` method of ``move2``, and ``move2``has no method for type ``Y``::    &gt;&gt;&gt; move2.default is move    True    &gt;&gt;&gt; move.has_type(Y)    True    &gt;&gt;&gt; move2.has_type(Y)    FalseLimitations-----------* The first argument is always used for dispatching, and it must always be  passed *positionally* when the function is called.* Documentation tools don't see the function's original argument signature, so  you have to describe it in the docstring.* If you have optional arguments, you must duplicate them on every method in  order for them to work correctly.  (On the plus side, it means you can have  different defaults or required arguments for each method, although relying on  that quirk probably isn't a good idea.)These restrictions may be lifted in later releases, if I feel the need.  Theywould require runtime code generation the way I do it in ``RuleDispatch``,however, which is somewhat of a pain.  (Alternately I could use the``BytecodeAssembler`` package to do the code generation, as that's a lot easierto use than string-based code generation, but that would introduce moredependencies, and I'm trying to keep this simple so I can justtoss it into Chandler without a big footprint increase.).. _excellent alternative to the Visitor pattern: http://peak.telecommunity.com/DevCenter/VisitorRevisited</longdescription>
</pkgmetadata>