<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Big Tree Python PackageTree Implementation for Python, integrated with Python list, dictionary, and pandas DataFrame.It is pythonic, making it easy to learn and extendable to many types of workflows.----Related Links:- [Documentation](https://bigtree.readthedocs.io/en/latest/)- [GitHub](https://github.com/kayjan/bigtree/)- [Changelog](https://github.com/kayjan/bigtree/blob/master/CHANGELOG.md)- [Issues](https://github.com/kayjan/bigtree/issues)- [Discussions](https://github.com/kayjan/bigtree/discussions)- [Contributing](https://bigtree.readthedocs.io/en/latest/others/contributing.html)- [PyPI](https://pypi.org/project/bigtree/)- Articles  - [Python Tree Implementation with BigTree](https://towardsdatascience.com/python-tree-implementation-with-bigtree-13cdabd77adc#245a-94ae81f0b3f1)- &lt;div&gt;&lt;p&gt;If you want to support bigtree, &lt;a href=&quot;https://www.buymeacoffee.com/kayjan&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Buy_Me_A_Coffee-FFDD00?style=for-the-badge&amp;logo=buy-me-a-coffee&amp;logoColor=black&quot; alt=&quot;Buy Me a Coffee&quot; style=&quot;vertical-align:middle&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;----## ComponentsThere are 3 segments to Big Tree consisting of Tree, Binary Tree, and Directed Acyclic Graph (DAG) implementation.For **Tree** implementation, there are 9 main components.1. [**Node**](https://bigtree.readthedocs.io/en/latest/node.html)   1. ``BaseNode``, extendable class   2. ``Node``, BaseNode with node name attribute2. [**Constructing Tree**](https://bigtree.readthedocs.io/en/latest/bigtree/tree/construct.html)   1. From *str*, using tree in string display format   2. From *list*, using paths or parent-child tuples   3. From *nested dictionary*, using path or recursive structure   4. From *pandas DataFrame*, using paths or parent-child columns   5. Add nodes to existing tree using path string   6. Add nodes and attributes to existing tree using dictionary or pandas DataFrame, using path   7. Add only attributes to existing tree using dictionary or pandas DataFrame, using node name3. [**Traversing Tree**](https://bigtree.readthedocs.io/en/latest/bigtree/utils/iterators.html)   1. Pre-Order Traversal   2. Post-Order Traversal   3. Level-Order Traversal   4. Level-Order-Group Traversal   5. ZigZag Traversal   6. ZigZag-Group Traversal4. [**Modifying Tree**](https://bigtree.readthedocs.io/en/latest/bigtree/tree/modify.html)   1. Shift nodes from location to destination   2. Copy nodes from location to destination   3. Copy nodes from one tree to another5. [**Tree Search**](https://bigtree.readthedocs.io/en/latest/bigtree/tree/search.html)   1. Find multiple nodes based on name, partial path, relative path, attribute value, user-defined condition   2. Find single nodes based on name, partial path, relative path, full path, attribute value, user-defined condition   3. Find multiple child nodes based on user-defined condition   4. Find single child node based on name, user-defined condition6. [**Helper Function**](https://bigtree.readthedocs.io/en/latest/bigtree/tree/helper.html)   1. Cloning tree to another `Node` type   2. Prune tree   3. Get difference between two trees7. [**Plotting Tree**](https://bigtree.readthedocs.io/en/latest/bigtree/utils/plot.html)   1. Enhanced Reingold Tilford Algorithm to retrieve (x, y) coordinates for a tree structure8. [**Exporting Tree**](https://bigtree.readthedocs.io/en/latest/bigtree/tree/export.html)   1. Print to console   2. Export to *dictionary*, *nested dictionary*, or *pandas DataFrame*   3. Export tree to dot (can save to .dot, .png, .svg, .jpeg files)   4. Export tree to Pillow (can save to .png, .jpg)9. [**Workflows**](https://bigtree.readthedocs.io/en/latest/workflows.html)   1. Sample workflows for tree demonstration!For **Binary Tree** implementation, there are 3 main components.Binary Node inherits from Node, so the components in Tree implementation are also available in Binary Tree.1. [**Node**](https://bigtree.readthedocs.io/en/latest/node.html)   1. ``BinaryNode``, Node with binary tree rules2. [**Constructing Binary Tree**](https://bigtree.readthedocs.io/en/latest/bigtree/binarytree/construct.html)   1. From *list*, using flattened list structure3. [**Traversing Binary Tree**](https://bigtree.readthedocs.io/en/latest/bigtree/utils/iterators.html)   1. In-Order TraversalFor **Directed Acyclic Graph (DAG)** implementation, there are 4 main components.1. [**Node**](https://bigtree.readthedocs.io/en/latest/node.html)   1. ``DAGNode``, extendable class for constructing Directed Acyclic Graph (DAG)2. [**Constructing DAG**](https://bigtree.readthedocs.io/en/latest/bigtree/dag/construct.html)   1. From *list*, containing parent-child tuples   2. From *nested dictionary*   3. From *pandas DataFrame*3. [**Traversing DAG**](https://bigtree.readthedocs.io/en/latest/bigtree/utils/iterators.html)   1. Generic traversal method4. [**Exporting DAG**](https://bigtree.readthedocs.io/en/latest/bigtree/dag/export.html)   1. Export to *list*, *dictionary*, or *pandas DataFrame*   2. Export DAG to dot (can save to .dot, .png, .svg, .jpeg files)----## InstallationTo install `bigtree`, run the following line in command prompt:```shell$ pip install bigtree```If tree needs to be exported to image, it requires additional dependencies.Run the following lines in command prompt:```shell$ pip install 'bigtree[image]'$ brew install gprof2dot  # for MacOS$ conda install graphviz  # for Windows```----## Tree DemonstrationHere are some codes to get started.### Construct TreeNodes can have attributes if they are initialized from `Node`, *dictionary*, or *pandas DataFrame*.1. **From `Node`**Nodes can be linked to each other with `parent` and `children` setter methods,or using bitshift operator with the convention `parent_node &gt;&gt; child_node` or `child_node &lt;&lt; parent_node`.```pythonfrom bigtree import Node, tree_to_dotroot = Node(&quot;a&quot;)b = Node(&quot;b&quot;)c = Node(&quot;c&quot;)d = Node(&quot;d&quot;)root.children = [b, c]d.parent = broot.show()# a# ├── b# │   └── d# └── cgraph = tree_to_dot(root, node_colour=&quot;gold&quot;)graph.write_png(&quot;assets/demo_tree.png&quot;)```![Sample Tree Output](https://github.com/kayjan/bigtree/raw/master/assets/demo_tree.png)```pythonfrom bigtree import Noderoot = Node(&quot;a&quot;)b = Node(&quot;b&quot;)c = Node(&quot;c&quot;)d = Node(&quot;d&quot;)root &gt;&gt; broot &gt;&gt; cd &lt;&lt; broot.show()# a# ├── b# │   └── d# └── c```Alternatively, we can directly pass `parent` or `children` argument.```pythonfrom bigtree import Nodeb = Node(&quot;b&quot;)c = Node(&quot;c&quot;)d = Node(&quot;d&quot;, parent=b)root = Node(&quot;a&quot;, children=[b, c])root.show(style=&quot;ascii&quot;)# a# |-- b# |   +-- d# +-- c```2. **From *str***Construct nodes only.```pythonfrom bigtree import str_to_treetree_str = &quot;&quot;&quot;a├── b│   ├── d│   └── e│       ├── g│       └── h└── c    └── f&quot;&quot;&quot;root = str_to_tree(tree_str, tree_prefix_list=[&quot;├──&quot;, &quot;└──&quot;])root.show()# a# ├── b# │   ├── d# │   └── e# │       ├── g# │       └── h# └── c#     └── f```3. **From *list***Construct nodes only, list can contain either full paths or tuples of parent-child names.```pythonfrom bigtree import list_to_tree, list_to_tree_by_relationroot = list_to_tree([&quot;a/b/d&quot;, &quot;a/c&quot;])root.show()# a# ├── b# │   └── d# └── croot = list_to_tree_by_relation([(&quot;a&quot;, &quot;b&quot;), (&quot;a&quot;, &quot;c&quot;), (&quot;b&quot;, &quot;d&quot;)])root.show()# a# ├── b# │   └── d# └── c```4. **From *nested dictionary***Construct nodes with attributes, `key`: path, `value`: dict of node attribute names and attribute values.```pythonfrom bigtree import dict_to_treepath_dict = {   &quot;a&quot;: {&quot;age&quot;: 90},   &quot;a/b&quot;: {&quot;age&quot;: 65},   &quot;a/c&quot;: {&quot;age&quot;: 60},   &quot;a/b/d&quot;: {&quot;age&quot;: 40},}root = dict_to_tree(path_dict)root.show(attr_list=[&quot;age&quot;])# a [age=90]# ├── b [age=65]# │   └── d [age=40]# └── c [age=60]```5. **From *nested recursive dictionary***Construct nodes with attributes, `key`: node attribute names, `value`: node attribute values, and list ofchildren (recursive).```pythonfrom bigtree import nested_dict_to_treepath_dict = {   &quot;name&quot;: &quot;a&quot;,   &quot;age&quot;: 90,   &quot;children&quot;: [      {         &quot;name&quot;: &quot;b&quot;,         &quot;age&quot;: 65,         &quot;children&quot;: [            {&quot;name&quot;: &quot;d&quot;, &quot;age&quot;: 40},         ],      },      {&quot;name&quot;: &quot;c&quot;, &quot;age&quot;: 60},   ],}root = nested_dict_to_tree(path_dict)root.show(attr_list=[&quot;age&quot;])# a [age=90]# ├── b [age=65]# │   └── d [age=40]# └── c [age=60]```6. **From *pandas DataFrame***Construct nodes with attributes, *pandas DataFrame* can contain either path column or parent-child columns,and attribute columns.```pythonimport pandas as pdfrom bigtree import dataframe_to_tree, dataframe_to_tree_by_relationdata = pd.DataFrame(   [      [&quot;a&quot;, 90],      [&quot;a/b&quot;, 65],      [&quot;a/c&quot;, 60],      [&quot;a/b/d&quot;, 40],   ],   columns=[&quot;path&quot;, &quot;age&quot;],)root = dataframe_to_tree(data)root.show(attr_list=[&quot;age&quot;])# a [age=90]# ├── b [age=65]# │   └── d [age=40]# └── c [age=60]data = pd.DataFrame(   [      [&quot;a&quot;, None, 90],      [&quot;b&quot;, &quot;a&quot;, 65],      [&quot;c&quot;, &quot;a&quot;, 60],      [&quot;d&quot;, &quot;b&quot;, 40],   ],   columns=[&quot;child&quot;, &quot;parent&quot;, &quot;age&quot;],)root = dataframe_to_tree_by_relation(data)root.show(attr_list=[&quot;age&quot;])# a [age=90]# ├── b [age=65]# │   └── d [age=40]# └── c [age=60]```&gt; If tree is already created, attributes can still be added using dictionary or pandas DataFrame!### Print TreeAfter tree is constructed, it can be viewed by printing to console using `show` method directly.Alternatively, the `print_tree` method can be used.```pythonfrom bigtree import Node, print_treeroot = Node(&quot;a&quot;, age=90, gender=&quot;F&quot;)b = Node(&quot;b&quot;, age=65, gender=&quot;M&quot;, parent=root)c = Node(&quot;c&quot;, age=60, gender=&quot;M&quot;, parent=root)d = Node(&quot;d&quot;, age=40, gender=&quot;F&quot;, parent=b)e = Node(&quot;e&quot;, age=35, gender=&quot;M&quot;, parent=b)print_tree(root)# a# ├── b# │   ├── d# │   └── e# └── c# Print subtreeprint_tree(root, node_name_or_path=&quot;b&quot;)# b# ├── d# └── eprint_tree(root, max_depth=2)# a# ├── b# └── c# Print attributesprint_tree(root, attr_list=[&quot;age&quot;])# a [age=90]# ├── b [age=65]# │   ├── d [age=40]# │   └── e [age=35]# └── c [age=60]print_tree(root, attr_list=[&quot;age&quot;], attr_bracket=[&quot;*(&quot;, &quot;)&quot;])# a *(age=90)# ├── b *(age=65)# │   ├── d *(age=40)# │   └── e *(age=35)# └── c *(age=60)print_tree(root, all_attrs=True)# a [age=90, gender=F]# ├── b [age=65, gender=M]# │   ├── d [age=40, gender=F]# │   └── e [age=35, gender=M]# └── c [age=60, gender=M]# Available stylesprint_tree(root, style=&quot;ansi&quot;)# a# |-- b# |   |-- d# |   `-- e# `-- cprint_tree(root, style=&quot;ascii&quot;)# a# |-- b# |   |-- d# |   +-- e# +-- cprint_tree(root, style=&quot;const&quot;)# a# ├── b# │   ├── d# │   └── e# └── cprint_tree(root, style=&quot;const_bold&quot;)# a# ┣━━ b# ┃   ┣━━ d# ┃   ┗━━ e# ┗━━ cprint_tree(root, style=&quot;rounded&quot;)# a# ├── b# │   ├── d# │   ╰── e# ╰── cprint_tree(root, style=&quot;double&quot;)# a# ╠══ b# ║   ╠══ d# ║   ╚══ e# ╚══ cprint_tree(    root,    style=&quot;custom&quot;,    custom_style=(&quot;|   &quot;, &quot;|-- &quot;, &quot;+-- &quot;),)# a# |-- b# |   |-- d# |   +-- e# +-- c```### Traverse TreeTree can be traversed using pre-order, post-order, level-order, level-order-group, zigzag, zigzag-group traversal methods.```pythonfrom bigtree import Node, preorder_iter, postorder_iter, levelorder_iter, levelordergroup_iter, zigzag_iter, zigzaggroup_iterroot = Node(&quot;a&quot;)b = Node(&quot;b&quot;, parent=root)c = Node(&quot;c&quot;, parent=root)d = Node(&quot;d&quot;, parent=b)e = Node(&quot;e&quot;, parent=b)root.show()# a# ├── b# │   ├── d# │   └── e# └── c[node.name for node in preorder_iter(root)]# ['a', 'b', 'd', 'e', 'c'][node.name for node in postorder_iter(root)]# ['d', 'e', 'b', 'c', 'a'][node.name for node in levelorder_iter(root)]# ['a', 'b', 'c', 'd', 'e'][[node.name for node in node_group] for node_group in levelordergroup_iter(root)]# [['a'], ['b', 'c'], ['d', 'e']][node.name for node in zigzag_iter(root)]# ['a', 'c', 'b', 'd', 'e'][[node.name for node in node_group] for node_group in zigzaggroup_iter(root)]# [['a'], ['c', 'b'], ['d', 'e']]```### Modify TreeNodes can be shifted or copied from one path to another.```pythonfrom bigtree import Node, shift_nodesroot = Node(&quot;a&quot;)b = Node(&quot;b&quot;, parent=root)c = Node(&quot;c&quot;, parent=root)d = Node(&quot;d&quot;, parent=root)root.show()# a# ├── b# ├── c# └── dshift_nodes(   tree=root,   from_paths=[&quot;a/c&quot;, &quot;a/d&quot;],   to_paths=[&quot;a/b/c&quot;, &quot;a/dummy/d&quot;],)root.show()# a# ├── b# │   └── c# └── dummy#     └── d``````pythonfrom bigtree import Node, copy_nodesroot = Node(&quot;a&quot;)b = Node(&quot;b&quot;, parent=root)c = Node(&quot;c&quot;, parent=root)d = Node(&quot;d&quot;, parent=root)root.show()# a# ├── b# ├── c# └── dcopy_nodes(   tree=root,   from_paths=[&quot;a/c&quot;, &quot;a/d&quot;],   to_paths=[&quot;a/b/c&quot;, &quot;a/dummy/d&quot;],)root.show()# a# ├── b# │   └── c# ├── c# ├── d# └── dummy#     └── d```Nodes can also be copied between two different trees.```pythonfrom bigtree import Node, copy_nodes_from_tree_to_treeroot = Node(&quot;a&quot;)b = Node(&quot;b&quot;, parent=root)c = Node(&quot;c&quot;, parent=root)d = Node(&quot;d&quot;, parent=root)root.show()# a# ├── b# ├── c# └── droot_other = Node(&quot;aa&quot;)copy_nodes_from_tree_to_tree(   from_tree=root,   to_tree=root_other,   from_paths=[&quot;a/b&quot;, &quot;a/c&quot;, &quot;a/d&quot;],   to_paths=[&quot;aa/b&quot;, &quot;aa/b/c&quot;, &quot;aa/dummy/d&quot;],)root_other.show()# aa# ├── b# │   └── c# └── dummy#     └── d```### Tree SearchOne or multiple nodes can be search based on name, path, attribute value, or user-defined condition.To find a single node,```pythonfrom bigtree import Node, find, find_name, find_path, find_relative_path, find_full_path, find_attrroot = Node(&quot;a&quot;, age=90)b = Node(&quot;b&quot;, age=65, parent=root)c = Node(&quot;c&quot;, age=60, parent=root)d = Node(&quot;d&quot;, age=40, parent=c)root.show(attr_list=[&quot;age&quot;])# a [age=90]# ├── b [age=65]# └── c [age=60]#     └── d [age=40]find(root, lambda node: node.age == 60)# Node(/a/c, age=60)find_name(root, &quot;d&quot;)# Node(/a/c/d, age=40)find_path(root, &quot;/c/d&quot;)  # partial path# Node(/a/c/d, age=40)find_relative_path(c, &quot;../b&quot;)  # relative path# (Node(/a/b, age=65),)find_full_path(root, &quot;a/c/d&quot;)  # full path# Node(/a/c/d, age=40)find_attr(root, &quot;age&quot;, 40)# Node(/a/c/d, age=40)```To find multiple nodes,```pythonfrom bigtree import Node, findall, find_names, find_relative_path, find_paths, find_attrsroot = Node(&quot;a&quot;, age=90)b = Node(&quot;b&quot;, age=65, parent=root)c = Node(&quot;c&quot;, age=60, parent=root)d = Node(&quot;c&quot;, age=40, parent=c)root.show(attr_list=[&quot;age&quot;])# a [age=90]# ├── b [age=65]# └── c [age=60]#     └── c [age=40]findall(root, lambda node: node.age &gt;= 65)# (Node(/a, age=90), Node(/a/b, age=65))find_names(root, &quot;c&quot;)# (Node(/a/c, age=60), Node(/a/c/c, age=40))find_relative_path(c, &quot;../*&quot;)  # relative path# (Node(/a/b, age=65), Node(/a/c, age=60))find_paths(root, &quot;/c&quot;)  # partial path# (Node(/a/c, age=60), Node(/a/c/c, age=40))find_attrs(root, &quot;age&quot;, 40)# (Node(/a/c/c, age=40),)```It is also possible to search for one or more child node(s) based on attributes, and the search will be faster asthis does not require traversing the whole tree to find the node(s).```pythonfrom bigtree import Node, find_children, find_child, find_child_by_nameroot = Node(&quot;a&quot;, age=90)b = Node(&quot;b&quot;, age=65, parent=root)c = Node(&quot;c&quot;, age=60, parent=root)d = Node(&quot;c&quot;, age=40, parent=c)root.show(attr_list=[&quot;age&quot;])# a [age=90]# ├── b [age=65]# └── c [age=60]#     └── c [age=40]find_children(root, lambda node: node.age &gt;= 60)# (Node(/a/b, age=65), Node(/a/c, age=60))find_child(root, lambda node: node.name == &quot;c&quot;)# Node(/a/c, age=60)find_child_by_name(root, &quot;c&quot;)# Node(/a/c, age=60)find_child_by_name(c, &quot;c&quot;)# Node(/a/c/c, age=40)```### Helper UtilityThere following are helper functions for cloning tree to another `Node` type, pruning tree, and getting differencebetween two trees.```pythonfrom bigtree import BaseNode, Node, clone_tree, prune_tree, get_tree_diff# Cloning tree from `BaseNode` to `Node` typeroot = BaseNode(name=&quot;a&quot;)b = BaseNode(name=&quot;b&quot;, parent=root)clone_tree(root, Node)# Node(/a, )# Prune tree to only path a/broot = Node(&quot;a&quot;)b = Node(&quot;b&quot;, parent=root)c = Node(&quot;c&quot;, parent=root)root.show()# a# ├── b# └── croot_pruned = prune_tree(root, &quot;a/b&quot;)root_pruned.show()# a# └── b# Get difference between two treesroot = Node(&quot;a&quot;)b = Node(&quot;b&quot;, parent=root)c = Node(&quot;c&quot;, parent=root)root.show()# a# ├── b# └── croot_other = Node(&quot;a&quot;)b_other = Node(&quot;b&quot;, parent=root_other)root_other.show()# a# └── btree_diff = get_tree_diff(root, root_other)tree_diff.show()# a# └── c (-)tree_diff = get_tree_diff(root, root_other, only_diff=False)tree_diff.show()# a# ├── b# └── c (-)```### Export TreeTree can be exported to another data type.1. *Export to **nested dictionary***2. *Export to **nested recursive dictionary***3. *Export to **pandas DataFrame***4. *Export to **dot** (and png)*5. *Export to **Pillow** (and png)*```pythonfrom bigtree import Node, tree_to_dict, tree_to_nested_dict, tree_to_dataframe, tree_to_dot, tree_to_pillowroot = Node(&quot;a&quot;, age=90)b = Node(&quot;b&quot;, age=65, parent=root)c = Node(&quot;c&quot;, age=60, parent=root)d = Node(&quot;d&quot;, age=40, parent=b)e = Node(&quot;e&quot;, age=35, parent=b)root.show()# a# ├── b# │   ├── d# │   └── e# └── ctree_to_dict(   root,   name_key=&quot;name&quot;,   parent_key=&quot;parent&quot;,   attr_dict={&quot;age&quot;: &quot;person age&quot;})# {#    '/a': {'name': 'a', 'parent': None, 'person age': 90},#    '/a/b': {'name': 'b', 'parent': 'a', 'person age': 65},#    '/a/b/d': {'name': 'd', 'parent': 'b', 'person age': 40},#    '/a/b/e': {'name': 'e', 'parent': 'b', 'person age': 35},#    '/a/c': {'name': 'c', 'parent': 'a', 'person age': 60}# }tree_to_nested_dict(root, all_attrs=True)# {#    'name': 'a',#    'age': 90,#    'children': [#       {#          'name': 'b',#          'age': 65,#          'children': [#             {#                'name': 'd',#                'age': 40#             },#             {#                'name': 'e',#                'age': 35#             }#          ]#       },#       {#          'name': 'c',#          'age': 60#       }#    ]# }tree_to_dataframe(   root,   name_col=&quot;name&quot;,   parent_col=&quot;parent&quot;,   path_col=&quot;path&quot;,   attr_dict={&quot;age&quot;: &quot;person age&quot;})#      path name parent  person age# 0      /a    a   None          90# 1    /a/b    b      a          65# 2  /a/b/d    d      b          40# 3  /a/b/e    e      b          35# 4    /a/c    c      a          60graph = tree_to_dot(root, node_colour=&quot;gold&quot;)graph.write_png(&quot;assets/demo.png&quot;)pillow_image = tree_to_pillow(root)pillow_image.save(&quot;assets/demo_pillow.png&quot;)```- demo.png![Sample Dot Image Output](https://github.com/kayjan/bigtree/raw/master/assets/demo.png)- demo_pillow.png![Sample Pillow Image Output](https://github.com/kayjan/bigtree/raw/master/assets/demo_pillow.png)----## Binary Tree DemonstrationCompared to nodes in tree, nodes in Binary Tree are only allowed maximum of 2 children.Since BinaryNode extends from Node, construct, traverse, search, export methods from Node are applicable toBinary Tree as well.### Construct Binary Tree1. **From `BinaryNode`**BinaryNode can be linked to each other with `parent`, `children`, `left`, and `right` setter methods,or using bitshift operator with the convention `parent_node &gt;&gt; child_node` or `child_node &lt;&lt; parent_node`.```pythonfrom bigtree import BinaryNode, tree_to_dote = BinaryNode(5)d = BinaryNode(4)c = BinaryNode(3)b = BinaryNode(2, left=d, right=e)a = BinaryNode(1, children=[b, c])f = BinaryNode(6, parent=c)g = BinaryNode(7, parent=c)h = BinaryNode(8, parent=d)graph = tree_to_dot(a, node_colour=&quot;gold&quot;)graph.write_png(&quot;assets/demo_binarytree.png&quot;)```![Sample DAG Output](https://github.com/kayjan/bigtree/raw/master/assets/demo_binarytree.png)2. **From *list***Construct nodes only, list has similar format as `heapq` list.```pythonfrom bigtree import list_to_binarytreenums_list = [1, 2, 3, 4, 5, 6, 7, 8]root = list_to_binarytree(nums_list)root.show()# 1# ├── 2# │   ├── 4# │   │   └── 8# │   └── 5# └── 3#     ├── 6#     └── 7```### Traverse Binary TreeIn addition to the traversal methods in the usual tree, binary tree includes in-order traversal method.```pythonfrom bigtree import list_to_binarytree, inorder_iter, preorder_iter, postorder_iter, levelorder_iter, levelordergroup_iter, zigzag_iter, zigzaggroup_iternums_list = [1, 2, 3, 4, 5, 6, 7, 8]root = list_to_binarytree(nums_list)root.show()# 1# ├── 2# │   ├── 4# │   │   └── 8# │   └── 5# └── 3#     ├── 6#     └── 7[node.name for node in inorder_iter(root)]# ['8', '4', '2', '5', '1', '6', '3', '7'][node.name for node in preorder_iter(root)]# ['1', '2', '4', '8', '5', '3', '6', '7'][node.name for node in postorder_iter(root)]# ['8', '4', '5', '2', '6', '7', '3', '1'][node.name for node in levelorder_iter(root)]# ['1', '2', '3', '4', '5', '6', '7', '8'][[node.name for node in node_group] for node_group in levelordergroup_iter(root)]# [['1'], ['2', '3'], ['4', '5', '6', '7'], ['8']][node.name for node in zigzag_iter(root)]# ['1', '3', '2', '4', '5', '6', '7', '8'][[node.name for node in node_group] for node_group in zigzaggroup_iter(root)]# [['1'], ['3', '2'], ['4', '5', '6', '7'], ['8']]```----## DAG DemonstrationCompared to nodes in tree, nodes in DAG are able to have multiple parents.### Construct DAG1. **From `DAGNode`**DAGNode can be linked to each other with `parents` and `children` setter methods,or using bitshift operator with the convention `parent_node &gt;&gt; child_node` or `child_node &lt;&lt; parent_node`.```pythonfrom bigtree import DAGNode, dag_to_dota = DAGNode(&quot;a&quot;)b = DAGNode(&quot;b&quot;)c = DAGNode(&quot;c&quot;, parents=[a, b])d = DAGNode(&quot;d&quot;, parents=[a, c])e = DAGNode(&quot;e&quot;, parents=[d])f = DAGNode(&quot;f&quot;, parents=[c, d])h = DAGNode(&quot;h&quot;)g = DAGNode(&quot;g&quot;, parents=[c], children=[h])graph = dag_to_dot(a, node_colour=&quot;gold&quot;)graph.write_png(&quot;assets/demo_dag.png&quot;)```![Sample DAG Output](https://github.com/kayjan/bigtree/raw/master/assets/demo_dag.png)2. **From *list***Construct nodes only, list contains parent-child tuples.```pythonfrom bigtree import list_to_dag, dag_iteratorrelations_list = [   (&quot;a&quot;, &quot;c&quot;),   (&quot;a&quot;, &quot;d&quot;),   (&quot;b&quot;, &quot;c&quot;),   (&quot;c&quot;, &quot;d&quot;),   (&quot;d&quot;, &quot;e&quot;)]dag = list_to_dag(relations_list)print([(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)])# [('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]```3. **From *nested dictionary***Construct nodes with attributes, `key`: child name, `value`: dict of parent name, child node attributes.```pythonfrom bigtree import dict_to_dag, dag_iteratorrelation_dict = {   &quot;a&quot;: {&quot;step&quot;: 1},   &quot;b&quot;: {&quot;step&quot;: 1},   &quot;c&quot;: {&quot;parents&quot;: [&quot;a&quot;, &quot;b&quot;], &quot;step&quot;: 2},   &quot;d&quot;: {&quot;parents&quot;: [&quot;a&quot;, &quot;c&quot;], &quot;step&quot;: 2},   &quot;e&quot;: {&quot;parents&quot;: [&quot;d&quot;], &quot;step&quot;: 3},}dag = dict_to_dag(relation_dict, parent_key=&quot;parents&quot;)print([(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)])# [('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]```4. **From *pandas DataFrame***Construct nodes with attributes, *pandas DataFrame* contains child column, parent column, and attribute columns.```pythonimport pandas as pdfrom bigtree import dataframe_to_dag, dag_iteratorpath_data = pd.DataFrame([   [&quot;a&quot;, None, 1],   [&quot;b&quot;, None, 1],   [&quot;c&quot;, &quot;a&quot;, 2],   [&quot;c&quot;, &quot;b&quot;, 2],   [&quot;d&quot;, &quot;a&quot;, 2],   [&quot;d&quot;, &quot;c&quot;, 2],   [&quot;e&quot;, &quot;d&quot;, 3],],   columns=[&quot;child&quot;, &quot;parent&quot;, &quot;step&quot;])dag = dataframe_to_dag(path_data)print([(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)])# [('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]```----## Demo UsageThere are existing implementations of workflows to showcase how `bigtree` can be used!### To Do ApplicationThere are functions to:- Add or remove list to To-Do application- Add or remove item to list, default list is the 'General' list- Prioritize a list/item by reordering them as first list/item- Save and import To-Do application to and from an external JSON file- Show To-Do application, which prints tree to console```pythonfrom bigtree import AppToDoapp = AppToDo(&quot;To Do App&quot;)app.add_item(item_name=&quot;Homework 1&quot;, list_name=&quot;School&quot;)app.add_item(item_name=[&quot;Milk&quot;, &quot;Bread&quot;], list_name=&quot;Groceries&quot;, description=&quot;Urgent&quot;)app.add_item(item_name=&quot;Cook&quot;)app.show()# To Do App# ├── School# │   └── Homework 1# ├── Groceries# │   ├── Milk [description=Urgent]# │   └── Bread [description=Urgent]# └── General#   └── Cookapp.save(&quot;list.json&quot;)app2 = AppToDo.load(&quot;list.json&quot;)```### Calendar ApplicationThere are functions to:- Add or remove event from Calendar- Find event by name, or name and date- Display calendar, which prints events to console- Export calendar to pandas DataFrame```pythonimport datetime as dtfrom bigtree import Calendarcalendar = Calendar(&quot;My Calendar&quot;)calendar.add_event(&quot;Gym&quot;, &quot;2023-01-01 18:00&quot;)calendar.add_event(&quot;Dinner&quot;, &quot;2023-01-01&quot;, date_format=&quot;%Y-%m-%d&quot;, budget=20)calendar.add_event(&quot;Gym&quot;, &quot;2023-01-02 18:00&quot;)calendar.show()# My Calendar# 2023-01-01 00:00:00 - Dinner (budget: 20)# 2023-01-01 18:00:00 - Gym# 2023-01-02 18:00:00 - Gymcalendar.find_event(&quot;Gym&quot;)# 2023-01-01 18:00:00 - Gym# 2023-01-02 18:00:00 - Gymcalendar.delete_event(&quot;Gym&quot;, dt.date(2023, 1, 1))calendar.show()# My Calendar# 2023-01-01 00:00:00 - Dinner (budget: 20)# 2023-01-02 18:00:00 - Gymdata_calendar = calendar.to_dataframe()data_calendar#                              path    name        date      time  budget# 0  /My Calendar/2023/01/01/Dinner  Dinner  2023-01-01  00:00:00    20.0# 1     /My Calendar/2023/01/02/Gym     Gym  2023-01-02  18:00:00     NaN```</longdescription>
</pkgmetadata>