<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>==================pdfrw2 0.5.0==================:Author: Patrick Maupin:Forked Version by Sam Arnold whichfixes many of the bugs from pdfrw 0.4including corrupted PDF forms.https://github.com/sarnold/pdfrw.. contents::    :backlinks: none.. sectnum::Introduction============**pdfrw** is a Python library and utility that reads and writes PDF files:* Version 0.5.0 is tested and works on Python 3.6 - 3.9 across github CI  runners: ubuntu-20.04, macos-latest, windows-latest* Operations include subsetting, merging, rotating, modifying metadata, etc.* The fastest pure Python PDF parser available* Has been used for years by a printer in pre-press production* Can be used with rst2pdf to faithfully reproduce vector images* Can be used either standalone, or in conjunction with `reportlab`__  to reuse existing PDFs in new ones* Permissively licensed__ http://www.reportlab.org/pdfrw will faithfully reproduce vector formats withoutrasterization, so the rst2pdf package has used pdfrwfor PDF and SVG images by default since March 2010.pdfrw can also be used in conjunction with reportlab, in orderto re-use portions of existing PDFs in new PDFs created withreportlab.Examples=========The library comes with several examples that show operation both withand without reportlab.All examples------------------The examples directory has a few scripts which use the library.Note that if these examples do not work with your PDF, you shouldtry to use pdftk to uncompress and/or unencrypt them first.* `4up.py`__ will shrink pages down and place 4 of them on  each output page.* `alter.py`__ shows an example of modifying metadata, without  altering the structure of the PDF.* `booklet.py`__ shows an example of creating a 2-up output  suitable for printing and folding (e.g on tabloid size paper).* `cat.py`__ shows an example of concatenating multiple PDFs together.* `extract.py`__ will extract images and Form XObjects (embedded pages)  from existing PDFs to make them easier to use and refer to from  new PDFs (e.g. with reportlab or rst2pdf).* `poster.py`__ increases the size of a PDF so it can be printed  as a poster.* `print_two.py`__ Allows creation of 8.5 X 5.5&quot; booklets by slicing  8.5 X 11&quot; paper apart after printing.* `rotate.py`__ Rotates all or selected pages in a PDF.* `subset.py`__ Creates a new PDF with only a subset of pages from the  original.* `unspread.py`__ Takes a 2-up PDF, and splits out pages.* `watermark.py`__ Adds a watermark PDF image over or under all the pages  of a PDF.* `rl1/4up.py`__ Another 4up example, using reportlab canvas for output.* `rl1/booklet.py`__ Another booklet example, using reportlab canvas for  output.* `rl1/subset.py`__ Another subsetting example, using reportlab canvas for  output.* `rl1/platypus_pdf_template.py`__ Another watermarking example, using  reportlab canvas and generated output for the document.  Contributed  by user asannes.* `rl2`__ Experimental code for parsing graphics.  Needs work.* `subset_booklets.py`__ shows an example of creating a full printable pdf  version in a more professional and pratical way ( take a look at  http://www.wikihow.com/Bind-a-Book )__ https://github.com/pmaupin/pdfrw/tree/master/examples/4up.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/alter.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/booklet.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/cat.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/extract.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/poster.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/print_two.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/rotate.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/subset.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/unspread.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/watermark.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/4up.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/booklet.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/subset.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/platypus_pdf_template.py__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl2/__ https://github.com/pmaupin/pdfrw/tree/master/examples/subset_booklets.pyNotes on selected examples------------------------------------Reorganizing pages and placing them two-up~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~A printer with a fancy printer and/or a full-up copy of Acrobat caneasily turn your small PDF into a little booklet (for example, print 4letter-sized pages on a single 11&quot; x 17&quot;).But that assumes several things, including that the personnel know howto operate the hardware and software. `booklet.py`__ lets you turn your PDFinto a preformatted booklet, to give them fewer chances to mess it up.__ https://github.com/pmaupin/pdfrw/tree/master/examples/booklet.pyAdding or modifying metadata~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~The `cat.py`__ example will accept multiple input files on the commandline, concatenate them and output them to output.pdf, after adding somenonsensical metadata to the output PDF file.__ https://github.com/pmaupin/pdfrw/tree/master/examples/cat.pyThe `alter.py`__ example alters a single metadata item in a PDF,and writes the result to a new PDF.__ https://github.com/pmaupin/pdfrw/tree/master/examples/alter.pyOne difference is that, since **cat** is creating a new PDF structure,and **alter** is attempting to modify an existing PDF structure, thePDF produced by alter (and also by watermark.py) *should* bemore faithful to the original (except for the desired changes).For example, the alter.py navigation should be left intact, whereas withcat.py it will be stripped.Rotating and doubling~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~If you ever want to print something that is like a small booklet, butneeds to be spiral bound, you either have to do some fancy rearranging,or just waste half your paper.The `print_two.py`__ example program will, for example, make two side-by-sidecopies each page of of your PDF on a each output sheet.__ https://github.com/pmaupin/pdfrw/tree/master/examples/print_two.pyBut, every other page is flipped, so that you can print double-sided andthe pages will line up properly and be pre-collated.Graphics stream parsing proof of concept~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~The `copy.py`__ script shows a simple example of reading in a PDF, andusing the decodegraphics.py module to try to write the same informationout to a new PDF through a reportlab canvas. (If you know about reportlab,you know that if you can faithfully render a PDF to a reportlab canvas, youcan do pretty much anything else with that PDF you want.) This kind oflow level manipulation should be done only if you really need to.decodegraphics is really more than a proof of concept than anythingelse. For most cases, just use the Form XObject capability, as shown inthe examples/rl1/booklet.py demo.__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl2/copy.pypdfrw philosophy==================Core library-------------The philosophy of the library portion of pdfrw is to provide intuitivefunctions to read, manipulate, and write PDF files.  There should beminimal leakage between abstraction layers, although getting usefulwork done makes &quot;pure&quot; functionality separation difficult.A key concept supported by the library is the use of Form XObjects,which allow easy embedding of pieces of one PDF into another.Addition of core support to the library is typically done carefullyand thoughtfully, so as not to clutter it up with too many specialcases.There are a lot of incorrectly formatted PDFs floating around; supportfor these is added in some cases.  The decision is often based on whatacroread and okular do with the PDFs; if they can display them properly,then eventually pdfrw should, too, if it is not too difficult or costly.Contributions are welcome; one user has contributed some decompressionfilters and the ability to process PDF 1.5 stream objects.  Additionalfunctionality that would obviously be useful includes additionaldecompression filters, the ability to process password-protected PDFs,and the ability to output linearized PDFs.Examples--------The philosophy of the examples is to provide small, easily-understoodexamples that showcase pdfrw functionality.PDF files and Python======================Introduction------------In general, PDF files conceptually map quite well to Python. The majorobjects to think about are:-  **strings**. Most things are strings. These also often decompose   naturally into-  **lists of tokens**. Tokens can be combined to create higher-level   objects like-  **arrays** and-  **dictionaries** and-  **Contents streams** (which can be more streams of tokens)Difficulties------------The apparent primary difficulty in mapping PDF files to Python is thePDF file concept of &quot;indirect objects.&quot;  Indirect objects providethe efficiency of allowing a single piece of data to be referred tofrom more than one containing object, but probably more importantly,indirect objects provide a way to get around the chicken and eggproblem of circular object references when mapping arbitrary datastructures to files. To flatten out a circular reference, an indirectobject is *referred to* instead of being *directly included* in anotherobject. PDF files have a global mechanism for locating indirect objects,and they all have two reference numbers (a reference number and a&quot;generation&quot; number, in case you wanted to append to the PDF filerather than just rewriting the whole thing).pdfrw automatically handles indirect references on reading in a PDFfile. When pdfrw encounters an indirect PDF file object, thecorresponding Python object it creates will have an 'indirect' attributewith a value of True. When writing a PDF file, if you have createdarbitrary data, you just need to make sure that circular references arebroken up by putting an attribute named 'indirect' which evaluates toTrue on at least one object in every cycle.Another PDF file concept that doesn't quite map to regular Python is a&quot;stream&quot;. Streams are dictionaries which each have an associatedunformatted data block. pdfrw handles streams by placing a specialattribute on a subclassed dictionary.Usage Model-----------The usage model for pdfrw treats most objects as strings (it takes theirstring representation when writing them to a file). The two mainexceptions are the PdfArray object and the PdfDict object.PdfArray is a subclass of list with two special features.  First,an 'indirect' attribute allows a PdfArray to be written out asan indirect PDF object.  Second, pdfrw reads files lazily, soPdfArray knows about, and resolves references to other indirectobjects on an as-needed basis.PdfDict is a subclass of dict that also has an indirect attributeand lazy reference resolution as well.  (And the subclassedIndirectPdfDict has indirect automatically set True).But PdfDict also has an optional associated stream. The stream objectdefaults to None, but if you assign a stream to the dict, it willautomatically set the PDF /Length attribute for the dictionary.Finally, since PdfDict instances are indexed by PdfName objects (whichalways start with a /) and since most (all?) standard Adobe PdfNameobjects use names formatted like &quot;/CamelCase&quot;, it makes sense to allowaccess to dictionary elements via object attribute accesses as well asobject index accesses. So usage of PdfDict objects is normally viaattribute access, although non-standard names (though still with aleading slash) can be accessed via dictionary index lookup.Reading PDFs~~~~~~~~~~~~~~~The PdfReader object is a subclass of PdfDict, which allows easy accessto an entire document::    &gt;&gt;&gt; from pdfrw import PdfReader    &gt;&gt;&gt; x = PdfReader('source.pdf')    &gt;&gt;&gt; x.keys()    ['/Info', '/Size', '/Root']    &gt;&gt;&gt; x.Info    {'/Producer': '(cairo 1.8.6 (http://cairographics.org))',     '/Creator': '(cairo 1.8.6 (http://cairographics.org))'}    &gt;&gt;&gt; x.Root.keys()    ['/Type', '/Pages']Info, Size, and Root are retrieved from the trailer of the PDF file.In addition to the tree structure, pdfrw creates a special attributenamed *pages*, that is a list of all the pages in the document. pdfrwcreates the *pages* attribute as a simplification for the user, becausethe PDF format allows arbitrarily complicated nested dictionaries todescribe the page order. Each entry in the *pages* list is the PdfDictobject for one of the pages in the file, in order.::    &gt;&gt;&gt; len(x.pages)    1    &gt;&gt;&gt; x.pages[0]    {'/Parent': {'/Kids': [{...}], '/Type': '/Pages', '/Count': '1'},     '/Contents': {'/Length': '11260', '/Filter': None},     '/Resources': ... (Lots more stuff snipped)    &gt;&gt;&gt; x.pages[0].Contents    {'/Length': '11260', '/Filter': None}    &gt;&gt;&gt; x.pages[0].Contents.stream    'q\n1 1 1 rg /a0 gs\n0 0 0 RG 0.657436      w\n0 J\n0 j\n[] 0.0 d\n4 M q' ... (Lots more stuff snipped)Writing PDFs~~~~~~~~~~~~~~~As you can see, it is quite easy to dig down into a PDF document. Butwhat about when it's time to write it out?::    &gt;&gt;&gt; from pdfrw import PdfWriter    &gt;&gt;&gt; y = PdfWriter()    &gt;&gt;&gt; y.addpage(x.pages[0])    &gt;&gt;&gt; y.write('result.pdf')That's all it takes to create a new PDF. You may still need to read the`Adobe PDF reference manual`__ to figure out what needs to go *into*the PDF, but at least you don't have to sweat actually building itand getting the file offsets right.__ http://www.adobe.com/devnet/acrobat/pdfs/pdf_reference_1-7.pdfManipulating PDFs in memory~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~For the most part, pdfrw tries to be agnostic about the contents ofPDF files, and support them as containers, but to do useful work,something a little higher-level is required, so pdfrw works tounderstand a bit about the contents of the containers.  For example:-  PDF pages. pdfrw knows enough to find the pages in PDF files you read   in, and to write a set of pages back out to a new PDF file.-  Form XObjects. pdfrw can take any page or rectangle on a page, and   convert it to a Form XObject, suitable for use inside another PDF   file.  It knows enough about these to perform scaling, rotation,   and positioning.-  reportlab objects. pdfrw can recursively create a set of reportlab   objects from its internal object format. This allows, for example,   Form XObjects to be used inside reportlab, so that you can reuse   content from an existing PDF file when building a new PDF with   reportlab.There are several examples that demonstrate these features inthe example code directory.Missing features~~~~~~~~~~~~~~~~~~~~~~~Even as a pure PDF container library, pdfrw comes up a bit short. Itdoes not currently support:-  Most compression/decompression filters-  encryption`pdftk`__ is a wonderful command-linetool that can convert your PDFs to remove encryption and compression.However, in most cases, you can do a lot of useful work with PDFswithout actually removing compression, because only certain elementsinside PDFs are actually compressed.__ https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/Library internals==================Introduction------------**pdfrw** currently consists of 19 modules organized into a mainpackage and one sub-package.The `__init.py__`__ module does the usual thing of importing a fewmajor attributes from some of the submodules, and the `errors.py`__module supports logging and exception generation.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/__init__.py__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/errors.pyPDF object model support--------------------------The `objects`__ sub-package contains one module for each of theinternal representations of the kinds of basic objects that existin a PDF file, with the `objects/__init__.py`__ module in thatpackage simply gathering them up and making them available to themain pdfrw package.One feature that all the PDF object classes have in common is theinclusion of an 'indirect' attribute. If 'indirect' exists and evaluatesto True, then when the object is written out, it is written out as anindirect object. That is to say, it is addressable in the PDF file, andcould be referenced by any number (including zero) of container objects.This indirect object capability saves space in PDF files by allowingobjects such as fonts to be referenced from multiple pages, and alsoallows PDF files to contain internal circular references.  This lattercapability is used, for example, when each page object has a &quot;parent&quot;object in its dictionary.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/__init__.pyOrdinary objects~~~~~~~~~~~~~~~~The `objects/pdfobject.py`__ module contains the PdfObject class, which isa subclass of str, and is the catch-all object for any PDF file elementsthat are not explicitly represented by other objects, as described below.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfobject.pyName objects~~~~~~~~~~~~The `objects/pdfname.py`__ module contains the PdfName singleton object,which will convert a string into a PDF name by prepending a slash. It canbe used either by calling it or getting an attribute, e.g.::    PdfName.Rotate == PdfName('Rotate') == PdfObject('/Rotate')In the example above, there is a slight difference between the objectsreturned from PdfName, and the object returned from PdfObject.  ThePdfName objects are actually objects of class &quot;BasePdfName&quot;.  Thisis important, because only these may be used as keys in PdfDict objects.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfname.pyString objects~~~~~~~~~~~~~~The `objects/pdfstring.py`__module contains the PdfString class, which is a subclass of str that isused to represent encoded strings in a PDF file. The class has encodeand decode methods for the strings.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfstring.pyArray objects~~~~~~~~~~~~~The `objects/pdfarray.py`__module contains the PdfArray class, which is a subclass of list that isused to represent arrays in a PDF file. A regular list could be usedinstead, but use of the PdfArray class allows for an indirect attributeto be set, and also allows for proxying of unresolved indirect objects(that haven't been read in yet) in a manner that is transparent to pdfrwclients.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfarray.pyDict objects~~~~~~~~~~~~The `objects/pdfdict.py`__module contains the PdfDict class, which is a subclass of dict that isused to represent dictionaries in a PDF file. A regular dict could beused instead, but the PdfDict class matches the requirements of PDFfiles more closely:* Transparent (from the library client's viewpoint) proxying  of unresolved indirect objects* Return of None for non-existent keys (like dict.get)* Mapping of attribute accesses to the dict itself  (pdfdict.Foo == pdfdict[NameObject('Foo')])* Automatic management of following stream and /Length attributes  for content dictionaries* Indirect attribute* Other attributes may be set for private internal use of the  library and/or its clients.* Support for searching parent dictionaries for PDF &quot;inheritable&quot;  attributes.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfdict.pyIf a PdfDict has an associated data stream in the PDF file, the streamis accessed via the 'stream' (all lower-case) attribute.  Setting thestream attribute on the PdfDict will automatically set the /Length attributeas well.  If that is not what is desired (for example if the the streamis compressed), then _stream (same name with an underscore) may be usedto associate the stream with the PdfDict without setting the length.To set private attributes (that will not be written out to a new PDFfile) on a dictionary, use the 'private' attribute::    mydict.private.foo = 1Once the attribute is set, it may be accessed directly as an attributeof the dictionary::    foo = mydict.fooSome attributes of PDF pages are &quot;inheritable.&quot;  That is, they maybelong to a parent dictionary (or a parent of a parent dictionary, etc.)The &quot;inheritable&quot; attribute allows for easy discovery of these::    mediabox = mypage.inheritable.MediaBoxProxy objects~~~~~~~~~~~~~The `objects/pdfindirect.py`__module contains the PdfIndirect class, which is a non-transparent proxyobject for PDF objects that have not yet been read in and resolved froma file. Although these are non-transparent inside the library, client codeshould never see one of these -- they exist inside the PdfArray and PdfDictcontainer types, but are resolved before being returned to a client ofthose types.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfindirect.pyFile reading, tokenization and parsing--------------------------------------`pdfreader.py`__contains the PdfReader class, which can read a PDF file (or be passed afile object or already read string) and parse it. It uses the PdfTokensclass in `tokens.py`__  for low-level tokenization.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/pdfreader.py__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/tokens.pyThe PdfReader class does not, in general, parse into containers (e.g.inside the content streams). There is a proof of concept for doing thatinside the examples/rl2 subdirectory, but that is slow and not well-developed,and not useful for most applications.An instance of the PdfReader class is an instance of a PdfDict -- thetrailer dictionary of the PDF file, to be exact.  It will have a privateattribute set on it that is named 'pages' that is a list containing allthe pages in the file.When instantiating a PdfReader object, there are options availablefor decompressing all the objects in the file.  pdfrw does not currentlyhave very many options for decompression, so this is not all that useful,except in the specific case of compressed object streams.Also, there are no options for decryption yet.  If you have PDF filesthat are encrypted or heavily compressed, you may find that using anotherprogram like pdftk on them can make them readable by pdfrw.In general, the objects are read from the file lazily, but this is notcurrently true with compressed object streams -- all of these are decompressedand read in when the PdfReader is instantiated.File output-----------`pdfwriter.py`__contains the PdfWriter class, which can create and output a PDF file.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/pdfwriter.pyThere are a few options available when creating and using this class.In the simplest case, an instance of PdfWriter is instantiated, andthen pages are added to it from one or more source files (or createdprogrammatically), and then the write method is called to dump theresults out to a file.If you have a source PDF and do not want to disturb the structureof it too badly, then you may pass its trailer directly to PdfWriterrather than letting PdfWriter construct one for you.  There is anexample of this (alter.py) in the examples directory.Advanced features-----------------`buildxobj.py`__contains functions to build Form XObjects out of pages or rectangles onpages.  These may be reused in new PDFs essentially as if they were images.buildxobj is careful to cache any page used so that it only appears inthe output once.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/buildxobj.py`toreportlab.py`__provides the makerl function, which will translate pdfrw objects into aformat which can be used with `reportlab &lt;http://www.reportlab.org/&gt;`__.It is normally used in conjunction with buildxobj, to be able to reuseparts of existing PDFs when using reportlab.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/toreportlab.py`pagemerge.py`__ builds on the foundation laid by buildxobj.  Itcontains classes to create a new page (or overlay an existing page)using one or more rectangles from other pages.  There are examplesshowing its use for watermarking, scaling, 4-up output, splittingeach page in 2, etc.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/pagemerge.py`findobjs.py`__ contains code that can find specific kinds of objectsinside a PDF file.  The extract.py example uses this module to createa new PDF that places each image and Form XObject from a source PDF ontoits own page, e.g. for easy reuse with some of the other examples orwith reportlab.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/findobjs.pyMiscellaneous----------------`compress.py`__ and `uncompress.py`__contains compression and decompression functions. Very few filters arecurrently supported, so an external tool like pdftk might be good if yourequire the ability to decompress (or, for that matter, decrypt) PDFfiles.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/compress.py__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/uncompress.py`py23_diffs.py`__ contains code to help manage the differences betweenPython 2 and Python 3.__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/py23_diffs.pyTesting===============The tests associated with pdfrw require a large number of PDFs,which are not distributed with the library.To run the tests:* Clone the full package from github with ``--recursive``* Install the tox test drivers from OS pkgs or pip in a venv* Run the tests with tox using default system python version.. code-block:: bash   $ &lt;apt|yum|emerge|pip&gt; install tox tox-xdist   $ git clone --recursive https://github.com/sarnold/pdfrw.git   $ cd pdfrw   $ tox -e pyTo run a single test-case:.. code-block:: bash   $ pytest test_roundtrip.py -k &quot;test_compress_9f98322c243fe67726d56ccfa8e0885b.pdf&quot;Other libraries=====================Pure Python------------  `reportlab &lt;http://www.reportlab.org/&gt;`__    reportlab is must-have software if you want to programmatically    generate arbitrary PDFs.-  `PyFPDF &lt;https://github.com/reingart/pyfpdf&gt;`__    PyPDF is, in some ways, very full-featured. It can do decompression    and decryption and seems to know a lot about items inside at least    some kinds of PDF files. In comparison, pdfrw knows less about    specific PDF file features (such as metadata), but focuses on trying    to have a more Pythonic API for mapping the PDF file container    syntax to Python, and (IMO) has a simpler and better PDF file    parser.  The Form XObject capability of pdfrw means that, in many    cases, it does not actually need to decompress objects -- they    can be left compressed.    PyPDF is not maintained anymore, but it has a successors:    `PyFPDF2 &lt;https://github.com/mstamy2/PyPDF2&gt;`__    and `fpdf2 &lt;https://github.com/PyPDF/fpdf2&gt;`__.-  `pdftools &lt;http://www.boddie.org.uk/david/Projects/Python/pdftools/index.html&gt;`__    pdftools feels large and I fell asleep trying to figure out how it    all fit together, but many others have done useful things with it.-  `pagecatcher &lt;http://www.reportlab.com/docs/pagecatcher-ds.pdf&gt;`__    My understanding is that pagecatcher would have done exactly what I    wanted when I built pdfrw. But I was on a zero budget, so I've never    had the pleasure of experiencing pagecatcher. I do, however, use and    like `reportlab &lt;http://www.reportlab.org/&gt;`__ (open source, from    the people who make pagecatcher) so I'm sure pagecatcher is great,    better documented and much more full-featured than pdfrw.-  `pdfminer &lt;http://www.unixuser.org/~euske/python/pdfminer/index.html&gt;`__    This looks like a useful, actively-developed program. It is quite    large, but then, it is trying to actively comprehend a full PDF    document. From the website:    &quot;PDFMiner is a suite of programs that help extracting and analyzing    text data of PDF documents. Unlike other PDF-related tools, it    allows to obtain the exact location of texts in a page, as well as    other extra information such as font information or ruled lines. It    includes a PDF converter that can transform PDF files into other    text formats (such as HTML). It has an extensible PDF parser that    can be used for other purposes instead of text analysis.&quot;-  `WeasyPrint &lt;https://github.com/Kozea/WeasyPrint&gt;`__    WeasyPrint is a visual rendering engine for HTML and CSS that can export to PDF.    It aims to support web standards for printing.    It is based on various libraries but not on a full rendering engine like WebKit or Gecko.    The CSS layout engine is written in Python, designed for pagination,    and meant to be easy to hack on.non-pure-Python libraries--------------------------  `pikepdf &lt;https://github.com/pikepdf/pikepdf&gt;`__ read and write PDF files,    based on C++ lib QPDF.-  `pyPoppler &lt;https://launchpad.net/poppler-python/&gt;`__ can read PDF   files.-  `pycairo &lt;http://www.cairographics.org/pycairo/&gt;`__ can write PDF   files.-  `PyMuPDF &lt;https://github.com/rk700/PyMuPDF&gt;`_ high performance rendering   of PDF, (Open)XPS, CBZ and EPUBOther tools------------  `pdftk &lt;https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/&gt;`__ is a wonderful command   line tool for basic PDF manipulation. It complements pdfrw extremely   well, supporting many operations such as decryption and decompression   that pdfrw cannot do.-  `MuPDF &lt;http://www.mupdf.com/&gt;`_ is a free top performance PDF, (Open)XPS, CBZ and EPUB rendering library   that also comes with some command line tools. One of those, ``mutool``, has big overlaps with pdftk's -    except it is up to 10 times faster.Release information=======================Revisions:0.4 -- Released 18 September, 2017    - Python 3.6 added to test matrix    - Proper unicode support for text strings in PDFs added    - buildxobj fixes allow better support creating form XObjects      out of compressed pages in some cases    - Compression fixes for Python 3+    - New subset_booklets.py example    - Bug with non-compressed indices into compressed object streams fixed    - Bug with distinguishing compressed object stream first objects fixed    - Better error reporting added for some invalid PDFs (e.g. when reading      past the end of file)    - Better scrubbing of old bookmark information when writing PDFs, to      remove dangling references    - Refactoring of pdfwriter, including updating API, to allow future      enhancements for things like incremental writing    - Minor tokenizer speedup    - Some flate decompressor bugs fixed    - Compression and decompression tests added    - Tests for new unicode handling added    - PdfReader.readpages() recursion error (issue #92) fixed.    - Initial crypt filter support added0.3 -- Released 19 October, 2016.    - Python 3.5 added to test matrix    - Better support under Python 3.x for in-memory PDF file-like objects    - Some pagemerge and Unicode patches added    - Changes to logging allow better coexistence with other packages    - Fix for &quot;from pdfrw import \*&quot;    - New fancy_watermark.py example shows off capabilities of pagemerge.py    - metadata.py example renamed to cat.py0.2 -- Released 21 June, 2015.  Supports Python 2.6, 2.7, 3.3, and 3.4.    - Several bugs have been fixed    - New regression test functionally tests core with dozens of      PDFs, and also tests examples.    - Core has been ported and tested on Python3 by round-tripping      several difficult files and observing binary matching results      across the different Python versions.    - Still only minimal support for compression and no support      for encryption or newer PDF features.  (pdftk is useful      to put PDFs in a form that pdfrw can use.)0.1 -- Released to PyPI in 2012.  Supports Python 2.5 - 2.7</longdescription>
</pkgmetadata>