<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Summary`agency` is a python library that provides a communication and action frameworkfor creating AI agent integrated applications.The library provides a low-level means for connecting agents, systems, and humanusers by defining actions, callbacks, and access policies that you can use toconnect, monitor, control, and interact with your agents.`agency` handles the details of the common messaging system and allowsdiscovering and invoking actions across parties, automatically handling thingssuch as reporting exceptions, enforcing access restrictions, and more.## Features### Low-Level API Flexibility  * Straightforward class/method based agent and action definition  * Supports defining single process applications or networked agent systems  using AMQP### Observability and Control  * Before/after action and lifecycle callbacks for observability or other needs  * Access policies and permission callbacks for access control### Performance  * Multithreaded (though python's GIL is a bottleneck for single process apps)  * AMQP support for multiprocess and networked systems (avoids GIL)  * [_Python multiprocess support is planned for better scalability on    single-host systems_](https://github.com/operand/agency/issues/33)### Multimodal (image/audio) support  * [_Not yet developed, but is planned_](https://github.com/operand/agency/issues/27)### Full demo available at [`examples/demo`](./examples/demo/)  * Two OpenAI agent examples  * HuggingFace transformers agent example  * Simple Flask/React web interface included  * Operating system access for agents  * Docker configuration for reference and development# API Overview`agency` is an implementation of the [Actormodel](https://en.wikipedia.org/wiki/Actor_model) for building AI agentintegrated systems.In `agency`, all entities are represented as instances of the `Agent` class.This includes all humans, software, and AI-driven agents that may communicate aspart of your application.All agents may expose &quot;actions&quot; that other agents can discover and invoke at runtime. An example of a simple agent implemention could be:```pythonclass CalculatorAgent(Agent):  def _action__add(a, b):    return a + b```This defines an agent with a single action: `&quot;add&quot;`. Other agents will be ableto call this method by sending a message to an instance of `CalculatorAgent` andspecifying the `&quot;add&quot;` action.```pythonother_agent._send({  'to': 'CalcAgent',  'thoughts': 'Optionally explain here',  'action': 'add',  'args': {    'a': 1,    'b': 2,  },})```Actions must also specify an access policy, allowing you to control access forsafety. For example:```python  @access_policy(ACCESS_PERMITTED) # This allows the action at any time  def _action__add(a, b):    ...```You can also define callbacks for various purposes:```pythonclass CalculatorAgent(Agent):  ...  def _before_action(self, original_message: dict):    # Called before any action is attempted  def _after_action(self, original_message: dict, return_value: str, error: str):    # Called after any action is attempted  def _after_add(self):    # Called after the agent is added to the space and may begin communicating  def _before_remove(self):    # Called before the agent is removed from the space  def _request_permission(self, proposed_message: dict) -&gt; bool:    # Called before an ACCESS_REQUESTED action is attempted for run-time review```A `Space` is how you connect your agents together. An agent cannot communicatewith others until it is added to a common `Space`.There are two included `Space` implementations to choose from:* `NativeSpace` - which connects agents within the same python process* `AMQPSpace` - which connects agents across processes and systems using an AMQP  server like RabbitMQ.Here is an example of creating a `NativeSpace` and adding two agents to it.```pythonspace = NativeSpace()space.add(CalculatorAgent(&quot;CalcAgent&quot;))space.add(AIAgent(&quot;AIAgent&quot;))# The agents above can now communicate```These are just some of the main `agency` features. For more detailed informationplease see [the docs directory](./docs/).# Install```shpip install agency```or```shpoetry add agency```# Running the Demo ApplicationTo run the demo, please follow the directions at[examples/demo](./examples/demo/). After a short boot time you can visit theweb app at `http://localhost:8080` and you should see a simple chat interface.The following is a screenshot of the web UI that demonstrates the multiple demoagents intelligently interacting and following orders.There are two OpenAI based agents: `&quot;FunctionAI&quot;` and `&quot;CompletionAI&quot;`, namedfor the API's they use, and `&quot;Chatty&quot;` a simple chat agent who uses a smalllocal transformers based model for demonstration.The screenshot also demonstrates the results of rejecting an action anddirecting an agent to use a different approach in real time. After I explainedmy rejection of the `read_file` action (which happened behind the scenes on theterminal), `&quot;FunctionAI&quot;` appropriately used the `shell_command` action with `wc-l Dockerfile`.&lt;p align=&quot;center&quot;&gt;  &lt;img src=&quot;https://i.ibb.co/nbvLJvg/Screenshot-2023-06-14-at-3-59-01-AM.png&quot;       alt=&quot;Screenshot-2023-06-14-at-3-59-01-AM&quot; border=&quot;0&quot; width=500&gt;&lt;/p&gt;# FAQ## How does `agency` compare to agent libraries like LangChain?Though you could entirely create a simple agent using only the primitives in`agency` (see [`examples/demo/agents/`](./examples/demo/agents/)), it is notintended to be a full-fledged agent toolset like other libraries or tools.`agency` is focused on the problems surrounding agent/tool/human integration,such as communication, observability, and access control. The library strives toprovide a minimal yet practical foundation for defining and integrating agentsystems, allowing developers the freedom to experiment with different agentsolutions as they desire.More likely, you would use LangChain or other libraries for defining agentspecific behavior and rely on `agency` to provide the connective layer forbringing agents and other systems together.## What are some known limitations or issues?* It's a new project, so keep that in mind in terms of  completeness, but see [the issues  page](https://github.com/operand/agency/issues) for what is currently planned,  and the [Roadmap](#roadmap) below for the high level plan.* This library makes use of threads for each individual agent. Multithreading  is limited by [python's  GIL](https://wiki.python.org/moin/GlobalInterpreterLock), meaning that if you  run a local model or other heavy computation in the same process as other  agents, they may have to wait for their &quot;turn&quot;. Note that I/O does not block,  so networked backends or services will execute in parallel.    For blocking processes, it's recommended to use the `AMQPSpace` class and run  heavy computations in isolation to avoid blocking other agents.* This API does not assume or enforce predefined roles like &quot;user&quot;, &quot;system&quot;,  &quot;assistant&quot;, etc. This is an intentional decision and is not likely to change.  `agency` is intended to allow potentially large numbers of agents, systems,  and people to come together. A small predefined set of roles gets in the way  of representing many things generally. This is a core feature of `agency`:  that all entities are treated the same and may be interacted with through  common means.  The lack of roles may require extra translation code when integrating with  role based APIs. See the implementation of  [`OpenAIFunctionAgent`](./examples/demo/agents/openai_function_agent.py) for  an example.* There is currently not much by way of storage support. That is mostly left up  to you and I'd suggest looking at the many technologies that focus on that.  The `Agent` class implements a simple `_message_log` array which you can make  use of or overwrite to back it with longer term storage. More direct support  for storage APIs will likely be considered in the future.  # ContributingPlease do!## Development Installation```bashgit clone git@github.com:operand/agency.gitcd agencypoetry install```## Developing with the Demo ApplicationSee [the demo directory](./examples/demo/) for instructions on how to run thedemo.The demo application is written to showcase both native and AMQP spaces andseveral agent examples. It can also be used for experimentation and development.The application is configured to read the agency library source when running,allowing changes to be tested manually.## Test SuiteEnsure you have Docker installed. A small RabbitMQ container will beautomatically created.You can run the test suite with:```bashpoetry run pytest```# Roadmap- **Multiprocess Support**:An additional space type utilizing python multiprocessing, as anotherparallelism option for single-host systems.- **Multimodal Support**:Image/audio transfer for use with multimodal models or other multimediaservices.- **More Examples**:More examples of integrations with popular AI libraries and tools such asLangchain and oobabooga.## Planned Work[Please see the issues page.](https://github.com/operand/agency/issues)If you have any suggestions or otherwise, feel free to add an issue!</longdescription>
</pkgmetadata>