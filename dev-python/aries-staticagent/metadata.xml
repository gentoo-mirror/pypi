<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Static Agent Library====================This repo contains an example Aries Static Agent Library in Python.A static agent is a form of agent that can speak DIDComm at a basic level but its keys andconnections are configured statically. Static Agents have a direct relationship with a single fullagent. Static Agents do not have a wallet.Examples of static agents may include:- Remote administration interface for an agent- IoT devices- [Relays][1]- OpenAPI to DIDComm translatorA static agent's configuration minimally consists of:- Its own public and private key- The public key of its full agent counterpart- The endpoint of its full agent counterpart_**It is up to you to secure your static agent's configuration.**_ The examples included in thisrepository use command line arguments or environment variables to configure the agent for simplicityand demonstration purposes only. _**This is not recommended for production environments.**_This library makes as few assumptions about it's running environment as possible. This includesfew dependencies, assumptions about web frameworks, etc.[1]: https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0046-mediators-and-relays#summaryQuick Start Guide-----------------#### Requirements- Python 3.6 or higher#### Running the included examplesYou will need to pair the static agent with a full agent capable of basic DIDComm to complete theexamples. The [Indy Python Reference Agent][3] can be used as the full agent for these examples.Create and activate python virtual environment:```sh$ python3 -m venv env$ source env/bin/activate```Install dependencies and the library into the virtual environment:```sh$ pip install -e .```&gt; If you want to run the included tests, install the `test` feature with pip:&gt; `pip install -e .[test]`Execute `keygen()`:```sh$ python -c &quot;import aries_staticagent; aries_staticagent.keygen()&quot;For full agent:        DID: &lt;Base58 encoded DID&gt;        VK: &lt;Base58 encoded verkey&gt;For static agent:        VK: &lt;the same Base58 encoded verkey&gt;        SK: &lt;Base58 encoded sigkey&gt;```As the output implies, the first section is intended to be entered in on the full agent to configurea static connection. The second section is used to configure the static agent. The `verkey` (VK) inthe first and second section are the _same_ key, representing the key the static agent will usefor the connection. The `keygen` script does _not_ generate the keys that the full agent will use.If using the [Indy Python Reference Agent][3], open the web interface andclick `Add Static Connection`. Enter the information output by `keygen.py` and a label of yourchoice. The endpoint of the static agent is optional and must match the hostname and port youconfigure for the static agent if running the web server example. After clicking `Add`, a newdialogue window will open with the information needed to now start up the static agent.If you are using another agent that supports configuring a static connection, follow theinstructions provided by that agent.Start the static agent (in this case, `exapmles/cron.py`):```sh$ python examples/cron.py --endpoint &lt;the endpoint of the full agent&gt; \$ --endpointkey &lt;the verkey output by the full agent&gt; \$ --mypublickey &lt;the verkey output by keygen.py&gt; \$ --myprivatekey &lt;the sigkey output by keygen.py&gt;```In the full agent's BasicMessages, you should now see a message sent from the static agent script.&gt; TODO: Include screencast of running the example with the Indy Python Reference Agent[2]: https://download.libsodium.org/doc/installation[3]: https://github.com/hyperledger/indy-agent/tree/master/pythonUsing the library-----------------Refer to the `examples` directory for complete working examples of using this library.### Setting up a Static Agent Connection```pythonfrom aries_staticagent import StaticConnection# endpoint, endpointkey, mypublickey, myprivatekey key are obtained through some form of static# configurationconn = StaticConnection((mypublickey, myprivatekey), their_vk=endpointkey, endpoint=endpoint)```This will open a static connection with the full agent reachable at `endpoint` and messages packedfor `endpointkey`.### Sending a message to the Full AgentWith the static agent connection `a`, to send messages to the full agent:```pythonconn.send({    &quot;@type&quot;: &quot;https://didcomm.org/basicmessage/1.0/message&quot;,    &quot;~l10n&quot;: {&quot;locale&quot;: &quot;en&quot;},    &quot;sent_time&quot;: utils.timestamp(),    &quot;content&quot;: &quot;The Cron Script has been executed.&quot;})```An asynchronous method is also provided:```pythonawait conn.send_async({    &quot;@type&quot;: &quot;https://didcomm.org/basicmessage/1.0/message&quot;,    &quot;~l10n&quot;: {&quot;locale&quot;: &quot;en&quot;},    &quot;sent_time&quot;: utils.timestamp(),    &quot;content&quot;: &quot;The Cron Script has been executed.&quot;})```### Receiving messages from the Full AgentTransport mechanisms are completely decoupled from the Static Agent Library. This is intended toallow library consumers to choose which transport is appropriate for their use case. The`examples/webserver_aiohttp.py` example shows how one might use the `aiohttp` library as an inboundtransport mechanism for the static agent:```pythonfrom aiohttp import webfrom aries_staticagent import StaticConnection, utils# ... Configuration omitted# Create static agent connectionconn = StaticConnection((args.mypublickey, args.myprivatekey), their_vk=args.endpointkey, endpoint=args.endpoint)# Register a handler for the basicmessage/1.0/message message type@conn.route(&quot;https://didcomm.org/basicmessage/1.0/message&quot;)async def basic_message(msg, conn):    # Respond to the received basic message by sending another basic message back    await conn.send_async({        &quot;@type&quot;: &quot;https://didcomm.org/basicmessage/1.0/message&quot;,        &quot;~l10n&quot;: {&quot;locale&quot;: &quot;en&quot;},        &quot;sent_time&quot;: utils.timestamp(),        &quot;content&quot;: &quot;You said: {}&quot;.format(msg['content'])    })# aiohttp request handlerasync def handle(request):    # Read request body and pass to StaticConnection.handle    await conn.handle(await request.read())    raise web.HTTPAccepted()# Register aiohttp request handlerapp = web.Application()app.add_routes([web.post('/', handle)])# Start the web serverweb.run_app(app, port=args.port)```As seen in this example, registering a handler for a DIDComm message is done using the`@conn.route('&lt;message_type&gt;')` decorator. Passing raw, unpackaged messages to the static agentconnection over the decoupled transport mechanism is done by calling `conn.handle(&lt;raw message&gt;)`.Static agents can only unpack messages sent by the full agent.### Unresolved Questions* Are we allowing Agent routing between a static agent and it's full agent?  * We're starting with no and will revisit in the future.</longdescription>
</pkgmetadata>