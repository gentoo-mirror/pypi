<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Lobotomy[![PyPI version](https://badge.fury.io/py/lobotomy.svg)](https://pypi.org/project/lobotomy/)[![build status](https://gitlab.com/rocket-boosters/lobotomy/badges/main/pipeline.svg)](https://gitlab.com/rocket-boosters/lobotomy/commits/main)[![coverage report](https://gitlab.com/rocket-boosters/lobotomy/badges/main/coverage.svg)](https://gitlab.com/rocket-boosters/lobotomy/commits/main)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![Code style: flake8](https://img.shields.io/badge/code%20style-flake8-white)](https://gitlab.com/pycqa/flake8)[![Code style: mypy](https://img.shields.io/badge/code%20style-mypy-white)](http://mypy-lang.org/)[![Code style: pydocstyle](https://img.shields.io/badge/code%20style-pydocstyle-white)](http://www.pydocstyle.org/en/stable/)[![Code style: radon](https://img.shields.io/badge/code%20style-radon-white)](https://radon.readthedocs.io/en/latest/)[![PyPI - License](https://img.shields.io/pypi/l/lobotomy)](https://pypi.org/project/lobotomy/)- [Installation](#installation)- [Tl;dr Usage](#tldr-usage)- [Usage](#usage)    - [Configuration Files](#configuration-files)    - [Test Patching](#test-patching)    - [YAML IO Modifiers](#yaml-io-modifiers)      - [!lobotomy.to_json](#to_json)      - [!lobotomy.inject_string](#inject_string)    - [Special Cases](#special-cases)      - [s3.download_fileobj](#s3download_fileobj)    - [Command Line Interface](#command-line-interface)- [Advanced Usage](#advanced-usage)    - [Key Prefixes](#key-prefixes)    - [Patching Targets](#patching-targets)    - [Session Configuration](#session-configuration)    - [Client Overrides](#client-overrides)    - [Error Handling](#error-handling)    - [Callable Responses](#callable-responses)The *lo&amp;#8226;**boto**&amp;#8226;my* library allows one to mock the low-level boto3client libraries efficiently, especially in more complex scenario testing situations, using configuration-based response definitions. The benefit is aseparation of the configuration from the test execution, which cleans up thetest invocation process.## Installationlobotomy is available on pypi and installable via pip:```shell script$ pip install lobotomy```or via poetry as a development dependency in a project:```shell script$ poetry add lobotomy -D```## Tl;dr UsageCreate a configuration file in YAML, TOML, or JSON format with a root *clients*key. Beneath that key add the desired client calls mocked responses by serviceas shown here for a `session.client('s3').get_object()` mocked response:```yamlclients:  s3:    get_object:      Body: 'The contents of my S3 file.'      LastModified: '2020-12-01T01:02:03Z'```Then in the test notice that the lobotomy patching process handles therest, including casting the configuration values specified in the callabove into the more complex data types returned for the specific call.```pythonimport lobotomyimport pathlibimport boto3import datetimemy_directory = pathlib.Path(__file__).parent@lobotomy.patch(my_directory.joinpath(&quot;test_lobotomy.yaml&quot;))def test_lobotomy(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;    Should return the mocked get_object response generated from the    configuration data specified in the lobotomy patch above. By default    the patch(...) applies to the boto3.Session object, so calling     boto3.Session() will create a lobotomy.Session instead of a normal    boto3.Session. From there the low-level client interface is designed    to match normal usage.    &quot;&quot;&quot;    s3_client = boto3.Session().client(&quot;s3&quot;)        # Lobotomy will validate that you have specified the required keys    # in your request, so Bucket and Key have to be supplied here even though    # they are not meaningful values in this particular test scenario.    response = s3_client.get_object(Bucket=&quot;foo&quot;, Key=&quot;bar&quot;)    expected = b&quot;The contents of my S3 file.&quot;    assert response[&quot;Body&quot;].read() == expected, &quot;&quot;&quot;        Expected the mocked response body data to be returned as a        StreamingBody object with blob/bytes contents. The lobotomy        library introspects boto to properly convert the string body        value in the configuration file into the expected return format        for the particular call.        &quot;&quot;&quot;        expected = datetime.datetime(2020, 12, 1, 1, 2, 3, 0, datetime.timezone.utc)    assert response[&quot;LastModified&quot;] == expected, &quot;&quot;&quot;        Expected the mocked response last modified value to be a timezone-aware        datetime value generated from the string timestamp value in the        configuration file to match how it would be returned by boto in        an actual response.        &quot;&quot;&quot;    call = lobotomized.get_service_call(&quot;s3&quot;, &quot;get_object&quot;)    assert call.request[&quot;Bucket&quot;] == &quot;foo&quot;, &quot;&quot;&quot;        Expected the s3.get_object method call arguments to have specified the bucket        as &quot;foo&quot;.        &quot;&quot;&quot;    assert call.request[&quot;Key&quot;] == &quot;bar&quot;, &quot;&quot;&quot;        Expected the s3.get_object method call argumets to have specified the key as        &quot;bar&quot;.        &quot;&quot;&quot;```# Usage## Configuration FilesTest scenarios can be written in YAML, TOML, or JSON formats. YAML or TOML arerecommended unless copying output responses from JSON calls is easier for agiven use-case. In the following example, we'll define the calls using YAML:```yamlclients:  sts:    get_caller_identity:      Account: '987654321'  s3:    get_object:      Body: 'The contents of my S3 file.'      LastModified: '2020-11-01T12:23:34Z'```All call responses are stored within the root *clients* attribute with servicenames as sub-attributes and then the service method call responses defined beneath the service name attributes. Multiple services and multiple methodsper service are specified in this way by the hierarchical key lists.If the contents of a method response definition are not a list, the sameresponse will be returned for each call to that client method during thetest. Specifying a list of responses will alter the behavior such that eachsuccessive call will iterate through that list of configured responses.```yamlclients:  s3:    get_object:    - Body: 'The contents of my S3 file.'      LastModified: '2020-11-01T12:23:34Z'    - Body: 'Another S3 file.'      LastModified: '2020-11-03T12:23:34Z'```The lobotomy library dynamically inspects boto for its response structureand data types, such that they match the types for the normal boto responsefor each client method call. In the case of the`session.client('s3').get_object()` calls above, the `Body` would returna `StreamingBody` object with the string converted to bytes to match thenormal output. Similarly, the `LastModified` would be converted to atimezone-aware datetime object by lobotomy as well. This makes it easyto specify primitive data types in the configuration file that are transformedinto their more complex counterparts when returned within the execution ofthe actual code.## Test PatchingOnce the configuration file has been specified, it is used within a testvia a `lobotomy.patch` as shown below.```pythonimport lobotomyimport pathlibimport boto3import datetimemy_directory = pathlib.Path(__file__).parent@lobotomy.patch(my_directory.joinpath(&quot;test_lobotomy.yaml&quot;))def test_lobotomy(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;    Should return the mocked get_object response generated from the    configuration data specified in the lobotomy patch above. By default    the patch(...) applies to the boto3.Session object, so calling     boto3.Session() will create a lobotomy.Session instead of a normal    boto3.Session. From there the low-level client interface is designed    to match normal usage.    &quot;&quot;&quot;    s3_client = boto3.Session().client(&quot;s3&quot;)        # Lobotomy will validate that you have specified the required keys    # in your request, so Bucket and Key have to be supplied here even though    # they are not meaningful values in this particular test scenario.    response = s3_client.get_object(Bucket=&quot;foo&quot;, Key=&quot;bar&quot;)    expected = b&quot;The contents of my S3 file.&quot;    assert response['Body'].read() == expected, &quot;&quot;&quot;        Expect the mocked response body data to be returned as a        StreamingBody object with blob/bytes contents. The lobotomy        library introspects boto to properly convert the string body        value in the configuration file into the expected return format        for the particular call.        &quot;&quot;&quot;        expected = datetime.datetime(2020, 12, 1, 1, 2, 3, 0, datetime.timezone.utc)    assert response['LastModified'] == expected, &quot;&quot;&quot;        Expect the mocked response last modified value to be a timezeon-aware        datetime value generated from the string timestamp value in the        configuration file to match how it would be returned by boto in        an actual response.        &quot;&quot;&quot;```The patching process replaces the `boto3.Session` class with a`lobotomy.Lobotomy` object that contains the loaded configuration data.When patched in this fashion, `boto3.Session()` calls will actually be`lobotomy.Lobotomy()` calls that return `lobotomy.Session` objects. Thesesessions have the interface of the `boto3.Session` object, but behave ina way such that client responses are returned from the configuration datainstead of through interactivity with AWS.For simple cases with little configuration, it is also possible to patchdata stored directly within the Python code. The above test could be rewrittenin this way as:```pythonimport lobotomyconfiguration = {    &quot;clients&quot;: {        &quot;s3&quot;: {            &quot;get_object&quot;: [                {                     &quot;Body&quot;: &quot;The contents of my S3 file.&quot;,                    &quot;LastModified&quot;: &quot;2020-11-01T12:23:34Z&quot;,                },                {                    &quot;Body&quot;: &quot;Another S3 file.&quot;,                    &quot;LastModified&quot;: &quot;2020-11-03T12:23:34Z&quot;,                },            ],        },    },}@lobotomy.patch(data=configuration)def test_lobotomy(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;...&quot;&quot;&quot;```Although one of the benefits of lobotomy is the ability to streamline thetests files by reducing the response configuration, which can be a bitverbose inside Python files and that is the highly recommended approach.A third option for simpler cases is to use the `Lobotomy.add_call()` methodto register calls and responses.```pythonimport lobotomy@lobotomy.patch()def test_lobotomy(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;...&quot;&quot;&quot;    lobotomized.add_call(        service_name=&quot;s3&quot;,         method_name=&quot;get_object&quot;,         response={             &quot;Body&quot;: &quot;The contents of my S3 file.&quot;,            &quot;LastModified&quot;: &quot;2020-11-01T12:23:34Z&quot;,        },    )    lobotomized.add_call(        service_name=&quot;s3&quot;,         method_name=&quot;get_object&quot;,         response={            &quot;Body&quot;: &quot;Another S3 file.&quot;,            &quot;LastModified&quot;: &quot;2020-11-03T12:23:34Z&quot;,        },    )```In the case above no data or path was supplied to the `lobotomy.patch()` and insteadcall responses were registered within the test function itself. The response argumentin the `Lobotomy.add_call()` method is optional. If omitted, a default one will becreated instead in the same fashion as one would be created via the CLI (see below).Note that it is also possible to mix loading data and adding calls within the testfunction.## YAML IO ModifiersWhen using YAML files, lobotomy comes with custom YAML classes that can provideeven more flexibility and ease in defining data. The following are the availablemodifiers and how to use them:### to_jsonThis modifier will convert YAML data into a JSON string in the creation of theresponse, which makes it easier to represent complex JSON data in the scenariodata.```yamlclients:  secretsmanager:    get_secret_value:      SecretString: !lobotomy.to_json        first: first_value        second: second_value```In this example the `!lobotomy.to_json` YAML modifier instructs the lobotomy toconverts the object data beneath the `SecretString` attribute into a JSON stringas part of the response object. In this case then in the associated Python test:```pythonimport boto3import lobotomyimport json@lobotomy.patch(path=&quot;scenario.yaml&quot;)def test_showing_to_json(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;Should expect a JSON string for the 'SecretString' value.&quot;&quot;&quot;    client = boto3.Session().client(&quot;secretsmanager&quot;)    response = client.get_secret_value(SecretId=&quot;fake&quot;)        expected = {&quot;first&quot;: &quot;first_value&quot;, &quot;second&quot;: &quot;second_value&quot;}    assert expected == json.loads(response[&quot;SecretValue&quot;])```the value is returned as the expected JSON string.### inject_stringThis modifier is used to inject the string contents of another file into the valueof the associated attribute.```yamlclients:  s3:    get_object:      Body: !lobotomy.inject_string './body.txt'```Here the `!lobotomy.inject_string` YAML modifier instructs lobotomy to load thecontents of the external file `./body.txt` into the `Body` attribute value wherethe external file path is defined relative to the defining YAML file.So in this case, if there's a `body.txt` file with the contents `Hello lobotomy!`,the Python test would find this in reading the body:```pythonimport boto3import lobotomy@lobotomy.patch(path=&quot;scenario.yaml&quot;)def test_showing_inject_string(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;Should expect the body.txt to be injected into the Body response attribute.&quot;&quot;&quot;    client = boto3.Session().client(&quot;s3&quot;)    response = client.get_object(Bucket=&quot;fake&quot;, Key=&quot;fake&quot;)    assert response[&quot;Body&quot;].read() == b&quot;Hello lobotomy!&quot;```## Special CasesThe following are special case operations that are handled slightly differently thanthe regular lobotomy behaviors.### s3.download_fileobjThis is a special action that is not actually included in the botocore API. It's aconvenience wrapper that has the special behavior of written data to a byte-bufferobject instead of returning a value. To handle that, the `&quot;Fileobj&quot;` response shouldbe populated with either a string or a bytes object. Lobotomy will internally handlewriting that to the specified buffer like this:```pythonimport boto3import lobotomyimport io@lobotomy.Patch()def test_s3_download_fileobj(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;Should write s3.download_fileobj outputs to the Fileobj argument buffer.&quot;&quot;&quot;    lobotomized.add_call(&quot;s3&quot;, &quot;download_fileobj&quot;, {&quot;Fileobj&quot;: &quot;Hello World!&quot;})    client = boto3.Session().client(&quot;s3&quot;)    data = io.BytesIO()    client.download_fileobj(Bucket=&quot;bar&quot;, Key=&quot;baz&quot;, Fileobj=data)    call = lobotomized.get_service_calls(&quot;s3&quot;, &quot;download_fileobj&quot;)[0]    assert call.request[&quot;Fileobj&quot;] == data    assert call.request[&quot;Bucket&quot;] == &quot;bar&quot;    assert call.request[&quot;Key&quot;] == &quot;baz&quot;    assert data.getvalue().decode() == &quot;Hello World!&quot;```## Command Line InterfaceThe lobotomy library also has a command line interface to help streamlinethe process of creating configuration files. The CLI has an `add` commandthat can be used to auto-generate method call response configurations toa new or existing configuration file. The values are meant to be replacedand unused keys to be removed to streamline for testing, but it helps a lotto get the full structure of the response in place and work from there insteadof having to look it up yourself.For example, creating the file:```yamlclients:  sts:    get_caller_identity:      Account: '987654321'  s3:    get_object:    - Body: 'The contents of my S3 file.'      LastModified: '2020-11-01T12:23:34Z'    - Body: 'Another S3 file.'      LastModified: '2020-11-03T12:23:34Z'```could be done first through the CLI commands:```shell script$ lobotomy add sts.get_caller_identity example.yaml``` After that command is executed, the `example.yaml` file will becreated and populated initially with:```yamlclients:  sts:    get_caller_identity:      Account: '...'      Arn: '...'      UserId: '...'```Notice the values are placeholders. We can adjust the values to what we wantand remove the unnecessary keys for our particular case such that the filecontents are then:```yamlclients:  sts:    get_caller_identity:      Account: '987654321'```Next add the first `s3.get_object` call:```shell script$ lobotomy add s3.get_object example.yaml```The configuration file now looks like:```yamlclients:  s3:    get_object:      AcceptRanges: '...'      Body: '...'      CacheControl: '...'      ContentDisposition: '...'      ContentEncoding: '...'      ContentLanguage: '...'      ContentLength: 1      ContentRange: '...'      ContentType: '...'      DeleteMarker: null      ETag: '...'      Expiration: '...'      Expires: '2020-11-04T14:37:18.042821Z'      LastModified: '2020-11-04T14:37:18.042821Z'      Metadata: null      MissingMeta: 1      ObjectLockLegalHoldStatus: '...'      ObjectLockMode: '...'      ObjectLockRetainUntilDate: '2020-11-04T14:37:18.042821Z'      PartsCount: 1      ReplicationStatus: '...'      RequestCharged: '...'      Restore: '...'      SSECustomerAlgorithm: '...'      SSECustomerKeyMD5: '...'      SSEKMSKeyId: '...'      ServerSideEncryption: '...'      StorageClass: '...'      TagCount: 1      VersionId: '...'      WebsiteRedirectLocation: '...'  sts:    get_caller_identity:      Account: '987654321'```Of course, this is a simple case because we don't need much of the responsestructure in our simplified use-case, but hopefully you can see the valueof being able to add the response structure so easily for more complex cases.Once again, the new call is adjusted to fit our particular needs:```yamlclients:  s3:    get_object:      Body: 'The contents of my S3 file.'      LastModified: '2020-11-01T12:23:34Z'  sts:    get_caller_identity:      Account: '987654321'```Adding the second `s3.get_object` call is identical:```shell script$ lobotomy add s3.get_object example.yaml```However, lobotomy notices the existing call there and so converts the`get_object` response configuration to a list of responses for you:```yamlclients:  s3:    Body: 'The contents of my S3 file.'    LastModified: '2020-11-01T12:23:34Z'    get_object:      AcceptRanges: '...'      Body: '...'      CacheControl: '...'      ContentDisposition: '...'      ContentEncoding: '...'      ContentLanguage: '...'      ContentLength: 1      ContentRange: '...'      ContentType: '...'      DeleteMarker: null      ETag: '...'      Expiration: '...'      Expires: '2020-11-04T14:42:51.077364Z'      LastModified: '2020-11-04T14:42:51.077364Z'      Metadata: null      MissingMeta: 1      ObjectLockLegalHoldStatus: '...'      ObjectLockMode: '...'      ObjectLockRetainUntilDate: '2020-11-04T14:42:51.077364Z'      PartsCount: 1      ReplicationStatus: '...'      RequestCharged: '...'      Restore: '...'      SSECustomerAlgorithm: '...'      SSECustomerKeyMD5: '...'      SSEKMSKeyId: '...'      ServerSideEncryption: '...'      StorageClass: '...'      TagCount: 1      VersionId: '...'      WebsiteRedirectLocation: '...'  sts:    get_caller_identity:      Account: '987654321'```Finally, edit the new call response configuration and we end up with theconfiguration we were looking for:```yamlclients:  sts:    get_caller_identity:      Account: '987654321'  s3:    get_object:    - Body: 'The contents of my S3 file.'      LastModified: '2020-11-01T12:23:34Z'    - Body: 'Another S3 file.'      LastModified: '2020-11-03T12:23:34Z'```# Advanced Usage## Key PrefixesBy default configuration files are rooted at the `clients` key within thefile. However, it is possible to specify a different root key prefix, whichis useful when co-locating lobotomy test configuration with other testconfiguration data in the same file, or when co-locating multiple lobotomytest configurations within the same file. To achieve that a prefix must bespecified during patching.As an example, consider the configuration file:```yamllobotomy:  test_a:    clients:      sts:        get_caller_identity:          Account: '987654321'  test_b:    clients:      sts:        get_caller_identity:          Account: '123456678'          UserId: 'AIFASDJWISJAVHXME'```In this case the prefixes are `lobotomy.test_a` and `lobotomy.test_b`.To use these in a test the *prefix* must be specified in the patch:```pythonimport pathlibimport lobotomyconfig_path = pathlib.Path(__file__).parent.joinpath(&quot;validation.yaml&quot;)@lobotomy.patch(config_path, prefix=&quot;lobotomy.test_a&quot;)def test_a(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;...&quot;&quot;&quot;@lobotomy.patch(config_path, prefix=&quot;lobotomy.test_b&quot;)def test_b(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;...&quot;&quot;&quot;```The prefix can be specified as a `.` delimited string, or as a list/tuple.The list/tuple is needed if the keys themselves contains `.`.## Patching TargetsBy default, lobotomy will patch `boto3.Session`. There are scenarios wherea different patch would be desired either to limit the scope of the patch orto patch another library wrapping the `boto3.Session` call. In those cases,specify the patch path argument:```pythonimport pathlibimport lobotomyconfig_path = pathlib.Path(__file__).parent.joinpath(&quot;test.yaml&quot;)@lobotomy.patch(config_path, patch_path=&quot;something.else.Session&quot;)def test_another_patch_path(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;...&quot;&quot;&quot;```## Session ConfigurationIn addition to the clients configurations described above, it is also possibleto configure the session values as well with the `session:` attribute. Theavailable configuration settings for the session are:```yamlsession:  profile_name: some-profile  region_name: us-west-2  available_profiles:    - some-profile    - some-other-profile  credentials:    access_key: A123KEY    secret_key: somesecretkeyvalue    token: theaccesstokenifset    method: how-the-credentials-were-loadedclients:  ...```All of these values are optional and in cases where they are omitted, but the sessionrequires having them, they will be defaulted.## Client OverridesThere are cases where it is desirable to replace one or more service clients withnon-lobotomy objects. Lobotomy supports that by adding client overrides to the patchedlobotomy object:```pythonfrom unittest.mock import MagicMockimport lobotomy@lobotomy.patch()def test_example(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;Should do something...&quot;&quot;&quot;    mock_dynamo_db_client = MagicMock()    lobotomized.add_client_override(&quot;dynamodb&quot;, mock_dynamo_db_client)    # continue testing...```## Error HandlingThe lobotomy library mimics client error handling with a lobotomized version of thesame interface used by the live clients. As such, handling and capturing errors workstransparently. For example,```pythonimport boto3import pytestimport lobotomy@lobotomy.patch()def test_client_errors(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;Should raise the specified error.&quot;&quot;&quot;    lobotomized.add_error_call(        service_name=&quot;s3&quot;,        method_name=&quot;list_objects&quot;,        error_code=&quot;NoSuchBucket&quot;,         error_message=&quot;Hello...&quot;,    )    session = boto3.Session()    client = session.client(&quot;s3&quot;)    with pytest.raises(client.exceptions.NoSuchBucket):        client.list_objects(Bucket=&quot;foo&quot;)```Or the generic client error handling with response codes can be used as well:```pythonimport boto3import pytestimport lobotomy@lobotomy.patch()def test_client_errors(lobotomized: lobotomy.Lobotomy):    &quot;&quot;&quot;Should raise the specified error.&quot;&quot;&quot;    lobotomized.add_call(        service_name=&quot;s3&quot;,        method_name=&quot;list_objects&quot;,        error_code=&quot;NoSuchBucket&quot;,         error_message=&quot;Hello...&quot;,    )    session = boto3.Session()    client = session.client(&quot;s3&quot;)    with pytest.raises(lobotomy.ClientError) as exception_info:        client.list_objects(Bucket=&quot;foo&quot;)    assert exception_info.value.response[&quot;Error&quot;][&quot;Code&quot;] == &quot;NoSuchBucket&quot;```These errors can also be specified in YAML files like this:```yamlclients:  s3:    list_objects: !lobotomy.error      code: NoSuchBucket      message: Hello...```The `!lobotomy.error` will load this as an error response with the same behavior as theexamples shown above.## Callable ResponsesFor more advanced cases it is also possible to use any callable as the source forgenerating the response. For example, if I want the response to be different basedon the arguments specified when making the call, I can create a function to returna result that reflects the inputs.```pythonimport typingimport boto3import lobotomydef _respond(*args, **kwargs) -&gt; typing.Dict[str, typing.Any]:    return {        &quot;Body&quot;: &quot;{}.{}&quot;.format(kwargs[&quot;Bucket&quot;], kwargs[&quot;Key&quot;]).encode()    }@lobotomy.patch()def test_callable_responses(lobotomized: &quot;lobotomy.Lobotomy&quot;):    &quot;&quot;&quot;Should return the expected body value from the callable response.&quot;&quot;&quot;    lobotomized.add_call(&quot;s3&quot;, &quot;get_object&quot;, _respond)    session = boto3.Session()    client = session.client(&quot;s3&quot;)    response = client.get_object(Bucket=&quot;foo&quot;, Key=&quot;bar&quot;)    assert response[&quot;Body&quot;].read() == b&quot;foo.bar&quot;```Any callable is supported as long as it accepts the `*args, **kwargs` appropriate tothe calling client service request.</longdescription>
</pkgmetadata>