<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: http://www.repostatus.org/badges/latest/active.svg    :target: http://www.repostatus.org/#active    :alt: Project Status: Active — The project has reached a stable, usable          state and is being actively developed... image:: https://github.com/jwodder/headerparser/workflows/Test/badge.svg?branch=master    :target: https://github.com/jwodder/headerparser/actions?workflow=Test    :alt: CI Status.. image:: https://codecov.io/gh/jwodder/headerparser/branch/master/graph/badge.svg    :target: https://codecov.io/gh/jwodder/headerparser.. image:: https://img.shields.io/pypi/pyversions/headerparser.svg    :target: https://pypi.org/project/headerparser.. image:: https://img.shields.io/github/license/jwodder/headerparser.svg    :target: https://opensource.org/licenses/MIT    :alt: MIT License`GitHub &lt;https://github.com/jwodder/headerparser&gt;`_| `PyPI &lt;https://pypi.org/project/headerparser&gt;`_| `Documentation &lt;https://headerparser.readthedocs.io&gt;`_| `Issues &lt;https://github.com/jwodder/headerparser/issues&gt;`_| `Changelog &lt;https://github.com/jwodder/headerparser/blob/master/CHANGELOG.md&gt;`_``headerparser`` parses key-value pairs in the style of RFC 822 (e-mail)headers and converts them into case-insensitive dictionaries with the trailingmessage body (if any) attached.  Fields can be converted to other types, markedrequired, or given default values using an API based on the standard library's``argparse`` module.  (Everyone loves ``argparse``, right?)  Low-levelfunctions for just scanning header fields (breaking them into sequences ofkey-value pairs without any further processing) are also included.The Format==========RFC 822-style headers are header fields that follow the general format ofe-mail headers as specified by RFC 822 and friends: each field is a line of theform &quot;``Name: Value``&quot;, with long values continued onto multiple lines(&quot;folded&quot;) by indenting the extra lines.  A blank line marks the end of theheader section and the beginning of the message body.This basic grammar has been used by numerous textual formats besides e-mail,including but not limited to:- HTTP request &amp; response headers- Usenet messages- most Python packaging metadata files- Debian packaging control files- ``META-INF/MANIFEST.MF`` files in Java JARs- a subset of the `YAML &lt;http://www.yaml.org/&gt;`_ serialization format— all of which this package can parse.Installation============``headerparser`` requires Python 3.7 or higher.  Just use `pip&lt;https://pip.pypa.io&gt;`_ for Python 3 (You have pip, right?) to install``headerparser``::    python3 -m pip install headerparserExamples========Define a parser:&gt;&gt;&gt; import headerparser&gt;&gt;&gt; parser = headerparser.HeaderParser()&gt;&gt;&gt; parser.add_field('Name', required=True)&gt;&gt;&gt; parser.add_field('Type', choices=['example', 'demonstration', 'prototype'], default='example')&gt;&gt;&gt; parser.add_field('Public', type=headerparser.BOOL, default=False)&gt;&gt;&gt; parser.add_field('Tag', multiple=True)&gt;&gt;&gt; parser.add_field('Data')Parse some headers and inspect the results:&gt;&gt;&gt; msg = parser.parse('''\... Name: Sample Input... Public: yes... tag: doctest, examples,...   whatever... TAG: README...... Wait, why I am using a body instead of the &quot;Data&quot; field?... ''')&gt;&gt;&gt; sorted(msg.keys())['Name', 'Public', 'Tag', 'Type']&gt;&gt;&gt; msg['Name']'Sample Input'&gt;&gt;&gt; msg['Public']True&gt;&gt;&gt; msg['Tag']['doctest, examples,\n  whatever', 'README']&gt;&gt;&gt; msg['TYPE']'example'&gt;&gt;&gt; msg['Data']Traceback (most recent call last):    ...KeyError: 'data'&gt;&gt;&gt; msg.body'Wait, why I am using a body instead of the &quot;Data&quot; field?\n'Fail to parse headers that don't meet your requirements:&gt;&gt;&gt; parser.parse('Type: demonstration')Traceback (most recent call last):    ...headerparser.errors.MissingFieldError: Required header field 'Name' is not present&gt;&gt;&gt; parser.parse('Name: Bad type\nType: other')Traceback (most recent call last):    ...headerparser.errors.InvalidChoiceError: 'other' is not a valid choice for 'Type'&gt;&gt;&gt; parser.parse('Name: unknown field\nField: Value')Traceback (most recent call last):    ...headerparser.errors.UnknownFieldError: Unknown header field 'Field'Allow fields you didn't even think of:&gt;&gt;&gt; parser.add_additional()&gt;&gt;&gt; msg = parser.parse('Name: unknown field\nField: Value')&gt;&gt;&gt; msg['Field']'Value'Just split some headers into names &amp; values and worry about validity later:&gt;&gt;&gt; for field in headerparser.scan('''\... Name: Scanner Sample... Unknown headers: no problem... Unparsed-Boolean: yes... CaSe-SeNsItIvE-rEsUlTs: true... Whitespace around colons:optional... Whitespace around colons  :  I already said it's optional....   That means you have the _option_ to use as much as you want!...... And there's a body, too, I guess.... '''): print(field)('Name', 'Scanner Sample')('Unknown headers', 'no problem')('Unparsed-Boolean', 'yes')('CaSe-SeNsItIvE-rEsUlTs', 'true')('Whitespace around colons', 'optional')('Whitespace around colons', &quot;I already said it's optional.\n  That means you have the _option_ to use as much as you want!&quot;)(None, &quot;And there's a body, too, I guess.\n&quot;)</longdescription>
</pkgmetadata>