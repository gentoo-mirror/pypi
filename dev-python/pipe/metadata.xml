<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Infix programming toolkitModule enabling a sh like infix syntax (using pipes).# IntroductionAs an example, here is the solution for the 2nd Euler Project exercise:&gt; Find the sum of all the even-valued terms in Fibonacci which do not  exceed four million.Given `fib` a generator of Fibonacci numbers:```pythonsum(fib() | where(lambda x: x % 2 == 0) | take_while(lambda x: x &lt; 4000000))```Each pipes is lazy evalatated, can be aliased, and partiallyinitialized, so it could be rewritten as:```pythonis_even = where(lambda x: x % 2 == 0)sum(fib() | is_even | take_while(lambda x: x &lt; 4000000)```# InstallingTo install the library, you can just run the following command:```shell# Linux/macOSpython3 -m pip install pipe# Windowspy -3 -m pip install pipe```# UsingThe basic syntax is to use a Pipe like in a shell:```python&gt;&gt;&gt; from itertools import count&gt;&gt;&gt; from pipe import select, take&gt;&gt;&gt; sum(count() | select(lambda x: x ** 2) | take(10))285```Some pipes take an argument:```python&gt;&gt;&gt; from pipe import where&gt;&gt;&gt; sum([1, 2, 3, 4] | where(lambda x: x % 2 == 0))6```Some do not need one:```python&gt;&gt;&gt; from pipe import traverse&gt;&gt;&gt; for i in [1, [2, 3], 4] | traverse:...     print(i)1234```In which case it's allowed to use the calling parenthesis:```python&gt;&gt;&gt; from pipe import traverse&gt;&gt;&gt; for i in [1, [2, 3], 4] | traverse():...     print(i)1234```## Constructing your ownYou can construct your pipes using the `Pipe` class like:```pythonfrom pipe import Pipesquare = Pipe(lambda iterable: (x ** 2 for x in iterable))map = Pipe(lambda iterable, fct: builtins.map(fct, iterable)```As you can see it's often very short to write, and with a bit of luckthe function you're wrapping already takes an iterable as the firstargument, making the wrapping straight forward:```python&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; from pipe import Pipe&gt;&gt;&gt; end = Pipe(deque)```and that's it `itrable | end(3)` is `deque(iterable, 3)`:```python&gt;&gt;&gt; list(range(100) | end(3))[97, 98, 99]```In case it gets more complicated one can use `Pipe` as a decorator toa function taking an iterable as the first argument, and any otheroptional arguments after:```python&gt;&gt;&gt; from statistics import mean&gt;&gt;&gt; @Pipe... def running_average(iterable, width):...     items = deque(maxlen=width)...     for item in iterable:...         items.append(item)...         yield mean(items)&gt;&gt;&gt; list(range(20) | running_average(width=2))[0, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5, 17.5, 18.5]&gt;&gt;&gt; list(range(20) | running_average(width=10))[0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5]```## Partial PipesA `pipe` can be parametrized without being evaluated:```python&gt;&gt;&gt; running_average_of_two = running_average(2)&gt;&gt;&gt; list(range(20) | running_average_of_two)[0, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5, 17.5, 18.5]```For multi-argument pipes then can be partially initialized, you can think of curying:```pythonsome_iterable | some_pipe(1, 2, 3)```is strictly equivalent to:```pythonsome_iterable | some_pipe(1)(2)(3)```So it can be used to specialize pipes, first a dummy example:```python&gt;&gt;&gt; @Pipe... def addmul(iterable, to_add, to_mul):...     &quot;&quot;&quot;Computes (x + to_add) * to_mul to every items of the input.&quot;&quot;&quot;...     for i in iterable:...         yield (i + to_add) * to_mul&gt;&gt;&gt; mul = addmul(0)  # This partially initialize addmul with to_add=0&gt;&gt;&gt; list(range(10) | mul(10))[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]```Which also works with keyword arguments:```python&gt;&gt;&gt; add = addmul(to_mul=1)  # This partially initialize addmul with `to_mul=1`&gt;&gt;&gt; list(range(10) | add(10))[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]```But now for something interesting:```python&gt;&gt;&gt; import re&gt;&gt;&gt; @Pipe... def grep(iterable, pattern, flags=0):...     for line in iterable:...         if re.match(pattern, line, flags=flags):...             yield line...&gt;&gt;&gt; lines = [&quot;Hello&quot;, &quot;hello&quot;, &quot;World&quot;, &quot;world&quot;]&gt;&gt;&gt; for line in lines | grep(&quot;H&quot;):...     print(line)Hello```Now let's reuse it in two ways, first with a pattern:```python&gt;&gt;&gt; lowercase_only = grep(&quot;[a-z]+$&quot;)&gt;&gt;&gt; for line in lines | lowercase_only:...     print(line)helloworld```Or now with a flag:```python&gt;&gt;&gt; igrep = grep(flags=re.IGNORECASE)&gt;&gt;&gt; for line in lines | igrep(&quot;hello&quot;):...    print(line)...Hellohello```# Deprecations of pipe 1.xIn pipe 1.x a lot of functions were returning iterables and a lotother functions were returning non-iterables, causing confusion. Theone returning non-iterables could only be used as the last function ofa pipe expression, so they are in fact useless:```pythonrange(100) | where(lambda x: x % 2 == 0) | add```can be rewritten with no less readability as:```pythonsum(range(100) | where(lambda x: x % 2 == 0))```so all pipes returning non-iterables are now deprecated and wereremoved in pipe 2.0.## What shoud I do?Oh, you just upgraded pipe, got an exception, and landed here? Youhave three solutions:1) Stop using closing-pipes, replace `...|...|...|...|as_list` to   `list(...|...|...|)`, that's it, it's even shorter.2) If &quot;closing pipes&quot; are not an issue for you, and you really like   them, just reimplement the few you really need, it often take a very   few lines of code, or copy them from   [here](https://github.com/JulienPalard/Pipe/blob/dd179c8ff0aa28ee0524f3247e5cb1c51347cba6/pipe.py).3) If you still rely on a lot of them and are in a hurry, just `pip install pipe&lt;2`.And start testing your project using the [Python DevelopmentMode](https://docs.python.org/3/library/devmode.html) so you catchthose warnings before they bite you.## But I like them, pleassssse, reintroduce them!This has already been discussed in [#74](https://github.com/JulienPalard/Pipe/issues/74).An `@Pipe` is often easily implemented in a 1 to 3 lines of codefunction, and the `pipe` module does not aim at giving allpossibilities, it aims at giving the `Pipe` decorator.So if you need more pipes, closing pipes, weired pipes, you-name-it,feel free to implement them on your project, and consider thealready-implemented ones as examples on how to do it.See the `Constructing your own` paragraph below.# Existing Pipes in this moduleAlphabetical list of available pipes; when several names are listed for a given pipe, these are aliases.## `chain`Chain a sequence of iterables:```python&gt;&gt;&gt; from pipe import chain&gt;&gt;&gt; list([[1, 2], [3, 4], [5]] | chain)[1, 2, 3, 4, 5]```Warning : chain only unfold iterable containing ONLY iterables:```python[1, 2, [3]] | chain```Gives a `TypeError: chain argument #1 must support iteration`Consider using traverse.## `chain_with(other)`Like itertools.chain, yields elements of the given iterable,hen yields elements of its parameters```python&gt;&gt;&gt; from pipe import chain_with&gt;&gt;&gt; list((1, 2, 3) | chain_with([4, 5], [6]))[1, 2, 3, 4, 5, 6]```## `dedup(key=None)`Deduplicate values, using the given `key` function if provided.```python&gt;&gt;&gt; from pipe import dedup&gt;&gt;&gt; list([-1, 0, 0, 0, 1, 2, 3] | dedup)[-1, 0, 1, 2, 3]&gt;&gt;&gt; list([-1, 0, 0, 0, 1, 2, 3] | dedup(key=abs))[-1, 0, 2, 3]```## `filter(predicate)`Alias for `where(predicate)`, see `where(predicate)`.## `groupby(key=None)`Like `itertools.groupby(sorted(iterable, key = keyfunc), keyfunc)````python&gt;&gt;&gt; from pipe import groupby, map&gt;&gt;&gt; items = range(10)&gt;&gt;&gt; ' / '.join(items | groupby(lambda x: &quot;Odd&quot; if x % 2 else &quot;Even&quot;)...                  | select(lambda x: &quot;{}: {}&quot;.format(x[0], ', '.join(x[1] | map(str)))))'Even: 0, 2, 4, 6, 8 / Odd: 1, 3, 5, 7, 9'```## `islice()`Just the `itertools.islice` function as a Pipe:```python&gt;&gt;&gt; from pipe import islice&gt;&gt;&gt; list((1, 2, 3, 4, 5, 6, 7, 8, 9) | islice(2, 8, 2))[3, 5, 7]```## `izip()`Just the `itertools.izip` function as a Pipe:```python&gt;&gt;&gt; from pipe import izip&gt;&gt;&gt; list(range(0, 10) | izip(range(1, 11)))[(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]```## `map()`, `select()`Apply a conversion expression given as parameterto each element of the given iterable```python&gt;&gt;&gt; list([1, 2, 3] | map(lambda x: x * x))[1, 4, 9]&gt;&gt;&gt; list([1, 2, 3] | select(lambda x: x * x))[1, 4, 9]```## `netcat`The netcat Pipe sends and receive bytes over TCP:```pythondata = [    b&quot;HEAD / HTTP/1.0\r\n&quot;,    b&quot;Host: python.org\r\n&quot;,    b&quot;\r\n&quot;,]for packet in data | netcat(&quot;python.org&quot;, 80):    print(packet.decode(&quot;UTF-8&quot;))```Gives:```HTTP/1.1 301 Moved PermanentlyContent-length: 0Location: https://python.org/Connection: close```## ```permutations(r=None)```Returns all possible permutations:```python&gt;&gt;&gt; from pipe import permutations&gt;&gt;&gt; for item in 'ABC' | permutations(2):...     print(item)('A', 'B')('A', 'C')('B', 'A')('B', 'C')('C', 'A')('C', 'B')``````python&gt;&gt;&gt; for item in range(3) | permutations:...     print(item)(0, 1, 2)(0, 2, 1)(1, 0, 2)(1, 2, 0)(2, 0, 1)(2, 1, 0)```## `reverse`Like Python's built-in `reversed` function.```python&gt;&gt;&gt; from pipe import reverse&gt;&gt;&gt; list([1, 2, 3] | reverse)[3, 2, 1]```## `select(fct)`Alias for `map(fct)`, see `map(fct)`.## `skip()`Skips the given quantity of elements from the given iterable, then yields```python&gt;&gt;&gt; from pipe import skip&gt;&gt;&gt; list((1, 2, 3, 4, 5) | skip(2))[3, 4, 5]```## `skip_while(predicate)`Like itertools.dropwhile, skips elements of the given iterablewhile the predicate is true, then yields others:```python&gt;&gt;&gt; from pipe import skip_while&gt;&gt;&gt; list([1, 2, 3, 4] | skip_while(lambda x: x &lt; 3))[3, 4]```## `sort(key=None, reverse=False)`Like Python's built-in &quot;sorted&quot; primitive.```python&gt;&gt;&gt; from pipe import sort&gt;&gt;&gt; ''.join(&quot;python&quot; | sort)'hnopty'&gt;&gt;&gt; [5, -4, 3, -2, 1] | sort(key=abs)[1, -2, 3, -4, 5]```## `t`Like Haskell's operator &quot;:&quot;:```python&gt;&gt;&gt; from pipe import t&gt;&gt;&gt; for i in 0 | t(1) | t(2):...     print(i)012```## `tail(n)`Yields the given quantity of the last elements of the given iterable.```python&gt;&gt;&gt; from pipe import tail&gt;&gt;&gt; for i in (1, 2, 3, 4, 5) | tail(3):...     print(i)345```## `take(n)`Yields the given quantity of elements from the given iterable, like `head`in shell script.```python&gt;&gt;&gt; from pipe import take&gt;&gt;&gt; for i in count() | take(5):...     print(i)01234```## `take_while(predicate)`Like `itertools.takewhile`, yields elements of thegiven iterable while the predicate is true:```python&gt;&gt;&gt; from pipe import take_while&gt;&gt;&gt; for i in count() | take_while(lambda x: x ** 2 &lt; 100):...     print(i)0123456789```## `tee`tee outputs to the standard output and yield unchanged items, useful fordebugging a pipe stage by stage:```python&gt;&gt;&gt; from pipe import tee&gt;&gt;&gt; sum([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;] | tee | map(int) | tee)'1'1'2'2'3'3'4'4'5'515```The `15` at the end is the `sum` returning.## `transpose()`Transposes the rows and columns of a matrix.```python&gt;&gt;&gt; from pipe import transpose&gt;&gt;&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9]] | transpose[(1, 4, 7), (2, 5, 8), (3, 6, 9)]```## `traverse`Recursively unfold iterables:```python&gt;&gt;&gt; list([[1, 2], [[[3], [[4]]], [5]]] | traverse)[1, 2, 3, 4, 5]&gt;&gt;&gt; squares = (i * i for i in range(3))&gt;&gt;&gt; list([[0, 1, 2], squares] | traverse)[0, 1, 2, 0, 1, 4]```## `uniq(key=None)`Like dedup() but only deduplicate consecutive values, using the given`key` function if provided (or else the identity).```python&gt;&gt;&gt; from pipe import uniq&gt;&gt;&gt; list([1, 1, 2, 2, 3, 3, 1, 2, 3] | uniq)[1, 2, 3, 1, 2, 3]&gt;&gt;&gt; list([1, -1, 1, 2, -2, 2, 3, 3, 1, 2, 3] | uniq(key=abs))[1, 2, 3, 1, 2, 3]```## `where(predicate)`, `filter(predicate)`Only yields the matching items of the given iterable:```python&gt;&gt;&gt; list([1, 2, 3] | where(lambda x: x % 2 == 0))[2]```Don't forget they can be aliased:```python&gt;&gt;&gt; positive = where(lambda x: x &gt; 0)&gt;&gt;&gt; negative = where(lambda x: x &lt; 0)&gt;&gt;&gt; sum([-10, -5, 0, 5, 10] | positive)15&gt;&gt;&gt; sum([-10, -5, 0, 5, 10] | negative)-15```# Euler project samples&gt; Find the sum of all the multiples of 3 or 5 below 1000.```python&gt;&gt;&gt; euler1 = sum(count() | where(lambda x: x % 3 == 0 or x % 5 == 0) | take_while(lambda x: x &lt; 1000))&gt;&gt;&gt; assert euler1 == 233168```&gt; Find the sum of all the even-valued terms in Fibonacci which do not exceed four million.```pythoneuler2 = sum(fib() | where(lambda x: x % 2 == 0) | take_while(lambda x: x &lt; 4000000))```&gt; Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.```python&gt;&gt;&gt; square = map(lambda x: x ** 2)&gt;&gt;&gt; euler6 = sum(range(101)) ** 2 - sum(range(101) | square)&gt;&gt;&gt; assert euler6 == 25164150```# Lazy evaluationUsing this module, you get lazy evaluation at two levels:- the object obtained by piping is a generator and will be evaluated only if needed,- within a series of pipe commands, only the elements that are actually needed will be evaluated.To illustrate:```pythonfrom itertools import countfrom pipe import select, where, takedef dummy_func(x):    print(f&quot;processing at value {x}&quot;)    return xprint(&quot;----- test using a generator as input -----&quot;)print(f&quot;we are feeding in a: {type(count(100))}&quot;)res_with_count = (count(100) | select(dummy_func)                             | where(lambda x: x % 2 == 0)                             | take(2))print(f&quot;the resulting object is: {res_with_count}&quot;)print(f&quot;when we force evaluation we get:&quot;)print(f&quot;{list(res_with_count)}&quot;)print(&quot;----- test using a list as input -----&quot;)list_to_100 = list(range(100))print(f&quot;we are feeding in a: {type(list_to_100)} which has length {len(list_to_100)}&quot;)res_with_list = (list_to_100 | select(dummy_func)                             | where(lambda x: x % 2 == 0)                             | take(2))print(f&quot;the resulting object is: {res_with_list}&quot;)print(f&quot;when we force evaluation we get:&quot;)print(f&quot;{list(res_with_list)}&quot;)```Which prints:```----- test using a generator as input -----we are feeding in a: &lt;class 'itertools.count'&gt;the resulting object is: &lt;generator object take at 0x7fefb5e70c10&gt;when we force evaluation we get:processing at value 100processing at value 101processing at value 102processing at value 103processing at value 104[100, 102]----- test using a list as input -----we are feeding in a: &lt;class 'list'&gt; which has length 100the resulting object is: &lt;generator object take at 0x7fefb5e70dd0&gt;when we force evaluation we get:processing at value 0processing at value 1processing at value 2processing at value 3processing at value 4[0, 2]```</longdescription>
</pkgmetadata>