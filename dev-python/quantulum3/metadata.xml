<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># quantulum3 [![Travis master build state](https://app.travis-ci.com/nielstron/quantulum3.svg?branch=master &quot;Travis master build state&quot;)](https://app.travis-ci.com/nielstron/quantulum3) [![Coverage Status](https://coveralls.io/repos/github/nielstron/quantulum3/badge.svg?branch=master)](https://coveralls.io/github/nielstron/quantulum3?branch=master) [![PyPI version](https://badge.fury.io/py/quantulum3.svg)](https://pypi.org/project/quantulum3/) ![PyPI - Python Version](https://img.shields.io/pypi/pyversions/quantulum3.svg) [![PyPI - Status](https://img.shields.io/pypi/status/quantulum3.svg)](https://pypi.org/project/quantulum3/)Python library for information extraction of quantities, measurementsand their units from unstructured text. It is able to disambiguate between similarlooking units based on their *k-nearest neighbours* in their [GloVe](https://nlp.stanford.edu/projects/glove/) vector representationand their [Wikipedia](https://en.wikipedia.org/) page.This is the Python 3 compatible fork of [recastrodiaz\'fork](https://github.com/recastrodiaz/quantulum) of [grhawks\'fork](https://github.com/grhawk/quantulum) of [the original by MarcoLagi](https://github.com/marcolagi/quantulum).The compatibility with the newest version of sklearn is based onthe fork of [sohrabtowfighi](https://github.com/sohrabtowfighi/quantulum).## User Guide### Installation```bashpip install quantulum3```To install dependencies for using or training the disambiguation classifier, use```bashpip install quantulum3[classifier]```The disambiguation classifier is used when the parser find two or more units that are a match for the text.### Usage```pycon&gt;&gt;&gt; from quantulum3 import parser&gt;&gt;&gt; quants = parser.parse('I want 2 liters of wine')&gt;&gt;&gt; quants[Quantity(2, 'litre')]```The *Quantity* class stores the surface of the original text it wasextracted from, as well as the (start, end) positions of the match:```pycon&gt;&gt;&gt; quants[0].surfaceu'2 liters'&gt;&gt;&gt; quants[0].span(7, 15)```The *value* attribute provides the parsed numeric value and the *unit.name*attribute provides the name of the parsed unit:```pycon&gt;&gt;&gt; quants[0].value2.0&gt;&gt;&gt; quants[0].unit.name'litre'```An inline parser that embeds the parsed quantities in the text is alsoavailable (especially useful for debugging):```pycon&gt;&gt;&gt; print parser.inline_parse('I want 2 liters of wine')I want 2 liters {Quantity(2, &quot;litre&quot;)} of wine```As the parser is also able to parse dimensionless numbers,this library can also be used for simple number extraction.```pycon&gt;&gt;&gt; print parser.parse('I want two')[Quantity(2, 'dimensionless')]```### Units and entitiesAll units (e.g. *litre*) and the entities they are associated to (e.g.*volume*) are reconciled against WikiPedia:```pycon&gt;&gt;&gt; quants[0].unitUnit(name=&quot;litre&quot;, entity=Entity(&quot;volume&quot;), uri=https://en.wikipedia.org/wiki/Litre)&gt;&gt;&gt; quants[0].unit.entityEntity(name=&quot;volume&quot;, uri=https://en.wikipedia.org/wiki/Volume)```This library includes more than 290 units and 75 entities. It alsoparses spelled-out numbers, ranges and uncertainties:```pycon&gt;&gt;&gt; parser.parse('I want a gallon of beer')[Quantity(1, 'gallon')]&gt;&gt;&gt; parser.parse('The LHC smashes proton beams at 12.8–13.0 TeV')[Quantity(12.8, &quot;teraelectronvolt&quot;), Quantity(13, &quot;teraelectronvolt&quot;)]&gt;&gt;&gt; quant = parser.parse('The LHC smashes proton beams at 12.9±0.1 TeV')&gt;&gt;&gt; quant[0].uncertainty0.1```Non-standard units usually don\'t have a WikiPedia page. The parser willstill try to guess their underlying entity based on theirdimensionality:```pycon&gt;&gt;&gt; parser.parse('Sound travels at 0.34 km/s')[0].unitUnit(name=&quot;kilometre per second&quot;, entity=Entity(&quot;speed&quot;), uri=None)```### DisambiguationIf the parser detects an ambiguity, a classifier based on the WikiPediapages of the ambiguous units or entities tries to guess the right one:```pycon&gt;&gt;&gt; parser.parse('I spent 20 pounds on this!')[Quantity(20, &quot;pound sterling&quot;)]&gt;&gt;&gt; parser.parse('It weighs no more than 20 pounds')[Quantity(20, &quot;pound-mass&quot;)]```or:```pycon&gt;&gt;&gt; text = 'The average density of the Earth is about 5.5x10-3 kg/cm³'&gt;&gt;&gt; parser.parse(text)[0].unit.entityEntity(name=&quot;density&quot;, uri=https://en.wikipedia.org/wiki/Density)&gt;&gt;&gt; text = 'The amount of O₂ is 2.98e-4 kg per liter of atmosphere'&gt;&gt;&gt; parser.parse(text)[0].unit.entityEntity(name=&quot;concentration&quot;, uri=https://en.wikipedia.org/wiki/Concentration)```In addition to that, the classifier is trained on the most similar words toall of the units surfaces, according to their distance in [GloVe](https://nlp.stanford.edu/projects/glove/)vector representation.## Spoken versionQuantulum classes include methods to convert them to a speakable unit.```pycon&gt;&gt;&gt; parser.parse(&quot;Gimme 10e9 GW now!&quot;)[0].to_spoken()ten billion gigawatts&gt;&gt;&gt; parser.inline_parse_and_expand(&quot;Gimme $1e10 now and also 1 TW and 0.5 J!&quot;)Gimme ten billion dollars now and also one terawatt and zero point five joules!```### ManipulationWhile quantities cannot be manipulated within this library, there aremany great options out there:- [pint](https://pint.readthedocs.org/en/latest/)- [natu](http://kdavies4.github.io/natu/)- [quantities](http://python-quantities.readthedocs.org/en/latest/)## Extension### Training the classifierIf you want to train the classifier yourself, you will need the dependencies for the classifier (see installation).Use `quantulum3-training` on the command line, the script `quantulum3/scripts/train.py` or the method `train_classifier` in `quantulum3.classifier` to train the classifier.``` bashquantulum3-training --lang &lt;language&gt; --data &lt;path/to/training/file.json&gt; --output &lt;path/to/output/file.joblib&gt;```You can pass multiple training files in to the training command. The output is in joblib format.To use your custom model, pass the path to the trained model file to theparser:```pytonparser = Parser.parse(&lt;text&gt;, classifier_path=&quot;path/to/model.joblib&quot;)```Example training files can be found in `quantulum3/_lang/&lt;language&gt;/train`.If you want to create a new or different `similars.json`, install `pymagnitude`.For the extraction of nearest neighbours from a vector word representation file, use `scripts/extract_vere.py`. It automatically extracts the `k` nearest neighboursin vector space of the vector representation for each of the possible surfacesof the ambiguous units. The resulting neighbours are stored in `quantulum3/similars.json`and automatically included for training.The file provided should be in `.magnitude` format as other formats are firstconverted to a `.magnitude` file on-the-run. Check out[pre-formatted Magnitude formatted word-embeddings](https://github.com/plasticityai/magnitude#pre-converted-magnitude-formats-of-popular-embeddings-models)and [Magnitude](https://github.com/plasticityai/magnitude) for more information.### Additional unitsIt is possible to add additional entities and units to be parsed by quantulum. These will be added to the default units and entities. See below code for an example invocation:```pycon&gt;&gt;&gt; from quantulum3.load import add_custom_unit, remove_custom_unit&gt;&gt;&gt; add_custom_unit(name=&quot;schlurp&quot;, surfaces=[&quot;slp&quot;], entity=&quot;dimensionless&quot;)&gt;&gt;&gt; parser.parse(&quot;This extremely sharp tool is precise up to 0.5 slp&quot;)[Quantity(0.5, &quot;Unit(name=&quot;schlurp&quot;, entity=Entity(&quot;dimensionless&quot;), uri=None)&quot;)]```The keyword arguments to the function `add_custom_unit` are directly translatedto the properties of the unit to be created.### Custom Units and EntitiesIt is possible to load a completely custom set of units and entities. This can be done by passing a list of file paths to the load_custom_units and load_custom_entities functions. Loading custom untis and entities will replace the default units and entities that are normally loaded.The recomended way to load quantities is via a context manager:```pycon&gt;&gt;&gt; from quantulum3 import load, parser&gt;&gt;&gt; with load.CustomQuantities([&quot;path/to/units.json&quot;], [&quot;path/to/entities.json&quot;]):&gt;&gt;&gt;     parser.parse(&quot;This extremely sharp tool is precise up to 0.5 slp&quot;)[Quantity(0.5, &quot;Unit(name=&quot;schlurp&quot;, entity=Entity(&quot;dimensionless&quot;), uri=None)&quot;)]&gt;&gt;&gt; # default units and entities are loaded again```But it is also possible to load custom units and entities manually:```pycon&gt;&gt;&gt; from quantulum3 import load, parser&gt;&gt;&gt; load.load_custom_units([&quot;path/to/units.json&quot;])&gt;&gt;&gt; load.load_custom_entities([&quot;path/to/entities.json&quot;])&gt;&gt;&gt; parser.parse(&quot;This extremely sharp tool is precise up to 0.5 slp&quot;)[Quantity(0.5, &quot;Unit(name=&quot;schlurp&quot;, entity=Entity(&quot;dimensionless&quot;), uri=None)&quot;)]&gt;&gt;&gt; # remove custom units and entities and load default units and entities&gt;&gt;&gt; load.reset_quantities()```See the Developer Guide below for more information about the format of units and entities files.## Developer Guide### Adding Units and EntitiesSee *units.json* for the complete list of units and *entities.json* forthe complete list of entities. The criteria for adding units have been:- the unit has (or is redirected to) a WikiPedia page- the unit is in common use (e.g. not the [premetric Swedish units of    measurement](https://en.wikipedia.org/wiki/Swedish_units_of_measurement#Length)).It\'s easy to extend these two files to the units/entities of interest.Here is an example of an entry in *entities.json*:```json&quot;speed&quot;: {    &quot;dimensions&quot;: [{&quot;base&quot;: &quot;length&quot;, &quot;power&quot;: 1}, {&quot;base&quot;: &quot;time&quot;, &quot;power&quot;: -1}],    &quot;URI&quot;: &quot;https://en.wikipedia.org/wiki/Speed&quot;}```- The *name* of an entity is its key. Names are required to be unique.- *URI* is the name of the wikipedia page of the entity. (i.e. `https://en.wikipedia.org/wiki/Speed` =&gt; `Speed`)- *dimensions* is the dimensionality, a list of dictionaries each    having a *base* (the name of another entity) and a *power* (an    integer, can be negative).Here is an example of an entry in *units.json*:```json&quot;metre per second&quot;: {    &quot;surfaces&quot;: [&quot;metre per second&quot;, &quot;meter per second&quot;],    &quot;entity&quot;: &quot;speed&quot;,    &quot;URI&quot;: &quot;Metre_per_second&quot;,    &quot;dimensions&quot;: [{&quot;base&quot;: &quot;metre&quot;, &quot;power&quot;: 1}, {&quot;base&quot;: &quot;second&quot;, &quot;power&quot;: -1}],    &quot;symbols&quot;: [&quot;mps&quot;]},&quot;year&quot;: {    &quot;surfaces&quot;: [ &quot;year&quot;, &quot;annum&quot; ],    &quot;entity&quot;: &quot;time&quot;,    &quot;URI&quot;: &quot;Year&quot;,    &quot;dimensions&quot;: [],    &quot;symbols&quot;: [ &quot;a&quot;, &quot;y&quot;, &quot;yr&quot; ],    &quot;prefixes&quot;: [ &quot;k&quot;, &quot;M&quot;, &quot;G&quot;, &quot;T&quot;, &quot;P&quot;, &quot;E&quot; ]}```- The *name* of a unit is its key. Names are required to be unique.- *URI* follows the same scheme as in the *entities.json*- *surfaces* is a list of strings that refer to that unit. The library    takes care of plurals, no need to specify them.- *entity* is the name of an entity in *entities.json*- *dimensions* follows the same schema as in *entities.json*, but the    *base* is the name of another unit, not of another entity.- *symbols* is a list of possible symbols and abbreviations for that    unit.- *prefixes* is an optional list. It can contain [Metric](https://en.wikipedia.org/wiki/Metric_prefix) and [Binary prefixes](https://en.wikipedia.org/wiki/Binary_prefix) and    automatically generates according units. If you want to    add specifics (like different surfaces) you need to create an entry for that    prefixes version on its own.All fields are case sensitive.### Contributing`dev` build: [![Travis dev build state](https://travis-ci.com/nielstron/quantulum3.svg?branch=dev &quot;Travis dev build state&quot;)](https://travis-ci.com/nielstron/quantulum3)[![Coverage Status](https://coveralls.io/repos/github/nielstron/quantulum3/badge.svg?branch=dev)](https://coveralls.io/github/nielstron/quantulum3?branch=dev)If you'd like to contribute follow these steps:1. Clone a fork of this project into your workspace2. Run `pip install -e .` at the root of your development folder.3. `pip install pipenv` and `pipenv shell`4. Inside the project folder run `pipenv install --dev`5. Make your changes6. Run `scripts/format.sh` and `scripts/build.py` from the package root directory.7. Test your changes with `python3 setup.py test` (Optional, will be done automatically after pushing)8. Create a Pull Request when having commited and pushed your changes### Language support[![Travis dev build state](https://travis-ci.com/nielstron/quantulum3.svg?branch=language_support &quot;Travis dev build state&quot;)](https://travis-ci.com/nielstron/quantulum3)[![Coverage Status](https://coveralls.io/repos/github/nielstron/quantulum3/badge.svg?branch=language_support)](https://coveralls.io/github/nielstron/quantulum3?branch=dev)There is a branch for language support, namely `language_support`.From inspecting the `README` file in the `_lang` subdirectory andthe functions and values given in the new `_lang.en_US` submodule,one should be able to create own language submodules.The new language modules should automatically be invoked and be available,both through the `lang=` keyword argument in the parser functions as wellas in the automatic unittests.No changes outside the own language submodule folder (i.e. `_lang.de_DE`) shouldbe necessary. If there are problems implementing a new language, don't hesitate to open an issue.</longdescription>
</pkgmetadata>