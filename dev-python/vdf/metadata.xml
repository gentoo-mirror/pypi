<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>| |pypi| |license| |coverage| |master_build|| |sonar_maintainability| |sonar_reliability| |sonar_security|Pure python module for (de)serialization to and from VDF that works just like ``json``.Tested and works on ``py2.7``, ``py3.3+``, ``pypy`` and ``pypy3``.VDF is Valve's KeyValue text file formathttps://developer.valvesoftware.com/wiki/KeyValues| Supported versions: ``kv1``| Unsupported: ``kv2`` and ``kv3``Install-------You can grab the latest release from https://pypi.org/project/vdf/ or via ``pip``.. code:: bash    pip install vdfInstall the current dev version from ``github``.. code:: bash    pip install git+https://github.com/ValvePython/vdfProblems &amp; solutions--------------------- There are known files that contain duplicate keys. This is supported the format and  makes mapping to ``dict`` impossible. For this case the module provides ``vdf.VDFDict``  that can be used as mapper instead of ``dict``. See the example section for details.- By default de-serialization will return a ``dict``, which doesn't preserve nor guarantee  key order on Python versions prior to 3.6, due to `hash randomization`_. If key order is  important on old Pythons, I suggest using ``collections.OrderedDict``, or ``vdf.VDFDict``.Example usage-------------For text representation.. code:: python    import vdf    # parsing vdf from file or string    d = vdf.load(open('file.txt'))    d = vdf.loads(vdf_text)    d = vdf.parse(open('file.txt'))    d = vdf.parse(vdf_text)    # dumping dict as vdf to string    vdf_text = vdf.dumps(d)    indented_vdf = vdf.dumps(d, pretty=True)    # dumping dict as vdf to file    vdf.dump(d, open('file2.txt','w'), pretty=True)For binary representation.. code:: python    d = vdf.binary_loads(vdf_bytes)    b = vdf.binary_dumps(d)    # alternative format - VBKV    d = vdf.binary_loads(vdf_bytes, alt_format=True)    b = vdf.binary_dumps(d, alt_format=True)    # VBKV with header and CRC checking    d = vdf.vbkv_loads(vbkv_bytes)    b = vdf.vbkv_dumps(d)Using an alternative mapper.. code:: python  d = vdf.loads(vdf_string, mapper=collections.OrderedDict)  d = vdf.loads(vdf_string, mapper=vdf.VDFDict)``VDFDict`` works much like the regular ``dict``, except it handles duplicates and remembersinsert order. Additionally, keys can only be of type ``str``. The most important differenceis that when trying to assigning a key that already exist it will create a duplicate insteadof reassign the value to the existing key... code:: python  &gt;&gt;&gt; d = vdf.VDFDict()  &gt;&gt;&gt; d['key'] = 111  &gt;&gt;&gt; d['key'] = 222  &gt;&gt;&gt; d  VDFDict([('key', 111), ('key', 222)])  &gt;&gt;&gt; d.items()  [('key', 111), ('key', 222)]  &gt;&gt;&gt; d['key']  111  &gt;&gt;&gt; d[(0, 'key')]  # get the first duplicate  111  &gt;&gt;&gt; d[(1, 'key')]  # get the second duplicate  222  &gt;&gt;&gt; d.get_all_for('key')  [111, 222]  &gt;&gt;&gt; d[(1, 'key')] = 123  # reassign specific duplicate  &gt;&gt;&gt; d.get_all_for('key')  [111, 123]  &gt;&gt;&gt; d['key'] = 333  &gt;&gt;&gt; d.get_all_for('key')  [111, 123, 333]  &gt;&gt;&gt; del d[(1, 'key')]  &gt;&gt;&gt; d.get_all_for('key')  [111, 333]  &gt;&gt;&gt; d[(1, 'key')]  333  &gt;&gt;&gt; print vdf.dumps(d)  &quot;key&quot; &quot;111&quot;  &quot;key&quot; &quot;333&quot;  &gt;&gt;&gt; d.has_duplicates()  True  &gt;&gt;&gt; d.remove_all_for('key')  &gt;&gt;&gt; len(d)  0  &gt;&gt;&gt; d.has_duplicates()  False.. |pypi| image:: https://img.shields.io/pypi/v/vdf.svg?style=flat&amp;label=latest%20version    :target: https://pypi.org/project/vdf/    :alt: Latest version released on PyPi.. |license| image:: https://img.shields.io/pypi/l/vdf.svg?style=flat&amp;label=license    :target: https://pypi.org/project/vdf/    :alt: MIT License.. |coverage| image:: https://img.shields.io/coveralls/ValvePython/vdf/master.svg?style=flat    :target: https://coveralls.io/r/ValvePython/vdf?branch=master    :alt: Test coverage.. |sonar_maintainability| image:: https://sonarcloud.io/api/project_badges/measure?project=ValvePython_vdf&amp;metric=sqale_rating    :target: https://sonarcloud.io/dashboard?id=ValvePython_vdf    :alt: SonarCloud Rating.. |sonar_reliability| image:: https://sonarcloud.io/api/project_badges/measure?project=ValvePython_vdf&amp;metric=reliability_rating    :target: https://sonarcloud.io/dashboard?id=ValvePython_vdf    :alt: SonarCloud Rating.. |sonar_security| image:: https://sonarcloud.io/api/project_badges/measure?project=ValvePython_vdf&amp;metric=security_rating    :target: https://sonarcloud.io/dashboard?id=ValvePython_vdf    :alt: SonarCloud Rating.. |master_build| image:: https://github.com/ValvePython/vdf/workflows/Tests/badge.svg?branch=master    :target: https://github.com/ValvePython/vdf/actions?query=workflow%3A%22Tests%22+branch%3Amaster    :alt: Build status of master branch.. _DuplicateOrderedDict: https://github.com/rossengeorgiev/dota2_notebooks/blob/master/DuplicateOrderedDict_for_VDF.ipynb.. _hash randomization: https://docs.python.org/2/using/cmdline.html#envvar-PYTHONHASHSEED</longdescription>
</pkgmetadata>