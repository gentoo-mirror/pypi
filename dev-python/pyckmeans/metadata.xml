<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](/LICENSE)[![PyPI version](https://img.shields.io/pypi/v/pyckmeans?color=blue)](https://pypi.org/project/pyckmeans/)[![Anaconda-Server Badge](https://img.shields.io/conda/v/TankredO/pyckmeans?label=conda)](https://anaconda.org/tankredo/pyckmeans)[![Coverage Status](https://img.shields.io/coveralls/github/TankredO/pyckmeans)](https://coveralls.io/github/TankredO/pyckmeans?branch=main)[![DOI](https://zenodo.org/badge/361376094.svg)](https://zenodo.org/badge/latestdoi/361376094)# pyckmeanspyckmeans is a Python package for [Consensus K-Means](https://doi.org/10.1023/A:1023949509487) and [Weighted Ensemble Consensus of Random (WECR) K-Means](https://doi.org/10.1109/TKDE.2019.2952596) clustering, especially in the context of DNA sequence data. To evaluate the quality of clusterings, pyckmeans implements several internal validation metrics.In addition to the clustering functionality, it provides tools for working with DNA sequence data such as reading and writing of DNA alignment files, calculating genetic distances, and Principle Coordinate Analysis (PCoA) for dimensionality reduction.## Consensus K-Means[Consensus K-Means](https://doi.org/10.1023/A:1023949509487) is an unsupervised ensemble clustering algorithm, combining multiple K-Means clusterings, where each K-Means is trained on a subset of the data (random subset) and a subset of the the features (random subspace). The predicted cluster memberships of the single clusterings are combined to a consensus (or co-association) matrix, determining the number of times each pair of samples was clustered together over all clusterings. This matrix can be interpreted as similarity matrix and can be used to resolve the final consensus clustering by subjecting it to a last clustering step, e.g. hierarchical, or spectral clustering.## WECR K-Means[Weighted Ensemble Consensus of Random (WECR) K-Means](https://doi.org/10.1109/TKDE.2019.2952596) is a semi-supervised ensemble clustering algorithm. Similar to consensus K-Means, it is based on a collection of K-Means clusterings, which are each trained on a random subset of data and a random subspace of features. In addition, for each single clustering the number of clusters _k_ is also randomized. This library of clusterings is subjected to weighting function that integrates user-supplied must-link and must-not-link constraints, as well as an internal cluster validation criterion. The constraints represent the semi-supervised component of WECR K-Means: the user can provide prior knowledge considering the composition of the clusters. Must-link and must-not-link constraints imply that a pair of samples (observations, data points) is expected to be found in the same or different clusters, respectively. Based on the clusterings and the calculated weights, a weighted consensus (co-association) matrix is constructed, which is subjected to Cluster-based Similariry Partitioning (CSPA; e.g. hierarchical clustering) or spectral clustering to resolve the consensus clustering.## DocumentationSee pyckmeans' [RTD Documentation](https://pyckmeans.readthedocs.io/) for details.## Installationpyckmeans can be installed using pip, Conda, or from source.### pip```bashpip install pyckmeans```### Conda```bashconda install pyckmeans -c TankredO```### From SourceThe installation from source requires `git` and a c++ compiler.```bashgit clone https://github.com/TankredO/pyckmeanscd pyckmeanspip install .```## UsageExamples using the Python API:- [Consensus K-Means: Clustering a Data Matrix (Single K)](#ckmeans-data-single)- [Consensus K-Means: Clustering a Data Matrix (Multi K)](#ckmeans-data-multi)- [Consensus K-Means: Clustering Sequence Data](#ckmeans-sequence-multi)- [WECR K-Means: Clustering Sequence Data](#wecr-sequence)&lt;h3 id=&quot;ckmeans-data-single&quot;&gt;Consensus K-Means: Clustering a Data Matrix (Single K)&lt;/h3&gt;```pythonfrom pyckmeans import CKmeans# simulate dataset# 50 samples, 2 features, 3 true clustersimport sklearn.datasetsx, _ = sklearn.datasets.make_blobs(n_samples=50, n_features=2, centers=3, random_state=75)# apply Consensus K-Means# 3 clusters, 100 K-Means runs,# draw 80% of samples and 50% of features for each single K-Meansckm = CKmeans(k=3, n_rep=100, p_samp=0.8, p_feat=0.5)ckm.fit(x)ckm_res = ckm.predict(x)# plot consensus matrix and consensus clusteringfig = ckm_res.plot(figsize=(7,7))# consensus matrixckm_res.cmatrix# clustering metricsprint('Bayesian Information Criterion:', ckm_res.bic)print('Davies-Bouldin Index:', ckm_res.db)print('Silhouette Score:', ckm_res.sil)print('Calinski-Harabasz Index:', ckm_res.ch)# consensus clustersprint('Cluster Membership:', ckm_res.cl)```    Bayesian Information Criterion: 50.21824821939818    Davies-Bouldin Index: 0.2893792767901513    Silhouette Score: 0.7827738719266039    Calinski-Harabasz Index: 630.8235586596012    Cluster Membership: [0 2 1 0 2 2 1 0 2 1 0 0 2 0 2 2 1 1 1 1 0 1 2 2 2 2 1 0 2 2 1 0 1 1 0 0 0     1 0 1 2 1 2 2 1 0 0 0 0 1]![png](https://github.com/TankredO/pyckmeans/blob/main/docs/images/output_4_1.png?raw=true)&lt;h3 id=&quot;ckmeans-data-multi&quot;&gt;Consensus K-Means: Clustering a Data Matrix (Multi K)&lt;/h3&gt;The `MultiCKmeans` class allows to train multiple `CKmeans` objects a once.This is, for example, useful for exploring clustering for different values of _k_.```pythonfrom pyckmeans import MultiCKMeansimport sklearn.datasets# simulate dataset# 50 samples, 10 features, 3 true clustersx, _ = sklearn.datasets.make_blobs(n_samples=50, n_features=10, centers=3, random_state=44)# apply multiple Consensus K-Means for# k = 2, ..., 5# 100 K-Means runs per Consensus K-Means# draw 80% of the sample for each single K-Means# draw 50% of the features for each single K-Meansmckm = MultiCKMeans(k=[2, 3, 4, 5], n_rep=100, p_samp=0.8, p_feat=0.5)mckm.fit(x)mckm_res = mckm.predict(x)# clustering metricsprint('Metrics:')print(mckm_res.metrics)# plot clustering metrics against k# BIC, DB: lower is better# SIL, CH: higher is bettermckm_res.plot_metrics(figsize=(10,5))# get a single CKmeansResult                  0 |1| 2  3ckm_res_k3 = mckm_res.ckmeans_results[1] # k=[2, 3, 4, 5]# ...# see &quot;Clustering a Data Matrix (Single K)&quot;```    Metrics:       k       sil         bic        db          ch    0  2  0.574369  225.092100  0.646401   59.733498    1  3  0.788207  126.358519  0.302979  387.409107    2  4  0.563343  126.979355  1.214520  271.019424    3  5  0.339466  128.061382  1.698652  211.080143![png](https://github.com/TankredO/pyckmeans/blob/main/docs/images/output_6_1.png?raw=true)&lt;h3 id=&quot;ckmeans-sequence-multi&quot;&gt;Consensus K-Means: Clustering Sequence Data&lt;/h3&gt;```pythonfrom pyckmeans import MultiCKMeans, NucleotideAlignment, pcoafrom IPython.display import display# Set random seed for demonstrationimport numpynumpy.random.seed(0)# Load nucleotide alignment# Note: the file is available from# &quot;https://github.com/TankredO/pyckmeans/tree/main/docs/datasets/rhodanthemum_ct85_msl68.snps.phy&quot;aln = NucleotideAlignment.from_file('datasets/rhodanthemum_ct85_msl68.snps.phy')print('Nucleotide alignment:', aln)# Calculate Kimura 2-parameter distancesdst = aln.distance(distance_type='k2p')# Apply PCoA, including negative Eigentvalue correctionpcoa_res = pcoa(dst, correction='lingoes')# display Eigenvaluesprint('Eigenvalues:')display(pcoa_res.values)# Get Eigenvectors until the cumulative corrected Eigenvalues are &gt;= 0.8vectors = pcoa_res.get_vectors(    filter_by='eigvals_rel_corrected_cum',    filter_th=0.8,    out_format='pandas')# Apply Multi-K Consensus K-Meansmckm = MultiCKMeans(    k=range(2, 20),    n_rep=50,    p_samp=0.8,    p_feat=0.8)mckm.fit(vectors)mckm_res = mckm.predict(vectors)mckm_res.plot_metrics(figsize=(12, 7))# Select a 'good' K# At k values around 7, BIC, DB, and SIL have a (local) optimumckm_res_k7 = mckm_res.ckmeans_results[5]fig = ckm_res_k7.plot(figsize=(14,14))```    Nucleotide alignment: &lt;NucleotideAlignment; #samples: 108, #sites: 6752&gt;    Eigenvalues:&lt;div&gt;&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;  &lt;thead&gt;    &lt;tr style=&quot;text-align: right;&quot;&gt;      &lt;th&gt;&lt;/th&gt;      &lt;th&gt;eigvals&lt;/th&gt;      &lt;th&gt;eigvals_rel&lt;/th&gt;      &lt;th&gt;eigvals_rel_cum&lt;/th&gt;      &lt;th&gt;eigvals_rel_corrected&lt;/th&gt;      &lt;th&gt;eigvals_rel_corrected_cum&lt;/th&gt;    &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr&gt;      &lt;th&gt;0&lt;/th&gt;      &lt;td&gt;0.115972&lt;/td&gt;      &lt;td&gt;0.471458&lt;/td&gt;      &lt;td&gt;0.233986&lt;/td&gt;      &lt;td&gt;0.233986&lt;/td&gt;      &lt;td&gt;0.233986&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;th&gt;1&lt;/th&gt;      &lt;td&gt;0.039585&lt;/td&gt;      &lt;td&gt;0.160924&lt;/td&gt;      &lt;td&gt;0.317016&lt;/td&gt;      &lt;td&gt;0.083030&lt;/td&gt;      &lt;td&gt;0.317016&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;th&gt;2&lt;/th&gt;      &lt;td&gt;0.035079&lt;/td&gt;      &lt;td&gt;0.142604&lt;/td&gt;      &lt;td&gt;0.391140&lt;/td&gt;      &lt;td&gt;0.074125&lt;/td&gt;      &lt;td&gt;0.391140&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;th&gt;3&lt;/th&gt;      &lt;td&gt;0.017383&lt;/td&gt;      &lt;td&gt;0.070665&lt;/td&gt;      &lt;td&gt;0.430295&lt;/td&gt;      &lt;td&gt;0.039154&lt;/td&gt;      &lt;td&gt;0.430295&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;th&gt;4&lt;/th&gt;      &lt;td&gt;0.009831&lt;/td&gt;      &lt;td&gt;0.039965&lt;/td&gt;      &lt;td&gt;0.454525&lt;/td&gt;      &lt;td&gt;0.024230&lt;/td&gt;      &lt;td&gt;0.454525&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;th&gt;...&lt;/th&gt;      &lt;td&gt;...&lt;/td&gt;      &lt;td&gt;...&lt;/td&gt;      &lt;td&gt;...&lt;/td&gt;      &lt;td&gt;...&lt;/td&gt;      &lt;td&gt;...&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;th&gt;103&lt;/th&gt;      &lt;td&gt;-0.001325&lt;/td&gt;      &lt;td&gt;-0.005388&lt;/td&gt;      &lt;td&gt;0.998575&lt;/td&gt;      &lt;td&gt;0.001457&lt;/td&gt;      &lt;td&gt;0.998575&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;th&gt;104&lt;/th&gt;      &lt;td&gt;-0.001693&lt;/td&gt;      &lt;td&gt;-0.006881&lt;/td&gt;      &lt;td&gt;0.999654&lt;/td&gt;      &lt;td&gt;0.001079&lt;/td&gt;      &lt;td&gt;0.999654&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;th&gt;105&lt;/th&gt;      &lt;td&gt;-0.001884&lt;/td&gt;      &lt;td&gt;-0.007660&lt;/td&gt;      &lt;td&gt;1.000000&lt;/td&gt;      &lt;td&gt;0.000346&lt;/td&gt;      &lt;td&gt;1.000000&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;th&gt;106&lt;/th&gt;      &lt;td&gt;-0.002255&lt;/td&gt;      &lt;td&gt;-0.009168&lt;/td&gt;      &lt;td&gt;1.000000&lt;/td&gt;      &lt;td&gt;0.000000&lt;/td&gt;      &lt;td&gt;1.000000&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;th&gt;107&lt;/th&gt;      &lt;td&gt;-0.002430&lt;/td&gt;      &lt;td&gt;-0.009880&lt;/td&gt;      &lt;td&gt;1.000000&lt;/td&gt;      &lt;td&gt;0.000000&lt;/td&gt;      &lt;td&gt;1.000000&lt;/td&gt;    &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;108 rows × 5 columns&lt;/p&gt;&lt;/div&gt;![png](https://github.com/TankredO/pyckmeans/blob/main/docs/images/output_8_2.png?raw=true)![png](https://github.com/TankredO/pyckmeans/blob/main/docs/images/output_8_3.png?raw=true)&lt;h3 id=&quot;wecr-sequence&quot;&gt;WECR K-Means: Clustering Sequence Data&lt;/h3&gt;```pythonfrom pyckmeans import WECR, NucleotideAlignment, pcoa# Load nucleotide alignmentaln = NucleotideAlignment.from_file('datasets/rhodanthemum_ct85_msl68.snps.phy')# Calculate Kimura 2-parameter distancesdst = aln.distance(distance_type='k2p')# Apply PCoA, including negative Eigentvalue correctionpcoa_res = pcoa(dst, correction='lingoes')# Get Eigenvectors until the cumulative corrected Eigenvalues are &gt;= 0.8vectors = pcoa_res.get_vectors(    filter_by='eigvals_rel_corrected_cum',    filter_th=0.8,    out_format='pandas')# Apply WECR K-Meanswecr = WECR(    k=range(2, 20),    n_rep=1000,    p_samp=0.6,    p_feat=0.6,)wecr.fit(vectors)wecr_res = wecr.predict(vectors)# Plot clustering metrics for each kwecr_res.plot_metrics(figsize=(12, 7))# Select a 'good' K (e.g., 6, 7, 8) for the consensus clusteringwecr_res.plot(k=6, figsize=(14,14))cluster_membership = wecr_res.get_cl(k=6, with_names=True)print('cluster_membership:')print(cluster_membership)```    cluster_membership:    PP-R002-01         0    PP-R002-01-dupl    0    PP-R017-04         4    PP-R017-04-dupl    4    PP-R019-01         5                      ..    R044-02            3    R044-12            3    R045-02            0    R045-06            0    R045-25            0    Length: 108, dtype: int32![png](https://github.com/TankredO/pyckmeans/blob/main/docs/images/output_10_1.png?raw=true)![png](https://github.com/TankredO/pyckmeans/blob/main/docs/images/output_10_2.png?raw=true)</longdescription>
</pkgmetadata>