<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>============poetry2conda============.. image:: https://img.shields.io/pypi/v/poetry2conda.svg    :target: https://pypi.org/project/poetry2conda/.. image:: https://img.shields.io/pypi/l/poetry2conda.svg    :target: https://pypi.org/project/poetry2conda/.. image:: https://github.com/dojeda/poetry2conda/workflows/unit%20tests/badge.svg?branch=master    :target: https://github.com/dojeda/poetry2conda/actionsA script to convert a Python project declared on a pyproject.toml to a condaenvironment.This is not an attempt to move away from pyproject.toml to conda. It is a toolto help teams maintain a single file for dependencies when there arecollaborators that prefer regular Python/PyPI and others that prefer conda.Features--------- Set conda channels for each dependency.- Rename conda dependencies.- Convert tilde and caret dependencies to regular version specifiers.- Handle pure pip dependencies.Installation------------You will be able to install poetry2conda by running:.. code-block:: bash    $ pip install poetry2condaUsage-----The most straightforward use-case for poetry2conda is to convert a pyproject.tomlthat uses poetry. This can be achieved by adding the following section to yourpyproject.toml:.. code-block:: toml    [tool.poetry.dependencies]    foo = &quot;^1.2.3&quot;    # ...    [tool.poetry2conda]    name = &quot;some-name-env&quot;Then, use the command line to create a conda environment file:.. code-block:: bash    $ poetry2conda pyproject.toml environment.yaml    # or if you want to see the contents but not write the file:    $ poetry2conda pyproject.toml -This will create a yaml file like:.. code-block:: yaml    name: some-name-env    dependencies:      - foo&gt;=1.2.3,&lt;2.0.0      # ...If you want to include extras in the created environment, you can usethe `--extra` or `-E` arguments. They can be used multiple times tospecify multiple extrasIf you also want to include development dependencies, the `--dev`argument will do that.Sometimes, a dependency is handled differently on conda. For this case,the section ``tool.poetry2conda.dependencies`` can be used to inform on specificchannels, or package names.For example, if a dependency should be installed from a specific channel, likeconda-forge, declare it as follows:.. code-block:: toml    [tool.poetry.dependencies]    foo = &quot;^1.2.3&quot;    # ...    [tool.poetry2conda]    name = &quot;my-env-with-channels&quot;    [tool.poetry2conda.dependencies]    foo = { channel = &quot;conda-forge&quot; }After conversion, the yaml file will look like:.. code-block:: yaml    name: my-env-with-channels    dependencies:      - conda-forge::foo&gt;=1.2.3,&lt;2.0.0      # ...Sometimes, a package on PyPI does not have the same name on conda(why? why not? confusion!). For example, ``tables`` and ``pytables``,``docker`` and ``docker-py``. To change the name when converting to a condaenvironment file, you can set it as:.. code-block:: toml    [tool.poetry.dependencies]    docker = &quot;^4.2.0&quot;    # ...    [tool.poetry2conda]    name = &quot;another-example&quot;    [tool.poetry2conda.dependencies]    docker = { name = &quot;docker-py&quot; }The converted yaml file will look like:.. code-block:: yaml    name: another-example    dependencies:      - docker-py&gt;=4.2.0,&lt;5.0.0      # ...When a package does not exist on conda, declare it on the pip channel:.. code-block:: toml    [tool.poetry.dependencies]    quetzal-client = &quot;^0.5.2&quot;    # ...    [tool.poetry2conda]    name = &quot;example-with-pip&quot;    [tool.poetry2conda.dependencies]    quetzal-client = { channel = &quot;pip&quot; }Which would give:.. code-block:: yaml    name: example-with-pip    dependencies:      - pip      - pip:        - quetzal-client&gt;=0.5.2,&lt;0.6.0Not all poetry dependency types are supported, only regular ones and gitdependencies:.. code-block:: toml    [tool.poetry.dependencies]    my_private_lib = { git = &quot;https://github.com/company/repo.git&quot;, tag = &quot;v1.2.3&quot; }    # ...    [tool.poetry2conda]    name = &quot;example-with-git&quot;This is handled like a pure pip dependency:.. code-block:: yaml    name: example-with-git    dependencies:      - pip      - pip:        - git+https://github.com/company/repo.git@v1.2.3#egg=my_private_libPackages with extras are supported on a pyproject.toml, but conda does notsupport extras. For the moment, this information is dropped:.. code-block:: toml    [tool.poetry.dependencies]    dask = { extras = [&quot;bag&quot;], version = &quot;^2.15.0&quot; }    # ...    [tool.poetry2conda]    name = &quot;example-with-extras&quot;Which will be translated to:.. code-block:: yaml    name: example-with-extras    dependencies:      - dask&gt;=2.15.0,&lt;3.0.0Sometimes (very rarely) a package is not available on PyPI but conda does haveit. Poetry can handle this with a git dependency and poetry2conda can keepthese as pip installable packages. But if you prefer to transform it to itsconda package, use the following configuration:.. code-block:: toml    [tool.poetry.dependencies]    weird = { git = &quot;https://github.com/org/weird.git&quot;, tag = &quot;v2.3&quot; }    [tool.poetry2conda]    name = &quot;strange-example&quot;    [tool.poetry2conda.dependencies]    weird = { name = &quot;bob&quot;, channel = &quot;conda-forge&quot;, version = &quot;^2.3&quot; }  # You need to declare the version hereWhich will be translated to:.. code-block:: yaml    name: strange-example    dependencies:      - conda-forge::bob&gt;=2.3.0,&lt;3.0.0Contribute----------- Issue Tracker: https://github.com/dojeda/poetry2conda/issues- Source Code: https://github.com/dojeda/poetry2condaLicense-------The project is licensed under the BSD license.Why poetry2conda?-----------------This part is an opinion.Python is a great language with great libraries, but environment management hasbeen notoriously bad. Bad enough to have its own `XKCD comic &lt;https://xkcd.com&gt;`_:.. image:: https://imgs.xkcd.com/comics/python_environment.png  :alt: Python environment bankrupcty.  :width: 50%  :align: centerThere is a lack of agreement on how and where to declare dependencies.``setup.py`` contains abstract dependencies (but only apply to packages), and``requirements.txt`` file has concrete dependencies(with version specifications). But development dependencies go somewhere else in``requirements-dev.txt`` and testing dependencies in ``requirements-test.txt``.Because dependencies are now declared in two or moreseparate files, this is a burden. Some people read and parse ``requirements-*.txt``files on their ``setup.py``. Others say that this is a bad practice.Then, there is the environment management problem. ``virtualenv`` was created along time ago to isolate environments so you one does end up with thedependencies of another project. I do not know why, this was not enough,``venv`` was created. And then some other ones that can handle different Pythonversions.At some point on this story, a new generation of clever developers broughtideas from other package managers to improve on how packages, environments, etc.should be managed. ``requirements.txt`` were replaced (in theory) by``Pipfile`` and ``Pipfile.lock``. New tools were created to manage packages andenvironments, such as Pipenv and poetry, tackling even more problems such asvirtual environments, Python versions, and many other distribution problems.Dependencies, environemnts, package managers... this confused a lot of people(including me).Eventually, I decided to give the`PEP 5128 &lt;https://www.python.org/dev/peps/pep-0518/&gt;`_ and poetry a try.It was not easy: a new markup language, TOML (Tom's Obvious Markup Language,which has this strange old man smell, like naphtalene, because it looks likea new INI file). I encountered many new problems with poetry.I abandoned many times but always came back because at least it helps medefine my dependencies in only file. After two or three tries, I decided tomigrate my code base to poetry and drop the requirement and setup files.But wait...To add a bit of entropy to the Python situation, a company called ContinuumAnalytics (later renamed Anaconda) created a *different* Python distribution and package management, Anaconda (and its less obese brother, Miniconda).I think they were tired of the current Python situation, and they were right.They replaced all of the virtual environment problems with their ownenvironments and they distribute their own packages without using the currentPython package authority, PyPI. This workedwell, in my opinion, because Anaconda distributes compiled versions of somepackages, giving massive performance improvements in some cases (like NumPy),because it is easier to setup on Windows,but more importantly because Anaconda was targeted for the*scientific computing community* (e.g. data scientists).Cool! I should migrate to conda then! Alas, some people (like me),who used Python before Anaconda ever existed, tried it and got confused.I have three main problems with conda: First, not all packages are distributedby Anaconda, so you eventually need to mix conda and pip to work together. It isdifficult to summarize how many problems I have encountered when mixing thesetwo. Second, every single day I use conda, I ran into problems: maybe somethingwas installed on the root environment (this also happens without conda),maybe I wrote a command the wrong way (errors are often misleading),maybe the command syntax changed recently,maybe my network is slow and that explains why adding a new dependency takesages (among other examples). I can go on. Third, I said to myself, if you aregoing to use conda, you should go all the way and write packages for their condarepositories. Oh boy, I triedthat and it is very complicated and the documentation is so confusing.I eventually managed to do it, but I have PTSD.So to summarize, I am not convinced by Anaconda, buy I have colleagues orcollaborators that do use it. I don't understand why (yes, apparently tensorflowis faster with anaconda, sigh...). But I have to admit that conda is not goingto go anywhere.This leaves me in an uncomfortable situation: I want to use poetry, but I don'tlike forcing others to use it to. And by others I mean my conda friends. Isearched for some tool to auto-convert from one to another. Dephell does this,but it does not address all of my use-cases. There is an open issue for someof them. I saw that changing dephell was going to be a complicated endeavor,so I decided to just write a new tool to do it.So that's why poetry2conda exists.</longdescription>
</pkgmetadata>