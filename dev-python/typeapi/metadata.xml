<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># typeapi[![Python](https://github.com/NiklasRosenstein/python-typeapi/actions/workflows/python.yml/badge.svg)](https://github.com/NiklasRosenstein/python-typeapi/actions/workflows/python.yml)  [PEP484]: https://peps.python.org/pep-0484/  [PEP585]: https://peps.python.org/pep-0585/  [PEP604]: https://peps.python.org/pep-0604/__Compatibility__: Python 3.6.3+The `typeapi` package provides an object-oriented interface for introspecting [PEP484][] type hints at runtime,including forward references that make use of the more recent [PEP585][] and [PEP604][] type hint features inPython versions that don't natively support them.The main API of this module is comprised of:* `typeapi.TypeHint()` &amp;ndash; A class to parse low-level type hints and present them in a consistent, object-oriented API.* `typeapi.get_annotations()` &amp;ndash; Retrieve an object's `__annotations__` with support for evaluating future type hints ([PEP585][], [PEP604][]).The following kinds of type hints are currently supported:| Concrete type | Description | Added in || ------------- | ----------- | -------- || `ClassTypeHint` | For any normal or generic type as well as `typing.Any`. Provides access to the underlying type, the type arguments and parameters, if any. | 1.0.0 || `UnionTypeHint` | Represents `Union` type hint and gives access to the union members. | 1.0.0 || `LiteralTypeHint` | Represents a `Literal` type hint and gives access to the literal values. | 1.0.0 || `AnnotatedTypeHint` | Represents an `Annotated` type hint and gives access to the annotated type as well as the metadata. | 1.0.0 || `TypeVarTypeHint` | Represents a `TypeVar` type hint and gives an interface to access the variable's metadata (such as constarints, variance, ...). | 1.0.0 || `ForwardRefTypeHint` | Represents a forward reference. Can be evaluated in Python 3.6+ even if it contains [PEP585][] and [PEP604][] expressions. &lt;sup&gt;1)&lt;/sup&gt; | 1.0.0, future support in 1.3.0 || `TupleTypeHint` | Reperesents a `Tuple` type hint, allowing you to differentiate between repeated and explicitly sized tuples. | 1.2.0 |&lt;sup&gt;1)&lt;/sup&gt; New-style type union evaluation will continue to return a `typing.Union`, even if the same syntaxevaluated natively by Python 3.10+ results in a `types.UnionType`.## ExamplesInspect a `List[int]` type hint:```py# cat &lt;&lt;EOF | python -from typeapi import ClassTypeHint, TypeHintfrom typing import Listhint = TypeHint(List[int])assert isinstance(hint, ClassTypeHint)assert hint.type is listitem_hint = hint[0]assert isinstance(item_hint, ClassTypeHint)assert item_hint.type is int```Retrieve the metadata from an `Annotated[...]` type hint:```py# cat &lt;&lt;EOF | python -from typeapi import AnnotatedTypeHint, ClassTypeHint, TypeHintfrom typing_extensions import Annotatedhint = TypeHint(Annotated[int, 42])assert isinstance(hint, AnnotatedTypeHint)assert hint.type is intassert hint.metadata == (42,)sub_hint = hint[0]assert isinstance(sub_hint, ClassTypeHint)assert sub_hint.type is int```Parameterize one type hint with the parameterization of a generic alias:```py# cat &lt;&lt;EOF | python -from dataclasses import dataclassfrom typeapi import ClassTypeHint, TypeHintfrom typing import Generic, TypeVarfrom typing_extensions import AnnotatedT = TypeVar(&quot;T&quot;)@dataclassclass MyGeneric(Generic[T]):  value: Thint = TypeHint(MyGeneric[int])assert isinstance(hint, ClassTypeHint)assert hint.get_parameter_map() == {T: int}member_hint = TypeHint(T).parameterize(hint.get_parameter_map())assert isinstance(member_hint, ClassTypeHint)assert member_hint.type is int```Evaluate forward references with `get_annotations()`:```py# cat &lt;&lt;EOF | python -from typeapi import get_annotationsfrom typing import Optionalfrom sys import version_infoclass MyType:  a: &quot;str | None&quot;annotations = get_annotations(MyType)if version_info[:2] &lt; (3, 10):  assert annotations == {&quot;a&quot;: Optional[str]}else:  assert annotations == {&quot;a&quot;: str | None}```Evaluating forward references with the `TypeHint` API:```py# cat &lt;&lt;EOF | python -from typeapi import ClassTypeHint, ForwardRefTypeHint, TypeHintMyVector = &quot;list[MyType]&quot;class MyType:  passhint = TypeHint(MyVector).evaluate(globals())print(hint)  # TypeHint(typing.List[__main__.MyType])assert isinstance(hint, ClassTypeHint)assert hint.type is listitem_hint = hint[0]assert isinstance(item_hint, ClassTypeHint)assert item_hint.type is MyType```</longdescription>
</pkgmetadata>