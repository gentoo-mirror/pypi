<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># orthauth[![PyPI version](https://badge.fury.io/py/orthauth.svg)](https://pypi.org/project/orthauth/)[![Build Status](https://travis-ci.org/tgbugs/orthauth.svg?branch=master)](https://travis-ci.org/tgbugs/orthauth)[![Coverage Status](https://coveralls.io/repos/github/tgbugs/orthauth/badge.svg?branch=master)](https://coveralls.io/github/tgbugs/orthauth?branch=master)A library to separate configuration and authentication from program logic# THIS IS NOT ENCRYPTED# THIS IS NOT A PASSWORD MANAGER# THIS IS NOT A SECURE SECRET STORAGE SYSTEM# YOU CAN SHOOT YOURSELF IN THE FOOT WITH THISThere is **NO encryption** for secrets stored using orthauth.Orthauth can source credientials from a variety of sourcesbut it is **INTENTIONALLY INSECURE**.If you do not understand the [use case](#use-case) for this as well as therisks if used outside a secure environment then DO NOT USE IT.No one can help you if you get pwnd.## Use caseThe primary use case for `orthauth` is to keep api keys from leaking intosource code and winding up in public repositories. `orthauth` does not provideoperational security for any auth store that it uses. It is up to the user tosecure those and the systems they reside on as they see fit.While `orthauth` attemts to prevent secrets from leaking via debug messagesor logging, it doesn't know anything about the secretness of the values itreturns, and once it has returned that value, it is up to the consuming codeto prevent the contents of the value from leaking.`orthauth` is indented to unify two common ways managing configurationvariables and credentials: setting them environment variables, and includingthem in a plain text file with permissions set to `0600` (and preferably keptin a folder set to `0700`).For example running a program in the following way`export API_KEY=lolplzdonotstealthis; ./my-script-that-needs-the-key`or using a file like `~/.pgpass` or emacs `.authinfo`. Note thatpgpass probably shouldn't be a source for most python implementationsbecause libraries like psycopg2 are able to read it directly. However inother languages that do not have a library that supports reading from pgpassdirectly, then pgpass would be a useful source.By making it possible to provide credentials seemlessley in multiple waysthe hope is to reduce the use of different solutions in different environmentswithout incuring the massive complexity of maintaining a managed authenticationinfrasturcture.## Approach1. Decorators  2. A layer of indirection between names in a code base and config/secrets structure.3. Be clear about what should be considered public information. Thus prevent anythingstored as a secret from being used as a key to find another secret.4. Bare minimum to store static configuration information, anything more shouldbe implemented in the language consuming the config, not in the config.## Currently supported config formats| Format                     | Support         | Install                      || -------------------------- | --------------- | ---------------------------- || json                       | builtin         | `pip install orthauth`       || python dictionary literals | builtin         | `pip install orthauth`       || yaml                       | requires pyyaml | `pip install orthauth[yaml]` |## Usage```pythonimport orthauth as oaauth = oa.AuthConfig('path/to/config.yaml')@auth.tangential_init('api_key', 'some-service-api-key')class ThatNeedsAuth:    &quot;&quot;&quot; needs authenticated connection to some-service &quot;&quot;&quot;tna = ThatNeedsAuth()print(tna.api_key)```Haven't been scared off yet?See the [developer guide](./docs/guide.org) for more examples.</longdescription>
</pkgmetadata>