<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Query Helper for Elasticsearch or OpenSearch[![Pypi](https://img.shields.io/pypi/v/fastapi-elasticsearch.svg)](https://pypi.org/project/fastapi-elasticsearch/)This is a helper library for creating elasticsearch or opensearch query proxies using [FastAPI](https://fastapi.tiangolo.com/).```pythonfrom fastapi_elasticsearch import ElasticsearchAPIQueryBuilder# Create a new query_builder for the endpoint.query_builder = ElasticsearchAPIQueryBuilder()# Decorate a function as a filter.# The filter can declare parameters.@query_builder.filter()def filter_category(c: Optional[List[str]] = Query([],                                             description=&quot;Category name to filter results.&quot;)):    return {        &quot;terms&quot;: {            &quot;category&quot;: c        }    } if len(c) &gt; 0 else None# Then use the query_builder in your endpoint.@app.get(&quot;/search&quot;)async def search(        es: Elasticsearch = Depends(get_elasticsearch),        query_body: Dict = Depends(query_builder.build())) -&gt; JSONResponse:    return es.search(        body=query_body,        index=index_name    )```The swagger API will result in:![Category Filter](https://github.com/euler-io/fastapi-elasticsearch/blob/main/docs/category_filter.png?raw=true)The resulting query will be like this:```json{  &quot;query&quot;: {    &quot;bool&quot;: {      &quot;filter&quot;: [        {          &quot;terms&quot;: {            &quot;category&quot;: [              &quot;the-category&quot;            ]          }        }      ]    }  },  &quot;size&quot;: 10,  &quot;from&quot;: 0}```To use OpenSearch, simply change the client.```pythonfrom fastapi_elasticsearch import ElasticsearchAPIQueryBuilderfrom opensearchpy import OpenSearch...@app.get(&quot;/search&quot;)async def search(        os: OpenSearch = Depends(get_opensearch),        query_body: Dict = Depends(query_builder.build())) -&gt; JSONResponse:    return os.search(        body=query_body,        index=index_name    )...# Create a new query_builder for the endpoint.query_builder = ElasticsearchAPIQueryBuilder()```To control the scoring use a matcher.```python# Or decorate a function as a matcher# (will contribute to the query scoring).# Parameters can also be used.@query_builder.matcher()def match_fields(q: Optional[str] = Query(None)):    return {        &quot;multi_match&quot;: {            &quot;query&quot;: q,            &quot;fuzziness&quot;: &quot;AUTO&quot;,            &quot;fields&quot;: [                &quot;name^2&quot;,                &quot;description&quot;            ]        }    } if q is not None else None```The swagger API will result in:![Category Filter](https://github.com/euler-io/fastapi-elasticsearch/blob/main/docs/matchers.png?raw=true)The resulting query will be like this:```json{  &quot;query&quot;: {    &quot;bool&quot;: {      &quot;should&quot;: [        {          &quot;multi_match&quot;: {            &quot;query&quot;: &quot;bob&quot;,            &quot;fuzziness&quot;: &quot;AUTO&quot;,            &quot;fields&quot;: [              &quot;name^2&quot;,              &quot;description&quot;            ]          }        }      ],      &quot;minimum_should_match&quot;: 1    }  },  &quot;size&quot;: 10,  &quot;from&quot;: 0}```To control the ordering, it is possible to annotate a function as sorter.```pythonclass Direction(str, Enum):    asc = &quot;asc&quot;    desc = &quot;desc&quot;# Decorate a function as a sorter.# Parameters can be declared.@query_builder.sorter()def sort_by(direction: Optional[Direction] = Query(None)):    return {        &quot;name&quot;: direction    } if direction is not None else None```The swagger API will result in:![Category Filter](https://github.com/euler-io/fastapi-elasticsearch/blob/main/docs/sorter.png?raw=true)The resulting query will be like this:```json{  &quot;query&quot;: {    &quot;match_all&quot;: {}  },  &quot;size&quot;: 10,  &quot;from&quot;: 0,  &quot;sort&quot;: [    {      &quot;name&quot;: &quot;asc&quot;    }  ]}```To add highlight functionality, it is possible to annotate a function as highlighter.```python# Decorate a function as a highlighter.# Parameters can also be declared.@query_builder.highlighter()def highlight(q: Optional[str] = Query(None,                                       description=&quot;Query to match the document text.&quot;),              h: bool = Query(False,                              description=&quot;Highlight matched text and inner hits.&quot;)):    return {        &quot;name&quot;: {            &quot;fragment_size&quot;: 256,            &quot;number_of_fragments&quot;: 1        }    } if q is not None and h else None```The swagger API will result in:![Category Filter](https://github.com/euler-io/fastapi-elasticsearch/blob/main/docs/highlighter.png?raw=true)The resulting query will be like this:```json{  &quot;query&quot;: {    &quot;bool&quot;: {      &quot;should&quot;: [        {          &quot;multi_match&quot;: {            &quot;query&quot;: &quot;bob&quot;,            &quot;fuzziness&quot;: &quot;AUTO&quot;,            &quot;fields&quot;: [              &quot;name^2&quot;            ]          }        }      ],      &quot;minimum_should_match&quot;: 1    }  },  &quot;size&quot;: 10,  &quot;from&quot;: 0,  &quot;highlight&quot;: {    &quot;fields&quot;: {      &quot;name&quot;: {        &quot;fragment_size&quot;: 256,        &quot;number_of_fragments&quot;: 1      }    }  }}```Now, a complete example:```pythonapp = FastAPI()query_builder = ElasticsearchAPIQueryBuilder()@query_builder.filter()def filter_items():    return {        &quot;term&quot;: {            &quot;join_field&quot;: &quot;item&quot;        }    }@query_builder.filter()def filter_category(c: Optional[List[str]] = Query([],                                                   description=&quot;Category name to filter results.&quot;)):    return {        &quot;terms&quot;: {            &quot;category&quot;: c        }    } if len(c) &gt; 0 else None@query_builder.matcher()def match_fields(q: Optional[str] = Query(None,                                          description=&quot;Query to match the document text.&quot;)):    return {        &quot;multi_match&quot;: {            &quot;query&quot;: q,            &quot;fuzziness&quot;: &quot;AUTO&quot;,            &quot;fields&quot;: [                &quot;name^2&quot;,            ]        }    } if q is not None else None@query_builder.matcher()def match_fragments(q: Optional[str] = Query(None,                                             description=&quot;Query to match the document text.&quot;),                    h: bool = Query(False,                                    description=&quot;Highlight matched text and inner hits.&quot;)):    if q is not None:        matcher = {            &quot;has_child&quot;: {                &quot;type&quot;: &quot;fragment&quot;,                &quot;score_mode&quot;: &quot;max&quot;,                &quot;query&quot;: {                    &quot;bool&quot;: {                        &quot;minimum_should_match&quot;: 1,                        &quot;should&quot;: [                            {                                &quot;match&quot;: {                                    &quot;content&quot;: {                                        &quot;query&quot;: q,                                        &quot;fuzziness&quot;: &quot;auto&quot;                                    }                                }                            },                            {                                &quot;match_phrase&quot;: {                                    &quot;content&quot;: {                                        &quot;query&quot;: q,                                        &quot;slop&quot;: 3,                                        &quot;boost&quot;: 50                                    }                                }                            },                        ]                    }                }            }        }        if h:            matcher[&quot;has_child&quot;][&quot;inner_hits&quot;] = {                &quot;size&quot;: 1,                &quot;_source&quot;: &quot;false&quot;,                &quot;highlight&quot;: {                    &quot;fields&quot;: {                        &quot;content&quot;: {                            &quot;fragment_size&quot;: 256,                            &quot;number_of_fragments&quot;: 1                        }                    }                }            }        return matcher    else:        return Noneclass Direction(str, Enum):    asc = &quot;asc&quot;    desc = &quot;desc&quot;@query_builder.sorter()def sort_by(direction: Optional[Direction] = Query(None)):    return {        &quot;name&quot;: direction    } if direction is not None else None@query_builder.highlighter()def highlight(q: Optional[str] = Query(None,                                       description=&quot;Query to match the document text.&quot;),              h: bool = Query(False,                              description=&quot;Highlight matched text and inner hits.&quot;)):    return {        &quot;name&quot;: {            &quot;fragment_size&quot;: 256,            &quot;number_of_fragments&quot;: 1        }    } if q is not None and h else None@app.get(&quot;/search&quot;)async def search(query_body: Dict = Depends(query_builder.build())) -&gt; JSONResponse:    return es.search(        body=query_body,        index=index_name    )```Also it is possible to customize the generated query body using the decorator search_builder.```pythonfrom typing import List, Dict@query_builder.search_builder()def build_search_body(size: int = 10,                      start_from: int = 0,                      source: Union[List, Dict, str] = None,                      minimum_should_match: int = 1,                      filters: List[Dict] = [],                      matchers: List[Dict] = [],                      highlighters: List[Dict] = [],                      sorters: List[Dict] = []) -&gt; Dict:    return {        &quot;query&quot;: {            ...        },        ...    }```Adopt this project: if you like and want to adopt it, talk to me.</longdescription>
</pkgmetadata>