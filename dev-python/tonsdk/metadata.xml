<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># TONsdk[![PyPI](https://img.shields.io/pypi/v/tonsdk?color=blue)](https://pypi.org/project/tonsdk/)[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/tonsdk)](https://pypi.org/project/tonsdk/)[![Downloads](https://static.pepy.tech/badge/tonsdk)](https://pepy.tech/project/tonsdk)## DescriptionThis low-level Python library allows you to work with the [TON blockchain](https://ton.org/).### Notes- tonsdk/provider part is dirty.## How to install```bashpip install tonsdk```## How to useYou can find examples in [examples](https://github.com/tonfactory/tonsdk/tree/master/examples) folder## General usage examples### Create mnemonic, init wallet class, create external message to deploy the wallet```pythonfrom tonsdk.contract.wallet import WalletVersionEnum, Walletsfrom tonsdk.utils import bytes_to_b64strfrom tonsdk.crypto import mnemonic_newwallet_workchain = 0wallet_version = WalletVersionEnum.v3r2wallet_mnemonics = mnemonic_new()_mnemonics, _pub_k, _priv_k, wallet = Wallets.from_mnemonics(    wallet_mnemonics, wallet_version, wallet_workchain)query = wallet.create_init_external_message()base64_boc = bytes_to_b64str(query[&quot;message&quot;].to_boc(False))print(&quot;&quot;&quot;Mnemonic: {}Raw address: {}Bounceable, url safe, user friendly address: {}Base64boc to deploy the wallet: {}&quot;&quot;&quot;.format(wallet_mnemonics,           wallet.address.to_string(),           wallet.address.to_string(True, True, True),           base64_boc))```### Transfer NFT &amp; Jettons by creating a transfer message from an owner wallet```pythonfrom tonsdk.contract.token.nft import NFTItemfrom tonsdk.contract.token.ft import JettonWalletfrom tonsdk.utils import Address, to_nanobody = NFTItem().create_transfer_body(    Address(&quot;New Owner Address&quot;))query = wallet.create_transfer_message(    &quot;NFT Item Address&quot;,    to_nano(0.05, &quot;ton&quot;),    0,  # owner wallet seqno    payload=body)nft_boc = bytes_to_b64str(query[&quot;message&quot;].to_boc(False))body = JettonWallet().create_transfer_body(    Address(&quot;Destination address&quot;),    to_nano(40000, &quot;ton&quot;)  # jettons amount)query = wallet.create_transfer_message(    &quot;Jetton Wallet Address&quot;,    to_nano(0.05, &quot;ton&quot;),    0,  # owner wallet seqno    payload=body)jettons_boc = bytes_to_b64str(query[&quot;message&quot;].to_boc(False))print(&quot;&quot;&quot;Base64boc to transfer the NFT item: {}Base64boc to transfer the jettons: {}&quot;&quot;&quot;.format(nft_boc, jettons_boc))```### Clients usage example (dirty)*Note - to use these clients you should install tvm_valuetypes and aiohttp packages*```pythonfrom abc import ABC, abstractmethodimport asyncioimport aiohttpfrom tvm_valuetypes import serialize_tvm_stackfrom tonsdk.provider import ToncenterClient, SyncTonlibClient, prepare_address, address_statefrom tonsdk.utils import TonCurrencyEnum, from_nanofrom tonsdk.boc import Cellclass AbstractTonClient(ABC):    @abstractmethod    def _run(self, to_run, *, single_query=True):        raise NotImplemented    def get_address_information(self, address: str,                                currency_to_show: TonCurrencyEnum = TonCurrencyEnum.ton):        return self.get_addresses_information([address], currency_to_show)[0]    def get_addresses_information(self, addresses,                                  currency_to_show: TonCurrencyEnum = TonCurrencyEnum.ton):        if not addresses:            return []        tasks = []        for address in addresses:            address = prepare_address(address)            tasks.append(self.provider.raw_get_account_state(address))        results = self._run(tasks, single_query=False)        for result in results:            result[&quot;state&quot;] = address_state(result)            if &quot;balance&quot; in result:                if int(result[&quot;balance&quot;]) &lt; 0:                    result[&quot;balance&quot;] = 0                else:                    result[&quot;balance&quot;] = from_nano(                        int(result[&quot;balance&quot;]), currency_to_show)        return results        def seqno(self, addr: str):        addr = prepare_address(addr)        result = self._run(self.provider.raw_run_method(addr, &quot;seqno&quot;, []))        if 'stack' in result and ('@type' in result and result['@type'] == 'smc.runResult'):            result['stack'] = serialize_tvm_stack(result['stack'])        return result    def send_boc(self, boc: Cell):        return self._run(self.provider.raw_send_message(boc))class TonCenterTonClient(AbstractTonClient):    def __init__(self):        self.loop = asyncio.get_event_loop()        self.provider = ToncenterClient(base_url=&quot;https://testnet.toncenter.com/api/v2/&quot;,                                        api_key=&quot;eb542b65e88d2da318fb7c163b9245e4edccb2eb8ba11cabda092cdb6fbc3395&quot;)    def _run(self, to_run, *, single_query=True):        try:            return self.loop.run_until_complete(                self.__execute(to_run, single_query))        except Exception:  # ToncenterWrongResult, asyncio.exceptions.TimeoutError, aiohttp.client_exceptions.ClientConnectorError            raise    async def __execute(self, to_run, single_query):        timeout = aiohttp.ClientTimeout(total=5)        async with aiohttp.ClientSession(timeout=timeout) as session:            if single_query:                to_run = [to_run]            tasks = []            for task in to_run:                tasks.append(task[&quot;func&quot;](                    session, *task[&quot;args&quot;], **task[&quot;kwargs&quot;]))            return await asyncio.gather(*tasks)class TonLibJsonTonClient(AbstractTonClient):    def __init__(self):        self.loop = asyncio.get_event_loop()        self.provider = SyncTonlibClient(config=&quot;./.tonlibjson/testnet.json&quot;,                                         keystore=&quot;./.tonlibjson/keystore&quot;,                                         cdll_path=&quot;./.tonlibjson/linux_libtonlibjson.so&quot;)  # or macos_libtonlibjson.dylib        self.provider.init()    def _run(self, to_read, *, single_query=True):        try:            if not single_query:                queries_order = {query_id: i for i,                                 query_id in enumerate(to_read)}                return self.provider.read_results(queries_order)            else:                return self.provider.read_result(to_read)        except Exception:  # TonLibWrongResult, TimeoutError            raise# create a client instanceclient = TonCenterTonClient()# use client to get any addr informationaddr_info = client.get_address_information(    &quot;EQAhE3sLxHZpsyZ_HecMuwzvXHKLjYx4kEUehhOy2JmCcHCT&quot;)# get your wallet seqnoseqno = client.seqno(wallet.address.to_string())# send any bocclient.send_boc(nft_boc)```</longdescription>
</pkgmetadata>