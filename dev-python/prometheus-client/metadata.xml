<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Prometheus Python ClientThe official Python client for [Prometheus](https://prometheus.io).## Three Step Demo**One**: Install the client:```pip install prometheus-client```**Two**: Paste the following into a Python interpreter:```pythonfrom prometheus_client import start_http_server, Summaryimport randomimport time# Create a metric to track time spent and requests made.REQUEST_TIME = Summary('request_processing_seconds', 'Time spent processing request')# Decorate function with metric.@REQUEST_TIME.time()def process_request(t):    &quot;&quot;&quot;A dummy function that takes some time.&quot;&quot;&quot;    time.sleep(t)if __name__ == '__main__':    # Start up the server to expose the metrics.    start_http_server(8000)    # Generate some requests.    while True:        process_request(random.random())```**Three**: Visit [http://localhost:8000/](http://localhost:8000/) to view the metrics.From one easy to use decorator you get:  * `request_processing_seconds_count`: Number of times this function was called.  * `request_processing_seconds_sum`: Total amount of time spent in this function.Prometheus's `rate` function allows calculation of both requests per second,and latency over time from this data.In addition if you're on Linux the `process` metrics expose CPU, memory andother information about the process for free!## Installation```pip install prometheus-client```This package can be found on[PyPI](https://pypi.python.org/pypi/prometheus_client).## InstrumentingFour types of metric are offered: Counter, Gauge, Summary and Histogram.See the documentation on [metric types](http://prometheus.io/docs/concepts/metric_types/)and [instrumentation best practices](https://prometheus.io/docs/practices/instrumentation/#counter-vs-gauge-summary-vs-histogram)on how to use them.### CounterCounters go up, and reset when the process restarts.```pythonfrom prometheus_client import Counterc = Counter('my_failures', 'Description of counter')c.inc()     # Increment by 1c.inc(1.6)  # Increment by given value```If there is a suffix of `_total` on the metric name, it will be removed. Whenexposing the time series for counter, a `_total` suffix will be added. This isfor compatibility between OpenMetrics and the Prometheus text format, as OpenMetricsrequires the `_total` suffix.There are utilities to count exceptions raised:```python@c.count_exceptions()def f():  passwith c.count_exceptions():  pass# Count only one type of exceptionwith c.count_exceptions(ValueError):  pass```### GaugeGauges can go up and down.```pythonfrom prometheus_client import Gaugeg = Gauge('my_inprogress_requests', 'Description of gauge')g.inc()      # Increment by 1g.dec(10)    # Decrement by given valueg.set(4.2)   # Set to a given value```There are utilities for common use cases:```pythong.set_to_current_time()   # Set to current unixtime# Increment when entered, decrement when exited.@g.track_inprogress()def f():  passwith g.track_inprogress():  pass```A Gauge can also take its value from a callback:```pythond = Gauge('data_objects', 'Number of objects')my_dict = {}d.set_function(lambda: len(my_dict))```### SummarySummaries track the size and number of events.```pythonfrom prometheus_client import Summarys = Summary('request_latency_seconds', 'Description of summary')s.observe(4.7)    # Observe 4.7 (seconds in this case)```There are utilities for timing code:```python@s.time()def f():  passwith s.time():  pass```The Python client doesn't store or expose quantile information at this time.### HistogramHistograms track the size and number of events in buckets.This allows for aggregatable calculation of quantiles.```pythonfrom prometheus_client import Histogramh = Histogram('request_latency_seconds', 'Description of histogram')h.observe(4.7)    # Observe 4.7 (seconds in this case)```The default buckets are intended to cover a typical web/rpc request from milliseconds to seconds.They can be overridden by passing `buckets` keyword argument to `Histogram`.There are utilities for timing code:```python@h.time()def f():  passwith h.time():  pass```### InfoInfo tracks key-value information, usually about a whole target.```pythonfrom prometheus_client import Infoi = Info('my_build_version', 'Description of info')i.info({'version': '1.2.3', 'buildhost': 'foo@bar'})```### EnumEnum tracks which of a set of states something is currently in.```pythonfrom prometheus_client import Enume = Enum('my_task_state', 'Description of enum',        states=['starting', 'running', 'stopped'])e.state('running')```### LabelsAll metrics can have labels, allowing grouping of related time series.See the best practices on [naming](http://prometheus.io/docs/practices/naming/)and [labels](http://prometheus.io/docs/practices/instrumentation/#use-labels).Taking a counter as an example:```pythonfrom prometheus_client import Counterc = Counter('my_requests_total', 'HTTP Failures', ['method', 'endpoint'])c.labels('get', '/').inc()c.labels('post', '/submit').inc()```Labels can also be passed as keyword-arguments:```pythonfrom prometheus_client import Counterc = Counter('my_requests_total', 'HTTP Failures', ['method', 'endpoint'])c.labels(method='get', endpoint='/').inc()c.labels(method='post', endpoint='/submit').inc()```Metrics with labels are not initialized when declared, because the client can'tknow what values the label can have. It is recommended to initialize the labelvalues by calling the `.labels()` method alone:```pythonfrom prometheus_client import Counterc = Counter('my_requests_total', 'HTTP Failures', ['method', 'endpoint'])c.labels('get', '/')c.labels('post', '/submit')```### ExemplarsExemplars can be added to counter and histogram metrics. Exemplars can bespecified by passing a dict of label value pairs to be exposed as the exemplar.For example with a counter:```pythonfrom prometheus_client import Counterc = Counter('my_requests_total', 'HTTP Failures', ['method', 'endpoint'])c.labels('get', '/').inc(exemplar={'trace_id': 'abc123'})c.labels('post', '/submit').inc(1.0, {'trace_id': 'def456'})```And with a histogram:```pythonfrom prometheus_client import Histogramh = Histogram('request_latency_seconds', 'Description of histogram')h.observe(4.7, {'trace_id': 'abc123'})```### Disabling `_created` metricsBy default counters, histograms, and summaries export an additional seriessuffixed with `_created` and a value of the unix timestamp for when the metricwas created. If this information is not helpful, it can be disabled by settingthe environment variable `PROMETHEUS_DISABLE_CREATED_SERIES=True`.### Process CollectorThe Python client automatically exports metrics about process CPU usage, RAM,file descriptors and start time. These all have the prefix `process`, andare only currently available on Linux.The namespace and pid constructor arguments allows for exporting metrics aboutother processes, for example:```ProcessCollector(namespace='mydaemon', pid=lambda: open('/var/run/daemon.pid').read())```### Platform CollectorThe client also automatically exports some metadata about Python. If using Jython,metadata about the JVM in use is also included. This information is available as labels on the `python_info` metric. The value of the metric is 1, since it is the labels that carry information.### Disabling Default Collector metricsBy default the collected `process`, `gc`, and `platform` collector metrics are exported.If this information is not helpful, it can be disabled using the following:```pythonimport prometheus_clientprometheus_client.REGISTRY.unregister(prometheus_client.GC_COLLECTOR)prometheus_client.REGISTRY.unregister(prometheus_client.PLATFORM_COLLECTOR)prometheus_client.REGISTRY.unregister(prometheus_client.PROCESS_COLLECTOR)```## ExportingThere are several options for exporting metrics.### HTTPMetrics are usually exposed over HTTP, to be read by the Prometheus server.The easiest way to do this is via `start_http_server`, which will start a HTTPserver in a daemon thread on the given port:```pythonfrom prometheus_client import start_http_serverstart_http_server(8000)```Visit [http://localhost:8000/](http://localhost:8000/) to view the metrics.To add Prometheus exposition to an existing HTTP server, see the `MetricsHandler` classwhich provides a `BaseHTTPRequestHandler`. It also serves as a simple example of howto write a custom endpoint.#### TwistedTo use prometheus with [twisted](https://twistedmatrix.com/), there is `MetricsResource` which exposes metrics as a twisted resource.```pythonfrom prometheus_client.twisted import MetricsResourcefrom twisted.web.server import Sitefrom twisted.web.resource import Resourcefrom twisted.internet import reactorroot = Resource()root.putChild(b'metrics', MetricsResource())factory = Site(root)reactor.listenTCP(8000, factory)reactor.run()```#### WSGITo use Prometheus with [WSGI](http://wsgi.readthedocs.org/en/latest/), there is`make_wsgi_app` which creates a WSGI application.```pythonfrom prometheus_client import make_wsgi_appfrom wsgiref.simple_server import make_serverapp = make_wsgi_app()httpd = make_server('', 8000, app)httpd.serve_forever()```Such an application can be useful when integrating Prometheus metrics with WSGIapps.The method `start_wsgi_server` can be used to serve the metrics through theWSGI reference implementation in a new thread.```pythonfrom prometheus_client import start_wsgi_serverstart_wsgi_server(8000)```By default, the WSGI application will respect `Accept-Encoding:gzip` headers used by Prometheusand compress the response if such a header is present. This behaviour can be disabled by passing`disable_compression=True` when creating the app, like this:```pythonapp = make_wsgi_app(disable_compression=True)```#### ASGITo use Prometheus with [ASGI](http://asgi.readthedocs.org/en/latest/), there is`make_asgi_app` which creates an ASGI application.```pythonfrom prometheus_client import make_asgi_appapp = make_asgi_app()```Such an application can be useful when integrating Prometheus metrics with ASGIapps.By default, the WSGI application will respect `Accept-Encoding:gzip` headers used by Prometheusand compress the response if such a header is present. This behaviour can be disabled by passing `disable_compression=True` when creating the app, like this:```pythonapp = make_asgi_app(disable_compression=True)```#### FlaskTo use Prometheus with [Flask](http://flask.pocoo.org/) we need to serve metrics through a Prometheus WSGI application. This can be achieved using [Flask's application dispatching](http://flask.pocoo.org/docs/latest/patterns/appdispatch/). Below is a working example.Save the snippet below in a `myapp.py` file```pythonfrom flask import Flaskfrom werkzeug.middleware.dispatcher import DispatcherMiddlewarefrom prometheus_client import make_wsgi_app# Create my appapp = Flask(__name__)# Add prometheus wsgi middleware to route /metrics requestsapp.wsgi_app = DispatcherMiddleware(app.wsgi_app, {    '/metrics': make_wsgi_app()})```Run the example web application like this```bash# Install uwsgi if you do not have itpip install uwsgiuwsgi --http 127.0.0.1:8000 --wsgi-file myapp.py --callable app```Visit http://localhost:8000/metrics to see the metrics### Node exporter textfile collectorThe [textfile collector](https://github.com/prometheus/node_exporter#textfile-collector)allows machine-level statistics to be exported out via the Node exporter.This is useful for monitoring cronjobs, or for writing cronjobs to expose metricsabout a machine system that the Node exporter does not support or would not make senseto perform at every scrape (for example, anything involving subprocesses).```pythonfrom prometheus_client import CollectorRegistry, Gauge, write_to_textfileregistry = CollectorRegistry()g = Gauge('raid_status', '1 if raid array is okay', registry=registry)g.set(1)write_to_textfile('/configured/textfile/path/raid.prom', registry)```A separate registry is used, as the default registry may contain other metricssuch as those from the Process Collector.## Exporting to a PushgatewayThe [Pushgateway](https://github.com/prometheus/pushgateway)allows ephemeral and batch jobs to expose their metrics to Prometheus.```pythonfrom prometheus_client import CollectorRegistry, Gauge, push_to_gatewayregistry = CollectorRegistry()g = Gauge('job_last_success_unixtime', 'Last time a batch job successfully finished', registry=registry)g.set_to_current_time()push_to_gateway('localhost:9091', job='batchA', registry=registry)```A separate registry is used, as the default registry may contain other metricssuch as those from the Process Collector.Pushgateway functions take a grouping key. `push_to_gateway` replaces metricswith the same grouping key, `pushadd_to_gateway` only replaces metrics with thesame name and grouping key and `delete_from_gateway` deletes metrics with thegiven job and grouping key. See the[Pushgateway documentation](https://github.com/prometheus/pushgateway/blob/master/README.md)for more information.`instance_ip_grouping_key` returns a grouping key with the instance label setto the host's IP address.### Handlers for authenticationIf the push gateway you are connecting to is protected with HTTP Basic Auth,you can use a special handler to set the Authorization header.```pythonfrom prometheus_client import CollectorRegistry, Gauge, push_to_gatewayfrom prometheus_client.exposition import basic_auth_handlerdef my_auth_handler(url, method, timeout, headers, data):    username = 'foobar'    password = 'secret123'    return basic_auth_handler(url, method, timeout, headers, data, username, password)registry = CollectorRegistry()g = Gauge('job_last_success_unixtime', 'Last time a batch job successfully finished', registry=registry)g.set_to_current_time()push_to_gateway('localhost:9091', job='batchA', registry=registry, handler=my_auth_handler)```TLS Auth is also supported when using the push gateway with a special handler.```pythonfrom prometheus_client import CollectorRegistry, Gauge, push_to_gatewayfrom prometheus_client.exposition import tls_auth_handlerdef my_auth_handler(url, method, timeout, headers, data):    certfile = 'client-crt.pem'    keyfile = 'client-key.pem'    return tls_auth_handler(url, method, timeout, headers, data, certfile, keyfile)registry = CollectorRegistry()g = Gauge('job_last_success_unixtime', 'Last time a batch job successfully finished', registry=registry)g.set_to_current_time()push_to_gateway('localhost:9091', job='batchA', registry=registry, handler=my_auth_handler)```## BridgesIt is also possible to expose metrics to systems other than Prometheus.This allows you to take advantage of Prometheus instrumentation evenif you are not quite ready to fully transition to Prometheus yet.### GraphiteMetrics are pushed over TCP in the Graphite plaintext format.```pythonfrom prometheus_client.bridge.graphite import GraphiteBridgegb = GraphiteBridge(('graphite.your.org', 2003))# Push once.gb.push()# Push every 10 seconds in a daemon thread.gb.start(10.0)```Graphite [tags](https://grafana.com/blog/2018/01/11/graphite-1.1-teaching-an-old-dog-new-tricks/) are also supported.```pythonfrom prometheus_client.bridge.graphite import GraphiteBridgegb = GraphiteBridge(('graphite.your.org', 2003), tags=True)c = Counter('my_requests_total', 'HTTP Failures', ['method', 'endpoint'])c.labels('get', '/').inc()gb.push()```## Custom CollectorsSometimes it is not possible to directly instrument code, as it is notin your control. This requires you to proxy metrics from other systems.To do so you need to create a custom collector, for example:```pythonfrom prometheus_client.core import GaugeMetricFamily, CounterMetricFamily, REGISTRYclass CustomCollector(object):    def collect(self):        yield GaugeMetricFamily('my_gauge', 'Help text', value=7)        c = CounterMetricFamily('my_counter_total', 'Help text', labels=['foo'])        c.add_metric(['bar'], 1.7)        c.add_metric(['baz'], 3.8)        yield cREGISTRY.register(CustomCollector())````SummaryMetricFamily`, `HistogramMetricFamily` and `InfoMetricFamily` work similarly.A collector may implement a `describe` method which returns metrics in the sameformat as `collect` (though you don't have to include the samples). This isused to predetermine the names of time series a `CollectorRegistry` exposes andthus to detect collisions and duplicate registrations.Usually custom collectors do not have to implement `describe`. If `describe` isnot implemented and the CollectorRegistry was created with `auto_describe=True`(which is the case for the default registry) then `collect` will be called atregistration time instead of `describe`. If this could cause problems, eitherimplement a proper `describe`, or if that's not practical have `describe`return an empty list.## Multiprocess Mode (E.g. Gunicorn)Prometheus client libraries presume a threaded model, where metrics are sharedacross workers. This doesn't work so well for languages such as Python whereit's common to have processes rather than threads to handle large workloads.To handle this the client library can be put in multiprocess mode.This comes with a number of limitations:- Registries can not be used as normal, all instantiated metrics are exported  - Registering metrics to a registry later used by a `MultiProcessCollector`    may cause duplicate metrics to be exported- Custom collectors do not work (e.g. cpu and memory metrics)- Info and Enum metrics do not work- The pushgateway cannot be used- Gauges cannot use the `pid` label- Exemplars are not supportedThere's several steps to getting this working:**1. Deployment**:The `PROMETHEUS_MULTIPROC_DIR` environment variable must be set to a directorythat the client library can use for metrics. This directory must be wipedbetween process/Gunicorn runs (before startup is recommended).This environment variable should be set from a start-up shell script,and not directly from Python (otherwise it may not propagate to child processes).**2. Metrics collector**:The application must initialize a new `CollectorRegistry`, and store themulti-process collector inside. It is a best practice to create this registryinside the context of a request to avoid metrics registering themselves to acollector used by a `MultiProcessCollector`. If a registry with metricsregistered is used by a `MultiProcessCollector` duplicate metrics may beexported, one for multiprocess, and one for the process serving the request.```pythonfrom prometheus_client import multiprocessfrom prometheus_client import generate_latest, CollectorRegistry, CONTENT_TYPE_LATEST, CounterMY_COUNTER = Counter('my_counter', 'Description of my counter')# Expose metrics.def app(environ, start_response):    registry = CollectorRegistry()    multiprocess.MultiProcessCollector(registry)    data = generate_latest(registry)    status = '200 OK'    response_headers = [        ('Content-type', CONTENT_TYPE_LATEST),        ('Content-Length', str(len(data)))    ]    start_response(status, response_headers)    return iter([data])```**3. Gunicorn configuration**:The `gunicorn` configuration file needs to include the following function:```pythonfrom prometheus_client import multiprocessdef child_exit(server, worker):    multiprocess.mark_process_dead(worker.pid)```**4. Metrics tuning (Gauge)**:When `Gauge`s are used in multiprocess applications,you must decide how to handle the metrics reported by each process.Gauges have several modes they can run in, which can be selected with the `multiprocess_mode` parameter.- 'all': Default. Return a timeseries per process (alive or dead), labelled by the process's `pid` (the label is added internally).- 'min': Return a single timeseries that is the minimum of the values of all processes (alive or dead).- 'max': Return a single timeseries that is the maximum of the values of all processes (alive or dead).- 'sum': Return a single timeseries that is the sum of the values of all processes (alive or dead).Prepend 'live' to the beginning of the mode to return the same result but only considering living processes(e.g., 'liveall, 'livesum', 'livemax', 'livemin').```pythonfrom prometheus_client import Gauge# Example gaugeIN_PROGRESS = Gauge(&quot;inprogress_requests&quot;, &quot;help&quot;, multiprocess_mode='livesum')```## ParserThe Python client supports parsing the Prometheus text format.This is intended for advanced use cases where you have serversexposing Prometheus metrics and need to get them into some othersystem.```pythonfrom prometheus_client.parser import text_string_to_metric_familiesfor family in text_string_to_metric_families(u&quot;my_gauge 1.0\n&quot;):  for sample in family.samples:    print(&quot;Name: {0} Labels: {1} Value: {2}&quot;.format(*sample))```## Links* [Releases](https://github.com/prometheus/client_python/releases): The releases page shows the history of the project and acts as a changelog.* [PyPI](https://pypi.python.org/pypi/prometheus_client)</longdescription>
</pkgmetadata>