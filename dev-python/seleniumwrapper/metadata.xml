<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>About this module-----------------selenium webdriver wrapper to make manipulation easier... image:: https://secure.travis-ci.org/keitaoouchi/seleniumwrapper.png.. image:: https://pypip.in/download/seleniumwrapper/badge.svg?period=month    :target: https://pypi.python.org/pypi//seleniumwrapper/    :alt: Downloads.. image:: https://pypip.in/version/seleniumwrapper/badge.svg?text=version    :target: https://pypi.python.org/pypi/seleniumwrapper/    :alt: Latest Version.. image:: https://pypip.in/py_versions/seleniumwrapper/badge.svg    :target: https://pypi.python.org/pypi/seleniumwrapper/    :alt: Supported Python versions.. image:: https://pypip.in/status/seleniumwrapper/badge.svg    :target: https://pypi.python.org/pypi/seleniumwrapper/    :alt: Development StatusFeatures--------* Support Internet Explorer, Chrome, Opera, Firefox, PhantomJS* Support remote webdriver.* Easy to type aliases. (find_element_by_xpath =&gt; xpath, etc.)* Wrapped WebdriverWait( ... ).until( ... ) pattern.* Polling at the time of clicking or selecting.* Wrapping chaining.How to install--------------Requires python2.6 or later.You need *pip* or *distribute* or *setuptools*::    $ pip install seleniumwrapperor use easy_install::    $ easy_install seleniumwrapperalso you need selenium::    $ pip install seleniumExample to use--------------**create** function helps you to init webdriver and wrap it easily::    &gt;&gt;&gt; import seleniumwrapper as selwrap    &gt;&gt;&gt; br = selwrap.create(&quot;chrome&quot;)**connect** function helps you to use remote webdriver and wrap it::    &gt;&gt;&gt; br = connect(&quot;android&quot;, &quot;http://localhost:9999&quot;, {&quot;acceptSslCerts&quot;: True})SeleniumWrapper delegate to its wrapped webdriver::    &gt;&gt;&gt; br.get(&quot;http://www.example.com&quot;)    &lt;seleniumwrapper.wrapper.SeleniumWrapper object at 0x...&gt;    &gt;&gt;&gt; br.xpath(&quot;//div[@class='main'])    &lt;seleniumwrapper.wrapper.SeleniumWrapper object at 0x...&gt;Setting **eager=True** to invoke find_elements::    &gt;&gt;&gt; br.xpath(&quot;//a&quot;, eager=True)    &lt;seleniumwrapper.wrapper.SeleniumContainerWrapper object at 0x...&gt;SeleniumContainerWrapper also delegate to its wrapped container::    &gt;&gt;&gt; links = [i.get_attribute(&quot;href&quot;) for i in br.xpath(&quot;//a&quot;, eager=True)]Each contents in SeleniumContainerWrapper also SeleniumWrapper::    &gt;&gt;&gt; tds = [tr.xpath(&quot;//td&quot;, eager=True) for tr in br.xpath(&quot;//tr&quot;, eager=True)]Basic API---------* seleniumwrapper.create(drivername)* seleniumwrapper.connect(drivername, executor, custom_capabilities)    Create webdriver instance and wrap it with SeleniumWrapper.SeleniumWrapper^^^^^^^^^^^^^^^* unwrap    Retrieves WebDriver or WebElement from wrapped object::        &gt;&gt;&gt; isinstance(br.unwrap, WebElement)        True* parent    find_element_by_xpath(&quot;./parent::node()&quot;)::        &gt;&gt;&gt; price = br.by_tag(&quot;th&quot;, &quot;Price&quot;).parent.by_tag(&quot;td&quot;).text* performance    Returns window.performance wrapped object::        &gt;&gt;&gt; performance = br.performance        &gt;&gt;&gt; timing = performance.timing        &gt;&gt;&gt; navigation = performance.navigation        &gt;&gt;&gt; timing.loadEventEnd        1358319427476* to_select    Convert wrapped WebElement to raw Select object::        &gt;&gt;&gt; br.by_id('select_button').to_select.select_by_visible_text(&quot;hoge&quot;)    select method returns the same as below::        &gt;&gt;&gt; br.select(id = 'select_button').select_by_visible_text(&quot;hoge&quot;)* alert    Returns Alert(switch_to_alert()) object::        &gt;&gt;&gt; br.alert.accept()* current_url    Returns current_url after loading page body::        &gt;&gt;&gt; br.current_url* timeout    Accessor for _timeout property::        &gt;&gt;&gt; br.timeout        5        &gt;&gt;&gt; br.timeout = 10        &gt;&gt;&gt; br.timeout        10* silent    Accessor for _silent property::        # default        &gt;&gt;&gt; br.by_id(&quot;Hoge&quot;)        Traceback (most recent call last):            ...        NoSuchElementException:...        &gt;&gt;&gt; br.silent = True        &gt;&gt;&gt; br.by_id(&quot;Hoge&quot;) is None        True* attr(name)    Shortcut to get_attribute::        &gt;&gt;&gt; br.attr('href')* click(timeout=3, presleep=0, postsleep=0)    Continue to polling until timeout or element is displayed and clickable::        &gt;&gt;&gt; br.button(&quot;Send&quot;).click()* scroll_to(x, y)    equivalent to javascript's scrollTo::        &gt;&gt;&gt; br.scrollTo(0, 100)* scroll_by(x, y)    equivalent to javascript's scrollBy::        &gt;&gt;&gt; br.scrollBy(10, 10)* scroll_into_view(jq_identifier, align_with_top=True)    find elements by jq_identifier and retrieve its first element and invoke scrollIntoView to it::        &gt;&gt;&gt; var element = $('#hoge');        &gt;&gt;&gt; element &amp;&amp; element.scrollIntoView(true)    second argument is passed as javascript's boolean to scrollIntoView::        &gt;&gt;&gt; br.scrollIntoView('#hoge', False)* waitfor(type, target, eager=False, timeout=3)    See source::        &gt;&gt;&gt; br.waitfor(&quot;xpath&quot;, &quot;//input[@type='submit']&quot;)* xpath(target, eager=False, timeout=3)    find_element_by_xpath(target, timeout)::        &gt;&gt;&gt; buttons = br.xpath(&quot;//input[@type='submit' or @type='button']&quot;, eager=True)* css(target, eager=False, timeout=3)    find_element_by_css_selector(target, timeout)::        &gt;&gt;&gt; [li.text for li in br.css(&quot;ul li&quot;)]* by_tag(self, tag, eager=False, timeout=3, \*\*attributes)    Returns specified tagged element with specified attributes optionally.::        &gt;&gt;&gt; br.by_tag(&quot;link&quot;, rel=&quot;stylesheet&quot;)* by_text(text, tag='*', partial=False, eager=False, timeout=3)    similar to find_element_by_link_text or find_element_by_partial_link_text, but this method can be applicable to any tag::        &gt;&gt;&gt; br.by_text(&quot;Go back to Top Page&quot;, &quot;a&quot;)* by_class(target, eager=False, timeout=3)    find_element_by_class_name(target, timeout)::        &gt;&gt;&gt; br.by_class(&quot;colored&quot;)* by_id(target, eager=False, timeout=3)    find_element_by_id(target, timeout)::        &gt;&gt;&gt; br.by_id(&quot;main_contents&quot;)* by_name(target, eager=False, timeout=3)    find_element_by_name(target, timeout)::        &gt;&gt;&gt; br.by_name(&quot;page_password&quot;)* by_linktxt(target, eager=False, timeout=3, partial=False)    find_element_by_link_text(target, timeout). if partial=True, then find_element_by_partial_link_text::        &gt;&gt;&gt; br.by_linktxt(&quot;Go back to&quot;, partial=True)* href(partialurl=None, eager=False, timeout=3):    find_element_by_xpath(&quot;//a&quot;, timeout). if partialurl was given, search 'a' tag which href contains partialurl::        &gt;&gt;&gt; phplinks = br.href(&quot;.php&quot;, eager=True)* img(alt=None, ext=None, eager=False, timeout=3)    find_elements_by_xpath(&quot;//img&quot;, timeout)::        &gt;&gt;&gt; br.img(alt=&quot;I am sorry&quot;, ext=&quot;sorry.gif&quot;)* button(value, eager=False, timeout=3)    find_element_by_xpath(&quot;//input[@type='submit' or @type='button' and @value='{0}']|.//button[text()='{0}']&quot;.format(value), timeout)::        &gt;&gt;&gt; br.button(&quot;Send this form&quot;).click()* checkbox(self, eager=False, timeout=3, \*\*attributes)    Returns 'input' element type='checkbox'::        &gt;&gt;&gt; br.checkbox(name='checked_value', id='hoge')* radio(self, eager=False, timeout=3, \*\*attributes)    Retuns 'input' element type='radio'.::        &gt;&gt;&gt; br.radio(name='hoge', id='fuga').click()* select(self, eager=False, timeout=3, \*\*attributes)    Returns Select(self.by_tag(&quot;select&quot;, eager, timeout, \*\*attributes) or their wrapped SeleniumContainerWrapper::        &gt;&gt;&gt; br.select(name=&quot;hoge&quot;).select_by_index(1)        &gt;&gt;&gt; [select.is_multiple for select in br.select(eager=True, name=&quot;hoge&quot;)]SeleniumContainerWrapper^^^^^^^^^^^^^^^^^^^^^^^^* size    Returns length of wrapped iterable::        &gt;&gt;&gt; br.img(eager=True).size* sample(size)    Returns random.sample(self._iterable, size)::        &gt;&gt;&gt; br.img(eager=True).sample(10)* choice()    Returns random.choice(self._iterable)::        &gt;&gt;&gt; br.img(eager=True).choice()Recent Change-------------* 0.5.4    * Add support for Python-3.4.    * Fix **button** to look for `&lt;button&gt;` tag.* 0.5.3    * Fix README* 0.5.2    * Add silent mode option.* 0.5.0    * Support Python3.* 0.4.3    * Add **perfomance**, **performance.timing**, **performance.navigation**, **performance.memory** properties.* 0.4.2    * Add 'PhantomJS' support.* 0.4.1    * Fixed some bugs.* 0.4.0    * Added **scroll_to**, **scroll_by**, **scroll_into_view** methods.* 0.3.5    * Added **attr** method.    * Fixed some typos.* 0.3.4    * Added size property to SeleniumContainerWrapper    * Fixed to be able to change default timeout.* 0.3.3    * Fixed bugs of string formatting.* 0.3.2    * Changed **alert** to wait until Alert's text is accesible.    * Override **current_url** to wait for page body loaded.* 0.3.1    * Added **connect** functon.* 0.3.0    * Changed **tag** method to **by_tag**.    * Added **checkbox**, **radio**.    * Changed **select** property to method.    * Added **sample**, **choice** methods to SeleniumContainerWrapper.    * Fixed **click** bug.* 0.2.4    * Fixed bug.* 0.2.3    * Added ext argument to **img** (alt and ext are both optional.)* 0.2.2    * Added new property **alert**    * Changed **img**'s argument from ext to alt( find_element_by_xpath(&quot;//img[@alt='{}'.format(alt)) )    * Modified SeleniumContainerWrapper's __contains__ behavior to unwrap given object if it is a SeleniumWrapper.</longdescription>
</pkgmetadata>