<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;h1&gt;Exert&lt;img src='https://user-images.githubusercontent.com/30027932/164949229-8ef0baf9-119c-4cd6-8df9-c1b6644b399b.png' align='right' width='128' height='128'&gt;&lt;/h1&gt;&lt;strong&gt;&gt;&gt; &lt;i&gt;Declaratively apply converter functions to class attributes.&lt;/i&gt; &lt;&lt;&lt;/strong&gt;&lt;/div&gt;## InstallationInstall via pip:```pip install exert```## UsageUse this to declaratively apply arbitrary converter functions to the attributes of aclass. For example:```pythonfrom __future__ import annotationsfrom typing import Annotatedfrom exert import exert, Mark@exertclass Foo:    a: Annotated[int, Mark(lambda x: x**2)]    b: Annotated[float, Mark(lambda x: x / 2)]    def __init__(self, a: int, b: float) -&gt; None:        self.a = a        self.b = bfoo = Foo(2, 42.0)print(foo.a) # prints 4print(foo.b) # prints 21.0```Here, the lambda function tagged with `Mark` is the converter.### Use with dataclassesDataclasses can also be used to avoid writing the initializer by hand. For example:```python...from dataclasses import dataclass@exert@datclassesclass Foo:    a: Annotated[int, Mark(lambda x: x**2)]    b: Annotated[float, Mark(lambda x: x / 2)]foo = Foo(2, 42.0)print(foo.a) # prints 4print(foo.b) # prints 21.0```### Apply multiple converters sequentiallyMultiple converters are allowed. For example:```python...@exert@dataclassclass Foo:    a: Annotated[int, Mark(lambda x: x**2, lambda x: x**3)]    b: Annotated[float, Mark(lambda x: x / 2, lambda x: x / 3)]foo = Foo(2, 42.0)print(foo.a) # prints 64  [2**2=4, 4**3=64]print(foo.b) # prints 7.0 [42.0/2=21.0, 21.0/3=7.0]```Here, the converters are applied sequentially. The result of the preceding converter isfed into the succeeding converter as input. You've to make sure that the number of thereturned values of the preceding converter matches that of the succeeding converter.### Exclude annotated fieldsIf you don't wrap converters with `Mark`, the corresponding field won't be transformed:```python...@exert@dataclassclass Foo:    a: Annotated[int, Mark(lambda x: x**2, lambda x: x**3)]    b: Annotated[float, lambda x: x / 2, lambda x: x / 3]foo = Foo(2, 42.0)print(foo.a)  # prints 64  [2**2=4, 4**3=64]print(foo.b)  # prints 42.0 [This field was ignored]```Since the converters in field `b` weren't tagged with `Mark`, no conversion happened.### Apply common converters without repetitionCommon converters can be applied to multiple fields without repetition:```python...@exert(converters=(lambda x: x**2,))@dataclassclass Foo:    a: Annotated[int, None]    b: Annotated[float, None]foo = Foo(2, 42.0)print(foo.a)  # prints 4      [2**2=4]print(foo.b)  # prints 1764.0 [42.0**2=1764.0]```### Apply common and marked converters togetherYou can apply a sequence of common converters and marked converters together. By default,the common converters are applied first and then the tagged converters are appliedsequentially:```python...@exert(converters=(lambda x: x**2, lambda x: x**3))@dataclassclass Foo:    a: Annotated[int, Mark(lambda x: x / 100)]    b: Annotated[float, None]foo = Foo(2, 42.0)print(foo.a)  # prints 0.64         [2**2=4, 4**3=64, 64/100=0.64]print(foo.b)  # prints 5489031744.0 [42.0**2=1764, 1764**3=5489031744.0]```You can also, choose to apply the common converters after the tagged ones. For this,you'll need to set the `apply_last` parameter to `True`:```python...@exert(    converters=(lambda x: x**2, lambda x: x**3),    apply_last=True,)@dataclassclass Foo:    a: Annotated[int, Mark(lambda x: x / 100)]    b: Annotated[float, None]foo = Foo(2, 42.0)print(foo.a)  # prints 6.401e-11 [2/100=0.02, 0.02**2=0.004, 0.0004**3=6.401e-11]print(foo.b)  # prints 5489031744.0 [42.0**2=1764, 1764**3=5489031744.0]```### Simple data validationThe snippet below ensures that the attributes of the class `Foo` conforms to the constraints imposed by the converter functions.```pythonfrom __future__ import annotationsimport jsonfrom dataclasses import dataclassfrom functools import partialfrom typing import Annotated, Sizedfrom exert import Mark, exertdef assert_len(x: Sized, length: int) -&gt; Sized:    &quot;&quot;&quot;Assert that the incoming attribute has the expected length.&quot;&quot;&quot;    assert len(x) == length    return xdef assert_json(x: dict) -&gt; dict:    &quot;&quot;&quot;Assert that the incoming attribute is JSON serializable.&quot;&quot;&quot;    try:        json.dumps(x)    except TypeError:        raise AssertionError(f&quot;{x} is not JSON serializable&quot;)    return x@exert@dataclassclass Foo:    a: Annotated[tuple[int, ...], Mark(partial(assert_len, length=3))]    b: Annotated[dict, Mark(assert_json)]foo = Foo(a=(1, 2, 3), b={&quot;a&quot;: 1, &quot;b&quot;: 2})print(foo)```This will raise `AssertionError` if the value of the attributes violate the constraints.&lt;div align=&quot;center&quot;&gt;&lt;i&gt; ‚ú® üç∞ ‚ú® &lt;/i&gt;&lt;/div&gt;</longdescription>
</pkgmetadata>