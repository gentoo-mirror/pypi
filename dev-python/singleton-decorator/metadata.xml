<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>singleton-decorator===================A testable singleton decorator allows easily create a singleton objectsjust adding a decorator to class definition but also allows easily writeunit tests for those classes.A problem=========If you use a simple singleton pattern based on a decorator function thatwraps a class with inner wrapper function like this:.. code-block::    def singleton(cls):        instances = {}        def wrapper(*args, **kwargs):            if cls not in instances:              instances[cls] = cls(*args, **kwargs)            return instances[cls]        return wrapperit works fine with your classes, but it makes impossible a direct accessto the class object without decorator. So you cannot call methods usinga class name in unit tests:.. code-block::    @singleton    class YourClass:        def method(self):            ...    YourClass.method(...)this code would not work because ``YouClass`` actually contains a wrapper functionbut not your class object. Also this approach causes another problem if yourtests require separate instances of the objects, so a singleton pattern couldbreak an isolation of different tests.Solution========The **singleton-decorator** offers a simple solution to avoid both of theseproblems. It uses a separate wrapper object for each decorated class and holdsa class within ``__wrapped__`` attribute so you can access the decorated classdirectly in your unit tests.Installation============To install the **singleton-decorator** just type in the command line:.. code-block::    $ pip install singleton-decoratorUsage=====At first import the singleton decorator:.. code-block::    from singleton_decorator import singletonThen decorate you classes with this decorator:.. code-block::    @singleton    class YourClass:        ...That's all. Now you could create or get existing instance of your class bycalling it as a simple class object:.. code-block::    obj = YourClass()  # creates a new instance    obj2 = YourClass()  # returns the same instance    obj3 = YourClass()  # returns the same instance    ...You also could pass args and kwargs into constructor of your class:.. code-block::    obj = YourClass(1, &quot;foo&quot;, bar=&quot;baz&quot;).. NOTE::    Since the singleton pattern allows to create only one instance from    the class, an ``__init__`` method would be called once with args and    kwargs passed at the first call. Arguments of all future calls would    be completely ignored and would not impact the existing instance at all.Unit testing============In your unit tests to run the methods of decorated classes in isolationwithout instantiation the object (to avoid running a constructor code),use the ``__wrapped__`` attribute of the wrapper object:.. code-block::    # your_module.py    @singleton    class YourClass:        def your_method(self):            ..... code-block::    # tests.py    class TestYourClass(TestCase):        def test_your_method(self):            obj = mock.MagicMock()            YourClass.__wrapped__.your_method(obj)            ...This test runs a code of the ``your_method`` only using a mock objectas the ``self`` argument, so the test would be run in complete isolationand would not depend on another pieces of your code including a constructormethod.</longdescription>
</pkgmetadata>