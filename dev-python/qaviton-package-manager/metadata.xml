<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Qaviton Package Manager![logo](https://www.qaviton.com/wp-content/uploads/logo-svg.svg)  [![version](https://img.shields.io/pypi/v/qaviton_package_manager.svg)](https://pypi.python.org/pypi)[![license](https://img.shields.io/pypi/l/qaviton_package_manager.svg)](https://pypi.python.org/pypi)[![open issues](https://img.shields.io/github/issues/qaviton/qaviton_package_manager)](https://github/issues-raw/qaviton/qaviton_package_manager)[![downloads](https://img.shields.io/pypi/dm/qaviton_package_manager.svg)](https://pypi.python.org/pypi)![code size](https://img.shields.io/github/languages/code-size/qaviton/qaviton_package_manager)-------------------------  Qaviton Package Manager (qpm)  is a package management tool integrated with git.  to enable management of packages both public &amp; private,  from git repositories, in addition to the standard package manager.  Replace redundant packaging systems using qpm:  Package everything using git tags:```&gt;qpm --build         |branch: dev         |branch: tests         |  [tag 2019.9.1]          |[tag 2019.9.2]         |branch: release/latest&gt;qpm --install &quot;git+https://url/owner/project.git@release/latest#egg=package:&gt;=2019.9.2&quot;  |       |      |   |           |                     |             |              |qaviton install vcs+protocol://project_url          @branch   #egg=package      (optional) package method  type                                              directory   pep-440 pep-508manager                                                             path     :version_specifier```  ![simply_install](https://github.com/qaviton/qaviton_package_manager/blob/master/images/simply_install.JPG?raw=true)  ## Installation  ```sh  pip install --upgrade qaviton_package_manager```  ### Requirements- git 2.16+  - Python 3.6+  ## Features  * CI CD workflow ✓  * managing private+public packages ✓  * managing nested private packages ✓  * cli + scripting ✓  * pip capabilities ✓  * git capabilities ✓  * pypi capabilities ✓  * automatic builds ✓  * secure credentials ✓  * cross-platform ✓  * nested/multiple packages ✗  * pip -e installs ✗ (coming soon)  * docker build ✗ (but can be used with the run function)  * docker push ✗ (but can be used with the run function)  ## Usage  #### creating a manager:  ```(venv) windows&gt; qpm ^--create ^--url &quot;https://github.com/owner/project.git&quot; ^--username &quot;user1&quot; ^--password &quot;pass@#$&quot; ^--email &quot;awsome@qaviton.com&quot; ^--pypi_user &quot;supasayajin&quot; ^--pypi_pass &quot;final space&quot; ```  ```bash(venv) bash$ qpm  \--create  \--url &quot;https://github.com/owner/project.git&quot;  \--username &quot;user1&quot;  \--password &quot;pass@#$&quot;  \--email &quot;awsome@qaviton.com&quot;  \--pypi_user &quot;supasayajin&quot;  \--pypi_pass &quot;final space&quot;  \/```  this should leave you with the following project structure:```project/  ├ package/  │   └ __init__.py  # with __author__, __version__, __author_email__, __description__, __url__, __license__  ├ tests/  │   └ __init__.py  ├ .gitignore  ├ LICENSE   ├ README.md  ├ requirements.txt  ├ requirements-test.txt  ├ setup.py  └ package.py  # ignored by .gitignore```now let's build a package:  ```python# package.pyfrom qaviton_package_manager import Managerfrom qaviton_package_manager import decypt# if this is not secure enough, you can add cache_timeout=3600 # and store credentials in memory# manager = Manager(cache_timeout=3600)  # and we need to insert the credentials in run time: &gt; python package.py --username &quot;x&quot;  --password &quot;z&quot;manager = Manager(**decypt(    key=b'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx==',    token=b'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx==',))if __name__ == &quot;__main__&quot;:    # running with lambdas will protect you from processes getting stuck    manager.run(        lambda: manager.update(), # pip install -r requirements.txt --upgrade        lambda: manager.update_test(), # pip install -r requirements-test.txt --upgrade        lambda: manager.test(), # python -m pytest --junitxml=test_report.xml tests        lambda: manager.build(), # git commit, tag &amp; push (internal logic is more complicated)        lambda: manager.upload(), # upload to pypi    )```  make sure you have at list 1 passing test for your package ```python# tests/my_package_test.pydef test_with_100p_coverage():    print(&quot;testing my package!\nPASS&quot;)``````bash# we can now create a packagepython package.py```  #### CLI:  we can call any method and send any parameter to the manager through cli:```bash# release a version if all tests passqpm --username &quot;&quot; --password &quot;&quot; --update --update_test --test --build --upload# build a stable version if all tests passqpm --username &quot;&quot; --password &quot;&quot; --update --update_test --test --build &quot;stable/latest&quot;# install cachetools using pip and save the requirement in requirements.txtqpm --install cachetools# cache credentials in memoryqpm --username &quot;&quot; --password &quot;&quot; --cache_timeout &quot;-1&quot;# using the system &amp; python to execute testsqpm --test &quot;system&quot; &quot;echo success&quot; --test &quot;python&quot; &quot;-c&quot; &quot;print(\&quot;py success\&quot;);&quot;```  #### CLI shortcuts:  we can call any method and send any parameter to the manager through cli:```bash# install cachetools using pip and save the requirement in requirements.txtqpm i cachetools# uninstall cachetools using pip and remove the requirement in requirements.txtqpm un cachetools# build a stable versionqpm b &quot;stable/latest&quot;# run testsqpm t# upload to pypiqpm up# install cachetools using pip and save the requirement in requirements.txtqpm install cachetools# build packageqpm build &quot;stable/latest&quot;# upload to pypiqpm upload```  ![shortcuts_api](https://github.com/qaviton/qaviton_package_manager/blob/master/images/shortcuts_api.JPG?raw=true)  #### Script:  ```python# ci_cd.pyfrom qaviton_processes import run, escape, pythonfrom package import managerfrom datetime import datetimed = datetime.utcnow()docker_url = manager.vars['docker_url']docker_user = manager.vars['docker_user']docker_pass = manager.vars['docker_pass']docker_email = manager.vars['docker_email']SSH_PRIVATE_KEY = manager.kwargs['SSH_PRIVATE_KEY']docker_tag = manager.kwargs['docker_tag']branch_build = &quot;ci_cd/latest&quot;dev_branch = &quot;dev&quot;manager.run(    lambda: manager.should_build(from_branch=dev_branch, to_branch=branch_build),    lambda: manager.install(),    lambda: manager.install_test(),    lambda: manager.test.pytest(&quot;tests/ci_cd&quot;),    lambda: manager.build(to_branch=branch_build, version=f'{d.year}.{d.month}.{d.day}'),    # docker distribute    lambda: run(f&quot;docker login --username=\&quot;{escape(docker_user)}\&quot; --password=\&quot;{escape(docker_pass)}\&quot; --email=\&quot;{escape(docker_email)}\&quot; \&quot;{escape(docker_url)}\&quot;&quot;),    lambda: run(f&quot;docker build --force-rm -t test-multi-stage-builds --build-arg SSH_PRIVATE_KEY=\&quot;{escape(SSH_PRIVATE_KEY)}\&quot; .&quot;),    lambda: run(f&quot;docker tag {docker_tag} yourhubusername/verse_gapminder:firsttry&quot;),    lambda: run(&quot;docker push yourhubusername/verse_gapminder&quot;),    # deploy script    lambda: python(&quot;deploy.py&quot;)    )``````python# schedualer.pyfrom time import time, sleepfrom datetime import datetime, timedeltafrom qaviton_processes import python_code_asyncd = datetime.utcnow()date = datetime(year=d.year, month=d.month, day=d.day, hour=22)delta = timedelta(days=1)# build a package once a day at 22pmwhile True:    python_code_async('import ci_cd')    date += delta    sleep(date.timestamp()-time())```  ## warnings  * this manager is meant for automated ci cd purposes  and should not be used instead of regular git commit/push/merge.  make sure to avoid using it on unstable branches  to avoid failed packaging requests or potential data loss.  we recommend using it from a CI CD dedicated branch.  * the manager defaults to encrypted credentials,  if encrypted credentials on the disk are not secure enough,  please make sure to enable caching, to store credentials in memory  </longdescription>
</pkgmetadata>