<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># xdanticLightweight configuration library on top of Pydantic## Getting startedThis notebook shows some example usages of xdantic.It explains how to provide values to the configuration object, how toaccess values and how nested configurations work.The configuration management is simple, including the config objectitself with all the fields that you implement```pythonfrom typing import Literalfrom pydantic import HttpUrl, Fieldfrom xdantic import XConfigclass DemoConfig(XConfig):    &quot;&quot;&quot;    The object `DemoConfig` is the central config object that    will hold your values and can be extended to your needs with new values.    Here, you can leverage the power of Pydantic and Python typehints to create a configuration    that is safe, documented and easy to use.        Check https://pydantic-docs.helpmanual.io/usage/types/ to learn more about field types in Pydantic.    &quot;&quot;&quot;    DB_HOST: HttpUrl  # will be validate to be a httpUrl     DB_PORT: int = Field(default=3333, le=64000, ge=1024)  # will be validated to be in the given range    DB_TYPE: Literal[&quot;postgres&quot;, &quot;mysql&quot;] = &quot;mysql&quot;  # can only take on values present in the `Literal` definition```#### Create a configTo create a config object with parsed values you can simply call theinitializer method and XConfig will automatically create the objectusing values from e.g. environment variables.Now that we have the `DemoConfig` we are ready to use our config in thecode. The next cell provides an example of parsing values to the configfrom environment variables and accessing them:```pythonimport os os.environ['DB_PORT'] = '8888'  # note, how this value will take presedence over the defaultos.environ['DB_HOST'] = 'https://postgres-develop.cluster.svc.local'os.environ['DB_TYPE'] = 'postgres'print(DemoConfig())```#### Nested configurationSometime, it is desired to nest configurations to have a structure like`config.db.usernamne`. This can be easily achieved by creating aseparate class that inherits from `pydantic.BaseModel` and add it as anattribute to the config object (`DemoConfig`). In the cell below, weoverwrite the definitions from above to create the nested config object:```pythonfrom pydantic import BaseModel, PositiveFloat, HttpUrl# for objects that will be nested into the root config object, inherit from `BaseModel`class ModelConfig(BaseModel):    lr: PositiveFloat = 1e-3        # overwrite the `XConfig` definition from above to include the sub-config object.class DemoConfig(XConfig):    MODEL_CFG: ModelConfig = ModelConfig()        DB_HOST: HttpUrl  # will be validate to be a httpUrl     DB_PORT: int = Field(default=3333, le=64000, ge=1024)  # will be validated to be in the given range    DB_TYPE: Literal[&quot;postgres&quot;, &quot;mysql&quot;] = &quot;mysql&quot;  # can only take on values present in the `Literal` definition``````pythonos.environ['MODEL_CFG__LR'] = '0.1'print(DemoConfig())```#### Reading from .env file {#reading-from-env-file}In the notebooks folder there is a file called \'.env\' containing someconfig values. XConfig objects will also parse .env files automaticallyif they exist.```pythonos.environ.pop('MODEL_CFG__LR', None)print(ModelConfig())```</longdescription>
</pkgmetadata>