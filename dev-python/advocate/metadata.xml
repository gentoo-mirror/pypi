<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. role:: python(code)   :language: pythonAdvocate========.. image:: https://travis-ci.org/JordanMilne/Advocate.svg?branch=master    :target: https://travis-ci.org/JordanMilne/Advocate/.. image:: https://codecov.io/github/JordanMilne/Advocate/coverage.svg?branch=master    :target: https://codecov.io/github/JordanMilne/Advocate.. image:: https://img.shields.io/pypi/pyversions/advocate.svg.. image:: https://img.shields.io/pypi/v/advocate.svg    :target: https://pypi.python.org/pypi/advocateAdvocate is a set of tools based around the `requests library &lt;https://github.com/kennethreitz/requests&gt;`_ for safely makingHTTP requests on behalf of a third party. Specifically, it aims to prevent common techniques that enable `SSRF attacks &lt;https://cwe.mitre.org/data/definitions/918.html&gt;`_. Advocate was inspired by `fin1te's SafeCurl project &lt;https://github.com/fin1te/safecurl&gt;`_.Installation============.. code-block:: bash    pip install advocateAdvocate is officially supported on CPython 2.7+, CPython 3.4+ and PyPy 2. PyPy 3 may work as well, but you'll need a copy of the ipaddress module from elsewhere.See it in action================If you want to try out Advocate to see what kind of things it catches, there's a `test site up on advocate.saynotolinux.com &lt;http://advocate.saynotolinux.com/&gt;`_.Examples========Advocate is more-or-less a drop-in replacement for requests. In most cases you can just replace &quot;requests&quot; with&quot;advocate&quot; where necessary and be good to go:.. code-block:: python    &gt;&gt;&gt; import advocate    &gt;&gt;&gt; print advocate.get(&quot;http://google.com/&quot;)    &lt;Response [200]&gt;Advocate also provides a subclassed :python:`requests.Session` with sane defaults forvalidation already set up:.. code-block:: python    &gt;&gt;&gt; import advocate    &gt;&gt;&gt; sess = advocate.Session()    &gt;&gt;&gt; print sess.get(&quot;http://google.com/&quot;)    &lt;Response [200]&gt;    &gt;&gt;&gt; print sess.get(&quot;http://localhost/&quot;)    advocate.exceptions.UnacceptableAddressException: ('localhost', 80)All of the wrapped request functions accept a :python:`validator` kwarg where youcan set additional rules:.. code-block:: python    &gt;&gt;&gt; import advocate    &gt;&gt;&gt; validator = advocate.AddrValidator(hostname_blacklist={&quot;*.museum&quot;,})    &gt;&gt;&gt; print advocate.get(&quot;http://educational.MUSEUM/&quot;, validator=validator)    advocate.exceptions.UnacceptableAddressException: educational.MUSEUMIf you require more advanced rules than the defaults, but don't want to have to passthe validator kwarg everywhere, there's :python:`RequestsAPIWrapper` . You candefine a wrapper in a common file and import it instead of advocate:.. code-block:: python    &gt;&gt;&gt; from advocate import AddrValidator, RequestsAPIWrapper    &gt;&gt;&gt; from advocate.packages import ipaddress    &gt;&gt;&gt; dougs_advocate = RequestsAPIWrapper(AddrValidator(ip_blacklist={    ...     # Contains data incomprehensible to mere mortals    ...     ipaddress.ip_network(&quot;42.42.42.42/32&quot;)    ... }))    &gt;&gt;&gt; print dougs_advocate.get(&quot;http://42.42.42.42/&quot;)    advocate.exceptions.UnacceptableAddressException: ('42.42.42.42', 80)Other than that, you can do just about everything with Advocate that you canwith an unwrapped requests. Advocate passes requests' test suite with theexception of tests that require :python:`Session.mount()`.Conditionally bypassing protection==================================If you want to allow certain users to bypass Advocate's restrictions, justuse plain 'ol requests by doing something like:.. code-block:: python    if user == &quot;mr_skeltal&quot;:        requests_module = requests    else:        requests_module = advocate    resp = requests_module.get(&quot;http://example.com/doot_doot&quot;)requests-futures support========================A thin wrapper around `requests-futures &lt;https://github.com/ross/requests-futures&gt;`_ is provided to ease writing async-friendly code:.. code-block:: python    &gt;&gt;&gt; from advocate.futures import FuturesSession    &gt;&gt;&gt; sess = FuturesSession()    &gt;&gt;&gt; fut = sess.get(&quot;http://example.com/&quot;)    &gt;&gt;&gt; fut    &lt;Future at 0x10c717f28 state=finished returned Response&gt;    &gt;&gt;&gt; fut.result()    &lt;Response [200]&gt;You can do basically everything you can do with regular :python:`FuturesSession` s and :python:`advocate.Session` s:.. code-block:: python    &gt;&gt;&gt; from advocate import AddrValidator    &gt;&gt;&gt; from advocate.futures import FuturesSession    &gt;&gt;&gt; sess = FuturesSession(max_workers=20, validator=AddrValidator(hostname_blacklist={&quot;*.museum&quot;}))    &gt;&gt;&gt; fut = sess.get(&quot;http://anice.museum/&quot;)    &gt;&gt;&gt; fut    &lt;Future at 0x10c696668 state=running&gt;    &gt;&gt;&gt; fut.result()    Traceback (most recent call last):    # [...]    advocate.exceptions.UnacceptableAddressException: anice.museumWhen should I use Advocate?===========================Any time you're fetching resources over HTTP for / from someone you don't trust!When should I not use Advocate?===============================That's a tough one. There are a few cases I can think of where I wouldn't:* When good, safe support for IPv6 is important* When internal hosts use globally routable addresses and you can't guess their prefix to blacklist it ahead of time* You already have a good handle on network security within your networkActually, if you're comfortable enough with Squid and network security, you should set up a secured Squid instance on a segregated subnetand proxy through that instead. Advocate attempts to guess whether an address references an internal hostand block access, but it's definitely preferable to proxy through a host can't access anything internal in the first place!Of course, if you're writing an app / library that's meant to be usable OOTB on other people's networks, Advocate + a user-configurableblacklist is probably the safer bet.This seems like it's been done before=====================================There've been a few similar projects, but in my opinion Advocate's approach is the best because:It sees URLs the same as the underlying HTTP library----------------------------------------------------Parsing URLs is hard, and no two URL parsers seem to behave exactly the same. The tiniestdifferences in parsing between your validator and the underlying HTTP library can leadto vulnerabilities. For example, differences between PHP's :python:`parse_url` and cURL'sURL parser `allowed a blacklist bypass in SafeCurl &lt;https://github.com/fin1te/safecurl/issues/5&gt;`_.Advocate doesn't do URL parsing at all, and lets requests handle it. Advocate only looks at theaddress requests actually tries to open a socket to.It deals with DNS rebinding---------------------------Two consecutive calls to :python:`socket.getaddrinfo` aren't guaranteed to return the sameinfo, depending on the system configuration. If the &quot;safe&quot; looking record TTLs betweenthe verification lookup and the lookup for actually opening the socket, we may endup connecting to a very different server than the one we OK'd!Advocate gets around this by only using one :python:`getaddrinfo` call for both verificationand connecting the socket. In pseudocode:.. code-block:: python    def connect_socket(host, port):        for res in socket.getaddrinfo(host, port):            # where `res` will be a tuple containing the IP for the host            if not is_blacklisted(res):                # ... connect the socket using `res`See `Wikipedia's article on DNS rebinding attacks &lt;https://en.wikipedia.org/wiki/DNS_rebinding&gt;`_ for more info.It handles redirects sanely---------------------------Most of the other SSRF-prevention libs cover this, but I've seen a lotof sample code online that doesn't. Advocate will catch it since it inspects*every* connection attempt the underlying HTTP lib makes. TODO====Proper IPv6 Support?--------------------Advocate's IPv6 support is still a work-in-progress, since I'm notthat familiar with the spec, and there are so many ways to tunnel IPv4 over IPv6,as well as other non-obvious gotchas. IPv6 records are ignored by defaultfor now, but you can enable by using an :python:`AddrValidator` with :python:`allow_ipv6=True`.It should mostly work as expected, but Advocate's approach might not even make sense withmost IPv6 deployments, see `Issue #3 &lt;https://github.com/JordanMilne/Advocate/issues/3&gt;`_ formore info.If you can think of any improvements to the IPv6 handling, please submit an issue or PR!Caveats=======* This is beta-quality software, the API might change without warning!* :python:`mount()` ing other adapters is disallowed to prevent Advocate's validating adapters from being clobbered.* Advocate does not, and might never support the use of HTTP proxies.* Proper IPv6 support is still a WIP as noted above.Acknowledgements================* https://github.com/fin1te/safecurl for inspiration* https://github.com/kennethreitz/requests for the lovely requests module* https://bitbucket.org/kwi/py2-ipaddress for the backport of ipaddress* https://github.com/hakobe/paranoidhttp a similar project targeting golang* https://github.com/uber-common/paranoid-request a similar project targeting Node* http://search.cpan.org/~tsibley/LWP-UserAgent-Paranoid/ a similar project targeting Perl 5</longdescription>
</pkgmetadata>