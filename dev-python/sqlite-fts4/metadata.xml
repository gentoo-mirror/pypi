<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># sqlite-fts4[![PyPI](https://img.shields.io/pypi/v/sqlite-fts4.svg)](https://pypi.org/project/sqlite-fts4/)[![Changelog](https://img.shields.io/github/v/release/simonw/sqlite-fts4?include_prereleases&amp;label=changelog)](https://github.com/simonw/sqlite-fts4/releases)[![Tests](https://github.com/simonw/sqlite-fts4/workflows/Test/badge.svg)](https://github.com/simonw/sqlite-fts4/actions?query=workflow%3ATest)[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](https://github.com/simonw/sqlite-fts4/blob/main/LICENSE)Custom SQLite functions written in Python for ranking documents indexed using the FTS4 extension.Read [Exploring search relevance algorithms with SQLite](https://simonwillison.net/2019/Jan/7/exploring-search-relevance-algorithms-sqlite/) for further details on this project.## DemoYou can try out these SQL functions [using this interactive demo](https://datasette-sqlite-fts4.datasette.io/24ways-fts4?sql=select%0D%0A++++json_object%28%0D%0A++++++++&quot;label&quot;%2C+articles.title%2C+&quot;href&quot;%2C+articles.url%0D%0A++++%29+as+article%2C%0D%0A++++articles.author%2C%0D%0A++++rank_score%28matchinfo%28articles_fts%2C+&quot;pcx&quot;%29%29+as+score%2C%0D%0A++++rank_bm25%28matchinfo%28articles_fts%2C+&quot;pcnalx&quot;%29%29+as+bm25%2C%0D%0A++++json_object%28%0D%0A++++++++&quot;pre&quot;%2C+annotate_matchinfo%28matchinfo%28articles_fts%2C+&quot;pcxnalyb&quot;%29%2C+&quot;pcxnalyb&quot;%29%0D%0A++++%29+as+annotated_matchinfo%2C%0D%0A++++matchinfo%28articles_fts%2C+&quot;pcxnalyb&quot;%29+as+matchinfo%2C%0D%0A++++decode_matchinfo%28matchinfo%28articles_fts%2C+&quot;pcxnalyb&quot;%29%29+as+decoded_matchinfo%0D%0Afrom%0D%0A++++articles_fts+join+articles+on+articles.rowid+%3D+articles_fts.rowid%0D%0Awhere%0D%0A++++articles_fts+match+%3Asearch%0D%0Aorder+by+bm25&amp;search=jquery+maps).## Installation    pip install sqlite-fts4## UsageThis module implements several custom SQLite3 functions. You can register them against an existing SQLite connection like so:```pythonimport sqlite3from sqlite_fts4 import register_functionsconn = sqlite3.connect(&quot;:memory:&quot;)register_functions(conn)```If you only want a subset of the functions registered you can do so like this:```pythonfrom sqlite_fts4 import rank_scoreconn = sqlite3.connect(&quot;:memory:&quot;)conn.create_function(&quot;rank_score&quot;, 1, rank_score)```if you want to use these functions with [Datasette](https://github.com/simonw/datasette) you can enable them by installing the [datasette-sqlite-fts4](https://github.com/simonw/datasette-sqlite-fts4) plugin:    pip install datasette-sqlite-fts4## rank_score()This is an extremely simple ranking function, based on [an example](https://www.sqlite.org/fts3.html#appendix_a) in the SQLite documentation. It generates a score for each document using the sum of the score for each column. The score for each column is calculated as the number of search matches in that column divided by the number of search matches for every column in the index - a classic [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) calculation.You can use it in a query like this:```sqlselect *, rank_score(matchinfo(docs, &quot;pcx&quot;)) as scorefrom docs where docs match &quot;dog&quot;order by score desc```You *must* use the `&quot;pcx&quot;` matchinfo format string here, or you will get incorrect results.## rank_bm25()An implementation of the [Okapi BM25](https://en.wikipedia.org/wiki/Okapi_BM25) scoring algorithm. Use it in a query like this:```sqlselect *, rank_bm25(matchinfo(docs, &quot;pcnalx&quot;)) as scorefrom docs where docs match &quot;dog&quot;order by score desc```You *must* use the `&quot;pcnalx&quot;` matchinfo format string here, or you will get incorrect results. If you see any `math domain` errors in your logs it may be because you did not use exactly the right format string here.## decode_matchinfo()SQLite's [built-in matchinfo() function](https://www.sqlite.org/fts3.html#matchinfo) returns results as a binary string. This binary represents a list of 32 bit unsigned integers, but reading the binary results is not particularly human-friendly.The `decode_matchinfo()` function decodes the binary string and converts it into a JSON list of integers.Usage:```sqlselect *, decode_matchinfo(matchinfo(docs, &quot;pcx&quot;))from docs where docs match &quot;dog&quot;```Example output:    hello dog, [1, 1, 1, 1, 1]## annotate_matchinfo()This function decodes the matchinfo document into a verbose JSON structure that describes exactly what each of the returned integers actually means.Full documentation for the different format string options can be found here: https://www.sqlite.org/fts3.html#matchinfoYou need to call this function with the same format string as was passed to `matchinfo()` - for example:```sqlselect annotate_matchinfo(matchinfo(docs, &quot;pcxnal&quot;), &quot;pcxnal&quot;)from docs where docs match &quot;dog&quot;```The returned JSON will include a key for each letter in the format string. For example:```json{    &quot;p&quot;: {        &quot;value&quot;: 1,        &quot;title&quot;: &quot;Number of matchable phrases in the query&quot;    },    &quot;c&quot;: {        &quot;value&quot;: 1,        &quot;title&quot;: &quot;Number of user defined columns in the FTS table&quot;    },    &quot;x&quot;: {        &quot;value&quot;: [            {                &quot;column_index&quot;: 0,                &quot;phrase_index&quot;: 0,                &quot;hits_this_column_this_row&quot;: 1,                &quot;hits_this_column_all_rows&quot;: 2,                &quot;docs_with_hits&quot;: 2            }        ],        &quot;title&quot;: &quot;Details for each phrase/column combination&quot;    },    &quot;n&quot;: {        &quot;value&quot;: 3,        &quot;title&quot;: &quot;Number of rows in the FTS4 table&quot;    },    &quot;a&quot;: {        &quot;title&quot;:&quot;Average number of tokens in the text values stored in each column&quot;,        &quot;value&quot;: [            {                &quot;column_index&quot;: 0,                &quot;average_num_tokens&quot;: 2            }        ]    },    &quot;l&quot;: {        &quot;title&quot;: &quot;Length of value stored in current row of the FTS4 table in tokens for each column&quot;,        &quot;value&quot;: [            {                &quot;column_index&quot;: 0,                &quot;length_of_value&quot;: 2            }        ]    }}```</longdescription>
</pkgmetadata>