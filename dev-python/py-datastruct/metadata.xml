<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># py-datastructThis is a (relatively) simple, **pure-Python, no dependency** library, aiming to simplify parsing and building binary data structures. It uses **[`dataclasses`](https://docs.python.org/3/library/dataclasses.html)** as its main container type, and **[`struct`](https://docs.python.org/3/library/struct.html)-compatible format specifiers** for writing field definitions.The way of composing structures is somewhat similar to (and inspired by) [Construct](https://github.com/construct/construct). While probably not as powerful, it should give more flexibility and control over the data, as well as **full IDE type hinting**.## Installation```shellpip install py-datastruct```## UsageThis simple example illustrates creating a 24-byte long structure, consisting of a 32-bit integer, an 8-byte 0xFF-filled padding, and a 12-byte `bytes` string.```pythonfrom hexdump import hexdumpfrom dataclasses import dataclassfrom datastruct import DataStructfrom datastruct.fields import field, padding@dataclassclass MyStruct(DataStruct):    my_number: int = field(&quot;I&quot;, default=123)    _1: ... = padding(8)    my_binary: bytes = field(&quot;12s&quot;)my_object = MyStruct(my_binary=b&quot;Hello Python&quot;)print(my_object)# MyStruct(my_number=123, my_binary=b'Hello World!')my_object = MyStruct(my_number=5, my_binary=b&quot;Hello World!&quot;)print(my_object)# MyStruct(my_number=5, my_binary=b'Hello World!')packed = my_object.pack()hexdump(packed)# 00000000: 05 00 00 00 FF FF FF FF  FF FF FF FF 48 65 6C 6C  ............Hell# 00000010: 6F 20 57 6F 72 6C 64 21                           o World!unpacked = MyStruct.unpack(packed)print(unpacked)# MyStruct(my_number=5, my_binary=b'Hello World!')print(my_object == unpacked)# True```You might also pass a stream (file/BytesIO/etc.) to `pack()` and `unpack()`. Otherwise, `pack()` will create a BytesIO stream and return its contents after packing; `unpack()` will accept a `bytes` object as its parameter.`pack()` and `unpack()` also accept custom, keyword-only arguments, that are available in the Context, throughout the entire operation.### ContextUpon starting a pack/unpack operation, a `Context` object is created. The context is a container scoped to the currently processed structure. It's composed of the following main elements:- all values of the current structure - when packing; during unpacking, it contains all values of fields that were already processes (the context &quot;grows&quot;)- all keyword arguments passed to `pack()`/`unpack()` (for the root context only)- all keyword arguments passed to `subfield()` (for child contexts only)- `_: Context` - reference to the parent object's context (only when nesting `DataStruct`s)- `self: Any` - the current datastruct - note that it's a `DataStruct` subclass when packing, and a `Container` when unpacking- `G` - global context - general-purpose container that is not scoped to the current structure (it's identical for nested structs)  - `io: IO[bytes]` - the stream being read from/written to  - `packing: bool` - whether current operation is packing  - `unpacking: bool` - whether current operation is unpacking  - `root: Context` - context of the topmost structure  - `tell: () -&gt; int` - function returning the current position in the stream  - `seek: (offset: int, whence: int) -&gt; int` - function allowing to seek to an absolute offset- `P` - local context - general-purpose container that is different for each nested struct  - `config: Config` - current DataStruct's config   - `tell: () -&gt; int` - function returning the current position in the current structure (in bytes)  - `seek: (offset: int, whence: int) -&gt; int` - function allowing to seek to an offset within the current structure  - `skip: (length: int) -&gt; int` - function allowing to skip `length` bytes  - `i: int` - (for `repeat()` fields only) index of the current item of the list  - `item: Any` - (for `repeat()` fields, in `last=` lambda only) item processed right before evaluation  - `self: Any` - (packing only) value of the current fieldThe context is &quot;general-purpose&quot;, meaning that the user can write custom values to it. All fields presented above can be accessed by lambda functions - see &quot;Parameter evaluation&quot;.### Parameter evaluationMost field parameters support pack/unpack-time evaluation (which means they can e.g. depend on previously read fields). Lambda expressions are then given the current context, and expected to return a simple value, that would be statically valid in this parameter.```pythonan_unpredictable_field: int = field(lambda ctx: &quot;I&quot; if randint(1, 10) % 2 == 0 else &quot;H&quot;)```### Ellipsis - special valueA special value of type `Ellipsis`/`...` is used in the library, to indicate something not having a type or a value. **It's not the same as `None`**. `built()` fields, for example, have `...` as value after creating the struct, but before packing it for the first time.Special fields (like `padding()`, which don't have any value) must have `...` as their type hint.### Variable-length fieldsThis is a simple example of using parameter evaluation to dynamically size a `bytes` string. Binary strings use the `&lt;len&gt;s` specifier, which can be omitted (simple `int` can be used instead). ```python@dataclassclass MyStruct(DataStruct):    data_length: int = field(&quot;I&quot;)    data: bytes = field(lambda ctx: ctx.data_length)```The user is still responsible for adjusting `data_length` after changing `data`. The `built()` field comes in handy here:```python@dataclassclass MyStruct(DataStruct):    data_length: int = built(&quot;I&quot;, lambda ctx: len(ctx.data))    data: bytes = field(lambda ctx: ctx.data_length)```When unpacking, the `data_length` field will be used to dynamically size the `data` field. When packing, `data_length` will always be recalculated based on what's in `data`.### Wrapper fields - storing a listLists are also iterables, like `bytes`, but they store a number of items of a specific type. Thus, the `repeat()` field **wrapper** has to be used. **Wrapper fields** simply require calling them first with any used parameters, then with the &quot;base&quot; field.```python@dataclassclass MyStruct(DataStruct):    item_count: int = built(&quot;H&quot;, lambda ctx: len(ctx.items))    # This creates a list of 16-bit integers.    # The list is empty by default.    items: List[int] = repeat(lambda ctx: ctx.item_count)(field(&quot;H&quot;))my_object = MyStruct()my_object.items = [0x5555, 0x4444, 0x3333, 0x2222]my_object.item_count = 1  # this doesn't matter, as the field is rebuiltpacked = my_object.pack()hexdump(packed)# 00000000: 04 00 55 55 44 44 33 33  22 22```### Conditional fieldsThey're also wrapper fields - if the condition is not met, they act like as if the field didn't exist at all.```python@dataclassclass MyStruct(DataStruct):    has_text: bool = field(&quot;?&quot;)    text: str = cond(lambda ctx: ctx.has_text)(field(&quot;8s&quot;, default=&quot;&quot;))my_object = MyStruct.unpack(b&quot;\x01HELOWRLD&quot;)print(my_object)# MyStruct(has_text=True, text='HELOWRLD')my_object = MyStruct.unpack(b&quot;\x00&quot;)print(my_object)# MyStruct(has_text=False, text='')```### Switch fieldsSwitch fields are like more powerful conditional fields. The following example reads an 8/16/32-bit number, depending on the prefixing length byte. If the length is not supported, it reads the value as `bytes` instead.```pythonnumber_length: int = field(&quot;B&quot;, default=1)number: Union[int, bytes] = switch(lambda ctx: ctx.number_length)(    _1=(int, field(&quot;B&quot;)),    _2=(int, field(&quot;H&quot;)),    _4=(int, field(&quot;I&quot;)),    default=(bytes, field(lambda ctx: ctx.number_length)),)```The values on the left (`_1`, `_2`, `_4`) are the **keys**. The key is picked depending on the key-lambda result (`ctx.number_length`). The value on the right is a tuple of the expected field type, and a `field()` specifier.Since it's not possible to pass just `1` as a keyword argument, integers are looked up prefixed with an underscore as well. Enums are additionally looked up by their name and value, and booleans are looked up by **lowercase** `true`/`false`.Note that you can pass (probably) any kind of field to the switch list.## To be continued## License```MIT LicenseCopyright (c) 2023 Kuba Szczodrzy≈ÑskiPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.```</longdescription>
</pkgmetadata>