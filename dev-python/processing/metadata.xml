<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>`processing` is a package for the Python language which supports thespawning of processes using the API of the standard library's`threading` module.  It runs on both Unix and Windows.Features:* Objects can be transferred between processes using pipes or   multi-producer/multi-consumer queues.* Objects can be shared between processes using a server process or  (for simple data) shared memory.* Equivalents of all the synchronization primitives in `threading`   are available.  * A `Pool` class makes it easy to submit tasks to a pool of worker  processes.Links=====* `Documentation &lt;http://pyprocessing.berlios.de/doc/index.html&gt;`_* `Installation instructions &lt;http://pyprocessing.berlios.de/doc/INSTALL.html&gt;`_* `Changelog &lt;http://pyprocessing.berlios.de/doc/CHANGES.html&gt;`_* `Acknowledgments &lt;http://pyprocessing.berlios.de/doc/THANKS.html&gt;`_* `BSD Licence &lt;http://pyprocessing.berlios.de/doc/COPYING.html&gt;`_The project is hosted at*    http://developer.berlios.de/projects/pyprocessingThe package can be downloaded from*    http://developer.berlios.de/project/filelist.php?group_id=9001 or*    http://pypi.python.org/pypi/processingExamples========The `processing.Process` class follows the API of `threading.Thread`.For example ::    from processing import Process, Queue    def f(q):        q.put('hello world')    if __name__ == '__main__':        q = Queue()        p = Process(target=f, args=[q])        p.start()        print q.get()        p.join()Synchronization primitives like locks, semaphores and conditions areavailable, for example ::    &gt;&gt;&gt; from processing import Condition    &gt;&gt;&gt; c = Condition()    &gt;&gt;&gt; print c    &lt;Condition(&lt;RLock(None, 0)&gt;), 0&gt;    &gt;&gt;&gt; c.acquire()    True    &gt;&gt;&gt; print c    &lt;Condition(&lt;RLock(MainProcess, 1)&gt;), 0&gt;One can also use a manager to create shared objects either in sharedmemory or in a server process, for example ::    &gt;&gt;&gt; from processing import Manager    &gt;&gt;&gt; manager = Manager()    &gt;&gt;&gt; l = manager.list(range(10))    &gt;&gt;&gt; l.reverse()    &gt;&gt;&gt; print l    [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]    &gt;&gt;&gt; print repr(l)    &lt;Proxy[list] object at 0x00E1B3B0&gt;Tasks can be offloaded to a pool of worker processes in various ways, for example ::    &gt;&gt;&gt; from processing import Pool    &gt;&gt;&gt; def f(x): return x*x    ...    &gt;&gt;&gt; p = Pool(4)    &gt;&gt;&gt; result = p.mapAsync(f, range(10))    &gt;&gt;&gt; print result.get(timeout=1)    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</longdescription>
</pkgmetadata>