<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Opinionated Python bindings for the `libyang` library[![Install via pip](https://img.shields.io/pypi/v/oopt-gnpy-libyang)](https://pypi.org/project/oopt-gnpy-libyang/)[![Python versions](https://img.shields.io/pypi/pyversions/oopt-gnpy-libyang)](https://pypi.org/project/oopt-gnpy-libyang/)[![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/Telecominfraproject/oopt-gnpy-libyang/ci.yaml)](https://github.com/Telecominfraproject/oopt-gnpy-libyang/actions/workflows/ci.yaml)Python bindings and packaging of [`libyang`](https://github.com/CESNET/libyang).We're focusing on parsing, validating and accessing YANG-modeled JSON data trees.Essentially, just enough to get [`gnpy`](https://github.com/Telecominfraproject/oopt-gnpy) going.Want more?Patches welcome.Compared to the [CFFI libyang bindings](https://github.com/CESNET/libyang-python), this wrapper takes care of low-level memory management.This means no more `node.free()` and `ctx.destroy()`.We also produce prebuilt binary [wheels](https://realpython.com/python-wheels/) to make installation very simple.## Usage### Loading YANG data```pythonimport oopt_gnpy_libyang as lyc = ly.Context('tests/yang', ly.ContextOptions.AllImplemented | ly.ContextOptions.NoYangLibrary)for m in ('iana-if-type', 'ietf-interfaces', 'ietf-ip'):    c.load_module(m)blob = '''{  &quot;ietf-interfaces:interfaces&quot;: {    &quot;interface&quot;: [      {        &quot;name&quot;: &quot;lo&quot;,        &quot;type&quot;: &quot;iana-if-type:softwareLoopback&quot;,        &quot;ietf-ip:ipv4&quot;: {          &quot;address&quot;: [            {              &quot;ip&quot;: &quot;127.0.0.1&quot;,              &quot;prefix-length&quot;: 8            }          ]        },        &quot;ietf-ip:ipv6&quot;: {          &quot;address&quot;: [            {              &quot;ip&quot;: &quot;::1&quot;,              &quot;prefix-length&quot;: 128            }          ]        }      },      {        &quot;name&quot;: &quot;eth0&quot;,        &quot;type&quot;: &quot;iana-if-type:ethernetCsmacd&quot;      }    ]  }}'''data = c.parse_data(blob,    ly.DataFormat.JSON, ly.ParseOptions.Strict | ly.ParseOptions.Ordered,    ly.ValidationOptions.Present | ly.ValidationOptions.NoState)```### Working with dataLibyang works with forests (sets of trees), this is how to process all the data:```pythonfor x in data.siblings():    print(f'a sibling: {x.path}')    for xx in x.childrenDfs():        print(f' {&quot;term &quot; if xx.is_term else &quot;child&quot;}: {xx.path}')        if xx.is_term:            print(f'  {xx.as_term()} {&quot; (default)&quot; if xx.as_term().is_default_value else &quot;&quot;}')```Data can be accessed via their known paths, of course. Either as a full, multi-level XPath:```pythondata[&quot;interface[name='lo']/ietf-ip:ipv6/address[ip='::1']/prefix-length&quot;].as_term().value == 128```Or individually, one item per index:```pythondata[&quot;interface[name='lo']&quot;][&quot;ietf-ip:ipv6&quot;][&quot;address[ip='::1']&quot;][&quot;prefix-length&quot;].as_term().value```Everything is an XPath, so it's possible to take a shortcut and skip specifying keys for single-element lists:```pythondata[&quot;interface[name='lo']&quot;][&quot;ietf-ip:ipv6&quot;][&quot;address&quot;][&quot;prefix-length&quot;].as_term().value == 128```The data are provided as native Python types:```pythontype(data[&quot;interface[name='lo']&quot;][&quot;ietf-ip:ipv6&quot;][&quot;address&quot;][&quot;prefix-length&quot;]    .as_term().value) == int```### Validation errorsIn libyang, if an operation fails, error details are available via `context.errors()`:```pythonimport jsonwrong = json.loads(blob)wrong[&quot;ietf-interfaces:interfaces&quot;][&quot;interface&quot;][0]\    [&quot;ietf-ip:ipv6&quot;][&quot;address&quot;][0][&quot;prefix-length&quot;] = 666try:    data = c.parse_data(json.dumps(wrong),        ly.DataFormat.JSON, ly.ParseOptions.Strict | ly.ParseOptions.Ordered,        ly.ValidationOptions.Present | ly.ValidationOptions.NoState)    assert Falseexcept ly.Error:    for error in c.errors():        assert error.path == &quot;Schema location \&quot;/ietf-interfaces:interfaces/interface/ietf-ip:ipv6/address/prefix-length\&quot;, data location \&quot;/ietf-ip:address[ip='::1']\&quot;, line number 1.&quot;        assert error.message == 'Value &quot;666&quot; is out of type uint8 min/max bounds.'```## InstallingWe're producing wheels for many popular platforms.The installation is as simple as:```console-session$ pip install oopt-gnpy-libyang```### Building from sourceSince this library is a Python wrapper around a C++ wrapper around a C library, source-based builds are more complex.They require:- a C++20 compiler (e.g., GCC 10+, clang 10+, MSVC 17.2+)- [`libyang`](https://github.com/CESNET/libyang) and its dependencies- [`libyang-cpp`](https://github.com/CESNET/libyang-cpp/) and its dependencies- [CMake](https://cmake.org/) 3.21+Unlike the wheels already bundle all the required libraries, when building from source, `libyang`, `libyang-cpp` and all their dependencies will have to be installed first.Also, in a from-source build these won't be bundled into the resulting package.For an inspiration, consult our [GitHub packaging recipes](./.github/workflows/ci.yaml).## LicenseCopyright Â© 2021-2023 Telecom Infra Project and GNPy contributors.Licensed under the [3-clause BSD license](LICENSE).</longdescription>
</pkgmetadata>