<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># J2GPP - Jinja2-based General Purpose Preprocessor`j2gpp` is a command-line tool for rendering templates using the Jinja2 syntax. It's intended purpose is to serve as a preprocessor for any programming or markup language with a unified syntax and flow across languages.- [J2GPP - Jinja2-based General Purpose Preprocessor](#j2gpp---jinja2-based-general-purpose-preprocessor)  - [Installation](#installation)  - [Basic usage](#basic-usage)  - [Command line arguments](#command-line-arguments)    - [Specify output directory](#specify-output-directory)    - [Specifying output file](#specifying-output-file)    - [Include search directory](#include-search-directory)    - [Passing global variables in command line](#passing-global-variables-in-command-line)    - [Loading global variables from files](#loading-global-variables-from-files)    - [Loading global variables from environment](#loading-global-variables-from-environment)    - [Loading custom Jinja2 filters](#loading-custom-jinja2-filters)    - [Loading custom Jinja2 tests](#loading-custom-jinja2-tests)    - [Processing variables before rendering](#processing-variables-before-rendering)    - [Option flags](#option-flags)    - [Context variables](#context-variables)    - [Built-in filters](#built-in-filters)  - [Process directories](#process-directories)  - [Supported formats for variables](#supported-formats-for-variables)    - [Command line define](#command-line-define)    - [YAML](#yaml)    - [JSON](#json)    - [XML](#xml)    - [TOML](#toml)    - [INI/CFG](#inicfg)    - [ENV](#env)    - [CSV/TSV](#csvtsv)  - [Scripting in J2GPP templates](#scripting-in-j2gpp-templates)    - [Conditional and do extension](#conditional-and-do-extension)    - [Conditional and filters](#conditional-and-filters)    - [Throw errors and warnings from template](#throw-errors-and-warnings-from-template)    - [Writing files](#writing-files)      - [Write example](#write-example)      - [Append example](#append-example)      - [Path argument](#path-argument)      - [Writing to both files](#writing-to-both-files)      - [Skipping the parent file](#skipping-the-parent-file)## InstallationWith `Python &gt;= 3.7`, Install from Pypi :``` shellpip install j2gpp```## Basic usage`j2gpp` requires at least one source be provided. The source paths can be files or directories, relative or absolute, and can use UNIX-style patterns such as wildcards. Template file names must end with the `.j2` extension which will be stripped at render.For more information about the Jinja2 syntax, see the documentation at [jinja.palletsprojects.com](https://jinja.palletsprojects.com/).For instance, suppose we have a templatized source file `foo.c.j2` :``` c#include &lt;stdio.h&gt;{% set message = &quot;Hello, world!&quot; %}int main() {  printf(&quot;{{message}}&quot;);  return 0;}```We can render the template using `j2gpp` :``` shellj2gpp ./foo.c.j2```The output is written to `foo.c` next to the source template :``` c#include &lt;stdio.h&gt;int main() {  printf(&quot;Hello, world!&quot;);  return 0;}```The following arguments can be added to the command for additional features. The details of each command is explained in the sections below.| Argument                | Description                                                           || ----------------------- | --------------------------------------------------------------------- || `-O/--outdir`           | Output directory for all rendered templates                           || `-o/--output`           | Output file for single template                                       || `-I/--incdir`           | Include search directory for include and import statements            || `-D/--define`           | Inline global variables for all templates                             || `-V/--varfile`          | Global variables files for all templates                              || `--envvar`              | Loads environment variables as global variables                       || `--filters`             | Load extra Jinja2 filters from a Python file                          || `--tests`               | Load extra Jinja2 tests from a Python file                            || `--file-vars-adapter`   | Load a Python function to process variables after loading from a file || `--global-vars-adapter` | Load a Python function to process all variables before rendering      || `--overwrite-outdir`    | Overwrite output directory                                            || `--warn-overwrite`      | Warn when overwriting files                                           || `--no-overwrite`        | Prevent overwriting files                                             || `--no-strict-undefined` | Disable error with undefined variable in template                     || `--no-check-identifier` | Disable warning when attributes are not valid identifiers             || `--fix-identifiers`     | Replace invalid characters from identifiers with underscore           || `--csv-delimiter`       | CSV delimiter (default: '`,`')                                        || `--csv-escapechar`      | CSV escape character (default: None)                                  || `--csv-dontstrip`       | Disable stripping whitespace of CSV values                            || `--render-non-template` | Process also source files that are not recognized as templates        || `--copy-non-template`   | Copy source files that are not templates to output directory          || `--force-glob`          | Glob UNIX-like patterns in path even when quoted                      || `--perf`                | Measure the execution time for performance testing                    || `--version`             | Print J2GPP version and quits                                         || `--license`             | Print J2GPP license and quits                                         |## Command line arguments### Specify output directoryBy default the rendered files are saved next to the source templates. You can provide an output directory with the `-O/--outdir` argument. The output directory path can be relative or absolute. If the directory doesn't exist, it will be created.For instance the following command will write the rendered file to `./bar/foo.c`.``` shellj2gpp ./foo.c.j2 --outdir ./bar/```### Specifying output fileBy default the rendered files are saved next to the source templates. If a single source template is provided, you can specify the output file directory and name with the `-o/--output` argument. The output file path can be relative or absolute. If the directory doesn't exist, it will be created.For instance the following command will write the rendered file to `./bar.c`.``` shellj2gpp ./foo.c.j2 --output ./bar.c```### Include search directoryThe `include` and `import` Jinja2 statements require specifying the directory in which the renderer will search. That is provided using the `-I/--incidr` argument.For instance, with the following command, the files in the directory `./includes/` will be available to `include` and `import` statements when rendering the template `foo.c.j2`.``` shellj2gpp ./foo.c.j2 --incdir ./includes/```### Passing global variables in command lineYou can pass global variables to all templates rendered using the `-D/--define` argument with a list of variables in the format `name=value`. Values are parsed to cast to the correct Python type as explained [later](#command-line-define). Dictionary attributes to any depth can be assigned using dots &quot;`.`&quot; to separate the keys. Global variables defined in the command line overwrite the global variables set by loading files.For instance, with the following command, the variable `bar` will have the value `42` when rendering the template `foo.c.j2`.``` shellj2gpp ./foo.c.j2 --define bar=42```### Loading global variables from filesYou can load global variables from files using the `-V/--varfile` argument with a list of files. The file paths can be relative or absolute, and can use UNIX-style patterns such as wildcards. Variables file types supported right now are YAML, JSON, XML, TOML, INI/CFG, ENV, CSV and TSV. Global variables loaded from files are overwritten by variables defined in the command line.For instance, with the following command, the variable `bar` will have the value `42` when rendering the template `foo.c.j2`.``` shellj2gpp ./foo.c.j2 --varfile ./qux.yml```With the variables file `qux.yml` :``` ymlbar: 42```### Loading global variables from environmentYou can import the environment variables of the shell as global variables using the `--envvar` argument. The name of the variables will be that of the environment variable and the value will be cast automatically to the proper Python/Jinja2 type.For instance, with the following command, the variable `BAR` will have the value `42` when rendering the template `foo.c.j2`.``` shellexport BAR=42j2gpp ./foo.c.j2 --envvar```If a string is provided after the `--envvar` argument, the environment variables will be stored in an object of the name provided instead of at the root.For instance, with the following command, the variable `ENV.BAR` will have the value `42` when rendering the template `foo.c.j2`.``` shellexport BAR=42j2gpp ./foo.c.j2 --envvar ENV```### Loading custom Jinja2 filtersYou can import custom Jinja2 filters by providing Python files with the `--filters` argument. All functions defined in the python files will be available as Jinja2 filters in the templates.For instance, with the following command and python file, the filter `right_ajust` will be available when rendering the template `foo.c.j2`.``` shellj2gpp ./foo.c.j2 --filters ./bar.py`````` python# bar.pydef right_ajust(s, length=0):  return s.rjust(length)```### Loading custom Jinja2 testsYou can import custom Jinja2 tests by providing Python files with the `--tests` argument. All functions defined in the python files will be available as Jinja2 tests in the templates.For instance, with the following command and python file, the test `prime` will be available when rendering the template `foo.c.j2`.``` shellj2gpp ./foo.c.j2 --tests ./bar.py`````` python# bar.pyimport mathdef prime(x):  if x&lt;=1: return False  for i in range(2,int(math.sqrt(x))+1):    if (x%i) == 0:      return False  return True```### Processing variables before renderingYou can perform transformations on the dictionary storing the variables before rendering templates by providing a Python function with the argument `--global-vars-adapter`. It takes two arguments, the first is the path to the Python script, and the second is the name of the function to use. The function must take in a single argument, the variables dictionary, and modify it as a reference (not return the modified dictionary). You can also provide an adapter function to be run on the variables loaded from each file before they are written to the global variables object by providing a function with the argument `--file-vars-adapter`.For instance, with the following command and python file, the variable dictionary loaded from the file `qux.yml` will be processed by the function `shout_values()` before rendering the template `foo.c.j2`.``` shellj2gpp ./foo.c.j2 --varfile ./qux.yml --file-vars-adapter ./bar.py shout_values`````` python# bar.pydef shout_values(var_dict):  for key,val in var_dict.items():    if isinstance(val, str):      var_dict[key] = val.upper()```### Option flagsSome arguments are flags to enable or disable special features. This is more advanced but can be useful in niche situations.`--overwrite-outdir` cleans the output directory before rendering the templates and copying any other files.`--warn-overwrite` enables warnings triggered whenever a file is overwritten.`--no-overwrite` prevents any file from being overwritten, and triggers a warning when that happens.`--no-strict-undefined` disables errors triggered whenever a template variable is used but not defined.`--no-check-identifier` disables the ckecking that the variables names and attributes are valid Python identifiers. Root variables with a name not passing this check will not be accessible in Jinja2 templates.`--fix-identifiers` fixes variables and attributes names that are not valid Python identifiers by replacing incorrect characters by underscores, and if the first character is a number, an underscore is added before.`--csv-delimiter` followed by a string will change the delimiter used to parse CSV variables files. The default is &quot;`,`&quot;.`--csv-escapechar` followed by a character sets the escape character used to parse CSV variables files. There is no escape character by default.`--csv-dontstrip` disables the stripping of whitespace from CSV keys and values.`--render-non-template` forces every source file found to be rendered, even if they are not recognized as a template (by ending with a template extension). The resulting file will be saved in the location following the rules of regular templates, but instead of removing the template extension, they will have a suffix added before the file extensions. By default, this suffix is `_j2gpp`, but this can be replaced by whatever is specified after the flag argument.`--copy-non-template` enables the copying of the source files that are not recognized as templates or the files in the source directories to the output directory when one is provided with the `--outdir` argument.`--force-glob` enables globbing UNIX-like patterns in the source files paths even if they are surrounded by quotes. This is disabled by default to allow processing files with `*` and `[...]` in their path. Paths provided without quotes are preprocessed by the shell and any wildcard or other patterns cannot be prevented.### Context variablesUseful context variables are added before any other variable is loaded. Some are global for all templates rendered, and some are template-specific.| Variable                | Scope    | Description                                   || ----------------------- | -------- | --------------------------------------------- || `__python_version__`    | Global   | Python version                                || `__jinja2_version__`    | Global   | Jinja2 version                                || `__j2gpp_version__`     | Global   | J2GPP version                                 || `__user__`              | Global   | Name of the current user                      || `__pid__`               | Global   | Process ID of the current process             || `__ppid__`              | Global   | Process ID of the parent process              || `__working_directory__` | Global   | Working directory                             || `__output_directory__`  | Global   | Output directory                              || `__date__`              | Global   | Date in the format `DD-MM-YYYY`               || `__date_inv__`          | Global   | Date in the format `YYYY-MM-DD`               || `__time__`              | Global   | Time in the format `hh:mm:ss`                 || `__datetime__`          | Global   | Timestamp in the format `YYYY-MM-DD hh:mm:ss` || `__source_path__`       | Template | Path of the source template file              || `__output_path__`       | Template | Path where the template is rendered           |### Built-in filtersIn addition to the [Jinja2 built-in filters](https://jinja.palletsprojects.com/en/latest/templates/#builtin-filters), J2GPP also defines many useful filter functions.All functions from the Python libraries `math` and `statistics` are made available as filters. This includes useful functions such as `sqrt`, `pow`, `log`, `sin`, `cos`, `floor`, `ceil`, `mean`, `median`, `variance`, `stdev`, ...An operation can be applied to all elements of a list with the filters `list_add`, `list_sub`, `list_mult`, `list_div`, `list_mod`, `list_rem` and `list_exp` respectively for the Python operators `+`, `-`, `*`, `/`, `%`, `//` and `**`.Text alignment can be controlled with the Python functions `ljust`, `rjust` and `center`.Case and formatting can be controlled with the Python functions `title` and `swapcase`, or the added functions `camel`, `pascal`, `snake` and `kebab`. `camel` and `pascal` will remove the underscores and hyphens by default but leave the dots ; that behaviour can be changed by providing the filter arguments `remove_underscore`, `remove_hyphen` and `remove_dot` as `True` or `False`. `snake` and `kebab` will group capitalized letters and preserve capitalization by default ; that behaviour can be changed by providing the filter arguments `preserve_caps` and `group_caps` as `True` or `False`.Paragraph formatting is facilitated by multiple filters that should be used on a `filter` block. `reindent` removes pre-existing indentation and sets new one. `autoindent` removes pre-existing indentation and sets new indent by incrementing and decrementing the depth based on start and end delimiters of blocks provided by the `starts` and `ends` lists of strings provided by argument (culry braces by default). `align` aligns every line of the paragraph by columns, left before `§`, right before `§§`.When using a list of dictionaries with a key in common, you can get the list element with the minimum or maximum value of that attribute using the filters `el_of_max_attr` or `el_of_min_attr`.When using two-level dictionaries, the key corresponding to the minimum or maximum with regards to a specified attribute using the filters `key_of_max_attr` or `key_of_min_attr`.You can count the number of occurrences of a value in a list using the `count` filter.The `write` and `append` filters can be used to export the content of a filter to another file whose path is provided as argument to the filter. The path can be absolute or relative to the output rendered base template. By default, the content of the filter is not written to the base rendered template ; this behaviour can be changed by providing the filter argument `preserve` as `True`. The source template can also be prevented from resulting in a generated file by providing the filter argument `write_source` as `False`, and only the content of `write` and `append` blocks will generate files.The `warning` and `error` filters can be used to throw warnings and errors from the template that will be displayed in the J2GPP logs. The filter is applied to a block, replaces the block with nothing and throws the warning or error with the content of the block as comment. The filter works with conditional blocks if the version of Jinja2 installed supports the `@render_time_only` decorator.## Process directoriesWhen the source path provided corresponds to a directory, J2GPP will look for any template files in the source directory tree. If no output directory argument is provided, the rendered files will be written next to the source templates. If an output directory is provided, the source directory tree structure will be copied to the output directory with only the rendered files.For instance, suppose we have the following directory structure :``` txt.└── test_dir    ├── sub_dir_1    │   ├── deep_dir    │   │   └── template_1.txt.j2    │   └── non_template_1.txt    ├── sub_dir_2    │   └── non_template_2.txt    └── template_2.txt.j2```When we execute the command `j2gpp ./test_dir/`, we will get :``` txt.└── test_dir    ├── sub_dir_1    │   ├── deep_dir    │   │   ├── template_1.txt    │   │   └── template_1.txt.j2    │   └── non_template_1.txt    ├── sub_dir_2    │   └── non_template_2.txt    ├── template_2.txt    └── template_2.txt.j2```But if we provide an output directory with the command `j2gpp ./test_dir/ --outdir ./out_dir/`, we will get :``` txt.├── test_dir│   ├── sub_dir_1│   │   ├── deep_dir│   │   │   └── template_1.txt.j2│   │   └── non_template_1.txt│   ├── sub_dir_2│   │   └── non_template_2.txt│   └── template_2.txt.j2└── out_dir    ├── sub_dir_1    │   └── deep_dir    │       └── template_1.txt    └── template_2.txt```We can also tell J2GPP to copy the non-template files with the command `j2gpp ./test_dir/ --outdir ./out_dir/ --copy-non-template`, then we will get :``` txt.├── test_dir│   ├── sub_dir_1│   │   ├── deep_dir│   │   │   └── template_1.txt.j2│   │   └── non_template_1.txt│   ├── sub_dir_2│   │   └── non_template_2.txt│   └── template_2.txt.j2└── out_dir    ├── sub_dir_1    │   ├── deep_dir    │   │   └── template_1.txt    │   └── non_template_1.txt    ├── sub_dir_2    │   └── non_template_2.txt    └── template_2.txt```Or even to process non-templates files as templates anyway with the command `j2gpp ./test_dir/ --outdir ./out_dir/ --render-non-template`, then we will get :``` txt.├── test_dir│   ├── sub_dir_1│   │   ├── deep_dir│   │   │   └── template_1.txt.j2│   │   └── non_template_1.txt│   ├── sub_dir_2│   │   └── non_template_2.txt│   └── template_2.txt.j2└── out_dir    ├── sub_dir_1    │   ├── deep_dir    │   │   └── template_1.txt    │   └── non_template_1_j2gpp.txt    ├── sub_dir_2    │   └── non_template_2_j2gpp.txt    └── template_2.txt```## Supported formats for variablesJinja2 supports variables types from python. The main types are None, Boolean, Integer, Float, String, Tuple, List and Dictionary. J2GPP provides many ways to set variables and not all types are supported by each format.### Command line defineDefines passed by the command line are interpreted by the Python [ast.literal_eval()](https://docs.python.org/3/library/ast.html#ast.literal_eval) function which supports Python syntax and some additional types such as `set()`.``` shellj2gpp ./foo.c.j2 --define test_none=None             \                          test_bool=True             \                          test_int=42                \                          test_float=3.141592        \                          test_string1=lorem         \                          test_string2=&quot;lorem ipsum&quot; \                          test_tuple=&quot;(1,2,3)&quot;       \                          test_list=&quot;[1,2,3]&quot;        \                          test_dict=&quot;{'key1': value1, 'key2': value2}&quot; \                          test_dict.key3=value3```### YAML``` ymltest_none1:test_none2: nulltest_bool1: truetest_bool2: falsetest_int: 42test_float: 3.141592test_string1: lorem ipsumtest_string2:  single  line  texttest_string3: |  multi  line  texttest_list1: [1,2,3]test_list2:  - 1  - 2  - 3test_dict:  key1: value1  key2: value2  key3: value3```### JSON``` json{  &quot;test_none&quot;: null,  &quot;test_bool1&quot;: true,  &quot;test_bool2&quot;: false,  &quot;test_int&quot;: 42,  &quot;test_float&quot;: 3.141592,  &quot;test_string&quot;: &quot;lorem ipsum&quot;,  &quot;test_list&quot;: [1,2,3],  &quot;test_dict&quot;: {    &quot;key1&quot;: &quot;value1&quot;,    &quot;key2&quot;: &quot;value2&quot;,    &quot;key3&quot;: &quot;value3&quot;  }}```### XMLNote that XML expects a single root element. To avoid having to specify the root element when using the variables in a template, J2GPP automatically removes the root element level if it is named &quot;`_`&quot;.``` xml&lt;_&gt;  &lt;test_none&gt;&lt;/test_none&gt;  &lt;test_bool1&gt;true&lt;/test_bool1&gt;  &lt;test_bool2&gt;false&lt;/test_bool2&gt;  &lt;test_int&gt;42&lt;/test_int&gt;  &lt;test_float&gt;3.141592&lt;/test_float&gt;  &lt;test_string&gt;lorem ipsum&lt;/test_string&gt;  &lt;test_list&gt;1&lt;/test_list&gt;  &lt;test_list&gt;2&lt;/test_list&gt;  &lt;test_list&gt;3&lt;/test_list&gt;  &lt;test_dict&gt;    &lt;key1&gt;value1&lt;/key1&gt;    &lt;key2&gt;value2&lt;/key2&gt;    &lt;key3&gt;value3&lt;/key3&gt;  &lt;/test_dict&gt;&lt;/_&gt;```### TOML``` tomltest_bool1 = truetest_bool2 = falsetest_int = 42test_float = 3.141592test_string1 = &quot;lorem ipsum&quot;test_string2 = &quot;&quot;&quot;multilinetext&quot;&quot;&quot;test_list = [1,2,3][test_dict]key1 = &quot;value1&quot;key2 = &quot;value2&quot;key3 = &quot;value3&quot;```### INI/CFGNote that INI file expects data to be divided in sections with a header in square brackets. To avoid having to specify the root element when using the variables in a template, J2GPP automatically flattens the section whose header is &quot;`_`&quot;.``` ini[_]test_bool1 = Truetest_bool2 = Falsetest_int = 42test_float = 3.141592test_string = &quot;lorem ipsum&quot;test_list = [1,2,3][test_dict]key1 = value1key2 = value2key3 = value3```### ENV``` envtest_bool1 = Truetest_bool2 = Falsetest_int = 42test_float = 3.141592test_string = lorem ipsumtest_list = [1,2,3]test_dict = {'key1':'value1','key2':'value2','key3':'value3'}```### CSV/TSVCSV and TSV are interpreted as a list of objects with the same attributes. They are converted to a list of dictionaries whose name is the first cell of each line and the keys are the headers of each column.CSV and TSV use the same loader, just with different delimiters. A different delimiter can be provided with the argument `--csv-delimiter`. To use the delimiter in a value, it can be escaped by defining an escape character with the argument `--csv-escapechar`, for instance the backslash &quot;`\`&quot;.By default, the whitespace around the keys and values in the CSV is stripped. This behaviour can be disabled with the argument `--csv-dontstrip`.``` csvkeys,key1,key2,key3test_dict1,1,2,3test_dict2,11,12,13test_dict3,21,22,23`````` tsvkeys  key1  key2  key3test_dict1  1  2  3test_dict2  11  12  13test_dict3  21  22  23```## Scripting in J2GPP templatesAn advanced use of the template feature and filters of Jinja2 and J2GPP allow this tool to do some amount of scripting. The main features allowing this usage are explained in this section.### Conditional and do extensionThe basic Jinja2 feature of conditional blocks `if`/`elif`/`else` can be used alongside the `do` extension to more easily manipulate variables and complex objects such as Python dictionaries.Note that, if possible, it is preferable to process the variables after loading and before rendering by providing a Python function with the `--vars-post-processor` command line argument.### Conditional and filtersAs filters are Python functions, they can be very powerful, especially when coupled with the use of conditional blocks. However, Jinja2 optimizes processing by running some filters during the compilation phase, while conditional blocks are resolved at render time.To fix this, you can use the `@render_time_only` decorator to force a filter or test to execute at render time only. This decorator is [currently](https://github.com/pallets/jinja/pull/1759) only available by installing a custom fork of Jinja2 :``` shellgit clone https://github.com/Louis-DR/jinja.gitcd jinjapip3 install ./```### Throw errors and warnings from templateIf the version of Jinja2 installed supports the `@render_time_only` decorator, then the `warning` and `error` filters allow to throw warnings and erros from the template and display them in the J2GPP logs. This is useful with conditionals to perform data sanity checks for instance.### Writing filesThe J2GPP filters `write` and `append` allow exporting the content of a block to another file. This can be used for a file combining elements contributed by multiple templates, for alternative versions of a file from a single template, for generating small annex files to a large template, for generating a files for each element in a list, etc. When coupled with the `include` or `macro` statements with nested temlates, it allows for even more complex outputs.Note that if the installed Jinja2 version doesn't support the `@render_time_only` decorator, using the `write` and `append` filters in conditional blocks may results in unwnated behaviour.#### Write exampleFor example, with the parent template `parent.txt.j2`:``` jinja2This will be rendered to the parent output file{% filter write(&quot;child.txt&quot;) %}This will be rendered to the child output file{% endfilter %}`````` shell&gt;&gt;&gt; tree.└── parent.txt.j2&gt;&gt;&gt; j2gpp ./parent.txt.j2[...]&gt;&gt;&gt; tree.├── child.txt├── parent.txt└── parent.txt.j2&gt;&gt;&gt; cat parent.txtThis will be rendered to the parent output file&gt;&gt;&gt; cat child.txtThis will be rendered to the child output file```#### Append exampleIf the file doesn't exists, the `append` filter will create it and be equivalent to `write`. However, if the file already exists, `write` will override it while `append` will append to the end of it. For example, with the parent template `parent.txt.j2`:``` jinja2This will be rendered to the parent output file{% filter append(&quot;child.txt&quot;) %}This will be rendered to the child output file{% endfilter %}`````` shell&gt;&gt;&gt; tree.└── parent.txt.j2&gt;&gt;&gt; j2gpp ./parent.txt.j2[...]&gt;&gt;&gt; tree.├── child.txt├── parent.txt└── parent.txt.j2&gt;&gt;&gt; cat parent.txtThis will be rendered to the parent output file&gt;&gt;&gt; cat child.txtThis will be rendered to the child output file&gt;&gt;&gt; j2gpp ./parent.txt.j2[...]&gt;&gt;&gt; cat child.txtThis will be rendered to the child output fileThis will be rendered to the child output file&gt;&gt;&gt; j2gpp ./parent.txt.j2[...]&gt;&gt;&gt; cat child.txtThis will be rendered to the child output fileThis will be rendered to the child output fileThis will be rendered to the child output file```#### Path argumentThe `write` and `append` filters require at least one argument, the name or path of the second file to generate. The path can be absolute, or relative to the generated file of the parent template. Non-existing directories will be created. For example, with the parent template `parent.txt.j2`:``` jinja2{% filter write(&quot;foo/child.txt&quot;) %}This will be rendered to the child output file{% endfilter %}`````` shell&gt;&gt;&gt; tree.└── src    └── parent.txt.j2&gt;&gt;&gt; j2gpp ./src/parent.txt.j2 --outdir ./gen/[...]&gt;&gt;&gt; tree.├── src│   └── parent.txt.j2└── gen    ├── foo    │   └── child.txt    └── parent.txt```#### Writing to both filesBy default, the content of the block is only written to the child file, and is not written to the parent rendered template. This behaviour can be changed by providing the filter argument `preserve` as `True`. For example, with the parent template `parent.txt.j2`:``` jinja2{% filter write(&quot;child.txt&quot;, preserve=True) %}This will be rendered to both parent and child output files{% endfilter %}`````` shell&gt;&gt;&gt; j2gpp ./parent.txt.j2 --outdir ./gen/[...]&gt;&gt;&gt; cat ./parent.txtThis will be rendered to both parent and child output files&gt;&gt;&gt; cat ./child.txtThis will be rendered to both parent and child output files```#### Skipping the parent fileThe source template can also be prevented from resulting in a generated file by providing the filter argument `write_source` as `False`, and only the content of `write` and `append` blocks will generate files. For example, with the parent template `parent.txt.j2`:``` jinja2This will not be written to any file{% filter write(&quot;child.txt&quot;) %}This will be rendered to the child output file{% endfilter %}`````` shell&gt;&gt;&gt; tree.└── parent.txt.j2&gt;&gt;&gt; j2gpp ./parent.txt.j2[...]&gt;&gt;&gt; tree.├── child.txt└── parent.txt.j2&gt;&gt;&gt; cat child.txtThis will be rendered to the child output file```</longdescription>
</pkgmetadata>