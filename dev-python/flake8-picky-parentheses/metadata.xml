<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Picky Parentheses=================Picky Parentheses is a [flake8](https://github.com/pycqa/flake8) plugin thatnitpicks all things parentheses, brackets and braces.The plugin has two components: 1. A checker that warns about redundant parentheses (with some exceptions). 2. A checker for parentheses, brackets, and braces alignment.    This component is very opinionated but has its own error codes so you can    easily disable it.## Table of Contents * [Installation and Usage](#installation-and-usage) * [Error Codes](#error-codes) * [Details and Exceptions](#details-and-exceptions) * [Additional Notes](#additional-notes)## Installation and UsageThis is a plugin for `flake8`. It supports Python 3.7 - 3.11.  Refer to the documentation of `flake8` on how to run it on your code:https://flake8.pycqa.org/en/latest/Two common options are to either install the plugin and then run `flake8`:```bashpip install flake8-picky-parenthesesflake8 '&lt;path/to/your/code&gt;'```Or to let `flake8` fetch the plugin for you (requires `flake8 &gt;= 5.0.0`):```bashflake8 --require-plugins flake8-picky-parentheses '&lt;path/to/your/code&gt;'```If you only want to run this plugin and bypass any other `flake8` checks, youcan use the `--select` option:```bashflake8 [other options] --select='PAR0,PAR1' '&lt;path/to/your/code&gt;'```Where `PAR0` is the code for the redundant parentheses checker and `PAR1` isthe code for the parentheses alignment checker.If you, in turn want to disable the opinionated parentheses alignment checker,you can use the `--ignore` or `--extend-ignore` option:```bashflake8 [other options] --extend-ignore='PAR1' '&lt;path/to/your/code&gt;'```## Error CodesThese are the error codes which you can get using this plugin:| Code                | Brief Descritption                                                     ||---------------------|------------------------------------------------------------------------|| [`PAR0xx`](#par0xx) | [Group] Redundant parentheses                                          || [`PAR001`](#par001) | Redundant parentheses (general)                                        || [`PAR002`](#par002) | Parenteheses used for tuple unpacking                                  ||                     |                                                                        || [`PAR1xx`](#par1xx) | [Group] (Opinioinated) parentheses, brackets, braces not well-alinged  || [`PAR101`](#par101) | Opening bracket is last, but closing is not on new line                || [`PAR102`](#par102) | Closing bracket has different indentation than the line with the opening bracket || [`PAR103`](#par103) | Consecutive opening brackets at the end of the line must have consecutive closing brackets. || [`PAR104`](#par104) | Only operators and comments are allowed after a closing bracket on a new line |### `PAR0xx`These are the error codes for the redundant parentheses checker.#### `PAR001`It means that you use redundant parentheses, and they do not help readability.For example:```python# BADa = ((&quot;a&quot;, &quot;b&quot;))```#### `PAR002`It means that you use parentheses for an unpacking expression. For example:```python# BAD(a,) = &quot;b&quot;```#### `PAR1xx`These are the error codes for the opinionated alignment checker.#### `PAR101`It means that the opening bracket is last in its line, but closing one is noton a new line. For example:```python# BADif (        a == b):    c + d# GOODif (    a == b):    c + d# BADa = [    1, 2,    3, 4]# GOODa = [    1, 2,    3, 4]# GOODa = [1, 2,     3, 4]```#### `PAR102`It means that closing bracket is on new line, but there is a indentationmismatch. For example:```python# BADif (    a == b        ):    c + d# GOODif (    a == b):    c + d# BADa = [    1, 2,    3, 4    ]# GOODa = [    1, 2,    3, 4]```#### `PAR103`It means that consecutive opening brackets at the end of a line must haveconsecutive closing brackets.```python# BADanswer = func((    1, 2, 3, 4, 5,    ))# GOODanswer = func((    1, 2, 3, 4, 5,))```#### `PAR104`Only operators and comments are allowed after a closing bracket on a new line.```python# BADa = func(    1, 2, 3, 4, 5) + 6# GOODa = (    func(        1, 2, 3, 4, 5    )    + 6)```## Details and ExceptionsThe redundant parentheses checker uses Python's `tokenize` and `ast` module totry to remove each pair of parentheses and see if the code still compiles andyields the same AST (i.e., is semantically equivalent).If it does, a flake (lint error) is reported. However, there are two notableexceptions to this rule: 1. Parentheses for tuple literals 2. A single pair or parentheses in expressions to highlight operator    precedence.    Even if these parentheses are redundant, they help to divide parts of    expressions and show sequence of actions. 3. Parts of slices 4. Multi-line&lt;sup&gt;[1)](#footnotes)&lt;/sup&gt; `if` and `for` parts in comprehensions. 5. Multi-line&lt;sup&gt;[1)](#footnotes)&lt;/sup&gt; keyword arguments or argument defaults.Exception type 1:```pythona = (&quot;a&quot;,)     # GOODa = &quot;a&quot;,       # GOODa = (&quot;a&quot;)      # BADa = ((&quot;a&quot;),)   # BADa = ((&quot;a&quot;,))   # BADfoo((&quot;a&quot;,))    # GOODfoo(&quot;a&quot;,)      # BAD```Exception type 2:```pythona = (1 + 2) + 3            # GOODa = (1 + 2) % 3            # GOODa = 1 and (2 + 3)          # GOODa = (1 / 2) * 3            # GOODa = not (1 + 2)            # GOODa = (not 1) + 2            # GOODa = 1 + (2 if a else 3)    # GOODa = foo(*(a if b else c))  # GOODa = foo(*(a + b))          # GOODa = foo(**(a + b))         # GOODa = (1 + 2)                # BADa = 1 + (2)                # BADa = ((not 1)) + 2          # BADa = foo(*(a))              # BADa = foo(**(a))             # BAD```Exception type 3:```pythonfoo[(1 + 2):10]    # GOODfoo[1:(1 + 2)]     # GOODfoo[1:5:(1 + 1)]   # GOODfoo[:(-bar)]       # GOODfoo[(1):]          # BADfoo[:(1)]          # BAD```Exception type 4:```python# GOODa = (    b for b in c    if (        some_thing == other_thing        or whatever_but_long    ))# GOODa = [    b for b in c    if (b        in d)]# BADa = (    b for b in c    if (b in d))# GOODa = (    b for b in (c                + d))# BADa = (    b for b in (c + d))```Exception type 5:```python# GOODfoo(bar=(a         in b))# BADfoo(bar=(a in b))# GOODdef foo(bar=(a             is b)):    ...# BADdef foo(bar=(a is b)):    ...```### Footnotes:1. Multi-line means that either   * the expression spans multiple lines, e.g.,     ```python     (a      + b)     ```   * or the first part of the expression is on a new line (e.g., if a name is very long), e.g.,     ```python     (         veeeeeeeeeeery_looooooong_name     )     ```     but also     ```python     (         a         + b     )     ```   Multi-line exceptions do **not** include   ```python   (a + b   )   ```## Additional NotesThis plugin was developed to improve the code quality of Neo4j Python projects.</longdescription>
</pkgmetadata>