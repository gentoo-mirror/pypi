<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>totaltimeout============*Get timeouts right, without the hassle.*So you're writing a function that takes a timeout.. code:: python    def foo(timeout):        ...and inside it you do something like.. code:: python    bar(timeout)    qux(timeout)*Wrong!* The right way is to subtract the time spent in the firstfunction, and pass just the remaining time as the timeout to thesecond function.Or maybe you want to put a retry loop around a function that takesa timeout:.. code:: python    while ...:        foo(timeout)The right way is to set a timeout for the whole loop, subtract thetime each iteration took, pass the remaining time to the function,and break out once we're out of time.``totaltimeout`` lets you code timeouts the right way, withoutwriting all that boilerplate to calculate the remaining time.Versioning----------This library's version numbers follow the `SemVer 2.0.0specification &lt;https://semver.org/spec/v2.0.0.html&gt;`_.Installation------------::    pip install totaltimeoutUsage-----Import the ``Timeout`` class... code:: python    from totaltimeout import TimeoutWaiting in a &quot;timed loop&quot; for an API with retries (usefulfor unreliable APIs that may either hang or need retries):.. code:: python    for time_left in Timeout(SOME_NUMBER_OF_SECONDS):         reply = requests.get(api_url, timeout=time_left)         if reply.status == 200:             breakSame as above, but with a wait between retries:.. code:: python    timeout = Timeout(SOME_NUMBER_OF_SECONDS)    for time_left in timeout:         reply = requests.get(api_url, timeout=time_left)         if reply.status == 200:             break         # If you need to get the remaining time again in the same         # loop iteration, you have to use the .time_left() method:         if timeout.time_left() &lt;= RETRY_DELAY:             break         time.sleep(RETRY_DELAY)Waiting for multiple tasks to finish:.. code:: python    timeout = Timeout(10.0)    thread_foo.join(timeout.time_left())    thread_bar.join(timeout.time_left())    thread_qux.join(timeout.time_left())    # Works out almost as if we waited 10    # seconds for each thread in parallel.Waiting for multiple tasks within each iteration of a &quot;timed loop&quot;:.. code:: python    timeout = Timeout(SOME_NUMBER_OF_SECONDS)    for time_left in timeout:         some_work(timeout=time_left)         some_more_work(timeout=timeout.time_left())         some_other_work(timeout=timeout.time_left())Using a monotonic clock instead of the wall clock:.. code:: python    import time    timeout = Timeout(10.0, clock=time.monotonic)You can also set the starting time of the timeout. This lets timeoutscount down from a well-known point in time, which can be useful fortesting, for synchronizing timeouts across networks, and so on:.. code:: python    start_of_this_minute = (time.now() // 60) * 60    timeout = Timeout(10.0, start=start_of_this_minute).. code:: python    moment_in_time = time.now()    timeout = Timeout(10.0, start=moment_in_time)    time.sleep(1)    identical_timeout = Timeout(10.0, start=moment_in_time)    # both timeouts have exactly the same amount of time leftFinally, ``totaltimeout`` can be an ergonomic way to put a timelimit on a loop even if the code in the loop does not supporttimeouts, so long as each iteration does not block for too long:.. code:: python    counter = 0    for _ in Timeout(30):        counter += 1</longdescription>
</pkgmetadata>