<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Table of contents- [Dict to dataclass](#dict-to-dataclass)  - [Why?](#why)  - [Finding dictionary values](#finding-dictionary-values)  - [Nested data classes](#nested-data-classes)  - [Lists](#lists)  - [Value conversion](#value-conversion)    - [Datetime](#datetime)    - [Enum](#enum)    - [Custom converters](#custom-converters)  - [Optional types](#optional-types)  - [Missing values](#missing-values)  - [Data validation](#data-validation)# Dict to dataclassDict to dataclass makes it easy to convert dictionaries to instances of dataclasses.```pythonfrom dataclasses import dataclassfrom datetime import datetimefrom dict_to_dataclass import DataclassFromDict, field_from_dict# Declare dataclass fields with field_from_dict@dataclassclass MyDataclass(DataclassFromDict):    my_string: str = field_from_dict()    my_int: int = field_from_dict()    my_date: datetime = field_from_dict()# Create a dataclass instance using the from_dict constructororigin_dict = {  &quot;my_string&quot;: &quot;Hello&quot;,  &quot;my_int&quot;: 123,  &quot;my_date&quot;: &quot;2020-10-11T13:21:23.396748&quot;,}dataclass_instance = MyDataclass.from_dict(origin_dict)# Now our dataclass instance has the values from the dictionary&gt;&gt;&gt; dataclass_instance.my_string&quot;Hello&quot;&gt;&gt;&gt; dataclass_instance.my_int123&gt;&gt;&gt; dataclass_instance.my_datedatetime.datetime(2020, 10, 11, 13, 21, 23, 396748)```## Why?You can create a dataclass instance from a dictionary already by unpacking the dictionary values and passing them to the dataclass constructor like this:```pythonorigin_dict = {  &quot;my_string&quot;: &quot;Hello&quot;,  &quot;my_int&quot;: 123,  &quot;my_date&quot;: &quot;2020-10-11T13:21:23.396748&quot;,}dataclass_instance = MyDataclass(**origin_dict)```However, that method doesn't work when we need to consider- Type validation- Type conversion, e.g. an ISO string to a `datetime` instance- Differences between dictionary keys and dataclass field names- Complex structures with nested dictionaries and lists## Installation`dict_to_dataclass` can be installed using `pip````bashpip install dict-to-dataclass```## Finding dictionary valuesYou may have noticed that we don't need to specify where to look in the dictionary for field values. That's because by default, the name given to the field in the dataclass is used. It even works if the key in the dictionary is in camelCase:```python@dataclassclass MyDataclass(DataclassFromDict):    my_field: str = field_from_dict()origin_dict = {    &quot;myField&quot;: &quot;field value&quot;}dataclass_instance = MyDataclass.from_dict(origin_dict)&gt;&gt;&gt; dataclass_instance.my_field&quot;field value&quot;```It's probably quite common that your dataclass fields have the same names as the dictionary keys they map to but in case they don't, you can pass the dictionary key as the first argument (or the `dict_key` keyword argument) to `field_from_dict`:```python@dataclassclass MyDataclass(DataclassFromDict):    name_in_dataclass: str = field_from_dict(&quot;nameInDictionary&quot;)origin_dict = {    &quot;nameInDictionary&quot;: &quot;field value&quot;}dataclass_instance = MyDataclass.from_dict(origin_dict)&gt;&gt;&gt; dataclass_instance.name_in_dataclass&quot;field value&quot;```## Nested data classesNested dictionaries can be represented by nested dataclasses.```python@dataclassclass Child(DataclassFromDict):    my_field: str = field_from_dict()@dataclassclass Parent(DataclassFromDict):    child_field: Child = field_from_dict()origin_dict = {  &quot;child_field&quot;: {      &quot;my_field&quot;: &quot;Hello&quot;  }}dataclass_instance = Parent.from_dict(origin_dict)&gt;&gt;&gt; dataclass_instance.child_field.my_field&quot;Hello&quot;```## ListsList types are handled but the type of the list's items must be specified in the dataclass field type so that we know how to convert them.```python@dataclassclass MyDataclass(DataclassFromDict):    my_list_field: List[str] = field_from_dict()origin_dict = {    &quot;my_list_field&quot;: [&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;]}dataclass_instance = MyDataclass.from_dict(origin_dict)&gt;&gt;&gt; dataclass_instance.my_list_field[&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;]```If we were to use the more generic `typing.List` or `list` as the field type, an error would be raised when converting the dictionary (there's more info on errors later).```python@dataclassclass MyDataclass(DataclassFromDict):    name_in_dataclass: List = field_from_dict(&quot;nameInDictionary&quot;)origin_dict = {    &quot;my_list_field&quot;: [&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;]}# Here, an UnspecificListFieldError is raiseddataclass_instance = MyDataclass.from_dict(origin_dict)```Lists of other dataclasses are also supported.```python@dataclassclass Child(DataclassFromDict):    name: str = field_from_dict()@dataclassclass Parent(DataclassFromDict):    children: List[Child] = field_from_dict()origin_dict = {  &quot;children&quot;: [      { &quot;name&quot;: &quot;Jane&quot; },      { &quot;name&quot;: &quot;Joe&quot; },  ]}dataclass_instance = Parent.from_dict(origin_dict)&gt;&gt;&gt; dataclass_instance.children[Child(name='Jane'), Child(name='Joe')]```## Value conversionIf the value found in the dictionary doesn't match the dataclass field type, the dictionary value can be converted.### DatetimeDataclass fields of type `datetime` are handled and can be converted from- Strings (handled by [dateutil](https://dateutil.readthedocs.io/en/stable/))- Python-style timestamps of type `float`, e.g. `1602436272.681808`- Javascript-style timestamps of type `int`, e.g. `1602436323268`### EnumDataclass fields with an `Enum` type can also be converted by default:```pythonclass Number(Enum):    ONE = 1    TWO = 2    THREE = 3@dataclassclass MyDataclass(DataclassFromDict):    number: Number = field_from_dict()dataclass_instance = MyDataclass.from_dict({&quot;number&quot;: &quot;TWO&quot;})&gt;&gt;&gt; dataclass_instance.number&lt;Number.TWO: 2&gt;```The value in the dictionary should be the name of the Enum value as a string. If the value is not found, an `EnumValueNotFoundError` is raised.### Custom convertersIf you need to convert a dictionary value that isn't covered by the defaults, you can pass in a converter function using `field_from_dict`'s `converter` parameter:```pythondef yes_no_to_bool(yes_no: str) -&gt; bool:    return yes_no == &quot;yes&quot;@dataclassclass MyDataclass(DataclassFromDict):    is_yes: bool = field_from_dict(converter=yes_no_to_bool)dataclass_instance = MyDataclass.from_dict({&quot;is_yes&quot;: &quot;yes&quot;})&gt;&gt;&gt; dataclass_instance.is_yesTrue```A `DictValueConversionError` is raised if the dictionary value cannot be converted.## Optional typesIf you expect that the dictionary value for a field might be `None`, the dataclass field should be given an `Optional` type.```python@dataclassclass MyDataclass(DataclassFromDict):    my_field: Optional[str] = field_from_dict()dataclass_instance = MyDataclass.from_dict({&quot;myField&quot;: None})&gt;&gt;&gt; dataclass_instance.my_fieldNone```If `my_field` above had the type `str` instead, a `DictValueNotFoundError` would be raised.## Missing valuesIf you expect that the field might be missing from the dictionary, you should provide a value to either the `default` or `default_factory` parameters of `field_from_dict`. These are passed through to the underlying `dataclasses.field` call, which you can read about [here](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).If no default value is provided and the key is not found in the dictionary, a `DictKeyNotFoundError` is raised.```python@dataclassclass MyDataclass(DataclassFromDict):    my_field: str = field_from_dict(default=&quot;default value&quot;)    my_list_field: str = field_from_dict(default_factory=list)dataclass_instance = MyDataclass.from_dict({})&gt;&gt;&gt; dataclass_instance.my_field&quot;default value&quot;&gt;&gt;&gt; dataclass_instance.my_list_field[]```Note that if the field exists in the dictionary and has a value of `None`, `default` and `default_factory` are _not_ used. You would still need to give the field an `Optional` type.```python@dataclassclass MyDataclass(DataclassFromDict):    my_field: str = field_from_dict(default=&quot;default value&quot;)# Here, a DictValueNotFoundError is raiseddataclass_instance = MyDataclass.from_dict({&quot;myField&quot;: None})```## Data validationA side effect of converting a dictionary to a dataclass instance is that the data in the dictionary is validated, which can be useful on its own. For example, imagine we're writing a handler for a POST method in a REST API. If we use a `DataclassFromDict` to describe the request body, we can validate the user's input by attempting to convert it to a dataclass instance.```python@dataclassclass CreateResourceBody(DataclassFromDict):    ...fields@app.route(&quot;/resource&quot;, methods=[&quot;POST&quot;])def create_resource():    body_dict = request.get_json()    try:        body_dataclass_instance = CreateResourceBody.from_dict(body_dict)    except DataclassFromDictError:        return &quot;Bad request&quot;, 400    # Create the resource with with body_dataclass_instance```</longdescription>
</pkgmetadata>