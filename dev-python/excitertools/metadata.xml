<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://github.com/cjrh/excitertools/workflows/Python%20application/badge.svg    :target: https://github.com/cjrh/excitertools/actions.. image:: https://coveralls.io/repos/github/cjrh/excitertools/badge.svg?branch=master    :target: https://coveralls.io/github/cjrh/excitertools?branch=master.. image:: https://img.shields.io/pypi/pyversions/excitertools.svg    :target: https://pypi.python.org/pypi/excitertools.. image:: https://img.shields.io/github/tag/cjrh/excitertools.svg    :target: https://github.com/cjrh/excitertools.. image:: https://img.shields.io/badge/install-pip%20install%20excitertools-ff69b4.svg    :target: https://img.shields.io/badge/install-pip%20install%20excitertools-ff69b4.svg.. image:: https://img.shields.io/badge/dependencies-more--itertools-4488ff.svg    :target: https://more-itertools.readthedocs.io/en/stable/.. image:: https://img.shields.io/pypi/v/excitertools.svg    :target: https://img.shields.io/pypi/v/excitertools.svg.. image:: https://img.shields.io/badge/calver-YYYY.MM.MINOR-22bfda.svg    :target: http://calver.org/.. image:: https://img.shields.io/badge/code%20style-black-000000.svg    :target: https://github.com/ambv/black.. _more-itertools: https://more-itertools.readthedocs.io/en/stable/index.html.. _excitertools:excitertools############``itertools`` reimagined as a `fluent interface &lt;https://en.wikipedia.org/wiki/Fluent_interface&gt;`_.    In software engineering, a fluent interface is an object-oriented API whose design    relies extensively on method chaining. Its goal is to increase code legibility by    creating a domain-specific language (DSL). The term was coined in 2005 by Eric    Evans and Martin Fowler.    `*Wikipedia - Fluent Interface* &lt;https://en.wikipedia.org/wiki/Fluent_interface&gt;`_Note that nearly all of the ``more-itertools`` extension library is included.Demo****.. code-block:: python    &gt;&gt;&gt; range(10).map(lambda x: x*7).filter(lambda x: x % 3 == 0).collect()    [0, 21, 42, 63]    &gt;&gt;&gt; range(10).map(lambda x: x*7).filter(lambda x: x &gt; 0 and x % 3 == 0).collect()    [21, 42, 63]When the lines get long, parens can be used to split up each instruction:.. code-block:: python    &gt;&gt;&gt; (    ...     range(10)    ...         .map(lambda x: x*7)    ...         .filter(lambda x: x % 3 == 0)    ...         .collect()    ... )    [0, 21, 42, 63]What's also interesting about that is how lambda's can easily contain theseprocessing chains, since an entire chain is a single expression. Forexample:.. code-block:: python    &gt;&gt;&gt; names = ['caleb', 'james', 'gina']    &gt;&gt;&gt; Iter(names).map(    ...     lambda name: (    ...         Iter(name)    ...             .map(lambda c: c.upper() if c in 'aeiouy' else c)    ...             .collect(str)    ...     )    ... ).collect()    ['cAlEb', 'jAmEs', 'gInA']Something I've noticed is that ``reduce`` seems easier to use and reasonabout with this fluent interface, as compared to the conventional usageas a standalone function; also, the operator module makes ``reduce`` quiteuseful for simple cases:.. code-block:: python    &gt;&gt;&gt; from operator import add, mul    &gt;&gt;&gt; (    ...     range(10)    ...     .map(lambda x: x*7)    ...     .filter(lambda x: x &gt; 0 and x % 3 == 0)    ...     .reduce(add)    ... )    126    &gt;&gt;&gt; (    ...     range(10)    ...     .map(lambda x: x*7)    ...     .filter(lambda x: x &gt; 0 and x % 3 == 0)    ...     .reduce(mul)    ... )    55566.. contents::    :depth: 1.. |warning| unicode:: U+26A0.. |cool| unicode:: U+2728.. |flux| unicode:: U+1F6E0.. |source| unicode:: U+1F3A4.. |sink| unicode:: U+1F3A7.. |inf| unicode:: U+267EHow to Understand the API Documentation#######################################Several symbols are used to indicate things about parts of the API:- |source| This function is a *source*, meaning that it produces data  that will be processed in an iterator chain.- |sink| This function is a *sink*, meaning that it consumes data that  was processed in an iterator chain.- |inf| This function returns an infinite iterable- |warning| Warning - pay attention- |flux| This API is still in flux, and might be changed or  removed in the future- |cool| Noteworthy; could be especially useful in many situations.The API is arranged roughly with the module-level functions first, andthereafter the Iter_ class itself. It is the Iter_ class that doesthe work to allow these iterators to be chained together. However, themodule-level functions are more likely to be used directly and that'swhy they're presented first.The API includes wrappers for the stdlib *itertools* module, includingthe &quot;recipes&quot; given in the *itertools* docs, as well as wrappers forthe iterators from the more-itertools_ 3rd-party package.Module-level Replacements for Builtins######################################The following module-level functions, like range_, zip_ and so on, areintended to be used as replacements for their homonymous builtins. Theonly difference between these and the builtin versions is that thesereturn instances of the Iter_ class. Note that because Iter_ is itselfiterable, it means that the functions here can be used as drop-inreplacements.Once you have an Iter_ instance, all of its methods become availablevia function call chaining, so these toplevel functions are really onlya convenience to &quot;get started&quot; using the chaining syntax with minimalupfront cost in your own code... contents::    :local:.. _range:|source| ``range(*args) -&gt; &quot;Iter[int]&quot;``****************************************Replacement for the builtin ``range`` function.  This version returnsan instance of Iter_ to allow further iterable chaining.All the same calling variations work because this function merely wrapsthe original function... code-block:: python    &gt;&gt;&gt; range(3).collect()    [0, 1, 2]    &gt;&gt;&gt; range(1, 4).collect()    [1, 2, 3]    &gt;&gt;&gt; range(1, 6, 2).collect()    [1, 3, 5]    &gt;&gt;&gt; range(1, 101, 3).filter(lambda x: x % 7 == 0).collect()    [7, 28, 49, 70, 91]This example multiples, element by element, the series ``[0:5]`` with theseries ``[1:6]``. Two things to note: Firstly, Iter.zip_ is used to emitthe tuples from each series. Secondly, Iter.starmap_ is used to receivethose tuples into separate arguments in the ``lambda``... code-block:: python    &gt;&gt;&gt; range(5).zip(range(1, 6)).starmap(lambda x, y: x * y).collect()    [0, 2, 6, 12, 20]When written in a single line as above, it can get difficult to followthe chain of logic if there are many processing steps. Parentheses inPython allow grouping such that expressions can be spread over multiplelines.This is the same example as the prior one, but formatted to be spreadover several lines. This is much clearer:.. code-block:: python    &gt;&gt;&gt; # Written out differently    &gt;&gt;&gt; (    ...     range(5)    ...         .zip(range(1, 6))    ...         .starmap(lambda x, y: x * y)    ...         .collect()    ... )    [0, 2, 6, 12, 20]If you wanted the sum instead, it isn't necessary to do the collectionat all:.. code-block:: python    &gt;&gt;&gt; (    ...     range(5)    ...         .zip(range(1, 6))    ...         .starmap(lambda x, y: x * y)    ...         .sum()    ... )    40.. _zip:``zip(*iterables: Any) -&gt; &quot;Iter[Tuple[T, ...]]&quot;``*************************************************Replacement for the builtin ``zip`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... _enumerate:``enumerate(iterable) -&gt; &quot;Iter[Tuple[int, T]]&quot;``************************************************Replacement for the builtin ``enumerate`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; enumerate(string.ascii_lowercase).take(3).collect()    [(0, 'a'), (1, 'b'), (2, 'c')].. _map:``map(func: Union[Callable[..., C], str], iterable) -&gt; &quot;Iter[C]&quot;``******************************************************************Replacement for the builtin ``map`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; result = map(lambda x: (x, ord(x)), 'caleb').dict()    &gt;&gt;&gt; assert result == {'a': 97, 'b': 98, 'c': 99, 'e': 101, 'l': 108}    &gt;&gt;&gt; result = map('x, ord(x)', 'caleb').dict()    &gt;&gt;&gt; assert result == {'a': 97, 'b': 98, 'c': 99, 'e': 101, 'l': 108}.. _filter:``filter(function: &quot;Callable[[Any], bool]&quot;, iterable: &quot;Iterable[T]&quot;) -&gt; &quot;Iter[T]&quot;``***********************************************************************************Replacement for the builtin ``filter`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; filter(lambda x: x % 3 == 0, range(10)).collect()    [0, 3, 6, 9].. _count:|source| ``count(start=0, step: int = 1) -&gt; &quot;Iter[int]&quot;``*********************************************************Replacement for the itertools ``count`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; count().take(5).collect()    [0, 1, 2, 3, 4]    &gt;&gt;&gt; count(0).take(0).collect()    []    &gt;&gt;&gt; count(10).take(0).collect()    []    &gt;&gt;&gt; count(10).take(5).collect()    [10, 11, 12, 13, 14]    &gt;&gt;&gt; count(1).filter(lambda x: x &gt; 10).take(5).collect()    [11, 12, 13, 14, 15].. _cycle:``cycle(iterable) -&gt; &quot;Iter[T]&quot;``********************************Replacement for the itertools ``count`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; cycle(range(3)).take(6).collect()    [0, 1, 2, 0, 1, 2]    &gt;&gt;&gt; cycle([]).take(6).collect()    []    &gt;&gt;&gt; cycle(range(3)).take(0).collect()    [].. _repeat:|source| ``repeat(object: C, times=None) -&gt; &quot;Iter[C]&quot;``*******************************************************Replacement for the itertools ``count`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; repeat('a').take(3).collect()    ['a', 'a', 'a']    &gt;&gt;&gt; repeat([1, 2]).take(3).collect()    [[1, 2], [1, 2], [1, 2]]    &gt;&gt;&gt; repeat([1, 2]).take(3).collapse().collect()    [1, 2, 1, 2, 1, 2]    &gt;&gt;&gt; repeat([1, 2]).collapse().take(3).collect()    [1, 2, 1]    &gt;&gt;&gt; repeat('a', times=3).collect()    ['a', 'a', 'a']This next set of functions return iterators that terminate on the shortest input sequence... _accumulate:``accumulate(iterable, func=None, *, initial=None)``****************************************************Replacement for the itertools ``accumulate`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; accumulate([1, 2, 3, 4, 5]).collect()    [1, 3, 6, 10, 15]    &gt;&gt;&gt; if sys.version_info &gt;= (3, 8):    ...     output = accumulate([1, 2, 3, 4, 5], initial=100).collect()    ...     assert output == [100, 101, 103, 106, 110, 115]    &gt;&gt;&gt; accumulate([1, 2, 3, 4, 5], operator.mul).collect()    [1, 2, 6, 24, 120]    &gt;&gt;&gt; accumulate([]).collect()    []    &gt;&gt;&gt; accumulate('abc').collect()    ['a', 'ab', 'abc']    &gt;&gt;&gt; accumulate(b'abc').collect()    [97, 195, 294]    &gt;&gt;&gt; accumulate(bytearray(b'abc')).collect()    [97, 195, 294].. _chain:``chain(*iterables: Iterable[T]) -&gt; &quot;Iter[T]&quot;``***********************************************Replacement for the itertools ``chain`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; chain('ABC', 'DEF').collect()    ['A', 'B', 'C', 'D', 'E', 'F']    &gt;&gt;&gt; chain().collect()    [].. _chain_from_iterable:``chain_from_iterable(iterable) -&gt; &quot;Iter[T]&quot;``**********************************************Replacement for the itertools ``chain.from_iterable`` method.This version returns an instance of Iter_ to allowfurther iterable chaining... code-block:: python    &gt;&gt;&gt; chain_from_iterable(['ABC', 'DEF']).collect()    ['A', 'B', 'C', 'D', 'E', 'F']    &gt;&gt;&gt; chain_from_iterable([]).collect()    [].. _compress:``compress(data, selectors)``*****************************Replacement for the itertools ``compress`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; compress('ABCDEF', [1, 0, 1, 0, 1, 1]).collect()    ['A', 'C', 'E', 'F'].. _dropwhile:``dropwhile(pred, iterable)``*****************************Replacement for the itertools ``dropwhile`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; dropwhile(lambda x: x &lt; 4, range(6)).collect()    [4, 5].. _filterfalse:``filterfalse(pred, iterable)``*******************************Replacement for the itertools ``filterfalse`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; filterfalse(None, [2, 0, 3, None, 4, 0]).collect()    [0, None, 0].. _groupby:``groupby(iterable, key=None)``*******************************Replacement for the itertools ``groupby`` function.  This version returnsan instance of Iter_ to allow further iterable chaining.groupby_ returns an iterator of a key and &quot;grouper&quot; iterable. In theexample below, we use Iter.starmap_ to collect each grouper iterableinto a list, as this makes it neater for display here in the docstring... code-block:: python    &gt;&gt;&gt; (    ...     groupby(['john', 'jill', 'anne', 'jack'], key=lambda x: x[0])    ...         .starmap(lambda k, g: (k, list(g)))    ...         .collect()    ... )    [('j', ['john', 'jill']), ('a', ['anne']), ('j', ['jack'])].. _islice:``islice(iterable, *args) -&gt; &quot;Iter&quot;``*************************************Replacement for the itertools ``islice`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; islice('ABCDEFG', 2).collect()    ['A', 'B']    &gt;&gt;&gt; islice('ABCDEFG', 2, 4).collect()    ['C', 'D']    &gt;&gt;&gt; islice('ABCDEFG', 2, None).collect()    ['C', 'D', 'E', 'F', 'G']    &gt;&gt;&gt; islice('ABCDEFG', 0, None, 2).collect()    ['A', 'C', 'E', 'G'].. _starmap:``starmap(func, iterable)``***************************Replacement for the itertools ``starmap`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; starmap(pow, [(2, 5), (3, 2), (10, 3)]).collect()    [32, 9, 1000].. _takewhile:``takewhile(pred, iterable)``*****************************Replacement for the itertools ``takewhile`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; takewhile(lambda x: x &lt; 5, [1, 4, 6, 4, 1]).collect()    [1, 4].. _tee:``tee(iterable, n=2)``**********************Replacement for the itertools ``tee`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; a, b = tee(range(5))    &gt;&gt;&gt; a.collect()    [0, 1, 2, 3, 4]    &gt;&gt;&gt; b.sum()    10It is also possible to operate on the returned iterators in the chainbut it gets quite difficult to understand:.. code-block:: python    &gt;&gt;&gt; tee(range(5)).map(lambda it: it.sum()).collect()    [10, 10]In the example above we passed in range_, but with excitertools_it's usually more natural to push data sources further left:.. code-block:: python    &gt;&gt;&gt; range(5).tee().map(lambda it: it.sum()).collect()    [10, 10]Pay close attention to the above. The map_ is acting on each of thecopied iterators... _zip_longest:``zip_longest(*iterables, fillvalue=None)``*******************************************Replacement for the itertools ``zip_longest`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; zip_longest('ABCD', 'xy', fillvalue='-').collect()    [('A', 'x'), ('B', 'y'), ('C', '-'), ('D', '-')]    &gt;&gt;&gt; (    ...     zip_longest('ABCD', 'xy', fillvalue='-')    ...         .map(lambda tup: concat(tup, ''))    ...         .collect()    ... )    ['Ax', 'By', 'C-', 'D-']    &gt;&gt;&gt; (    ...     zip_longest('ABCD', 'xy', fillvalue='-')    ...         .starmap(operator.add)    ...         .collect()    ... )    ['Ax', 'By', 'C-', 'D-'].. _finditer_regex:``finditer_regex(pat: &quot;re.Pattern[AnyStr]&quot;, s: AnyStr, flags: Union[int, re.RegexFlag] = 0) -&gt; &quot;Iter[AnyStr]&quot;``***************************************************************************************************************Wrapper for ``re.finditer``. Returns an instance of Iter_ to allowchaining... code-block:: python    &gt;&gt;&gt; pat = r&quot;\w+&quot;    &gt;&gt;&gt; text = &quot;Well hello there! How ya doin!&quot;    &gt;&gt;&gt; finditer_regex(pat, text).map(str.lower).filter(lambda w: 'o' in w).collect()    ['hello', 'how', 'doin']    &gt;&gt;&gt; finditer_regex(r&quot;[A-Za-z']+&quot;, &quot;A programmer's RegEx test.&quot;).collect()    ['A', &quot;programmer's&quot;, 'RegEx', 'test']    &gt;&gt;&gt; finditer_regex(r&quot;[A-Za-z']+&quot;, &quot;&quot;).collect()    []    &gt;&gt;&gt; finditer_regex(&quot;&quot;, &quot;&quot;).collect()    ['']    &gt;&gt;&gt; finditer_regex(&quot;&quot;, &quot;&quot;).filter(None).collect()    [].. _splititer_regex:``splititer_regex(pat: &quot;re.Pattern[AnyStr]&quot;, s: AnyStr, flags: Union[int, re.RegexFlag] = 0) -&gt; &quot;Iter[AnyStr]&quot;``****************************************************************************************************************Lazy string splitting using regular expressions.Most of the time you want ``str.split``. Really! That will almostalways be fastest. You might think that ``str.split`` is inefficientbecause it always has to build a list, but it can do this very, veryquickly.The lazy splitting shown here is more about supporting a particularkind of programming model, rather than performance.See more discussion `here &lt;https://stackoverflow.com/questions/3862010/is-there-a-generator-version-of-string-split-in-python&gt;`_... code-block:: python    &gt;&gt;&gt; splititer_regex(r&quot;\s&quot;, &quot;A programmer's RegEx test.&quot;).collect()    ['A', &quot;programmer's&quot;, 'RegEx', 'test.']Note that splitting at a single whitespace character will return blanksfor each found. This is different to how ``str.split()`` works... code-block:: python    &gt;&gt;&gt; splititer_regex(r&quot;\s&quot;, &quot;aaa     bbb  \n  ccc\nddd\teee&quot;).collect()    ['aaa', '', '', '', '', 'bbb', '', '', '', '', 'ccc', 'ddd', 'eee']To match ``str.split()``, specify a sequence of whitespace as theregex pattern... code-block:: python    &gt;&gt;&gt; splititer_regex(r&quot;\s+&quot;, &quot;aaa     bbb  \n  ccc\nddd\teee&quot;).collect()    ['aaa', 'bbb', 'ccc', 'ddd', 'eee']Counting the whitespace.. code-block:: python    &gt;&gt;&gt; splititer_regex(r&quot;\s&quot;, &quot;aaa     bbb  \n  ccc\nddd\teee&quot;).collect(Counter)    Counter({'': 8, 'aaa': 1, 'bbb': 1, 'ccc': 1, 'ddd': 1, 'eee': 1})Lazy splitting at newlines.. code-block:: python    &gt;&gt;&gt; splititer_regex(r&quot;\n&quot;, &quot;aaa     bbb  \n  ccc\nddd\teee&quot;).collect()    ['aaa     bbb  ', '  ccc', 'ddd\teee']A few more examples:.. code-block:: python    &gt;&gt;&gt; splititer_regex(r&quot;&quot;, &quot;aaa&quot;).collect()    ['', 'a', 'a', 'a', '']    &gt;&gt;&gt; splititer_regex(r&quot;&quot;, &quot;&quot;).collect()    ['', '']    &gt;&gt;&gt; splititer_regex(r&quot;\s&quot;, &quot;&quot;).collect()    ['']    &gt;&gt;&gt; splititer_regex(r&quot;a&quot;, &quot;&quot;).collect()    ['']    &gt;&gt;&gt; splititer_regex(r&quot;\s&quot;, &quot;aaa&quot;).collect()    ['aaa'].. _concat:``concat(iterable: Iterable[AnyStr], glue: AnyStr) -&gt; &quot;AnyStr&quot;``****************************************************************Concatenate strings, bytes and bytearrays. It is careful to avoid theproblem with single bytes becoming integers, and it looks at the valueof `glue` to know whether to handle bytes or strings.This function can raise ``ValueError`` if called with somethingother than ``bytes``, ``bytearray`` or ``str``... _from_queue:|cool| |source| ``from_queue(q: queue.Queue, timeout=None, sentinel=None) -&gt; &quot;Iter&quot;``*************************************************************************************Wrap a queue with an iterator interface. This allows it to participatein chaining operations. The iterator will block while waiting fornew values to appear on the queue. This is useful: it allows youto easily and safely pass data between threads or processes, andfeed the incoming data into a pipeline.The sentinel value, default ``None``, will terminate the iterator... code-block:: python    &gt;&gt;&gt; q = queue.Queue()    &gt;&gt;&gt; # This line puts stuff onto a queue    &gt;&gt;&gt; range(10).chain([None]).map(q.put).consume()    &gt;&gt;&gt; from_queue(q).filter(lambda x: 2 &lt; x &lt; 9).collect()    [3, 4, 5, 6, 7, 8]This can be used in the same way you would normally use a queue, inthat it will block while waiting for future input. This makes itconvenient to run in a thread and wait for work. Below is a roughsketch of how one might cobble together a thread pool using thisfeature. Note the use of Iter.side_effect_ to call ``task_done()``on the queue... code-block:: python    import queue    from threading import Thread    import logging    from excitertools import from_queue    logger = logging.getLogger(__name__)    def process_job(job):        result = ...        return result    def worker(inputs: Queue, results: Queue):        (            from_queue(inputs)            .side_effect(lambda job: logger.info(f&quot;Received job {job}&quot;)            .map(process_job)            .side_effect(lambda result: logger.info(f&quot;Got result {job}&quot;)            .into_queue(results)            # Note that we only mark the task as done after the result            # is added to the results queue.            .side_effect(lambda _: inputs.task_done()        )    def create_job_pool(n: int) -&gt; Tuple[Queue, Queue, Callable]:        &quot;&quot;&quot;Returns two queues, and a pool shutdown method. The        shutdown function can be called to shut down the pool and        the ``inputs`` queue. Caller is responsible for draining        the ``results`` queue.&quot;&quot;&quot;        # Independent control of the sizes of the input and output        # queues is interesting: it lets you decide how to bias        # backpressure depending on the details of your workload.        inputs, results = Queue(maxsize=100), Queue(maxsize=3)        kwargs = dict(target=worker, args=(inputs, results), daemon=True)        threads = repeat(Thread).map(lambda T: T(**kwargs)).take(n).collect()        def shutdown():            # Shut down each thread            repeat(None).map(inputs.put).take(n).consume()            inputs.join()            Iter(threads).map(lambda t: t.join()).consume()        return inputs, results, shutdownNow the two queues ``inputs`` and ``results`` can be used in variousother threads to supply and consume data.The ``Iter`` Class##################.. contents::    :backlinks: entry    :local:.. _Iter:|cool| ``class Iter(Generic[T])``*********************************This class is what allows chaining. Many of the methods in this classreturn an instance of Iter_, which allows further chaining. Thereare two exceptions to this: *sources* and *sinks*.A &quot;source&quot; is usually a ``classmethod`` which can be used as aninitializer to produce data via an iterable. For example, the Iter.range_classmethod can be used to get a sequence of numbers:.. code-block:: python    &gt;&gt;&gt; Iter.range(1_000_000).take(3).collect()    [0, 1, 2]Even though our range was a million elements, the iterator chainingtook only 3 of those elements before collecting.A &quot;sink&quot; is a method that is usually the last component of a processingchain and often (but not always!) consumes the entire iterator. In theexample above, the call to Iter.collect_ was a sink. Note that we stillcall it a sink even though it did not consume the entire iterator.We're using the term &quot;source&quot; to refer to a classmethod of Iter_ thatproduces data; but, the most typical source is going to be data thatyou provide. Iter_ can be called with anything that is iterable, includingsequences, iterators, mappings, sets, generators and so on.Examples:.. code-block:: python    List    &gt;&gt;&gt; Iter([1, 2, 3]).map(lambda x: x * 2).sum()    12    Generator    &gt;&gt;&gt; Iter((1, 2, 3)).map(lambda x: x * 2).sum()    12    &gt;&gt;&gt; def g():    ...     for i in [1, 2, 3]:    ...         yield i    &gt;&gt;&gt; Iter(g()).map(lambda x: x * 2).sum()    12    Iterator    &gt;&gt;&gt; Iter(iter([1, 2, 3])).map(lambda x: x * 2).sum()    12    Dict    &gt;&gt;&gt; Iter(dict(a=1, b=2)).map(lambda x: x.upper()).collect()    ['A', 'B']    &gt;&gt;&gt; d = dict(a=1, b=2, c=3)    &gt;&gt;&gt; Iter(d.items()).starmap(lambda k, v: v).map(lambda x: x * 2).sum()    12A common error with generators is forgetting to actually evaluate, i.e.,call a generator function. If you do this there's a friendly errorpointing out the mistake:.. code-block:: python    &gt;&gt;&gt; def mygen(): yield 123    &gt;&gt;&gt; Iter(mygen).collect()    Traceback (most recent call last):        ...    TypeError: It seems you passed a generator function, but you    probably intended to pass a generator. Remember to evaluate the    function to obtain a generator instance:    def mygen():        yield 123    Iter(mygen)    # ERROR - a generator function object is not iterable    Iter(mygen())  # CORRECT - a generator instance is iterable.    &gt;&gt;&gt; Iter(mygen()).collect()    [123]Instance of Iter_ are resumable. Once an instance it created, it canbe partially iterated in successive calls, like the following exampleshows:.. code-block:: python    &gt;&gt;&gt; it = Iter.range(1_000_000)    &gt;&gt;&gt; it.take(3).collect()    [0, 1, 2]    &gt;&gt;&gt; it.take(4).collect()    [3, 4, 5, 6]    &gt;&gt;&gt; # Consume most of the stream, collect the last few    &gt;&gt;&gt; it.consume(999_990).collect()    [999997, 999998, 999999]This class implements the chaining. However, the module-level functionsin excitertools_, such as range_, zip_ and so on, also returninstances of Iter_, so they allow the chaining to continue. These areequivalent:.. code-block:: python    &gt;&gt;&gt; Iter.range(10).filter(lambda x: x &gt; 7).collect()    [8, 9]    &gt;&gt;&gt; range(10).filter(lambda x: x &gt; 7).collect()    [8, 9]It is intended that the module-level functions can act as drop-inreplacements for the builtins they wrap:&gt;&gt;&gt; import builtins&gt;&gt;&gt; list(builtins.range(3))[0, 1, 2]&gt;&gt;&gt; list(range(3))  # This is excitertools.range![0, 1, 2]&gt;&gt;&gt; list(Iter.range(3))[0, 1, 2]In your own code where you might like to use the excitertools_ version ofrange_ and the other functions, you can just import it and use it to access all the othercool stuff:.. code-block:: python    # mymodule.py    from excitertools import (        range,        map,        filter,        reduce,        repeat,        count,        enumerate,        zip,        ...    )    def func(inputs):        data = (            map(lambda x: x + 2, inputs)                .enumerate()                .filter(lambda x: x[1] &gt; 10)                ...                .collect()        )Alternatively, if you don't want to hide the builtins you can do justfine with importing this class only, or even importing the module only:.. code-block:: python    # mymodule.py - same example as before    import excitertools    def func(inputs):        data = (            excitertools.Iter(inputs)                .map(lambda x: x + 2, inputs)                .enumerate()                .filter(lambda x: x[1] &gt; 10)                ...                .collect()        )        # Do something with dataThere are several valuable additions to the standard *itertools* andmore-itertools_ functions. These usually involve sources and sinks,which are ways of getting data into an iterator pipeline, and thengetting results out again. In the majority of documentation examplesshown here, the Iter.collect_ method is used to collect all theremaining data on a stream into a list; but in practice this is notuseful because large lists consume memory.In practice it is more useful to send iterator data to one of thesecommon sinks:- files- sockets- queues- HTTP APIs- Cloud storage buckets- (Ideas for more to add here?)Iter_ has support for these use-cases, both for reading and for writing... _Iter.register:``@classmethod Iter.register(cls, *func)``==========================================Add a new method to Iter_. Sure, you could subclass Iter_ to getnew chaining features, but it would be neat to let all existingIter_ instance just immediately have the new registered functionavailable.The new function must take ``iterable`` as the first parameter... code-block:: python    &gt;&gt;&gt; def up(iterable):    ...     for v in iterable:    ...         yield v.upper()    &gt;&gt;&gt; Iter.register(up)    &gt;&gt;&gt; Iter('abc').up().collect()    ['A', 'B', 'C']    &gt;&gt;&gt; def poly(iterable, a, b, c):    ...     # Polynomials a.x^2 + b.x + c    ...     for x in iterable:    ...         yield a*x**2 + b*x + c    &gt;&gt;&gt; Iter.register(poly)    &gt;&gt;&gt; Iter(range(-5, 5, 1)).poly(1, -5, 6).collect()    [56, 42, 30, 20, 12, 6, 2, 0, 0, 2]Here's a math round-trip rollercoaster... code-block:: python    &gt;&gt;&gt; import math    &gt;&gt;&gt; def log(iterable):    ...     for x in iterable:    ...         yield math.log(x)    &gt;&gt;&gt; def exp(iterable):    ...     for x in iterable:    ...         yield math.exp(x)    &gt;&gt;&gt; def rnd(iterable):    ...     for x in iterable:    ...         yield round(x)    &gt;&gt;&gt; Iter.register(log, exp, rnd)    &gt;&gt;&gt; Iter(range(5)).exp().log().rnd().collect()    [0, 1, 2, 3, 4]These are silly examples, but hopefully you get the idea... _Iter.collect:|sink| ``Iter.collect(self, container=list) -&gt; &quot;List[T]&quot;``==========================================================This is the most common way of &quot;realizing&quot; an interable chaininto a concrete data structure. It should be the case that thisis where most of the memory allocation occurs.The default container is a list and you'll see throughout thisdocumentation that most examples produce lists. However,any container, and indeed any function, can be used as the sink.The basic example:.. code-block:: python    &gt;&gt;&gt; Iter(range(3)).collect()    [0, 1, 2]    &gt;&gt;&gt; Iter(range(3)).collect(tuple)    (0, 1, 2)You must pay attention to some things. For example, if youriterable is a string, the characters of the string are whatget iterated over, and when you collect you'll get a collectionof those atoms. You can however use ``str`` as your &quot;containerfunction&quot; and that will give you back a string. It's like a joinwith blank joiner... code-block:: python    &gt;&gt;&gt; Iter('abc').collect()    ['a', 'b', 'c']    &gt;&gt;&gt; Iter('abc').collect(str)    'abc'With some types, things get a little more tricky. Take ``bytes``for example:.. code-block:: python    &gt;&gt;&gt; Iter(b'abc').collect()    [97, 98, 99]You probably didn't expect to get the integers back right? Anyhow,you can use ``bytes`` as the &quot;collection container&quot;, just likewe did with strings and that will work:.. code-block:: python    &gt;&gt;&gt; Iter(b'abc').collect(bytes)    b'abc'    &gt;&gt;&gt; Iter(b'abc').collect(bytearray)    bytearray(b'abc')The other standard collections also work, here's a set forcompleteness... code-block:: python    &gt;&gt;&gt; Iter('abcaaaabbbbccc').collect(set) == {'a', 'b', 'c'}    True.. _Iter.open:|cool| |source| ``@classmethod Iter.open(cls, file, mode=&quot;r&quot;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None, ) -&gt; &quot;Iter&quot;``==============================================================================================================================================================Wrap the ``open()`` builtin precisely, but return an ``Iter``instance to allow function chaining on the result.I know you're thinking that we should always use a contextmanager for files. Don't worry, there is one being usedinternally. When the iterator chain is terminated the underlyingfile will be closed.&gt;&gt;&gt; import tempfile&gt;&gt;&gt; with tempfile.TemporaryDirectory() as td:...     # Put some random text into a temporary file...     with open(td + 'text.txt', 'w') as f:...         f.writelines(['abc\n', 'def\n', 'ghi\n'])......     # Open the file, filter some lines, collect the result...     Iter.open(td + 'text.txt').filter(lambda line: 'def' in line).collect()['def\n']Note that this is a convenience method for *reading* from a file,not for writing. The function signature includes the ``mode``parameter for parity with the builtin ``open()`` function, butonly reading is supported... _Iter.read_lines:|source| ``@classmethod Iter.read_lines(cls, stream: IO[str], rewind=True)``============================================================================Read lines from a file-like object.First, let's put some data in a file. We'll be using thatfile in the examples that follow... code-block:: python    &gt;&gt;&gt; import tempfile    &gt;&gt;&gt; td = tempfile.TemporaryDirectory()    ... # Put some random text into a temporary file    &gt;&gt;&gt; with open(td.name + 'text.txt', 'w') as f:    ...     f.writelines(['abc\n', 'def\n', 'ghi\n'])    ...Use read_lines to process the file data.. code-block:: python    &gt;&gt;&gt; with open(td.name + 'text.txt') as f:    ...     Iter.read_lines(f).filter(lambda line: 'def' in line).collect()    ['def\n']The ``rewind`` parameter can be used to read sections of a file... code-block:: python    &gt;&gt;&gt; with open(td.name + 'text.txt') as f:    ...     part1 = Iter.read_lines(f).take(1).collect()    ...     part2 = Iter.read_lines(f, rewind=False).collect()    &gt;&gt;&gt; part1    ['abc\n']    &gt;&gt;&gt; part2    ['def\n', 'ghi\n']    &gt;&gt;&gt; td.cleanup().. _Iter.read_bytes:|source| ``@classmethod Iter.read_bytes(cls, stream: IO[bytes], size: Union[Callable[[], int], int] = -1, rewind=True)``========================================================================================================================The ``size`` parameter can be used to control how many bytes areread for each advancement of the iterator chain. Here we set ``size=1``which means we'll get back one byte at a time... code-block:: python    &gt;&gt;&gt; import tempfile    &gt;&gt;&gt; td = tempfile.TemporaryDirectory()    &gt;&gt;&gt; filename = td.name + 'bytes.bin'Put some random text into a temporary file:.. code-block:: python    &gt;&gt;&gt; with open(filename, 'wb') as f:    ...     x = f.write(b'\x00' * 100)    ...    &gt;&gt;&gt; with open(filename, 'rb') as f:    ...     data = Iter.read_bytes(f, size=1).collect()    ...     len(data)    100    &gt;&gt;&gt; with open(filename, 'rb') as f:    ...     data = Iter.read_bytes(f).collect()    ...     len(data)    1A little more ambitious. Because ``size`` is a callable, we can usea ``deque`` and a ``side_effect`` to pass information back intothe reader to control how many bytes are read in each chunk.In this example we're reading 1 byte at a time. In a real exampleyou might have a sequence of headers and bodies, where headersgive size information about how many bytes are in the bodycorresponding to that header. Then you can precisely read each body in sequence... code-block:: python    &gt;&gt;&gt; read_sizes = deque([1])    &gt;&gt;&gt; with open(filename, 'rb') as f:    ...     data = (    ...         Iter    ...             .read_bytes(f, size=lambda: read_sizes.popleft())    ...             .side_effect(lambda bytes: read_sizes.append(1))    ...             .collect()    ...     )    ...     len(data)    100The ``rewind`` parameter can be used to read sections of a file... code-block:: python    &gt;&gt;&gt; with open(filename, 'rb') as f:    ...     part1 = Iter.read_bytes(f, size=10).take(1).collect()    ...     part2 = Iter.read_bytes(f, rewind=False).collect()    &gt;&gt;&gt; part1    [b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00']    &gt;&gt;&gt; len(part2[0])    90    &gt;&gt;&gt; td.cleanup().. _Iter.write_text_to_stream:|sink| ``Iter.write_text_to_stream(self, stream: IO[str], insert_newlines=True, flush=True)``=============================================================================================.. code-block:: python    &gt;&gt;&gt; import tempfile    &gt;&gt;&gt; td = tempfile.TemporaryDirectory()    &gt;&gt;&gt; filename = td.name + 'text.txt'    &gt;&gt;&gt; data = ['a', 'b', 'c']    &gt;&gt;&gt; with open(filename, 'w') as f:    ...     Iter(data).map(str.upper).write_text_to_stream(f)    ...     with open(filename) as f2:    ...         Iter.read_lines(f2).concat()    'A\nB\nC'If some prior step adds newlines, or more commonly, newlinesoriginate with a data source and are simply carried through theprocessing chain unaltered, disable the insertion of newlines:.. code-block:: python    &gt;&gt;&gt; with open(filename, 'w') as f:    ...     Iter(data).map(str.upper).write_text_to_stream(f, insert_newlines=False)    ...     with open(filename) as f2:    ...         Iter.read_lines(f2).concat()    'ABC'Multiple successive writes may be slowed down by the default``flush=True`` parameter. In this case you can delay flushing untileverything has been written... code-block:: python    &gt;&gt;&gt; with open(filename, 'w') as f:    ...     Iter(data).map(str.upper).write_text_to_stream(f, flush=False)    ...     Iter(data).map(str.upper).write_text_to_stream(f, flush=False)    ...     Iter(data).map(str.upper).write_text_to_stream(f, flush=True)    ...     with open(filename) as f2:    ...         Iter.read_lines(f2).concat()    'A\nB\nCA\nB\nCA\nB\nC'    &gt;&gt;&gt; td.cleanup().. _Iter.write_bytes_to_stream:|sink| ``Iter.write_bytes_to_stream(self, stream: IO[bytes], flush=True)``==========================================================================.. code-block:: python    &gt;&gt;&gt; import tempfile    &gt;&gt;&gt; td = tempfile.TemporaryDirectory()    &gt;&gt;&gt; filename = td.name + 'bytes.bin'    &gt;&gt;&gt; data = [b'a', b'b', b'c']    &gt;&gt;&gt; with open(filename, 'wb') as f:    ...     Iter(data).map(lambda x: x * 2 ).write_bytes_to_stream(f)    ...     with open(filename, 'rb') as f2:    ...         Iter.read_bytes(f2).collect()    [b'aabbcc']    &gt;&gt;&gt; with open(filename, 'wb') as f:    ...     Iter(data).map(lambda x: x * 2 ).write_bytes_to_stream(f)    ...     with open(filename, 'rb') as f2:    ...         Iter.read_bytes(f2).concat(b'')    b'aabbcc'    &gt;&gt;&gt; with open(filename, 'wb') as f:    ...     Iter(data).map(lambda x: x * 2 ).write_bytes_to_stream(f)    ...     with open(filename, 'rb') as f2:    ...         Iter.read_bytes(f2, size=1).collect()    [b'a', b'a', b'b', b'b', b'c', b'c']    &gt;&gt;&gt; with open(filename, 'wb') as f:    ...     Iter(data).map(lambda x: x * 2 ).write_bytes_to_stream(f)    ...     with open(filename, 'rb') as f2:    ...         Iter.read_bytes(f2, size=2).map(bytes.decode).collect()    ['aa', 'bb', 'cc']Flushing can be delayed if multiple parts are to be written... code-block:: python    &gt;&gt;&gt; with open(filename, 'wb') as f:    ...     it = Iter(data)    ...     it.map(lambda x: x * 2 ).take(2).write_bytes_to_stream(f, flush=False)    ...     it.map(lambda x: x * 2 ).write_bytes_to_stream(f, flush=True)    ...     with open(filename, 'rb') as f2:    ...         Iter.read_bytes(f2, size=2).map(bytes.decode).collect()    ['aa', 'bb', 'cc']    &gt;&gt;&gt; td.cleanup().. _Iter.write_to_file:|cool| |sink| ``Iter.write_to_file(self, file, mode=&quot;w&quot;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None, )``===============================================================================================================================================.. code-block:: python    &gt;&gt;&gt; import tempfile    &gt;&gt;&gt; with tempfile.TemporaryDirectory() as td:    ...     # Put some random text into a temporary file    ...     with open(td + 'text.txt', 'w') as f:    ...         f.writelines(['abc\n', 'def\n', 'ghi\n'])    ...    ...     # Open the file, transform, write out to new file.    ...     Iter.open(td + 'text.txt').map(str.upper).write_to_file(td + 'test2.txt')    ...     # Read the new file, for the test    ...     Iter.open(td + 'test2.txt').collect()    ['ABC\n', 'DEF\n', 'GHI\n'].. _Iter.range:|source| ``@classmethod Iter.range(cls, *args) -&gt; &quot;Iter[int]&quot;``===============================================================The ``range`` function you all know and love... code-block:: python    &gt;&gt;&gt; Iter.range(3).collect()    [0, 1, 2]    &gt;&gt;&gt; Iter.range(0).collect()    [].. _Iter.zip:``Iter.zip(self, *iterables: Any) -&gt; &quot;Iter[Tuple[T, ...]]&quot;``============================================================The ``zip`` function you all know and love. The only thing tonote here is that the first iterable is really what the Iter_instance is wrapping. The Iter.zip_ invocation brings in theother iterables.Make an Iter_ instance, then call ``zip`` on that... code-block:: python    &gt;&gt;&gt; Iter('caleb').zip(range(10)).collect()    [('c', 0), ('a', 1), ('l', 2), ('e', 3), ('b', 4)]Use a classmethod to get an infinite stream using Iter.count_and zip against that with more finite iterators... code-block:: python    &gt;&gt;&gt; Iter.count().zip(range(5), range(3, 100, 2)).collect()    [(0, 0, 3), (1, 1, 5), (2, 2, 7), (3, 3, 9), (4, 4, 11)]It takes a few minutes to get used to that but feels comfortablepretty quickly.Iter.take_ can be used to stop infinite zip sequences:.. code-block:: python    &gt;&gt;&gt; Iter('caleb').cycle().enumerate().take(8).collect()    [(0, 'c'), (1, 'a'), (2, 'l'), (3, 'e'), (4, 'b'), (5, 'c'), (6, 'a'), (7, 'l')]While we're here (assuming you worked through the previousexample), note the difference if you switch the order of theIter.cycle_ and Iter.enumerate_ calls:.. code-block:: python    &gt;&gt;&gt; Iter('caleb').enumerate().cycle().take(8).collect()    [(0, 'c'), (1, 'a'), (2, 'l'), (3, 'e'), (4, 'b'), (0, 'c'), (1, 'a'), (2, 'l')]If you understand how this works, everything else in _excitertools_will be intuitive to use... _Iter.any:|sink| ``Iter.any(self) -&gt; &quot;bool&quot;``===================================.. code-block:: python    &gt;&gt;&gt; Iter([0, 0, 0]).any()    False    &gt;&gt;&gt; Iter([0, 0, 1]).any()    True    &gt;&gt;&gt; Iter([]).any()    False.. _Iter.all:|sink| ``Iter.all(self) -&gt; &quot;bool&quot;``===================================.. code-block:: python    &gt;&gt;&gt; Iter([0, 0, 0]).all()    False    &gt;&gt;&gt; Iter([0, 0, 1]).all()    False    &gt;&gt;&gt; Iter([1, 1, 1]).all()    TrueNow pay attention:.. code-block:: python    &gt;&gt;&gt; Iter([]).all()    TrueThis behaviour has some controversy around it, but that's how the``all()`` builtin works so that's what we do too. The way tothink about what ``all()`` does is this: it returns False if thereis at least one element that is falsy.  Thus, if there are no elementsit follows that there are no elements that are falsy and that's why``all([]) == True``... _Iter.enumerate:``Iter.enumerate(self) -&gt; &quot;Iter[Tuple[int, T]]&quot;``=================================================.. code-block:: python    &gt;&gt;&gt; Iter('abc').enumerate().collect()    [(0, 'a'), (1, 'b'), (2, 'c')]    &gt;&gt;&gt; Iter([]).enumerate().collect()    [].. _Iter.dict:``Iter.dict(self) -&gt; &quot;Dict&quot;``=============================In regular Python a dict can be constructed through an iterable of tuples:.. code-block:: python    &gt;&gt;&gt; dict([('a', 0), ('b', 1)])                      {'a': 0, 'b': 1}In *excitertools* we prefer chaining so this method is a shortcutfor that:.. code-block:: python    &gt;&gt;&gt; d = Iter('abc').zip(count()).dict()    &gt;&gt;&gt; assert d == {'a': 0, 'b': 1, 'c': 2}.. _Iter.map:``Iter.map(self, func: Union[Callable[..., C], str]) -&gt; &quot;Iter[C]&quot;``===================================================================The ``map`` function you all know and love... code-block:: python    &gt;&gt;&gt; Iter('abc').map(str.upper).collect()    ['A', 'B', 'C']    &gt;&gt;&gt; Iter(['abc', 'def']).map(str.upper).collect()    ['ABC', 'DEF']Using lambdas might seem convenient but in practice it turnsout that they make code difficult to read:.. code-block:: python    &gt;&gt;&gt; result = Iter('caleb').map(lambda x: (x, ord(x))).dict()    &gt;&gt;&gt; assert result == {'a': 97, 'b': 98, 'c': 99, 'e': 101, 'l': 108}It's recommended that you make a separate function instead:.. code-block:: python    &gt;&gt;&gt; def f(x):    ...     return x, ord(x)    &gt;&gt;&gt; result = Iter('caleb').map(f).dict()    &gt;&gt;&gt; assert result == {'a': 97, 'b': 98, 'c': 99, 'e': 101, 'l': 108}I know many people prefer anonymous functions (often onphilosphical grounds) but in practice it's just easier to makea separate, named function.I've experimented with passing a string into the map, and using``eval()`` to make a lambda internally. This simplifies the codevery slightly, at the cost of using strings-as-code. I'm prettysure this feature will be removed so don't use it... code-block:: python    &gt;&gt;&gt; result = Iter('caleb').map('x, ord(x)').dict()    &gt;&gt;&gt; assert result == {'a': 97, 'b': 98, 'c': 99, 'e': 101, 'l': 108}.. _Iter.filter:``Iter.filter(self, function: &quot;Optional[Callable[[T], bool]]&quot; = None) -&gt; &quot;Iter[T]&quot;``====================================================================================The ``map`` function you all know and love... code-block:: python    &gt;&gt;&gt; Iter('caleb').filter(lambda x: x in 'aeiou').collect()    ['a', 'e']There is a slight difference between this method signature andthe builtin ``filter``:  how the identity function is handled.This is a consquence of chaining. In the function signature aboveit is possible for us to give the ``function`` parameter adefault value of ``None`` because the parameter appears towardsthe end of the parameter list. Last, in fact.  In the`builtin filter signature &lt;https://docs.python.org/3/library/functions.html#filter&gt;`_it doesn't allow for this because the predicate parameter appearsfirst.This is a long way of saying: if you just want to filter outfalsy values, no parameter is needed:.. code-block:: python    &gt;&gt;&gt; Iter([0, 1, 0, 0, 0, 1, 1, 1, 0, 0]).filter().collect()    [1, 1, 1, 1]Using the builtin, you'd have to do ``filter(None, iterable)``.You'll find that Iter.map_ and Iter.filter_(and Iter.reduce_, up next) work together very nicely:.. code-block:: python    &gt;&gt;&gt; def not_eve(x):    ...    return x != 'eve'    &gt;&gt;&gt; Iter(['bob', 'eve', 'alice']).filter(not_eve).map(str.upper).collect()    ['BOB', 'ALICE']The long chains get unwieldy so let's rewrite that:.. code-block:: python    &gt;&gt;&gt; (    ...     Iter(['bob', 'eve', 'alice'])    ...         .filter(not_eve)    ...         .map(str.upper)    ...         .collect()    ... )    ['BOB', 'ALICE'].. _Iter.starfilter:|cool| ``Iter.starfilter(self, function: &quot;Optional[Callable[[T, ...], bool]]&quot; = None) -&gt; &quot;Iter[T]&quot;``====================================================================================================Like Iter.filter_, but arg unpacking in lambdas will work.With the normal ``filter``, this fails:.. code-block:: python    &gt;&gt;&gt; Iter('caleb').enumerate().filter(lambda i, x: i &gt; 2).collect()    Traceback (most recent call last):        ...    TypeError: &lt;lambda&gt;() missing 1 required positional argument: 'x'This is a real buzzkill. ``starfilter`` is very similar to ``starmap`` in that tuples are unpacked when calling the function:.. code-block:: python    &gt;&gt;&gt; Iter('caleb').enumerate().starfilter(lambda i, x: i &gt; 2).collect()    [(3, 'e'), (4, 'b')].. _Iter.filter_gt:``Iter.filter_gt(self, value) -&gt; &quot;Iter[T]&quot;``============================================Convenience method.. code-block:: python    &gt;&gt;&gt; Iter([1,2,3]).filter_gt(1).collect()    [2, 3].. _Iter.filter_ge:``Iter.filter_ge(self, value) -&gt; &quot;Iter[T]&quot;``============================================Convenience method.. code-block:: python    &gt;&gt;&gt; Iter([1,2,3]).filter_ge(2).collect()    [2, 3].. _Iter.filter_lt:``Iter.filter_lt(self, value) -&gt; &quot;Iter[T]&quot;``============================================Convenience method.. code-block:: python    &gt;&gt;&gt; Iter([1,2,3]).filter_lt(3).collect()    [1, 2].. _Iter.filter_le:``Iter.filter_le(self, value) -&gt; &quot;Iter[T]&quot;``============================================Convenience method.. code-block:: python    &gt;&gt;&gt; Iter([1,2,3]).filter_le(2).collect()    [1, 2].. _Iter.filter_eq:``Iter.filter_eq(self, value) -&gt; &quot;Iter[T]&quot;``============================================Convenience method.. code-block:: python    &gt;&gt;&gt; Iter([1,2,3]).filter_eq(2).collect()    [2].. _Iter.filter_ne:``Iter.filter_ne(self, value) -&gt; &quot;Iter[T]&quot;``============================================Convenience method.. code-block:: python    &gt;&gt;&gt; Iter([1,2,3]).filter_ne(2).collect()    [1, 3].. _Iter.filter_in:``Iter.filter_in(self, value: Sized) -&gt; &quot;Iter[T]&quot;``===================================================Convenience method for membership testing. Note that the valueparameter must be at least ``Sized`` because it gets reusedover and over for each pass of the iterator chain. For example,passing in things like ``range()`` will not work properly becauseit will become progressively exhausted... code-block:: python    &gt;&gt;&gt; Iter([1,2,3]).filter_in([2, 3, 4, 5]).collect()    [2, 3]    &gt;&gt;&gt; Iter([1,2,3]).filter_in(range(2, 8).collect()).collect()    [2, 3]    &gt;&gt;&gt; Iter([1,2,3]).filter_in({2, 3, 4, 5}).collect()    [2, 3]    &gt;&gt;&gt; Iter([1,2,3]).filter_in(dict.fromkeys({2, 3, 4, 5})).collect()    [2, 3].. _Iter.filter_ni:``Iter.filter_ni(self, value) -&gt; &quot;Iter[T]&quot;``============================================Convenience method for membership testing. Note that the valueparameter must be at least ``Sized`` because it gets reusedover and over for each pass of the iterator chain. For example,passing in things like ``range()`` will not work properly becauseit will become progressively exhausted... code-block:: python    &gt;&gt;&gt; Iter([1,2,3]).filter_ni([2, 3, 4, 5]).collect()    [1]    &gt;&gt;&gt; Iter([1,2,3]).filter_ni(range(2, 8).collect()).collect()    [1]    &gt;&gt;&gt; Iter([1,2,3]).filter_ni({2, 3, 4, 5}).collect()    [1]    &gt;&gt;&gt; Iter([1,2,3]).filter_ni(dict.fromkeys({2, 3, 4, 5})).collect()    [1].. _Iter.reduce:|sink| ``Iter.reduce(self, func: Callable[..., T], *args) -&gt; &quot;T&quot;``==================================================================The ``reduce`` function you all know and...hang on, actually``reduce`` is rather unloved. In the past I've found it very complexto reason about, when looking at a bunch of nested function callsin typical ``itertools`` code. Hopefully iterable chaining makesit easier to read code that uses ``reduce``?Let's check, does this make sense?.. code-block:: python    &gt;&gt;&gt; payments = [    ...     ('bob', 100),    ...     ('alice', 50),    ...     ('eve', -100),    ...     ('bob', 19.95),    ...     ('bob', -5.50),    ...     ('eve', 11.95),    ...     ('eve', 200),    ...     ('alice', -45),    ...     ('alice', -67),    ...     ('bob', 1.99),    ...     ('alice', 89),    ... ]    &gt;&gt;&gt; (    ...     Iter(payments)    ...         .filter(lambda entry: entry[0] == 'bob')    ...         .map(lambda entry: entry[1])    ...         .reduce(lambda total, value: total + value, 0)    ... )    116.44I intentionally omitted comments above so that you can try the&quot;readability experiment&quot;, but in practice you would definitelywant to add some comments on these chains:.. code-block:: python    &gt;&gt;&gt; (    ...     # Iterate over all payments    ...     Iter(payments)    ...         # Only look at bob's payments    ...         .filter(lambda entry: entry[0] == 'bob')    ...         # Extract the value of the payment    ...         .map(lambda entry: entry[1])    ...         # Add all those payments together    ...         .reduce(lambda total, value: total + value, 0)    ... )    116.44``reduce`` is a quite crude low-level tool. In many cases you'llfind that there are other functions and methods better suitedto the situations you'll encounter most often. For example, there is already Iter.sum_ if you just want to add up numbers,and it's much easier to use Iter.groupby_ for grouping than to try to make that work with Iter.reduce_. You *can* make it work but it'll be easier to use Iter.groupby_... _Iter.starreduce:|sink| ``Iter.starreduce(self, function: Callable[..., T], initializer=0) -&gt; &quot;T&quot;``==================================================================================Iter.starreduce_ is the same as Iter.reduce_ except that args arestar-unpacked when passed into ``function``. This is frequentlymore convenient than the default behaviour.We can see this using the same example shown for Iter.reduce_.The star unpacking makes it easier to just do the filteringdirectly inside the reducer function... code-block:: python    &gt;&gt;&gt; payments = [    ...     ('bob', 100),    ...     ('alice', 50),    ...     ('eve', -100),    ...     ('bob', 19.95),    ...     ('bob', -5.50),    ...     ('eve', 11.95),    ...     ('eve', 200),    ...     ('alice', -45),    ...     ('alice', -67),    ...     ('bob', 1.99),    ...     ('alice', 89),    ... ]    &gt;&gt;&gt; (    ...     Iter(payments)    ...         .starreduce(    ...             lambda tot, name, value: tot + value if name == 'bob' else tot,    ...             0    ...         )    ... )    116.44This is how that looks if you avoid a lambda:.. code-block:: python    &gt;&gt;&gt; def f(tot, name, value):    ...     if name == 'bob':    ...         return tot + value    ...     else:    ...         return tot    &gt;&gt;&gt; Iter(payments).starreduce(f)    116.44.. _Iter.sum:|sink| ``Iter.sum(self)``=========================Exactly what you expect:.. code-block:: python    &gt;&gt;&gt; Iter(range(10)).sum()    45.. _Iter.concat:|sink| ``Iter.concat(self, glue: AnyStr = '') -&gt; &quot;AnyStr&quot;``===========================================================Joining strings (and bytes)... code-block:: python    &gt;&gt;&gt; Iter(['hello', 'there']).concat()    'hellothere'    &gt;&gt;&gt; Iter(['hello', 'there']).concat(' ')    'hello there'    &gt;&gt;&gt; Iter(['hello', 'there']).concat(',')    'hello,there'    &gt;&gt;&gt; Iter([b'hello', b'there']).concat(b',')    b'hello,there'.. _Iter.insert:``Iter.insert(self, glue: C) -&gt; &quot;Iter[Union[C, T]]&quot;``=====================================================Docstring TBD.. _Iter.count:|source| ``@classmethod Iter.count(cls, *args) -&gt; &quot;Iter[int]&quot;``===============================================================.. code-block:: python    &gt;&gt;&gt; Iter.count().take(3).collect()    [0, 1, 2]    &gt;&gt;&gt; Iter.count(100).take(3).collect()    [100, 101, 102]    &gt;&gt;&gt; Iter.count(100, 2).take(3).collect()    [100, 102, 104].. _Iter.cycle:|inf| ``Iter.cycle(self) -&gt; &quot;Iter[T]&quot;``=======================================.. code-block:: python    &gt;&gt;&gt; Iter('abc').cycle().take(8).collect()    ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b']    &gt;&gt;&gt; Iter('abc').cycle().take(8).concat('')    'abcabcab'.. _Iter.repeat:|source| |inf| ``@classmethod Iter.repeat(cls, elem: C, times=None) -&gt; &quot;Iter[C]&quot;``==================================================================================.. code-block:: python    &gt;&gt;&gt; Iter.repeat('c', times=3).collect()    ['c', 'c', 'c'].. _Iter.accumulate:``Iter.accumulate(self, func=None, *, initial=None)``=====================================================Docstring TBD.. code-block:: python    &gt;&gt;&gt; Iter([1, 2, 3, 4, 5]).accumulate().collect()    [1, 3, 6, 10, 15]    &gt;&gt;&gt; if sys.version_info &gt;= (3, 8):    ...     out = Iter([1, 2, 3, 4, 5]).accumulate(initial=100).collect()    ...     assert out == [100, 101, 103, 106, 110, 115]    &gt;&gt;&gt; Iter([1, 2, 3, 4, 5]).accumulate(operator.mul).collect()    [1, 2, 6, 24, 120].. _Iter.chain:``Iter.chain(self, *iterables: Iterable[T]) -&gt; &quot;Iter[T]&quot;``==========================================================Docstring TBD.. code-block:: python    &gt;&gt;&gt; Iter('ABC').chain('DEF').collect()    ['A', 'B', 'C', 'D', 'E', 'F']    &gt;&gt;&gt; Iter('ABC').chain().collect()    ['A', 'B', 'C'].. _Iter.chain_from_iterable:``Iter.chain_from_iterable(self) -&gt; &quot;Iter[T]&quot;``===============================================Docstring TBD.. code-block:: python    &gt;&gt;&gt; Iter(['ABC', 'DEF']).chain_from_iterable().collect()    ['A', 'B', 'C', 'D', 'E', 'F'].. _Iter.compress:``Iter.compress(self, selectors)``==================================Replacement for the itertools ``compress`` function.  This version returnsan instance of Iter_ to allow further iterable chaining... code-block:: python    &gt;&gt;&gt; Iter('ABCDEF').compress([1, 0, 1, 0, 1, 1]).collect()    ['A', 'C', 'E', 'F'].. _Iter.dropwhile:``Iter.dropwhile(self, pred)``==============================Docstring TBD.. _Iter.filterfalse:``Iter.filterfalse(self, pred)``================================Docstring TBD.. _Iter.groupby:``Iter.groupby(self, key=None)``================================Docstring TBD.. _Iter.islice:``Iter.islice(self, *args) -&gt; &quot;Iter&quot;``======================================Docstring TBD.. _Iter.starmap:``Iter.starmap(self, func)``============================Docstring TBD.. _Iter.takewhile:``Iter.takewhile(self, pred)``==============================Docstring TBD.. _Iter.tee:``Iter.tee(self, n=2)``=======================Docstring TBD.. _Iter.zip_longest:``Iter.zip_longest(self, *iterables, fillvalue=None)``======================================================Docstring TBD.. _Iter.chunked:``Iter.chunked(self, n: int) -&gt; &quot;Iter&quot;``========================================Docstring TBD.. _Iter.ichunked:``Iter.ichunked(self, n: int) -&gt; &quot;Iter&quot;``=========================================Docstring TBD.. _Iter.sliced:``@classmethod Iter.sliced(cls, seq: Sequence, n: int) -&gt; &quot;Iter&quot;``==================================================================Docstring TBD.. _Iter.distribute:``Iter.distribute(self, n: int) -&gt; &quot;Iter&quot;``===========================================Docstring TBD.. _Iter.divide:``Iter.divide(self, n: int) -&gt; &quot;Iter&quot;``=======================================Docstring TBD.. _Iter.split_at:``Iter.split_at(self, pred)``=============================Docstring TBD.. _Iter.split_before:``Iter.split_before(self, pred)``=================================Docstring TBD.. _Iter.split_after:``Iter.split_after(self, pred)``================================Docstring TBD.. _Iter.split_into:``Iter.split_into(self, sizes)``================================Docstring TBD.. _Iter.split_when:``Iter.split_when(self, pred)``===============================Docstring TBD.. _Iter.bucket:``Iter.bucket(self, key, validator=None)``==========================================This is the basic example, copied from the more-itertoolsdocs:.. code-block:: python    &gt;&gt;&gt; iterable = ['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'b3']    &gt;&gt;&gt; b = Iter(iterable).bucket(key=lambda x: x[0])    &gt;&gt;&gt; sorted(b)    ['a', 'b', 'c']    &gt;&gt;&gt; list(b['a'])    ['a1', 'a2']Note that once consumed, you can't iterate over the contentsof a group again... _Iter.unzip:``Iter.unzip(self)``====================Docstring TBD.. _Iter.grouper:``Iter.grouper(self, n: int, fillvalue=None) -&gt; &quot;Iter&quot;``========================================================Docstring TBD.. _Iter.partition:``Iter.partition(self, pred) -&gt; &quot;Iter&quot;``========================================Docstring TBD.. _Iter.spy:``Iter.spy(self, n=1) -&gt; &quot;Tuple[Iter, Iter]&quot;``==============================================Docstring TBD.. _Iter.peekable:``Iter.peekable(self) -&gt; &quot;more_itertools.peekable&quot;``====================================================Docstring TBD.. code-block:: python    &gt;&gt;&gt; p = Iter(['a', 'b']).peekable()    &gt;&gt;&gt; p.peek()    'a'    &gt;&gt;&gt; next(p)    'a'The peekable can be used to inspect what will be coming up.But if you then want to resume iterator chaining, pass thepeekable back into an Iter_ instance... code-block:: python    &gt;&gt;&gt; p = Iter(range(10)).peekable()    &gt;&gt;&gt; p.peek()    0    &gt;&gt;&gt; Iter(p).take(3).collect()    [0, 1, 2]A peekable is not an Iter_ instance so it doesn't providethe iterator chaining methods. But if you want to get intochaining, use the ``iter()`` method... code-block:: python    &gt;&gt;&gt; p = Iter(range(5)).peekable()    &gt;&gt;&gt; p.peek()    0    &gt;&gt;&gt; p[1]    1    &gt;&gt;&gt; p.iter().take(3).collect()    [0, 1, 2]Peekables can be prepended. But then you usually want to goright back to iterator chaining. Thus, the ``prepend`` method(on the returned ``peekable`` instance) returns an Iter_ instance... code-block:: python    &gt;&gt;&gt; p = Iter(range(3)).peekable()    &gt;&gt;&gt; p.peek()    0    &gt;&gt;&gt; p.prepend('a', 'b').take(4).collect()    ['a', 'b', 0, 1].. _Iter.seekable:``Iter.seekable(self) -&gt; &quot;more_itertools.seekable&quot;``====================================================Docstring TBD.. _Iter.windowed:``Iter.windowed(self, n, fillvalue=None, step=1) -&gt; &quot;Iter&quot;``============================================================Docstring TBD.. _Iter.substrings:``Iter.substrings(self)``=========================Docstring TBD.. _Iter.substrings_indexes:``Iter.substrings_indexes(self, reverse=False)``================================================Docstring TBD.. _Iter.stagger:``Iter.stagger(self, offsets=(-1, 0, 1), longest=False, fillvalue=None)``=========================================================================.. code-block:: python    &gt;&gt;&gt; Iter([0, 1, 2, 3]).stagger().collect()    [(None, 0, 1), (0, 1, 2), (1, 2, 3)]    &gt;&gt;&gt; Iter(range(8)).stagger(offsets=(0, 2, 4)).collect()    [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]    &gt;&gt;&gt; Iter([0, 1, 2, 3]).stagger(longest=True).collect()    [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)].. _Iter.pairwise:``Iter.pairwise(self)``=======================Reference `more_itertools.pairwise &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.pairwise&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter.count().pairwise().take(4).collect()    [(0, 1), (1, 2), (2, 3), (3, 4)].. _Iter.count_cycle:``Iter.count_cycle(self, n=None) -&gt; &quot;Iter&quot;``============================================Reference: `more_itertools.count_cycle &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.count_cycle&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter('AB').count_cycle(3).collect()    [(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')].. _Iter.intersperse:``Iter.intersperse(self, e, n=1) -&gt; &quot;Iter&quot;``============================================Reference: `more_itertools.intersperse &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.intersperse&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([1, 2, 3, 4, 5]).intersperse('!').collect()    [1, '!', 2, '!', 3, '!', 4, '!', 5]    &gt;&gt;&gt; Iter([1, 2, 3, 4, 5]).intersperse(None, n=2).collect()    [1, 2, None, 3, 4, None, 5].. _Iter.padded:``Iter.padded(self, fillvalue: Optional[C] = None, n: Optional[int] = None, next_multiple: bool = False, ) -&gt; &quot;Iter[Union[T, C]]&quot;``===================================================================================================================================Reference: `more_itertools.padded &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.padded&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([1, 2, 3]).padded('?', 5).collect()    [1, 2, 3, '?', '?']    &gt;&gt;&gt; Iter([1, 2, 3, 4]).padded(n=3, next_multiple=True).collect()    [1, 2, 3, 4, None, None].. _Iter.repeat_last:``Iter.repeat_last(self, default=None) -&gt; &quot;Iter[T]&quot;``=====================================================Reference: `more_itertools.repeat_last &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.repeat_last&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter(range(3)).repeat_last().islice(5).collect()    [0, 1, 2, 2, 2]    &gt;&gt;&gt; Iter(range(0)).repeat_last(42).islice(5).collect()    [42, 42, 42, 42, 42].. _Iter.adjacent:``Iter.adjacent(self, pred, distance=1) -&gt; &quot;Iter[Tuple[bool, T]]&quot;``===================================================================Reference: `more_itertools.adjacent &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.adjacent&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter(range(6)).adjacent(lambda x: x == 3).collect()    [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]    &gt;&gt;&gt; Iter(range(6)).adjacent(lambda x: x == 3, distance=2).collect()    [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)].. _Iter.groupby_transform:``Iter.groupby_transform(self, keyfunc: Optional[Callable[..., K]] = None, valuefunc: Optional[Callable[..., V]] = None, ) -&gt; &quot;Iter[Tuple[K, Iterable[V]]]&quot;``=============================================================================================================================================================Reference: `more_itertools.groupby_transform &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.groupby_transform&gt;`_This example has been modified somewhat from the original. We're using``starmap`` here to &quot;unzip&quot; the tuples produced by the grouptransform... code-block:: python    &gt;&gt;&gt; iterable = 'AaaABbBCcA'    &gt;&gt;&gt; keyfunc = lambda x: x.upper()    &gt;&gt;&gt; valuefunc = lambda x: x.lower()    &gt;&gt;&gt; (    ...    Iter(iterable)    ...        .groupby_transform(keyfunc, valuefunc)    ...        .starmap(lambda k, g: (k, ''.join(g)))    ...        .collect()    ... )    [('A', 'aaaa'), ('B', 'bbb'), ('C', 'cc'), ('A', 'a')]    &gt;&gt;&gt; from operator import itemgetter    &gt;&gt;&gt; keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]    &gt;&gt;&gt; values = 'abcdefghi'    &gt;&gt;&gt; iterable = zip(keys, values)    &gt;&gt;&gt; (    ...     Iter(iterable)    ...        .groupby_transform(itemgetter(0), itemgetter(1))    ...        .starmap(lambda k, g: (k, ''.join(g)))    ...        .collect()    ... )    [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')].. _Iter.padnone:``Iter.padnone(self) -&gt; &quot;Iter[Union[T, None]]&quot;``================================================Reference: `more_itertools.padnone &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.padnone&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter(range(3)).padnone().take(5).collect()    [0, 1, 2, None, None].. _Iter.ncycles:``Iter.ncycles(self, n) -&gt; &quot;Iter[T]&quot;``======================================Reference: `more_itertools.ncycles &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.ncycles&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter(['a', 'b']).ncycles(3).collect()    ['a', 'b', 'a', 'b', 'a', 'b'].. _Iter.collapse:``Iter.collapse(self, base_type=None, levels=None) -&gt; &quot;Iter&quot;``==============================================================Reference: `more_itertools.collapse &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse&gt;`_.. code-block:: python    &gt;&gt;&gt; iterable = [(1, 2), ([3, 4], [[5], [6]])]    &gt;&gt;&gt; Iter(iterable).collapse().collect()    [1, 2, 3, 4, 5, 6]    &gt;&gt;&gt; iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]    &gt;&gt;&gt; Iter(iterable).collapse(base_type=tuple).collect()    ['ab', ('cd', 'ef'), 'gh', 'ij']    &gt;&gt;&gt; iterable = [('a', ['b']), ('c', ['d'])]    &gt;&gt;&gt; Iter(iterable).collapse().collect() # Fully flattened    ['a', 'b', 'c', 'd']    &gt;&gt;&gt; Iter(iterable).collapse(levels=1).collect() # Only one level flattened    ['a', ['b'], 'c', ['d']].. _Iter.sort_together:``@class_or_instancemethod Iter.sort_together(self_or_cls, iterables, key_list=(0,), reverse=False)``=====================================================================================================Reference: `more_itertools.sort_together &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.sort_together&gt;`_This can be called either as an instance method or a class method.The classmethod form is more convenient if all the iterables arealready available. The instancemethod form is more convenient ifone of the iterables already goes through some transformation.Here are examples from the classmethod form, which mirror theexamples in the more-itertools_ documentation:.. code-block:: python    &gt;&gt;&gt; iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]    &gt;&gt;&gt; Iter.sort_together(iterables).collect()    [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]    &gt;&gt;&gt; iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]    &gt;&gt;&gt; Iter.sort_together(iterables, key_list=(1, 2)).collect()    [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]    &gt;&gt;&gt; Iter.sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True).collect()    [(3, 2, 1), ('a', 'b', 'c')]Here is an examples using the instancemethod form:.. code-block:: python    &gt;&gt;&gt; iterables = [('a', 'b', 'c', 'd')]    &gt;&gt;&gt; Iter([4, 3, 2, 1]).sort_together(iterables).collect()    [(1, 2, 3, 4), ('d', 'c', 'b', 'a')].. _Iter.interleave:``@class_or_instancemethod Iter.interleave(self_or_cls, *iterables) -&gt; &quot;Iter&quot;``===============================================================================Reference: `more_itertools.interleave &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.interleave&gt;`_Classmethod form:.. code-block:: python    &gt;&gt;&gt; Iter.interleave([1, 2, 3], [4, 5], [6, 7, 8]).collect()    [1, 4, 6, 2, 5, 7]Instancemethod form:.. code-block:: python    &gt;&gt;&gt; Iter([1, 2, 3]).interleave([4, 5], [6, 7, 8]).collect()    [1, 4, 6, 2, 5, 7].. _Iter.interleave_longest:``@class_or_instancemethod Iter.interleave_longest(self_or_cls, *iterables) -&gt; &quot;Iter&quot;``=======================================================================================Reference: `more_itertools.interleave_longest &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.interleave_longest&gt;`_Classmethod form:.. code-block:: python    &gt;&gt;&gt; Iter.interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]).collect()    [1, 4, 6, 2, 5, 7, 3, 8]Instancemethod form:.. code-block:: python    &gt;&gt;&gt; Iter([1, 2, 3]).interleave_longest([4, 5], [6, 7, 8]).collect()    [1, 4, 6, 2, 5, 7, 3, 8].. _Iter.zip_offset:``@classmethod Iter.zip_offset(cls, *iterables, offsets, longest=False, fillvalue=None) -&gt; &quot;Iter&quot;``===================================================================================================Reference: `more_itertools.zip_offset &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.zip_offset&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter.zip_offset('0123', 'abcdef', offsets=(0, 1)).collect()    [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]    &gt;&gt;&gt; Iter.zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True).collect()    [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')].. _Iter.dotproduct:``Iter.dotproduct(self, vec2: Iterable)``=========================================Reference: `more_itertools.dotproduct &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.dotproduct&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([10, 10]).dotproduct([20, 20])    400.. _Iter.flatten:``Iter.flatten(self) -&gt; &quot;Iter[T]&quot;``===================================Reference: `more_itertools.flatten &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.flatten&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([[0, 1], [2, 3]]).flatten().collect()    [0, 1, 2, 3].. _Iter.roundrobin:``@class_or_instancemethod Iter.roundrobin(self_or_cls: Union[Type[T], T], *iterables: C) -&gt; &quot;Iter[Union[T, C]]&quot;``==================================================================================================================Reference: `more_itertools.roundrobin &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.roundrobin&gt;`_Classmethod form:.. code-block:: python    &gt;&gt;&gt; Iter.roundrobin('ABC', 'D', 'EF').collect()    ['A', 'D', 'E', 'B', 'F', 'C']Instancemethod form:.. code-block:: python    &gt;&gt;&gt; Iter('ABC').roundrobin('D', 'EF').collect()    ['A', 'D', 'E', 'B', 'F', 'C'].. _Iter.prepend:``Iter.prepend(self, value: C) -&gt; &quot;Iter[Union[T, C]]&quot;``=======================================================Reference: `more_itertools.prepend &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.prepend&gt;`_.. code-block:: python    &gt;&gt;&gt; value = '0'    &gt;&gt;&gt; iterator = ['1', '2', '3']    &gt;&gt;&gt; Iter(iterator).prepend(value).collect()    ['0', '1', '2', '3'].. _Iter.ilen:|sink| ``Iter.ilen(self) -&gt; &quot;int&quot;``===================================Reference: `more_itertools.ilen &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.ilen&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter(x for x in range(1000000) if x % 3 == 0).ilen()    333334.. _Iter.unique_to_each:``Iter.unique_to_each(self) -&gt; &quot;Iter[T]&quot;``==========================================Reference: `more_itertools.unique_to_each &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_to_each&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([{'A', 'B'}, {'B', 'C'}, {'B', 'D'}]).unique_to_each().collect()    [['A'], ['C'], ['D']]    &gt;&gt;&gt; Iter([&quot;mississippi&quot;, &quot;missouri&quot;]).unique_to_each().collect()    [['p', 'p'], ['o', 'u', 'r']].. _Iter.sample:``Iter.sample(self, k=1, weights=None) -&gt; &quot;Iter&quot;``==================================================Reference: `more_itertools.sample &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.sample&gt;`_.. code-block:: python    &gt;&gt;&gt; iterable = range(100)    &gt;&gt;&gt; Iter(iterable).sample(5).collect()                      [81, 60, 96, 16, 4]    &gt;&gt;&gt; iterable = range(100)    &gt;&gt;&gt; weights = (i * i + 1 for i in range(100))    &gt;&gt;&gt; Iter(iterable).sample(5, weights=weights)                      [79, 67, 74, 66, 78]    &gt;&gt;&gt; data = &quot;abcdefgh&quot;    &gt;&gt;&gt; weights = range(1, len(data) + 1)    &gt;&gt;&gt; Iter(data).sample(k=len(data), weights=weights)                      ['c', 'a', 'b', 'e', 'g', 'd', 'h', 'f']    &gt;&gt;&gt; # This one just to let the doctest run    &gt;&gt;&gt; iterable = range(100)    &gt;&gt;&gt; Iter(iterable).sample(5).map(lambda x: 0 &lt;= x &lt; 100).all()    True.. _Iter.consecutive_groups:``Iter.consecutive_groups(self, ordering=lambda x: x)``=======================================================Reference: `more_itertools.consecutive_groups &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.consecutive_groups&gt;`_.. code-block:: python    &gt;&gt;&gt; iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]    &gt;&gt;&gt; Iter(iterable).consecutive_groups().map(lambda g: list(g)).print('{v}').consume()    [1]    [10, 11, 12]    [20]    [30, 31, 32, 33]    [40].. _Iter.run_length_encode:``Iter.run_length_encode(self) -&gt; &quot;Iter[Tuple[T, int]]&quot;``=========================================================Reference: `more_itertools.run_length &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.run_length&gt;`_.. code-block:: python    &gt;&gt;&gt; uncompressed = 'abbcccdddd'    &gt;&gt;&gt; Iter(uncompressed).run_length_encode().collect()    [('a', 1), ('b', 2), ('c', 3), ('d', 4)].. _Iter.run_length_decode:``Iter.run_length_decode(self) -&gt; &quot;Iter&quot;``==========================================Reference: `more_itertools.run_length &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.run_length&gt;`_.. code-block:: python    &gt;&gt;&gt; compressed = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]    &gt;&gt;&gt; Iter(compressed).run_length_decode().collect()    ['a', 'b', 'b', 'c', 'c', 'c', 'd', 'd', 'd', 'd'].. _Iter.map_reduce:``Iter.map_reduce(self, keyfunc, valuefunc=None, reducefunc=None) -&gt; &quot;Dict&quot;``=============================================================================Reference: `more_itertools.map_reduce &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.map_reduce&gt;`_This interface mirrors what more-itertools_ does in that it returnsa dict. See ``map_reduce_it()`` for a slightly-modified interfacethat returns the dict items as another iterator... code-block:: python    &gt;&gt;&gt; keyfunc = lambda x: x.upper()    &gt;&gt;&gt; d = Iter('abbccc').map_reduce(keyfunc)    &gt;&gt;&gt; sorted(d.items())    [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]    &gt;&gt;&gt; keyfunc = lambda x: x.upper()    &gt;&gt;&gt; valuefunc = lambda x: 1    &gt;&gt;&gt; d = Iter('abbccc').map_reduce(keyfunc, valuefunc)    &gt;&gt;&gt; sorted(d.items())    [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]    &gt;&gt;&gt; keyfunc = lambda x: x.upper()    &gt;&gt;&gt; valuefunc = lambda x: 1    &gt;&gt;&gt; reducefunc = sum    &gt;&gt;&gt; d = Iter('abbccc').map_reduce(keyfunc, valuefunc, reducefunc)    &gt;&gt;&gt; sorted(d.items())    [('A', 1), ('B', 2), ('C', 3)]Note the warning given in the more-itertools_ docs about howlists are created before the reduce step. This means you always wantto filter *before* applying map_reduce, not after... code-block:: python    &gt;&gt;&gt; all_items = _range(30)    &gt;&gt;&gt; keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1    &gt;&gt;&gt; categories = Iter(all_items).filter(lambda x: 10&lt;=x&lt;=20).map_reduce(keyfunc=keyfunc)    &gt;&gt;&gt; sorted(categories.items())    [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]    &gt;&gt;&gt; summaries = Iter(all_items).filter(lambda x: 10&lt;=x&lt;=20).map_reduce(keyfunc=keyfunc, reducefunc=sum)    &gt;&gt;&gt; sorted(summaries.items())    [(0, 90), (1, 75)].. _Iter.map_reduce_it:``Iter.map_reduce_it(self, keyfunc: Callable[..., K], valuefunc: Optional[Callable[..., V]] = None, reducefunc: Optional[Callable[..., R]] = None, ) -&gt; &quot;Iter[Tuple[K, R]]&quot;``=============================================================================================================================================================================Reference: `more_itertools.map_reduce &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.map_reduce&gt;`_.. code-block:: python    &gt;&gt;&gt; keyfunc = lambda x: x.upper()    &gt;&gt;&gt; Iter('abbccc').map_reduce_it(keyfunc).collect()    [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]    &gt;&gt;&gt; keyfunc = lambda x: x.upper()    &gt;&gt;&gt; valuefunc = lambda x: 1    &gt;&gt;&gt; Iter('abbccc').map_reduce_it(keyfunc, valuefunc).collect()    [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]    &gt;&gt;&gt; keyfunc = lambda x: x.upper()    &gt;&gt;&gt; valuefunc = lambda x: 1    &gt;&gt;&gt; reducefunc = sum    &gt;&gt;&gt; Iter('abbccc').map_reduce_it(keyfunc, valuefunc, reducefunc).collect()    [('A', 1), ('B', 2), ('C', 3)].. _Iter.exactly_n:|sink| ``Iter.exactly_n(self, n, predicate=bool) -&gt; &quot;bool&quot;``============================================================Docstring TBD.. code-block:: python    &gt;&gt;&gt; Iter([True, True, False]).exactly_n(2)    True.. _Iter.all_equal:``Iter.all_equal(self)``========================.. _Iter.first_true:``Iter.first_true(self)``=========================.. _Iter.quantify:``Iter.quantify(self)``=======================.. _Iter.islice_extended:``Iter.islice_extended(self, *args)``=====================================Reference: `more_itertools.islice_extended &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.islice_extended&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter('abcdefgh').islice_extended(-4, -1).collect()    ['e', 'f', 'g'].. code-block:: python    &gt;&gt;&gt; Iter.count().islice_extended( 110, 99, -2).collect()    [110, 108, 106, 104, 102, 100].. _Iter.first:``Iter.first(self)``====================Reference: `more_itertools.first &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.first&gt;`_.. _Iter.last:``Iter.last(self)``===================Reference: `more_itertools.last &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.last&gt;`_.. _Iter.one:``Iter.one(self)``==================Reference: `more_itertools.one &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.one&gt;`_.. _Iter.only:``Iter.only(self, default=None, too_long=ValueError) -&gt; &quot;T&quot;``=============================================================Reference: `more_itertools.one &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.one&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([]).only(default='missing')    'missing'    &gt;&gt;&gt; Iter([42]).only(default='missing')    42    &gt;&gt;&gt; Iter([1, 2]).only()    Traceback (most recent call last):        ...    ValueError: ..... _Iter.strip:``Iter.strip(self, pred) -&gt; &quot;Iter[T]&quot;``=======================================Reference: `more_itertools.strip &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.strip&gt;`_.. code-block:: python    &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)    &gt;&gt;&gt; pred = lambda x: x in {None, False, ''}    &gt;&gt;&gt; Iter(iterable).strip(pred).collect()    [1, 2, None, 3].. _Iter.lstrip:``Iter.lstrip(self, pred) -&gt; &quot;Iter[T]&quot;``========================================Reference: `more_itertools.lstrip &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.lstrip&gt;`_.. code-block:: python    &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)    &gt;&gt;&gt; pred = lambda x: x in {None, False, ''}    &gt;&gt;&gt; Iter(iterable).lstrip(pred).collect()    [1, 2, None, 3, False, None].. _Iter.rstrip:``Iter.rstrip(self, pred) -&gt; &quot;Iter[T]&quot;``========================================Reference: `more_itertools.rstrip &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.rstrip&gt;`_.. code-block:: python    &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)    &gt;&gt;&gt; pred = lambda x: x in {None, False, ''}    &gt;&gt;&gt; Iter(iterable).rstrip(pred).collect()    [None, False, None, 1, 2, None, 3].. _Iter.filter_except:``Iter.filter_except(self, validator, *exceptions) -&gt; &quot;Iter[T]&quot;``=================================================================Reference: `more_itertools.filter_except &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.filter_except&gt;`_.. code-block:: python    &gt;&gt;&gt; iterable = ['1', '2', 'three', '4', None]    &gt;&gt;&gt; Iter(iterable).filter_except(int, ValueError, TypeError).collect()    ['1', '2', '4'].. _Iter.map_except:``Iter.map_except(self, function, *exceptions) -&gt; &quot;Iter&quot;``==========================================================Reference: `more_itertools.map_except &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.map_except&gt;`_.. code-block:: python    &gt;&gt;&gt; iterable = ['1', '2', 'three', '4', None]    &gt;&gt;&gt; Iter(iterable).map_except(int, ValueError, TypeError).collect()    [1, 2, 4].. _Iter.nth_or_last:``Iter.nth_or_last(self, n, default=_marker) -&gt; &quot;T&quot;``=====================================================Reference: `more_itertools.nth_or_last &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.nth_or_last&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([0, 1, 2, 3]).nth_or_last(2)    2    &gt;&gt;&gt; Iter([0, 1]).nth_or_last(2)    1    &gt;&gt;&gt; Iter([]).nth_or_last(0, 'some default')    'some default'.. _Iter.nth:``Iter.nth(self, n, default=None)``===================================Reference: `more_itertools.nth &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.nth&gt;`_.. _Iter.take:``Iter.take(self, n: int) -&gt; &quot;Iter&quot;``=====================================Reference: `more_itertools.take &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.take&gt;`_.. _Iter.tail:``Iter.tail(self, n) -&gt; &quot;Iter[T]&quot;``===================================Reference: `more_itertools.tail &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.tail&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter('ABCDEFG').tail(3).collect()    ['E', 'F', 'G'].. _Iter.unique_everseen:``Iter.unique_everseen(self, key=None) -&gt; &quot;Iter[T]&quot;``=====================================================Reference: `more_itertools.unique_everseen &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_everseen&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter('AAAABBBCCDAABBB').unique_everseen().collect()    ['A', 'B', 'C', 'D']    &gt;&gt;&gt; Iter('ABBCcAD').unique_everseen(key=str.lower).collect()    ['A', 'B', 'C', 'D']Be sure to read the *more-itertools* docs whne using unhashableitems... code-block:: python    &gt;&gt;&gt; iterable = ([1, 2], [2, 3], [1, 2])    &gt;&gt;&gt; Iter(iterable).unique_everseen().collect()  # Slow    [[1, 2], [2, 3]]    &gt;&gt;&gt; Iter(iterable).unique_everseen(key=tuple).collect()  # Faster    [[1, 2], [2, 3]].. _Iter.unique_justseen:``Iter.unique_justseen(self, key=None) -&gt; &quot;Iter[T]&quot;``=====================================================Reference: `more_itertools.unique_justseen &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_justseen&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter('AAAABBBCCDAABBB').unique_justseen().collect()    ['A', 'B', 'C', 'D', 'A', 'B']    &gt;&gt;&gt; Iter('ABBCcAD').unique_justseen(key=str.lower).collect()    ['A', 'B', 'C', 'A', 'D'].. _Iter.distinct_permutations:``Iter.distinct_permutations(self)``====================================Reference: `more_itertools.distinct_permutations &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.distinct_permutations&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([1, 0, 1]).distinct_permutations().sorted().collect()    [(0, 1, 1), (1, 0, 1), (1, 1, 0)].. _Iter.distinct_combinations:``Iter.distinct_combinations(self, r) -&gt; &quot;Iter[T]&quot;``====================================================Reference: `more_itertools.distinct_combinations &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.distinct_combinations&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([0, 0, 1]).distinct_combinations(2).collect()    [(0, 0), (0, 1)].. _Iter.circular_shifts:``Iter.circular_shifts(self) -&gt; &quot;Iter[T]&quot;``===========================================Reference: `more_itertools.circular_shifts &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.circular_shifts&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter(range(4)).circular_shifts().collect()    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)].. _Iter.partitions:``Iter.partitions(self) -&gt; &quot;Iter[T]&quot;``======================================Reference: `more_itertools.partitions &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.partitions&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter('abc').partitions().collect()    [[['a', 'b', 'c']], [['a'], ['b', 'c']], [['a', 'b'], ['c']], [['a'], ['b'], ['c']]]    &gt;&gt;&gt; Iter('abc').partitions().print('{v}').consume()    [['a', 'b', 'c']]    [['a'], ['b', 'c']]    [['a', 'b'], ['c']]    [['a'], ['b'], ['c']]    &gt;&gt;&gt; Iter('abc').partitions().map(lambda v: [''.join(p) for p in v]).print('{v}').consume()    ['abc']    ['a', 'bc']    ['ab', 'c']    ['a', 'b', 'c'].. _Iter.set_partitions:``Iter.set_partitions(self, k=None) -&gt; &quot;Iter[T]&quot;``==================================================Reference: `more_itertools.set_partitions &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.set_partitions&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter('abc').set_partitions(2).collect()    [[['a'], ['b', 'c']], [['a', 'b'], ['c']], [['b'], ['a', 'c']]].. _Iter.powerset:``Iter.powerset(self)``=======================Reference: `more_itertools.powerset &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.powerset&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([1, 2, 3]).powerset().collect()    [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)].. _Iter.random_product:``@class_or_instancemethod Iter.random_product(self_or_cls, *args, repeat=1)``==============================================================================Reference: `more_itertools.random_product &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.random_product&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter('abc').random_product(range(4), 'XYZ').collect()                      ['c', 3, 'X']    &gt;&gt;&gt; Iter.random_product('abc', range(4), 'XYZ').collect()                      ['c', 0, 'Z']    &gt;&gt;&gt; Iter('abc').random_product(range(0)).collect()    Traceback (most recent call last):        ...    IndexError: Cannot choose from an empty sequence    &gt;&gt;&gt; Iter.random_product(range(0)).collect()    Traceback (most recent call last):        ...    IndexError: Cannot choose from an empty sequence.. _Iter.random_permutation:``Iter.random_permutation(self, r=None)``=========================================Reference: `more_itertools.random_permutation &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.random_permutation&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter(range(5)).random_permutation().collect()                      [2, 0, 4, 3, 1]    &gt;&gt;&gt; Iter(range(0)).random_permutation().collect()    [].. _Iter.random_combination:``Iter.random_combination(self, r)``====================================Reference: `more_itertools.random_combination &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.random_combination&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter(range(5)).random_combination(3).collect()                      [0, 1, 4]    &gt;&gt;&gt; Iter(range(5)).random_combination(0).collect()    [].. _Iter.random_combination_with_replacement:``Iter.random_combination_with_replacement(self, r)``=====================================================Reference: `more_itertools.random_combination_with_replacement &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.random_combination_with_replacement&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter(range(3)).random_combination_with_replacement(5).collect()                      [0, 0, 1, 2, 2]    &gt;&gt;&gt; Iter(range(3)).random_combination_with_replacement(0).collect()    [].. _Iter.nth_combination:``Iter.nth_combination(self, r, index)``========================================Reference: `more_itertools.nth_combination &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.nth_combination&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter(range(9)).nth_combination(3, 1).collect()    [0, 1, 3]    &gt;&gt;&gt; Iter(range(9)).nth_combination(3, 2).collect()    [0, 1, 4]    &gt;&gt;&gt; Iter(range(9)).nth_combination(3, 3).collect()    [0, 1, 5]    &gt;&gt;&gt; Iter(range(9)).nth_combination(4, 3).collect()    [0, 1, 2, 6]    &gt;&gt;&gt; Iter(range(9)).nth_combination(3, 7).collect()    [0, 2, 3].. _Iter.always_iterable:``@classmethod Iter.always_iterable(cls, obj, base_type=(str, bytes)) -&gt; 'Iter'``=================================================================================Reference: `more_itertools.always_iterable &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable&gt;`_.. code-block: python.. code-block:: python    &gt;&gt;&gt; Iter.always_iterable([1, 2, 3]).collect()    [1, 2, 3]    &gt;&gt;&gt; Iter.always_iterable(1).collect()    [1]    &gt;&gt;&gt; Iter.always_iterable(None).collect()    []    &gt;&gt;&gt; Iter.always_iterable('foo').collect()    ['foo']    &gt;&gt;&gt; Iter.always_iterable(dict(a=1), base_type=dict).collect()    [{'a': 1}].. _Iter.always_reversible:``Iter.always_reversible(self)``================================Reference: `more_itertools.always_reversible &lt;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_reversible&gt;`_This is like ``reversed()`` but it also operates on things thatwouldn't normally be reversible, like generators. It does this withinternal caching, so be careful with memory use... code-block: python    &gt;&gt;&gt; Iter('abc').always_reversible().collect()    ['c', 'b', 'a']    &gt;&gt;&gt; Iter(x for x in 'abc').always_reversible().collect()    ['c', 'b', 'a'].. _Iter.with_iter:``@classmethod Iter.with_iter(cls, context_manager)``=====================================================Reference: `more_itertools.with_iter &lt;https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.with_iter&gt;`_Note: Any context manager which returns an iterable is a candidate forIter.with_iter_... code-block:: python    &gt;&gt;&gt; import tempfile    &gt;&gt;&gt; with tempfile.TemporaryDirectory() as td:    ...     with open(td + 'text.txt', 'w') as f:    ...         f.writelines(['abc\n', 'def\n', 'ghi\n'])    ...     Iter.with_iter(open(td + 'text.txt')).map(lambda x: x.upper()).collect()    ['ABC\n', 'DEF\n', 'GHI\n']See also: Iter.open_|flux| TODO: perhaps we should get rid of Iter.open_ and just use this?.. _Iter.iter_except:``@classmethod Iter.iter_except(cls, func, exception, first=None) -&gt; &quot;Iter&quot;``=============================================================================Reference: `more_itertools.iter_except &lt;https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.iter_except&gt;`_.. code-block:: python    &gt;&gt;&gt; l = [0, 1, 2]    &gt;&gt;&gt; Iter.iter_except(l.pop, IndexError).collect()    [2, 1, 0].. _Iter.locate:``Iter.locate(self, pred=bool, window_size=None) -&gt; &quot;Iter&quot;``============================================================Reference: `more_itertools.locate &lt;https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.locate&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([0, 1, 1, 0, 1, 0, 0]).locate().collect()    [1, 2, 4].. code-block:: python    &gt;&gt;&gt; Iter(['a', 'b', 'c', 'b']).locate(lambda x: x == 'b').collect()    [1, 3].. code-block:: python    &gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]    &gt;&gt;&gt; pred = lambda *args: args == (1, 2, 3)    &gt;&gt;&gt; Iter(iterable).locate(pred=pred, window_size=3).collect()    [1, 5, 9].. code-block:: python    &gt;&gt;&gt; from itertools import count    &gt;&gt;&gt; from more_itertools import seekable    &gt;&gt;&gt; source = (3 * n + 1 if (n % 2) else n // 2 for n in count())    &gt;&gt;&gt; it = Iter(source).seekable()    &gt;&gt;&gt; pred = lambda x: x &gt; 100    &gt;&gt;&gt; # TODO: can we avoid making two instances?    &gt;&gt;&gt; indexes = Iter(it).locate(pred=pred)    &gt;&gt;&gt; i = next(indexes)    &gt;&gt;&gt; it.seek(i)    &gt;&gt;&gt; next(it)    106.. _Iter.rlocate:``Iter.rlocate(self, pred=bool, window_size=None) -&gt; &quot;Iter&quot;``=============================================================Reference: `more_itertools.rlocate &lt;https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.rlocate&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter([0, 1, 1, 0, 1, 0, 0]).rlocate().collect()  # Truthy at 1, 2, and 4    [4, 2, 1].. code-block:: python    &gt;&gt;&gt; pred = lambda x: x == 'b'    &gt;&gt;&gt; Iter('abcb').rlocate(pred).collect()    [3, 1].. code-block:: python    &gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]    &gt;&gt;&gt; pred = lambda *args: args == (1, 2, 3)    &gt;&gt;&gt; Iter(iterable).rlocate(pred=pred, window_size=3).collect()    [9, 5, 1].. _Iter.replace:``Iter.replace(self, pred, substitutes, count=None, window_size=1) -&gt; &quot;Iter&quot;``==============================================================================Reference: `more_itertools.replace &lt;https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.replace&gt;`_.. code-block:: python    &gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1]    &gt;&gt;&gt; pred = lambda x: x == 0    &gt;&gt;&gt; substitutes = (2, 3)    &gt;&gt;&gt; Iter(iterable).replace(pred, substitutes).collect()    [1, 1, 2, 3, 1, 1, 2, 3, 1, 1].. code-block:: python    &gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]    &gt;&gt;&gt; pred = lambda x: x == 0    &gt;&gt;&gt; substitutes = [None]    &gt;&gt;&gt; Iter(iterable).replace(pred, substitutes, count=2).collect()    [1, 1, None, 1, 1, None, 1, 1, 0].. code-block:: python    &gt;&gt;&gt; iterable = [0, 1, 2, 5, 0, 1, 2, 5]    &gt;&gt;&gt; window_size = 3    &gt;&gt;&gt; pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred    &gt;&gt;&gt; substitutes = [3, 4] # Splice in these items    &gt;&gt;&gt; Iter(iterable).replace(    ...     pred, substitutes, window_size=window_size    ... ).collect()    [3, 4, 5, 3, 4, 5].. _Iter.numeric_range:``@classmethod Iter.numeric_range(cls, *args) -&gt; &quot;Iter&quot;``=========================================================Reference: `more_itertools.numeric_range &lt;https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.numeric_range&gt;`_.. code-block:: python    &gt;&gt;&gt; Iter.numeric_range(3.5).collect()    [0.0, 1.0, 2.0, 3.0].. code-block:: python    &gt;&gt;&gt; from decimal import Decimal    &gt;&gt;&gt; start = Decimal('2.1')    &gt;&gt;&gt; stop = Decimal('5.1')    &gt;&gt;&gt; Iter.numeric_range(start, stop).collect()    [Decimal('2.1'), Decimal('3.1'), Decimal('4.1')].. code-block:: python    &gt;&gt;&gt; from fractions import Fraction    &gt;&gt;&gt; start = Fraction(1, 2)  # Start at 1/2    &gt;&gt;&gt; stop = Fraction(5, 2)  # End at 5/2    &gt;&gt;&gt; step = Fraction(1, 2)  # Count by 1/2    &gt;&gt;&gt; Iter.numeric_range(start, stop, step).collect()    [Fraction(1, 2), Fraction(1, 1), Fraction(3, 2), Fraction(2, 1)].. code-block:: python    &gt;&gt;&gt; Iter.numeric_range(3, -1, -1.0).collect()    [3.0, 2.0, 1.0, 0.0].. _Iter.side_effect:``Iter.side_effect(self, func, *args, chunk_size=None, before=None, after=None)``=================================================================================Reference: `more_itertools.side_effect &lt;https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.side_effect&gt;`_.. code-block:: python    &gt;&gt;&gt; def f(item):    ...     if item == 3:    ...         raise Exception('got 3')    &gt;&gt;&gt; Iter.range(5).side_effect(f).consume()    Traceback (most recent call last):        ...    Exception: got 3.. code-block:: python    &gt;&gt;&gt; func = lambda item: print('Received {}'.format(item))    &gt;&gt;&gt; Iter.range(2).side_effect(func).consume()    Received 0    Received 1This version of ``side_effect`` also allows extra args:.. code-block:: python    &gt;&gt;&gt; func = lambda item, format_str='Received {}': print(format_str.format(item))    &gt;&gt;&gt; Iter.range(2).side_effect(func).consume()    Received 0    Received 1    &gt;&gt;&gt; func = lambda item, format_str='Received {}': print(format_str.format(item))    &gt;&gt;&gt; Iter.range(2).side_effect(func, 'Got {}').consume()    Got 0    Got 1.. _Iter.iterate:``Iter.iterate(self)``======================.. _Iter.difference:``Iter.difference(self, func=operator.sub, *, initial=None)``=============================================================Reference: `more_itertools.difference &lt;https://more-itertools.readthedocs.io/en/stable/api.html?highlight=difference#more_itertools.difference&gt;`_.. code-block:: python    &gt;&gt;&gt; iterable = [0, 1, 3, 6, 10]    &gt;&gt;&gt; Iter(iterable).difference().collect()    [0, 1, 2, 3, 4].. code-block:: python    &gt;&gt;&gt; iterable = [1, 2, 6, 24, 120]  # Factorial sequence    &gt;&gt;&gt; func = lambda x, y: x // y    &gt;&gt;&gt; Iter(iterable).difference(func).collect()    [1, 2, 3, 4, 5].. _Iter.make_decorator:``Iter.make_decorator(self)``=============================.. _Iter.SequenceView:``Iter.SequenceView(self)``===========================.. _Iter.time_limited:``Iter.time_limited(self, limit_seconds) -&gt; &quot;Iter&quot;``====================================================Reference: `more_itertools.time_limited &lt;https://more-itertools.readthedocs.io/en/stable/api.html?highlight=time_limited#more_itertools.time_limited&gt;`_.. code-block:: python    &gt;&gt;&gt; from time import sleep    &gt;&gt;&gt; def generator():    ...     yield 1    ...     yield 2    ...     sleep(0.2)    ...     yield 3    &gt;&gt;&gt; Iter(generator()).time_limited(0.1).collect()    [1, 2].. _Iter.consume:|sink| ``Iter.consume(self, n: Optional[int] = None) -&gt; &quot;Optional[Iter[T]]&quot;``=============================================================================If n is not provided, the entire iterator is consumed and``None`` is returned. Otherwise, an iterator will *always* bereturned, even if n is greater than the number of items left inthe iterator.In this example, the source has more elements than what we consume,so there will still be data available on the chain:.. code-block:: python    &gt;&gt;&gt; range(10).consume(5).collect()    [5, 6, 7, 8, 9]We can bump up the count of how many items can be consumed. Note thateven though ``n`` is greater than the number of items in the source,it is still required to call Iter.collect_ to consume the remainingitems... code-block:: python    &gt;&gt;&gt; range(10).consume(50).collect()    []Finally, if ``n`` is not provided, the entire stream is consumed.In this scenario, Iter.collect_ would fail since nothing is beingreturned from the consume call... code-block:: python    &gt;&gt;&gt; assert range(10).consume() is None.. _Iter.tabulate:``Iter.tabulate(self)``=======================.. _Iter.repeatfunc:|source| ``@classmethod Iter.repeatfunc(cls, func, *args, times=None)``=======================================================================Docstring TBD.. code-block:: python    &gt;&gt;&gt; Iter.repeatfunc(operator.add, 3, 5, times=4).collect()    [8, 8, 8, 8].. _Iter.wrap:``Iter.wrap(self, ends: &quot;Sequence[T, T]&quot; = &quot;()&quot;)``==================================================Other examples for ends: '&quot;' * 2, or '`' * 2, or '[]' etc... _Iter.print:``Iter.print(self, template=&quot;{i}: {v}&quot;) -&gt; &quot;Iter[T]&quot;``======================================================Printing during the execution of an iterator. Mostly usefulfor debugging. Returns another iterator instance through whichthe original data is passed unchanged. This means you can includea `print()` step as necessary to observe data during iteration... code-block:: python    &gt;&gt;&gt; Iter('abc').print().collect()    0: a    1: b    2: c    ['a', 'b', 'c']    &gt;&gt;&gt; (    ...    Iter(range(5))    ...        .print('before filter {i}: {v}')    ...        .filter(lambda x: x &gt; 2)    ...        .print('after filter {i}: {v}')    ...        .collect()    ... )    before filter 0: 0    before filter 1: 1    before filter 2: 2    before filter 3: 3    after filter 0: 3    before filter 4: 4    after filter 1: 4    [3, 4].. _Iter.from_queue:|source| ``@classmethod Iter.from_queue(cls, q: queue.Queue, timeout=None, sentinel=None)``===========================================================================================Wrap a queue with an iterator interface. This allows it to participatein chaining operations. The iterator will block while waiting fornew values to appear on the queue. This is useful: it allows youto easily and safely pass data between threads or processes, andfeed the incoming data into a pipeline.The sentinel value, default ``None``, will terminate the iterator... code-block:: python    &gt;&gt;&gt; q = queue.Queue()    &gt;&gt;&gt; # This line puts stuff onto a queue    &gt;&gt;&gt; range(10).chain([None]).map(q.put).consume()    &gt;&gt;&gt; # This is where we consume data from the queue:    &gt;&gt;&gt; Iter.from_queue(q).filter(lambda x: 2 &lt; x &lt; 9).collect()    [3, 4, 5, 6, 7, 8]If ``None`` had not been chained onto the data, the iterator wouldhave waited in Iter.collect_ forever... _Iter.into_queue:``Iter.into_queue(self, q: queue.Queue) -&gt; &quot;Iter[T]&quot;``======================================================This is a sink, like Iter.collect_, that consumes data froman iterator chain and puts the data into the given queue... code-block:: python    &gt;&gt;&gt; q = queue.Queue()    &gt;&gt;&gt; # This demonstrates the queue sink    &gt;&gt;&gt; range(5).into_queue(q).consume()    &gt;&gt;&gt; # Code below is only for verification    &gt;&gt;&gt; out = []    &gt;&gt;&gt; finished = False    &gt;&gt;&gt; while not finished:    ...     try:    ...         out.append(q.get_nowait())    ...     except queue.Empty:    ...         finished = True    &gt;&gt;&gt; out    [0, 1, 2, 3, 4].. _Iter.send:|sink| ``Iter.send(self, collector: Generator, close_collector_when_done=False) -&gt; &quot;None&quot;``===========================================================================================See also: `more_itertools.consumer &lt;https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.consumer&gt;`_Send data into a generator. You do not have to first call ``next()``on the generator. Iter.send_ will do this for you.|warning| Look carefully at the examples below; you'll see that the``yield`` keyword is wrapped in a second set of parens, e.g.``output.append((yield))``. This is required!Simple case:.. code-block:: python    &gt;&gt;&gt; output = []    &gt;&gt;&gt; def collector():    ...     while True:    ...         output.append((yield))    &gt;&gt;&gt; Iter.range(3).send(collector())    &gt;&gt;&gt; output    [0, 1, 2]Note that the generator is **not** closed by default after the iterable isexhausted. But this can be changed. If you choose to close thegenerator, use the parameter:.. code-block:: python    &gt;&gt;&gt; output = []    &gt;&gt;&gt; def collector():    ...     while True:    ...         output.append((yield))    &gt;&gt;&gt; g = collector()    &gt;&gt;&gt; Iter.range(3).send(g, close_collector_when_done=True)    &gt;&gt;&gt; Iter.range(3).send(g)    Traceback (most recent call last):        ...    StopIterationThe default behaviour is that the generator is left open which means youcan keep using it for other iterators:.. code-block:: python    &gt;&gt;&gt; output = []    &gt;&gt;&gt; def collector():    ...     while True:    ...         output.append((yield))    &gt;&gt;&gt; g = collector()    &gt;&gt;&gt; Iter.range(3).send(g)    &gt;&gt;&gt; Iter.range(10, 13).send(g)    &gt;&gt;&gt; Iter.range(100, 103).send(g)    &gt;&gt;&gt; output    [0, 1, 2, 10, 11, 12, 100, 101, 102]If the generator is closed before the iteration is complete,you'll get a ``StopIteration`` exception:.. code-block:: python    &gt;&gt;&gt; output = []    &gt;&gt;&gt; def collector():    ...   for i in range(3):    ...       output.append((yield))    &gt;&gt;&gt; Iter.range(5).send(collector())    Traceback (most recent call last):        ...    StopIterationNote that Iter.send_ is a sink, so no further chaining is allowed... _Iter.send_also:``Iter.send_also(self, collector: Generator) -&gt; &quot;Iter&quot;``========================================================Reference: `more_itertools.consumer &lt;https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.consumer&gt;`_Some ideas around a reverse iterator as a sink. Usually you havefirst to &quot;send&quot; a ``None`` into a generator if you want to sendmore values into it (or call ``next()`` on it), but we handle that automatically.Simple case:.. code-block:: python    &gt;&gt;&gt; output = []    &gt;&gt;&gt; def collector():    ...     while True:    ...         output.append((yield))    &gt;&gt;&gt; Iter.range(3).send_also(collector()).collect()    [0, 1, 2]    &gt;&gt;&gt; output    [0, 1, 2]However, if the caller already started the generator, that works too:.. code-block:: python    &gt;&gt;&gt; output = []    &gt;&gt;&gt; def collector():    ...     while True:    ...         output.append((yield))    &gt;&gt;&gt; g = collector()    &gt;&gt;&gt; next(g)  # This &quot;starts&quot; the generator    &gt;&gt;&gt; Iter.range(3).send_also(g).collect()    [0, 1, 2]    &gt;&gt;&gt; output    [0, 1, 2]If the generator is closed before the iteration is complete,you'll get an exception (Python 3.7+):.. code-block:: python    &gt;&gt;&gt; output = []    &gt;&gt;&gt; def collector():    ...   for i in builtins.range(3):    ...       output.append((yield))    &gt;&gt;&gt; Iter.range(50).send_also(collector()).collect()                      Traceback (most recent call last):        ...    RuntimeErrorNote that the above doesn't happen in Python &lt; 3.7 (which includespypy 7.3.1 that matches Python 3.6.9 compatibility). Instead, youcollect out the items up to until the point that the collectorreturns; in this case, you'd get [0, 1, 2]. This change was madeas part of `PEP 479 &lt;https://www.python.org/dev/peps/pep-0479/&gt;`_.Regardless, for any Python it's recommended that your generatorlive at least as long as the iterator feeding it... _Iter.sorted:|sink| |warning| ``Iter.sorted(self, key=None, reverse=False) -&gt; &quot;Iter[T]&quot;``============================================================================Simple wrapper for the ``sorted`` builtin.Calling this will read the entire stream before producingresults... code-block:: python    &gt;&gt;&gt; Iter('bac').sorted().collect()    ['a', 'b', 'c']    &gt;&gt;&gt; Iter('bac').sorted(reverse=True).collect()    ['c', 'b', 'a']    &gt;&gt;&gt; Iter('bac').zip([2, 1, 0]).sorted(key=lambda tup: tup[1]).collect()    [('c', 0), ('a', 1), ('b', 2)].. _Iter.reversed:|sink| |warning| ``Iter.reversed(self) -&gt; &quot;Iter[T]&quot;``=====================================================Simple wrapper for the ``reversed`` builtin.Calling this will read the entire stream before producingresults... code-block:: python    &gt;&gt;&gt; Iter(range(4)).reversed().collect()    [3, 2, 1, 0]Experiments and Provisional Ideas#################################.. _IterDict:|flux| ``class IterDict(UserDict)``***********************************The idea here was to make a custom dict where several ofthe standard dict methods return ``Iter`` instances, which can thenbe chained. I'm not sure if this will be kept yet... _IterDict.keys:``IterDict.keys(self) -&gt; &quot;Iter&quot;``=================================.. _IterDict.values:``IterDict.values(self) -&gt; &quot;Iter&quot;``===================================.. _IterDict.items:``IterDict.items(self) -&gt; &quot;Iter&quot;``==================================.. _IterDict.update:``IterDict.update(self, *args, **kwargs) -&gt; &quot;IterDict&quot;``========================================================.. _insert_separator:``insert_separator(iterable: Iterable[Any], glue: Any) -&gt; &quot;Iterable[Any]&quot;``***************************************************************************Similar functionality can be obtained with, e.g.,interleave, as in.. code-block:: python    &gt;&gt;&gt; result = Iter('caleb').interleave(Iter.repeat('x')).collect()    &gt;&gt;&gt; result == list('cxaxlxexbx')    TrueBut you'll see a trailing &quot;x&quot; there, which join avoids. joinmakes sure to only add the glue separator if another elementhas arrived.It can handle strings without any special considerations, but it doesn'tdo any special handling for bytes and bytearrays. For that, ratherlook at `concat()`.Related projects################It turns out the idea of chaining iterators is not new. There are manylibraries that offer similar features:* My fork of a now-missing library: `chained-iterable &lt;https://github.com/cjrh/chained-iterable&gt;`_.* `https://github.com/olirice/flupy &lt;https://github.com/olirice/flupy&gt;`_* `https://github.com/ddstte/chiter &lt;https://github.com/ddstte/chiter&gt;`_* `https://github.com/neverendingqs/pyiterable &lt;https://github.com/neverendingqs/pyiterable&gt;`_* `https://github.com/alliefitter/iterable_collections &lt;https://github.com/alliefitter/iterable_collections&gt;`_* `https://github.com/halprin/iterator-chain &lt;https://github.com/halprin/iterator-chain&gt;`_* `https://github.com/jagill/python-chainz &lt;https://github.com/jagill/python-chainz&gt;`_* `https://github.com/ZianVW/IterPipe &lt;https://github.com/ZianVW/IterPipe&gt;`_* `https://github.com/Evelyn-H/iterchain &lt;https://github.com/Evelyn-H/iterchain&gt;`_* `https://github.com/EntilZha/PyFunctional &lt;https://github.com/EntilZha/PyFunctional&gt;`_* `https://github.com/dwt/fluent &lt;https://github.com/dwt/fluent&gt;`_Somewhat related:* `https://github.com/jreese/aioitertools &lt;https://github.com/jreese/aioitertools&gt;`_Dev Instructions################Setup*****.. code-block:: shell    $ python -m venv venv    $ source venv/bin/activate    (venv) $ pip install -e .[dev,test]Testing*******.. code-block:: shell    (venv) $ pytest --covDocumentation*************To regenerate the documentation, file ``README.rst``:.. code-block:: shell    (venv) $ python regenerate_readme.py -m excitertools.py &gt; README.rstReleasing*********To do a release, we're using `bumpymcbumpface &lt;https://pypi.org/project/bumpymcbumpface/&gt;`_.Make sure that is set up correctly according to its own documentation. I like to use `pipx &lt;https://github.com/pipxproject/pipx&gt;`_ to install and manage these kinds of tools... code-block:: shell    $ bumpymcbumpface --push-git --push-pypi||-----||    Work is a necessary evil to be avoided.     *Mark Twain*</longdescription>
</pkgmetadata>