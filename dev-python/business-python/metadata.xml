<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Business (Python)[![circleci-badge](https://circleci.com/gh/gocardless/business-python.svg?style=shield)](https://app.circleci.com/pipelines/github/gocardless/business-python) [![pypi-badge](https://badge.fury.io/py/business-python.svg)](https://badge.fury.io/py/business-python)Date calculations based on business calendars. (Python 3.8+)Python implementation of https://github.com/gocardless/business## DocumentationTo get business, simply:```bash$ pip install business-python```## Version 2.1.0 breaking changesIn version 2.1.0 we have dropped support for End-of-Life Python version 3.6 and 3.7. Last release supporting these versions is [v2.0.3](https://github.com/gocardless/business-python/tree/v2.0.3).## Version 2.0.0 breaking changesIn version 2.0.0 we have removed the bundled calendars. If you still need these they are available on [v1.0.1](https://github.com/gocardless/business-python/tree/74fe7e4068e0f16b68e7478f8b5ca1cc52f9a7d0/business/data).### Migration- Download/create calendars to a directory within your project eg: `lib/calendars`- Change your code to include the `load_path` for your calendars- Continue using `.load(&quot;my_calendar&quot;)` as usual```python# lib/calendars contains yml filesCalendar.load_paths = ['lib/calendars']calendar = Calendar.load(&quot;my_calendar&quot;)```### Getting startedGet started with business by creating an instance of the calendar class, passing in a hash that specifies which days of the week are considered working days, and which days are holidays.```pythonfrom business.calendar import Calendarcalendar = Calendar(  working_days=[&quot;monday&quot;, &quot;tuesday&quot;, &quot;wednesday&quot;, &quot;thursday&quot;, &quot;friday&quot;],  # array items are either parseable date strings, or real datetime.date objects  holidays=[&quot;January 1st, 2020&quot;, &quot;April 10th, 2020&quot;],  extra_working_dates=[],)````extra_working_dates` key makes the calendar to consider a weekend day as a working day.If `working_days` is missing, then common default is used (mon-fri).If `holidays` is missing, &quot;no holidays&quot; assumed.If `extra_working_dates` is missing, then no changes in `working_days` will happen.Elements of `holidays` and `extra_working_dates` may be either strings that `Calendar.parse_date()` can understand, or YYYY-MM-DD (which is considered as a Date by Python YAML itself).#### Calendar YAML file example```yaml# lib/calendars/my_calendar.ymlworking_days:  - Monday  - Sundayholidays:  - 2017-01-08 # Same as January 8th, 2017extra_working_dates:  - 2020-12-26 # Will consider 26 Dec 2020 (A Saturday), a working day```The `load_cache` method allows a thread safe way to avoid reloading the same calendar multiple times, and provides a performant way to dynamically load calendars for different requests.#### Using business-pythonDefine your calendars in a folder eg: `lib/calendars` and set this directory on `Calendar.load_paths=````pythonCalendar.load_paths = ['lib/calendars']calendar = Calendar.load_cache(&quot;my_calendar&quot;)```### Input data typesThe `parse_date` method is used to process the input date(s) in each method and return a `datetime.date` object.```pythonCalendar.parse_date(&quot;2019-01-01&quot;)# =&gt; datetime.date(2019, 1, 1)```Supported data types are:- `datetime.date`- `datetime.datetime`- `pandas.Timestamp` (treated as `datetime.datetime`)- date string parseable by [`dateutil.parser.parse`](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse)`numpy.datetime64` is not supported, but can be converted to `datetime.date`:```pythonnumpy.datetime64('2014-06-01T23:00:05.453000000').astype('M8[D]').astype('O')# =&gt;  datetime.date(2014, 6, 1)```### Checking for business daysTo check whether a given date is a business day (falls on one of the specified working days or extra working dates, and is not a holiday), use the `is_business_day` method on `Calendar`.```pythoncalendar.is_business_day(&quot;Monday, 8 June 2020&quot;)# =&gt; truecalendar.is_business_day(&quot;Sunday, 7 June 2020&quot;)# =&gt; false```### Business day arithmetic&gt; For our purposes, date-based calculations are sufficient. Supporting time-based calculations as well makes the code significantly more complex. We chose to avoid this extra complexity by sticking solely to date-based mathematics.The `add_business_days` method is used to perform business day arithmetic on dates.```pythoninput_date = Calendar.parse_date(&quot;Thursday, 12 June 2014&quot;)calendar.add_business_days(input_date, 4).strftime(&quot;%A, %d %B %Y&quot;)# =&gt; &quot;Wednesday, 18 June 2014&quot;calendar.add_business_days(input_date, -4).strftime(&quot;%A, %d %B %Y&quot;)# =&gt; &quot;Friday, 06 June 2014&quot;```The `roll_forward` and `roll_backward` methods snap a date to a nearby business day. If provided with a business day, they will return that date. Otherwise, they will advance (forward for `roll_forward` and backward for `roll_backward`) until a business day is found.```pythoninput_date = Calendar.parse_date(&quot;Saturday, 14 June 2014&quot;)calendar.roll_forward(input_date).strftime(&quot;%A, %d %B %Y&quot;)# =&gt; &quot;Monday, 16 June 2014&quot;calendar.roll_backward(input_date).strftime(&quot;%A, %d %B %Y&quot;)# =&gt; &quot;Friday, 13 June 2014&quot;```In contrast, the `next_business_day` and `previous_business_day` methods will always move to a next or previous date until a business day is found, regardless if the input provided is a business day.```pythoninput_date = Calendar.parse_date(&quot;Monday, 9 June 2014&quot;)calendar.roll_forward(input_date).strftime(&quot;%A, %d %B %Y&quot;)# =&gt; &quot;Monday, 09 June 2014&quot;calendar.next_business_day(input_date).strftime(&quot;%A, %d %B %Y&quot;)# =&gt; &quot;Tuesday, 10 June 2014&quot;calendar.previous_business_day(input_date).strftime(&quot;%A, %d %B %Y&quot;)# =&gt; &quot;Friday, 06 June 2014&quot;```To count the number of business days between two dates, pass the dates to `business_days_between`. This method counts from start of the first date to start of the second date. So, assuming no holidays, there would be two business days between a Monday and a Wednesday.```pythonfrom datetime import timedeltainput_date = Calendar.parse_date(&quot;Saturday, 14 June 2014&quot;)calendar.business_days_between(input_date, input_date + timedelta(days=7))# =&gt; 5```The `get_business_day_of_month` method return the running total of business days for a given date in that month. This method counts the number of business days from the start of the first day of the month to the given input date.```pythoninput_date = Calendar.parse_date(&quot;Thursday, 12 June 2014&quot;)calendar.get_business_day_of_month(input_date)# =&gt; 9```## License &amp; Contributing- This is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).- Bug reports and pull requests are welcome on GitHub at https://github.com/gocardless/business-python.GoCardless â™¥ open source. If you do too, come [join us](https://gocardless.com/about/jobs).</longdescription>
</pkgmetadata>