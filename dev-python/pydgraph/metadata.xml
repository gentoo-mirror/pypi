<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pydgraphThis is the official Dgraph database client implementation for Python (Python &gt;= v3.7), using [gRPC][grpc].[grpc]: https://grpc.io/This client follows the [Dgraph Go client][goclient] closely.[goclient]: https://github.com/dgraph-io/dgoBefore using this client, we highly recommend that you read thethe product documentation at [dgraph.io/docs].[dgraph.io/docs]:https://dgraph.io/docs## Table of contents- [pydgraph](#pydgraph)  - [Table of contents](#table-of-contents)  - [Install](#install)  - [Supported Versions](#supported-versions)  - [Quickstart](#quickstart)  - [Using a client](#using-a-client)    - [Creating a Client](#creating-a-client)    - [Login into a Namespace](#login-into-a-namespace)    - [Connecting To Dgraph Cloud](#connecting-to-dgraph-cloud)    - [Altering the Database](#altering-the-database)    - [Creating a Transaction](#creating-a-transaction)    - [Running a Mutation](#running-a-mutation)    - [Running a Query](#running-a-query)    - [Query with RDF response](#query-with-rdf-response)    - [Running an Upsert: Query + Mutation](#running-an-upsert-query--mutation)    - [Running a Conditional Upsert](#running-a-conditional-upsert)    - [Committing a Transaction](#committing-a-transaction)    - [Cleaning Up Resources](#cleaning-up-resources)    - [Setting Metadata Headers](#setting-metadata-headers)    - [Setting a timeout](#setting-a-timeout)    - [Async methods](#async-methods)  - [Examples](#examples)  - [Development](#development)    - [Setting up environment](#setting-up-environment)    - [Build from source](#build-from-source)    - [Running tests](#running-tests)## InstallInstall using pip:```shpip install pydgraph```## Supported VersionsDepending on the version of Dgraph that you are connecting to, you will have touse a different version of this client.| Dgraph version |   pydgraph version   ||:--------------:|:--------------------:||    20.3.X      |      *20.3.0*        ||    20.7.X      |      *20.7.0*        ||    20.11.X     |      *20.7.0*        ||    21.03.X     |      *21.3.0*        ||    22.0.X      |      *21.3.0*        ||    23.0.X      |      *23.0.0*        |## QuickstartBuild and run the [simple project][simple] in the `examples` folder, whichcontains an end-to-end example of using the Dgraph python client. For additional details, follow theinstructions in the project's [README](./examples/simple/README.md).[simple]: ./examples/simple## Using a client### Creating a ClientYou can initialize a `DgraphClient` object by passing it a list of`DgraphClientStub` clients as variadic arguments. Connecting to multiple Dgraphservers in the same cluster allows for better distribution of workload.The following code snippet shows just one connection.```python3import pydgraphclient_stub = pydgraph.DgraphClientStub('localhost:9080')client = pydgraph.DgraphClient(client_stub)```### Login into a NamespaceIf your server has Access Control Lists enabled (Dgraph v1.1 or above), the client must belogged in for accessing data. Use `login` endpoint:Calling login will obtain and remember the access and refresh JWT tokens. All subsequent operationsvia the logged in client will send along the stored access token.```python3client.login(&quot;groot&quot;, &quot;password&quot;)```If your server additionally has namespaces (Dgraph v21.03 or above), use the`login_into_namespace` API.```python3client.login_into_namespace(&quot;groot&quot;, &quot;password&quot;, &quot;123&quot;)```### Connecting To Dgraph CloudIf you want to connect to Dgraph running on [Dgraph Cloud](https://cloud.dgraph.io) instance, thenget the gRPC endpoint of your cluster that you can find in the[Settings section](https://cloud.dgraph.io/_/settings) of Dgraph Cloud console and obtain a Clientor Admin API key (created in the [API key tab](https://cloud.dgraph.io/_/settings?tab=api-keys)of the Setting section). Create the `client_stub` using the gRPC endpoint and the API key:```python3client_stub = pydgraph.DgraphClientStub.from_cloud(    &quot;https://morning-glade.grpc.us-east-1.aws.cloud.dgraph.io:443&quot;, &quot;&lt;api-key&gt;&quot;)client = pydgraph.DgraphClient(client_stub)```The `DgraphClientStub.from_slash_endpoint()` method has been removed v23.0.Please use `DgraphClientStub.from_cloud()` instead.### Altering the DatabaseTo set the schema, create an `Operation` object, set the schema and pass it to`DgraphClient#alter(Operation)` method.```python3schema = 'name: string @index(exact) .'op = pydgraph.Operation(schema=schema)client.alter(op)````Operation` contains other fields as well, including `DropAttr` and `DropAll`. `DropAll` isuseful if you wish to discard all the data, and start from a clean slate, without bringingthe instance down. `DropAttr` is used to drop all the data related to a predicate.```python3# Drop all data including schema from the Dgraph instance. This is a useful# for small examples such as this since it puts Dgraph into a clean state.op = pydgraph.Operation(drop_all=True)client.alter(op)```Indexes can be computed in the background.You can set the `run_in_background` field of `pydgraph.Operation` to `True`before passing it to the `Alter` function. You can find more details[here](https://docs.dgraph.io/master/query-language/#indexes-in-background).```python3schema = 'name: string @index(exact) .'op = pydgraph.Operation(schema=schema, run_in_background=True)client.alter(op)```### Creating a TransactionTo create a transaction, call the `DgraphClient#txn()` method, which returns anew `Txn` object. This operation incurs no network overhead.It is good practice to call `Txn#discard()` in a `finally` block after runningthe transaction. Calling `Txn#discard()` after `Txn#commit()` is a no-opand you can call `Txn#discard()` multiple times with no additional side-effects.```python3txn = client.txn()try:  # Do something here  # ...finally:  txn.discard()  # ...```To create a read-only transaction, call `DgraphClient#txn(read_only=True)`.Read-only transactions are ideal for transactions which only involve queries.Mutations and commits are not allowed.```python3txn = client.txn(read_only=True)try:  # Do some queries here  # ...finally:  txn.discard()  # ...```To create a read-only transaction that executes best-effort queries, call`DgraphClient#txn(read_only=True, best_effort=True)`. Best-effort queries arefaster than normal queries because they bypass the normal consensus protocol.For this same reason, best-effort queries cannot guarantee to return the latestdata. Best-effort queries are only supported by read-only transactions.### Running a Mutation`Txn#mutate(mu=Mutation)` runs a mutation. It takes in a `Mutation` object,which provides two main ways to set data: JSON and RDF N-Quad. You can choosewhichever way is convenient.`Txn#mutate()` provides convenience keyword arguments `set_obj` and `del_obj`for setting JSON values and `set_nquads` and `del_nquads` for setting N-Quadvalues. See examples below for usage.We define a person object to represent a person and use it in a transaction.```python3# Create data.p = { 'name': 'Alice' }# Run mutation.txn.mutate(set_obj=p)# If you want to use a mutation object, use this instead:# mu = pydgraph.Mutation(set_json=json.dumps(p).encode('utf8'))# txn.mutate(mu)# If you want to use N-Quads, use this instead:# txn.mutate(set_nquads='_:alice &lt;name&gt; &quot;Alice&quot; .')``````python3# Delete dataquery = &quot;&quot;&quot;query all($a: string) {   all(func: eq(name, $a))    {      uid    }  }&quot;&quot;&quot;variables = {'$a': 'Bob'}res = txn.query(query, variables=variables)ppl = json.loads(res.json)# For a mutation to delete a node, use this:txn.mutate(del_obj=person)```For a complete example with multiple fields and relationships, look at the[simple project][simple] in the `examples` folder.Sometimes, you only want to commit a mutation, without querying anything further.In such cases, you can set the keyword argument `commit_now=True` to indicatethat the mutation must be immediately committed.A mutation can be executed using `txn.do_request` as well.```python3mutation = txn.create_mutation(set_nquads='_:alice &lt;name&gt; &quot;Alice&quot; .')request = txn.create_request(mutations=[mutation], commit_now=True)txn.do_request(request)```### Running a QueryYou can run a query by calling `Txn#query(string)`. You will need to pass in a[DQL](https://dgraph.io/docs/query-language/) query string. If you want to passan additional dictionary of any variables that you might want to set in the query,call `Txn#query(string, variables=d)` with the variables dictionary `d`.The query response contains the `json` field, which returns the JSON response.Letâ€™s run a query with a variable `$a`, deserialize the result from JSON andprint it out:```python3# Run query.query = &quot;&quot;&quot;query all($a: string) {  all(func: eq(name, $a))  {    name  }}&quot;&quot;&quot;variables = {'$a': 'Alice'}res = txn.query(query, variables=variables)# If not doing a mutation in the same transaction, simply use:# res = client.txn(read_only=True).query(query, variables=variables)ppl = json.loads(res.json)# Print results.print('Number of people named &quot;Alice&quot;: {}'.format(len(ppl['all'])))for person in ppl['all']:  print(person)```This should print:```consoleNumber of people named &quot;Alice&quot;: 1Alice```You can also use `txn.do_request` function to run the query.```python3request = txn.create_request(query=query)txn.do_request(request)```### Query with RDF responseYou can get query result as a RDF response by calling `Txn#query(string)` with `resp_format` setto `RDF`. The response would contain a `rdf` field, which has the RDF encoded result.**Note:** If you are querying only for `uid` values, use a JSON format response.```python3res = txn.query(query, variables=variables, resp_format=&quot;RDF&quot;)print(res.rdf)```### Running an Upsert: Query + MutationThe `txn.do_request` function allows you to use upsert blocks. An upsert blockcontains one query block and one or more mutation blocks, so it lets you performqueries and mutations in a single request. Variables defined in the query blockcan be used in the mutation blocks using the `uid` and `val` functionsimplemented by DQL.To learn more about upsert blocks, see the[Upsert Block documentation](https://dgraph.io/docs/mutations/upsert-block/).```python3query = &quot;&quot;&quot;{  u as var(func: eq(name, &quot;Alice&quot;))}&quot;&quot;&quot;nquad = &quot;&quot;&quot;  uid(u) &lt;name&gt; &quot;Alice&quot; .  uid(u) &lt;age&gt; &quot;25&quot; .&quot;&quot;&quot;mutation = txn.create_mutation(set_nquads=nquad)request = txn.create_request(query=query, mutations=[mutation], commit_now=True)txn.do_request(request)```### Running a Conditional UpsertThe upsert block also allows specifying a conditional mutation block using an `@if` directive.The mutation is executed only when the specified condition is true. If the condition is false,the mutation is silently ignored.See more about Conditional Upserts [here](https://docs.dgraph.io/mutations/#conditional-upsert).```python3query = &quot;&quot;&quot;  {    user as var(func: eq(email, &quot;wrong_email@dgraph.io&quot;))  }&quot;&quot;&quot;cond = &quot;@if(eq(len(user), 1))&quot;nquads = &quot;&quot;&quot;  uid(user) &lt;email&gt; &quot;correct_email@dgraph.io&quot; .&quot;&quot;&quot;mutation = txn.create_mutation(cond=cond, set_nquads=nquads)request = txn.create_request(mutations=[mutation], query=query, commit_now=True)txn.do_request(request)```### Committing a TransactionA transaction can be committed using the `Txn#commit()` method. If your transactionconsist solely of `Txn#query` or `Txn#queryWithVars` calls, and no calls to`Txn#mutate`, then calling `Txn#commit()` is not necessary.An error is raised if another transaction(s) modify the same data concurrently that wasmodified in the current transaction. It is up to the user to retry transactionswhen they fail.```python3txn = client.txn()try:  # ...  # Perform any number of queries and mutations  # ...  # and finally...  txn.commit()except pydgraph.AbortedError:  # Retry or handle exception.finally:  # Clean up. Calling this after txn.commit() is a no-op  # and hence safe.  txn.discard()```### Cleaning Up ResourcesTo clean up resources, you have to call `DgraphClientStub#close()` individually forall the instances of `DgraphClientStub`.```python3SERVER_ADDR1 = &quot;localhost:9080&quot;SERVER_ADDR2 = &quot;localhost:9080&quot;# Create instances of DgraphClientStub.stub1 = pydgraph.DgraphClientStub(SERVER_ADDR1)stub2 = pydgraph.DgraphClientStub(SERVER_ADDR2)# Create an instance of DgraphClient.client = pydgraph.DgraphClient(stub1, stub2)# Use client...# Clean up resources by closing all client stubs.stub1.close()stub2.close()```### Setting Metadata HeadersMetadata headers such as authentication tokens can be set through the metadata of gRPC methods.Below is an example of how to set a header named &quot;auth-token&quot;.```python3# The following piece of code shows how one can set metadata with# auth-token, to allow Alter operation, if the server requires it.# metadata is a list of arbitrary key-value pairs.metadata = [(&quot;auth-token&quot;, &quot;the-auth-token-value&quot;)]dg.alter(op, metadata=metadata)```### Setting a timeoutA timeout value representing the number of seconds can be passed to the `login`,`alter`, `query`, and `mutate` methods using the `timeout` keyword argument.For example, the following alters the schema with a timeout of ten seconds:`dg.alter(op, timeout=10)`### Async methodsThe `alter` method in the client has an asynchronous version called`async_alter`. The async methods return a future. You can directly call the`result` method on the future. However. The DgraphClient class provides a staticmethod `handle_alter_future` to handle any possible exception.```python3alter_future = self.client.async_alter(pydgraph.Operation(schema=&quot;name: string @index(term) .&quot;))response = pydgraph.DgraphClient.handle_alter_future(alter_future)```The `query` and `mutate` methods int the `Txn` class also have async versionscalled `async_query` and `async_mutation` respectively. These functions workjust like `async_alter`.You can use the `handle_query_future` and `handle_mutate_future` static methodsin the `Txn` class to retrieve the result. A short example is given below:```python3txn = client.txn()query = &quot;query body here&quot;future = txn.async_query()response = pydgraph.Txn.handle_query_future(future)```Keep in mind that due to the nature of async calls, the async functions cannotretry the request if the login is invalid. You will have to check for this errorand retry the login (with the function `retry_login` in both the `Txn` and`Client` classes). A short example is given below:```python3client = DgraphClient(client_stubs) # client_stubs is a list of gRPC stubs.alter_future = client.async_alter()try:    response = alter_future.result()except Exception as e:# You can use this function in the util package to check for JWT    # expired errors.    if pydgraph.util.is_jwt_expired(e):        # retry your request here.```## Examples[tls]: ./examples/tls[parse_datetime]: ./examples/parse_datetime- [simple][]: Quickstart example of using pydgraph.- [tls][]: Quickstart example that uses TLS.- [parse_datetime]: Demonstration of converting Dgraph's DateTime strings to native python datetime.## Development### Setting up environmentThere are many ways to set up your local Python environment. We suggest some sane defaults here.- Use [pyenv](https://github.com/pyenv/pyenv) to manage your Python installations.- Most recent versions of Python should work, but the version of Python officially supported is located in`.python-version`- Create a Python virtual environment using `python -m venv .venv`- Activate virtual environment via `source .venv/bin/activate`### Build from sourceTo build and install pydgraph locally, run```shpip install -e &quot;.[dev]&quot;```If you have made changes to the `pydgraph/proto/api.proto` file, you need needto regenerate the source files generated by Protocol Buffer tools. To do that,install the [grpcio-tools][grpcio-tools] library and then run the followingcommand:[grpcio-tools]: https://pypi.python.org/pypi/grpcio-tools```shpython scripts/protogen.py```### Running testsTo run the tests in your local machine, run:```bashbash scripts/local-test.sh```This script assumes dgraph is located on your path. Dgraph release binaries canbe found [here](https://github.com/dgraph-io/dgraph/releases).The test script also requires that `docker` and `docker compose` are installed onyour machine.The script will take care of bringing up a Dgraph cluster and bringing it downafter the tests are executed. The script connects to randomly selected ports forHTTP and gRPC requests to prevent interference with clusters running on thedefault port. Docker and docker-compose need to be installed before running thescript. Refer to the official [Docker documentation](https://docs.docker.com/)for instructions on how to install those packages.</longdescription>
</pkgmetadata>