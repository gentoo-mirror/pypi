<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># JSONRPClib (patched for Pelix and Python 3)[![Latest Version](https://img.shields.io/pypi/v/jsonrpclib-pelix.svg)](https://pypi.python.org/pypi/jsonrpclib-pelix/)[![License](https://img.shields.io/pypi/l/jsonrpclib-pelix.svg)](https://pypi.python.org/pypi/jsonrpclib-pelix/)[![Travis-CI status](https://travis-ci.org/tcalmant/jsonrpclib.svg?branch=master)](https://travis-ci.org/tcalmant/jsonrpclib)[![Coveralls status](https://coveralls.io/repos/tcalmant/jsonrpclib/badge.svg?branch=master)](https://coveralls.io/r/tcalmant/jsonrpclib?branch=master)This library is an implementation of the JSON-RPC specification.It supports both the original 1.0 specification, as well as the new(proposed) 2.0 specification, which includes batch submission, keywordarguments, etc.This library is licensed under the terms of the[Apache Software License 2.0](&lt;http://www.apache.org/licenses/LICENSE-2.0.html&gt;).## About this versionThis is a patched version of the original `jsonrpclib` project by Josh Marshall,available at[joshmarshall/jsonrpclib](&lt;https://github.com/joshmarshall/jsonrpclib&gt;).The suffix *-pelix* only indicates that this version works with PelixRemote Services, but it is **not** a Pelix specific implementation.* This version adds support for Python 3, staying compatible with Python 2.7.  The support for Python 2.6 has been dropped, as it was becoming to hard to  maintain.* It is now possible to use the `dispatch_method` argument while extending the  `SimpleJSONRPCDispatcher`, to use a custom dispatcher.  This allows to use this package by Pelix Remote Services.* It can use thread pools to control the number of threads spawned to handle  notification requests and clients connections.* The modifications added in other forks of this project have been added:    * From [drdaeman/jsonrpclib](&lt;https://github.com/drdaeman/jsonrpclib&gt;):      * Improved JSON-RPC 1.0 support      * Less strict error response handling    * From [tuomassalo/jsonrpclib](&lt;https://github.com/tuomassalo/jsonrpclib&gt;):      * In case of a non-predefined error, raise an AppError and give access        to *error.data*    * From [dejw/jsonrpclib](&lt;https://github.com/dejw/jsonrpclib&gt;):      * Custom headers can be sent with request and associated tests* Since version 0.4, this package added back the support of Unix sockets.* This package cannot be installed with the original `jsonrpclib`, as it uses  the same name.## SummaryThis library implements the JSON-RPC 2.0 proposed specification in pure Python.It is designed to be as compatible with the syntax of `xmlrpclib` as possible(it extends where possible), so that projects using `xmlrpclib` could easily bemodified to use JSON and experiment with the differences.It is backwards-compatible with the 1.0 specification, and supports all of thenew proposed features of 2.0, including:- Batch submission (via the `MultiCall` class)- Keyword arguments- Notifications (both in a batch and 'normal')- Class translation using the `__jsonclass__` key.A `SimpleJSONRPCServer` class has been added. It is intended to emulate the`SimpleXMLRPCServer` from the default Python distribution.## RequirementsThis library supports `ujson`, `cjson` and `simplejson`, and looks for theparsers in that order (searching first for `ujson`, `cjson`, `simplejson`and finally for the *built-in* `json`).One of these must be installed to use this library, although if you have astandard distribution of 2.7+, you should already have one.Keep in mind that `ujson` is supposed to be the quickest, I believe, so if youare going for full-on optimization you may want to pick it up.## InstallationYou can install this from PyPI with one of the following commands (`sudo`might be required):```# Global installationpip install jsonrpclib-pelix# Local installationpip install --user jsonrpclib-pelix```Alternatively, you can download the source from the GitHub repository at[tcalmant/jsonrpclib](http://github.com/tcalmant/jsonrpclib) and manuallyinstall it with the following commands:```git clone git://github.com/tcalmant/jsonrpclib.gitcd jsonrpclibpython setup.py install```## A note on logging`jsonrpclib-pelix` uses the `logging` module from the standard Pythonlibrary to trace warnings and errors, but doesn't set it up.As a result, you have to configure the Python logging to print out traces.The easiest way to do it is to add those lines at the beginning of your code:```pythonimport logginglogging.basiConfig()```More information can be found in the[`logging` documentation page](https://docs.python.org/3/library/logging.html).## `SimpleJSONRPCServer`This is identical in usage (or should be) to the `SimpleXMLRPCServer` in thePython standard library.Some of the differences in features are that it obviously supports notification,batch calls, class translation (if left on), etc.**Note:** The import line is slightly different from the regular`SimpleXMLRPCServer`, since the `SimpleJSONRPCServer` is provided by th`jsonrpclib` library.```pythonfrom jsonrpclib.SimpleJSONRPCServer import SimpleJSONRPCServerserver = SimpleJSONRPCServer(('localhost', 8080))server.register_function(pow)server.register_function(lambda x,y: x+y, 'add')server.register_function(lambda x: x, 'ping')server.serve_forever()```To start protect the server with SSL, use the following snippet:```pythonfrom jsonrpclib.SimpleJSONRPCServer import SimpleJSONRPCServerimport ssl# Setup the SSL socketserver = SimpleJSONRPCServer(('localhost', 8080), bind_and_activate=False)server.socket = ssl.wrap_socket(server.socket, certfile='server.pem',                                server_side=True)server.server_bind()server.server_activate()# ... register functions# Start the serverserver.serve_forever()```### Notification Thread PoolBy default, notification calls are handled in the request handling thread.It is possible to use a thread pool to handle them, by giving it to the serverusing the `set_notification_pool()` method:```pythonfrom jsonrpclib.SimpleJSONRPCServer import SimpleJSONRPCServerfrom jsonrpclib.threadpool import ThreadPool# Setup the thread pool: between 0 and 10 threadspool = ThreadPool(max_threads=10, min_threads=0)# Don't forget to start itpool.start()# Setup the serverserver = SimpleJSONRPCServer(('localhost', 8080))server.set_notification_pool(pool)# Register methodsserver.register_function(pow)server.register_function(lambda x,y: x+y, 'add')server.register_function(lambda x: x, 'ping')try:    server.serve_forever()finally:    # Stop the thread pool (let threads finish their current task)    pool.stop()    server.set_notification_pool(None)```### Threaded serverIt is also possible to use a thread pool to handle clients requests, using the`PooledJSONRPCServer` class.By default, this class uses pool of 0 to 30 threads.A custom pool can be given with the `thread_pool` parameter of the classconstructor.The notification pool and the request pool are different: by default, a serverwith a request pool doesn't have a notification pool.```pythonfrom jsonrpclib.SimpleJSONRPCServer import PooledJSONRPCServerfrom jsonrpclib.threadpool import ThreadPool# Setup the notification and request poolsnofif_pool = ThreadPool(max_threads=10, min_threads=0)request_pool = ThreadPool(max_threads=50, min_threads=10)# Don't forget to start themnofif_pool.start()request_pool.start()# Setup the serverserver = PooledJSONRPCServer(('localhost', 8080), thread_pool=request_pool)server.set_notification_pool(nofif_pool)# Register methodsserver.register_function(pow)server.register_function(lambda x,y: x+y, 'add')server.register_function(lambda x: x, 'ping')try:    server.serve_forever()finally:    # Stop the thread pools (let threads finish their current task)    request_pool.stop()    nofif_pool.stop()    server.set_notification_pool(None)```### Unix socketTo start a server listening on a Unix socket, you will have to use thefollowing snippet:```pythonfrom jsonrpclib.SimpleJSONRPCServer import SimpleJSONRPCServerimport osimport socket# Set the path to the socket filesocket_name = &quot;/tmp/my_socket.socket&quot;# Ensure that the file doesn't exist yet (or an error will be raised)if os.path.exists(socket_name):   os.remove(socket_name)try:   # Start the server, indicating the socket family   # The server will force some flags when in Unix socket mode   # (no log request, no reuse address, ...)   srv = SimpleJSONRPCServer(socket_name, address_family=socket.AF_UNIX)   # ... register methods to the server   # Run the server   srv.serve_forever()except KeyboardInterrupt:   # Shutdown the server gracefully   srv.shutdown()   srv.server_close()finally:   # You should clean up after the server stopped   os.remove(socket_name)```This feature is tested on Linux during Travis-CI builds. It also hasbeen tested on Windows Subsystem for Linux (WSL) on Windows 10 1809.This feature is not available on &quot;pure&quot; Windows, as it doesn't providethe `AF_UNIX` address family.## Client UsageThis is (obviously) taken from a console session.```python&gt;&gt;&gt; import jsonrpclib&gt;&gt;&gt; server = jsonrpclib.ServerProxy('http://localhost:8080')&gt;&gt;&gt; server.add(5,6)11&gt;&gt;&gt; server.add(x=5, y=10)15&gt;&gt;&gt; server._notify.add(5,6)# No result returned...&gt;&gt;&gt; batch = jsonrpclib.MultiCall(server)&gt;&gt;&gt; batch.add(5, 6)&gt;&gt;&gt; batch.ping({'key':'value'})&gt;&gt;&gt; batch._notify.add(4, 30)&gt;&gt;&gt; results = batch()&gt;&gt;&gt; for result in results:&gt;&gt;&gt; ... print(result)11{'key': 'value'}# Note that there are only two responses -- this is according to spec.# Clean up&gt;&gt;&gt; server('close')()# Using client history&gt;&gt;&gt; history = jsonrpclib.history.History()&gt;&gt;&gt; server = jsonrpclib.ServerProxy('http://localhost:8080', history=history)&gt;&gt;&gt; server.add(5,6)11&gt;&gt;&gt; print(history.request){&quot;id&quot;: &quot;f682b956-c8e1-4506-9db4-29fe8bc9fcaa&quot;, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;add&quot;, &quot;params&quot;: [5, 6]}&gt;&gt;&gt; print(history.response){&quot;id&quot;: &quot;f682b956-c8e1-4506-9db4-29fe8bc9fcaa&quot;, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 11}# Clean up&gt;&gt;&gt; server('close')()```If you need 1.0 functionality, there are a bunch of places you can passthat in, although the best is just to give a specific configuration to`jsonrpclib.ServerProxy`:```python&gt;&gt;&gt; import jsonrpclib&gt;&gt;&gt; jsonrpclib.config.DEFAULT.version2.0&gt;&gt;&gt; config = jsonrpclib.config.Config(version=1.0)&gt;&gt;&gt; history = jsonrpclib.history.History()&gt;&gt;&gt; server = jsonrpclib.ServerProxy('http://localhost:8080', config=config,                                    history=history)&gt;&gt;&gt; server.add(7, 10)17&gt;&gt;&gt; print(history.request){&quot;id&quot;: &quot;827b2923-5b37-49a5-8b36-e73920a16d32&quot;, &quot;method&quot;: &quot;add&quot;, &quot;params&quot;: [7, 10]}&gt;&gt;&gt; print(history.response){&quot;id&quot;: &quot;827b2923-5b37-49a5-8b36-e73920a16d32&quot;, &quot;error&quot;: null, &quot;result&quot;: 17}&gt;&gt;&gt; server('close')()```The equivalent `loads` and `dumps` functions also exist, although withminor modifications.The `dumps` arguments are almost identical, but it adds three arguments:`rpcid` for the `id` key, `version` to specify the JSON-RPC compatibility,and `notify` if it's a request that you want to be a notification.Additionally, the `loads` method does not return the params and method like`xmlrpclib`, but insteada.) parses for errors, raising ProtocolErrors, andb.) returns the entire structure of the request / response for manual parsing.### Unix socketsTo connect a JSON-RPC server over a Unix socket, you have to use a specificprotocol: `unix+http`.When connecting to a Unix socket in the current working directory, you can usethe following syntax: `unix+http://my.socket`When you need to give an absolute path you must use the path part of the URL,the host part will be ignored. For example, you can use this URL to indicate aUnix socket in `/var/lib/daemon.socket`: `unix+http://./var/lib/daemon.socket`**Note:** Currently, only HTTP is supported over a Unix socket.If you want HTTPS support to be implemented, please create an[issue on GitHub](https://github.com/tcalmant/jsonrpclib/issues)### Additional headersIf your remote service requires custom headers in request, you can pass themusing the `headers` keyword argument, when creating the `ServerProxy`:```python&gt;&gt;&gt; import jsonrpclib&gt;&gt;&gt; server = jsonrpclib.ServerProxy(&quot;http://localhost:8080&quot;,                                    headers={'X-Test' : 'Test'})```You can also put additional request headers only for certain methodinvocation:```python&gt;&gt;&gt; import jsonrpclib&gt;&gt;&gt; server = jsonrpclib.Server(&quot;http://localhost:8080&quot;)&gt;&gt;&gt; with server._additional_headers({'X-Test' : 'Test'}) as test_server:...     test_server.ping(42)...&gt;&gt;&gt; # X-Test header will be no longer sent in requests```Of course `_additional_headers` contexts can be nested as well.## Class TranslationThe library supports an *&quot;automatic&quot;* class translation process, although itis turned off by default.This can be devastatingly slow if improperly used, so the following is just ashort list of things to keep in mind when using it.- Keep It (the object) Simple Stupid. (for exceptions, keep reading)- Do not require init params (for exceptions, keep reading)- Getter properties without setters could be dangerous (read: not tested)If any of the above are issues, use the `_serialize` method (see usage below).The server and client must **BOTH** have the `use_jsonclass` configurationitem on and they must both have access to the same libraries used by theobjects for this to work.If you have excessively nested arguments, it would be better to turn off thetranslation and manually invoke it on specific objects using`jsonrpclib.jsonclass.dump` / `jsonrpclib.jsonclass.load` (since thedefault behavior recursively goes through attributes and lists/dicts/tuples).* Sample file: `test_obj.py````python# This object is /very/ simple, and the system will look through the# attributes and serialize what it can.class TestObj(object):    foo = 'bar'# This object requires __init__ params, so it uses the _serialize method# and returns a tuple of init params and attribute values (the init params# can be a dict or a list, but the attribute values must be a dict.)class TestSerial(object):    foo = 'bar'    def __init__(self, *args):        self.args = args    def _serialize(self):        return (self.args, {'foo':self.foo,})```- Sample usage:```python&gt;&gt;&gt; import jsonrpclib&gt;&gt;&gt; import test_obj# History is used only to print the serialized form of beans&gt;&gt;&gt; history = jsonrpclib.history.History()&gt;&gt;&gt; testobj1 = test_obj.TestObj()&gt;&gt;&gt; testobj2 = test_obj.TestSerial()&gt;&gt;&gt; server = jsonrpclib.Server('http://localhost:8080', history=history)# The 'ping' just returns whatever is sent&gt;&gt;&gt; ping1 = server.ping(testobj1)&gt;&gt;&gt; ping2 = server.ping(testobj2)&gt;&gt;&gt; print(history.request){&quot;id&quot;: &quot;7805f1f9-9abd-49c6-81dc-dbd47229fe13&quot;, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;ping&quot;, &quot;params&quot;: [{&quot;__jsonclass__&quot;:                               [&quot;test_obj.TestSerial&quot;, []], &quot;foo&quot;: &quot;bar&quot;}                             ]}&gt;&gt;&gt; print(history.response){&quot;id&quot;: &quot;7805f1f9-9abd-49c6-81dc-dbd47229fe13&quot;, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: {&quot;__jsonclass__&quot;: [&quot;test_obj.TestSerial&quot;, []], &quot;foo&quot;: &quot;bar&quot;}}```This behavior is turned on by default.To deactivate it, just set the `use_jsonclass` member of a server `Config` to`False`.If you want to use a per-class serialization method, set its name in the`serialize_method` member of a server `Config`.Finally, if you are using classes that you have defined in the implementation(as in, not a separate library), you'll need to add those(on **BOTH** the server and the client) using the `config.classes.add()` method.Feedback on this &quot;feature&quot; is very, VERY much appreciated.## TestsTests are an almost-verbatim drop from the JSON-RPC specification 2.0page. They can be run using *unittest* or *nosetest*:```python -m unittest discover testspython3 -m unittest discover testsnosetests tests```## Why JSON-RPC?In my opinion, there are several reasons to choose JSON over XML for RPC:* Much simpler to read (I suppose this is opinion, but I know I'm right. :)* Size / Bandwidth - Main reason, a JSON object representation is just much  smaller.* Parsing - JSON should be much quicker to parse than XML.* Easy class passing with `jsonclass` (when enabled)In the interest of being fair, there are also a few reasons to choose XML overJSON:* Your server doesn't do JSON (rather obvious)* Wider XML-RPC support across APIs (can we change this? :))* Libraries are more established, *i.e.* more stable (Let's change this too)</longdescription>
</pkgmetadata>