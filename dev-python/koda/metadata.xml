<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># KodaKoda is a collection of practical type-safe tools for Python.At its core are a number of datatypes that are common in functional programming.## Maybe`Maybe` is similar to Python's `Optional` type. It has two variants: `Nothing` and `Just`, and they work in similar waysto what you may have seen in other languages.```python3from koda import Maybe, Just, nothinga: Maybe[int] = Just(5)b: Maybe[int] = nothing```To know if a `Maybe` is a `Just` or a `Nothing`, you'll need to inspect it.```python3from koda import Just, Maybemaybe_str: Maybe[str] = function_returning_maybe_str()# python 3.10 +match maybe_str:    case Just(val):        print(val)    case Nothing:        print(&quot;No value!&quot;)# python 3.9 and earlierif isinstance(maybe_str, Just):    print(maybe_str.val)else:    print(&quot;No value!&quot;)````Maybe` has methods for conveniently stringing logic together.#### Maybe.map```python3from koda import Just, nothingdef add_10(x: int) -&gt; int:    return x + 10Just(5).map(add_10)  # Just(15)nothing.map(add_10)  # nothing Just(5).map(add_10).map(lambda x: f&quot;abc{x}&quot;)  # Just(&quot;abc15&quot;)```#### Maybe.flat_map```python3from koda import Maybe, Just, nothingdef safe_divide(dividend: int, divisor: int) -&gt; Maybe[float]:    if divisor != 0:        return Just(dividend / divisor)    else:        return nothingJust(5).flat_map(lambda x: safe_divide(10, x))  # Just(2)Just(0).flat_map(lambda x: safe_divide(10, x))  # nothingnothing.flat_map(lambda x: safe_divide(10, x))  # nothing```## Result`Result` provides a means of representing whether a computation succeeded or failed. To represent success, we can use `OK`;for failures we can use `Err`. Compared to `Maybe`, `Result` is perhaps most useful in that the &quot;failure&quot; case also returns data,whereas `Nothing` contains no data.```python3from koda import Ok, Err, Result def safe_divide_result(dividend: int, divisor: int) -&gt; Result[float, str]:    if divisor != 0:        return Ok(dividend / divisor)    else:        return Err(&quot;cannot divide by zero!&quot;)Ok(5).flat_map(lambda x: safe_divide_result(10, x))  # Ok(2)Ok(0).flat_map(lambda x: safe_divide_result(10, x))  # Err(&quot;cannot divide by zero!&quot;) Err(&quot;some other error&quot;).map(lambda x: safe_divide_result(10, x))  # Err(&quot;some other error&quot;)````Result` can be convenient with `try`/`except` logic.```python3from koda import Result, Ok, Errdef divide_by(dividend: int, divisor: int) -&gt; Result[float, ZeroDivisionError]:    try:        return Ok(dividend / divisor)    except ZeroDivisionError as exc:        return Err(exc)divided: Result[float, ZeroDivisionError] = divide_by(10, 0)  # Err(ZeroDivisionError(&quot;division by zero&quot;))```Another way to perform the same computation would be to use `safe_try`:```python3from koda import Result, safe_try# not safe on its own!def divide(dividend: int, divisor: int) -&gt; float:    return dividend / divisor# safe if used with `safe_try`divided_ok: Result[float, Exception] = safe_try(divide, 10, 2)  # Ok(5)divided_err: Result[float, Exception] = safe_try(divide, 10, 0)  # Err(ZeroDivisionError(&quot;division by zero&quot;))```### Conversion between `Result`s, `Maybe`s, and `Optional`s### Result and MaybeConvert a `Result` to a `Maybe` type.```python3from koda import Just, nothing, Ok, Errassert Ok(5).to_maybe == Just(5)assert Err(&quot;any error&quot;).to_maybe == nothing ```Convert a `Maybe` to a `Result` type.```python3from koda import Just, nothing, Ok, Errassert nothing.to_result(&quot;value if nothing&quot;) == Err(&quot;value if nothing&quot;)assert Just(5).to_result(&quot;value if nothing&quot;) == Ok(5)```### `Maybe` and `Optional`Convert an `Optional` value to a `Maybe`.```python3from koda import to_maybe, Just, nothingassert to_maybe(5) == Just(5)assert to_maybe(&quot;abc&quot;) == Just(&quot;abc&quot;)assert to_maybe(False) == Just(False)assert to_maybe(None) == nothing```Convert a `Maybe` to an `Optional`.```python3from koda import Just, nothingassert Just(5).to_optional == 5assert nothing.to_optional is None# note that `Maybe[None]` will always return None, # so `Maybe.get_or_else` would be preferable in this caseassert Just(None) is None```### `Result` and `Optional`Convert an `Optional` value to a `Result`.```python3from koda import to_result, Ok, Err assert to_result(5, &quot;fallback&quot;) == Ok(5)assert to_result(&quot;abc&quot;, &quot;fallback&quot;) == Ok(&quot;abc&quot;)assert to_result(False, &quot;fallback&quot;) == Ok(False)assert to_result(None, &quot;fallback&quot;) == Err(&quot;fallback&quot;)```Convert a `Result` to an `Optional`.```python3from koda import Ok, Errassert Ok(5).to_optional == 5assert Err(&quot;some error&quot;).to_optional is None# note that `Result[None, Any]` will always return None, # so `Result.get_or_else` would be preferable in this caseassert Ok(None) is None```## MoreThere are many other functions and datatypes included. Some examples:### composeCombine functions by sequencing.```python3from koda import composefrom typing import Callabledef int_to_str(val: int) -&gt; str:    return str(val)def prepend_str_abc(val: str) -&gt; str:    return f&quot;abc{val}&quot;    combined_func: Callable[[int], str] = compose(int_to_str, prepend_str_abc)assert combined_func(10) == &quot;abc10&quot;```### mapping_getTry to get a value from a `Mapping` object, and return an unambiguous result.```python3from koda import mapping_get, Just, Maybe, nothingexample_dict: dict[str, Maybe[int]] = {&quot;a&quot;: Just(1), &quot;b&quot;: nothing}assert mapping_get(example_dict, &quot;a&quot;) == Just(Just(1))assert mapping_get(example_dict, &quot;b&quot;) == Just(nothing)assert mapping_get(example_dict, &quot;c&quot;) == nothing```As a comparison, note that `dict.get` can return ambiguous results:```pythonfrom typing import Optionalexample_dict: dict[str, Optional[int]] = {&quot;a&quot;: 1, &quot;b&quot;: None}assert example_dict.get(&quot;b&quot;) is Noneassert example_dict.get(&quot;c&quot;) is None```We can't tell from the resulting value whether the `None` was the value for a key, or whether the key was not present in the `dict`### load_onceCreate a lazy function, which will only call the passed-in functionthe first time it is called. After it is called, the value is cached.The cached value is returned on each successive call.```python3from random import randomfrom koda import load_oncecall_random_once = load_once(random)  # has not called random yetretrieved_val: float = call_random_once()assert retrieved_val == call_random_once()```## IntentKoda is intended to focus on a small set of practical data types and utility functions for Python. It will not grow to encompass every possible functional or typesafe concept. Similarly, the intent of this library is to avoid requiring extra plugins (beyond a type-checker like mypy or pyright) or specific typchecker settings. As such,it is unlikely that things like Higher Kinded Types emulation or extended type inference will be implemented in this library.</longdescription>
</pkgmetadata>