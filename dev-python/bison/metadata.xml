<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://pypi.python.org/pypi/bison&quot;&gt;&lt;img src=&quot;https://img.shields.io/pypi/v/bison.svg&quot;&gt;&lt;/a&gt;    &lt;a href=&quot;LICENSE&quot;&gt;&lt;img src=&quot;https://img.shields.io/github/license/edaniszewski/bison.svg&quot;&gt;&lt;/a&gt;&lt;h1 align=&quot;center&quot;&gt;bison&lt;/h1&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;Python application configuration&lt;/p&gt;## What is Bison?Bison is a configuration solution for Python applications that aims to be simpleand intuitive. It supports:* reading from YAML config files* reading from environment variables* setting explicit values* setting defaults* configuration validation* configuration access/manipulation with dot notationInstead of implementing custom configuration reading and parsing, you can useBison to handle it for you.Bison was inspired by [Viper][viper] and the lack of goodapplication configuration solutions for Python (at least, in my opinion). Documentationfor Bison can be found on [ReadtheDocs][docs]Bison uses the following precedence order. Each item in the list takes precedenceover the item below it.- override (e.g. calling `Bison.set()`)- environment- config file- defaults## InstallationBison can be installed with `pip````pip install bison```or with `pipenv````pipenv install bison```## Using Bison### Creating a configuration SchemeA configuration scheme is not required by Bison, but having one allows you to set defaultvalues for configuration fields as well as do configuration validation. It is pretty easyto create a new Scheme:```pythonscheme = bison.Scheme()```A Scheme is really just a container for configuration options, so without any options, aScheme is somewhat useless.#### Configuration OptionsThere are currently three types of configuration options:- `bison.Option`- `bison.DictOption`- `bison.ListOption`Their intended functionality should be mostly obvious from their names. An `Option` representsa singular value in a configuration. A `DictOption` represents a dictionary or mapping of valuesin a configuration. A `ListOption` represents a list of values in a configuration.See the [documentation][docs] for more on how options can be configured.Any number of options can be added to a Scheme, but as a simple example we can define a Schemewhich expects a key &quot;log&quot;, and a key &quot;count&quot;.```pythonscheme = bison.Scheme(    bison.Option('log'),    bison.Option('count'),)```#### Configuration ValidationValidation operates based on the constraints set on the options. Above, there are noconstraints (other than the need for those keys to exist), so any value for &quot;log&quot; and&quot;count&quot; will pass validation.An option can be constrained in different ways by using its keyword arguments. For example,to ensure the value for &quot;count&quot; is an integer,```pythonbison.Option('count', field_type=int)```Or, to restrict the values to a set of choices```pythonbison.Option('log', choices=['debug', 'info', 'warn', 'error'])```The [documentation][docs] goes into more detail about other validation settings.#### Setting DefaultsIf a default value is not set on an option, it is considered required. In these cases,if the key specified by that value is not present in the parse configuration, it willcause a validation failure.If a default value is set, then the absence of that field in the configuration will notcause a validation failure.```pythonbison.Option('log', default='info')```### Configuring BisonOnce you have a Scheme to use (if you'd like to), it will need to be passed to a Bisonobject to manage the config building. ```pythonscheme = bison.Scheme()config = bison.Bison(scheme)```There are a few options that can be set on the Bison object to change how itsearches for and builds the unified configuration. For reading configuration files```pythonconfig.config_name = 'config'  # name of the config file (no extension)config.add_config_paths(       # paths to look in for the config file    '.',    '/tmp/app')config.config_format = bison.YAML # the config format to use```For reading environment variables```pythonconfig.env_prefix = &quot;MY_APP&quot;  # the prefix to use for environment variablesconfig.auto_env = True  #  automatically bind all options to env variables based on their key```### Building the unified configOnce the scheme has been set (if using) and Bison has been configured, the only thingleft to do is to read in all the config sources and parse them into a unified config.This is done simply with```pythonconfig.parse()```### ExampleBelow is a complete example for parsing a hypothetical application configuration whichis described by the following YAML config.```yamllog: debugport: 5000settings:  requests:    timeout: 3backends:  - host: 10.1.2.3    port: 5001  - host: 10.1.2.4    port: 5013  - host: 10.1.2.5    port: 5044``````pythonimport bison# the scheme for the configuration. this allows us to set defaults# and validate configuration dataconfig_scheme = bison.Scheme(    bison.Option('log', default='info', choices=['debug', 'info', 'warn', 'error']),    bison.Option('port', field_type=int),    bison.DictOption('settings', scheme=bison.Scheme(        bison.DictOption('requests', scheme=bison.Scheme(            bison.Option('timeout', field_type=int)        ))    )),    bison.ListOption('backends', member_scheme=bison.Scheme(        bison.Option('host', field_type=str),        bison.Option('port', field_type=int)    )))# create a new Bison instance to store and manage configuration dataconfig = bison.Bison(scheme=config_scheme)# set the config file name to 'app' (default is 'config') and set the# search paths to '.' and '/tmp/app/config'config.config_name = 'app'config.add_config_paths('.', '/tmp/app/config')# set the environment variable prefix and enable auto-envconfig.env_prefix = 'MY_APP'config.auto_env = True# finally, parse the config sources to build the unified configurationconfig.parse()```See the [example](example) directory for this example along with demonstrationsof how to access configuration data.## Future WorkThere is more that can be done to improve Bison and expand its functionality. Ifyou wish to contribute, open a pull request. If you have questions or feature requests,open an issue. Below are some high level ideas for future improvements:* Support additional configuration formats (JSON, TOML, ...)* Versioned configurations[docs]: http://readthedocs[viper]: https://github.com/spf13/viper</longdescription>
</pkgmetadata>