<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Overload ``NumPy`` ufuncs and functions#######################################.. container::    |PyPI status| |coverage status| |RTD status| |black status| |pre-commit status|``overload_numpy`` provides easy-to-use tools for working with ``NumPy``'s``__array_(u)func(tion)__``. The library is fully typed and wheels are compiledwith mypyc.Implementing an Overload------------------------First, some imports:    &gt;&gt;&gt; from dataclasses import dataclass, fields    &gt;&gt;&gt; from typing import ClassVar    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; from overload_numpy import NumPyOverloader, NPArrayOverloadMixinNow we can define a ``NumPyOverloader`` instance:    &gt;&gt;&gt; W_FUNCS = NumPyOverloader()The overloads apply to an array wrapping class. Let's define one:    &gt;&gt;&gt; @dataclass    ... class Wrap1D(NPArrayOverloadMixin):    ...     '''A simple array wrapper.'''    ...     x: np.ndarray    ...     NP_OVERLOADS: ClassVar[NumPyOverloader] = W_FUNCS    &gt;&gt;&gt; w1d = Wrap1D(np.arange(3))Now both ``numpy.ufunc`` (e.g. ``numpy.add``) and ``numpy`` functions (e.g.``numpy.concatenate``) can be overloaded and registered for ``Wrap1D``.    &gt;&gt;&gt; @W_FUNCS.implements(np.add, Wrap1D)    ... def add(w1, w2):    ...     return Wrap1D(np.add(w1.x, w2.x))    &gt;&gt;&gt; @W_FUNCS.implements(np.concatenate, Wrap1D)    ... def concatenate(w1ds):    ...     return Wrap1D(np.concatenate(tuple(w.x for w in w1ds)))Time to check these work:    &gt;&gt;&gt; np.add(w1d, w1d)    Wrap1D(x=array([0, 2, 4]))    &gt;&gt;&gt; np.concatenate((w1d, w1d))    Wrap1D(x=array([0, 1, 2, 0, 1, 2]))``ufunc`` also have a number of methods: 'at', 'accumulate', etc. The functiondispatch mechanism in `NEP13&lt;https://numpy.org/neps/nep-0013-ufunc-overrides.html&gt;`_ says that  &quot;If one ofthe input or output arguments implements __array_ufunc__, it is executed insteadof the ufunc.&quot; Currently the overloaded ``numpy.add`` does not work for any ofthe ``ufunc`` methods.    &gt;&gt;&gt; try: np.add.accumulate(w1d)    ... except Exception: print(&quot;failed&quot;)    failed``ufunc`` method overloads can be registered on the wrapped ``add``implementation:    &gt;&gt;&gt; @add.register('accumulate')    ... def add_accumulate(w1):    ...     return Wrap1D(np.add.accumulate(w1.x))    &gt;&gt;&gt; np.add.accumulate(w1d)    Wrap1D(x=array([0, 1, 3]))Dispatching Overloads for Subclasses------------------------------------What if we defined a subclass of ``Wrap1D``?    &gt;&gt;&gt; @dataclass    ... class Wrap2D(Wrap1D):    ...     '''A simple 2-array wrapper.'''    ...     y: np.ndarrayThe overload for ``numpy.concatenate`` registered on ``Wrap1D`` will not workcorrectly for ``Wrap2D``. However, ``NumPyOverloader`` supports single-dispatchon the calling type for the overload, so overloads can be customized forsubclasses.    &gt;&gt;&gt; @W_FUNCS.implements(np.add, Wrap2D)    ... def add(w1, w2):    ...     print(&quot;using Wrap2D implementation...&quot;)    ...     return Wrap2D(np.add(w1.x, w2.x),    ...                   np.add(w1.y, w2.y))    &gt;&gt;&gt; @W_FUNCS.implements(np.concatenate, Wrap2D)    ... def concatenate2(w2ds):    ...     print(&quot;using Wrap2D implementation...&quot;)    ...     return Wrap2D(np.concatenate(tuple(w.x for w in w2ds)),    ...                   np.concatenate(tuple(w.y for w in w2ds)))Checking these work:    &gt;&gt;&gt; w2d = Wrap2D(np.arange(3), np.arange(3, 6))    &gt;&gt;&gt; np.add(w2d, w2d)    using Wrap2D implementation...    Wrap2D(x=array([0, 2, 4]), y=array([ 6, 8, 10]))    &gt;&gt;&gt; np.concatenate((w2d, w2d))    using Wrap2D implementation...    Wrap2D(x=array([0, 1, 2, 0, 1, 2]), y=array([3, 4, 5, 3, 4, 5]))Great! But rather than defining a new implementation for each subclass,let's see how we could write a more broadly applicable overload:    &gt;&gt;&gt; @W_FUNCS.implements(np.add, Wrap1D)  # overriding both    ... @W_FUNCS.implements(np.add, Wrap2D)  # overriding both    ... def add_general(w1, w2):    ...     WT = type(w1)    ...     return WT(*(np.add(getattr(w1, f.name), getattr(w2, f.name))    ...                 for f in fields(WT)))    &gt;&gt;&gt; @W_FUNCS.implements(np.concatenate, Wrap1D)  # overriding both    ... @W_FUNCS.implements(np.concatenate, Wrap2D)  # overriding both    ... def concatenate_general(ws):    ...     WT = type(ws[0])    ...     return WT(*(np.concatenate(tuple(getattr(w, f.name) for w in ws))    ...                 for f in fields(WT)))Checking these work:    &gt;&gt;&gt; np.add(w2d, w2d)    Wrap2D(x=array([0, 2, 4]), y=array([ 6, 8, 10]))    &gt;&gt;&gt; np.concatenate((w2d, w2d))    Wrap2D(x=array([0, 1, 2, 0, 1, 2]), y=array([3, 4, 5, 3, 4, 5]))    &gt;&gt;&gt; @dataclass    ... class Wrap3D(Wrap2D):    ...     '''A simple 3-array wrapper.'''    ...     z: np.ndarray    &gt;&gt;&gt; w3d = Wrap3D(np.arange(2), np.arange(3, 5), np.arange(6, 8))    &gt;&gt;&gt; np.add(w3d, w3d)    Wrap3D(x=array([0, 2]), y=array([6, 8]), z=array([12, 14]))    &gt;&gt;&gt; np.concatenate((w3d, w3d))    Wrap3D(x=array([0, 1, 0, 1]), y=array([3, 4, 3, 4]), z=array([6, 7, 6, 7]))Assisting Groups of Overloads-----------------------------In the previous examples we wrote implementations for a single NumPyfunction. Overloading the full set of NumPy functions this way would take along time.Wouldn't it be better if we could write many fewer, based on groups of NumPyfunctions?    &gt;&gt;&gt; add_funcs = {np.add, np.subtract}    &gt;&gt;&gt; @W_FUNCS.assists(add_funcs, types=Wrap1D, dispatch_on=Wrap1D)    ... def add_assists(cls, func, w1, w2, *args, **kwargs):    ...     return cls(*(func(getattr(w1, f.name), getattr(w2, f.name), *args, **kwargs)    ...                     for f in fields(cls)))    &gt;&gt;&gt; stack_funcs = {np.vstack, np.hstack, np.dstack, np.column_stack, np.row_stack}    &gt;&gt;&gt; @W_FUNCS.assists(stack_funcs, types=Wrap1D, dispatch_on=Wrap1D)    ... def stack_assists(cls, func, ws, *args, **kwargs):    ...     return cls(*(func(tuple(getattr(v, f.name) for v in ws), *args, **kwargs)    ...                     for f in fields(cls)))Checking these work:    &gt;&gt;&gt; np.subtract(w2d, w2d)    Wrap2D(x=array([0, 0, 0]), y=array([0, 0, 0]))    &gt;&gt;&gt; np.vstack((w1d, w1d))    Wrap1D(x=array([[0, 1, 2],                        [0, 1, 2]]))    &gt;&gt;&gt; np.hstack((w1d, w1d))    Wrap1D(x=array([0, 1, 2, 0, 1, 2]))We would also like to implement the ``accumulate`` method for all the``add_funcs`` overloads:    &gt;&gt;&gt; @add_assists.register(&quot;accumulate&quot;)    ... def add_accumulate_assists(cls, func, w1, *args, **kwargs):    ...     return cls(*(func(getattr(w1, f.name), *args, **kwargs)    ...                  for f in fields(cls)))    &gt;&gt;&gt; np.subtract.accumulate(w2d)    Wrap2D(x=array([ 0, -1, -3]), y=array([ 3, -1, -6]))Details-------Want to see about type constraints and the API? Check out the docs!.. |black status| image:: https://img.shields.io/badge/code%20style-black-000000.svg   :target: https://github.com/psf/black   :alt: Codestyle Black.. |coverage status| image:: https://codecov.io/gh/nstarman/overload_numpy/branch/main/graph/badge.svg    :target: https://codecov.io/gh/nstarman/overload_numpy    :alt: overload_numpy's Coverage Status.. |pre-commit status| image:: https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&amp;logoColor=white   :target: https://github.com/pre-commit/pre-commit   :alt: pre-commit.. |PyPI status| image:: https://img.shields.io/pypi/v/overload_numpy.svg    :target: https://pypi.org/project/overload_numpy    :alt: overload_numpy's PyPI Status.. |RTD status| image:: https://readthedocs.org/projects/overload-numpy/badge/?version=latest    :target: https://overload-numpy.readthedocs.io/en/latest/?badge=latest    :alt: overload_numpy's Documentation Status</longdescription>
</pkgmetadata>