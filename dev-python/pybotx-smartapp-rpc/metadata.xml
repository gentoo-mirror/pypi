<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># BotX-SmartApp-RPCБиблиотека, позволяющая писать смартаппы, используя [наш JSONRPC-like протокол](https://ccsteam.atlassian.net/wiki/spaces/EI/pages/193167368/SmartApp+RPC)## УстановкаИспользуя `poetry`:```bashpoetry add pybotx-smartapp-rpc```## Добавление RPC методов1. Создайте класс для входящих аргументов:``` pythonfrom pybotx_smartap_rpc import RPCArgsBaseModel...class SumArgs(RPCArgsBaseModel):    a: int    b: int```2. Создайте RPC метод:``` pythonfrom pybotx_smartapp_rpc import SmartApp, RPCRouter, RPCResultResponse...rpc = RPCRouter()...@rpc.method(&quot;sum&quot;)async def sum(    smartapp: SmartApp, rpc_arguments: SumArgs) -&gt; RPCResultResponse[int]:    return RPCResultResponse(result=rpc_arguments.a + rpc_arguments.b)# Так же у метода может не быть аргументов:@rpc.method(&quot;answer&quot;)async def answer(smartapp: SmartApp) -&gt; RPCResultResponse[int]:    return RPCResultResponse(result=42)```3. Создайте экземпляр `SmartAppRPC` и подключите роутер из прошлого пункта:``` pythonfrom pybotx_smartapp_rpc import SmartAppRPCfrom anywhere import methods ...smartapp = SmartAppRPC(routers=[methods.rpc])```4. Сделайте хендлер для `smartapp_event` и вызывайте в нем хендлер библиотеки``` python@collector.smartapp_eventasync def handle_smartapp_event(event: SmartAppEvent, bot: Bot) -&gt; None:    await smartapp.handle_smartapp_event(event, bot)```## Продвинутая работа с библиотекой* В `RPCResultResponse` можно передавать `botx.File` файлы.``` python@rpc.method(&quot;get-pdf&quot;)async def get_pdf(    smartapp: SmartApp, rpc_arguments: GetPDFArgs) -&gt; RPCResultResponse[None]:    ...    return RPCResultResponse(result=None, files=[...])```* В `SmartAppRPC`, `RPCRouter` и `RPCRouter.method` можно передать мидлвари, сначала будут вызваны мидлвари приложения, затем мидлвари роутера и в конце мидлвари метода.``` pythonsmartapp = SmartAppRPC(..., middlewares=[...])...rpc = RPCRouter(middlewares=[...])...@rpc.method(&quot;sum&quot;, middlewares=[...])```* `RPCArgsBaseModel` это алиас для `pydantic.BaseModel`, вы можете использовать все возможности исходного класса.``` pythonfrom uuid import UUID...class DelUserArgs(RPCArgsBaseModel):    # pydantic сериализует входящую строку в UUID    user_huid: UUID```* Через объект `smartapp`, передаваемый в хендлер можно получить доступ к `event` и `bot`.``` python...@rpc.method(&quot;del-user&quot;)async def del_user(    smartapp: SmartApp, rpc_arguments: DelUserArgs) -&gt; RPCResultResponse[None]:    await smartapp.bot.send_message(        body=&quot;Done&quot;,        bot_id=smartapp.event.bot.id,        chat_id=smartapp.event.chat.id,    )    ...```* Используя метод `smartapp.send_event` можно отправлять RPC ивенты с `ref: null`.  Это может пригодиться при необходимости отправки уведомления не в ответ на RPC запрос.``` python@rpc.method(&quot;notify-me&quot;)async def notify_me(    smartapp: SmartApp, rpc_arguments: NotifyMeArgs) -&gt; RPCResultResponse[None]:    ...    await smartapp.send_event(&quot;notified&quot;, files=[notify_file])    ...```* Используя метод `smartapp.send_push` можно отправлять пуш уведомлений на клиент.И обновлять счетчик уведомлений на икноке смартапа.``` python@rpc.method(&quot;notify-me&quot;)async def notify_me(    smartapp: SmartApp, rpc_arguments: NotifyMeArgs) -&gt; RPCResultResponse[None]:    await smartapp.send_push(42, &quot;You have 42 new emails!&quot;)    ...```* В мидлварях можно создавать новые объекты в `smartapp.state`, чтобы потом использовать их в хендлерах.``` pythonasync def user_middleware(smartapp: SmartApp, rpc_arguments: RPCArgsBaseModel, call_next: Callable) -&gt; RPCResponse[User]:    smartapp.state.user = await User.get(smartapp.message.user_huid)    return await call_next(smartapp, rpc_arguments)@rpc.method(&quot;get-user-fullname&quot;)async def get_user_fullname(smartapp: SmartApp) -&gt; RPCResultResponse[str]:    return RPCResultResponse(result=smartapp.state.user.fullname)```* Можно выбрасывать пользовательские RPC ошибки, которые будут отправлены как ответ на RPC запрос.``` pythonfrom pybotx_smartapp_rpc import RPCErrorExc, RPCError...@rpc.method(&quot;return-error&quot;)async def return_error(smartapp: SmartApp, rpc_arguments: RaiseOneErrorArgs) -&gt; None:    # one error    raise RPCErrorExc(        RPCError(            reason=&quot;It's error reason&quot;,            id=&quot;CUSTOM_ERROR&quot;,            meta={&quot;args&quot;: rpc_arguments.dict()},        )    )    # or list of errors    raise RPCErrorExc(        [            RPCError(                reason=&quot;It's error reason&quot;,                id=&quot;CUSTOM_ERROR&quot;,                meta={&quot;args&quot;: rpc_arguments.dict()},            ),            RPCError(                reason=&quot;It's one more error reason&quot;,                id=&quot;CUSTOM_ERROR_NUMBER_TWO&quot;,                meta={&quot;args&quot;: rpc_arguments.dict()},            )        ]    )```* Можно добавить хендлер на определенный тип исключений. В него будут отправлять исключения того же и дочерних классов.Хендлер **обязан** возвращать `RPCErrorResponse`, ошибки из которого будут отправлены источнику запроса.``` pythonfrom pybotx_smartapp_rpc import SmartAppRPC, RPCErrorResponse...async def key_error_handler(exc: KeyError, smartapp: SmartApp) -&gt; RPCErrorResponse:    key = exc.args[0]    return RPCErrorResponse(        errors=[            RPCError(                reason=f&quot;Key {key} not found.&quot;,                id=&quot;KEY_ERROR&quot;,                meta={&quot;key&quot;: key},            ),        ]    )smartapp = SmartAppRPC(..., exception_handlers={KeyError: key_error_handler})```</longdescription>
</pkgmetadata>