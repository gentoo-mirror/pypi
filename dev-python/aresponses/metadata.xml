<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># aresponses[![image](https://img.shields.io/pypi/v/aresponses.svg)](https://pypi.org/project/aresponses/)[![image](https://img.shields.io/pypi/pyversions/aresponses.svg)](https://pypi.org/project/aresponses/)[![build status](https://github.com/CircleUp/aresponses/workflows/Python%20Checks/badge.svg)](https://github.com/CircleUp/aresponses/actions?query=branch%3Amaster)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)an asyncio testing server for mocking external services## Features - Fast mocks using actual network connections - allows mocking some types of network issues - use regular expression matching for domain, path, method, or body - works with https requests as well (by switching them to http requests) - works with callables## UsageAdd routes and responses via the `aresponses.add` method:```pythondef add(    host_pattern=ANY,     path_pattern=ANY,     method_pattern=ANY,     response=&quot;&quot;,     *,     route=None,     body_pattern=ANY, m    match_querystring=False,     repeat=1    )```When a request is received the first matching response will be returnedand removed from the routing table.  The `response` argument can beeither a string, Response, dict, or list.  Use `aresponses.Response`when you need to do something more complex.**Note that version &gt;=2.0 requires explicit assertions!**```python@pytest.mark.asyncioasync def test_simple(aresponses):    aresponses.add(&quot;google.com&quot;, &quot;/api/v1/&quot;, &quot;GET&quot;, response=&quot;OK&quot;)    aresponses.add('foo.com', '/', 'get', aresponses.Response(text='error', status=500))    async with aiohttp.ClientSession() as session:        async with session.get(&quot;http://google.com/api/v1/&quot;) as response:            text = await response.text()            assert text == &quot;OK&quot;        async with session.get(&quot;https://foo.com&quot;) as response:            text = await response.text()            assert text == &quot;error&quot;    aresponses.assert_plan_strictly_followed()```#### AssertionsIn aresponses 1.x requests that didn't match a route stopped the eventloop and thus forced an exception.  In aresponses &gt;2.x it's required tomake assertions at the end of the test.There are three assertions functions provided:- `aresponses.assert_no_unused_routes` Raises `UnusedRouteError` if allthe routes defined were not used up.- `aresponses.assert_called_in_order` - Raises `UnorderedRouteCallError`if the routes weren't called in the order they were defined.- `aresponses.assert_all_requests_matched` - Raises `NoRouteFoundError`if any requests were made that didn't match to a route.  It's likelybut not guaranteed that your code will throw an exception in thissituation before the assertion is reached.Instead of calling these individually, **it's recommended to call`aresponses.assert_plan_strictly_followed()` at the end of each test asit runs all three of the above assertions.**#### Regex and Repeat`host_pattern`, `path_pattern`, `method_pattern` and `body_pattern` maybe either strings (exact match) or regular expressions.The repeat argument permits a route to be used multiple times.If you want to just blanket mock a service, without concern for how manytimes its called you could set repeat to a large number and not call`aresponses.assert_plan_strictly_followed` or`arespones.assert_no_unused_routes`.```python@pytest.mark.asyncioasync def test_regex_repetition(aresponses):    aresponses.add(re.compile(r&quot;.*\.?google\.com&quot;), response=&quot;OK&quot;, repeat=2)    async with aiohttp.ClientSession() as session:        async with session.get(&quot;http://google.com&quot;) as response:            text = await response.text()            assert text == &quot;OK&quot;        async with session.get(&quot;http://api.google.com&quot;) as response:            text = await response.text()            assert text == &quot;OK&quot;    aresponses.assert_plan_strictly_followed()```#### Json ResponsesAs a convenience, if a dict or list is passed to `response` then it willcreate a json response. A `aiohttp.web_response.json_response` objectcan be used for more complex situations.```python@pytest.mark.asyncioasync def test_json(aresponses):    aresponses.add(&quot;google.com&quot;, &quot;/api/v1/&quot;, &quot;GET&quot;, response={&quot;status&quot;: &quot;OK&quot;})    async with aiohttp.ClientSession() as session:        async with session.get(&quot;http://google.com/api/v1/&quot;) as response:            assert {&quot;status&quot;: &quot;OK&quot;} == await response.json()    aresponses.assert_plan_strictly_followed()```#### Custom HandlerCustom functions can be used for whatever other complex logic isdesired. In example below the handler is set to repeat infinitelyand always return 500.```pythonimport math@pytest.mark.asyncioasync def test_handler(aresponses):    def break_everything(request):        return aresponses.Response(status=500, text=str(request.url))    aresponses.add(response=break_everything, repeat=math.inf)    async with aiohttp.ClientSession() as session:        async with session.get(&quot;http://google.com/api/v1/&quot;) as response:            assert response.status == 500```#### PassthroughPass `aresponses.passthrough` into the response argument to allow arequest to bypass mocking.```python    aresponses.add('httpstat.us', '/200', 'get', aresponses.passthrough)```#### Inspecting historyHistory of calls can be inspected via `aresponses.history` which returnsthe namedTuple `RoutingLog(request, route, response)````python@pytest.mark.asyncioasync def test_history(aresponses):    aresponses.add(response=aresponses.Response(text=&quot;hi&quot;), repeat=2)    async with aiohttp.ClientSession() as session:        async with session.get(&quot;http://foo.com/b&quot;) as response:            await response.text()        async with session.get(&quot;http://bar.com/a&quot;) as response:            await response.text()    assert len(aresponses.history) == 2    assert aresponses.history[0].request.host == &quot;foo.com&quot;    assert aresponses.history[1].request.host == &quot;bar.com&quot;    assert &quot;Route(&quot; in repr(aresponses.history[0].route)    aresponses.assert_plan_strictly_followed()```#### Context manager usage```pythonimport aiohttpimport pytestimport aresponses@pytest.mark.asyncioasync def test_foo(event_loop):    async with aresponses.ResponsesMockServer(loop=event_loop) as arsps:        arsps.add('foo.com', '/', 'get', 'hi there!!')        arsps.add(arsps.ANY, '/', 'get', arsps.Response(text='hey!'))        async with aiohttp.ClientSession(loop=event_loop) as session:            async with session.get('http://foo.com') as response:                text = await response.text()                assert text == 'hi'            async with session.get('https://google.com') as response:                text = await response.text()                assert text == 'hey!'```#### working with [pytest-aiohttp](https://github.com/aio-libs/pytest-aiohttp)If you need to use aresponses together with pytest-aiohttp, you should re-initialize main aresponses fixture with `loop` fixture```pythonfrom aresponses import ResponsesMockServer@pytest.fixtureasync def aresponses(loop):    async with ResponsesMockServer(loop=loop) as server:        yield server```If you're trying to use the `aiohttp_client` test fixture then you'll need to mock out the aiohttp `loop` fixtureinstead:```python@pytest.fixturedef loop(event_loop):    &quot;&quot;&quot;replace aiohttp loop fixture with pytest-asyncio fixture&quot;&quot;&quot;    return event_loop```## Contributing### Dev environment setup  - **install pyenv and pyenv-virtualenv**  - Makes it easy to install specific versions of python and switch between them. Make sure you install the virtualenv bash hook  - `git clone` the repo and `cd` into it.  - `make init` - installs proper version of python, creates the virtual environment, activates it and installs all the requirements### Submitting a feature request    - **`git checkout -b my-feature-branch`**   - **make some cool changes**  - **`make autoformat`**  - **`make test`**  - **`make lint`**  - **create pull request**### Updating package on pypi  - `make deploy`## Changelog#### 2.1.6- fix: incorrect pytest plugin entrypoint name (#72)#### 2.1.5- support asyncio_mode = strict (#68)#### 2.1.4- fix: don't assume utf8 request contents#### 2.1.3- accidental no-op release#### 2.1.2- documentation: add pypi documentation#### 2.1.1- bugfix: RecursionError when aresponses is used in more than 1000 tests (#63)#### 2.1.0- feature: add convenience method `add_local_passthrough`- bugfix: fix https subrequest mocks. support aiohttp_client compatibility#### 2.0.2- bugfix: ensure request body is available in history#### 2.0.0**Warning! Breaking Changes!**- breaking change: require explicit assertions for test failures- feature: autocomplete works in intellij/pycharm- feature: can match on body of request- feature: store calls made- feature: repeated responses- bugfix: no longer stops event loop- feature: if dict or list is passed into `response`, a json responsewill be generated#### 1.1.2- make passthrough feature work with binary data#### 1.1.1- regex fix for Python 3.7.0#### 1.1.0- Added passthrough option to permit live network calls- Added example of using a callable as a response#### 1.0.0- Added an optional `match_querystring` argument that lets you match on querystring as well## Contributors* Bryce Drennan, CircleUp &lt;aresponses@brycedrennan.com&gt;* Marco Castelluccio, Mozilla &lt;mcastelluccio@mozilla.com&gt;* Jesse Vogt, CircleUp &lt;jesse.vogt@gmail.com&gt;* Pavol Vargovcik, Kiwi.com &lt;pavol.vargovcik@gmail.com&gt;</longdescription>
</pkgmetadata>