<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># MultiPing: A pure-python implemention to monitor IP addresses with pingsMultiPing is a Python library to monitor one or many IP addresses via ICMP echo(ping) requests. Features:* It works for Python 2 and 3.* Supports timeouts and retries.* Supports IPv4 as well as IPv6.* Small and compact and does not rely on any 3rd party packages, aside from  what's included in Python.It is ideally suited to monitor large numbers of hosts in clusters, but is justas suitable to check on a single address.MultiPing was originally developed for the[vpc-router](https://github.com/romana/vpc-router) project, but can easilybe used on its own.## Installation### Installation via pipMultiPing is available in PyPi, the Python Package Index. Therefore, you caninstall it simply with:    pip install multiping### Installation from sourceAfter downloading the code or cloning this repository, please run the `setup.py`file, which is included in the source code:    python setup.py install## ContributionsWe welcome any contributions, bug reports or feedback. Please use our[issue tracker](https://github.com/romana/multi-ping/issues) to file bugs orrequest additional features. We are happy to consider pull requests as well.## Using MultiPing_Note: ICMP packets can only be sent by processes with root privileges._Here is an example of how to use MultiPing in your own code:    from multiping import MultiPing    # Create a MultiPing object to test three hosts / addresses    mp = MultiPing([&quot;8.8.8.8&quot;, &quot;youtube.com&quot;, &quot;127.0.0.1&quot;])    # Send the pings to those addresses    mp.send()    # With a 1 second timout, wait for responses (may return sooner if all    # results are received).    responses, no_responses = mp.receive(1)The `receive()` function returns a tuple containing a results dictionary(addresses and response times) as well as a list of addresses that did notrespond in time. The results may be processed like this:    ...    for addr, rtt in responses.items():        print &quot;%s responded in %f seconds&quot; % (addr, rtt)    if no_responses:        print &quot;These addresses did not respond: %s&quot; % &quot;, &quot;.join(no_responses)        # Sending pings once more, but just to those addresses that have not        # responded, yet. The MultiPing object 'mp' remembers the state of        # which address has responded already, so that another call to        # send() just generates packets to those hosts from which we haven't        # heard back, yet.        mp.send()        responses, no_responses = mp.receive(1)        ...Note that `send()` can be called multiple times. If there are any addressesleft for which no response has been received yet then this will resend pingsto those remaining addresses.A convenient `multi_ping()` function is provided, which implements retries anddelivers results in a single and simple function call:    from multiping import multi_ping    addrs = [&quot;8.8.8.8&quot;, &quot;youtube.com&quot;, &quot;127.0.0.1&quot;]    # Ping the addresses up to 4 times (initial ping + 3 retries), over the    # course of 2 seconds. This means that for those addresses that do not    # respond another ping will be sent every 0.5 seconds.    responses, no_responses = multi_ping(addrs, timeout=2, retry=3)Also see the `demo.py` file for more examples.If there are any names or addresses in the list of target addresses, whichcannot be resolved or looked up, a `socket.gaierror` is raised. This can besurpressed if the `silent_lookup_errors` parameter flag is set. Either as namedparameter for the `multi_ping` function or when a `MultiPing` object iscreated.</longdescription>
</pkgmetadata>