<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>python2=======A library for running Python 2 code from a Python 3 application.    Effortlessly harness the power and convenience of Python 2... in Python 3!Why?----Why not??This library was created for more whimsical than practical reasons.  In theory,it could be used to interface with legacy Python 2 code which for one reason oranother cannot be ported to Python 3.Installation------------``python2`` requires a working install of both Python 2 and Python 3.Currently the library has only been tested with Python 2.7 and Python 3.4, 3.5,and 3.6.To install the package::    pip install -U python2If using virtualenvs, you will need to create separate Python 2 and 3virtualenvs, and install the package into both.Usage-----To begin working with Python 2, import the package in Python 3 and create a new``Python2`` object::    &gt;&gt;&gt; from python2.client import Python2    &gt;&gt;&gt; py2 = Python2('/path/to/python2/executable')This object is our gateway to the Python 2 world.  Python 2 builtins can beaccessed as attributes of the ``Python2`` object. Let's use Python 2's``__import__()`` function to import the deprecated ``sha`` module, which wasremoved in Python 3::    &gt;&gt;&gt; py2_sha = py2.__import__('sha')    &gt;&gt;&gt; py2_sha.sha('abc')    &lt;Py2Object &lt;sha1 HASH object @ 0x107463c30&gt;&gt;Ahh, just like the good ol' days.  You can deprecate a module but you can'tdeprecate the human spirit!We can use the ``Python2.project()`` method to convert Python 3 objects toPython 2::    &gt;&gt;&gt; py2.project(1)    &lt;Py2Object 1&gt;    &gt;&gt;&gt; py2.project('foo')    &lt;Py2Object u'foo'&gt;You can use ``Python2.lift()`` to lift Python 2 objects back to Python 3.  Forcontainer types, use ``Python2.deeplift()`` to recursively perform the lifting.``Py2Object`` instances have special properties ``_`` and ``__`` to perform theequivalent operations::    &gt;&gt;&gt; o = py2.project([1, 2, 3])    &gt;&gt;&gt; o    &lt;Py2Object [1, 2, 3]&gt;    &gt;&gt;&gt; o._    [&lt;Py2Object 1&gt;, &lt;Py2Object 2&gt;, &lt;Py2Object 3&gt;]    &gt;&gt;&gt; o.__    [1, 2, 3]Python 2 objects can be used pretty much like regular Python 3 objects.  Youcan also freely mix and match with Python 3 builtin types::    &gt;&gt;&gt; x = py2.project(1)    &gt;&gt;&gt; x    &lt;Py2Object 1&gt;    &gt;&gt;&gt; str(x)    '1'    &gt;&gt;&gt; x + 1    &lt;Py2Object 2&gt;    &gt;&gt;&gt; d = py2.dict(foo=x, bar=None)    &gt;&gt;&gt; d['foo'] is x    True    &gt;&gt;&gt; del d['foo']    &gt;&gt;&gt; d    &lt;Py2Object {u'bar': None}&gt;    &gt;&gt;&gt; d.__    {'bar': None}If you just want to execute some Python 2 code directly, you can use the``Python2.exec()`` method.  This method accepts a string containing Python 2code and an optional dict representing the scope to execute the code in, andreturns the resulting scope after executing the code.  This can be used todefine new Python 2 classes and functions::   &gt;&gt;&gt; scope = py2.exec(&quot;&quot;&quot;   ... def foo(x):   ...     return x + 1   ... &quot;&quot;&quot;)   &gt;&gt;&gt; foo = scope['foo']   &gt;&gt;&gt; foo(2)   &lt;Py2Object 3&gt;If an exception occurs in Python 2, a ``Py2Error`` will be thrown by theclient.  The Python 2 exception is stored as the ``exception`` attribute of the``Py2Error`` object.  The underlying traceback is attached to the Python 2exception as the ``__traceback__`` attribute.::    &gt;&gt;&gt; py2.int('asdf')    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;      ...    python2.client.exceptions.Py2Error: ValueError: invalid literal for int() with base 10: 'asdf'When you're done using Python 2, you can end the session by calling the``Python2.shutdown()`` method.  You can also use the ``Python2`` object as acontext manager to automatically do the same thing when exiting the context.::    &gt;&gt;&gt; py2.shutdown()Testing-------This package uses Tox for testing.  Tests are not included in the Python dist,so you will need to clone the repo to run them.  To run the unit tests, installTox and run the following command from the project's base directory::    toxAfter running tox, you can run the client-server integration tests with the'integration_tests.sh' script.  This script takes two arguments specifying theTox virtualenvs to use for Python 2 and 3, respectively::    ./integration_tests.sh py27 py36To modify the behavior of Tox, you can set the ``PYTEST_ADDOPTS`` variable.For example, you can set the ``-x`` flag to abort after the first testfailure::    export PYTEST_ADDOPTS=-xYou can use the ``-n NUM`` flag to parallelize the tests using the`pytest-xdist plugin`_  This adds some overhead to the test setup, so thisoption is primarily useful for speeding up the integration tests.    export PYTEST_ADDOPTS='-n 4'.. _pytest-xdist plugin: http://pytest.org/dev/xdist.htmlCaveats-------Supported types```````````````Projection is only supported for basic builtin types.  Other objects cannot beprojected to Python 2.  The supported types are: ``bool``, ``int``, ``float``,``complex``, ``bytes``, ``unicode``, ``bytearray``, ``range``, ``slice``,``list``, ``tuple``, ``set``, ``frozenset``, and ``dict``.  The ``None``,``NotImplemented``, and ``Ellipsis`` singletons are also supported.In particular, Python 3 functions, types, and instances of user-defined classescannot currently be projected into Python 2.Type introspection``````````````````The ``Py2Object`` class implements many &quot;magic methods&quot; from the Python 3 datamodel.  As a result, a ``Py2Object`` appears to be callable, iterable, etc.,even if the underlying object is not.  Attempting to perform such operations mayresult in a ``Py2Error``.If you need to introspect a Python 2 object, use the corresponding *Python 2*builtin functions.  For example::    &gt;&gt;&gt; i = py2.project(1)    &gt;&gt;&gt; py2.callable(i)    &lt;Py2Object False&gt;    &gt;&gt;&gt; py2.isinstance(i, py2.int)    &lt;Py2Object True&gt;String types````````````In Python 2, ``str`` objects are raw byte strings, while in Python 3 they areUnicode strings.  This can lead to some confusion, as projecting a Python 3``str`` will result in a Python 2 ``unicode`` object, while lifting a Python 2``str`` will return a Python 3 ``bytes`` object.    &gt;&gt;&gt; py2.project('foo')    &lt;Py2Object u'foo'&gt;    &gt;&gt;&gt; py2.lift(py2.str(123))    b'123'Division````````The behavior of the division operator changed with `PEP 238`_.  This createdtwo alternate division operations, &quot;true division&quot; and &quot;classic division&quot;.Classic division was removed in Python 3.To respect this change, when two ``Py2Object`` s are divided, classic divisionis used.  When a ``Py2Object`` divides or is divided by a Python 3 value, true division is used.::    &gt;&gt;&gt; i = py2.project(1)    &gt;&gt;&gt; j = py2.project(2)    &gt;&gt;&gt; i / j  # classic division    &lt;Py2Object 0&gt;    &gt;&gt;&gt; i / 2  # true division    &lt;Py2Object 0.5&gt;    &gt;&gt;&gt; 1 / j  # true division    &lt;Py2Object 0.5&gt;.. _PEP 238: https://www.python.org/dev/peps/pep-0238/Further discussion------------------How it works````````````When you launch a Python 2 session, the library spawns a child process runningPython 2.  This child process runs a *server* that listens for commands fromthe Python 3 *client*.  For each command, the server performs an operation inPython 2 and returns the result either as an encoded *value* made up ofsupported types, or a *reference* to a Python 2 object stored on the server.On the client side, the library wraps Python 2 references with the``Py2Object`` class.  This class implements many of the &quot;magic methods&quot; of the`Python 3 data model`_ by sending commands to the Python 2 server to performthe appropriate operation on the underlying Python 2 object... _Python 3 data model: https://docs.python.org/3/reference/datamodel.htmlCall-by-value semantics```````````````````````When projecting a value or calling a Python 2 function with Python 3 arguments,the arguments will be passed to Python 2 &quot;by value&quot;, that is, by encoding thevalue of the argument to be decoded by the server.  When using a Python 2object, the object is stored in the Python 2 session and is passed &quot;byreference&quot;.This has some implications for the semantics of Python 2 functions.  Suppose wehave a Python 2 function that mutates a list.  If we pass this function aPython 3 list, the list will be copied into Python 2 and the copy will bemutated, but the original will not be modified::    &gt;&gt;&gt; f = py2.eval(&quot;lambda l: l.append(1)&quot;)    &gt;&gt;&gt; l = []    &gt;&gt;&gt; f(l)    &lt;Py2Object None&gt;    &gt;&gt;&gt; l    []However, if we project the list into Python 2 before passing it to thefunction, then we can observe the modifications on the projected list::    &gt;&gt;&gt; py2_l = py2.project(l)    &gt;&gt;&gt; f(py2_l)    &lt;Py2Object None&gt;    &gt;&gt;&gt; py2_l    &lt;Py2Object [1]&gt;Return semantics````````````````Returning generally occurs by reference except for operations that require aspecific return type (``str()``, ``int()``, etc.).  The main reason for this isthat returning by value may lose information about object identity that needsto be preserved.  Return values can be easily lifted to Python 2 if desired.Object identity and lifespan````````````````````````````Each Python 2 object returned by the server is represented by a unique``Py2Object``.  This means that the ``is`` operator can be used to determine iftwo ``Py2Object`` s refer to the same underlying object.The Python 2 server stores all objects it returns, to prevent them from beingdeallocated.  When the corresponding ``Py2Object`` is deallocated in the Python3 process, the underlying Python 2 object will be removed from the server cacheto allow it to be deallocated as appropriate.Encoding algorithm``````````````````This library uses a simple JSON encoding for supported types.  For a givenfunction call, each unique object will only be encoded once.  This means thatdata structures with circular references are supported.  For a detaileddescription of the algorithm, see the ``python2.shared.codec`` module.Possible improvements---------------------Python 2 types``````````````Currently there is a single type for Python 2 objects in Python 3,``Py2Object``. An alternate strategy would be to dynamically create Python 3classes for each Python 2 type encountered, and create proxy objects asinstances of these classes.The main benefit of this change would be better type introspection for Python 2objects (see the discussion at `Type introspection`_).  However, it would bemore cumbersome and incur a performance cost, since the client would need toknow the type of each object and the methods supported by that type.Additionally, this approach would not fully support the dynamic nature of thePython type system, since the proxied type would not reflect changes to theunderlying type such as adding or removing methods.This would require the server to return the object type for references, andsome mechanism for the client to introspect Python 2 types.  The client wouldcache types for the lifetime of the Python 2 session, with a mechanism toexplicitly refresh a type to pick up any changes that had occurred in Python 2.Bootstrapping the type system might be a little tricky.  We would want tocreate a type ``Py2type`` such all proxy types are instances of, *including``Py2type`` itself.*  We would also probably want a base type for all proxyobjects, including types.Python 3 proxy objects in Python 2``````````````````````````````````Currently the relationship between client and server is asymmetrical.  Theclient has a representation of Python 2 objects, but the server does not havea way to represent Python 3 objects.  We might like to add such a mechanism.This would mean that instead of the simple request-response pattern from clientto server we have now, there would be the possibility of callbacks.  In effect,the two processes would act more like coroutines with the flow of controlpassing back and forth between them.Better Python version support`````````````````````````````We could extend support to more Python 2 and 3 versions.Similar projects----------------After writing this library, I discovered that I'm not the only one to have hadthis idea.  `Sux`_ is a library that provides similar functionality, with somenotable differences:- The library is much smaller and more lightweight, and only needs to be  installed in the Python 3 environment to work.- The main emphasis is on imports and function calls, which makes sense since  these are the most important operations for the using legacy packages.  Most  other operators (e.g. arithmetic operators) are not supported.- The library uses Pickle to communicate between the Python 2 and 3 processes.  This is a good idea and I should probably have done the same, although I had  fun implementing the current encoding algorithm... _Sux: https://github.com/nicois/sux/</longdescription>
</pkgmetadata>