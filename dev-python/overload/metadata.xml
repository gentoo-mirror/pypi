<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Simple overloading of methods and functions through an @overload decorator.This module allows one to provide multiple interfaces for a functions,methods, classmethods, staticmethods or classes. See below for some notesabout overloading classes, you strange person you.The appropriate implementation is chosen based on the calling argumentpattern.For example:&gt;&gt;&gt; class A(object):...   @overload...   def method(self, a):...     return 'a'...   @method.add...   def method(self, a, b):...     return 'a, b'... &gt;&gt;&gt; a = A()&gt;&gt;&gt; a.method(1)'a'&gt;&gt;&gt; a.method(1, 2)'a, b'The overloading handles fixed, keyword, variable (``*args``) and arbitrarykeyword (``**keywords``) arguments.It also handles annotations if those annotations are types:&gt;&gt;&gt; @overload... def func(a:int):...   return 'int'... &gt;&gt;&gt; @func.add... def func(a:str):...   return 'str'... &gt;&gt;&gt; func(1)'int'&gt;&gt;&gt; func('s')'str'&gt;&gt;&gt; func(1.0)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;overload.py&quot;, line 94, in f    raise TypeError('invalid call argument(s)')TypeError: invalid call argument(s)This feature (and currently the module in general) requires Python 3.The docstring and name (ie. documentation) of the resultant callable willmatch that of the *first* callable overloaded.Overloading Classes--------------------Overloading classes allows you to select a class type based on theconstruction arguments of each alternative type's __new__ method.There's a catch though: the __new__ method must *explicitly* invoke thebase class __new__ method, rather than use super() like usual. This isbecause after being @overloaded the class is a function, and super()doesn't like being passed functions. So instead of::    @overload    class A(object):        def __new__(cls):            # this will fail because &quot;A&quot; is a function now            return super(A, cls).__new__(cls)you must::    @overload    class A(object):        def __new__(cls):            # must explicitly reference the base class            return object.__new__(cls)I'll leave it up to the reader to justify their use of @overloadingclasses.Version History (in Brief)--------------------------- 1.1 altered the text of the invalid call TypeError. Removed debug prints.- 1.0 the initial releaseSee the end of the source file for the license of use.----I would be interested to know whether this module is useful - if you use itplease indicate so at https://www.ohloh.net/p/pyoverload</longdescription>
</pkgmetadata>