<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># BarterDude[![Build Status](https://travis-ci.com/olxbr/BarterDude.svg?branch=master)](https://travis-ci.com/olxbr/BarterDude)[![Coverage Status](https://coveralls.io/repos/github/olxbr/BarterDude/badge.svg?branch=master)](https://coveralls.io/github/olxbr/BarterDude?branch=master)Message exchange engine to build pipelines using brokers like RabbitMQ. This project is build on top of the great [async-worker](https://github.com/async-worker/async-worker).![barter](https://github.com/olxbr/BarterDude/blob/master/barterdude.jpg)## InstallUsing Python 3.6+```shpip install barterdude```## UsageBuild your consumer with this complete example:```pythonimport loggingfrom barterdude import BarterDudefrom barterdude.monitor import Monitorfrom barterdude.hooks.healthcheck import Healthcheckfrom barterdude.hooks.logging import Loggingfrom barterdude.hooks.metrics.prometheus import Prometheusfrom barterdude.message import Messagefrom barterdude.conf import getLogger# from my_project import MyHook # (you can build your own hooks)# configure RabbitMQbarterdude = BarterDude(    hostname=&quot;localhost&quot;,    username=&quot;guest&quot;,    password=&quot;guest&quot;,    prefetch=256,)# Prometheus labels for automatic metricslabels = dict(    app_name=&quot;my_app&quot;,    team_name=&quot;my_team&quot;)healthcheck = Healthcheck(barterdude) # automatic and customizable healthcheckprometheus = Prometheus(labels) # automatic and customizable Prometheus integrationself.logger = getLogger(&quot;my_app&quot;, logging.DEBUG) # automatic json log with barterdude namespace# BARTERDUDE_DEFAULT_APP_NAME is an env var to control your project namespace# BARTERDUDE_DEFAULT_LOG_LEVEL is an env var to control loglevel by number 0, 10, 20, etc...monitor = Monitor(    healthcheck,    prometheus,    # MyHook(barterdude, &quot;/path&quot;), # (will make localhost:8080/path url)    Logging() # automatic and customizable logging)my_metric = prometheus.metrics.counter(name=&quot;fail&quot;, description=&quot;fail again&quot;)  # It's the same as https://github.com/prometheus/client_python@barterdude.consume_amqp(    [&quot;queue1&quot;, &quot;queue2&quot;],    monitor,    coroutines = 10,  # number of coroutines spawned to consume messages (1 per message)    bulk_flush_interval = 60.0,  #  max waiting time for messages to start process n_coroutines    requeue_on_fail = True  # should retry or not the message)async def your_consumer(msg: Message): # you receive only one message and we parallelize processing for you    await barterdude.publish_amqp(        exchange=&quot;my_exchange&quot;,        data=msg.body    )    if msg.body == &quot;fail&quot;:        my_metric.inc() # you can use prometheus metrics        healthcheck.force_fail() # you can use your hooks inside consumer too        msg.reject(requeue=False) # You can force to reject a message, exactly equal https://b2wdigital.github.io/async-worker/src/asyncworker/asyncworker.rabbitmq.html#asyncworker.rabbitmq.message.RabbitMQMessage    if msg.body == &quot;exception&quot;:        raise Exception() # this will reject the message and requeue    # if everything is fine, than message automatically is acceptedbarterdude.run() # you will start consume and start a server on http://localhost:8080# Change host and port with ASYNCWORKER_HTTP_HOST and ASYNCWORKER_HTTP_PORT env vars```### Build your own Hook#### Base Hook (Simple One)These hooks are called when message retreive, have success and fail.```pythonfrom barterdude.hooks import BaseHookfrom asyncworker.rabbitmq.message import RabbitMQMessageclass MyCounterHook(BaseHook):    _consume = _fail = _success = 0    async def on_success(self, message: RabbitMQMessage):        self._success += 1    async def on_fail(self, message: RabbitMQMessage, error: Exception):        self._fail += 1    async def before_consume(self, message: RabbitMQMessage):        self._consume += 1```#### Http Hook (Open Route)These hooks can do everything simple hook does, but responding to a route.```pythonfrom aiohttp import webfrom barterdude.hooks import HttpHookfrom asyncworker.rabbitmq.message import RabbitMQMessageclass MyCounterHttpHook(HttpHook):    _consume = _fail = _success = 0    async def __call__(self, req: web.Request):        return web.json_response(dict(            consumed=self._consume,            success=self._success,            fail=self._fail        ))    async def on_success(self, message: RabbitMQMessage):        self._success += 1    async def on_fail(self, message: RabbitMQMessage, error: Exception):        self._fail += 1    async def before_consume(self, message: RabbitMQMessage):        self._consume += 1```### Data SharingFollowing the approach found in [async-worker](https://b2wdigital.github.io/async-worker/userguide/asyncworker-app/storage.html) and in [aiohttp](https://docs.aiohttp.org/en/stable/web_advanced.html#data-sharing-aka-no-singletons-please),`BarterDude` discourages the use of global variables, aka singletons.To share data states globally in an application, `BarterDude` behaves like a `dict`.As an example, one can save a global-like variable in a  `BarterDude` instance:```pythonfrom barterdude import BarterDudebarterdude = BarterDude()baterdude[&quot;my_variable&quot;] = data```and get it back in a consumer```pythonasync def consumer_access_storage(msg):    data = baterdude[&quot;my_variable&quot;]```### Monitoring extra modules on HealthcheckIf you run extra modules on your application, like workers or services, you can include them in the healthcheck.First, you need to update your module to implement the interface `HealthcheckMonitored`:```pythonfrom barterdude.hooks.healthcheck import HealthcheckMonitoredclass ExtraService(HealthcheckMonitored):```Implementing that interface will require the definition of the method `healthcheck` in your module. It should return a boolean value indicating if your module is healhty or not:```python    def healthcheck(self):        return self._thread.is_alive()```Finally, you need to make the BarterDude and Healthcheck module be aware of your module. To do so, you'll use the Data Sharing feature:```pythonfrom barterdude import BarterDudefrom app.extra_service import ExtraServicebarterdude = BarterDude()barterdude[&quot;extra_service&quot;] = ExtraService()```If you are already running your extra modules on BartedDude startup using the data sharing model, it's all done:```python@app.run_on_startupasync def startup(app):    app[&quot;client_session&quot;] = ClientSession()    app[&quot;extra_service&quot;] = ExtraService()```The healthcheck module will identify all shared modules that implement the interface `HealthcheckMonitored` and run its healthcheck method automatically.The result of all monitored modules will be included in the result body of the healthcheck endpoint and if any of the modules fail, the healthcheck endpoint will indicate that:```json{    &quot;extra_service&quot;: &quot;ok&quot;,    &quot;message&quot;: &quot;Success rate: 1.0 (expected: 0.9)&quot;,    &quot;fail&quot;: 0,    &quot;success&quot;: 1,    &quot;status&quot;: &quot;ok&quot;}```### Schema ValidationConsumed messages can be validated by json schema:```python@barterdude.consume_amqp(    [&quot;queue1&quot;, &quot;queue2&quot;],    monitor,    validation_schema={            &quot;$schema&quot;: &quot;http://json-schema.org/draft-04/schema#&quot;,            &quot;$id&quot;: &quot;http://example.com/example.json&quot;,            &quot;type&quot;: &quot;object&quot;,            &quot;title&quot;: &quot;Message Schema&quot;,            &quot;description&quot;: &quot;The root schema comprises the entire JSON document.&quot;,            &quot;additionalProperties&quot;: True,            &quot;required&quot;: [                &quot;key&quot;            ],            &quot;properties&quot;: {                &quot;key&quot;: {                    &quot;$id&quot;: &quot;#/properties/key&quot;,                    &quot;type&quot;: &quot;string&quot;,                    &quot;title&quot;: &quot;The Key Schema&quot;,                    &quot;description&quot;: &quot;An explanation about message.&quot;,                    &quot;default&quot;: &quot;&quot;                }            }        },    requeue_on_validation_fail=False # invalid messages are removed without requeue)```You can still validate messages before produce them or when you want:```pythonfrom barterdude.message import MessageValidationvalidator = MessageValidation(json_schema)validator.validate(message)```### Data ProtectionBarterdude takes in account GDPR data protection and by default doesn't log message body, but you can deactivate with environment variable `BARTERDUDE_LOG_REDACTED=0`Now messages body will be logged by Logging hook.This configuration just controls BarterDude's default Logging Hook and doesn't have effect on user custom user log. If you want to control your log with this configuration use:```pythonfrom baterdude.conf import BARTERDUDE_LOG_REDACTED```## HTTP Endpoints### Simple endpointsIf you want to expose and HTTP endpoint, you can easily do that to your Barterdude worker by adding a route mapped to a hook.```pythonbarterdude.add_endpoint(    routes=[&quot;/some_hook&quot;],    methods=[&quot;GET&quot;],    hook=some_hook,)```### Barterdude's callback endpointYou can also expose an HTTP endpoint that calls the worker's callback to emulate a message being consumed and processed from a queue. This way you can make a request passing a body and header of a message and the response of this request will have all information of what the worker would do without really publishing the message.```pythonbarterdude.add_callback_endpoint(    routes=[&quot;/execute&quot;],    hook=execute,)```In order to use a mock instance of the barterdude object, you also need to modify the signature of your callback method to receive a optional argument for the barterdude mock. Then you'll have to choose which one to use. Only the callback endpoint calls will pass the barterdude object to your callback.```pythonasync def execute(rabbitmq_message: RabbitMQMessage, barterdude_arg=None):    bd = barterdude_arg if barterdude_arg is not None else barterdude```#### Request and response example:```json# Request{&quot;body&quot;: {&quot;list_id&quot;: 105515152},&quot;headers&quot;: {&quot;trace_id&quot;: &quot;random_id&quot;}}# Response{&quot;message_calls&quot;: [{&quot;method&quot;: &quot;accept&quot;,&quot;args&quot;: [],&quot;kwargs&quot;: {}}],&quot;barterdude_calls&quot;: [{&quot;method&quot;: &quot;publish_amqp&quot;,&quot;args&quot;: [],&quot;kwargs&quot;: {&quot;exchange&quot;: &quot;NEXT_EXCHANGE_TO_BE_CALLED&quot;,&quot;data&quot;: {&quot;list_id&quot;: 1055151521,&quot;subject&quot;: &quot;vendo samsung galaxy s21&quot;,&quot;timestamp&quot;: 1657231231000},&quot;properties&quot;: {&quot;headers&quot;: {&quot;has_failed&quot;: false,&quot;trace_id&quot;: &quot;random_id&quot;}}}}]}```### Side-effectsIf your callback has services with side-effects such as inserting a row in a database or updating an API, you can pass fake instances of these services that are going to be injected to prevent side-effects from happenning.```pythonbarterdude.add_callback_endpoint(    routes=[&quot;/execute&quot;],    hook=execute,    mock_dependencies=[        (            fake_database_service,  # fake service instance to be used by the worker            &quot;database_service&quot;,     # name used in the data sharing/dependency injection        ),    ])```#### Forcing side-effectsIf you want the message to be published when calling the callback endpoint, you can pass the parameter `should_mock_barterdude: false`. This way the message will be published. Also, you don't have to mock the services used by your worker, all side-effects will happen and you'll have your worker processing your message just like it would be when consuming from a queue.#### Request and response example:```json# Request{&quot;body&quot;: {&quot;list_id&quot;: 105515152},&quot;headers&quot;: {&quot;trace_id&quot;: &quot;random_id&quot;},        &quot;should_mock_barterdude&quot;: false}# Response{&quot;message_calls&quot;: [{&quot;method&quot;: &quot;accept&quot;,&quot;args&quot;: [],&quot;kwargs&quot;: {}}]    # message will be published, so we won't have information about publish method's calls}```## TestingTo test async consumers we recommend `asynctest` lib```pythonfrom asynctest import TestCaseclass TestMain(TestCase):    def test_should_pass(self):        self.assertTrue(True)```We hope you enjoy! :wink:## ContributeFor development and contributing, please follow [Contributing Guide](https://github.com/olxbr/BarterDude/blob/master/CONTRIBUTING.md) and **ALWAYS** respect the [Code of Conduct](https://github.com/olxbr/BarterDude/blob/master/CODE_OF_CONDUCT.md)</longdescription>
</pkgmetadata>