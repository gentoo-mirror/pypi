<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pymartiniA Cython port of [Martini][martini] for fast RTIN terrain mesh generation, 2-3xfaster than Martini in Node. The only dependency is Numpy.[![][image_url]][example][image_url]: https://raw.githubusercontent.com/kylebarron/pymartini/master/assets/grca_wireframe.jpg[example]: https://kylebarron.dev/quantized-mesh-encoderA wireframe rendering of the Grand Canyon. The mesh is created using`pymartini`, encoded using [`quantized-mesh-encoder`][quantized-mesh-encoder],served on-demand using [`dem-tiler`][dem-tiler], and rendered with[deck.gl](https://deck.gl).[quantized-mesh-encoder]: https://github.com/kylebarron/quantized-mesh-encoder[dem-tiler]: https://github.com/kylebarron/dem-tiler## InstallWith pip:```pip install pymartini```or with Conda:```conda install -c conda-forge pymartini```## Using### ExampleThe API is modeled after Martini.```pyfrom pymartini import Martini# set up mesh generator for a certain 2^k+1 grid size# Usually either 257 or 513martini = Martini(257)# generate RTIN hierarchy from terrain data (an array of size^2 length)tile = martini.create_tile(terrain)# get a mesh (vertices and triangles indices) for a 10m errorvertices, triangles = tile.get_mesh(10)```### APIThe `Martini` class and `create_tile` and `get_mesh` methods are a direct portfrom the JS Martini library.Additionally I include two helper functions: `decode_ele` to decode a MapboxTerrain RGB or Terrarium PNG array to elevations; and `rescale_positions`, whichadds elevations to each vertex and optionally linearly rescales each vertex's XYcoordinates to a new bounding box.#### `Martini`A class to instantiate constants needed for the `create_tile` and `get_mesh`steps. As noted in the benchmarks below, instantiating the `Martini` class isthe slowest of the three functions. If you're planning to create many meshes ofthe same size, create one `Martini` class and create many tiles from it.##### Arguments- `grid_size` (`int`, default `257`): the grid size to use when generating the  mesh. Must be 2^k+1. If your source heightmap is 256x256 pixels, use  `grid_size=257` and backfill the border pixels.##### ReturnsReturns a `Martini` instance on which you can call `create_tile`.#### `Martini.create_tile`Generate RTIN hierarchy from terrain data. This is faster than creating the`Martini` instance, but slower than creating a mesh for a given max error. Ifyou need to create many meshes with different errors for the same tile, youshould reuse a `Tile` instance.##### Arguments- `terrain` (numpy `ndarray`): an array of dtype `float32` representing the  input heightmap. The array can either be flattened, of shape (2^k+1 \* 2^k+1)  or a two-dimensional array of shape (2^k+1, 2^k+1). Note that for a 2D array  pymartini expects indices in (columns, rows) order, so you might need to  transpose your array first. Currently an error will be produced if the dtype  of your input array is not `np.float32`.##### ReturnsReturns a `Tile` instance on which you can call `get_mesh`.#### `Tile.get_mesh`Get a mesh for a given max error.##### Arguments- `max_error` (`float`, default `0`): the maximum vertical error for each  triangle in the output mesh. For example if the units of the input heightmap  is meters, using `max_error=5` would mean that the mesh is continually refined  until every triangle approximates the surface of the heightmap within 5  meters.##### ReturnsReturns a tuple of (`vertices`, `triangles`).Each is a flat numpy array. Vertices represents the interleaved **2D**coordinates of each vertex, e.g. `[x0, y0, x1, y1, ...]`. If you need 3Dcoordinates, you can use the `rescale_positions` helper function describedbelow.`triangles` represents _indices_ within the `vertices` array. So `[0, 1, 3, ...]` would use the first, second, and fourth vertices within the `vertices`array as a single triangle.#### `decode_ele`A helper function to decode a PNG terrain tile into elevations.##### Arguments- `png` (`np.ndarray`): Ndarray of elevations encoded in three channels,  representing red, green, and blue. Must be of shape (`tile_size`, `tile_size`,  `&gt;=3`) or (`&gt;=3`, `tile_size`, `tile_size`), where `tile_size` is usually 256  or 512- `encoding` (`str`): Either 'mapbox' or 'terrarium', the two main RGB  encodings for elevation values- `backfill` (`bool`, default `True`): Whether to create an array of size  (`tile_size + 1`, `tile_size + 1`), backfilling the bottom and right edges. This is used  because Martini needs a grid of size `2^n + 1`##### Returns- (`np.ndarray`) Array with decoded elevation values. If `backfill` is `True`,  returned shape is (`tile_size + 1`, `tile_size + 1`), otherwise returned shape  is (`tile_size`, `tile_size`), where `tile_size` is the shape of the input  array.##### Example```pyfrom imageio import imreadfrom pymartini import decode_elepath = './test/data/fuji.png'fuji = imread(path)terrain = decode_ele(fuji, 'mapbox')```#### `rescale_positions`A helper function to rescale the `vertices` output and add elevations. Theoutput is a numpy ndarray of the form `[[x1, y1, z1], [x2, y2, z2], ...]`.##### Arguments- `vertices`: (`np.array`) vertices output from Martini- `terrain`: (`np.ndarray`) 2d heightmap array of elevations as output by  `decode_ele`. Expected to have shape (`grid_size`, `grid_size`). **`terrain`  is expected to be the exact same array passed to `Martini.create_tile`.** If  you use a different or transposed array, the mesh will look weird. See  [#15](https://github.com/kylebarron/pymartini/issues/15). If you need to  transpose your array, do it before passing to `Martini.create_tile`.- `bounds`: (`List[float]`, default `None`) linearly rescale position values to  this extent, expected to be [minx, miny, maxx, maxy]. If not provided, no  rescaling is done- `flip_y`: (`bool`, default `False`) Flip y coordinates. Can be useful when  original data source is a PNG, since the origin of a PNG is the top left.##### Example```pyfrom imageio import imreadfrom pymartini import decode_ele, Martini, rescale_positionspath = './test/data/terrarium.png'png = imread(path)terrain = decode_ele(png, 'mapbox')martini = Martini(png.shape[0] + 1)tile = martini.create_tile(terrain)vertices, triangles = tile.get_mesh(10)# Use mercantile to find the bounds in WGS84 of this tileimport mercantilebounds = mercantile.bounds(mercantile.Tile(385, 803, 11))# Rescale positions to WGS84rescaled = rescale_positions(    vertices,    terrain,    bounds=bounds,    flip_y=True    column_row=True)```## `Martini` or `Delatin`?Two popular algorithms for terrain mesh generation are the **&quot;Martini&quot;**algorithm, found in the JavaScript [`martini`][martini] library and this Python`pymartini` library, and the **&quot;Delatin&quot;** algorithm, found in theC++ [`hmm`][hmm] library, the Python [`pydelatin`][pydelatin] library, and the JavaScript[`delatin`][delatin] library.Which to use?For most purposes, use `pydelatin` over `pymartini`. A good breakdown from [aMartini issue][martini_desc_issue]:&gt; Martini:&gt;&gt; - Only works on square 2^n+1 x 2^n+1 grids.&gt; - Generates a hierarchy of meshes (pick arbitrary detail after a single run)&gt; - Optimized for meshing speed rather than quality.&gt;&gt; Delatin:&gt;&gt; - Works on arbitrary raster grids.&gt; - Generates a single mesh for a particular detail.&gt; - Optimized for quality (as few triangles as possible for a given error).[hmm]: https://github.com/fogleman/hmm[pydelatin]: https://github.com/kylebarron/pydelatin[delatin]: https://github.com/mapbox/delatin[martini_desc_issue]: https://github.com/mapbox/martini/issues/15#issuecomment-700475731## Correctness`pymartini` passes the (only) test case included in the original Martini JSlibrary. I also wrote a few extra conformance tests to compare output by`pymartini` and Martini. I've found some small differences in float values atthe end of the second step.This second step, `martini.create_tile(terrain)`, computes the maximum error ofevery possible triangle and accumulates them. Thus, small float errors appear tobe magnified by the summation of errors into larger triangles. These errorsappear to be within `1e-5` of the JS output. I'm guessing that this variance isgreater than normal float rounding errors, due to this summation behavior.These differences are larger when using 512px tiles compared to 256px tiles,which reinforces my hypothesis that the differences have something to do withsmall low-level float or bitwise operations differences between Python andJavaScript.If you'd like to explore this in more detail, look at the `Tile.update()` in`martini.pyx` and the corresponding Martini code.## Type CheckingAs of `pymartini` 0.4.0, types are provided, which can be used with a checkerlike [`mypy`](https://mypy.readthedocs.io/). If you wish to get the fullbenefit, make sure to [enable Numpy's mypyplugin](https://numpy.org/devdocs/reference/typing.html#examples).## BenchmarkPreparation steps are about 3x faster in Python than in Node; generating themesh is about 2x faster in Python than in Node.### Python```bashgit clone https://github.com/kylebarron/pymartinicd pymartinipip install '.[test]'python bench.py``````init tileset: 14.860mscreate tile: 5.862msmesh (max_error=30): 1.010msvertices: 9700.0, triangles: 19078.0mesh 0: 18.350msmesh 1: 17.581msmesh 2: 15.245msmesh 3: 13.853msmesh 4: 11.284msmesh 5: 12.360msmesh 6: 8.293msmesh 7: 8.342msmesh 8: 7.166msmesh 9: 5.678msmesh 10: 5.886msmesh 11: 5.092msmesh 12: 3.732msmesh 13: 3.420msmesh 14: 3.524msmesh 15: 3.101msmesh 16: 2.892msmesh 17: 2.358msmesh 18: 2.250msmesh 19: 2.293msmesh 20: 2.281ms20 meshes total: 155.559ms```### JS (Node)```bashgit clone https://github.com/mapbox/martinicd martininpm installnode -r esm bench.js``````init tileset: 54.293mscreate tile: 17.307msmesh: 6.230msvertices: 9704, triangles: 19086mesh 0: 43.181msmesh 1: 33.102msmesh 2: 30.735msmesh 3: 25.935msmesh 4: 20.643msmesh 5: 17.511msmesh 6: 15.066msmesh 7: 13.334msmesh 8: 11.180msmesh 9: 9.651msmesh 10: 9.240msmesh 11: 10.996msmesh 12: 7.520msmesh 13: 6.617msmesh 14: 5.860msmesh 15: 5.693msmesh 16: 4.907msmesh 17: 4.469msmesh 18: 4.267msmesh 19: 4.267msmesh 20: 3.619ms20 meshes total: 290.256ms```## LicenseThis library is ported from Mapbox's [Martini][martini], which is licensed underthe ISC License. My additions are licensed under the MIT license.ISC LicenseCopyright (c) 2019, MapboxPermission to use, copy, modify, and/or distribute this software for any purposewith or without fee is hereby granted, provided that the above copyright noticeand this permission notice appear in all copies.THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITHREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY ANDFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSSOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHERTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OFTHIS SOFTWARE.[martini]: https://github.com/mapbox/martini</longdescription>
</pkgmetadata>