<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Build Status](https://travis-ci.com/AtakamaLLC/cloudsync.svg?branch=master&amp;token=WD7aozR2wQ3ePGe1QpA8)](https://travis-ci.com/AtakamaLLC/cloudsync)[![Code Coverage](https://codecov.io/gh/AtakamaLLC/cloudsync/branch/master/graph/badge.svg)](https://codecov.io/gh/AtakamaLLC/cloudsync)# cloudsync READMEPython Cloud Synchronization Library## Installation```bashpip install cloudsync# install provider supportpip install cloudsync-gdrive```## Links*   [Documentation](https://atakama-llc-cloudsync.readthedocs-hosted.com/en/latest/)*   [Source Code + Issue Tracker](https://github.com/AtakamaLLC/cloudsync)## Command-line Example```bashcloudsync sync --helpcloudsync sync file:c:/users/me/documents gdrive:/mydocs# on linux you can pass -D for 'daemon mode', which will detatch and run in the background```## Example of a single cloud provider integration```pythonimport cloudsync# Get a generic client_id and client_secret. Do not use this in production code.# For more information on getting your own client_id and client_secret, see README_OAUTH.mdoauth_config = cloudsync.command.utils.generic_oauth_config('gdrive')# get an instance of the gdrive provider classprovider = cloudsync.create_provider('gdrive', oauth_config=oauth_config)# Start the oauth process to login in to the cloud providercreds = provider.authenticate()# Use the credentials to connect to the cloud providerprovider.connect(creds)# Perform cloud operationsfor entry in provider.listdir_path(&quot;/&quot;):    print(entry.path)```## Example of a syncronization between two cloud providers```pythonimport cloudsyncimport tempfileimport time# a little setuplocal_root = tempfile.mkdtemp()remote_root = &quot;/cloudsync_test/&quot; + time.strftime(&quot;%Y%m%d%H%M&quot;)provider_name = 'gdrive'print(&quot;syncronizing between %s locally and %s on %s&quot; % (local_root, remote_root, provider_name))# Get a generic client_id and client_secret. Do not use this in production code.# For more information on getting your own client_id and client_secret, see README_OAUTH.mdcloud_oauth_config = cloudsync.command.utils.generic_oauth_config(provider_name)# get instances of the local file provider and cloud provider from the provider factorylocal = cloudsync.create_provider(&quot;filesystem&quot;)remote = cloudsync.create_provider(provider_name, oauth_config=cloud_oauth_config)# Authenticate with the remote provider using OAuthcreds = remote.authenticate()# Connect with the credentials acquired by authenticating with the providerlocal.namespace = local_root  # filesystem provider wants to know the root namespace before connectinglocal.connect(None)remote.connect(creds)# Create the folder on google drive to syncronize locallyprint(&quot;Creating folder %s on %s&quot; % (remote_root, provider_name))remote.mkdirs(remote_root)  # provider.mkdirs() will automatically create any necessary parent folders# Specify which folders to syncronizesync_roots = (local_root, remote_root)# instantiate a new sync engine and start syncingsync = cloudsync.CloudSync((local, remote), roots=sync_roots)sync.start()# should sync this file as soon as it's noticed by watchdoglocal_hello_path = local.join(local_root, &quot;hello.txt&quot;)print(&quot;Creating local file %s&quot; % local_hello_path)with open(local_hello_path, &quot;w&quot;) as f:    f.write(&quot;hello&quot;)# note remote.join, NOT os.path.join... Gets the path separator correctremote_hello_path = remote.join(remote_root, &quot;hello.txt&quot;)# wait for sync to upload the new file to the cloudwhile not remote.exists_path(remote_hello_path):    time.sleep(1)remote_hello_info = remote.info_path(remote_hello_path)# rename in the cloudlocal_goodbye_path = local.join(local_root, &quot;goodbye.txt&quot;)remote_goodbye_path = remote.join(remote_root, &quot;goodbye.txt&quot;)print(&quot;renaming %s to %s on %s&quot; % (remote_hello_path, remote_goodbye_path, provider_name))remote.rename(remote_hello_info.oid, remote_goodbye_path)  # rename refers to the file to rename by oid# wait for sync to cause the file to get renamed locallywhile not local.exists_path(local_goodbye_path):    time.sleep(1)print(&quot;synced&quot;)sync.stop(forever=True)local.disconnect()remote.disconnect()```</longdescription>
</pkgmetadata>