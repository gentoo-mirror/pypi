<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;!-- Copyright (c) 2023 Anthony Mugendi  This software is released under the MIT License. https://opensource.org/licenses/MIT--&gt;# ClassworkThis is a simple Python module to help distribute you tasks across multiple brokers as microservices.Classwork uses [NATS](https://nats.io/) to manage communication between job schedulers and workers. Nats does most of the heavy lifting, allowing us to keep the rest of the code simple and concise.## What is in name?So why ClassWork? Well, this is simply because workers are simply **&quot;python classes&quot;** (The Class) whose **&quot;methods&quot;** become individual workers (The Students). ## Get startedFirst let us create a simple worker```pythonimport asynciofrom classwork import ClassWorkclass WorkerClass:    # Your worker...    # Notice that we expect workers to be async    async def add(self, a, b):        # the work!        resp = a + b        # simulate a long process        await asyncio.sleep(3)        # return results        return resp# this is our nats server urlnats_url = &quot;nats://127.0.0.1:4222&quot;# initialize ClassWorkclass_work = ClassWork(nats_url=nats_url)# init worker classworker = WorkerClass()# Ok, let us register things with asyncio# notice the method 'class_work.register' is async!asyncio.run(class_work.register(name=&quot;my-worker&quot;, worker_class=worker))```This is all the code we need to set up the worker.It is important to note the following:1. Worker Class methods should be asynchronous2. class_work.register is also async3. You will need NATS running with [JetStream](https://docs.nats.io/nats-concepts/jetstream) enabled!## The Job SchedulerNow we need to create the job scheduler. Below is the code we need```pythonimport asyncioimport numpy as npfrom pprint import pprintfrom classwork import ClassWork# init ClassWorknats_url = &quot;nats://127.0.0.1:4222&quot;class_work = ClassWork(nats_url=nats_url)# Our callback function# This is where complete work gets reportedasync def report_callback(report_card):    print(&quot;We have a report!&quot;)    pprint(report_card)# We need this function to create our job schedulesasync def schedules():    # Assign a job    await class_work.assign(        # the task name        task=&quot;my_worker.add&quot;,        # arguments        args=[1, 2],        # the callback to report our results        report_callback=report_callback,    )# Ok, let us create the schedules nowasyncio.run(schedules())```This code will create a *task* into NATS and the job workers (attentive students ðŸ˜‚) already listening will pick the task and run it, then publish their reports which is routed via NATS back to the scheduler (teacher?).Take note of the following:1. `class_work.assign` must be run in async mode. So we have wrapped it in an async method. You can also use `asyncio.run` directly.2. Naming your task is very important. This naming convection is unashamedly borrowed from [moleculer](https://moleculer.services/). In this case, your task is **&quot;my_worker.add&quot;**. This will route to any worker class registered with the **name** &quot;my_worker&quot; and method &quot;add&quot;. 3. Because all this traffic is routed via NATS, your arguments must be JSON serializable. Even though we use [typ](https://github.com/vsapronov/typjson) to handle edge cases like `sets`, beware that there are limits to what you can pass in your arguments4. `report_callback` must be async. It is called with a 'report' of your task. A report card ðŸ˜Š will look like the one below:5. `args` can be passed as a list or dict. They will be treated as `*args` if list and `**kwargs` if dict.```We have a report!{'task': 'my_worker.add', 'duration': {'latency': {'request': '4 ms and 356 Âµs',                          'response': '5 s and 4 ms'},              'my_worker.add': '3 s and 1 ms'}, 'req_id': '8mYjJjM0kb5', 'response': 3}```## Report Explanation- **duration:** is a high precision (down to yoctoseconds) report of the time taken.    - **latency:** shows the time taken to route your &quot;task **request**&quot; to the worker and &quot;task **response**&quot; back to the scheduler. It is important to understand that since both worker and scheduler are disconnected, latency may also include delays of either to access the NATS network and thus does not specifically refer to network latency.- **req_id:** is a unique id assigned to each job- **response:** is the actual value returned by the worker## Try itWe have sample code in [scheduler.py](scheduler.py) and [worker.py](worker.py)</longdescription>
</pkgmetadata>