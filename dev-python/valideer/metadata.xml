<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>========Valideer========.. image:: https://travis-ci.org/podio/valideer.svg?branch=master    :target: https://travis-ci.org/podio/valideer.. image:: https://coveralls.io/repos/podio/valideer/badge.svg?branch=master    :target: https://coveralls.io/r/podio/valideer?branch=master.. image:: https://pypip.in/status/valideer/badge.svg    :target: https://pypi.python.org/pypi/valideer/.. image:: https://pypip.in/version/valideer/badge.svg    :target: https://pypi.python.org/pypi/valideer/.. image:: https://pypip.in/py_versions/valideer/badge.svg    :target: https://pypi.python.org/pypi/valideer/.. image:: https://pypip.in/license/valideer/badge.svg    :target: https://pypi.python.org/pypi/valideer/Lightweight data validation and adaptation library for Python.**At a Glance**:- Supports both validation (check if a value is valid) and adaptation (convert  a valid input to an appropriate output).- Succinct: validation schemas can be specified in a declarative and extensible  mini &quot;language&quot;; no need to define verbose schema classes upfront. A regular  Python API is also available if the compact syntax is not your cup of tea.- Batteries included: validators for most common types are included out of the box.- Extensible: New custom validators and adaptors can be easily defined and  registered.- Informative, customizable error messages: Validation errors include the reason  and location of the error.- Agnostic: not tied to any particular framework or application domain (e.g.  Web form validation).- Well tested: Extensive test suite with 100% coverage.- Production ready: Used for validating every access to the `Podio API`_.- Licence: MIT.Installation------------To install run::    pip install valideerOr for the latest version::    git clone git@github.com:podio/valideer.git    cd valideer    python setup.py installYou may run the unit tests with::    $ python setup.py test --quiet    running test    running egg_info    writing dependency_links to valideer.egg-info/dependency_links.txt    writing requirements to valideer.egg-info/requires.txt    writing valideer.egg-info/PKG-INFO    writing top-level names to valideer.egg-info/top_level.txt    reading manifest file 'valideer.egg-info/SOURCES.txt'    reading manifest template 'MANIFEST.in'    writing manifest file 'valideer.egg-info/SOURCES.txt'    running build_ext    ...........................................................................................................................................................................    ----------------------------------------------------------------------    Ran 171 tests in 0.106s    OKBasic Usage-----------We'll demonstrate ``valideer`` using the following `JSON schema example`_::{    &quot;name&quot;: &quot;Product&quot;,    &quot;properties&quot;: {        &quot;id&quot;: {            &quot;type&quot;: &quot;number&quot;,            &quot;description&quot;: &quot;Product identifier&quot;,            &quot;required&quot;: true        },        &quot;name&quot;: {            &quot;type&quot;: &quot;string&quot;,            &quot;description&quot;: &quot;Name of the product&quot;,            &quot;required&quot;: true        },        &quot;price&quot;: {            &quot;type&quot;: &quot;number&quot;,            &quot;minimum&quot;: 0,            &quot;required&quot;: true        },        &quot;tags&quot;: {            &quot;type&quot;: &quot;array&quot;,            &quot;items&quot;: {                &quot;type&quot;: &quot;string&quot;            }        },        &quot;stock&quot;: {            &quot;type&quot;: &quot;object&quot;,            &quot;properties&quot;: {                &quot;warehouse&quot;: {                    &quot;type&quot;: &quot;number&quot;                },                &quot;retail&quot;: {                    &quot;type&quot;: &quot;number&quot;                }            }        }    }}This can be specified by passing a similar but less verbose structure to the``valideer.parse`` function::&gt;&gt;&gt; import valideer as V&gt;&gt;&gt; product_schema = {&gt;&gt;&gt;     &quot;+id&quot;: &quot;number&quot;,&gt;&gt;&gt;     &quot;+name&quot;: &quot;string&quot;,&gt;&gt;&gt;     &quot;+price&quot;: V.Range(&quot;number&quot;, min_value=0),&gt;&gt;&gt;     &quot;tags&quot;: [&quot;string&quot;],&gt;&gt;&gt;     &quot;stock&quot;: {&gt;&gt;&gt;         &quot;warehouse&quot;: &quot;number&quot;,&gt;&gt;&gt;         &quot;retail&quot;: &quot;number&quot;,&gt;&gt;&gt;     }&gt;&gt;&gt; }&gt;&gt;&gt; validator = V.parse(product_schema)``parse`` returns a ``Validator`` instance, which can be then used to validateor adapt values.Validation##########To check if an input is valid call the ``is_valid`` method::&gt;&gt;&gt; product1 = {&gt;&gt;&gt;     &quot;id&quot;: 1,&gt;&gt;&gt;     &quot;name&quot;: &quot;Foo&quot;,&gt;&gt;&gt;     &quot;price&quot;: 123,&gt;&gt;&gt;     &quot;tags&quot;: [&quot;Bar&quot;, &quot;Eek&quot;],&gt;&gt;&gt;     &quot;stock&quot;: {&gt;&gt;&gt;         &quot;warehouse&quot;: 300,&gt;&gt;&gt;         &quot;retail&quot;: 20&gt;&gt;&gt;     }&gt;&gt;&gt; }&gt;&gt;&gt; validator.is_valid(product1)True&gt;&gt;&gt; product2 = {&gt;&gt;&gt;     &quot;id&quot;: 1,&gt;&gt;&gt;     &quot;price&quot;: 123,&gt;&gt;&gt; }&gt;&gt;&gt; validator.is_valid(product2)FalseAnother option is the ``validate`` method. If the input is invalid, it raises``ValidationError``::&gt;&gt;&gt; validator.validate(product2)ValidationError: Invalid value {'price': 123, 'id': 1} (dict): missing required properties: ['name']For the common use case of validating inputs when entering a function, the``@accepts`` decorator provides some nice syntax sugar (shamelessly stolen fromtypecheck_)::&gt;&gt;&gt; from valideer import accepts&gt;&gt;&gt; @accepts(product=product_schema, quantity=&quot;integer&quot;)&gt;&gt;&gt; def get_total_price(product, quantity=1):&gt;&gt;&gt;     return product[&quot;price&quot;] * quantity&gt;&gt;&gt;&gt;&gt;&gt; get_total_price(product1, 2)246&gt;&gt;&gt; get_total_price(product1, 0.5)ValidationError: Invalid value 0.5 (float): must be integer (at quantity)&gt;&gt;&gt; get_total_price(product2)ValidationError: Invalid value {'price': 123, 'id': 1} (dict): missing required properties: ['name'] (at product)Adaptation##########Often input data have to be converted from their original form before they areready to use; for example a number that may arrive as integer or string andneeds to be adapted to a float. Since validation and adaptation usually happensimultaneously, ``validate`` returns the adapted version of the (valid) inputby default.An existing class can be easily used as an adaptor by being wrapped in ``AdaptTo``::&gt;&gt;&gt; import valideer as V&gt;&gt;&gt; adapt_prices = V.parse({&quot;prices&quot;: [V.AdaptTo(float)]}).validate&gt;&gt;&gt; adapt_prices({&quot;prices&quot;: [&quot;2&quot;, &quot;3.1&quot;, 1]}){'prices': [2.0, 3.1, 1.0]}&gt;&gt;&gt; adapt_prices({&quot;prices&quot;: [&quot;2&quot;, &quot;3f&quot;]})ValidationError: Invalid value '3f' (str): invalid literal for float(): 3f (at prices[1])&gt;&gt;&gt; adapt_prices({&quot;prices&quot;: [&quot;2&quot;, 1, None]})ValidationError: Invalid value None (NoneType): float() argument must be a string or a number (at prices[2])Similar to ``@accepts``, the ``@adapts`` decorator provides a convenient syntaxfor adapting function inputs::&gt;&gt;&gt; from valideer import adapts&gt;&gt;&gt; @adapts(json={&quot;prices&quot;: [AdaptTo(float)]})&gt;&gt;&gt; def get_sum_price(json):&gt;&gt;&gt;     return sum(json[&quot;prices&quot;])&gt;&gt;&gt; get_sum_price({&quot;prices&quot;: [&quot;2&quot;, &quot;3.1&quot;, 1]})6.1&gt;&gt;&gt; get_sum_price({&quot;prices&quot;: [&quot;2&quot;, &quot;3f&quot;]})ValidationError: Invalid value '3f' (str): invalid literal for float(): 3f (at json['prices'][1])&gt;&gt;&gt; get_sum_price({&quot;prices&quot;: [&quot;2&quot;, 1, None]})ValidationError: Invalid value None (NoneType): float() argument must be a string or a number (at json['prices'][2])Required and optional object properties#######################################By default object properties are considered optional unless they start with &quot;+&quot;.This default can be inverted by using the ``parsing`` context manager with``required_properties=True``. In this case object properties are consideredrequired by default unless they start with &quot;?&quot;. For example::validator = V.parse({    &quot;+name&quot;: &quot;string&quot;,    &quot;duration&quot;: {        &quot;+hours&quot;: &quot;integer&quot;,        &quot;+minutes&quot;: &quot;integer&quot;,        &quot;seconds&quot;: &quot;integer&quot;    }})is equivalent to::    with V.parsing(required_properties=True):    validator = V.parse({        &quot;name&quot;: &quot;string&quot;,        &quot;?duration&quot;: {            &quot;hours&quot;: &quot;integer&quot;,            &quot;minutes&quot;: &quot;integer&quot;,            &quot;?seconds&quot;: &quot;integer&quot;        }    })Ignoring optional object property errors########################################By default an invalid object property value raises ``ValidationError``,regardless of whether it's required or optional. It is possible to ignore invalidvalues for optional properties by using the ``parsing`` context manager with``ignore_optional_property_errors=True``::    &gt;&gt;&gt; schema = {    ...     &quot;+name&quot;: &quot;string&quot;,    ...     &quot;price&quot;: &quot;number&quot;,    ... }    &gt;&gt;&gt; data = {&quot;name&quot;: &quot;wine&quot;, &quot;price&quot;: &quot;12.50&quot;}    &gt;&gt;&gt; V.parse(schema).validate(data)    valideer.base.ValidationError: Invalid value '12.50' (str): must be number (at price)    &gt;&gt;&gt; with V.parsing(ignore_optional_property_errors=True):    ...     print V.parse(schema).validate(data)    {'name': 'wine'}Additional object properties############################Any properties that are not specified as either required or optional are allowedby default. This default can be overriden by calling ``parsing`` with``additional_properties=``- ``False`` to disallow all additional properties- ``Object.REMOVE`` to remove all additional properties from the adapted value- any validator or parseable schema to validate all additional property  values using this schema::&gt;&gt;&gt; schema = {&gt;&gt;&gt;     &quot;name&quot;: &quot;string&quot;,&gt;&gt;&gt;     &quot;duration&quot;: {&gt;&gt;&gt;         &quot;hours&quot;: &quot;integer&quot;,&gt;&gt;&gt;         &quot;minutes&quot;: &quot;integer&quot;,&gt;&gt;&gt;     }&gt;&gt;&gt; }&gt;&gt;&gt; data = {&quot;name&quot;: &quot;lap&quot;, &quot;duration&quot;: {&quot;hours&quot;:3, &quot;minutes&quot;:33, &quot;seconds&quot;: 12}}&gt;&gt;&gt; V.parse(schema).validate(data){'duration': {'hours': 3, 'minutes': 33, 'seconds': 12}, 'name': 'lap'}&gt;&gt;&gt; with V.parsing(additional_properties=False):...    V.parse(schema).validate(data)ValidationError: Invalid value {'hours': 3, 'seconds': 12, 'minutes': 33} (dict): additional properties: ['seconds'] (at duration)&gt;&gt;&gt; with V.parsing(additional_properties=V.Object.REMOVE):...    print V.parse(schema).validate(data){'duration': {'hours': 3, 'minutes': 33}, 'name': 'lap'}&gt;&gt;&gt; with V.parsing(additional_properties=&quot;string&quot;):...    V.parse(schema).validate(data)ValidationError: Invalid value 12 (int): must be string (at duration['seconds'])Explicit Instantiation######################The usual way to create a validator is by passing an appropriate nested structureto ``parse``, as outlined above.  This enables concise schema definitions withminimal boilerplate. In case this seems too cryptic or &quot;unpythonic&quot; for yourtaste, a validator can be also created explicitly from regular Python classes::&gt;&gt;&gt; from valideer import Object, HomogeneousSequence, Number, String, Range&gt;&gt;&gt; validator = Object(&gt;&gt;&gt;     required={&gt;&gt;&gt;         &quot;id&quot;: Number(),&gt;&gt;&gt;         &quot;name&quot;: String(),&gt;&gt;&gt;         &quot;price&quot;: Range(Number(), min_value=0),&gt;&gt;&gt;     },&gt;&gt;&gt;     optional={&gt;&gt;&gt;         &quot;tags&quot;: HomogeneousSequence(String()),&gt;&gt;&gt;         &quot;stock&quot;: Object(&gt;&gt;&gt;             optional={&gt;&gt;&gt;                 &quot;warehouse&quot;: Number(),&gt;&gt;&gt;                 &quot;retail&quot;: Number(),&gt;&gt;&gt;             }&gt;&gt;&gt;         )&gt;&gt;&gt;     }&gt;&gt;&gt; )Built-in Validators-------------------``valideer`` comes with several predefined validators, each implemented as a``Validator`` subclass. As shown above, some validator classes also support ashortcut form that can be used to specify implicitly a validator instance.Basic#####* ``valideer.Boolean()``: Accepts ``bool`` instances.  :Shortcut: ``&quot;boolean&quot;``* ``valideer.Integer()``: Accepts integers (``numbers.Integral`` instances),  excluding ``bool``.  :Shortcut: ``&quot;integer&quot;``* ``valideer.Number()``: Accepts numbers (``numbers.Number`` instances),  excluding ``bool``.  :Shortcut: ``&quot;number&quot;``* ``valideer.Date()``: Accepts ``datetime.date`` instances.  :Shortcut: ``&quot;date&quot;``* ``valideer.Time()``: Accepts ``datetime.time`` instances.  :Shortcut: ``&quot;time&quot;``* ``valideer.Datetime()``: Accepts ``datetime.datetime`` instances.  :Shortcut: ``&quot;datetime&quot;``* ``valideer.String(min_length=None, max_length=None)``: Accepts strings  (``basestring`` instances).  :Shortcut: ``&quot;string&quot;``* ``valideer.Pattern(regexp)``: Accepts strings that match the given regular  expression.  :Shortcut: *Compiled regular expression** ``valideer.Condition(predicate, traps=Exception)``: Accepts values for which  ``predicate(value)`` is true. Any raised exception that is instance of ``traps``  is re-raised as a ``ValidationError``.  :Shortcut: *Python function or method*.* ``valideer.Type(accept_types=None, reject_types=None)``: Accepts instances of  the given ``accept_types`` but excluding instances of ``reject_types``.  :Shortcut: *Python type*. For example ``int`` is equivalent to ``valideer.Type(int)``.* ``valideer.Enum(values)``: Accepts a fixed set of values.  :Shortcut: *N/A*Containers##########* ``valideer.HomogeneousSequence(item_schema=None, min_length=None, max_length=None)``:  Accepts sequences (``collections.Sequence`` instances excluding strings) with  elements that are valid for ``item_schema`` (if specified) and length between  ``min_length`` and ``max_length`` (if specified).  :Shortcut: [*item_schema*]* ``valideer.HeterogeneousSequence(*item_schemas)``: Accepts fixed length  sequences (``collections.Sequence`` instances excluding strings) where the  ``i``-th element is valid for the ``i``-th ``item_schema``.  :Shortcut: (*item_schema*, *item_schema*, ..., *item_schema*)* ``valideer.Mapping(key_schema=None, value_schema=None)``: Accepts mappings  (``collections.Mapping`` instances) with keys that are valid for ``key_schema``  (if specified) and values that are valid for ``value_schema`` (if specified).  :Shortcut: *N/A** ``valideer.Object(optional={}, required={}, additional=True)``: Accepts JSON-like  objects (``collections.Mapping`` instances with string keys). Properties that  are specified as ``optional`` or ``required`` are validated against the respective  value schema. Any additional properties are either allowed (if ``additional``  is True), disallowed (if ``additional`` is False) or validated against the  ``additional`` schema.  :Shortcut: {&quot;*property*&quot;: *value_schema*, &quot;*property*&quot;: *value_schema*, ...,    &quot;*property*&quot;: *value_schema*}. Properties that start with ``'+'``    are required, the rest are optional and additional properties are    allowed.Adaptors########* ``valideer.AdaptBy(adaptor, traps=Exception)``: Adapts a value by calling  ``adaptor(value)``. Any raised exception that is instance of ``traps`` is  wrapped into a ``ValidationError``.  :Shortcut: *N/A** ``valideer.AdaptTo(adaptor, traps=Exception, exact=False)``: Similar to  ``AdaptBy`` but for types. Any value that is already instance of ``adaptor``  is returned as is, otherwise it is adapted by calling ``adaptor(value)``. If  ``exact`` is ``True``, instances of ``adaptor`` subclasses are also adapted.  :Shortcut: *N/A*Composite#########* ``valideer.Nullable(schema, default=None)``: Accepts values that are valid for  ``schema`` or ``None``. ``default`` is returned as the adapted value of ``None``.  ``default`` can also be a zero-argument callable, in which case the adapted  value of ``None`` is ``default()``.  :Shortcut: &quot;?{*validator_name*}&quot;. For example ``&quot;?integer&quot;`` accepts any integer   or ``None`` value.* ``valideer.NonNullable(schema=None)``: Accepts values that are valid for  ``schema`` (if specified) except for ``None``.  :Shortcut: &quot;+{*validator_name*}&quot;* ``valideer.Range(schema, min_value=None, max_value=None)``: Accepts values that  are valid for ``schema`` and within the given ``[min_value, max_value]`` range.  :Shortcut: *N/A** ``valideer.AnyOf(*schemas)``: Accepts values that are valid for at least one  of the given ``schemas``.  :Shortcut: *N/A** ``valideer.AllOf(*schemas)``: Accepts values that are valid for all the given  ``schemas``.  :Shortcut: *N/A** ``valideer.ChainOf(*schemas)``: Passes values through a chain of validator and  adaptor ``schemas``.  :Shortcut: *N/A*User Defined Validators-----------------------The set of predefined validators listed above can be easily extended with userdefined validators. All you need to do is extend ``Validator`` (or a moreconvenient subclass) and implement the ``validate`` method. Here is an exampleof a custom validator that could be used to enforce minimal password strength::from valideer import String, ValidationErrorclass Password(String):    name = &quot;password&quot;    def __init__(self, min_length=6, min_lower=1, min_upper=1, min_digits=0):        super(Password, self).__init__(min_length=min_length)        self.min_lower = min_lower        self.min_upper = min_upper        self.min_digits = min_digits    def validate(self, value, adapt=True):        super(Password, self).validate(value)        if len(filter(str.islower, value)) &lt; self.min_lower:            raise ValidationError(&quot;At least %d lowercase characters required&quot; % self.min_lower)        if len(filter(str.isupper, value)) &lt; self.min_upper:            raise ValidationError(&quot;At least %d uppercase characters required&quot; % self.min_upper)        if len(filter(str.isdigit, value)) &lt; self.min_digits:            raise ValidationError(&quot;At least %d digits required&quot; % self.min_digits)        return valueA few notes:* The optional ``name`` class attribute creates a shortcut for referring to a  default instance of the validator. In this example the string ``&quot;password&quot;``  becomes an alias to a ``Password()`` instance.* ``validate`` takes an optional boolean ``adapt`` parameter that defaults to  ``True``. If it is ``False``, the validator is allowed to skip adaptation and  perform validation only. This is basically an optimization hint that can be  useful if adaptation happens to be significantly more expensive than validation.  This isn't common though and so ``adapt`` is usually ignored.Shortcut Registration#####################Setting a ``name`` class attribute is the simplest way to create a validatorshortcut. A shortcut can also be created explicitly with the ``valideer.register``function::&gt;&gt;&gt; import valideer as V&gt;&gt;&gt; V.register(&quot;strong_password&quot;, Password(min_length=8, min_digits=1))&gt;&gt;&gt; is_fair_password = V.parse(&quot;password&quot;).is_valid&gt;&gt;&gt; is_strong_password = V.parse(&quot;strong_password&quot;).is_valid&gt;&gt;&gt; for pwd in &quot;passwd&quot;, &quot;Passwd&quot;, &quot;PASSWd&quot;, &quot;Pas5word&quot;:&gt;&gt;&gt;     print (pwd, is_fair_password(pwd), is_strong_password(pwd))('passwd', False, False)('Passwd', True, False)('PASSWd', True, False)('Pas5word', True, True)Finally it is possible to parse arbitrary Python objects as validator shortcuts.For example let's define a ``Not`` composite validator, a validator that acceptsa value if and only if it is rejected by another validator::class Not(Validator):    def __init__(self, schema):        self._validator = Validator.parse(schema)    def validate(self, value, adapt=True):        if self._validator.is_valid(value):            raise ValidationError(&quot;Should not be a %s&quot; % self._validator.__class__.__name__, value)        return valueIf we'd like to parse ``'!foo'`` strings as a shortcut for ``Not('foo')``, wecan do so with the ``valideer.register_factory`` decorator::&gt;&gt;&gt; @V.register_factory&gt;&gt;&gt; def NotFactory(obj):&gt;&gt;&gt;     if isinstance(obj, basestring) and obj.startswith(&quot;!&quot;):&gt;&gt;&gt;         return Not(obj[1:])&gt;&gt;&gt;&gt;&gt;&gt; validate = V.parse({&quot;i&quot;: &quot;integer&quot;, &quot;s&quot;: &quot;!number&quot;}).validate&gt;&gt;&gt; validate({&quot;i&quot;: 4, &quot;s&quot;: &quot;&quot;}){'i': 4, 's': ''}&gt;&gt;&gt; validate({&quot;i&quot;: 4, &quot;s&quot;: 1.2})ValidationError: Invalid value 1.2 (float): Should not be a Number (at s).. _valideer: https://github.com/podio/valideer.. _JSON Schema: https://tools.ietf.org/html/draft-zyp-json-schema-03.. _Podio API: https://developers.podio.com.. _nose: http://pypi.python.org/pypi/nose.. _coverage: http://pypi.python.org/pypi/coverage.. _JSON schema example: http://en.wikipedia.org/wiki/JSON#Schema.. _typecheck: http://pypi.python.org/pypi/typecheck</longdescription>
</pkgmetadata>