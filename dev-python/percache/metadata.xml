<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>percache========*percache* is a Python module to persistently cache results of functions(or callables in general) using decorators.It is somehow similar to the [MemoizeExample](http://wiki.python.org/moin/PythonDecoratorLibrary#Memoize)from the Python Decorator Library but with the advantage that resultsare stored *persistently* in a cache. *percache* provides memoizationacross multiple invocations of the Python interpreter.*percache* requires Python 3. Install with `pip install percache`. Ithas no dependencies outside the standard library.[![image](https://builds.sr.ht/~obensonne/percache.svg?search=0.4.4)](https://builds.sr.ht/~obensonne/percache?search=0.4.4)Example-------    &gt;&gt;&gt; import percache    &gt;&gt;&gt; cache = percache.Cache(&quot;/tmp/my-cache&quot;)    &gt;&gt;&gt;    &gt;&gt;&gt; @cache    ... def longtask(a, b):    ...     print(&quot;running a long task&quot;)    ...     return a + b    ...    &gt;&gt;&gt; longtask(1, 2)    running a long task    3    &gt;&gt;&gt;    &gt;&gt;&gt; longtask(1, 2)    3    &gt;&gt;&gt; cache.close() # writes new cached results to diskAs you can see at the missing output after the second invocation,`longtask` has been called once only. The second time the result isretrieved from the cache. *The key feature of this module is that thisworks across multiple invocations of the Python interpreter.*A requirement on the results to cache is that they are[pickable](http://docs.python.org/library/pickle.html#what-can-be-pickled-and-unpickled).Each cache file can be used for any number of differently namedcallables.### Alternative back-ends and live synchronizationBy default *percache* uses a[shelve](http://docs.python.org/library/shelve.html) as its cacheback-end. Alternative back-ends may be used if they are given asdictionary-like objects with a `close()` and `sync()` method:```python&gt;&gt;&gt; class FooCache(dict):...     def sync(self):...         ......     def close(self):...         ...&gt;&gt;&gt; fc = FooCache()&gt;&gt;&gt; cache = percache.Cache(fc, livesync=True)```In this example a cache is created in live-sync mode, i.e. results*immediately* are stored permanently. Normally this happens not until acache's `close()` method has been called or until it gets[finalized](). Note that the live-sync mode may slow down yourpercache-decorated functions (though it reduces the risk of &quot;loosing&quot;results).Caching details (you should know)---------------------------------When caching the result of a callable, a SHA1 hash based on thecallable's name and arguments is used as a key to store the result inthe cache file.The hash calculation does not work directly with the arguments but withtheir *representations*, i.e. the string returned by applying `repr()`.Argument representations are supposed to differentiate valuessufficiently for the purpose of the function but identically acrossmultiple invocations of the Python interpreter. By default the built-infunction `repr()` is used to get argument representations. This is justperfect for basic types, lists, tuples and combinations of them but itmay fail on other types:```python&gt;&gt;&gt; repr(42)42                                  # good&gt;&gt;&gt; repr([&quot;a&quot;, &quot;b&quot;, (1, 2L)])&quot;['a', 'b', (1, 2L)]&quot;               # good&gt;&gt;&gt; o = object()&gt;&gt;&gt; repr(o)'&lt;object object at 0xb769a4f8&gt;'     # bad (address is dynamic)&gt;&gt;&gt; repr({&quot;a&quot;:1,&quot;b&quot;:2,&quot;d&quot;:4,&quot;c&quot;:3})&quot;{'a': 1, 'c': 3, 'b': 2, 'd': 4}&quot;  # bad (order may change)&gt;&gt;&gt; class A(object):...     def __init__(self, a):...         self.a = a...&gt;&gt;&gt; repr(A(36))'&lt;__main__.A object at 0xb725bb6c&gt;' # bad (A.a not considered)&gt;&gt;&gt; repr(A(35))'&lt;__main__.A object at 0xb725bb6c&gt;' # bad (A.a not considered)```A *bad* representation is one that is not identically across Pythoninvocations (all *bad* examples) or one that does not differentiatevalues sufficiently (last 2 *bad* examples).To use such types anyway you can either1.  implement the type's `__repr__()` method accordingly or2.  provide a custom representation function using the `repr` keyword of    the `Cache` constructor.### Implement the `__repr__()` methodTo pass dictionaries to *percache* decorated functions, you could wrapthem in an own dictionary type with a suitable `__repr__()` method:```python&gt;&gt;&gt; class mydict(dict):...     def __repr__(self):...         items = [&quot;%r: %r&quot; % (k, self[k]) for k in sorted(self)]...         return &quot;{%s}&quot; % &quot;, &quot;.join(items)...&gt;&gt;&gt; repr(mydict({&quot;a&quot;:1,&quot;b&quot;:2,&quot;d&quot;:4,&quot;c&quot;:3}))&quot;{'a': 1, 'b': 2, 'c': 3, 'd': 4}&quot;  # good (always same order)```### Provide a custom `repr()` functionThe following example shows how to use a custom representation functionto get a suitable argument representation of `file` objects:```python&gt;&gt;&gt; def myrepr(arg):...     if isinstance(arg, file):...         # return a string with file name and modification time...         return &quot;%s:%s&quot; % (arg.name, os.fstat(arg.fileno())[8])...     else:...         return repr(arg)...&gt;&gt;&gt; cache = percache.Cache(&quot;/some/path&quot;, repr=myrepr)```Housekeeping-------------   Make sure to delete the cache file whenever the behavior of a cached    function has changed!-   To prevent the cache from getting larger and larger you can call the    `clear()` method of a `Cache` instance. By default it clears *all*    results from the cache. The keyword `maxage` my be used to specify a    maximum number of seconds passed since a cached result has been    *used* the last time. Any result not used (written or accessed) for    `maxage` seconds gets removed from the cache.Changes-------### Version 0.4.4-   Project README in markdown### Version 0.4.3-   Pin build status badge in README to a specific version.### Version 0.4.1-   README fixes.-   Use twine for PyPi upload.-   Use builds.sr.ht for CI.### Version 0.4.0-   Update docs due to project migration to    [sourcehut](https://hg.sr.ht/~obensonne/percache).-   Discontinue Python 2 support.### Version 0.3.0-   Support Python 3.3 (next to 2.6 and 2.7)### Version 0.2.1-   Add missing README to PyPi package.### Version 0.2-   Automatically close (i.e. sync) the cache on finalization.-   Optionally sync the cache on each change.-   Support for alternative back-ends (others than    [shelve](http://docs.python.org/library/shelve.html)).-   Cache object are callable now, which makes the explicit `check()`    method obsolete (though the old interface is still supported).### Version 0.1.1-   Fix wrong usage age output of command line interface.-   Meet half way with pylint.### Version 0.1-   Initial release</longdescription>
</pkgmetadata>