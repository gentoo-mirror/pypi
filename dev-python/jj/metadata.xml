<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># jj[![Codecov](https://img.shields.io/codecov/c/github/tsv1/jj/master.svg?style=flat-square)](https://codecov.io/gh/tsv1/jj)[![PyPI](https://img.shields.io/pypi/v/jj.svg?style=flat-square)](https://pypi.python.org/pypi/jj)[![PyPI - Downloads](https://img.shields.io/pypi/dm/jj?style=flat-square)](https://pypi.python.org/pypi/jj)[![Python Version](https://img.shields.io/pypi/pyversions/jj.svg?style=flat-square)](https://pypi.python.org/pypi/jj)## Installation```bashpip3 install jj```## Usage```pythonimport jj@jj.match(&quot;*&quot;)async def handler(request: jj.Request) -&gt; jj.Response:    return jj.Response(body=&quot;200 OK&quot;)jj.serve()```## Documentation* [Documentation](#documentation)  * [Matchers](#matchers)    * [Method](#method)      * [match_method(`method`)](#match_methodmethod)      * [match_methods(`methods`)](#match_methodsmethods)    * [Path](#path)      * [match_path(`path`)](#match_pathpath)    * [Segments](#segments)    * [Params](#params)      * [match_param(`name`, `val`)](#match_paramname-val)      * [match_params(`params`)](#match_paramsparams)    * [Headers](#headers)      * [match_header(`name`, `val`)](#match_headername-val)      * [match_headers(`headers`)](#match_headersheaders)    * [Combining Matchers](#combining-matchers)      * [match_any(`matchers`)](#match_anymatchers)      * [match_all(`matchers`)](#match_allmatchers)      * [match(`method`, `path`, `params`, `headers`)](#matchmethod-path-params-headers)  * [Responses](#responses)    * [Response](#response)      * [JSON Response](#json-response)      * [HTML Response](#html-response)      * [Binary Response](#binary-response)      * [Not Found Response](#not-found-response)      * [Predefined Body](#predefined-body)    * [StaticResponse](#staticresponse)      * [Inline Content](#inline-content)      * [Downloadable File](#downloadable-file)    * [RelayResponse `β`](#relayresponse-β)  * [Apps](#apps)    * [Single App](#single-app)    * [Multiple Apps](#multiple-apps)    * [App Inheritance](#app-inheritance)  * [Middlewares](#middlewares)    * [Handler Middleware](#handler-middleware)    * [App Middleware](#app-middleware)  * [Remote Mock](#remote-mock)    * [Server Side](#server-side)      * [Start Remote Mock](#start-remote-mock)    * [Client Side](#client-side)      * [Low Level API](#low-level-api)        * [Register Remote Handler](#register-remote-handler)        * [Deregister Remote Handler](#deregister-remote-handler)        * [Retrieve Remote Handler History](#retrieve-remote-handler-history)    * [Expiration Policy](#expiration-policy)    * [Custom Logger](#custom-logger)---### Matchers#### Method##### match_method(`method`)```pythonfrom jj.http.methods import GET@jj.match_method(GET)async def handler(request):    return jj.Response(body=&quot;Method: &quot; + request.method)```##### match_methods(`methods`)```pythonfrom jj.http.methods import PUT, PATCH@jj.match_methods(PUT, PATCH)async def handler(request):    return jj.Response(body=&quot;Method: &quot; + request.method)```#### Path##### match_path(`path`)```python@jj.match_path(&quot;/users&quot;)async def handler(request):    return jj.Response(body=&quot;Path: &quot; + request.path)```#### Segments```python@jj.match_path(&quot;/users/{users_id}&quot;)async def handler(request):    return jj.Response(body=f&quot;Segments: {request.segments}&quot;)```More information available here https://docs.aiohttp.org/en/stable/web_quickstart.html#variable-resources#### Params##### match_param(`name`, `val`)```python@jj.match_param(&quot;locale&quot;, &quot;en_US&quot;)async def handler(request):    locales = request.params.getall('locale')    return jj.Response(body=&quot;Locales: &quot; + &quot;,&quot;.join(locales))```##### match_params(`params`)```python@jj.match_params({&quot;locale&quot;: &quot;en_US&quot;, &quot;timezone&quot;: &quot;UTC&quot;})async def handler(request):    # Literal String Interpolation (PEP 498)    return jj.Response(body=f&quot;Params: {request.params}&quot;)```#### Headers#####  match_header(`name`, `val`)```python@jj.match_header(&quot;X-Forwarded-Proto&quot;, &quot;https&quot;)async def handler(request):    proto = request.headers.getone(&quot;X-Forwarded-Proto&quot;)    return jj.Response(body=&quot;Proto: &quot; + proto)```##### match_headers(`headers`)```python@jj.match_headers({    &quot;x-user-id&quot;: &quot;1432&quot;,    &quot;x-client-id&quot;: &quot;iphone&quot;,})async def handler(request):    return jj.Response(body=f&quot;Headers: {request.headers}&quot;)```#### Combining Matchers##### match_any(`matchers`)```pythonfrom jj.http import PATCH, PUT@jj.match_any([    jj.match_method(PUT),    jj.match_method(PATCH),])async def handler(request):    return jj.Response(body=&quot;200 OK&quot;)```##### match_all(`matchers`)```python@jj.match_all([    jj.match_method(&quot;*&quot;),    jj.match_path(&quot;/&quot;),    jj.match_params({&quot;locale&quot;: &quot;en_US&quot;}),    jj.match_headers({&quot;x-request-id&quot;: &quot;0fefbf48&quot;}),])async def handler(request):    return jj.Response(body=&quot;200 OK&quot;)```##### match(`method`, `path`, `params`, `headers`)```python@jj.match(&quot;*&quot;, &quot;/&quot;, {&quot;locale&quot;: &quot;en_US&quot;}, {&quot;x-request-id&quot;: &quot;0fefbf48&quot;})async def handler(request):    return jj.Response(body=&quot;200 OK&quot;)```---### Responses#### Response##### JSON Response```python@jj.match(&quot;*&quot;)async def handler(request):    return jj.Response(json={&quot;message&quot;: &quot;200 OK&quot;})```##### HTML Response```python@jj.match(&quot;*&quot;)async def handler(request):    return jj.Response(body=&quot;&lt;p&gt;text&lt;p&gt;&quot;, headers={&quot;Content-Type&quot;: &quot;text/html&quot;})```##### Binary Response```python@jj.match(&quot;*&quot;)async def handler(request):    return jj.Response(body=b&quot;&lt;binary&gt;&quot;)```##### Not Found Response```python@jj.match(&quot;*&quot;)async def handler(request):    return jj.Response(status=404, reason=&quot;Not Found&quot;)```##### Predefined Body```pythonfrom jj.http import GET@jj.match(GET, &quot;/users&quot;)async def handler(request):    return jj.Response(body=open(&quot;responses/users.json&quot;, &quot;rb&quot;))``````pythonfrom jj.http import POST, CREATED@jj.match(POST, &quot;/users&quot;)async def handler(request):    return jj.Response(body=open(&quot;responses/created.json&quot;, &quot;rb&quot;), status=CREATED)```#### StaticResponse##### Inline Content```pythonfrom jj.http import GET@jj.match(GET, &quot;/image&quot;)async def handler(request):    return jj.StaticResponse(&quot;public/image.jpg&quot;)```##### Downloadable File```pythonfrom jj.http import GET@jj.match(GET, &quot;/report&quot;)async def handler(request):    return jj.StaticResponse(&quot;public/report.csv&quot;, attachment=True)``````pythonfrom jj.http import GET@jj.match(GET, &quot;/&quot;)async def handler(request):    return jj.StaticResponse(&quot;public/report.csv&quot;, attachment=&quot;report.csv&quot;)```For more information visit https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition#### RelayResponse `β````python@jj.match(&quot;*&quot;)async def handler(request):    return jj.RelayResponse(target=&quot;https://httpbin.org/&quot;)```---### Apps#### Single App```pythonimport jjfrom jj.http.methods import GET, ANYfrom jj.http.codes import OK, NOT_FOUNDclass App(jj.App):    @jj.match(GET, &quot;/&quot;)    async def root_handler(self, request: jj.Request) -&gt; jj.Response:        return jj.Response(status=OK, json={&quot;message&quot;: &quot;200 OK&quot;})    @jj.match(ANY)    async def default_handler(self, request: jj.Request) -&gt; jj.Response:        return jj.Response(status=NOT_FOUND, json={&quot;message&quot;: &quot;Not Found&quot;})jj.serve(App(), port=5000)```#### Multiple Apps```pythonimport jjclass App(jj.App):    @jj.match(&quot;*&quot;)    async def handler(self, request: jj.Request) -&gt; jj.Response:        return jj.Response(body=&quot;App&quot;)class AnotherApp(jj.App):    @jj.match(&quot;*&quot;)    async def handler(self, request: jj.Request) -&gt; jj.Response:        return jj.Response(body=&quot;AnotherApp&quot;)jj.start(App(), port=5001)jj.start(AnotherApp(), port=5002)jj.wait_for([KeyboardInterrupt])```#### App Inheritance```pythonimport jjclass UsersApp(jj.App):    @jj.match(&quot;*&quot;, path=&quot;/users&quot;)    async def handler(self, request: jj.Request) -&gt; jj.Response:        return jj.Response(body=&quot;Users&quot;)class GroupsApp(jj.App):    @jj.match(&quot;*&quot;, path=&quot;/groups&quot;)    async def handler(self, request: jj.Request) -&gt; jj.Response:        return jj.Response(body=&quot;Groups&quot;)class App(UsersApp, GroupsApp):    passjj.serve(App())```### Middlewares#### Handler Middleware```pythonimport jjfrom jj.http.codes import OK, FORBIDDENclass Middleware(jj.Middleware):    async def do(self, request, handler, app):        if request.headers.get(&quot;x-secret-key&quot;) != &quot;&lt;SECRET_KEY&gt;&quot;:            return jj.Response(status=FORBIDDEN, body=&quot;Forbidden&quot;)        return await handler(request)class App(jj.App):    @Middleware()    @jj.match(&quot;*&quot;)    async def handler(self, request: jj.Request) -&gt; jj.Response:        return jj.Response(status=OK, body=&quot;Ok&quot;)jj.serve(App())```#### App Middleware```pythonimport jjfrom jj.http.codes import OK, FORBIDDENclass ReusableMiddleware(jj.Middleware):    def __init__(self, secret_key):        super().__init__()        self._secret_key = secret_key    async def do(self, request, handler, app):        if request.headers.get(&quot;x-secret-key&quot;) != self._secret_key:            return jj.Response(status=FORBIDDEN, body=&quot;Forbidden&quot;)        return await handler(request)private = ReusableMiddleware(&quot;&lt;SECRET_KEY&gt;&quot;)@privateclass App(jj.App):    @jj.match(&quot;*&quot;)    async def handler(self, request: jj.Request) -&gt; jj.Response:        return jj.Response(status=OK, body=&quot;Ok&quot;)jj.serve(App())```---### Remote Mock#### Server Side##### Start Remote Mock```pythonimport jjfrom jj.mock import Mockjj.serve(Mock(), port=8080)```or via docker```shelldocker run -p 8080:80 vedro-universe/jj```#### Client Side```pythonimport asyncioimport jjfrom jj.mock import mockedasync def main():    matcher = jj.match(&quot;GET&quot;, &quot;/users&quot;)    response = jj.Response(status=200, json=[])    async with mocked(matcher, response) as mock:        # Request GET /users        # Returns status=200 body=[]    assert len(mock.history) == 1asyncio.run(main())```Use [jj-district42](https://pypi.org/project/jj-district42/) for testing requests##### Low Level API###### Register Remote Handler```pythonimport asyncioimport jjfrom jj.mock import RemoteMockasync def main():    remote_mock = RemoteMock(&quot;http://localhost:8080&quot;)    matcher = jj.match(&quot;GET&quot;, &quot;/users&quot;)    response = jj.Response(status=200, json=[])    remote_handler = remote_mock.create_handler(matcher, response)    await remote_handler.register()    # Request GET /users    # Returns status=200 body=[]asyncio.run(main())```###### Deregister Remote Handler```pythonimport asyncioimport jjfrom jj.mock import RemoteMockasync def main():    remote_mock = RemoteMock(&quot;http://localhost:8080&quot;)    matcher = jj.match(&quot;GET&quot;, &quot;/users&quot;)    response = jj.Response(status=200, json=[])    remote_handler = remote_mock.create_handler(matcher, response)    await remote_handler.register()    # Request GET /users    # Returns status=200 body=[]    await remote_handler.deregister()asyncio.run(main())```###### Retrieve Remote Handler History```pythonimport asyncioimport jjfrom jj.mock import RemoteMockasync def main():  remote_mock = RemoteMock(&quot;http://localhost:8080&quot;)  matcher = jj.match(&quot;GET&quot;, &quot;/users&quot;)  response = jj.Response(status=200, json=[])  remote_handler = remote_mock.create_handler(matcher, response)  await remote_handler.register()  # Request GET /users  # Returns status=200 body=[]  history = await remote_handler.fetch_history()  print(history)  await remote_handler.deregister()asyncio.run(main())```History:```python[    {        'request': HistoryRequest(            method='GET',            path='/users',            params=&lt;MultiDictProxy()&gt;,            headers=&lt;CIMultiDictProxy('Host': 'localhost:8080',                                      'Accept': '*/*',                                      'Accept-Encoding': 'gzip, deflate',                                      'User-Agent': 'Python/3.8 aiohttp/3.7.3')&gt;,            body=b'',        ),        'response': HistoryResponse(            status=200,            reason='OK',            headers=&lt;CIMultiDictProxy('Content-Type': 'application/json',                                      'Server': 'jj via aiohttp/3.7.3',                                      'Content-Length': '2',                                      'Date': 'Sun, 09 May 2021 08:08:19 GMT')&gt;,            body=b'[]',        ),        'tags': ['f75c2ab7-f68d-4b4a-85e0-1f38bb0abe9a']    }]```#### Expiration Policy```pythonimport jjfrom jj.mock import mockedfrom jj.expiration_policy import ExpireAfterRequestsfrom httpx import AsyncClientmatcher = jj.match(&quot;GET&quot;, &quot;/&quot;)response = jj.Response(status=200)policy = ExpireAfterRequests(1)async with mocked(matcher, response, expiration_policy=policy):    async with AsyncClient() as client:        resp1 = await client.get(&quot;/&quot;)        assert resp1.status_code == 200        # expired        resp2 = await client.get(&quot;/&quot;)        assert resp2.status_code == 404```#### Custom Logger```pythonimport loggingimport jjfrom jj.logs import SimpleFormatterfrom jj.mock import Mock, SystemLogFilterclass Formatter(SimpleFormatter):    def format_request(self, request: jj.Request, record: logging.LogRecord) -&gt; str:        return f&quot;-&gt; {request.method} {request.url.path_qs} {request.headers}&quot;    def format_response(self, response: jj.Response, request: jj.Request, record: logging.LogRecord) -&gt; str:        return f&quot;&lt;- {response.status} {response.reason} {response.body}&quot;handler = logging.StreamHandler()handler.setFormatter(Formatter())logger = logging.getLogger(&quot;custom_logger&quot;)logger.setLevel(logging.INFO)logger.addHandler(handler)logger.addFilter(SystemLogFilter())jj.serve(Mock(), logger=logger)```</longdescription>
</pkgmetadata>