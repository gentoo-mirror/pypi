<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Configue========![CI](https://github.com/illuin-tech/configue/workflows/CI/badge.svg)[![codecov](https://codecov.io/gh/illuin-tech/configue/branch/master/graph/badge.svg)](https://codecov.io/gh/illuin-tech/configue)A YAML parser with advanced functionalities to ease your application configuration.# Who is this library for ?This library is meant to be used in medium to large-scale applications, that have a lot of parameters to configure. Modular applications especially can greatly benefit from using `configue` to easily inject new modules.# InstallationRun `pip install configue` to install from PyPI.Run `pip install .` to install from sources.This project follows the (Semantic Versioning Specification)[https://semver.org/].All breaking changes are described in the [Changelog](CHANGELOG.md). # Usage### Basic usageThis library uses [PyYAML](https://github.com/yaml/pyyaml) to parse the YAML files and return the file content.```pythonimport configueconfig = configue.load(&quot;/path/to/yaml/file.yml&quot;)```### Loading a sub pathIf you are not interested in loading the whole file, you can only load a subpath:```yaml# config.ymlsome_key:  some_list:    - first_item    - second_item:        item_key: item_valuenot_loaded_key: not_loaded_value``````pythonimport configueconfig = configue.load(&quot;config.yml&quot;, &quot;some_key.some_list.1.item_key&quot;)assert config == &quot;item_value&quot;```### Instantiating classesUse `()` in your YAML files to instantiate classes:```yaml# config.yml(): &quot;my_project.MyAwesomeClass&quot;my_argument: &quot;my_value&quot;my_other_argument:  (): &quot;my_project.my_module.MyOtherClass&quot;``````pythonimport configuefrom my_project import MyAwesomeClassfrom my_project.my_module import MyOtherClassmy_instance = configue.load(&quot;config.yml&quot;)assert isinstance(my_instance, MyAwesomeClass)assert my_instance.my_argument == &quot;my_value&quot;assert isinstance(my_instance.my_other_argument, MyOtherClass)```### Loading external variables```yaml# config.ymlmy_argument: !ext my_project.my_module.my_variablemy_argument: !ext my_project.my_module.my_instance.my_attribute```When using the `!ext` tag, the value will be imported from the corresponding python module.### Loading internal variables```yaml# config.ymlmy_object:    my_instance:        (): my_project.MyClassmy_instance_shortcut: !cfg my_object.my_instancemy_attribute_shortcut: !cfg my_object.my_instance.my_attribute```When using the `!cfg` tag, the value will be loaded from the same configuration file (useful for a DRY configuration).### Environment variablesIf you want to load an environment variable in your YAML config file, you can use this syntax:```yaml# config.ymlmy_key: ${VAR_NAME}```This will resolve as `&quot;my_value&quot;` if the environment variable `VAR_NAME` is set to this value.If you need a default value in case the environment variable is not set:```yaml# config.ymlmy_key: ${VAR_NAME-default}```You can insert this syntax in the middle of a string:```yaml# config.ymlmy_key: prefix${VAR_NAME-default}suffix```This will resolve as `&quot;prefixmy_value_suffix&quot;` if the value is set, `&quot;prefixdefaultsuffix&quot;` if it is not.If your environment variable resolves to a yaml value, it will be cast (unless you are using quotes):```yaml# config.ymlmy_key: ${VAR_NAME}my_quoted_key: &quot;${VAR_NAME}&quot;```This will resolve as `True` if the value is set to `true`, `yes` or `y`, `None` if the value is set to `~` or `null`.### Relative pathsIf you want to expand a relative path in your YAML config file:````yaml# config.ymlmy_path: !path my_folder/my_file.txt  ````Assuming your file structure looks like this:```root/├── config.yml└── my_folder    └── my_file.txt```The path is resolved starting from the folder containing the parent yml file, this example will resolve to`/root/my_folder/my_file.txt`Do not start the path with `/` as it will be treated as an absolute path instead.You can use environment variables in your file path.### Importing other filesYou can import another file directly in your YAML config file:````yaml# config.ymlmy_import: !import my_folder/my_other_config.yml```````yaml# my_other_config.ymlsome_key:    - var_1    - var_2```By default, the path is resolved starting from the folder containing the parent yml file, this example will resolve to`&quot;my_import&quot;: {&quot;some_key&quot;: [var_1, var_2]}`If you want to import only a section of the file, use the path in the tag suffix `!import:some_key.0`Do not start the import path with `/` as it will be treated as an absolute path instead.You can use environment variables in your import path.### Logging configurationYou can load the logging configuration for your application by using the `logging_config_path` parameter:```yaml# config.ymllogging_config:  version: 1  handlers:    console:      class : logging.StreamHandler      stream  : ext://sys.stdout    custom_handler:      \(): my_app.CustomHandler      some_param: some_value      level: ERROR  root:    level: INFO    handlers:      - consoleapp_config:  some_key: some_valuenot_loaded_key: not_loaded_value``````pythonimport loggingimport configueapp_config = configue.load(&quot;config.yml&quot;, &quot;app_config&quot;, logging_config_path=&quot;logging_config&quot;)assert app_config == {&quot;some_key&quot;: &quot;some_value&quot;}logger = logging.getLogger(__name__)logger.info(&quot;Hello world!&quot;)  # Uses the console handler```The logging configuration should follow the format of `logging.config.dictConfig`(check [the documentation](https://docs.python.org/3/library/logging.config.html#logging-config-dictschema) for moredetails).Make sure to escape the constructors with `\()` instead of `()` for handlers, formatters and filters.# TestingInstall the development dependencies with `pip install -r dev.requirements.txt`.Run `python -m unitttest discover` to run the tests.Run `pylint configue` to check the files linting.</longdescription>
</pkgmetadata>