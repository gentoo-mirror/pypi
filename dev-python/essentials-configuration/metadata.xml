<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![Build](https://github.com/Neoteroi/essentials-configuration/workflows/Build/badge.svg)[![pypi](https://img.shields.io/pypi/v/essentials-configuration.svg)](https://pypi.python.org/pypi/essentials-configuration)[![versions](https://img.shields.io/pypi/pyversions/essentials-configuration.svg)](https://github.com/Neoteroi/essentials-configuration)[![codecov](https://codecov.io/gh/Neoteroi/essentials-configuration/branch/main/graph/badge.svg?token=VzAnusWIZt)](https://codecov.io/gh/Neoteroi/essentials-configuration)[![license](https://img.shields.io/github/license/Neoteroi/essentials-configuration.svg)](https://github.com/Neoteroi/essentials-configuration/blob/main/LICENSE)# Python configuration utilitiesImplementation of key-value pair based configuration for Python applications.**Features:**- support for most common sources of application settings- support for overriding settings in sequence- support for nested structures and lists, using attribute notation- strategy to use environment specific settings- features to handle secrets and values stored in the user folder, for local  development- features to support validation of configuration items, for example using  `pydantic`, or user defined classesThis library is freely inspired by .NET Core `Microsoft.Extensions.Configuration` (_ref. [MSDN documentation](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-2.1), [Microsoft Extensions Configuration Deep Dive](https://www.paraesthesia.com/archive/2018/06/20/microsoft-extensions-configuration-deep-dive/)_).The main class is influenced by Luciano Ramalho`s example ofJSON structure explorer using attribute notation, in his book [Fluent Python](http://shop.oreilly.com/product/0636920032519.do).## Overview`essentials-configuration` provides a way to handle configuration rootscomposed of several layers, such as configuration files and environmentvariables. Layers are applied in order and can override each others' values,enabling different scenarios like configuration by environment and systeminstance.## Supported sources:- **toml** files- **yaml** files- **json** files- **ini** files- environment variables- secrets stored in the user folder, for development purpose- dictionaries- keys and values- [Azure Key Vault](https://docs.microsoft.com/en-us/azure/key-vault/general/basic-concepts), using [essentials-configuration-keyvault](https://github.com/Neoteroi/essentials-configuration-keyvault)- custom sources, implementing the `ConfigurationSource` interface## Installation```bashpip install essentials-configuration```To install with support for `YAML` configuration files:```pip install essentials-configuration[yaml]```To install with support for `YAML` configuration files and the `CLI` to handleuser secrets:```pip install essentials-configuration[full]```## Extensions* Azure Key Vault secrets configuration source:  [essentials-configuration-keyvault](https://github.com/Neoteroi/essentials-configuration-keyvault)# ExamplesPlease read the list of examples in the [examples folder](./examples). Beloware reported some of the examples that are tested in this repository.### TOML file```pythonfrom config.common import ConfigurationBuilderfrom config.env import EnvVarsfrom config.toml import TOMLFilebuilder = ConfigurationBuilder(    TOMLFile(&quot;settings.toml&quot;),    EnvVars(prefix=&quot;APP_&quot;))config = builder.build()```For example, if the TOML file contains the following contents:```tomltitle = &quot;TOML Example&quot;[owner]name = &quot;Tom Preston-Werner&quot;```And the environment has a variable such as `APP_OWNER__NAME=AAA`, the ownername from the TOML file gets overridden by the env variable:```python&gt;&gt;&gt; config&lt;Configuration {'title': '...', 'owner': '...'}&gt;&gt;&gt;&gt; config.title'TOML Example'&gt;&gt;&gt; config.owner.name'AAA'```### JSON file and environment variablesIn the following example, configuration values will include the structureinside the file `settings.json` and environment variables whose name startswith &quot;APP_&quot;. Settings are applied in order, so environment variables withmatching name override values from the `json` file.```pythonfrom config.common import ConfigurationBuilderfrom config.json import JSONFilefrom config.env import EnvVarsbuilder = ConfigurationBuilder(    JSONFile(&quot;settings.json&quot;),    EnvVars(prefix=&quot;APP_&quot;))config = builder.build()```For example, if the JSON file contains the following contents:```json{    &quot;logging&quot;: {        &quot;level&quot;: &quot;INFO&quot;    },    &quot;example&quot;: &quot;Hello World&quot;,    &quot;foo&quot;: &quot;foo&quot;}```And the environment has a variable named `APP_foo=AAA`:```python&gt;&gt;&gt; config&lt;Configuration {'logging': '...', 'example': '...', 'foo': '...'}&gt;&gt;&gt;&gt; config.foo'AAA'&gt;&gt;&gt; config.logging.level'INFO'```### YAML file and environment variablesIn this example, configuration will include anything inside a file`settings.yaml` and environment variables. Settings are applied in order, soenvironment variables with matching name override values from the `yaml` file(using the `yaml` source requires also `PyYAML` package).```pythonfrom config.common import ConfigurationBuilderfrom config.env import EnvVarsfrom config.yaml import YAMLFilebuilder = ConfigurationBuilder()builder.add_source(YAMLFile(&quot;settings.yaml&quot;))builder.add_source(EnvVars())config = builder.build()```### YAML file, optional file by environmentIn this example, if an environment variable with name `APP_ENVIRONMENT` andvalue `dev` exists, and a configuration file with name `settings.dev.yaml` ispresent, it is read to override values configured in `settings.yaml` file.```pythonimport osfrom config.common import ConfigurationBuilderfrom config.env import EnvVarsfrom config.yaml import YAMLFileenvironment_name = os.environ[&quot;APP_ENVIRONMENT&quot;]builder = ConfigurationBuilder(    YAMLFile(&quot;settings.yaml&quot;),    YAMLFile(f&quot;settings.{environment_name}.yaml&quot;, optional=True))config = builder.build()```### Filtering environment variables by prefix```pythonfrom config.common import ConfigurationBuilderfrom config.env import EnvVarsbuilder = ConfigurationBuilder()builder.add_source(EnvVars(prefix=&quot;APP_&quot;))config = builder.build()```### INI filesINI files are parsed using the built-in `configparser` module, thereforesupport `[DEFAULT]` section; all values are kept as strings.```pythonfrom config.common import ConfigurationBuilderfrom config.ini import INIFilebuilder = ConfigurationBuilder()builder.add_source(INIFile(&quot;settings.ini&quot;))config = builder.build()```### Dictionaries```pythonfrom config.common import ConfigurationBuilderbuilder = ConfigurationBuilder()builder.add_map({&quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: 8080})builder.add_map({&quot;hello&quot;: &quot;world&quot;, &quot;example&quot;: [{&quot;id&quot;: 1}, {&quot;id&quot;: 2}]})config = builder.build()assert config.host == &quot;localhost&quot;assert config.port == 8080assert config.hello == &quot;world&quot;assert config.example[0].id == 1assert config.example[1].id == 2```### Keys and values```pythonfrom config.common import ConfigurationBuilderbuilder = ConfigurationBuilder()builder.add_map({&quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: 8080})builder.add_value(&quot;port&quot;, 44555)config = builder.build()assert config.host == &quot;localhost&quot;assert config.port == 44555```### User secretsThe library provides a strategy to handle secrets during local development,storing them into the user folder.The following example shows how secrets can be configured for a project:```bashconfig settings initconfig settings set &quot;Foo&quot; &quot;Some secret value&quot;```Secrets are organized by project, and the project information is obtained from`pyproject.toml` files (from the `project.name` property). If `pyproject.toml`file does not exist, one is generated automatically with a random name.---Then, from a Python app, it's possible to load the secrets from the user folder:```pythonfrom config.common import ConfigurationBuilderfrom config.json import JSONFilefrom config.secrets import UserSecretsbuilder = ConfigurationBuilder(JSONFile(&quot;settings.json&quot;), UserSecrets())config = builder.build()print(config)# config contains both values from `settings.json`, and secrets read from the user# folder```Secrets are optional and should be used only for local development, they arestored in unencrypted form in the user's folder.Production apps should use dedicated services to handle secrets, like[Azure Key Vault](https://docs.microsoft.com/en-us/azure/key-vault/general/basic-concepts),[AWS Secrets Manager](https://aws.amazon.com/secrets-manager/), or similar services.For Azure Key Vault, an implementation is provided in [essentials-configuration-keyvault](https://github.com/Neoteroi/essentials-configuration-keyvault).## Handling user settingsUser settings (stored in the user's folder) can be handled using the provided `config` CLI.![Rich CLI](https://gist.githubusercontent.com/RobertoPrevato/38a0598b515a2f7257c614938843b99b/raw/a83facd6eb4ddc1dc8552a5f5f073278470010c2/config-settings-rich-cli.png)These settings can be useful to store secrets and other values during local development, or in general when working with desktop applications.### Overriding nested valuesIt is possible to override nested values by environment variables ordictionary keys using the following notation for sub properties:* keys separated by colon &quot;:&quot;, such as `a:d:e`* keys separated by &quot;__&quot;, such as `a__d__e````pythonfrom config.common import ConfigurationBuilder, MapSourcebuilder = ConfigurationBuilder(    MapSource(        {            &quot;a&quot;: {                &quot;b&quot;: 1,                &quot;c&quot;: 2,                &quot;d&quot;: {                    &quot;e&quot;: 3,                    &quot;f&quot;: 4,                },            }        }    ))config = builder.build()assert config.a.b == 1assert config.a.d.e == 3assert config.a.d.f == 4builder.add_value(&quot;a:d:e&quot;, 5)config = builder.build()assert config.a.d.e == 5assert config.a.d.f == 4```### Overriding nested values using env variables```pythonimport osfrom config.common import ConfigurationBuilder, MapSourcefrom config.env import EnvVarsbuilder = ConfigurationBuilder(    MapSource(        {            &quot;a&quot;: {                &quot;b&quot;: 1,                &quot;c&quot;: 2,                &quot;d&quot;: {                    &quot;e&quot;: 3,                    &quot;f&quot;: 4,                },            }        }    ))config = builder.build()assert config.a.b == 1assert config.a.d.e == 3assert config.a.d.f == 4# NB: if an env variable such as:# a:d:e=5# or...# a__d__e=5## is defined, it overrides the value  from the dictionaryos.environ[&quot;a__d__e&quot;] = &quot;5&quot;builder.sources.append(EnvVars())config = builder.build()assert config.a.d.e == &quot;5&quot;```### Overriding values in list items using env variables```pythonimport osfrom config.common import ConfigurationBuilder, MapSourcefrom config.env import EnvVarsbuilder = ConfigurationBuilder(    MapSource(        {            &quot;b2c&quot;: [                {&quot;tenant&quot;: &quot;1&quot;},                {&quot;tenant&quot;: &quot;2&quot;},                {&quot;tenant&quot;: &quot;3&quot;},            ]        }    ),    EnvVars(),)os.environ[&quot;b2c__0__tenant&quot;] = &quot;5&quot;config = builder.build()assert config.b2c[0].tenant == &quot;5&quot;assert config.b2c[1].tenant == &quot;2&quot;assert config.b2c[2].tenant == &quot;3&quot;```### Typed configTo bind configuration sections with types checking, for example to use `pydantic` tovalidate application settings, use the `config.bind` method like inthe following example:```yaml# example-01.yamlfoo:  value: &quot;foo&quot;  x: 100``````python# examplefrom pydantic import BaseModelfrom config.common import ConfigurationBuilderfrom config.yaml import YAMLFileclass FooSettings(BaseModel):    value: str    x: intbuilder = ConfigurationBuilder(YAMLFile(&quot;example-01.yaml&quot;))config = builder.build()# the bind method accepts a variable number of fragments to# obtain the configuration section that should be used to instantiate the given typefoo_settings = config.bind(FooSettings, &quot;foo&quot;)assert isinstance(foo_settings, FooSettings)assert foo_settings.value == &quot;foo&quot;assert foo_settings.x == 100```### Goal and non-goalsThe goal of this package is to provide a way to handle configuration roots,fetching and composing settings from different sources, usually happeningonce at application's start.The library implements only a synchronous API and fetching of applicationsettings atomically (it doesn't support generators), like application settingsfetched from INI, JSON, or YAML files that are read once in memory entirely.An asynchronous API is currently out of the scope of this library, since itsprimary use case is to fetch configuration values once at application's start.</longdescription>
</pkgmetadata>