<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Disk-based hashtable[![Travis](https://api.travis-ci.org/luispedro/diskhash.png)](https://travis-ci.org/luispedro/diskhash)[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)A simple disk-based hash table (i.e., persistent hash table).It is a hashtable implemented on memory-mapped disk, so that it can be loadedwith a single `mmap()` system call and used in memory directly (being as fastas an in-memory hashtable once it is loaded from disk).The code is in C, wrappers are provided for Python, Haskell, and C++. Thewrappers follow similar APIs with variations to accommodate the languagespecificity. They all use the same underlying code, so you can open a hashtablecreated in C from Haskell, modify it within your Haskell code, and later openthe result in Python.Cross-language functionality will only work for simple types where you cancontrol their binary representation (64-bit integers, for example).Reading does not touch the disk representation at all and, thus, can be done ontop of read-only files or using multiple threads (and different processes willshare the memory: the operating system does that for you). Writing or modifyingvalues is, however, not thread-safe.## ExamplesThe following examples all create a hashtable to store longs (`int64_t`), thenset the value associated with the key `&quot;key&quot;` to 9. In the current API, themaximum size of the keys needs to be pre-specified, which is the value `15`below.### Raw C```c#include &lt;stdio.h&gt;#include &lt;inttypes.h&gt;#include &quot;diskhash.h&quot;int main(void) {    HashTableOpts opts;    opts.key_maxlen = 15;    opts.object_datalen = sizeof(int64_t);    char* err = NULL;    HashTable* ht = dht_open(&quot;testing.dht&quot;, opts, O_RDWR|O_CREAT, &amp;err);    if (!ht) {        if (!err) err = &quot;Unknown error&quot;;        fprintf(stderr, &quot;Failed opening hash table: %s.\n&quot;, err);        return 1;    }    long i = 9;    dht_insert(ht, &quot;key&quot;, &amp;i);        long* val = (long*) dht_lookup(ht, &quot;key&quot;);    printf(&quot;Looked up value: %l\n&quot;, *val);    dht_free(ht);    return 0;}```The C API relies on error codes and error strings (the `&amp;err` argument above).The header file has [decentdocumentation](https://github.com/luispedro/diskhash/blob/master/src/diskhash.h).### HaskellIn Haskell, you have different types/functions for read-write and read-onlyhashtables. Read-write operations are `IO` operations, read-only hashtables arepure.Read write example:```haskellimport Data.DiskHashimport Data.Intmain = do    ht &lt;- htOpenRW &quot;testing.dht&quot; 15    htInsertRW ht &quot;key&quot; (9 :: Int64)    val &lt;- htLookupRW &quot;key&quot; ht    print val```Read only example (`htLookupRO` is pure in this case):```haskellimport Data.DiskHashimport Data.Intmain = do    ht &lt;- htOpenRO &quot;testing.dht&quot; 15    let val :: Int64        val = htLookupRO &quot;key&quot; ht    print val```### PythonPython's interface is based on the [structmodule](https://docs.python.org/3/library/struct.html). For example, `'ll'`refers to a pair of 64-bit ints (_longs_):```pythonimport diskhashtb = diskhash.StructHash(&quot;testing.dht&quot;, 15, 'll', 'rw')tb.insert(&quot;key&quot;, 1, 2)print(tb.lookup(&quot;key&quot;))```The Python interface is currently Python 3 only. Patches to extend it to 2.7are welcome, but it's not a priority.### C++In C++, a simple wrapper is defined, which provides a modicum of type-safety.You use the `DiskHash&lt;T&gt;` template. Additionally, errors are reported throughexceptions (both `std::bad_alloc` and `std::runtime_error` can be thrown) andnot return codes.```c++#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;diskhash.hpp&gt;int main() {    const int key_maxlen = 15;    dht::DiskHash&lt;uint64_t&gt; ht(&quot;testing.dht&quot;, key_maxlen, dht::DHOpenRW);    std::string line;    uint64_t ix = 0;    while (std::getline(std::cine, line)) {        if (line.length() &gt; key_maxlen) {            std::cerr &lt;&lt; &quot;Key too long: '&quot; &lt;&lt; line &lt;&lt; &quot;'. Aborting.\n&quot;;            return 2;        }        const bool inserted = ht.insert(line.c_str(), ix);        if (!inserted) {            std::cerr  &lt;&lt; &quot;Found repeated key '&quot; &lt;&lt; line &lt;&lt; &quot;' (ignored).\n&quot;;        }        ++ix;    }    return 0;}```## StabilityThis is _beta_ software. It is good enough that I am using it, but the API canchange in the future with little warning. The binary format is versioned (themagic string encodes its version, so changes can be detected and you will getan error message in the future rather than some silent misbehaviour.[Automated unit testing](https://travis-ci.org/luispedro/diskhash) ensures thatbasic mistakes will not go uncaught.## Limitations- You must specify the maximum key size. This can be worked around either by  pre-hashing the keys (with a strong hash) or using multiple hash tables for  different key sizes. Neither is currently implemented in diskhash.- You cannot delete objects. This was not a necessity for my uses, so it was  not implemented. A simple implementation could be done by marking objects as  &quot;deleted&quot; in place and recompacting when the hash table size changes or with  an explicit `dht_gc()` call. It may also be important to add functionality to  shrink hashtables so as to not waste disk space.- The algorithm is a rather na√Øve implementation of linear addression. It would  not be hard to switch to [robin hood  hashing](https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/)  and this may indeed happen in the near future.License: MIT</longdescription>
</pkgmetadata>