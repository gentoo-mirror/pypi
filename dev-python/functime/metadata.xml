<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;div align=&quot;center&quot;&gt;    &lt;h1&gt;Time-series machine learning at scale&lt;/h1&gt;&lt;br /&gt;![functime](https://github.com/neocortexdb/functime/raw/main/docs/img/banner_dark_bg.png)[![Python](https://img.shields.io/pypi/pyversions/functime)](https://pypi.org/project/functime/)[![PyPi](https://img.shields.io/pypi/v/functime?color=blue)](https://pypi.org/project/functime/)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![GitHub Publish to PyPI](https://github.com/neocortexdb/functime/actions/workflows/publish.yml/badge.svg)](https://github.com/neocortexdb/functime/actions/workflows/publish.yml)[![GitHub Run Quickstart](https://github.com/neocortexdb/functime/actions/workflows/quickstart.yml/badge.svg)](https://github.com/neocortexdb/functime/actions/workflows/quickstart.yml)[![Discord](https://img.shields.io/discord/1145819725276917782)](https://discord.gg/JKMrZKjEwN)&lt;/div&gt;---**functime** is a powerful [Python library](https://pypi.org/project/functime/) for production-ready **global forecasting** and **time-series feature extraction** on **large panel datasets**.**functime** also comes with time-series [preprocessing](https://docs.functime.ai/ref/preprocessing/) (box-cox, differencing etc), cross-validation [splitters](https://docs.functime.ai/ref/cross-validation/) (expanding and sliding window), and forecast [metrics](https://docs.functime.ai/ref/metrics/) (MASE, SMAPE etc). All optimized as [lazy Polars](https://pola-rs.github.io/polars-book/user-guide/lazy/using/) transforms.Join us on [Discord](https://discord.gg/JKMrZKjEwN)!## Highlights- **Fast:** Forecast and extract features (e.g. tsfresh, Catch22) across 100,000 time series in seconds *on your laptop*- **Efficient:** Embarrassingly parallel feature engineering for time-series using [`Polars`](https://www.pola.rs/)- **Battle-tested:** Machine learning algorithms that deliver real business impact and win competitions- **Exogenous features:** supported by every forecaster- **Backtesting** with expanding window and sliding window splitters- **Automated lags and hyperparameter tuning** using [`FLAML`](https://github.com/microsoft/FLAML)## Additional Highlights`functime` comes with a specialized LLM agent to analyze, describe, and compare your forecasts. Check out the walkthrough [here](https://docs.functime.ai/notebooks/llm/).## Getting StartedInstall `functime` via the [pip](https://pypi.org/project/functime) package manager.```bashpip install functime````functime` comes with extra options. For example, to install `functime` with large-language model (LLM) and lightgbm features:```bashpip install &quot;functime[llm,lgb]&quot;```- `cat`: To use `catboost` forecaster- `xgb`: To use `xgboost` forecaster- `lgb`: To use `lightgbm` forecaster- `llm`: To use the LLM-powered forecast analyst### Forecasting```pythonimport polars as plfrom functime.cross_validation import train_test_splitfrom functime.seasonality import add_fourier_termsfrom functime.forecasting import linear_modelfrom functime.preprocessing import scalefrom functime.metrics import mase# Load commodities price datay = pl.read_parquet(&quot;https://github.com/neocortexdb/functime/raw/main/data/commodities.parquet&quot;)entity_col, time_col = y.columns[:2]# Time series splity_train, y_test = y.pipe(train_test_split(test_size=3))# Fit-predictforecaster = linear_model(freq=&quot;1mo&quot;, lags=24)forecaster.fit(y=y_train)y_pred = forecaster.predict(fh=3)# functime ‚ù§Ô∏è functional design# fit-predict in a single liney_pred = linear_model(freq=&quot;1mo&quot;, lags=24)(y=y_train, fh=3)# Score forecasts in parallelscores = mase(y_true=y_test, y_pred=y_pred, y_train=y_train)# Forecast with target transforms and feature transformsforecaster = linear_model(    freq=&quot;1mo&quot;,    lags=24,    target_transform=scale(),    feature_transform=add_fourier_terms(sp=12, K=6))# Forecast with exogenous regressors!# Just pass them into XX = (    y.select([entity_col, time_col])    .pipe(add_fourier_terms(sp=12, K=6)).collect())X_train, X_future = y.pipe(train_test_split(test_size=3))forecaster = linear_model(freq=&quot;1mo&quot;, lags=24)forecaster.fit(y=y_train, X=X_train)y_pred = forecaster.predict(fh=3, X=X_future)```View the full walkthrough on forecasting [here](https://docs.functime.ai/forecasting/).### Feature Extraction`functime` comes with over 100+ [time-series feature extractors](https://docs.functime.ai/feature-extraction/).Every feature is easily accessible via `functime`'s custom `ts` (time-series) namespace, which works with any `Polars` Series or expression. To register the custom `ts` `Polars` namespace, you must first import `functime` in your module.To register the custom `ts` `Polars` namespace, you must first import `functime`!```pythonimport polar as plimport numpy as npimport functime# Load commodities price datay = pl.read_parquet(&quot;https://github.com/neocortexdb/functime/raw/main/data/commodities.parquet&quot;)# Get column names (&quot;commodity_type&quot;, &quot;time&quot;, &quot;price&quot;)entity_col, time_col, value_col = y.columns# Extract a single feature from a single time-seriesbinned_entropy = (    pl.Series(np.random.normal(0, 1, size=10))    .ts.binned_entropy(bin_count=10))# üî• Also works on LazyFrames with query optimizationfeatures = (    pl.LazyFrame({        &quot;index&quot;: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],        &quot;value&quot;: np.random.normal(0, 1, size=10)    })    .select(        pl.col(&quot;value&quot;).ts.binned_entropy(bin_count=10),        pl.col(&quot;value&quot;).ts.lempel_ziv_complexity(threshold=3),        pl.col(&quot;value&quot;).ts.longest_streak_above_mean(),    ))# üöÑ Extract features blazingly fast on many# stacked time-series using `group_by`features = (    y.group_by(entity_col)    .agg(        pl.col(value_col).ts.binned_entropy(bin_count=10),        pl.col(value_col).ts.lempel_ziv_complexity(threshold=3),        pl.col(value_col).ts.longest_streak_above_mean(),    ))# üöÑ Extract features blazingly fast on windows# of many time-series using `group_by_dynamic`features = (    # Compute rolling features at yearly intervals    y.group_by_dynamic(        time_col,        every=&quot;12mo&quot;,        by=entity_col,    )    .select(        pl.col(&quot;value&quot;).ts.binned_entropy(bin_count=10),        pl.col(&quot;value&quot;).ts.lempel_ziv_complexity(threshold=3),        pl.col(&quot;value&quot;).ts.longest_streak_above_mean(),    ))```## Related ProjectsIf you are interested in general data-science related plugins for `Polars`, you must check out [`polars-ds`](https://github.com/abstractqqq/polars_ds_extension). `polars-ds` is a project created by one of `functime`'s core maintainers and is the easiest way to extend your `Polars` pipelines with commonly used data-science operations made blazing fast with Rust!## License`functime` is distributed under [Apache-2.0](LICENSE).</longdescription>
</pkgmetadata>