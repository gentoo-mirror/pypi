<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://img.shields.io/badge/stdlib--only-yes-green.svg    :target: https://img.shields.io/badge/stdlib--only-yes-green.svg.. image:: https://coveralls.io/repos/github/cjrh/autoslot/badge.svg?branch=master    :target: https://coveralls.io/github/cjrh/autoslot?branch=master.. image:: https://img.shields.io/pypi/pyversions/autoslot.svg    :target: https://pypi.python.org/pypi/autoslot.. image:: https://img.shields.io/github/tag/cjrh/autoslot.svg    :target: https://img.shields.io/github/tag/cjrh/autoslot.svg.. image:: https://img.shields.io/badge/install-pip%20install%20autoslot-ff69b4.svg    :target: https://img.shields.io/badge/install-pip%20install%20autoslot-ff69b4.svg.. image:: https://img.shields.io/pypi/v/autoslot.svg    :target: https://img.shields.io/pypi/v/autoslot.svg.. image:: https://img.shields.io/badge/calver-YYYY.MM.MINOR-22bfda.svg    :target: http://calver.org/autoslot========Automatic &quot;__slots__&quot;.Demo----.. code-block:: python   from autoslot import Slots   class Compact(Slots):       def __init__(self, a, b):           self.x = a           self.y = bThis produces *exactly* the same class as if you had done:.. code-block:: python   class Compact:       __slots__ = {'x', 'y'}       def __init__(self, a, b):           self.x = a           self.y = bSimply: the code inside ``__init__()`` is scanned to find all assignmentsto attributes on ``self``, and these are added as ``__slots__``.The benefit of using ``autoslot.Slots`` over a manual slots declaration isthat you can modify thecode inside the ``__init__()`` method to add more attributes, and thosechanges will *automatically* be reflected in the ``__slots__`` definition.You can also have the best of both worlds: slots for fields you expect,**as well as** a ``__dict__`` for those you don't:.. code-block:: python   from autoslot import SlotsPlusDict   class SemiCompact(SlotsPlusDict):       def __init__(self, a, b):           self.x = a           self.y = b   inst = SemiCompact(1, 2)   inst.z = 123  # &lt;-- This won't fail!Attributes ``x`` and ``y`` will be stored in slots, while all otherdynamically-assigned attributes will go into the usual ``__dict__`` instanceinside the class.  If most of your class's attributes appear in the ``__init__()``method (these will become slots), then the space bloat caused by dictionaryhash-table expansion will be contained to only the dynamically-assignedattributes.How does it work?-----------------See for yourself! The code is tiny.In words: the metaclass finds the ``__init__()`` method, if present, andaccesses its bytecode. It looks for all assignments to attributes of``self``, and considers those to be desired ``__slots__`` entries. Then themetaclass injects ``__slots__`` into the namespace of the class definitionand thereafter allows class creation to proceed as normal.Weakref-------When ``__slots__`` are used, weak references (e.g. using the weakref_standard library module) won't work. If you need weak references, justset it up on a new ``__slots__`` class variable as you would normallydo without using ``autoslot``:.. code-block:: python   from autoslot import Slots   class Compact(Slots):       __slots__ = ['__weakref__']       def __init__(self, a, b):           self.x = a           self.y = bEverything else will still work, and instances of ``Compact`` will nowalso play nicely with the weakref_ module... _weakref: https://docs.python.org/3/library/weakref.html?highlight=weakref#module-weakref</longdescription>
</pkgmetadata>