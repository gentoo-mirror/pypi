<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>pytest-subprocess=================.. image:: https://img.shields.io/pypi/v/pytest-subprocess.svg    :target: https://pypi.org/project/pytest-subprocess    :alt: PyPI version.. image:: https://img.shields.io/pypi/pyversions/pytest-subprocess.svg    :target: https://pypi.org/project/pytest-subprocess    :alt: Python versions.. image:: https://codecov.io/gh/aklajnert/pytest-subprocess/branch/master/graph/badge.svg?token=JAU1cGoYL8  :target: https://codecov.io/gh/aklajnert/pytest-subprocess.. image:: https://readthedocs.org/projects/pytest-subprocess/badge/?version=latest   :target: https://pytest-subprocess.readthedocs.io/en/latest/?badge=latest   :alt: Documentation StatusPytest plugin to fake subprocess... contents:: :local:.. include-startUsage=====The plugin adds the ``fake_process`` fixture (and ``fp`` as an alias).It can be used it to register subprocess results so you won't need to rely onthe real processes. The plugin hooks on the ``subprocess.Popen()``, which isthe base for other subprocess functions. That makes the ``subprocess.run()``,``subprocess.call()``, ``subprocess.check_call()`` and``subprocess.check_output()`` methods also functional.Installation------------You can install ``pytest-subprocess`` via `pip`_ from `PyPI`_::    $ pip install pytest-subprocessBasic usage-----------The most important method is ``fp.register()``(or ``register_subprocess`` if you prefer to be more verbose), whichallows defining the fake processes behavior... code-block:: python    def test_echo_null_byte(fp):        fp.register([&quot;echo&quot;, &quot;-ne&quot;, &quot;\x00&quot;], stdout=bytes.fromhex(&quot;00&quot;))        process = subprocess.Popen(            [&quot;echo&quot;, &quot;-ne&quot;, &quot;\x00&quot;],            stdout=subprocess.PIPE,        )        out, _ = process.communicate()        assert process.returncode == 0        assert out == b&quot;\x00&quot;Optionally, the ``stdout`` and ``stderr`` parameters can be a list (or tuple)of lines to be joined together with a trailing ``os.linesep`` on each line... code-block:: python    def test_git(fp):        fp.register([&quot;git&quot;, &quot;branch&quot;], stdout=[&quot;* fake_branch&quot;, &quot;  master&quot;])        process = subprocess.Popen(            [&quot;git&quot;, &quot;branch&quot;],            stdout=subprocess.PIPE,            universal_newlines=True,        )        out, _ = process.communicate()        assert process.returncode == 0        assert out == &quot;* fake_branch\n  master\n&quot;Passing input-------------By default, if you use ``input`` argument to the ``Popen.communicate()``method, it won't crash, but also won't do anything useful. By passinga function as ``stdin_callable`` argument for the``fp.register()`` method you can specify the behaviorbased on the input. The function shall accept one argument, which will bethe input data. If the function will return a dictionary with ``stdout`` or``stderr`` keys, its value will be appended to according stream... code-block:: python    def test_pass_input(fp):        def stdin_function(input):            return {                &quot;stdout&quot;: &quot;This input was added: {data}&quot;.format(                    data=input.decode()                )            }        fp.register(            [&quot;command&quot;],            stdout=[b&quot;Just stdout&quot;],            stdin_callable=stdin_function,        )        process = subprocess.Popen(            [&quot;command&quot;],            stdin=subprocess.PIPE,            stdout=subprocess.PIPE,        )        out, _ = process.communicate(input=b&quot;sample input\n&quot;)        assert out.splitlines() == [            b&quot;Just stdout&quot;,            b&quot;This input was added: sample input&quot;,        ]Unregistered commands---------------------By default, when the ``fp`` fixture is being used, any attempt torun subprocess that has not been registered will raisethe ``ProcessNotRegisteredError`` exception. To allow it, use``fp.allow_unregistered(True)``, which will execute all unregisteredprocesses with real ``subprocess``, or use``fp.pass_command(&quot;command&quot;)`` to allow just a single command... code-block:: python    def test_real_process(fp):        with pytest.raises(fp.exceptions.ProcessNotRegisteredError):            # this will fail, as &quot;ls&quot; command is not registered            subprocess.call(&quot;ls&quot;)        fp.pass_command(&quot;ls&quot;)        # now it should be fine        assert subprocess.call(&quot;ls&quot;) == 0        # allow all commands to be called by real subprocess        fp.allow_unregistered(True)        assert subprocess.call([&quot;ls&quot;, &quot;-l&quot;]) == 0Differing results-----------------Each ``register()`` or ``pass_command()`` method call will registeronly one command execution. You can call those methods multiple times, tochange the faked output on each subprocess run. When you call subprocess morewill be raised. To prevent that, call ``fp.keep_last_process(True)``,which will keep the last registered process forever... code-block:: python    def test_different_output(fp):        # register process with output changing each execution        fp.register(&quot;test&quot;, stdout=&quot;first execution&quot;)        # the second execution will return non-zero exit code        fp.register(&quot;test&quot;, stdout=&quot;second execution&quot;, returncode=1)        assert subprocess.check_output(&quot;test&quot;) == b&quot;first execution&quot;        second_process = subprocess.run(&quot;test&quot;, stdout=subprocess.PIPE)        assert second_process.stdout == b&quot;second execution&quot;        assert second_process.returncode == 1        # 3rd time shall raise an exception        with pytest.raises(fp.exceptions.ProcessNotRegisteredError):            subprocess.check_call(&quot;test&quot;)        # now, register two processes once again,        # but the last one will be kept forever        fp.register(&quot;test&quot;, stdout=&quot;first execution&quot;)        fp.register(&quot;test&quot;, stdout=&quot;second execution&quot;)        fp.keep_last_process(True)        # now the processes can be called forever        assert subprocess.check_output(&quot;test&quot;) == b&quot;first execution&quot;        assert subprocess.check_output(&quot;test&quot;) == b&quot;second execution&quot;        assert subprocess.check_output(&quot;test&quot;) == b&quot;second execution&quot;        assert subprocess.check_output(&quot;test&quot;) == b&quot;second execution&quot;Using callbacks---------------You can pass a function as ``callback`` argument to the ``register()``method which will be executed instead of the real subprocess. The callback functioncan raise exceptions which will be interpreted in tests as an exception raisedby the subprocess. The fixture will pass ``FakePopen`` class instance into thecallback function, that can be used to change the return code or modify outputstreams... code-block:: python    def callback_function(process):        process.returncode = 1        raise PermissionError(&quot;exception raised by subprocess&quot;)    def test_raise_exception(fp):        fp.register([&quot;test&quot;], callback=callback_function)        with pytest.raises(            PermissionError, match=&quot;exception raised by subprocess&quot;        ):            process = subprocess.Popen([&quot;test&quot;])            process.wait()        assert process.returncode == 1It is possible to pass additional keyword arguments into ``callback`` by usingthe ``callback_kwargs`` argument:.. code-block:: python    def callback_function_with_kwargs(process, return_code):        process.returncode = return_code    def test_callback_with_arguments(fp):        return_code = 127        fp.register(            [&quot;test&quot;],            callback=callback_function_with_kwargs,            callback_kwargs={&quot;return_code&quot;: return_code},        )        process = subprocess.Popen([&quot;test&quot;])        process.wait()        assert process.returncode == return_codeAs a context manager--------------------The ``fp`` fixture provides ``context()`` method that allows us touse it as a context manager. It can be used to limit the scope when a certaincommand is allowed, e.g. to make sure that the code doesn't want to executeit somewhere else... code-block:: python    def test_context_manager(fp):        with pytest.raises(fp.exceptions.ProcessNotRegisteredError):            # command not registered, so will raise an exception            subprocess.check_call(&quot;test&quot;)        with fp.context() as nested_process:            nested_process.register(&quot;test&quot;, occurrences=3)            # now, we can call the command 3 times without error            assert subprocess.check_call(&quot;test&quot;) == 0            assert subprocess.check_call(&quot;test&quot;) == 0        # the command was called 2 times, so one occurrence left, but since the        # context manager has been left, it is not registered anymore        with pytest.raises(fp.exceptions.ProcessNotRegisteredError):            subprocess.check_call(&quot;test&quot;)Non-exact command matching--------------------------If you need to catch a command with some non-predictable elements, like a pathto a randomly-generated file name, you can use ``fake_subprocess.any()`` forthat purpose. The number of arguments that should be matched can be controlledby ``min`` and ``max`` arguments. To use ``fake_subprocess.any()`` you needto define the command as a ``tuple`` or ``list``. The matching will work evenif the subprocess command will be called with a string argument... code-block:: python    def test_non_exact_matching(fp):        # define a command that will take any number of arguments        fp.register([&quot;ls&quot;, fp.any()])        assert subprocess.check_call(&quot;ls -lah&quot;) == 0        # `fake_subprocess.any()` is OK even with no arguments        fp.register([&quot;ls&quot;, fp.any()])        assert subprocess.check_call(&quot;ls&quot;) == 0        # but it can force a minimum amount of arguments        fp.register([&quot;cp&quot;, fp.any(min=2)])        with pytest.raises(fp.exceptions.ProcessNotRegisteredError):            # only one argument is used, so registered command won't match            subprocess.check_call(&quot;cp /source/dir&quot;)        # but two arguments will be fine        assert subprocess.check_call(&quot;cp /source/dir /tmp/random-dir&quot;) == 0        # the `max` argument can be used to limit maximum amount of arguments        fp.register([&quot;cd&quot;, fp.any(max=1)])        with pytest.raises(fp.exceptions.ProcessNotRegisteredError):            # cd with two arguments won't match with max=1            subprocess.check_call(&quot;cd ~/ /tmp&quot;)        # but any single argument is fine        assert subprocess.check_call(&quot;cd ~/&quot;) == 0        # `min` and `max` can be used together        fp.register([&quot;my_app&quot;, fp.any(min=1, max=2)])        assert subprocess.check_call([&quot;my_app&quot;, &quot;--help&quot;]) == 0You can also specify just the command name, and have it match any command withthe same name, regardless of the location. This is accomplished with``fake_subprocess.program(&quot;name&quot;)``... code-block:: python    def test_any_matching_program(fp):        # define a command that can come from anywhere        fp.register([fp.program(&quot;ls&quot;)])        assert subprocess.check_call(&quot;/bin/ls&quot;) == 0Check if process was called---------------------------You may want to simply check if a certain command was called, you can do thisby accessing ``fp.calls``, where all commands are stored as-called.You can also use a utility function ``fp.call_count()`` to seehow many a command has been called. The latter supports ``fp.any()``... code-block:: python    def test_check_if_called(fp):        fp.keep_last_process(True)        # any command can be called        fp.register([fp.any()])        subprocess.check_call([&quot;cp&quot;, &quot;/tmp/source&quot;, &quot;/source&quot;])        subprocess.check_call([&quot;cp&quot;, &quot;/source&quot;, &quot;/destination&quot;])        subprocess.check_call([&quot;cp&quot;, &quot;/source&quot;, &quot;/other/destination&quot;])        # you can check if command is in ``fp.calls``        assert [&quot;cp&quot;, &quot;/tmp/source&quot;, &quot;/source&quot;] in fp.calls        assert [&quot;cp&quot;, &quot;/source&quot;, &quot;/destination&quot;] in fp.calls        assert [&quot;cp&quot;, &quot;/source&quot;, &quot;/other/destination&quot;] in fp.calls        # or check how many it was called, possibly with wildcard arguments        assert fp.call_count([&quot;cp&quot;, &quot;/source&quot;, &quot;/destination&quot;]) == 1        # with ``call_count()`` you don't need to use the same type as        # the subprocess was called        assert fp.call_count(&quot;cp /tmp/source /source&quot;) == 1        # can be used with ``fp.any()`` to match more calls        assert fp.call_count([&quot;cp&quot;, fp.any()]) == 3Handling signals----------------You can use standard ``kill()``, ``terminate()`` or ``send_signal()`` methodsin ``Popen`` instances. There is an additional ``received_signals()`` methodto get a tuple of all signals received by the process. It is also possible toset up an optional callback function for signals... code-block:: python    import signal    def test_signal_callback(fp):        &quot;&quot;&quot;Test that signal callbacks work.&quot;&quot;&quot;        def callback(process, sig):            if sig == signal.SIGTERM:                process.returncode = -1        # the `register()` method returns a ProgressRecorder object, where        # all future matching `Popen()` instances will be appended        process_recorder = fp.register(&quot;test&quot;, signal_callback=callback)        process = subprocess.Popen(&quot;test&quot;)        process.send_signal(signal.SIGTERM)        process.wait()        assert process.returncode == -1        assert process.received_signals() == (signal.SIGTERM,)        # the instance appended to `register()` output is the `Popen` instance        # created later        assert process_recorder.first_call is processAsyncio support---------------The plugin now supports asyncio and works for ``asyncio.create_subprocess_shell``and ``asyncio.create_subprocess_exec``:.. code-block:: python    @pytest.mark.asyncio    async def test_basic_usage(        fp,    ):        fp.register(            [&quot;some-command-that-is-definitely-unavailable&quot;], returncode=500        )        process = await asyncio.create_subprocess_shell(            &quot;some-command-that-is-definitely-unavailable&quot;        )        returncode = await process.wait()        assert process.returncode == returncode        assert process.returncode == 500.. _`pip`: https://pypi.org/project/pip/.. _`PyPI`: https://pypi.org/project.. include-endDocumentation-------------For full documentation, including API reference, please see https://pytest-subprocess.readthedocs.io/en/latest/.Contributing------------Contributions are very welcome. Tests can be run with `tox`_, please ensurethe coverage at least stays the same before you submit a pull request.License-------Distributed under the terms of the `MIT`_ license, &quot;pytest-subprocess&quot; is free and open source softwareIssues------If you encounter any problems, please `file an issue`_ along with a detailed description.----This `pytest`_ plugin was generated with `Cookiecutter`_ along with `@hackebrot`_'s `cookiecutter-pytest-plugin`_ template... _`Cookiecutter`: https://github.com/audreyr/cookiecutter.. _`@hackebrot`: https://github.com/hackebrot.. _`MIT`: http://opensource.org/licenses/MIT.. _`BSD-3`: http://opensource.org/licenses/BSD-3-Clause.. _`GNU GPL v3.0`: http://www.gnu.org/licenses/gpl-3.0.txt.. _`Apache Software License 2.0`: http://www.apache.org/licenses/LICENSE-2.0.. _`cookiecutter-pytest-plugin`: https://github.com/pytest-dev/cookiecutter-pytest-plugin.. _`file an issue`: https://github.com/aklajnert/pytest-subprocess/issues.. _`pytest`: https://github.com/pytest-dev/pytest.. _`tox`: https://tox.readthedocs.io/en/latest/History=======1.5.0 (2023-01-28)  ------------------Features  ~~~~~~~~* `#109 &lt;https://github.com/aklajnert/pytest-subprocess/pull/109&gt;`_: Match also `os.PathLike`.* `#105 &lt;https://github.com/aklajnert/pytest-subprocess/pull/105&gt;`_: Add program matcher.Other changes  ~~~~~~~~~~~~~* `#110 &lt;https://github.com/aklajnert/pytest-subprocess/pull/110&gt;`_: Produce TypeError on Win Py&lt;3.8 for Path args.1.4.2 (2022-10-02)  ------------------Features  ~~~~~~~~* `#87 &lt;https://github.com/aklajnert/pytest-subprocess/pull/87&gt;`_: Add support for Python 3.11.* `#80 &lt;https://github.com/aklajnert/pytest-subprocess/pull/80&gt;`_, `#86 &lt;https://github.com/aklajnert/pytest-subprocess/pull/86&gt;`_: The `register()` method returns an auxiliary object that will contain all matching `FakePopen` instances.Bug fixes  ~~~~~~~~~* `#93 &lt;https://github.com/aklajnert/pytest-subprocess/pull/93&gt;`_: Raise callback exceptions on `communicate()` calls.Other changes  ~~~~~~~~~~~~~* `#97 &lt;https://github.com/aklajnert/pytest-subprocess/pull/97&gt;`_: Fixed warnings in tests, treat warnings as errors.* `#91 &lt;https://github.com/aklajnert/pytest-subprocess/pull/91&gt;`_: Use `sys.executable` instead just `&quot;python&quot;` in tests while invoking python subprocess.* `#90 &lt;https://github.com/aklajnert/pytest-subprocess/pull/90&gt;`_: Fix documentation build, add CI check for it.1.4.1 (2022-02-09)  ------------------Other changes  ~~~~~~~~~~~~~* `#74 &lt;https://github.com/aklajnert/pytest-subprocess/pull/74&gt;`_: Add ``fp`` alias for the fixture, and ``register`` for the ``regisiter_subprocess``.1.4.0 (2022-01-23)  ------------------Features  ~~~~~~~~* `#71 &lt;https://github.com/aklajnert/pytest-subprocess/pull/71&gt;`_: Add support for stdin with asyncio.Bug fixes  ~~~~~~~~~* `#68 &lt;https://github.com/aklajnert/pytest-subprocess/pull/68&gt;`_: Make `stdout` and `stderr` an `asyncio.StreamReader` instance when using asyncio functions.* `#63 &lt;https://github.com/aklajnert/pytest-subprocess/pull/63&gt;`_, `#67 &lt;https://github.com/aklajnert/pytest-subprocess/pull/67&gt;`_: Add missing items to `asyncio.subprocess`.Other changes  ~~~~~~~~~~~~~* `#69 &lt;https://github.com/aklajnert/pytest-subprocess/pull/69&gt;`_: Extracted code into separate files to improve navigation.1.3.2 (2021-11-07)  ------------------Bug fixes  ~~~~~~~~~* `#61 &lt;https://github.com/aklajnert/pytest-subprocess/pull/61&gt;`_: Fixed behavior of ``asyncio.create_subproess_exec()``.1.3.1 (2021-11-01)  ------------------Bug fixes  ~~~~~~~~~* `#58 &lt;https://github.com/aklajnert/pytest-subprocess/pull/58&gt;`_: Correctly handle file stream output.1.3.0 (2021-10-24)  ------------------Features  ~~~~~~~~* `#55 &lt;https://github.com/aklajnert/pytest-subprocess/pull/55&gt;`_: Add support for ``terminate()``, ``kill()``, ``send_signal()``.1.2.0 (2021-10-09)  ------------------Features  ~~~~~~~~* `#49 &lt;https://github.com/aklajnert/pytest-subprocess/pull/49&gt;`_, `#52 &lt;https://github.com/aklajnert/pytest-subprocess/pull/52&gt;`_: Add support for ``asyncio``.Other changes  ~~~~~~~~~~~~~* `#50 &lt;https://github.com/aklajnert/pytest-subprocess/pull/50&gt;`_: Change docs theme.1.1.2 (2021-07-17)  ------------------Bug fixes  ~~~~~~~~~* `#47 &lt;https://github.com/aklajnert/pytest-subprocess/pull/47&gt;`_: Prevent `allow_unregistered()` and `keep_last_process()` from affecting other tests.1.1.1 (2021-06-18)  ------------------Bug fixes  ~~~~~~~~~* `#43 &lt;https://github.com/aklajnert/pytest-subprocess/pull/43&gt;`_: Wait for callback thread to finish when calling ``communicate()``.Other changes  ~~~~~~~~~~~~~* `#42 &lt;https://github.com/aklajnert/pytest-subprocess/pull/42&gt;`_: Fix type annotations for `register_subprocess()`.1.1.0 (2021-04-18)  ------------------Bug fixes  ~~~~~~~~~* `#37 &lt;https://github.com/aklajnert/pytest-subprocess/pull/37&gt;`_: Preserve original command in `proc.args` to prevent leaking the internal `Command` type.Other changes  ~~~~~~~~~~~~~* `#38 &lt;https://github.com/aklajnert/pytest-subprocess/pull/38&gt;`_: Switched CI from Azure Pipelines to GitHub Actions.* `#35 &lt;https://github.com/aklajnert/pytest-subprocess/pull/35&gt;`_: Drop support for python 3.4 and 3.5. Move type annotations from `.pyi` files into sources.1.0.1 (2021-03-20)  ------------------Bug fixes  ~~~~~~~~~* `#34 &lt;https://github.com/aklajnert/pytest-subprocess/pull/34&gt;`_: Prevent appending newlines to outputs unless defined as list/tuple.Other changes  ~~~~~~~~~~~~~* `#32 &lt;https://github.com/aklajnert/pytest-subprocess/pull/32&gt;`_: Make the ``Command`` class iterable.1.0.0 (2020-08-22)  ------------------Features  ~~~~~~~~* `#29 &lt;https://github.com/aklajnert/pytest-subprocess/pull/29&gt;`_: Remember subprocess calls to check if expected commands were executed.* `#28 &lt;https://github.com/aklajnert/pytest-subprocess/pull/28&gt;`_: Allow to match a command with variable arguments (non-exact matching).0.1.5 (2020-06-19)  ------------------Bug fixes  ~~~~~~~~~* `#26 &lt;https://github.com/aklajnert/pytest-subprocess/pull/26&gt;`_: `encoding` and `errors` arguments will properly trigger `text` mode.0.1.4 (2020-04-28)  ------------------Bug fixes  ~~~~~~~~~* `#22 &lt;https://github.com/aklajnert/pytest-subprocess/pull/22&gt;`_: The `returncode` will not be ignored when `callback` is used.* `#21 &lt;https://github.com/aklajnert/pytest-subprocess/pull/21&gt;`_: The exception raised from callback will take precedence over those from subprocess.* `#20 &lt;https://github.com/aklajnert/pytest-subprocess/pull/20&gt;`_: Registering process will be now consistent regardless of the command type.* `#19 &lt;https://github.com/aklajnert/pytest-subprocess/pull/19&gt;`_: Fixed crash for stderr redirect with an empty stream definition.0.1.3 (2020-03-04)  ------------------Features  ~~~~~~~~* `#13 &lt;https://github.com/aklajnert/pytest-subprocess/pull/13&gt;`_: Allow passing keyword arguments into callbacks.Bug fixes  ~~~~~~~~~* `#12 &lt;https://github.com/aklajnert/pytest-subprocess/pull/12&gt;`_: Properly raise exceptions from callback functions.Documentation changes  ~~~~~~~~~~~~~~~~~~~~~* `#15 &lt;https://github.com/aklajnert/pytest-subprocess/pull/15&gt;`_: Add documentation chapter about the callback functions.0.1.2 (2020-01-17)  ------------------Features  ~~~~~~~~* `#3 &lt;https://github.com/aklajnert/pytest-subprocess/pull/3&gt;`_: Add basic support for process input.Bug fixes  ~~~~~~~~~* `#5 &lt;https://github.com/aklajnert/pytest-subprocess/pull/5&gt;`_: Make ``wait()`` method to raise ``TimeoutError`` after the desired time will elapse.Documentation changes  ~~~~~~~~~~~~~~~~~~~~~* `#7 &lt;https://github.com/aklajnert/pytest-subprocess/pull/7&gt;`_, `#8 &lt;https://github.com/aklajnert/pytest-subprocess/pull/8&gt;`_, `#9 &lt;https://github.com/aklajnert/pytest-subprocess/pull/9&gt;`_: Create Sphinx documentation.Other changes  ~~~~~~~~~~~~~* `#10 &lt;https://github.com/aklajnert/pytest-subprocess/pull/10&gt;`_:  Switch from ``tox`` to ``nox`` for running tests and tasks.* `#4 &lt;https://github.com/aklajnert/pytest-subprocess/pull/4&gt;`_: Add classifier for Python 3.9. Update CI config to test also on that interpreter version.0.1.1 (2019-11-24)  ------------------Other changes  ~~~~~~~~~~~~~* `#1 &lt;https://github.com/aklajnert/pytest-subprocess/pull/1&gt;`_, `#2 &lt;https://github.com/aklajnert/pytest-subprocess/pull/2&gt;`_: Enable support for Python 3.4, add CI tests for that version.0.1.0 (2019-11-23)  ------------------Initial release  </longdescription>
</pkgmetadata>