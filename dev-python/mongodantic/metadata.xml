<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># mongodantic## non stable now## InstallInstall using `pip`...    pip install mongodantic##settingsin your main file application```pythonfrom mongodantic import connectconnection_str = '&lt;your connection url&gt;'db_name = '&lt;name of database&gt;'# basicconnect(connection_str, db_name, max_pool_size=100)# if u use sslconnect(connection_str, db_name, max_pool_size=100, ssl=True, ssl_cert_path='&lt;path to cert&gt;')# extra paramsserver_selection_timeout_ms = 50000 # pymongo serverSelectionTimeoutMSconnect_timeout_ms = 50000 # pymongo connectTimeoutMSsocket_timeout_ms = 50000 # pymongo socketTimeoutMS```## Declare models```pythonfrom mongodantic.models import MongoModelclass Banner(MongoModel):    banner_id: str    name: str    utm: dict# if you need take an existing collection, you must reimplement set_collection_name method like thatclass Banner(MongoModel):    ...    @classmethod    def set_collection_name(cls) -&gt; str:        return 'banner_test'```## Queries```pythonbanner = Banner.Q.find_one() # return a banner model obj# skip and limitbanner_with_skip_and_limit = Banner.Q.find(skip_rows=10, limit_rows=10)banner_data = Banner.Q.find_one().data # return a dictbanners_queryset= Banner.Q.find() # return QuerySet objectbanners_dict = Banner.Q.find().datalist_of_banners = Banner.Q.find().listbanners_generator = Banner.Q.find().generator # generator of Banner objectsbanners_generator_of_dicts = Banner.Q.find().data_generator # generator of Banner objectscount, banners = Banner.Q.find_with_count() # return tuple(int, QuerySet)serializeble_fields = Banner.Q.find().serialize(['utm', 'banner_id', 'name']) # return list with dict like {'utm':..., 'banner_id': ..,'name': ...}generator_serializeble_fields = Banner.Q.find().serialize_generator(['utm', 'banner_id', 'name']) # return generatorjson_serializeble_fields = Banner.Q.find().serialize_json(['utm', 'banner_id', 'name']) # returnn json str serializeble# countcount = Banner.Q.count(name='test')# insert queriesBanner.Q.insert_one(banner_id=1, name='test', utm={'utm_source': 'yandex', 'utm_medium': 'cpc'})banners = [Banner(banner_id=2, name='test2', utm={}), Banner(banner_id=3, name='test3', utm={})]Banner.Q.insert_many(banners) # list off models obj, or dictsBanner.Q.bulk_create(banners, batch_size=1000) # insert_many with batch# update queriesBanner.Q.update_one(banner_id=1, name__set='updated') # parameters that end __set - been updatedBanner.Q.update_many(name__set='update all names')# delete queriesBanner.Q.delete_one(banner_id=1) # delete one rowBanner.Q.delete_many(banner_id=1) # delete many rows# extra queriesBanner.Q.find(banner_id__in=[1, 2]) # get data in listBanner.Q.find(banner_id__range=[1,10]) # get date from 1 to 10Banner.Q.find(name__regex='^test') # regex queryBanner.Q.find(name__startswith='t') # startswith queryBanner.Q.find(name__endswith='t') # endswith queryBanner.Q.find(name__not_startswith='t') # not startswith queryBanner.Q.find(name__not_endswith='t') # not endswith queryBanner.Q.find(name__nin=[1, 2]) # not in listBanner.Q.find(name__ne='test') # != testBanner.Q.find(banner_id__gte=1, banner_id__lte=10) # id &gt;=1 and id &lt;=10Banner.Q.find(banner_id__gt=1, banner_id__lt=10) # id &gt;1 and id &lt;10Banner.Q.find_one(banner_id=1, utm__utm_medium='cpm') # find banner where banner_id=1, and utm['utm_medium'] == 'cpm'Banner.Q.update_one(banner_id=1, utm__utm_source__set='google') # update utms['utm_source'] in Banner# find and updateBanner.Q.find_and_update(banner_id=1, name__set='updated', projection_fields=['name': True]) # return {'name': 'updated}Banner.Q.find_and_update(banner_id=1, name__set='updated') # return Banner obj# find and replaceBanner.Q.find_and_update(banner_id=1, Banner(banner_id=1, name='uptated'), projection={'name': True})# return {'name': 'updated}Banner.Q.find_and_update(banner_id=1, Banner(banner_id=1, name='uptated')) # return Banner obj# bulk operationsfrom random import randintbanners = Banner.Q.find()to_update = []for banner in banners:    banner.banner_id = randint(1,100)    to_update.append(banner)Banner.Q.bulk_update(banners, updated_fields=['banner_id'])# bulk update or createbanners = [Banner(banner_id=23, name='new', utms={}), Banner(banner_id=1, name='test', utms={})]Banner.Q.bulk_update_or_create(banners, query_fields=['banner_id'])# aggregate with sum, min, maxclass Stats(MongoModel):    id: int    cost: float    clicks: int    shows: int    date: strfrom mongodantic.aggregation import Sum, Min, MaxStats.Q.simple_aggregate(date='2020-01-20', aggregation=Sum('cost'))Stats.Q.simple_aggregate(date='2020-01-20', aggregation=Min('clicks'))Stats.Q.simple_aggregate(date='2020-01-20', aggregation=Max('shows'))# sessionsfrom mongodantic.session import Sessionwith Session(Banner) as session:    Banner.Q.find(skip_rows=1, limit_rows=1, session=session).data# logicalfrom mongodantic.logical import Querydata = Banner.Q.find_one(Query(name='test') | Query(name__regex='testerino'))# for async queriesasync def get_banner() -&gt; Optiona[Banner]:    banner = await Banner.AQ.find_one()    return banner```</longdescription>
</pkgmetadata>