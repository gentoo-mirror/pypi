<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![](https://github.com/filetrust/glasswall-python/actions/workflows/python-package.yml/badge.svg)![](https://github.com/filetrust/glasswall-python/actions/workflows/python-publish.yml/badge.svg)&lt;!-- omit in toc --&gt;# Glasswall Python WrapperA high level Python wrapper for interfacing with Glasswall libraries.&lt;!-- omit in toc --&gt;## InstallationInstall or upgrade to the latest version via pip:&lt;!-- omit in toc --&gt;### Online installation```pip install --upgrade glasswall```&lt;!-- omit in toc --&gt;### Offline installation for CentOS 7 and RHEL8Run the following commands within the directory containing the offline installation files.```pip install --upgrade --no-index --find-links=. glasswall```**Note:** The lxml wheel includes the required lxml dependencies and has been tested on CentOS 7 and RHEL8 environments.&lt;!-- omit in toc --&gt;## Prerequisites- [Python &gt;= 3.6](https://www.python.org/downloads/)&lt;!-- omit in toc --&gt;## Auto-generated Documentationhttps://gw-engineering.github.io/glasswall-python-wrapper/&lt;!-- omit in toc --&gt;## Examples- [Loading a Glasswall library](#loading-a-glasswall-library)- [Logging](#logging)- [Content management policies](#content-management-policies)- [Editor](#editor)  - [Protect](#protect)    - [Protect from file path to file path](#protect-from-file-path-to-file-path)    - [Protect from file path to memory](#protect-from-file-path-to-memory)    - [Protect from memory](#protect-from-memory)    - [Protect files in a directory](#protect-files-in-a-directory)    - [Protect files in a directory that may contain unsupported file types](#protect-files-in-a-directory-that-may-contain-unsupported-file-types)    - [Protect files in a directory using a custom content management policy](#protect-files-in-a-directory-using-a-custom-content-management-policy)    - [Protect files in a directory conditionally based on file format](#protect-files-in-a-directory-conditionally-based-on-file-format)  - [Analysis](#analysis)    - [Analyse from file path to file path](#analyse-from-file-path-to-file-path)    - [Analyse from file path to memory](#analyse-from-file-path-to-memory)    - [Analyse from memory](#analyse-from-memory)    - [Analyse files in a directory](#analyse-files-in-a-directory)    - [Analyse files in a directory that may contain unsupported file types](#analyse-files-in-a-directory-that-may-contain-unsupported-file-types)    - [Analyse files in a directory using a custom content management policy](#analyse-files-in-a-directory-using-a-custom-content-management-policy)    - [Analyse files in a directory conditionally based on file format](#analyse-files-in-a-directory-conditionally-based-on-file-format)  - [Export](#export)    - [Export from file path to file path](#export-from-file-path-to-file-path)    - [Export from file path to memory](#export-from-file-path-to-memory)    - [Export from memory](#export-from-memory)    - [Export files in a directory](#export-files-in-a-directory)    - [Export files in a directory that may contain unsupported file types](#export-files-in-a-directory-that-may-contain-unsupported-file-types)    - [Export files in a directory using a custom content management policy](#export-files-in-a-directory-using-a-custom-content-management-policy)    - [Export files in a directory conditionally based on file format](#export-files-in-a-directory-conditionally-based-on-file-format)  - [Import](#import)    - [Import from file path to file path](#import-from-file-path-to-file-path)    - [Import from file path to memory](#import-from-file-path-to-memory)    - [Import from memory](#import-from-memory)    - [Import files in a directory](#import-files-in-a-directory)    - [Import files in a directory that may contain unsupported file types](#import-files-in-a-directory-that-may-contain-unsupported-file-types)    - [Import files in a directory using a custom content management policy](#import-files-in-a-directory-using-a-custom-content-management-policy)    - [Import files in a directory conditionally based on file format](#import-files-in-a-directory-conditionally-based-on-file-format)- [Rebuild](#rebuild)- [Archive Manager](#archive-manager)    - [Protect an archive](#protect-an-archive)    - [Protect all archives in a directory using a custom content management policy](#protect-all-archives-in-a-directory-using-a-custom-content-management-policy)  - [Extraction - Unpacking an archive](#extraction---unpacking-an-archive)    - [Other useful arguments when unpacking](#other-useful-arguments-when-unpacking)  - [Extraction - Unpacking a directory of archives](#extraction---unpacking-a-directory-of-archives)  - [Compression - Packing a directory into an archive](#compression---packing-a-directory-into-an-archive)- [WordSearch](#wordsearch)  - [Redact](#redact)    - [Redact from file path to file path](#redact-from-file-path-to-file-path)    - [Redact from file path to memory](#redact-from-file-path-to-memory)    - [Redact from memory](#redact-from-memory)    - [Redact files in a directory](#redact-files-in-a-directory)    - [Redact files in a directory that may contain unsupported file types](#redact-files-in-a-directory-that-may-contain-unsupported-file-types)    - [Redact files in a directory conditionally based on file format](#redact-files-in-a-directory-conditionally-based-on-file-format)### Loading a Glasswall libraryEach library is a subclass of the `glasswall.libraries.library.Library` class and can be accessed from the top level of the `glasswall` module. The following subclasses are available:- ArchiveManager- Editor- Rebuild- SecurityTagging- WordSearchLibraries are loaded on initialisation and have one required argument: `library_path` which can be the path to a file or a directory. If a directory is specified it is recursively searched and the library with the latest change time will be loaded.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)``````&gt;&gt;&gt; 2021-03-15 12:27:42.337 glasswall INFO     __init__                  Loaded Glasswall Editor version 2.173 from C:\gwpw\libraries\sdk.editor\windows-drop-no-kill-switch\glasswall_core2.dll```---### LoggingLogs are saved to the temp directory and are also output to console with a default logging level of INFO. You can view the file path of the temp directory or the log file:```pyimport glasswallprint(glasswall._TEMPDIR)print(glasswall.config.logging.log_file_path)``````&gt;&gt;&gt; C:\Users\ANGUSR~1\AppData\Local\Temp\glasswall&gt;&gt;&gt; C:\Users\ANGUSR~1\AppData\Local\Temp\glasswall\logs\2021-03-15 122826.txt```The logging level can be modified, for a list of levels see: https://docs.python.org/3/library/logging.html#logging-levels```pyimport loggingimport glasswall# Modify logging level for logs to the consoleglasswall.config.logging.console.setLevel(logging.DEBUG)# Modify logging level for logs to fileglasswall.config.logging.log.setLevel(logging.DEBUG)```---### Content management policiesDocumentation about content management policies can be found on the [Policy Management](https://docs.glasswall.com/docs/embedded-engine-policy-management) page.Subclasses of the `glasswall.content_management.policies.Policy` class can be used to easily create content management policies of varying complexity by passing the `default` and `config` keyword arguments. Subclasses include:- ArchiveManager- Editor- Rebuild- WordSearchSome examples of content management policies are below. Note that if a content management policy is required but has not been specified with the keyword argument `content_management_policy` then the default content management policy will be used.Content management policies can be specified using subclasses of `Policy`:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)editor.protect_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\input_sanitised&quot;,    content_management_policy=glasswall.content_management.policies.Editor(default=&quot;sanitise&quot;))```or loaded from a file path:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)editor.protect_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\input_sanitised&quot;,    content_management_policy=r&quot;C:\gwpw\configs\config.xml&quot;)```Default sanitise all Editor policy```pyimport glasswall# Print the default Editor content management policyprint(glasswall.content_management.policies.Editor())``````xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;config&gt;    &lt;pdfConfig&gt;        &lt;acroform&gt;sanitise&lt;/acroform&gt;        &lt;actions_all&gt;sanitise&lt;/actions_all&gt;        &lt;digital_signatures&gt;sanitise&lt;/digital_signatures&gt;        &lt;embedded_files&gt;sanitise&lt;/embedded_files&gt;        &lt;embedded_images&gt;sanitise&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;sanitise&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;sanitise&lt;/internal_hyperlinks&gt;        &lt;javascript&gt;sanitise&lt;/javascript&gt;        &lt;metadata&gt;sanitise&lt;/metadata&gt;    &lt;/pdfConfig&gt;    &lt;pptConfig&gt;        &lt;embedded_files&gt;sanitise&lt;/embedded_files&gt;        &lt;embedded_images&gt;sanitise&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;sanitise&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;sanitise&lt;/internal_hyperlinks&gt;        &lt;javascript&gt;sanitise&lt;/javascript&gt;        &lt;macros&gt;sanitise&lt;/macros&gt;        &lt;metadata&gt;sanitise&lt;/metadata&gt;        &lt;review_comments&gt;sanitise&lt;/review_comments&gt;    &lt;/pptConfig&gt;    &lt;sysConfig&gt;        &lt;interchange_pretty&gt;false&lt;/interchange_pretty&gt;        &lt;interchange_type&gt;sisl&lt;/interchange_type&gt;    &lt;/sysConfig&gt;    &lt;tiffConfig&gt;        &lt;geotiff&gt;sanitise&lt;/geotiff&gt;    &lt;/tiffConfig&gt;    &lt;wordConfig&gt;        &lt;dynamic_data_exchange&gt;sanitise&lt;/dynamic_data_exchange&gt;        &lt;embedded_files&gt;sanitise&lt;/embedded_files&gt;        &lt;embedded_images&gt;sanitise&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;sanitise&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;sanitise&lt;/internal_hyperlinks&gt;        &lt;macros&gt;sanitise&lt;/macros&gt;        &lt;metadata&gt;sanitise&lt;/metadata&gt;        &lt;review_comments&gt;sanitise&lt;/review_comments&gt;    &lt;/wordConfig&gt;    &lt;xlsConfig&gt;        &lt;dynamic_data_exchange&gt;sanitise&lt;/dynamic_data_exchange&gt;        &lt;embedded_files&gt;sanitise&lt;/embedded_files&gt;        &lt;embedded_images&gt;sanitise&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;sanitise&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;sanitise&lt;/internal_hyperlinks&gt;        &lt;macros&gt;sanitise&lt;/macros&gt;        &lt;metadata&gt;sanitise&lt;/metadata&gt;        &lt;review_comments&gt;sanitise&lt;/review_comments&gt;    &lt;/xlsConfig&gt;&lt;/config&gt;```Custom Rebuild policy```pyimport glasswall# Print a custom Rebuild content management policy with a default of allow# that only sanitises macros in wordConfig, and embedded images and files in# xlsConfigprint(glasswall.content_management.policies.Rebuild(    default=&quot;allow&quot;,    config={        &quot;wordConfig&quot;: {            &quot;macros&quot;: &quot;sanitise&quot;,        },        &quot;xlsConfig&quot;: {            &quot;embedded_files&quot;: &quot;sanitise&quot;,            &quot;embedded_images&quot;: &quot;sanitise&quot;,        },    }))``````xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;config&gt;    &lt;pdfConfig&gt;        &lt;acroform&gt;allow&lt;/acroform&gt;        &lt;actions_all&gt;allow&lt;/actions_all&gt;        &lt;digital_signatures&gt;allow&lt;/digital_signatures&gt;        &lt;embedded_files&gt;allow&lt;/embedded_files&gt;        &lt;embedded_images&gt;allow&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;allow&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;allow&lt;/internal_hyperlinks&gt;        &lt;javascript&gt;allow&lt;/javascript&gt;        &lt;metadata&gt;allow&lt;/metadata&gt;    &lt;/pdfConfig&gt;    &lt;pptConfig&gt;        &lt;embedded_files&gt;allow&lt;/embedded_files&gt;        &lt;embedded_images&gt;allow&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;allow&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;allow&lt;/internal_hyperlinks&gt;        &lt;javascript&gt;allow&lt;/javascript&gt;        &lt;macros&gt;allow&lt;/macros&gt;        &lt;metadata&gt;allow&lt;/metadata&gt;        &lt;review_comments&gt;allow&lt;/review_comments&gt;    &lt;/pptConfig&gt;    &lt;sysConfig&gt;        &lt;default&gt;allow&lt;/default&gt;        &lt;interchange_pretty&gt;false&lt;/interchange_pretty&gt;        &lt;interchange_type&gt;sisl&lt;/interchange_type&gt;    &lt;/sysConfig&gt;    &lt;tiffConfig&gt;        &lt;geotiff&gt;allow&lt;/geotiff&gt;    &lt;/tiffConfig&gt;    &lt;wordConfig&gt;        &lt;dynamic_data_exchange&gt;allow&lt;/dynamic_data_exchange&gt;        &lt;embedded_files&gt;allow&lt;/embedded_files&gt;        &lt;embedded_images&gt;allow&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;allow&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;allow&lt;/internal_hyperlinks&gt;        &lt;macros&gt;sanitise&lt;/macros&gt;        &lt;metadata&gt;allow&lt;/metadata&gt;        &lt;review_comments&gt;allow&lt;/review_comments&gt;    &lt;/wordConfig&gt;    &lt;xlsConfig&gt;        &lt;dynamic_data_exchange&gt;allow&lt;/dynamic_data_exchange&gt;        &lt;embedded_files&gt;sanitise&lt;/embedded_files&gt;        &lt;embedded_images&gt;sanitise&lt;/embedded_images&gt;        &lt;external_hyperlinks&gt;allow&lt;/external_hyperlinks&gt;        &lt;internal_hyperlinks&gt;allow&lt;/internal_hyperlinks&gt;        &lt;macros&gt;allow&lt;/macros&gt;        &lt;metadata&gt;allow&lt;/metadata&gt;        &lt;review_comments&gt;allow&lt;/review_comments&gt;    &lt;/xlsConfig&gt;&lt;/config&gt;```---### Editor#### ProtectFiles can be protected individually from a file path or in memory using the [`protect_file`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.protect_file) method, or all files from a directory can be protected using the [`protect_directory`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.protect_directory) method.##### Protect from file path to file path```py   import glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to sanitise a file, writing the sanitised file to a new patheditor.protect_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,    output_file=r&quot;C:\gwpw\output\editor\protect_f2f\TestFile_11.doc&quot;,)```##### Protect from file path to memory`protect_file` returns the protected file's bytes. The below example demonstrates assigning the variable `file_bytes`. We can see that after sanitisation the first 8 bytes of `file_bytes` matches the [file signature](https://en.wikipedia.org/wiki/List_of_file_signatures) for the Microsoft Compound File Binary (CFB) format, `D0 CF 11 E0 A1 B1 1A E1`.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to sanitise a file in memory, returning the file bytes in memoryfile_bytes = editor.protect_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;)assert file_bytes[:8] == b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'```##### Protect from memory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Read file from disk to memorywith open(r&quot;C:\gwpw\input\TestFile_11.doc&quot;, &quot;rb&quot;) as f:    input_bytes = f.read()# Use the default policy to sanitise a filefile_bytes = editor.protect_file(    input_file=input_bytes,)assert file_bytes[:8] == b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'```##### Protect files in a directory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to protect a directory of files, writing the sanitised files to a new directory.editor.protect_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\protect_directory&quot;)```##### Protect files in a directory that may contain unsupported file typesThe default behaviour of the Glasswall Python wrapper is to raise the relevant exception (see: [glasswall.libraries.editor.errors](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/errors.html)) if processing fails. Passing `raise_unsupported=False` will prevent an exception being raised and can be useful when working with a directory containing a mixture of both supported and unsupported file types when it is desired to process as many of the files as possible instead of terminating on the first failure.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to protect a directory of files, writing the sanitised files to a new directory.editor.protect_directory(    input_directory=r&quot;C:\gwpw\input_with_unsupported_file_types&quot;,    output_directory=r&quot;C:\gwpw\output\editor\protect_directory_unsupported&quot;,    raise_unsupported=False)```##### Protect files in a directory using a custom content management policyUsing `glasswall.content_management.policies.Editor`:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use a custom Editor policy to sanitise all files in the input directory# and write them to the input_sanitised directory. If macros are present# in ppt or word files, the file will be marked as non-conforming and blocked.# If internal or external hyperlinks are present in word files they will not# be sanitised, and will remain in the regenerated document.editor.protect_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\protect_directory_custom&quot;,    content_management_policy=glasswall.content_management.policies.Editor(        default=&quot;sanitise&quot;,        config={            &quot;pptConfig&quot;: {                &quot;macros&quot;: &quot;disallow&quot;,            },            &quot;wordConfig&quot;: {                &quot;internal_hyperlinks&quot;: &quot;allow&quot;,                &quot;external_hyperlinks&quot;: &quot;allow&quot;,                &quot;macros&quot;: &quot;disallow&quot;,            }        }    ))```##### Protect files in a directory conditionally based on file formatThe example below demonstrates processing of only doc and docx files from a nested directory containing multiple file formats.```pyimport osimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)input_directory = r&quot;C:\gwpw\input&quot;output_directory = r&quot;C:\gwpw\output\editor\protect_directory_file_format&quot;# Iterate relative file paths from input_directoryfor relative_file in glasswall.utils.list_file_paths(input_directory, absolute=False):    # Construct absolute paths    input_file = os.path.join(input_directory, relative_file)    output_file = os.path.join(output_directory, relative_file)    # Get the file type of the file    file_type = editor.determine_file_type(        input_file=input_file,        as_string=True,        raise_unsupported=False    )    # Protect only doc and docx files    if file_type in [&quot;doc&quot;, &quot;docx&quot;]:        editor.protect_file(input_file, output_file)```---#### AnalysisFiles can be analysed individually from a file path or in memory using the [`analyse_file`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.analyse_file) method, or all files from a directory can be analysed using the [`analyse_directory`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.analyse_directory) method.##### Analyse from file path to file path```py   import glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to analyse a file, writing the analysis report to a new patheditor.analyse_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,    output_file=r&quot;C:\gwpw\output\editor\analyse_f2f\TestFile_11.doc.xml&quot;,)```##### Analyse from file path to memory`analyse_file` returns the analysis report xml file's bytes. The below example demonstrates assigning the variable `analysis_report` and checking the contents of the beginning of an Editor analysis report.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to analyse a fileanalysis_report = editor.analyse_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,)assert analysis_report[:500] == b'&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;gw:GWallInfo xsi:schemaLocation=&quot;http://glasswall.com/namespace/gwallInfo.xsd&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;\n\t&lt;gw:DocumentStatistics&gt;\n\t\t&lt;gw:DocumentSummary&gt;\n\t\t\t&lt;gw:TotalSizeInBytes&gt;35840&lt;/gw:TotalSizeInBytes&gt;\n\t\t\t&lt;gw:FileType&gt;doc&lt;/gw:FileType&gt;\n\t\t\t&lt;gw:Version&gt;Not Applicable&lt;/gw:Version&gt;\n\t\t\t&lt;gw:InputSHA256&gt;9FDE85B8800C1019D2865FA298A7F75873E09870B71F9825827E354B865686A6&lt;/gw:InputSHA256&gt;\n\t\t\t&lt;gw'```##### Analyse from memory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Read file from disk to memorywith open(r&quot;C:\gwpw\input\TestFile_11.doc&quot;, &quot;rb&quot;) as f:    input_bytes = f.read()# Use the default policy to analyse a fileanalysis_report = editor.analyse_file(    input_file=input_bytes,)assert analysis_report[:500] == b'&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;gw:GWallInfo xsi:schemaLocation=&quot;http://glasswall.com/namespace/gwallInfo.xsd&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;\n\t&lt;gw:DocumentStatistics&gt;\n\t\t&lt;gw:DocumentSummary&gt;\n\t\t\t&lt;gw:TotalSizeInBytes&gt;35840&lt;/gw:TotalSizeInBytes&gt;\n\t\t\t&lt;gw:FileType&gt;doc&lt;/gw:FileType&gt;\n\t\t\t&lt;gw:Version&gt;Not Applicable&lt;/gw:Version&gt;\n\t\t\t&lt;gw:InputSHA256&gt;9FDE85B8800C1019D2865FA298A7F75873E09870B71F9825827E354B865686A6&lt;/gw:InputSHA256&gt;\n\t\t\t&lt;gw'```##### Analyse files in a directory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to analyse a directory of files, writing the analysis reports to a new directory.editor.analyse_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\analyse_directory&quot;)```##### Analyse files in a directory that may contain unsupported file typesThe default behaviour of the Glasswall Python wrapper is to raise the relevant exception (see: [glasswall.libraries.editor.errors](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/errors.html)) if processing fails. Passing `raise_unsupported=False` will prevent an exception being raised and can be useful when working with a directory containing a mixture of both supported and unsupported file types when it is desired to process as many of the files as possible instead of terminating on the first failure.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to analyse a directory of files, writing the analysis reports to a new directory.editor.analyse_directory(    input_directory=r&quot;C:\gwpw\input_with_unsupported_file_types&quot;,    output_directory=r&quot;C:\gwpw\output\editor\analyse_directory_unsupported&quot;,    raise_unsupported=False)```##### Analyse files in a directory using a custom content management policyUsing `glasswall.content_management.policies.Editor`:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use a custom Editor policy to analyse all files in the input directory# and write them to analyse_directory_custom directory. If macros are# present in ppt or word files, a GeneralFail exception will be raised if the# raise_unsupported argument is left at it's default value of False, but the# analysis report will still be written to file and will contain IssueItems.# If internal or external hyperlinks are present in word files they will not# be sanitised, and will remain in the regenerated document.editor.analyse_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\analyse_directory_custom&quot;,    content_management_policy=glasswall.content_management.policies.Editor(        default=&quot;sanitise&quot;,        config={            &quot;pptConfig&quot;: {                &quot;macros&quot;: &quot;disallow&quot;,            },            &quot;wordConfig&quot;: {                &quot;internal_hyperlinks&quot;: &quot;allow&quot;,                &quot;external_hyperlinks&quot;: &quot;allow&quot;,                &quot;macros&quot;: &quot;disallow&quot;,            }        }    ),    raise_unsupported=False)```##### Analyse files in a directory conditionally based on file formatThe example below demonstrates processing of only doc and docx files from a nested directory containing multiple file formats.```pyimport osimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)input_directory = r&quot;C:\gwpw\input&quot;output_directory = r&quot;C:\gwpw\output\editor\analyse_directory_file_format&quot;# Iterate relative file paths from input_directoryfor relative_file in glasswall.utils.list_file_paths(input_directory, absolute=False):    # Construct absolute paths    input_file = os.path.join(input_directory, relative_file)    output_file = os.path.join(output_directory, relative_file + &quot;.xml&quot;)    # Get the file type of the file    file_type = editor.determine_file_type(        input_file=input_file,        as_string=True,        raise_unsupported=False    )    # Analyse only doc and docx files    if file_type in [&quot;doc&quot;, &quot;docx&quot;]:        editor.analyse_file(input_file, output_file)```---#### ExportFiles can be exported individually from a file path or in memory using the [`export_file`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.export_file) method, or all files from a directory can be exported using the [`export_directory`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.export_directory) method.##### Export from file path to file path```py   import glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to export a file, writing the export archive to a new patheditor.export_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,    output_file=r&quot;C:\gwpw\output\editor\export_f2f\TestFile_11.doc.zip&quot;,)```##### Export from file path to memory`export_file` returns the exported archive file's bytes. The below example demonstrates assigning the variable `export_archive` and checking the contents of the beginning of an Editor export archive.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to export a fileexport_archive = editor.export_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,)assert export_archive[:8] == b'PK\x03\x04\x14\x00\x0e\x00'```##### Export from memory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Read file from disk to memorywith open(r&quot;C:\gwpw\input\TestFile_11.doc&quot;, &quot;rb&quot;) as f:    input_bytes = f.read()# Use the default policy to export a fileexport_archive = editor.export_file(    input_file=input_bytes,)assert export_archive[:8] == b'PK\x03\x04\x14\x00\x0e\x00'```##### Export files in a directory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to export a directory of files, writing the export archives to a new directory.editor.export_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\export_directory&quot;)```##### Export files in a directory that may contain unsupported file typesThe default behaviour of the Glasswall Python wrapper is to raise the relevant exception (see: [glasswall.libraries.editor.errors](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/errors.html)) if processing fails. Passing `raise_unsupported=False` will prevent an exception being raised and can be useful when working with a directory containing a mixture of both supported and unsupported file types when it is desired to process as many of the files as possible instead of terminating on the first failure.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to export a directory of files, writing the export archives to a new directory.editor.export_directory(    input_directory=r&quot;C:\gwpw\input_with_unsupported_file_types&quot;,    output_directory=r&quot;C:\gwpw\output\editor\export_directory_unsupported&quot;,    raise_unsupported=False)```##### Export files in a directory using a custom content management policyUsing `glasswall.content_management.policies.Editor`:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use a custom Editor policy to export all files in the input directory# and write them to export_directory_custom directory. Write streams as# &quot;.xml&quot; instead of the default interchange_type, &quot;.sisl&quot;. Export embedded# images as &quot;.xml&quot; instead of their default image file type.editor.export_directory(    input_directory=r&quot;C:\gwpw\input&quot;,    output_directory=r&quot;C:\gwpw\output\editor\export_directory_custom&quot;,    content_management_policy=glasswall.content_management.policies.Editor(        default=&quot;sanitise&quot;,        config={            &quot;sysConfig&quot;: {                &quot;interchange_type&quot;: &quot;xml&quot;,                &quot;export_embedded_images&quot;: &quot;true&quot;,            },        }    ),    raise_unsupported=False)```##### Export files in a directory conditionally based on file formatThe example below demonstrates processing of only doc and docx files from a nested directory containing multiple file formats.```pyimport osimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)input_directory = r&quot;C:\gwpw\input&quot;output_directory = r&quot;C:\gwpw\output\editor\export_directory_file_format&quot;# Iterate relative file paths from input_directoryfor relative_file in glasswall.utils.list_file_paths(input_directory, absolute=False):    # Construct absolute paths    input_file = os.path.join(input_directory, relative_file)    output_file = os.path.join(output_directory, relative_file + &quot;.zip&quot;)    # Get the file type of the file    file_type = editor.determine_file_type(        input_file=input_file,        as_string=True,        raise_unsupported=False    )    # Export only doc and docx files    if file_type in [&quot;doc&quot;, &quot;docx&quot;]:        editor.export_file(input_file, output_file)```---#### ImportExport archives can be imported individually from a file path or in memory using the [`import_file`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.import_file) method, or all export archives from a directory can be imported using the [`import_directory`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/editor.html#glasswall.libraries.editor.editor.Editor.import_directory) method.##### Import from file path to file path```py   import glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to import an export archive, writing the imported file to a new patheditor.import_file(    input_file=r&quot;C:\gwpw\output\editor\export_f2f\TestFile_11.doc.zip&quot;,    output_file=r&quot;C:\gwpw\output\editor\import_f2f\TestFile_11.doc&quot;,)```##### Import from file path to memory`import_file` returns the imported file's bytes. The below example demonstrates assigning the variable `file_bytes` and checking the contents of the beginning of an Editor export archive.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to import an export archivefile_bytes = editor.import_file(    input_file=r&quot;C:\gwpw\output\editor\export_f2f\TestFile_11.doc.zip&quot;,)assert file_bytes[:8] == b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'```##### Import from memory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Read file from disk to memorywith open(r&quot;C:\gwpw\output\editor\export_f2f\TestFile_11.doc.zip&quot;, &quot;rb&quot;) as f:    export_archive_bytes = f.read()# Use the default policy to import an export archivefile_bytes = editor.import_file(    input_file=export_archive_bytes,)assert file_bytes[:8] == b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'```##### Import files in a directory```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to import a directory of export archives, writing the import archives to a new directory.editor.import_directory(    input_directory=r&quot;C:\gwpw\output\editor\export_directory&quot;,    output_directory=r&quot;C:\gwpw\output\editor\import_directory&quot;)```##### Import files in a directory that may contain unsupported file typesThe default behaviour of the Glasswall Python wrapper is to raise the relevant exception (see: [glasswall.libraries.editor.errors](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/editor/errors.html)) if processing fails. Passing `raise_unsupported=False` will prevent an exception being raised and can be useful when working with a directory containing a mixture of both supported and unsupported file types when it is desired to process as many of the files as possible instead of terminating on the first failure.```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default policy to export a directory of export archives, writing the export archives to a new directory.editor.import_directory(    input_directory=r&quot;C:\gwpw\output\editor\export_directory_unsupported&quot;,    output_directory=r&quot;C:\gwpw\output\editor\import_directory_unsupported&quot;,    raise_unsupported=False)```##### Import files in a directory using a custom content management policyUsing `glasswall.content_management.policies.Editor`:```pyimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use a custom Editor policy to import all files in the export directory# and write them to import_directory_custom directory. Read streams as# &quot;.xml&quot; instead of the default interchange_type, &quot;.sisl&quot;.editor.import_directory(    input_directory=r&quot;C:\gwpw\output\editor\export_directory_custom&quot;,    output_directory=r&quot;C:\gwpw\output\editor\import_directory_custom&quot;,    content_management_policy=glasswall.content_management.policies.Editor(        default=&quot;sanitise&quot;,        config={            &quot;sysConfig&quot;: {                &quot;interchange_type&quot;: &quot;xml&quot;,            },        }    ),    raise_unsupported=False)```##### Import files in a directory conditionally based on file formatThe example below demonstrates processing of only doc and docx files from a nested directory containing multiple file formats.```pyimport osimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)input_directory = r&quot;C:\gwpw\output\editor\export_directory_file_format&quot;output_directory = r&quot;C:\gwpw\output\editor\import_directory_file_format&quot;# Iterate relative file paths from input_directoryfor relative_file in glasswall.utils.list_file_paths(input_directory, absolute=False):    # Construct absolute paths    input_file = os.path.join(input_directory, relative_file)    output_file = os.path.join(output_directory, os.path.splitext(relative_file)[0])    # Get the file type of the file    file_type = editor.determine_file_type(        input_file=input_file,        as_string=True,        raise_unsupported=False    )    # Import only doc.zip and docx.zip files    if file_type == &quot;zip&quot; and input_file.endswith((&quot;doc.zip&quot;, &quot;docx.zip&quot;,)):        editor.import_file(input_file, output_file)```---### RebuildSee [Editor](#editor) documentation. High level functionality is the same between the Editor and Rebuild classes, simply use the Rebuild class instead of the Editor class:```pyimport glasswall# Load the Glasswall Rebuild libraryrebuild = glasswall.Rebuild(r&quot;C:\gwpw\libraries\rebuild\1.661.0&quot;)# Use the default policy to sanitise a file, writing the sanitised file to a new pathrebuild.protect_file(    input_file=r&quot;C:\gwpw\input\TestFile_11.doc&quot;,    output_file=r&quot;C:\gwpw\output\rebuild\protect_f2f\TestFile_11.doc&quot;,)```---### Archive Manager##### Protect an archive```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use the default Archive Manager policy: sanitise all, process all, writing# the sanitised archive and the analysis report to the output directory.am.protect_archive(    input_file=r&quot;C:\gwpw\input_archives\7Zip\0000001.jpg.7z&quot;,    output_file=r&quot;C:\gwpw\output\archive_manager\protect_archive\7Zip\0000001.jpg.7z&quot;,    output_report=r&quot;C:\gwpw\output\archive_manager\protect_archive\7Zip\0000001.jpg.7z.xml&quot;)```##### Protect all archives in a directory using a custom content management policy```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Use a custom Archive Manager policy: sanitise all, process all, but discard# mp3 and mp4 files. Write the sanitised archives and the analysis reports to# different directoriesam.protect_directory(    input_directory=r&quot;C:\gwpw\input_archives&quot;,    output_directory=r&quot;C:\gwpw\output\archive_manager\protect_directory_custom&quot;,    output_report_directory=r&quot;C:\gwpw\output\archive_manager\protect_directory_custom_reports&quot;,    content_management_policy=glasswall.content_management.policies.ArchiveManager(        default=&quot;sanitise&quot;,        default_archive_manager=&quot;process&quot;,        config={            &quot;archiveConfig&quot;: {                &quot;mp3&quot;: &quot;discard&quot;,                &quot;mp4&quot;: &quot;discard&quot;            }        }    ),    raise_unsupported=False)```#### Extraction - Unpacking an archive```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Unpack the Nested_4_layers.zip archive to a new directoryam.unpack(    input_file=r&quot;C:\gwpw\input_archives\Nested_4_layers.zip&quot;,    output_directory=r&quot;C:\gwpw\output\archive_manager\unpack&quot;)```A new directory is created: `C:\gwpw\output\archive_manager\unpack\Nested_4_layers` containing the unpacked contents of the `Nested_4_layers` zip archive. Nested archives are recursively unpacked while maintaining the same directory structure. To disable recursive unpacking use the `recursive` arg:```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Unpack the Nested_4_layers.zip archive to a new directory without recursing the archive.am.unpack(    input_file=r&quot;C:\gwpw\input_archives\Nested_4_layers.zip&quot;,    output_directory=r&quot;C:\gwpw\output\archive_manager\unpack_nonrecursive&quot;,    recursive=False)```##### Other useful arguments when unpacking- `include_file_type` default False, keep the archive format in the directory name when unpacking. e.g. when True `Nested_4_layers.zip` will be unpacked to a directory `Nested_4_layers.zip` instead of `Nested_4_layers`. This can be necessary when unpacking multiple same-named archives that have different archive formats.- `raise_unsupported` default True, raise an error if the Glasswall library encounters an error.- `delete_origin` default False, delete the `input_file` after it has been unpacked to `output_directory`.#### Extraction - Unpacking a directory of archives```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Recursively unpack all archives found in the `archives` directoryam.unpack_directory(    input_directory=r&quot;C:\gwpw\input_archives&quot;,    output_directory=r&quot;C:\gwpw\output\archive_manager\unpack_directory&quot;)```The `unpack_directory` method shares the same optional arguments as `unpack`. See also: `Extraction - Unpacking an archive`#### Compression - Packing a directory into an archive```pyimport glasswall# Load the Glasswall Archive Manager libraryam = glasswall.ArchiveManager(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Pack the `input_archives` directory as zip to `input_archives.zip` in the 'C:\gwpw\output\archive_manager\pack' directoryam.pack_directory(    input_directory=r&quot;C:\gwpw\input_archives&quot;,    output_directory=r&quot;C:\gwpw\output\archive_manager\pack&quot;,    file_type=&quot;zip&quot;,)```---### WordSearchGlasswall WordSearch can be used to redact text from files and generates an XML report on the redacted file's details.This report includes details on the file size, the determined file type, the total number of text matches, and the location of each of the text matches.&lt;details&gt;    &lt;summary&gt;Example report&lt;/summary&gt;```xml&lt;gw:WordSearchStatistics xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;&lt;gw:DocumentSummary&gt;&lt;gw:TotalSizeInBytes&gt;13084&lt;/gw:TotalSizeInBytes&gt;&lt;gw:FileType&gt;docx&lt;/gw:FileType&gt;&lt;gw:TotalItemMatchCount&gt;8&lt;/gw:TotalItemMatchCount&gt;&lt;/gw:DocumentSummary&gt;&lt;gw:WordItem&gt;&lt;gw:Name&gt;ipsum&lt;/gw:Name&gt;&lt;gw:ItemMatchCount&gt;5&lt;/gw:ItemMatchCount&gt;&lt;gw:Locations&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;120&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;267&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;691&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;973&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;1034&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;/gw:Locations&gt;&lt;/gw:WordItem&gt;&lt;gw:WordItem&gt;&lt;gw:Name&gt;lorem&lt;/gw:Name&gt;&lt;gw:ItemMatchCount&gt;3&lt;/gw:ItemMatchCount&gt;&lt;gw:Locations&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;114&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;244&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;gw:Location&gt;&lt;gw:Offset&gt;1224&lt;/gw:Offset&gt;&lt;gw:Page&gt;0&lt;/gw:Page&gt;&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;&lt;/gw:Location&gt;&lt;/gw:Locations&gt;&lt;/gw:WordItem&gt;&lt;/gw:WordSearchStatistics&gt;```&lt;/details&gt;A homoglyphs JSON file can be specified either as a file path or in memory as bytes, bytearray, or io.BytesIO. If this is not specified then the default will be used:&lt;details&gt;    &lt;summary&gt;Default homoglyphs.json file&lt;/summary&gt;```json{&quot;!&quot;: &quot;ǃⵑ&quot;,&quot;$&quot;: &quot;＄&quot;,&quot;%&quot;: &quot;％&quot;,&quot;&amp;&quot;: &quot;ꝸ＆&quot;,&quot;'&quot;: &quot;`´ʹʻʼʽʾˈˊˋ˴ʹ΄՚՝י׳ߴߵᑊᛌ᾽᾿`´῾‘’‛′‵ꞌ＇｀𖽑𖽒&quot;,&quot;(&quot;: &quot;❨❲〔﴾（［&quot;,&quot;)&quot;: &quot;❩❳〕﴿）］&quot;,&quot;*&quot;: &quot;٭⁎∗＊𐌟&quot;,&quot;+&quot;: &quot;᛭＋𐊛&quot;,&quot;,&quot;: &quot;¸؍٫‚ꓹ，&quot;,&quot;-&quot;: &quot;˗۔‐‑‒–⁃−➖Ⲻ﹘&quot;,&quot;.&quot;: &quot;٠۰܁܂․ꓸ꘎．𐩐𝅭&quot;,&quot;/&quot;: &quot;᜵⁁⁄∕╱⟋⧸Ⳇ⼃〳ノ㇓丿／𝈺&quot;,&quot;0&quot;: &quot;OoΟοσОоՕօסه٥ھہە۵߀०০੦૦ଠ୦௦ం౦ಂ೦ംഠ൦ං๐໐ဝ၀ჿዐᴏᴑℴⲞⲟⵔ〇ꓳꬽﮦﮧﮨﮩﮪﮫﮬﮭﻩﻪﻫﻬ０Ｏｏ𐊒𐊫𐐄𐐬𐓂𐓪𐔖𑓐𑢵𑣈𑣗𑣠𝐎𝐨𝑂𝑜𝑶𝒐𝒪𝓞𝓸𝔒𝔬𝕆𝕠𝕺𝖔𝖮𝗈𝗢𝗼𝘖𝘰𝙊𝙤𝙾𝚘𝚶𝛐𝛔𝛰𝜊𝜎𝜪𝝄𝝈𝝤𝝾𝞂𝞞𝞸𝞼𝟎𝟘𝟢𝟬𝟶𞸤𞹤𞺄&quot;,&quot;1&quot;: &quot;Il|ƖǀΙІӀ׀וןا١۱ߊᛁℐℑℓⅠⅼ∣⏽Ⲓⵏꓲﺍﺎ１Ｉｌ￨𐊊𐌉𐌠𖼨𝐈𝐥𝐼𝑙𝑰𝒍𝓁𝓘𝓵𝔩𝕀𝕝𝕴𝖑𝖨𝗅𝗜𝗹𝘐𝘭𝙄𝙡𝙸𝚕𝚰𝛪𝜤𝝞𝞘𝟏𝟙𝟣𝟭𝟷𞣇𞸀𞺀&quot;,&quot;2&quot;: &quot;ƧϨᒿꙄꛯꝚ２𝟐𝟚𝟤𝟮𝟸&quot;,&quot;3&quot;: &quot;ƷȜЗӠⳌꝪꞫ３𑣊𖼻𝈆𝟑𝟛𝟥𝟯𝟹&quot;,&quot;4&quot;: &quot;Ꮞ４𑢯𝟒𝟜𝟦𝟰𝟺&quot;,&quot;5&quot;: &quot;Ƽ５𑢻𝟓𝟝𝟧𝟱𝟻&quot;,&quot;6&quot;: &quot;бᏮⳒ６𑣕𝟔𝟞𝟨𝟲𝟼&quot;,&quot;7&quot;: &quot;７𐓒𑣆𝈒𝟕𝟟𝟩𝟳𝟽&quot;,&quot;8&quot;: &quot;Ȣȣ৪੪ଃ８𐌚𝟖𝟠𝟪𝟴𝟾𞣋&quot;,&quot;9&quot;: &quot;৭੧୨൭ⳊꝮ９𑢬𑣌𑣖𝟗𝟡𝟫𝟵𝟿&quot;,&quot;A&quot;: &quot;4ΑАᎪᗅᴀꓮꭺＡ𐊠𖽀𝐀𝐴𝑨𝒜𝓐𝔄𝔸𝕬𝖠𝗔𝘈𝘼𝙰𝚨𝛢𝜜𝝖𝞐&quot;,&quot;B&quot;: &quot;ʙΒВвᏴᏼᗷᛒℬꓐꞴＢ𐊂𐊡𐌁𝐁𝐵𝑩𝓑𝔅𝔹𝕭𝖡𝗕𝘉𝘽𝙱𝚩𝛣𝜝𝝗𝞑&quot;,&quot;C&quot;: &quot;ϹСᏟℂℭⅭⲤꓚＣ𐊢𐌂𐐕𐔜𑣩𑣲𝐂𝐶𝑪𝒞𝓒𝕮𝖢𝗖𝘊𝘾𝙲🝌&quot;,&quot;D&quot;: &quot;ᎠᗞᗪᴅⅅⅮꓓꭰＤ𝐃𝐷𝑫𝒟𝓓𝔇𝔻𝕯𝖣𝗗𝘋𝘿𝙳&quot;,&quot;E&quot;: &quot;ΕЕᎬᴇℰ⋿ⴹꓰꭼＥ𐊆𑢦𑢮𝐄𝐸𝑬𝓔𝔈𝔼𝕰𝖤𝗘𝘌𝙀𝙴𝚬𝛦𝜠𝝚𝞔&quot;,&quot;F&quot;: &quot;ϜᖴℱꓝꞘＦ𐊇𐊥𐔥𑢢𑣂𝈓𝐅𝐹𝑭𝓕𝔉𝔽𝕱𝖥𝗙𝘍𝙁𝙵𝟊&quot;,&quot;G&quot;: &quot;ɢԌԍᏀᏳᏻꓖꮐＧ𝐆𝐺𝑮𝒢𝓖𝔊𝔾𝕲𝖦𝗚𝘎𝙂𝙶&quot;,&quot;H&quot;: &quot;ʜΗНнᎻᕼℋℌℍⲎꓧꮋＨ𐋏𝐇𝐻𝑯𝓗𝕳𝖧𝗛𝘏𝙃𝙷𝚮𝛨𝜢𝝜𝞖&quot;,&quot;I&quot;: &quot;&quot;,&quot;J&quot;: &quot;ͿЈᎫᒍᴊꓙꞲꭻＪ𝐉𝐽𝑱𝒥𝓙𝔍𝕁𝕵𝖩𝗝𝘑𝙅𝙹&quot;,&quot;K&quot;: &quot;ΚКᏦᛕKⲔꓗＫ𐔘𝐊𝐾𝑲𝒦𝓚𝔎𝕂𝕶𝖪𝗞𝘒𝙆𝙺𝚱𝛫𝜥𝝟𝞙&quot;,&quot;L&quot;: &quot;ʟᏞᒪℒⅬⳐⳑꓡꮮＬ𐐛𐑃𐔦𑢣𑢲𖼖𝈪𝐋𝐿𝑳𝓛𝔏𝕃𝕷𝖫𝗟𝘓𝙇𝙻&quot;,&quot;M&quot;: &quot;ΜϺМᎷᗰᛖℳⅯⲘꓟＭ𐊰𐌑𝐌𝑀𝑴𝓜𝔐𝕄𝕸𝖬𝗠𝘔𝙈𝙼𝚳𝛭𝜧𝝡𝞛&quot;,&quot;N&quot;: &quot;ɴΝℕⲚꓠＮ𐔓𝐍𝑁𝑵𝒩𝓝𝔑𝕹𝖭𝗡𝘕𝙉𝙽𝚴𝛮𝜨𝝢𝞜&quot;,&quot;O&quot;: &quot;0&quot;,&quot;P&quot;: &quot;ΡРᏢᑭᴘᴩℙⲢꓑꮲＰ𐊕𝐏𝑃𝑷𝒫𝓟𝔓𝕻𝖯𝗣𝘗𝙋𝙿𝚸𝛲𝜬𝝦𝞠&quot;,&quot;Q&quot;: &quot;ℚⵕＱ𝐐𝑄𝑸𝒬𝓠𝔔𝕼𝖰𝗤𝘘𝙌𝚀&quot;,&quot;R&quot;: &quot;ƦʀᎡᏒᖇᚱℛℜℝꓣꭱꮢＲ𐒴𖼵𝈖𝐑𝑅𝑹𝓡𝕽𝖱𝗥𝘙𝙍𝚁&quot;,&quot;S&quot;: &quot;$ЅՏᏕᏚꓢＳ𐊖𐐠𖼺𝐒𝑆𝑺𝒮𝓢𝔖𝕊𝕾𝖲𝗦𝘚𝙎𝚂&quot;,&quot;T&quot;: &quot;ŤΤτТтᎢᴛ⊤⟙ⲦꓔꭲＴ𐊗𐊱𐌕𑢼𖼊𝐓𝑇𝑻𝒯𝓣𝔗𝕋𝕿𝖳𝗧𝘛𝙏𝚃𝚻𝛕𝛵𝜏𝜯𝝉𝝩𝞃𝞣𝞽🝨&quot;,&quot;U&quot;: &quot;Սሀᑌ∪⋃ꓴＵ𐓎𑢸𖽂𝐔𝑈𝑼𝒰𝓤𝔘𝕌𝖀𝖴𝗨𝘜𝙐𝚄&quot;,&quot;V&quot;: &quot;Ѵ٧۷ᏙᐯⅤⴸꓦꛟＶ𐔝𑢠𖼈𝈍𝐕𝑉𝑽𝒱𝓥𝔙𝕍𝖁𝖵𝗩𝘝𝙑𝚅&quot;,&quot;W&quot;: &quot;ԜᎳᏔꓪＷ𑣦𑣯𝐖𝑊𝑾𝒲𝓦𝔚𝕎𝖂𝖶𝗪𝘞𝙒𝚆&quot;,&quot;X&quot;: &quot;ΧХ᙭ᚷⅩ╳ⲬⵝꓫꞳＸ𐊐𐊴𐌗𐌢𐔧𑣬𝐗𝑋𝑿𝒳𝓧𝔛𝕏𝖃𝖷𝗫𝘟𝙓𝚇𝚾𝛸𝜲𝝬𝞦&quot;,&quot;Y&quot;: &quot;ΥϒУҮᎩᎽⲨꓬＹ𐊲𑢤𖽃𝐘𝑌𝒀𝒴𝓨𝔜𝕐𝖄𝖸𝗬𝘠𝙔𝚈𝚼𝛶𝜰𝝪𝞤&quot;,&quot;Z&quot;: &quot;ΖᏃℤℨꓜＺ𐋵𑢩𑣥𝐙𝑍𝒁𝒵𝓩𝖅𝖹𝗭𝘡𝙕𝚉𝚭𝛧𝜡𝝛𝞕&quot;,&quot;a&quot;: &quot;@ɑαа⍺ａ𝐚𝑎𝒂𝒶𝓪𝔞𝕒𝖆𝖺𝗮𝘢𝙖𝚊𝛂𝛼𝜶𝝰𝞪&quot;,&quot;b&quot;: &quot;ƄЬᏏᖯｂ𝐛𝑏𝒃𝒷𝓫𝔟𝕓𝖇𝖻𝗯𝘣𝙗𝚋&quot;,&quot;c&quot;: &quot;ϲсᴄⅽⲥꮯｃ𐐽𝐜𝑐𝒄𝒸𝓬𝔠𝕔𝖈𝖼𝗰𝘤𝙘𝚌&quot;,&quot;d&quot;: &quot;ԁᏧᑯⅆⅾꓒｄ𝐝𝑑𝒅𝒹𝓭𝔡𝕕𝖉𝖽𝗱𝘥𝙙𝚍&quot;,&quot;e&quot;: &quot;еҽ℮ℯⅇꬲｅ𝐞𝑒𝒆𝓮𝔢𝕖𝖊𝖾𝗲𝘦𝙚𝚎&quot;,&quot;f&quot;: &quot;ſϝքẝꞙꬵｆ𝐟𝑓𝒇𝒻𝓯𝔣𝕗𝖋𝖿𝗳𝘧𝙛𝚏𝟋&quot;,&quot;g&quot;: &quot;ƍɡցᶃℊｇ𝐠𝑔𝒈𝓰𝔤𝕘𝖌𝗀𝗴𝘨𝙜𝚐&quot;,&quot;h&quot;: &quot;һհᏂℎｈ𝐡𝒉𝒽𝓱𝔥𝕙𝖍𝗁𝗵𝘩𝙝𝚑&quot;,&quot;i&quot;: &quot;ıɩɪ˛ͺιіӏᎥιℹⅈⅰ⍳ꙇꭵｉ𑣃𝐢𝑖𝒊𝒾𝓲𝔦𝕚𝖎𝗂𝗶𝘪𝙞𝚒𝚤𝛊𝜄𝜾𝝸𝞲&quot;,&quot;j&quot;: &quot;ϳјⅉｊ𝐣𝑗𝒋𝒿𝓳𝔧𝕛𝖏𝗃𝗷𝘫𝙟𝚓&quot;,&quot;k&quot;: &quot;ｋ𝐤𝑘𝒌𝓀𝓴𝔨𝕜𝖐𝗄𝗸𝘬𝙠𝚔&quot;,&quot;l&quot;: &quot;1&quot;,&quot;m&quot;: &quot;ｍ&quot;,&quot;n&quot;: &quot;ոռｎ𝐧𝑛𝒏𝓃𝓷𝔫𝕟𝖓𝗇𝗻𝘯𝙣𝚗&quot;,&quot;o&quot;: &quot;&quot;,&quot;p&quot;: &quot;ρϱр⍴ⲣｐ𝐩𝑝𝒑𝓅𝓹𝔭𝕡𝖕𝗉𝗽𝘱𝙥𝚙𝛒𝛠𝜌𝜚𝝆𝝔𝞀𝞎𝞺𝟈&quot;,&quot;q&quot;: &quot;ԛգզｑ𝐪𝑞𝒒𝓆𝓺𝔮𝕢𝖖𝗊𝗾𝘲𝙦𝚚&quot;,&quot;r&quot;: &quot;гᴦⲅꭇꭈꮁｒ𝐫𝑟𝒓𝓇𝓻𝔯𝕣𝖗𝗋𝗿𝘳𝙧𝚛&quot;,&quot;s&quot;: &quot;$ƽѕꜱꮪｓ𐑈𑣁𝐬𝑠𝒔𝓈𝓼𝔰𝕤𝖘𝗌𝘀𝘴𝙨𝚜&quot;,&quot;t&quot;: &quot;ｔ𝐭𝑡𝒕𝓉𝓽𝔱𝕥𝖙𝗍𝘁𝘵𝙩𝚝&quot;,&quot;u&quot;: &quot;ʋυսᴜꞟꭎꭒｕ𐓶𑣘𝐮𝑢𝒖𝓊𝓾𝔲𝕦𝖚𝗎𝘂𝘶𝙪𝚞𝛖𝜐𝝊𝞄𝞾&quot;,&quot;v&quot;: &quot;νѵטᴠⅴ∨⋁ꮩｖ𑜆𑣀𝐯𝑣𝒗𝓋𝓿𝔳𝕧𝖛𝗏𝘃𝘷𝙫𝚟𝛎𝜈𝝂𝝼𝞶&quot;,&quot;w&quot;: &quot;ɯѡԝաᴡꮃｗ𑜊𑜎𑜏𝐰𝑤𝒘𝓌𝔀𝔴𝕨𝖜𝗐𝘄𝘸𝙬𝚠&quot;,&quot;x&quot;: &quot;×хᕁᕽ᙮ⅹ⤫⤬⨯ｘ𝐱𝑥𝒙𝓍𝔁𝔵𝕩𝖝𝗑𝘅𝘹𝙭𝚡&quot;,&quot;y&quot;: &quot;ɣʏγуүყᶌỿℽꭚｙ𑣜𝐲𝑦𝒚𝓎𝔂𝔶𝕪𝖞𝗒𝘆𝘺𝙮𝚢𝛄𝛾𝜸𝝲𝞬&quot;,&quot;z&quot;: &quot;ᴢꮓｚ𑣄𝐳𝑧𝒛𝓏𝔃𝔷𝕫𝖟𝗓𝘇𝘻𝙯𝚣&quot;,&quot;£&quot;: &quot;₤&quot;,&quot;©&quot;: &quot;Ⓒ&quot;,&quot;®&quot;: &quot;Ⓡ&quot;}```&lt;/details&gt;#### RedactFiles can be redacted individually from a file path or in memory using the [`redact_file`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/word_search/word_search.html#glasswall.libraries.word_search.word_search.WordSearch.redact_file) method, or all files from a directory can be redacted using the [`redact_directory`](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/word_search/word_search.html#glasswall.libraries.word_search.word_search.WordSearch.redact_directory) method.##### Redact from file path to file path```pyimport glasswall# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within the input file, writing the redacted file to a new pathword_search.redact_file(    input_file=r&quot;C:\gwpw\input_redact\lorem_ipsum.docx&quot;,    output_file=r&quot;C:\gwpw\output\word_search\redact_f2f\lorem_ipsum.docx&quot;,    content_management_policy=glasswall.content_management.policies.WordSearch(        config={            &quot;textSearchConfig&quot;: {                &quot;@libVersion&quot;: &quot;core2&quot;,                &quot;textList&quot;: [                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                ]            }        }    ))```##### Redact from file path to memory`redact_file` returns an object with the attributes: &quot;status&quot; (int), &quot;output_file&quot; (bytes), &quot;output_report&quot; (bytes). The below example demonstrates assigning the variable `result` and checking the contents of the beginning of the redacted output_file and the output_report.```pyimport glasswall# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within the input file, writing the redacted file to a new pathresult = word_search.redact_file(    input_file=r&quot;C:\gwpw\input_redact\lorem_ipsum.docx&quot;,    output_file=None,    content_management_policy=glasswall.content_management.policies.WordSearch(        config={            &quot;textSearchConfig&quot;: {                &quot;@libVersion&quot;: &quot;core2&quot;,                &quot;textList&quot;: [                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                ]            }        }    ))assert result.output_file[:6] == b'PK\x03\x04\x14\x00'assert result.output_report[:500] == b'&lt;gw:WordSearchStatistics xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;\n\t&lt;gw:DocumentSummary&gt;\n\t\t&lt;gw:TotalSizeInBytes&gt;14292&lt;/gw:TotalSizeInBytes&gt;\n\t\t&lt;gw:FileType&gt;docx&lt;/gw:FileType&gt;\n\t\t&lt;gw:TotalItemMatchCount&gt;14&lt;/gw:TotalItemMatchCount&gt;\n\t&lt;/gw:DocumentSummary&gt;\n\t&lt;gw:WordItem&gt;\n\t\t&lt;gw:Name&gt;ipsum&lt;/gw:Name&gt;\n\t\t&lt;gw:ItemMatchCount&gt;8&lt;/gw:ItemMatchCount&gt;\n\t\t&lt;gw:Locations&gt;\n\t\t\t&lt;gw:Location&gt;\n\t\t\t\t&lt;gw:Offset&gt;120&lt;/gw:Offset&gt;\n\t\t\t\t&lt;gw:Page&gt;0&lt;/gw:Page&gt;\n\t\t\t\t&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;\n\t\t\t&lt;/gw:Location&gt;\n\t\t\t&lt;gw:Location&gt;\n\t\t\t'```##### Redact from memory```pyimport glasswall# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Read file from disk to memorywith open(r&quot;C:\gwpw\input_redact\lorem_ipsum.docx&quot;, &quot;rb&quot;) as f:    input_bytes = f.read()# Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within the input file, writing the redacted file to a new pathresult = word_search.redact_file(    input_file=input_bytes,    output_file=r&quot;C:\gwpw\output\word_search\redact_m2f\lorem_ipsum.docx&quot;,    content_management_policy=glasswall.content_management.policies.WordSearch(        config={            &quot;textSearchConfig&quot;: {                &quot;@libVersion&quot;: &quot;core2&quot;,                &quot;textList&quot;: [                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                ]            }        }    ))assert result.output_file[:6] == b'PK\x03\x04\x14\x00'assert result.output_report[:500] == b'&lt;gw:WordSearchStatistics xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;\n\t&lt;gw:DocumentSummary&gt;\n\t\t&lt;gw:TotalSizeInBytes&gt;14292&lt;/gw:TotalSizeInBytes&gt;\n\t\t&lt;gw:FileType&gt;docx&lt;/gw:FileType&gt;\n\t\t&lt;gw:TotalItemMatchCount&gt;14&lt;/gw:TotalItemMatchCount&gt;\n\t&lt;/gw:DocumentSummary&gt;\n\t&lt;gw:WordItem&gt;\n\t\t&lt;gw:Name&gt;ipsum&lt;/gw:Name&gt;\n\t\t&lt;gw:ItemMatchCount&gt;8&lt;/gw:ItemMatchCount&gt;\n\t\t&lt;gw:Locations&gt;\n\t\t\t&lt;gw:Location&gt;\n\t\t\t\t&lt;gw:Offset&gt;120&lt;/gw:Offset&gt;\n\t\t\t\t&lt;gw:Page&gt;0&lt;/gw:Page&gt;\n\t\t\t\t&lt;gw:Paragraph&gt;0&lt;/gw:Paragraph&gt;\n\t\t\t&lt;/gw:Location&gt;\n\t\t\t&lt;gw:Location&gt;\n\t\t\t'```##### Redact files in a directory`redact_directory` returns a dictionary of file paths relative to the input_directory, and an object with the attributes: &quot;status&quot; (int), &quot;output_file&quot; (bytes), &quot;output_report&quot; (bytes). The below example demonstrates assigning the variable `results` and checking the keys and values of the `results` dictionary.```pyimport glasswall# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within each file in the input_directory, writing the redacted file# to a new path in the output_directoryresults = word_search.redact_directory(    input_directory=r&quot;C:\gwpw\input_redact&quot;,    output_directory=r&quot;C:\gwpw\output\word_search\redact_directory&quot;,    content_management_policy=glasswall.content_management.policies.WordSearch(        config={            &quot;textSearchConfig&quot;: {                &quot;@libVersion&quot;: &quot;core2&quot;,                &quot;textList&quot;: [                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                ]            }        }    ))assert list(results.keys()) == ['lorem_ipsum.docx', 'lorem_ipsum.pptx']assert all(result.status == 1 for result in results.values())```##### Redact files in a directory that may contain unsupported file typesThe default behaviour of the Glasswall Python wrapper is to raise the relevant exception (see: [glasswall.libraries.word_search.errors](https://gw-engineering.github.io/glasswall-python-wrapper/libraries/word_search/errors.html)) if processing fails. Passing `raise_unsupported=False` will prevent an exception being raised and can be useful when working with a directory containing a mixture of both supported and unsupported file types when it is desired to process as many of the files as possible instead of terminating on the first failure.The below example input directory contains the same two files in the above example as well as a file with an unsupported file format: `python-package.yml`. We can inspect the key value pairs in the `results` dictionary and see that the object returned for the `python-package.yml` file returned a `status: 0`, a failure. The `output_file` attribute is empty bytes, and the `output_report` bytes is populated with a report that includes an `IssueItem` describing the problems encountered while attempting to redact the file: `File contents could not be accessed`.```pyimport glasswall# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within each file in the input_directory, writing the redacted file# to a new path in the output_directoryresults = word_search.redact_directory(    input_directory=r&quot;C:\gwpw\input_redact_with_unsupported_file_types&quot;,    output_directory=r&quot;C:\gwpw\output\word_search\redact_directory_unsupported&quot;,    content_management_policy=glasswall.content_management.policies.WordSearch(        config={            &quot;textSearchConfig&quot;: {                &quot;@libVersion&quot;: &quot;core2&quot;,                &quot;textList&quot;: [                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                    {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                        {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                        {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                    ]},                ]            }        }    ),    raise_unsupported=False)assert list(results.keys()) == [&quot;lorem_ipsum.docx&quot;, &quot;lorem_ipsum.pptx&quot;, &quot;python-package.yml&quot;]assert [result.status for result in results.values()] == [1, 1, 0]print(results[&quot;python-package.yml&quot;].__dict__)# {'status': 0,# 'output_file': b'',# 'output_report': b'&lt;gw:WordSearchStatistics xmlns:gw=&quot;http://glasswall.com/namespace&quot;&gt;\n\t&lt;gw:IssueItem&gt;\n\t\t&lt;gw:Description&gt;File contents could not be accessed&lt;/gw:Description&gt;\n\t&lt;/gw:IssueItem&gt;\n\t&lt;gw:DocumentSummary&gt;\n\t\t&lt;gw:TotalSizeInBytes&gt;1460&lt;/gw:TotalSizeInBytes&gt;\n\t\t&lt;gw:FileType&gt;Unknown&lt;/gw:FileType&gt;\n\t\t&lt;gw:TotalItemMatchCount&gt;0&lt;/gw:TotalItemMatchCount&gt;\n\t&lt;/gw:DocumentSummary&gt;\n\t&lt;gw:WordItem&gt;\n\t\t&lt;gw:Name&gt;ipsum&lt;/gw:Name&gt;\n\t\t&lt;gw:ItemMatchCount&gt;0&lt;/gw:ItemMatchCount&gt;\n\t\t&lt;gw:Locations/&gt;\n\t&lt;/gw:WordItem&gt;\n\t&lt;gw:WordItem&gt;\n\t\t&lt;gw:Name&gt;lorem&lt;/gw:Name&gt;\n\t\t&lt;gw:ItemMatchCount&gt;0&lt;/gw:ItemMatchCount&gt;\n\t\t&lt;gw:Locations/&gt;\n\t&lt;/gw:WordItem&gt;\n&lt;/gw:WordSearchStatistics&gt;\n\n'}```##### Redact files in a directory conditionally based on file formatThe example below demonstrates redacting of only docx and pptx files from a directory that also contains other unsupported file types.```pyimport osimport glasswall# Load the Glasswall Editor libraryeditor = glasswall.Editor(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)# Load the Glasswall WordSearch libraryword_search = glasswall.WordSearch(r&quot;C:\gwpw\libraries\embedded_engine_release_5.3&quot;)input_directory = r&quot;C:\gwpw\input_redact_with_unsupported_file_types&quot;output_directory = r&quot;C:\gwpw\output\word_search\redact_directory_file_format&quot;# Iterate relative file paths from input_directoryfor relative_file in glasswall.utils.list_file_paths(input_directory, absolute=False):    # Construct absolute paths    input_file = os.path.join(input_directory, relative_file)    output_file = os.path.join(output_directory, relative_file)    # Get the file type of the file    file_type = editor.determine_file_type(        input_file=input_file,        as_string=True,        raise_unsupported=False    )    # Protect only doc and docx files    if file_type in [&quot;docx&quot;, &quot;pptx&quot;]:        # Redact occurrences of the text &quot;lorem&quot; and &quot;ipsum&quot; within the input file, writing the redacted file to a new path        word_search.redact_file(            input_file=input_file,            output_file=output_file,            content_management_policy=glasswall.content_management.policies.WordSearch(                config={                    &quot;textSearchConfig&quot;: {                        &quot;@libVersion&quot;: &quot;core2&quot;,                        &quot;textList&quot;: [                            {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                                {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;lorem&quot;},                                {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                            ]},                            {&quot;name&quot;: &quot;textItem&quot;, &quot;switches&quot;: [                                {&quot;name&quot;: &quot;text&quot;, &quot;value&quot;: &quot;ipsum&quot;},                                {&quot;name&quot;: &quot;textSetting&quot;, &quot;@replacementChar&quot;: &quot;*&quot;, &quot;value&quot;: &quot;redact&quot;},                            ]},                        ]                    }                }            )        )```</longdescription>
</pkgmetadata>