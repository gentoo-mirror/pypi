<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>## DescriptionSimple functions to set or get values from a nested dict structure or in fact a deep structure of any object, becausesince version 2 we no longer assume we are dealing with dicts.You may use a custom accessor or pass your own getter, setter, deleter callables so that you can traverse a nestedstructure of any kind of object.This module DOES NOT implement dotted notation as an alternative access method for dicts.I generally do not like changing python dicts to enable dot notation, hence no availablepackage fitted my needs for a simple deep accessor.NEW IN VERSION 4:Since version 3 we make no assumption that we are dealing with dicts, so you can have your nestedstructure of any type. However, in version 4 we reintroduce better defaults so that for those thatare indeed working with nested dicts the default values shall be enough without having to define anaccessor or a getter.Notes:With deep_get, you could use 'lambda o, k: o[k]' or 'lambda o, k: o.get(k)' as either the getter or the accessor.The only 'special' thing about the 'getter' function is that when it is invoked with 'o' being a list, it will insteaditerate over the list and call the accessor for each item in the list.In a simplified way, this is how deep_get works:1. The key is broken down into a list of keys: &quot;customer.address.city&quot; -&gt; ['customer', 'address', 'city'] 2. The list of keys is iterated over, calling the getter for each key and the last value retrieved is returned.```for k in keys[:-1]:    if o is None:        return o    o = getter(o, k)o = getter_last_step(o, keys[-1])return o```You see that getter could be as simple as 'lambda o, k: o.get(k)'. However, by default the code uses a smarter getter asdefined below, which tries to deal properly with nested lists.```def __default_getter(o, k):    if isinstance(o, list):        return [accessor(i, k) for i in o]    else:        return accessor(o, k)```If you do not want this checks for nested lists, just pass your own getter which could just as wellbe 'lambda o, k: o.get(k)'.The default setter also knows how to deal with nested lists:```def __default_setter(o, k, v):    n_set = 0    if isinstance(o, list):        for i in o:            i[k] = v            n_set += 1        return n_set    else:        o[k] = v        return 1```You could just as well replace if with your own 'setter=lambda o, k, v: o[k]=v' if you know thatyou have no nested lists in your structures and want to avoid the overhead, but in that case you shouldalso change the getter 'getter=lambda o, k: o.get(k)'.However, if you like the list handling skills of the code but just needs to change the way the value is retrieved,in this case you pass an accessor only to deep_get or deep_set which could be, say, 'lambda o, k: o.getValueById(k)'## Functions*deep_get* accepts:- o: required. Any object, usually a dictionary- k: required. The key or keys, must be a string or anything accepted by the list() constructor- accessor: optional, callable: Takes o, k (object and key) and returns the value. Default accessor is  'lambda o, k: o.get(k) if hasattr(o, &quot;get&quot;) else o[k]'- getter: optional, callable. If getter is set, accessor is ignored. Takes an object and a key as arguments and returns  a value- getter_last_step: optional, callable. The getter to be used on the last step (with the last key). By default,  if the last key is a list of keys, it returns a dict {k[0]: o[k[0]], k[1]: o[k[1]]}. If the last object is a list, it returns a list  of dicts [{k[0]: o[0][k[0]]], k[1]: o[0][k[1]]}, {k[0]: o[1][k[0]]], k[1]: o[1][k[1]]}, ...]- sep: optional, string: by default it is a dot '.', you can use anything the string function split will accept- empty_list_as_none: bool = False. If true and the return value would be an empty list, returns None instead.- list_of_len_one_as_value: bool = False. If true and the return value would be a list with a single item, returns the item insteadReturns o[k]. If o[k] does not exist, should return None (but depends on the callables used).*deep_set* accepts:- o: see 'deep_get'- k: see 'deep_get'- v: required, the value that will be set- accessor: optional, callable: see 'deep_get'. For the deep_set function, the default accessor is:  'lambda o, k: o.setdefault(k, dict()) if hasattr(o, &quot;setdefault&quot;) else o[k]'- getter: optional, callable: see 'deep_get'- setter: optional, callable. A callable that takes 3 parameters: o, k, v - where o = any object, k = key, v = value- sep: optional, string: see 'deep_get'No return value*deep_del* accepts:- o: required: see 'deep_get'- k: required: see 'deep_get'- accessor: optional, callable: see 'deep_get'- getter: optional, callable: see 'deep_get'- deleter: optional, callable: Takes 2 parameters: o, k (object and key).- sep: optional, string: see 'deep_get'Returns an integer with the number of entries that were deleted.## Example / Usage```from dict_deep import deep_get, deep_set, deep_deli = 0# 1i += 1o = {'a': {'b': {}}}deep_set(o, &quot;a.b.c&quot;, &quot;Hello World&quot;)print(&quot;{}: {}&quot;.format(i, deep_get(o, &quot;a.b.c&quot;)))# 2i += 1o = {}deep_set(o, ['a', 'b', 'c'], &quot;Hello World&quot;)print(&quot;{}: {}&quot;.format(i, deep_get(o, &quot;a.b.c&quot;)))# 3i += 1o = {}deep_set(o, &quot;a-&gt;b-&gt;c&quot;, &quot;Hello World&quot;, sep=&quot;-&gt;&quot;)print(&quot;{}: {}&quot;.format(i, deep_get(o, &quot;a-&gt;b-&gt;c&quot;, sep=&quot;-&gt;&quot;)))# 4i += 1o = {}deep_set(o, &quot;a-&gt;b-&gt;c&quot;, &quot;Hello World&quot;, getter=lambda o, k: o.setdefault(k, dict()), sep=&quot;-&gt;&quot;)print(&quot;{}: {}&quot;.format(i, deep_get(o, &quot;a-&gt;b-&gt;c&quot;, sep=&quot;-&gt;&quot;)))# 5i += 1o = {}keys = 'a.b.c'keys = keys.split('.')_ = deep_get(o=o, k=keys[0:-1], accessor=lambda o, k: o.setdefault(k, dict()), sep=&quot;.&quot;)_[keys[-1]] = &quot;Hello World&quot;print(&quot;{}: {}&quot;.format(i, deep_get(o, keys)))# 6i += 1o = {}deep_set(o, &quot;1.1.1&quot;, 'a', accessor=lambda o, k: o.setdefault(k, dict()))deep_set(o, &quot;1.1.2&quot;, 'Hello World')deep_set(o, &quot;1.1.3&quot;, 'c')deep_del(o, &quot;1.1.2&quot;)print(&quot;{}: {}&quot;.format(i, o))# 7i += 1o = {'students': [{'name': 'Joe', 'age': 10, 'gender': 'male'}, {'name': 'Maria', 'age': 12, 'gender': 'female'}]}keys = ['students', 'name']print(&quot;{}: {}&quot;.format(i, deep_get(o, keys)))# 8i += 1keys = ['students', ['name', 'age']]print(&quot;{}: {}&quot;.format(i, deep_get(o, keys)))# 9i += 1keys = ['students', 'gender']deep_set(o, keys, 'Nowadays better not ask')print(&quot;{}: {}&quot;.format(i, o))# 10i += 1keys = ['students', 'gender']deep_del(o, keys)print(&quot;{}: {}&quot;.format(i, o))# 11i += 1keys = ['director', 'name']print(&quot;{}: {}&quot;.format(i, deep_get(o, keys)))```</longdescription>
</pkgmetadata>