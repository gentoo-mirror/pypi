<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># onto[![Build Status](https://travis-ci.com/billyrrr/flask-boiler.svg?branch=master)](https://travis-ci.com/billyrrr/flask-boiler)[![Coverage Status](https://coveralls.io/repos/github/billyrrr/flask-boiler/badge.svg?branch=master)](https://coveralls.io/github/billyrrr/flask-boiler?branch=master)[![Documentation Status](https://readthedocs.org/projects/flask-boiler/badge/?version=latest)](https://flask-boiler.readthedocs.io/en/latest/?badge=latest)&quot;boiler&quot;: **B**ackend-**O**riginated **I**nstantly-**L**oaded **E**ntity **R**epository NOTE: This package is not profiled or checked for memory usage. It is recommended that you use Kubernetes to increase fault tolerance. Flask-boiler manages your application state with Firestore. You can create view models that aggregates underlying data sources and store them immediately and permanently in Firestore. As a result, your front end development will be as easy as using Firestore. Flask-boiler is comparable to Spring Web Reactive. Demo: When you change the attendance status of one of the participants in the meeting, all other participants receive an updated version of the list of people attending the meeting. ![Untitled_2](https://user-images.githubusercontent.com/24789156/71137341-be0e1000-2242-11ea-98cb-53ad237cac43.gif)Some reasons that you may want to use this framework or architectualpractice:- You want to build a reactive system and not just a reactive view. - You want to build a scalable app that is native to distributed     systems. - You want a framework with a higher level of abstraction, so you can     exchange components such as transportation protocols - You want your code to be readable and clear and written mostly     in python, while maintaining compatibility to different APIs. - You have constantly-shifting requirements, and want to have     the flexibility to migrate different layers, for example,     switch from REST API to WebSocket to serve a resource. This framework is at ***beta testing stage***. API is not guaranteed and ***may*** change. Documentations: [readthedocs](https://flask-boiler.readthedocs.io/)Quickstart: [Quickstart](https://flask-boiler.readthedocs.io/en/latest/quickstart_link.html)API Documentations: [API Docs](https://flask-boiler.readthedocs.io/en/latest/apidoc/flask_boiler.html)Example of a Project using flask-boiler: [gravitate-backend](https://github.com/billyrrr/gravitate-backend)[Related Technologies](https://medium.baqend.com/real-time-databases-explained-why-meteor-rethinkdb-parse-and-firebase-dont-scale-822ff87d2f87)## Ideal Usageboiler will compile your python code into flink jobs, web servers, and more to be run on a kubernetes engine (not currently implemented).  ![Ideal Usage](docs/distributed.png)## Connectors supported Implemented: - REST API (Flask and Flasgger)- GraphQL (Starlette)- Firestore- Firebase Functions- JsonRPC (flask-jsonrpc)- Leancloud Engine- WebSocket (flask socketio)To be supported: - Flink Table API- Kafka## Design Pattern  onto abstracts to MVVM (Model-View-ViewModel), where, 1. Model consists of a transactional database or datastore, and lives in back end. 2. ViewModel consists of a distributed state consists of Model and     aggregator. It is the main part of boiler. For client-read,     it receives the streams coming in from the Model layer, and     output them as a View to the View layer. For client-write,     it receives the change streams from View     layer, and operate on Model layer to persist the change.     ViewModel lives in the back end, and may be operated as     boiler python code, or compiled as flink jobs in the case of     big data application (to be implemented). 3. View is the presentational layer for the back end. It serves     1NF normalized data that are readable to the front end     without further aggregation. Client reads and writes to View.     View should be ephemeral, and can be rebuilt from ViewModel.      View may be a remote system, eg. firestore or leancloud. ## InstallationIn your project directory, ```pip install onto```See more in [Quickstart](https://flask-boiler.readthedocs.io/en/latest/quickstart_link.html). &lt;!--## Usage--&gt;&lt;!--### Business Properties Binding--&gt;&lt;!--You can bind a view model to its business properties (underlying domain model).--&gt;&lt;!--See `examples/binding_example.py`. (Currently breaking)--&gt;&lt;!--```python--&gt;&lt;!--vm: Luggages = Luggages.new(vm_ref)--&gt;&lt;!--vm.bind_to(key=id_a, obj_type=&quot;LuggageItem&quot;, doc_id=id_a)--&gt;&lt;!--vm.bind_to(key=id_b, obj_type=&quot;LuggageItem&quot;, doc_id=id_b)--&gt;&lt;!--vm.register_listener()--&gt;&lt;!--```--&gt;### State ManagementYou can combine information gathered in domain models and serve them in Firestore, so that front end can read all data required from a single document or collection, without client-side queries and excessive server roundtrip time. There is a medium [article](https://medium.com/resolvejs/resolve-redux-backend-ebcfc79bbbea)  that explains a similar architecture called &quot;reSolve&quot; architecture. See ```examples/meeting_room/view_models``` on how to use onto to expose a &quot;view model&quot; in firestore that can be queried directly by front end without aggregation.  ### Processor Modes`onto` is essentially a framework for source-sink operations: ```Source(s) -&gt; Processor -&gt; Sink(s)```Take query as an example,  - Boiler- NoSQL- Flink    - staticmethods: converts to UDF    - classmethods: converts to operators and aggregator's     ### Declare View Model```pythonclass CityView(ViewModel):    name = attrs.bproperty()    country = attrs.bproperty()    @classmethod    def new(cls, snapshot):        store = CityStore()        store.add_snapshot(&quot;city&quot;, dm_cls=City, snapshot=snapshot)        store.refresh()        return cls(store=store)    @name.getter    def name(self):        return self.store.city.city_name    @country.getter    def country(self):        return self.store.city.country    @property    def doc_ref(self):        return CTX.db.document(f&quot;cityView/{self.store.city.doc_id}&quot;)```### Document View``` pythonclass MeetingSessionGet(Mediator):    from onto import source, sink    source = source.domain_model(Meeting)    sink = sink.firestore()  # TODO: check variable resolution order    @source.triggers.on_update    @source.triggers.on_create    def materialize_meeting_session(self, obj):        meeting = obj        assert isinstance(meeting, Meeting)        def notify(obj):            for ref in obj._view_refs:                self.sink.emit(reference=ref, snapshot=obj.to_snapshot())        _ = MeetingSession.get(            doc_id=meeting.doc_id,            once=False,            f_notify=notify        )        # mediator.notify(obj=obj)    @classmethod    def start(cls):        cls.source.start()```### WebSocket View ```pythonclass Demo(WsMediator):    passmediator = Demo(view_model_cls=rainbow_vm,                mutation_cls=None,                namespace=&quot;/palette&quot;)io = flask_socketio.SocketIO(app=app)io.on_namespace(mediator)```### Create Flask ViewYou can use a RestMediator to create a REST API. OpenAPI3 docs will be automatically generated in ```&lt;site_url&gt;/apidocs``` when you run ```_ = Swagger(app)```. ```pythonapp = Flask(__name__)class MeetingSessionRest(Mediator):    # from onto import source, sink    view_model_cls = MeetingSessionC    rest = RestViewModelSource()    @rest.route('/&lt;doc_id&gt;', methods=('GET',))    def materialize_meeting_session(self, doc_id):        meeting = Meeting.get(doc_id=doc_id)        def notify(obj):            d = obj.to_snapshot().to_dict()            content = jsonify(d)            self.rest.emit(content)        _ = MeetingSessionC.get(            doc_id=meeting.doc_id,            once=False,            f_notify=notify        )    # @rest.route('/', methods=('GET',))    # def list_meeting_ids(self):    #     return [meeting.to_snapshot().to_dict() for meeting in Meeting.all()]    @classmethod    def start(cls, app):        cls.rest.start(app)swagger = Swagger(app)app.run(debug=True)```(currently under implementation) ## Object Lifecycle### OnceObject created with ```cls.new``` -&gt; Object exported with ```obj.to_view_dict```. ### MultiObject created when a new domain model is created in database -&gt; Object changed when underlying datasource changes -&gt; Object calls ```self.notify``` ## Typical ViewMediator Use Cases Data flow direction is described as Source -&gt; Sink. &quot;Read&quot; describes the flow of data where front end would find data in Sink useful. &quot;Write&quot; describes the flow of data where the Sink is the single source of truth. ### Rest Read: Request -&gt; Response \Write: Request -&gt; Document1. Front end sends HTTP request to Server  2. Server queries datastore3. Server returns response### QueryRead: Document -&gt; Document \Write: Document -&gt; Document1. Datastore triggers update function 2. Server rebuilds ViewModel that may be changed as a result 3. Server saves newly built ViewModel to datastore ### Query+TaskRead: Document -&gt; Document \Write: Document -&gt; Document1. Datastore triggers update function for document `d` at time `t`2. Server starts a transaction3. Server sets write_option to only allow commit if documents are last updated at time `t` (still under design)3. Server builds ViewModel with transaction 5. Server saves ViewModel with transaction7. Server marks document `d` as processed (remove document or update a field)7. Server retries up to MAX_RETRIES from step 2 if precondition failed ### WebSocketRead: Document -&gt; WebSocket Event \Write: WebSocket Event -&gt; Document1. Front end subscribes to a ViewModel by sending a WebSocket event to server 2. Server attaches listener to the result of the query3. Every time the result of the query is changed and consistent:    1. Server rebuilds ViewModel that may be changed as a result     2. Server publishes newly built ViewModel4. Front end ends the session5. Document listeners are released ### DocumentRead: Document -&gt; Document \Write: Document -&gt; Document### Comparisons |                 | Rest             | Query      | Query+Task                   | WebSocket     | Document ||-----------------|------         |-------|------------|-----------|----------|| Guarantees      |    ≤1   (At-Most-Once)         | ≥ 1 (At-Least-Once)          |  =1[^1] (Exactly-Once)    |   ≤1   (At-Most-Once)  |       ≥ 1 (At-Least-Once) || Idempotence      | If Implemented    | No            | Yes, with transaction[^1]    | If Implemented  | No    || Designed For      | Stateless Lambda  |  Stateful Container   | Stateless Lambda      | Stateless Lambda  | Stateful Container || Latency         | Higher            | Higher |   Higher     |  Lower           |     Higher     || Throughput      | Higher when Scaled| Lower[^2]       | Lower          |   Higher when Scaled|   Lower[^2]      || Stateful        | No               | If Implemented    | If Implemented   | Yes        | Yes         || Reactive        | No           | Yes    | Yes   | Yes        | Yes         |&lt;!---Gaurantees| Back Pressure   |      |       |            |           |          |LatencyThroughput| Fault Tolerance |      |       |            |           |          |Stateful--&gt;[^1]:  A message may be received and processed by multiple consumer, but only one consumer can successfully commit change and mark the event as processed. [^2]:  Scalability is limited by the number of listeners you can attach to the datastore. ## Advantages### Decoupled Domain Model and View ModelUsing Firebase Firestore sometimes require duplicated fieldsacross several documents in order to both query the data anddisplay them properly in front end. Flask-boiler solves thisproblem by decoupling domain model and view model. View modelare generated and refreshed automatically as domain modelchanges. This means that you will only have to write businesslogics on the domain model without worrying about how the datawill be displayed. This also means that the View Models canbe displayed directly in front end, while supportingreal-time features of Firebase Firestore.### One-step ConfigurationRather than configuring the network and different certificatesettings for your database and other cloud services. All youhave to do is to enable related services on Google CloudConsole, and add your certificate. Flask-boiler configuresall the services you need, and expose them as a singletonContext object across the project.### RedundancySince all View Models are persisted in Firebase Firestore.Even if your App Instance is offline, the users can stillaccess a view of the data from Firebase Firestore. EveryView is also a Flask View, so you can also access the datawith auto-generated REST API, in case Firebase Firestore isnot viable.### Added SafetyBy separating business data from documents that are accessibleto the front end, you have more control over which data isdisplayed depending on the user's role.### One-step DocumentationAll ViewModels have automatically generated documentations(provided by Flasgger). This helps AGILE teams keep theirdocumentations and actual code in sync.### Fully-extendableWhen you need better performance or relational databasesupport, you can always refactor a specific layer byadding modules such as `flask-sqlalchemy`.## Comparisons ### GraphQLIn GraphQL, the fields are evaluated with each query, but onto evaluates the fields if and only if the underlying data source changes. This leads to faster read for data that has not changed for a while. Also, the data source is expected to be consistent, as the field evaluation are triggered after all changes made in one transaction to firestore is read. GraphQL, however, lets front-end customize the return. You must define the exact structure you want to return in onto. This nevertheless has its advantage as most documentations of the request and response can be done the same way as REST API. ### REST API / FlaskREST API does not cache or store the response. When a view model is evaluated by onto, the response is stored in firestore forever until update or manual removal. Flask-boiler controls role-based access with security rules integrated with Firestore. REST API usually controls these access with a JWT token. ### ReduxRedux is implemented mostly in front end. Flask-boiler targets back end and is more scalable, since all data are communicated with Firestore, a infinitely scalable NoSQL datastore. Flask-boiler is declarative, and Redux is imperative. The design pattern of REDUX requires you to write functional programming in domain models, but onto favors a different approach: ViewModel reads and calculates data from domain models and exposes the attribute as a property getter. (When writing to DomainModel, the view model changes domain model and exposes the operation as a property setter). Nevertheless, you can still add function callbacks that are triggered after a domain model is updated, but this may introduce concurrency issues and is not perfectly supported due to the design tradeoff in onto. ### Architecture Diagram: ![Architecture Diagram](https://user-images.githubusercontent.com/24789156/70380617-06e4d100-18f3-11ea-9111-4398ed0e865c.png)## ContributingPull requests are welcome. Please make sure to update tests as appropriate.## License[MIT](https://choosealicense.com/licenses/mit/)</longdescription>
</pkgmetadata>