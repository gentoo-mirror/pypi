<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;!--SPDX-FileCopyrightText: 2021 Magenta ApS &lt;https://magenta.dk&gt;SPDX-License-Identifier: MPL-2.0--&gt;# Rammearkitektur AMQPRammearkitektur AMQP (RAMQP) is an opinionated library for AMQP.It is implemented as a thin wrapper around `aio_pika`, with a generic and a MOspecific AMQPSystem abstract, the MO abstraction being implementing using a thinwrapper around the generic abstraction.## Usage### GenericReceiving:```pythonimport asynciofrom ramqp import AMQPSystemfrom ramqp import Routerfrom ramqp.config import AMQPConnectionSettingsfrom ramqp.depends import RoutingKeyrouter = Router()# Configure the callback function to receive messages for the two routing keys.# If an exception is thrown from the function, the message is not acknowledged.# Thus, it will be retried immediately.@router.register(&quot;my.routing.key&quot;)@router.register(&quot;my.other.routing.key&quot;)async def callback_function(routing_key: RoutingKey) -&gt; None:    passasync def main() -&gt; None:    settings = AMQPConnectionSettings(url=..., queue_prefix=&quot;my-program&quot;)    async with AMQPSystem(settings=settings, router=router) as amqp_system:        await amqp_system.run_forever()asyncio.run(main())```Sending:```pythonfrom ramqp import AMQPSystemwith AMQPSystem(...) as amqp_system:    await amqp_system.publish_message(&quot;my.routing.key&quot;, {&quot;key&quot;: &quot;value&quot;})```### Dependency InjectionThe callback handlers support[FastAPI dependency injection](https://fastapi.tiangolo.com/tutorial/dependencies).This allows handlers to request exactly the data that they need, as seen withFastAPI dependencies or PyTest fixtures. A callback may look like:```pythonfrom ramqp.mo import MORoutingKeyfrom ramqp.mo import PayloadTypeasync def callback(mo_routing_key: MORoutingKey, payload: PayloadType):    ...```Experienced FastAPI developers might wonder how this works without the `Depends`function. Indeed, this less verbose pattern was[introduced in FastAPI v0.95](https://fastapi.tiangolo.com/release-notes/#0950),and works by defining the dependency directly on the type using the `Annotated`mechanism from [PEP593](https://peps.python.org/pep-0593/). For example:```pythonMORoutingKey = Annotated[MORoutingKey, Depends(get_routing_key)]PayloadType = Annotated[PayloadType, Depends(get_payload_as_type(PayloadType))]```whereby the previous example is equivalent to```pythonasync def callback(    mo_routing_key: MORoutingKey = Depends(get_routing_key),    payload: PayloadType = Depends(get_payload_as_type(PayloadType))):    ...```.Reference documentation should be made available for these types in the future,but for now they can be found mainly in `ramqp/depends.py` and `ramqp/mo.py`.### Context```pythonimport asynciofrom typing import Annotatedimport httpxfrom fastapi import Dependsfrom ramqp import AMQPSystemfrom ramqp import Routerfrom ramqp.depends import Contextfrom ramqp.depends import from_contextrouter = Router()async def main() -&gt; None:    async with httpx.AsyncClient() as client:        context = {            &quot;client&quot;: client,        }        async with AMQPSystem(..., context=context) as amqp_system:            await amqp_system.run_forever()HTTPXClient = Annotated[httpx.AsyncClient, Depends(from_context(&quot;client&quot;))]@router.register(&quot;my.routing.key&quot;)async def callback_function(context: Context, client: HTTPXClient) -&gt; None:    passasyncio.run(main())```### SettingsIn most cases, `AMQPConnectionSettings` is probably initialised by beingincluded in the `BaseSettings` of the application using the library. The `url`parameter of the `AMQPConnectionSettings` object can be given as a single URLstring or as individual structured fields. Consider the following:```pythonfrom pydantic import BaseSettingsfrom ramqp.config import AMQPConnectionSettings# BaseSettings makes the entire model initialisable using environment variablesclass Settings(BaseSettings):    amqp: AMQPConnectionSettings    class Config:        env_nested_delimiter = &quot;__&quot;  # allows setting e.g. AMQP__URL__HOST=foosettings = Settings()```The above would work with either multiple structured environment variables```AMQP__URL__SCHEME=amqpAMQP__URL__USER=guestAMQP__URL__PASSWORD=guestAMQP__URL__HOST=msg_brokerAMQP__URL__PORT=5672AMQP__URL__VHOST=os2mo```or a single URL definition```AMQP__URL=amqp://guest:guest@msg_broker:5672/os2mo```### MO AMQPReceiving:```pythonimport asynciofrom ramqp.config import AMQPConnectionSettingsfrom ramqp.mo import MOAMQPSystemfrom ramqp.mo import MORouterfrom ramqp.mo import MORoutingKeyfrom ramqp.mo import PayloadTyperouter = MORouter()# Configure the callback function to receive messages for the two routing keys.# If an exception is thrown from the function, the message is not acknowledged.# Thus, it will be retried immediately.@router.register(&quot;employee.address.edit&quot;)@router.register(&quot;employee.it.create&quot;)async def callback_function(    mo_routing_key: MORoutingKey, payload: PayloadType) -&gt; None:    passasync def main() -&gt; None:    settings = AMQPConnectionSettings(url=..., queue_prefix=&quot;my-program&quot;)    async with MOAMQPSystem(settings=settings, router=router) as amqp_system:        await amqp_system.run_forever()asyncio.run(main())```Sending:```pythonfrom datetime import datetimefrom uuid import uuid4from ramqp.mo import MOAMQPSystemfrom ramqp.mo import PayloadTypepayload = PayloadType(uuid=uuid4(), object_uuid=uuid4(), time=datetime.now())async with MOAMQPSystem(...) as amqp_system:    await amqp_system.publish_message(&quot;employee.address.edit&quot;, payload)```### MetricsRAMQP exports a myriad of prometheus metrics via `prometheus/client_python`.These can be exported using:```from prometheus_client import start_http_serverstart_http_server(8000)```Or similar, see the promethues client library for details.## Development### Prerequisites- [Poetry](https://github.com/python-poetry/poetry)### Getting Started1. Clone the repository:```git clone git@git.magenta.dk:rammearkitektur/ramqp.git```2. Install all dependencies:```poetry install```3. Set up pre-commit:```poetry run pre-commit install```### Running the testsYou use `poetry` and `pytest` to run the tests:`poetry run pytest`You can also run specific files`poetry run pytest tests/&lt;test_folder&gt;/&lt;test_file.py&gt;`and even use filtering with `-k``poetry run pytest -k &quot;Manager&quot;`You can use the flags `-vx` where `v` prints the test &amp; `x` makes the test stop if any tests fails (Verbose, X-fail)#### Running the integration testsTo run the integration tests, an AMQP instance must be available.If an instance is already available, it can be used by configuring the `AMQP_URL`environmental variable. Alternatively a RabbitMQ can be started in docker, using:```docker run -d -p 5672:5672 -p 15672:15672 rabbitmq:3-management```## VersioningThis project uses [Semantic Versioning](https://semver.org/) with the following strategy:- MAJOR: Incompatible changes to existing data models- MINOR: Backwards compatible updates to existing data models OR new models added- PATCH: Backwards compatible bug fixes## AuthorsMagenta ApS &lt;https://magenta.dk&gt;## LicenseThis project uses: [MPL-2.0](MPL-2.0.txt)This project uses [REUSE](https://reuse.software) for licensing.All licenses can be found in the [LICENSES folder](LICENSES/) of the project.</longdescription>
</pkgmetadata>