<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># EXCAL - Extendable Clang AST based Linter.## WARNING: This project is still in an early stage. Currently working Plugins may not be supported in future versions.This is a simple project implementing a C/C++ linter based on the clang AST. The main porpoise is to create a tool which is easily extendable via plugins.The focus of this project is to provide a tool for the implementation of custom C/C++ coding guidelines. There are no rules provided by the linter itself, rather a toolset to implement your own. (see Plugins)## InstallationIn order to use excal you need to have [clang](http://clang.org/) installed on your system.This tool is available on PyPI so you can install it via pip:```pip install excal```## UsageTo Analyze a file or project the tool expects input files/directories. Additionally you should provide all includes. If no Includes are given Clang will still create an AST, however it will be incomplete and may cause false positives/negatives from the linter.```    excal -f path/to/file_to_analyze.c -i path/to/includes/```A list of all supported options: &lt;table border=&quot;2&quot; cellspacing=&quot;0&quot; cellpadding=&quot;6&quot; rules=&quot;groups&quot; frame=&quot;hsides&quot;&gt;&lt;colgroup&gt;&lt;col  class=&quot;org-left&quot; /&gt;&lt;col  class=&quot;org-left&quot; /&gt;&lt;col  class=&quot;org-left&quot; /&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th scope=&quot;col&quot; class=&quot;org-left&quot;&gt;Command&lt;/th&gt;&lt;th scope=&quot;col&quot; class=&quot;org-left&quot;&gt;arguments&lt;/th&gt;&lt;th scope=&quot;col&quot; class=&quot;org-left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;org-left&quot;&gt;-a&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;List of compiler arguments&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;provide compiler arguments for Clang, may improve the AST&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;org-left&quot;&gt;&amp;#x2013;argfile&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;File&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;Compiler arguments may be provided in a File, seperated by newlines&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;org-left&quot;&gt;-i&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;List of files/directories&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;Include Files used by the compiler to build the AST&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;org-left&quot;&gt;-f (required)&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;List of files/directories&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;Files/Directories to analyze.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;org-left&quot;&gt;-e&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;List of files/directories&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;Files/Directories within given directories, which should be ignored.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;org-left&quot;&gt;-p&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;-&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;If this flag is provided the Linter will print the AST of all included files. This is useful for creating Plugins.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;org-left&quot;&gt;-ptt&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;-&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;Same as above, but will also Print all Tokens under their corresponding AST Nodes. (will produce long output)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;org-left&quot;&gt;-cpp&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;-&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;Libclang will analyze files based on their extension. If the extension is not cpp specific (eg. .h instead .hpp) this flag will force all files to be analyzed as c++ code.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;org-left&quot;&gt;-ext&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;List of file extensions&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;If provided only files with the given extensions will be parsed.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;org-left&quot;&gt;-c&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;Cache AST files.&lt;/td&gt;&lt;td class=&quot;org-left&quot;&gt;AST files will be saved in a .excal directory of the project base. If the file content did not change, they will be reloaded. This will save time when reanalyzing Big projects with only a few files changing or If new rules are added.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;### Config filesIf a single directory is given as input, excal will scan its root for a setup.cfg file. Here some project parameters may be provided. At the moment only the options given in belows example are being used, additional ones will be added.```[EXCAL]includes =   /opt/ros/foxy/include/exclude_files =  file/to/exclude.c  files/to/exclude/  **/venvforce_cpp = True```## PluginsThe Goal of this project is to provide an interface that allows it to easily implement linter rules based on an AST.A Plugin will need to provide a register method in which it will register itself within the Project. The Plugin then can provide a class inherits from the NodeVisitor class. Here the visit_X functions can be overwritten. When parsing the AST, these functions will be called whenever a desired Node is reached. From there further operations may be done on the provided AstNode.See the following example:```    from visitor import NodeVisitor    from pluginManager import PluginManager    from astNode import AstNode        PLUGIN_NAME = &quot;AutonomusReply&quot;        class customVisitor(NodeVisitor):        def __init__(self) -&gt; None:            super().__init__()            def visit_class_base(self, node: AstNode) -&gt; None:            return        def register(pm: PluginManager):        pm.register(PLUGIN_NAME, customVisitor)```There are two ways to provide Plugins. The preferred one is to Create as a standalone python Package. [See this example](https://github.com/PKN-AUTDE/excal-example-plugin).The other way is to put the Plugin in the plugins folder and register it in the plugins.json file.```    {      &quot;plugins&quot;: [&quot;plugins.myPlugin&quot;]    }```All possible functions can be seen in src/visitor.py. To see which function may be needed for your use-cases run the excal project using the -p flag. This will print an AST of the desired file.</longdescription>
</pkgmetadata>