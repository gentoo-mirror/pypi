<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;    &lt;img style=&quot;width:300px&quot; src=&quot;https://raw.githubusercontent.com/karosis88/aioreq/b9a4fa392798c49f2eb533ffb60b8c5564524f72/.github/images/logo.svg&quot;&gt;&lt;/img&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;b&gt;Aioreq&lt;/b&gt; is a Python asynchronous HTTP client library. It is built on top of TCP sockets and implements the HTTP protocol entirely on his own.&lt;/p&gt;[mygit]: https://github.com/karosis88/aioreq[documentation]: https://karosis88.github.io/aioreq/---## Documentation[Click here][documentation]## InstallFrom [pypi](https://pypi.org/)``` shell$ pip install aioreq```From [GitHub][mygit]``` shell$ git clone https://github.com/karosis88/aioreq$ pip install ./aioreq````Aioreq` can be used as a Python library or as a command-line tool to make HTTP requests.## Basic Usage### Python``` pycon&gt;&gt;&gt; import aioreq&gt;&gt;&gt; response = aioreq.get(&quot;http://127.0.0.1:7575/&quot;)&gt;&gt;&gt; response.status200&gt;&gt;&gt; content_type = response.headers[&quot;content-type&quot;] # Case insensitive&gt;&gt;&gt; response.contentb'Hello World'```or in async context``` pycon&gt;&gt;&gt; import asyncio&gt;&gt;&gt; &gt;&gt;&gt; async def main():...     async with aioreq.Client() as client:...         response = await client.get(&quot;http://127.0.0.1:7575&quot;)...         return response&gt;&gt;&gt; asyncio.run(main())&lt;Response 200 OK&gt;```### CLI`Aioreq` cli tools are very similar to [curl](https://github.com/curl/curl), so if you've used curl before, you should have no trouble.``` shell$ aioreq http://127.0.0.1:7575/cli_docHello World```When performing HTTP requests, there are a few options available.* `--method -X` Specify HTTP method* `--verbose -v` Show HTTP request headers* `--include -i` Include HTTP response headers* `--output -o`  Output file* `--headers -H` Send custom headers* `--data -d` HTTP POST data* `--user-agent -A` Set User-Agent headerHere are some examples of requests.``` shell$ aioreq http://127.0.0.1:7575 $ aioreq http://127.0.0.1:7575/cli_doc -d &quot;Bob&quot; -X POSTUser Bob was created!$ aioreq http://127.0.0.1:7575/cli_doc -o /dev/null$ aioreq http://127.0.0.1:7575/cli_doc -v -H &quot;custom-header: custom-value&quot; \                                             &quot;second-header: second-value&quot;========REQUEST HEADERS========user-agent: python/aioreqaccept: */*custom-header: custom-valuesecond-header: second-valueaccept-encoding:  gzip; q=1, deflate; q=1Hello                                ```## Middlewares**Aioreq** now supports 'middleware' power.### The first steps with middlewareAioreq provides default middlewares to each client.We can see that middlewares by importing 'default_middlewares'  variable.``` python&gt;&gt;&gt; import aioreq&gt;&gt;&gt; aioreq.middlewares.default_middlewares('RetryMiddleWare', 'RedirectMiddleWare', 'CookiesMiddleWare', 'DecodeMiddleWare', 'AuthenticationMiddleWare')```The first item on this list represents the first middleware that should handle our request (i.e. the **closest middleware to our client**), while the last index represents the **closest middleware to the server**.We can pass our modified middlewares tuple to the Client to override the default middlewares.``` python&gt;&gt;&gt; client = aioreq.Client(middlewares=aioreq.middlewares.default_middlewares[2:])```This client will no longer redirect or retry responses.Also, because aioreq stores middlewares in Client objects as linked lists, we can simply change the head of that linked list to skip the first middleware.``` python&gt;&gt;&gt; client = aioreq.Client()&gt;&gt;&gt; client.middlewares.__class__.__name__'RetryMiddleWare'&gt;&gt;&gt;&gt;&gt;&gt; client.middlewares = client.middlewares.next_middleware&gt;&gt;&gt; client.middlewares.__class__.__name__'RedirectMiddleWare'&gt;&gt;&gt; &gt;&gt;&gt; client.middlewares = client.middlewares.next_middleware&gt;&gt;&gt; client.middlewares.__class__.__name__'CookiesMiddleWare'```or ``` python&gt;&gt;&gt; client = aioreq.Client()&gt;&gt;&gt; client.middlewares = client.middlewares.next_middleware.next_middleware&gt;&gt;&gt; # alternative for client = aioreq.Client(middlewares=aioreq.middlewares.default_middlewares[2:])```### Create your own middlewares!All 'aioreq' middlewares must be subclasses of the class `middlewares.MiddleWare`MiddleWare below would add 'test-md' header if request domain is `www.example.com```` python&gt;&gt;&gt; import aioreq&gt;&gt;&gt;&gt;&gt;&gt; class CustomMiddleWare(aioreq.middlewares.MiddleWare):...     async def process(self, request, client):...         if request.host == 'www.example.com':...             request.headers['test_md'] = 'test'...         return await self.next_middleware.process(request, client)...&gt;&gt;&gt; client = aioreq.Client()&gt;&gt;&gt; client.middlewares = CustomMiddleWare(next_middleware=client.middlewares)```Our CustomMiddleWare will now be the first middleware (i.e. closest to the client). Because 'aioreq' middlewares are stored as linked lists, this pattern works (i.e. same as linked list insert method).Alternatively, we can alter the list of middlewares that the client receives.``` python&gt;&gt;&gt; client = aioreq.Client(middlewares = (CustomMiddleWare, ) + aioreq.middlewares.default_middlewares)&gt;&gt;&gt; client.middlewares.__class__.__name__'CustomMiddleWare'```## SSL/TLSAioreq supports three attributes related to this topic.* `check_hostname` Checks whether the peer cert hostname matches the server domain.* `verify_mode` Specifies whether the server certificate must be verified.* `keylog_filename` File location for dumping private keysYou can also set the environment variable `SSLKEYLOGFILE` instead of specifying `keylog_filename`.You can use a tool like `wireshark` to decrypt your `HTTPS` traffic if you have a file with the private keys.Example:``` shell$ export SSLKEYLOGFILE=logs```Then just run aioreq.``` shell$ aioreq https://example.com$ ls -ltotal 8-rw-r--r-- 1 user user 406 Dec  5 17:19 logs```Now, the 'logs' file contains keylogs that can be used to decrypt your TLS/SSL traffic with a tool such as 'wireshark'.Here are a few examples of how to manage the SSL context for your requests.``` pythonimport aioreqdont_verify_cert = aioreq.get(&quot;https://example.com&quot;, verify_mode=False)verify_and_dump_logs = aioreq.get(&quot;https://example.com&quot;, verify_mode=True, keylog_filename=&quot;logs&quot;)default_configs = aioreq.get(&quot;https://example.com&quot;, verify_mode=True, check_hostname=True)```## AuthenticationIf the `auth` parameter is included in the request, Aioreq will handle authentication.There are two types of authorization that aioreq can handle.* Digest Authorization* Basic AuthorizationIf the incoming response status code is **401** and the header contains `www-authorization`, `aioreq` will attempt **each** of the schemes until authorization is complete.``` python&gt;&gt;&gt; import aioreq&gt;&gt;&gt; import asyncio&gt;&gt;&gt; async def send_req():...     async with aioreq.Client() as cl:...         return await cl.get('http://httpbin.org/basic-auth/foo/bar', auth=('foo', 'bar'))&gt;&gt;&gt; resp = asyncio.run(send_req())&gt;&gt;&gt; resp.status200```Parameter `auth` should be a tuple with two elements: login and password.Authentication is enabled by `AuthenticationMiddleWare`, so exercise caution when managing middlewares manually.## BenchmarksIn this benchmarks, we compare `aioreq` and `httpx` during 999 asynchronous requests, without cachingYou can run these tests on your **local machine**; the directory `aioreq/benchmarks\contains all of the required modules.```$ cd benchmarks$ ./run_testsBenchmarks---------------------------aioreq benchmarkTotal time: 2.99---------------------------httpx benchmarkTotal time: 7.60```## Supported Features**Aioreq** support basic features to work with **HTTP/1.1**.&lt;br /&gt;More functionality will be available in future releases.&lt;br /&gt;This is the latest version features.* [Keep-Alive (Persistent Connections)](#more-advanced-usage)* [Middlewares](#middlewares)* [Keylogs](#keylog)* [Authentication](#authentication)* Cookies* Automatic accepting and decoding responses. Using `Accept-Encoding` header* HTTPS support, TLS/SSL Verification* Request Timeouts</longdescription>
</pkgmetadata>