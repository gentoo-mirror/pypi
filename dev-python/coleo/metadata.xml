<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># ColeoColeo is a minimum-effort way to create a command-line interface in Python.* Declare options where they are used.* Scale easily to extensive CLIs with dozens of subcommands and options.## Basic usageFirst, define a command line interface as follows:```pythonfrom coleo import Option, auto_cli, default@auto_clidef main():    # The greeting    greeting: Option = default(&quot;Hello&quot;)    # The name to greet    name: Option = default(&quot;you&quot;)    return f&quot;{greeting}, {name}!&quot;```Then you may run it like this on the command line:```bash$ python hello.pyHello, you!$ python hello.py --name LukeHello, Luke!$ python hello.py --name Luke --greeting &quot;Happy birthday&quot;Happy birthday, Luke!$ python hello.py -husage: hello.py [-h] [--greeting VALUE] [--name VALUE]optional arguments:  -h, --help        show this help message and exit  --greeting VALUE  The greeting  --name VALUE      The name to greet```* Any variable annotated with `Option` will become an option.* You can provide a default value with `default(value)`, although you don't have to, if the argument is required.* If there is a comment above the variable, it will be used as documentation for the option.## Option typesBy default, all arguments are interpreted as strings, but you can easily give a different type to an argument:```python@auto_clidef main():    # This argument will be converted to an int    x: Option &amp; int    # This argument will be converted to a float    y: Option &amp; float    return x + y```**Boolean flags**If the type is bool, the option will take no argument, for example:```python@auto_clidef main():    flag: Option &amp; bool = default(False)    return &quot;yes!&quot; if flag else &quot;no!&quot;```Use it like this:```bash$ python script.py --flagyes!$ python script.pyno!```You can also *negate* the flag, meaning that you want to provide an option that will store False in the variable instead of True. For example:```python@auto_clidef main():    # [negate]    flag: Option &amp; bool = default(True)    return &quot;yes!&quot; if flag else &quot;no!&quot;```By default, the above will create a flag called `--no-&lt;optname&gt;`:```bash$ python script.pyyes!$ python script.py --no-flagno!```You can write `[negate: --xyz -n]` if you want the option to be `--xyz` or `-n`. This overrides the default `--no-flag` option.Note that using `[negate]` will remove `--flag`, because we assume that it is True by default and there is therefore no need for this option.If you wish, you can have both options that set the flag to True and others that set the flag to False, using `[false-options]`. You can optionally document these options with `[false-options-doc]` (if not provided, Coleo will use a sensible default):```python@auto_clidef main():    # Set the flag to True    # [options: -y]    # [false-options: -n]    # [false-options-doc: Set the flag to False]    flag: Option &amp; bool = default(None)    return flag``````bash$ python script.pyNone$ python script.py -yTrue$ python script.py -nFalse```**Files**Use `coleo.FileType` (or `argparse.FileType`, it's the same thing) to open a file to read from or to write to:```python@auto_clidef main():    grocery_list: Option &amp; coleo.FileType(&quot;r&quot;)    with grocery_list as f:        for food in f.readlines():            print(f&quot;Gotta buy some {food}&quot;)```**Config**You can manipulate configuration files with `coleo.config` or `coleo.ConfigFile`:```python@auto_clidef main():    # ConfigFile lets you read or write a configuration file    book: Option &amp; ConfigFile    contents = book.read()    contents[&quot;xyz&quot;] = &quot;abc&quot;    book.write(contents)    # config will read the file for you or parse the argument as JSON    magazine: Option &amp; config    print(magazine)```Use it simply like this:```bash$ python librarian.py --book alice.json --magazine vogue.json$ python librarian.py --book history.yaml --magazine gamez.toml$ python librarian.py --book physics.json --magazine '{&quot;a&quot;: 1, &quot;b&quot;: 2}'# etc```Supported extensions are `json`, `yaml` and `toml` (the latter two require installing the `pyyaml` or `toml` packages).**Other**Any function can be used as a &quot;type&quot; for an argument. So for example, if you want to be able to provide lists and dictionaries on the command line you can simply use `json.loads` (although `coleo.config` is usually better, because it can also read files, in various formats):```python@auto_clidef main():    obj: Option &amp; json.loads    return type(obj).__name__``````bash$ python json.py --obj 1int$ python json.py --obj '&quot;hello&quot;'str$ python json.py --obj '{&quot;a&quot;: 1, &quot;b&quot;: 2}'dict```If you're feeling super feisty and care nothing about safety, you can even use `eval`:```python@auto_clidef main():    obj: Option &amp; eval    return type(obj).__name__``````bash$ python eval.py --obj &quot;1 + 2&quot;int$ python eval.py --obj &quot;lambda x: x + 1&quot;function```## CustomizationUsing comments of the form `# [&lt;instruction&gt;: &lt;args ...&gt;]` you can customize the option parser:```python@auto_clidef main():    # This argument can be given as either --greeting or -g    # [alias: -g]    greeting: Option = default(&quot;Hello&quot;)    # This argument is positional    # [positional]    name: Option = default(&quot;you&quot;)    # This argument can only be given as -n    # [options: -n]    ntimes: Option &amp; int = default(1)    for i in range(ntimes):        print(f&quot;{greeting}, {name}!&quot;)```The above would be used like this:```bash$ python hello.py Alice -g Greetings -n 2Greetings, Alice!Greetings, Alice!```The following customizations are available:* `[alias: ...]` defines one or several options that are aliases for the main one. Options are separated by spaces, commas or semicolons.* `[options: ...]` defines one or several options for this argument, which *override* the default one. Options are separated by spaces, commas or semicolons.* `[positional]` defines one positional argument.  * `[positional: n]`: n positional arguments (a list is returned).  * `[positional: ?]`: one optional positional argument  * `[positional: *]`: zero or more positional arguments  * `[positional: +]`: one or more positional arguments* `[remainder]` represents all arguments that are not matched by the argument parser* `[nargs: n]` declares that the option takes n arguments  * `[nargs: ?]`: one optional argument  * `[nargs: *]`: zero or more arguments  * `[nargs: +]`: one or more arguments  * `[nargs: **]` or `[nargs: --]`: all remaining arguments, including --args* `[action: &lt;action&gt;]` customizes the action to perform  * `[action: append]` lets you use an option multiple times, accumulating the results in a list (e.g. `python app.py -a 1 -a 2 -a 3`, would put `[1, 2, 3]` in `a`)* `[metavar: varname]` changes the variable name right after the option in the help string, e.g. `--opt METAVAR`* `[group: groupname]` puts the option in a named group. Options in the same group will appear together in the help.* For **bool** options only:    * `[negate: ...]` changes the option so that it sets the variable to False instead of True when they are given. Space/comma aliases may be provided for the option, otherwise the flag will be named `--no-&lt;optname&gt;`.    * `[false-options: ]` provide a list of options that set the flag to False.    * `[false-options-doc: ]` provide a documentation for the options given using the previous statement.## SubcommandsYou can create an interface with a hierarchy of subcommands by decorating a class with `auto_cli`:```python@auto_cliclass main:    class calc:        def add():            x: Option &amp; int            y: Option &amp; int            return x + y        def mul():            x: Option &amp; int            y: Option &amp; int            return x * y        def pow():            base: Option &amp; int            exponent: Option &amp; int            return base ** exponent    def greet():        greeting: Option = default(&quot;Hello&quot;)        name: Option = default(&quot;you&quot;)        return f&quot;{greeting}, {name}!&quot;```The class only holds structure and will never be instantiated, so don't add `self` to the argument lists for these functions.Then you may use it like this:```bash$ python multi.py greet --name Alice --greeting HiHi, Alice!$ python multi.py calc add --x=3 --y=811```## Sharing argumentsIt is possible to share behavior and arguments between subcommands, or to split complex functionality into multiple pieces. For example, maybe multiple subcommands in your application require an API key, which can either be given on the command line or can be read from a file. This is how you would share this behavior across all subcommands:```pythonfrom coleo import Option, auto_cli, config, default, tooled@tooleddef apikey():    # The API key to use    key: Option = default(None)    if key is None:        # If no key parameter is given on the command line, try to read it from        # some standard location.        key = config(&quot;~/.config/myapp/config.json&quot;)[&quot;key&quot;]    return key@auto_cliclass main:    def search():        interface = Application(apikey())        query: Option        return interface.search(query)    def install():        interface = Application(apikey())        package: Option        return interface.install(package)```If a function is decorated with `@tooled` and is called from one of the main functions (or from another tooled function), Coleo will search for arguments in that function too. Thus any subcommand that calls `apikey()` will gain a `--key` option.In addition to this, you can &quot;share&quot; arguments by defining the same argument with the same type in multiple functions. Coleo will set all of them to the same value.For example, in the example above you could easily let the user specify the path to the file that contains the key, simply by replacing```pythonkey = config(&quot;~/.config/myapp/config.json&quot;)[&quot;key&quot;]# ==&gt;config_path: Option = default(&quot;~/.config/myapp/config.json&quot;)key = config(config_path)[&quot;key&quot;]```And that `config_path` argument could, of course, be declared in any other function that needs to read some configuration value.## run_cli```pythonfrom coleo import Option, auto_cli@auto_clidef main():    x: Option    return x```Is equivalent to:```pythonfrom coleo import Option, run_cli, tooled@tooleddef main():    x: Option    return xresult = run_cli(main)if result is not None:    print(result)```## Non-CLI usageIt is possible to set arguments without `auto_cli` using `setvars`:```pythonfrom coleo import Option, setvars, tooled@tooleddef greet():    greeting: Option = default(&quot;Hello&quot;)    name: Option = default(&quot;you&quot;)    return f&quot;{greeting} {name}!&quot;with setvars(greeting=&quot;Hi&quot;, name=&quot;Bob&quot;):    assert greet() == &quot;Hi bob!&quot;```Note:* With `setvars`, you *must* decorate the function with `@tooled` (this is something `auto_cli` does on your behalf).* `setvars` entirely bypasses the option parsing and the type annotations will not be used to wrap these values. In other words, if a variable is annotated `Option &amp; int` and you provide the value &quot;1&quot;, it will remain a string.### Using with PteraColeo is based on [Ptera](https://github.com/mila-iqia/ptera) and all of Ptera's functionality is de facto available on functions marked as `@tooled`. For example, using the example above:```python# Set the variables in the greet function -- it's a bit like making an objecthibob = greet.new(greeting=&quot;Hi&quot;, name=&quot;Bob&quot;)assert hibob() == &quot;Hi Bob!&quot;# Same as above but this would also change greeting/name in any other function# that is called by greet, and so on recursively (a bit like dynamic scoping)hibob = greet.tweaking({&quot;greeting&quot;: &quot;Hi&quot;, &quot;name&quot;: &quot;Bob&quot;})assert hibob() == &quot;Hi Bob!&quot;# More complex behaviorfrom ptera import overlaywith overlay.tweaking({    &quot;greet(greeting='Bonjour') &gt; name&quot;: &quot;Toto&quot;}):    assert greet() == &quot;Hello you!&quot;    assert greet.new(greeting=&quot;Hi&quot;)() == &quot;Hi you!&quot;    assert greet.new(greeting=&quot;Bonjour&quot;)() == &quot;Bonjour toto!&quot;```Read the documentation for [Ptera](https://github.com/mila-iqia/ptera) for more information. Note that Ptera is not limited to variables tagged `Option`, it can manipulate *any* variable in a tooled function.</longdescription>
</pkgmetadata>