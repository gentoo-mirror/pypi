<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![PyPI](https://img.shields.io/pypi/v/drf-openapi-tester.svg)](https://pypi.org/project/drf-openapi-tester/)[![Coverage](https://codecov.io/gh/snok/drf-openapi-tester/branch/master/graph/badge.svg)](https://codecov.io/gh/snok/drf-openapi-tester)[![Python versions](https://img.shields.io/badge/Python-3.7%2B-blue)](https://pypi.org/project/drf-openapi-tester/)[![Django versions](https://img.shields.io/badge/Django-3.0%2B-blue)](https://pypi.org/project/drf-openapi-tester/)# DRF OpenAPI TesterThis is a test utility to validate DRF Test Responses against OpenAPI 2 and 3 schema. It has built-in support for:- OpenAPI 2/3 yaml or json schema files.- OpenAPI 2 schemas created with [drf-yasg](https://github.com/axnsan12/drf-yasg).- OpenAPI 3 schemas created with [drf-spectacular](https://github.com/tfranzel/drf-spectacular).## Installation```shell scriptpip install drf-openapi-tester```## UsageInstantiate one or more instances of `SchemaTester`:```pythonfrom openapi_tester import SchemaTesterschema_tester = SchemaTester()```If you are using either [drf-yasg](https://github.com/axnsan12/drf-yasg)or [drf-spectacular](https://github.com/tfranzel/drf-spectacular) this will be auto-detected, and the schema will beloaded by the `SchemaTester` automatically.If you are using schema files, you will need to pass the file path:```pythonfrom openapi_tester import SchemaTester# path should be a stringschema_tester = SchemaTester(schema_file_path=&quot;./schemas/publishedSpecs.yaml&quot;)```Once you've instantiated a tester, you can use it to test responses:```pythonfrom openapi_tester.schema_tester import SchemaTesterschema_tester = SchemaTester()def test_response_documentation(client):    response = client.get('api/v1/test/1')    assert response.status_code == 200    schema_tester.validate_response(response=response)```If you are using the Django testing framework, you can create a base `APITestCase` that incorporates schema validation:```pythonfrom rest_framework.response import Responsefrom rest_framework.test import APITestCasefrom openapi_tester.schema_tester import SchemaTesterschema_tester = SchemaTester()class BaseAPITestCase(APITestCase):    &quot;&quot;&quot; Base test class for api views including schema validation &quot;&quot;&quot;    @staticmethod    def assertResponse(response: Response, **kwargs) -&gt; None:        &quot;&quot;&quot; helper to run validate_response and pass kwargs to it &quot;&quot;&quot;        schema_tester.validate_response(response=response, **kwargs)```Then use it in a test file:```pythonfrom shared.testing import BaseAPITestCaseclass MyAPITests(BaseAPITestCase):    def test_some_view(self):        response = self.client.get(&quot;...&quot;)        self.assertResponse(response)```## OptionsYou can pass options either globally, when instantiating a `SchemaTester`, or locally, wheninvoking `validate_response`:```pythonfrom openapi_tester import SchemaTester, is_camel_casefrom tests.utils import my_uuid_4_validatorschema_test_with_case_validation = SchemaTester(    case_tester=is_camel_case,    ignore_case=[&quot;IP&quot;],    validators=[my_uuid_4_validator])```Or```pythonfrom openapi_tester import SchemaTester, is_camel_casefrom tests.utils import my_uuid_4_validatorschema_tester = SchemaTester()def my_test(client):    response = client.get('api/v1/test/1')    assert response.status_code == 200    schema_tester.validate_response(        response=response,        case_tester=is_camel_case,        ignore_case=[&quot;IP&quot;],        validators=[my_uuid_4_validator]    )```### case_testerThe case tester argument takes a callable that is used to validate the key case of both schemas and responses. Ifnothing is passed, case validation is skipped.The library currently has 4 built-in case testers:- `is_pascal_case`- `is_snake_case`- `is_camel_case`- `is_kebab_case`You can use one of these, or your own.### ignore_caseList of keys to ignore when testing key case. This setting only applies when case_tester is not `None`.### validatorsList of custom validators. A validator is a function that receives two parameters: schema_section and data, and returnseither an error message or `None`, e.g.:```pythonfrom typing import Any, Optionalfrom uuid import UUIDdef my_uuid_4_validator(schema_section: dict, data: Any) -&gt; Optional[str]:    schema_format = schema_section.get(&quot;format&quot;)    if schema_format == &quot;uuid4&quot;:        try:            result = UUID(data, version=4)            if not str(result) == str(data):                return f&quot;Expected uuid4, but received {data}&quot;        except ValueError:            return f&quot;Expected uuid4, but received {data}&quot;    return None```### field_key_mapYou can pass an optional dictionary that maps custom url parameter names into values, for situations where this cannot beinferred by the DRF `EndpointEnumerator`. A concrete use case for this option is whenthe [django i18n locale prefixes](https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#language-prefix-in-url-patterns).```pythonfrom openapi_tester import SchemaTesterschema_tester = SchemaTester(field_key_map={  &quot;language&quot;: &quot;en&quot;,})```## Schema ValidationWhen the SchemaTester loads a schema, it parses it using an[OpenAPI spec validator](https://github.com/p1c2u/openapi-spec-validator). This validates the schema.In case of issues with the schema itself, the validator will raise the appropriate error.## Django testing clientThe library includes an `OpenAPIClient`, which extends Django REST framework's[`APIClient` class](https://www.django-rest-framework.org/api-guide/testing/#apiclient).If you wish to validate each response against OpenAPI schema when writingunit tests - `OpenAPIClient` is what you need!To use `OpenAPIClient` simply pass `SchemaTester` instance that should be usedto validate responses and then use it like regular Django testing client:```pythonschema_tester = SchemaTester()client = OpenAPIClient(schema_tester=schema_tester)response = client.get('/api/v1/tests/123/')```To force all developers working on the project to use `OpenAPIClient` simplyoverride the `client` fixture (when using `pytest` with `pytest-django`):```pythonfrom pytest_django.lazy_django import skip_if_no_djangofrom openapi_tester.schema_tester import SchemaTester@pytest.fixturedef schema_tester():    return SchemaTester()@pytest.fixturedef client(schema_tester):    skip_if_no_django()    from openapi_tester.clients import OpenAPIClient    return OpenAPIClient(schema_tester=schema_tester)```If you are using plain Django test framework, we suggest to create customtest case implementation and use it instead of original Django one:```pythonimport functoolsfrom django.test.testcases import SimpleTestCasefrom openapi_tester.clients import OpenAPIClientfrom openapi_tester.schema_tester import SchemaTesterschema_tester = SchemaTester()class MySimpleTestCase(SimpleTestCase):    client_class = OpenAPIClient    # or use `functools.partial` when you want to provide custom    # ``SchemaTester`` instance:    # client_class = functools.partial(OpenAPIClient, schema_tester=schema_tester)```This will ensure you all newly implemented views will be validated againstthe OpenAPI schema.## Known Issues* We are using [prance](https://github.com/jfinkhaeuser/prance) as a schema resolver, and it has some issues with the  resolution of (very) complex OpenAPI 2.0 schemas. If you encounter  issues, [please document them here](https://github.com/snok/drf-openapi-tester/issues/205).## ContributingContributions are welcome. Please see the [contributing guide](https://github.com/snok/.github/blob/main/CONTRIBUTING.md)</longdescription>
</pkgmetadata>