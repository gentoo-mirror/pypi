<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Asymmetric JWT Authentication=============================.. image:: https://img.shields.io/pypi/v/asymmetric_jwt_auth.svg    :target: https://pypi.python.org/pypi/asymmetric_jwt_auth.. image:: https://gitlab.com/crgwbr/asymmetric_jwt_auth/badges/master/pipeline.svg    :target: https://gitlab.com/crgwbr/asymmetric_jwt_auth/-/commits/master.. image:: https://gitlab.com/crgwbr/asymmetric_jwt_auth/badges/master/coverage.svg    :target: https://gitlab.com/crgwbr/asymmetric_jwt_auth/-/commits/masterWhat?-----This is an library designed to handle authentication in*server-to-server* API requests. It accomplishes this using RSA public /private key pairs.Why?----The standard pattern of using username and password works well foruser-to-server requests, but is lacking for server-to-serverapplications. In these scenarios, since the password doesn’t need to bememorable by a user, we can use something far more secure: asymmetrickey cryptography. This has the advantage that a password is neveractually sent to the server.How?----A public / private key pair is generated by the client machine. Theserver machine is then supplied with the public key, which it can storein any method it likes. When this library is used with Django, itprovides a model for storing public keys associated with built-in Userobjects. When a request is made, the client creates a JWT includingseveral claims and signs it using it’s private key. Upon receipt, theserver verifies the claim to using the public key to ensure the issueris legitimately who they claim to be.The claim (issued by the client) includes components: the username ofthe user who is attempting authentication, the current unix timestamp,and a randomly generated nonce. For example:::    {        &quot;username&quot;: &quot;guido&quot;,        &quot;time&quot;: 1439216312,        &quot;nonce&quot;: &quot;1&quot;    }The timestamp must be within ±20 seconds of the server time and thenonce must be unique within the given timestamp and user. In otherwords, if more than one request from a user is made within the samesecond, the nonce must change. Due to these two factors no token isusable more than once, thereby preventing replay attacks.To make an authenticated request, the client must generate a JWTfollowing the above format and include it as the HTTP Authorizationheader in the following format:::    Authorization: JWT &lt;my_token&gt;**Important note**: the claim is *not* encrypted, only signed.Additionally, the signature only prevents the claim from being tamperedwith or re-used. Every other part of the request is still vulnerable totamper. Therefore, this is not a replacement for using SSL in thetransport layer.**Full Documentation**: https://asymmetric-jwt-auth.readthedocs.io</longdescription>
</pkgmetadata>