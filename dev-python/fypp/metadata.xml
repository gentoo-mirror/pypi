<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>*********************************************Fypp â€” Python powered Fortran metaprogramming*********************************************.. image:: https://travis-ci.org/aradi/fypp.svg?branch=develop           :target: https://travis-ci.org/aradi/fyppFypp is a Python powered preprocessor. It can be used for any programminglanguages but its primary aim is to offer a Fortran preprocessor, which helps toextend Fortran with condititional compiling and template metaprogrammingcapabilities. Instead of introducing its own expression syntax, it uses Pythonexpressions in its preprocessor directives, offering the consistency andversatility of Python when formulating metaprogramming tasks. It puts strongemphasis on robustness and on neat integration into developing toolchains.The project is `hosted on github &lt;https://github.com/aradi/fypp&gt;`_.`Detailed DOCUMENTATION &lt;http://fypp.readthedocs.org&gt;`_ is available on`readthedocs.org &lt;http://fypp.readthedocs.org&gt;`_.Fypp is released under the *BSD 2-clause license*.Main features=============* Definition, evaluation and removal of variables::    #:if DEBUG &gt; 0      print *, &quot;Some debug information&quot;    #:endif    #:set LOGLEVEL = 2    print *, &quot;LOGLEVEL: ${LOGLEVEL}$&quot;    #:del LOGLEVEL* Macro definitions and macro calls::    #:def ASSERT(cond)      #:if DEBUG &gt; 0        if (.not. ${cond}$) then          print *, &quot;Assert failed in file ${_FILE_}$, line ${_LINE_}$&quot;          error stop        end if      #:endif    #:enddef ASSERT    ! Invoked via direct call (argument needs no quotation)    @:ASSERT(size(myArray) &gt; 0)    ! Invoked as Python expression (argument needs quotation)    $:ASSERT('size(myArray) &gt; 0')* Conditional output::    program test    #:if defined('WITH_MPI')      use mpi    #:elif defined('WITH_OPENMP')      use openmp    #:else      use serial    #:endif* Iterated output (e.g. for generating Fortran templates)::    interface myfunc    #:for dtype in ['real', 'dreal', 'complex', 'dcomplex']      module procedure myfunc_${dtype}$    #:endfor    end interface myfunc* Inline directives::    logical, parameter :: hasMpi = #{if defined('MPI')}# .true. #{else}# .false. #{endif}#* Insertion of arbitrary Python expressions::    character(*), parameter :: comp_date = &quot;${time.strftime('%Y-%m-%d')}$&quot;* Inclusion of files during preprocessing::    #:include &quot;macrodefs.fypp&quot;* Using Fortran-style continutation lines in preprocessor directives::    #:if var1 &gt; var2 &amp;        &amp; or var2 &gt; var4      print *, &quot;Doing something here&quot;    #:endif* Passing (unquoted) multiline string arguments to callables::    #! Callable needs only string argument    #:def DEBUG_CODE(code)      #:if DEBUG &gt; 0        $:code      #:endif    #:enddef DEBUG_CODE    #! Pass code block as first positional argument    #:block DEBUG_CODE      if (size(array) &gt; 100) then        print *, &quot;DEBUG: spuriously large array&quot;      end if    #:endblock DEBUG_CODE    #! Callable needs also non-string argument types    #:def REPEAT_CODE(code, repeat)      #:for ind in range(repeat)        $:code      #:endfor    #:enddef REPEAT_CODE    #! Pass code block as positional argument and 3 as keyword argument &quot;repeat&quot;    #:block REPEAT_CODE(repeat=3)    this will be repeated 3 times    #:endblock REPEAT_CODE* Preprocessor comments::    #! This will not show up in the output    #! Also the newline characters at the end of the lines will be suppressed* Suppressing the preprocessor output in selected regions::    #! Definitions are read, but no output (e.g. newlines) will be produced    #:mute    #:include &quot;macrodefs.fypp&quot;    #:endmute* Explicit request for stopping the preprocessor::    #:if DEBUGLEVEL &lt; 0      #:stop 'Negative debug level not allowed!'    #:endif* Easy check for macro parameter sanity::    #:def mymacro(RANK)      #! Macro only works for RANK 1 and above      #:assert RANK &gt; 0      :    #:enddef mymacro* Line numbering directives in output::    program test    #:if defined('MPI')    use mpi    #:endif    :  transformed to ::    # 1 &quot;test.fypp&quot; 1    program test    # 3 &quot;test.fypp&quot;    use mpi    # 5 &quot;test.fypp&quot;    :  when variable ``MPI`` is defined and Fypp was instructed to generate line  markers.* Automatic folding of generated lines exceeding line length limitInstalling==========Fypp needs a working Python 3 interpreter (Python 3.5 or above).When you install Fypp, you obtain the command line tool ``fypp`` and the Pythonmodule ``fypp.py``. Latter you can import if you want to access thefunctionality of Fypp directly from within your Python scripts.Installing via conda--------------------The last stable release of Fypp can be easily installed as conda package byissuing ::  conda install -c conda-forge fyppInstalling via pip------------------You can also use Pythons command line installer ``pip`` in order to download thestable release from the `Fypp page on PyPI &lt;http://pypi.python.org/pypi/fypp&gt;`_and install it on your system.If you want to install Fypp into the module system of the active Python 3interpreter (typically the case when you are using a Python virtualenvironment), issue ::  pip3 install fyppAlternatively, you can install Fypp into the user space (under `~/.local`) with::  pip3 install --user fyppInstalling via MSYS2 pacman---------------------------On Windows you can use the `MSYS2 toolchain &lt;https://www.msys2.org/&gt;`_ to installFypp in a MinGW terminal. To install Fypp use::  pacman -S mingw-w64-x86_64-python-fyppMake sure the selected architecture is matching your current MinGW terminal.For all supporting MinGW architectures visit check the package index`here &lt;https://packages.msys2.org/base/mingw-w64-python-fypp&gt;`_.Manual install--------------For a manual install, you can download the source code of the **stable**releases from the `Fypp project website&lt;https://github.com/aradi/fypp/releases&gt;`_.If you wish to obtain the latest **development** version, clone the projectsrepository::  git clone https://github.com/aradi/fypp.gitand check out the `master` branch.The command line tool is a single stand-alone script. You can run it directlyfrom the source folder ::  FYPP_SOURCE_FOLDER/bin/fyppor after copying it from the `bin` folder to any location listed in your `PATH`environment variable, by just issuing ::  fyppThe python module ``fypp.py`` can be found in ``FYP_SOURCE_FOLDER/src``.Running=======The Fypp command line tool reads a file, preprocesses it and writes it toanother file, so you would typically invoke it like::  fypp source.fpp source.f90which would process `source.fpp` and write the result to `source.f90`.  Ifinput and output files are not specified, information is read from stdin andwritten to stdout.The behavior of Fypp can be influenced with various command line options. Asummary of all command line options can be obtained by::  fypp -h</longdescription>
</pkgmetadata>