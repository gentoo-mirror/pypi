<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Pyrsec&gt; Simple parser combinator made in Python![PyPI](https://img.shields.io/pypi/v/pyrsec)![PyPI - License](https://img.shields.io/pypi/l/pyrsec)[![codecov](https://codecov.io/gh/frndmg/pyrsec/branch/main/graph/badge.svg?token=ROCVIXSZMO)](https://codecov.io/gh/frndmg/pyrsec)In the journey of creating a parser combinator in python while being as type safe aspossible we are here now. I don't recommend you use this for anything important but forexploration and fun. This library is a mostly undocumented, bare bone implementation ofa parser combinator, no error recovery is currently in place, only `None` is returned incase the parser can't continue. I basically started with a minimum implementation whileadding a basic `json` parser as a test and kept adding functionality as needed.```bashpip install pyrsec```## A Json parser as an example&gt; You should be able to inspect the types of the variables in the following code```python&gt;&gt;&gt; from pyrsec import Parsec```Lets define the type of our json values,```python&gt;&gt;&gt; from typing import Union, List, Dict  # because 3.8 and 3.9 ðŸ™„&gt;&gt;&gt; # Recursive type alias ðŸ‘€. See how we will not parse `floats` here.&gt;&gt;&gt; # Also at this level we can't still reference JSON recursively, idk why.&gt;&gt;&gt; JSON = Union[bool, int, None, str, List[&quot;JSON&quot;], Dict[str, &quot;JSON&quot;]]```and the type of our parser. Since this is a parser that will output `JSON` values itstype will be `Parsec[JSON]`.```python&gt;&gt;&gt; # To be defined later&gt;&gt;&gt; json_: Parsec[JSON]&gt;&gt;&gt; # For recursive parsers like `list_` and `dict_`&gt;&gt;&gt; deferred_json_ = Parsec.from_deferred(lambda: json_)```Lets bring up a few basic parsers.```python&gt;&gt;&gt; import re&gt;&gt;&gt; true = Parsec.from_string(&quot;true&quot;).map(lambda _: True)&gt;&gt;&gt; false = Parsec.from_string(&quot;false&quot;).map(lambda _: False)&gt;&gt;&gt; null = Parsec.from_string(&quot;null&quot;).map(lambda _: None)&gt;&gt;&gt; number = Parsec.from_re(re.compile(r&quot;-?\d+&quot;)).map(int)&gt;&gt;&gt; true(&quot;true&quot;)(True, '')&gt;&gt;&gt; false(&quot;false&quot;)(False, '')&gt;&gt;&gt; null(&quot;null&quot;)(None, '')&gt;&gt;&gt; number(&quot;42&quot;)(42, '')```We need to be able to parse character sequences, lets keep it simple.The operators `&gt;&gt;` and `&lt;&lt;` are used to discard the part that the arrow is not pointingat. They are meant to work well with `Parsec` instances. In this case only the result ofthe middle parser `Parsec.from_re(re.compile(r&quot;[^\&quot;]*&quot;))` is returned from the `string`parser.If what you want instead is to concatenate the results you should see the `&amp;` operator.(wait for the pair definition).```python&gt;&gt;&gt; quote = Parsec.from_string('&quot;').ignore()&gt;&gt;&gt; string = quote &gt;&gt; Parsec.from_re(re.compile(r&quot;[^\&quot;]*&quot;)) &lt;&lt; quote&gt;&gt;&gt; string('&quot;foo&quot;')('foo', '')```See how the quotes got discarded?Also, missing a quote would mean a parsing error.```python&gt;&gt;&gt; string('foo&quot;'), string('&quot;bar')(None, None)```Lets get a little bit more serious with the lists.Spaces are always optional on `json` strings. Other basic tokens are also needed.```python&gt;&gt;&gt; space = Parsec.from_re(re.compile(r&quot;\s*&quot;)).ignore()&gt;&gt;&gt; comma = Parsec.from_string(&quot;,&quot;).ignore()&gt;&gt;&gt; opened_square_bracket = Parsec.from_string(&quot;[&quot;).ignore()&gt;&gt;&gt; closed_square_bracket = Parsec.from_string(&quot;]&quot;).ignore()```And finally, the `list` parser. We need to use a deferred value here because thedefinition is recursive but the whole `json` parser is still not available.```python&gt;&gt;&gt; list_ = (...     opened_square_bracket...     &gt;&gt; (deferred_json_.sep_by(comma))  # See here?...     &lt;&lt; closed_square_bracket... )```Lets create an incomplete one.```python&gt;&gt;&gt; json_ = space &gt;&gt; (true | false | number | null | string | list_) &lt;&lt; space```Lets try it then!```python&gt;&gt;&gt; list_(&quot;[]&quot;)([], '')&gt;&gt;&gt; list_(&quot;[1, true, false, []]&quot;)([1, True, False, []], '')```Defining a dict should be pretty easy by now. Maybe the `pair` parser is interestingbecause its use of `&amp;`.Some tokens,```python&gt;&gt;&gt; opened_bracket = Parsec.from_string(&quot;{&quot;).ignore()&gt;&gt;&gt; closed_bracket = Parsec.from_string(&quot;}&quot;).ignore()&gt;&gt;&gt; colon = Parsec.from_string(&quot;:&quot;).ignore()```And `pair`, notice that the type of `pair` will be `Parsec[tuple[str, JSON]]`.```python&gt;&gt;&gt; pair = ((space &gt;&gt; string &lt;&lt; space) &lt;&lt; colon) &amp; deferred_json_&gt;&gt;&gt; pair('&quot;foo&quot;: [123]')(('foo', [123]), '')```The `dict` parser will finally be pretty close to the `list` one.```python&gt;&gt;&gt; dict_ = (...     opened_bracket...     &gt;&gt; pair.sep_by(comma).map(lambda xs: dict(xs))...     &lt;&lt; closed_bracket... )```And finally lets redefine the `json` parser to embrace the full beauty of it.```python&gt;&gt;&gt; json_ = space &gt;&gt; (true | false | number | null | string | list_ | dict_) &lt;&lt; space&gt;&gt;&gt; json_(&quot;&quot;&quot;... {...     &quot;json_parser&quot;: [true]... }... &quot;&quot;&quot;)({'json_parser': [True]}, '')```Enjoy!</longdescription>
</pkgmetadata>