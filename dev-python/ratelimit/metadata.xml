<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>ratelimit |build| |maintainability|===================================.. |build| image:: https://travis-ci.org/tomasbasham/ratelimit.svg?branch=master    :target: https://travis-ci.org/tomasbasham/ratelimit.. |maintainability| image:: https://api.codeclimate.com/v1/badges/21dc7c529c35cd7ef732/maintainability    :target: https://codeclimate.com/github/tomasbasham/ratelimit/maintainability    :alt: MaintainabilityAPIs are a very common way to interact with web services. As the need toconsume data grows, so does the number of API calls necessary to remain up todate with data sources. However many API providers constrain developers frommaking too many API calls. This is know as rate limiting and in a worst casescenario your application can be banned from making further API calls if itabuses these limits.This packages introduces a function decorator preventing a function from beingcalled more often than that allowed by the API provider. This should preventAPI providers from banning your applications by conforming to their ratelimits.Installation------------PyPi~~~~To install ratelimit, simply:.. code:: bash    $ pip install ratelimitGitHub~~~~~~Installing the latest version from Github:.. code:: bash    $ git clone https://github.com/tomasbasham/ratelimit    $ cd ratelimit    $ python setup.py installUsage-----To use this package simply decorate any function that makes an API call:.. code:: python    from ratelimit import limits    import requests    FIFTEEN_MINUTES = 900    @limits(calls=15, period=FIFTEEN_MINUTES)    def call_api(url):        response = requests.get(url)        if response.status_code != 200:            raise Exception('API response: {}'.format(response.status_code))        return responseThis function will not be able to make more then 15 API call within a 15 minutetime period.The arguments passed into the decorator describe the number of functioninvocation allowed over a specified time period (in seconds). If no time periodis specified then it defaults to 15 minutes (the time window imposed byTwitter).If a decorated function is called more times than that allowed within thespecified time period then a ``ratelimit.RateLimitException`` is raised. Thismay be used to implement a retry strategy such as an `expoential backoff&lt;https://pypi.org/project/backoff/&gt;`_.. code:: python    from ratelimit import limits, RateLimitException    from backoff import on_exception, expo    import requests    FIFTEEN_MINUTES = 900    @on_exception(expo, RateLimitException, max_tries=8)    @limits(calls=15, period=FIFTEEN_MINUTES)    def call_api(url):        response = requests.get(url)        if response.status_code != 200:            raise Exception('API response: {}'.format(response.status_code))        return responseAlternatively to cause the current thread to sleep until the specified timeperiod has ellapsed and then retry the function use the ``sleep_and_retry``decorator. This ensures that every function invocation is successful at thecost of halting the thread... code:: python    from ratelimit import limits, sleep_and_retry    import requests    FIFTEEN_MINUTES = 900    @sleep_and_retry    @limits(calls=15, period=FIFTEEN_MINUTES)    def call_api(url):        response = requests.get(url)        if response.status_code != 200:            raise Exception('API response: {}'.format(response.status_code))        return responseContributing------------1. Fork it (https://github.com/tomasbasham/ratelimit/fork)2. Create your feature branch (`git checkout -b my-new-feature`)3. Commit your changes (`git commit -am 'Add some feature'`)4. Push to the branch (`git push origin my-new-feature`)5. Create a new Pull Request</longdescription>
</pkgmetadata>