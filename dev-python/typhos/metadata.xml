<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;img src=&quot;docs/source/_static/hydra.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; align=&quot;right&quot;/&gt;  &lt;h1&gt;Typhos&lt;/h1&gt;  &lt;h3&gt;Automated User Interface Creation from Ophyd Devices&lt;/h3&gt;&lt;/p&gt;EPICS is a flexible and powerful controls system that gives access to experimentalinformation, however, the relation and meaning of process variables is oftenobscure. Many of the user interfaces for EPICS information reflect this, aswalls of buttons and flashing lights bombard the user with little thought tostructure or cohesion.Typhos addresses this by providing an automated way to generate screens basedon a provided hierarchy of devices and signals. Built using PyDM, a PyQt baseddisplay manager developed at SLAC National Laboratory, Typhos utilizes a largetoolkit of widgets to display EPICS information. For each process variable, acorresponding widget is created based on; the importance to the averageoperator, the type of value the EPICS PV will return, and whether a user shouldbe allowed to write to the variable. These widgets are then placed in aconvenient tab-based system to only show the necessary information for basicfunction, but still allow access to more advanced signals.Instead of reinventing a new way to specify device structures, Typhos uses`Ophyd`, a library to abstract EPICS information into consistently structuredPython objects. Originally built for scripting experimental procedures atNSLSII, Ophyd represents devices as combinations of components which areeither signals or nested devices. Then, either at runtime or by using thedefaults of the representative Python class, these signals are sorted intodifferent categories based on their relevance to operators. Typhos uses thisinformation to craft user interfaces.## InstallationRecommended installation on Linux:```conda install typhos -c conda-forge -c pcds-tag```All `-tag` channels have `-dev` counterparts for bleeding edge installations.Both `requirements.txt` and optional `dev-requirements.txt` are kept up to dateas well for those who prefer installation via `pip`typhos utilizes PyDM's designer widget entrypoints.  This means that if youhave PyDM working correctly with the Qt Designer, typhos widgets will also beavailable.  No further customization or environment settings are required.`happi` is an optional dependency but is recommended. This must be installedmanually if not using the CONDA recipe.### Qt InstallationThere have been some observed inconsistencies between installations of `Qt`available on `pip`, `defaults` and `conda-forge`. It is recommended that if youwant to use the full `typhos` feature to install via `conda-forge`. We havefound this the most reliable, especially when it comes to using the`QtDesigner`. It is worth noting that since this library uses `qtpy` as aninterface layer to the various options for Qt Python bindings, the barerequirements will not install a specific one for you. The testing suite runsusing `PyQt5`.## Getting StartedCreating your first ``typhos`` panel for an``ophyd.Device`` only takes twolines:```pythonimport sysfrom ophyd.sim import motorfrom qtpy.QtWidgets import QApplicationimport typhos# Create our applicationapp = QApplication.instance() or QApplication(sys.argv)typhos.use_stylesheet()  # Optionalsuite = typhos.TyphosSuite.from_device(motor)# Launchsuite.show()app.exec_()```## Available WidgetsTyphos has three major building blocks that combine into the final display seenby the operator:* ``TyphosSuite``: The overall view for a Typhos window. It allows theoperator to view all of the loaded components and tools* ``TyphosDeviceDisplay``: This is the widget created for a standard``ophyd.Device``. Signals are organized based on their``Kind`` and description.* ``typhos.tools``: These are widgets that interface with externalapplications. While you may have other GUIs for these systems,``typhos.tools`` are built especially to handle the handshaking between all theinformation stored on your device and the tool you are interfacing with. Thissaves your operator clicks and ensures consistency in use.### Initialization PatternAll three of the widgets listed above share a similar API for creation.Instantiating the object by itself handles loading the container widgets andplacing them in the correct place, but these do not accept ``ophyd.Device``arguments. The reason for this is to ensure that we can use all of the``typhos`` screens as templates, and regardless or not of whether you have an``ophyd.Device`` you can always populate the screens by hand. If you do in facthave an ``ophyd.Device`` every class has an ``add_device`` method andalternatively and be constructed using the ``from_device`` classmethod.## Related Projects[**PyDM**](https://github.com/slaclab/pydm) - PyQT Display Manager for EPICS information[**Ophyd**](https://github.com/NSLS-II/ophyd) - Device abstraction for Experimental Control</longdescription>
</pkgmetadata>