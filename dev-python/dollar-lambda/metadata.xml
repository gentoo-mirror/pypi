<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;  &lt;img height=&quot;300&quot; src=&quot;https://dollar-lambda.readthedocs.io/en/latest/_static/logo.png&quot;&gt;&lt;/p&gt;[$λ](https://dollar-lambda.readthedocs.io/) provides an alternative to [`argparse`](https://docs.python.org/3/library/argparse.html)based on parser combinators and functional first principles. Arguably, `$λ` is way more expressive than any reasonableperson would ever need... but even if it's not the parser that we need, it's the parser we deserve.# Installation```pip install dollar-lambda```# [Documentation](https://dollar-lambda.readthedocs.io/)# Highlights`$λ` comes with syntactic sugar that can make building parsers completely boilerplate-free.For complex parsing situations that exceed the expressive capacity of this syntax,the user can also drop down to the lower-level syntax that lies behind the sugar, which canhandle any reasonable amount of logical complexity.## The [`@command`](https://dollar-lambda.readthedocs.io/en/latest/api.html?highlight=command#dollar_lambda.decorators.command)decoratorFor the vast majority of parsing patterns,[`@command`](https://dollar-lambda.readthedocs.io/en/latest/api.html?highlight=command#dollar_lambda.decorators.command)is the most concise way to define a parser:```pythonfrom dollar_lambda import command@command()def main(x: int, dev: bool = False, prod: bool = False):    print(dict(x=x, dev=dev, prod=prod))```Here is the help text generated by this parser:```pythonmain(&quot;-h&quot;)```    usage: -x X --dev --prod    dev: (default: False)    prod: (default: False)Ordinarily you provide no arguments to `main` and it would get them from the command line.The explicit arguments in this Readme are for demonstration purposes only.Here is how the main function handles input:```pythonmain(&quot;-x&quot;, &quot;1&quot;, &quot;--dev&quot;)```    {'x': 1, 'dev': True, 'prod': False}Use the `parsers` argument to add custom logic using the lower-level syntax:```pythonfrom dollar_lambda import flag@command(parsers=dict(kwargs=flag(&quot;dev&quot;) | flag(&quot;prod&quot;)))def main(x: int, **kwargs):    print(dict(x=x, **kwargs))```This parser requires either a `--dev` or `--prod` flag and maps it to the `kwargs` argument:```pythonmain(&quot;-h&quot;)```    usage: -x X [--dev | --prod]This assigns `{'dev': True}` to the `kwargs` argument:```pythonmain(&quot;-x&quot;, &quot;1&quot;, &quot;--dev&quot;)```    {'x': 1, 'dev': True}This assigns `{'prod': True}` to the `kwargs` argument:```pythonmain(&quot;-x&quot;, &quot;1&quot;, &quot;--prod&quot;)```    {'x': 1, 'prod': True}This fails because the parser requires one or the other:```pythonmain(&quot;-x&quot;, &quot;1&quot;)```    usage: -x X [--dev | --prod]    The following arguments are required: --dev## [`CommandTree`](https://dollar-lambda.readthedocs.io/en/latest/commandtree.html) for dynamic dispatchFor many programs, a user will want to use one entrypoint for one set ofarguments, and another for another set of arguments. Returning to our example,let's say we wanted to execute `prod_function` when the user provides the`--prod` flag, and `dev_function` when the user provides the `--dev` flag:```pythonfrom dollar_lambda import CommandTreetree = CommandTree()@tree.command()def base_function(x: int):    print(&quot;Ran base_function with arguments:&quot;, dict(x=x))@base_function.command()def prod_function(x: int, prod: bool):    print(&quot;Ran prod_function with arguments:&quot;, dict(x=x, prod=prod))@base_function.command()def dev_function(x: int, dev: bool):    print(&quot;Ran dev_function with arguments:&quot;, dict(x=x, dev=dev))```Let's see how this parser handles different inputs.If we provide the `--prod` flag, `$λ` automatically invokes `prod_function` with the parsed arguments:```pythontree(    &quot;-x&quot;, &quot;1&quot;, &quot;--prod&quot;)  # usually you provide no arguments and tree gets them from sys.argv```    Ran prod_function with arguments: {'x': 1, 'prod': True}If we provide the `--dev` flag, `$λ` invokes `dev_function`:```pythontree(&quot;-x&quot;, &quot;1&quot;, &quot;--dev&quot;)```    Ran dev_function with arguments: {'x': 1, 'dev': True}With this configuration, the parser will run `base_function` if neither`--prod` nor `--dev` are given:```pythontree(&quot;-x&quot;, &quot;1&quot;)```    Ran base_function with arguments: {'x': 1}There are many other ways to use [`CommandTree`](https://dollar-lambda.readthedocs.io/en/latest/commandtree.html).To learn more, we recommend the [`CommandTree` tutorial](https://dollar-lambda.readthedocs.io/en/latest/command_tree.html).## Lower-level syntax[`@command`](https://dollar-lambda.readthedocs.io/en/latest/api.html?highlight=command#dollar_lambda.decorators.command)and [`CommandTree`](https://dollar-lambda.readthedocs.io/en/latest/api.html#dollar_lambda.decorators.CommandTree)cover many use cases,but they are both syntactic sugar for a lower-level interface that is farmore expressive.Suppose you want to implement a parser that first tries to parse an option(a flag that takes an argument),`-x X` and if that fails, tries to parse the input as a variadic sequence offloats:```pythonfrom dollar_lambda import argument, optionp = option(&quot;x&quot;, type=int) | argument(&quot;y&quot;, type=float).many()```We go over this syntax in greater detail in the [tutorial](https://dollar-lambda.readthedocs.io/en/latest/tutorial.html).For now, suffice to say that [`argument`](https://dollar-lambda.readthedocs.io/en/latest/api.html?highlight=argument#dollar_lambda.parsers.argument) defines a positional argument,[`many`](https://dollar-lambda.readthedocs.io/en/latest/variations.html?highlight=many#many) allows parsers to be appliedzero or more times, and [`|`](https://dollar-lambda.readthedocs.io/en/latest/api.html?highlight=__or__#dollar_lambda.parsers.Parser.__or__) expresses alternatives.Here is the help text:```pythonp.parse_args(    &quot;-h&quot;)  # usually you provide no arguments and parse_args gets them from sys.argv```    usage: [-x X | [Y ...]]As promised, this succeeds:```pythonp.parse_args(&quot;-x&quot;, &quot;1&quot;)```    {'x': 1}And this succeeds:```pythonp.parse_args(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)```    {'y': [1.0, 2.0, 3.0]}### ThanksSpecial thanks to [&quot;Functional Pearls&quot;](https://www.cs.nott.ac.uk/~pszgmh/pearl.pdf) by Graham Hutton and Erik Meijer for bringing these topics to life.</longdescription>
</pkgmetadata>