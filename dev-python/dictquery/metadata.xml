<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>DictQuery========================Library to query python dictsSeveral syntax examples:```&quot;age &gt;= 12&quot;&quot;`user.name` == 'cyberlis'&quot;&quot;`user.email` MATCH /\w+@\w+\.com/ AND age != 11&quot;&quot;`user.friends.age` &gt; 12 AND `user.friends.name` LIKE 'Ra*ond'&quot;&quot;email LIKE 'mariondelgado?bleendot?com'&quot;&quot;eyeColor IN ['blue', 'green', 'black']&quot;&quot;isActive AND (gender == 'female' OR age == 27)&quot;&quot;latitude != longitude&quot;```Supported data types====================| type | example ||-----------|---------|| KEY       | name, age, \`friends.name.firstname\`, \`friends.age\` || NUMBER    | 42, -12, 34.7 || STRING    | 'hello', &quot;hellow&quot; || BOOLEAN   | true, false || NONE      | none, null || NOW       | utc current datetime || REGEXP    | /\d+\d+\w+/ || ARRAY     | list of any items and any types |Keys===========Key literals must start with a letter or an underscore, such as:  * `_underscore`  * `underscore_`The remainder of your variable name may consist of letters, numbers and underscores.  * `password1`  * `n00b`  * `un_der_scores`If you need a key with separator character (`.` or `/`) because you use nested keys, or need spaces or other punctuation characters in key, use back-ticks (\`\`)DictQuery supports nested dicts splited by dot `.` or any separator specified in `key_separator` param. Default `key_separator='.'````&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;`friends.age` &lt;= 26&quot;)True&gt;&gt;&gt; compiled = dq.compile(&quot;`friends/age` &lt;= 26&quot;, key_separator='/')&gt;&gt;&gt; compiled.match(data)True```if you don't need nested keys parsing and want get keys as is or if your keys contain separator char, you can disable nested keys behaviour by setting `use_nested_keys=False````&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;`user.address`&quot;)False&gt;&gt;&gt; dq.match(data, &quot;age&quot;)True&gt;&gt;&gt; compiled = dq.compile(&quot;`user.address`&quot;, use_nested_keys=False)&gt;&gt;&gt; compiled.match(data)True```In query you can use dict keys 'as is' without any binary operation. DictQuery will get value by the key and evaluate it to bool```&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;isActive&quot;)False&gt;&gt;&gt; dq.match(data, &quot;isActive == false&quot;)True```if key is not found by default this situation evaluates to boolean `False` (no exception raised).You can set `raise_keyerror=True` to raise keyerror if key would not be found.```&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;favoriteFruit&quot;)False&gt;&gt;&gt; compiled = dq.compile(&quot;`favoriteFruit`&quot;, raise_keyerror=True)&gt;&gt;&gt; compiled.match(data)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;.../dictquery/dictquery/visitors.py&quot;, line 41, in match    return self.evaluate(data)  File &quot;.../dictquery/dictquery/visitors.py&quot;, line 35, in evaluate    result = bool(self.ast.accept(self))  File &quot;.../dictquery/dictquery/parsers.py&quot;, line 80, in accept    return visitor.visit_key(self)  File &quot;.../dictquery/dictquery/visitors.py&quot;, line 84, in visit_key    values=self._get_dict_value(expr.value),  File &quot;.../dictquery/dictquery/visitors.py&quot;, line 30, in _get_dict_value    self.key_separator, self.raise_keyerror)  File &quot;.../dictquery/dictquery/datavalue.py&quot;, line 112, in query_value    raise DQKeyError(&quot;Key '{}' not found&quot;.format(data_key))dictquery.exceptions.DQKeyError: &quot;Key 'favoriteFruit' not found&quot;```Comparisons===========| Operation | Meaning ||-----------|---------|| &lt;         | strictly less than || &lt;=        | less than or equal || &gt;         | strictly greater than || &gt;=        | greater than or equal || ==        | equal || !=        | not equal |```&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;age == 26&quot;)True&gt;&gt;&gt; dq.match(data, &quot;latitude &gt; 12&quot;)True&gt;&gt;&gt; dq.match(data, &quot;longitude &lt; 30&quot;)True&gt;&gt;&gt; dq.match(data, &quot;`friends.age` &lt;= 26&quot;)True&gt;&gt;&gt; dq.match(data, &quot;longitude &gt;= -130&quot;)True&gt;&gt;&gt; dq.match(data, &quot;id != 0&quot;)True&gt;&gt;&gt; dq.match(data, &quot;gender == 'male'&quot;)False```String comparisons and matching===============================String literals are written in a variety of ways:* Single quotes: 'allows embedded &quot;double&quot; quotes'* Double quotes: &quot;allows embedded 'single' quotes&quot;.| Operation | Meaning ||-----------|---------|| MATCH     | regexp matching || LIKE      | glob like matching || IN        | dict item substring in string || CONTAINS   | dict item substring contains string |&lt; , &lt;= , &gt; , &gt;= , == , != works same way with strings as python```&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;eyeColor == 'green'&quot;)True&gt;&gt;&gt; dq.match(data, &quot;`name.firstname` != 'Ratliff'&quot;)True&gt;&gt;&gt; dq.match(data, &quot;eyeColor IN 'string with green color'&quot;)True&gt;&gt;&gt; dq.match(data, &quot;email CONTAINS '.com'&quot;)True&gt;&gt;&gt; dq.match(data, r&quot;email MATCH /\w+@\w+\.\w+/&quot;)True&gt;&gt;&gt; dq.match(data, r&quot;email LIKE 'mariondelgado@*'&quot;)True&gt;&gt;&gt; dq.match(data, r&quot;email LIKE 'mariondelgado?bleendot?com'&quot;)True```By default all string related operations are case sensitive. To change this behaviour you have to create instance of DictQuery with `case_sensitive=False````&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;`name.firstname` == 'marion'&quot;)False&gt;&gt;&gt; compiled = dq.compile(&quot;`name.firstname` == 'marion'&quot;, case_sensitive=False)&gt;&gt;&gt; compiled.match(data)True```Array comparisons=================| Operation | Meaning ||-----------|---------|| IN        | dict item in array || CONTAINS   | dict item contains matching item |```&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;tags CONTAINS 'dolor'&quot;)True&gt;&gt;&gt; dq.match(data, &quot;eyeColor IN ['blue', 'green', 'black']&quot;)True```Key presence in dict=====================`CONTAINS` can be used with dict items to check if key in dict```&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;name CONTAINS 'firstname'&quot;)True&gt;&gt;&gt; dq.match(data, &quot;name CONTAINS 'thirdname'&quot;)False```Datetime comparisons with `NOW`===============================`NOW` returns current utc datetimedict item can be compared with `NOW` using standard operations (&lt; , &lt;= , &gt; , &gt;= , == , !=)```&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;registered &lt; NOW&quot;)True&gt;&gt;&gt; dq.match(data, &quot;registered != NOW&quot;)True```Logical operators=================|Operator|Meaning|Example||--------|---------|---------||and|True if both the operands are true|x and y||or|True if either of the operands is true|x or y||not|True if operand is false (complements the operand)|not x |```&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;isActive AND gender == 'female'&quot;)False&gt;&gt;&gt; dq.match(data, &quot;isActive OR gender == 'female'&quot;)True&gt;&gt;&gt; dq.match(data, &quot;NOT isActive AND gender == 'female'&quot;)True```You can use parentheses to group statements or change evaluation order```&gt;&gt;&gt; import dictquery as dq&gt;&gt;&gt; dq.match(data, &quot;isActive AND gender == 'female' OR age == 27&quot;)True&gt;&gt;&gt; dq.match(data, &quot;isActive AND (gender == 'female' OR age == 27)&quot;)False```Data for examples above:=================```from datetime import datetimedata = {  &quot;_id&quot;: 10,  &quot;isActive&quot;: False,  &quot;age&quot;: 27,  &quot;eyeColor&quot;: &quot;green&quot;,  &quot;name&quot;: {    &quot;firstname&quot;: &quot;Marion&quot;,    &quot;secondname&quot;: &quot;Delgado&quot;,  },  &quot;gender&quot;: &quot;female&quot;,  &quot;email&quot;: &quot;mariondelgado@bleendot.com&quot;,  &quot;registered&quot;: datetime.strptime(&quot;2015-03-29T06:07:58&quot;, &quot;%Y-%m-%dT%H:%M:%S&quot;),  &quot;latitude&quot;: 74.785608,  &quot;longitude&quot;: -112.366088,  &quot;tags&quot;: [    &quot;voluptate&quot;,    &quot;ex&quot;,    &quot;dolor&quot;,    &quot;aute&quot;  ],  &quot;user.address&quot;: &quot;155 Village Road, Enetai, Puerto Rico, 2634&quot;,  &quot;friends&quot;: [    {      &quot;id&quot;: 0,      &quot;name&quot;: {        &quot;firstname&quot;: &quot;Ratliff&quot;,        &quot;secondname&quot;: &quot;Becker&quot;,      },      &quot;age&quot;: 27,      &quot;eyeColor&quot;: &quot;green&quot;    },    {      &quot;id&quot;: 1,      &quot;name&quot;: {        &quot;firstname&quot;: &quot;Raymond&quot;,        &quot;secondname&quot;: &quot;Albert&quot;,      },      &quot;age&quot;: 19,      &quot;eyeColor&quot;: &quot;brown&quot;    },    {      &quot;id&quot;: 2,      &quot;name&quot;: {        &quot;firstname&quot;: &quot;Mavis&quot;,        &quot;secondname&quot;: &quot;Sheppard&quot;,      },      &quot;age&quot;: 34,      &quot;eyeColor&quot;: &quot;blue&quot;    }  ]}```</longdescription>
</pkgmetadata>