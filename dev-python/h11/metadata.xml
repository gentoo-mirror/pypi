<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>h11===.. image:: https://travis-ci.org/python-hyper/h11.svg?branch=master   :target: https://travis-ci.org/python-hyper/h11   :alt: Automated test status.. image:: https://codecov.io/gh/python-hyper/h11/branch/master/graph/badge.svg   :target: https://codecov.io/gh/python-hyper/h11   :alt: Test coverage.. image:: https://readthedocs.org/projects/h11/badge/?version=latest   :target: http://h11.readthedocs.io/en/latest/?badge=latest   :alt: Documentation StatusThis is a little HTTP/1.1 library written from scratch in Python,heavily inspired by `hyper-h2 &lt;https://hyper-h2.readthedocs.io/&gt;`_.It's a &quot;bring-your-own-I/O&quot; library; h11 contains no IO codewhatsoever. This means you can hook h11 up to your favorite networkAPI, and that could be anything you want: synchronous, threaded,asynchronous, or your own implementation of `RFC 6214&lt;https://tools.ietf.org/html/rfc6214&gt;`_ -- h11 won't judge you.(Compare this to the current state of the art, where every time a `newnetwork API &lt;https://trio.readthedocs.io/&gt;`_ comes along then someonegets to start over reimplementing the entire HTTP protocol fromscratch.) Cory Benfield made an `excellent blog post describing thebenefits of this approach&lt;https://lukasa.co.uk/2015/10/The_New_Hyper/&gt;`_, or if you like videothen here's his `PyCon 2016 talk on the same theme&lt;https://www.youtube.com/watch?v=7cC3_jGwl_U&gt;`_.This also means that h11 is not immediately useful out of the box:it's a toolkit for building programs that speak HTTP, not somethingthat could directly replace ``requests`` or ``twisted.web`` orwhatever. But h11 makes it much easier to implement something like``requests`` or ``twisted.web``.At a high level, working with h11 goes like this:1) First, create an ``h11.Connection`` object to track the state of a   single HTTP/1.1 connection.2) When you read data off the network, pass it to   ``conn.receive_data(...)``; you'll get back a list of objects   representing high-level HTTP &quot;events&quot;.3) When you want to send a high-level HTTP event, create the   corresponding &quot;event&quot; object and pass it to ``conn.send(...)``;   this will give you back some bytes that you can then push out   through the network.For example, a client might instantiate and then send a``h11.Request`` object, then zero or more ``h11.Data`` objects for therequest body (e.g., if this is a POST), and then a``h11.EndOfMessage`` to indicate the end of the message. Then theserver would then send back a ``h11.Response``, some ``h11.Data``, andits own ``h11.EndOfMessage``. If either side violates the protocol,you'll get a ``h11.ProtocolError`` exception.h11 is suitable for implementing both servers and clients, and has apleasantly symmetric API: the events you send as a client are exactlythe ones that you receive as a server and vice-versa.`Here's an example of a tiny HTTP client&lt;https://github.com/python-hyper/h11/blob/master/examples/basic-client.py&gt;`_It also has `a fine manual &lt;https://h11.readthedocs.io/&gt;`_.FAQ---*Whyyyyy?*I wanted to play with HTTP in `Curio&lt;https://curio.readthedocs.io/en/latest/tutorial.html&gt;`__ and `Trio&lt;https://trio.readthedocs.io&gt;`__, which at the time didn't have anyHTTP libraries. So I thought, no big deal, Python has, like, a dozendifferent implementations of HTTP, surely I can find one that'sreusable. I didn't find one, but I did find Cory's call-to-armsblog-post. So I figured, well, fine, if I have to implement HTTP fromscratch, at least I can make sure no-one *else* has to ever again.*Should I use it?*Maybe. You should be aware that it's a very young project. But, it'sfeature complete and has an exhaustive test-suite and complete docs,so the next step is for people to try using it and see how it goes:-). If you do then please let us know -- if nothing else we'll wantto talk to you before making any incompatible changes!*What are the features/limitations?*Roughly speaking, it's trying to be a robust, complete, and non-hackyimplementation of the first &quot;chapter&quot; of the HTTP/1.1 spec: `RFC 7230:HTTP/1.1 Message Syntax and Routing&lt;https://tools.ietf.org/html/rfc7230&gt;`_. That is, it mostly focuses onimplementing HTTP at the level of taking bytes on and off the wire,and the headers related to that, and tries to be anal about specconformance. It doesn't know about higher-level concerns like URLrouting, conditional GETs, cross-origin cookie policies, or contentnegotiation. But it does know how to take care of framing,cross-version differences in keep-alive handling, and the &quot;obsoleteline folding&quot; rule, so you can focus your energies on the hard /interesting parts for your application, and it tries to support thefull specification in the sense that any useful HTTP/1.1 conformantapplication should be able to use h11.It's pure Python, and has no dependencies outside of the standardlibrary.It has a test suite with 100.0% coverage for both statements andbranches.Currently it supports Python 3 (testing on 3.7-3.10) and PyPy 3.The last Python 2-compatible version was h11 0.11.x.(Originally it had a Cython wrapper for `http-parser&lt;https://github.com/nodejs/http-parser&gt;`_ and a beautiful nested statemachine implemented with ``yield from`` to postprocess the output. ButI had to take these out -- the new *parser* needs fewer lines-of-codethan the old *parser wrapper*, is written in pure Python, uses noexotic language syntax, and has more features. It's sad, really; thatold state machine was really slick. I just need a few sentences hereto mourn that.)I don't know how fast it is. I haven't benchmarked or profiled it yet,so it's probably got a few pointless hot spots, and I've been tryingto err on the side of simplicity and robustness instead ofmicro-optimization. But at the architectural level I tried hard toavoid fundamentally bad decisions, e.g., I believe that all theparsing algorithms remain linear-time even in the face of pathologicalinput like slowloris, and there are no byte-by-byte loops. (I alsobelieve that it maintains bounded memory usage in the face ofarbitrary/pathological input.)The whole library is ~800 lines-of-code. You can read and understandthe whole thing in less than an hour. Most of the energy invested inthis so far has been spent on trying to keep things simple byminimizing special-cases and ad hoc state manipulation; even though itis now quite small and simple, I'm still annoyed that I haven'tfigured out how to make it even smaller and simpler. (Unfortunately,HTTP does not lend itself to simplicity.)The API is ~feature complete and I don't expect the general outlinesto change much, but you can't judge an API's ergonomics until youactually document and use it, so I'd expect some changes in thedetails.*How do I try it?*.. code-block:: sh  $ pip install h11  $ git clone git@github.com:python-hyper/h11  $ cd h11/examples  $ python basic-client.pyand go from there.*License?*MIT*Code of conduct?*Contributors are requested to follow our `code of conduct&lt;https://github.com/python-hyper/h11/blob/master/CODE_OF_CONDUCT.md&gt;`_ inall project spaces.</longdescription>
</pkgmetadata>