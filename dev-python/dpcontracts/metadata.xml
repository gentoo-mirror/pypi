<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Introduction============This module provides a collection of decorators that makes it easy towrite software using contracts.Contracts are a debugging and verification tool.  They are declarativestatements about what states a program must be in to be considered&quot;correct&quot; at runtime.  They are similar to assertions, and are verifiedautomatically at various well-defined points in the program.  Contracts canbe specified on functions and on classes.Contracts serve as a form of documentation and a way of formallyspecifying program behavior.  Good practice often includes writing all ofthe contracts first, with these contract specifying the exact expectedstate before and after each function or method call and the things thatshould always be true for a given class of object.Contracts consist of two parts: a description and a condition.  Thedescription is simply a human-readable string that describes what thecontract is testing, while the condition is a single function that teststhat condition.  The condition is executed automatically and passed certainarguments (which vary depending on the type of contract), and must returna boolean value: True if the condition has been met, and False otherwise.Legacy Python Support=====================This module supports versions of Python &gt;= 3.5; that is, versions withsupport for &quot;async def&quot; functions.  There is a branch of this module thatis kept compatible to the greatest possible degree for versions of Pythonearlier than 3.5 (including Python 2.7).The Python 2 and &lt;= 3.5 branch is available athttps://github.com/deadpixi/contracts/tree/python2This legacy-compatible version is also distributed on PyPI along the 0.5.xbranch; this branch will kept compatible with newer versions to the greatestextent possible.That branch is a drop-in replacement for this module and includes allfunctionality except support for &quot;async def&quot; functions.Preconditions and Postconditions================================Contracts on functions consist of preconditions and postconditions.A precondition is declared using the `requires` decorator, and describeswhat must be true upon entrance to the function. The condition functionis passed an arguments object, which as as its attributes the argumentsto the decorated function:    &gt;&gt;&gt; @require(&quot;`i` must be an integer&quot;, lambda args: isinstance(args.i, int))    ... @require(&quot;`j` must be an integer&quot;, lambda args: isinstance(args.j, int))    ... def add2(i, j):    ...   return i + jNote that an arbitrary number of preconditions can be stacked on top ofeach other.These decorators have declared that the types of both arguments must beintegers.  Calling the `add2` function with the correct types of argumentsworks:    &gt;&gt;&gt; add2(1, 2)    3But calling with incorrect argument types (violating the contract) failswith a PreconditionError (a subtype of AssertionError):    &gt;&gt;&gt; add2(&quot;foo&quot;, 2)    Traceback (most recent call last):    PreconditionError: `i` must be an integerFunctions can also have postconditions, specified using the `ensure`decorator.  Postconditions describe what must be true after the functionhas successfully returned.  Like the `require` decorator, the `ensure`decorator is passed an argument object.  It is also passed an additionalargument, which is the result of the function invocation.  For example:    &gt;&gt;&gt; @require(&quot;`i` must be a positive integer&quot;,    ...          lambda args: isinstance(args.i, int) and args.i &gt; 0)    ... @require(&quot;`j` must be a positive integer&quot;,    ...          lambda args: isinstance(args.j, int) and args.j &gt; 0)    ... @ensure(&quot;the result must be greater than either `i` or `j`&quot;,    ...         lambda args, result: result &gt; args.i and result &gt; args.j)    ... def add2(i, j):    ...     if i == 7:    ...        i = -7 # intentionally broken for purposes of example    ...     return i + jWe can now call the function and ensure that everything is working correctly:    &gt;&gt;&gt; add2(1, 3)    4Except that the function is broken in unexpected ways:    &gt;&gt;&gt; add2(7, 4)    Traceback (most recent call last):    PostconditionError: the result must be greater than either `i` or `j`The function specifying the condition doesn't have to be a lambda; it can beany function, and pre- and postconditions don't have to actually referencethe arguments or results of the function at all.  They can simply checkthe function's environments and effects:    &gt;&gt;&gt; names = set()    &gt;&gt;&gt; def exists_in_database(x):    ...   return x in names    &gt;&gt;&gt; @require(&quot;`name` must be a string&quot;, lambda args: isinstance(args.name, str))    ... @require(&quot;`name` must not already be in the database&quot;,    ...          lambda args: not exists_in_database(args.name.strip()))    ... @ensure(&quot;the normalized version of the name must be added to the database&quot;,    ...         lambda args, result: exists_in_database(args.name.strip()))    ... def add_to_database(name):    ...     if name not in names and name != &quot;Rob&quot;: # intentionally broken    ...         names.add(name.strip())    &gt;&gt;&gt; add_to_database(&quot;James&quot;)    &gt;&gt;&gt; add_to_database(&quot;Marvin&quot;)    &gt;&gt;&gt; add_to_database(&quot;Marvin&quot;)    Traceback (most recent call last):    PreconditionError: `name` must not already be in the database    &gt;&gt;&gt; add_to_database(&quot;Rob&quot;)    Traceback (most recent call last):    PostconditionError: the normalized version of the name must be added to the databaseAll of the various calling conventions of Python are supported:    &gt;&gt;&gt; @require(&quot;`a` is an integer&quot;, lambda args: isinstance(args.a, int))    ... @require(&quot;`b` is a string&quot;, lambda args: isinstance(args.b, str))    ... @require(&quot;every member of `c` should be a boolean&quot;,    ...          lambda args: all(isinstance(x, bool) for x in args.c))    ... def func(a, b=&quot;Foo&quot;, *c):    ...     pass    &gt;&gt;&gt; func(1, &quot;foo&quot;, True, True, False)    &gt;&gt;&gt; func(b=&quot;Foo&quot;, a=7)    &gt;&gt;&gt; args = {&quot;a&quot;: 8, &quot;b&quot;: &quot;foo&quot;}    &gt;&gt;&gt; func(**args)    &gt;&gt;&gt; args = (1, &quot;foo&quot;, True, True, False)    &gt;&gt;&gt; func(*args)    &gt;&gt;&gt; args = {&quot;a&quot;: 9}    &gt;&gt;&gt; func(**args)    &gt;&gt;&gt; func(10)A common contract is to validate the types of arguments. To that end,there is an additional decorator, `types`, that can be usedto validate arguments' types:    &gt;&gt;&gt; class ExampleClass:    ...     pass    &gt;&gt;&gt; @types(a=int, b=str, c=(type(None), ExampleClass)) # or types.NoneType, if you prefer    ... @require(&quot;a must be nonzero&quot;, lambda args: args.a != 0)    ... def func(a, b, c=38):    ...     return &quot; &quot;.join(str(x) for x in [a, b])    &gt;&gt;&gt; func(1, &quot;foo&quot;, ExampleClass())    '1 foo'    &gt;&gt;&gt; func(1.0, &quot;foo&quot;, ExampleClass) # invalid type for `a`    Traceback (most recent call last):    PreconditionError: the types of arguments must be valid    &gt;&gt;&gt; func(1, &quot;foo&quot;) # invalid type (the default) for `c`    Traceback (most recent call last):    PreconditionError: the types of arguments must be validContracts on Classes====================The `require` and `ensure` decorators can be used on class methods too,not just bare functions:    &gt;&gt;&gt; class Foo:    ...     @require(&quot;`name` should be nonempty&quot;, lambda args: len(args.name) &gt; 0)    ...     def __init__(self, name):    ...         self.name = name    &gt;&gt;&gt; foo = Foo()    Traceback (most recent call last):    TypeError: __init__ missing required positional argument: 'name'    &gt;&gt;&gt; foo = Foo(&quot;&quot;)    Traceback (most recent call last):    PreconditionError: `name` should be nonemptyClasses may also have an additional sort of contract specified over them:the invariant.  An invariant, created using the `invariant` decorator,specifies a condition that must always be true for instances of that class.In this case, &quot;always&quot; means &quot;before invocation of any method and afterits return&quot; -- methods are allowed to violate invariants so long as theyare restored prior to return.Invariant contracts are passed a single variable, a reference to theinstance of the class. For example:    &gt;&gt;&gt; @invariant(&quot;inner list can never be empty&quot;, lambda self: len(self.lst) &gt; 0)    ... @invariant(&quot;inner list must consist only of integers&quot;,    ...            lambda self: all(isinstance(x, int) for x in self.lst))    ... class NonemptyList:    ...     @require(&quot;initial list must be a list&quot;, lambda args: isinstance(args.initial, list))    ...     @require(&quot;initial list cannot be empty&quot;, lambda args: len(args.initial) &gt; 0)    ...     @ensure(&quot;the list instance variable is equal to the given argument&quot;,    ...             lambda args, result: args.self.lst == args.initial)    ...     @ensure(&quot;the list instance variable is not an alias to the given argument&quot;,    ...             lambda args, result: args.self.lst is not args.initial)    ...     def __init__(self, initial):    ...         self.lst = initial[:]    ...    ...     def get(self, i):    ...         return self.lst[i]    ...    ...     def pop(self):    ...         self.lst.pop()    ...    ...     def as_string(self):    ...         # Build up a string representation using the `get` method,    ...         # to illustrate methods calling methods with invariants.    ...         return &quot;,&quot;.join(str(self.get(i)) for i in range(0, len(self.lst)))    &gt;&gt;&gt; nl = NonemptyList([1,2,3])    &gt;&gt;&gt; nl.pop()    &gt;&gt;&gt; nl.pop()    &gt;&gt;&gt; nl.pop()    Traceback (most recent call last):    PostconditionError: inner list can never be empty    &gt;&gt;&gt; nl = NonemptyList([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])    Traceback (most recent call last):    PostconditionError: inner list must consist only of integersViolations of invariants are ignored in the following situations:    - before calls to __init__ and __new__ (since the object is still      being initialized)    - before and after calls to any method whose name begins with &quot;__&quot;,      except for methods implementing arithmetic and comparison operations      and container type emulation (because such methods are private and      expected to manipulate the object's inner state, plus things get hairy      with certain applications of `__getattr(ibute)?__`)    - before and after calls to methods added from outside the initial      class definition (because invariants are processed only at class      definition time)    - before and after calls to classmethods, since they apply to the class      as a whole and not any particular instanceFor example:    &gt;&gt;&gt; @invariant(&quot;`always` should be True&quot;, lambda self: self.always)    ... class Foo:    ...     always = True    ...    ...     def get_always(self):    ...         return self.always    ...    ...     @classmethod    ...     def break_everything(cls):    ...         cls.always = False    &gt;&gt;&gt; x = Foo()    &gt;&gt;&gt; x.get_always()    True    &gt;&gt;&gt; x.break_everything()    &gt;&gt;&gt; x.get_always()    Traceback (most recent call last):    PreconditionError: `always` should be TrueAlso note that if a method invokes another method on the same object,all of the invariants will be tested again:    &gt;&gt;&gt; nl = NonemptyList([1,2,3])    &gt;&gt;&gt; nl.as_string() == '1,2,3'    TrueTransforming Data in Contracts==============================In general, you should avoid transforming data inside a contract; contractsthemselves are supposed to be side-effect-free.However, this is not always possible in Python.Take, for example, iterables passed as arguments. We might want to verifythat a given set of properties hold for every item in the iterable. Theobvious solution would be to do something like this:    &gt;&gt;&gt; @require(&quot;every item in `l` must be &gt; 0&quot;, lambda args: all(x &gt; 0 for x in args.l))    ... def my_func(l):    ...     return sum(l)This works well in most situations:    &gt;&gt;&gt; my_func([1, 2, 3])    6    &gt;&gt;&gt; my_func([0, -1, 2])    Traceback (most recent call last):    PreconditionError: every item in `l` must be &gt; 0But it fails in the case of a generator:    &gt;&gt;&gt; def iota(n):    ...     for i in range(1, n):    ...         yield i    &gt;&gt;&gt; sum(iota(5))    10    &gt;&gt;&gt; my_func(iota(5))    0The call to `my_func` has a result of 0 because the generator was consumedinside the `all` call inside the contract. Obviously, this is problematic.Sadly, there is no generic solution to this problem. In a statically-typedlanguage, the compiler can verify that some properties of infinite lists(though not all of them, and what exactly depends on the type system).We get around that limitation here using an additional decorator, called`transform` that transforms the arguments to a function, and a functioncalled `rewrite` that rewrites argument tuples.For example:    &gt;&gt;&gt; @transform(lambda args: rewrite(args, l=list(args.l)))    ... @require(&quot;every item in `l` must be &gt; 0&quot;, lambda args: all(x &gt; 0 for x in args.l))    ... def my_func(l):    ...     return sum(l)    &gt;&gt;&gt; my_func(iota(5))    10Note that this does not completely solve the problem of infinite sequences,but it does allow for verification of any desired prefix of such a sequence.This works for class methods too, of course:    &gt;&gt;&gt; class TestClass:    ...     @transform(lambda args: rewrite(args, l=list(args.l)))    ...     @require(&quot;every item in `l` must be &gt; 0&quot;, lambda args: all(x &gt; 0 for x in args.l))    ...     def my_func(self, l):    ...         return sum(l)    &gt;&gt;&gt; TestClass().my_func(iota(5))    10Contracts on Asynchronous Functions (aka coroutine functions)=============================================================Contracts can be placed on coroutines (that is, async functions):    &gt;&gt;&gt; import asyncio    &gt;&gt;&gt; @require(&quot;`a` is an integer&quot;, lambda args: isinstance(args.a, int))    ... @require(&quot;`b` is a string&quot;, lambda args: isinstance(args.b, str))    ... @require(&quot;every member of `c` should be a boolean&quot;,    ...          lambda args: all(isinstance(x, bool) for x in args.c))    ... async def func(a, b=&quot;Foo&quot;, *c):    ...     await asyncio.sleep(1)    &gt;&gt;&gt; asyncio.get_event_loop().run_until_complete(    ...     func( 1, &quot;foo&quot;, True, True, False))Predicates functions themselves cannot be coroutines, as this couldinfluence the run loop:    &gt;&gt;&gt; async def coropred_aisint(e):    ...     await asyncio.sleep(1)    ...     return isinstance(getattr(e, 'a'), int)    &gt;&gt;&gt; @require(&quot;`a` is an integer&quot;, coropred_aisint)    ... @require(&quot;`b` is a string&quot;, lambda args: isinstance(args.b, str))    ... @require(&quot;every member of `c` should be a boolean&quot;,    ...          lambda args: all(isinstance(x, bool) for x in args.c))    ... async def func(a, b=&quot;Foo&quot;, *c):    ...     await asyncio.sleep(1)    Traceback (most recent call last):    AssertionError: contract predicates cannot be coroutinesContracts and Debugging=======================Contracts are a documentation and testing tool; they are not intendedto be used to validate user input or implement program logic.  Indeed,running Python with `__debug__` set to False (e.g. by calling the Pythonintrepreter with the &quot;-O&quot; option) disables contracts.Testing This Module===================This module has embedded doctests that are run with the module is invokedfrom the command line.  Simply run the module directly to run the tests.Contact Information and Licensing=================================This module has a home page at `GitHub &lt;https://github.com/deadpixi/contracts&gt;`_.This module was written by Rob King (jking@deadpixi.com).This program is free software: you can redistribute it and/or modifyit under the terms of the GNU Lesser General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public Licensealong with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</longdescription>
</pkgmetadata>