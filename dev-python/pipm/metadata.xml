<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pipm[![Build Status](https://travis-ci.com/jnoortheen/pipm.svg?branch=master)](https://travis-ci.com/jnoortheen/pipm)Python package management using pip, requirements file &amp; [setup.cfg](https://setuptools.pypa.io/en/latest/userguide/declarative_config.html).# Installation- Adviced to install only inside virtualenvInstall from PyPI```pip install pipm```**Note:**- This tool manipulates all your requirements file. So be sure to use version control software or take backup of your files to keep track of changes.# Quickstart- Both `pip` and `pipm` command will work as the same.- Create a virtualenv for the project and install pipm with ```shpip install pipm``` - Create an alias as `alias pip=pipm` or use as it is - `pipm`## I. Install- install all your dependencies from the base requirements file (`requirements.txt`)```shpipm installpipm install --all  # *requirements*.txt - all environment -&gt; test/prod/dev```## 2. Add new packages to project```shpipm install pkg-namepipm install pkg-name --dev # as development dependencypipm install pkg-name --test # as testing dependency```## 3. Removal of packages- Remove one or more packages. Their dependencies will also get uninstalled. No orphaned packages. ```shpipm uninstall pkg-name```## 4. update all your dependencies in requirements.txt```shpipm updatepipm update --dev```# Features1. No new set of files. `*-requirements.txt` works like the lockfile with pinned versions 2. Just a wrapper around the standard pip's `install/uninstall` command. So all the cli options will work3. Handles multiple `requirements` files  and [setup.cfg](https://setuptools.pypa.io/en/latest/userguide/declarative_config.html) stores abstract dependencies.# Commands## 1. install - a wrapper around standard `pip install` command and accepts all the standard options Below are the things that `pipm` brings to the table1. Extra functionality    - when package names are given it will be saved to the requirements.txt file in the current directory.    If you have `requirements` directory structure with `base.txt` inside then that file will be used. Otherwise it    will create one in the current directory.    - when no package name is given then it is equivalent to `-r requirements.txt` and it will install all requirements    from the current directory2. Additional options:    It will search for the matching one in the following pattern `&lt;name&gt;-requirements.txt` or    `requirements/&lt;name&gt;.txt` or `requirements-&lt;name&gt;.txt`    the below saves to file when package name given otherwise equivalent to passing requirements file name.   1. `--dev` - saves to development requirements   2. `--prod` - saves to production requirements   3. `--test` - saves to  testing requirements   4. `--doc` - saves to  documentation requirements   5. `--env &lt;name&gt;` - if you have any special set of requirements that belong to a separate file you could pass the name here.## 2. uninstall  - a wrapper around standard `pip uninstall` command - alias `rm` is available - when uninstalling a package, this command also checks packages that are no longer required by any of user installed packages and removes them - ofcourse it removes the packages from `requirements` files## 3. update - new command - equivalent to calling `pip install` with `--upgrade` flag - update a single package or the whole environment when no argument given. - by default the packages are updated interactively     - set `--auto-update` to disable this## 4. save/freeze - extends the standard freeze command to save the currently installed packages# Development- clone the repository and create new virtualenv```git clone git@github.com:jnoortheen/pipm.gitcd pipmpew new pipm -a .pip install -r dev-requirements.txt```-  to test from local sources```pip install -e .```- Commit message should follow [this](https://udacity.github.io/git-styleguide/) style-guide.## Testing- run `invoke test` from the root directory.# Alternatives and their problems (IMHO)1. [pipenv](https://docs.pipenv.org/)    - good for local development with only one virtual environment per project    - Not good when we need to deploy over production server or keep multiple virtuals-envs    - it is better to use `pew` alone instead of the shell command that comes with this2. [pip-tools](https://github.com/jazzband/pip-tools)    - another set of files to keep track of, additional commands to remember3. [poetry](https://github.com/sdispater/poetry)     - more robust than `pipenv`    - ~~the problems I faced are related to installing dependencies in remote servers/docker environments. ~~    - ~~longer install/update times~~    ~~As the project matures this problem might get resolved. ~~    - since version 1.1 these are solved.     - new projects are to advised to use poetry when possible.4. [dephell](https://github.com/dephell/dephell)    - haven't used it. But seems to handle requirements files as well as other formats.# TODOs: - rm will check whether a package is present in setup.cfg</longdescription>
</pkgmetadata>