<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Django Async DownloadsAsynchronous downloads scaffolding for Django projects.- TODO: describe cache mechanism- TODO: how to customise the front end## Installation```# Without websocket supportpip install django-async-downloads# With Websocket supportpip install django-async-downloads[ws]```Note at the present time on Windows, if you require websocket support,you will need &quot;Microsoft Visual C++ 14.0&quot; installed (https://visualstudio.microsoft.com/visual-cpp-build-tools/) due to `hiredis` from the dependency chain (`channels_redis` -&gt; `aioredis-py` -&gt; `hiredis`).Add to your `INSTALLED_APPS`:```INSTALLED_APPS = [    ...    &quot;async_downloads&quot;,]```Add to your project's `url_patterns`:```path(&quot;async_downloads/&quot;, include(&quot;async_downloads.urls&quot;))```Add the CSS:```&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{% static 'css/async_downloads.css' %}&quot; /&gt;```Add the JS:```&lt;script src=&quot;{% static &quot;js/async_downloads.js&quot; %}&quot; id=&quot;async-downloads-script&quot;    data-url=&quot;{% url 'async_downloads:ajax_update' %}&quot;    data-clear-url=&quot;{% url 'async_downloads:ajax_clear_download' %}&quot;&gt;&lt;/script&gt;```Include the download centre nav-menu:```&lt;ul class=&quot;navbar-nav&quot;&gt;    ...    {% include 'async_downloads/download_centre.html' %}    ...```## WS modePackage can be used with websockets to provide asynchronous communicationbetween frontend and backend.If package will be used in websockets mode additional settings must be applied.* Inside common settings `WS_MODE` must be toggled on.    ```    ASYNC_DOWNLOADS_WS_MODE = True    ```* Application needs to be configured as a `ASGI` and proper WS urls need to be configured:    ```    # ws/urls.py    from async_downloads.ws_consumers import DownloadsConsumer          urlpatterns += [        re_path(r&quot;ws/downloads/(?P&lt;username&gt;[\w.]+)/$&quot;, DownloadsConsumer.as_asgi()),     ]    ```    ```    # example asgi.py    from django.core.asgi import get_asgi_application    from channels.auth import AuthMiddlewareStack    from channels.routing import ProtocolTypeRouter, URLRouter    import ws.urls    application = ProtocolTypeRouter(        {            &quot;http&quot;: get_asgi_application(),            &quot;websocket&quot;: AuthMiddlewareStack(URLRouter(ws.urls.urlpatterns)),        }    )    ```* Change in application template async-downloads section to use WS js version.    ```    # example: FULL_WS_URL = &quot;http://app.com/ws/downloads/&quot;    &lt;script src=&quot;{% static &quot;js/ws_async_downloads.js&quot; %}&quot; id=&quot;async-downloads-script&quot;        data-url=&quot;{{ FULL_WS_URL }}&quot;    &lt;/script&gt;    ```    - `data-url` must be an absolute URL because this is required for a WebSocket connection,        and it must include the protocol because the `ws_async_downloads.js` script will         inspect it to determine which WebSockets protocol to use - `ws` if `http` or `wss`         if `https`.* Configure `CHANNEL_LAYERS` inside common settings. Example config:    ```    CHANNEL_LAYERS = {        &quot;default&quot;: {            &quot;BACKEND&quot;: &quot;channels_redis.core.RedisChannelLayer&quot;,            &quot;CONFIG&quot;: {                &quot;hosts&quot;: [(&quot;127.0.0.1&quot;, 6379)],            },        },    }    ```## UsageTODO: using the JS### Cache Functions#### `cache.init_download`Initialise a download by preparing the cache entries. Returns a tuple of keys, the collection keyand specific download key. You would typically want to call this within the web process, and passthe download key (and possibly the collection key) into the asynchronous function call so that thestatus can be updated.Arguments:- `user`: the unique identifier for a collection of downloads - this will typically be a user         object but can be user PK or username.- `filename`: the name of the file being downloaded (does not need to be unique)- `name`: (optional) the name to associate with this download - defaults to `filename`#### `cache.save_download`The asynchronous process should call this function when the iterable or file is prepared in order to savethe output.Arguments:- `download_key`: the cache key of this particular download- `iterable`: (optional) an iterable of data rows to be written- `file`: (optional) a BytesIO object#### `cache.update_percentage`The asynchronous process can call this function to calculate and update the completion percentage.(download_key, total, cur, resolution=10):Arguments:- `download_key`: the cache key of this particular download- `total`: total to compare current progress against- `cur`: current progress index- `resolution`: resolution of the percentage calculation (make smaller for fewer updates, larger formore precision); default is `10`, meaning it will increase in steps of 10%. The value is capped between`1` and `100`.#### `cache.set_percentage`The asynchronous process can call this function to directly set the completion percentage.Arguments:- `download_key`: the cache key of this particular download- `percentage`: an number between 0 and 100 (inclusive)#### `cache.cleanup_collection`There can be a build up of expired download keys in a collection so it can be worth periodicallyremoving them using this function. (Note that the collection cache itself will expire if not touchedfor `ASYNC_DOWNLOADS_TIMEOUT` seconds, so it may not be critical to use this.)Arguments:- `collection_key`: the cache key of a collection of downloads### `cache.set_error`The asynchronous process can call this function to set an error message on the download.Arguments:- `download_key`: the cache key of this particular download- `error`: the error message to set#### `tasks.cleanup_expired_downloads`Delete expired downloads (where the download no longer exists in the cache).This is a clean up operation to prevent downloads that weren't manually deleted from building up,and should be run periodically to avoid bloating the server with files.This is best setup as a periodic task in your project, which can be done by adding the followingto your project's `celery.py`:```app.conf.beat_schedule = {    &quot;async_downloads_cleanup&quot;: {        &quot;task&quot;: &quot;async_downloads.tasks.cleanup_expired_downloads&quot;,        &quot;schedule&quot;: crontab(hour=0, minute=0, day_of_week=1)    }}```## Configurable Settings### `ASYNC_DOWNLOADS_TIMEOUT`Default: `60 * 60 * 24` (1 day)This is the cache timeout used for cache operations. ### `ASYNC_DOWNLOADS_DOWNLOAD_TEMPLATE`Default: `&quot;async_downloads/downloads.html&quot;`This is the template that will be used by the `ajax_update` view. You can override it by creatinga template in `&lt;project&gt;/templates/async_downloads/downloads.html`, or else putting the templatewherever you choose and changing this setting.### `ASYNC_DOWNLOADS_PATH_PREFIX`Default: `&quot;downloads&quot;`The parent directory for all downloads in the `MEDIA_ROOT` directory.### `ASYNC_DOWNLOADS_COLLECTION_KEY_FORMAT`Default: `&quot;async_downloads/{}&quot;`The collection key keeps track of the cache keys of a grouped collection of downloads. In theunlikely event that this key format clashes with something in your project, you can change it.The expectation is for the string to have a user primary key inserted with `str.format`, so `{}`is required to be present.### `ASYNC_DOWNLOADS_WS_CHANNEL_NAME`Default: `&quot;downloads&quot;`The channel name for all shared information about download in channels cache layer.### `ASYNC_DOWNLOADS_CACHE_NAME`If this settings will be added default cache will be changed into new with provided name.### `ASYNC_DOWNLOADS_WS_MODE`Default: `False`If this flag will be set to `True` package will be set to work with WebSockets in [WS_MODE](#ws-mode).### `ASYNC_DOWNLOADS_CSS_CLASS`Default: `None`Additional CSS class can be added to `download-content` div.</longdescription>
</pkgmetadata>