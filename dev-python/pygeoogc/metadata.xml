<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://raw.githubusercontent.com/hyriver/HyRiver-examples/main/notebooks/_static/pygeoogc_logo.png    :target: https://github.com/hyriver/HyRiver|.. image:: https://joss.theoj.org/papers/b0df2f6192f0a18b9e622a3edff52e77/status.svg    :target: https://joss.theoj.org/papers/b0df2f6192f0a18b9e622a3edff52e77    :alt: JOSS|.. |pygeohydro| image:: https://github.com/hyriver/pygeohydro/actions/workflows/test.yml/badge.svg    :target: https://github.com/hyriver/pygeohydro/actions/workflows/test.yml    :alt: Github Actions.. |pygeoogc| image:: https://github.com/hyriver/pygeoogc/actions/workflows/test.yml/badge.svg    :target: https://github.com/hyriver/pygeoogc/actions/workflows/test.yml    :alt: Github Actions.. |pygeoutils| image:: https://github.com/hyriver/pygeoutils/actions/workflows/test.yml/badge.svg    :target: https://github.com/hyriver/pygeoutils/actions/workflows/test.yml    :alt: Github Actions.. |pynhd| image:: https://github.com/hyriver/pynhd/actions/workflows/test.yml/badge.svg    :target: https://github.com/hyriver/pynhd/actions/workflows/test.yml    :alt: Github Actions.. |py3dep| image:: https://github.com/hyriver/py3dep/actions/workflows/test.yml/badge.svg    :target: https://github.com/hyriver/py3dep/actions/workflows/test.yml    :alt: Github Actions.. |pydaymet| image:: https://github.com/hyriver/pydaymet/actions/workflows/test.yml/badge.svg    :target: https://github.com/hyriver/pydaymet/actions/workflows/test.yml    :alt: Github Actions.. |pynldas2| image:: https://github.com/hyriver/pynldas2/actions/workflows/test.yml/badge.svg    :target: https://github.com/hyriver/pynldas2/actions/workflows/test.yml    :alt: Github Actions.. |async| image:: https://github.com/hyriver/async-retriever/actions/workflows/test.yml/badge.svg    :target: https://github.com/hyriver/async-retriever/actions/workflows/test.yml    :alt: Github Actions.. |signatures| image:: https://github.com/hyriver/hydrosignatures/actions/workflows/test.yml/badge.svg    :target: https://github.com/hyriver/hydrosignatures/actions/workflows/test.yml    :alt: Github Actions================ ==================================================================== ============Package          Description                                                          Status================ ==================================================================== ============PyNHD_           Navigate and subset NHDPlus (MR and HR) using web services           |pynhd|Py3DEP_          Access topographic data through National Map's 3DEP web service      |py3dep|PyGeoHydro_      Access NWIS, NID, WQP, eHydro, NLCD, CAMELS, and SSEBop databases    |pygeohydro|PyDaymet_        Access daily, monthly, and annual climate data via Daymet            |pydaymet|PyNLDAS2_        Access hourly NLDAS-2 data via web services                          |pynldas2|HydroSignatures_ A collection of tools for computing hydrological signatures          |signatures|AsyncRetriever_  High-level API for asynchronous requests with persistent caching     |async|PyGeoOGC_        Send queries to any ArcGIS RESTful-, WMS-, and WFS-based services    |pygeoogc|PyGeoUtils_      Utilities for manipulating geospatial, (Geo)JSON, and (Geo)TIFF data |pygeoutils|================ ==================================================================== ============.. _PyGeoHydro: https://github.com/hyriver/pygeohydro.. _AsyncRetriever: https://github.com/hyriver/async-retriever.. _PyGeoOGC: https://github.com/hyriver/pygeoogc.. _PyGeoUtils: https://github.com/hyriver/pygeoutils.. _PyNHD: https://github.com/hyriver/pynhd.. _Py3DEP: https://github.com/hyriver/py3dep.. _PyDaymet: https://github.com/hyriver/pydaymet.. _PyNLDAS2: https://github.com/hyriver/pynldas2.. _HydroSignatures: https://github.com/hyriver/hydrosignaturesPyGeoOGC: Retrieve Data from RESTful, WMS, and WFS Services-----------------------------------------------------------.. image:: https://img.shields.io/pypi/v/pygeoogc.svg    :target: https://pypi.python.org/pypi/pygeoogc    :alt: PyPi.. image:: https://img.shields.io/conda/vn/conda-forge/pygeoogc.svg    :target: https://anaconda.org/conda-forge/pygeoogc    :alt: Conda Version.. image:: https://codecov.io/gh/hyriver/pygeoogc/branch/main/graph/badge.svg    :target: https://codecov.io/gh/hyriver/pygeoogc    :alt: CodeCov.. image:: https://img.shields.io/pypi/pyversions/pygeoogc.svg    :target: https://pypi.python.org/pypi/pygeoogc    :alt: Python Versions.. image:: https://pepy.tech/badge/pygeoogc    :target: https://pepy.tech/project/pygeoogc    :alt: Downloads|.. image:: https://img.shields.io/badge/security-bandit-green.svg    :target: https://github.com/PyCQA/bandit    :alt: Security Status.. image:: https://www.codefactor.io/repository/github/hyriver/pygeoogc/badge   :target: https://www.codefactor.io/repository/github/hyriver/pygeoogc   :alt: CodeFactor.. image:: https://img.shields.io/badge/code%20style-black-000000.svg    :target: https://github.com/psf/black    :alt: black.. image:: https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&amp;logoColor=white    :target: https://github.com/pre-commit/pre-commit    :alt: pre-commit.. image:: https://mybinder.org/badge_logo.svg    :target: https://mybinder.org/v2/gh/hyriver/HyRiver-examples/main?urlpath=lab/tree/notebooks    :alt: Binder|Features--------PyGeoOGC is a part of `HyRiver &lt;https://github.com/hyriver/HyRiver&gt;`__ software stack thatis designed to aid in hydroclimate analysis through web services. This package providesgeneral interfaces to web services that are based on`ArcGIS RESTful &lt;https://en.wikipedia.org/wiki/Representational_state_transfer&gt;`__,`WMS &lt;https://en.wikipedia.org/wiki/Web_Map_Service&gt;`__, and`WFS &lt;https://en.wikipedia.org/wiki/Web_Feature_Service&gt;`__. Althoughall these web services have limits on the number of features per request (e.g., 1000object IDs for a RESTful request or 8 million pixels for a WMS request), PyGeoOGC, first, dividesthe large requests into smaller chunks, and then returns the merged results.Moreover, under the hood, PyGeoOGC uses`AsyncRetriever &lt;https://github.com/hyriver/async-retriever&gt;`__for making requests asynchronously with persistent caching. This improves thereliability and speed of data retrieval significantly. AsyncRetriever caches all request/responsepairs and upon making an already cached request, it will retrieve the responses from the cacheif the server's response is unchanged.You can control the request/response caching behavior and verbosity of the packageby setting the following environment variables:* ``HYRIVER_CACHE_NAME``: Path to the caching SQLite database. It defaults to  ``./cache/aiohttp_cache.sqlite``* ``HYRIVER_CACHE_EXPIRE``: Expiration time for cached requests in seconds. It defaults to  -1 (never expire).* ``HYRIVER_CACHE_DISABLE``: Disable reading/writing from/to the cache. The default is false.For example, in your code before making any requests you can do:.. code-block:: python    import os    os.environ[&quot;HYRIVER_CACHE_NAME&quot;] = &quot;path/to/aiohttp_cache.sqlite&quot;    os.environ[&quot;HYRIVER_CACHE_NAME_HTTP&quot;] = &quot;path/to/http_cache.sqlite&quot;    os.environ[&quot;HYRIVER_CACHE_EXPIRE&quot;] = &quot;3600&quot;    os.environ[&quot;HYRIVER_CACHE_DISABLE&quot;] = &quot;true&quot;There is also an inventory of URLs for some of these web services in form of a class called``ServiceURL``. These URLs are in four categories: ``ServiceURL().restful``,``ServiceURL().wms``, ``ServiceURL().wfs``, and ``ServiceURL().http``. These URLs provide youwith some examples of the services that PyGeoOGC supports. If you have success using PyGeoOGC with a webservice please consider submitting a request to be added to this URL inventory. You can get allthe URLs in the ``ServiceURL`` class by just printing it ``print(ServiceURL())``.PyGeoOGC has three main classes:* ``ArcGISRESTful``: This class can be instantiated by providing the target layer URL.  For example, for getting Watershed Boundary Data we can use ``ServiceURL().restful.wbd``.  By looking at the web service's  `website &lt;https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer&gt;`_  we see that there are nine layers. For example, 1 for 2-digit HU (Region), 6 for 12-digit HU  (Subregion), and so on. We can pass the URL to the target layer directly, like this  ``f&quot;{ServiceURL().restful.wbd}/6&quot;`` or as a separate argument via ``layer``.  Afterward, we request for the data in two steps. First, we need to get  the target object IDs using ``oids_bygeom`` (within a geometry), ``oids_byfield`` (specific  field IDs), or ``oids_bysql`` (any valid SQL 92 WHERE clause) class methods. Then, we can get  the target features using ``get_features`` class method. The returned response can be converted  into a ``geopandas.GeoDataFrame`` using ``json2geodf`` function from  `PyGeoUtils &lt;https://github.com/hyriver/pygeoutils&gt;`__.* ``WMS``: Instantiation of this class requires at least 3 arguments: service URL, layer  name(s), and output format. Additionally, target CRS and the web service version can be provided.  Upon instantiation, we can use ``getmap_bybox`` method class to get the target raster data  within a bounding box. The box can be in any valid CRS and if it is different from the default  CRS, ``EPSG:4326``, it should be passed using ``box_crs`` argument. The service response can be  converted into a ``xarray.Dataset`` using ``gtiff2xarray`` function from PyGeoUtils.* ``WFS``: Instantiation of this class is similar to ``WMS``. The only difference is that  only one layer name can be passed. Upon instantiation there are three ways to get the data:  - ``getfeature_bybox``: Get all the target features within a bounding box in any valid CRS.  - ``getfeature_byid``: Get all the target features based on the IDs. Note that two arguments    should be provided: ``featurename``, and ``featureids``. You can get a list of valid feature    names using ``get_validnames`` class method.  - ``getfeature_byfilter``: Get the data based on any valid    `CQL &lt;https://docs.geoserver.org/latest/en/user/tutorials/cql/cql_tutorial.html&gt;`__ filter.  You can convert the returned response of this function to a ``GeoDataFrame`` using ``json2geodf``  function from PyGeoUtils package.PyGeoOGC also includes several utilities:- ``streaming_download`` for downloading large files in parallel and in chunks, efficiently.- ``traverse_json`` for traversing a nested JSON object.- ``match_crs`` for reprojecting a geometry or bounding box to any valid CRS.You can find some example notebooks `here &lt;https://github.com/hyriver/HyRiver-examples&gt;`__.Furthermore, you can also try using PyGeoOGC without installingit on your system by clicking on the binder badge. A Jupyter Labinstance with the HyRiver stack pre-installed will be launched in your web browser, and youcan start coding!Moreover, requests for additional functionalities can be submitted via`issue tracker &lt;https://github.com/hyriver/pygeoogc/issues&gt;`__.Citation--------If you use any of HyRiver packages in your research, we appreciate citations:.. code-block:: bibtex    @article{Chegini_2021,        author = {Chegini, Taher and Li, Hong-Yi and Leung, L. Ruby},        doi = {10.21105/joss.03175},        journal = {Journal of Open Source Software},        month = {10},        number = {66},        pages = {1--3},        title = {{HyRiver: Hydroclimate Data Retriever}},        volume = {6},        year = {2021}    }Installation------------You can install PyGeoOGC using ``pip``:.. code-block:: console    $ pip install pygeoogcAlternatively, PyGeoOGC can be installed from the ``conda-forge`` repositoryusing `Conda &lt;https://docs.conda.io/en/latest/&gt;`__or `Mamba &lt;https://github.com/conda-forge/miniforge&gt;`__:.. code-block:: console    $ conda install -c conda-forge pygeoogcQuick start-----------We can access`NHDPlus HR &lt;https://edits.nationalmap.gov/arcgis/rest/services/NHDPlus_HR/NHDPlus_HR/MapServer&gt;`__via RESTful service,`National Wetlands Inventory &lt;https://www.fws.gov/wetlands/&gt;`__ from WMS, and`FEMA National Flood Hazard &lt;https://www.fema.gov/national-flood-hazard-layer-nfhl&gt;`__via WFS. The output for these functions are of type ``requests.Response`` thatcan be converted to ``GeoDataFrame`` or ``xarray.Dataset`` using`PyGeoUtils &lt;https://github.com/hyriver/pygeoutils&gt;`__.Let's start the National Map's NHDPlus HR web service. We can query the flowlines that arewithin a geometry as follows:.. code-block:: python    from pygeoogc import ArcGISRESTful, WFS, WMS, ServiceURL    import pygeoutils as geoutils    from pynhd import NLDI    basin_geom = NLDI().get_basins(&quot;01031500&quot;).geometry[0]    hr = ArcGISRESTful(ServiceURL().restful.nhdplushr, 2, outformat=&quot;json&quot;)    resp = hr.get_features(hr.oids_bygeom(basin_geom, &quot;epsg:4326&quot;))    flowlines = geoutils.json2geodf(resp)Note ``oids_bygeom`` has three additional arguments: ``sql_clause``, ``spatial_relation``,and ``distance``. We can use ``sql_clause`` for passing any valid SQL WHERE clauses and``spatial_relation`` for specifying the target predicate such asintersect, contain, cross, etc. The default predicate is intersect(``esriSpatialRelIntersects``). Additionally, we can use ``distance`` for specifying the bufferdistance from the input geometry for getting features.We can also submit a query based on IDs of any valid field in the database. If the measureproperty is desired you can pass ``return_m`` as ``True`` to the ``get_features`` class method:.. code-block:: python    oids = hr.oids_byfield(&quot;PERMANENT_IDENTIFIER&quot;, [&quot;103455178&quot;, &quot;103454362&quot;, &quot;103453218&quot;])    resp = hr.get_features(oids, return_m=True)    flowlines = geoutils.json2geodf(resp)Additionally, any valid SQL 92 WHERE clause can be used. For more details look`here &lt;https://developers.arcgis.com/rest/services-reference/query-feature-service-.htm#ESRI_SECTION2_07DD2C5127674F6A814CE6C07D39AD46&gt;`__.For example, let's limit our first request to only include catchments withareas larger than 0.5 sqkm... code-block:: python    oids = hr.oids_bygeom(basin_geom, geo_crs=&quot;epsg:4326&quot;, sql_clause=&quot;AREASQKM &gt; 0.5&quot;)    resp = hr.get_features(oids)    catchments = geoutils.json2geodf(resp)A WMS-based example is shown below:.. code-block:: python    wms = WMS(        ServiceURL().wms.fws,        layers=&quot;0&quot;,        outformat=&quot;image/tiff&quot;,        crs=&quot;epsg:3857&quot;,    )    r_dict = wms.getmap_bybox(        basin_geom.bounds,        1e3,        box_crs=&quot;epsg:4326&quot;,    )    wetlands = geoutils.gtiff2xarray(r_dict, basin_geom, &quot;epsg:4326&quot;)Query from a WFS-based web service can be done either within a bounding box or usingany valid `CQL filter &lt;https://docs.geoserver.org/stable/en/user/tutorials/cql/cql_tutorial.html&gt;`__... code-block:: python    wfs = WFS(        ServiceURL().wfs.fema,        layer=&quot;public_NFHL:Base_Flood_Elevations&quot;,        outformat=&quot;esrigeojson&quot;,        crs=&quot;epsg:4269&quot;,    )    r = wfs.getfeature_bybox(basin_geom.bounds, box_crs=&quot;epsg:4326&quot;)    flood = geoutils.json2geodf(r.json(), &quot;epsg:4269&quot;, &quot;epsg:4326&quot;)    layer = &quot;wmadata:huc08&quot;    wfs = WFS(        ServiceURL().wfs.waterdata,        layer=layer,        outformat=&quot;application/json&quot;,        version=&quot;2.0.0&quot;,        crs=&quot;epsg:4269&quot;,    )    r = wfs.getfeature_byfilter(f&quot;huc8 LIKE '13030%'&quot;)    huc8 = geoutils.json2geodf(r.json(), &quot;epsg:4269&quot;, &quot;epsg:4326&quot;).. image:: https://raw.githubusercontent.com/hyriver/HyRiver-examples/main/notebooks/_static/sql_clause.png    :target: https://github.com/hyriver/HyRiver-examples/blob/main/notebooks/webservices.ipynbContributing------------Contributions are appreciated and very welcomed. Please read`CONTRIBUTING.rst &lt;https://github.com/hyriver/pygeoogc/blob/main/CONTRIBUTING.rst&gt;`__for instructions.</longdescription>
</pkgmetadata>