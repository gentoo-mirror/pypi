<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># **Neumann** - A Python Library for Applied Mathematics in Physical Sciences[![CircleCI](https://circleci.com/gh/dewloosh/Neumann.svg?style=shield)](https://circleci.com/gh/dewloosh/Neumann)[![Documentation Status](https://readthedocs.org/projects/neumann/badge/?version=latest)](https://neumann.readthedocs.io/en/latest/?badge=latest)[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)[![PyPI](https://badge.fury.io/py/Neumann.svg)](https://pypi.org/project/Neumann)[![codecov](https://codecov.io/gh/dewloosh/Neumann/branch/main/graph/badge.svg?token=TBI6GG4ECG)](https://codecov.io/gh/dewloosh/Neumann)[![Python 3.7-3.10](https://img.shields.io/badge/python-3.7%E2%80%923.10-blue)](https://www.python.org)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)`Neumann` is a Python library that provides tools to formulate and solve problems related to all kinds of scientific disciplines. It is a part of the DewLoosh ecosystem which is designed mainly to solve problems related to computational solid mechanics, but if something is general enough, it ends up here. A good example is the included vector and tensor algebra modules, or the various optimizers, which are applicable in a much broader context than they were originally designed for.The most important features:* Linear Algebra  * A mechanism that guarantees to maintain the property of objectivity of tensorial quantities.  * A `ReferenceFrame` class for all kinds of frames, and dedicated `RectangularFrame` and `CartesianFrame` classes as special cases, all NumPy compliant.  * NumPy compliant classes like `Tensor` and `Vector` to handle various kinds of tensorial quantities efficiently.  * A `JaggedArray` and a Numba-jittable `csr_matrix` to handle sparse data.* Operations Research  * Classes to define and solve linear and nonlinear optimization problems.    * A `LinearProgrammingProblem` class to define and solve any kind of linear optimization problem.    * A `BinaryGeneticAlgorithm` class to tackle more complicated optimization problems.* Graph Theory  * Algorithms to calculate rooted level structures and pseudo peripheral nodes of a `networkx` graph, which are useful if you want to minimize the bandwidth of sparse symmetrix matrices.&gt; **Note**&gt; Be aware, that the library uses JIT-compilation through Numba, and as a result,&gt; first calls to these functions may take longer, but pay off in the long run.## **Documentation**The documentation is hosted on [ReadTheDocs](https://Neumann.readthedocs.io/en/latest/).## **Installation**`Neumann` can be installed (either in a virtual enviroment or globally) from PyPI using `pip` on Python &gt;= 3.7:```console&gt;&gt;&gt; pip install neumann```or chechkout with the following command using GitHub CLI```consolegh repo clone dewloosh/Neumann```and install from source by typing```console&gt;&gt;&gt; python install setup.py```## **Motivating Examples**### Linear AlgebraDefine a reference frame $\mathbf{B}$ relative to the frame $\mathbf{A}$:```python&gt;&gt;&gt; from neumann.linalg import ReferenceFrame, Vector, Tensor&gt;&gt;&gt; A = ReferenceFrame(name='A', axes=np.eye(3))&gt;&gt;&gt; B = A.orient_new('Body', [0, 0, 90*np.pi/180], 'XYZ', name='B')```Get the *DCM matrix* of the transformation between two frames:```python&gt;&gt;&gt; B.dcm(target=A)```Define a vector $\mathbf{v}$ in frame $\mathbf{A}$ and show the components of it in frame $\mathbf{B}$:```python&gt;&gt;&gt; v = Vector([0.0, 1.0, 0.0], frame=A)&gt;&gt;&gt; v.show(B)```Define the same vector in frame $\mathbf{B}$:```python&gt;&gt;&gt; v = Vector(v.show(B), frame=B)&gt;&gt;&gt; v.show(A)```### Linear ProgrammingSolve the following Linear Programming Problem (LPP) with one unique solution:```python&gt;&gt;&gt; from neumann.optimize import LinearProgrammingProblem as LPP&gt;&gt;&gt; from neumann.function import Function, Equality&gt;&gt;&gt; import sympy as sy&gt;&gt;&gt; variables = ['x1', 'x2', 'x3', 'x4']&gt;&gt;&gt; x1, x2, x3, x4 = syms = sy.symbols(variables, positive=True)&gt;&gt;&gt; obj1 = Function(3*x1 + 9*x3 + x2 + x4, variables=syms)&gt;&gt;&gt; eq11 = Equality(x1 + 2*x3 + x4 - 4, variables=syms)&gt;&gt;&gt; eq12 = Equality(x2 + x3 - x4 - 2, variables=syms)&gt;&gt;&gt; problem = LPP(cost=obj1, constraints=[eq11, eq12], variables=syms)&gt;&gt;&gt; problem.solve()['x']array([0., 6., 0., 4.])```### NonLinear ProgrammingFind the minimizer of the Rosenbrock function:```python&gt;&gt;&gt; from neumann.optimize import BinaryGeneticAlgorithm&gt;&gt;&gt; def Rosenbrock(x):...     a, b = 1, 100...     return (a-x[0])**2 + b*(x[1]-x[0]**2)**2&gt;&gt;&gt; ranges = [[-10, 10], [-10, 10]]&gt;&gt;&gt; BGA = BinaryGeneticAlgorithm(Rosenbrock, ranges, length=12, nPop=200)&gt;&gt;&gt; BGA.solve()...```## **License**This package is licensed under the MIT license.</longdescription>
</pkgmetadata>