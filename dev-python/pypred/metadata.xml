<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>PyPred======[![Build Status](https://travis-ci.org/armon/pypred.png)](https://travis-ci.org/armon/pypred)PyPred is a package to do predicate evaluation in Python. It uses aPLY (Lex/Yacc for Python) to parse inputs into an AST tree which itthen evaluates. The PyPred provides simple APIs to do the evaluationis most sitations, but allows for customized evaluation techniques formore complex situations.Additionally, PyPred supports the notion of predicate &quot;sets&quot;. This isa collection of predicates that are all simultaneously evaluated againsta single input document. For example, in a Pub/Sub system, each subscriptioncan be modeled as a predicate. When a new event arrives, the predicate setof all subscriptions can be evaluated to find all matching subscriptions.PyPred provides a PredicateSet model as well as an OptimizedPredicateSet.The optimized variant trades memory for speed. It extracts commonsub-expressions into a branch, and conditionally executes different setsof predicates to prune the predicates that will not match most efficiently.The parameters of the optimization can be tweaked to find a speed/memorybalance.Grammar=======The grammar that PyPred understands is limited to simple comparisonsand boolean logic.It supports the following:* Logical operators `not`, `and`, `or`* Comparison operators &gt;, &gt;=, &lt;, &lt;=, =, !=, 'is', 'is not'* Parenthesis to disambiguate* The subset check operator `contains`* The regular expression matcher `matches`* String literals, quoted if they include spaces* Numeric literals* Constants true, false, undefined, null, empty* Set literal, containing string literals, numeric and constant valuesGrammar Examples================To demonstate the capabilities of the pypred grammar, the followingexamples are provided.    name is 'Jack' and friend_name is 'Jill'This predicate checks that the input document has a field name equal to&quot;Jack&quot;, and a field friend\_name equal to &quot;Jill&quot;    event is &quot;Record Score&quot; and ((score &gt;= 500 and highest_score_wins) or (score &lt; 10 and lowest_score_wins))This is a slightly more advanced predicate. It checks that this is a &quot;Record Score&quot; event,and that the score is either greater than or equal to 500 in the case that a high score is desireable,or that the score is less than 10 if a low score is desirable.    server matches &quot;east-web-([\d]+)&quot; and errors contains &quot;CPU load&quot; and environment != testThis checks for any webserver hostname matching a numeric suffix, such as &quot;east-web-001&quot;, with&quot;CPU load&quot; being reported as an error in a non-test environment.Literal sets can be used to check for multiple clauses:    {&quot;WARN&quot; &quot;ERR&quot; &quot;CRIT&quot;} contains error_level or {500 501 503} contains status_codeThis provides two literal sets which are used to check against the dynamic valuesof error\_level and status\_code.API===Predicates themselves have a single interface, which is the `Predicate` class.It is instantiated with a string predicate.The main API's for it are:* Predicate(Pred) : Creates a new predicate object* Predicate.description(): Returns a human readable version of the tree if valid* Predicate.is\_valid() : Returns if the predicate is valid* Predicate.errors(): If not valid, returns a list of tokenization, syntax, and semantic errors* Predicate.evaluate(document) : Evaluates the given document against the predicate* Predicate.analyze(document) : Evaluates the given document against the predicate,  returns the results, as well as the evaluation context that includes more information about  the evaluation, including the failure reasons. This is generally much slower than  evaluate in the failure cases.One of the critical aspects of evaluating a predicate is the resolution ofliterals. When the AST needs a value to substitute a variable, it calls the`resolve_identifier` method of the Predicate. The default behavior is flexible,and support string literals, dictionary lookups, nested dictionaries, andcall back resolution via `set_resolver`. However, if a client wants to customizethe resolution of identifier, they can simply override this method.Predicate Sets have two main interfaces, either the `PredicateSet` or `OptimizedPredicateSet`.Both share part a subset of their calls:* Set(preds=None) : Instantiate the set, optionally with a list of predicates* Set.add(predicate) : Adds a predicate to the set* Set.update(predicates) : Extends to include a list of predicates* Set.evaluate(document) : Evaluates the document against the predicates and returns a list of matchesThe OptimizedPredicateSet supports an extended set of API's:* OptSet.description() : Returns ahuman readable version of the optimized tree* OptSet.analyze(document) : Like Predicate.analyze(), but returns a boolean, a list, and the evaluation context.* OptSet.compile\_ast() : Forces compilation of the interal AST* OptSet.finalize() : Prunes the AST of sub-predicates, and removes any instance data that is not used  as part of the evaluation of the optimized set. Not usually needed, but can reduce the total memory  footprint, and is useful if the object is going to be pickled.The standard PredicateSet relies on the underlying predicates to doresolution of literals, however the OptimizedPredicateSet implements`resolve_identifier` to do so. Thus if custom behavior is wanted, theoptimized set must be sub-classed.Human Readable Outputs======================PyPred tries to make it possible to provide human readable output ofboth predicates as well as any error messages that are encountered.Here is an example of a human readable description of:    p = Predicate('server matches &quot;east-web-([\d]+)&quot; and errors contains &quot;CPU load&quot; and environment != test')    print p.description()    AND operator at line: 1, col 34        MatchOperator at line: 1, col 7            Literal server at line: 1, col 0            Regex 'east-web-([\\d]+)' at line: 1, col 15        AND operator at line: 1, col 65            ContainsOperator at line: 1, col 45                Literal errors at line: 1, col 38                Literal &quot;CPU load&quot; at line: 1, col 54            != comparison at line: 1, col 81                Literal environment at line: 1, col 69                Literal test at line: 1, col 84Here is an example of the output during a failed evaluation:    p = Predicate('server matches &quot;east-web-([\d]+)&quot; and errors contains &quot;CPU load&quot; and environment != test')    res, ctx = p.analyze({'server': 'east-web-001', 'errors': [], 'environment': 'prod'})    assert res == False    pprint.pprint(ctx.failed)     [&quot;Right side: 'CPU load' not in left side: [] for ContainsOperator at line: 1, col 45&quot;,                 'Left hand side of AND operator at line: 1, col 65 failed',                 'Right hand side of AND operator at line: 1, col 34 failed']    pprint.pprint(ctx.literals)     {'&quot;CPU load&quot;': 'CPU load',      'errors': [],      'server': 'east-web-001'}</longdescription>
</pkgmetadata>