<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![PyPI version](https://badge.fury.io/py/django-datawatch.svg)](https://badge.fury.io/py/django-datawatch)[![GitHub build status](https://github.com/RegioHelden/django-datawatch/workflows/Test/badge.svg)](https://github.com/RegioHelden/django-datawatch/actions)[![Coverage Status](https://coveralls.io/repos/github/RegioHelden/django-datawatch/badge.svg?branch=add_coveralls)](https://coveralls.io/github/RegioHelden/django-datawatch?branch=add_coveralls)[![Open Source Love](https://badges.frapsoft.com/os/v2/open-source.svg?v=103)](https://github.com/ellerbrock/open-source-badges/)[![MIT Licence](https://badges.frapsoft.com/os/mit/mit.svg?v=103)](https://opensource.org/licenses/mit-license.php)# Django DatawatchWith Django Datawatch you are able to implement arbitrary checks on data, review their status and even describe what to do to resolve them.Think of [nagios](https://www.nagios.org/)/[icinga](https://www.icinga.org/) for data.## Check execution backends### SynchronousWill execute all tasks synchronously which is not recommended but the most simple way to get started.### CeleryWill execute the tasks asynchronously using celery as a task broker and executor.Requires celery 5.0.0 or later.### Other backendsFeel free to implement other task execution backends and send a pull request.## Install```shell$ pip install django-datawatch```Add `django_datawatch` to your `INSTALLED_APPS`## Celery beat database schedulerIf the datawatch scheduler should be run using the celery beat database scheduler, you need to install [django_celery_beat](hhttp://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#beat-custom-schedulers).Add `django_datawatch.tasks.django_datawatch_scheduler` to the `CELERYBEAT_SCHEDULE` of your app.This task should be executed every minute e.g. `crontab(minute='*/1')`, see example app.## Write a custom checkCreate `checks.py` inside your module.```pythonfrom datetime import datetimefrom celery.schedules import crontabfrom django_datawatch.datawatch import datawatchfrom django_datawatch.base import BaseCheck, CheckResponsefrom django_datawatch.models import Result@datawatch.registerclass CheckTime(BaseCheck):    run_every = crontab(minute='*/5')  # scheduler will execute this check every 5 minutes    def generate(self):        yield datetime.now()    def check(self, payload):        response = CheckResponse()        if payload.hour &lt;= 7:            response.set_status(Result.STATUS.ok)        elif payload.hour &lt;= 12:            response.set_status(Result.STATUS.warning)        else:            response.set_status(Result.STATUS.critical)        return response    def get_identifier(self, payload):        # payload will be our datetime object that we are getting from generate method        return payload    def get_payload(self, identifier):        # as get_identifier returns the object we don't need to process it        # we can return identifier directly        return identifier    def user_forced_refresh_hook(self, payload):        payload.do_something()```### .generateMust yield payloads to be checked. The check method will then be called for every payload.### .checkMust return an instance of CheckResponse.### .get_identifierMust return a unique identifier for the payload. ### .user_forced_refresh_hookA function that gets executed when the refresh is requested by a user through the `ResultRefreshView`.This is used in checks that are purely based on triggers, e.g. when a field changes the test gets executed.### trigger check updatesCheck updates for individual payloads can also be triggered when related datasets are changed.The map for update triggers is defined in the Check class' trigger_update attribute.```trigger_update = dict(subproduct=models_customer.SubProduct)```The key is a slug to define your trigger while the value is the model that issues the trigger when saved.You must implement a resolver function for each entry with the name of get_&lt;slug&gt;_payload which returns the payload or multiple payloads (as a list) to check (same datatype as .check would expect or .generate would yield).```def get_subproduct_payload(self, instance):    return instance.product```## Exceptions#### `DatawatchCheckSkipException`raise this exception to skip current check. The result will not appear in the checks results. ## Run your checksA management command is provided to queue the execution of all checks based on their schedule.Add a crontab to run this command every minute and it will check if there's something to do.```shell$ ./manage.py datawatch_run_checks$ ./manage.py datawatch_run_checks --slug=example.checks.UserHasEnoughBalance```## Refresh your check resultsA management command is provided to forcefully refresh all existing results for a check.This comes in handy if you changes the logic of your check and don't want to wait until the periodic execution or an update trigger.```shell$ ./manage.py datawatch_refresh_results$ ./manage.py datawatch_refresh_results --slug=example.checks.UserHasEnoughBalance```## Get a list of registered checks```shell$ ./manage.py datawatch_list_checks```## Clean up your databaseRemove the unnecessary check results and executions if you've removed the code for a check.```shell$ ./manage.py datawatch_clean_up```## Settings```pythonDJANGO_DATAWATCH_BACKEND = 'django_datawatch.backends.synchronous'DJANGO_DATAWATCH_RUN_SIGNALS = True```### DJANGO_DATAWATCH_BACKENDYou can chose the backend to run the tasks. Supported are 'django_datawatch.backends.synchronous' and 'django_datawatch.backends.celery'.Default: 'django_datawatch.backends.synchronous'### DJANGO_DATAWATCH_RUN_SIGNALSUse this setting to disable running post_save updates during unittests if required.Default: True### celery task queueDatawatch supported setting a specific queue in release &lt; 0.4.0With the switch to celery 4, you should use task routing to define the queue for your tasks, see http://docs.celeryproject.org/en/latest/userguide/routing.html# CONTRIBUTE## Dev environment- [Docker](https://docs.docker.com/) (19.03.0 or later)- [Compose plugin for Docker](https://docs.docker.com/compose/install/linux/)Please make sure that no other container is using port 8000 as this is the one you're install gets exposed to:http://localhost:8000/## SetupWe've included an example app to show how django_datawatch works.Start by launching the included docker container.```bashdocker compose up -d```Then setup the example app environment.```bashdocker compose run --rm app migratedocker compose run --rm app loaddata example```The installed superuser is &quot;example&quot; with password &quot;datawatch&quot;.## Run checksOpen http://localhost:8000/, log in and then go back to http://localhost:8000/.You'll be prompted with an empty dashboard. That's because we didn't run any checks yet.Let's enqueue an update.```bashdocker compose run --rm app datawatch_run_checks --force```The checks for the example app are run synchronously and should be updated immediately.If you decide to switch to the celery backend, you should now start a celery worker to process the checks.```bashdocker compose run --rm --entrypoint celery app -A example worker -l DEBUG```To execute the celery beat scheduler which runs the datawatch scheduler every minute, just run:```bashdocker compose run --rm --entrypoint celery app -A example  beat --scheduler django_celery_beat.schedulers:DatabaseScheduler```You will see some failed check now after you refreshed the dashboard view.![Django Datawatch dashboard](http://static.jensnistler.de/django_datawatch.png &quot;Django Datawatch dashboard&quot;)![Django Datawatch detail view](http://static.jensnistler.de/django_datawatch_details.png &quot;Django Datawatch detail view&quot;)## Run the tests```bashdocker compose run --rm app test```## Requirements upgradesCheck for upgradeable packages by running ```bashdocker compose up -ddocker compose exec app pip-check```## TranslationsCollect and compile translations for all registered locales```bashdocker compose run --rm app makemessages --no-location --alldocker compose run --rm app compilemessages```## Making a new release[bumpversion](https://github.com/peritus/bumpversion) is used to manage releases.Add your changes to the [CHANGELOG](./CHANGELOG.rst), run```bashdocker compose exec app bumpversion &lt;major|minor|patch&gt;```then push (including tags).</longdescription>
</pkgmetadata>