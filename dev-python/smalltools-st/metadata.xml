<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># smalltools_stA Python port with a few small tools, snippets and utils (with a lot of WIP) learned in my times as a Smalltalk developer and which I miss a lot.[![PyPI](https://img.shields.io/pypi/v/smalltools_st?color=blue&amp;label=PyPI%20Version&amp;logo=python&amp;logoColor=white)](https://pypi.org/project/smalltools_st/)[![GitHub release (latest by date)](https://img.shields.io/github/v/release/EzequielPuerta/smalltools?label=Latest%20Release&amp;display_name=tag&amp;logo=github&amp;logoColor=white)](https://github.com/EzequielPuerta/smalltools/releases/latest)![GitHub License](https://img.shields.io/github/license/EzequielPuerta/smalltools?label=License&amp;logo=github&amp;logoColor=white)[![Package Status](https://img.shields.io/pypi/status/smalltools_st.svg?label=PyPI%20Status&amp;logo=python&amp;logoColor=white)](https://pypi.org/project/smalltools_st/)[![CircleCI](https://img.shields.io/circleci/build/gh/EzequielPuerta/smalltools/main?label=CircleCI%20Build&amp;logo=circleci&amp;logoColor=white)](https://circleci.com/gh/EzequielPuerta/smalltools)[![CodeFactor Grade](https://img.shields.io/codefactor/grade/github/EzequielPuerta/smalltools/main?label=CodeFactor&amp;logo=codefactor&amp;logoColor=white)](https://www.codefactor.io/repository/github/ezequielpuerta/smalltools)[![Codecov](https://img.shields.io/codecov/c/gh/EzequielPuerta/smalltools?label=Codecov&amp;logo=codecov&amp;logoColor=white)](https://codecov.io/gh/EzequielPuerta/smalltools)---## Behavior:### 1. SuitableClassFinder:&gt; Given the hierarchy of an abstract class, it detects the appropriate concrete subclass (deterministically) that satisfies certain attributes obtained as a parameter. Useful for implementing the Strategy design pattern.#### ExampleLet's imagine that we have the following hierarchy:```pythonfrom abc import ABCclass Vehicle(ABC):    def __init__(self, brand, color):        self.brand = brand        self.color = colorclass Car(Vehicle):    def __init__(self, doors_amount, *args):        self.doors_amount = doors_amount        super().__init__(*args)class Bike(Vehicle):    passclass Motorbike(Vehicle):    pass```And we are consuming some silly API. The response could be something like:```pythonvehicles = [    {'type':'car', 'doors':5, 'motor':1400, 'brand':'renault', 'color':'red'},    {'type':'bike', 'doors':0, 'motor':0, 'brand':'trek', 'color':'orange'},    {'type':'motorbike', 'doors':0, 'motor':250, 'brand':'yamaha', 'color':'black'},    {'type':'car', 'doors':3, 'motor':1200, 'brand':'volkswagen', 'color':'white'},    ...]```Adding just this snippet to `Vehicle`:```python    @classmethod    def can_handle(cls, vehicle_type):        return cls.__name__.lower() == vehicle_type```...we can get the right subclass for each `json`, just passing the `type` string attribute to the `suitable_for` method:```pythonfrom smalltools.behavior.suitable_class_finder import SuitableClassFinderSuitableClassFinder(Vehicle).suitable_for(vehicles[0]['type']) # Returns Car```&gt; Note: The `can_handle` method is what we called the `suitable_method` and its arguments are the `suitable_object`.But, what if the API response is not so easy?```pythonvehicles = [    {'doors':5, 'motor':1400, 'brand':'renault', 'color':'red'},    {'doors':0, 'motor':0, 'brand':'trek', 'color':'orange'},    {'doors':0, 'motor':250, 'brand':'yamaha', 'color':'black'},    {'doors':3, 'motor':1200, 'brand':'volkswagen', 'color':'white'},    ...]```Don't worry. We can do something like this:```pythonfrom abc import ABC, abstractmethodclass Vehicle(ABC):    def __init__(self, brand, color):        self.brand = brand        self.color = color    @classmethod    @abstractmethod    def can_handle(cls, doors, motor):        passclass Car(Vehicle):    def __init__(self, doors_amount, *args):        self.doors_amount = doors_amount        super().__init__(*args)    @classmethod    def can_handle(cls, doors, motor):        return doors &gt; 0 and motor &gt; 0class Bike(Vehicle):    @classmethod    def can_handle(cls, doors, motor):        return doors == 0 and motor == 0class Motorbike(Vehicle):    @classmethod    def can_handle(cls, doors, motor):        return doors == 0 and motor &gt; 0```Check that you can pass multiple arguments to the `suitable_method`. So we have to do the next lines:```pythonfrom smalltools.behavior.suitable_class_finder import SuitableClassFindervehicle = vehicles[0]SuitableClassFinder(Vehicle).suitable_for(vehicle['doors'], vehicle['motor']) # Returns Car```Okey, and if you have objects with different &quot;shapes&quot;?```pythonvehicles = [    {'doors':5, 'motor':1400, 'brand':'renault', 'color':'red'},    {'brand':'trek', 'color':'orange'},    {'motor':250, 'brand':'yamaha', 'color':'black'},    {'doors':3, 'motor':1200, 'brand':'volkswagen', 'color':'white'},    ...]```Then, you can pass the entire `json` and process it:```pythonfrom abc import ABC, abstractmethodclass Vehicle(ABC):    def __init__(self, brand, color):        self.brand = brand        self.color = color    @classmethod    @abstractmethod    def can_handle(cls, raw_json):        passclass Car(Vehicle):    def __init__(self, doors_amount, *args):        self.doors_amount = doors_amount        super().__init__(*args)    @classmethod    def can_handle(cls, raw_json):        return 'doors' in raw_json and raw_json['doors'] &gt; 0class Bike(Vehicle):    @classmethod    def can_handle(cls, raw_json):        return 'doors' not in raw_json and 'motor' not in raw_jsonclass Motorbike(Vehicle):    @classmethod    def can_handle(cls, raw_json):        return 'doors' not in raw_json and 'motor' in raw_json and raw_json['motor'] &gt; 0```As simple as that!```pythonfrom smalltools.behavior.suitable_class_finder import SuitableClassFinderSuitableClassFinder(Vehicle).suitable_for(vehicles[0]) # Returns Car```The sky is the limit!#### Final words1. The different `can_handle` cases should be disjoint. If there are many subclasses that suits to one case, it will raise an exception.2. Subclasses should cover all possible cases. If there is a case that doesn't match with any subclass, then an exception will be thrown.3. You can use a different method than `can_handle`. Just replace the desired method in the `suitable_method` argument of `suitable_for` function. This could be useful when you have a complex `suitable_object` and you want to be more explicit with the name of the method.4. Sometimes, it could be good to return a default class when no result is found (instead of raising an exception). You can do this with the `default_subclass` argument of `suitable_for` method. It's disabled by default, as mentioned at the second item.---And thats it! for now...</longdescription>
</pkgmetadata>