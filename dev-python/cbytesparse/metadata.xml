<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>********Overview********.. start-badges.. list-table::    :stub-columns: 1    * - docs      - |docs|    * - tests      - | |gh_actions|        | |codecov|    * - package      - | |version| |wheel|        | |supported-versions|        | |supported-implementations|.. |docs| image:: https://readthedocs.org/projects/cbytesparse/badge/?style=flat    :target: https://readthedocs.org/projects/cbytesparse    :alt: Documentation Status.. |gh_actions| image:: https://github.com/TexZK/cbytesparse/workflows/CI/badge.svg    :alt: GitHub Actions Status    :target: https://github.com/TexZK/cbytesparse.. |codecov| image:: https://codecov.io/gh/TexZK/cbytesparse/branch/main/graphs/badge.svg?branch=main    :alt: Coverage Status    :target: https://codecov.io/github/TexZK/cbytesparse.. |version| image:: https://img.shields.io/pypi/v/cbytesparse.svg    :alt: PyPI Package latest release    :target: https://pypi.org/project/cbytesparse/.. |wheel| image:: https://img.shields.io/pypi/wheel/cbytesparse.svg    :alt: PyPI Wheel    :target: https://pypi.org/project/cbytesparse/.. |supported-versions| image:: https://img.shields.io/pypi/pyversions/cbytesparse.svg    :alt: Supported versions    :target: https://pypi.org/project/cbytesparse/.. |supported-implementations| image:: https://img.shields.io/pypi/implementation/cbytesparse.svg    :alt: Supported implementations    :target: https://pypi.org/project/cbytesparse/.. end-badgesLibrary to handle sparse bytes within a virtual memory space.* Free software: BSD 2-Clause LicenseObjectives==========This library aims to provide utilities to work with a `virtual memory`, whichconsists of a virtual addressing space where sparse `chunks` of data can bestored.In order to be easy to use, its interface should be close to that of a``bytearray``, which is the closest pythonic way to store dynamic data.The main downside of a ``bytearray`` is that it requires a contiguous dataallocation starting from address 0. This is not good when sparse data have tobe stored, such as when emulating the addressing space of a genericmicrocontroller.The main idea is to provide a ``bytearray``-like class with the possibility tointernally hold the sparse `blocks` of data.A `block` is ideally a tuple ``(start, data)`` where `start` is the startaddress and `data` is the container of data items (e.g. ``bytearray``).The length of the block is ``len(data)``.Those blocks are usually not overlapping nor contiguous, and sorted by startaddress.Python implementation=====================This library is the Cython complement to the Python implementation provided bythe ``bytesparse`` Python package.Please refer to its own documentation for more details.The ``bytesparse`` package provides the following virtual memory types:* ``bytesparse.Memory``, a generic virtual memory with infinite address range.* ``bytesparse.bytesparse``, a subclass behaving more like ``bytearray``.All the implementations inherit the behavior of``collections.abc.MutableSequence`` and ``collections.abc.MutableMapping``.Please refer to `the collections.abc reference manual&lt;https://docs.python.org/3/library/collections.abc.html&gt;`_ for more informationabout the interface API methods and capabilities.Cython implementation=====================The library provides an experimental `Cython` implementation. It tries tomimic the same algorithms of the Python implementation, while exploiting thespeedup of compiled `C` code.Beware that the Cython implementation is meant to be potentially faster thanthe pure Python one, but there might be even faster `ad-hoc` implementationsof virtual memory highly optimized for the underlying hardware.The addressing space is limited to that of an ``uint_fast64_t``, so it is notpossible to have an infinite addressing space, nor negative addresses.To keep the implementation code simple enough, the highest address (i.e.``0xFFFFFFFFFFFFFFFF``) is reserved.Block data chunks cannot be greater than the maximum ``ssize_t`` value(typically half of the addressing space).The Cython implementation is optional, and potentially useful only when thePython implementation seems too slow for the user's algorithms, within thelimits stated above.If in doubt about using the Cython implementation, just stick with the Pythonone, which is much easier to integrate and debug.More details can be found within ``cbytesparse.c``.Examples========Here's a quick usage example of ``bytesparse`` objects:&gt;&gt;&gt; from cbytesparse import Memory&gt;&gt;&gt; from cbytesparse import bytesparse&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; m = bytesparse(b'Hello, World!')  # creates from bytes&gt;&gt;&gt; len(m)  # total length13&gt;&gt;&gt; str(m)  # string representation, with bounds and data blocks&quot;&lt;[[0, b'Hello, World!']]&gt;&quot;&gt;&gt;&gt; bytes(m)  # exports as bytesb'Hello, World!'&gt;&gt;&gt; m.to_bytes()  # exports the whole range as bytesb'Hello, World!'&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; m.extend(b'!!')  # more emphasis!!!&gt;&gt;&gt; bytes(m)b'Hello, World!!!'&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; i = m.index(b',')  # gets the address of the comma&gt;&gt;&gt; m[:i] = b'Ciao'  # replaces 'Hello' with 'Ciao'&gt;&gt;&gt; bytes(m)b'Ciao, World!!!'&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; i = m.index(b',')  # gets the address of the comma&gt;&gt;&gt; m.insert(i, b'ne')  # inserts 'ne' to make 'Ciaone' (&quot;big ciao&quot;)&gt;&gt;&gt; bytes(m)b'Ciaone, World!!!'&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; i = m.index(b',')  # gets the address of the comma&gt;&gt;&gt; m[(i - 2):i] = b' ciao'  # makes 'Ciaone' --&gt; 'Ciao ciao'&gt;&gt;&gt; bytes(m)b'Ciao ciao, World!!!'&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; m.pop()  # less emphasis --&gt; 33 == ord('!')33&gt;&gt;&gt; bytes(m)b'Ciao ciao, World!!'&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; del m[m.index(b'l')]  # makes 'World' --&gt; 'Word'&gt;&gt;&gt; bytes(m)b'Ciao ciao, Word!!'&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; m.popitem()  # less emphasis --&gt; pops 33 (== '!') at address 16(16, 33)&gt;&gt;&gt; bytes(m)b'Ciao ciao, Word!'&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; m.remove(b' ciao')  # self-explanatory&gt;&gt;&gt; bytes(m)b'Ciao, Word!'&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; i = m.index(b',')  # gets the address of the comma&gt;&gt;&gt; m.clear(start=i, endex=(i + 2))  # makes empty space between the words&gt;&gt;&gt; m.to_blocks()  # exports as data block list[[0, b'Ciao'], [6, b'Word!']]&gt;&gt;&gt; m.contiguous  # multiple data blocks (emptiness inbetween)False&gt;&gt;&gt; m.content_parts  # two data blocks2&gt;&gt;&gt; m.content_size  # excluding emptiness9&gt;&gt;&gt; len(m)  # including emptiness11&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; m.flood(pattern=b'.')  # replaces emptiness with dots&gt;&gt;&gt; bytes(m)b'Ciao..Word!'&gt;&gt;&gt; m[-2]  # 100 == ord('d')100&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; m.peek(-2)  # 100 == ord('d')100&gt;&gt;&gt; m.poke(-2, b'k')  # makes 'Word' --&gt; 'Work'&gt;&gt;&gt; bytes(m)b'Ciao..Work!'&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; m.crop(start=m.index(b'W'))  # keeps 'Work!'&gt;&gt;&gt; m.to_blocks()[[6, b'Work!']]&gt;&gt;&gt; m.span  # address range of the whole memory(6, 11)&gt;&gt;&gt; m.start, m.endex  # same as above(6, 11)&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; m.bound_span = (2, 10)  # sets memory address bounds&gt;&gt;&gt; str(m)&quot;&lt;2, [[6, b'Work']], 10&gt;&quot;&gt;&gt;&gt; m.to_blocks()[[6, b'Work']]&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; m.shift(-6)  # shifts to the left; NOTE: address bounds will cut 2 bytes!&gt;&gt;&gt; m.to_blocks()[[2, b'rk']]&gt;&gt;&gt; str(m)&quot;&lt;2, [[2, b'rk']], 10&gt;&quot;&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; a = bytesparse(b'Ma')&gt;&gt;&gt; a.write(0, m)  # writes [2, b'rk'] --&gt; 'Mark'&gt;&gt;&gt; a.to_blocks()[[0, b'Mark']]&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; b = Memory.from_bytes(b'ing', offset=4)&gt;&gt;&gt; b.to_blocks()[[4, b'ing']]&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; a.write(0, b)  # writes [4, b'ing'] --&gt; 'Marking'&gt;&gt;&gt; a.to_blocks()[[0, b'Marking']]&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; a.reserve(4, 2)  # inserts 2 empty bytes after 'Mark'&gt;&gt;&gt; a.to_blocks()[[0, b'Mark'], [6, b'ing']]&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; a.write(4, b'et')  # --&gt; 'Marketing'&gt;&gt;&gt; a.to_blocks()[[0, b'Marketing']]&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; a.fill(1, -1, b'*')  # fills asterisks between the first and last letters&gt;&gt;&gt; a.to_blocks()[[0, b'M*******g']]&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; v = a.view(1, -1)  # creates a memory view spanning the asterisks&gt;&gt;&gt; v[::2] = b'1234'  # replaces even asterisks with numbers&gt;&gt;&gt; a.to_blocks()[[0, b'M1*2*3*4g']]&gt;&gt;&gt; a.count(b'*')  # counts all the asterisks3&gt;&gt;&gt; v.release()  # release memory view&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; c = a.copy()  # creates a (deep) copy&gt;&gt;&gt; c == aTrue&gt;&gt;&gt; c is aFalse&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; del a[a.index(b'*')::2]  # deletes every other byte from the first asterisk&gt;&gt;&gt; a.to_blocks()[[0, b'M1234']]&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; a.shift(3)  # moves away from the trivial 0 index&gt;&gt;&gt; a.to_blocks()[[3, b'M1234']]&gt;&gt;&gt; list(a.keys())[3, 4, 5, 6, 7]&gt;&gt;&gt; list(a.values())[77, 49, 50, 51, 52]&gt;&gt;&gt; list(a.items())[(3, 77), (4, 49), (5, 50), (6, 51), (7, 52)]&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; c.to_blocks()  # reminder[[0, b'M1*2*3*4g']]&gt;&gt;&gt; c[2::2] = None  # clears (empties) every other byte from the first asterisk&gt;&gt;&gt; c.to_blocks()[[0, b'M1'], [3, b'2'], [5, b'3'], [7, b'4']]&gt;&gt;&gt; list(c.intervals())  # lists all the block ranges[(0, 2), (3, 4), (5, 6), (7, 8)]&gt;&gt;&gt; list(c.gaps())  # lists all the empty ranges[(None, 0), (2, 3), (4, 5), (6, 7), (8, None)]&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; c.flood(pattern=b'xy')  # fills empty spaces&gt;&gt;&gt; c.to_blocks()[[0, b'M1x2x3x4']]&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; t = c.cut(c.index(b'1'), c.index(b'3'))  # cuts an inner slice&gt;&gt;&gt; t.to_blocks()[[1, b'1x2x']]&gt;&gt;&gt; c.to_blocks()[[0, b'M'], [5, b'3x4']]&gt;&gt;&gt; t.bound_span  # address bounds of the slice (automatically activated)(1, 5)&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; k = bytesparse.from_blocks([[4, b'ABC'], [9, b'xy']], start=2, endex=15)  # bounded&gt;&gt;&gt; str(k)  # shows summary&quot;&lt;2, [[4, b'ABC'], [9, b'xy']], 15&gt;&quot;&gt;&gt;&gt; k.bound_span  # defined at creation(2, 15)&gt;&gt;&gt; k.span  # superseded by bounds(2, 15)&gt;&gt;&gt; k.content_span  # actual content span (min/max addresses)(4, 11)&gt;&gt;&gt; len(k)  # superseded by bounds13&gt;&gt;&gt; k.content_size  # actual content size5&gt;&gt;&gt; # ----------------------------------------------------------------&gt;&gt;&gt; k.flood(pattern=b'.')  # floods between span&gt;&gt;&gt; k.to_blocks()[[2, b'..ABC..xy....']]Documentation=============For the full documentation, please refer to:https://cbytesparse.readthedocs.io/Installation============From PyPI (might not be the latest version found on *github*):.. code-block:: sh    $ pip install cbytesparseFrom the source code root directory:.. code-block:: sh    $ pip install .Development===========To run the all the tests:.. code-block:: sh    $ pip install tox    $ toxTo regenerate the Cython files manually, run the following commands:.. code-block:: sh    $ python scripts/cython_build_src.py    $ python scripts/cython_build_tests.pyor alternatively:.. code-block:: sh    $ tox -e cythonize</longdescription>
</pkgmetadata>