<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. figure:: https://travis-ci.org/smartfile/django-transfer.png   :alt: Travis CI Status   :target: https://travis-ci.org/smartfile/django-transferA `SmartFile`_ Open Source project. `Read more`_ about how SmartFileuses and contributes to Open Source software... figure:: http://www.smartfile.com/images/logo.jpg   :alt: SmartFileIntroduction------------The Django project recommends serving static files from a different webserver than the one executing the web application. This is easy to implementwhen the static files are web assets. These resources can be served to anyanonymous user and can easily be cached. However, in some cases, anapplication must control access to files, or even allow users to uploadfiles. In these cases, there is a need to tightly control the process,which runs contrary to the Django project's recommendations.Luckily, there are a few tools available that allow removing downloadsand even uploads from the application server, while still allowing itto control the process. This Django application is meant to helpintegrate with such tools, so that your web application can hand offfile transfers to a downstream proxy server, which is better equippedto handle this task, freeing up the application server for the heavylifting.django-transfer integrates with:- `mod_xsendfile`_ for Apache- `X-Accel-Redirect`_ for Nginx- `X-SendFile`_ header in Lighttpd- `mod_upload`_ for NginxThe first three of the above allow the web application to emit a headerinstructing the content server to transfer a file to the HTTP client.This way, the web app still receives the download request, performs anychecks required, and sends a header instead of the actual file contents.The last, `mod_upload`_ does something similar, but for file UPLOADS.mod_upload will receive files POSTed to the server and save them offto temporary files. It will then forward the request to the webapplication, replacing the file bodies with paths to the temporary filescontaining them.`mod_upload`_ is better than simply buffering the upload because the filebodies are NEVER handled by the application server. In fact, if you canwrite the temporary files to a holding area that exists on the same volumeas their final location, a simple move is all that is required to finishthe upload. In fact, the ``ProxyUploadedFile`` class (contained in``request.FILES`` has a convenience ``move()`` method.Downloading-----------django-transfer provides an HttpResponse subclass that handles downloadstriggered via response header. The actual header and format are handled bythis class. TransferHttpResponse accepts a path, and handles the transfer.When ``settings.DEBUG == True`` the path is sent directly to the client,this allows the Django development server to function as normal withoutchanging your application code.The timeline of events for a download looks like the following.1. A client initiates a download (GET request).2. The downstream server forwards the request to Django.3. Django application authenticates the user and does other necessary   processing.4. Django application returns a ``TransferHttpResponse``.5. The ``TransferHttpResponse`` emits a header instructing the downstream   server to transfer a file to the client.First you must configure django-transfer and let it know the detailsabout your downstream server.*Server Types*::    TRANSFER_SERVER = 'apache'  # or 'nginx' or 'lighttpd'You can change the server type and TransferHttpResponse will use thecorrect header(s) for the configured server.*Nginx Mappings*Nginx has support for the X-Accel-Redirect header built in. However, itdoes not accept arbitrary paths for transfer. Nginx requires that youconfigure internal locations, and return a path relative to one of those.For example, if you configure:::    location /downloads {        internal;        alias /mnt/shared/downloads;    }When nginx receives the header ``X-Accel-Redirect: /downloads/foo/bar.png``it will transfer ``'/mnt/shared/downloads/foo/bar.png'`` to the client.django-transfer needs to know about such locations. You can inform it ofthem by configuring the mappings.::    TRANSFER_MAPPINGS = {        '/mnt/shared/downloads': '/downloads',    }Once the mapping is configured, you can use absolute paths, which willbe converted to the locations required by nginx. If you later switch toa different server (apache or lighttpd), these absolute paths will continueto function without changing your code. Similarly, when ``settings.DEBUG ==True``, absolute paths will be required so that the development server cansend the file directly.If you do not configure any mappings, and you are using server type``'nginx'``, an ImproperlyConfigured exception will be raised. Mappingsare ignored when the server type is not ``'nginx'``.*Apache Configuration*Apache requires a module to be installed in order to use the X-Sendfileheader. Once installed, this module must be enabled, and you must definethe locations that allow downloads. Much like Nginx, Apache will notserve arbitrary paths, only those specifically configured.::    XSendFile On    XSendFilePath /mnt/shared/downloadsWhen apache receives the header ``X-SendFile: /mnt/shared/downloads/foo/bar.png``It will transfer ``'/mnt/shared/downloads/foo/bar.png'`` to the client.django-transfer will pass along absolute paths when the server type is``'apache'``.*Lighttpd Configuration*TODO: I have never used lighttpd, but I know it supports this.Uploading---------Uploads are handled using a similar (but reversed) process. Nginxsupports uploading with `mod_upload`_. This is not part of the defaultserver, so you must build nginx with support for uploading. If available,the upload module will strip file contents from POST requests, savethem to temporary files and then forward those file names to yourapplication.1. A client initiates an upload (POST reqest).2. The downstream server saves any file(s) to a holding area.3. The downstream server forwards the request (minus the file content) to   Django.4. Django does any processing that is necessary and returns a response.5. The downstream server relays the response to the client.To handle downstream uploads in the same way you handle regular fileuploads, you must install the ``TransferMiddleware``. This middlewareprocesses the ``request.POST`` data, identifying uploaded files andcreating new entries in ``request.FILES`` to represent them.::    MIDDLEWARE_CLASSES = (        ...        'django_transfer.TransferMiddleware',        ...    )Nginx requires a bit of configuration to make this possible. Below is asample configuration.::    location /upload {        upload_pass @application;        # The path below must exist, so must subdirectories named 0-9        # $ mkdir -p /mnt/shared/uploads/{0-9}        upload_store /mnt/shared/uploads 1;        upload_store_access user:r;        # You can limit file size here...        upload_max_file_size 0;        # These are the MINIMUM fields required by django-transfer.        # mod_upload will replace $upload_field_name with the name of the file        # field. If there are multiple files, your web application will receive        # a set of filename/paths for each.        upload_set_form_field $upload_field_name[filename] &quot;$upload_file_name&quot;;        upload_set_form_field $upload_field_name[path] &quot;$upload_tmp_path&quot;;        # You can also pass along the following fields, otherwise        # django-transfer will attempt to &quot;figure out&quot; these values on it's        # own.        upload_set_form_field $upload_field_name[content_type] &quot;$upload_content_type&quot;;        upload_aggregate_form_field $upload_field_name[size] &quot;$upload_file_size&quot;;        # If you want to receive non-file fields provide the following, note        # that if nginx supports it, this can be a regular expression. If not        # you can define allowed fields separately, by providing this argument        # multiple times.        upload_pass_form_field &quot;.*&quot;;        # If you want to receive querystring arguments...        upload_pass_args on;    }    location / {        # ... proxy-pass or FCGI directives here ...        # This is where requests to URLs other than /upload go.    }    location @application {        # ... proxy-pass or FCGI directives here ...        # This is where to pass upload requests, most frequently, it will be        # the same as the previous location.    }For more information on how to install and configure mod_upload, see thefollowing pages, I found them useful while implementing this.http://www.grid.net.ru/nginx/upload.en.htmlhttp://blog.joshsoftware.com/2010/10/20/uploading-multiple-files-with-nginx-upload-module-and-upload-progress-bar/http://bclennox.com/extremely-large-file-uploads-with-nginx-passenger-rails-and-jqueryYour views can now handle regular or downstream uploads in the same fashion.Development / Debugging-----------------------When ``settings.DEBUG == True``, ``TransferHttpResponse`` will transfer thefile directly which suitable for use with the Django development server.The ``TransferMiddleware`` always supports regular file uploads, so itwill also function properly when ``settings.DEBUG == True``.Non-ASCII File Names--------------------This library does nothing to help with non-ASCII filenames, however, aquick note on this topic might save you some headache.A common practice is to include a Content-Disposition header thatincludes the file name. This breaks when the filename contains non-ASCIIcharacters (UTF-8 etc). Specifically, Django will raise an exception whenyou try to set the header. The HTTP specification states that headers mustcontain only ASCII.The best workaround I have found for this is to include the file name inthe URL. It must be the last element of the URL. All browsers I know ofwill use this file name in the &quot;Save As&quot; dialog. Since a URL can containany character, this works around the issue. To implement this, Igenerally add a regular expression to urls.py that ignores the file name.The file name is there only for the benefit of the browser, and is notused by the Django view. Thus::    url('^/download/.*', 'myapp.views.download'),will allow an optional trailing file name for our purposes. You then mustensure that any links to your download view include the file name, like so::    http://myapp.com/download/desired_filename.pngWhen the user clicks that link and the application sends file contents, thebrowser will obtain the file name from the URL. The browser may decide torender or save the file. You can force the issue (saving vs. rendering) byincluding a Content-Disposition header with the value &quot;attachment;&quot;excluding the (unsafe) filename... _SmartFile: http://www.smartfile.com/.. _Read more: http://www.smartfile.com/open-source.html.. _mod_xsendfile: https://tn123.org/mod_xsendfile/.. _X-Accel-Redirect: http://wiki.nginx.org/XSendfile.. _X-SendFile: http://redmine.lighttpd.net/projects/1/wiki/Docs_ModFastCGI#X-Sendfile.. _mod_upload: http://wiki.nginx.org/HttpUploadModule</longdescription>
</pkgmetadata>