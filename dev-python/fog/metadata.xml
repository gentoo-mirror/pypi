<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Build Status](https://travis-ci.org/Yomguithereal/fog.svg)](https://travis-ci.org/Yomguithereal/fog)# FogA fuzzy matching/clustering library for Python.## InstallationYou can install `fog` with pip with the following command:```pip install fog```## Usage* [Evaluation](#evaluation)  * [best_matching_macro_average](#best_matching_macro_average)* [Graph](#graph)  * [floatsam_sparsification](#floatsam_sparsification)  * [monopartite_projection](#monopartite_projection)* [Keyers](#keyers)  * [omission_key](#omission_key)  * [skeleton_key](#skeleton_key)* [Metrics](#metrics)  * [cosine_similarity](#cosine_similarity)  * [sparse_cosine_similarity](#sparse_cosine_similarity)  * [sparse_dot_product](#sparse_dot_product)  * [binary_cosine_similarity](#binary_cosine_similarity)  * [sparse_binary_cosine_similarity](#sparse_binary_cosine_similarity)  * [dice_coefficient](#dice_coefficient)  * [jaccard_similarity](#jaccard_similarity)  * [weighted_jaccard_similarity](#weighted_jaccard_similarity)  * [overlap_coefficient](#overlap_coefficient)### Evaluation#### best_matching_macro_averageEfficient implementation of the &quot;macro average best matching F1&quot; evaluationmetric for clusters.Note that this metric is not symmetric and will match truth -&gt; predicted.*Arguments** **truth** *iterable*: the truth clusters.* **predicted** *iterable*: the predicted clusters.* **allow_additional_items** *?bool* [`False`]: Whether to allow additional itemsthat don't exist in truth clusters to be found in predicted ones. Thoseadditional items will then be ignored when computing the metrics insteadof raising an error when found.### Graph#### floatsam_sparsificationFunction using an iterative algorithm to try and find the best weightthreshold to apply to trim the given graph's edges while keeping theunderlying community structures.It works by iteratively increasing the threshold and stopping as soon asa significant connected component starts to drift away from the principalone.This is basically a very naive gradient descent with a very naive costfunction but it works decently for typical cases.*Arguments** **graph** *nx.Graph*: Graph to sparsify.* **starting_treshold** *?float* [`0.0`]: Starting similarity threshold.* **learning_rate** *?float* [`0.05`]: How much to increase the thresholdat each step of the algorithm.* **max_drifter_size** *?int*: Max size of component to detach itselffrom the principal one before stopping the algorithm. If notprovided it will default to the logarithm of the graph's totalnumber of nodes.* **weight** *?str* [`weight wrt networkx conventions`]: Name of the weight attribute.* **remove_edges** *?bool* [`False`]: Whether to remove edges from the graphhaving a weight less than found threshold or not. Note that if`True`, this will mutate the given graph.#### monopartite_projectionFunction computing a monopartite projection of the given bipartite graph.This projection can be basic and create a weighted edge each time two nodesin target partition share a common neighbor. Or it can be weighted andfiltered using a similarity metric such as Jaccard or cosine similarity,for instance.*Arguments** **bipartite** *nx.Graph*: Target bipartite graph.* **project** *str*: Name of the partition to project.* **part** *?str* [`bipartite`]: Name of the node attribute on which thegraph partition is built e.g. &quot;color&quot; or &quot;type&quot; etc.* **weight** *?str* [`weight`]: Name of the weight edge attribute.* **metric** *?str* [`None`]: Metric to use. If `None`, the basic projectionwill be returned. Also accepts `jaccard`, `overlap`, `dice`,`cosine` or `binary_cosine`.* **threshold** *?float* [`None`]: Optional similarity threshold under whichedges won't be added to the monopartite projection.* **use_topology** *?bool*: Whether to use the bipartite graph'stopology to attempt a subquadratic time projection. Intuitively,this works by not computing similarities of all pairs of nodes butonly of pairs of nodes that share at least a common neighbor.It generally works better than the quadratic approach but cansometimes hurt your performance by losing time on graph traversalswhen your graph is very dense.* **bipartition_check** *?bool*: This function will start by checkingwhether your graph is bipartite because it can get stuck in aninfinite loop if given graph is not truly bipartite. Be sure todisable this kwarg if you know beforehand that your graph isbipartite and for better performance.### Keyers#### omission_keyFunction returning a string's omission key which is constructed thusly:1. First we record the string's set of consonant in an order   where most frequently mispelled consonants will be last.2. Then we record the string's set of vowels in the order of   first appearance.This key is very useful when searching for mispelled strings becauseif sorted using this key, similar strings will be next to each other.*Arguments** **string** *str*: The string to encode.#### skeleton_keyFunction returning a string's skeleton key which is constructed thusly:1. The first letter of the string2. Unique consonants in order of appearance3. Unique vowels in order of appearanceThis key is very useful when searching for mispelled strings becauseif sorted using this key, similar strings will be next to each other.*Arguments** **string** *str*: The string to encode.### Metrics#### cosine_similarityFunction computing the cosine similarity of the given sequences.Runs in O(n), n being the sum of A &amp; B's sizes.*Arguments** **A** *iterable*: First sequence.* **B** *iterable*: Second sequence.#### sparse_cosine_similarityFunction computing cosine similarity on sparse weighted sets representedas python dicts.Runs in O(n), n being the sum of A &amp; B's sizes.```pythonfrom fog.metrics import sparse_cosine_similarity# Basicsparse_cosine_similarity({'apple': 34, 'pear': 3}, {'pear': 1, 'orange': 1})&gt;&gt;&gt; ~0.062```*Arguments** **A** *Counter*: First weighted set.* **B** *Counter*: Second weighted set.#### sparse_dot_productFunction used to compute the dotproduct of sparse weighted sets representedby python dicts.Runs in O(n), n being the size of the smallest set.*Arguments** **A** *Counter*: First weighted set.* **B** *Counter*: Second weighted set.#### binary_cosine_similarityFunction computing the binary cosine similarity of the given sequences.Runs in O(n), n being the size of the smallest set.*Arguments** **A** *iterable*: First sequence.* **B** *iterable*: Second sequence.#### sparse_binary_cosine_similarityFunction computing binary cosine similarity on sparse vectors representedas python sets.Runs in O(n), n being the size of the smaller set.*Arguments** **A** *Counter*: First set.* **B** *Counter*: Second set.#### dice_coefficientFunction computing the Dice coefficient. That is to say twice the size ofthe intersection of both sets divided by the sum of both their sizes.Runs in O(n), n being the size of the smallest set.```pythonfrom fog.metrics import dice_coefficient# Basicdice_coefficient('context', 'contact')&gt;&gt;&gt; ~0.727```*Arguments** **A** *iterable*: First sequence.* **B** *iterable*: Second sequence.#### jaccard_similarityFunction computing the Jaccard similarity. That is to say the intersectionof input sets divided by their union.Runs in O(n), n being the size of the smallest set.```pythonfrom fog.metrics import jaccard_similarity# Basicjaccard_similarity('context', 'contact')&gt;&gt;&gt; ~0.571```*Arguments** **A** *iterable*: First sequence.* **B** *iterable*: Second sequence.#### weighted_jaccard_similarityFunction computing the weighted Jaccard similarity.Runs in O(n), n being the sum of A &amp; B's sizes.```pythonfrom fog.metrics import weighted_jaccard_similarity# Basicweighted_jaccard_similarity({'apple': 34, 'pear': 3}, {'pear': 1, 'orange': 1})&gt;&gt;&gt; ~0.026```*Arguments** **A** *Counter*: First weighted set.* **B** *Counter*: Second weighted set.#### overlap_coefficientFunction computing the overlap coefficient of the given sets, i.e. the sizeof their intersection divided by the size of the smallest set.Runs in O(n), n being the size of the smallest set.*Arguments** **A** *iterable*: First sequence.* **B** *iterable*: Second sequence.</longdescription>
</pkgmetadata>