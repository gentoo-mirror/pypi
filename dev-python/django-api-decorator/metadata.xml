<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;h1 align=&quot;center&quot;&gt;  Django API Decorator&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;  A collection of tools to build function based Django APIs.&lt;/p&gt;&gt; **Warning**&gt; This project is still in early development. Expect breaking changes.## InstallationDjango API Decorator can be installed from[PyPI](https://pypi.org/project/django-api-decorator):`pip install django-api-decorator`## UsageThe main interface of this library is the `@api` decorator. This handles inputand output from your view, according to type annotations on the view. Pydanticis used to handle most of the encoding and decoding, but you are not limited touse pydantic models for your types. You can use any type supported by pydantic,from simple types to dataclasses and typed dicts.Here's a simple example:```python@api(method=&quot;GET&quot;)def list_some_numbers(request: HttpRequest) -&gt; list[int]:    return [1, 2, 3, 4]```Under the hood the `@api` decorator will encode the list of numbers ot JSON andwrap it up in a response object for Django to handle like any other response.You can also specify query parameters, that will be decoded according to thespecified type annotations:```python@api(method=&quot;GET&quot;, query_params=[&quot;count&quot;])def list_some_numbers(request: HttpRequest, count: int) -&gt; list[int]:    return [random.randint(0, 10) for _ in range(count)]```Here the decorator will extract the `count` query paramter from the request andmake sure it's a valid integer.The decorator can also decode the request body for you:```python@api(method=&quot;POST&quot;)def sum_of_numbers(request: HttpRequest, body: list[int]) -&gt; int:    return sum(body)```The views produced by the decorator are plain Django views and should be addedin your urls module just like any other view:```pythonurlpatterns = [    path(&quot;/api/numbers/&quot;, list_some_numbers, name=&quot;list-some-numbers&quot;),]```If you want to handle multiple methods on the same url a `method_router` helperfunction is provided, which can be used like this:```pythonurlpatterns = [    path(        &quot;/api/numbers/&quot;,        method_router(            GET=list_some_numbers,            POST=...        ),        name=&quot;list-some-numbers&quot;,    ),]```## OpenAPI specificationThis library can also generate an OpenAPI specification from your views. Thisis done by inspecting the urlpatterns of the Django project, finding all viewsusing the `@api` decorator. The schema for the specification is generated usingpydantic, so for details about how different types are treated see [Pydantic'sdocumentation](https://docs.pydantic.dev/latest/usage/json_schema/).The specification is generated using the `generate_api_schemas` managementcommand.</longdescription>
</pkgmetadata>