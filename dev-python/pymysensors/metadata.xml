<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pymysensors [![Build Status][build-badge]][build]Python API for talking to a [MySensors gateway](http://www.mysensors.org/). Currently supports serial protocol v1.4, v1.5, v2.0 - v2.2. Not all features of v2.x are implemented yet.- Supports smartsleep with serial API v2.x.- Supports the MQTT client gateway with serial API v2.x.- Supports OTA updates, for both [DualOptiboot](https://github.com/mysensors/DualOptiboot) and [MYSBootloader](https://github.com/mysensors/MySensorsBootloaderRF24) bootloaders.- All gateway instances, serial, tcp (ethernet) or mqtt will run in separate threads.- As an alternative to running the gateway in its own thread, there are experimental implementations of all gateways using asyncio.## Requirementspymysensors requires Python 3.7+.## InstallationYou can easily install it from PyPI:```pip3 install pymysensors```## UsageCurrently the API is best used by implementing a callback handler```pyimport mysensors.mysensors as mysensorsdef event(message):    &quot;&quot;&quot;Callback for mysensors updates.&quot;&quot;&quot;    print('sensor_update ' + str(message.node_id))GATEWAY = mysensors.SerialGateway('/dev/ttyACM0', event)GATEWAY.start()```In the above example pymysensors will call &quot;event&quot; whenever a node in the Mysensors network has been updated. The message passed to the callback handler has the following data:```txtMessage    gateway - the gateway instance    node_id - the sensor node identifier    child_id - the child sensor id    type - the message type, for example &quot;set&quot; or &quot;presentation&quot; (int)    ack - True is message was an ACK, false otherwise (0 or 1)    sub_type - the message sub_type (int)    payload - the payload of the message (string)```_Note: The content of the sub_type differs according to the context. In presentation messages, the sub_type denotes S_TYPE data (such as S_INFO). In 'set' and 'req' messages the sub_type denotes V_TYPE data (such as V_TEXT)._Symbolic names for the Message types and sub_types are defined in the protocol version-specific const_X.py files.The data structure of a gateway and it's network is described below.```txtSerialGateway/TCPGateway/MQTTGateway    sensors - a dict containing all nodes for the gateway; node is of type SensorSensor - a sensor node    children - a dict containing all child sensors for the node    sensor_id - node id on the MySensors network    type - 17 for node or 18 for repeater    sketch_name    sketch_version    battery_level    protocol_version - the mysensors protocol version used by the nodeChildSensor - a child sensor    id - child id on the parent node    type - data type, S_HUM, S_TEMP etc.    description - the child description sent when presenting the child    values - a dictionary of values (V_HUM, V_TEMP, etc.)```Getting the type and values of node 23, child sensor 4 would be performed as follows:```pys_type = GATEWAY.sensors[23].children[4].typevalues = GATEWAY.sensors[23].children[4].values```Similarly, printing all the sketch names of the found nodes could look like this:```pyfor node in GATEWAY.sensors.values():    print(node.sketch_name)```Getting a child object inside the event function could be:```py    if GATEWAY.is_sensor(message.node_id, message.child_id):        child = GATEWAY.sensors[message.node_id].children[message.child_id]    else:        print(&quot;Child not available yet.&quot;)```To update a node child sensor value and send it to the node, use the set_child_value method in the Gateway class:```py# To set sensor 1 (int), child 1 (int), sub-type V_LIGHT (= 2) (int), with value 1.GATEWAY.set_child_value(1, 1, 2, 1)```### PersistenceWith persistence mode on, you can restart the gateway withouthaving to restart each individual node in your sensor network. To enable persistence mode, the keyword argument `persistence`in the constructor should be True. A path to the config filecan be specified as the keyword argument `persistence_file`. The file type (.pickle or .json) will set which persistence protocol to use, pickle or json. JSON files can be read using a normal text editor. Saving to the persistence file will be done on a schedule every 10 seconds if an update has been done since the last save. Make sure you start the persistence saving before starting the gateway.```pyGATEWAY.start_persistence()```### Protocol versionSet the keyword argument `protocol_version` to set which version of the MySensors serial API to use. The default value is `'1.4'`. Set the `protocol_version` to the version you're using.### Serial gatewayThe serial gateway also supports setting the baud rate, read timeout and reconnect timeout.```pyimport mysensors.mysensors as mysensorsdef event(message):    &quot;&quot;&quot;Callback for mysensors updates.&quot;&quot;&quot;    print(&quot;sensor_update &quot; + str(message.node_id))GATEWAY = mysensors.SerialGateway(  '/dev/ttyACM0', baud=115200, timeout=1.0, reconnect_timeout=10.0,  event_callback=event, persistence=True,  persistence_file='some_folder/mysensors.pickle', protocol_version='2.2')GATEWAY.start_persistence() # optional, remove this line if you don't need persistence.GATEWAY.start()```There are two other gateway types supported besides the serial gateway: the tcp-ethernet gateway and the MQTT gateway.### TCP ethernet gatewayThe ethernet gateway is initialized similar to the serial gateway. The ethernet gateway supports setting the tcp host port, receive timeout and reconnect timeout, besides the common settings and the host ip address.```pyGATEWAY = mysensors.TCPGateway(  '127.0.0.1', port=5003, timeout=1.0, reconnect_timeout=10.0,  event_callback=event, persistence=True,  persistence_file='some_folder/mysensors.pickle', protocol_version='1.4')```### MQTT gatewayThe MQTT gateway requires MySensors serial API v2.0 or greater and the MQTT client gateway example sketch loaded in the gateway device. The gateway also requires an MQTT broker and a python MQTT client interface to the broker. See [mqtt.py](https://github.com/theolind/pymysensors/blob/master/mqtt.py) for an example of how to implement this and initialize the MQTT gateway.### Over the air (OTA) firmware updatesCall `Gateway` method `update_fw` to set one or more nodes for OTAfirmware update. The method takes three positional arguments and onekeyword argument. The first argument should be the node id of the node toupdate. This can also be a list of many node ids. The next two arguments shouldbe integers representing the firmware type and version. The keyword argument isoptional and should be a path to a hex file with the new firmware.```pyGATEWAY.update_fw([1, 2], 1, 2, fw_path='/path/to/firmware.hex')```After the `update_fw` method has been called the node(s) will be requestedto restart when pymysensors Gateway receives the next set message. Afterrestart and during the MySensors `begin` method, the node will send a firmwareconfig request. The pymysensors library will respond to the config request. Ifthe node receives a proper firmware config response it will send a firmwarerequest for a block of firmware. The pymysensors library will handle this andsend a firmware response message. The latter request-response conversation willcontinue until all blocks of firmware are sent. If the CRC of the transmittedfirmware match the CRC of the firmware config response, the node will restartand load the new firmware.### Gateway idThe gateway method `get_gateway_id` will try to return a unique id for thegateway. This will be the serial number of the usb device for serial gateways,the mac address of the connected gateway for tcp gateways or the publish topicprefix (in_prefix) for mqtt gateways.### Connection callbacksIt's possible to register two optional callbacks on the gateway that are calledwhen the connection is made and when the connection is lost to the gatewaydevice. Both callbacks should accept a gateway parameter, which is the gatewayinstance. The connection lost callback should also accept a second parameterfor possible connection error exception argument. If connection was lostwithout error, eg when disconnecting, the error argument will be `None`.**NOTE:**The MQTT gateway doesn't support these callbacks since the connection to theMQTT broker is handled outside of pymysensors.```pydef conn_made(gateway):  &quot;&quot;&quot;React when the connection is made to the gateway device.&quot;&quot;&quot;  passGATEWAY.on_conn_made = conn_madedef conn_lost(gateway, error):  &quot;&quot;&quot;React when the connection is lost to the gateway device.&quot;&quot;&quot;  passGATEWAY.on_conn_lost = conn_lost```### Async gatewayThe serial, TCP and MQTT gateways now also have versions that support asyncio. Use the`AsyncSerialGateway` class, `AsyncTCPGateway` class or `AsyncMQTTGateway` class to make a gateway thatuses asyncio. The following public methods are coroutines in the async gateway:- get_gateway_id- start_persistence- start- stop- update_fwSee [async_main.py](https://github.com/theolind/pymysensors/blob/master/async_main.py) for an example of how to use this gateway.## DevelopmentInstall the packages needed for development.```shpip install -r requirements_dev.txt```Use the Makefile to run common development tasks.```shmake```### Code formattingWe use black code formatter to automatically format the code.```shblack ./```### ReleaseSee the [release instructions](RELEASE.md).[build-badge]: https://github.com/theolind/pymysensors/workflows/Test/badge.svg[build]: https://github.com/theolind/pymysensors/actions</longdescription>
</pkgmetadata>