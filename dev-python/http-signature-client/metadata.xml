<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># http-signature-client  [![CircleCI](https://circleci.com/gh/michalc/python-http-signature-client.svg?style=shield)](https://circleci.com/gh/michalc/python-http-signature-client) [![Test Coverage](https://api.codeclimate.com/v1/badges/fcf6ed3ac0c04d3878a8/test_coverage)](https://codeclimate.com/github/michalc/python-http-signature-client/test_coverage)Utility function with an HTTP client agnostic Python implementation of the client side of the [IETF draft &quot;Signing HTTP Messages&quot;](https://tools.ietf.org/html/draft-ietf-httpbis-message-signatures-00). No dependencies other than the standard library, but [cryptography](https://github.com/pyca/cryptography) would typically be required in client code to load a private key.See [http-signature-server](https://github.com/michalc/python-http-signature-server) for a compatible server-side implementation.## Installation```pythonpip install http-signature-client```## Usage```pythonfrom http_signature_client import sign_headersdef sign(data):    # Return a signature of `data`, for example using a private keysigned_headers = sign_headers(key_id, sign, method, path, headers_to_sign)```## Recipe: HTTPX with PEM-encoded private key and SHA-512 body digest```pythonfrom base64 import b64encodeimport hashlibfrom cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives.serialization import load_pem_private_keyimport httpxfrom http_signature_client import sign_headersclass HttpSignature(httpx.Auth):    requires_request_body = True    def __init__(self, key_id, pem_private_key):        self.key_id = key_id        self.private_key = load_pem_private_key(            pem_private_key, password=None, backend=default_backend())    def auth_flow(self, request):        body_sha512 = b64encode(hashlib.sha512(r.content).digest()).decode('ascii')        headers_to_sign = tuple(request.headers.items()) + (('digest', f'SHA512={body_sha512}'),)        request.headers = httpx.Headers(sign_headers(            self.key_id, self.private_key.sign, request.method,            request.url.full_path, headers_to_sign))        yield r# In real cases, take credentials from environment variables/secret storeresponse = httpx.post('https://postman-echo.com/post', data=b'The bytes', auth=HttpSignature(    key_id='my-key',    pem_private_key= \        b'-----BEGIN PRIVATE KEY-----\n' \        b'MC4CAQAwBQYDK2VwBCIEINQG5lNt1bE8TZa68mV/WZdpqsXaOXBHvgPQGm5CcjHp\n' \        b'-----END PRIVATE KEY-----\n',    ))```## Recipe: Python requests with PEM-encoded private key and SHA-512 body digest```pythonfrom base64 import b64encodeimport hashlibfrom cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives.serialization import load_pem_private_keyimport requestsimport urllib3from http_signature_client import sign_headersdef HttpSignature(key_id, pem_private_key):    private_key = load_pem_private_key(            pem_private_key, password=None, backend=default_backend())    def sign(r):        body_sha512 = b64encode(hashlib.sha512(r.body).digest()).decode('ascii')        headers_to_sign = tuple(r.headers.items()) + (('digest', f'SHA512={body_sha512}'),)        parsed_url = urllib3.util.url.parse_url(r.path_url)        path = parsed_url.path + (f'?{parsed_url.query}' if parsed_url.query else '')        r.headers = dict(sign_headers(            key_id, private_key.sign, r.method, path, headers_to_sign))        return r    return sign# In real cases, take credentials from environment variables/secret storeresponse = requests.post('https://postman-echo.com/post', data=b'The bytes', auth=HttpSignature(    key_id='my-key',    pem_private_key= \        b'-----BEGIN PRIVATE KEY-----\n' \        b'MC4CAQAwBQYDK2VwBCIEINQG5lNt1bE8TZa68mV/WZdpqsXaOXBHvgPQGm5CcjHp\n' \        b'-----END PRIVATE KEY-----\n',    ))```## Recipe: Create an Ed25519 public/private key pair```pythonfrom cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKeyfrom cryptography.hazmat.primitives.serialization import Encoding, NoEncryption, PrivateFormat, PublicFormatprivate_key = Ed25519PrivateKey.generate()print(private_key.private_bytes(encoding=Encoding.PEM, format=PrivateFormat.PKCS8, encryption_algorithm=NoEncryption()))print(private_key.public_key().public_bytes(encoding=Encoding.PEM, format=PublicFormat.SubjectPublicKeyInfo))```## API### Parameters- `key_id` - The keyId parameter sent with the signature. Typically, the server treats this as the claimed identity of the client.- `sign` - A function that signs the request bytes once canonicalised. Typically, this would be a function that uses a private key.- `method` - The HTTP method of the request, such as `GET` or `POST`.- `path` - The full path of the request, including any query string.- `headers_to_sign` - A tuple of (key, value) pairs of HTTP headers to sign.- `headers_to_ignore` - A `frozenset` of HTTP header names to _not_ be signed, even if passed in `headers_to_sign`. These default to hop-by-hop-headers that are typically set by intermediaries.### ReturnsThe `headers_to_sign` argument concatanated with an `signature` header containing the HTTP signature.## What's implementedA deliberate subset of the signature algorithm is implemented:- the `(request-target)` pseudo-header is sent and signed [to allow the server to verify the method and path];- the `created` parameter is sent and signed as the `(created)` pseudo-header [to allow the server to decide to reject if the skew is too large];- the `headers` parameter is sent and signed [to allow the server to verify headers and pseudo-headers];- the `expires` parameter is _not_ sent [the server can decide this using the created parameter];- the `algorithm` parameter is _not_ sent [it should not be used by the server to choose the algorithm].The `(request-target)` and `(created)` pseudo-headers are always prepended to the list of real HTTP headers before canonicalisation.</longdescription>
</pkgmetadata>