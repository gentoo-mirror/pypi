<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># meteoblue Python Dataset SDK[![PyPI version](https://badge.fury.io/py/meteoblue-dataset-sdk.svg)](https://badge.fury.io/py/meteoblue-dataset-sdk)This library simplifies access to the [meteoblue dataset API](https://docs.meteoblue.com/en/apis/environmental-data/dataset-api).In order to use this library you need a meteoblue API key.Features:- Fetch any dataset from the meteoblue environmental data archive- Transparently integrates job queues to query large datasets- Efficiently transfers data using compressed protobuf messages- Asynchronous interface to query data in parallel- Data can be used as simple floating-point arrays. No further formatting required.- Semantic Versioning: The interface for version 1 is declared stable. Breaking interface changes will be published in version 2.Example notebooks:- [Basic example](example.ipynb)- [Using model data, creating graphs and maps](example_datasets.ipynb)- [Using measurement data](example_measurements.ipynb)## Installation- Ensure that you are using at least Python 3.7 with `python --version` (Sometimes `python3`)- Install the module with `pip install 'meteoblue_dataset_sdk &gt;=1.0,&lt;2.0'` (Sometimes `pip3`)This module will also install the following dependencies automatically:- aiohttp &gt;=3.6,&lt;4- protobuf &gt;=3.0,&lt;4## UsageSee [main.py](./main.py) for a working example. To generate the query JSON it is highly recommended to use the [dataset API web interfaces](https://docs.meteoblue.com/en/apis/environmental-data/web-interfaces).```pythonimport meteoblue_dataset_sdkimport logging# Display information about the current download statelogging.basicConfig(level=logging.INFO)query = {    &quot;units&quot;: {        &quot;temperature&quot;: &quot;C&quot;,        &quot;velocity&quot;: &quot;km/h&quot;,        &quot;length&quot;: &quot;metric&quot;,        &quot;energy&quot;: &quot;watts&quot;,    },    &quot;geometry&quot;: {        &quot;type&quot;: &quot;MultiPoint&quot;,        &quot;coordinates&quot;: [[7.57327, 47.558399, 279]],        &quot;locationNames&quot;: [&quot;Basel&quot;],    },    &quot;format&quot;: &quot;protobuf&quot;,    &quot;timeIntervals&quot;: [&quot;2019-01-01T+00:00/2019-01-01T+00:00&quot;],    &quot;timeIntervalsAlignment&quot;: &quot;none&quot;,    &quot;queries&quot;: [        {            &quot;domain&quot;: &quot;NEMSGLOBAL&quot;,            &quot;gapFillDomain&quot;: None,            &quot;timeResolution&quot;: &quot;hourly&quot;,            &quot;codes&quot;: [{&quot;code&quot;: 11, &quot;level&quot;: &quot;2 m above gnd&quot;}],        }    ],}client = meteoblue_dataset_sdk.Client(apikey=&quot;xxxxxx&quot;)result = client.query_sync(query)# result is a structured object containing timestamps and datatimeInterval = result.geometries[0].timeIntervals[0]data = result.geometries[0].codes[0].timeIntervals[0].dataprint(timeInterval)# start: 1546300800# end: 1546387200# stride: 3600```NOTE: `timeInterval.end` is the first timestamp that is not included anymore in the time interval.If your code is using `async/await`, you should use `await client.query()` instead of `client.query_sync()`. Asynchronous IO is essential for modern webserver frameworks like Flask or FastAPI.```pythonclient = meteoblue_dataset_sdk.Client(apikey=&quot;xxxxxx&quot;)result = await client.query(query)```## Caching resultsIf you are training a model and re-run your program multiple times, you can enable caching to store results from the meteoblue dataset SDK on disk. A simple file cache can be enabled with:```pythonimport zlibfrom meteoblue_dataset_sdk.caching import FileCache# Cache results for 1 day (86400 seconds)cache = FileCache(path=&quot;./mb_cache&quot;, max_age=86400, compression_level=zlib.Z_BEST_SPEED)client = meteoblue_dataset_sdk.Client(apikey=&quot;xxxxxx&quot;, cache=cache)```If you want to implement a different cache (e.g. redis or S3), the SDK offers an abstract base class `caching.cache.AbstractCache`. The required methods are listed [here](./meteoblue_dataset_sdk/caching/abstractcache.py).## Working with timestampsTime intervals are encoded as a simple `start`, `end` and `stride` unix timestamps. With just a  view lines of code, timestamps can be converted to an array of datetime objects:```pythonimport datetime as dtprint(timeInterval)# start: 1546300800# end: 1546387200# stride: 3600timerange = range(timeInterval.start, timeInterval.end, timeInterval.stride)timestamps = list(map(lambda t: dt.date.fromtimestamp(t), timerange))```This code works well for regular timesteps like hourly, 3-hourly or daily data. Monthly data is unfortunately not regular, and the API returns timestamps as an string array. The following code takes care of all cases and always returns an array of datetime objects:```pythonimport datetime as dtimport dateutil.parserdef meteoblue_timeinterval_to_timestamps(t):    if len(t.timestrings) &gt; 0:        def map_ts(time):            if &quot;-&quot; in time:                return dateutil.parser.parse(time.partition(&quot;-&quot;)[0])            return dateutil.parser.parse(time)        return list(map(map_ts, t.timestrings))    timerange = range(t.start, t.end, t.stride)    return list(map(lambda t: dt.datetime.fromtimestamp(t), timerange))query = { ... }result = client.query_sync(query)timestamps = meteoblue_timeinterval_to_timestamps(result.geometries[0].timeIntervals[0])```## Working with dataframesTo convert a result from the meteoblue dataset API to pandas dataframe, a few lines of code can help:```pythonimport pandas as pdimport numpy as npdef meteoblue_result_to_dataframe(geometry):    t = geometry.timeIntervals[0]    timestamps = meteoblue_timeinterval_to_timestamps(t)    n_locations = len(geometry.lats)    n_timesteps = len(timestamps)    df = pd.DataFrame(        {            &quot;TIMESTAMP&quot;: np.tile(timestamps, n_locations),            &quot;Longitude&quot;: np.repeat(geometry.lons, n_timesteps),            &quot;Latitude&quot;: np.repeat(geometry.lats, n_timesteps),        }    )    for code in geometry.codes:        name = str(code.code) + &quot;_&quot; + code.level + &quot;_&quot; + code.aggregation        df[name] = list(code.timeIntervals[0].data)    return dfquery = { ... }result = client.query_sync(query)df = meteoblue_result_to_dataframe(result.geometries[0])```## Protobuf formatIn the background, data is transferred using protobuf and defined as [this protobuf structure](./meteoblue_dataset_sdk/Dataset.proto).A 10 year hourly data series for 1 location requires `350 kb` using protobuf, compared to `1600 kb` using JSON. Additionally the meteoblue Python SDK transfers data using gzip which reduces the size to only `87 kb`. More detailed output of the `result` protobuf object:```geometries {  domain: &quot;NEMSGLOBAL&quot;  lats: 47.66651916503906  lons: 7.5  asls: 499.7736511230469  locationNames: &quot;Basel&quot;  nx: 1  ny: 1  timeResolution: &quot;hourly&quot;  timeIntervals {    start: 1546300800    end: 1546387200    stride: 3600  }  codes {    code: 11    level: &quot;2 m above gnd&quot;    unit: &quot;\302\260C&quot;    aggregation: &quot;none&quot;    timeIntervals {      data: 2.890000104904175      data: 2.690000057220459      data: 2.549999952316284      data: 2.380000114440918      data: 2.2699999809265137      data: 2.119999885559082      data: 1.9900000095367432      data: 1.8300000429153442      data: 1.8200000524520874      data: 2.0999999046325684      data: 2.430000066757202      data: 2.9200000762939453      data: 3.7200000286102295      data: 3.930000066757202      data: 3.9100000858306885      data: 3.5299999713897705      data: 3.130000114440918      data: 2.880000114440918      data: 2.6500000953674316      data: 2.4600000381469727      data: 2.2799999713897705      data: 2.0299999713897705      data: 1.690000057220459      data: 1.3799999952316284    }  }}```</longdescription>
</pkgmetadata>