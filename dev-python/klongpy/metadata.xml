<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![Unit Tests](https://github.com/briangu/klongpy/workflows/Unit%20Tests/badge.svg)# KlongPyIf you're intrigued by the world of [array languages](https://en.wikipedia.org/wiki/Array_programming) and love Python's versatility, meet KlongPy. This project marries the two, bringing Klong's elegant, terse syntax and the computational power of array programming to Python.Born from the lineage of the [Klong](https://t3x.org/klong) array language, KlongPy leverages [NumPy](https://numpy.org/), an [Iverson Ghost](https://analyzethedatanotthedrivel.org/2018/03/31/NumPy-another-iverson-ghost/) that traces its roots back to APL, as its runtime target. This paves a relatively seamless path for mapping Klong constructs to NumPy, unleashing the performance benefits of this efficient, data-crunching Python library.The charm of KlongPy? It integrates Python's extensive library ecosystem right into the Klong language. Whether it's feeding your machine learning model with Klong-processed data or mixing and matching Klong with other Python libraries for your data analysis workflow, KlongPy has you covered. And, with [CuPy](https://github.com/cupy/cupy) in play, you have the flexibility of both CPU and GPU backends at your disposal.The project builds upon the work of [Nils M Holm](https://t3x.org), the creator of the Klong language, who has written a comprehensive [Klong Book](https://t3x.org/klong/book.html) for anyone interested in diving deeper. In short, if you're a data scientist, researcher, or just a programming language enthusiast, KlongPy may just be the next thing you want to check out.# OverviewKlongPy is a powerful language for high performance data analysis and distributed computing. Some of its main features include:* __Simplicity__: KlongPy is based on Klong, a concise, expressive, and easy-to-understand array programming language. Its simple syntax and rich feature set make it an excellent tool for data scientists and engineers.* __Speed__: KlongPy is designed for high-speed computing, enabling you to process large data sets quickly and efficiently. Its efficient internal mechanisms allow for rapid execution of operations on arrays of data.* __Inter-Process Communication (IPC)__: KlongPy has built-in support for IPC, enabling easy communication between different processes and systems. You can create remote function proxies, allowing you to execute functions on a remote server as if they were local functions. This powerful feature facilitates distributed computing tasks.* __Array Programming__: KlongPy supports array programming, which makes it a great tool for mathematical and scientific computing. You can manipulate entire arrays of data at once, enabling efficient data analysis and manipulation.* __Compatibility__: KlongPy is designed to be compatible with Python, allowing you to leverage existing Python libraries and frameworks in conjunction with KlongPy. This seamless integration enhances KlongPy's usability and adaptability.* __Web server__: Includes a web server, making it easy to build sites backed by KlongPy capabilities.* __Timers__: Includes periodic timer facility to periodically perform tasks.At its heart, KlongPy is about infusing Python's flexibility with the compact Klong array language, allowing you to tap into the performance of NumPy while writing code that's concise and powerful. Consider this simple Klong expression that computes an array's average: (+/a)%#a. Decoded, it means &quot;sum of 'a' divided by the length of 'a'&quot;, as read from right to left.Below, we define the function 'avg' and apply it to the array of 1 million integers (as defined by !1000000)Let's try this in the KlongPy REPL:```Bash$ rlwrap kgpyWelcome to KlongPy REPL v0.3.78author: Brian Guarracirepo  : https://github.com/briangu/klongpycrtl-d or ]q to quit?&gt; avg::{(+/x)%#x}:monad?&gt; avg(!1000000)499999.5```Now let's time it (first, right it once, then 100 times):```?&gt; ]T avg(!1000000)total: 0.0032962500117719173 per: 0.0032962500117719173?&gt; ]T:100 avg(!1000000)total: 0.10882879211567342 per: 0.0010882879211567343```We can also import Python modules to use directly in Klong language.  Here we import the standard Python math library and redefine avg to use 'fsum':```?&gt; .py(&quot;math&quot;)1?&gt; favg::{fsum(x)%#x}:monad?&gt; favg(!1000000)499999.5```Notice that using fsum is slower than using Klong '+/'.  This is because the '+/' operation is vectorized while fsum is not.```?&gt; ]T favg(!1000000)total: 0.050078875152394176 per: 0.050078875152394176?&gt; ]T:100 favg(!1000000)total: 2.93945804098621 per: 0.029394580409862103```To use KlongPy within Python, here's a basic outline:```pythonfrom klongpy import KlongInterpreter# instantiate the KlongPy interpeterklong = KlongInterpreter()# define average function in Klong (Note the '+/' (sum over) uses np.add.reduce under the hood)klong('avg::{(+/x)%#x}')# create a billion random uniform values [0,1)data = np.random.rand(10**9)# reference the 'avg' function in Klong interpeter and call it directly from Python.r = klong['avg'](data)print(f&quot;avg={np.round(r,6)}&quot;)```And let's run a performance comparison between CPU and GPU backends:```pythonimport timefrom klongpy.backend import npfrom klongpy import KlongInterpreterklong = KlongInterpreter()klong('avg::{(+/x)%#x}')data = np.random.rand(10**9)start = time.perf_counter_ns()r = klong['avg'](data)stop = time.perf_counter_ns()print(f&quot;avg={np.round(r,6)} in {round((stop - start) / (10**9), 6)} seconds&quot;)```Run (CPU)    $ python3 tests/perf_avg.py    avg=0.5 in 0.16936 secondsRun (GPU)    $ USE_GPU=1 python3 tests/perf_avg.py    avg=0.500015 in 0.027818 seconds# Python integrationSeamlessly blending Klong and Python is the cornerstone of KlongPy, enabling you to utilize each language where it shines brightest. For instance, you can integrate KlongPy into your ML/Pandas workflows, or deploy it as a powerhouse driving your website backend.The charm of KlongPy lies in its dictionary-like interpreter that hosts the current KlongPy state, making it incredibly simple to extend KlongPy with custom functions and shuttle data in and out of the interpreter.Imagine your data processed elsewhere, just set it into KlongPy and watch as the Klong language works its magic, accessing and manipulating your data with effortless ease. Even more, Python lambdas or functions can directly be exposed as Klong functions, adding an array of powerful tools to your Klong arsenal.KlongPy indeed is a force multiplier, amplifying the power of your data operations.## Function exampleCall a Python function from Klong:```pythonfrom klongpy import KlongInterpreterklong = KlongInterpreter()klong['f'] = lambda x, y, z: x*1000 + y - zr = klong('f(3; 10; 20)')assert r == 2990```and vice versa, you can call a Klong function from Python:```pythonfrom klongpy import KlongInterpreterklong = KlongInterpreter()klong(&quot;f::{(x*1000) + y - z}&quot;)r = klong['f'](3, 10, 20)assert r == 2990```## Data exampleSince the Klong interpreter context is dictionary-like, you can store values there for access in Klong:```pythondata = np.arange(10*9)klong['data'] = datar = klong('1+data')assert r == 1 + data```Variables may be directly retrieved from KlongPy context:```pythonklong('Q::1+data')Q = klong['Q']print(Q)```## Python library accessPython functions, including lambdas, can be easily added to support common operations.  In order to be consistent with Klong language, the paramters of Python functions may have at most three paramters and they must be x, y, and z.```Pythonfrom datetime import datetimefrom klongpy import KlongInterpreterklong = KlongInterpreter()klong['strptime'] = lambda x: datetime.strptime(x, &quot;%d %B, %Y&quot;)klong(&quot;&quot;&quot;    a::strptime(&quot;21 June, 2018&quot;)    .p(a)    d:::{};d,&quot;timestamp&quot;,a    .p(d)&quot;&quot;&quot;)```prints the following dictionary to the console:```2018-06-21 00:00:00{'timestamp': datetime.datetime(2018, 6, 21, 0, 0)}```You can go one step further and call back into Python from Klong with the result:```Pythonfrom datetime import datetimefrom klongpy import KlongInterpreterklong = KlongInterpreter()klong['strptime'] = lambda x: datetime.strptime(x, &quot;%d %B, %Y&quot;)klong['myprint'] = lambda x: print(f&quot;called from KlongPy: {x}&quot;)klong(&quot;&quot;&quot;    a::strptime(&quot;21 June, 2018&quot;)    myprint(a)    d:::{};d,&quot;timestamp&quot;,a    myprint(d)&quot;&quot;&quot;)```outputs```called from KlongPy: 2018-06-21 00:00:00called from KlongPy: {'timestamp': datetime.datetime(2018, 6, 21, 0, 0)}```## Loading Python Modules directly into KlongPyKlongPy has the powerful ability to load Python modules directly. This can be extremely useful when you want to utilize the functionality offered by various Python libraries, and seamlessly integrate them into your KlongPy programs.  Here is an example of how you can load a Python module into KlongPy:```bash$ rlwrap kgpyWelcome to KlongPy REPL v0.3.76author: Brian Guarracirepo  : https://github.com/briangu/klongpycrtl-d or ]q to quit?&gt; .py(&quot;math&quot;)1?&gt; sqrt(64)8.0?&gt; fsum(!100)4950.0```In order to keep consistency with Klong 3-parameter function rules, KlongPy will attempt to remap loaded functions to use the x,y and z convention.  For example, in the Python math module, fsum is defined as fsum(seq), so KlongPy remaps this to fsum(x) so that it works within the runtime.## Loading Custom Python ModulesCustom modules can be written for KlongPy in the same way as any Python module, the maindifference is that they don't need to be installed (e.g. via pip).Simply create a directory with a __init__.py and appropriate files, as in:```Python# __init__.pyfrom .hello_world import hello``````Python# hello_world.pydef hello():    return &quot;world!&quot;def not_exported():    raise RuntimeError()```Now, you can import the module with the .py command and run the &quot;hello&quot; function.```bash$ rlwrap kgpyWelcome to KlongPy REPL v0.3.76author: Brian Guarracirepo  : https://github.com/briangu/klongpycrtl-d or ]q to quit?&gt; .py(&quot;tests/plugins/greetings&quot;)1?&gt; hello()world!```# Pandas DataFrame integrationThis a work in progress, but it's very interesting to think about what DataFrames look like in Klong since they are basically a dictionary of columns.For now, the following works where we convert a DataFrame into a dictionary of columns:```Pythonfrom klongpy import KlongInterpreterimport pandas as pdimport numpy as npdata = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],        'Age': [25, 30, 35, 40]}df = pd.DataFrame(data)klong = KlongInterpreter()klong['df'] = {col: np.array(df[col]) for col in df.columns}klong('df?&quot;Name&quot;') # ==&gt; ['Alice', 'Bob', 'Charlie', 'David']klong('df?&quot;Age&quot;')  # ==&gt; [25, 30, 35, 40]```# Inter-Process Communication (IPC) CapabilitiesKlongPy has powerful Inter-Process Communication (IPC) features that enable it to connect and interact with remote KlongPy instances. This includes executing commands, retrieving or storing data, and even defining functions remotely. These new capabilities are available via two new functions: .cli() and .clid().## The .cli() FunctionThe .cli() function creates an IPC client. You can pass it either an integer (interpreted as a port on &quot;localhost:&lt;port&gt;&quot;), a string (interpreted as a host address &quot;&lt;host&gt;:&lt;port&gt;&quot;), or a remote dictionary (which shares the network connection and returns a remote function).Use .cli() to evaluate commands on a remote KlongPy server, define functions, perform calculations, or retrieve values. You can also pass it a symbol to retrieve a value or a function from the remote server.Start the IPC server:```bash$ kgpy -s 8888Welcome to KlongPy REPL v0.4.0author: Brian Guarracirepo  : https://github.com/briangu/klongpycrtl-d or ]q to quitRunning IPC server at 8888?&gt;```In a different terminal:```bash$ kgpy?&gt; f::.cli(8888)remote[localhost:8888]:fn?&gt; f(&quot;avg::{(+/x)%#x}&quot;):monad?&gt; f(&quot;avg(!100)&quot;)49.5?&gt; :&quot; Call a remote function and pass a local value (!100)?&gt; data::!100[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]?&gt; f(:avg,,data)49.5```Using remote function proxies, you can reference a remotely defined function and call it as if it were local:```?&gt; q::f(:avg)remote[localhost:8888]:avg:monad?&gt; q(!100)49.5 ```## The .clid() FunctionAs seen in Python interop examples, the KlongPy context is effectively a dictionary.  The .clid() function creates an IPC client that treats the remote KlongPy context as a dictionary, allowing you to set/get values on the remote instance.  Combined with the remote function capabilities, the remote dictionary makes it easy to interact with remote KlongPy instances.Here are some examples:```?&gt; :&quot; Open a remote dictionary using the same connection as f &quot;?&gt; d::.clid(f)remote[localhost:8888]:dict?&gt; :&quot; Add key/value pair :foo -&gt; 2 to remote context &quot;?&gt; d,[:foo 2]?&gt; :&quot; Get the value for :foo key from the remote context &quot;?&gt; d?:foo2?&gt; d,[:bar &quot;hello&quot;]?&gt; d?:barhello?&gt; :&quot; Assign a remote function to :fn &quot;?&gt; d,:fn,{x+1}?&gt; t::d?:fnremote[localhost:8888]:fn:monad?&gt; t(10)11```These powerful capabilities allow for more effective use of distributed computing resources. Please be aware of potential security issues, as you are allowing a remote server to execute potentially arbitrary commands from your client. Always secure your connections and validate your commands to avoid potential attacks.## Remote Function Proxies and EnumerationAnother powerful feature of KlongPy's IPC capabilities is the use of remote function proxies. These function proxies behave as if they were local functions, but are actually executed on a remote server. You can easily create these function proxies using .cli() or .clid(), and then use them as you would any other function.One of the most powerful aspects of these remote function proxies is that they can be stored in an array and then enumerated. When you do this, KlongPy will execute each function in turn with the specified parameters.For example, suppose you have created three remote function proxies:```?&gt; d::.clid(8888)?&gt; d,:avg,{(+/x)%#x}?&gt; d,:sum,{(+/x)}?&gt; d,:max,{(x@&gt;x)@0}?&gt; a = d?:avg?&gt; b = d?:sum?&gt; c = d?:max```You can then call each of these functions with the same parameter by using enumeration:```?&gt; {x@,!100}'[a b c][  49.5 4950.    99. ]```In this example, KlongPy will execute each function with the range 0-99 as a parameter, and then store the results in the results array. The :avg function will calculate the average of the numbers, the :sum function will add them up, and the :max function will return the largest number in the range.This makes it easy to perform multiple operations on the same data set, or to compare the results of different functions. It's another way that KlongPy's IPC capabilities can enhance your data analysis and distributed computing tasks.## Closing Remote Function ProxiesClosing remote connections is done with the .clic() command.  Once it is closed, all proxies that shared that connection are now disconnected as well.```?&gt; f::.cli(8888)?&gt; .clic(f)1```## SynchronizationWhile the IPC server I/O is async, the KlongPy interpreter is single-threaded.  All remote operations are synchronous to make it easy to use remote operations as part of a normal workflow.  Of course, when calling over to another KlongPy instance, you have no idea what state that instance is in, but within the calling instance operations will be sequential.# Web serverKlongPy includes a simple web server module.  It's optional so you need to install the dependencies:```bash$ pip3 install klongpy[web]```The web server allows you to implement KlongPy functions as GET/POST handlers for registered routes.Here's a simple example that lets you fetch and update a data array:```:&quot; Import the Klongpy web module.  Requires pip3 install klongpy[web] first&quot;.py(&quot;klongpy.web&quot;):&quot; Array of data to display&quot;data::[]:&quot; Return the data for a GET method at /&quot;index::{x;data}:&quot; Create the GET route handlers&quot;get:::{}get,&quot;/&quot;,index:&quot; Append the query param q value to data&quot;update::{[p];p::x?&quot;p&quot;;.p(p);data::data,p}:&quot; Create the POST route handlers&quot;post:::{}post,&quot;/p&quot;,update:&quot; Start the web server with the GET and POST handlers&quot;.web(8888;get;post).p(&quot;curl -X POST -d&quot;&quot;p=100&quot;&quot; &quot;&quot;http://localhost:8888/p&quot;&quot;&quot;).p(&quot;curl &quot;&quot;http://localhost:8888&quot;&quot;&quot;)data```Test it out:```bash$ curl &quot;http://localhost:8888&quot;[]$ curl -X POST -d&quot;p=100&quot; &quot;http://localhost:8888/p&quot;[100]$ curl &quot;http://localhost:8888&quot;[100]```# TimerKlongPy includes periodic timer capabilities:```cb::{.p(&quot;hello&quot;)}th::.timer(&quot;greeting&quot;;1;cb)```To stop the timer, it can be closed via:```.timerc(th)```The following example will create a timer which counts to 5 and then terminates the timer by return 0 from the callback.```counter::0u::{counter::counter+1;.p(counter);1}c::{.p(&quot;stopping timer&quot;);0}cb::{:[counter&lt;5;u();c()]}th::.timer(&quot;count&quot;;1;cb)```which displays:```12345stopping timer``# PerformanceThe Klong language is simple, so the overhead is low.  The bulk of the compute time will likely be spent in NumPy doing actual work.Here's a contrived rough benchmark to show the magnitude differences between Python, KlongPy (CPU + GPU) and Numpy (CPU).**Spoiler**: GPU-backed KlongPy is about 790x faster than naive Python and 36x faster than NumPy-backed KlongPy.### Python```pythondef python_vec(number=100):    r = timeit.timeit(lambda: [2 * (1 + x) for x in range(10000000)], number=number)    return r/number```### KlongPy```python# NumPy and CuPy (CuPy is enabled via USE_GPU=1 environment variabledef klong_vec(number=100):    klong = KlongInterpreter()    r = timeit.timeit(lambda: klong(&quot;2*1+!10000000&quot;), number=number)    return r/number```### NumPy (explicit usage)```pythondef NumPy_vec(number=100):    r = timeit.timeit(lambda: np.multiply(np.add(np.arange(10000000), 1), 2), number=number)    return r/number```## Results### CPU (AMD Ryzen 9 7950x)    $ python3 tests/perf_vector.py    Python: 0.369111s    KlongPy USE_GPU=None: 0.017946s    Numpy: 0.017896s    Python / KlongPy =&gt; 20.568334    Numpy / KlongPy =&gt; 0.997245### GPU (Same CPU w/ NVIDIA GeForce RTX 3090)    $ USE_GPU=1 python3 tests/perf_vector.py    Python: 0.364893s    KlongPy USE_GPU=1: 0.000461s    NumPy: 0.017053s    Python / KlongPy =&gt; 790.678069    Numpy / KlongPy =&gt; 36.951443# Installation### CPU    $ pip3 install klongpy### GPU support    Choose your CuPy prebuilt binary or from source.  Note, the ROCM support for CuPy is experimental and likely will have issues.    'cupy' =&gt; build from source    'cuda12x' =&gt; &quot;cupy-cuda12x&quot;    'cuda11x' =&gt; &quot;cupy-cuda11x&quot;    'cuda111' =&gt; &quot;cupy-cuda111&quot;    'cuda110' =&gt; &quot;cupy-cuda110&quot;    'cuda102' =&gt; &quot;cupy-cuda102&quot;    'rocm-5-0' =&gt; &quot;cupy-rocm-5-0&quot;    'rocm-4-3' =&gt; &quot;cupy-rocm-4-3&quot;    $ pip3 install klongpy[cupy]### Everything    $ pip3 install klongpy[cupy,repl]### Develop    $ git clone https://github.com/briangu/klongpy.git    $ cd klongpy    $ python3 setup.py develop# REPLKlongPy has a REPL similar to Klong's REPL.```bash$ pip3 install klongpy[repl]$ rlwrap kgpyWelcome to KlongPy REPLauthor: Brian Guarracirepo  : https://github.com/briangu/klongpycrtl-c to quit?&gt; 1+12&gt;? &quot;hello, world!&quot;hello, world!?&gt; prime::{&amp;/x!:\2+!_x^1%2}:monad?&gt; prime(4)0?&gt; prime(251)1?&gt; ]T prime(251)total: 0.0004914579913020134 per: 0.0004914579913020134```Read about the [prime example here](https://t3x.org/klong/prime.html).# StatusKlongPy aims to be a complete implementation of klong.  It currently passes all of the integration tests provided by klong as well as additional suites.Since CuPy is [not 100% compatible with NumPy](https://docs.cupy.dev/en/stable/user_guide/difference.html), there are currently some gaps in KlongPy between the two backends.  Notably, strings are supported in CuPy arrays so KlongPy GPU support currently is limited to math.Primary ongoing work includes:* Add IPC capabilities so to enable inter-KlongPy commoncation* Actively switch between CuPy and NumPy when incompatibilities are present    * Work on CuPy kernels is in this branch: _cupy_reduce_kernels* Additional syntax error help* Additional tests to    * ensure proper vectorization    * increase Klong grammar coverage* Make REPL (kgpy) compatible with original Klong (kg) REPL# Differences from KlongWhile KlongPy aims to be 100% compatible with Klong language, the KlongPy system has some differences:    * Infinite precision: The main difference in this implementation of Klong is the lack of infinite precision.  By using NumPy we are restricted to doubles.    * Python integration: Most notably, the &quot;.py&quot; command allows direct import of Python modules into the current Klong context.    * IPC - KlongPy will support IPC between KlongPy processes, allowing one KlongPy process to interact with other KlongPy processes over the network.# Related * [Klupyter - KlongPy in Jupyter Notebooks](https://github.com/briangu/klupyter) * [Advent Of Code '22](https://github.com/briangu/aoc/tree/main/22) * [Example Ticker Plant with streaming and dataframes](https://github.com/briangu/kdfs)# Running tests```bashpython3 -m unittest```# Unused operatorsThe following operators are yet to be used:```:! :&amp; :, :&lt; :&gt; :?```# AcknowledgementHUGE thanks to Nils M Holm for his work on Klong and providing the foundations for this interesting project.</longdescription>
</pkgmetadata>