<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># py-smart-gardena[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)[![PyPI version](https://badge.fury.io/py/py-smart-gardena.svg)](https://badge.fury.io/py/py-smart-gardena)[![Build Status](https://travis-ci.org/py-smart-gardena/py-smart-gardena.svg?branch=master)](https://travis-ci.org/py-smart-gardena/py-smart-gardena)[![Updates](https://pyup.io/repos/github/py-smart-gardena/py-smart-gardena/shield.svg)](https://pyup.io/repos/github/py-smart-gardena/py-smart-gardena/)Feel free to join the discord server : [![Support Server](https://img.shields.io/discord/853252789522268180.svg?color=7289da&amp;label=Discord&amp;logo=discord&amp;style=flat-square)](https://discord.gg/59sFjykS)## DescriptionThe **py-smart-gardena** library aims to provide python way to communicate with gardena smart systems andall gardena smart equipment. Configuration of the equipement and inclusion has still to be done using the Gardena application or website.## Support**This project needs your support.**  Gardena equipments are expensive, and I need to buy them in order to add support.If you find this library useful and want to help me support more devices (or if youjust want to reward me for my spent time), you are very welcome !   Your help is very much appreciated.Here are the links if you want to show your support :  &lt;span class=&quot;badge-paypal&quot;&gt;&lt;a href=&quot;https://paypal.me/grmklein&quot; title=&quot;Donate to this project using Paypal&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/paypal-donate-yellow.svg&quot; alt=&quot;PayPal donate button&quot; /&gt;&lt;/a&gt;&lt;/span&gt;Thx for your support !## Requirements*   **Python 3.8+**## Supported devicesFor now, only few devices are supported. I may add new ones in the future :  *   Gateway*   Smart Mower*   Smart water control*   Smart sensor*   Power plugs*   Smart Irrigation control## Account creation in order to have access to Gardena APIGardena requires the creation of an account and an application in order to use their API.You can find how to create such an account and application here : &lt;a href=&quot;https://developer.husqvarnagroup.cloud/docs/getting-started#/docs/getting-started/#3connect-api-to-application&quot;&gt;Account and application creation&lt;/a&gt;## Installation```sh$ pip install py-smart-gardena```## Usage### Data modelThe entrypoint of the library is the the SmartSytem class (in gardena.smart_systempackage).From there, you can get all locations from your account, and for each of theselocations, get the declared devices.All communications are not done directly with the gateway. This library uses a websocket in orderto communicate with gardena systems in order to avoid throttling. There is only one connection to authenticate,and two connections to revoke tokens, everything else is done through websockets.### AuthenticationYou first need to get a client id (also called application key in theAPI documentation) for your personal installation of gardena.  To doso, create an account here : https://developer.husqvarnagroup.cloud/Then you need to create an application, add APIs (Authentication APIand GARDENA smart system API), and copy the application key asexplained here: https://developer.husqvarnagroup.cloud/docs/getting-startedThe library manages the token for you then.An exception is raised if authentication fails.```pythonfrom gardena.smart_system import SmartSystemimport pprintsmart_system = SmartSystem(client_id=&quot;client_id&quot;, client_secret=&quot;client_secret&quot;)await smart_system.authenticate()await smart_system.update_locations()for location in smart_system.locations.values():    await smart_system.update_devices(location)    pprint.pprint(location)    for device in location.devices.values():        pprint.pprint(device)await smart_system.start_ws(smart_system.locations['LOCATION_ID'])```Once authentication is successful, you need to gather locations and devices for the first time and then, you can create start the websocket in order to get updates automatically.### LocationsLocations are automatically retrieved the first time from the API, and then the websocket is used to get updates.Here is the list of the current available fields and methods :```pythonfor location in smart_system.locations.values():    print(&quot;location : &quot; + location.name + &quot;(&quot; + location.id + &quot;)&quot;)```### DevicesDevices are automatically retrieved the first time from the API, and then the websocket is used to get updates. They are stored in each locations. Depending on the function type, you can have diffrents fields.#### Mowers```python    for device in smart_system.locations[&quot;LOCATION_ID&quot;].find_device_by_type(&quot;MOWER&quot;):          print(f&quot;name : {device.name}&quot;)          print(f&quot;id : {device.id}&quot;)          print(f&quot;type : {device.type}&quot;)          print(f&quot;model_type : {device.model_type}&quot;)          print(f&quot;battery_level : {device.battery_level}&quot;)          print(f&quot;battery_state : {device.battery_state}&quot;)          print(f&quot;rf_link_level : {device.rf_link_level}&quot;)          print(f&quot;rf_link_state : {device.rf_link_state}&quot;)          print(f&quot;serial : {device.serial}&quot;)          print(f&quot;activity : {device.activity}&quot;)          print(f&quot;operating_hours : {device.operating_hours}&quot;)          print(f&quot;state : {device.state}&quot;)          print(f&quot;last_error_code : {device.last_error_code}&quot;)```#### Power Socket```python    for device in smart_system.locations[&quot;LOCATION_ID&quot;].find_device_by_type(&quot;POWER_SOCKET&quot;):          print(f&quot;name : {device.name}&quot;)          print(f&quot;id : {device.id}&quot;)          print(f&quot;type : {device.type}&quot;)          print(f&quot;model_type : {device.model_type}&quot;)          print(f&quot;battery_level : {device.battery_level}&quot;)          print(f&quot;battery_state : {device.battery_state}&quot;)          print(f&quot;rf_link_level : {device.rf_link_level}&quot;)          print(f&quot;rf_link_state : {device.rf_link_state}&quot;)          print(f&quot;serial : {device.serial}&quot;)          print(f&quot;activity : {device.activity}&quot;)          print(f&quot;state : {device.state}&quot;)```#### Sensor```python    for device in smart_system.locations[&quot;LOCATION_ID&quot;].find_device_by_type(&quot;SENSOR&quot;):          print(f&quot;name : {device.name}&quot;)          print(f&quot;id : {device.id}&quot;)          print(f&quot;type : {device.type}&quot;)          print(f&quot;model_type : {device.model_type}&quot;)          print(f&quot;battery_level : {device.battery_level}&quot;)          print(f&quot;battery_state : {device.battery_state}&quot;)          print(f&quot;rf_link_level : {device.rf_link_level}&quot;)          print(f&quot;rf_link_state : {device.rf_link_state}&quot;)          print(f&quot;serial : {device.serial}&quot;)          print(f&quot;ambient_temperature : {device.ambient_temperature}&quot;)          print(f&quot;light_intensity : {device.light_intensity}&quot;)          print(f&quot;soil_humidity : {device.soil_humidity}&quot;)          print(f&quot;soil_temperature : {device.soil_temperature}&quot;)```#### Smart irrigation control```python    for device in smart_system.locations[&quot;LOCATION_ID&quot;].find_device_by_type(&quot;SMART_IRRIGATION_CONTROL&quot;):          print(f&quot;name : {device.name}&quot;)          print(f&quot;id : {device.id}&quot;)          print(f&quot;type : {device.type}&quot;)          print(f&quot;model_type : {device.model_type}&quot;)          print(f&quot;battery_level : {device.battery_level}&quot;)          print(f&quot;battery_state : {device.battery_state}&quot;)          print(f&quot;rf_link_level : {device.rf_link_level}&quot;)          print(f&quot;rf_link_state : {device.rf_link_state}&quot;)          print(f&quot;serial : {device.serial}&quot;)          print(f&quot;valve_set_id : {device.valve_set_id}&quot;)          print(f&quot;valve_set_state : {device.valve_set_state}&quot;)          print(f&quot;valve_set_last_error_code : {device.valve_set_last_error_code}&quot;)          for valve in device.valves.values():            print(f&quot;name : {valve['name']}&quot;)            print(f&quot;{valve['name']} - id : {valve['id']}&quot;)            print(f&quot;{valve['name']} - activity : {valve['activity']}&quot;)            print(f&quot;{valve['name']} - state : {valve['state']}&quot;)            print(f&quot;{valve['name']} - last_error_code : {valve['last_error_code']}&quot;)```#### Smart water control```python    for device in smart_system.locations[&quot;LOCATION_ID&quot;].find_device_by_type(&quot;WATER_CONTROL&quot;):          print(f&quot;name : {device.name}&quot;)          print(f&quot;id : {device.id}&quot;)          print(f&quot;type : {device.type}&quot;)          print(f&quot;model_type : {device.model_type}&quot;)          print(f&quot;battery_level : {device.battery_level}&quot;)          print(f&quot;battery_state : {device.battery_state}&quot;)          print(f&quot;rf_link_level : {device.rf_link_level}&quot;)          print(f&quot;rf_link_state : {device.rf_link_state}&quot;)          print(f&quot;serial : {device.serial}&quot;)          print(f&quot;valve_set_id : {device.valve_set_id}&quot;)          print(f&quot;valve_name : {device.valve_name}&quot;)          print(f&quot;valve_id : {device.valve_id}&quot;)          print(f&quot;valve_activity : {device.valve_activity}&quot;)          print(f&quot;valve_state : {device.valve_state}&quot;)```### Using websocketOnce the websocket has been started, everything is managed and the devices are automatically updated once their state change.In order for your to be alerted of such a change, you need to add a callback to the device.This callback will be called each time the device state changed :```pythondef my_callback(device):    print(f&quot;The device {device.name} has been updated !&quot;)device.add_callback(my_callback)```## Development environmentTo install the dev environment, you just have to do, in the source code directory :```sh$ pip install -e .[dev]```</longdescription>
</pkgmetadata>