<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Welcome to Pemi's documentation!================================Pemi is a framework for building testable ETL processes and workflows.  Usersdefine **pipes** that define how to collect, transform, and deliver data.  Pipescan be combined with other pipes to build out complex and modular data pipelines.Testing is a first-class feature of Pemi and comes with a testing API to allow fordescribing test coverage in a manner that is natural for data transformations.`Full documentation on readthedocs &lt;http://pemi.readthedocs.io/en/latest/index.html&gt;`_Install Pemi============.. inclusion-marker-install-pemi-beginPemi can be installed from pip::    pip install pemi.. inclusion-marker-install-pemi-endConcepts and Features=====================.. inclusion-marker-concepts-features-beginPipes-----The principal abstraction in Pemi is the **Pipe**.  A pipe can be composedof **Data Sources**, **Data Targets**, and other **Pipes**.  Whena pipe is executed, it collects data form the data sources, manipulates that data,and loads the results into the data targets.  For example, here's a simple&quot;Hello World&quot; pipe. It takes a list of names in the form of a Pandas DataFrameand returns a Pandas DataFrame saying hello to each of them... code-block:: python    import pandas as pd    import pemi    from pemi.fields import *    class HelloNamePipe(pemi.Pipe):        # Override the constructor to configure the pipe        def __init__(self):            # Make sure to call the parent constructor            super().__init__()            # Add a data source to our pipe - a pandas dataframe called 'input'            self.source(                pemi.PdDataSubject,                name='input',                schema = pemi.Schema(                    name=StringField()                )            )            # Add a data target to our pipe - a pandas dataframe called 'output'            self.target(                pemi.PdDataSubject,                name='output'            )        # All pipes must define a 'flow' method that is called to execute the pipe        def flow(self):            self.targets['output'].df = self.sources['input'].df.copy()            self.targets['output'].df['salutation'] = self.sources['input'].df['name'].apply(                lambda v: 'Hello ' + v            )To use the pipe, we have to create an instance of it::    pipe = HelloNamePipe()and give some data to the source named &quot;input&quot;::    pipe.sources['input'].df = pd.DataFrame({        'name': ['Buffy', 'Xander', 'Willow', 'Dawn']    })+--------+| name   |+========+| Buffy  |+--------+| Xander |+--------+| Willow |+--------+| Dawn   |+--------+The pipe performs the data transformation when the ``flow`` method is called::    pipe.flow()The data target named &quot;output&quot; is then populated::    pipe.targets['output'].df+--------+--------------+| name   | salutation   |+========+==============+| Buffy  | Hello Buffy  |+--------+--------------+| Xander | Hello Xander |+--------+--------------+| Willow | Hello Willow |+--------+--------------+| Dawn   | Hello Dawn   |+--------+--------------+Data Subjects-------------**Data Sources** and **Data Targets** are both types of **DataSubjects**.  A data subject is mostly just a reference to an objectthat can be used to manipulate data.  In the [Pipes](#pipes) exampleabove, we defined the data source called &quot;input&quot; as using the``pemi.PdDataSubject`` class.  This means that this data subject refersto a Pandas DataFrame object.  Calling the `df` method on this data subjectsimply returns the Pandas DataFrame, which can be manipulated in all the waysthat Pandas DataFrames can be manipulated.Pemi supports 3 data subjects natively, but can easily be extended to support others.  The3 supported data subjects are* ``pemi.PdDataSubject`` - Pandas DataFrames* ``pemi.SaDataSubject`` - SQLAlchemy Engines* ``pemi.SparkDataSubject`` - Apache Spark DataFramesSchemas-------A data subject can optionally be associated with a **Schema**.Schemas can be used to validate that the data object of the datasubject conforms to the schema.  This is useful when data is passedfrom the target of one pipe to the source of another because itensures that downstream pipes get the data they are expecting.For example, suppose we wanted to ensure that our data had fields called ``id`` and ``name``.We would define a data subject like::    from pemi.fields import *    ds = pemi.PdDataSubject(        schema=pemi.Schema(            id=IntegerField(),            name=StringField()        )    )If we provide the data subject with a dataframe that does not have a field::    df = pd.DataFrame({        'name': ['Buffy', 'Xander', 'Willow']    })    ds.df = dfThen an error will be raised when the schema is validated (which happens automatically whendata is passed between pipes, as we'll see below)::    ds.validate_schema()    #=&gt; MissingFieldsError: DataFrame missing expected fields: {'id'}We'll also see later that defining a data subject with a schema alsoaids with writing tests.  So while optional, defining data subjectswith an associated schema is highly recommended.Referencing data subjects in pipes^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Data subjects are rarely defined outside the scope of a pipe as donein [Schemas](#schemas).  Instead, they are usually defined in theconstructor of a pipe as in [Pipes](#pipes).  Two methods of the``pemi.Pipe`` class are used to define data subjects: ``source`` and``target``.  These methods allow one to specify the data subject classthat the data subject will use, give it a name, assign a schema, andpass on any other arguments to the specific data subject class.For example, if we were to define a pipe that was meant to use anApache Spark dataframe as a source::    spark_session = ...    class MyPipe(pemi.Pipe):        def __init__(self):            super().__init__()            self.source(                pemi.SparkDataSubject,                name='my_spark_source',                schema=pemi.Schema(                    id=IntegerField(),                    name=StringField()                ),                spark=spark_session            )When ``self.source`` is called, it builds the data subject from the options providedand puts it in a dictionary that is associated with the pipe.  The spark data framecan then be accessed from within the flow method as::            def flow(self):                self.sources['my_spark_source'].dfTypes of Pipes--------------Most user pipes will typically inherit from the main ``pemi.Pipe`` class.  However,the topology of the pipe can classify it according to how it might be used.  Whilethe following definitions can be bent in some ways, they are useful for describingthe purpose of a given pipe.* A **Source Pipe** is a pipe that is used to extract data from some  external system and convert it into a Pemi data subject.  This data  subject is the *target* of the *source* pipe.* A **Target Pipe** is a pipe that is used to take a data subject and  convert it into a form that can be loaded into some external system.  This data subject is the *source* of the *target* pipe.* A **Transformation Pipe** is a pipe that takes one or more data sources,  transforms them, and delivers one more target sources.* A **Job Pipe** is a pipe that is self-contained and does not specify any  source or target data subjects.  Instead, it is usually composed of other  pipes that are connected to each other.Pipe Connections----------------A pipe can be composed of other pipes that are each connected to eachother.  These connections for a directed acyclic graph (DAG).  Whenthen connections between all pipes are executed, the pipes that formthe nodes of the DAG are executed in the order specified by the DAG(in parallel, when possible -- parallel execution is made possibleunder the hood via `Dask graphs&lt;https://dask.pydata.org/en/latest/custom-graphs.html&gt;`_).  The dataobjects referenced by the node pipes' data subjects are passed betweenthe pipes according.As a minimal example showing how connections work, let's definea dummy source pipe that just generates a Pandas dataframe withsome data in it::    class MySourcePipe(pemi.Pipe):        def __init__(self):            super().__init__()            self.target(                pemi.PdDataSubject,                name='main'            )        def flow(self):            self.targets['main'].df = pd.DataFrame({                'id': [1,2,3],                'name': ['Buffy', 'Xander', 'Willow']            })And a target pipe that just prints the &quot;salutation&quot; field::    class MyTargetPipe(pemi.Pipe):        def __init__(self):            super().__init__()            self.source(                pemi.PdDataSubject,                name='main'            )        def flow(self):            for idx, row in self.sources['main'].df.iterrows():                print(row['salutation'])Now we define a job pipe that will connect the dummy source pipe toour hello world pipe and connect that to our dummy target pipe::    class MyJob(pemi.Pipe):        def __init__(self):            super().__init__()            self.pipe(                name='my_source_pipe',                pipe=MySourcePipe()            )            self.connect('my_source_pipe', 'main').to('hello_pipe', 'input')            self.pipe(                name='hello_pipe',                pipe=HelloNamePipe()            )            self.connect('hello_pipe', 'output').to('my_target_pipe', 'main')            self.pipe(                name='my_target_pipe',                pipe=MyTargetPipe()            )        def flow(self):            self.connections.flow()In the flow method we call ``self.connections.flow()``.  This calls the``flow`` method of each pipe defined in the connections graph andtransfers data between them, in the order specified by the DAG.The job pipe can be executed by calling its ``flow`` method::    MyJob().flow()    # =&gt; Hello Buffy    # =&gt; Hello Xander    # =&gt; Hello WillowFurthermore, if you're running this in a Jupyter notebook, you can see a graph of theconnections by running::    import pemi.dot    pemi.dot.graph(MyJob())Referencing pipes in pipes^^^^^^^^^^^^^^^^^^^^^^^^^^Referencing pipes within pipes works the same way as for data sources and targets.For example, if we wanted to run the ``MyJob`` job pipe and then look at thesource of the &quot;hello_pipe&quot;::    job  = MyJob()    job.flow()    job.pipes['hello_pipe'].sources['input'].df.. inclusion-marker-concepts-features-endWhere to go from here=====================`Full documentation on readthedocs &lt;http://pemi.readthedocs.io/en/latest/index.html&gt;`_Contributing============If you want to contribute to the development of Pemi, you'll need to be able to run the testsuite locally.  To get started, copy the example environment file to a file you canedit locally if needed:    &gt;&gt;&gt; cp example.env .envAll of the tests are run inside of a docker container, which you can build using    &gt;&gt;&gt; inv buildOnce the containers are built, spin up the containers to run the tests    &gt;&gt;&gt; inv upAnd then run the tests using something like (you may prefer different pytest options):    &gt;&gt;&gt; inv test --opts=&quot;-s -x -vv --tb=short --color=yes tests&quot;The test container also launches a local Jupyter notebook server.  This can be a convenient tool tohave when developing Pemi.  To access the notebook severs, just visit http://localhost:8890/labin a web browser (the specific port can be configured in the ``.env`` file).Take down the container using    &gt;&gt;&gt; inv down</longdescription>
</pkgmetadata>