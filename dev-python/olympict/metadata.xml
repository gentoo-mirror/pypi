<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Olympict![coverage](https://gitlab.com/gabraken/olympict/badges/master/coverage.svg?job=tests)![status](https://gitlab.com/gabraken/olympict/badges/master/pipeline.svg)![Olympict](https://gitlab.com/gabraken/olympict/-/raw/master/Olympict.png)Based on [olympipe](https://pypi.org/project/olympipe/), this project will make image processing pipelines easy to use using the basic multiprocessing module. This module uses type checking to ensure your data process validity from the start.## Basic image processing pipeline### Loading images from a folder and resize them to a new folder```pythonfrom olympict import ImagePipelinep0 = ImagePipeline.load_folder(&quot;./examples&quot;) # path containing the imagesp1 = p0.resize((150, 250)) # new width, new heightp2 = p1.save_to_folder(&quot;./resized_examples&quot;) # path to save the imagesp2.wait_for_completion() # the code blocks here until all images are processedprint(&quot;Finished resizing&quot;)```### Loading images from a folder and overwrite them with a new size```pythonfrom olympict import ImagePipelinep0 = ImagePipeline.load_folder(&quot;./examples&quot;) # path containing the imagesp1 = p0.resize((150, 250))p2 = p1.save() # overwrite the imagesp2.wait_for_completion()```### Loading images from a folder and resize them keeping the aspect ratio using a padding color```pythonfrom olympict import ImagePipelineblue = (255, 0, 0) # Colors are BGR to match opencv formatp0 = ImagePipeline.load_folder(&quot;./examples&quot;)p1 = p0.resize((150, 250), pad_color=blue)p2 = p1.save() # overwrite the imagesp2.wait_for_completion()```### Load image to make a specific operation```pythonfrom olympict import ImagePipeline, Imgdef operation(image: Img) -&gt; Img:    # set the green channel as a mean of blue and red channels    img[:, :, 1] = (img[:, :, 0] + img[:, :, 2]) / 2    return imgp0 = ImagePipeline.load_folder(&quot;./examples&quot;)p1 = p0.task_img(operation)p2 = p1.save() # overwrite the imagesp2.wait_for_completion()```### Check ongoing operation```pythonfrom olympict import ImagePipeline, Imgdef operation(image: Img) -&gt; Img:    # set the green channel as a mean of blue and red channels    img[:, :, 1] = (img[:, :, 0] + img[:, :, 2]) / 2    return imgp0 = ImagePipeline.load_folder(&quot;./examples&quot;).debug_window(&quot;Raw image&quot;)p1 = p0.task_img(operation).debug_window(&quot;Processed image&quot;)p2 = p1.save() # overwrite the imagesp2.wait_for_completion()```### Load a video and process each individual frame```pythonfrom olympict import VideoPipelinep0 = VideoPipeline.load_folder(&quot;./examples&quot;) # will load .mp4 and .mkv filesp1 = p0.to_sequence() # split each video frame into a basic imagep2 = p1.resize((100, 3), (255, 255, 255)) # resize each image with white paddingp3 = p2.save_to_folder(&quot;./sequence&quot;) # save images individuallyp3.wait_for_completion()img_paths = glob(&quot;./sequence/*.png&quot;) # count imagesprint(&quot;Number of images:&quot;, len(img_paths))```### Complex example with preview windows```pythonimport osfrom random import randintimport reimport timefrom olympict import ImagePipelinefrom olympict.files.o_image import OlympImagedef img_simple_order(path: str) -&gt; int:    number_pattern = r&quot;\d+&quot;    res = re.findall(number_pattern, os.path.basename(path))    return int(res[0])if __name__ == &quot;__main__&quot;:    def wait(x: OlympImage):        time.sleep(0.1)        print(x.path)        return x    def generator():        for i in range(96):            img = np.zeros((256, 256, 3), np.uint8)            img[i, :, :] = (255, 255, 255)            o = OlympImage()            o.path = f'/tmp/{i}.png'            o.img = img            yield o        return    p = (        ImagePipeline(generator())        .task(wait)        .debug_window(&quot;start it&quot;)        .task_img(lambda x: x[::-1, :, :])        .debug_window(&quot;flip it&quot;)        .keep_each_frame_in(1, 3)        .debug_window(&quot;stuttered&quot;)        .draw_bboxes(            lambda x: [                (                    (                        randint(0, 50),                        randint(0, 50),                        randint(100, 200),                        randint(100, 200),                        &quot;change&quot;,                        0.5,                    ),                    (randint(0, 255), 25, 245),                )            ]        )        .debug_window(&quot;bboxed&quot;)    )    p.wait_for_completion()```## /!\ To use Huggingface Models, you must install this package with [hf] extras```bashpoetry add olympict[hf]orpip install olympict[hf]```### Use with Huggingface image classification models```pythonfrom olympict import ImagePipelinefrom olympict.files.o_image import OlympImagedef print_metas(x: OlympImage):    print(x.metadata)    return xif __name__ == &quot;__main__&quot;:    # very important, without this processes will get stuck    from torch.multiprocessing import set_start_method    set_start_method(&quot;spawn&quot;)    (        ImagePipeline.load_folder(&quot;./classif&quot;)        .classify(&quot;google/mobilenet_v2_1.0_224&quot;)        .task(print_metas)    ).wait_for_completion()```This project is still an early version, feedback is very helpful.</longdescription>
</pkgmetadata>