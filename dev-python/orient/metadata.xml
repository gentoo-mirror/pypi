<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>orient======[![](https://github.com/lycantropos/orient/workflows/CI/badge.svg)](https://github.com/lycantropos/orient/actions/workflows/ci.yml &quot;Github Actions&quot;)[![](https://readthedocs.org/projects/orient/badge/?version=latest)](https://orient.readthedocs.io/en/latest &quot;Documentation&quot;)[![](https://codecov.io/gh/lycantropos/orient/branch/master/graph/badge.svg)](https://codecov.io/gh/lycantropos/orient &quot;Codecov&quot;)[![](https://img.shields.io/github/license/lycantropos/orient.svg)](https://github.com/lycantropos/orient/blob/master/LICENSE &quot;License&quot;)[![](https://badge.fury.io/py/orient.svg)](https://badge.fury.io/py/orient &quot;PyPI&quot;)In what follows `python` is an alias for `python3.7` or `pypy3.7`or any later version (`python3.8`, `pypy3.8` and so on).Installation------------Install the latest `pip` &amp; `setuptools` packages versions```bashpython -m pip install --upgrade pip setuptools```### UserDownload and install the latest stable version from `PyPI` repository```bashpython -m pip install --upgrade orient```### DeveloperDownload the latest version from `GitHub` repository```bashgit clone https://github.com/lycantropos/orient.gitcd orient```Install dependencies```bashpython -m pip install -r requirements.txt```Install```bashpython setup.py install```Usage-----```python&gt;&gt;&gt; from ground.base import get_context&gt;&gt;&gt; context = get_context()&gt;&gt;&gt; Contour = context.contour_cls&gt;&gt;&gt; Point = context.point_cls&gt;&gt;&gt; Polygon = context.polygon_cls&gt;&gt;&gt; Segment = context.segment_cls&gt;&gt;&gt; left_bottom = Point(0, 0)&gt;&gt;&gt; right_bottom = Point(4, 0)&gt;&gt;&gt; left_top = Point(0, 4)&gt;&gt;&gt; right_top = Point(4, 4)&gt;&gt;&gt; bottom_segment_midpoint = Point(2, 0)&gt;&gt;&gt; bottom_segment = Segment(left_bottom, right_bottom)&gt;&gt;&gt; from ground.base import Location&gt;&gt;&gt; from orient.planar import point_in_segment&gt;&gt;&gt; point_in_segment(left_bottom, bottom_segment) is Location.BOUNDARYTrue&gt;&gt;&gt; (point_in_segment(bottom_segment_midpoint, bottom_segment) ...  is Location.BOUNDARY)True&gt;&gt;&gt; point_in_segment(right_bottom, bottom_segment) is Location.BOUNDARYTrue&gt;&gt;&gt; point_in_segment(left_top, bottom_segment) is Location.EXTERIORTrue&gt;&gt;&gt; square = Contour([left_bottom, right_bottom, right_top, left_top])&gt;&gt;&gt; from orient.planar import point_in_region&gt;&gt;&gt; point_in_region(left_bottom, square) is Location.BOUNDARYTrue&gt;&gt;&gt; point_in_region(Point(1, 1), square) is Location.INTERIORTrue&gt;&gt;&gt; point_in_region(right_top, square) is Location.BOUNDARYTrue&gt;&gt;&gt; point_in_region(Point(5, 5), square) is Location.EXTERIORTrue&gt;&gt;&gt; main_diagonal = Segment(left_bottom, right_top)&gt;&gt;&gt; from ground.base import Relation&gt;&gt;&gt; from orient.planar import segment_in_region&gt;&gt;&gt; segment_in_region(bottom_segment, square) is Relation.COMPONENTTrue&gt;&gt;&gt; (segment_in_region(Segment(Point(1, 0), Point(5, 0)), square)...  is Relation.TOUCH)True&gt;&gt;&gt; segment_in_region(main_diagonal, square) is Relation.ENCLOSEDTrue&gt;&gt;&gt; (segment_in_region(Segment(Point(1, 1), Point(2, 2)), square)...  is Relation.WITHIN)True&gt;&gt;&gt; (segment_in_region(Segment(Point(1, 1), Point(5, 5)), square)...  is Relation.CROSS)True&gt;&gt;&gt; inner_square = Contour([Point(1, 1), Point(3, 1), Point(3, 3),...                         Point(1, 3)])&gt;&gt;&gt; from orient.planar import region_in_region&gt;&gt;&gt; region_in_region(square, square) is Relation.EQUALTrue&gt;&gt;&gt; region_in_region(inner_square, square) is Relation.WITHINTrue&gt;&gt;&gt; region_in_region(square, inner_square) is Relation.COVERTrue&gt;&gt;&gt; from orient.planar import point_in_polygon&gt;&gt;&gt; point_in_polygon(left_bottom, Polygon(square, [])) is Location.BOUNDARYTrue&gt;&gt;&gt; point_in_polygon(Point(1, 1), Polygon(square, [])) is Location.INTERIORTrue&gt;&gt;&gt; point_in_polygon(Point(2, 2), Polygon(square, [])) is Location.INTERIORTrue&gt;&gt;&gt; (point_in_polygon(Point(1, 1), Polygon(square, [inner_square]))...  is Location.BOUNDARY)True&gt;&gt;&gt; (point_in_polygon(Point(2, 2), Polygon(square, [inner_square]))...  is Location.EXTERIOR)True&gt;&gt;&gt; from orient.planar import segment_in_polygon&gt;&gt;&gt; (segment_in_polygon(bottom_segment, Polygon(square, []))...  is Relation.COMPONENT)True&gt;&gt;&gt; (segment_in_polygon(Segment(Point(1, 0), Point(5, 0)), Polygon(square, []))...  is Relation.TOUCH)True&gt;&gt;&gt; segment_in_polygon(main_diagonal, Polygon(square, [])) is Relation.ENCLOSEDTrue&gt;&gt;&gt; (segment_in_polygon(main_diagonal, Polygon(square, [inner_square]))...  is Relation.CROSS)True&gt;&gt;&gt; (segment_in_polygon(Segment(Point(1, 1), Point(2, 2)), Polygon(square, []))...  is Relation.WITHIN)True&gt;&gt;&gt; segment_in_polygon(Segment(Point(1, 1), Point(2, 2)),...                    Polygon(square, [inner_square])) is Relation.TOUCHTrue&gt;&gt;&gt; (segment_in_polygon(Segment(Point(1, 1), Point(5, 5)), Polygon(square, []))...  is Relation.CROSS)True&gt;&gt;&gt; segment_in_polygon(Segment(Point(1, 1), Point(5, 5)),...                    Polygon(square, [inner_square])) is Relation.CROSSTrue&gt;&gt;&gt; from orient.planar import polygon_in_polygon&gt;&gt;&gt; (polygon_in_polygon(Polygon(square, []), Polygon(square, []))...  is Relation.EQUAL)True&gt;&gt;&gt; (polygon_in_polygon(Polygon(inner_square, []), Polygon(square, []))...  is Relation.WITHIN)True&gt;&gt;&gt; (polygon_in_polygon(Polygon(square, []), Polygon(inner_square, []))...  is Relation.COVER)True&gt;&gt;&gt; polygon_in_polygon(Polygon(inner_square, []),...                    Polygon(square, [inner_square])) is Relation.TOUCHTrue&gt;&gt;&gt; polygon_in_polygon(Polygon(square, [inner_square]),...                    Polygon(inner_square, [])) is Relation.TOUCHTrue```Development-----------### Bumping version#### PreparationInstall[bump2version](https://github.com/c4urself/bump2version#installation).#### Pre-releaseChoose which version number category to bump following [semverspecification](http://semver.org/).Test bumping version```bashbump2version --dry-run --verbose $CATEGORY```where `$CATEGORY` is the target version number category name, possiblevalues are `patch`/`minor`/`major`.Bump version```bashbump2version --verbose $CATEGORY```This will set version to `major.minor.patch-alpha`. #### ReleaseTest bumping version```bashbump2version --dry-run --verbose release```Bump version```bashbump2version --verbose release```This will set version to `major.minor.patch`.### Running testsInstall dependencies```bashpython -m pip install -r requirements-tests.txt```Plain```bashpytest```Inside `Docker` container:- with `CPython`  ```bash  docker-compose --file docker-compose.cpython.yml up  ```- with `PyPy`  ```bash  docker-compose --file docker-compose.pypy.yml up  ````Bash` script:- with `CPython`  ```bash  ./run-tests.sh  ```  or  ```bash  ./run-tests.sh cpython  ```- with `PyPy`  ```bash  ./run-tests.sh pypy  ````PowerShell` script:- with `CPython`  ```powershell  .\run-tests.ps1  ```  or  ```powershell  .\run-tests.ps1 cpython  ```- with `PyPy`  ```powershell  .\run-tests.ps1 pypy  ```</longdescription>
</pkgmetadata>