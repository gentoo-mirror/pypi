<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Sedaro Python ClientA python client for interacting with the Sedaro API using intuitive classes and methods.This client is intended to be used alongside our [OpenAPI Specification](https://sedaro.github.io/openapi/). Please refer to this documentation for detailed information on the names, attributes, and relationships of each Sedaro Block. See docstrings on classes and their methods for further instructions and explanations.It is recommended that you are familiar with [Modeling in Sedaro](https://sedaro.github.io/openapi/#tag/Templates) as a prerequisite to using this client.Package release versions correspond to the Sedaro application version at the time of package updates.## Installation```bashpip install sedaro```## Getting StartedInstantiate `SedaroApiClient` and get a `Branch````py# Generate an API key in the Sedaro Management Console.sedaro = SedaroApiClient(api_key=API_KEY)# Get an agent template branchagent_template_branch = sedaro.agent_template('NShL_CIU9iuufSII49xm-')# Get a scenario branchscenario_branch = sedaro.scenario('NXKwd2xSSPo-V2ivlIr8k')``````py# If using a dedicated enterprise Sedaro instance, overwrite the default `host` kwarg.HOST = 'url-to-my-sedaro-instance.com'sedaro = SedaroApiClient(api_key=API_KEY, host=HOST)```## Block CRUDUse the `AgentTemplateBranch` or `ScenarioBranch` to instantiate and utilize the `BlockType` class. A `BlockType` object is used to create and access Sedaro Blocks of the respective class.```pybranch.BatteryCellbranch.Componentbranch.Subsystem# ...etc.```- Valid `BlockType`s for Agent Template Branches and Scenario Branches can be found in our redocs [OpenAPI Specification](https://sedaro.github.io/openapi/), by viewing the valid classes in the `blocks` key for the `Template` `PATCH` route. In code editors that support it, intellisense will suggest names for `BlockTypes`.A `BlockType` has several methods:```pybranch.Subsystem.create(name='Structure')branch.Subsystem.get(block_id) # ID of desired Subsystembranch.Subsystem.get_all_ids()branch.Subsystem.get_all()branch.Subsystem.get_where()branch.Subsystem.get_first()branch.Subsystem.get_last()```These methods (except for `get_all_ids`) return a single or list of `Block`(s). A `Block` has several methods and properties.```pysubsystem = branch.Subsystem.create(name='Structure')subsystem.update(name='Structure 2.0')subsystem.delete()```A `Block` will always be equal to and in sync with all other `Block`s referencing the same Sedaro Block:```pysubsystem = branch.Subsystem.create(name='Structure')subsystem_2 = subsystem.update(name='Structure 2.0')subsystem_3 = branch.Subsystem.get(subsystem.id)assert subsystem == subsystem_2 == subsystem_3```The `repr` of a `Block` will show you the corresponding Sedaro Block's data:```pyrepr(subsystem)&gt;&gt;&gt; Subsystem(&gt;&gt;&gt;   category='CUSTOM'&gt;&gt;&gt;   components=[]&gt;&gt;&gt;   id='NShHxZwUh1JGRfZKDvqdA'&gt;&gt;&gt;   name='Structure 2.0'&gt;&gt;&gt;   type='Subsystem'&gt;&gt;&gt; )```Keying into any field existing on the corresponding Sedaro Block will return the value.```pysubsystem.name&gt;&gt;&gt; 'Structure 2.0'```Keying into relationship fields returns `Block`s corresponding to the related Sedaro `Block`s as follows:- `OneSide`: a `Block`- `ManySide`: a `list` of `Block`s- `DataSide`: a dictionary with `Block`s as keys and relationship data as values```pysubsystem.components[0]&gt;&gt;&gt; SolarPanel(id='NShKPImRZHxGAXqkPsluk')```Note that this allows for traversing via chained relationship fields.```pysolar_panel.cell.panels[-1].subsystem.components[0].delete()```### **Full Example**```pyfrom sedaro import SedaroApiClientfrom sedaro.exceptions import NonexistantBlockErrorAPI_KEY = 'api_key_generated_by_sedaro'AGENT_TEMPLATE_ID = 'NShL_CIU9iuufSII49xm-'sedaro = SedaroApiClient(api_key=API_KEY)branch = sedaro.agent_template(AGENT_TEMPLATE_ID)solar_cell = branch.SolarCell.create(  partNumber=&quot;987654321&quot;,  manufacturer='Sedaro Corporation',  openCircuitVoltage=3.95,  shortCircuitCurrent=0.36,  maxPowerVoltage=3.54,  maxPowerCurrent=0.345,  numJunctions=3,)sc_id = solar_cell.idsolar_cell.update(partNumber=&quot;123456789&quot;)solar_cell.delete()try:    solar_cell.update(partNumber=&quot;987654321&quot;)except NonexistantBlockError as e:    assert str(e) == f'The referenced &quot;SolarCell&quot; (id: {sc_id}) no longer exists.'```### Multi-Block CRUDThe `crud` method is also available for performing operations on multiple Sedaro blocks and/or root at the same time using kwargs as follows:- `root`: update fields on the root by passing a dictionary- `blocks`: create/update 1+ blocks by passing a list of dictionaries. If an `id` is present, the corresponding block will be updated. If an `id` isn't present, a new block will be created. The `type` is always required.- `delete`: delete 1+ blocks by passing a list of their block `id`s.```pybranch.crud(    root={ &quot;field&quot;: &quot;value&quot; }, # update fields on root    blocks=[        { &quot;id&quot;: &quot;NXKzb4gSdLyThwudHSR4k&quot;, &quot;type&quot;: &quot;Modem&quot;, &quot;field&quot;: &quot;value&quot; }, # update block        { &quot;type&quot;: &quot;SolarCell&quot;,  &quot;field&quot;: &quot;value&quot;, ... }, # create block    ],    delete=[&quot;NTF8-90Sh93mPKxJkq6z-&quot;] # delete block)```The response from this method is used to update the blocks in the `Branch` the method was called on. The content of the response is also returned, as follows:```py{    &quot;crud&quot;: {      &quot;blocks&quot;: [], # ids of all Blocks created or updated      &quot;delete&quot;: [], # ids of all Blocks deleted  },    &quot;branch&quot;: {      # whole branch dictionary  }}```## SimulationAccess a `Simulation` via the `simulation` attribute on a `ScenarioBranch`.```pysim = sedaro.scenario('NShL7J0Rni63llTcEUp4F').simulation# Start simulationsimulation_handle = sim.start()# See simulation statussimulation_handle = sim.status()# Poll simulation, and return results when complete (progress will be printed until ready)results = sim.results_poll()# If you know it's complete, query for results directlyresults = sim.results()# Terminate running simulationsim.terminate()```- The `status`, `results`, `results_poll`, and `terminate` methods can all optionally take a `job_id`, otherwise they operate on the latest (most recently started/finished) simulation.- For `results` and `results_poll`, you may also provide the optional kwarg `streams`. This triggers narrowing results to fetch only specific streams that you specify. See doc strings for the `results` method for details on how to use the `streams` kwarg.### Simulation HandleThe following `Simulation` methods are also available on the `SimulationHandle` returned by `sim.start()` and `sim.status()`:```pysimulation_handle.status()simulation_handle.results_poll()simulation_handle.results()simulation_handle.results_plain(...)simulation_handle.terminate()```The `SimulationHandle` can also be used to access the attributes of the running simulation. For example:```pysimulation_handle['id']simulation_handle['status']...```## ResultsAny object in the results API will provide a descriptive summary of its contents when the `.summarize` method is called. See the `results_api_demo` notebook in the [modsim notebooks](https://github.com/sedaro/modsim-notebooks) repository for more examples.## Fetch Raw DataYou may also fetch results directly as a plain dictionary with additional arguments to customize the result.```pysim = sedaro.scenario('NShL7J0Rni63llTcEUp4F').simulation# Run simulationsim.start()# After finished... get raw dataselected_streams=[    ('foo',),    ('bar', 'Thermal'),    ('bar', 'Power')]data = sim.results_plain(  start=65000,  stop=65001,  limit=250,  streams=selected_streams,  axisOrder='TIME_MINOR')### alternative:data = sim.results_plain(  start=65000,  stop=65001,  binWidth=0.004,  streams=selected_streams,  axisOrder='TIME_MINOR')```See doc string in the `results_plain` for details on use of the arguments.## Send RequestsUse the built-in method to send custom requests to the host. See [OpenAPI Specification](https://sedaro.github.io/openapi/) for documentation on resource paths and body params.Through the `request` property, you can access `get`, `post`, `put`, `patch`, and `delete` methods.```py# get a branchsedaro.request.get(f'/models/branches/{AGENT_TEMPLATE_ID}')``````py# create a celestial target in a branchsun = {    'name': 'Sun',    'type': 'CelestialTarget'}sedaro.request.patch(    f'/models/branches/{AGENT_TEMPLATE_ID}/template/',    { 'blocks': [sun] })```Note that requests sent this way to CRUD Sedaro Blocks won't automatically update already instantiated `Branch` or `Block` objects.## External Simulation State DependenciesThe following API is exposed to enable the integration of external software with a Sedaro simulation during runtime. Read more about &quot;Cosimulation&quot; in Sedaro [here](https://sedaro.github.io/openapi/#tag/Externals).**Warning:** The following documentation is a work in progress as we continue to evolve this feature. It is recommended that you reach out to Sedaro Application Engineering for assistance using this capability while we mature the documentation for it.### SetupDefine `ExternalState` block(s) on a `Scenario` to facilitate in-the-loop connections from external client(s) (i.e. [Cosimulation](https://sedaro.github.io/openapi/#tag/Externals)). The existance of these blocks determines whether or not the external interface is enabled and active during a simulation. These blocks will also be version controlled just as any other block in a Sedaro model.```python# Per Round External State Block{    &quot;id&quot;: &quot;NZ2SGPWRnmdJhwUT4GD5k&quot;,    &quot;type&quot;: &quot;PerRoundExternalState&quot;,    &quot;produced&quot;: [{&quot;root&quot;: &quot;velocity&quot;}], # Implicit QuantityKind    &quot;consumed&quot;: [{&quot;prev.root.position.as&quot;: &quot;Position.eci&quot;}], # Explicit QuantityKind    &quot;engineIndex&quot;: 0, # 0: GNC, 1: C&amp;DH, 2: Power, 3: Thermal    &quot;agents&quot;: [&quot;NSghFfVT8ieam0ydeZGX-&quot;]}# Spontaneous External State Block{    &quot;id&quot;: &quot;NZ2SHUkS95z1GtmMZ0CTk&quot;,    &quot;type&quot;: &quot;SpontaneousExternalState&quot;,    &quot;produced&quot;: [{&quot;root&quot;: &quot;activeOpMode&quot;}],    &quot;consumed&quot;: [{&quot;prev.root.position.as&quot;: &quot;Position.eci&quot;}],    &quot;engineIndex&quot;: 0, # 0: GNC, 1: C&amp;DH, 2: Power, 3: Thermal    &quot;agents&quot;: [&quot;NSghFfVT8ieam0ydeZGX-&quot;]}```### Deploy (i.e. Initialize)```pythonsim_client = sedaro.scenario('NShL7J0Rni63llTcEUp4F').simulation# Start the simulation# Note that when `sim_client.start()` returns, the simulation is running and ready for external state production/consumptionsimulation_handle = sim_client.start()```### Consume```pythonagent_id = ... # The ID of the relevant simulation Agentper_round_external_state_id = ... # The ID of the relevant ExternalState blockspontaneous_external_state_id = ... # The ID of the relevant ExternalState blocktime = 60050.0137 # Time in MJD# Query the simulation for the state defined on the ExternalState block at the optionally given time# This blocks until the state is available from the simulationstate = simulasimulation_handletion.consume(agent_id, per_round_external_state_id)print(state)state = simulation_handle.consume(agent_id, spontaneous_external_state_id, time=time) # Optionally provide timeprint(state)```**Note:** Calling `consume` with a `time` value that the simulation hasn't reached yet will block until the simulation catches up. This is currently subject to a 10 minute timeout. If the request fails after 10 minutes, it is recommended that it be reattempted.Similarly, calling `consume` with a `time` that too far lags the current simulation might result in an error as the value has been garbage collected from the simulation caches and is no longer available for retrieval. If this is the case, please fetch the data from the Data Service (via the Results API) instead.### Produce```pythonstate = (  [7000, 0, 0], # Position as ECI (km)  [12, 0, 14.1, 14.3, 7, 0], # Thruster thrusts)simulation_handle.produce(agent_id, per_round_external_state_id, state)state = (  [0, 0, 0, 1], # Commanded Attitude as Quaternion)simulation_handle.produce(agent_id, spontaneous_external_state_id, state, timestamp=60050.2)# `timestamp` is optional.  If not provided, the `time` at which the simulation receives the spontaneous state is used# Note: `timestamp` can be used to intentionally inject latency between the time a command is sent and when it is to take effect.  This allows for more accurately modeling communications latency on various comms buses.```### TeardownA simulation that terminates on its own will clean up all external state interfaces. Manually terminating the simulation will do the same:```pythonsimulation_handle.terminate()```## Sedaro Base ClientThe Sedaro client is a wrapper around the Swagger generated OpenAPI client. When this package is installed, the auto-generated, lower-level clients and methods are also available under `sedaro_base_client`.```pyfrom sedaro_base_client import ...```## Community, Support, DiscussionIf you have any issues using the package or any suggestions, please start by reaching out:1. Open an issue on [GitHub](https://github.com/sedaro/sedaro-python/issues)2. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow)3. Email us at support@sedarotech.comPlease note that while emails are always welcome, we prefer the first two options as this allows for others to benefit from the discourse in the threads. That said, if the matter is specific to your use case or sensitive in nature, don't hesitate to shoot us an email instead.</longdescription>
</pkgmetadata>