<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># awstin[![PyPI](https://img.shields.io/pypi/v/awstin)](https://pypi.org/project/awstin/) ![Dev Status](https://img.shields.io/pypi/status/awstin)![CI Build](https://github.com/k2bd/awstin/workflows/CI/badge.svg)[![Documentation Status](https://readthedocs.org/projects/awstin/badge/?version=latest)](https://awstin.readthedocs.io/en/latest/?badge=latest)[![codecov](https://codecov.io/gh/k2bd/awstin/branch/master/graph/badge.svg)](https://codecov.io/gh/k2bd/awstin)High-level utilities for building and testing AWS applications in Python.## DynamoDB[![DynamoDB](https://img.shields.io/github/milestones/progress/k2bd/awstin/1)](https://github.com/k2bd/awstin/milestone/1)### ProductionTo use DynamoDB either the `TEST_DYNAMODB_ENDPOINT` (for integrationtesting) or `AWS_REGION` (for production) environment variable must be set.DynamoDB is accessed through Python data models that users define to representstructured data in tables.```pythonfrom awstin.dynamodb import Attr, DynamoModel, Keyclass User(DynamoModel):    # Name of the DynamoDB table (required!)    _table_name_ = &quot;Users&quot;    # Sort or hash keys are marked with Key    user_id = Key()    # Other attributes are marked with Attr    favorite_color = Attr()    # The names of attributes and keys can differ from the names on the data    # model - the name of the attribute in DynamoDB should be passed to Attr    account_age = Attr(&quot;ageDays&quot;)```Tables are tied to these data models. They'll be returned when items are retrieved from the table. Also, `put_item` takes instances of this data model class.These data models also define projection expressions, so only those attributesare retrieved from `get_item`, `query`, and `scan` calls.```pythonfrom awstin.dynamodb import DynamoDBdynamodb = DynamoDB()# List of available tablestables = dynamodb.list_tables()# Access a table by modelusers_table = dynamodb[User]# Put an item into the tableuser = User(    user_id=&quot;user123&quot;,    favorite_color=&quot;Blue&quot;,    account_age=120,)users_table.put_item(user)# Tables that only have a partition key can be accessed directly by their# partition keyitem1 = users_table[&quot;user123&quot;]# Tables that have partition and sort keys can be accessed by a tupletable2 = dynamodb[AnotherTableModel]item2 = table2[(&quot;hashval&quot;, 123)]# Full primary key access is also availableitem3 = table2[{&quot;hashkey_name&quot;: &quot;hashval&quot;, &quot;sortkey_name&quot;: 123}]```Query and scan filters can be built up using these data models as well. Results can be iterated without worrying about pagination. `Table.scan` and `Table.query` yield items, requesting another page of items lazily only when it's out of items in a page.```pythonscan_filter = (    (User.account_age &gt; 30)    &amp; (User.favorite_color.in_([&quot;Blue&quot;, &quot;Green&quot;])))for user in users_table.scan(scan_filter):    ban_user(user)```Queries must be given a query expression and can optionally be given a filter expression. Query expressions must represent valid DynamoDB queries.```pythonclass Student(DynamoModel):    _table_name_ = &quot;Students&quot;    # Hash key    name = Key()    # Sort key    year = Key()    homeroom = Attr()students_table = dynamodb[Student]query_expression = (Student.name == &quot;John&quot;) &amp; (Student.year &gt;= 10)filter_expression = Student.homeroom == &quot;Smith&quot;results = students_table.query(    query_expression=query_expression,    filter_expression=filter_expression,)```Indexes work identically, but must have a `_index_name_` attribute on the datamodel. Indexes can be used for queries and scans.```pythonclass ByHomeroomIndex(DynamoModel):    _table_name_ = &quot;Students&quot;    _index_name_ = &quot;ByHomeroom&quot;    # Hash key    homeroom = Key()    # Sort key    name = Key()    year = Attr()homeroom_index = dynamodb[ByHomeroomIndex]query_expression = (    (ByHomeroomIndex.homeroom == &quot;Doe&quot;)    &amp; (ByHomeroomIndex.name &gt; &quot;B&quot;))filter_expression = ByHomeroomIndex.year &gt; 11items = list(homeroom_index.query(query_expression, filter_expression))```**Nested Values**Filters on nested attributes work as well:```pythonscan_filter = (    (MyModel.map_attr.key == &quot;value&quot;)    &amp; (MyModel.list_attr[3] == 10))results = my_table.scan(scan_filter)```**Updating Items**A syntax is also available for updating items, with an optional condition expression:```pythonupdate_expression = (    MyModel.an_attr.set(5 - MyModel.another_attr)    &amp; MyModel.third_attr.add(100)    &amp; MyModel.another_attr.remove()    &amp; MyModel.set_attr.delete([2, 3]))condition_expression = MyModel.an_attr &gt; 11updated = my_table.update_item(    &quot;primary_key&quot;,    update_expression,    condition_expression,)````if_not_exists` and `list_append` are provided as well:```pythonfrom awstin.dynamodb import list_appendupdate_expression = (    MyModel.an_attr.set(MyModel.an_attr.if_not_exists(MyModel.another_attr))    &amp; MyModel.third_attr.set(list_append([1.1, 2.2], MyModel.list_attr)))````update_item` returns `None` if the condition evaluates to `False`.**Float and Decimal**Floats should be used when working with DynamoDB through `awstin`. Conversions between float and Decimal is done internally.**Unset Values**Values in a data model class that are unset, either by user instantiation or byretrieval from DynamoDB, are given the value `awstin.dynamodb.NOT_SET`.### TestingFor integration testing, a context manager to create and then automatically tear-down a DynamoDB table is provided.The context manager waits for the table to be created/deleted before entering/exiting to avoid testing issues.Hashkey and sortkey info can be provided.```pythonfrom awstin.dynamodb.testing import temporary_dynamodb_tablewith temporary_dynamodb_table(User, &quot;hashkey_name&quot;) as table:    item = User(        user_id=&quot;user456&quot;,        favorite_color=&quot;Green&quot;,        account_age=333,    )    table.put_item(item)```## Lambdas[![Lambda](https://img.shields.io/github/milestones/progress/k2bd/awstin/3)]((https://github.com/k2bd/awstin/milestone/3))### ProductionLambda handlers can be made more readable by separating event parsing from business logic.The `lambda_handler` decorator factory takes a parser for the triggering event and context, and returns individual values to be used in the wrapped function.```pythonfrom awstin.awslambda import lambda_handlerdef event_parser(event, context):    request_id = event[&quot;requestContext&quot;][&quot;requestId&quot;]    memory_limit = context[&quot;memory_limit_in_mb&quot;]    return request_id, memory_limit@lambda_handler(event_parser)def handle_custom_event(request_id, memory_limit):    print(request_id)    print(memory_limit)```#### TestingA function wrapped with `lambda_handler` is stored on the `inner` attribute of the returned function. That way, the business logic of the handler can be tested separately without having to build events.```python@lambda_handler(my_parser)def my_handler(a: int, b: str):    ...# ------def test_parser():    args = my_parser(test_event, test_context)    assert ...def test_handler():    result = my_handler.inner(1, &quot;abc&quot;)    assert ...```## API Gateway### Authorization Lambdas#### ProductionAuthorizor lambda responses can be generated with helper functions provided by `awstin.apigateway.auth`. `accept`, `reject`, `unauthorized`, and `invalid` will produce properly formatted auth lambda responses.```pythonfrom awstin.apigateway import authdef auth_event_parser(event, _context):    token = event[&quot;headers&quot;][&quot;AuthToken&quot;]    resource_arn = event[&quot;methodArn&quot;]    principal_id = event[&quot;requestContext&quot;][&quot;connectionId&quot;]    return token, resource_arn, principal_id@lambda_handler(auth_event_parser)def token_auth(token, resource_arn, principal_id):    if token == &quot;good token&quot;:        return auth.accept(principal_id, resource_arn)    elif token == &quot;bad token&quot;:        return auth.reject(principal_id, resource_arn)    elif token == &quot;unauthorized token&quot;:        return auth.unauthorized()    else:        return auth.invalid()```### Websockets#### ProductionWebsocket pushes can be performed with a callback URL and message:```pythonfrom awstin.apigateway.websocket import WebsocketWebsocket(&quot;endpoint_url&quot;, &quot;dev&quot;).send(&quot;callback_url&quot;, &quot;message&quot;)```## SNS[![SNS](https://img.shields.io/github/milestones/progress/k2bd/awstin/2)]((https://github.com/k2bd/awstin/milestone/2))### ProductionSNS topics can be retrieved by name and published to with the message directly.This requires either the `TEST_SNS_ENDPOINT` (for integration testing) or `AWS_REGION` (for production) environment variable to be set.```pythonfrom awstin.sns import SNSTopictopic = SNSTopic(&quot;topic-name&quot;)message_id = topic.publish(&quot;a message&quot;)```Message attributes can be set from the kwargs of the publish:```pythontopic.publish(    &quot;another message&quot;,    attrib_a=&quot;a string&quot;,    attrib_b=1234,    attrib_c=[&quot;a&quot;, &quot;b&quot;, False, None],    attrib_d=b&quot;bytes value&quot;,)```</longdescription>
</pkgmetadata>