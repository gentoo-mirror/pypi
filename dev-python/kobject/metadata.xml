<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>```                       ▄▄          ▄▄                      ▀████▀ ▀███▀          ▄██          ██                 ██     ██   ▄█▀             ██                             ██     ██ ▄█▀      ▄██▀██▄  ██▄████▄  ▀███  ▄▄█▀██ ▄██▀████████   █████▄     ██▀   ▀██ ██    ▀██   ██ ▄█▀   ███▀  ██  ██     ██  ███    ██     ██ ██     ██   ██ ██▀▀▀▀▀▀█       ██     ██   ▀██▄  ██▄   ▄██ ██▄   ▄██   ██ ██▄    ▄█▄    ▄ ██   ▄████▄   ███▄ ▀█████▀  █▀█████▀    ██  ▀█████▀█████▀  ▀████                                ██ ██                                                      ▀███                       By CenturyBoys                                Know your object is a __init__ type validator for class and dataclass```## UsageKobject can be use inside default class declaration and with dataclasses. Kobject uses the ```__init__``` signature to check types.### Default classes```pythonfrom kobject import Kobjectclass StubClass(Kobject):    a_int: int    a_bool: bool        def __init__(        self,        a_int: int,        a_bool: bool    ):        self.a_int = a_int        self.a_bool = a_bool        self.__post_init__()instance = StubClass(a_int=1, a_bool=True)```Notice that in the default class declaration you need to call ```self.__post_init__()``` at the end of the ```__init__``` declaration.### Dataclass```pythonfrom dataclasses import dataclassfrom kobject import Kobject@dataclassclass StubClass(Kobject):    a_int: int    a_bool: boolinstance = StubClass(a_int=1, a_bool=True)```By default, dataclass calls ```self.__post_init__()``` at the end of the ```__init__``` declaration [doc](https://docs.python.org/3/library/dataclasses.html#dataclasses.__post_init__). ### ExceptionKobject raises ```TypeError``` with all validation errors, that means it checks all your object's attributes before raising the ```TypeError```. Types like List and Tuple will have all their elements checked.```pythonfrom dataclasses import dataclassfrom kobject import Kobjectfrom typing import List, Tuple@dataclassclass StubClass(Kobject):    a_list_int: List[int]    a_tuple_bool: Tuple[bool]instance = StubClass(a_list_int=[1, &quot;&quot;, 2, &quot;&quot;], a_tuple_bool=[&quot;&quot;, True])``````bashTraceback (most recent call last):...TypeError: Class 'StubClass' type error: Wrong type for a_list_int: typing.List[int] != '&lt;class 'list'&gt;' Wrong type for a_tuple_bool: typing.Tuple[bool] != '&lt;class 'list'&gt;'```You can use lazy validation to improve performance, the code will stop in the first found error for this use```pythonfrom kobject import KobjectKobject.set_lazy_type_check(status=True)```### Default valueKobject supports default values and will check them before any validation, that means if you declare a ```a_bool: bool = None``` it will not raise an error.```pythonfrom dataclasses import dataclassfrom kobject import Kobjectclass StubClass(Kobject):    a_bool: bool = None    def __init__(self, a_bool: bool = 10):        self.a_bool = a_bool        self.__post_init__()@dataclassclass StubDataClass(Kobject):    a_bool: bool = 10```### Custom exceptionBy default, Kobject raise a ```TypeError``` but you can override this exception using `set_validation_custom_exception` for type validation or `set_content_check_custom_exception` for field check on from JSON operation.```pythonfrom dataclasses import dataclassfrom kobject import Kobjectclass CustomException(Exception):    passKobject.set_validation_custom_exception(CustomException)#Kobject.set_content_check_custom_exception(CustomException)@dataclassclass StubClass(Kobject):    a__int: intinstance = StubClass(a__int=&quot;&quot;)``````bashTraceback (most recent call last):...CustomException: Class 'StubClass' type error: Wrong type for a__int: &lt;class 'int'&gt; != '&lt;class 'str'&gt;'```### ToJSONKobject has his own implementation to parse class instance to a JSON representation. ```pythonfrom dataclasses import dataclassfrom typing import List, Tuplefrom kobject import Kobject    @dataclassclass BaseC(Kobject):    a_int: int    a_str: str    a_list_of_int: List[int]    a_tuple_of_bool: Tuple[bool]    instance = BaseC(    a_int=1,    a_str=&quot;lala&quot;,    a_list_of_int=[1, 2, 3],    a_tuple_of_bool=(True,))json_bytes = instance.to_json()print(json_bytes)``````bashb'{&quot;a_int&quot;: 1, &quot;a_str&quot;: &quot;lala&quot;, &quot;a_list_of_int&quot;: [1, 2, 3], &quot;a_tuple_of_bool&quot;: [true]}'```For complex values ToJSON expose ```set_encoder_resolver``` to handler it.```pythonfrom dataclasses import dataclassfrom datetime import datetimefrom typing import Listfrom uuid import UUIDfrom kobject import Kobject, ToJSON@dataclassclass BaseA(Kobject):    a_datetime: datetime@dataclassclass BaseB:    a_uuid: UUID@dataclassclass BaseC(Kobject):    a_base_a: BaseA    a_base_b: BaseB    a_list_of_base_a: List[BaseA]ToJSON.set_encoder_resolver(datetime, lambda value: str(value))ToJSON.set_encoder_resolver(BaseB, lambda value: {&quot;a_uuid&quot;: str(value.a_uuid)})instance = BaseC(    a_base_a=BaseA(a_datetime=datetime.fromisoformat(&quot;2023-02-01 17:38:45.389426&quot;)),    a_base_b=BaseB(a_uuid=UUID(&quot;1d9cf695-c917-49ce-854b-4063f0cda2e7&quot;)),    a_list_of_base_a=[BaseA(a_datetime=datetime.fromisoformat(&quot;2023-02-01 17:38:45.389426&quot;))])json_bytes = instance.to_json()print(json_bytes)``````bashb'{&quot;a_base_a&quot;: {&quot;a_datetime&quot;: &quot;2023-02-01 17:38:45.389426&quot;}, &quot;a_base_b&quot;: {&quot;a_uuid&quot;: &quot;1d9cf695-c917-49ce-854b-4063f0cda2e7&quot;}, &quot;a_list_of_base_a&quot;: [{&quot;a_datetime&quot;: &quot;2023-02-01 17:38:45.389426&quot;}]}'```### FromJSONKobject has his own implementation to parse JSON to a class instance. ```pythonfrom dataclasses import dataclassfrom typing import List, Tuplefrom kobject import Kobject@dataclassclass BaseC(Kobject):    a_int: int    a_str: str    a_list_of_int: List[int]    a_tuple_of_bool: Tuple[bool]payload = (    b'{&quot;a_int&quot;: 1,&quot;a_str&quot;: &quot;lala&quot;,&quot;a_list_of_int&quot;: [1,2,3],'    b'&quot;a_tuple_of_bool&quot;: [true]}')instance = BaseC.from_json(payload=payload)print(instance)``````bashBaseC(a_int=1, a_str='lala', a_list_of_int=[1, 2, 3], a_tuple_of_bool=(True,))```For complex values FromJSON expose ```set_decoder_resolver``` to handler it.```pythonfrom datetime import datetimefrom dataclasses import dataclassfrom typing import Listfrom uuid import UUIDfrom kobject import Kobjectfrom kobject.from_json import FromJSON@dataclassclass BaseA(Kobject):    a_datetime: datetime@dataclassclass BaseB:    a_uuid: UUID@dataclassclass BaseC(Kobject):    a_base_a: BaseA    a_base_b: BaseB    a_list_of_base_a: List[BaseA]FromJSON.set_decoder_resolver(    datetime,    lambda attr_type, value: datetime.fromisoformat(value)    if isinstance(value, str)    else value,)FromJSON.set_decoder_resolver(    BaseB,    lambda attr_type, value: attr_type(a_uuid=UUID(value[&quot;a_uuid&quot;]))    if isinstance(value, dict)    else value,)payload = (    b'{&quot;a_base_a&quot;: {&quot;a_datetime&quot;: &quot;2023-02-01 17:38:45.389426&quot;},&quot;a_base_b&quot;: {&quot;a_'    b'uuid&quot;:&quot;1d9cf695-c917-49ce-854b-4063f0cda2e7&quot;}, &quot;a_lis'    b't_of_base_a&quot;: [{&quot;a_datetime&quot;: &quot;2023-02-01 17:38:45.389426&quot;}]}')instance = BaseC.from_json(payload=payload)print(instance)``````bashBaseC(a_base_a=BaseA(a_datetime=datetime.datetime(2023, 2, 1, 17, 38, 45, 389426)), a_base_b=BaseB(a_uuid=UUID('1d9cf695-c917-49ce-854b-4063f0cda2e7')), a_list_of_base_a=[BaseA(a_datetime=datetime.datetime(2023, 2, 1, 17, 38, 45, 389426))])```</longdescription>
</pkgmetadata>