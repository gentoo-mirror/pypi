<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Digital Humanities UtilitiesPython 3.6+ package containing various utilities relevant in the field of digital humanities.```shell$ pip install dh-utils```## Unicode utilities### Convert Greek beta code to unicode```python&gt;&gt;&gt; from dh_utils.unicode import beta2uni&gt;&gt;&gt; beta2uni('lo/gos')'λόγος'```This is a wrapper of the CLTK converter. We used this converter to also create inverse:```python&gt;&gt;&gt; from dh_utils.unicode import uni2beta&gt;&gt;&gt; uni2beta('λόγος')'lo/gos'```NB: Since [cltk](https://pypi.org/project/cltk/) and its dependency [nltk](https://pypi.org/project/nltk/) are relatively large, cltk is added as an optional dependency. To use the `beta2uni` converter, either install cltk separately using `pip install cltk` or install dh-utils including this optional depency with `pip install dh-utils[betacode]`.### Decompose a unicode string```pycon&gt;&gt;&gt; u.decompose('λόγος')λ U+03bb GREEK SMALL LETTER LAMDAο U+03bf GREEK SMALL LETTER OMICROŃ U+0301 COMBINING ACUTE ACCENTγ U+03b3 GREEK SMALL LETTER GAMMAο U+03bf GREEK SMALL LETTER OMICRONς U+03c2 GREEK SMALL LETTER FINAL SIGMA```## TEI utilities### Convert markdown to TEIA basic converter from markdown to TEI has been added. It will convert a markdown file like:```Some paragraph block&gt; A blockquote1. An2. Ordered3. ListAnother paragraph block with _italics_ and __bold__, and:* An* Unordered* List```using a Python snippet like```python&gt;&gt;&gt; from dh_utils.tei import md2tei&gt;&gt;&gt; with open('file.md') as f:&gt;&gt;&gt;    md = md2tei(f.read())```to the following TEI XML:```xml&lt;p&gt;Some paragraph block&lt;/p&gt;&lt;quote&gt;  &lt;p&gt;A blockquote&lt;/p&gt;&lt;/quote&gt;&lt;list rend=&quot;numbered&quot;&gt;  &lt;item&gt;An&lt;/item&gt;  &lt;item&gt;Ordered&lt;/item&gt;  &lt;item&gt;List&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Another paragraph block with &lt;hi rend=&quot;italic&quot;&gt;italics&lt;/hi&gt; and &lt;hi rend=&quot;bold&quot;&gt;bold&lt;/hi&gt;, and:&lt;/p&gt;&lt;list rend=&quot;bulleted&quot;&gt;  &lt;item&gt;An&lt;/item&gt;  &lt;item&gt;Unordered&lt;/item&gt;  &lt;item&gt;List&lt;/item&gt;&lt;/list&gt;```The function `md2tei` is syntactic sugar for the markdown extension `ToTEI`, which can be used in combination with other extensions as follows:```python&gt;&gt;&gt; from markdown import markdown&gt;&gt;&gt; from dh_utils.tei import ToTEI&gt;&gt;&gt; markdown('some text', extensions=[ToTEI()]) # Other extensions can be added to this list```The extension `ToTEI` in turn exists solely of the postprocessor `TEIPostprocessor`. It has priority 0, which usually means that it will run after all other postprocessors have finished. If any other behaviour or prioritization is required, the processor `TEIPostprocessor` can also be directly imported (`from dh_utils.tei import TEIPostprocessor`) and used in a custom [markdown extension](https://python-markdown.github.io/extensions/api/).### Tag languagesTag languages in a given string based on its script:```python&gt;&gt;&gt; from dh_utils.tei import tag_script&gt;&gt;&gt; tag_script('A line contaning the hebrew אגוז מלך inline', 'Hebr')'A line contaning the hebrew &lt;foreign xml:lang=&quot;he-Hebr&quot;&gt;אגוז מלך&lt;/foreign&gt; inline'```It is also possible to tag a given language based on its script in a TEI XML document (NB: file will be overwritten!):```python&gt;&gt;&gt; from dh_utils.tei import tag_script_from_file&gt;&gt;&gt; tag_script_from_file('path/to/file.xml', 'Arab')```The available scripts are stored in `dh_utils.tei.AVAILABLE_SCRIPTS` and are enumerated below:```python&gt;&gt;&gt; from dh_utils.tei import AVAILABLE_SCRIPTS&gt;&gt;&gt; AVAILABLE_SCRIPTS['Arab', 'Copt', 'Hebr', 'Latn', 'Cyrl']```Default language-script codes are used to tag the scripts (stored in `DEFAULT_LCS`), which can be adjusted using the `language_code` keyword argument:```python&gt;&gt;&gt; t.tag_script_from_file('path/to/file.xml', 'Cyrl', language_code = 'ov-Cyrs')```### Refsdecl generatorTo generate refsdecl elements, the generator can be used to create etree xml elements:```pythonfrom dh_utils.tei import refsdecl_generatorrefs_decl = refsdecl_generator.generate_for_file(&quot;./path/to/file&quot;)refs_decls = refsdecl_generator.generate_for_path(&quot;./path/to/files&quot;)```It can also be used trough the command line interface:`python -m dh_utils.tei.refsdecl_generator [--update] [PATH]`By default, it does not update the file but outputs the refsdecl xml to the terminal. If the `--update` flag is given, the file is updated with the generated refsdecl.### [MyCapytain](https://github.com/Capitains/MyCapytain)-compatilble critical apparatusThe Python API [MyCapytain](https://github.com/Capitains/MyCapytain) only serves the main text of a CTS structured text version, and does not support stand-off annotation, bibliographies, critical apparati, etc. To overcome the last problem, we have developed a script that generates a separate text version of the critical apparatus that can be served through [MyCapytain](https://github.com/Capitains/MyCapytain). Brill's [Scholarly Editions](https://dh.brill.com) uses these separate text versions, which can be displayed [in parallel](https://dh.brill.com/scholarlyeditions/reader/urn:cts:latinLit:stoa0023.stoa001.amo-lat2:14.1.1-14.1.5?right=amo-appcrit3).The following snippet creates such a critapp file from `textgroup.work.edition-extension.xml` located in `path/to/data/textgroup/work` and saves it as `textgroup.work.edition-appcrit1.xml````python&gt;&gt;&gt; from dh_utils.tei import crit_app as ca&gt;&gt;&gt; data_dir = &quot;path/to/data/textgroup/work&quot;&gt;&gt;&gt; filename = &quot;textgroup.work.edition-extension.xml&quot;&gt;&gt;&gt; ca_ext = &quot;appcrit1&quot; # Or any other extension&gt;&gt;&gt; ca.create(filename, ca_ext, data_dir)```If a file contains multiple critical apparati, these can be distinguished using `/listApp[@type]`, e.g.:```xml&lt;listApp type=&quot;superior&quot;&gt;  &lt;app/&gt;  &lt;app/&gt;  ...&lt;/listApp&gt;&lt;listApp type=&quot;inferior&quot;&gt;  &lt;app/&gt;  &lt;app/&gt;  ...&lt;/listApp&gt;```Using the above snippet will combine these apparati into one file. If these should be conerted to separate files, one can pass an additional argument `app_type` to `ca.create` (e.g., `ca.create(filename, ca_ext, data_dir app_type=&quot;superior&quot;)`) to convert an apparatus separately.</longdescription>
</pkgmetadata>