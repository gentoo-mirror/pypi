<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>txredisapi==========[![Build Status](https://secure.travis-ci.org/IlyaSkriblovsky/txredisapi.png)](http://travis-ci.org/IlyaSkriblovsky/txredisapi)*For the latest source code, see &lt;http://github.com/IlyaSkriblovsky/txredisapi&gt;*``txredisapi`` is a non-blocking client driver for the [redis](http://redis.io)database, written in Python. It uses [Twisted](http://twistedmatrix.com) forthe asynchronous communication with redis.It started as a fork of the original[redis protocol for twisted](http://pypi.python.org/pypi/txredis/), and evolvedinto a more robust, reliable, and complete solution for applications like webservers. These types of applications often need a fault-tolerant pool ofconnections with multiple redis servers, making it possible to easily developand maintain distributed systems.Most of the [redis commands](http://redis.io/commands) are supported, as wellas other features such as silent reconnection, connection pools, and automaticsharding.This driver is distributed as part of the [cyclone](http://cyclone.io) webframework.### Changelog ###See [CHANGELOG.md](CHANGELOG.md)### Features ###- Connection Pools- Lazy Connections- Automatic Sharding- Automatic Reconnection- Connection using Redis Sentinel- Publish/Subscribe (PubSub)- Transactions- Unix Socket ConnectionsInstall-------Bear in mind that ``txredisapi.py`` is pure-python, in a single file.Thus, there's absolutely no need to install it. Instead, just copy it to yourproject directory and start using.Latest source code is at &lt;https://github.com/IlyaSkriblovsky/txredisapi&gt;.If you have [cyclone](http://cyclone.io), you probably already have it too.Try the following:    $ python    &gt;&gt;&gt; import cyclone.redis    &gt;&gt;&gt; cyclone.redis.version    '1.0'However, if you really really insist in installing, get it from pypi:    pip install txredisapi### Unit Tests ###[Twisted Trial](http://twistedmatrix.com/trac/wiki/TwistedTrial) unit testsare available. Just start redis, and run ``trial ./tests``.If *unix sockets* are disabled in redis, it will silently skip those tests.Make sure you run `redis-cli flushall` to clean up redis after the tests.Usage-----First thing to do is choose what type of connection you want. The driversupports single connection, connection pools, sharded connections (withautomatic distribution based on a built-in consistent hashing algorithm),sharded connection pools, and all of these different types can be *lazy*,which is explained later (because I'm lazy now).Basically, you want normal connections for simple batch clients that connectto redis, execute a couple of commands and disconnect - like crawlers, etc.Example:    #!/usr/bin/env python    # coding: utf-8    import txredisapi as redis    from twisted.internet import defer    from twisted.internet import reactor    @defer.inlineCallbacks    def main():        rc = yield redis.Connection()        print rc        yield rc.set(&quot;foo&quot;, &quot;bar&quot;)        v = yield rc.get(&quot;foo&quot;)        print &quot;foo:&quot;, repr(v)        yield rc.disconnect()    if __name__ == &quot;__main__&quot;:        main().addCallback(lambda ign: reactor.stop())        reactor.run()Easily switch between ``redis.Connection()`` and ``redis.ConnectionPool()``with absolutely no changes to the logic of your program.These are all the supported methods for connecting to Redis::    Connection(host, port, dbid, reconnect, charset)    lazyConnection(host, port, dbid, reconnect, charset)    ConnectionPool(host, port, dbid, poolsize, reconnect, charset)    lazyConnectionPool(host, port, dbid, poolsize, reconnect, charset)    ShardedConnection(hosts, dbid, reconnect, charset)    lazyShardedConnection(hosts, dbid, reconnect, charset)    ShardedConnectionPool(hosts, dbid, poolsize, reconnect, charset)    lazyShardedConnectionPool(hosts, dbid, poolsize, reconnect, charset)    UnixConnection(path, dbid, reconnect, charset)    lazyUnixConnection(path, dbid, reconnect, charset)    UnixConnectionPool(unix, dbid, poolsize, reconnect, charset)    lazyUnixConnectionPool(unix, dbid, poolsize, reconnect, charset)    ShardedUnixConnection(paths, dbid, reconnect, charset)    lazyShardedUnixConnection(paths, dbid, reconnect, charset)    ShardedUnixConnectionPool(paths, dbid, poolsize, reconnect, charset)    lazyShardedUnixConnectionPool(paths, dbid, poolsize, reconnect, charset)The arguments are:- host: the IP address or hostname of the redis server. [default: localhost]- port: port number of the redis server. [default: 6379]- path: path of redis server's socket [default: /tmp/redis.sock]- dbid: database id of redis server. [default: 0]- poolsize: how many connections to make. [default: 10]- reconnect: auto-reconnect if connection is lost. [default: True]- charset: string encoding. Do not decode/encode strings if None.  [default: utf-8]- hosts (for sharded): list of ``host:port`` pairs. [default: None]- paths (for sharded): list of ``pathnames``. [default: None]- password: password for the redis server. [default: None]- ssl_context_factory: Either a boolean indicating wether to use SSL/TLS or a specific `ClientContextFactory`. [default: False]### Connection Handlers ###All connection methods return a connection handler object at some point.Normal connections (not lazy) return a deferred, which is fired with theconnection handler after the connection is established.In case of connection pools, it will only fire the callback after allconnections are set up, and ready.Connection handler is the client interface with redis. It accepts all thecommands supported by redis, such as ``get``, ``set``, etc. It is the ``rc``object in the example below.Connection handlers will automatically select one of the available connectionsin connection pools, and automatically reconnect to redis when necessary.If the connection with redis is lost, all commands will raise the``ConnectionError`` exception, to indicate that there's no active connection.However, if the ``reconnect`` argument was set to ``True`` during theinitialization, it will continuosly try to reconnect, in background.Example:    #!/usr/bin/env python    # coding: utf-8    import txredisapi as redis    from twisted.internet import defer    from twisted.internet import reactor    def sleep(n):        d = defer.Deferred()        reactor.callLater(5, lambda *ign: d.callback(None))        return d    @defer.inlineCallbacks    def main():        rc = yield redis.ConnectionPool()        print rc        # set        yield rc.set(&quot;foo&quot;, &quot;bar&quot;)        # sleep, so you can kill redis        print &quot;sleeping for 5s, kill redis now...&quot;        yield sleep(5)        try:          v = yield rc.get(&quot;foo&quot;)          print &quot;foo:&quot;, v          yield rc.disconnect()        except redis.ConnectionError, e:          print str(e)    if __name__ == &quot;__main__&quot;:        main().addCallback(lambda ign: reactor.stop())        reactor.run()### Lazy Connections ###This type of connection will immediately return the connection handler object,even before the connection is made.It will start the connection, (or connections, in case of connection pools) inbackground, and automatically reconnect if necessary.You want lazy connections when you're writing servers, like web servers, orany other type of server that should not wait for the redis connection duringthe initialization of the program.The example below is a web application, which will expose redis set, get anddelete commands over HTTP.If the database connection is down (either because redis is not running, orwhatever reason), the web application will start normally. If connection islost during the operation, nothing will change.When there's no connection, all commands will fail, therefore the webapplication will respond with HTTP 503 (Service Unavailable). It will resume tonormal once the connection with redis is re-established.Try killing redis server after the application is running, and make a coupleof requests. Then, start redis again and give it another try.Example:    #!/usr/bin/env python    # coding: utf-8    import sys    import cyclone.web    import cyclone.redis    from twisted.internet import defer    from twisted.internet import reactor    from twisted.python import log    class Application(cyclone.web.Application):        def __init__(self):          handlers = [ (r&quot;/text/(.+)&quot;, TextHandler) ]          RedisMixin.setup()          cyclone.web.Application.__init__(self, handlers, debug=True)    class RedisMixin(object):        redis_conn = None        @classmethod        def setup(self):            RedisMixin.redis_conn = cyclone.redis.lazyConnectionPool()    # Provide GET, SET and DELETE redis operations via HTTP    class TextHandler(cyclone.web.RequestHandler, RedisMixin):        @defer.inlineCallbacks        def get(self, key):          try:              value = yield self.redis_conn.get(key)          except Exception, e:              log.msg(&quot;Redis failed to get('%s'): %s&quot; % (key, str(e)))              raise cyclone.web.HTTPError(503)          self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)          self.write(&quot;%s=%s\r\n&quot; % (key, value))        @defer.inlineCallbacks        def post(self, key):            value = self.get_argument(&quot;value&quot;)            try:                yield self.redis_conn.set(key, value)            except Exception, e:                log.msg(&quot;Redis failed to set('%s', '%s'): %s&quot; % (key, value, str(e)))                raise cyclone.web.HTTPError(503)            self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)            self.write(&quot;%s=%s\r\n&quot; % (key, value))        @defer.inlineCallbacks        def delete(self, key):            try:                n = yield self.redis_conn.delete(key)            except Exception, e:                log.msg(&quot;Redis failed to del('%s'): %s&quot; % (key, str(e)))                raise cyclone.web.HTTPError(503)            self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)            self.write(&quot;DEL %s=%d\r\n&quot; % (key, n))    def main():        log.startLogging(sys.stdout)        reactor.listenTCP(8888, Application(), interface=&quot;127.0.0.1&quot;)        reactor.run()    if __name__ == &quot;__main__&quot;:        main()This is the server running in one terminal::    $ ./helloworld.py    2012-02-17 15:40:25-0500 [-] Log opened.    2012-02-17 15:40:25-0500 [-] Starting factory &lt;redis.Factory instance at 0x1012f0560&gt;    2012-02-17 15:40:25-0500 [-] __main__.Application starting on 8888    2012-02-17 15:40:25-0500 [-] Starting factory &lt;__main__.Application instance at 0x100f42290&gt;    2012-02-17 15:40:53-0500 [RedisProtocol,client] 200 POST /text/foo (127.0.0.1) 1.20ms    2012-02-17 15:41:01-0500 [RedisProtocol,client] 200 GET /text/foo (127.0.0.1) 0.97ms    2012-02-17 15:41:09-0500 [RedisProtocol,client] 200 DELETE /text/foo (127.0.0.1) 0.65ms    (killed redis-server)    2012-02-17 15:48:48-0500 [HTTPConnection,0,127.0.0.1] Redis failed to get('foo'): Not connected    2012-02-17 15:48:48-0500 [HTTPConnection,0,127.0.0.1] 503 GET /text/foo (127.0.0.1) 2.99msAnd these are the requests, from ``curl`` in another terminal.Set:    $ curl -D - -d &quot;value=bar&quot; http://localhost:8888/text/foo    HTTP/1.1 200 OK    Content-Length: 9    Content-Type: text/plain    foo=barGet:    $ curl -D - http://localhost:8888/text/foo    HTTP/1.1 200 OK    Content-Length: 9    Etag: &quot;b63729aa7fa0e438eed735880951dcc21d733676&quot;    Content-Type: text/plain    foo=barDelete:    $ curl -D - -X DELETE http://localhost:8888/text/foo    HTTP/1.1 200 OK    Content-Length: 11    Content-Type: text/plain    DEL foo=1When redis is not running:    $ curl -D - http://localhost:8888/text/foo    HTTP/1.1 503 Service Unavailable    Content-Length: 89    Content-Type: text/html; charset=UTF-8    &lt;html&gt;&lt;title&gt;503: Service Unavailable&lt;/title&gt;    &lt;body&gt;503: Service Unavailable&lt;/body&gt;&lt;/html&gt;### Sharded Connections ###They can be normal, or lazy connections. They can be sharded connection pools.Not all commands are supported on sharded connections.If the command you're trying to run is not supported on sharded connections,the connection handler will raise the ``NotImplementedError`` exception.Simple example with automatic sharding of keys between two redis servers:    #!/usr/bin/env python    # coding: utf-8    import txredisapi as redis    from twisted.internet import defer    from twisted.internet import reactor    @defer.inlineCallbacks    def main():        rc = yield redis.ShardedConnection([&quot;localhost:6379&quot;, &quot;localhost:6380&quot;])        print rc        print &quot;Supported methods on sharded connections:&quot;, rc.ShardedMethods        keys = []        for x in xrange(100):            key = &quot;foo%02d&quot; % x            yield rc.set(key, &quot;bar%02d&quot; % x)            keys.append(key)        # yey! mget is supported!        response = yield rc.mget(keys)        for val in response:            print val        yield rc.disconnect()    if __name__ == &quot;__main__&quot;:        main().addCallback(lambda ign: reactor.stop())        reactor.run()### Transactions ###For obvious reasons, transactions are NOT supported on sharded connections.But they work pretty good on normal or lazy connections, and connection pools.NOTE: redis uses the following methods for transactions:- WATCH: synchronization- MULTI: start the transaction- EXEC: commit the transaction- DISCARD: you got it.Because ``exec`` is a reserved word in Python, the command to commit is``commit``.Example:    #!/usr/bin/env python    # coding: utf-8    import txredisapi as redis    from twisted.internet import defer    from twisted.internet import reactor    @defer.inlineCallbacks    def main():        rc = yield redis.ConnectionPool()        # Remove the keys        yield rc.delete([&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;])        # Start transaction        t = yield rc.multi()        # These will return &quot;QUEUED&quot; - even t.get(key)        yield t.set(&quot;a1&quot;, &quot;1&quot;)        yield t.set(&quot;a2&quot;, &quot;2&quot;)        yield t.set(&quot;a3&quot;, &quot;3&quot;)        yield t.get(&quot;a1&quot;)        # Try to call get() while in a transaction.        # It will fail if it's not a connection pool, or if all connections        # in the pool are in a transaction.        # Note that it's rc.get(), not the transaction object t.get().        try:            v = yield rc.get(&quot;foo&quot;)        print &quot;foo=&quot;, v            except Exception, e:            print &quot;can't get foo:&quot;, e        # Commit, and get all responses from transaction.        r = yield t.commit()        print &quot;commit=&quot;, repr(r)        yield rc.disconnect()    if __name__ == &quot;__main__&quot;:        main().addCallback(lambda ign: reactor.stop())        reactor.run()A &quot;COUNTER&quot; example, using WATCH/MULTI:     #!/usr/bin/env python     # coding: utf-8     import txredisapi as redis     from twisted.internet import defer     from twisted.internet import reactor     @defer.inlineCallbacks     def main():         rc = yield redis.ConnectionPool()         # Reset keys         yield rc.set(&quot;a1&quot;, 0)         # Synchronize and start transaction         t = yield rc.watch(&quot;a1&quot;)         # Load previous value         a1 = yield t.get(&quot;a1&quot;)         # start the transactional pipeline         yield t.multi()         # modify and retrieve the new a1 value         yield t.set(&quot;a1&quot;, a1 + 1)         yield t.get(&quot;a1&quot;)         print &quot;simulating concurrency, this will abort the transaction&quot;         yield rc.set(&quot;a1&quot;, 2)         try:             r = yield t.commit()             print &quot;commit=&quot;, repr(r)         except redis.WatchError, e:             a1 = yield rc.get(&quot;a1&quot;)             print &quot;transaction has failed.&quot;             print &quot;current a1 value: &quot;, a1         yield rc.disconnect()     if __name__ == &quot;__main__&quot;:         main().addCallback(lambda ign: reactor.stop())         reactor.run()Calling ``commit`` will cause it to return a list with the return of allcommands executed in the transaction. ``discard``, on the other hand, willnormally return just an ``OK``.### Pipelining ###txredisapi automatically [pipelines](http://redis.io/topics/pipelining) all commandsby sending next commands without waiting for the previous one to receive reply fromserver. This works even on single connections and increases performance by reducingnumber of round-trip delays and. There are two exceptions, though: - no commands will be sent after blocking `blpop`, `brpop` or `brpoplpush` until   response is received; - transaction by `multi`/`commit` are also blocking connection making all other   commands to wait until transaction is executed.When you need to load tons of data to Redis it might be more effective to sentcommands in batches grouping them together offline to save on TCP packets and networkstack overhead. You can do this using `pipeline` method to explicitly accumulatecommands and send them to server in a single batch. Be careful to not accumulate toomany commands: unreasonable batch size may eat up unexpected amount of memory on bothclient and server side. Group commands in batches of, for example, 10k commands insteadof sending all your data at once. The speed will be nearly the same, but the additionalmemory used will be at max the amount needed to queue this 10k commandsTo send commands in a batch:    #!/usr/bin/env python    # coding: utf-8    import txredisapi as redis    from twisted.internet import defer    from twisted.internet import reactor    @defer.inlineCallbacks    def main():        rc = yield redis.ConnectionPool()        # Start grouping commands        pipeline = yield rc.pipeline()        pipeline.set(&quot;foo&quot;, 123)        pipeline.set(&quot;bar&quot;, 987)        pipeline.get(&quot;foo&quot;)        pipeline.get(&quot;bar&quot;)        # Write those 2 sets and 2 gets to redis all at once, and wait        # for all replies before continuing.        results = yield pipeline.execute_pipeline()        print &quot;foo:&quot;, results[2] # should be 123        print &quot;bar:&quot;, results[3] # should be 987        yield rc.disconnect()    if __name__ == &quot;__main__&quot;:        main().addCallback(lambda ign: reactor.stop())        reactor.run()### Authentication ###This is how to authenticate::    #!/usr/bin/env python    import txredisapi    from twisted.internet import defer    from twisted.internet import reactor    @defer.inlineCallbacks    def main():        redis = yield txredisapi.Connection(password=&quot;foobared&quot;)        yield redis.set(&quot;foo&quot;, &quot;bar&quot;)        print (yield redis.get(&quot;foo&quot;))        reactor.stop()    if __name__ == &quot;__main__&quot;:        main()        reactor.run()        ### Connection using Redis Sentinel ###`txredisapi` can discover Redis master and slaves addresses using [Redis Sentinel](http://redis.io/topics/sentinel) and automatically failoverin case of server failure.    #!/usr/bin/env python        from twisted.internet.task import react    import txredisapi        @defer.inlineCallbacks    def main(reactor):        sentinel = txredisapi.Sentinel([(&quot;sentinel-a&quot;, 26379), (&quot;sentinel-b&quot;, 26379), (&quot;sentinel-c&quot;, 26379)])        redis = sentinel.master_for(&quot;service_name&quot;)        yield redis.set(&quot;foo&quot;, &quot;bar&quot;)        print (yield redis.get(&quot;foo&quot;))        yield redis.disconnect()        yield sentinel.disconnect()            react(main)    Usual connection arguments like `dbid=N` or `poolsize=N` can be specified in`master_for()` call. Use `sentinel.slave_for()` to connect to one of the slaves instead of master.Add `min_other_sentinels=N` to `Sentinel` constructor call to make it obey informationonly from sentinels that currently connected to specified number of other sentinelsto minimize a risk of split-brain in case of network partitioning.Credits=======Thanks to (in no particular order):- Alexandre Fiori  - Author of txredisapi- Gleicon Moraes  - Bug fixes, testing, and [RestMQ](http://github.com/gleicon/restmq&gt;).  - For writing the Consistent Hashing algorithm used for sharding.- Dorian Raymer and Ludovico Magnocavallo  - Authors of the original *redis protocol for twisted*.- Vanderson Mota  - Initial pypi setup, and patches.- Jeethu Rao  - Contributed with test cases, and other ideas like support for travis-ci- Jeremy Archer  - Minor bugfixes.- Christoph Tavan (@ctavan)  - Idea and test case for nested multi bulk replies, minor command enhancements.- dgvncsz0f  - WATCH/UNWATCH commands- Ilia Glazkov  - Free connection selection algorithm for pools.  - Non-unicode charset fixes.  - SCAN commands- Matt Pizzimenti (mjpizz)  - pipelining support- Nickolai Novik (jettify)  - update of SET command- Evgeny Tataurov (etataurov)  - Ability to use hiredis protocol parser- Ilya Skriblovsky (IlyaSkriblovsky)  - Sentinel support</longdescription>
</pkgmetadata>