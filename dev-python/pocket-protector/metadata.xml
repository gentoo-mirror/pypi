<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Pocket Protector üîèPocket Protector provides a cryptographically-strong, serverless secretmanagement infrastructure. Pocket Protector enables *key management ascode*, securely storing secrets in a versionable format, rightalongside the corresponding application code.Pocket Protector's approach lets you:* Leverage existing user, versioning, and backup systems, with no  infrastructure to set up* Support multiple environments* Integrate easily with existing key management systems  (AWS/Heroku/TravisCI)Pocket Protector also:* Minimizes the number of passphrases and keys your team has to  remember and secure* Beats the heck out of hardcoded plaintext secrets!## InstallationRight now the easiest way to install Pocket Protector across allplatforms is with `pip`:```shpip install pocket_protector```This will install the command-line application `pocket_protector`,conveniently shortened to `pprotect`, which you can use to test yourinstallation:```sh$ pprotect versionpocket_protector version 18.0.1```Once the above is working, we're ready to start using Pocket Protector!## UsagePocket Protector aims to be as easy to use as a secret managementsystem can get. That said, understanding security takes time, so besure to go beyond the quick start and reference below, and read our[User Guide](https://github.com/SimpleLegal/pocket_protector/blob/master/USER_GUIDE.md)as well.### Quick startPocket Protector's CLI is its primary interface. It presents a compactset of commands, each representing one action you might want to takeon a secret store. Basic usage starts on your laptop, inside yourchecked out code repository:```sh# create a new protected filepprotect init# add a key domainpprotect add-domain# add a secret to the new key domainpprotect add-secret# decrypt and read out the secretpprotect decrypt-domain```Each of these will prompt the user for credentials when necessary. Seethe section below on passing credentials.When you're done updating the secret store, simply `git commit` (orequivalent) to save your changes. Should you make any mistakes, useyour VCS to revert the changes.### Passing credentialsBy default, the `pocket_protector` command prompts you for credentialswhen necessary. But convenience and automation both demand moreoptions, highlighted here:* Command-line Flags  * `-u / --user USER_EMAIL` - specifies the user email for subcommands which require it  * `--passphrase-file PATH` - specifies a path to a readable file    which contains the passphrase (useful for mount-based key    management, like Docker)  * `--domain DOMAIN` - specifies the name of the domain  * `--non-interactive` - causes the command to fail when credentials cannot be gotten by other means* Environment variables  * `PPROTECT_USER` - environment variable which contains the user email  * `PPROTECT_PASSPHRASE` - environment variable which contains the    passphrase (useful for environment variable-based key management,    used by AWS/Heroku/many CI systems)In all cases, flags take precedence over environment variables, andboth take precedence over and bypass interactive prompts. In the eventan incorrect credential is passed, `pocket_protector` does *not*automatically check other sources.See our[User Guide](https://github.com/SimpleLegal/pocket_protector/blob/master/USER_GUIDE.md)for more usage tips.### Command summaryHere is a summary of all commands:```usage: pprotect [COMMANDS]Commands:  add-domain            add a new domain to the protected  add-key-custodian     add a new key custodian to the protected  add-owner             add a key custodian as owner of a domain  add-secret            add a secret to a specified domain  decrypt-domain        decrypt and display JSON-formatted cleartext for a                        domain  init                  create a new pocket-protected file  list-all-secrets      display all secrets, with a list of domains the key is                        present in  list-audit-log        display a chronological list of audit log entries                        representing file activity  list-domain-secrets   display a list of secrets under a specific domain  list-domains          display a list of available domains  list-user-secrets     similar to list-all-secrets, but filtered by a given                        user  rm-domain             remove a domain from the protected  rm-owner              remove an owner's privileges on a specified domain  rm-secret             remove a secret from a specified domain  rotate-domain-keys    rotate the internal keys for a particular domain (must                        be owner)  set-key-custodian-passphrase                        change a key custodian passphrase  update-secret         update an existing secret in a specified domain```## DesignThe theory of operation is that the `protected.yaml` file consists of&quot;key domains&quot; at the root level. Each domain stores data encrypted bya keypair. The public key of the keypair is stored in plaintext, sothat anyone may encrypt and add a new secret. The private key isencrypted with the owner's passphrase. The owners are known as &quot;keycustodians&quot;, and their private keys are protected by passphrases.Secrets are broken up into domains for the purposes of grantingsecurity differently. For example, `prod`, `dev`, and `stage` may allbe different domains. Protected stores may have as few or as manydomains as the team and application require.To allow secrets to be accessed in a certain environment, PocketProtector must be invoked with a user and passphrase. As long as thecredentials are correct and the user has permissions to a domain, allsecrets within that domain are unlocked.Passphrase security will depend on the domain. For instance, a domainused for local development may set the passphrase as an environmentvariable, or hardcode it in a configuration file.On the other hand, a production domain would likely require manualentry of an authorized release engineer, or use AWS/GCP/Heroku keymanagement solutions to inject the passphrase.for prod domains, use AWS / heroku key management to storethe passphraseAn application / script wants to get its secrets:```python# at initializationsecrets = KeyFile.decrypt_domain(domain_name, Creds(name, passphrase))# ... later to access a secretsecrets[secret_name]```An application / script that wants to add / overwrite a secret:```pythonKeyFile.from_file(path).with_secret(    domain_name, secret_name, value).write()```Note -- the secure environment key is needed to read secrets, but not write them.Change management on secrets is intended to follow normal source-codemanagement.File structure:```yaml[key-domain]:  meta:    owners:      [name]: [encrypted-private-key]    public_key: [b64-bytes]    private_key: [b64-bytes]  secret-[name]: [b64-bytes]key-custodians:  [name]:    public-key: [b64-bytes]    encrypted-private-key: [b64-bytes]```### Threat modelAn attacker is presumed to be able to read but not write the contentsof `protected.yaml`. This could happen because a developer's laptopis compromised, GitHub credentials are compromised, or (most likely)Git history is accidentally pushed to a publicly acessible repo.With read access, an attacker gets environment and secret names,and which secrets are used in which environments.Neither the file as a whole nor individual entries are signed,since the security model assumes an attacker does not havewrite access.### NotesPocket Protector is a streamlined, people-centric secret managementsystem, custom built to work with distributed version control systems.* Pocket Protector is a data protection tool, not a change management  tool. While it has convenient affordances like an informal  `audit_log`, Pocket Protector is meant to be used in conjunction with  your version management tool. Signed commits are a particularly good  complement.* Pocket Protector is designed for single-user usage. This is not a  scaling limitation as much as it is a scaling feature. Single-user  means that every `pprotect` command needs at most one credentialed  user present. No sideband communication is required, minimizing  leakage, while maintaining a system as distributed as your version  management.## FAQ### Securing Write AccessPocket Protector does not provide any security against unauthorized writesto the `protected.yaml` file, by design. Firstly, without any Public Key Infrastructure,Pocket Protector is not a good basis for cryptographic signatures. (An attackerthat modifies the file could also replace the signing keypair with their own;the only way to detect this would be to have a data-store outside of the file.)Secondly -- and more importantly -- the Git or Mercurial repository already hasgood controls around write access. All changes are auditable, authenticated withssh keypairs or user passphrases. For futher security, consider using signed commits:* https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work* https://help.github.com/articles/signing-commits-using-gpg/* https://docs.gitlab.com/ee/user/project/repository/gpg_signed_commits/index.html</longdescription>
</pkgmetadata>