<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># The **treepath** Package.The **treepath** package offers a [declarative programming](https://en.wikipedia.org/wiki/Declarative_programming) approach to extracting data from a [json](https://docs.python.org/3/library/json.html) data structure.  The expressions are a [query language](https://en.wikipedia.org/wiki/Query_language) similar to[jsonpath](https://goessner.net/articles/JsonPath/), and [Xpath](https://en.wikipedia.org/wiki/XPath), but arewritten in native python syntax.Note python 3.6 is supported in version earlier that 1.0.0.# Quick startAll of the treepath components should be imported as follows:```pythonfrom treepath import path, pathd, wc, wildcard, set_, get, get_match, find, find_matches, has, has_all,    has_any, has_not, MatchNotFoundError, Match, log_to, Document, attr, attr_typed, attr_iter_typed,    attr_list_typed, JsonArgTypes```A treepath example that fetches the value 1 from data.```pythondata = {    &quot;a&quot;: {        &quot;b&quot;: [            {                &quot;c&quot;: 1            },            {                &quot;c&quot;: 2            }]    }}value = get(path.a.b[0].c, data)assert value == 1```A treepath example that fetches the values 1 and 2 from data.```pythonvalue = [value for value in find(path.a.b[wc].c, data)]assert value == [1, 2]```# Solar System Json DocumentThe examples shown in this README use the following json document.  It describes our solar system. Click to expand.  &lt;details&gt;&lt;summary&gt;solar_system = {...}&lt;/summary&gt;&lt;p&gt;```json{  &quot;star&quot;: {    &quot;name&quot;: &quot;Sun&quot;,    &quot;diameter&quot;: 1391016,    &quot;age&quot;: null,    &quot;planets&quot;: {      &quot;inner&quot;: [        {          &quot;name&quot;: &quot;Mercury&quot;,          &quot;Number of Moons&quot;: &quot;0&quot;,          &quot;diameter&quot;: 4879,          &quot;has-moons&quot;: false        },        {          &quot;name&quot;: &quot;Venus&quot;,          &quot;Number of Moons&quot;: &quot;0&quot;,          &quot;diameter&quot;: 12104,          &quot;has-moons&quot;: false        },        {          &quot;name&quot;: &quot;Earth&quot;,          &quot;Number of Moons&quot;: &quot;1&quot;,          &quot;diameter&quot;: 12756,          &quot;has-moons&quot;: true        },        {          &quot;name&quot;: &quot;Mars&quot;,          &quot;Number of Moons&quot;: &quot;2&quot;,          &quot;diameter&quot;: 6792,          &quot;has-moons&quot;: true        }      ],      &quot;outer&quot;: [        {          &quot;name&quot;: &quot;Jupiter&quot;,          &quot;Number of Moons&quot;: &quot;79&quot;,          &quot;diameter&quot;: 142984,          &quot;has-moons&quot;: true        },        {          &quot;name&quot;: &quot;Saturn&quot;,          &quot;Number of Moons&quot;: &quot;82&quot;,          &quot;diameter&quot;: 120536,          &quot;has-moons&quot;: true        },        {          &quot;name&quot;: &quot;Uranus&quot;,          &quot;Number of Moons&quot;: &quot;27&quot;,          &quot;diameter&quot;: 51118,          &quot;has-moons&quot;: true        },        {          &quot;name&quot;: &quot;Neptune&quot;,          &quot;Number of Moons&quot;: &quot;14&quot;,          &quot;diameter&quot;: 49528,          &quot;has-moons&quot;: true        }      ]    }  }}```&lt;/p&gt;&lt;/details&gt;# Quick comparison between Imperative and Declarative Solution.The following problem is solved using a Imperative Solution and a Declarative Solution to try to illustrate the differences between the two approaches.  The problem is fetch the planet by name from the given solar system json document.  ## Imperative SolutionThe first example uses flow control statements to define a[Imperative Solution]( https://en.wikipedia.org/wiki/Imperative_programming).   This is avery common approach to solving problems.```pythondef get_planet_by_name(name, the_solar_system):    try:        planets = the_solar_system['star']['planets']        for arc in planets.values():            for planet in arc:                if name == planet.get('name', None):                    return planet    except KeyError:        pass    return Noneactual = get_planet_by_name('Earth', solar_system)expected = {'Number of Moons': '1', 'diameter': 12756, 'has-moons': True, 'name': 'Earth'}assert actual == expected```## Declarative  SolutionThe second example uses treepath to define a[declarative solution](https://en.wikipedia.org/wiki/Declarative_programming).It solves the same problem without defining any flow control statements.    This keeps the Cyclomatic andCognitive Complexity low.```pythondef get_planet_by_name(name: str, the_solar_system):    return get(        path.star.planets.wc[wc][has(path.name == name)],        the_solar_system,        default=None    )actual = get_planet_by_name('Earth', solar_system)expected = {'Number of Moons': '1', 'diameter': 12756, 'has-moons': True, 'name': 'Earth'}assert actual == expected```# query examples.| Description                                 | Xpath                               | jsonpath                                  | treepath                            ||----------------------------------------------|-------------------------------------|-------------------------------------------|------------------------------------|| Find planet earth.                           | /star/planets/inner[name='Earth']   | $.star.planets.inner[?(@.name=='Earth')]  | path.star.planets.inner[wc][has(path.name == 'Earth')]   || List the names of all inner planets.         | /star/planets/inner[*].name         | $.star.planets.inner[*].name              | path.star.planets.inner[wc].name   || List the names of all planets.               | /star/planets/*/name                | $.star.planets.[*].name                   | path.star.planets.wc[wc].name      || List the names of all celestial bodies       | //name                              | $..name                                   | path.rec.name                      |  | List all nodes in the tree Preorder          | //*                                 | $..                                       | path.rec                           || Get the third rock from the sun              | /star/planets/inner[3]              | $.star.planets.inner[2]                   | path.star.planets.inner[2]         || List first two inner planets                 | /star/planets.inner[position()&lt;3]   | $.star.planets.inner[:2]                  | path.star.planets.inner[0:2]       ||                                              |                                     | $.star.planets.inner[0, 1]                | path.star.planets.inner[0, 2]      || List planets smaller than earth              | /star/planets/inner[Equatorial_diameter &lt; 1]   | $.star.planets.inner[?(@.['Equatorial diameter'] &lt; 1)]              | path.star.planets.inner[wc][has(path[&quot;Equatorial diameter&quot;] &lt; 1)]       || List celestial bodies that have planets.     | //*[planets]/name                   | $..*[?(@.planets)].name                   | path.rec[has(path.planets)].name       |# Traversal Functions## getThe **get** function returns the first value the path leads to.Get the star name from the solar_system```pythonsun = get(path.star.name, solar_system)assert sun == 'Sun'```When there is no match, MatchNotFoundError is thrown.```pythontry:    get(path.star.human_population, solar_system)    assert False, &quot;Not expecting humans on the sun&quot;except MatchNotFoundError:    pass```Or if preferred, a default value can be given.```pythonhuman_population = get(path.star.human_population, solar_system, default=0)assert human_population == 0```In addition to a constant, the default value may also be a callable```pythondef population():    return 0human_population = get(path.star.human_population, solar_system, default=population)assert human_population == 0```The default value can be automatically injected in to json document```pythonhuman_population = get(path.star.human_population, solar_system, default=1, store_default=True)assert human_population == solar_system[&quot;star&quot;][&quot;human_population&quot;]```The data source can be a json data structure or a Match object.```pythonparent_match = get_match(path.star.planets.inner, solar_system)name = get(path[2].name, parent_match)assert name == &quot;Earth&quot;```## set_The **set_** function modifies the json document.Use the set_ function to modify the star name.```pythonsun = get(path.star.name, solar_system)assert sun == 'Sun'set_(path.star.name, &quot;RedSun&quot;, solar_system)sun = get(path.star.name, solar_system)assert sun == 'RedSun'assert solar_system[&quot;star&quot;][&quot;name&quot;] == 'RedSun'```Use the set_ to add planet9.   This example creates multiple objects in one step.```pythonname = get(path.star.planets.outer[4].name, solar_system, default=None)assert name is Noneplanets_count = len(list(find(path.star.planets.wc[wc].name, solar_system)))assert planets_count == 8set_(path.star.planets.outer[4].name, 'planet9', solar_system, cascade=True)name = get(path.star.planets.outer[4].name, solar_system, default=None)assert name == 'planet9'planets_count = len(list(find(path.star.planets.wc[wc].name, solar_system)))assert planets_count == 9```## findThe **find** function returns an Iterator that iterates to each value the path leads to.  Each value isdetermine on its iteration.Find all of the planet names.```pythoninner_planets = [planet for planet in find(path.star.planets.inner[wc].name, solar_system)]assert inner_planets == ['Mercury', 'Venus', 'Earth', 'Mars']```The data source can be a json data structure or a Match object.```pythonparent_match = get_match(path.star.planets.inner, solar_system)inner_planets = [planet for planet in find(path[wc].name, parent_match)]assert inner_planets == ['Mercury', 'Venus', 'Earth', 'Mars']```## get_matchThe **get_match** function returns the first Match the path leads to.Get the star name from the solar_system```pythonmatch = get_match(path.star.name, solar_system)assert match.data == 'Sun'```When there is no match, MatchNotFoundError is thrown.```pythontry:    get_match(path.star.human_population, solar_system)    assert False, &quot;Not expecting humans on the sun&quot;except MatchNotFoundError:    pass```Or if preferred, **None** is returned if must_match is set to False.```pythonmatch = get_match(path.star.human_population, solar_system, must_match=False)assert match is None```The data source can be a json data structure or a Match object.```pythonparent_match = get_match(path.star.planets.inner, solar_system)earth_match = get_match(path[2].name, parent_match)assert earth_match.path_as_str == &quot;$.star.planets.inner[2].name&quot;assert earth_match.data == &quot;Earth&quot;```## find_matchesThe **find_matches** function returns an Iterator that iterates to each match the path leads to.  Each match isdetermine on its iteration.Find the path to each of the inner planets.```pythonfor match in find_matches(path.star.planets.inner[wc], solar_system):    assert match.path_as_str in [        '$.star.planets.inner[0]',        '$.star.planets.inner[1]',        '$.star.planets.inner[2]',        '$.star.planets.inner[3]',    ]```The data source can be a json data structure or a Match object.```pythonparent_match = get_match(path.star.planets.inner, solar_system)for match in find_matches(path[wc], parent_match):    assert match.path_as_str in [        '$.star.planets.inner[0]',        '$.star.planets.inner[1]',        '$.star.planets.inner[2]',        '$.star.planets.inner[3]',    ]```## The Match ClassThe **Match** class provides metadata about the match.```pythonmatch = get_match(path.star.name, solar_system)```The explicit path to the match```pythonexplicit_path = match.pathassert explicit_path == path.star.name```The string representation of the match including the value: &quot;path=value&quot;```pythonassert repr(match) == &quot;$.star.name=Sun&quot;assert str(match) == &quot;$.star.name=Sun&quot;```The string representation of the match, but with just the path component.```pythonassert match.path_as_str == &quot;$.star.name&quot;```A list containing each match in the path.```pythonassert match.path_match_list == [match.parent.parent, match.parent, match]```The key that points to the match value.  The data_name is a dictionary key if the parent is a dict or an index ifthe parent is a list.```pythonassert match.data_name == &quot;name&quot; and match.parent.data[match.data_name] == match.data```The value the path matched.```pythonassert match.data == &quot;Sun&quot;```The parent match.```pythonassert match.parent.path_as_str == &quot;$.star&quot;```The match can modify the value```pythonmatch.data = &quot;Soleil&quot;assert repr(match) == &quot;$.star.name=Soleil&quot;del match.dataassert repr(match) == &quot;$.star.name=None&quot;match.data = &quot;Sun&quot;assert repr(match) == &quot;$.star.name=Sun&quot;match.pop()assert repr(match) == &quot;$.star.name=None&quot;```## Tracing DebuggingAll of the functions: get, find, get_match and find_matchesm, support tracing.   An option, when enabled,records the route the algorithm takes to determine a match.This example logs the route the algorithm takes to find the inner planets.  The **print**function is give to capture the logs, but any single argument function can be used.```pythoninner_planets = [planet for planet in find(path.star.planets.inner[wc].name, solar_system, trace=log_to(print))]assert inner_planets == ['Mercury', 'Venus', 'Earth', 'Mars']```The results```python&quot;&quot;&quot;at $.star got {'name': 'Sun', 'dia...at $.star.planets got {'inner': [{'name': ...at $.star.planets.inner got [{'name': 'Mercury',...at $.star.planets.inner[*] got {'name': 'Mercury', ...at $.star.planets.inner[0].name got 'Mercury'at $.star.planets.inner[*] got {'name': 'Venus', 'N...at $.star.planets.inner[1].name got 'Venus'at $.star.planets.inner[*] got {'name': 'Earth', 'N...at $.star.planets.inner[2].name got 'Earth'at $.star.planets.inner[*] got {'name': 'Mars', 'Nu...at $.star.planets.inner[3].name got 'Mars'&quot;&quot;&quot;```# Path## The rootThe **path** point to root of the tree.```pythonmatch = get_match(path, solar_system)assert match.data == solar_system```In a filter path point to the current element.```pythonmatch = get_match(path.star.name[has(path == 'Sun')], solar_system)assert match.data == 'Sun'```## Dictionaries### KeysThe dictionary keys are referenced as dynamic attributes on a path.```pythoninner_from_attribute = get(path.star.planets.inner, solar_system)inner_from_string_keys = get(path[&quot;star&quot;][&quot;planets&quot;][&quot;inner&quot;], solar_system)assert inner_from_attribute == inner_from_string_keys == solar_system[&quot;star&quot;][&quot;planets&quot;][&quot;inner&quot;]```### Keys With Special CharactersDictionary keys that are not valid python syntax can be referenced as double quoted strings.```pythonsun_equatorial_diameter = get(path.star.planets.inner[0][&quot;Number of Moons&quot;], solar_system)assert sun_equatorial_diameter == solar_system[&quot;star&quot;][&quot;planets&quot;][&quot;inner&quot;][0][&quot;Number of Moons&quot;]```Dictionaries that have alot of keys with a dash in the name can can use **pathd** instead.  It will interpretpath attributes with underscore as dashes.```pythonmercury_has_moons = get(pathd.star.planets.inner[0].has_moons, solar_system)assert mercury_has_moons == solar_system[&quot;star&quot;][&quot;planets&quot;][&quot;inner&quot;][0][&quot;has-moons&quot;]```### Wildcard as a Key.The **wildcard** attribute specifies all sibling keys.   It is useful for iterating over attributes.```pythonstar_children = [child for child in find(path.star.wildcard, solar_system)]assert star_children == [solar_system[&quot;star&quot;][&quot;name&quot;],                         solar_system[&quot;star&quot;][&quot;diameter&quot;],                         solar_system[&quot;star&quot;][&quot;age&quot;],                         solar_system[&quot;star&quot;][&quot;planets&quot;], ]```The **wc** is the short version of wildcard.```pythonstar_children = [child for child in find(path.star.wc, solar_system)]assert star_children == [solar_system[&quot;star&quot;][&quot;name&quot;],                         solar_system[&quot;star&quot;][&quot;diameter&quot;],                         solar_system[&quot;star&quot;][&quot;age&quot;],                         solar_system[&quot;star&quot;][&quot;planets&quot;], ]```The dictionary wildcard is declared using dot notation and cannot be used to iterator over a list.  The listwildcard is declared using index notation and cannot be used to iterate over dictionary keys.```pythonall_planets = [p for p in find(path.star.planets.wc[wc].name, solar_system)]assert all_planets == ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']```The generic_wildcard, also known as gwc, can be declared in either notations and supports iterating over bothlist and dictionaries.```pythonall_planets = [p for p in find(path.star.planets.gwc.gwc.name, solar_system)]assert all_planets == ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']```### Comma Delimited KeysMultiple dictionary keys can be specified using a comma delimited list.```pythonlast_and_first = [planet for planet in find(path.star[&quot;diameter&quot;, &quot;name&quot;], solar_system)]assert last_and_first == [1391016, &quot;Sun&quot;]```## List### IndexesList can be access using index.```pythonearth = get(path.star.planets.inner[2], solar_system)assert earth == solar_system[&quot;star&quot;][&quot;planets&quot;][&quot;inner&quot;][2]```List the third inner and outer planet.```pythonlast_two = [planet for planet in find(path.star.wc.wc[2].name, solar_system)]assert last_two == ['Earth', 'Uranus']```### SlicesList can be access using slices.List the first two planets.```pythonfirst_two = [planet for planet in find(path.star.planets.outer[:2].name, solar_system)]assert first_two == [&quot;Jupiter&quot;, &quot;Saturn&quot;]```List the last two planets.```pythonlast_two = [planet for planet in find(path.star.planets.outer[-2:].name, solar_system)]assert last_two == [&quot;Uranus&quot;, &quot;Neptune&quot;]```List all outer planets in reverse.```pythonlast_two = [planet for planet in find(path.star.planets.outer[::-1].name, solar_system)]assert last_two == [&quot;Neptune&quot;, &quot;Uranus&quot;, &quot;Saturn&quot;, &quot;Jupiter&quot;]```List the last inner and outer planets.```pythonlast_two = [planet for planet in find(path.star.wc.wc[-1:].name, solar_system)]assert last_two == [&quot;Mars&quot;, &quot;Neptune&quot;]```### Comma Delimited Indexes.List indexes can be specified as a comma delimited list.```pythonlast_and_first = [planet for planet in find(path.star.planets.outer[3, 0].name, solar_system)]assert last_and_first == [&quot;Neptune&quot;, &quot;Jupiter&quot;]```### Wildcard as an Index.The **wildcard** word can be used as a list index.   It is useful for iterating over attributes.```pythonall_outer = [planet for planet in find(path.star.planets.outer[wildcard].name, solar_system)]assert all_outer == [&quot;Jupiter&quot;, &quot;Saturn&quot;, &quot;Uranus&quot;, &quot;Neptune&quot;]```The **wc** is the short version of wildcard.```pythonall_outer = [planet for planet in find(path.star.planets.outer[wc].name, solar_system)]assert all_outer == [&quot;Jupiter&quot;, &quot;Saturn&quot;, &quot;Uranus&quot;, &quot;Neptune&quot;]```The list wildcard is declared using index notation and cannot be used to iterate over dictionary keys.  Thedictionary wildcard is declared using dot notation and cannot be used to iterator over a list.```pythonall_planets = [p for p in find(path.star.planets.wc[wc].name, solar_system)]assert all_planets == ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']```The generic_wildcard, also known as gwc, can be declared in either notations and supports iterating over bothlist and dictionaries.```pythonall_planets = [p for p in find(path.star.planets[gwc][gwc].name, solar_system)]assert all_planets == ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']```## RecursionThe **recursive** word implies recursive search.  It executes a preorder tree traversal.  The search algorithmdescends the tree hierarchy evaluating the path on each vertex until a match occurs.  On each iteration itcontinues where it left off. This is an example that finds all the planets names.```pythonall_planets = [p for p in find(path.star.planets.recursive.name, solar_system)]assert all_planets == ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']```The **rec** is the short version of recursive.```pythonall_planets = [p for p in find(path.star.planets.rec.name, solar_system)]assert all_planets == ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']```Here is another example that finds all the celestial bodies names.```pythonall_celestial_bodies = [p for p in find(path.rec.name, solar_system)]assert all_celestial_bodies == ['Sun', 'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus',                                'Neptune']```## FiltersFilters are use to add additional search criteria.### has filterThe **has** function is a filter that evaluates a branched off path relative to its parent path.  This examplefinds all celestial bodies that have planets.```pythonsun = get(path.rec[has(path.planets)].name, solar_system)assert sun == &quot;Sun&quot;```This search finds all celestial bodies that have a has-moons attribute.```pythonall_celestial_bodies_moon_attribute = [planet for planet in find(path.rec[has(pathd.has_moons)].name, solar_system)]assert all_celestial_bodies_moon_attribute == ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus',                                               'Neptune']```This search finds all celestial bodies that have moons. Note the **operator.truth** is used to exclude planetsthat don't have moons.```pythonall_celestial_bodies_moon_attribute = [planet for planet in                                       find(path.rec[has(pathd.has_moons, operator.truth)].name, solar_system)]assert all_celestial_bodies_moon_attribute == ['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']```### has filter comparison operatorsFilters can be specified with a comparison operator.```pythonearth = [planet for planet in find(path.rec[has(path.diameter == 12756)].name, solar_system)]assert earth == ['Earth']earth = [planet for planet in find(path.rec[has(path.diameter != 12756)].name, solar_system)]assert earth == ['Sun', 'Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']earth = [planet for planet in find(path.rec[has(path.diameter &gt; 12756)].name, solar_system)]assert earth == ['Sun', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']earth = [planet for planet in find(path.rec[has(path.diameter &gt;= 12756)].name, solar_system)]assert earth == ['Sun', 'Earth', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']earth = [planet for planet in find(path.rec[has(path.diameter &lt; 12756)].name, solar_system)]assert earth == ['Mercury', 'Venus', 'Mars']earth = [planet for planet in find(path.rec[has(path.diameter &lt;= 12756)].name, solar_system)]assert earth == ['Mercury', 'Venus', 'Earth', 'Mars']```### has filter type conversionSometimes the value is the wrong type for the comparison operator. In this example the attribute&quot;Number of Moons&quot; is str type.```pythonplanets = [planet for planet in find(path.rec[has(path[&quot;Number of Moons&quot;] &gt; &quot;5&quot;)].name, solar_system)]assert planets == ['Jupiter', 'Saturn']```This is how to convert the type to an int before applying the comparison operator.```pythonplanets = [planet for planet in find(path.rec[has(path[&quot;Number of Moons&quot;] &gt; 5, int)].name, solar_system)]assert planets == ['Jupiter', 'Saturn', 'Uranus', 'Neptune']```### has filter comparison operators as single argument functionsA filter operator can be specified as a single argument function.  Here an example that searches for planets thathave the same diameter as earth.```pythonearths_diameter = partial(operator.eq, 12756)earth = [planet for planet in find(path.rec[has(path.diameter, earths_diameter)].name, solar_system)]assert earth == ['Earth']```Any single argument function can be used as an operator.  This example uses a Regular Expression to findsplanets that end with s.```pythonname_ends_with_s = re.compile(r&quot;\w+s&quot;).matchearth = [planet for planet in find(path.rec[has(path.name, name_ends_with_s)].name, solar_system)]assert earth == ['Venus', 'Mars', 'Uranus']```This example uses a closure to find planets that have the same diameter as earth.```pythondef smaller_than_earth(value):    return value &lt; 12756earth = [planet for planet in find(path.rec[has(path.diameter, smaller_than_earth)].name, solar_system)]assert earth == ['Mercury', 'Venus', 'Mars']```### logical and, or and not filters#### has_allA regular express to test if second letter in the value is an a.```pythonsecond_letter_is_a = re.compile(r&quot;.a.*&quot;).fullmatch```The **has_all** function evaluates as the logical **and** operator.   It is equivalent to: (arg1 and arg2 and ...)```pythonfound = [planet for planet in find(    path.rec[has_all(path.diameter &lt; 10000, (path.name, second_letter_is_a))].name,    solar_system)         ]assert found == ['Mars']```#### has_anyThe **has_any** function evaluates as the logical **or** operator.   It is equivalent to: (arg1 and arg2 and ...)```pythonfound = [planet for planet in find(    path.rec[has_any(path.diameter &lt; 10000, (path.name, second_letter_is_a))].name,    solar_system)         ]assert found == ['Mercury', 'Earth', 'Mars', 'Saturn']```#### has_notThe **has_not** function evaluates as the logical **not** operator.   It is equivalent to: (not arg)This example find all the planets names not not equal to Earth.  Note the double nots.```pythonfound = [planet for planet in find(    path.rec[has_not(path.name != 'Earth')].name,    solar_system)         ]assert found == ['Earth']```#### Combining has, has_all, has_any, and has_not filters.Each of the **has** function can be passed as arguments to any of the other **has** function to construct complexboolean equation.  This example is equivalent to:(10000 &gt; diameter  or diameter &gt; 20000) and second_letter_is_a(name))```pythonfound = [planet for planet in find(    path.rec[has_all(has_any(path.diameter &lt; 10000, path.diameter &gt; 20000), (path.name, second_letter_is_a))].name,    solar_system)         ]assert found == ['Mars', 'Saturn']```#### has.theseThe decorator **has.these** can be used to construct the boolean equations more explicitly.  This example showsto use python built in and, or and not operators.```python@has.these(path.diameter &lt; 10000, path.diameter &gt; 20000, (path.name, second_letter_is_a))def predicate(parent_match: Match, small_diameter, large_diameter, name_second_letter_is_a):    return (small_diameter(parent_match) or large_diameter(parent_match)) and name_second_letter_is_a(parent_match)found = [planet for planet in find(path.rec[predicate].name, solar_system)]assert found == ['Mars', 'Saturn']```### A custom filter.A predicate is a single argument function that returns anything. The argument is the current match.   The hasfunction is a fancy predicate.This example writes a custom predicate that find all of Earth's neighbours.```pythondef my_neighbor_is_earth(match: Match):    i_am_planet = get_match(path.parent.parent.parent.planets, match, must_match=False)    if not i_am_planet:        return False    index_before_planet = match.data_name - 1    before_planet = get_match(path[index_before_planet][has(path.name == &quot;Earth&quot;)], match.parent,                              must_match=False)    if before_planet:        return True    index_after_planet = match.data_name + 1    before_planet = get_match(path[index_after_planet][has(path.name == &quot;Earth&quot;)], match.parent,                              must_match=False)    if before_planet:        return True    return Falseearth = [planet for planet in find(path.rec[my_neighbor_is_earth].name, solar_system)]assert earth == ['Venus', 'Mars']```# Class Descriptors### basic path descriptorpaths can be added as properties to a class using the path_descriptor function.```pythonplanets = path.star.planets.wc[wc]class SolarSystem(Document):    jupiter_name = attr(path.star.planets.outer[0].name)    saturn_name = attr(path.star.planets.outer[1].name)    big_planets = attr(planets[has(path.diameter &gt; 25000)].name, getter=find)    small_planets = attr(planets[has(path.diameter &lt;= 25000)].name, getter=find, to_wrapped_value=list)    number_of_planets = attr(planets, getter=find, to_wrapped_value=lambda itr: len(list(itr)))```The property support both gets and sets and dels```pythonss = SolarSystem(solar_system)assert ss.jupiter_name == 'Jupiter'assert ss.saturn_name == 'Saturn'```Rename Jupiter to Planet 5```pythonss.jupiter_name = 'Planet 5'assert ss.jupiter_name == 'Planet 5'```The assignment operation alters the original document.```pythonassert solar_system[&quot;star&quot;][&quot;planets&quot;][&quot;outer&quot;][0][&quot;name&quot;] == 'Planet 5'```remove Jupiter's name```pythondel ss.jupiter_namewith pytest.raises(MatchNotFoundError):    print(ss.jupiter_name)assert &quot;name&quot; not in solar_system[&quot;star&quot;][&quot;planets&quot;][&quot;outer&quot;][0]```There are still 8 planets because only Jupiter's name was delete```pythonassert ss.number_of_planets == 8```list all the big planets.  Remember Jupiter was deleted.```pythonbig_planets = [name for name in ss.big_planets]assert big_planets == ['Saturn', 'Uranus', 'Neptune']```list all the small planets.```pythonassert ss.small_planets == ['Mercury', 'Venus', 'Earth', 'Mars']```### document typed path descriptorA descriptor support wrapping json types with an adaptor class. This example wraps the json that represents aplanet with the planet class.   The Planet class extends the Document class which provides the marshallingmethods.```pythonclass Planet(Document):    name = attr(path.name)class SolarSystem(Document):    jupiter = attr_typed(Planet, path.star.planets.outer[0])    planets = attr_iter_typed(Planet, path.star.planets.wc[wc])    outer_planets = attr_list_typed(Planet, path.star.planets.outer)```The getter returns the planet type```pythonss = SolarSystem(solar_system)planet = ss.jupiterassert planet.name == 'Jupiter'```rename Jupiter to Planet 5```pythonplanet.name = 'Planet 5'assert planet.name == 'Planet 5'```The assignment operation alters the original document.```pythonassert solar_system[&quot;star&quot;][&quot;planets&quot;][&quot;outer&quot;][0][&quot;name&quot;] == 'Planet 5'```Jupiter can be renamed by replacing the planet with an imposter.```pythonimpostor_planet = Planet({})impostor_planet.name = 'Imposter Jupiter'ss.jupiter = impostor_planetassert ss.jupiter.name == 'Imposter Jupiter'```The imposter planet also alters the original document.```pythonassert solar_system[&quot;star&quot;][&quot;planets&quot;][&quot;outer&quot;][0][&quot;name&quot;] == 'Imposter Jupiter'```An attribute descriptor can return an iterator where each element is converted to the correct type.```pythonplanets = [planet.name for planet in ss.planets]assert planets == ['Mercury', 'Venus', 'Earth', 'Mars', 'Imposter Jupiter', 'Saturn', 'Uranus', 'Neptune']```An attribute descriptor can return an list where each element is converted to the correct type.```pythonassert ss.outer_planets[0].name == 'Imposter Jupiter'```The list can be modified and the underline document is modified too.```pythonjupiter = Planet({})jupiter.name = 'Jupiter'ss.outer_planets[0] = jupiterplanets = [planet.name for planet in ss.planets]assert planets == ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']```### custom typed path descriptorA descriptor support wrapping json types with an adaptor class. This example wraps the json that represents aplanet with the planet class.   This Planet class defines its own marshalling methods.```pythonclass Planet:    def __init__(self, name: str = None):        self._name = name    @property    def name(self) -&gt; str:        return self._name    @name.setter    def name(self, name: str):        self._name = name    @staticmethod    def to_wrapped_value(json_: JsonArgTypes) -&gt; Planet:        return Planet(json_[&quot;name&quot;])    @staticmethod    def to_json_value(planet_: Planet) -&gt; JsonArgTypes:        return {&quot;name&quot;: planet_.name}class SolarSystem(Document):    jupiter = attr_typed(Planet, path.star.planets.outer[0],                         to_wrapped_value=Planet.to_wrapped_value,                         to_json_value=Planet.to_json_value)    planets = attr_iter_typed(Planet, path.star.planets.wc[wc],                              to_wrapped_value=Planet.to_wrapped_value)    outer_planets = attr_list_typed(Planet, path.star.planets.outer,                                    to_wrapped_value=Planet.to_wrapped_value,                                    to_json_value=Planet.to_json_value)```The getter returns the planet type```pythonss = SolarSystem(solar_system)planet = ss.jupiterassert planet.name == 'Jupiter'```rename Jupiter to Planet 5```pythonplanet.name = 'Planet 5'assert planet.name == 'Planet 5'```Jupiter can be renamed by replacing the planet with an imposter.```pythonimpostor_planet = Planet()impostor_planet.name = 'Imposter Jupiter'ss.jupiter = impostor_planetassert ss.jupiter.name == 'Imposter Jupiter'```The imposter planet also alters the original document.```pythonassert solar_system[&quot;star&quot;][&quot;planets&quot;][&quot;outer&quot;][0][&quot;name&quot;] == 'Imposter Jupiter'```An attribute descriptor can return an iterator where each element is converted to the correct type.```pythonplanets = [planet.name for planet in ss.planets]assert planets == ['Mercury', 'Venus', 'Earth', 'Mars', 'Imposter Jupiter', 'Saturn', 'Uranus', 'Neptune']```An attribute descriptor can return an list where each element is converted to the correct type.```pythonassert ss.outer_planets[0].name == 'Imposter Jupiter'```The list can be modified and the underline document is modified too.```pythonjupiter = Planet()jupiter.name = 'Jupiter'ss.outer_planets[0] = jupiterplanets = [planet.name for planet in ss.planets]assert planets == ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']```</longdescription>
</pkgmetadata>