<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>REST Navigator==============|Build Status| |Coverage Status| |Pypi Status| |Documentation Status|REST Navigator is a python library for interacting with hypermedia apis(`REST level3 &lt;http://martinfowler.com/articles/richardsonMaturityModel.html#level3&gt;`__).Right now, it only supports`HAL+JSON &lt;http://tools.ietf.org/html/draft-kelly-json-hal-05&gt;`__ but itshould be general enough to extend to other formats eventually. Itsfirst goal is to make interacting with HAL hypermedia apis as painlessas possible, while discouraging REST anti-patterns.To install it, simply use pip:.. code:: bash    $ pip install restnavigatorContents---------  `How to use it &lt;#how-to-use-it&gt;`__   -  `Links &lt;#links&gt;`__   -  `GET requests &lt;#get-requests&gt;`__   -  `Link relation docs &lt;#link-relation-docs&gt;`__   -  `POST requests &lt;#post-requests&gt;`__   -  `Errors &lt;#errors&gt;`__   -  `Templated links &lt;#templated-links&gt;`__   -  `Authentication &lt;#authentication&gt;`__-  `Additional Topics &lt;#additional-topics&gt;`__   -  `Identity Map &lt;#identity-map&gt;`__   -  `Iterating over a Navigator &lt;#iterating-over-a-navigator&gt;`__   -  `Headers (Request vs. Response) &lt;#headers-request-vs-response&gt;`__   -  `Bracket mini-language &lt;#bracket-minilanguage&gt;`__   -  `Finding the right link &lt;#finding-the-right-link&gt;`__   -  `Default curie &lt;#default-curie&gt;`__   -  `Specifying an api name &lt;#specifying-an-api-name&gt;`__   -  `Embedded documents &lt;#embedded-documents&gt;`__-  `Development &lt;#development&gt;`__   -  `Testing &lt;#testing&gt;`__   -  `Planned for the future &lt;#planned-for-the-future&gt;`__.. raw:: html   &lt;!-- end toc --&gt;How to use it-------------To begin interacting with a HAL api, you've got to create a HALNavigatorthat points to the api root. Ideally, in a hypermedia API, the root URLis the only URL that needs to be hardcoded in your application. Allother URLs are obtained from the api responses themselves (think of yourapi client as 'clicking on links', rather than having the urlshardcoded).As an example, we'll connect to the haltalk api... code:: python    &gt;&gt;&gt; from restnavigator import Navigator    &gt;&gt;&gt; N = Navigator.hal('http://haltalk.herokuapp.com/', default_curie=&quot;ht&quot;)    &gt;&gt;&gt; N    HALNavigator(Haltalk)Links~~~~~Usually, with the index (normally at the api root), you're mostinterested in the links. Let's look at those:.. code:: python    &gt;&gt;&gt; N.links()    {u'ht:users': HALNavigator(Haltalk.users),     u'ht:signup': HALNavigator(Haltalk.signup),     u'ht:me': TemplatedThunk(Haltalk.users.{name}),     u'ht:latest-posts': HALNavigator(Haltalk.posts.latest)}(This may take a moment because asking for the links causes theHALNavigator to actually request the resource from the server).Here we can see that the links are organized by their relation type (thekey), and each key corresponds to a new HALNavigator that representssome other resource. Relation types are extremely important in restfulapis: we need them to be able to determine what a link means in relationto the current resource, in a way that is automatable.GET requests~~~~~~~~~~~~In addition, the root has some state associated with it which you canget in two different ways:.. code:: python    &gt;&gt;&gt; N() # cached state of resource (obtained when we looked at N.links)    {u'hint_1': u'You need an account to post stuff..',     u'hint_2': u'Create one by POSTing via the ht:signup link..',     u'hint_3': u'Click the orange buttons on the right to make POST requests..',     u'hint_4': u'Click the green button to follow a link with a GET request..',     u'hint_5': u'Click the book icon to read docs for the link relation.',     u'welcome': u'Welcome to a haltalk server.'}    &gt;&gt;&gt; N.fetch() # will refetch the resource from the server    {u'hint_1': u'You need an account to post stuff..',     u'hint_2': u'Create one by POSTing via the ht:signup link..',     u'hint_3': u'Click the orange buttons on the right to make POST requests..',     u'hint_4': u'Click the green button to follow a link with a GET request..',     u'hint_5': u'Click the book icon to read docs for the link relation.',     u'welcome': u'Welcome to a haltalk server.'}Calling a HALNavigator will execute a GET request against the resourceand returns its value (which it will cache).Link relation docs~~~~~~~~~~~~~~~~~~Let's register a hal talk account. Unfortunately, we don't really knowhow to do that, so let's look at the documentation. The ``ht:signup``link looks promising, let's check that:.. code:: python    &gt;&gt;&gt; N.docsfor('ht:signup')A browser will open to http://haltalk.herokuapp.com/rels/signup.What? Popping up a browser from a library call? Yes, that's howrest\_navigator rolls. The way we see it: docs are for humans, and whilecustom rel-types are URIs, they shouldn't automatically be dereferencedby a program that interacts with the api. So popping up a browser servestwo purposes:1. It allows easy access to the documentation at the time when you most   need it: when you're mucking about in the command line trying to   figure out how to interact with the api.2. It reminds you not to try to automatically dereference the rel   documentation and parse it in your application.If you need a more robust way to browse the api and the documentation,`HAL Browser &lt;https://github.com/mikekelly/hal-browser&gt;`__ is probablyyour best bet.POST requests~~~~~~~~~~~~~The docs for ``ht:signup`` explain the format of the POST request tosign up. So let's actually sign up. Since we've set ``&quot;ht&quot;`` as ourdefault curie, we can skip typing the curie for convenience. (Note:haltalk is a toy api for example purposes, don't ever send plaintextpasswords over an unencrypted connection in a real app!):.. code:: python    &gt;&gt;&gt; fred23 = N['signup'].create(    ... {'username': 'fred23',    ...  'password': 'hunter2',    ...  'real_name': 'Fred 23'}    ... )    &gt;&gt;&gt; fred23    HALNavigator(Haltalk.users.fred23)Errors~~~~~~If the user name had already been in use, a 400 would have been returnedfrom the haltalk api. rest\_navigator follows the Zen of Pythonguideline &quot;Errors should never pass silently&quot;. An exception would havebeen raised on a 400 or 500 status code. You can squelch this exceptionand just have the post call return a ``HALNavigator`` with a 400/500status code if you want:.. code:: python    &gt;&gt;&gt; dup_signup = N['ht:signup'].create({    ...    'username': 'fred23',    ...    'password': 'hunter2',    ...    'real_name': 'Fred Wilson'    ... }, raise_exc=False)    &gt;&gt;&gt; dup_signup    OrphanHALNavigator(Haltalk.signup)  # 400!    &gt;&gt;&gt; dup_signup.status    (400, 'Bad Request')    &gt;&gt;&gt; dup_signup.state    {u&quot;errors&quot;: {u&quot;username&quot;: [u&quot;is already taken&quot;]}}Templated links~~~~~~~~~~~~~~~Now that we've signed up, lets take a look at our profile. The link fora user's profile is a templated link, which restnavigator represents asa ``PartialNavigator``. Similar to python's`functools.partial &lt;https://docs.python.org/2/library/functools.html#functools.partial&gt;`__,a ``PartialNavigator`` is an object that needs a few more arguments togive you a full navigator back. Despite its name, it can't talk to thenetwork by itself. Its job is to to generate new navigators for you. Youcan see what variables it has by looking at its ``.variables`` attribute(its ``__repr__`` hints at this as well):.. code:: python    &gt;&gt;&gt; N.links().keys()    ['ht:latest-posts', 'ht:me', 'ht:users', 'ht:signup']    &gt;&gt;&gt; N['ht:me']    PartialNavigator(Haltalk.users.{name})    &gt;&gt;&gt; N['ht:me'].variables    set(['name'])The documentation for the ``ht:me`` rel type should tell us how the nameparameter is supposed to work, but in this case it's fairly obvious(plug in the username). Two provide the template parameters, just callit with keyword args:.. code:: python    &gt;&gt;&gt; partial_me = N['ht:me']    &gt;&gt;&gt; partial_me.template_uri    'http://haltalk.herokuapp.com/users/{name}'    &gt;&gt;&gt; Fred = partial_me(name='fred23')    &gt;&gt;&gt; Fred    HALNavigator('haltalk.users.fred23')Now that we have a real navigator, we can fetch the resource:.. code:: python    &gt;&gt;&gt; Fred()    {u'bio': None, u'real_name': u'Fred Wilson', u'username': u'fred23'}Authentication~~~~~~~~~~~~~~In order to post something to haltalk, we need to authenticate with ournewly created account. HALNavigator allows any `authentication methodthat requestssupports &lt;http://www.python-requests.org/en/latest/user/advanced/#custom-authentication&gt;`__(so OAuth etc). For basic auth (which haltalk uses), we can just pass atuple... code:: python    &gt;&gt;&gt; N.authenticate(('fred23', 'hunter2'))  # All subsequent calls are authenticatedThis doesn't send anything to the server, it just sets theauthentication details that we'll use on the next request. Otherauthentication methods may contact the server immediately.Now we can put it all together to create a new post:.. code:: python    &gt;&gt;&gt; N_post = N['me'](name='fred23')['posts'].create({'content': 'My first post'})    &gt;&gt;&gt; N_post    HALNavigator(Haltalk.posts.523670eff0e6370002000001)    &gt;&gt;&gt; N_post()    {'content': 'My first post', 'created_at': '2015-06-13T19:38:59+00:00'}It is also possible to specify a custom requests Session object when creating a new navigator.For example, if you want to talk to a OAuth2 protected api, simply pass an OAuth2 Session object that will be used for all requests done by HALNavigator:.. code:: python    &gt;&gt;&gt; from requests_oauthlib import OAuth2Session    &gt;&gt;&gt; oauth2_session = OAuth2Session(r'client_id', token='token')    &gt;&gt;&gt; N = Navigator.hal('https://api.example.com', session=oauth2_session)Additional Topics-----------------Identity Map~~~~~~~~~~~~You don't need to worry about inadvertently having two differentnavigators pointing to the same resource. rest\_navigator will reuse theexisting navigator instead of creating a new oneIterating over a Navigator~~~~~~~~~~~~~~~~~~~~~~~~~~If a resource has a link with the rel &quot;next&quot;, the navigator for thatresource can be used as a python iterator. It will automatically raise aStopIteration exception if a resource in the chain does not have a nextlink. This makes moving through paged resources really simple andpythonic:.. code:: python    post_navigator = fred['ht:posts']    for post in post_navigator:        # the first post will be post_navigator itself        print(post.state)Headers (Request vs. Response)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~HTTP response headers are available in ``N.response.headers``Headers that will be sent on each request can be obtained through thesession:.. code:: python    &gt;&gt;&gt; N.session.headers    # Cookies, etcBracket mini-language~~~~~~~~~~~~~~~~~~~~~The bracket (``[]``) operator on Navigators has a lot of power. As wesaw earlier, the main use is to get a new Navigator from a linkrelation:.. code:: python    &gt;&gt;&gt; N2 = N['curie:link_rel']But, it can also go more than one link deep, which is equivalent tousing multiple brackets in a row:.. code:: python    &gt;&gt;&gt; N3 = N['curie:first_link', 'curie:second_link']    # equivalent to:    N3 = N['curie:first_link']['curie:second_link']And of course, if you set a default curie, you can omit it:.. code:: python    &gt;&gt;&gt; N3 = N['first_link', 'second_link']Internally, this is completely equivalent to repeatedly applying thebracket operator, so you can even use it to jump over intermediateobjects that aren't Navigators themselves:.. code:: python    &gt;&gt;&gt; N['some-link', 3, 'another-link']This would use the ``some-link`` link relation, select the third linkfrom the list, and then follow ``another-link`` from that resource.Finding the right link~~~~~~~~~~~~~~~~~~~~~~Normally, you can chain together brackets to jump from one resource toanother in one go:.. code:: python    &gt;&gt;&gt; N['ht:widget']['ht:gadget']This will return a Navigator for the ``ht:widget`` link relation andthen immediately fetch the resource and return a Navigator for the``ht:gadget`` link relation. This works great if you have only one linkper relation, but HAL allows multiple links per relation. Say forinstance we have some links like the following:.. code:: javascript{    &quot;ht:some_rel: [        {            &quot;href&quot;: &quot;/api/widget/1&quot;,            &quot;name&quot;: &quot;widget1&quot;,            &quot;profile&quot;: &quot;widget&quot;        },        {            &quot;href&quot;: &quot;/api/widget/2&quot;,            &quot;name&quot;: &quot;widget2&quot;,            &quot;profile&quot;: &quot;widget&quot;        },        {            &quot;href&quot;: &quot;/api/gadget/1&quot;,            &quot;name&quot;: &quot;gadget1&quot;,            &quot;profile&quot;: &quot;gadget&quot;        }    ]When we go to get the ``ht:some_rel``, we'll get multiple results:.. code:: python    &gt;&gt;&gt; N['ht:some_rel']    [HALNavigator(api.widget[1]),     HALNavigator(api.widget[2]),     HALNavigator(api.gadget[1])]How do we know which one is the one we want? The `HALspec &lt;https://tools.ietf.org/html/draft-kelly-json-hal-06#section-5.5&gt;`__says links with the same rel can be disambiguated by the ``name`` linkproperty:.. code:: python    &gt;&gt;&gt; N.links['ht:some_rel'].get_by('name', 'gadget1')    HALNavigator(api.gadget[1])    &gt;&gt;&gt; N.links['ht:some_rel'].named('gadget1')  # same as previous    HALNavigator(api.gadget[1])We could also use other properties to slice and dice the list:.. code:: python    &gt;&gt;&gt; N.links['ht:some_rel'].get_by('profile', 'gadget')    HALNavigator(api.gadget[1])    &gt;&gt;&gt; N.links['ht:some_rel'].getall_by('profile', 'widget')    [HALNavigator(api.widget[1]), HALNavigator(api.widget[2])]This works for any property on links, not just the standard HALproperties.Default curie~~~~~~~~~~~~~You may specify a default curie when creating your Navigator:.. code:: python    &gt;&gt;&gt; N = HALNavigator('http://haltalk.herokuapp.com', curie='ht')Now, when you follow links, you may leave off the default curie if youwant:.. code:: python    &gt;&gt;&gt; N.links    {'ht:users': [HALNavigator(Haltalk.users)],     'ht:signup': [HALNavigator(Haltalk.signup)],     'ht:me': [HALNavigator(Haltalk.users.{name})],     'ht:latest-posts': [HALNavigator(Haltalk.posts.latest)]    }    &gt;&gt;&gt; N['ht:users']    HALNavigator(Haltalk.users)    &gt;&gt;&gt; N['users']    HALNavigator(Haltalk.users)The only exception is where the key being supplied is a `IANA registeredlinkrelation &lt;http://www.iana.org/assignments/link-relations/link-relations.xhtml&gt;`__,and there is a conflict (hint: this should be quite rare):.. code:: python    &gt;&gt;&gt; N.links    {'ht:next': HALNavigator(Haltalk.unregistered),      'next': HALNavigator(Haltalk.registered)}    &gt;&gt;&gt; N['next']    HALNavigator(Haltalk.registered)Specifying an api name~~~~~~~~~~~~~~~~~~~~~~Sometimes the automatic api naming guesses poorly. If you'd like tooverride the default name, you can specify it when creating thenavigator:.. code:: python    &gt;&gt;&gt; N = Navigator.hal('http://api.example.com', apiname='MySpecialAPI')    HALNavigator(MySpecialAPI)Embedded documents~~~~~~~~~~~~~~~~~~In rest\_navigator, embedded documents are treated transparently. Thismeans that in many cases you don't need to worry about whether adocument is embedded or whether it's just linked.As an example, assume we have a resource like the following:.. code:: json    {      &quot;_links&quot;: {         ...         &quot;xx:yams&quot;: {            &quot;href&quot;: &quot;/yams&quot;         }         ...      },      &quot;_embedded&quot;: {         &quot;xx:pickles&quot;: {           &quot;_links&quot;: {             &quot;self&quot;: {&quot;href&quot;: &quot;/pickles&quot;}           },           &quot;state&quot;: &quot;A pickle&quot;         }      }      ...    }From here, you would access both the ``yams`` and the ``pickles``resource with normal bracket syntax:.. code:: python    &gt;&gt;&gt; Yams = N['xx:yams']    &gt;&gt;&gt; Pickles = N['xx:pickles']The only difference here is that ``Yams`` hasn't been fetched yet, while``Pickles`` is considered &quot;resolved&quot; already because we got it as anembedded document.::    &gt;&gt;&gt; Yams.resolved    False    &gt;&gt;&gt; Yams.state # None    &gt;&gt;&gt; Pickles.resolved    True    &gt;&gt;&gt; Pickles.state    {'state': 'A pickle'}If an embedded document has a self link, you can treat it just like youwould any other resource. So if you want to refresh the resource, it'sas easy as:.. code:: python    &gt;&gt;&gt; Pickles.fetch()This will fetch the current state of the resource from the uri in itsself link, even if you've never directly requested that uri before. Ifan embedded resource doesn't have a self link, it will be an``OrphanNavigator`` with the parent set to the resource it was embeddedin.Of course, if you need to directly distinguish between linked resourcesand embedded resources, there is an out:.. code:: python    &gt;&gt;&gt; N.embedded()    {'xx:pickles': HALNavigator(api.pickles)    &gt;&gt;&gt; N.links()    {'xx:yams': HALNavigator(api.yams)However, when using the ``in`` operator, it will look in both for a keyyou're interested in:.. code:: python    &gt;&gt;&gt; 'yams' in N  # default curie is taken into account!    True    &gt;&gt;&gt; 'xx:yams in N    True    &gt;&gt;&gt; 'xx:pickles' in N    TrueDevelopment-----------Testing~~~~~~~To run tests, first install the `pytestframework &lt;http://pytest.org/latest/getting-started.html&gt;`__:::    $ pip install -U pytestTo run tests, execute following from the root of the source directory:::    $ py.testPlanned for the future~~~~~~~~~~~~~~~~~~~~~~-  Ability to add hooks for different types, rels and profiles. If a   link has one of these properties, it will call your hook when doing a   server call.-  Since HAL doesn't specify what content type POSTs, PUTs, and PATCHes   need to have, you can specify the hooks based on what the server will   accept. This can trigger off either the rel type of the link, or rest   navigator can do content negotiation over HTTP with the server   directly to see what content types that resource will accept.Contributors~~~~~~~~~~~~Thanks very much to rest navigator's contributors:-  `dudycooly &lt;http://github.com/dudycooly&gt;`__-  `bubenkoff &lt;http://github.com/bubenkoff&gt;`__-  `bbsgfalconer &lt;http://github.com/bbsgfalconer&gt;`__.. |Build Status| image:: https://img.shields.io/travis/deontologician/restnavigator/next.svg   :target: https://travis-ci.org/deontologician/restnavigator.. |Coverage Status| image:: https://img.shields.io/coveralls/deontologician/rest_navigator/next.svg   :target: https://coveralls.io/r/deontologician/rest_navigator?branch=next.. |Documentation Status| image:: https://readthedocs.org/projects/rest-navigator/badge/?version=latest   :target: https://readthedocs.org/projects/rest-navigator/?badge=latest   :alt: Documentation Status.. |Pypi Status| image:: https://pypip.in/v/restnavigator/badge.png   :target: https://crate.io/packages/restnavigator/Changelog=========Unreleased----------- TBD1.0---- Embedded support- Ability to specify default curies- Resources with no URL are now represented by a special Navigator type called OrphanNavigators- IP addresses can be used in the url (@dudycooly)- All tests pass in python 2.6 -&gt; 3.4 (@bubenkoff), and travis now runs tox to ensure they stay that way- Support the DELETE, and PATCH methods- posts allow an empty body (@bbsgfalconer)- Much improved content negotiation (@bbsgfalconer)- There was also a major refactoring that changed how Navigators are created and internally cleaned up a    lot of really messy code.</longdescription>
</pkgmetadata>