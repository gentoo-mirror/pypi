<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># coveo-testingA set of test/pytest helpers to facilitate common routines.Content in a nutshell:- Reusable pytest markers (UnitTest, IntegrationTest)- Unique ID generation for tests- Multiline logging assertions with includes, excludes, levels and comprehensive assertion output- Refactorable `unittest.mock.patch('this.module')` module references- Human-readable (but still customizable) display for parametrized testsThis project is used as the test base for all other projects in this repository.Therefore, it cannot depend on any of them.More complex use cases may be implemented in the `coveo-testing-extras` project. That's also where you can depend on projects that depend on `coveo-testing`. # pytest markers and auto-registrationThis enables code completion on markers.Three markers are already provided: `[UnitTest, Integration, Interactive]`Here's how you can create additional markers:```python# /test_some_module/markers.pyimport pytestDockerTest = pytest.mark.docker_testCloudTest = pytest.mark.cloud_testALL_MARKERS = [DockerTest, CloudTest]```You can then import these markers and decorate your test functions accordingly:```python# /test_some_module/test_something.pyfrom coveo_testing.markers import UnitTest, Integration, Interactivefrom test_some_module.markers import CloudTest, DockerTest@UnitTestdef test_unit() -&gt; None:    ...  # designed to be fast and lightweight, most likely parametrized@Integrationdef test_integration() -&gt; None:    ...  # combines multiple features to achieve a test@CloudTestdef test_in_the_cloud() -&gt; None:    ...  # this could be a post-deployment test, for instance.@DockerTest@Integrationdef test_through_docker() -&gt; None:    ... # will run whenever docker tests or integration tests are requested@Interactivedef test_interactive() -&gt; None:    ...  # these tests rely on eye-validations, special developer setups, etc  ```Pytest will issue a warning when markers are not registered.To register coveo-testing's markers along with your custom markers, use the provided `register_markers` method:```python# /test_some_module/conftest.pyfrom _pytest.config import Configfrom coveo_testing.markers import register_markersfrom test_some_module.markers import ALL_MARKERSdef pytest_configure(config: Config) -&gt; None:    &quot;&quot;&quot;This pytest hook is ran once, before collecting tests.&quot;&quot;&quot;    register_markers(config, *ALL_MARKERS)```# Human-readable unique ID generationThe generated ID has this format:`friendly-name.timestamp.pid.host.executor.sequence`- friendly-name:  - provided by you, for your own benefit    - timestamp:   - format &quot;%m%d%H%M%S&quot; (month, day, hour, minutes, seconds)  - computed once, when TestId is imported    - pid:  - the pid of the python process    - host:  - the network name of the machine- executor:  - the content of the `EXECUTOR_NUMBER` environment variable  - returns 'default' when not defined    - historically, this variable comes from jenkins  - conceptually, it can be used to help distribute (and identify) tests and executors- sequence:  - Thread-safe  - Each `friendly-name` has an isolated `sequence` that starts at 0  - Incremented on each new instance  - Enables support for parallel parametrized tests```pythonfrom coveo_testing.temporary_resource.unique_id import TestId, unique_test_id# the friendly name is the only thing you need to specifytest_id = TestId('friendly-name')str(test_id)'friendly-name.0202152243.18836.WORKSTATION.default.0'# you can pass the instance around to share the IDstr(test_id)'friendly-name.0202152243.18836.WORKSTATION.default.0'# create new instances to increment the sequence numbertest_id = TestId('friendly-name')str(test_id)'friendly-name.0202152243.18836.WORKSTATION.default.1'# use it in parallel parameterized testsimport pytest@pytest.mark.parametrize('param', (True, False))def test_param(param: bool, unique_test_id: TestId) -&gt; None:    # in this case, the friendly name is the function name and    # the sequence will increase on each parameter    # test_param.0202152243.18836.WORKSTATION.default.0    # test_param.0202152243.18836.WORKSTATION.default.1    ...```# multiline logging assertionsMaybe pytest's `caplog` is enough for your needs, or maybe you need more options.This tool uses `in` and `not in` to match strings in a case-sensitive way.```pythonimport loggingfrom coveo_testing.logging import assert_loggingwith assert_logging(        logging.getLogger('logger-name'),        present=['evidence1', 'evidence2'],         absent=[...],         level=logging.WARN):    ...```# Human-readable (but still customizable) display for parametrized testsIf you're like me, you typed `@pytest.mark.parametrize` wrong a couple of times!Enable IDE completion by using this one instead:```pythonfrom coveo_testing.parametrize import parametrize@parametrize('var', (True, False))def test_var(var: bool) -&gt; None:    ...```It has one difference vs the pytest one, and it's the way it formats the &quot;parameter name&quot; for each iteration of the test.Pytest will skip a lot of types and will simply name your test &quot;var0&quot;, &quot;var1&quot; and so on.Using this `@parametrize` instead, the variable's content will be inspected:```pythonfrom typing import Anyfrom coveo_testing.parametrize import parametrizeimport pytestclass StrMe:    def __init__(self, var: Any) -&gt; None:      self.var = var          def __str__(self) -&gt; str:      return f&quot;Value: {self.var}&quot;@parametrize('var', [['list', 'display'], [StrMe('hello')]])def test_param(var: bool) -&gt; None:    ...@pytest.mark.parametrize('var', [['list', 'display'], [StrMe('hello')]])def test_param_from_pytest(var: bool) -&gt; None:    ...```If you run `pytest --collect-only` you will obtain the following:```    &lt;Function test_param[list-display]&gt;    &lt;Function test_param[Value: hello]&gt;    &lt;Function test_param_from_pytest[var0]&gt;    &lt;Function test_param_from_pytest[var1]&gt;```# Refactorable mock targetsThe `ref` tool has moved to its own package called [coveo-ref](https://github.com/coveooss/coveo-python-oss/tree/main/coveo-ref).## Backward CompatibilityYou can still continue using `ref` from `coveo-testing`: the backward compatibility patch will not be deprecated.## Migration GuideIf you'd rather use the new package directly:- Import the `coveo-ref` dependency into your project- Replace `from coveo_testing.mocks import ref` by `from coveo_ref import ref`- Exceptions have been moved to `coveo_ref.exceptions`</longdescription>
</pkgmetadata>