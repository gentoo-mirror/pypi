<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://badge.fury.io/py/pyebus.svg    :target: https://badge.fury.io/py/pyebus.. image:: https://img.shields.io/pypi/dm/pyebus.svg?label=pypi%20downloads   :target: https://pypi.python.org/pypi/pyebus.. image:: https://travis-ci.com/c0fec0de/pyebus.svg?branch=main    :target: https://travis-ci.com/github/c0fec0de/pyebus.. image:: https://readthedocs.org/projects/pyebus/badge/?version=latest    :target: https://pyebus.readthedocs.io/en/latest/?badge=latest.. image:: https://img.shields.io/pypi/pyversions/pyebus.svg   :target: https://pypi.python.org/pypi/pyebus.. image:: https://img.shields.io/badge/code%20style-pep8-brightgreen.svg   :target: https://www.python.org/dev/peps/pep-0008/.. image:: https://img.shields.io/badge/code%20style-pep257-brightgreen.svg   :target: https://www.python.org/dev/peps/pep-0257/.. image:: https://img.shields.io/badge/code%20style-black-000000.svg   :target: https://github.com/psf/blackPythonic interface to EBUSD_.Installation============To install the `pyebus` module run::    pip install pyebusIf you do not have write-permissions to the python installation, try::    pip install pyebus --userCommand-Line-Interface======================Usage::usage: ebustool [-h] [--host HOST] [--port PORT] [--timeout TIMEOUT] [--version] [--debug] {cmd,listen,ls,observe,read,state,write,info} ...positional arguments:  {cmd,listen,ls,observe,read,state,write,info}                        Sub Commands    cmd                 Issue TCP Command on EBUSD. See https://github.com/john30/ebusd/wiki/3.1.-TCP-client-commands for reference.    listen              Listen on the bus, decode messages and print    ls                  List all messages    observe             Read all known messages once and continue listening so that ALL EBUS values are available, decode every message and print.    read                Read values from the bus, decode and print    state               Show EBUSD state    write               Write value to the bus    info                Show EBUSD meta informationoptional arguments:  -h, --help            show this help message and exit  --host HOST, -H HOST  EBUSD address. Default is '127.0.0.1'.  --port PORT, -P PORT  EBUSD port. Default is 8888.  --timeout TIMEOUT, -T TIMEOUT                        EBUSD connection timeout. Default is 10.  --version             show program's version number and exit  --debugList all messages and fields----------------------------The `ls` command lists all messages `CIRCUIT/MESSAGENAME/FIELDNAME     rwuSP INFO`::$ ebt -H 192.168.1.4 lsmc/DateTime/dcfstate                     r---1 nosignal, ok, sync, valid [DCF Empf√§ngerstatus]mc/DateTime/btime                        r---1 HOUR:MINUTE:SECOND [Uhrzeit]mc/DateTime/bdate                        r---1 DAY.MONTH.YEAR [Datum]mc/DateTime/temp2                        r---1 Float within [-127.99:127.99] with 0.00390625 fractionmc/DateTime/bdate+btime+dcfstate         r---1 DAY.MONTH.YEAR HOUR:MINUTE:SECONDmc/FlowTemp/temp                         r---1 Float within [-2047.9:2047.9] with 0.0625 fraction [Temperatur]mc/FlowTemp/sensor                       r---1 ok, circuit, cutoffmc/FlowTemp/temp+sensor                  r---1 Float within [-2047.9:2047.9] with 0.0625 fractionmc/FlowTempDesired/temp1                 r---1 Float within [0:100] with 0.5 fractionmc/FlowTempMax/temp0                     rw--2 Integer within [0:254]mc/FlowTempMin/temp0                     rw--2 Integer within [0:254]mc/OperatingMode/mcmode                  rw--2 disabled, on, off, auto, eco, lowmc/TempDesired/temp1                     rw--2 Float within [0:100] with 0.5 fractionmc/TempDesiredLow/temp1                  rw--2 Float within [0:100] with 0.5 fraction`CIRCUIT/MESSAGENAME/FIELDNAME` is a unique message field identifier.`CIRCUIT` names the device which contains the information.`MESSAGENAME` is the name of the message on the bus.Each message consists of fields.`FIELDNAME` identifies the specific information within the message.EBUSD fieldnames are **NOT** unique. `pyebus` appends a suffix in case of naming collisions.Field names with a `+` are virtual and just the concatenation of existing fields.The access rights have the following meaning:* `r`: The message is explicitly readable.* `w`: The message is explicitly writable.* `u`: The message is **NOT** readable, but emitted by the sender on change.* `S`: Is the poll priority to be set. **This applies to readable messages only.** Values `1-9` can be used. `A` is a placeholder for automatic. This will choose an appropriate priority.* `P`: Actual polling priority.List some messages and fields-----------------------------The `ls` command accepts explicit names with wildcards and placeholders. **Case-Insensitive**::$ ebt -H 192.168.1.4 ls &quot;mc/FlowTemp*&quot;mc/FlowTemp/temp                         r---1 Float within [-2047.9:2047.9] with 0.0625 fraction [Temperatur]mc/FlowTemp/sensor                       r---1 ok, circuit, cutoffmc/FlowTemp/temp+sensor                  r---1 Float within [-2047.9:2047.9] with 0.0625 fractionmc/FlowTempDesired/temp1                 r---1 Float within [0:100] with 0.5 fractionmc/FlowTempMax/temp0                     rw--2 Integer within [0:254]mc/FlowTempMin/temp0                     rw--2 Integer within [0:254]$ ebt -H 192.168.1.4 ls &quot;*/*mode*&quot;mc/OperatingMode/mcmode                  rw--2 disabled, on, off, auto, eco, lowRead messages and fields------------------------`read` behaves identical to `ls` (with or without patterns), but returns the actual value::$ ebt -H 192.168.1.4 read &quot;*/*mode*&quot;mc/OperatingMode/mcmode                  rw--2 eco                 disabled, on, off, auto, eco, lowNon-readable messages are filtered automatically.Please note, EBUS is slow. EBUSD only reads values which are older than 300s or not cached.`--ttl` explicitly specifies the maximum age in seconds.Write Message Field-------------------Each writable field can be set by::$ ebt -H 192.168.1.4 write mc/OperatingMode/mcmode autoEBUS Status-----------The EBUS status can be retrieved by::$ ebt -H 192.168.1.4 stateokor more detailled::$ ebt -H 192.168.1.4 infoversion                ebusd 21.1.v21.1-12-gccfc025update check           version 3.4 availablesignal                 acquiredsymbol rate            114max symbol rate        217min arbitration micros 317max arbitration micros 4751min symbol latency     0max symbol latency     10reconnects             0masters                7messages               1006conditional            14poll                   597update                 10address 03             master #11address 08             slave #11, scanned &quot;MF=Vaillant;ID=BAI00;SW=0204;HW=9602&quot;, loaded &quot;vaillant/bai.0010015600.inc&quot; ([HW=9602]), &quot;vaillant/08.bai.csv&quot;address 10             master #2address 15             slave #2, scanned &quot;MF=Vaillant;ID=UI   ;SW=0508;HW=6201&quot;, loaded &quot;vaillant/15.ui.csv&quot;address 17             master #17Programming API===============Complete API-Documentation_Overview--------`Ebus` represents one connection to a EBUSD instance.&gt;&gt;&gt; from pyebus import Ebus&gt;&gt;&gt; ebus = Ebus('127.0.0.1')The instance needs to know the messages definitions handled by the EBUSD instance.The EBUSD message definitions are based on a EBUSD scan algorithm and the EBUSD-configuration_.Wait for the EBUSD scan to be completed:&gt;&gt;&gt; await ebus.async_wait_scancompleted()Now, we can load the message definition codes and convert them to message definitions `MsgDef`.&gt;&gt;&gt; await ebus.async_load_msgdefs()The message definitions are stored in a `MsgDefs` instance at&gt;&gt;&gt; ebus.msgdefsA single message can be read via:&gt;&gt;&gt; msgdef = ebus.msgdefs.get('circuit', 'name')&gt;&gt;&gt; print(await ebus.async_read(msgdef))All messages can be read via:&gt;&gt;&gt; for msgdef in ebus.msgdefs:&gt;&gt;&gt;   if msgdef.read:&gt;&gt;&gt;     print(await ebus.async_read(msgdef))Message can be filtered via patterns `CIRCUIT/MESSAGENAME` or `CIRCUIT/MESSAGENAME/FIELDNAME`.Wildcards (`*`) and Placeholder (`?`) are supported.The following example will read all temperature fields and all message of the circuit named `mc`.The read value must not be older than 1000s.&gt;&gt;&gt; for msgdef in ebus.msgdefs.resolve(['*/*/*temp*', 'mc/*']):&gt;&gt;&gt;   if msgdef.read:&gt;&gt;&gt;     print(await ebus.async_read(msgdef, ttl=1000))Writing is also possible&gt;&gt;&gt; await ebus.async_write(msgdef, value)EBUS meta informations are available at:&gt;&gt;&gt; await ebus.async_get_state()&gt;&gt;&gt; await ebus.async_get_info().. _EBUSD: https://github.com/john30/ebusd.. _EBUSD-Configuration: https://github.com/john30/ebusd-configuration.. _API-Documentation: https://pyebus.readthedocs.io/en/latest/api/pyebus.htmlContribution============* Fork https://github.com/c0fec0de/pyebus* Commit Your Changes* Test* Create Pull RequestDevelopment Environment-----------------------Please ensure to have python3 and venv installed.Run these commands to ensure to have the proper test environment::python3 -m venv .venvsource .venv/bin/activatepip install tox poetryTesting-------`tox` manages the test execution. Please ensure to enter the environment::source .venv/bin/activatetoxSee the coverage report at `htmlcov/index.html`.See the documentation at `docs/_build/html/index.html` </longdescription>
</pkgmetadata>