<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>An lightweight extension to Selenium/Appium Python.&lt;br/&gt;It's inspired by [Selenide](https://github.com/selenide/selenide &quot;Selenide GitHub page&quot;) from Java world and [Selene](https://github.com/yashaka/selene &quot;Selene Github page&quot;)## Short Features Overview:- **Selen-kaa** is easy integrated with your existing either Selenium or Appium code, - **Selen-kaa** doesn't break any line of your existing project!- **Selen-kaa** is compatible with any standard Selenium\Appium methods.&lt;br/&gt;For instance:```# Your old Selenium codebrowser = webdriver.Chrome()browser.get(&quot;https://www.seleniumhq.org/&quot;)# The same works with `selen-kaa`from se_wrapper.webdriver import SeWebDriverbrowser = BrowserDriver(webdriver.Chrome())  # wrap your browser to SeWebDriver browser.get(&quot;https://www.seleniumhq.org/&quot;)# any methods from the WebDriver works!element = browser.find_element_by_css(&quot;.test-class&quot;)```Besides, standard Selenium/Appium, **Selen-kaa** introduces more convenient way to interact with a web page and web elements through `init_web_element()`and `init_all_web_elements()`:&lt;br/&gt;What it brings you? Possibility to create the web element in `__init__()` method of a Page Object, as the WebDriver would search this element only at the time of interaction with it:```browser = BrowserDriver(webdriver.Chrome())class MyPage:    def __init__():        # lazy creation of a web element        # it's safe, you would have no NoSuchElementException        # even if `self.element1` has not been rendered yet on the web page,         self.element1 = browser.init_web_element(&quot;#test&quot;)    page = MyPage()browser.get(&quot;www.some.com&quot;)page.element1.click() # WebDriver would `find_element` and click it only on this step```&lt;br/&gt;`init_web_element()` returns `SeWebElement` object, which has attributes of standard WebElement but with additional logic of lazy initialization, custom waits and conditions.`init_all_web_elements()` returns `SeElementsArray` - a collection of `SeWebElement` objects with the same lazy initialization logic.```element1 = browser.init_web_element(&quot;#test&quot;)element1.should.be_visible(timeout=4) # wait 4 seconds until element becomes visibleelements = browser.init_all_web_elements(&quot;.test-class&quot;)elements[0].should.have_exact_text(text=&quot;first element&quot;, timeout=4)```When `SeWebDriver` initializes a new `SeWebElement` it waits for the element with a default timeout (4 seconds), so you don't need to handle waits your self!Use css selector or xpath for SeWebElement initialization:&lt;br/&gt;__Valid__:&lt;br/&gt;```browser.init_web_element(&quot;#this_hashtag_for_id&quot;)browser.init_web_element(&quot;.this-dor-for-class&quot;)browser.init_web_element(&quot;button[class='my-button']&quot;)browser.init_web_element(&quot;//div//a[contains(@href, '/imgres')]&quot;)```[About CSS selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors &quot;Mozilla page&quot;)If you need any other strategy to find an element, provide an optional `locator_strategy`, e.g. for `Appium`:```browser.init_web_element(&quot;**/XCUIElementTypeImage[`label == &quot;test&quot;`]&quot;, locator_strategy=MobileBy.IOS_CLASS_CHAIN)browser.init_web_element(&quot;access-id&quot;, locator_strategy=MobileBy.ACCESSIBILITY_ID)```### More handful methodsWait for element with css selector &quot;.test-class&quot; to be visible.Condition `should` raises Timeout exception if the element is not visible within `timeout`.Condition `expect` returns True if the element is visible or False if it is not visible within `timeout`.```pythonbrowser = BrowserDriver(webdriver.Chrome())  # wrap your browser to SeWebDriver element = browser.init_web_element(&quot;.test-class&quot;)element.should.be_visible(timeout)element.expect.be_visible(timeout)```Wait for element with css selector &quot;.test-class&quot; to be invisible.```pythonelement.should.be_invisible(timeout)element.expect.be_invisible(timeout)```Wait for element with css selector &quot;.test-class&quot; to have class.```pythonelement.should.have_class(expected_class, timeout)element.expect.have_class(expected_class, timeout)```Wait for element with css selector &quot;.test-class&quot; to include another element with css or xpath selector.```pythonelement.should.include_element(child_selector, timeout)element.expect.include_element(child_selector, timeout)```Wait for element with css selector &quot;.test-class&quot; to contain a text.`Contain` would be True for &quot;text&quot; in &quot;this is fulltext.&quot;```pythonelement.should.contain_text(text, timeout)element.expect.contain_text(text, timeout)```Wait for element with css selector &quot;.test-class&quot; to have_similar_text.Not precise comparision, e.g. returns True for:&quot;some&quot; in &quot;this is some text&quot;, &quot; test\n&quot; and &quot;test&quot;, &quot;TEST&quot; and &quot;test&quot;. Ignores whitespaces and is case insensitive.```pythonelement.should.have_similar_text(text, timeout)element.expect.have_similar_text(text, timeout)```Wait for element with css selector &quot;.test-class&quot; to have exact text.Strict comparision &quot;text == text&quot;```pythonelement.should.have_exact_text(text, timeout)element.expect.have_exact_text(text, timeout)```Wait for element with css selector &quot;.test-class&quot; to be not present in dom.```pythonelement.should.not_present_in_dom(timeout)element.expect.not_present_in_dom(timeout)```Wait for element with css selector &quot;.test-class&quot; to be on the screen.Checks if element's coordinates match viewport height and width.```pythonelement.should.be_on_the_screen(timeout)element.expect.be_on_the_screen(timeout)```</longdescription>
</pkgmetadata>