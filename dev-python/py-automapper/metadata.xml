<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;img src=&quot;logo.png&quot; style=&quot;width:128px; margin-right: 20px;&quot; /&gt;# py-automapper &lt;!-- omit in toc --&gt;**Build Status**[![Main branch status](https://github.com/anikolaienko/py-automapper/actions/workflows/run_code_checks.yml/badge.svg?branch=main)](https://github.com/anikolaienko/py-automapper/actions?query=branch%3Amain)---Table of Contents:- [Versions](#versions)- [About](#about)- [Contribute](#contribute)- [Usage](#usage)  - [Installation](#installation)  - [Get started](#get-started)  - [Map dictionary source to target object](#map-dictionary-source-to-target-object)  - [Different field names](#different-field-names)  - [Overwrite field value in mapping](#overwrite-field-value-in-mapping)  - [Disable Deepcopy](#disable-deepcopy)  - [Extensions](#extensions)  - [Pydantic/FastAPI Support](#pydanticfastapi-support)  - [TortoiseORM Support](#tortoiseorm-support)  - [SQLAlchemy Support](#sqlalchemy-support)  - [Create your own extension (Advanced)](#create-your-own-extension-advanced)# VersionsCheck [CHANGELOG.md](/CHANGELOG.md)# About**Python auto mapper** is useful for multilayer architecture which requires constant mapping between objects from separate layers (data layer, presentation layer, etc).Inspired by: [object-mapper](https://github.com/marazt/object-mapper)The major advantage of py-automapper is its extensibility, that allows it to map practically any type, discover custom class fields and customize mapping rules. Read more in [documentation](https://anikolaienko.github.io/py-automapper).# ContributeRead [CONTRIBUTING.md](/CONTRIBUTING.md) guide.# Usage## InstallationInstall package:```bashpip install py-automapper```## Get startedLet's say we have domain model `UserInfo` and its API representation `PublicUserInfo` without exposing user `age`:```pythonclass UserInfo:    def __init__(self, name: str, profession: str, age: int):        self.name = name        self.profession = profession        self.age = ageclass PublicUserInfo:    def __init__(self, name: str, profession: str):        self.name = name        self.profession = professionuser_info = UserInfo(&quot;John Malkovich&quot;, &quot;engineer&quot;, 35)```To create `PublicUserInfo` object:```pythonfrom automapper import mapperpublic_user_info = mapper.to(PublicUserInfo).map(user_info)print(vars(public_user_info))# {'name': 'John Malkovich', 'profession': 'engineer'}```You can register which class should map to which first:```python# Registermapper.add(UserInfo, PublicUserInfo)public_user_info = mapper.map(user_info)print(vars(public_user_info))# {'name': 'John Malkovich', 'profession': 'engineer'}```## Map dictionary source to target objectIf source object is dictionary:```pythonsource = {    &quot;name&quot;: &quot;John Carter&quot;,    &quot;profession&quot;: &quot;hero&quot;}public_info = mapper.to(PublicUserInfo).map(source)print(vars(public_info))# {'name': 'John Carter', 'profession': 'hero'}```## Different field namesIf your target class field name is different from source class.```pythonclass PublicUserInfo:    def __init__(self, full_name: str, profession: str):        self.full_name = full_name       # UserInfo has `name` instead        self.profession = profession```Simple map:```pythonpublic_user_info = mapper.to(PublicUserInfo).map(user_info, fields_mapping={    &quot;full_name&quot;: user_info.name})```Preregister and map. Source field should start with class name followed by period sign and field name:```pythonmapper.add(UserInfo, PublicUserInfo, fields_mapping={&quot;full_name&quot;: &quot;UserInfo.name&quot;})public_user_info = mapper.map(user_info)print(vars(public_user_info))# {'full_name': 'John Malkovich', 'profession': 'engineer'}```## Overwrite field value in mappingVery easy if you want to field just have different value, you provide a new value:```pythonpublic_user_info = mapper.to(PublicUserInfo).map(user_info, fields_mapping={    &quot;full_name&quot;: &quot;John Cusack&quot;})print(vars(public_user_info))# {'full_name': 'John Cusack', 'profession': 'engineer'}```## Disable DeepcopyBy default, py-automapper performs a recursive `copy.deepcopy()` call on all attributes when copying from source object into target class instance.This makes sure that changes in the attributes of the source do not affect the target and vice versa.If you need your target and source class share same instances of child objects, set `use_deepcopy=False` in `map` function.```pythonfrom dataclasses import dataclassfrom automapper import mapper@dataclassclass Address:    street: str    number: int    zip_code: int    city: str  class PersonInfo:    def __init__(self, name: str, age: int, address: Address):        self.name = name        self.age = age        self.address = addressclass PublicPersonInfo:    def __init__(self, name: str, address: Address):        self.name = name        self.address = addressaddress = Address(street=&quot;Main Street&quot;, number=1, zip_code=100001, city='Test City')info = PersonInfo('John Doe', age=35, address=address)# default deepcopy behaviorpublic_info = mapper.to(PublicPersonInfo).map(info)print(&quot;Target public_info.address is same as source address: &quot;, address is public_info.address)# Target public_info.address is same as source address: False# disable deepcopypublic_info = mapper.to(PublicPersonInfo).map(info, use_deepcopy=False)print(&quot;Target public_info.address is same as source address: &quot;, address is public_info.address)# Target public_info.address is same as source address: True```## Extensions`py-automapper` has few predefined extensions for mapping support to classes for frameworks:* [FastAPI](https://github.com/tiangolo/fastapi) and [Pydantic](https://github.com/samuelcolvin/pydantic)* [TortoiseORM](https://github.com/tortoise/tortoise-orm)* [SQLAlchemy](https://www.sqlalchemy.org/)## Pydantic/FastAPI SupportOut of the box Pydantic models support:```pythonfrom pydantic import BaseModelfrom typing import Listfrom automapper import mapperclass UserInfo(BaseModel):    id: int    full_name: str    public_name: str    hobbies: List[str]class PublicUserInfo(BaseModel):    id: int    public_name: str    hobbies: List[str]obj = UserInfo(    id=2,    full_name=&quot;Danny DeVito&quot;,    public_name=&quot;dannyd&quot;,    hobbies=[&quot;acting&quot;, &quot;comedy&quot;, &quot;swimming&quot;])result = mapper.to(PublicUserInfo).map(obj)# same behaviour with preregistered mappingprint(vars(result))# {'id': 2, 'public_name': 'dannyd', 'hobbies': ['acting', 'comedy', 'swimming']}```## TortoiseORM SupportOut of the box TortoiseORM models support:```pythonfrom tortoise import Model, fieldsfrom automapper import mapperclass UserInfo(Model):    id = fields.IntField(pk=True)    full_name = fields.TextField()    public_name = fields.TextField()    hobbies = fields.JSONField()class PublicUserInfo(Model):    id = fields.IntField(pk=True)    public_name = fields.TextField()    hobbies = fields.JSONField()obj = UserInfo(    id=2,    full_name=&quot;Danny DeVito&quot;,    public_name=&quot;dannyd&quot;,    hobbies=[&quot;acting&quot;, &quot;comedy&quot;, &quot;swimming&quot;],    using_db=True)result = mapper.to(PublicUserInfo).map(obj)# same behaviour with preregistered mapping# filtering out protected fields that start with underscore &quot;_...&quot;print({key: value for key, value in vars(result) if not key.startswith(&quot;_&quot;)})# {'id': 2, 'public_name': 'dannyd', 'hobbies': ['acting', 'comedy', 'swimming']}```## SQLAlchemy SupportOut of the box SQLAlchemy models support:```pythonfrom sqlalchemy.orm import declarative_basefrom sqlalchemy import Column, Integer, Stringfrom automapper import mapperBase = declarative_base()class UserInfo(Base):    __tablename__ = &quot;users&quot;    id = Column(Integer, primary_key=True)    full_name = Column(String)    public_name = Column(String)    hobbies = Column(String)    def __repr__(self):        return &quot;&lt;User(full_name='%s', public_name='%s', hobbies='%s')&gt;&quot; % (            self.full_name,            self.public_name,            self.hobbies,        )class PublicUserInfo(Base):    __tablename__ = 'public_users'    id = Column(Integer, primary_key=True)    public_name = Column(String)    hobbies = Column(String)    obj = UserInfo(            id=2,            full_name=&quot;Danny DeVito&quot;,            public_name=&quot;dannyd&quot;,            hobbies=&quot;acting, comedy, swimming&quot;,        )result = mapper.to(PublicUserInfo).map(obj)# same behaviour with preregistered mapping# filtering out protected fields that start with underscore &quot;_...&quot;print({key: value for key, value in vars(result) if not key.startswith(&quot;_&quot;)})# {'id': 2, 'public_name': 'dannyd', 'hobbies': &quot;acting, comedy, swimming&quot;}```## Create your own extension (Advanced)When you first time import `mapper` from `automapper` it checks default extensions and if modules are found for these extensions, then they will be automatically loaded for default `mapper` object.**What does extension do?** To know what fields in Target class are available for mapping, `py-automapper` needs to know how to extract the list of fields. There is no generic way to do that for all Python objects. For this purpose `py-automapper` uses extensions.List of default extensions can be found in [/automapper/extensions](/automapper/extensions) folder. You can take a look how it's done for a class with `__init__` method or for Pydantic or TortoiseORM models.You can create your own extension and register in `mapper`:```pythonfrom automapper import mapperclass TargetClass:    def __init__(self, **kwargs):        self.name = kwargs[&quot;name&quot;]        self.age = kwargs[&quot;age&quot;]        @staticmethod    def get_fields(cls):        return [&quot;name&quot;, &quot;age&quot;]source_obj = {&quot;name&quot;: &quot;Andrii&quot;, &quot;age&quot;: 30}try:    # Map object    target_obj = mapper.to(TargetClass).map(source_obj)except Exception as e:    print(f&quot;Exception: {repr(e)}&quot;)    # Output:    # Exception: KeyError('name')    # mapper could not find list of fields from BaseClass    # let's register extension for class BaseClass and all inherited ones    mapper.add_spec(TargetClass, TargetClass.get_fields)    target_obj = mapper.to(TargetClass).map(source_obj)    print(f&quot;Name: {target_obj.name}; Age: {target_obj.age}&quot;)```You can also create your own clean Mapper without any extensions and define extension for very specific classes, e.g. if class accepts `kwargs` parameter in `__init__` method and you want to copy only specific fields. Next example is a bit complex but probably rarely will be needed:```pythonfrom typing import Type, TypeVarfrom automapper import Mapper# Create your own Mapper object without any predefined extensionsmapper = Mapper()class TargetClass:    def __init__(self, **kwargs):        self.data = kwargs.copy()    @classmethod    def fields(cls):        return [&quot;name&quot;, &quot;age&quot;, &quot;profession&quot;]source_obj = {&quot;name&quot;: &quot;Andrii&quot;, &quot;age&quot;: 30, &quot;profession&quot;: None}try:    target_obj = mapper.to(TargetClass).map(source_obj)except Exception as e:    print(f&quot;Exception: {repr(e)}&quot;)    # Output:    # Exception: MappingError(&quot;No spec function is added for base class of &lt;class 'type'&gt;&quot;)# Instead of using base class, we define spec for all classes that have `fields` propertyT = TypeVar(&quot;T&quot;)def class_has_fields_property(target_cls: Type[T]) -&gt; bool:    return callable(getattr(target_cls, &quot;fields&quot;, None))    mapper.add_spec(class_has_fields_property, lambda t: getattr(t, &quot;fields&quot;)())target_obj = mapper.to(TargetClass).map(source_obj)print(f&quot;Name: {target_obj.data['name']}; Age: {target_obj.data['age']}; Profession: {target_obj.data['profession']}&quot;)# Output:# Name: Andrii; Age: 30; Profession: None# Skip `None` valuetarget_obj = mapper.to(TargetClass).map(source_obj, skip_none_values=True)print(f&quot;Name: {target_obj.data['name']}; Age: {target_obj.data['age']}; Has profession: {hasattr(target_obj, 'profession')}&quot;)# Output:# Name: Andrii; Age: 30; Has profession: False```</longdescription>
</pkgmetadata>