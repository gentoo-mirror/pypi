<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># sensor-fusion-ioSDK for working with sensor fusion scenes## Installation```pip install scale-sensor-fusion-io```## RequirementsMinimum Python version supported is 3.8.# Code samples## Constructing an SFS scene### PosePath Dataframe## Encoding a SFS scene```import scale_sensor_fusion_io as sfiofrom scale_sensor_fusion_io.model_converters to_scene_spec_sfsfrom scale_json_binary import write_filescene = sfio.Scene() # your scene herescene_sfs = to_scene_spec_sfs(scene)import scale_sensor_fusion_io as sfiowrite_file(f'~/scene.sfs', scene_sfs)```## Loading sfs fileThere is a SFSLoader class that provides helper functions for loading a scene from url. There are few variations of loading function, depending on your use case.```from scale_sensor_fusion_io.loaders import SFSLoaderscene_url = &quot;~/scene.sfs&quot;# Not recommended, but possibleraw_scene = SFSLoader(scene_url).load_unsafe() # scene is dictsfs_scene = SFSLoader(scene_url).load_as_sfs() # scene is SFS.Scenescene = SceneLoader(scene_url).load() # scene is models.Scene```## Validating SFSBefore you upload a scene for task creation, you'll want to validate that your sfs scene is well formed. You can do this in a variety of ways.### Validating scene objectIf you're working with the model.Scene object, you can use the `validate_scene` method available under scale_sensor_fusion_io.models.validation```import scale_sensor_fusion_io as sfioimport pprintscene = sfio.Scene() #errors = validate_scene(scene)if errors:    pp.pprint(asdict(errors))else:    print(&quot;Scene validated successfully&quot;)```### Validating from urlIf you've already generated a .sfs file, you can also validate that it is well formed```from scale_sensor_fusion_io.validation import parse_and_validate_scenefrom scale_json_binary import read_fileimport pprintpp = pprint.PrettyPrinter(depth=6)scene_url = &quot;your_scene.sfs&quot;raw_data = read_file(scene_url)result = parse_and_validate_scene(raw_data)if not result.success:    pp.pprint(asdict(result))else:    print(&quot;Scene parsed and validated successfully&quot;)```# FAQ## Resulting scene file is too largeFor scenes that span a large timeframe, the size of the resulting .sfs file may increase to multi-GBs. This is not ideal for loading onto LidarLite.### Video encodingOne easy way to reduce scene size is to encode camera content as video, as the video content can be more easily compressed. The tradeoff is the potentially reduced quality of images, but for labeling 3D scenes, this is often sufficient.See .utils/generate_video.py for helper functions### Downsample point cloudsAnother option is to downsample lidar point clouds. If your scene is used primarily for cuboid annotation, we recommend voxel downsampling using voxel sizes of at most 20mm.A good heuristic for efficient loading and labeling is to have a scene contain no more than 100,000 points.</longdescription>
</pkgmetadata>