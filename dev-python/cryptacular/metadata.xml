<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>cryptacular===========Hash responsibly::    from cryptacular.bcrypt import BCRYPTPasswordManager    manager = BCRYPTPasswordManager()    hashed = manager.encode('password')    if manager.check(hashed, 'password'):        pass # let them incryptacular is a collection of strong password hashing functions thatshare a common interface, and a nice way to use bcrypt as a passwordhash. It's designed to make it easy for you to migrate away from yourhalf-assed custom password scheme. Compared with popular choices likeplain text or single rounds of md5 or sha, strong password hashes greatlyincrease the computational cost of obtaining users' passwords from aleaked password database.cryptacular's interface was inspired by zope.password but cryptacular doesnot depend on zope and implements much stronger algorithms. cryptacularalso provides a convenient way to recognize and upgrade obsolete passwordhashes on the fly when users log in with their correct password.`z3c.bcrypt`_ integrates cryptacular into zope.password.http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.htmlexplains why bcrypt is a good idea. Computers are fast now. To protectour users against a leaked password database, we should use passwordhashes that take a little longer to check than sha1(salt + hash). bcryptand pbkdf2 have this property. They also have parametric complexity sothey can be made stronger as computers continue to get faster.cryptacular ships with 100% test coverage... _`z3c.bcrypt`: http://pypi.python.org/pypi/z3c.bcryptcryptacular.core----------------``cryptacular.core`` defines the ``DelegatingPasswordManager``and the interfaces (abstract base classes) ``PasswordChecker`` and``PasswordManager``.``DelegatingPasswordManager`` is the recommended way to usecryptacular. ``DelegatingPasswordManager`` holds a preferred``cryptacular.core.PasswordManager`` instance that canencode and check password hashes and a list of fallback``cryptacular.core.PasswordChecker`` instances that are onlyrequired to be able to check password hashes (no need to implement``InsecurePasswordHash.encode()``). When asked to check a password hashagainst a plaintext password, ``DelegatingPasswordManager`` finds thefirst item in its list that understands the given hash format and usesit to check the password. If the password was correct but not in thepreferred hash format, ``DelegatingPasswordManager`` will re-hash the givenpassword using its preferred ``PasswordManager``.&gt;&gt;&gt; import cryptacular.core&gt;&gt;&gt; import cryptacular.bcrypt&gt;&gt;&gt; import cryptacular.pbkdf2&gt;&gt;&gt; bcrypt = cryptacular.bcrypt.BCRYPTPasswordManager()&gt;&gt;&gt; pbkdf2 = cryptacular.pbkdf2.PBKDF2PasswordManager()&gt;&gt;&gt; delegator = cryptacular.core.DelegatingPasswordManager(preferred=bcrypt, fallbacks=(pbkdf2,))&gt;&gt;&gt; users = {'one':{'password':'xyzzy'}, 'two':{'password':u'hashy the \N{SNOWMAN}'}}&gt;&gt;&gt; for key in users: users[key]['hash'] = pbkdf2.encode(users[key]['password'])&gt;&gt;&gt; bcrypt.match(users['one']['password'])False&gt;&gt;&gt; def set_hash(hash): users['one']['hash'] = hash&gt;&gt;&gt; delegator.check(users['one']['hash'], users['one']['password'], setter=set_hash)True&gt;&gt;&gt; bcrypt.match(users['one']['hash'])True&gt;&gt;&gt; def set_hash(hash): raise Exception(&quot;Should not re-set a preferred hash&quot;)&gt;&gt;&gt; delegator.check(users['one']['hash'], users['one']['password'], setter=set_hash)True&gt;&gt;&gt; bcrypt.match(users['two']['hash'])False&gt;&gt;&gt; pbkdf2.match(users['two']['hash'])True&gt;&gt;&gt; delegator.check(users['two']['hash'], users['two']['password'])True&gt;&gt;&gt; bcrypt.match(users['two']['hash'])False&gt;&gt;&gt; pbkdf2.match(users['two']['hash'])Truecryptacular.bcrypt------------------``cryptacular.bcrypt`` uses a C extension module to call the public-domaincrypt_blowfish (http://www.openwall.com/crypt/) which is bundled withcryptacular. You should use this if you can.cryptacular.pbkdf2------------------``cryptacular.pbkdf2`` applies the pbkdf2 key derivation algorithmdescribed in RFC 2898 as a password hash. It uses M2Crypto.EVP.pbkdf2with a Python fallback when M2Crypto is not available. You can use thiseven if you cannot run C extension modules in your Python.cryptacular.crypt-----------------``cryptacular.crypt`` uses Python's builtin ``crypt`` module, available onUnix, to hash passwords. It takes a string such as '$1$' as an argumentto determine which kind of hash the underlying ``crypt()`` function willproduce (see ``man crypt`` for details). ``crypt()`` can even providebcrypt hashes if you are lucky; the SHA hashes invented for RedHat are alsogood.On my Ubuntu system::    from cryptacular.crypt import CRYPTPasswordManager, SHA256CRYPT    manager = CRYPTPasswordManager(SHA256CRYPT)    manager.encode('secret')    &gt;&gt;&gt; '$5$Ka9M/5GqJWMCnLI7$ZR0k9g2NlnXvgjjDYmobVUuLzfn/Tmo.vnW4WvW5Tx/'    manager.encode('secret')    &gt;&gt;&gt; '$5$o4RUq2zuVWYWZpuq$35VyAVxfeL4sQ9//ODNw8jIDW7khJ5s0lUlXCHJ6WZ2'</longdescription>
</pkgmetadata>