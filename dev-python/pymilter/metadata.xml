<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># AbstractThis is a python extension module to enable python scripts to attach toSendmail's libmilter API, enabling filtering of messages as they arrive.Since it's a script, you can do anything you want to the message - screenout viruses, collect statistics, add or modify headers, etc.  You can, atany point, tell Sendmail to reject, discard, or accept the message.Additional python modules provide for navigating and modifying MIME parts, andsending DSNs or doing CBVs.# Requirements Python milter extension: https://pypi.python.org/pypi/pymilter/Python: http://www.python.orgSendmail: http://www.sendmail.org# Quick Installation 1. Build and install Sendmail, enabling libmilter (see libmilter/README). 2. Build and install Python, enabling threading. 3. Install this module: python setup.py --help 4. Add these two lines to sendmail.cf[a]: O InputMailFilters=pythonfilter Xpythonfilter,        S=local:/home/username/pythonsock 5. Run the sample.py example milter with: python sample.py Note that milters should almost certainly not run as root.That's it.  Incoming mail will cause the milter to print some things, andsome email will be rejected (see the &quot;header&quot; method).  Edit and play.  See spfmilter.py for a functional SPF milter, or see bms.py for an complexmilter used in production.[a] This is for a quick test.  Your sendmail.cf in most distros will getoverwritten whenever sendmail.mc is updated.  To make a milter permanent,add something like:```INPUT_MAIL_FILTER(`pythonfilter', `S=local:/home/username/pythonsock, F=T, T=C:5m;S:20s;R:5m;E:5m')```to sendmail.mc instead.# Not-so-quick InstallationFirst install Sendmail.  Make sure you read libmilter/README in the Sendmailsource directory, and make sure you enable libmilter before you build.  The8.11 series had libmilter marked as FFR (For Future Release); 8.12officially supports libmilter, but it's still not built by default.Install Python, and enable threading in Modules/Setup.Install this miltermodule package; DistUtils Automatic Installation:$ python setup.py --helpFor versions of python prior to 2.0, you will need to download distutilsseparately or build manually.  You will need to download unittestseparately to run the test programs.  The bdist_rpm distutils option seemsnot to work for python 2.0; upgrade to at least 2.1.1.Now that everything is installed, we need to tell sendmail that we're goingto filter incoming email.  Add lines similar to the following tosendmail.cf:O InputMailFilters=pythonfilterXpythonfilter,        S=local:/home/username/pythonsockThe &quot;O&quot; line tells sendmail which filters to use in what order; here we'retelling sendmail to use the filter named &quot;pythonfilter&quot;.The next line, the &quot;X&quot; line (for &quot;eXternal&quot;), lists that filter along withsome options associated with it.  In this case, we have the &quot;S&quot; option, whichnames the socket that sendmail will use to communicate with this particularmilter.  This milter's socket is a unix-domain socket in the filesystem.See libmilter/README for the definitive list of options.NB: The name is specified in two places: here, in sendmail's cf file, andin the milter itself.  Make sure the two match.NB: The above lines can be added in your .mc file with this line:```INPUT_MAIL_FILTER(`pythonfilter', `S=local:/home/username/pythonsock')```For versions of sendmail prior to 8.12, you will need to enable`_FFR_MILTER` for the cf macros.  For example,m4 -D_FFR_MILTER ../m4/cf.m4 myconfig.mc &gt; myconfig.cf# IPv6 NotesThe IPv6 protocol is supported if your operation system supports itand if sendmail was compiled with IPv6 support.  To determine if yoursendmail supports IPv6, run &quot;sendmail -d0&quot; and check for the NETINET6compilation option.  To compile sendmail with IPv6 support, add thisdeclaration to your site.config.m4 before building it:```APPENDDEF(`confENVDEF', `-DNETINET6=1')```IPv6 support can show up in two places; the communications socketbetween the milter and sendmail processes and in the host addressargument to the connect() callback method.For sendmail to be able to accept IPv6 SMTP sessions, you mustconfigure the daemon to listen on an IPv6 port.  Furthermore if youwant to allow both IPv4 and IPv6 connections, some operating systemswill require that each listens to different port numbers.  For anIPv6-only setup, your sendmail configuration should contain a linesimilar to (first line is for sendmail.mc, second is sendmail.cf):```DAEMON_OPTIONS(`Name=MTA-v6, Family=inet6, Modify=C, Port=25')O DaemonPortOptions=Name=MTA-v6, Family=inet6, Modify=C, Port=25```To allow sendmail and the milter process to communicate with eachother over IPv6, you may use the &quot;inet6&quot; socket name prefix, as in:Xpythonfilter,        S=inet6:1234@fec0:0:0:7::5cThe connect() callback method in the milter class will pass theIPv6-specific information in the 'hostaddr' argument as a tuple.  Notethat the type of this value is dependent upon the protocol family, andis not compatible with IPv4 connections.  Therefore you should alwayscheck the family argument before attempting to use the hostaddrargument.  A quick example showing this follows:  import socket    class ipv6awareMilter(Milter.Milter):          def connect(self,hostname,family,hostaddr):if family==socket.AF_INET:   ipaddress, port = hostaddrelif family==socket.AF_INET6:   ip6address, port, flowinfo, scopeid = hostaddrelif family==socket.AF_UNIX:   socketpath = hostaddrThe hostname argument is always safe to use without interpreting theprotocol family.  For IPv6 connections for which the hostname can notbe determined the hostname will appear similar to the string&quot;[IPv6:::1]&quot; with the corresponding hostaddr[0] being &quot;::1&quot;.  Refer toRFC 2553 for information on interpreting and using the flowinfo andscopeid socket attributes, both of which are integers.# AuthorsJim Niemira (urmane@urmane.org) wrote the original C module and some quickand dirty python to use it.  Stuart D. Gathman (stuart@gathman.org) took thatkludge and added threading and context objects to it, wrote a proper OOwrapper (Milter.py) that handles attachments, did lots of testing, packagedit with distutils, and generally transformed it from a quick hack to areal, usable Python extension.</longdescription>
</pkgmetadata>