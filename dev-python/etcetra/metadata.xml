<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># etcetraPure python asyncio Etcd client.## Installation```bashpip install etcetra```## API DocumentationRefer [here](/docs/references.md).## Basic usageAll etcd operations managed by etcetra can be executed using `EtcdClient`.`EtcdClient` instance is a wrapper which holds connection information to Etcd channel.This instance is reusable, since actual connection to gRPC channel will be establishedwhen you initiate connection calls (see below).```pythonfrom etcetra import EtcdClient, HostPortPairetcd = EtcdClient(HostPortPair('127.0.0.1', 2379))```Like I mentioned above, actual connection establishment with Etcd's gRPC channel will be donewhen you call `EtcdClient.connect()`. This call returns async context manager, which manages `EtcdCommunicator` instance.```pythonasync with etcd.connect() as communicator:    await communicator.put('testkey', 'testvalue')    value = await communicator.get('testkey')    print(value)  # testvalue````EtcdCommunicator.get_prefix(prefix)` will return a dictionary containing all key-values with given key prefix.```pythonasync with etcd.connect() as communicator:    await communicator.put('/testdir', 'root')    await communicator.put('/testdir/1', '1')    await communicator.put('/testdir/2', '2')    await communicator.put('/testdir/2/3', '3')    test_dir = await communicator.get_prefix('/testdir')    print(test_dir)  # {'/testdir': 'root', '/testdir/1': '1', '/testdir/2': '2', '/testdir/2/3': '3'}```## Operating with Etcd lockJust like `EtcdClient.connect()`, you can easilly use etcd lock by calling `EtcdClient.with_lock(lock_name, timeout=None)`.```pythonasync def first():    async with etcd.with_lock('foolock') as communicator:        value = await communicator.get('testkey')        print('first:', value, end=' | ')async def second():    await asyncio.sleep(0.1)    async with etcd.with_lock('foolock') as communicator:        value = await communicator.get('testkey')        print('second:', value)async with etcd.connect() as communicator:    await communicator.put('testkey', 'testvalue')await asyncio.gather(first(), second())  # first: testvalue | second: testvalue```Adding `timeout` parameter to `EtcdClient.with_lock()` call will add a timeout to lock acquiring process.```pythonasync def first():    async with etcd.with_lock('foolock') as communicator:        value = await communicator.get('testkey')        print('first:', value)        await asyncio.sleep(10)async def second():    await asyncio.sleep(0.1)    async with etcd.with_lock('foolock', timeout=5) as communicator:        value = await communicator.get('testkey')        print('second:', value)async with etcd.connect() as communicator:    await communicator.put('testkey', 'testvalue')await asyncio.gather(first(), second())  # asyncio.TimeoutError followed by first: testvalue output```Adding `ttl` parameter to `EtcdClient.with_lock()` call will force lock to be released after given seconds.```pythonasync def first():    async with etcd.with_lock('foolock', ttl=5) as communicator:        await asyncio.sleep(10)await first()# on other fileimport timeasync def second():    start = time.time()    async with etcd.with_lock('foolock', ttl=5) as communicator:        print(f'acquired lock after {time.time() - start} seconds')await second()  # acquired lock after 4.756163120269775 seconds```## WatchYou can watch changes on key with `EtcdCommunicator.watch(key)`.```pythonasync def watch():    async with etcd.connect() as communicator:        async for event in communicator.watch('testkey'):            print(event.event, event.value)async def update():    await asyncio.sleep(0.1)    async with etcd.connect() as communicator:        await communicator.put('testkey', '1')        await communicator.put('testkey', '2')        await communicator.put('testkey', '3')        await communicator.put('testkey', '4')        await communicator.put('testkey', '5')await asyncio.gather(watch(), update())# WatchEventType.PUT 1# WatchEventType.PUT 2# WatchEventType.PUT 3# WatchEventType.PUT 4# WatchEventType.PUT 5```Watching changes on keys with specific prefix can be also done by `EtcdCommunicator.watch_prefix(key_prefix)`.```pythonasync def watch():    async with etcd.connect() as communicator:        async for event in communicator.watch_prefix('/testdir'):            print(event.event, event.key, event.value)async def update():    await asyncio.sleep(0.1)    async with etcd.connect() as communicator:        await communicator.put('/testdir', '1')        await communicator.put('/testdir/foo', '2')        await communicator.put('/testdir/bar', '3')        await communicator.put('/testdir/foo/baz', '4')await asyncio.gather(watch(), update())# WatchEventType.PUT /testdir 1# WatchEventType.PUT /testdir/foo 2# WatchEventType.PUT /testdir/bar 3# WatchEventType.PUT /testdir/foo/baz 4```## TransactionYou can run etcd transaction by calling `EtcdCommunicator.txn_compare(compares, txn_builder)`.### Constructing comparesConstructing compare operations can be done by comparing `CompareKey` instance with value with Python's built-in comparison operators (`==`, `!=`, `&gt;`, `&lt;`).```pythonfrom etcetra import CompareKeycompares = [    CompareKey('cmpkey1').value == 'foo',    CompareKey('cmpkey2').value &gt; 'bar',]```### Executing transaction calls```pythonasync with etcd.connect() with communicator:    await communicator.put('cmpkey1', 'foo')    await communicator.put('cmpkey2', 'baz')    await communicator.put('successkey', 'asdf')    def _txn(success, failure):        success.get('successkey')    values = await communicator.txn_compare(compares, _txn)    print(values)  # ['asdf']``````pythoncompares = [    CompareKey('cmpkey1').value == 'foo',    CompareKey('cmpkey2').value &lt; 'bar',]async with etcd.connect() with communicator:    await communicator.put('failurekey', 'asdf')    def _txn(success, failure):        failure.get('failurekey')    values = await communicator.txn_compare(compares, _txn)    print(values)  # ['asdf']```If you don't need compare conditions for transaction, you can use `EtcdCommunicator.txn(txn_builder)`,which is a shorthand for `EtcdCommunicator.txn_compare([], lambda success, failure: txn_builder(success))`.```pythonasync with etcd.connect() with communicator:    def _txn(action):        action.get('cmpkey1')        action.get('cmpkey2')    values = await communicator.txn(_txn)    print(values)  # ['foo', 'baz']```# Contributing## Compiling Protobuf```bash$ scripts/compile_protobuf.py &lt;target Etcd version&gt;```## Generating documentation```bash$ cd docs$ make markdown$ mv _build/markdown/index.mf references.md```</longdescription>
</pkgmetadata>