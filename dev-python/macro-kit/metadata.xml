<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># macro-kit`macro-kit` is a package for efficient macro recording and metaprogramming in Python using abstract syntax tree (AST).The design of AST in this package is strongly inspired by [Julia metaprogramming](https://docs.julialang.org/en/v1/manual/metaprogramming/). Similar methods are also implemented in builtin `ast` module but `macro-kit` (Julia-style metaprogramming) is more convenient in code operation and also focused on the macro generation and customization.## Installation- use pip```pip install macro-kit -U```- from source```pip install git+https://github.com/hanjinliu/macro-kit```## Examples1. Define a macro-recordable function```pythonfrom macrokit import Macro, Expr, Symbolmacro = Macro()@macro.recorddef str_add(a, b):    return str(a) + str(b)val0 = str_add(1, 2)val1 = str_add(val0, &quot;xyz&quot;)macro``````[Out]var0x24fdc2d1530 = str_add(1, 2)var0x24fdc211df0 = str_add(var0x24fdc2d1530, 'xyz')```Use `format` method to rename variable names.```python# substitute identifiers of variables# var0x24fdc2d1530 -&gt; xmacro.format([(val0, &quot;x&quot;)])``````[Out]x = str_add(1, 2)var0x24fdc211df0 = str_add(x, 'xyz')````format` also support substitution with more complicated expressions.```python# substitute to _dict[&quot;key&quot;]expr = Expr(head=&quot;getitem&quot;, args=[Symbol(&quot;_dict&quot;), &quot;key&quot;])macro.format([(val0, expr)])``````[Out]_dict['key'] = str_add(1, 2)var0x24fdc211df0 = str_add(_dict['key'], 'xyz')```2. Record class```pythonmacro = Macro()@macro.recordclass C:    def __init__(self, val: int):        self.value = val    @property    def value(self):        return self._value    @value.setter    def value(self, new_value: int):        if not isinstance(new_value, int):            raise TypeError(&quot;new_value must be an integer.&quot;)        self._value = new_value    def show(self):        print(self._value)c = C(1)c.value = 5c.value = -10c.show()``````[Out]-10```Note that value assignments are not recorded in duplicate.```pythonmacro.format([(c, &quot;ins&quot;)])``````[Out]ins = C(1)ins.value = -10var0x7ffed09d2cd8 = ins.show()````eval` can evaluate macro.```pythonmacro.eval({&quot;C&quot;: C})``````[Out]-10```3. Record module```pythonimport numpy as npmacro = Macro()np = macro.record(np)  # macro-recordable numpyarr = np.random.random(30)mean = np.mean(arr)macro``````[Out]var0x2a0a2864090 = numpy.random.random(30)var0x2a0a40daef0 = numpy.mean(var0x2a0a2864090)```Recorded module is stored in `Symbol` so you can safely `eval` the macro without passing the module object as the global variables.```pythonmacro.eval()  # this works```4. String parsing`parse` calls `ast.parse` inside so that you can safely make `Expr` from string.```pythonfrom macrokit import parseexpr = parse(&quot;result = f(0, l[2:8])&quot;)expr``````[Out]:(result = f(0, l[slice(2, 8, None)]))``````pythonprint(expr.dump())``````[Out]head: assignargs: 0: result 1: head: call    args:     0: f     1: 0     2: head: getitem        args:         0: l         1: slice(2, 8, None)```</longdescription>
</pkgmetadata>