<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://travis-ci.org/shubhamchaudhary/configparser2.svg?branch=master    :target: https://travis-ci.org/shubhamchaudhary/configparser2.. image:: https://coveralls.io/repos/shubhamchaudhary/configparser2/badge.svg    :target: https://coveralls.io/r/shubhamchaudhary/configparser2.. image:: https://badge.waffle.io/shubhamchaudhary/configparser2.png?label=ready&amp;title=Ready     :target: https://waffle.io/shubhamchaudhary/configparser2    :alt: 'Stories in Ready'.. image:: https://img.shields.io/pypi/v/configparser2.svg    :target: https://pypi.python.org/pypi/configparser2.. image:: https://img.shields.io/github/tag/shubhamchaudhary/configparser2.svg.. image:: https://img.shields.io/github/release/shubhamchaudhary/configparser2.svg =============configparser2=============configparser2 is derived from Lukasz Langa's configparser mercurial repo. Theonly difference is a name is not conflicting with the default python3configparser.  Source Code~~~~~~~~~~~Source Code for configparser2 is on `Github &lt;https://github.com/shubhamchaudhary/configparser2&gt;`_.Installation~~~~~~~~~~~~A quick ``pip install configparser2`` should do the job.Docs for configparser~~~~~~~~~~~~~~~~~~~~~The ancient ``ConfigParser`` module available in the standard library 2.x hasseen a major update in Python 3.2. This is a backport of those changes so thatthey can be used directly in Python 2.6 - 3.5.To use the ``configparser2`` backport instead of the built-in version on bothPython 2 and Python 3, simply import it explicitly as a backport::  from backports import configparser2If you'd like to use the backport on Python 2 and the built-in version onPython 3, use that invocation instead::  import configparser2For detailed documentation consult the vanilla version athttp://docs.python.org/3/library/configparser2.html.Why you'll love ``configparser2``---------------------------------Whereas almost completely compatible with its older brother, ``configparser2``sports a bunch of interesting new features:* full mapping protocol access (`more info  &lt;http://docs.python.org/3/library/configparser2.html#mapping-protocol-access&gt;`_)::    &gt;&gt;&gt; parser = ConfigParser()    &gt;&gt;&gt; parser.read_string(&quot;&quot;&quot;    [DEFAULT]    location = upper left    visible = yes    editable = no    color = blue    [main]    title = Main Menu    color = green    [options]    title = Options    &quot;&quot;&quot;)    &gt;&gt;&gt; parser['main']['color']    'green'    &gt;&gt;&gt; parser['main']['editable']    'no'    &gt;&gt;&gt; section = parser['options']    &gt;&gt;&gt; section['title']    'Options'    &gt;&gt;&gt; section['title'] = 'Options (editable: %(editable)s)'    &gt;&gt;&gt; section['title']    'Options (editable: no)'* there's now one default ``ConfigParser`` class, which basically is the old  ``SafeConfigParser`` with a bunch of tweaks which make it more predictable for  users. Don't need interpolation? Simply use  ``ConfigParser(interpolation=None)``, no need to use a distinct  ``RawConfigParser`` anymore.* the parser is highly `customizable upon instantiation  &lt;http://docs.python.org/3/library/configparser2.html#customizing-parser-behaviour&gt;`__  supporting things like changing option delimiters, comment characters, the  name of the DEFAULT section, the interpolation syntax, etc.* you can easily create your own interpolation syntax but there are two powerful  implementations built-in (`more info  &lt;http://docs.python.org/3/library/configparser2.html#interpolation-of-values&gt;`__):  * the classic ``%(string-like)s`` syntax (called ``BasicInterpolation``)  * a new ``${buildout:like}`` syntax (called ``ExtendedInterpolation``)* fallback values may be specified in getters (`more info  &lt;http://docs.python.org/3/library/configparser2.html#fallback-values&gt;`__)::    &gt;&gt;&gt; config.get('closet', 'monster',    ...            fallback='No such things as monsters')    'No such things as monsters'* ``ConfigParser`` objects can now read data directly `from strings  &lt;http://docs.python.org/3/library/configparser2.html#configparser2.ConfigParser.read_string&gt;`__  and `from dictionaries  &lt;http://docs.python.org/3/library/configparser2.html#configparser2.ConfigParser.read_dict&gt;`__.  That means importing configuration from JSON or specifying default values for  the whole configuration (multiple sections) is now a single line of code. Same  goes for copying data from another ``ConfigParser`` instance, thanks to its  mapping protocol support.* many smaller tweaks, updates and fixesA few words about Unicode-------------------------``configparser2`` comes from Python 3 and as such it works well with Unicode.The library is generally cleaned up in terms of internal data storage andreading/writing files.  There are a couple of incompatibilities with the old``ConfigParser`` due to that. However, the work required to migrate is wellworth it as it shows the issues that would likely come up during migration ofyour project to Python 3.The design assumes that Unicode strings are used whenever possible [1]_.  Thatgives you the certainty that what's stored in a configuration object is text.Once your configuration is read, the rest of your application doesn't have todeal with encoding issues. All you have is text [2]_. The only two phases whenyou should explicitly state encoding is when you either read from an externalsource (e.g. a file) or write back.Versioning----------This backport is intended to keep 100% compatibility with the vanilla release inPython 3.2+. To help maintaining a version you want and expect, a versioningscheme is used where:* the first two numbers indicate the version of Python 3 from which the  backport is done* a backport release number is provided as the final number (zero-indexed)For example, ``3.5.2`` is the **third** backport release of the``configparser2`` library as seen in Python 3.5.  Note that ``3.5.2`` does**NOT** necessarily mean this backport version is based on the standard libraryof Python 3.5.2.One exception from the 100% compatibility principle is that bugs fixed beforereleasing another minor Python 3 bugfix version **will be included** in thebackport releases done in the mean time.Maintenance-----------This backport is maintained on BitBucket by ≈Åukasz Langa, the current vanilla``configparser2`` maintainer for CPython:* `configparser2 git repository &lt;https://github.com/shubhamchaudhary/configparser2&gt;`_* `configparser2 Mercurial repository &lt;https://github.com/shubhamchaudhary/configparser2&gt;`_* `configparser2 issue tracker &lt;https://github.com/shubhamchaudhary/configparser2/issues&gt;`_Change Log----------4.0.0~~~~~* Change name to configparser23.5.0~~~~~* a complete rewrite of the backport; now single codebase working on Python  2.6 - 3.5. To use on Python 3 import ``from backports import configparser2``  instead of the built-in version.* compatible with 3.4.1 + fixes for `#19546  &lt;http://bugs.python.org/issue19546&gt;`_* fixes `BitBucket issue #1  &lt;https://bitbucket.org/ambv/configparser2/issue/1&gt;`_: versioning non-compliant  with PEP 386* fixes `BitBucket issue #3  &lt;https://bitbucket.org/ambv/configparser2/issue/3&gt;`_: ``reload(sys);  sys.setdefaultencoding('utf8')`` in setup.py* fixes `BitBucket issue #5  &lt;https://bitbucket.org/ambv/configparser2/issue/5&gt;`_: Installing the backport  on Python 3 breaks virtualenv* fixes `BitBucket issue #6  &lt;https://bitbucket.org/ambv/configparser2/issue/6&gt;`_: PyPy compatibility3.5.0b2~~~~~~~* second beta of 3.5.0, not using any third-party futurization libraries3.5.0b1~~~~~~~* first beta of 3.5.0, using python-future* for the full feature list, see `3.5.0`_3.3.0r2~~~~~~~* updated the fix for `#16820 &lt;http://bugs.python.org/issue16820&gt;`_: parsers  now preserve section order when using ``__setitem__`` and ``update``3.3.0r1~~~~~~~* compatible with 3.3.0 + fixes for `#15803  &lt;http://bugs.python.org/issue15803&gt;`_ and `#16820  &lt;http://bugs.python.org/issue16820&gt;`_* fixes `BitBucket issue #4  &lt;https://bitbucket.org/ambv/configparser2/issue/4&gt;`_: ``read()`` properly  treats a bytestring argument as a filename* `ordereddict &lt;http://pypi.python.org/pypi/ordereddict&gt;`_ dependency required  only for Python 2.6* `unittest2 &lt;http://pypi.python.org/pypi/unittest2&gt;`_ explicit dependency  dropped. If you want to test the release, add ``unittest2`` on your own.3.2.0r3~~~~~~~* proper Python 2.6 support  * explicitly stated the dependency on `ordereddict    &lt;http://pypi.python.org/pypi/ordereddict&gt;`_  * numbered all formatting braces in strings* explicitly says that Python 2.5 support won't happen (too much work necessary  without abstract base classes, string formatters, the ``io`` library, etc.)* some healthy advertising in the README3.2.0r2~~~~~~~* a backport-specific change: for convenience and basic compatibility with the  old ConfigParser, bytestrings are now accepted as section names, options and  values.  Those strings are still converted to Unicode for internal storage so  in any case when such conversion is not possible (using the 'ascii' codec),  UnicodeDecodeError is raised.3.2.0r1~~~~~~~* the first public release compatible with 3.2.0 + fixes for `#11324  &lt;http://bugs.python.org/issue11324&gt;`_, `#11670  &lt;http://bugs.python.org/issue11670&gt;`_ and `#11858  &lt;http://bugs.python.org/issue11858&gt;`_.Conversion Process------------------This section is technical and should bother you only if you are wondering howthis backport is produced. If the implementation details of this backport arenot important for you, feel free to ignore the following content.``configparser2`` is converted using `python-future&lt;http://python-future.org&gt;`_ and free time.  Because a fully automaticconversion was not doable, I took the following branching approach:* the ``3.x`` branch holds unchanged files synchronized from the upstream  CPython repository. The synchronization is currently done by manually copying  the required files and stating from which CPython changeset they come from.* the ``default`` branch holds a version of the ``3.x`` code with some tweaks  that make it independent from libraries and constructions unavailable on 2.x.  Code on this branch still *must* work on the corresponding Python 3.x but  will also work on Python 2.6 and 2.7 (including PyPy).  You can check this  running the supplied unit tests with ``tox``.The process works like this:1. I update the ``3.x`` branch with new versions of files. Commit.2. I merge the new commit to ``default``. I run ``tox``. Commit.3. If there are necessary changes, I do them now (on ``default``). Note that   the changes should be written in the syntax subset supported by Python   2.6.4. I run ``tox``. If it works, I update the docs and release the new version.   Otherwise, I go back to point 3. I might use ``pasteurize`` to suggest me   required changes but usually I do them manually to keep resulting code in   a nicer form.Footnotes---------.. [1] To somewhat ease migration, passing bytestrings is still supported but       they are converted to Unicode for internal storage anyway. This means       that for the vast majority of strings used in configuration files, it       won't matter if you pass them as bytestrings or Unicode. However, if you       pass a bytestring that cannot be converted to Unicode using the naive       ASCII codec, a ``UnicodeDecodeError`` will be raised. This is purposeful       and helps you manage proper encoding for all content you store in       memory, read from various sources and write back... [2] Life gets much easier when you understand that you basically manage       **text** in your application.  You don't care about bytes but about       letters.  In that regard the concept of content encoding is meaningless.       The only time when you deal with raw bytes is when you write the data to       a file.  Then you have to specify how your text should be encoded.  On       the other end, to get meaningful text from a file, the application       reading it has to know which encoding was used during its creation.  But       once the bytes are read and properly decoded, all you have is text.  This       is especially powerful when you start interacting with multiple data       sources.  Even if each of them uses a different encoding, inside your       application data is held in abstract text form.  You can program your       business logic without worrying about which data came from which source.       You can freely exchange the data you store between sources.  Only       reading/writing files requires encoding your text to bytes.</longdescription>
</pkgmetadata>