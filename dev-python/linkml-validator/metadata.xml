<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># LinkML Validator[![Run tests](https://github.com/linkml/linkml-validator/actions/workflows/run-tests.yml/badge.svg)](https://github.com/linkml/linkml-validator/actions/workflows/run-tests.yml)[![PyPI](https://img.shields.io/pypi/v/linkml-validator)](https://img.shields.io/pypi/v/linkml-validator)The LinkML Validator is a library for performing validation on data objects thatconform to a given LinkML schema.The Validator is initialized using a LinkML schema YAML, and is designed to allowfor flexible validation where each type of validation is done by a plugin.For example, JSONSchema validation is performed by[JsonSchemaValidationPlugin](linkml_validator/plugins/jsonschema_validation.py).## MotivationThe LinkML Validator is built with the following goals in mind:- the Validator should respond with parseable validation messages- the Validator should not break the validation process even if oneobject from a list of objects fail validation- the Validator should provide the ability to perform more than onetype of validation on an object## Installation```shpython setup.py install```To install development dependencies (like `pytest`, `mkdocs`, etc.):```shpip install -e &quot;.[dev]&quot;```## Running the LinkML Validator via CLITo run the LinkML Validator,```shlinkml-validator --inputs &lt;INPUT JSON&gt; \    --schema &lt;SCHEMA YAML&gt; \    --output &lt;OUTPUT&gt;```You can pass filepath or a URL that points to the LinkML schema YAML.### Input data as a dictionary of objectsThe input JSON can be a dictionary of objects keyed by the object type.```json{    &quot;&lt;OBJECT_TYPE&gt;&quot;: [        {        }    ]}```Where the `&lt;OBJECT_TYPE&gt;` is the pythonic representation of a class defined in the schema YAML.For example, consider [examples/example_data1.json](examples/example_data1.json):```json{    &quot;NamedThing&quot;: [        {            &quot;id&quot;: &quot;obj1&quot;,            &quot;name&quot;: &quot;Object 1&quot;,            &quot;type&quot;: &quot;X&quot;        },        {            &quot;id&quot;: &quot;obj2&quot;,            &quot;name&quot;: &quot;Object 2&quot;,            &quot;type&quot;: &quot;Y&quot;        }    ]}```In the above example, the `NamedThing` is the `target_class`, which is the pythonicrepresentation of the class `named thing` as defined in the[examples/example_schema.yaml](examples/example_schema.yaml).You can run the validator on the above data as follows:```shlinkml-validator --inputs examples/example_data1.json \    --schema examples/example_schema.yaml \    --output examples/example_data1_validation_report.json```### Input data as an array of objectsThe input JSON can also be an array of objects:```json[    {},    {}]```In this case, one must also specify the object type via `--target-class` argument in the CLI.For example, consider [examples/example_data2.json](examples/example_data2.json):```json[    {        &quot;id&quot;: &quot;obj1&quot;,        &quot;name&quot;: &quot;Object 1&quot;,        &quot;type&quot;: &quot;X&quot;    },    {        &quot;id&quot;: &quot;obj2&quot;,        &quot;name&quot;: &quot;Object 2&quot;,        &quot;type&quot;: &quot;Y&quot;    }]```You can run the validator on the above data as follows:```shlinkml-validator --inputs examples/example_data2.json \    --schema examples/example_schema.yaml \    --output examples/example_data2_validation_report.json \    --target-class NamedThing```## Running selected pluginsTo run only certain plugins as part of the validation,```shlinkml-validator --inputs data.json \    --schema schema.yaml \    --output validation_results.json \    --plugins JsonSchemaValidationPlugin```To perform strict validation,```shlinkml-validator --inputs data.json \    --schema schema.yaml \    --output validation_results.json \    --plugins JsonSchemaValidationPlugin \    --strict```Under normal (default) mode, the validator will run all the checks defined in allreferenced plugins on a given object.When in strict mode, the validator will stop the validation for an object if even oneof the plugins report a failed validation.## Running your own plugins with the Validator (via CLI)To run your custom plugin as part of the validation,```shlinkml-validator --inputs data.json \    --schema schema.yaml \    --output validation_results.json \    --plugins JsonSchemaValidationPlugin \    --plugins &lt;CUSTOM_PLUGIN_CLASS&gt;```where `&lt;CUSTOM_PLUGIN_CLASS&gt;` the reference to a custom plugin class.**Note:** The custom plugin class must be a subclass of `linkml_validator.plugins.base.BasePlugin` and must implement all the methods defined in `BasePlugin` class.## Using LinkML Validator as a moduleYou can use the `linkml_validator.validator.Validator` class directly in your codebaseto perform validation on objects that you are working with.The following code snippet provides a quick way of instantiating the Validator classand performing validation on an object:```pyfrom linkml_validator.validator import Validatordata_obj = {    &quot;id&quot;: &quot;obj1&quot;,    &quot;name&quot;: &quot;Object 1&quot;,    &quot;type&quot;: &quot;X&quot;}validator = Validator(schema=&quot;examples/example_schema.yaml&quot;)validator.validate(obj=data_obj, target_class=&quot;NamedThing&quot;)```**Note:** The above code makes the assumption that there is a class `named thing` definedin the [examples/example_schema.yaml](examples/example_schema.yaml) and that `NamedThing`is its Pythonic representation.You can also provide your own custom plugin class to run with the Validator,```pyfrom linkml_validator.validator import Validatorfrom linkml_validator.plugins.base import BasePluginfrom linkml_validator.models import ValidationResultclass MyCustomPlugin(BasePlugin):    NAME = &quot;MyCustomPlugin&quot;    def __init__(self, schema: str, **kwargs) -&gt; None:        super().__init__(schema)    def process(self, obj: dict, **kwargs) -&gt; ValidationResult:        # Add your custom logic for processing and validating the incoming object        valid = False        print(&quot;In MyCustomPlugin.process method&quot;)        result = ValidationResult(            plugin_name=self.NAME,            valid=valid,            validation_messages=[]        )        return resultdata_obj = {    &quot;id&quot;: &quot;obj1&quot;,    &quot;name&quot;: &quot;Object 1&quot;,    &quot;type&quot;: &quot;X&quot;}validator = Validator(schema=&quot;examples/example_schema.yaml&quot;, plugins=[{&quot;plugin_class&quot;: &quot;MyCustomPlugin&quot;, &quot;args&quot;: {}])validator.validate(obj=data_obj, target_class=&quot;NamedThing&quot;)```</longdescription>
</pkgmetadata>