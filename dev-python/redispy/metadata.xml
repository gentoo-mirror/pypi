<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>redispy========The Python interface to the Redis key-value store... image:: https://travis-ci.org/JamieCressey/redispy.svg?branch=master    :target: https://travis-ci.org/JamieCressey/redispyInstallation------------redispy requires a running Redis server. See `Redis's quickstart&lt;http://redis.io/topics/quickstart&gt;`_ for installation instructions.To install redispy, simply:.. code-block:: bash    $ sudo pip install redispyor alternatively (you really should be using pip though):.. code-block:: bash    $ sudo easy_install redispyor from source:.. code-block:: bash    $ sudo python setup.py installGetting Started---------------.. code-block:: pycon    &gt;&gt;&gt; import redis    &gt;&gt;&gt; r = redis.StrictRedis(host='localhost', port=6379, db=0)    &gt;&gt;&gt; r.set('foo', 'bar')    True    &gt;&gt;&gt; r.get('foo')    'bar'API Reference-------------The `official Redis command documentation &lt;http://redis.io/commands&gt;`_ does agreat job of explaining each command in detail. redispy exposes two clientclasses that implement these commands. The StrictRedis class attempts to adhereto the official command syntax. There are a few exceptions:* **SELECT**: Not implemented. See the explanation in the Thread Safety section  below.* **DEL**: 'del' is a reserved keyword in the Python syntax. Therefore redispy  uses 'delete' instead.* **CONFIG GET|SET**: These are implemented separately as config_get or config_set.* **MULTI/EXEC**: These are implemented as part of the Pipeline class. The  pipeline is wrapped with the MULTI and EXEC statements by default when it  is executed, which can be disabled by specifying transaction=False.  See more about Pipelines below.* **SUBSCRIBE/LISTEN**: Similar to pipelines, PubSub is implemented as a separate  class as it places the underlying connection in a state where it can't  execute non-pubsub commands. Calling the pubsub method from the Redis client  will return a PubSub instance where you can subscribe to channels and listen  for messages. You can only call PUBLISH from the Redis client (see  `this comment on issue #151  &lt;https://github.com/andymccurdy/redispy/issues/151#issuecomment-1545015&gt;`_  for details).* **SCAN/SSCAN/HSCAN/ZSCAN**: The \*SCAN commands are implemented as they  exist in the Redis documentation. In addition, each command has an equivilant  iterator method. These are purely for convenience so the user doesn't have  to keep track of the cursor while iterating. Use the  scan_iter/sscan_iter/hscan_iter/zscan_iter methods for this behavior.In addition to the changes above, the Redis class, a subclass of StrictRedis,overrides several other commands to provide backwards compatibility with olderversions of redispy:* **LREM**: Order of 'num' and 'value' arguments reversed such that 'num' can  provide a default value of zero.* **ZADD**: Redis specifies the 'score' argument before 'value'. These were swapped  accidentally when being implemented and not discovered until after people  were already using it. The Redis class expects \*args in the form of:  `name1, score1, name2, score2, ...`* **SETEX**: Order of 'time' and 'value' arguments reversed.More Detail-----------Connection Pools^^^^^^^^^^^^^^^^Behind the scenes, redispy uses a connection pool to manage connections toa Redis server. By default, each Redis instance you create will in turn createits own connection pool. You can override this behavior and use an existingconnection pool by passing an already created connection pool instance to theconnection_pool argument of the Redis class. You may choose to do this in orderto implement client side sharding or have finer grain control of howconnections are managed... code-block:: pycon    &gt;&gt;&gt; pool = redis.ConnectionPool(host='localhost', port=6379, db=0)    &gt;&gt;&gt; r = redis.Redis(connection_pool=pool)Connections^^^^^^^^^^^ConnectionPools manage a set of Connection instances. redispy ships with twotypes of Connections. The default, Connection, is a normal TCP socket basedconnection. The UnixDomainSocketConnection allows for clients running on thesame device as the server to connect via a unix domain socket. To use aUnixDomainSocketConnection connection, simply pass the unix_socket_pathargument, which is a string to the unix domain socket file. Additionally, makesure the unixsocket parameter is defined in your redis.conf file. It'scommented out by default... code-block:: pycon    &gt;&gt;&gt; r = redis.Redis(unix_socket_path='/tmp/redis.sock')You can create your own Connection subclasses as well. This may be useful ifyou want to control the socket behavior within an async framework. Toinstantiate a client class using your own connection, you need to createa connection pool, passing your class to the connection_class argument.Other keyword parameters you pass to the pool will be passed to the classspecified during initialization... code-block:: pycon    &gt;&gt;&gt; pool = redis.ConnectionPool(connection_class=YourConnectionClass,                                    your_arg='...', ...)Parsers^^^^^^^Parser classes provide a way to control how responses from the Redis serverare parsed. redispy ships with two parser classes, the PythonParser and theHiredisParser. By default, redispy will attempt to use the HiredisParser ifyou have the hiredis module installed and will fallback to the PythonParserotherwise.Hiredis is a C library maintained by the core Redis team. Pieter Noordhuis waskind enough to create Python bindings. Using Hiredis can provide up to a10x speed improvement in parsing responses from the Redis server. Theperformance increase is most noticeable when retrieving many pieces of data,such as from LRANGE or SMEMBERS operations.Hiredis is available on PyPI, and can be installed via pip or easy_installjust like redispy... code-block:: bash    $ pip install hiredisor.. code-block:: bash    $ easy_install hiredisResponse Callbacks^^^^^^^^^^^^^^^^^^The client class uses a set of callbacks to cast Redis responses to theappropriate Python type. There are a number of these callbacks defined onthe Redis client class in a dictionary called RESPONSE_CALLBACKS.Custom callbacks can be added on a per-instance basis using theset_response_callback method. This method accepts two arguments: a commandname and the callback. Callbacks added in this manner are only valid on theinstance the callback is added to. If you want to define or override a callbackglobally, you should make a subclass of the Redis client and add your callbackto its REDIS_CALLBACKS class dictionary.Response callbacks take at least one parameter: the response from the Redisserver. Keyword arguments may also be accepted in order to further controlhow to interpret the response. These keyword arguments are specified during thecommand's call to execute_command. The ZRANGE implementation demonstrates theuse of response callback keyword arguments with its &quot;withscores&quot; argument.Thread Safety^^^^^^^^^^^^^Redis client instances can safely be shared between threads. Internally,connection instances are only retrieved from the connection pool duringcommand execution, and returned to the pool directly after. Command executionnever modifies state on the client instance.However, there is one caveat: the Redis SELECT command. The SELECT commandallows you to switch the database currently in use by the connection. Thatdatabase remains selected until another is selected or until the connection isclosed. This creates an issue in that connections could be returned to the poolthat are connected to a different database.As a result, redispy does not implement the SELECT command on clientinstances. If you use multiple Redis databases within the same application, youshould create a separate client instance (and possibly a separate connectionpool) for each database.It is not safe to pass PubSub or Pipeline objects between threads.Pipelines^^^^^^^^^Pipelines are a subclass of the base Redis class that provide support forbuffering multiple commands to the server in a single request. They can be usedto dramatically increase the performance of groups of commands by reducing thenumber of back-and-forth TCP packets between the client and server.Pipelines are quite simple to use:.. code-block:: pycon    &gt;&gt;&gt; r = redis.Redis(...)    &gt;&gt;&gt; r.set('bing', 'baz')    &gt;&gt;&gt; # Use the pipeline() method to create a pipeline instance    &gt;&gt;&gt; pipe = r.pipeline()    &gt;&gt;&gt; # The following SET commands are buffered    &gt;&gt;&gt; pipe.set('foo', 'bar')    &gt;&gt;&gt; pipe.get('bing')    &gt;&gt;&gt; # the EXECUTE call sends all buffered commands to the server, returning    &gt;&gt;&gt; # a list of responses, one for each command.    &gt;&gt;&gt; pipe.execute()    [True, 'baz']For ease of use, all commands being buffered into the pipeline return thepipeline object itself. Therefore calls can be chained like:.. code-block:: pycon    &gt;&gt;&gt; pipe.set('foo', 'bar').sadd('faz', 'baz').incr('auto_number').execute()    [True, True, 6]In addition, pipelines can also ensure the buffered commands are executedatomically as a group. This happens by default. If you want to disable theatomic nature of a pipeline but still want to buffer commands, you can turnoff transactions... code-block:: pycon    &gt;&gt;&gt; pipe = r.pipeline(transaction=False)A common issue occurs when requiring atomic transactions but needing toretrieve values in Redis prior for use within the transaction. For instance,let's assume that the INCR command didn't exist and we need to build an atomicversion of INCR in Python.The completely naive implementation could GET the value, increment it inPython, and SET the new value back. However, this is not atomic becausemultiple clients could be doing this at the same time, each getting the samevalue from GET.Enter the WATCH command. WATCH provides the ability to monitor one or more keysprior to starting a transaction. If any of those keys change prior theexecution of that transaction, the entire transaction will be canceled and aWatchError will be raised. To implement our own client-side INCR command, wecould do something like this:.. code-block:: pycon    &gt;&gt;&gt; with r.pipeline() as pipe:    ...     while 1:    ...         try:    ...             # put a WATCH on the key that holds our sequence value    ...             pipe.watch('OUR-SEQUENCE-KEY')    ...             # after WATCHing, the pipeline is put into immediate execution    ...             # mode until we tell it to start buffering commands again.    ...             # this allows us to get the current value of our sequence    ...             current_value = pipe.get('OUR-SEQUENCE-KEY')    ...             next_value = int(current_value) + 1    ...             # now we can put the pipeline back into buffered mode with MULTI    ...             pipe.multi()    ...             pipe.set('OUR-SEQUENCE-KEY', next_value)    ...             # and finally, execute the pipeline (the set command)    ...             pipe.execute()    ...             # if a WatchError wasn't raised during execution, everything    ...             # we just did happened atomically.    ...             break    ...        except WatchError:    ...             # another client must have changed 'OUR-SEQUENCE-KEY' between    ...             # the time we started WATCHing it and the pipeline's execution.    ...             # our best bet is to just retry.    ...             continueNote that, because the Pipeline must bind to a single connection for theduration of a WATCH, care must be taken to ensure that the connection isreturned to the connection pool by calling the reset() method. If thePipeline is used as a context manager (as in the example above) reset()will be called automatically. Of course you can do this the manual way byexplicitly calling reset():.. code-block:: pycon    &gt;&gt;&gt; pipe = r.pipeline()    &gt;&gt;&gt; while 1:    ...     try:    ...         pipe.watch('OUR-SEQUENCE-KEY')    ...         ...    ...         pipe.execute()    ...         break    ...     except WatchError:    ...         continue    ...     finally:    ...         pipe.reset()A convenience method named &quot;transaction&quot; exists for handling all theboilerplate of handling and retrying watch errors. It takes a callable thatshould expect a single parameter, a pipeline object, and any number of keys tobe WATCHed. Our client-side INCR command above can be written like this,which is much easier to read:.. code-block:: pycon    &gt;&gt;&gt; def client_side_incr(pipe):    ...     current_value = pipe.get('OUR-SEQUENCE-KEY')    ...     next_value = int(current_value) + 1    ...     pipe.multi()    ...     pipe.set('OUR-SEQUENCE-KEY', next_value)    &gt;&gt;&gt;    &gt;&gt;&gt; r.transaction(client_side_incr, 'OUR-SEQUENCE-KEY')    [True]Publish / Subscribe^^^^^^^^^^^^^^^^^^^redispy includes a `PubSub` object that subscribes to channels and listensfor new messages. Creating a `PubSub` object is easy... code-block:: pycon    &gt;&gt;&gt; r = redis.StrictRedis(...)    &gt;&gt;&gt; p = r.pubsub()Once a `PubSub` instance is created, channels and patterns can be subscribedto... code-block:: pycon    &gt;&gt;&gt; p.subscribe('my-first-channel', 'my-second-channel', ...)    &gt;&gt;&gt; p.psubscribe('my-*', ...)The `PubSub` instance is now subscribed to those channels/patterns. Thesubscription confirmations can be seen by reading messages from the `PubSub`instance... code-block:: pycon    &gt;&gt;&gt; p.get_message()    {'pattern': None, 'type': 'subscribe', 'channel': 'my-second-channel', 'data': 1L}    &gt;&gt;&gt; p.get_message()    {'pattern': None, 'type': 'subscribe', 'channel': 'my-first-channel', 'data': 2L}    &gt;&gt;&gt; p.get_message()    {'pattern': None, 'type': 'psubscribe', 'channel': 'my-*', 'data': 3L}Every message read from a `PubSub` instance will be a dictionary with thefollowing keys.* **type**: One of the following: 'subscribe', 'unsubscribe', 'psubscribe',  'punsubscribe', 'message', 'pmessage'* **channel**: The channel [un]subscribed to or the channel a message was  published to* **pattern**: The pattern that matched a published message's channel. Will be  `None` in all cases except for 'pmessage' types.* **data**: The message data. With [un]subscribe messages, this value will be  the number of channels and patterns the connection is currently subscribed  to. With [p]message messages, this value will be the actual published  message.Let's send a message now... code-block:: pycon    # the publish method returns the number matching channel and pattern    # subscriptions. 'my-first-channel' matches both the 'my-first-channel'    # subscription and the 'my-*' pattern subscription, so this message will    # be delivered to 2 channels/patterns    &gt;&gt;&gt; r.publish('my-first-channel', 'some data')    2    &gt;&gt;&gt; p.get_message()    {'channel': 'my-first-channel', 'data': 'some data', 'pattern': None, 'type': 'message'}    &gt;&gt;&gt; p.get_message()    {'channel': 'my-first-channel', 'data': 'some data', 'pattern': 'my-*', 'type': 'pmessage'}Unsubscribing works just like subscribing. If no arguments are passed to[p]unsubscribe, all channels or patterns will be unsubscribed from... code-block:: pycon    &gt;&gt;&gt; p.unsubscribe()    &gt;&gt;&gt; p.punsubscribe('my-*')    &gt;&gt;&gt; p.get_message()    {'channel': 'my-second-channel', 'data': 2L, 'pattern': None, 'type': 'unsubscribe'}    &gt;&gt;&gt; p.get_message()    {'channel': 'my-first-channel', 'data': 1L, 'pattern': None, 'type': 'unsubscribe'}    &gt;&gt;&gt; p.get_message()    {'channel': 'my-*', 'data': 0L, 'pattern': None, 'type': 'punsubscribe'}redispy also allows you to register callback functions to handle publishedmessages. Message handlers take a single argument, the message, which is adictionary just like the examples above. To subscribe to a channel or patternwith a message handler, pass the channel or pattern name as a keyword argumentwith its value being the callback function.When a message is read on a channel or pattern with a message handler, themessage dictionary is created and passed to the message handler. In this case,a `None` value is returned from get_message() since the message was alreadyhandled... code-block:: pycon    &gt;&gt;&gt; def my_handler(message):    ...     print 'MY HANDLER: ', message['data']    &gt;&gt;&gt; p.subscribe(**{'my-channel': my_handler})    # read the subscribe confirmation message    &gt;&gt;&gt; p.get_message()    {'pattern': None, 'type': 'subscribe', 'channel': 'my-channel', 'data': 1L}    &gt;&gt;&gt; r.publish('my-channel', 'awesome data')    1    # for the message handler to work, we need tell the instance to read data.    # this can be done in several ways (read more below). we'll just use    # the familiar get_message() function for now    &gt;&gt;&gt; message = p.get_message()    MY HANDLER:  awesome data    # note here that the my_handler callback printed the string above.    # `message` is None because the message was handled by our handler.    &gt;&gt;&gt; print message    NoneIf your application is not interested in the (sometimes noisy)subscribe/unsubscribe confirmation messages, you can ignore them by passing`ignore_subscribe_messages=True` to `r.pubsub()`. This will cause allsubscribe/unsubscribe messages to be read, but they won't bubble up to yourapplication... code-block:: pycon    &gt;&gt;&gt; p = r.pubsub(ignore_subscribe_messages=True)    &gt;&gt;&gt; p.subscribe('my-channel')    &gt;&gt;&gt; p.get_message()  # hides the subscribe message and returns None    &gt;&gt;&gt; r.publish('my-channel')    1    &gt;&gt;&gt; p.get_message()    {'channel': 'my-channel', 'data': 'my data', 'pattern': None, 'type': 'message'}There are three different strategies for reading messages.The examples above have been using `pubsub.get_message()`. Behind the scenes,`get_message()` uses the system's 'select' module to quickly poll theconnection's socket. If there's data available to be read, `get_message()` willread it, format the message and return it or pass it to a message handler. Ifthere's no data to be read, `get_message()` will immediately return None. Thismakes it trivial to integrate into an existing event loop inside yourapplication... code-block:: pycon    &gt;&gt;&gt; while True:    &gt;&gt;&gt;     message = p.get_message()    &gt;&gt;&gt;     if message:    &gt;&gt;&gt;         # do something with the message    &gt;&gt;&gt;     time.sleep(0.001)  # be nice to the system :)Older versions of redispy only read messages with `pubsub.listen()`. listen()is a generator that blocks until a message is available. If your applicationdoesn't need to do anything else but receive and act on messages received fromredis, listen() is an easy way to get up an running... code-block:: pycon    &gt;&gt;&gt; for message in p.listen():    ...     # do something with the messageThe third option runs an event loop in a separate thread.`pubsub.run_in_thread()` creates a new thread and starts the event loop. Thethread object is returned to the caller of `run_in_thread()`. The caller canuse the `thread.stop()` method to shut down the event loop and thread. Behindthe scenes, this is simply a wrapper around `get_message()` that runs in aseparate thread, essentially creating a tiny non-blocking event loop for you.`run_in_thread()` takes an optional `sleep_time` argument. If specified, theevent loop will call `time.sleep()` with the value in each iteration of theloop.Note: Since we're running in a separate thread, there's no way to handlemessages that aren't automatically handled with registered message handlers.Therefore, redispy prevents you from calling `run_in_thread()` if you'resubscribed to patterns or channels that don't have message handlers attached... code-block:: pycon    &gt;&gt;&gt; p.subscribe(**{'my-channel': my_handler})    &gt;&gt;&gt; thread = p.run_in_thread(sleep_time=0.001)    # the event loop is now running in the background processing messages    # when it's time to shut it down...    &gt;&gt;&gt; thread.stop()A PubSub object adheres to the same encoding semantics as the client instanceit was created from. Any channel or pattern that's unicode will be encodedusing the `charset` specified on the client before being sent to Redis. If theclient's `decode_responses` flag is set the False (the default), the'channel', 'pattern' and 'data' values in message dictionaries will be bytestrings (str on Python 2, bytes on Python 3). If the client's`decode_responses` is True, then the 'channel', 'pattern' and 'data' valueswill be automatically decoded to unicode strings using the client's `charset`.PubSub objects remember what channels and patterns they are subscribed to. Inthe event of a disconnection such as a network error or timeout, thePubSub object will re-subscribe to all prior channels and patterns whenreconnecting. Messages that were published while the client was disconnectedcannot be delivered. When you're finished with a PubSub object, call its`.close()` method to shutdown the connection... code-block:: pycon    &gt;&gt;&gt; p = r.pubsub()    &gt;&gt;&gt; ...    &gt;&gt;&gt; p.close()LUA Scripting^^^^^^^^^^^^^redispy supports the EVAL, EVALSHA, and SCRIPT commands. However, there area number of edge cases that make these commands tedious to use in real worldscenarios. Therefore, redispy exposes a Script object that makes scriptingmuch easier to use.To create a Script instance, use the `register_script` function on a clientinstance passing the LUA code as the first argument. `register_script` returnsa Script instance that you can use throughout your code.The following trivial LUA script accepts two parameters: the name of a key anda multiplier value. The script fetches the value stored in the key, multipliesit with the multiplier value and returns the result... code-block:: pycon    &gt;&gt;&gt; r = redis.StrictRedis()    &gt;&gt;&gt; lua = &quot;&quot;&quot;    ... local value = redis.call('GET', KEYS[1])    ... value = tonumber(value)    ... return value * ARGV[1]&quot;&quot;&quot;    &gt;&gt;&gt; multiply = r.register_script(lua)`multiply` is now a Script instance that is invoked by calling it like afunction. Script instances accept the following optional arguments:* **keys**: A list of key names that the script will access. This becomes the  KEYS list in LUA.* **args**: A list of argument values. This becomes the ARGV list in LUA.* **client**: A redispy Client or Pipeline instance that will invoke the  script. If client isn't specified, the client that intiially  created the Script instance (the one that `register_script` was  invoked from) will be used.Continuing the example from above:.. code-block:: pycon    &gt;&gt;&gt; r.set('foo', 2)    &gt;&gt;&gt; multiply(keys=['foo'], args=[5])    10The value of key 'foo' is set to 2. When multiply is invoked, the 'foo' key ispassed to the script along with the multiplier value of 5. LUA executes thescript and returns the result, 10.Script instances can be executed using a different client instance, even onethat points to a completely different Redis server... code-block:: pycon    &gt;&gt;&gt; r2 = redis.StrictRedis('redis2.example.com')    &gt;&gt;&gt; r2.set('foo', 3)    &gt;&gt;&gt; multiply(keys=['foo'], args=[5], client=r2)    15The Script object ensures that the LUA script is loaded into Redis's scriptcache. In the event of a NOSCRIPT error, it will load the script and retryexecuting it.Script objects can also be used in pipelines. The pipeline instance should bepassed as the client argument when calling the script. Care is taken to ensurethat the script is registered in Redis's script cache just prior to pipelineexecution... code-block:: pycon    &gt;&gt;&gt; pipe = r.pipeline()    &gt;&gt;&gt; pipe.set('foo', 5)    &gt;&gt;&gt; multiply(keys=['foo'], args=[5], client=pipe)    &gt;&gt;&gt; pipe.execute()    [True, 25]Sentinel support^^^^^^^^^^^^^^^^redispy can be used together with `Redis Sentinel &lt;http://redis.io/topics/sentinel&gt;`_to discover Redis nodes. You need to have at least one Sentinel daemon runningin order to use redispy's Sentinel support.Connecting redispy to the Sentinel instance(s) is easy. You can use aSentinel connection to discover the master and slaves network addresses:.. code-block:: pycon    &gt;&gt;&gt; from redis.sentinel import Sentinel    &gt;&gt;&gt; sentinel = Sentinel([('localhost', 26379)], socket_timeout=0.1)    &gt;&gt;&gt; sentinel.discover_master('mymaster')    ('127.0.0.1', 6379)    &gt;&gt;&gt; sentinel.discover_slaves('mymaster')    [('127.0.0.1', 6380)]You can also create Redis client connections from a Sentinel instance. You canconnect to either the master (for write operations) or a slave (for read-onlyoperations)... code-block:: pycon    &gt;&gt;&gt; master = sentinel.master_for('mymaster', socket_timeout=0.1)    &gt;&gt;&gt; slave = sentinel.slave_for('mymaster', socket_timeout=0.1)    &gt;&gt;&gt; master.set('foo', 'bar')    &gt;&gt;&gt; slave.get('foo')    'bar'The master and slave objects are normal StrictRedis instances with theirconnection pool bound to the Sentinel instance. When a Sentinel backed clientattempts to establish a connection, it first queries the Sentinel servers todetermine an appropriate host to connect to. If no server is found,a MasterNotFoundError or SlaveNotFoundError is raised. Both exceptions aresubclasses of ConnectionError.When trying to connect to a slave client, the Sentinel connection pool williterate over the list of slaves until it finds one that can be connected to.If no slaves can be connected to, a connection will be established with themaster.See `Guidelines for Redis clients with support for Redis Sentinel&lt;http://redis.io/topics/sentinel-clients&gt;`_ to learn more about Redis Sentinel.Scan Iterators^^^^^^^^^^^^^^The \*SCAN commands introduced in Redis 2.8 can be cumbersome to use. Whilethese commands are fully supported, redispy also exposes the following methodsthat return Python iterators for convenience: `scan_iter`, `hscan_iter`,`sscan_iter` and `zscan_iter`... code-block:: pycon    &gt;&gt;&gt; for key, value in (('A', '1'), ('B', '2'), ('C', '3')):    ...     r.set(key, value)    &gt;&gt;&gt; for key in r.scan_iter():    ...     print key, r.get(key)    A 1    B 2    C 3Author^^^^^^redispy is developed and maintained by Jamie Cressey based onthe original redis-py work by Andy McCurdy (sedrik@gmail.com).It can be found here: http://github.com/jamiecressey/redispySpecial thanks to:* Ludovico Magnocavallo, author of the original Python Redis client, from  which some of the socket code is still used.* Alexander Solovyov for ideas on the generic response callback system.* Paul Hubbard for initial packaging support.</longdescription>
</pkgmetadata>