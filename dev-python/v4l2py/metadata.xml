<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># v4l2py[![V4L2py][pypi-version]](https://pypi.python.org/pypi/v4l2py)[![Python Versions][pypi-python-versions]](https://pypi.python.org/pypi/v4l2py)![License][license][![CI][CI]](https://github.com/tiagocoutinho/v4l2py/actions/workflows/ci.yml)Video for linux 2 (V4L2) python libraryA two purpose API:* high level Device API for humans to play with :-)* raw python binding for the v4l2 (video4linux2) userspace API, using ctypes (don't even  bother wasting your time here. You probably won't use it)Only works on python &gt;= 3.7.## InstallationFrom within your favorite python environment:```bash$ pip install v4l2py```## UsageWithout further ado:```python&gt;&gt;&gt; from v4l2py import Device&gt;&gt;&gt; with Device.from_id(0) as cam:&gt;&gt;&gt;     for i, frame in enumerate(cam):...         print(f&quot;frame #{i}: {len(frame)} bytes&quot;)...         if i &gt; 9:...             break...frame #0: 54630 bytesframe #1: 50184 bytesframe #2: 44054 bytesframe #3: 42822 bytesframe #4: 42116 bytesframe #5: 41868 bytesframe #6: 41322 bytesframe #7: 40896 bytesframe #8: 40844 bytesframe #9: 40714 bytesframe #10: 40662 bytes```Getting information about the device:```python&gt;&gt;&gt; from v4l2py.device import Device, BufferType&gt;&gt;&gt; cam = Device.from_id(0)&gt;&gt;&gt; cam.open()&gt;&gt;&gt; cam.info.card'Integrated_Webcam_HD: Integrate'&gt;&gt;&gt; cam.info.capabilities&lt;Capability.STREAMING|EXT_PIX_FORMAT|VIDEO_CAPTURE: 69206017&gt;&gt;&gt;&gt; cam.info.formats[ImageFormat(type=&lt;BufferType.VIDEO_CAPTURE: 1&gt;, description=b'Motion-JPEG',             flags=&lt;ImageFormatFlag.COMPRESSED: 1&gt;, pixelformat=&lt;PixelFormat.MJPEG: 1196444237&gt;), ImageFormat(type=&lt;BufferType.VIDEO_CAPTURE: 1&gt;, description=b'YUYV 4:2:2',             flags=&lt;ImageFormatFlag.0: 0&gt;, pixelformat=&lt;PixelFormat.YUYV: 1448695129&gt;)]&gt;&gt;&gt; cam.get_format(BufferType.VIDEO_CAPTURE)Format(width=640, height=480, pixelformat=&lt;PixelFormat.MJPEG: 1196444237&gt;}&gt;&gt;&gt; for ctrl in cam.controls.values(): print(ctrl)&lt;Control brightness type=integer min=0 max=255 step=1 default=128 value=64&gt;&lt;Control contrast type=integer min=0 max=255 step=1 default=32 value=32&gt;&lt;Control saturation type=integer min=0 max=100 step=1 default=64 value=64&gt;&lt;Control hue type=integer min=-180 max=180 step=1 default=0 value=0&gt;&lt;Control white_balance_automatic type=boolean default=1 value=1&gt;&lt;Control gamma type=integer min=90 max=150 step=1 default=120 value=120&gt;&lt;Control gain type=integer min=1 max=7 step=1 default=1 value=1&gt;&lt;Control power_line_frequency type=menu min=0 max=2 step=1 default=2 value=2&gt;&lt;Control white_balance_temperature type=integer min=2800 max=6500 step=1 default=4000 value=4000 flags=inactive&gt;&lt;Control sharpness type=integer min=0 max=7 step=1 default=2 value=2&gt;&lt;Control backlight_compensation type=integer min=0 max=1 step=1 default=0 value=0&gt;&lt;Control auto_exposure type=menu min=0 max=3 step=1 default=3 value=3&gt;&lt;Control exposure_time_absolute type=integer min=10 max=333 step=1 default=156 value=156 flags=inactive&gt;&lt;Control exposure_dynamic_framerate type=boolean default=0 value=1&gt;```&gt;&gt;&gt; cam.controls[&quot;saturation&quot;]&lt;Control saturation type=integer min=0 max=100 step=1 default=64 value=64&gt;&gt;&gt;&gt; cam.controls[&quot;saturation&quot;].id9963778&gt;&gt;&gt; cam.controls[9963778]&lt;Control saturation type=integer min=0 max=100 step=1 default=64 value=64&gt;&gt;&gt;&gt; cam.controls.brightness&lt;Control brightness type=integer min=0 max=255 step=1 default=128 value=64&gt;&gt;&gt;&gt; cam.controls.brightness.value = 128&gt;&gt;&gt; cam.controls.brightness&lt;Control brightness type=integer min=0 max=255 step=1 default=128 value=128&gt;```### asynciov4l2py is asyncio friendly:```bash$ python -m asyncio&gt;&gt;&gt; from v4l2py import Device&gt;&gt;&gt; with Device.from_id(0) as camera:...     async for frame in camera:...         print(f&quot;frame {len(frame)}&quot;)frame 10224frame 10304frame 10224frame 10136...```(check [basic async](examples/basic_async.py) and [web async](examples/web/async.py) examples)### geventv4l2py is also gevent friendly:```$ python&gt;&gt;&gt; from v4l2py import Device, GeventIO&gt;&gt;&gt; with Device.from_id(0, io=GeventIO) as camera:...     for frame in camera:...         print(f&quot;frame {len(frame)}&quot;)frame 10224frame 10304frame 10224frame 10136...```(check [basic gevent](examples/basic_gevent.py) and [web gevent](examples/web/sync.py) examples)## Bonus trackYou've been patient enough to read until here so, just for you,a 20 line gem: a flask web server displaying your device on the web:```bash$ pip install flask``````python# web.pyimport flaskfrom v4l2py import Deviceapp = flask.Flask('basic-web-cam')def gen_frames():    with Device.from_id(0) as cam:        for frame in cam:            yield b&quot;--frame\r\nContent-Type: image/jpeg\r\n\r\n&quot; + frame.data + b&quot;\r\n&quot;@app.route(&quot;/&quot;)def index():    return '&lt;html&gt;&lt;img src=&quot;/stream&quot; /&gt;&lt;/html&gt;'@app.route(&quot;/stream&quot;)def stream():    return flask.Response(        gen_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')```run with:```bash$ FLASK_APP=web flask run -h 0.0.0.0```Point your browser to [127.0.0.1:5000](http://127.0.0.1:5000) and you should seeyour camera rolling!## Migrating from 1.x to 2A frame changed from a simple bytes object to a Frame which containsthe data plus all frame metadata.As a consequence, when migrating from 1.x to 2, you will need to castframe object with `bytes` or access the `frame.data` item:Before:```pythonwith Device.from_id(0) as cam:    for frame in cam:        buff = io.BytesIO(frame)```Now:```pythonwith Device.from_id(0) as cam:    for frame in cam:        frame = bytes(frame)  # or frame = frame.data        buff = io.BytesIO(frame)```## ReferencesSee the ``linux/videodev2.h`` header file for details.* `Video for Linux Two Specification &lt;http://linuxtv.org/downloads/v4l-dvb-apis/ch07s02.html&gt;`[pypi-python-versions]: https://img.shields.io/pypi/pyversions/v4l2py.svg[pypi-version]: https://img.shields.io/pypi/v/v4l2py.svg[pypi-status]: https://img.shields.io/pypi/status/v4l2py.svg[license]: https://img.shields.io/pypi/l/v4l2py.svg[CI]: https://github.com/tiagocoutinho/v4l2py/actions/workflows/ci.yml/badge.svg</longdescription>
</pkgmetadata>