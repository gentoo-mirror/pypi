<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># rtreelibPluggable R-tree implementation in pure Python.## OverviewSince the original R-tree data structure has been initially proposed in 1984, there have beenmany variations introduced over the years optimized for various use cases [1]. However, whenworking in Python (one of the most popular languages for spatial data processing), there isno easy way to quickly compare how these various implementations behave on real data.The aim of this library is to provide a &quot;pluggable&quot; R-tree implementation that allows swappingout the various strategies for insertion, node deletion, and other behaviors so that theirimpact can be easily compared (without having to install separate libraries and having tomake code changes to accommodate for API differences). Several of the more common R-treevariations will soon be provided as ready-built implementations (see the **Status** sectionbelow).In addition, this library also provides utilities for inspecting the R-tree structure. Itallows creating diagrams (using matplotlib and graphviz) that show the R-tree nodes andentries (including all the intermediate, non-leaf nodes), along with plots of theircorresponding bounding boxes. It also allows exporting the R-tree to PostGIS so it couldbe examined using a GIS viewer like QGIS.## StatusThis library is currently in early development. The table below shows which R-tree variantshave been implemented, along with which operations they currently support:| R-Tree Variant        | Insert                | Update                | Delete                ||-----------------------|-----------------------|-----------------------|-----------------------|| **Guttman** [2]       | :heavy_check_mark:    | :black_square_button: | :black_square_button: || **R\*-Tree** [3]      | :heavy_check_mark:    | :black_square_button: | :black_square_button: |The library has a framework in place for swapping out the various strategies, making itpossible to add a new R-tree variant. However, given that this library is still early indevelopment, it is anticipated that this framework may need to be extended, resulting inbreaking changes.Contributions for implementing additional strategies and operations are welcome. Seethe section on **Extending** below.## SetupThis package is available on PyPI and can be installed using pip:```pip install rtreelib```This package requires Python 3.6+.There are additional optional dependencies you can install if you want to be able tocreate diagrams or export the R-tree data to PostGIS. See the corresponding sectionsbelow for additional setup information.## UsageTo instantiate the default implementation and insert some entries:```pythonfrom rtreelib import RTree, Rectt = RTree()t.insert('a', Rect(0, 0, 3, 3))t.insert('b', Rect(2, 2, 4, 4))t.insert('c', Rect(1, 1, 2, 4))t.insert('d', Rect(8, 8, 10, 10))t.insert('e', Rect(7, 7, 9, 9))```The first parameter to the `insert` method represents the data, and can be of any data type(though you will want to stick to strings, numbers, and other basic data types that can beeasily and succintly represented as a string if you want to create diagrams). The secondparameter represents the minimum bounding rectangle (MBR) of the associated data element.The default implementation uses Guttman's original strategies for insertion, node splitting,and deletion, as outlined in his paper from 1984 [2].To use the R* implementation instead:```pythonfrom rtreelib import RStarTree, Rectt = RStarTree()t.insert('a', Rect(0, 0, 3, 3))t.insert('b', Rect(2, 2, 4, 4))t.insert('c', Rect(1, 1, 2, 4))t.insert('d', Rect(8, 8, 10, 10))t.insert('e', Rect(7, 7, 9, 9))```You can also create a custom implementation by inheriting from `RTreeBase` and providingyour own implementations for the various behaviors (insert, overflow, etc.). See thefollowing section for more information.## QueryingUse the `query` method to find entries at a given location. The library supports queryingby either a point or a rectangle, and returns an iterable of matching entries thatintersect the given location.To query using `Point`:```pythonentries = t.query(Point(2, 4))```Alternatively, you can also pass a tuple or list of 2 coordinates (`x` and `y`):```pythonentries = t.query((2, 4))```When querying by point, note that points that lie on the border (rather than theinterior) of a bounding rectangle are considered to intersect the rectangle.To query using `Rect`:```pythonentries = t.query(Rect(2, 1, 4, 5))```Alternatively, you can also pass a tuple or list of 4 coordinates (the order is thesame as when using `Rect`, namely `min_x`, `min_y`, `max_x`, and `max_y`):```pythonentries = t.query((2, 1, 4, 5))```When querying by rectangle, note that the rectangles must have a non-zero intersectionarea. Rectangles that intersect at the border but whose interiors do not overlap will*not* match the query.Note the above methods return entries rather than nodes. To get an iterable of leafnodes instead, use `query_nodes`:```pythonnodes = t.query_nodes(Rect(2, 1, 4, 5))```By default, this method will only return leaf-level nodes. To include allintermediate-level nodes (including the root), set the optional `leaves` parameterto `False` (it defaults to `True` if not passed in):```pythonall_nodes = t.query_nodes(Rect(2, 1, 4, 5), leaves=False)```## ExtendingAs noted above, the purpose of this library is to provide a pluggable R-tree implementationwhere the various behaviors can be swapped out and customized to allow comparison. To thatend, this library provides a framework for achieving this.As an example, the [`RTreeGuttman`](https://github.com/sergkr/rtreelib/blob/master/rtreelib/strategies/guttman.py)class (aliased as `RTree`) simply inherits from `RTreeBase`, providing an implementationfor the `insert`, `choose_leaf`, `adjust_tree`, and `overflow_strategy` behaviors as follows:```pythonclass RTreeGuttman(RTreeBase[T]):    &quot;&quot;&quot;R-Tree implementation that uses Guttman's strategies for insertion, splitting, and deletion.&quot;&quot;&quot;    def __init__(self, max_entries: int = DEFAULT_MAX_ENTRIES, min_entries: int = None):        &quot;&quot;&quot;        Initializes the R-Tree using Guttman's strategies for insertion, splitting, and deletion.        :param max_entries: Maximum number of entries per node.        :param min_entries: Minimum number of entries per node. Defaults to ceil(max_entries/2).        &quot;&quot;&quot;        super().__init__(            max_entries=max_entries,            min_entries=min_entries,            insert=insert,            choose_leaf=guttman_choose_leaf,            adjust_tree=adjust_tree_strategy,            overflow_strategy=quadratic_split        )```Each behavior should be a function that implements a specific signature and performs a giventask. Here are the behaviors that are currently required to be specified:* **`insert`**: Strategy used for inserting a single new entry into the tree.  * Signature: `(tree: RTreeBase[T], data: T, rect: Rect) → RTreeEntry[T]`  * Arguments:    * `tree: RTreeBase[T]`: R-tree instance.    * `data: T`: Data stored in this entry.    * `rect: Rect`: Bounding rectangle.  * Returns: `RTreeEntry[T]`    * This function should return the newly inserted entry.* **`choose_leaf`**: Strategy used for choosing a leaf node when inserting a new entry.  * Signature: `(tree: RTreeBase[T], entry: RTreeEntry[T]) → RTreeNode[T]`  * Arguments:    * `tree: RTreeBase[T]`: R-tree instance.    * `entry: RTreeEntry[T]`: Entry being inserted.  * Returns: `RTreeNode[T]`    * This function should return the leaf node where the new entry should be inserted. This    node may or may not have the capacity for the new entry. If the insertion of the new node    results in the node overflowing, then `overflow_strategy` will be invoked on the node.* **`adjust_tree`**: Strategy used for balancing the tree, including propagating node splits,updating bounding boxes on all nodes and entries as necessary, and growing the tree bycreating a new root if necessary. This strategy is executed after inserting or deleting anentry.  * Signature: `(tree: RTreeBase[T], node: RTreeNode[T], split_node: RTreeNode[T]) → None`  * Arguments:    * `tree: RTreeBase[T]`: R-tree instance.    * `node: RTreeNode[T]`: Node where a newly-inserted entry has just been added.    * `split_node: RTreeNode[T]`: If the insertion of a new entry has caused the node to    split, this is the newly-created split node. Otherwise, this will be `None`.  * Returns: `None`* **`overflow_strategy`**: Strategy used for handling an overflowing node (a node thatcontains more than `max_entries`). Depending on the implementation, this may involvesplitting the node and potentially growing the tree (Guttman), performing a forcedreinsert of entries (R*), or some other strategy.  * Signature: `(tree: RTreeBase[T], node: RTreeNode[T]) → RTreeNode[T]`  * Arguments:    * `tree: RTreeBase[T]`: R-tree instance.    * `node: RTreeNode[T]`: Overflowing node.  * Returns: `RTreeNode[T]`    * Depending on the implementation, this function may return a newly-created split    node whose entries are a subset of the original node's entries (Guttman), or simply    return `None`.## Creating R-tree DiagramsThis library provides a set of utility functions that can be used to create diagrams of theentire R-tree structure, including the root and all intermediate and leaf level nodes andentries.These features are optional, and the required dependencies are *not* automatically installedwhen installing this library. Therefore, you must install them manually. This includes thefollowing Python dependencies which can be installed using pip:```pip install matplotlib pydot tqdm```This also includes the following system-level dependencies:* TkInter* GraphvizOn Ubuntu, these can be installed using:```sudo apt install python3-tk graphviz```Once the above dependencies are installed, you can create an R-tree diagram as follows:```pythonfrom rtreelib import RTree, Rectfrom rtreelib.diagram import create_rtree_diagram# Create an RTree instance with some sample datat = RTree(max_entries=4)t.insert('a', Rect(0, 0, 3, 3))t.insert('b', Rect(2, 2, 4, 4))t.insert('c', Rect(1, 1, 2, 4))t.insert('d', Rect(8, 8, 10, 10))t.insert('e', Rect(7, 7, 9, 9))# Create a diagram of the R-tree structurecreate_rtree_diagram(t)```This creates a diagram like the following:![R-tree Diagram](https://github.com/sergkr/rtreelib/blob/master/doc/rtree_diagram.png &quot;R-tree Diagram&quot;)The diagram is created in a temp directory as a PNG file, and the default vieweris automatically launched for convenience. Each box in the main diagram represents a node(except at the leaf level, where it represents the leaf entry), and contains a plot thatdepicts all of the data spatially. The bounding boxes of each node are represented usingtan rectangles with a dashed outline. The bounding box corresponding to the current nodeis highlighted in pink.The bounding boxes for the original data entries themselves are depicted in blue, and arelabeled using the value that was passed in to `insert`. At the leaf level, the correspondingdata element is highlighted in pink.The entries contained in each node are depicted along the bottom of the node's box, andpoint to either a child node (for non-leaf nodes), or to the data entries (for leaf nodes).As can be seen in the above screenshot, the diagram depicts the entire tree structure, whichcan be quite large depending on the number of nodes and entries. It may also take a while togenerate, since it launches matplotlib to plot the data spatially for each node and entry, andthen graphviz to generate the overall diagram. Given the size and execution time required togenerate these diagrams, it's only practical for R-trees containing a relatively smallamount of data (e.g., no more than about a dozen total entries). To analyze the resultingR-tree structure when working with a large amount of data, it is recommended to export thedata to PostGIS and use a viewer like QGIS (as explained in the following section).## Exporting to PostGISIn addition to creating diagrams, this library also allows exporting R-trees to aPostGIS database.To do so, you will first need to install the [psycopg2](http://initd.org/psycopg/) driver.This is an optional dependency, so it is not automatically installed when you installthis package. Refer to the[installation instructions for psycopg2](http://initd.org/psycopg/docs/install.html) toensure that you have all the necessary system-wide prerequisites installed (C compiler,Python header files, etc.). Then, install `psycopg2` using the following command (passingthe `--no-binary` flag to ensure that it is built from source, and also to avoid a consolewarning when using `psycopg2`):```pip install psycopg2 --no-binary psycopg2```Once `psycopg2` is installed, you should be able to import the functions you need from the`rtreelib.pg` module:```pythonfrom rtreelib.pg import init_db_pool, create_rtree_tables, export_to_postgis```The subsections below guide you throw how to use this library to export R-trees to thedatabase. You will first need to decide on your preferred method for connecting to thedatabase, as well as create the necessary tables to store the R-tree data. Once theseprerequisites are met, exporting the R-tree can be done using a simple function call.Finally, this guide shows how you can visualize the exported data using QGIS, a popularand freely-available GIS viewer.### Initializing a Connection PoolWhen working with the `rtreelib.pg` module, there are three ways of passing databaseconnection information:1. Initialize a connection pool by calling `init_db_pool`. This allows using the otherfunctions in this module without having to pass around connection info.2. Manually open the connection yourself, and pass in the connection object to thefunction.3. Pass in keyword arguments that can be used to establish the database connection.The first method is generally the easiest - you just have to call it once, and nothave to worry about passing in connection information to the other functions. Thissection explains this method, and the following sections assume that you are usingit. However, the other methods are also explained later on in this guide.`init_db_pool` accepts the same parameters as the[psycopg2.connect](http://initd.org/psycopg/docs/module.html#psycopg2.connect) function.For example, you can pass in a connection string:```pythoninit_db_pool(&quot;dbname=mydb user=postgres password=temp123!&quot;)```Alternatively, using the URL syntax:```pythoninit_db_pool(&quot;postgresql://localhost/mydb?user=postgres&amp;password=temp123!&quot;)```Or keyword arguments:```pythoninit_db_pool(user=&quot;postgres&quot;, password=&quot;temp123!&quot;, host=&quot;localhost&quot;, database=&quot;mydb&quot;)```Next, before you can export an R-tree, you first need to create a few databasetables to store the data. The following section explains how to achieve this.### Creating Tables to Store R-tree DataWhen exporting an R-tree using this library, the data is populated inside threetables:* `rtree`: This tables simply contains the ID of each R-tree that was exported.This library allows you to export multiple R-trees at once, and they aredifferentiated by ID (you can also clear the contents of all tables using`clear_rtree_tables`).* `rtree_node`: Contains information about each node in the R-tree, includingits bounding box (as a PostGIS geometry column), a pointer to the parent entrycontaining this node, and the level of this node (starting at 0 for the root).The node also contains a reference to the `rtree` that it is a part of.* `rtree_entry`: Contains information about each entry in the R-tree, includingits bounding box (as a PostGIS geometry column) and a pointer to the nodecontaining this entry. For leaf entries, this also contains the value of thedata element.These tables can be created using the `create_rtree_tables` function. This issomething you only need to do once.This function can be called without any arguments if you have established theconnection pool, and your data does not use a spatial reference system (`srid`).However, generally when working with spatial data, you will have a particularSRID that your data is in, in which case you should pass it in to ensure thatall geometry columns use the correct SRID:```pythoncreate_rtree_tables(srid=4326)```You can also choose to create the tables in a different schema (other than `public`):```pythoncreate_rtree_tables(srid=4326, schema=&quot;temp&quot;)```However, in this case, be sure to pass in the same schema to the other functions inthis module.You can also pass in a `datatype`, which indicates the type of data stored in the leafentries (i.e., the type of the data you pass in to the `insert` method of `RTree`).This can either be a string containing a PostgreSQL column type:```pythoncreate_rtree_tables(srid=4326, datatype='VARCHAR(255)')```Or a Python type, in which case an appropriate PostgreSQL data type will be inferred:```pythoncreate_rtree_tables(srid=4326, datatype=int)```If you don't pass anything in, or an appropriate PostgreSQL data type cannot bedetermined from the Python type, the column type will default to `TEXT`, which allowsstoring arbitrary-length strings.When passing a string containing a PostgreSQL column type, you also have the optionof adding a modifier such as `NOT NULL`, or even a foreign key constraint:```pythoncreate_rtree_tables(srid=4326, datatype='INT REFERENCES my_other_table (my_id_column)')```### Exporting the R-treeTo export the R-tree once the tables have been created, simply call the`export_to_postgis` function, passing in the R-tree instance (and optionally an SRID):```pythonrtree_id = export_to_postgis(tree, srid=4326)```This function populates the `rtree`, `rtree_node`, and `rtree_entry` tables withthe data from the R-tree, and returns the ID of the newly-inserted R-tree in the`rtree` table.Note that if you used a schema other than `public` when calling`create_rtree_tables`, you will need to pass in the same schema when calling`export_to_postgis`:```pythonrtree_id = export_to_postgis(tree, srid=4326, schema='temp')```### Viewing the Data Using QGIS[QGIS](https://qgis.org/en/site/) is a popular and freely-available GIS viewer whichcan be used to visualize the exported R-tree data. To do so, launch QGIS and createa new project. Then, follow these steps to add the exported R-tree data as a layer:* Go to Layer → Add Layer → Add PostGIS Layers* Connect to the database where you exported the data* Select either the `rtree_node` or `rtree_entry` table, depending on which part ofthe structure you wish to visualize. For this example, we will be looking at thenodes, so select `rtree_node`.* Optionally, you can set a layer filter to only include the nodes belonging to aparticular tree (if you exported multiple R-trees). To do so, click the**Set Filter** button, and enter a filter expression (such as `rtree_id=1`).* Click **Add**At this point, the layer will be displaying all nodes at every level of the tree,which may be a bit hard to decipher if you have a lot of data. After adjusting thelayer style to make it partially transparent, here is an example of what an R-treewith a couple hundred leaf entries might look like (41 nodes across 3 levels):![QGIS - All Nodes](https://github.com/sergkr/rtreelib/blob/master/doc/qgis_all_nodes.png)To make it easier to understand the structure, it might help to be able to view eachlevel of the tree independently. To do this, double click the layer in the Layerspanel, switch to the Style tab, and change the style type at the top from&quot;Single symbol&quot; (the default) to &quot;Categorized&quot;. Then in the Column dropdown, selectthe &quot;level&quot; column. You can optionally assign a color ramp or use random colors sothat each level gets a different color. Then click **Classify** to automaticallycreate a separate style for each layer:![QGIS - Layer Style](https://github.com/sergkr/rtreelib/blob/master/doc/qgis_layer_style.png)Now in the layers panel, each level will be shown as a separate entry and can betoggled on and off, making it possible to explore the R-tree structure one levelat a time:![QGIS - Layers Panel](https://github.com/sergkr/rtreelib/blob/master/doc/qgis_layers_panel.png)The advantage with exporting the data to QGIS is you can also bring in youroriginal dataset as a layer to see how it was partitioned spatially. Further,you can import multiple R-trees as separate layers and be able to compare themside by side.Below, I am using a subset of the FAA airspace data for a portion of theNortheastern US, and then toggling each level of the `rtree_node` layer individuallyso we can examine the resulting R-tree structure one level at a time. Aftercompositing these together, you can see how the Guttman R-Tree performs againstR*.**Guttman**:![Guttman R-Tree](https://github.com/sergkr/rtreelib/blob/master/doc/qgis_guttman.gif)**R\*-Tree**:![R*-Tree](https://github.com/sergkr/rtreelib/blob/master/doc/qgis_rstar.gif)It is evident that R* has resulted in more square-like bounding rectangles withless overlap at the intermediate levels, compared to Guttman. The areas of overlapare made especially evident when using a partially transparent fill. Ideally, thespatial partitioning scheme should aim to minimize this overlap, since a query tofind the leaf entry for a given point would require visiting multiple subtrees ifthat point happens to land in one of these darker shaded areas of overlap.You can also write a query to analyze the amount of overlap that resulted in eachlevel of the tree. For example, the query below returns the total amount of overlaparea of all nodes at level 2 of an exported R-tree having ID 1:```postgresqlSELECT ST_Area(ST_Union(ST_Intersection(n1.bbox, n2.bbox))) AS OverlapAreaFROM temp.rtree t  INNER JOIN temp.rtree_node n1 ON n1.rtree_id = t.id  INNER JOIN temp.rtree_node n2 ON n2.rtree_id = t.id AND n1.level = n2.levelWHERE  t.id = 1  AND n1.level = 2  AND ST_Overlaps(n1.bbox, n2.bbox)  AND n1.id &lt;&gt; n2.id;```Extending this even further, you can compare the total overlap area of multiple exportedR-trees by level:```postgresqlSELECT  CASE t.id    WHEN 1 THEN 'Guttman'    WHEN 2 THEN 'R*'  END AS tree,  n.level,  ST_Area(ST_Union(ST_Intersection(n.bbox, n2.bbox))) AS OverlapAreaFROM temp.rtree t  INNER JOIN temp.rtree_node n ON n.rtree_id = t.id  INNER JOIN temp.rtree_node n2 ON n2.rtree_id = t.id AND n.level = n2.levelWHERE  ST_Overlaps(n.bbox, n2.bbox)  AND n.id &lt;&gt; n2.idGROUP BY  t.id,  n.levelORDER BY  t.id,  n.level;```The above query may return a result like the following:tree    | level | OverlapArea |--------|-------|-------------|Guttman | 1     | 7.89e+11    |Guttman | 2     | 9.12e+11    |Guttman | 3     | 4.75e+11    |R*      | 1     | 3.97e+11    |R*      | 2     | 4.35e+11    |R*      | 3     | 1.80e+11    |In the above example, the R*-Tree (`id`=2) achieved a smaller overlap area atevery level of the tree compared to Guttman (`id`=1).### Cleaning UpAs mentioned above, when you call `export_to_postgis`, the existing data in thetables is *not* cleared. This allows you to export multiple R-trees at once andcompare them side-by-side.However, for simplicity, you may wish to clear out the existing data prior toexporting new data. To do so, call `clear_rtree_tables`:```pythonclear_rtree_tables()```This will perform a SQL `TRUNCATE` on all R-tree tables.Note that if you created the tables in a different schema (other than `public`),you will need to pass in that same schema to this function:```pythonclear_rtree_tables(schema='temp')```You may also wish to completely drop all the tables that were created by`create_rtree_tables`. To do so, call `drop_rtree_tables`:```pythondrop_rtree_tables()```Again, you may need to pass in a schema if it is something other than `public`:```pythondrop_rtree_tables(schema='temp')```### Alternate Database Connection Handling MethodsAs mentioned earlier in this guide, instead of initializing a connection pool,you have other options for how to handle establishing database connections whenusing this library. You can choose to handle opening and closing the connectionyourself and pass in the connection object; alternatively, you can pass in theconnection information as keyword arguments.To establish the database connection yourself, the typical usage scenario mightlook like this:```pythonimport psycopg2from rtreelib import RTree, Rectfrom rtreelib.pg import init_db_pool, create_rtree_tables, clear_rtree_tables, export_to_postgis, drop_rtree_tables# Create an RTree instance with some sample datat = RTree(max_entries=4)t.insert('a', Rect(0, 0, 3, 3))t.insert('b', Rect(2, 2, 4, 4))t.insert('c', Rect(1, 1, 2, 4))t.insert('d', Rect(8, 8, 10, 10))t.insert('e', Rect(7, 7, 9, 9))# Export R-tree to PostGIS (using explicit connection)conn = Nonetry:    conn = psycopg2.connect(user=&quot;postgres&quot;, password=&quot;temp123!&quot;, host=&quot;localhost&quot;, database=&quot;mydb&quot;)    create_rtree_tables(conn, schema='temp')    rtree_id = export_to_postgis(t, conn=conn, schema='temp')    print(rtree_id)finally:    if conn:        conn.close()```You can also pass in the database connection information separately to each method askeyword arguments. These keyword arguments should be the same ones as required by the[psycopg2.connect](http://initd.org/psycopg/docs/module.html#psycopg2.connect) function:```pythonrtree_id = export_to_postgis(tree, schema='temp', user=&quot;postgres&quot;, password=&quot;temp123!&quot;, host=&quot;localhost&quot;, database=&quot;mydb&quot;)```## References[1]: Nanopoulos, Alexandros &amp; Papadopoulos, Apostolos (2003):[&quot;R-Trees Have Grown Everywhere&quot;](https://pdfs.semanticscholar.org/4e07/e800fe71505fbad686b08334abb49d41fcda.pdf)[2]:  Guttman, A. (1984):[&quot;R-trees: a Dynamic Index Structure for Spatial Searching&quot;](http://www-db.deis.unibo.it/courses/SI-LS/papers/Gut84.pdf)(PDF), *Proceedings of the 1984 ACM SIGMOD international conference on Management of data – SIGMOD'84.* p. 47.[3]: Beckmann, Norbert, et al.[&quot;The R*-tree: an efficient and robust access method for points and rectangles.&quot;](https://infolab.usc.edu/csci599/Fall2001/paper/rstar-tree.pdf)*Proceedings of the 1990 ACM SIGMOD international conference on Management of data.* 1990.</longdescription>
</pkgmetadata>