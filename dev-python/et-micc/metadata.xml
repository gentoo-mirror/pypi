<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>****Micc****.. image:: https://img.shields.io/pypi/v/micc.svg        :target: https://pypi.python.org/pypi/micc.. image:: https://img.shields.io/travis/etijskens/micc.svg        :target: https://travis-ci.org/etijskens/micc.. image:: https://readthedocs.org/projects/micc/badge/?version=latest        :target: https://micc.readthedocs.io/en/latest/?badge=latest        :alt: Documentation Status`Micc &lt;https://github.com/etijskens/et-micc&gt;`_ is a Python project manager: it helps you organize your Python project from simple single file modules to fully fledged Python packages containing modules, sub-modules, apps and binary extension modules written in Fortran or C++. Micc_ organizes your project in a way that is considered goodpractice by a large part of the Python community. * Micc_ helps you create new projects. You can start small with a simple one-file   package and add material as you go, such as:    * Python **sub-modules** and **sub-packages**,  * **applications**, also known as command line interfaces (CLIs).   * **binary extension modules** written in C++ and Fortran. Boiler plate code is     automatically added as to build these binary extension with having to go through    al the details. This is, in fact, the foremost reason that got me started on this    project: For *High Performance Python* it is essential to rewrite slow and     time consuming parts of a Python script or module in a language that is made     for High Performance Computing. As figuring out how that can be done, requires     quite some effort, Micc_ was made to automate this part while maintaining the     flexibility.   * Micc_ adds typically files containing example code to show you how to add your    own functionality.    * You can automatically **extract documentation** from the doc-strings of your files,  and build html documentation that you can consult in your browser, or a .pdf   documentation file.* With a little extra effort the generated html **documentation is automatically published**   to `readthedocs &lt;https://readthedocs.org&gt;`_.* Micc_ helps you with **version management and control**.* Micc_ helps you with **testing** your code.* Micc_ helps you with **publishing** your code to e.g. `PyPI &lt;https://pypi.org&gt;`_, so  that you colleagues can use your code by simply running::    &gt; pip install your_nifty_packageCredits-------Micc_ does not do all of this by itself. For many things it relies on other strong open source tools and it is therefor open source as well (MIT Licence). Here is a list of tools micc_ is using or cooperating with happily:*   `Pyenv &lt;https://github.com/pyenv/pyenv&gt;`_: management of different Python versions.*   `Pipx &lt;https://github.com/pipxproject/pipx/&gt;`_ for installation of CLIs in a system-wide    way.*   `Poetry &lt;https://github.com/sdispater/poetry&gt;`_ for dependency management, virtual    environment management, packaging and publishing.*   `Git &lt;https://www.git-scm.com/&gt;`_ for version control.*   `CMake &lt;https://cmake.org&gt;`_ is usde for building binary extension modules written    in C++.The above tools are not dependencies of Micc_ and must be installed separately. Thenthere are a number of python packages on which micc_ depends and which are automaticallyinstalled when poetry_ creates a virtual environment for a project.*   `Cookiecutter &lt;https://github.com/audreyr/cookiecutter&gt;`_ for creating boilerplate    code from templates for all the parts that can be added to your project.*   `Python-semanticversion &lt;https://github.com/rbarrois/python-semanticversion/blob/master/docs/index.rst&gt;`_    for managing version strings and dependency version constraints according to the    `Semver 2.0 &lt;http://semver.org/&gt;`_ specification.*   `Pytest &lt;https://www.git-scm.com/&gt;`_ for testing your code.*   `Click &lt;https://click.palletsprojects.com/en/7.x/&gt;`_ for a pythonic and intuitive definition    of command-line interfaces (CLIs).*   `Sphinx &lt;http://www.sphinx-doc.org/&gt;`_ to extract documentation from your project's    doc-strings.*   `Sphinx-click &lt;https://sphinx-click.readthedocs.io/en/latest/&gt;`_ for extracting documentation    from the click_ command descriptions.*   `F2py &lt;https://docs.scipy.org/doc/numpy/f2py/&gt;`_ for transforming modern Fortran code into performant    binary extension modules interfacing nicely with `Numpy &lt;https://numpy.org/&gt;`_.*   `Pybind11 &lt;https://pybind11.readthedocs.io/en/stable/&gt;`_ as the    glue between C++ source code and performant binary extension modules, also interfacing nicely with Numpy_.Roadmap=======These features are still on our wish list:* Contininous integtration (CI)* Code style, e.g. `flake8 &lt;http://flake8.pycqa.org/en/latest/&gt;`_ or `black &lt;https://github.com/psf/black&gt;`_* Profiling* Gui for debugging C++/Fortran binary extensions* Micc projects on Windows (So far, only support on Linux and MacOS).</longdescription>
</pkgmetadata>