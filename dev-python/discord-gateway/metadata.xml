<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Discord gatewaySans-I/O Python implementation of the Discord gateway.Sans-I/O means that this implements no I/O (network) and operates purely on thebytes given using `wsproto`.It means that this implementation can be reused for libraries implemented in athreading fashion or asyncio/trio/curio.## Reference ImplementationFor a reference implementation see[wumpy-gateway](https://github.com/Bluenix2/wumpy/blob/main/library/wumpy-gateway/wumpy/gateway/shard.py).It is designed to handle all sort of network failures and race conditions.## QuickstartHere's a very minimal implementation using the `socket` library and `threading`for the heartbeating (it does not handle reconnecting or any form ofunexpected disconnections):```pythonimport socketimport sslimport threadingimport timefrom sys import platformimport certififrom discord_gateway import DiscordConnectionTOKEN = 'YOUR_VERY.WELL.HIDDEN_TOKEN'RECV_SIZE = 65536SERVER_NAME = 'gateway.discord.gg'def heartbeat(conn, sock):    while True:        sock.send(conn.heartbeat())        time.sleep(conn.heartbeat_interval)def recv_event(conn, sock):    while True:        for event in conn.events():            return event        for to_send in conn.receive(sock.recv(RECV_SIZE)):            sock.send(to_send)def main():    # Setup the socket and SSL for the WebSocket Secure connection.    conn = DiscordConnection(SERVER_NAME, encoding='json')    ctx = ssl.create_default_context(cafile=certifi.where())    sock = socket.create_connection(conn.destination)    sock = ctx.wrap_socket(sock, server_hostname=SERVER_NAME)    sock.send(conn.connect())  # Convert to a WebSocket    # Receive the very first HELLO event.    hello = recv_event(conn, sock)    # Send RESUME or IDENTIFY depending on state (will always be False    # when initially connecting, but may be different when reconnecting).    if conn.should_resume:        sock.send(conn.resume(TOKEN))    else:        sock.send(conn.identify(            token=TOKEN,            intents=65535,            properties={                '$os': platform,                '$browser': 'discord-gateway',                '$device': 'discord-gateway'            },        ))    heartbeater = threading.Thread(target=heartbeat, args=(conn,sock))    heartbeater.start()    try:        while True:            event = recv_event(conn, sock)            print('Received:', event)    finally:        sock.shutdown(socket.SHUT_WR)        sock.close()if __name__ == '__main__':    main()```## Comprehensive Guide### ConnectingThe very first thing required to use the Discord Gateway is to connect using aTCP socket with TLS enabled.Start by creating an instance of `DiscordConnection`, passing in the URI andencoding to use (most likely `'json'`), assign it to a variable called `conn`.Now, connect a TCP socket to `conn.destination` (this is a property thatreturns a tuple with the host and port to use - as often used when connecting)and wrap it with TLS. Using the built-in `socket` and `ssl` module with`certifi` that looks like this:```pythonSERVER_NAME = 'gateway.discord.gg'conn = DiscordConnection(SERVER_NAME, encoding='json')sock = socket.create_connection(conn.destination)ctx = ssl.create_default_context(cafile=certifi.where())sock = ctx.wrap_socket(sock, server_hostname=SERVER_NAME)```After the connection is established, generate a HTTP 101 Switching Protocolsrequest by calling `conn.connect()` and sending it over the socket.### Bootstrapping and HELLOsIt is now time to communicate over the WebSocket - or almost!You have yet to receive anything over the socket, not even the response to theHTTP request made. Create a while-loop that will iterate until a full eventhas been received, but it is important to wrap it in a try/except statementthat catches the `ConnectionRejected` in-case Discord rejects the WebSocketupgrade.In each iteration the data from the socket should be passed to`conn.receive()`, which then returns a list of bytes that should be sent backto the socket. The code should roughly look like this:```pythonhello = Nonewhile hello is None:    try:        for to_send in conn.receive(sock.recv(65535)):            sock.send(to_send)    except ConnectionRejected:        print('Discord rejected the connection!')        raise    for hello in conn.events():        # After this has been executed, the hello variable will no longer        # be set to None and the while-loop will exit.        break```When this loop has exited all internal state of discord-gateway should be readyto IDENTIFY or RESUME depending on `conn.should_resume` (which is alwaysfalsely during startup - but useful during reconnections).### HeartbeatingThe next part is maintaining the connection established, this is done bylaunching a concurrent thread/task (depending on how concurrency is handled).The only purpose of this concurrent heartbeater is to periodically generatea HEARTBEAT commands and sleep:```pythondef heartbeater(conn: DiscordConnection, sock: socket.socket) -&gt; typing.NoReturn:    # Discord recommends sleeping this random amount of time before the first    # heartbeat, this is to relieve Discord's servers when they are starting    # up again after downtimes.    time.sleep(random.random() * conn.heartbeat_interval)    while True:        sock.send(conn.heartbeat())        time.sleep(conn.heartbeat_interval)```After this, you are now fully connected and can receive events similar to howyou received the HELLO event.### Disconnecting#### Expected DisconnectionsWhen disconnecting you need to follow the WebSocket protocol, to start offgenerate a closing frame using `conn.close()` and send it over the socket.Afterwards, receive data until discord-gateway raises `CloseDiscordConnection`and send the `data` attribute over the socket. Lastly shutdown the write endof the socket using `sock.shutdown(socket.SHUT_WR)` and then fully close thesocket. In code that would look like this:```pythonsock.send(conn.close())try:    while True:        for data in conn.receive(socket.recv(65535)):            sock.send(data)except CloseDiscordConnection as err:    if err.data is not None:        sock.send(err.data)# Shutdown the socket now that the WebSocket is closedsock.shutdown(socket.SHUT_WR)received = Nonewhile received != b'':    received = sock.recv(65535)sock.close()```#### Unexpected DisconnectionsDiscord-gateway automatically schedules for reconnections in cases such asun-acknowledged heartbeats and RECONNECT events. That said, discord-gatewaystill needs your help to actually reconnect the underlying socket.Like with expected disconnections discord-gateway raises`CloseDiscordConnection` when the closing handshake is being made, just followwhat was done for expected disconnects and then reconnect but do not create anew `DiscordConnection` instance. Doing so looses information such as why thereconnection is happening in the first place. Instead call the `reconnect()`method to reset the internal state.`reconnect()` returns an integer representing the amount of seconds to waitbefore retrying, this will expotentially increase until a successful HELLOevent is received. To take advantage of this, you should structure a retry looplike this:```pythonwhile True:    time.sleep(conn.reconnect())    try:        # Connect to the socket as normal, see &quot;Bootstrapping and HELLOs&quot; above        ...    except EOFError:        # Note that in some implementations an empty bytes object is returned        # to signal this. It essentially means that the socket closed. Don't        # forget to clean up the socket in all of these except-clauses.        ...        continue    except ConnectionRejected as err:        ...        continue    else:        # If the bootstrapping succeeded and we received a HELLO event, then        # we can finally exit this loop.        break```Use the `should_reconnect()` function to determine whether to reconnect, if itreturns `False` that signals that the connection **must not** be reconnected.It is recommended to raise an error or similar in this case.### Race conditionsBecause of the concurrent heartbeater there are potential race conditions,primarily when reconnecting.The easiest way to fix this is to use a lock that is held when reconnecting,the heartbeater has to acquire it everytime it tries to send a heartbeat.Another potential issue is sending a heartbeat while the closing handshake isin progress - that is, the client has sent one closing frame but not yetreceived it from the other end. Discord-gateway provides a simple propertycalled `closed`, if this is set just skip sending anything and sleep again.Following the theme of `socket`s and threads here is an example of an improvedheartbeater:```pythonlock = ...def heartbeater(conn, sock):    # Discord recommends sleeping this random amount of time before the first    # heartbeat, this is to relieve Discord's servers when they are starting    # up again after downtimes.    time.sleep(random.random() * conn.heartbeat_interval)    while True:        with lock:            if not conn.closing:                sock.send(conn.heartbeat())        time.sleep(conn.heartbeat_interval)```</longdescription>
</pkgmetadata>