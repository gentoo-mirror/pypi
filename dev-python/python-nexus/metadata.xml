<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># python-nexusA Generic phylogenetic nexus format (.nex, .trees) reader and writer for python.[![Build Status](https://github.com/dlce-eva/python-nexus/workflows/tests/badge.svg)](https://github.com/dlce-eva/python-nexus/actions?query=workflow%3Atests)[![codecov](https://codecov.io/gh/dlce-eva/python-nexus/branch/master/graph/badge.svg)](https://codecov.io/gh/dlce-eva/python-nexus)[![PyPI](https://img.shields.io/pypi/v/python-nexus.svg)](https://pypi.org/project/python-nexus)[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.595426.svg)](https://doi.org/10.5281/zenodo.595426)## Descriptionpython-nexus provides simple nexus file-format reading/writing tools, and a smallcollection of nexus manipulation scripts. Please note that this library works with the phylogenetics data format (e.g. https://en.wikipedia.org/wiki/Nexus_file)and not the phyics data format (e.g. https://manual.nexusformat.org/).Note: Due to a name clash with another python package, this package must be **installed** as`pip install python-nexus` but **imported** as `import nexus`.## Usage### CLI`python-nexus` installs a command `nexus` for cli use. You can inspect its help via```shellnexus -h```### Python APIReading a Nexus:```python&gt;&gt;&gt; from nexus import NexusReader&gt;&gt;&gt; n = NexusReader.from_file('tests/examples/example.nex')```    You can also load from a string:```python&gt;&gt;&gt; n = NexusReader.from_string('#NEXUS\n\nbegin foo; ... end;')```NexusReader will load each of the nexus `blocks` it identifies using specific `handlers`. ```python&gt;&gt;&gt; n.blocks{'foo': &lt;nexus.handlers.GenericHandler object at 0x7f55d94140f0&gt;}&gt;&gt;&gt; n = NexusReader('tests/examples/example.nex')&gt;&gt;&gt; n.blocks{'data': &lt;NexusDataBlock: 2 characters from 4 taxa&gt;}```A dictionary mapping blocks to handlers is available as `nexus.reader.HANDLERS:```python&gt;&gt;&gt; from nexus.reader import HANDLERS&gt;&gt;&gt; HANDLERS{    'trees': &lt;class 'nexus.handlers.tree.TreeHandler'&gt;,     'taxa': &lt;class 'nexus.handlers.taxa.TaxaHandler'&gt;,     'characters': &lt;class 'nexus.handlers.data.CharacterHandler'&gt;,     'data': &lt;class 'nexus.handlers.data.DataHandler'&gt;}```Any blocks that aren't in this dictionary will be parsed using `nexus.handlers.GenericHandler`.`NexusReader` can then write the nexus to a string using `NexusReader.write` or to another file using `NexusReader.write_to_file`:```python&gt;&gt;&gt; output = n.write()&gt;&gt;&gt; n.write_to_file(&quot;mynewnexus.nex&quot;)```Note: if you want more fine-grained control over generating nexus files, then try`NexusWriter` discussed below.### Block Handlers:There are specific &quot;Handlers&quot; to parse certain known nexus blocks, including thecommon 'data', 'trees', and 'taxa' blocks. Any blocks that are unknown will be parsed with GenericHandler.ALL handlers extend the `GenericHandler` class and have the following methods.* `__init__(self, name=None, data=None)`    `__init__` is called by `NexusReader` to parse the contents of the block (in `data`)    appropriately.* `write(self)`    write is called by `NexusReader` to write the contents of a block to a string     (i.e. for regenerating the nexus format for saving a file to disk)#### `generic` block handlerThe generic block handler simply stores each line of the block in `.block`:    n.blockname.block    ['line1', 'line2', ... ]#### `data` block handlerThese are the main blocks encountered in nexus files - and contain the data matrix.So, given the following nexus file with a data block:    #NEXUS     Begin data;    Dimensions ntax=4 nchar=2;    Format datatype=standard symbols=&quot;01&quot; gap=-;        Matrix    Harry              00    Simon              01    Betty              10    Louise             11        ;    End;    begin trees;        tree A = ((Harry:0.1,Simon:0.2),Betty:0.2)Louise:0.1;;        tree B = ((Simon:0.1,Harry:0.2),Betty:0.2)Louise:0.1;;    end;You can do the following:Find out how many characters:```python&gt;&gt;&gt; n.data.nchar2```Ask about how many taxa:```python&gt;&gt;&gt; n.data.ntaxa4```Get the taxa names:```python &gt;&gt;&gt; n.data.taxa['Harry', 'Simon', 'Betty', 'Louise']```Get the `format` info:```python &gt;&gt;&gt; n.data.format{'datatype': 'standard', 'symbols': '01', 'gap': '-'}```The actual data matrix is a dictionary, which you can get to in `.matrix`:```python&gt;&gt;&gt; n.data.matrixdefaultdict(&lt;class 'list'&gt;, {'Harry': ['0', '0'], 'Simon': ['0', '1'], 'Betty': ['1', '0'], 'Louise': ['1', '1']})```Or, you could access the data matrix via taxon:```python&gt;&gt;&gt; n.data.matrix['Simon']['0', '1']```    Or even loop over it like this:```python&gt;&gt;&gt; for taxon, characters in n.data:...     print(taxon, characters)...     Harry ['0', '0']Simon ['0', '1']Betty ['1', '0']Louise ['1', '1']```You can also iterate over the sites (rather than the taxa):```python&gt;&gt;&gt; for site, data in n.data.characters.items():...     print(site, data)...     0 {'Harry': '0', 'Simon': '0', 'Betty': '1', 'Louise': '1'}1 {'Harry': '0', 'Simon': '1', 'Betty': '0', 'Louise': '1'}```..or you can access the characters matrix directly:```python&gt;&gt;&gt; n.data.characters[0]{'Harry': '0', 'Simon': '0', 'Betty': '1', 'Louise': '1'}```Note: that sites are zero-indexed!#### `trees` block handlerIf there's a `trees` block, then you can do the followingYou can get the number of trees:```python&gt;&gt;&gt; n.trees.ntrees2```You can access the trees via the `.trees` dictionary:```python&gt;&gt;&gt; n.trees.trees[0]'tree A = ((Harry:0.1,Simon:0.2):0.1,Betty:0.2):Louise:0.1);'```Or loop over them:```python&gt;&gt;&gt; for tree in n.trees:...     print(tree)... tree A = ((Harry:0.1,Simon:0.2):0.1,Betty:0.2):Louise:0.1);tree B = ((Simon:0.1,Harry:0.2):0.1,Betty:0.2):Louise:0.1);```For further inspection of trees via  the [newick package](https://pypi.org/project/newick/), you can retrieve a `nexus.Node` object for a tree:```python&gt;&gt;&gt; print(n.trees.trees[0].newick_tree.ascii_art())                  ┌─Harry         ┌────────┤──Louise─┤        └─Simon         └─Betty```#### `taxa` block handlerPrograms like SplitsTree understand &quot;TAXA&quot; blocks in Nexus files:    BEGIN Taxa;    DIMENSIONS ntax=4;    TAXLABELS    [1] 'John'    [2] 'Paul'    [3] 'George'    [4] 'Ringo'    ;    END; [Taxa]In a taxa block you can get the number of taxa and the taxa list:```python&gt;&gt;&gt; n.taxa.ntaxa4&gt;&gt;&gt; n.taxa.taxa['John', 'Paul', 'George', 'Ringo']```NOTE: with this alternate nexus format the Characters blocks *should* be parsed byDataHandler.### Writing a Nexus File using NexusWriter`NexusWriter` provides more fine-grained control over writing nexus files, and is useful if you're programmatically generating a nexus file rather than loadinga pre-existing one.```python&gt;&gt;&gt; from nexus import NexusWriter&gt;&gt;&gt; n = NexusWriter()&gt;&gt;&gt; #Add a comment to appear in the header of the file&gt;&gt;&gt; n.add_comment(&quot;I am a comment&quot;)```Data are added by using the &quot;add&quot; function - which takes 3 arguments, a taxon, a character name, and a value.```python&gt;&gt;&gt; n.add('taxon1', 'Character1', 'A')&gt;&gt;&gt; n.data{'Character1': {'taxon1': 'A'}}&gt;&gt;&gt; n.add('taxon2', 'Character1', 'C')&gt;&gt;&gt; n.add('taxon3', 'Character1', 'A')```Characters and values can be strings or integers (but you **cannot** mix string andinteger characters).```python&gt;&gt;&gt; n.add('taxon1', 2, 1)&gt;&gt;&gt; n.add('taxon2', 2, 2)&gt;&gt;&gt; n.add('taxon3', 2, 3)```NexusWriter will interpolate missing entries (i.e. taxon2 in this case)```python&gt;&gt;&gt; n.add('taxon1', &quot;Char3&quot;, '4')&gt;&gt;&gt; n.add('taxon3', &quot;Char3&quot;, '4')```... when you're ready, you can generate the nexus using `make_nexus` or `write_to_file`:```python    &gt;&gt;&gt; data = n.make_nexus(interleave=True, charblock=True, preserve_order=False)&gt;&gt;&gt; n.write_to_file(&quot;output.nex&quot;, interleave=True, charblock=True, preserve_order=False)```... you can make an interleaved nexus by setting `interleave` to True, and you caninclude a character block in the nexus (if you have character labels for example) by setting charblock to True. Furthermore you can specify whether the order of addedtaxa and characters should be preserved by setting `preserve_order` to True, otherwise they willbe sorted alphanumerically.There is rudimentary support for handling trees e.g.:```python&gt;&gt;&gt; n.trees.append(&quot;tree tree1 = (a,b,c);&quot;)&gt;&gt;&gt; n.trees.append(&quot;tree tree2 = (a,b,c);&quot;)```</longdescription>
</pkgmetadata>