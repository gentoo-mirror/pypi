<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>pyconfig - Python-based singleton configuration===============================================This module provides python based configuration that is stored in a singletonobject to ensure consistency across your project... contents::   :depth: 2   :local:Command Line------------Pyconfig has a command line utility that lets you inspect your project to findall the configuration keys defined.::   $ pyconfig -h   usage: pyconfig [-h] [-f F | -m M] [-v] [-l] [-a | -k] [-n] [-s] [-c]   Helper for working with pyconfigs   optional arguments:     -h, --help          show this help message and exit     -f F, --filename F  parse an individual file or directory     -m M, --module M    parse a package or module, recursively looking inside it     -v, --view-call     show the actual pyconfig call made (default: show namespace)     -l, --load-configs  query the currently set value for each key found     -a, --all           show keys which don't have defaults set     -k, --only-keys     show a list of discovered keys without values     -n, --natural-sort  sort by filename and line (default: alphabetical by key)     -s, --source        show source annotations (implies --natural-sort)     -c, --color         toggle output colors (default: True)**Example output**.. code-block:: bash   $ pyconfig --file .   humbledb.allow_explicit_request = True   humbledb.auto_start_request = True   humbledb.connection_pool = 300   humbledb.tz_aware = True   humbledb.use_greenlets = False   humbledb.write_concern = 1   $ pyconfig --view-call --file .   pyconfig.get('humbledb.allow_explicit_request', True)   pyconfig.setting('humbledb.auto_start_request', True)   pyconfig.setting('humbledb.connection_pool', 300)   pyconfig.setting('humbledb.tz_aware', True)   pyconfig.setting('humbledb.use_greenlets', False)   pyconfig.setting('humbledb.write_concern', 1)   $ pyconfig --source --file .   # ./humbledb/mongo.py, line 98   humbledb.allow_explicit_request = True   # ./humbledb/mongo.py, line 178   humbledb.connection_pool = 300   # ./humbledb/mongo.py, line 181   humbledb.auto_start_request = True   # ./humbledb/mongo.py, line 185   humbledb.use_greenlets = False   # ./humbledb/mongo.py, line 188   humbledb.tz_aware = True   # ./humbledb/mongo.py, line 191   humbledb.write_concern = 1Etcd----*Version added: 3.0.0*Pyconfig has read-only support for configurations stored in etcd. The preferredmethod for configuring Pyconfig to work with etcd is via ENV variables, sincethey must be set as early as possible. It is also possible to use the PythonAPI to make Pyconfig work with etcd.Pyconfig uses a directory namespace to store its dot notation configuration keynames. By default, that namespace is ``/config/``.At a minimum, ``PYCONFIG_ETCD_HOSTS`` must be set to get Pyconfig to try toread a configuration from etcd using the default settings.You can set a value with `etcdctl` like:.. code-block:: bash   $ # The etcdctl command is provided by etcd and not part of pyconfig   $ etcdctl set /pyconfig/example/my.setting &quot;from etcd&quot;And configure Pyconfig to connect and use that setting:.. code-block:: bash   $ export PYCONFIG_ETCD_PREFIX=&quot;/pyconfig/example/&quot;   $ export PYCONFIG_ETCD_HOSTS=&quot;127.0.0.1:2379&quot;   $ python   &gt;&gt;&gt; import pyconfig   &gt;&gt;&gt; pyconfig.get('my.setting')   'from etcd'Because of Pyconfig's singleton nature, only one configuration can be accessedat a time in this way.**Environment variables:*** ``PYCONFIG_ETCD_PREFIX`` - The namespace to prefix settings with (default:  ``'/config/'``)* ``PYCONFIG_ETCD_HOSTS`` - A comma separated list of hosts, like  ``10.0.0.1:2379,10.0.0.2:2379``* ``PYCONFIG_ETCD_CACERT`` - CA cert file to use for SSL* ``PYCONFIG_ETCD_CERT`` - Client cert file to use for SSL client authentication* ``PYCONFIG_ETCD_KEY`` - Client private key file to use for SSL client auth* ``PYCONFIG_ETCD_WATCH`` - If this is set to a truthy value (a non-empty  string), then pyconfig will keep the local configuration synchronized with  etcd (*Version added: 3.1.0*)* ``PYCONFIG_ETCD_PROTOCOL`` - Set this to force HTTPS connections even if not  using certificates. This should be a string of the form `https` or `http`.  (*Version added: 3.2.0*)* ``PYCONFIG_ETCD_AUTH`` - Set this use Basic Authentication with requests.  This should be a string of the format `username:password`. (*Version added:  3.2.0*)**Inheritance:**If you want to create a configuration that inherits from an existingconfiguration, Pyconfig will look for a special key, which by default is set to``config.inherit``. If this exists and is set to an etcd namespace, thatconfiguration will be used as the base for the current config.A typical use case would be a Test environment configuration which is derivedfrom a Development config. Below is a barebones example of how that might beset up using `etcdctl` and Pyconfig... code-block:: bash   $ # Create the development settings   $ etcdctl set /config/app/dev/my.name example   $ etcdctl set /config/app/dev/my.hostname localhost   $ etcdctl set /config/app/dev/my.api.key abcdef0123456789   $ # Create the test settings   $ etcdctl set /config/app/test/my.hostname test.example.com   $ # Tell it to inherit from the development settings   $ etcdctl set /config/app/test/config.inherit /config/app/dev/   $ # Configure Pyconfig to use the test configuration   $ export PYCONFIG_ETCD_PREFIX=&quot;/config/app/test/&quot;   $ export PYCONFIG_ETCD_HOSTS=&quot;127.0.0.1:2379&quot;   $ python   &gt;&gt;&gt; import pyconfig   &gt;&gt;&gt; pyconfig.get('my.hostname')   'test.example.com'   &gt;&gt;&gt; pyconfig.get('my.name')   'example'Code Examples-------------The most basic usage allows you to get, retrieve and modify values. Pyconfig'ssingleton provides convenient accessor methods for these actions:*Version changed: 3.0.0*As of version 3.0.0, keys are not case sensitive by default... code-block:: python    &gt;&gt;&gt; import pyconfig    &gt;&gt;&gt; pyconfig.get('my.setting', 'default')    'default'    &gt;&gt;&gt; pyconfig.set('my.setting', 'new')    &gt;&gt;&gt; pyconfig.get('my.setting', 'default')    'new'    &gt;&gt;&gt; pyconfig.reload(clear=True)    &gt;&gt;&gt; pyconfig.get('my.setting', 'default')    'default'You can also opt-out of default values:.. code-block:: python    &gt;&gt;&gt; import pyconfig    &gt;&gt;&gt; pyconfig.get('my.setting', allow_default=False)    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;      File &quot;pyconfig/__init__.py&quot;, line 275, in get        return Config().get(name, default, allow_default=allow_default)      File &quot;pyconfig/__init__.py&quot;, line 234, in get        return self.settings[name]     LookupError: No setting &quot;my.setting&quot;Pyconfig also provides shortcuts for giving classes property descriptors whichmap to the current setting stored in the singleton:.. code-block:: python    &gt;&gt;&gt; import pyconfig    &gt;&gt;&gt; class MyClass(object):    ...     my_setting = pyconfig.setting('my.setting', 'default')    ...    &gt;&gt;&gt; MyClass.my_setting    'default'    &gt;&gt;&gt; MyClass().my_setting    'default'    &gt;&gt;&gt; pyconfig.set('my.setting', &quot;Hello World!&quot;)    &gt;&gt;&gt; MyClass.my_setting    'Hello World!'    &gt;&gt;&gt; MyClass().my_setting    'Hello World!'    &gt;&gt;&gt; pyconfig.reload(clear=True)    &gt;&gt;&gt; MyClass.my_setting    'default'The `Setting` class also supports preventing default values.  When set this way,all reads on the attribute will prevent the use of defaults:.. code-block:: python    &gt;&gt;&gt; import pyconfig    &gt;&gt;&gt; class MyClass(object):    ...     my_setting = pyconfig.setting('my.setting', allow_default=False)    ...    &gt;&gt;&gt; MyClass.my_setting    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;      File &quot;pyconfig/__init__.py&quot;, line 84, in __get__        allow_default=self.allow_default)      File &quot;pyconfig/__init__.py&quot;, line 232, in get        raise LookupError('No setting &quot;{}&quot;'.format(name))    LookupError: No setting &quot;my.setting&quot;    &gt;&gt;&gt; pyconfig.set('my.setting', 'new_value')    &gt;&gt;&gt; MyClass.my_setting    'value'Pyconfig allows you to override settings via a python configuration file, thatdefines its configuration keys as a module namespace. By default, Pyconfig willlook on your ``PYTHONPATH`` for a module named ``localconfig``, and if it exists, itwill use this module namespace to update all configuration settings:.. code-block:: python    # __file__ = &quot;$PYTHONPATH/localconfig.py&quot;    from pyconfig import Namespace    # Namespace objects allow you to use attribute assignment to create setting    # key names    my = Namespace()    my.setting = 'from_localconfig'    # Namespace objects implicitly return new nested Namespaces when accessing    # attributes that don't exist    my.nested.setting = 'also_from_localconfig'With a ``localconfig`` on the ``PYTHONPATH``, it will be loaded before any settingsare read:.. code-block:: python    &gt;&gt;&gt; import pyconfig    &gt;&gt;&gt; pyconfig.get('my.setting')    'from_localconfig'    &gt;&gt;&gt; pyconfig.get('my.nested.setting')    'also_from_localconfig'Pyconfig also allows you to create distutils plugins that are automaticallyloaded. An example ``setup.py``:.. code-block:: python    # __file__ = setup.py    from setuptools import setup    setup(            name='pytest',            version='0.1.0-dev',            py_modules=['myconfig', 'anyconfig'],            entry_points={                # The &quot;my&quot; in &quot;my =&quot; indicates a base namespace to use for                # the contained configuration. If you do not wish a base                # namespace, use &quot;any&quot;                'pyconfig':[                      'my = myconfig',                      'any = anyconfig',                      ],                },            )An example distutils plugin configuration file:.. code-block:: python    # __file__ = myconfig.py    from pyconfig import Namespace    def some_callable():        print &quot;This callable was called.&quot;        print &quot;You can execute any arbitrary code.&quot;    setting = 'from_plugin'    nested = Namespace()    nested.setting = 'also_from_plugin'Another example configuration file, without a base namespace:.. code-block:: python    # __file__ = anyconfig.py    from pyconfig import Namespace    other = Namespace()    other.setting = 'anyconfig_value'Showing the plugin-specified settings:.. code-block:: python    &gt;&gt;&gt; import pyconfig    &gt;&gt;&gt; pyconfig.get('my.setting', 'default')    This callable was called.    You can execute any arbitrary code.    'from_plugin'    &gt;&gt;&gt; pyconfig.get('my.nested.setting', 'default')    'also_from_plugin'    &gt;&gt;&gt; pyconfig.get('other.setting', 'default')    'anyconfig_value'More fancy stuff:.. code-block:: python    &gt;&gt;&gt; # Reloading changes re-calls functions...    &gt;&gt;&gt; pyconfig.reload()    This callable was called.    You can execute any arbitrary code.    &gt;&gt;&gt; # This can be used to inject arbitrary code by changing a    &gt;&gt;&gt; # localconfig.py or plugin and reloading a config... especially    &gt;&gt;&gt; # when pyconfig.reload() is attached to a signal    &gt;&gt;&gt; import signal    &gt;&gt;&gt; signal.signal(signal.SIGUSR1, pyconfig.reload)Pyconfig provides a ``@reload_hook`` decorator that allows you to registerfunctions or methods to be called when the configuration is reloaded:.. code-block:: python      &gt;&gt;&gt; import pyconfig      &gt;&gt;&gt; @pyconfig.reload_hook      ... def reload():      ...     print &quot;Do something here.&quot;      ...      &gt;&gt;&gt; pyconfig.reload()      Do something here.**Warning**: It should not be used to register large numbers of functions (e.g.registering a bound method in a class's ``__init__`` method), since there is noway to un-register a hook and it will cause a memory leak, since a bound methodmaintains a strong reference to the bound instance.**Note**: Because the reload hooks are called without arguments, it will notwork with unbound methods or classmethods.Changes-------This section contains descriptions of changes in each new version.3.2.0^^^^^* Adds `PYCONFIG_ETCD_PROTOCOL` and `PYCONFIG_ETCD_AUTH`.  *Released August 17, 2017.*3.1.1^^^^^* Documentation fixes that makes rendering work on PyPI and GitHub again.  *Released June 16, 2016.*3.1.0^^^^^* Adds the ability to watch etcd for changes to values. This can be enabled by  setting the environment variable ``PYCONFIG_ETCD_WATCH=true``.  *Released June 3, 2016.*3.0.2^^^^^* Fixes an issue when using Python 3 compatibility in Python 2.7 and PyOpenSSL.  *Released September 28, 2015.*3.0.1^^^^^* Changes the default inherit depth to 2, which is more useful than 1.3.0.0^^^^^* Adds support for loading configurations from etcd, with inheritance.* Use ``pytool.lang.Namespace`` instead of alternate implementation.* Drops support for Python 2.6 and 3.2.* Pyconfig setting keys are now case insensitive by default (Use  ``pyconfig.set('pyconfig.case_sensitive', True)`` to change the behavior)* Adds new ``clear()`` method for wiping out the cached configuration.Older Versions^^^^^^^^^^^^^^2.2.1&quot;&quot;&quot;&quot;&quot;* The command line tool will now attempt to handle source files which specify a  non-ascii encoding gracefully.2.2.0&quot;&quot;&quot;&quot;&quot;* Add ``allow_default`` keyword option to ``get()`` and ``setting()``. Thanks  to `yarbelk &lt;https://github.com/yarbelk&gt;`_!2.1.5&quot;&quot;&quot;&quot;&quot;* Fix regression where ``localconfig.py`` wasn't being loaded on Python 2.7 due  to a logic flow error. Whoops!2.1.4&quot;&quot;&quot;&quot;&quot;* Broke Python 2.6 in 2.1.1, fixed again.2.1.2-2.1.3&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;* Package clean up and fixing README to work on PyPI again.2.1.1&quot;&quot;&quot;&quot;&quot;* Fix bug that would break on Python 2.6 and 2.7 when using a localconfig.py.2.1.0&quot;&quot;&quot;&quot;&quot;* Pyconfig now works on Python 3, thanks to  `hfalcic &lt;https://github.com/hfalcic&gt;`_!2.0.0&quot;&quot;&quot;&quot;&quot;* Pyconfig now has the ability to show you what config keys are defined in a  directory.1.2.0&quot;&quot;&quot;&quot;&quot;* No longer uses Python 2.7 ``format()``. Should work on 2.6 and maybe earlier.1.1.2&quot;&quot;&quot;&quot;&quot;* Move version string into ``pyconfig.__version__``1.1.1&quot;&quot;&quot;&quot;&quot;* Fix bug with setup.py that prevented installation1.1.0&quot;&quot;&quot;&quot;&quot;* Allow for implicitly nesting Namespaces when accessing attributes that are  undefinedContributors------------* `shakefu &lt;http://github.com/shakefu&gt;`_ - Creator and maintainer* `hfalcic &lt;https://github.com/hfalcic&gt;`_ - Python 3 compatability* `yarbelk &lt;https://github.com/yarbelk&gt;`_ - ``allow_default`` option</longdescription>
</pkgmetadata>