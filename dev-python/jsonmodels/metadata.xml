<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>===========JSON models===========.. image:: https://jazzband.co/static/img/badge.svg   :target: https://jazzband.co/   :alt: Jazzband.. image:: https://badge.fury.io/py/jsonmodels.svg   :target: http://badge.fury.io/py/jsonmodels.. image:: https://github.com/jazzband/jsonmodels/workflows/Test/badge.svg   :target: https://github.com/jazzband/jsonmodels/actions   :alt: Tests.. image:: https://img.shields.io/pypi/dm/jsonmodels.svg   :target: https://pypi.python.org/pypi/jsonmodels   :alt: PyPI.. image:: https://codecov.io/gh/jazzband/jsonmodels/branch/master/graph/badge.svg   :target: https://codecov.io/gh/jazzband/jsonmodels   :alt: Coverage`jsonmodels` is library to make it easier for you to deal with structures thatare converted to, or read from JSON.* Free software: BSD license* Documentation: http://jsonmodels.rtfd.org* Source: https://github.com/jazzband/jsonmodelsFeatures--------* Fully tested with Python 3.7+.* Support for PyPy 3.8 (see implementation notes in docs for more details).* Create Django-like models:  .. code-block:: python    from jsonmodels import models, fields, errors, validators    class Cat(models.Base):        name = fields.StringField(required=True)        breed = fields.StringField()        love_humans = fields.IntField(nullable=True)    class Dog(models.Base):        name = fields.StringField(required=True)        age = fields.IntField()    class Car(models.Base):        registration_number = fields.StringField(required=True)        engine_capacity = fields.FloatField()        color = fields.StringField()    class Person(models.Base):        name = fields.StringField(required=True)        surname = fields.StringField(required=True)        nickname = fields.StringField(nullable=True)        car = fields.EmbeddedField(Car)        pets = fields.ListField([Cat, Dog], nullable=True)* Access to values through attributes:  .. code-block:: python    &gt;&gt;&gt; cat = Cat()    &gt;&gt;&gt; cat.populate(name='Garfield')    &gt;&gt;&gt; cat.name    'Garfield'    &gt;&gt;&gt; cat.breed = 'mongrel'    &gt;&gt;&gt; cat.breed    'mongrel'* Validate models:  .. code-block:: python    &gt;&gt;&gt; person = Person(name='Chuck', surname='Norris')    &gt;&gt;&gt; person.validate()    None    &gt;&gt;&gt; dog = Dog()    &gt;&gt;&gt; dog.validate()    *** ValidationError: Field &quot;name&quot; is required!* Cast models to python struct and JSON:  .. code-block:: python    &gt;&gt;&gt; cat = Cat(name='Garfield')    &gt;&gt;&gt; dog = Dog(name='Dogmeat', age=9)    &gt;&gt;&gt; car = Car(registration_number='ASDF 777', color='red')    &gt;&gt;&gt; person = Person(name='Johny', surname='Bravo', pets=[cat, dog])    &gt;&gt;&gt; person.car = car    &gt;&gt;&gt; person.to_struct()    {        'car': {            'color': 'red',            'registration_number': 'ASDF 777'        },        'surname': 'Bravo',        'name': 'Johny',        'nickname': None,        'pets': [            {'name': 'Garfield'},            {'age': 9, 'name': 'Dogmeat'}        ]    }    &gt;&gt;&gt; import json    &gt;&gt;&gt; person_json = json.dumps(person.to_struct())* You don't like to write JSON Schema? Let `jsonmodels` do it for you:  .. code-block:: python    &gt;&gt;&gt; person = Person()    &gt;&gt;&gt; person.to_json_schema()    {        'additionalProperties': False,        'required': ['surname', 'name'],        'type': 'object',        'properties': {            'car': {                'additionalProperties': False,                'required': ['registration_number'],                'type': 'object',                'properties': {                    'color': {'type': 'string'},                    'engine_capacity': {'type': ''},                    'registration_number': {'type': 'string'}                }            },            'surname': {'type': 'string'},            'name': {'type': 'string'},            'nickname': {'type': ['string', 'null']}            'pets': {                'items': {                    'oneOf': [                        {                            'additionalProperties': False,                            'required': ['name'],                            'type': 'object',                            'properties': {                                'breed': {'type': 'string'},                                'name': {'type': 'string'}                            }                        },                        {                            'additionalProperties': False,                            'required': ['name'],                            'type': 'object',                            'properties': {                                'age': {'type': 'number'},                                'name': {'type': 'string'}                            }                        },                        {                            'type': 'null'                        }                    ]                },                'type': 'array'            }        }    }* Validate models and use validators, that affect generated schema:  .. code-block:: python    &gt;&gt;&gt; class Person(models.Base):    ...    ...     name = fields.StringField(    ...         required=True,    ...         validators=[    ...             validators.Regex('^[A-Za-z]+$'),    ...             validators.Length(3, 25),    ...         ],    ...     )    ...     age = fields.IntField(    ...         nullable=True,    ...         validators=[    ...             validators.Min(18),    ...             validators.Max(101),    ...         ]    ...     )    ...     nickname = fields.StringField(    ...         required=True,    ...         nullable=True    ...     )    ...    &gt;&gt;&gt; person = Person()    &gt;&gt;&gt; person.age = 11    &gt;&gt;&gt; person.validate()    *** ValidationError: '11' is lower than minimum ('18').    &gt;&gt;&gt; person.age = None    &gt;&gt;&gt; person.validate()    None    &gt;&gt;&gt; person.age = 19    &gt;&gt;&gt; person.name = 'Scott_'    &gt;&gt;&gt; person.validate()    *** ValidationError: Value &quot;Scott_&quot; did not match pattern &quot;^[A-Za-z]+$&quot;.    &gt;&gt;&gt; person.name = 'Scott'    &gt;&gt;&gt; person.validate()    None    &gt;&gt;&gt; person.nickname = None    &gt;&gt;&gt; person.validate()    *** ValidationError: Field is required!    &gt;&gt;&gt; person.to_json_schema()    {        &quot;additionalProperties&quot;: false,        &quot;properties&quot;: {            &quot;age&quot;: {                &quot;maximum&quot;: 101,                &quot;minimum&quot;: 18,                &quot;type&quot;: [&quot;number&quot;, &quot;null&quot;]            },            &quot;name&quot;: {                &quot;maxLength&quot;: 25,                &quot;minLength&quot;: 3,                &quot;pattern&quot;: &quot;/^[A-Za-z]+$/&quot;,                &quot;type&quot;: &quot;string&quot;            },            &quot;nickname&quot;: {,                &quot;type&quot;: [&quot;string&quot;, &quot;null&quot;]            }        },        &quot;required&quot;: [            &quot;nickname&quot;,            &quot;name&quot;        ],        &quot;type&quot;: &quot;object&quot;    }  You can also validate scalars, when needed:  .. code-block:: python    &gt;&gt;&gt; class Person(models.Base):    ...    ...     name = fields.StringField(    ...         required=True,    ...         validators=[    ...             validators.Regex('^[A-Za-z]+$'),    ...             validators.Length(3, 25),    ...         ],    ...     )    ...     age = fields.IntField(    ...         nullable=True,    ...         validators=[    ...             validators.Min(18),    ...             validators.Max(101),    ...         ]    ...     )    ...     nickname = fields.StringField(    ...         required=True,    ...         nullable=True    ...     )    ...    &gt;&gt;&gt; def only_odd_numbers(item):    ... if item % 2 != 1:    ...    raise validators.ValidationError(&quot;Only odd numbers are accepted&quot;)    ...    &gt;&gt;&gt; class Person(models.Base):    ... lucky_numbers = fields.ListField(int, item_validators=[only_odd_numbers])    ... item_validator_str = fields.ListField(    ...        str,    ...        item_validators=[validators.Length(10, 20), validators.Regex(r&quot;\w+&quot;)],    ...        validators=[validators.Length(1, 2)],    ...    )    ...    &gt;&gt;&gt; Person.to_json_schema()    {        &quot;type&quot;: &quot;object&quot;,        &quot;additionalProperties&quot;: false,        &quot;properties&quot;: {            &quot;item_validator_str&quot;: {                &quot;type&quot;: &quot;array&quot;,                &quot;items&quot;: {                    &quot;type&quot;: &quot;string&quot;,                    &quot;minLength&quot;: 10,                    &quot;maxLength&quot;: 20,                    &quot;pattern&quot;: &quot;/\\w+/&quot;                },                &quot;minItems&quot;: 1,                &quot;maxItems&quot;: 2            },            &quot;lucky_numbers&quot;: {                &quot;type&quot;: &quot;array&quot;,                &quot;items&quot;: {                    &quot;type&quot;: &quot;number&quot;                }            }        }    }(Note that `only_odd_numbers` did not modify schema, since only class based validators areable to do that, though it will still work as expected in python. Use class based validatorsthat can be expressed in json schema if you want to be 100% correct on schema side.)* Lazy loading, best for circular references:  .. code-block:: python    &gt;&gt;&gt; class Primary(models.Base):    ...    ...     name = fields.StringField()    ...     secondary = fields.EmbeddedField('Secondary')    &gt;&gt;&gt; class Secondary(models.Base):    ...    ...    data = fields.IntField()    ...    first = fields.EmbeddedField('Primary')  You can use either `Model`, full path `path.to.Model` or relative imports  `.Model` or `...Model`.* Using definitions to generate schema for circular references:  .. code-block:: python    &gt;&gt;&gt; class File(models.Base):    ...    ...     name = fields.StringField()    ...     size = fields.FloatField()    &gt;&gt;&gt; class Directory(models.Base):    ...    ...     name = fields.StringField()    ...     children = fields.ListField(['Directory', File])    &gt;&gt;&gt; class Filesystem(models.Base):    ...    ...     name = fields.StringField()    ...     children = fields.ListField([Directory, File])    &gt;&gt;&gt; Filesystem.to_json_schema()    {        &quot;type&quot;: &quot;object&quot;,        &quot;properties&quot;: {            &quot;name&quot;: {&quot;type&quot;: &quot;string&quot;}            &quot;children&quot;: {                &quot;items&quot;: {                    &quot;oneOf&quot;: [                        &quot;#/definitions/directory&quot;,                        &quot;#/definitions/file&quot;                    ]                },                &quot;type&quot;: &quot;array&quot;            }        },        &quot;additionalProperties&quot;: false,        &quot;definitions&quot;: {            &quot;directory&quot;: {                &quot;additionalProperties&quot;: false,                &quot;properties&quot;: {                    &quot;children&quot;: {                        &quot;items&quot;: {                            &quot;oneOf&quot;: [                                &quot;#/definitions/directory&quot;,                                &quot;#/definitions/file&quot;                            ]                        },                        &quot;type&quot;: &quot;array&quot;                    },                    &quot;name&quot;: {&quot;type&quot;: &quot;string&quot;}                },                &quot;type&quot;: &quot;object&quot;            },            &quot;file&quot;: {                &quot;additionalProperties&quot;: false,                &quot;properties&quot;: {                    &quot;name&quot;: {&quot;type&quot;: &quot;string&quot;},                    &quot;size&quot;: {&quot;type&quot;: &quot;number&quot;}                },                &quot;type&quot;: &quot;object&quot;            }        }    }* Dealing with schemaless data(Plese note that using schemaless fields can cause your models to get out of control - especially ifyou are the one responsible for data schema. On the other hand there is usually the case when incommingdata are with no schema defined and schemaless fields are the way to go.)  .. code-block:: python    &gt;&gt;&gt; class Event(models.Base):    ...    ...     name = fields.StringField()    ...     size = fields.FloatField()    ...     extra = fields.DictField()    &gt;&gt;&gt; Event.to_json_schema()    {        &quot;type&quot;: &quot;object&quot;,        &quot;additionalProperties&quot;: false,        &quot;properties&quot;: {            &quot;extra&quot;: {                &quot;type&quot;: &quot;object&quot;            },            &quot;name&quot;: {                &quot;type&quot;: &quot;string&quot;            },            &quot;size&quot;: {                &quot;type&quot;: &quot;float&quot;            }        }    }`DictField` allow to pass any dict of values (`&quot;type&quot;: &quot;object&quot;`), but note, that it will not make any validationon values except for the dict type.* Compare JSON schemas:  .. code-block:: python    &gt;&gt;&gt; from jsonmodels.utils import compare_schemas    &gt;&gt;&gt; schema1 = {'type': 'object'}    &gt;&gt;&gt; schema2 = {'type': 'array'}    &gt;&gt;&gt; compare_schemas(schema1, schema1)    True    &gt;&gt;&gt; compare_schemas(schema1, schema2)    FalseMore----For more examples and better description see full documentation:http://jsonmodels.rtfd.org.History-------2.6.0 (2022-10-14)++++++++++++++++++* Removed Python 3.6 support.* Added support for Python 3.11.2.5.1 (2022-06-16)++++++++++++++++++* Specified PyPy version to PyPy 3.8.* Added support for Python 3.10.2.5.0 (2021-07-26)++++++++++++++++++* Improvied error messages for field validation errors.* Allowed to validate non model list items.* Added DictField.2.4.1 (2021-02-19)++++++++++++++++++* Added Python 3.8 and 3.9 support.* Removed Python 2.7, 3.3 and 3.5 support.2.4 (2018-12-01)++++++++++++++++* Fixed length validator.* Added Python 3.7 support.2.3 (2018-02-04)++++++++++++++++* Added name mapping for fields.* Added value parsing to IntField.* Fixed bug with ECMA regex flags recognition.2.2 (2017-08-21)++++++++++++++++* Fixed time fields, when value is not required.* Dropped support for python 2.6* Added support for python 3.6* Added nullable param for fields.* Improved model representation.2.1.5 (2017-02-01)++++++++++++++++++* Fixed DateTimefield error when value is None.* Fixed comparing models without required values.2.1.4 (2017-01-24)++++++++++++++++++* Allow to compare models based on their type and fields (rather than their  reference).2.1.3 (2017-01-16)++++++++++++++++++* Fixed generated schema.* Improved JSON serialization.2.1.2 (2016-01-06)++++++++++++++++++* Fixed memory leak.2.1.1 (2015-11-15)++++++++++++++++++* Added support for Python 2.6, 3.2 and 3.5.2.1 (2015-11-02)++++++++++++++++* Added lazy loading of types.* Added schema generation for circular models.* Improved readability of validation error.* Fixed structure generation for list field.2.0.1 (2014-11-15)++++++++++++++++++* Fixed schema generation for primitives.2.0 (2014-11-14)++++++++++++++++* Fields now are descriptors.* Empty required fields are still validated only during explicite validations.Backward compatibility breaks~~~~~~~~~~~~~~~~~~~~~~~~~~~~~* Renamed _types to types in fields.* Renamed _items_types to items_types in ListField.* Removed data transformers.* Renamed module `error` to `errors`.* Removed explicit validation - validation occurs at assign time.* Renamed `get_value_replacement` to `get_default_value`.* Renamed modules `utils` to `utilities`.1.4 (2014-07-22)++++++++++++++++* Allowed validators to modify generated schema.* Added validator for maximum value.* Added utilities to convert regular expressions between Python and ECMA  formats.* Added validator for regex.* Added validator for minimum value.* By default &quot;validators&quot; property of field is an empty list.1.3.1 (2014-07-13)++++++++++++++++++* Fixed generation of schema for BoolField.1.3 (2014-07-13)++++++++++++++++* Added new fields (BoolField, TimeField, DateField and DateTimeField).* ListField is always not required.* Schema can be now generated from class itself (not from an instance).1.2 (2014-06-18)++++++++++++++++* Fixed values population, when value is not dictionary.* Added custom validators.* Added tool for schema comparison.1.1.1 (2014-06-07)++++++++++++++++++* Added possibility to populate already initialized data to EmbeddedField.* Added `compare_schemas` utility.1.1 (2014-05-19)++++++++++++++++* Added docs.* Added json schema generation.* Added tests for PEP8 and complexity.* Moved to Python 3.4.* Added PEP257 compatibility.* Added help text to fields.1.0.5 (2014-04-14)++++++++++++++++++* Added data transformers.1.0.4 (2014-04-13)++++++++++++++++++* List field now supports simple types.1.0.3 (2014-04-10)++++++++++++++++++* Fixed compatibility with Python 3.* Fixed `str` and `repr` methods.1.0.2 (2014-04-03)++++++++++++++++++* Added deep data initialization.1.0.1 (2014-04-03)++++++++++++++++++* Added `populate` method.1.0 (2014-04-02)++++++++++++++++* First stable release on PyPI.0.1.0 (2014-03-17)++++++++++++++++++* First release on PyPI.</longdescription>
</pkgmetadata>