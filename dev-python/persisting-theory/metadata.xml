<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Introduction============Persisting-theory is a small python utility designed to automate data discovering and access inside a list of packages. Use case: you are building an application that will have pluggable components. You want to allow these components to register data so it can be accessed by any other component of your app.If you ever used Django framework, you may remember this:.. code-block:: python    from django.contrib import admin    admin.autodiscover()Basically, persisting-theory will do the same, except that it let you declare what you want to autodiscover.Okay, I'm bad at explaining things, and english is not my mother tongue. Let's build a simple example.Quickstart==========Install*******Install the package from `PyPi &lt;https://pypi.python.org/pypi/persisting-theory/&gt;`_. via pip (or any other tool)::    pip install persisting-theoryPersisting-theory does not require any dependency but a python installation (it has been tested on python 2.7 and python 3.4).Setup*****A basic setup:.. code-block:: python    # registries.py    from persiting_theory import Registry    class CallbacksRegistry(Registry):        &quot;&quot;&quot;            Allow your apps to register callbacks        &quot;&quot;&quot;        # the package where the registry will try to find callbacks in each app        look_into = &quot;callbacks_registry&quot;    callbacks_registry = CallbacksRegistry()    # app1/callbacks_registry.py    from registries import callbacks_registry    @callbacks_registry.register    def dog():        print(&quot;Wouf&quot;)    # app2/callbacks_registry.py    from registries import callbacks_registry    @callbacks_registry.register    def cat():        print(&quot;Meow&quot;)    # dosomething.py    from registries import callbacks_registry    APPS = (        'app1',        'app2',    )    # Trigger autodiscovering process    callbacks_registry.autodiscover(APPS)    for callback in callbacks_registry.values():        callback()        # Wouf        # MeowAPI===``Registry`` inherits from python built-in `collections.OrderedDict`, which means you can use regular dict methods to access registered data:.. code-block:: python    callbacks_registry.get(&quot;dog&quot;)()  #  will print Wouf    assert callbacks_registry.get(&quot;chicken&quot;, None) is NoneRegistry.register()*******************You can use this function as a decorator for registering functions and classes:.. code-block:: python    from persisting_theory import Registry    class AwesomeRegistry(Registry):        pass    r = AwesomeRegistry()    # register a class    @r.register    class AwesomeClass:        pass    # register a function    @r.register    def awesome_function():        pass    # By default, the key in the registry for a given value is obtained from the function or class name, if possible    assert r.get(&quot;AwesomeClass&quot;) == AwesomeClass    assert r.get(&quot;awesome_function&quot;) == awesome_function    # You can override this behaviour:    @r.register(name=&quot;Chuck&quot;)    class AwesomeClass:        pass    @r.register(name=&quot;Norris&quot;)    def awesome_function():        pass    assert r.get(&quot;Chuck&quot;) == AwesomeClass    assert r.get(&quot;Norris&quot;) == awesome_function    # You can also use the register method as is    awesome_var = &quot;Chuck Norris&quot;    r.register(awesome_var, name=&quot;Who am I ?&quot;)    assert r.get(&quot;Who am I ?&quot;) == awesome_var    # I f you are not registering a function or a class, you MUST provide a name argumentRegistry.validate()*******************By default, a registry will accept any registered value. Sometimes, it's not what you want, so you can restrict what kind of data your registry accepts:.. code-block:: python    from persisting_theory import Registry    class StartsWithAwesomeRegistry(Registry):        def validate(self, data):            if isinstance(data, str):                return data.startswith(&quot;awesome&quot;)            return False    r = StartsWithAwesomeRegistry()    # will pass registration    r.register(&quot;awesome day&quot;, name=&quot;awesome_day&quot;)    # will fail and raise ValueError    r.register(&quot;not so awesome day&quot;, name=&quot;not_so_awesome_day&quot;)Registry.prepare_data()***********************If you want to manipulate your data before registering it, override this method. In this example, we prefix every registered string with 'hello':.. code-block:: python    from persisting_theory import Registry    class HelloRegistry(Registry):        def prepare_data(self, data):            return 'hello ' + data    r = HelloRegistry()    class Greeting:        def __init__(self, first_name):            self.first_name = first_name    r.register(Greeting('World'), name=&quot;world&quot;)    r.register(Greeting('agate'), name=&quot;agate&quot;)    assert r.register.get('world') == &quot;hello World&quot;    assert r.register.get('agate') == &quot;hello agate&quot;Registry.prepare_name()***********************In a similar way, you can manipulate the name of registered data. This can help if you want to avoid repetitions. Let's improve our previous example:.. code-block:: python    from persisting_theory import Registry    class HelloRegistry(Registry):        def prepare_data(self, data):            return 'hello ' + data        def prepare_name(self, data, name=None):            return self.data.first_name.lower()    r = HelloRegistry()    class Greeting:        def __init__(self, first_name):            self.first_name = first_name    r.register(Greeting('World'))    r.register(Greeting('agate'))    assert r.register.get('world') == &quot;hello World&quot;    assert r.register.get('agate') == &quot;hello agate&quot;Going meta**********If you have multiple registries, or want to allow your apps to declare their own registries, this is for you:.. code-block:: python    # registries.py    from persisting_theory import meta_registry, Registry    class RegistryA(Registry):        look_into = &quot;a&quot;    class RegistryB(Registry):        look_into = &quot;b&quot;    registry_a = RegistryA()    meta_registry.register(registry_a, name=&quot;registry_a&quot;)    registry_b = RegistryB()    meta_registry.register(registry_b, name=&quot;registry_b&quot;)    # dosomethingelse.py    from persisting_theory import meta_registry    # will import registries declared in `registries` packages, and trigger autodiscover() on each of them    meta_registry.autodiscover(apps=(&quot;app1&quot;, &quot;app2&quot;))What the hell is that name ?============================It's an anagram for &quot;python registries&quot;.Contribute==========Contributions, bug reports, and &quot;thank you&quot; are welcomed.License=======The project is licensed under BSD licence.</longdescription>
</pkgmetadata>