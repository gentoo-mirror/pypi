<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>What is pagination?---------------------This module helps dividing large lists of items into pages. The user is shown one page at a time andcan navigate to other pages. Imagine you are offering a company phonebook and let the user searchthe entries. If the search result contains 23 entries but you may want to display no more than 10entries at once. The first page contains entries 1-10, the second 11-20 and the third 21-23. See thedocumentation of the &quot;Page&quot; class for more information.How do I use this module?---------------------------The paginate module contains extensive in-line documentation with examples.Concerning WebHelpers-----------------------This is a standalone module. Former versions were included in the WebHelpers Python module aswebhelpers.paginate and were tightly coupled with the WebHelpers and the Pylons web framework. Thisversion aims to be useful independent of any web framework.Subclassing Page()------------------This module supports pagination through list-like objects. To paginate though other types of objectsyou can subclass the paginate.Page() class and provide a wrapper class that defines how to accesselements of that special collection.You can find examples in other paginate_* modules like paginate_sqlalchemy. Basically you would haveto provide a class that implements the __init__, __getitem__ and __len__ methods.It is trivial to make pagination for other datastores like Elasticsearch/Solr extending the base class.Example::    class SqlalchemyOrmWrapper(object):        &quot;&quot;&quot;Wrapper class to access elements of a collection.&quot;&quot;&quot;        def __init__(self, obj):            self.obj = obj        def __getitem__(self, range):            # Return a range of objects of an sqlalchemy.orm.query.Query object            return self.obj[range]        def __len__(self):            # Count the number of objects in an sqlalchemy.orm.query.Query object            return self.obj.count()Then you can create your own Page class that uses the above wrapper class::    class SqlalchemyOrmPage(paginate.Page):        &quot;&quot;&quot;A pagination page that deals with SQLAlchemy ORM objects.&quot;&quot;&quot;        def __init__(self, *args, **kwargs):            super(SqlalchemyOrmPage, self).__init__(*args, wrapper_class=SqlalchemyOrmWrapper, **kwargs)As you can see it does not do much. It basically calls paginate.Page.__init__ and addswrapper_class=SqlalchemyOrmWrapper as an argument. The paginate.Page instance will use that wrapperclass to access the elements.Generating HTML come for current page-------------------------------------Example::    p = paginate.Page([], page=15, items_per_page=15, item_count=1010)    # item_count is optional, but we pass a dummy empty resultset for this example    pattern = '$link_first $link_previous ~4~ $link_next $link_last (Page $page our of $page_count - total $item_count)'    p.pager(pattern, url='http://foo.com?x=$page', dotdot_attr={'x':5}, link_attr={'y':6}, curpage_attr={'z':77})    # *_attr arguments are optional and can be used to attach additional classes/attrs to tagsResults in::    '&lt;a class=&quot;L&quot; href=&quot;URL?x=1&quot;&gt;&amp;lt;&amp;lt;&lt;/a&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=14&quot;&gt;&amp;lt;&lt;/a&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=1&quot;&gt;1&lt;/a&gt; &lt;span class=&quot;D&quot;&gt;..&lt;/span&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=11&quot;&gt;11&lt;/a&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=12&quot;&gt;12&lt;/a&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=13&quot;&gt;13&lt;/a&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=14&quot;&gt;14&lt;/a&gt; &lt;span class=&quot;C&quot;&gt;15&lt;/span&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=16&quot;&gt;16&lt;/a&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=17&quot;&gt;17&lt;/a&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=18&quot;&gt;18&lt;/a&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=19&quot;&gt;19&lt;/a&gt; &lt;span class=&quot;D&quot;&gt;..&lt;/span&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=68&quot;&gt;68&lt;/a&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=16&quot;&gt;&amp;gt;&lt;/a&gt; &lt;a class=&quot;L&quot; href=&quot;URL?x=68&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt; (Page 15 our of 68 - total items 1010)'Using url maker to generate links to specific result ranges-----------------------------------------------------------You can pass `url_maker` Callback to generate the URL of other pages, given its numbers.Must accept one int parameter and return a URI string.Example::    def url_maker(page_number):        return str('foo/%s' % page_number)    page = paginate.Page(range(100), page=1, url_maker=url_maker)    eq_(page.pager(), '1 &lt;a href=&quot;foo/2&quot;&gt;2&lt;/a&gt; &lt;a href=&quot;foo/3&quot;&gt;3&lt;/a&gt; .. &lt;a href=&quot;foo/5&quot;&gt;5&lt;/a&gt;')Alternatively if you will not pass the link builder function, the pager() method can also accept `url` argument that contains URL that page links will point to.Make sure it contains the string $page which will be replaced by the actual page number.Must be given unless a url_maker is specified to __init__, in which case this parameter is ignored.Using link information for custom paginator templates-----------------------------------------------------If you do not like the default HTML format produced by paginator you can use link_map() function to generatea dictionary of links you can use in your own template.Example::    p.link_map('$link_first $link_previous ~4~ $link_next $link_last (Page $page our of $page_count - total items $item_count)',url='URL?x=$page',dotdot_attr={'class':'D'}, link_attr={'class':&quot;L&quot;}, curpage_attr={'class':&quot;C&quot;})Returns something like::    {'current_page': {'attrs': {'class': 'C'}, 'href': 'URL?x=15', 'value': 15},     'first_page': {'attrs': {'class': 'L'}, 'href': 'URL?x=1', 'type': 'first_page', 'value': 1},     'last_page': {'attrs': {'class': 'L'}, 'href': 'URL?x=68', 'type': 'last_page', 'value': 68},     'next_page': {'attrs': {'class': 'L'}, 'href': 'URL?x=16', 'type': 'next_page', 'value': 16},     'previous_page': {'attrs': {'class': 'L'}, 'href': 'URL?x=14', 'type': 'previous_page', 'value': 14},     'range_pages': [{'attrs': {'class': 'D'}, 'href': '', 'type': 'span', 'value': '..'},      {'attrs': {'class': 'L'}, 'href': 'URL?x=11', 'type': 'page', 'value': '11'},      {'attrs': {'class': 'L'}, 'href': 'URL?x=12', 'type': 'page', 'value': '12'},      {'attrs': {'class': 'L'}, 'href': 'URL?x=13', 'type': 'page', 'value': '13'},      {'attrs': {'class': 'L'}, 'href': 'URL?x=14', 'type': 'page', 'value': '14'},      {'attrs': {'class': 'C'}, 'href': 'URL?x=15', 'type': 'current_page', 'value': 15},      {'attrs': {'class': 'L'}, 'href': 'URL?x=16', 'type': 'page', 'value': '16'},      {'attrs': {'class': 'L'}, 'href': 'URL?x=17', 'type': 'page', 'value': '17'},      {'attrs': {'class': 'L'}, 'href': 'URL?x=18', 'type': 'page', 'value': '18'},      {'attrs': {'class': 'L'}, 'href': 'URL?x=19', 'type': 'page', 'value': '19'},      {'attrs': {'class': 'D'}, 'href': '', 'type': 'span', 'value': '..'}],      'radius': 4}Using link_tag callable to generate custom link markup------------------------------------------------------In case you want to generate custom link markup for your project - for example for use with bootstrap,`pager()` accepts `link_tag` argument that expects a callable that can be used to easly override the way links aregenerated.Example::    from paginate import Page, make_html_tag    def paginate_link_tag(item):        &quot;&quot;&quot;        Create an A-HREF tag that points to another page usable in paginate.        &quot;&quot;&quot;        a_tag = Page.default_link_tag(item)        if item['type'] == 'current_page':            return make_html_tag('li', a_tag, **{'class':'active'})        return make_html_tag('li', a_tag)    paginator.pager(    curpage_attr={'class':'current_page'},    dotdot_attr={'class':'spacer'},    symbol_first='&lt;i class=&quot;fa fa-chevron-circle-left&quot;&gt;&lt;/i&gt;',    symbol_last='&lt;i class=&quot;fa fa-chevron-circle-right&quot;&gt;&lt;/i&gt;',    symbol_previous='&lt;i class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt;',    symbol_next='&lt;i class=&quot;fa fa-chevron-right&quot;&gt;&lt;/i&gt;',    link_tag=paginate_link_tag)Version 0.5.5 - 2016-11-22--------------------------Changes:- Python 2.7/3.4+ compatibility improvementsVersion 0.5.4 - 2016-04-25--------------------------Changes:- Added radius size config optionVersion 0.5.3 - 2016-03-09--------------------------Changes:- Unocode related fixesVersion 0.5.2 - 2015-08-29--------------------------Changes:- Handle the slice prior to handling the length - for better experience with  various databases that include item count in results- bugfixesVersion 0.5.1 - 2015-10-22--------------------------Changes:- bugfixesVersion 0.5.0 - 2015-08-29--------------------------Changes:- link_tag callable can now be passed to generate custom link markup- page object now has link_map() method that returns a mapping of information useful for generating  custom markup based on paginator dataVersion 0.4.0 - 2012-12-06--------------------------Paginate has prior been maintained as webhelpers.paginate in the _webhelpers_ packages.This version is a standalone version that should be useful outside of the webhelpers'context.Changes:- Python 3 compatibility.- SQLAlchemyObject and SQLAlchemyQuery collections are not automatically detected any more.  Instead you can use the respective Page class from the paginate_sqlalchemy module also  available on PyPi.- presliced_list parameter no longer supported- 'page_nr' and 'current_page' had been deprecated already and are now removed. Please use 'page'  instead.- No automatic URL generation. You need to pass a 'url' argument to the Page.pager() method  containing a $page placeholder where you want the page number to be put in. Beware that the URL  is not quote-escaped any further.- The Page.pager() does not automatically add CSS classes any more. If you want the old  behavior you need to pass these parameters explicitly:  link_attr={'class':'pager_link'}  curpage_attr={'class':'pager_curpage'}  dotdot_attr={'class':'pager_dotdot'}- The partial_param parameter from Page.pager() is gone. You should use your own URLs for  AJAX/partial updates in the 'url' parameter.- The page_param parameter from Page.pager() is also gone as URL generation has been severely  simplified.- The string returned from Page.pager() consists of escaped HTML already. So you need to tell  your web framework to use the string verbatim and without further escaping.  The parameters symbol_first, symbol_last, symbol_previous and symbol_next use  &amp;lt; and &amp;gt; instead of &quot;&lt;&quot; and &quot;&gt;&quot; now.- Page.__repr__ now returns a brief representation. E.g. &lt;paginate.Page: 1 of 1&gt;  Page.__str__ returns the verbose view you may be used to.Version 0.3.2 - 2008-01-31--------------------------Public release on PyPi</longdescription>
</pkgmetadata>