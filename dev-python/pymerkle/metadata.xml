<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pymerkle**Merkle-tree cryptography in python**[![Build Status](https://gitlab.com/fmerg/pymerkle/badges/master/pipeline.svg)](https://gitlab.com/fmerg/pymerkle/commits/master)[![Docs Status](https://readthedocs.org/projects/pymerkle/badge/?version=latest)](http://pymerkle.readthedocs.org)[![PyPI version](https://badge.fury.io/py/pymerkle.svg)](https://pypi.org/project/pymerkle/)![Python &gt;= 3.10](https://img.shields.io/badge/python-%3E%3D%203.10-blue.svg)Documentation at **[pymerkle.readthedocs.org](http://pymerkle.readthedocs.org/)**.Storage agnostic implementation capable of generating inclusion and consistency proofs.## Install```bashpip3 install pymerkle```This will also install [`cachetools`](https://github.com/tkem/cachetools)as a dependency.## Basic APILet ``MerkleTree`` be any class implementing the ``BaseMerkleTree``interface; e.g.,```pythonfrom pymerkle import InmemoryTree as MerkleTreetree = MerkleTree()```Append data into the tree and retrieve the corresponding hash value:```pythonindex = tree.append_entry(b'foo')   # leaf indexvalue = tree.get_leaf(index)        # leaf hash```Current tree size:```pythonsize = tree.get_size()    # number of leaves```Current and intermediate states:```pythonstate = tree.get_state()    # current root-hashstate = tree.get_state(5)   # root-hash of size 5 subtree```### Inclusion proofProve inclusion of the 3-rd leaf hash in the subtree of size 5:```pythonproof = tree.prove_inclusion(3, 5)```Verify the proof against the base hash and the subtree root:```pythonfrom pymerkle import verify_inclusionbase = tree.get_leaf(3)root = tree.get_state(5)verify_inclusion(base, root, proof)```### Consistency proofProve consistency between the states with size 3 and 5:```pythonproof = tree.prove_consistency(3, 5)```Verify the proof against the respective root-hashes:```pythonfrom pymerkle import verify_consistencystate1 = tree.get_state(3)state2 = tree.get_state(5)verify_consistency(state1, state2, proof)```## Security*This library requires security review.*### Resistance against second-preimage attackThis consists in the following standard technique:- Upon computing the hash of a leaf node, prepend `0x00` to the payload- Upon computing the hash of an interior node, prepend `0x01` to the payload**Note**: For, say, testing purposes, you can disable this feature by passing`disable_security=True` when initializing the `BaseMerkleTree` superclass.Refer [here](./tests/test_defense.py) to see how to perform second-preimageattack against the present implementation.### Resistance against CVE-2012-2459 DOSContrary to the [bitcoin](https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees)specification, lonely leaves are not duplicated while the tree is growing.Instead, a bifurcation node is created at the rightmost branch (see next section).As a consequence, the present implementation should be invulnerable to the[CVE-2012-2459](https://nvd.nist.gov/vuln/detail/CVE-2012-2459) DOS attack (see also[here](https://github.com/bitcoin/bitcoin/blob/bccb4d29a8080bf1ecda1fc235415a11d903a680/src/consensus/merkle.cpp)for insight).## TopologyInterior nodes are not assumed to be stored anywhere and no concrete links arecreated between them. The tree structure is determined by the recursivefunction which computes intermediate states on the fly and is essentially the same as[RFC 9162](https://datatracker.ietf.org/doc/html/rfc9162) (Section 2).It turns out to be that of a binary[Sakura tree](https://keccak.team/files/Sakura.pdf) (Section 5.4).## OptimizationsThe performance of a Merkle-tree depends on how efficiently it computes the root-hashfor arbitrary leaf ranges on the fly. The recursive version of this operation(e.g., [RFC 9162](https://datatracker.ietf.org/doc/html/rfc9162), Section 2)is slow.A key remark is that the above operation can be made iterative by combining the root-hashesfor ranges whose size is a power of two (&quot;subroots&quot;) and can as such be computedefficiently. Subroot computation has significant impact on performance(&gt;500% speedup) while keeping peak memory usage reasonably low(e.g., 200 MiB for a tree with several tens of millions of entries) andlinear with respect to tree size.**Note**: For, say, comparison purposes, you can disable this feature by passing`disable_optimizations=True` when initializing the `BaseMerkleTree` superclass.### CachingIn view of the above technique, subroot computation is the only massively repeatedand relatively costly operation. It thus makes sense to apply memoizationfor ranges whose size exceeds a certain threshold (128 leaves by default).For example, after sufficiently many cache hits (e.g. 2MiB cache memory), proof generationbecomes 5 times faster for a tree with several tens of million of entries.Practically, a pretty big tree with sufficiently long uptime will respond instantlywith negligible penalty in memory usage.**Note**: For, say, comparison purposes, you can disable this feature by passing`disable_cache=True` when initializing the `BaseMerkleTree` superclass.## StorageThis library is unopinionated on how leaves are appended to the tree, i.e., howdata is stored in concrete.  Cryptographic functionality is encapsulated in the`BaseMerkleTree` abstract class, which admits pluggable storage backendsthrough subclassing. It is the the developer's choice to decide how tostore data by implementing the interior storage interface of this class.Any contiguously indexed dataset should do the job. Conversely, given any suchdataset, we should be able to trivially implement a Merkle-tree that isoperable with it.### ExampleThis is a simple non-persistent implementation utilizing a list as storage. Itexpects entries to be strings, which it encodes in utf-8 before hashing.```pythonfrom pymerkle import BaseMerkleTreeclass MerkleTree(BaseMerkleTree):    def __init__(self, algorithm='sha256'):        &quot;&quot;&quot;        Storage setup and superclass initialization        &quot;&quot;&quot;        self.hashes = []        super().__init__(algorithm)    def _encode_entry(self, data):        &quot;&quot;&quot;        Prepares data entry for hashing        &quot;&quot;&quot;        return data.encode('utf-8')    def _store_leaf(self, data, digest):        &quot;&quot;&quot;        Stores data hash in a new leaf and returns index        &quot;&quot;&quot;        self.hashes += [digest]        return len(self.hashes)    def _get_leaf(self, index):        &quot;&quot;&quot;        Returns the hash stored by the leaf specified        &quot;&quot;&quot;        value = self.hashes[index - 1]        return value    def _get_leaves(self, offset, width):        &quot;&quot;&quot;        Returns hashes corresponding to the specified leaf range        &quot;&quot;&quot;        values = self.hashes[offset: offset + width]        return values    def _get_size(self):        &quot;&quot;&quot;        Returns the current number of leaves        &quot;&quot;&quot;        return len(self.hashes)```## DevelopmentIn what follows, you need to have locally installed dev requirements:```commandlinepip3 install -r requirements-dev.txt```### Tests```commandline./test.sh --help```### Performance measurementsIn order to capture the effect of I/O operations, performance measurements arerun against a SQLite database as leaf storage. Create it using the following script:```commandlinepython benchmarks/init_db.py --help```#### Benchmarks```commandline./benchmark.sh --help```#### ProfilingAssuming [`valgrind`](https://valgrind.org/) and[`massif-visualizer`](https://apps.kde.org/massif-visualizer/) are installed, use```commandline./profile.sh --help```to do memory profiling. Pass `--time` to profile execution timesinstead of memory allocations.## Documentation**[pymerkle.readthedocs.org](http://pymerkle.readthedocs.org/)**.### Build locallyDocumentation is built with[`sphinx`](https://www.sphinx-doc.org/en/master/index.html)Assuming dev requirements have been installed, build the docs with```commandline./build-docs.sh [--help]```and browse at```docs/target/build/html/index.html```</longdescription>
</pkgmetadata>