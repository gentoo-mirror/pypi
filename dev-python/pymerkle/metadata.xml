<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pymerkle**Merkle-tree cryptography in python**[![Build Status](https://gitlab.com/fmerg/pymerkle/badges/master/pipeline.svg)](https://gitlab.com/fmerg/pymerkle/commits/master)[![Docs Status](https://readthedocs.org/projects/pymerkle/badge/?version=latest)](http://pymerkle.readthedocs.org)[![PyPI version](https://badge.fury.io/py/pymerkle.svg)](https://pypi.org/project/pymerkle/)![Python &gt;= 3.10](https://img.shields.io/badge/python-%3E%3D%203.10-blue.svg)Documentation at **[pymerkle.readthedocs.org](http://pymerkle.readthedocs.org/)**.Storage agnostic implementation, capable of generating inclusion and consistency proofs## Install```bashpip3 install pymerkle```## Basic APILet ``MerkleTree`` be any class implementing correctly the ``BaseMerkleTree``interface; e.g.,```pythonfrom pymerkle import InmemoryTree as MerkleTreetree = MerkleTree()```Store data into the tree and retrieve the corresponding leaf-hash:```pythonindex = tree.append(b'foo')   # index counting from onevalue = tree.get_leaf(index)  # leaf hash```Current size and root-hash:```pythonsize = tree.get_size()    # number of leavesstate = tree.get_state()  # current root hash```### Inclusion proofProve inclusion of the 3-rd leaf hash in the size 5 subtree:```pythonproof = tree.prove_inclusion(3, size=5)```Verify the proof against the base hash and the subtree root:```pythonfrom pymerkle import verify_inclusionbase = tree.get_leaf(3)target = tree.get_state(5)verify_inclusion(base, target, proof)```### Consistency proofProve consistency between the subtrees of size 3 and 5:```pythonproof = tree.prove_consistency(3, 5)```Verify the proof against the respective root hashes:```pythonfrom pymerkle import verify_consistencystate1 = tree.get_state(3)state2 = tree.get_state(5)verify_consistency(state1, state2, proof)```## StoragePymerkle is unopinionated on how leaves are appended to the tree, i.e., howentries should be stored in concrete. Core cryptographic functionality isencapsulated in the `BaseMerkleTree` abstract class which admits pluggablestorage backends. It is the developer's choice to decide how to store data inconcrete by implementing the interior storage interface of this class.### ExampleThis is the simplest possible non-persistent implementation utilizing a list,where inserted data is expected to be in binary format and stored withoutfurther processing:```pythonfrom pymerkle.base import BaseMerkleTreeclass MerkleTree(BaseMerkleTree):    def __init__(self, algorithm='sha256', security=True):        self.leaves = []        super().__init__(algorithm, security)    def _store_data(self, entry):        self.leaves += [entry]        return len(self.leaves)    def _get_blob(self, index):        return self.leaves[index - 1]    def _get_size(self):        return len(self.leaves)```## Security**Disclaimer**: This is currently a prototype requiring security review.### Resistance against second-preimage attackThis consists in the following standard technique:- Upon computing the hash of a leaf node, prepend `0x00` to the payload- Upon computing the hash of an interior node, prepend `0x01` to the payloadRefer [here](./tests/test_defense.py) to see how to perform second-preimageattack against the present implementation.### Resistance against CVE-2012-2459 DOSContrary to the [bitcoin](https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees)spec, lonely leaves are not duplicated while the tree is growing;instead, a bifurcation node is created at the rightmost branch (see next section).As a consequence, the present implementation should be invulnerable to the[CVE-2012-2459](https://nvd.nist.gov/vuln/detail/CVE-2012-2459) DOS attack (see also[here](https://github.com/bitcoin/bitcoin/blob/bccb4d29a8080bf1ecda1fc235415a11d903a680/src/consensus/merkle.cpp)for insight).## Tree topologyInterior nodes are in general not stored in memory and no concrete links areestablished between them. The tree structure is determined by the recursivefunction which computes intermediate states on the fly and is essentially the same as[RFC 9162](https://datatracker.ietf.org/doc/html/rfc9162) (Section 2).It turns out to be that of a binary[Sakura tree](https://keccak.team/files/Sakura.pdf) (Section 5.4).## Development```commandlinepip3 install -r requirements-dev.txt```### Tests```commandline./test.sh --help```## Documentation**[pymerkle.readthedocs.org](http://pymerkle.readthedocs.org/)**.### Build locallyDocumentation is built with[`sphinx`](https://www.sphinx-doc.org/en/master/index.html):```commandlinepip3 install -r requirements-doc.txt```Once installed, build the docs with```commandline./build-docs.sh [--help]```and browse at```docs/target/build/html/index.html```</longdescription>
</pkgmetadata>