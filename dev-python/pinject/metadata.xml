<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>========= Pinject=========.. image:: https://badge.fury.io/py/pinject.svg    :target: https://pypi.org/project/pinject/.. image:: https://travis-ci.com/google/pinject.svg?branch=master    :target: https://travis-ci.com/google/pinject.. image:: https://pepy.tech/badge/pinject    :target: https://pepy.tech/badge/pinject.. image:: https://pepy.tech/badge/pinject/month    :target: https://pepy.tech/badge/pinjectPinject is a dependency injection library for python.The primary goal of Pinject is to help you assemble objects into graphs in aneasy, maintainable way.If you are already familiar with other dependency injection libraries, you maywant to read the condensed summary section at the end, so that you get an ideaof what Pinject is like and how it might differ from libraries you're used to.There is a changelog of differences between released versions near the end ofthis README.Why Pinject?============If you're wondering why to use a dependency injection library at all: ifyou're writing a lot of object-oriented code in python, then it will make yourlife easier.  See, for instance:* https://en.wikipedia.org/wiki/Dependency_injection* http://lmgtfy.com/?q=dependency+injectionIf you're wondering why to use Pinject instead of another python dependencyinjection library, a few of reasons are:* Pinject is much easier to get started with.  Forget having to decorate your code with ``@inject_this`` and ``@annotate_that`` just to get started.  With Pinject, you call ``new_object_graph()``, one line, and you're good to go.* Pinject is a *pythonic* dependency injection library.  Python ports of other libraries, like Spring or Guice, retain the feel (and verbosity) of being designed for a statically typed language.  Pinject is designed from the ground up for python.* The design choices in Pinject are informed by several dependency injection experts working at Google, based on many years of experience.  Several common confusing or misguided features are omitted altogether from Pinject.* Pinject has great error messages.  They tell you exactly what you did wrong, and exactly where.  This should be a welcome change from other dependency frameworks, with their voluminous and yet inscrutable stack traces.Look at the simplest getting-started examples for Pinject and for othersimilar libraries.  Pinject should be uniformly easier to use, clearer toread, and less boilerplate that you need to add.  If you don't find this to bethe case, email!Installation============The easiest way to install Pinject is to get the latest released version fromPyPI:.. code-block:: shell    sudo pip install pinjectIf you are interested in the developing version, you can install the next version from Test PyPI:.. code-block:: shell    sudo pip install \        --no-deps \        --no-cache \        --upgrade \        --index-url https://test.pypi.org/simple/ \        pinjectYou can also check out all the source code, including tests, designs, andTODOs:.. code-block:: shell   git clone https://github.com/google/pinjectBasic dependency injection==========================The most important function in the ``pinject`` module is``new_object_graph()``.  This creates an ``ObjectGraph``, which you can use toinstantiate objects using dependency injection.  If you pass no args to``new_object_graph()``, it will return a reasonably configured default``ObjectGraph``... code-block:: python    &gt;&gt;&gt; class OuterClass(object):    ...     def __init__(self, inner_class):    ...         self.inner_class = inner_class    ...    &gt;&gt;&gt; class InnerClass(object):    ...     def __init__(self):    ...         self.forty_two = 42    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph()    &gt;&gt;&gt; outer_class = obj_graph.provide(OuterClass)    &gt;&gt;&gt; print outer_class.inner_class.forty_two    42    &gt;&gt;&gt;As you can see, you don't need to tell Pinject how to construct its``ObjectGraph``, and you don't need to put decorators in your code.  Pinject hasreasonable defaults that allow it to work out of the box.A Pinject *binding* is an association between an *arg name* and a *provider*.In the example above, Pinject created a binding between the arg name``inner_class`` and an implicitly created provider for the class``InnerClass``.  The binding it had created was how Pinject knew that itshould pass an instance of ``InnerClass`` as the value of the ``inner_class``arg when instantiating ``OuterClass``.Implicit class bindings=======================Pinject creates implicit bindings for classes.  The implicit bindings assumeyour code follows PEP8 conventions: your classes are named in ``CamelCase``,and your args are named in ``lower_with_underscores``.  Pinject transformsclass names to injectable arg names by lowercasing words and connecting themwith underscores.  It will also ignore any leading underscore on the classname.+-------------+-------------+| Class name  | Arg name    |+=============+=============+| ``Foo``     | ``foo``     |+-------------+-------------+| ``FooBar``  | ``foo_bar`` |+-------------+-------------+| ``_Foo``    | ``foo``     |+-------------+-------------+| ``_FooBar`` | ``foo_bar`` |+-------------+-------------+If two classes map to the same arg name, whether those classes are in the samemodule or different modules, Pinject will not create an implicit binding forthat arg name (though it will not raise an error).Finding classes and providers for implicit bindings===================================================So far, the examples have not told ``new_object_graph()`` the classes forwhich it should create implicit bindings.  ``new_object_graph()`` by defaultlooks in all imported modules, but you may occasionally want to restrict theclasses for which ``new_object_graph()`` creates implicit bindings.  If so,``new_object_graph()`` has two args for this purpose.* The ``modules`` arg specifies in which (python) modules to look for classes; this defaults to ``ALL_IMPORTED_MODULES``.* The ``classes`` arg specifies a exact list of classes; this defaults to ``None``... code-block:: python    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class Foo(object):    ...     pass    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(modules=None, classes=[SomeClass])    &gt;&gt;&gt; # obj_graph.provide(SomeClass)  # would raise a NothingInjectableForArgError    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(modules=None, classes=[SomeClass, Foo])    &gt;&gt;&gt; some_class = obj_graph.provide(SomeClass)    &gt;&gt;&gt;Auto-copying args to fields===========================One thing that can get tedious about dependency injection via initializers isthat you need to write ``__init__()`` methods that copy args to fields.  These``__init__()`` methods can get repetitive, especially when you have severalinitializer args... code-block:: python    &gt;&gt;&gt; class ClassWithTediousInitializer(object):    ...     def __init__(self, foo, bar, baz, quux):    ...         self._foo = foo    ...         self._bar = bar    ...         self._baz = baz    ...         self._quux = quux    ...    &gt;&gt;&gt;Pinject provides decorators that you can use to avoid repetitive initializerbodies.* ``@copy_args_to_internal_fields`` prepends an underscore, i.e., it copies an arg named ``foo`` to a field named ``_foo``.  It's useful for normal classes.* ``@copy_args_to_public_fields`` copies the arg named as-is, i.e., it copies an arg named ``foo`` to a field named ``foo``.  It's useful for data objects... code-block:: python    &gt;&gt;&gt; class ClassWithTediousInitializer(object):    ...     @pinject.copy_args_to_internal_fields    ...     def __init__(self, foo, bar, baz, quux):    ...         pass    ...    &gt;&gt;&gt; cwti = ClassWithTediousInitializer('a-foo', 'a-bar', 'a-baz', 'a-quux')    &gt;&gt;&gt; print cwti._foo    'a-foo'    &gt;&gt;&gt;When using these decorators, you'll normally ``pass`` in the body of theinitializer, but you can put other statements there if you need to.  The argswill be copied to fields before the initializer body is executed.These decorators can be applied to initializers that take ``**kwargs`` but notinitializers that take ``*pargs`` (since it would be unclear what field nameto use).Binding specs=============To create any bindings more complex than the implicit class bindings describedabove, you use a *binding spec*.  A binding spec is any python class thatinherits from ``BindingSpec``.  A binding spec can do three things:* Its ``configure()`` method can create explicit bindings to classes or instances, as well as requiring bindings without creating them.* Its ``dependencies()`` method can return depended-on binding specs.* It can have provider methods, for which explicit bindings are created.The ``new_object_graph()`` function takes a sequence of binding spec instancesas its ``binding_specs`` arg.  ``new_object_graph()`` takes binding specinstances, rather than binding spec classes, so that you can manually injectany initial dependencies into the binding specs as needed.Binding specs should generally live in files named ``binding_specs.py``, whereeach file is named in the plural even if there is exactly one binding spec init.  Ideally, a directory's worth of functionality should be coverable with asingle binding spec.  If not, you can create multiple binding specs in thesame ``binding_specs.py`` file.  If you have so many binding specs that youneed to split them into multiple files, you should name them each with a``_binding_specs.py`` suffix.Binding spec ``configure()`` methods------------------------------------Pinject creates implicit bindings for classes, but sometimes the implicitbindings aren't what you want.  For instance, if you have``SomeReallyLongClassName``, you may not want to name your initializer args``some_really_long_class_name`` but instead use something shorter like``long_name``, just for this class.For such situations, you can create explicit bindings using the``configure()`` method of a binding spec.  The ``configure()`` method takes afunction ``bind()`` as an arg and calls that function to create explicitbindings... code-block:: python    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, long_name):    ...         self.long_name = long_name    ...    &gt;&gt;&gt; class SomeReallyLongClassName(object):    ...     def __init__(self):    ...         self.foo = 'foo'    ...    &gt;&gt;&gt; class MyBindingSpec(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('long_name', to_class=SomeReallyLongClassName)    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[MyBindingSpec()])    &gt;&gt;&gt; some_class = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class.long_name.foo    'foo'    &gt;&gt;&gt;The ``bind()`` function passed to a binding function binds its first arg,which must be an arg name (as a ``str``), to exactly one of two kinds ofthings.* Using ``to_class`` binds to a class.  When the binding is used, Pinject injects an instance of the class.* Using ``to_instance`` binds to an instance of some object.  Every time the binding is used, Pinject uses that instance... code-block:: python    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class MyBindingSpec(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('foo', to_instance='a-foo')    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[MyBindingSpec()])    &gt;&gt;&gt; some_class = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class.foo    'a-foo'    &gt;&gt;&gt;The ``configure()`` method of a binding spec also may take a function``require()`` as an arg and use that function to require that a binding bepresent without actually defining that binding.  ``require()`` takes as argsthe name of the arg for which to require a binding... code-block:: python    &gt;&gt;&gt; class MainBindingSpec(pinject.BindingSpec):    ...     def configure(self, require):    ...         require('foo')    ...    &gt;&gt;&gt; class RealFooBindingSpec(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('foo', to_instance='a-real-foo')    ...    &gt;&gt;&gt; class StubFooBindingSpec(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('foo', to_instance='a-stub-foo')    ...    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(    ...     binding_specs=[MainBindingSpec(), RealFooBindingSpec()])    &gt;&gt;&gt; some_class = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class.foo    'a-real-foo'    &gt;&gt;&gt; # pinject.new_object_graph(    ... #    binding_specs=[MainBindingSpec()])  # would raise a MissingRequiredBindingError    ...    &gt;&gt;&gt;Being able to require a binding without defining the binding is useful whenyou know the code will need some dependency satisfied, but there is more thanone implementation that satisfies that dependency, e.g., there may be a realRPC client and a fake RPC client.  Declaring the dependency means that anyexpected but missing bindings will be detected early, when``new_object_graph()`` is called, rather than in the middle of running yourprogram.You'll notice that the ``configure()`` methods above have differentsignatures, sometimes taking the arg ``bind`` and sometimes taking the arg``require``.  ``configure()`` methods must take at least one arg that iseither ``bind`` or ``require``, and they may have both args.  Pinject willpass whichever arg or args your ``configure()`` method needs.Binding spec dependencies-------------------------Binding specs can declare dependencies.  A binding spec declares itsdependencies by returning a sequence of instances of the dependent bindingspecs from its ``dependencies()`` method... code-block:: python    &gt;&gt;&gt; class ClassOne(object):    ...    def __init__(self, foo):    ...        self.foo = foo    ....    &gt;&gt;&gt; class BindingSpecOne(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('foo', to_instance='foo-')    ...    &gt;&gt;&gt; class ClassTwo(object):    ...     def __init__(self, class_one, bar):    ...         self.foobar = class_one.foo + bar    ...    &gt;&gt;&gt; class BindingSpecTwo(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('bar', to_instance='-bar')    ...     def dependencies(self):    ...         return [BindingSpecOne()]    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[BindingSpecTwo()])    &gt;&gt;&gt; class_two = obj_graph.provide(ClassTwo)    &gt;&gt;&gt; print class_two.foobar    'foo--bar'    &gt;&gt;&gt;If classes from module A are injected as collaborators into classes frommodule B, then you should consider having the binding spec for module B dependon the binding spec for module A.  In the example above, ``ClassOne`` isinjected as a collaborator into ``ClassTwo``, and so ``BindingSpecTwo`` (thebinding spec for ``ClassTwo``) depends on ``BindingSpecOne`` (the binding specfor ``ClassOne``).In this way, you can build a graph of binding spec dependencies that mirrorsthe graph of collaborator dependencies.Since explicit bindings cannot conflict (see the section below on bindingprecedence), a binding spec should only have dependencies that there willnever be a choice about using.  If there may be a choice, then it is better tolist the binding specs separately and explicitly when calling``new_object_graph()``.The binding spec dependencies can be a directed acyclic graph (DAG); that is,binding spec A can be a dependency of B and of C, and binding spec D can havedependencies on B and C.  Even though there are multiple dependency paths fromD to A, the bindings in binding spec A will only be evaluated once.The binding spec instance of A that is a dependency of B is considered thesame as the instance that is a dependency of C if the two instances are equal(via ``__eq__()``).  The default implementation of ``__eq__()`` in``BindingSpec`` says that two binding specs are equal if they are of exactlythe same python type.  You will need to override ``__eq__()`` (as well as``__hash__()``) if your binding spec is parameterized, i.e., if it takes oneor more initializer args so that two instances of the binding spec may behavedifferently... code-block:: python    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def __init__(self, the_instance):    ...         self._the_instance = the_instance    ...     def configure(self, bind):    ...         bind('foo', to_instance=self._the_instance)    ...     def __eq__(self, other):    ...         return (type(self) == type(other) and    ...                 self._the_instance == other._the_instance)    ...     def __hash__(self):    ...         return hash(type(self)) ^ hash(self._the_instance)    ...    &gt;&gt;&gt;Provider methods----------------If it takes more to instantiate a class than calling its initializer andinjecting initializer args, then you can write a *provider method* for it.Pinject can use provider methods to instantiate objects used to inject as thevalues of other args.Pinject looks on binding specs for methods named like provider methods andthen creates explicit bindings for them... code-block:: python    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def provide_foo(self):    ...         return 'some-complex-foo'    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])    &gt;&gt;&gt; some_class = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class.foo    'some-complex-foo'    &gt;&gt;&gt;Pinject looks on binding specs for methods whose names start with``provide_``, and it assumes that the methods are providers for whatever therest of their method names are.  For instance, Pinject assumes that the method``provide_foo_bar()`` is a provider method for the arg name ``foo_bar``.Pinject injects all args of provider methods that have no default when itcalls the provider method... code-block:: python    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, foobar):    ...         self.foobar = foobar    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def provide_foobar(self, bar, hyphen='-'):    ...         return 'foo' + hyphen + bar    ...     def provide_bar(self):    ...         return 'bar'    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])    &gt;&gt;&gt; some_class = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class.foobar    'foo-bar'    &gt;&gt;&gt;Binding precedence==================Bindings have precedence: explicit bindings take precedence over implicitbindings.* Explicit bindings are the bindings that come from binding specs.* Implicit bindings are the bindings created for classes in the ``modules`` and ``classes`` args passed to ``new_object_graph()``.Pinject will prefer an explicit to an implicit binding... code-block:: python    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class Foo(object):    ...     pass    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('foo', to_instance='foo-instance')    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])    &gt;&gt;&gt; some_class = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class.foo    'foo-instance'    &gt;&gt;&gt;If you have two classes named the same thing, Pinject will have two different(and thus conflicting) implicit bindings.  But Pinject will not complainunless you try to use those bindings.  Pinject *will* complain if you try tocreate different (and thus conflicting) explicit bindings.Safety======Pinject tries to strike a balance between being helpful and being safe.Sometimes, you may want or need to change this balance.``new_object_graph()`` uses implicit bindings by default.  If you worry thatyou may accidentally inject a class or use a provider functionunintentionally, then you can make ``new_object_graph()`` ignore implicitbindings, by setting ``only_use_explicit_bindings=True``.  If you do so, thenPinject will only use explicit bindings.If you want to promote an implicit binding to be an explicit binding, you canannotate the corresponding class with ``@inject()``.  The ``@inject()``decorator lets you create explicit bindings without needing to create bindingspecs, as long as you can live with the binding defaults (e.g., no annotationson args, see below)... code-block:: python    &gt;&gt;&gt; class ExplicitlyBoundClass(object):    ...     @pinject.inject()    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class ImplicitlyBoundClass(object):    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('foo', to_instance='explicit-foo')    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()],    ...     only_use_explicit_bindings=True)    &gt;&gt;&gt; # obj_graph.provide(ImplicitlyBoundClass)  # would raise a NonExplicitlyBoundClassError    &gt;&gt;&gt; some_class = obj_graph.provide(ExplicitlyBoundClass)    &gt;&gt;&gt; print some_class.foo    'explicit-foo'    &gt;&gt;&gt;You can also promote an implicit binding to explicit by using``@annotated_arg()`` (see below), with or without ``@inject()`` as well.(Previous versions of Pinject included an ``@injectable`` decorator.  That isdeprecated in favor of ``@inject()``.  Note that ``@inject()`` needs parens,whereas ``@injectable`` didn't.)On the opposite side of permissiveness, Pinject by default will complain if aprovider method returns ``None``.  If you really want to turn off this defaultbehavior, you can pass ``allow_injecting_none=True`` to``new_object_graph()``.Annotations===========Pinject *annotations* let you have different objects injected for the same argname.  For instance, you may have two classes in different parts of yourcodebase named the same thing, and you want to use the same arg name indifferent parts of your codebase.On the arg side, an annotation tells Pinject only to inject using a bindingwhose binding key includes the annotation object.  You can use``@annotate_arg()`` on an initializer, or on a provider method, to specify theannotation object.On the binding side, an annotation changes the binding so that the key of thebinding includes the annotation object.  When using ``bind()`` in a bindingspec's ``configure()`` method, you can pass an ``annotated_with`` arg tospecify the annotation object... code-block:: python    &gt;&gt;&gt; class SomeClass(object):    ...     @pinject.annotate_arg('foo', 'annot')    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('foo', annotated_with='annot', to_instance='foo-with-annot')    ...         bind('foo', annotated_with=12345, to_instance='12345-foo')    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])    &gt;&gt;&gt; some_class = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class.foo    'foo-with-annot'    &gt;&gt;&gt;Also on the binding side, when defining a provider method, you can use the``@provides()`` decorator.  The decorator lets you pass an ``annotated_with``arg to specify the annotation object.  The decorator's first param,``arg_name`` also lets you override what arg name you want the provider to befor.  This is optional but useful if you want the same binding spec to havetwo provider methods for the same arg name but annotated differently.(Otherwise, the methods would need to be named the same, since they're for thesame arg name.).. code-block:: python    &gt;&gt;&gt; class SomeClass(object):    ...     @pinject.annotate_arg('foo', 'annot')    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     @pinject.provides('foo', annotated_with='annot')    ...     def provide_annot_foo(self):    ...         return 'foo-with-annot'    ...     @pinject.provides('foo', annotated_with=12345)    ...     def provide_12345_foo(self):    ...         return '12345-foo'    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])    &gt;&gt;&gt; some_class = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class.foo    'foo-with-annot'    &gt;&gt;&gt;When requiring a binding, via the ``require`` arg passed into the``configure()`` method of a binding spec, you can pass the arg``annotated_with`` to require an annotated binding... code-block:: python    &gt;&gt;&gt; class MainBindingSpec(pinject.BindingSpec):    ...     def configure(self, require):    ...         require('foo', annotated_with='annot')    ...    &gt;&gt;&gt; class NonSatisfyingBindingSpec(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('foo', to_instance='an-unannotated-foo')    ...    &gt;&gt;&gt; class SatisfyingBindingSpec(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('foo', annotated_with='annot', to_instance='an-annotated-foo')    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(    ...     binding_specs=[MainBindingSpec(), SatisfyingBindingSpec()])  # works    &gt;&gt;&gt; # obj_graph = pinject.new_object_graph(    ... #     binding_specs=[MainBindingSpec(),    ... #                    NonSatisfyingBindingSpec()])  # would raise a MissingRequiredBindingError    &gt;&gt;&gt;You can use any kind of object as an annotation object as long as itimplements ``__eq__()`` and ``__hash__()``.Scopes======By default, Pinject remembers the object it injected into a (possiblyannotated) arg, so that it can inject the same object into other args with thesame name.  This means that, for each arg name, a single instance of thebound-to class, or a single instance returned by a provider method, is createdby default... code-block:: python    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def provide_foo(self):    ...         return object()    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])    &gt;&gt;&gt; some_class_1 = obj_graph.provide(SomeClass)    &gt;&gt;&gt; some_class_2 = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class_1.foo is some_class_2.foo    True    &gt;&gt;&gt;In some cases, you may want to create new instances, always or sometimes,instead of reusing them each time they're injected.  If so, you want to use*scopes*.A scope controls memoization (i.e., caching).  A scope can choose to cachenever, sometimes, or always.Pinject has two built-in scopes.  *Singleton scope* (``SINGLETON``) is thedefault and always caches.  *Prototype scope* (``PROTOTYPE``) is the otherbuilt-in option and does no caching whatsoever.Every binding is associated with a scope.  You can specify a scope for abinding by decorating a provider method with ``@in_scope()``, or by passing an``in_scope`` arg to ``bind()`` in a binding spec's ``configure()`` method... code-block:: python    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     @pinject.provides(in_scope=pinject.PROTOTYPE)    ...     def provide_foo(self):    ...         return object()    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])    &gt;&gt;&gt; some_class_1 = obj_graph.provide(SomeClass)    &gt;&gt;&gt; some_class_2 = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class_1.foo is some_class_2.foo    False    &gt;&gt;&gt;If a binding specifies no scope explicitly, then it is in singleton scope.Implicit class bindings are always in singleton scope.Memoization of class bindings works at the class level, not at the binding keylevel.  This means that, if you bind two arg names (or the same arg name withtwo different annotations) to the same class, and the class is in a memoizingscope, then the same class instance will be provided when you inject thedifferent arg names... code-block:: python    &gt;&gt;&gt; class InjectedClass(object):    ...     pass    ...    &gt;&gt;&gt; class SomeObject(object):    ...     def __init__(self, foo, bar):    ...         self.foo = foo    ...         self.bar = bar    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('foo', to_class=InjectedClass)    ...         bind('bar', to_class=InjectedClass)    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(    ...     binding_specs=[SomeBindingSpec()])    &gt;&gt;&gt; some_object = obj_graph.provide(SomeObject)    &gt;&gt;&gt; print some_object.foo is some_object.bar    True    &gt;&gt;&gt;Pinject memoizes class bindings this way because this is more likely to bewhat you mean if you bind two different arg names to the same class insingleton scope: you want only one instance of the class, even though it maybe injected in multiple places.Provider bindings=================Sometimes, you need to inject not just a single instance of some class, butrather you need to inject the ability to create instances on demand.(Clearly, this is most useful when the binding you're using is not in thesingleton scope, otherwise you'll always get the same instance, and you may aswell just inject that..)You could inject the Pinject object graph, but you'd have to do thatdependency injection manually (Pinject doesn't inject itself!), and you'd beinjecting a huge set of capabilities when your class really only needs toinstantiate objects of one type.To solve this, Pinject creates *provider bindings* for each bound arg name.It will look at the arg name for the prefix ``provide_``, and if it finds thatprefix, it assumes you want to inject a provider function for whatever therest of the arg name is.  For instance, if you have an arg named``provide_foo_bar``, then Pinject will inject a zero-arg function that, whencalled, provides whatever the arg name ``foo_bar`` is bound to... code-block:: python    &gt;&gt;&gt; class Foo(object):    ...   def __init__(self):    ...     self.forty_two = 42    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def configure(self, bind):    ...         bind('foo', to_class=Foo, in_scope=pinject.PROTOTYPE)    ...    &gt;&gt;&gt; class NeedsProvider(object):    ...     def __init__(self, provide_foo):    ...         self.provide_foo = provide_foo    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])    &gt;&gt;&gt; needs_provider = obj_graph.provide(NeedsProvider)    &gt;&gt;&gt; print needs_provider.provide_foo() is needs_provider.provide_foo()    False    &gt;&gt;&gt; print needs_provider.provide_foo().forty_two    42    &gt;&gt;&gt;Pinject will always look for the ``provide_`` prefix as a signal to inject aprovider function, anywhere it injects dependencies (initializer args, bindingspec provider methods, etc.).  This does mean that it's quite difficult, say,to inject an instance of a class named ``ProvideFooBar`` into an arg named``provide_foo_bar``, but assuming you're naming your classes as noun phrasesinstead of verb phrases, this shouldn't be a problem.Watch out: don't confuse* *provider bindings*, which let you inject args named ``provide_something`` with provider functions; and* *provider methods*, which are methods of binding specs that provide instances of some arg name.Partial injection=================Provider bindings are useful when you want to create instances of a class ondemand.  But a zero arg provider function will always return an instanceconfigured the same way (within a given scope).  Sometimes, you want theability to parameterize the provided instances, e.g., based on run-time userconfiguration.  You want the ability to create instances where part of theinitialization data is provided per-instance at run-time and part of theinitialization data is injected as dependencies.To do this, other dependency injection libraries have you define factoryclasses.  You inject dependencies into the factory class's initializerfunction, and then you call the factory class's creation method with theper-instance data... code-block:: python    &gt;&gt;&gt; class WidgetFactory(object):    ...     def __init__(self, widget_polisher):    ...         self._widget_polisher = widget_polisher    ...     def new(self, color):  # normally would contain some non-trivial code...    ...         return some_function_of(self._widget_polisher, color)    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def provide_something_with_colored_widgets(self, colors, widget_factory):    ...         return SomethingWithColoredWidgets(    ...             [widget_factory.new(color) for color in colors])    ...    &gt;&gt;&gt;You can follow this pattern in Pinject, but it involves boring boilerplate forthe factory class, saving away the initializer-injected dependencies to beused in the creation method.  Plus, you have to create yet another``...Factory`` class, which makes you feel like you're programming in java,not python.As a less repetitive alternative, Pinject lets you use *partial injection* onthe provider functions returned by provider bindings.  You use the``@inject()`` decorator to tell Pinject ahead of time which args you expect topass directly (vs. automatic injection), and then you pass those args directlywhen calling the provider function... code-block:: python    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     @pinject.inject(['widget_polisher'])    ...     def provide_widget(self, color, widget_polisher):    ...         return some_function_of(widget_polisher, color)    ...     def provide_something_needing_widgets(self, colors, provide_widget):    ...         return SomethingNeedingWidgets(    ...             [provide_widget(color) for color in colors])    ...    &gt;&gt;&gt;The first arg to ``@inject()``, ``arg_names``, specifies which args of thedecorated method should be injected as dependencies.  If specified, it must bea non-empty sequence of names of the decorated method's args.  The remainingdecorated method args will be passed directly.In the example above, note that, although there is a method called``provide_widget()`` and an arg of ``provide_something_needing_widgets()``called ``provide_widget``, these are not exactly the same!  The latter is adependency-injected wrapper around the former.  The wrapper ensures that the``color`` arg is passed directly and then injects the ``widget_polisher``dependency.The ``@inject()`` decorator works to specify args passed directly both forprovider bindings to provider methods (as in the example above) and forprovider bindings to classes (where you can pass args directly to theinitializer, as in the example below)... code-block:: python    &gt;&gt;&gt; class Widget(object):    ...     @pinject.inject(['widget_polisher'])    ...     def __init__(self, color, widget_polisher):    ...         pass  # normally something involving color and widget_polisher    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def provide_something_needing_widgets(self, colors, provide_widget):    ...         return SomethingNeedingWidgets(    ...             [provide_widget(color) for color in colors])    ...    &gt;&gt;&gt;The ``@inject()`` decorator also takes an ``all_except`` arg.  You can usethis, instead of the (first positional) ``arg_names`` arg, if it's clearer andmore concise to say which args are *not* injected (i.e., which args are passeddirectly)... code-block:: python    &gt;&gt;&gt; class Widget(object):    ...     # equivalent to @pinject.inject(['widget_polisher']):    ...     @pinject.inject(all_except=['color'])    ...     def __init__(self, color, widget_polisher):    ...         pass  # normally something involving color and widget_polisher    ...    &gt;&gt;&gt;If both ``arg_names`` and ``all_except`` are omitted, then all args areinjected by Pinject, and none are passed directly.  (Both ``arg_names`` and``all_except`` may not be specified at the same time.)  Wildcard positionaland keyword args (i.e., ``*pargs`` and ``**kwargs``) are always passeddirectly, not injected.If you use ``@inject()`` to mark at least one arg of a provider method (orinitializer) as passed directly, then you may no longer directly inject thatprovider method's corresponding arg name.  You must instead use a providerbinding to inject a provider function, and then pass the required directarg(s), as in the examples above.Custom scopes=============If you want to, you can create your own custom scope.  A custom scope isuseful when you have some objects that need to be reused (i.e., cached) butwhose lifetime is shorter than the entire lifetime of your program.A custom scope is any class that implements the ``Scope`` interface... code-block:: python    class Scope(object):        def provide(self, binding_key, default_provider_fn):            raise NotImplementedError()The ``binding_key`` passed to ``provide()`` will be an object implementing``__eq__()`` and ``__hash__()`` but otherwise opaque (you shouldn't need tointrospect it).  You can think of the binding key roughly as encapsulating thearg name and annotation (if any).  The ``default_provider_fn`` passed to``provide()`` is a zero-arg function that, when called, provides an instanceof whatever should be provided.The job of a scope's ``provide()`` function is to return a cached object ifavailable and appropriate, otherwise to return (and possibly cache) the resultof calling the default provider function.Scopes almost always have other methods that control clearing the scope'scache.  For instance, a scope may have &quot;enter scope&quot; and &quot;exit scope&quot; methods,or a single direct &quot;clear cache&quot; method.  When passing a custom scope toPinject, your code should keep a handle to the custom scope and use thathandle to clear the scope's cache at the appropriate time.You can use one or more custom scopes by passing a map from *scope identifier*to scope as the ``id_to_scope`` arg of ``new_object_graph()``... code-block:: python    &gt;&gt;&gt; class MyScope(pinject.Scope):    ...     def __init__(self):    ...         self._cache = {}    ...     def provide(self, binding_key, default_provider_fn):    ...         if binding_key not in self._cache:    ...             self._cache[binding_key] = default_provider_fn()    ...         return self._cache[binding_key]    ...     def clear(self):    ...         self._cache = {}    ...    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     @pinject.provides(in_scope='my custom scope')    ...     def provide_foo(self):    ...         return object()    ...    &gt;&gt;&gt; my_scope = MyScope()    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(    ...     binding_specs=[SomeBindingSpec()],    ...     id_to_scope={'my custom scope': my_scope})    &gt;&gt;&gt; some_class_1 = obj_graph.provide(SomeClass)    &gt;&gt;&gt; some_class_2 = obj_graph.provide(SomeClass)    &gt;&gt;&gt; my_scope.clear()    &gt;&gt;&gt; some_class_3 = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class_1.foo is some_class_2.foo    True    &gt;&gt;&gt; print some_class_2.foo is some_class_3.foo    False    &gt;&gt;&gt;A scope identifier can be any object implementing ``__eq__()`` and``__hash__()``.If you plan to use Pinject in a multi-threaded environment (and even if youdon't plan to now but may some day), you should make your custom scopethread-safe.  The example custom scope above could be trivially (but moreverbosely) rewritten to be thread-safe, as in the example below.  The lock isreentrant so that something in ``MyScope`` can be injected into something elsein ``MyScope``... code-block:: python    &gt;&gt;&gt; class MyScope(pinject.Scope):    ...     def __init__(self):    ...         self._cache = {}    ...         self._rlock = threading.RLock()    ...     def provide(self, binding_key, default_provider_fn):    ...         with self._rlock:    ...             if binding_key not in self._cache:    ...                 self._cache[binding_key] = default_provider_fn()    ...             return self._cache[binding_key]    ...     def clear(self):    ...         with self._rlock:    ...             self._cache = {}    &gt;&gt;&gt;Scope accessibility===================To prevent yourself from injecting objects where they don't belong, you maywant to validate one object being injected into another w.r.t. scope.For instance, you may have created a custom scope for HTTP requests handled byyour program.  Objects in request scope would be cached for the duration of asingle HTTP request.  You may want to verify that objects in request scopenever get injected into objects in singleton scope.  Such an injection islikely not to make semantic sense, since it would make something tied to oneHTTP request be used for the duration of your program.Pinject lets you pass a validation function as the``is_scope_usable_from_scope`` arg to ``new_object_graph()``.  This functiontakes two scope identifiers and returns ``True`` iff an object in the firstscope can be injected into an object of the second scope... code-block:: python    &gt;&gt;&gt; class RequestScope(pinject.Scope):    ...     def start_request(self):    ...         self._cache = {}    ...     def provide(self, binding_key, default_provider_fn):    ...         if binding_key not in self._cache:    ...             self._cache[binding_key] = default_provider_fn()    ...         return self._cache[binding_key]    ...    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     @pinject.provides(in_scope=pinject.SINGLETON)    ...     def provide_foo(bar):    ...         return 'foo-' + bar    ...     @pinject.provides(in_scope='request scope')    ...     def provide_bar():    ...         return '-bar'    ...    &gt;&gt;&gt; def is_usable(scope_id_inner, scope_id_outer):    ...     return not (scope_id_inner == 'request scope' and    ...                 scope_id_outer == scoping.SINGLETON)    ...    &gt;&gt;&gt; my_request_scope = RequestScope()    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(    ...     binding_specs=[SomeBindingSpec()],    ...     id_to_scope={'request scope': my_request_scope},    ...     is_scope_usable_from_scope=is_usable)    &gt;&gt;&gt; my_request_scope.start_request()    &gt;&gt;&gt; # obj_graph.provide(SomeClass)  # would raise a BadDependencyScopeError    &gt;&gt;&gt;The default scope accessibility validator allows objects from any scope to beinjected into objects from any other scope.Changing naming conventions===========================If your code follows PEP8 naming coventions, then you're likely happy with thedefault implicit bindings (where the class ``FooBar`` gets bound to the argname ``foo_bar``) and where ``provide_foo_bar()`` is a binding spec's providermethod for the arg name ``foo_bar``.But if not, read on!Customizing implicit bindings-----------------------------``new_object_graph()`` takes a ``get_arg_names_from_class_name`` arg.  This isthe function that is used to determine implicit class bindings.  This functiontakes in a class name (e.g., ``FooBar``) and returns the arg names to whichthat class should be implicitly bound (e.g., ``['foo_bar']``).  Its defaultbehavior is described in the &quot;implicit class bindings&quot; section above, but thatdefault behavior can be overridden.For instance, suppose that your code uses a library that names many classeswith the leading letter X (e.g., ``XFooBar``), and you'd like to be able tobind that to a corresponding arg name without the leading X (e.g.,``foo_bar``)... code-block:: python    &gt;&gt;&gt; import re    &gt;&gt;&gt; def custom_get_arg_names(class_name):    ...     stripped_class_name = re.sub('^_?X?', '', class_name)    ...     return [re.sub('(?!^)([A-Z]+)', r'_\1', stripped_class_name).lower()]    ...    &gt;&gt;&gt; print custom_get_arg_names('XFooBar')    ['foo_bar']    &gt;&gt;&gt; print custom_get_arg_names('XLibraryClass')    ['library_class']    &gt;&gt;&gt; class OuterClass(object):    ...     def __init__(self, library_class):    ...         self.library_class = library_class    ...    &gt;&gt;&gt; class XLibraryClass(object):    ...     def __init__(self):    ...         self.forty_two = 42    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(    ...     get_arg_names_from_class_name=custom_get_arg_names)    &gt;&gt;&gt; outer_class = obj_graph.provide(OuterClass)    &gt;&gt;&gt; print outer_class.library_class.forty_two    42    &gt;&gt;&gt;The function passed as the ``get_arg_names_from_class_name`` arg to``new_object_graph()`` can return as many or as few arg names as it wants.  Ifit always returns the empty list (i.e., if it is ``lambda _: []``), then thatdisables implicit class bindings.Customizing binding spec method names-------------------------------------The standard binding spec methods to configure bindings and declaredependencies are named ``configure`` and ``dependencies``, by default.  If youneed to, you can change their names by passing ``configure_method_name``and/or ``dependencies_method_name`` as args to ``new_object_graph()``... code-block:: python    &gt;&gt;&gt; class NonStandardBindingSpec(pinject.BindingSpec):    ...     def Configure(self, bind):    ...         bind('forty_two', to_instance=42)    ...    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, forty_two):    ...         self.forty_two = forty_two    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(    ...     binding_specs=[NonStandardBindingSpec()],    ...     configure_method_name='Configure')    &gt;&gt;&gt; some_class = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class.forty_two    42    &gt;&gt;&gt;Customizing provider method names---------------------------------``new_object_graph()`` takes a ``get_arg_names_from_provider_fn_name`` arg.This is the function that is used to identify provider methods on bindingspecs.  This function takes in the name of a potential provider method (e.g.,``provide_foo_bar``) and returns the arg names for which the provider methodis a provider, if any (e.g., ``['foo_bar']``).  Its default behavior isdescribed in the &quot;provider methods&quot; section above, but that default behaviorcan be overridden.For instance, suppose that you work for a certain large corporation whosepython style guide makes you name functions in ``CamelCase``, and so you needto name the provider method for the arg name ``foo_bar`` more like``ProvideFooBar`` than ``provide_foo_bar``... code-block:: python    &gt;&gt;&gt; import re    &gt;&gt;&gt; def CustomGetArgNames(provider_fn_name):    ...     if provider_fn_name.startswith('Provide'):    ...         provided_camelcase = provider_fn_name[len('Provide'):]    ...         return [re.sub('(?!^)([A-Z]+)', r'_\1', provided_camelcase).lower()]    ...     else:    ...         return []    ...    &gt;&gt;&gt; print CustomGetArgNames('ProvideFooBar')    ['foo_bar']    &gt;&gt;&gt; print CustomGetArgNames('ProvideFoo')    ['foo']    &gt;&gt;&gt; class SomeClass(object):    ...     def __init__(self, foo):    ...         self.foo = foo    ...    &gt;&gt;&gt; class SomeBindingSpec(pinject.BindingSpec):    ...     def ProvideFoo(self):    ...         return 'some-foo'    ...    &gt;&gt;&gt; obj_graph = pinject.new_object_graph(    ...     binding_specs=[SomeBindingSpec()],    ...     get_arg_names_from_provider_fn_name=CustomGetArgNames)    &gt;&gt;&gt; some_class = obj_graph.provide(SomeClass)    &gt;&gt;&gt; print some_class.foo    'some-foo'    &gt;&gt;&gt;The function passed as the ``get_arg_names_from_provider_fn_name`` arg to``new_object_graph()`` can return as many or as few arg names as it wants.  Ifit returns an empty list, then that potential provider method is assumed notactually to be a provider method.Miscellaneous=============Pinject raises helpful exceptions whose messages include the file and linenumber of errors.  So, Pinject by default will shorten the stack trace ofexceptions that it raises, so that you don't see the many levels of functioncalls within the Pinject library.In some situations, though, the complete stack trace is helpful, e.g., whendebugging Pinject, or when your code calls Pinject, which calls back into yourcode, which calls back into Pinject.  In such cases, to disable exceptionstack shortening, you can pass ``use_short_stack_traces=False`` to``new_object_graph()``.Gotchas=======Pinject has a few things to watch out for.Thread safety-------------Pinject's default scope is ``SINGLETON``.  If you have a multi-threadedprogram, it's likely that some or all of the things that Pinject provides fromsingleton scope will be used in multiple threads.  So, it's important that youensure that such classes are thread-safe.Similarly, it's important that your custom scope classes are thread-safe.Even if the objects they provide are only used in a single thread, it may bethat the object graph (and therefore the scope itself) will be usedsimultaneously in multiple threads.Remember to make locks re-entrant on your custom scope classes, or otherwisedeal with one object in your custom scope trying to inject another object inyour custom scope.That's it for gotchas, for now.Condensed summary=================If you are already familiar with dependency injection libraries such as Guice,this section gives you a condensed high level summary of Pinject and how itmight be similar to or different than other dependency injection libraries.(If you don't understand it, no problem.  The rest of the documentation coverseverything listed here.)* Pinject uses code and decorators to configure injection, not a separate config file.* Bindings are keyed by arg name, (not class type, since Python is dynamically typed).* Pinject automatically creates bindings to ``some_class`` arg names for ``SomeClass`` classes.* You can ask Pinject only to create bindings from binding specs and classes whose ``__init__()`` is marked with ``@inject()``.* A binding spec is a class that creates explicit bindings.* A binding spec can bind arg names to classes or to instances.* A binding spec can bind arg names ``foo`` to provider methods ``provide_foo()``.* Binding specs can depend on (i.e., include) other binding specs.* You can annotate args and bindings to distinguish among args/bindings for the same arg name.* Pinject has two built-in scopes: &quot;singleton&quot; (always memoized; the default) and &quot;prototype&quot; (never memoized).* You can define custom scopes, and you can configure which scopes are accessible from which other scopes.* Pinject doesn't allow injecting ``None`` by default, but you can turn off that check.Changelog=========v0.13: masterv0.12: 28 Nov, 2018* Support Python 3* Add two maintainers: @trein and @huanv0.10.2:* Fixed bug: allows binding specs containing only provider methods.v0.10.1:* Fixed bug: allows omitting custom named ``configure()`` binding spec method.v0.10:* Added default ``__eq__()`` to ``BindingSpec``, so that DAG binding spec dependencies can have equal but not identical dependencies.* Allowed customizing ``configure()`` and ``dependencies()`` binding spec method names.* Deprecated ``@injectable`` in favor of ``@inject``.* Added partial injection.* Added ``require`` arg to allow binding spec ``configure`` methods to declare but not define bindings.* Sped up tests (and probably general functionality) by 10x.* Documented more design decisions.* Added ``@copy_args_to_internal_fields`` and ``@copy_args_to_public_fields``.* Renamed ``InjectableDecoratorAppliedToNonInitError`` to ``DecoratorAppliedToNonInitError``.v0.9:* Added validation of python types of public args.* Improved error messages for all Pinject-raised exceptions.* Added ``use_short_stack_traces`` arg to ``new_object_graph()``.* Allowed multiple ``@provides`` on single provider method.v0.8:* First released version.Maintainers===========* Kurt Steinkraus @kurt* Guilherme Trein @trein* Huan LI @huanLicense=======Apache-2.0Pinject and Google==================Though Google owns this project's copyright, this project is not an officialGoogle product.</longdescription>
</pkgmetadata>