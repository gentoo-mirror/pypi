<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/aiohttp-deps?style=for-the-badge)](https://pypi.org/project/aiohttp-deps/)[![PyPI](https://img.shields.io/pypi/v/aiohttp-deps?style=for-the-badge)](https://pypi.org/project/aiohttp-deps/)[![PyPI - Downloads](https://img.shields.io/pypi/dm/aiohttp-deps?style=for-the-badge)](https://pypistats.org/packages/aiohttp-deps)# AioHTTP depsThis project was initially created to show the abillities of [taskiq-dependencies](https://github.com/taskiq-python/taskiq-dependencies) project, which is used by [taskiq](https://github.com/taskiq-python/taskiq) to provide you with the best experience of sending distributed tasks.This project adds [FastAPI](https://github.com/tiangolo/fastapi)-like dependency injection to your [AioHTTP](https://github.com/aio-libs/aiohttp) application.To start using dependency injection, just initialize the injector.```pythonfrom aiohttp import webfrom aiohttp_deps import init as deps_initapp = web.Application()app.on_startup.append(deps_init)web.run_app(app)```If you use mypy, then we have a custom router with propper types.```pythonfrom aiohttp import webfrom aiohttp_deps import init as deps_initfrom aiohttp_deps import Routerrouter = Router()@router.get(&quot;/&quot;)async def handler():    return web.json_response({})app = web.Application()app.router.add_routes(router)app.on_startup.append(deps_init)web.run_app(app)```Also, you can nest routers with prefixes,```pythonapi_router = Router()memes_router = Router()main_router = Router()main_router.add_routes(api_router, prefix=&quot;/api&quot;)main_router.add_routes(memes_router, prefix=&quot;/memes&quot;)```## SwaggerIf you use dependencies in you handlers, we can easily generate swagger for you.We have some limitations:1. We don't support string type annotation for detecting required parameters in openapi. Like `a: &quot;Optional[int]&quot;`.2. We don't have support for 3.10 style Option annotations. E.G. `int | None`We will try to fix these limitations later.To enable swagger, just add it to your startup.```pythonfrom aiohttp_deps import init, setup_swaggerapp = web.Application()app.on_startup.extend([init, setup_swagger()])```## Default dependenciesBy default this library provides only two injectables. `web.Request` and `web.Application`.```pythonasync def handler(app: web.Application = Depends()): ...async def handler2(request: web.Request = Depends()): ...```It's super useful, because you can use these dependencies inany other dependency. Here's a more complex example of how you can use this library.```pythonfrom aiohttp_deps import Router, Dependsfrom aiohttp import webrouter = Router()async def get_db_session(app: web.Application = Depends()):    async with app[&quot;db&quot;] as sess:        yield sessclass MyDAO:    def __init__(self, session=Depends(get_db_session)):        self.session = session    async def get_objects(self) -&gt; list[object]:        return await self.session.execute(&quot;SELECT 1&quot;)@router.get(&quot;/&quot;)async def handler(db_session: MyDAO = Depends()):    objs = await db_session.get_objects()    return web.json_response({&quot;objects&quot;: objs})```If you do something like this, you would never think about initializing your DAO. You can just inject it and that's it.# Built-in dependenciesThis library also provides you with some default dependencies that can help you in building the best web-service.## JsonTo parse json, create a pydantic model and add a dependency to your handler.```pythonfrom aiohttp import webfrom pydantic import BaseModelfrom aiohttp_deps import Router, Json, Dependsrouter = Router()class UserInfo(BaseModel):    name: str@router.post(&quot;/users&quot;)async def new_data(user: UserInfo = Depends(Json())):    return web.json_response({&quot;user&quot;: user.dict()})```This dependency automatically validates data and senderrors if the data doesn't orrelate with schema or body is not a valid json.If you want to make this data optional, just mark it as optional.```python@router.post(&quot;/users&quot;)async def new_data(user: Optional[UserInfo] = Depends(Json())):    if user is None:        return web.json_response({&quot;user&quot;: None})    return web.json_response({&quot;user&quot;: user.dict()})```## HeadersYou can get and validate headers using `Header` dependency.Let's try to build simple example for authorization.```pythonfrom aiohttp_deps import Router, Header, Dependsfrom aiohttp import webrouter = Router()def decode_token(authorization: str = Depends(Header())) -&gt; str:    if authorization == &quot;secret&quot;:        # Let's pretend that here we        # decode our token.        return authorization    raise web.HTTPUnauthorized()@router.get(&quot;/secret_data&quot;)async def new_data(token: str = Depends(decode_token)) -&gt; web.Response:    return web.json_response({&quot;secret&quot;: &quot;not a secret&quot;})```As you can see, header name to parse is equal to thename of a parameter that introduces Header dependency.If you want to use some name that is not allowed in python, or just want to have different names, you can use alias. Like this:```pythondef decode_token(auth: str = Depends(Header(alias=&quot;Authorization&quot;))) -&gt; str:```Headers can also be parsed to types. If you want a header to be parsed as int, just add the typehint.```pythondef decode_token(meme_id: int = Depends(Header())) -&gt; str:```If you want to get list of values of one header, use parameter `multiple=True`.```pythondef decode_token(meme_id: list[int] = Depends(Header(multiple=True))) -&gt; str:```And, of course, you can provide this dependency with default value if the value from user cannot be parsed for some reason.```pythondef decode_token(meme_id: str = Depends(Header(default=&quot;not-a-secret&quot;))) -&gt; str:```## QueriesYou can depend on `Query` to get and parse query parameters.```pythonfrom aiohttp_deps import Router, Query, Dependsfrom aiohttp import webrouter = Router()@router.get(&quot;/shop&quot;)async def shop(item_id: str = Depends(Query())) -&gt; web.Response:    return web.json_response({&quot;id&quot;: item_id})```the name of the parameter is the same as the name of function parameter.The Query dependency is acually the same as the Header dependency, so everything about the `Header` dependency also applies to `Query`.## ViewsIf you use views as handlers, please use View class from `aiohttp_deps`, otherwise the magic won't work.```pythonfrom aiohttp_deps import Router, View, Dependsfrom aiohttp import webrouter = Router()@router.view(&quot;/view&quot;)class MyView(View):    async def get(self, app: web.Application = Depends()):        return web.json_response({&quot;app&quot;: str(app)})```## FormsNow you can easiy get and validate form data from your request.To make the magic happen, please add `arbitrary_types_allowed` to the config of your model.```pythonfrom pydantic import BaseModelfrom aiohttp_deps import Router, Depends, Formfrom aiohttp import webrouter = Router()class MyForm(BaseModel):    id: int    file: web.FileField    class Config:        arbitrary_types_allowed = True@router.post(&quot;/&quot;)async def handler(my_form: MyForm = Depends(Form())):    with open(&quot;my_file&quot;, &quot;wb&quot;) as f:        f.write(my_form.file.file.read())    return web.json_response({&quot;id&quot;: my_form.id})```## PathIf you have path variables, you can also inject them in your handler.```pythonfrom aiohttp_deps import Router, Path, Dependsfrom aiohttp import webrouter = Router()@router.get(&quot;/view/{var}&quot;)async def my_handler(var: str = Depends(Path())):    return web.json_response({&quot;var&quot;: var})```## Overridiing dependenciesSometimes for tests you don't want to calculate actual functionsand you want to pass another functions instead.To do so, you can add &quot;dependency_overrides&quot; key to the aplication.It's a dict that is passed as additional context to dependency resolvers.Here's an example.```pythondef original_dep() -&gt; int:    return 1class MyView(View):    async def get(self, num: int = Depends(original_dep)):        &quot;&quot;&quot;Nothing.&quot;&quot;&quot;        return web.json_response({&quot;request&quot;: num})```Imagine you have a handler that depends on some function,but instead of `1` you want to have `2` in your tests.To do it, jsut add `dependency_overrides` somewhere,where you create your application. And make sure that keysof that dict are actual function that are being replaced.```python    my_app[&quot;dependency_overrides&quot;] = {original_dep: 2}```</longdescription>
</pkgmetadata>