<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>ðŸ”€pipelineðŸ”€============.. image:: https://badge.fury.io/py/tanbih-pipeline.svg    :target: https://badge.fury.io/py/tanbih-pipeline.. image:: https://readthedocs.org/projects/tanbih-pipeline/badge/?version=latest    :target: https://tanbih-pipeline.readthedocs.io/en/latest/?badge=latest    :alt: Documentation Status.. image:: https://sonarcloud.io/api/project_badges/measure?project=yifan_pipeline&amp;metric=sqale_rating    :target: https://sonarcloud.io/api/project_badges/measure?project=yifan_pipeline&amp;metric=sqale_rating    :alt: Maintainability ScorePipeline provides an unified interface to set up data stream processing systems with Kafka, Pulsar,RabbitMQ, Redis and many more. The idea is to free developer from the dynamic change of technologyin deployment, so that a docker image released for a certain task can be used with Kafka or Redisthrough changes of environment variables.Features--------- a unified interface from Kakfa to Pulsar, from Redis to MongoDB- components connection controlled via command line, or environment variables- support file and in-memory for testingRequirements------------- Python 3.7, 3.8Installation------------.. code-block:: bash    $ pip install tanbih-pipelineYou can install the required backend dependencies with:.. code-block:: bash    $ pip install tanbih-pipeline[redis]    $ pip install tanbih-pipeline[kafka]    $ pip install tanbih-pipeline[pulsar]    $ pip install tanbih-pipeline[rabbitmq]    $ pip install tanbih-pipeline[elastic]    $ pip install tanbih-pipeline[mongodb]If you want to support all backends, you can:.. code-block:: bash    $ pip install tanbih-pipeline[full]Producer---------Producer is to be used when developing a data source in our pipeline. A sourcewill produce output without input. A crawler can be seen as a producer... code-block:: python    &gt;&gt;&gt; from typing import Generator    &gt;&gt;&gt; from pydantic import BaseModel    &gt;&gt;&gt; from pipeline import Producer as Worker, ProducerSettings as Settings    &gt;&gt;&gt;    &gt;&gt;&gt; class Output(BaseModel):    ...     key: int    &gt;&gt;&gt;    &gt;&gt;&gt; class MyProducer(Worker):    ...     def generate(self) -&gt; Generator[Output, None, None]:    ...         for i in range(10):    ...             yield Output(key=i)    &gt;&gt;&gt;    &gt;&gt;&gt; settings = Settings(name='producer', version='0.0.0', description='')    &gt;&gt;&gt; producer = MyProducer(settings, output_class=Output)    &gt;&gt;&gt; producer.parse_args(&quot;--out-kind MEM --out-topic test&quot;.split())    &gt;&gt;&gt; producer.start()    &gt;&gt;&gt; [r.get('key') for r in producer.destination.results]    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]Processor---------Processor is to be used to process input. Modification will be in-place. A processorcan produce one output for each input, or no output... code-block:: python    &gt;&gt;&gt; from pydantic import BaseModel    &gt;&gt;&gt; from pipeline import Processor as Worker, ProcessorSettings as Settings    &gt;&gt;&gt;    &gt;&gt;&gt; class Input(BaseModel):    ...     temperature: float    &gt;&gt;&gt;    &gt;&gt;&gt; class Output(BaseModel):    ...     is_hot: bool    &gt;&gt;&gt;    &gt;&gt;&gt; class MyProcessor(Worker):    ...     def process(self, content, key):    ...         is_hot = (content.temperature &gt; 25)    ...         return Output(is_hot=is_hot)    &gt;&gt;&gt;    &gt;&gt;&gt; settings = Settings(name='processor', version='0.1.0', description='')    &gt;&gt;&gt; processor = MyProcessor(settings, input_class=Input, output_class=Output)    &gt;&gt;&gt; args = &quot;--in-kind MEM --in-topic test --out-kind MEM --out-topic test&quot;.split()    &gt;&gt;&gt; processor.parse_args(args)    &gt;&gt;&gt; processor.start()Splitter--------Splitter is to be used when writing to multiple outputs. It will take a function togenerate output topic based on the processing message, and use it when writing output... code-block:: python    &gt;&gt;&gt; from pipeline import Splitter as Worker, SplitterSettings as Settings    &gt;&gt;&gt;    &gt;&gt;&gt; class MySplitter(Worker):    ...     def get_topic(self, msg):    ...         return '{}-{}'.format(self.destination.topic, msg.get('id'))    &gt;&gt;&gt;    &gt;&gt;&gt; settings = Settings(name='splitter', version='0.1.0', description='')    &gt;&gt;&gt; splitter = MySplitter(settings)    &gt;&gt;&gt; args = &quot;--in-kind MEM --in-topic test --out-kind MEM --out-topic test&quot;.split()    &gt;&gt;&gt; splitter.parse_args(args)    &gt;&gt;&gt; splitter.start()Usage-----Choosing backend technology:+-----------+----------------+---------+--------+-------+|           |                |  multi- | shared | data  || kind      |  description   |  reader | reader | expire|+===========+================+=========+========+=======+| LREDIS    |  Redis List    |    X    |    X   | read  |+-----------+----------------+---------+--------+-------+| XREDIS    |  Redis Stream  |    X    |    X   | limit |+-----------+----------------+---------+--------+-------+| KAFKA     |  Kafka         |    X    |    X   | read  |+-----------+----------------+---------+--------+-------+| PULSAR    |  Pulsar        |    X    |    X   | ttl   |+-----------+----------------+---------+--------+-------+| RABBITMQ  |  RabbitMQ      |    X    |        | read  |+-----------+----------------+---------+--------+-------+| ELASTIC   |  ElasticSearch |         |        |       |+-----------+----------------+---------+--------+-------+| MONGODB   |  MongoDB       |         |        |       |+-----------+----------------+---------+--------+-------+| FILE*     |  json,csv      |         |        |       |+-----------+----------------+---------+--------+-------+| MEM*      |  memory        |         |        |       |+-----------+----------------+---------+--------+-------+* FILE accepts jsonl input on stdin and with filename, it also accepts csv file.   Both format can be gzipped.* MEM read and write to memory, designed for unit tests... code-block:: shell    # check command line arguments for certain input and output    worker.py --in-kind FILE --help    # or    IN_KIND=FILE worker.py    # or    export IN_KIND=FILE    worker.py --help    # process input from file and output to stdout (--in-content-only is    # needed for this version)    worker.py --in-kind FILE --in-filename data.jsonl --in-content-only \              --out-kind FILE --out-filename -    # read from file and write to KAFKA    worker.py --in-kind FILE --in-filename data.jsonl --in-content-only \              --out-kind KAFKA --out-namespace test --out-topic articles \              --out-kafka kafka_url --out-config kafka_config_jsonArguments*********common    debug    monitoring    kind    namespace    topicinput:FILEScripts*******`pipeline-copy` is a script to copy data from a source to a destination. It canbe used to inject data from a file to a database, or from a database to anotherdatabase. It is implemented as a Pipeline worker.Since JSON format does not support datetimes, in order for `pipeline-copy` totreat datetime field as datetime instead of string, you can provide a modeldefinition via argument `--model-definition`. An example of such model definitionis as following (the class name needs to be `Model`):.. code-block:: shell    from datetime import datetime    from typing import Optional    from pydantic import BaseModel    class Model(BaseModel):        hashtag: str        username: str        text: str        tweet_id: str        location: Optional[str]        created_at: datetime        retweet_count: intEnvironment Variables*********************Application accepts following environment variables(Please note, you will need to add prefix `IN_`, `--in-` and`OUT_`, `--out-` to these variables to indicate the option forinput and output). Please refer to backend documentation foravailable arguments/environment variables.Customize Settings******************.. code-block:: python    class CustomSettings(Settings):        new_argument: str = Field(&quot;&quot;, title=&quot;a new argument for custom settings&quot;)    class CustomProcessor(Processor):        def __init__(self):            settings = CustomSettings(&quot;worker&quot;, &quot;v0.1.0&quot;, &quot;custom processor&quot;)            super().__init__(settings, input_class=BaseModel, output_class=BaseModel)Errors******PipelineError will be raised when error occurs Contribute----------Use `pre-commit` to run `black` and `flake8`Credits-------Yifan Zhang (yzhang at hbku.edu.qa)</longdescription>
</pkgmetadata>