<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Firedantic[![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/ioxiocom/firedantic/publish.yaml)](https://github.com/ioxiocom/firedantic/actions/workflows/publish.yaml)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![PyPI](https://img.shields.io/pypi/v/firedantic)](https://pypi.org/project/firedantic/)[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/firedantic)](https://pypi.org/project/firedantic/)[![License: BSD 3-Clause](https://img.shields.io/badge/License-BSD%203--Clause-blue.svg)](https://opensource.org/licenses/BSD-3-Clause)Database models for Firestore using Pydantic base models.## InstallationThe package is available on PyPI:```bashpip install firedantic```## UsageIn your application you will need to configure the firestore db client and optionallythe collection prefix, which by default is empty.```pythonfrom os import environfrom unittest.mock import Mockimport google.auth.credentialsfrom firedantic import configurefrom google.cloud.firestore import Client# Firestore emulator must be running if using locally.if environ.get(&quot;FIRESTORE_EMULATOR_HOST&quot;):    client = Client(        project=&quot;firedantic-test&quot;,        credentials=Mock(spec=google.auth.credentials.Credentials)    )else:    client = Client()configure(client, prefix=&quot;firedantic-test-&quot;)```Once that is done, you can start defining your Pydantic models, e.g:```pythonfrom pydantic import BaseModelfrom firedantic import Modelclass Owner(BaseModel):    &quot;&quot;&quot;Dummy owner Pydantic model.&quot;&quot;&quot;    first_name: str    last_name: strclass Company(Model):    &quot;&quot;&quot;Dummy company Firedantic model.&quot;&quot;&quot;    __collection__ = &quot;companies&quot;    company_id: str    owner: Owner# Now you can use the model to save it to Firestoreowner = Owner(first_name=&quot;John&quot;, last_name=&quot;Doe&quot;)company = Company(company_id=&quot;1234567-8&quot;, owner=owner)company.save()# Prints out the firestore ID of the Company modelprint(company.id)```Querying is done via a MongoDB-like `find()`:```pythonfrom firedantic import Modelimport firedantic.operators as opclass Product(Model):    __collection__ = &quot;products&quot;    product_id: str    stock: intProduct.find({&quot;product_id&quot;: &quot;abc-123&quot;})Product.find({&quot;stock&quot;: {&quot;&gt;=&quot;: 3}})# orProduct.find({&quot;stock&quot;: {op.GTE: 3}})```The query operators are found at[https://firebase.google.com/docs/firestore/query-data/queries#query_operators](https://firebase.google.com/docs/firestore/query-data/queries#query_operators).### Async usageFiredantic can also be used in an async way, like this:```pythonimport asynciofrom os import environfrom unittest.mock import Mockimport google.auth.credentialsfrom google.cloud.firestore import AsyncClientfrom firedantic import AsyncModel, configure# Firestore emulator must be running if using locally.if environ.get(&quot;FIRESTORE_EMULATOR_HOST&quot;):    client = AsyncClient(        project=&quot;firedantic-test&quot;,        credentials=Mock(spec=google.auth.credentials.Credentials),    )else:    client = AsyncClient()configure(client, prefix=&quot;firedantic-test-&quot;)class Person(AsyncModel):    __collection__ = &quot;persons&quot;    name: strasync def main():    alice = Person(name=&quot;Alice&quot;)    await alice.save()    print(f&quot;Saved Alice as {alice.id}&quot;)    bob = Person(name=&quot;Bob&quot;)    await bob.save()    print(f&quot;Saved Bob as {bob.id}&quot;)    found_alice = await Person.find_one({&quot;name&quot;: &quot;Alice&quot;})    print(f&quot;Found Alice: {found_alice.id}&quot;)    assert alice.id == found_alice.id    found_bob = await Person.get_by_id(bob.id)    assert bob.id == found_bob.id    print(f&quot;Found Bob: {found_bob.id}&quot;)    await alice.delete()    print(&quot;Deleted Alice&quot;)    await bob.delete()    print(&quot;Deleted Bob&quot;)if __name__ == &quot;__main__&quot;:    asyncio.run(main())```## SubcollectionsSubcollections in Firestore are basically dynamically named collections.Firedantic supports them via the `SubCollection` and `SubModel` classes, by creatingdynamic classes with collection name determined based on the &quot;parent&quot; class it is inreference to using the `model_for()` method.```pythonfrom typing import Optional, Typefrom firedantic import AsyncModel, AsyncSubCollection, AsyncSubModel, ModelNotFoundErrorclass UserStats(AsyncSubModel):    id: Optional[str] = None    purchases: int = 0    class Collection(AsyncSubCollection):        # Can use any properties of the &quot;parent&quot; model        __collection_tpl__ = &quot;users/{id}/stats&quot;class User(AsyncModel):    __collection__ = &quot;users&quot;    name: strasync def get_user_purchases(user_id: str, period: str = &quot;2021&quot;) -&gt; int:    user = await User.get_by_id(user_id)    stats_model: Type[UserStats] = UserStats.model_for(user)    try:        stats = await stats_model.get_by_id(period)    except ModelNotFoundError:        stats = stats_model()    return stats.purchases```## TTL PoliciesFiredantic has support for defining TTL policies and creating the policies.The field used for the TTL policy should be a datetime field and the name of the fieldshould be defined in `__ttl_field__`. The `set_up_ttl_policies` and`async_set_up_ttl_policies` functions are used to set up the policies.Below are examples (both sync and async) to show how to use Firedantic to set up the TTLpolicies.Note: The TTL policies can not be set up in the Firestore emulator.### TTL Policy Example (sync)```pythonfrom datetime import datetimefrom firedantic import Model, configure, get_all_subclasses, set_up_ttl_policiesfrom google.cloud.firestore import Clientfrom google.cloud.firestore_admin_v1 import FirestoreAdminClientclass ExpiringModel(Model):    __collection__ = &quot;expiringModel&quot;    __ttl_field__ = &quot;expire&quot;    expire: datetime    content: strdef main():    configure(Client(), prefix=&quot;firedantic-test-&quot;)    set_up_ttl_policies(        gcloud_project=&quot;my-project&quot;,        models=get_all_subclasses(Model),        client=FirestoreAdminClient(),    )if __name__ == &quot;__main__&quot;:    main()```### TTL Policy Example (async)```pythonimport asynciofrom datetime import datetimefrom firedantic import (    AsyncModel,    async_set_up_ttl_policies,    configure,    get_all_subclasses,)from google.cloud.firestore import AsyncClientfrom google.cloud.firestore_admin_v1.services.firestore_admin import (    FirestoreAdminAsyncClient,)class ExpiringModel(AsyncModel):    __collection__ = &quot;expiringModel&quot;    __ttl_field__ = &quot;expire&quot;    expire: datetime    content: strasync def main():    configure(AsyncClient(), prefix=&quot;firedantic-test-&quot;)    await async_set_up_ttl_policies(        gcloud_project=&quot;my-project&quot;,        models=get_all_subclasses(AsyncModel),        client=FirestoreAdminAsyncClient(),    )if __name__ == &quot;__main__&quot;:    asyncio.run(main())```## DevelopmentPRs are welcome!To run tests locally, you should run:```bashpoetry installpoetry run invoke test```### Running Firestore emulatorTo run the Firestore emulator locally you will need:- [Firebase CLI](https://firebase.google.com/docs/cli)To install the `firebase` CLI run:```bashnpm install -g firebase-tools```Run the Firestore emulator with a predictable port:```bash./start_emulator.sh# or on Windows run the .bat filestart_emulator```### About sync and async versions of libraryAlthough this library provides both sync and async versions of models, please keep inmind that you need to explicitly maintain only async version of it. The synchronousversion is generated automatically by invoke task:```bashpoetry run invoke unasync```We decided to go this way in order to:- make sure both versions have the same API- reduce human error factor- avoid working on two code bases at the same time to reduce maintenance effortThus, please make sure you don't modify any of files under[firedantic/\_sync](./firedantic/_sync) and[firedantic/tests/tests_sync](./firedantic/tests/tests_sync) by hands. `unasync` is alsorunning as part of pre-commit hooks, but in order to run the latest version of tests youhave to run it manually.## LicenseThis code is released under the BSD 3-Clause license. Details in the[LICENSE](./LICENSE) file.</longdescription>
</pkgmetadata>