<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># python-daachorse[daachorse](https://github.com/daac-tools/daachorse) is a fast implementation of the Aho-Corasick algorithm using the compact double-array data structure.This is a Python wrapper.[![PyPI](https://img.shields.io/pypi/v/daachorse)](https://pypi.org/project/daachorse/)[![Build Status](https://github.com/vbkaisetsu/python-daachorse/actions/workflows/CI.yml/badge.svg)](https://github.com/vbkaisetsu/python-daachorse/actions)[![Documentation Status](https://readthedocs.org/projects/python-daachorse/badge/?version=latest)](https://python-daachorse.readthedocs.io/en/latest/?badge=latest)## Installation### Install pre-built package from PyPIRun the following command:```$ pip install daachorse```### Build from sourceYou need to install the Rust compiler following [the documentation](https://www.rust-lang.org/tools/install) beforehand.daachorse uses `pyproject.toml`, so you also need to upgrade pip to version 19 or later.```$ pip install --upgrade pip```After setting up the environment, you can install daachorse as follows:```$ pip install git+https://github.com/daac-tools/python-daachorse```## Example usageDaachorse contains some search options,ranging from basic matching with the Aho-Corasick algorithm to trickier matching.All of them will run very fast based on the double-array data structure andcan be easily plugged into your application as shown below.### Finding overlapped occurrencesTo search for all occurrences of registered patternsthat allow for positional overlap in the input text,use `find_overlapping()`. When you instantiate a new automaton,unique identifiers are assigned to each pattern in the input order.The match result has the character positions of the occurrence and its identifier.```python&gt;&gt; import daachorse&gt;&gt; patterns = ['bcd', 'ab', 'a']&gt;&gt; pma = daachorse.Automaton(patterns)&gt;&gt; pma.find_overlapping('abcd')[(0, 1, 2), (0, 2, 1), (1, 4, 0)]```### Finding non-overlapped occurrences with standard matchingIf you do not want to allow positional overlap, use `find()` instead.It performs the search on the Aho-Corasick automatonand reports patterns first found in each iteration.```python&gt;&gt; import daachorse&gt;&gt; patterns = ['bcd', 'ab', 'a']&gt;&gt; pma = daachorse.Automaton(patterns)&gt;&gt; pma.find('abcd')[(0, 1, 2), (1, 4, 0)]```### Finding non-overlapped occurrences with longest matchingIf you want to search for the longest pattern without positional overlap in each iteration,use `MATCH_KIND_LEFTMOST_LONGEST` in the construction.```python&gt;&gt; import daachorse&gt;&gt; patterns = ['ab', 'a', 'abcd']&gt;&gt; pma = daachorse.Automaton(patterns, daachorse.MATCH_KIND_LEFTMOST_LONGEST)&gt;&gt; pma.find('abcd')[(0, 4, 2)]```### Finding non-overlapped occurrences with leftmost-first matchingIf you want to find the the earliest registered patternamong ones starting from the search position,use `MATCH_KIND_LEFTMOST_FIRST`.This is so-called *the leftmost first match*, a bit tricky search option.For example, in the following code,`ab` is reported because it is the earliest registered one.```python&gt;&gt; import daachorse&gt;&gt; patterns = ['ab', 'a', 'abcd']&gt;&gt; pma = daachorse.Automaton(patterns, daachorse.MATCH_KIND_LEFTMOST_FIRST)&gt;&gt; pma.find('abcd')[(0, 2, 0)]```## LicenseLicensed under either of * Apache License, Version 2.0   ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0) * MIT license   ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)at your option.</longdescription>
</pkgmetadata>