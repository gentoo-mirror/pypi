<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># solc-ast[![Pypi Status](https://img.shields.io/pypi/v/py-solc-ast.svg)](https://pypi.org/project/py-solc-ast/) [![Build Status](https://img.shields.io/github/workflow/status/iamdefinitelyahuman/py-solc-ast/main%20workflow/master)](https://github.com/iamdefinitelyahuman/py-solc-ast/actions) [![Coverage Status](https://img.shields.io/codecov/c/github/iamdefinitelyahuman/py-solc-ast)](https://codecov.io/gh/iamdefinitelyahuman/py-solc-ast)A tool for exploring the Solidity abstrax syntrax tree as generated by the [solc](https://github.com/ethereum/solidity) compiler.## InstallationYou can install the latest release via `pip`:```bash$ pip install py-solc-ast```Or clone the repo and use `setuptools`:```bash$ python setup.py install```## UsageFirst, use [py-solc-x](https://github.com/iamdefinitelyahuman/py-solc-x) to compile your contracts to the [standard JSON output format](https://solidity.readthedocs.io/en/latest/using-the-compiler.html#output-description).```python&gt;&gt;&gt; import json&gt;&gt;&gt; import solcx&gt;&gt;&gt; input_json = json.load(open('input.json'))&gt;&gt;&gt; output_json = solcx.compile_standard(input_json)```Next, import `solcast` and initialize using `from_standard_output_json` or `from_standard_output`. This returns a list of `SourceUnit` objects, which each represent the base AST node in a Solidity source file.```python&gt;&gt;&gt; import solcast&gt;&gt;&gt; nodes = solcast.from_standard_output(output_json)&gt;&gt;&gt; nodes[&lt;SourceUnit iterable 'contracts/Token.sol'&gt;, &lt;SourceUnit iterable 'contracts/SafeMath.sol'&gt;]```You can also generate a single `SourceUnit` directly from that source's AST:```python&gt;&gt;&gt; import solcast&gt;&gt;&gt; node = solcast.from_ast(output_json[&quot;sources&quot;][&quot;contracts/Token.sol&quot;][&quot;ast&quot;])&gt;&gt;&gt; node&lt;SourceUnit iterable 'contracts/Token.sol'&gt;```### Interacting with NodesEach node has the following attributes:```python&gt;&gt;&gt; node&lt;FunctionDefinition iterable 'mul'&gt;&gt;&gt;&gt; node.depth  # Number of nodes between this node and the SourceUnit2&gt;&gt;&gt; node.offset  # Absolute source offsets as a (start, stop) tuple(1693, 2151)&gt;&gt;&gt; node.contract_id  # Contract ID as given by the standard compiler JSON2&gt;&gt;&gt; node.fields  # List of fields for this node['baseNodeType', 'documentation', 'id', 'implemented', 'kind', 'modifiers', 'name', 'nodeType', 'nodes', 'parameters', 'returnParameters', 'scope', 'src', 'stateMutability', 'superFunction', 'visibility']```Fields mostly follow the expected [AST grammar](https://solidity.readthedocs.io/en/latest/miscellaneous.html#language-grammar). One notable difference: `Block` nodes are omitted and the body of each `Block` is available within it's parent as the attribute `nodes`. Nodes containing a body are iterable and can be accessed with list-like syntax. Additionally, any child node with a `name` field is accessible using dict-like syntax.The following additional fields are also available:* Most nodes have a `baseNodeType` field as defined in [grammar.py](solcast/grammar.py)* `ContractDefinition` nodes have `dependencies` and `libraries` fields that point to related `ContractDefition` nodesSome Examples:```python&gt;&gt;&gt; source_node&lt;SourceUnit iterable 'contracts/math/SafeMath.sol'&gt;&gt;&gt;&gt; source_node.keys()['absolutePath', 'children', 'contract_id', 'depth', 'exportedSymbols', 'id', 'is_child_of', 'is_parent_of', 'keys', 'nodeType', 'nodes', 'offset', 'parent', 'parents', 'src']&gt;&gt;&gt; source_node.nodes[&lt;PragmaDirective object&gt;, &lt;ContractDefinition iterable 'SafeMath'&gt;]&gt;&gt;&gt; source_node[1]&lt;ContractDefinition iterable 'SafeMath'&gt;&gt;&gt;&gt; source_node['SafeMath']&lt;ContractDefinition iterable 'SafeMath'&gt;&gt;&gt;&gt; source_node['SafeMath'].keys()['baseContracts', 'children', 'contractDependencies', 'contractKind', 'contract_id', 'dependencies', 'depth', 'documentation', 'fullyImplemented', 'id', 'is_child_of', 'is_parent_of', 'keys', 'libraries', 'linearizedBaseContracts', 'name', 'nodeType', 'nodes', 'offset', 'parent', 'parents', 'scope', 'src']&gt;&gt;&gt; source_node['SafeMath'].nodes[&lt;FunctionDefinition iterable 'add'&gt;, &lt;FunctionDefinition iterable 'sub'&gt;, &lt;FunctionDefinition iterable 'mul'&gt;, &lt;FunctionDefinition iterable 'div'&gt;, &lt;FunctionDefinition iterable 'mod'&gt;]&gt;&gt;&gt; source_node['SafeMath']['mul']&lt;FunctionDefinition iterable 'mul'&gt;&gt;&gt;&gt; source_node['SafeMath']['mul'][&lt;IfStatement object&gt;, &lt;VariableDeclarationStatement object&gt;, &lt;FunctionCall object&gt;, &lt;Return object&gt;]```### Exploring the TreeThe `Node.children()` method is used to search and filter through child nodes of a given node. It takes any of the following keyword arguments:* `depth`: Number of levels of children to traverse. `0` returns only this node.* `include_self`: Includes this node in the results.* `include_parents`: Includes nodes that match in the results, when they also have child nodes that match.* `include_children`: If True, as soon as a match is found it's children will not be included in the search.* `required_offset`: Only match nodes with a source offset that contains this offset.* `offset_limits`: Only match nodes when their source offset is contained inside this source offset.* `filters`: Dictionary of `{'attribute': &quot;value&quot;}` that children must match. Can also be given as a list of dicts, children that match any of the dicts will be returned.* `exclude_filter`: Dictionary of `{'attribute': &quot;value&quot;}` that children cannot match.```python&gt;&gt;&gt; node = s['Token']['transfer']&gt;&gt;&gt; node.children(    include_children=False,    filters={'nodeType': &quot;FunctionCall&quot;, &quot;expression.name&quot;: &quot;require&quot;})[&lt;FunctionCall&gt;]````Node.parent()` and `Node.parents()` are used to travel back up the tree. They take the following arguments:* `depth`: Depth limit. If given as a negative value, it will be subtracted from this object's depth.* `filters`: Dictionary of `{'attribute': &quot;value&quot;}` that parents must match.`Node.parent()` returns one result, `Node.parents()` returns a list of matches.```python&gt;&gt;&gt; node.parents()[&lt;ContractDefinition iterable 'Token'&gt;, &lt;SourceUnit iterable object 'contracts/Token.sol'&gt;]```## TestsTo run the test suite:```bash$ tox```## DevelopmentComments, questions, criticisms and pull requests are welcomed! Feel free to open an issue if you encounter a problem or would like to suggest a new feature.## LicenseThis project is licensed under the [MIT license](LICENSE).</longdescription>
</pkgmetadata>