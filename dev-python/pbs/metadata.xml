<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>PBS has now become sh.======================PBS will no longer be supported.  Please upgrade here:http://pypi.python.org/pypi/shAnd migrate your existin code with:```pythonimport sh as pbs```* * *PBS is a unique subprocess wrapper that maps your system programs toPython functions dynamically.  PBS helps you write shell scripts inPython by giving you the good features of Bash (easy command calling, easypiping) with all the power and flexibility of Python.```pythonfrom pbs import ifconfigprint ifconfig(&quot;eth0&quot;)```PBS is not a collection of system commands implemented in Python.# Getting    $&gt; pip install pbs# UsageThe easiest way to get up and running is to import pbsdirectly or import your program from pbs:```pythonimport pbsprint pbs.ifconfig(&quot;eth0&quot;)from pbs import ifconfigprint ifconfig(&quot;eth0&quot;)```A less common usage pattern is through PBS Command wrapper, which takes afull path to a command and returns a callable object.  This is useful forprograms that have weird characters in their names or programs that aren't inyour $PATH:```pythonimport pbsffmpeg = pbs.Command(&quot;/usr/bin/ffmpeg&quot;)ffmpeg(movie_file)```The last usage pattern is for trying PBS through an interactive REPL.  Bydefault, this acts like a star import (so all of your system programs will beimmediately available as functions):    $&gt; python pbs.py# Examples## Executing CommandsCommands work like you'd expect.  **Just call your program's name likea function:**```python# print the contents of this directory print ls(&quot;-l&quot;)# get the longest line of this filelongest_line = wc(__file__, &quot;-L&quot;)# get interface informationprint ifconfig(&quot;eth0&quot;)```Note that these aren't Python functions, these are running the binarycommands on your system dynamically by resolving your PATH, much like Bash does.In this way, all the programs on your system are easily availablein Python.You can also call attributes on commands.  This translates to the commandname followed by the attribute name:```pythonfrom pbs import git# resolves to &quot;git branch -v&quot;print git.branch(&quot;-v&quot;)```It turns out this is extremely useful for commands whose first argument is oftenanother sub-command (like git, svn, time, sudo, etc).See &quot;Baking&quot; for an advanced usage of this.## Keyword ArgumentsKeyword arguments also work like you'd expect: they get replaced with thelong-form and short-form commandline option:```python# resolves to &quot;curl http://duckduckgo.com/ -o page.html --silent&quot;curl(&quot;http://duckduckgo.com/&quot;, o=&quot;page.html&quot;, silent=True)# or if you prefer not to use keyword arguments, this does the same thing:curl(&quot;http://duckduckgo.com/&quot;, &quot;-o&quot;, &quot;page.html&quot;, &quot;--silent&quot;)# resolves to &quot;adduser amoffat --system --shell=/bin/bash --no-create-home&quot;adduser(&quot;amoffat&quot;, system=True, shell=&quot;/bin/bash&quot;, no_create_home=True)# oradduser(&quot;amoffat&quot;, &quot;--system&quot;, &quot;--shell&quot;, &quot;/bin/bash&quot;, &quot;--no-create-home&quot;)```## PipingPiping has become function composition:```python# sort this directory by biggest fileprint sort(du(glob(&quot;*&quot;), &quot;-sb&quot;), &quot;-rn&quot;)# print the number of folders and files in /etcprint wc(ls(&quot;/etc&quot;, &quot;-1&quot;), &quot;-l&quot;)```## RedirectionPBS can redirect the standard and error output streams of a process to a file. This is done with the special _out and _err keyword arguments. You can pass afilename or a file object as the argument value. When the name of an already existing file is passed, the contents of the file will be overwritten.```pythonls(_out=&quot;files.list&quot;)ls(&quot;nonexistent&quot;, _err=&quot;error.txt&quot;)```PBS can also redirect the error output stream to the standard output stream,using the special _err_to_out=True keyword argument.## Sudo and With ContextsCommands can be run within a &quot;with&quot; context.  Popular commands using thismight be &quot;sudo&quot; or &quot;fakeroot&quot;:```pythonwith sudo:    print ls(&quot;/root&quot;)```If you needto run a command in a with context AND call it, for example, specifyinga -p prompt with sudo, you need to use the &quot;_with&quot; keyword argument.This let's the command know that it's being run from a with context soit can behave correctly.```pythonwith sudo(p=&quot;&gt;&quot;, _with=True):    print ls(&quot;/root&quot;)```## Background ProcessesCommands can be run in the background with the special _bg=True keywordargument:```python# blockssleep(3)print &quot;...3 seconds later&quot;# doesn't blockp = sleep(3, _bg=True)print &quot;prints immediately!&quot;p.wait()print &quot;...and 3 seconds later&quot;```You can also pipe together background processes!```pythonp = wc(curl(&quot;http://github.com/&quot;, silent=True, _bg=True), &quot;--bytes&quot;)print &quot;prints immediately!&quot;print &quot;byte count of github: %d&quot; % int(p) # lazily completes```This lets you start long-running commands at the beginning of your script(like a file download) and continue performing other commands in theforeground.## Foreground ProcessesForeground processes are processes that you want to interact directly withthe default stdout and stdin of your terminal.  In other words, these areprocesses that you do not want to return their output as a return valueof their call.  An example would be opening a text editor:```pythonvim(file_to_edit)```This will block because pbs will be trying to aggregate the outputof the command to python, without displaying anything to the screen. Thesolution is the &quot;_fg&quot; special keyword arg:```pythonvim(file_to_edit, _fg=True)```This will open vim as expected and let you use it as expected, with allthe input coming from the keyboard and the output going to the screen.The return value of a foreground process is an empty string.## Finding Commands&quot;Which&quot; finds the full path of a program, or returns None if it doesn't exist.This command is one of the few commands implemented as a Python function,and therefore doesn't rely on the &quot;which&quot; program actually existing. ```pythonprint which(&quot;python&quot;) # &quot;/usr/bin/python&quot;print which(&quot;ls&quot;) # &quot;/bin/ls&quot;print which(&quot;some_command&quot;) # Noneif not which(&quot;supervisorctl&quot;): apt_get(&quot;install&quot;, &quot;supervisor&quot;, &quot;-y&quot;)```## BakingPBS is capable of &quot;baking&quot; arguments into commands.  This is similarto the stdlib functools.partial wrapper.  An example can speak volumes:```pythonfrom pbs import lsls = ls.bake(&quot;-la&quot;)print ls # &quot;/usr/bin/ls -la&quot;# resolves to &quot;ls / -la&quot;print ls(&quot;/&quot;) ```The idea is that calling &quot;bake&quot; on a command creates a callable object that automatically passes along all of the arguments passed into &quot;bake&quot;.This gets **really interesting** when you combine this with the attributeaccess on a command:```pythonfrom pbs import ssh# calling whoami on the server.  this is tedious to do if you're running# any more than a few commands.iam1 = ssh(&quot;myserver.com&quot;, &quot;-p 1393&quot;, &quot;whoami&quot;)# wouldn't it be nice to bake the common parameters into the ssh command?myserver = ssh.bake(&quot;myserver.com&quot;, p=1393)print myserver # &quot;/usr/bin/ssh myserver.com -p 1393&quot;# resolves to &quot;/usr/bin/ssh myserver.com -p 1393 whoami&quot;iam2 = myserver.whoami()assert(iam1 == iam2) # True!```Now that the &quot;myserver&quot; callable represents a baked ssh command, youcan call anything on the server easily:```python# resolves to &quot;/usr/bin/ssh myserver.com -p 1393 tail /var/log/dumb_daemon.log -n 100&quot;print myserver.tail(&quot;/var/log/dumb_daemon.log&quot;, n=100)```## Environment VariablesEnvironment variables are available much like they are in Bash:```pythonprint HOMEprint SHELLprint PS1```You can set enviroment variables the usual way, through the os.environmapping:```pythonimport osos.environ[&quot;TEST&quot;] = &quot;123&quot;```Now any new subprocess commands called from the script will be able toaccess that environment variable.## ExceptionsExceptions are dynamically generated based on the return code of the command.This lets you catch a specific return code, or catch all error return codesthrough the base class ErrorReturnCode:```pythontry: print ls(&quot;/some/non-existant/folder&quot;)except ErrorReturnCode_2:    print &quot;folder doesn't exist!&quot;    create_the_folder()except ErrorReturnCode:    print &quot;unknown error&quot;    exit(1)```## GlobbingGlob-expansion is not done on your arguments.  For example, this will not work:```pythonfrom pbs import duprint du(&quot;*&quot;)```You'll get an error to the effect of &quot;cannot access '\*': No such file or directory&quot;.This is because the &quot;\*&quot; needs to be glob expanded:```pythonfrom pbs import du, globprint du(glob(&quot;*&quot;)) ```## Commandline ArgumentsYou can access commandline arguments similar to Bash's $1, $2, etc by usingARG1, ARG2, etc:```pythonprint ARG1, ARG2# if an argument isn't defined, it's set to Noneif ARG10 is None: do_something()```You can access the entire argparse/optparse-friendly list of commandlinearguments through &quot;ARGV&quot;.  This is recommended for flexibility:```pythonimport argparseparser = argparse.ArgumentParser(prog=&quot;PROG&quot;)parser.add_argument(&quot;-x&quot;, default=3, type=int)ns = parser.parse_args(ARGV)print ns.x```## Weirdly-named CommandsPBS automatically handles underscore-dash conversions.  For example, if you wantto call apt-get:```pythonapt_get(&quot;install&quot;, &quot;mplayer&quot;, y=True)```PBS looks for &quot;apt_get&quot;, but if it doesn't find it, replaces all underscoreswith dashes and searches again.  If the command still isn't found, aCommandNotFound exception is raised.Commands with other, less-commonly symbols in their names must be accesseddirectly through the &quot;Command&quot; class wrapper.  The Command class takes the fullpath to the program as a string:```pythonp27 = Command(which(&quot;python2.7&quot;))print p27(&quot;-h&quot;)```The Command wrapper is also useful for commands that are not in your standard PATH:```pythonscript = Command(&quot;/tmp/temporary-script.sh&quot;)print script()```## Non-standard Exit CodesNormally, if a command returns an exit code that is not 0, PBS raises an exceptionbased on that exit code.  However, if you have determined that an error codeis normal and want to retrieve the output of the command without PBS raising anexception, you can use the &quot;_ok_code&quot; special argument to suppress the exception:```pythonoutput = pbs.ls(&quot;dir_that_exists&quot;, &quot;dir_that_doesnt&quot;, _ok_code=2)```In the above example, even though you're trying to list a directory that doesn'texist, you can still get the output from the directory that does exist by tellingthe command that 2 is an &quot;ok&quot; exit code, so don't raise an exception._ok_code can also take a list or tuple of numbers for multiple ok exit codes. </longdescription>
</pkgmetadata>