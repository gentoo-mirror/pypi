<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Django Frozen FieldDjango model custom field for storing a frozen snapshot of an object.## Principles* Behaves like a `ForeignKey` but the data is detached from the related object* Transparent to the client - it looks like the original object* The frozen object cannot be edited* The frozen object cannot be saved* Works even if original model is updated or deleted### Why not use DRF / Django serializers?This library has one specific requirement that makes using the existingsolutions hard - to be able to decouple the frozen data from the model,such that the underlying model can be altered or even deleted, and thedata can still be used as it was at the point of freezing. We use themodel itself only once, when we first set the data - from that point onthe field has no dependency on the original model, using intermediatedynamic dataclasses that represent the model as it was when the data wassaved. This package does reference a lot of the principles in both DRFand Django itself - and the structure of the serialized data is similarto that exported from the queryset serializer.### Why not just store frozen data as JSON and be done with it?This is probably a good / safe option for most codebases coming to thefreezing of data for the first time, and we have a lot of ephemeral datastored in `JSONField` fields ourselves. However, migrating an existingproject from `ForeignKey` to `JSONField`, along with all references tothe data, templates, etc., is painful. This package is designed to makethe migration from 'fresh' to 'frozen' as simple as possible.## Package internalsThe package includes three core modules, `serializers`, `models`, and`fields`, that together control the serialization process.#### `frozen_field.models`This module contains the engine of the package, which is a`FrozenObjectMeta` dataclass that is responsible for parsing Djangomodel attributes, extracting data and and creating the dynamicdataclasses used to represent a Django Model.You should not need to use this module in your application.#### `frozen_field.serializers`This module contains the `freeze_object` and `unfreeze_object` functionsthat are responsible for marshalling the serialized data between aDjango Model instance, a dynamic dataclass, and the serialized JSON..On set:    # model &gt;&gt; dataclassOn save:    dataclass &gt;&gt; dictOn refresh:    dict &gt;&gt; dataclassYou should not need to use this module in your application.#### `frozen_field.fields`This module contains the `FrozenObjectField` itself - it is the only part of thepackage that should need to use yourself.#### Evolution of `FrozenObjectField`The easiest way to understand why the field is structured as it is is tofollow the history:1. The first implementation serialized just non-related object fields (i.e.   excluded `ForeignKey` and `OneToOneField` attrs)1. The `include` and `exclude` arguments were added to control which fields were   serialized1. The `select_related` argument was added to enable the serialization of   top-level related objects (`ForeignKey` / `OneToOneField`)1. The `select_properties` argument was added to enable the serialization of   simple model properties (`@property`)1. Support was added for ORM-style paths (using the `__` delimiter) to enable   deep serialization beyond the top-level1. The `converters` argument was added to enable fine-tuning of the   deserialization process.## UsageA frozen field can be declared like a `ForeignKey`:```pythonclass Profile(Model):    address = FrozenObjectField(        Address,                         # The model being frozen        include=[],                      # defaults to all        exclude=[&quot;line_2&quot;],              # defaults to none        select_related=[]                # add related fields        select_properties=[&quot;attr_name&quot;]  # add model properties        converters={&quot;field_name&quot;: func}  # custom deserializer    )...&gt;&gt;&gt; profile.address = Address.objects.get(...)&gt;&gt;&gt; type(profile.address)types.FrozenAddress&gt;&gt;&gt; profile.save()&gt;&gt;&gt; profile.refresh_from_db()&gt;&gt;&gt; type(profile.address)types.FrozenAddress&gt;&gt;&gt; profile.address.id1&gt;&gt;&gt; profile.address.line_1&quot;29 Acacia Avenue&quot;&gt;&gt;&gt; profile.address.sincedatetime.date(2011, 6, 4)&gt;&gt;&gt; dataclasses.asdict(profile.address){    &quot;_meta&quot;: {        &quot;pk&quot;: 1,        &quot;model&quot;: &quot;Address&quot;,        &quot;frozen_at&quot;: &quot;2021-06-04T18:10:30.549Z&quot;,        &quot;fields&quot;: {            &quot;id&quot;: &quot;django.db.models.AutoField&quot;,            &quot;line_1&quot;: &quot;django.db.models.CharField&quot;,            &quot;since&quot;: &quot;django.db.models.DateField&quot;        },        &quot;properties&quot;: [&quot;attr_name&quot;]    },    &quot;id&quot;: 1,    &quot;line_1&quot;: &quot;29 Acacia Avenue&quot;,    &quot;since&quot;: &quot;2011-06-04T18:10:30.549Z&quot;    &quot;attr_name&quot;: &quot;hello&quot;}&gt;&gt;&gt; profile.address.json_data(){    &quot;id&quot;: 1,    &quot;line_1&quot;: &quot;29 Acacia Avenue&quot;,    &quot;since&quot;: &quot;2011-06-04T18:10:30.549Z&quot;,    &quot;attr_name&quot;: &quot;hello&quot;}&gt;&gt;&gt; profile.address.id = 2FrozenInstanceError: cannot assign to field 'id'&gt;&gt;&gt; profile.address.save()AttributeError: 'FrozenAddress' object has no attribute 'save'```### Controlling serializationBy default only top-level attributes of an object are frozen - relatedobjects (`ForeignKey`, `OneToOneField`) are ignored. This is by design -as deep serialization of recursive relationships can get very complexvery quickly, and a deep serialization of an object tree is notrecommended. This library is designed for the simple 'freezing' of basicdata. The recommended pattern is to flatten out the parts of the objecttree that you wish to record. You can control which top-level fields areincluded in the frozen data using the `include` and `exclude` arguments.Note that these are mutually exclusive - by default both are an emptylist, which results in all top-level non-related attributes beingserialized. If `included` is not empty, then *only* the fields in thelist are serialized. If `excluded` is not empty then all fields *except*those in the list are serialized.That said, there is support for related object capture using the`select_related` argument.The `select_properties` argument can be used to add model properties(e.g. methods decorated with `@property`) to the serialization. NB thiscurrently does no casting of the value when deserialized (as it doesn'tknow what the type is), so if your property is a date, it will come backas a string (isoformat). If you want it to return a `date` you will wantto use converters.The `converters` argument is used to override the default conversion ofthe JSON back to something more appropriate. A typical use case would bethe casting of a property which has no default backing field to use. Inthis case you could use the builtin Django `parse_date` function```pythonfield = FrozenObjectField(    Profile,    include=[],    exclude=[],    select_related=[],    select_properties=[&quot;date_registered&quot;],    converters={&quot;date_registered&quot;: parse_date})```## How it worksThe internal wrangling of a Django model to a JSON string is done using dynamicdataclasses, created on the fly using the `dataclasses.make_dataclass` function.The new dataclass contains one fixed property, `meta`, which is itself aninstance of a concrete dataclass, `FrozenObjectMeta`. This ensures that eachserialized blob contains enough original model field metadata to be able todeserialize the JSONField back into something that resembles the original. Thisis required because the process of serializing the data as JSON will convertcertain unsupported datatypes (e.g. `Decimal`, `float`, `date`, `datetime`,`UUID`) to string equivalents, and in order to deserialize these values we needto know what type the original value was. This is very similar to how Django'sown `django.core.serializers` work.#### Running testsThe tests use `pytest` as the test runner. If you have installed the `poetry`evironment, you can run them using:```$ poetry run pytest```</longdescription>
</pkgmetadata>