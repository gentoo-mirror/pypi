<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;div align=&quot;center&quot;&gt;  &lt;img width=&quot;250&quot; src=&quot;https://user-images.githubusercontent.com/1844269/226196799-402898d6-c363-4735-be23-57c0ba9e1035.png&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;p align=&quot;center&quot;&gt;  Write safe shell scripts in Python.  &lt;br&gt;  Combine the streamlined utility of a shell with the power of a modern programming language.&lt;/p&gt;---- [Install](#install)- [Usage](#usage)- [Why?](#why)  - [Similar Projects](#similar-projects)- [Advanced Usage](#advanced-usage)  - [Shell Command Result](#shell-command-result)  - [Exception Handling](#exception-handling)  - [Multiple Commands / Persisting Environment](#multiple-commands--persisting-environment)- [Options](#options)  - [Output](#output)  - [Environment Variables](#environment-variables)- [Examples](#examples)## Install```pip install -U python-shellrunner```## Usage```pythonfrom shellrunner import XX(&quot;echo hello world&quot;)# hello world```Easily get a command's output, do something with it, and run another command using the value:```pythonoutput = X(&quot;echo hello world | sed 's/world/there/'&quot;).outgreeting = output.capitalize()X(f&quot;echo 'echo {greeting}' &gt;&gt; .bashrc&quot;)```An exception is raised if a command exits with a non-zero status (like bash's `set -e`):```pythontext = X(&quot;grep hello /non/existent/file&quot;).out # grep exits with a non-zero status# ^ Raises ShellCommandError so the rest of the script doesn't runmy_text_processor(text)```Or, maybe you want to handle the error:```pythonfrom shellrunner import X, ShellCommandErrortext = &quot;&quot;try:    text = X(&quot;grep hello /non/existent/file&quot;).outexcept ShellCommandError:    text = X(&quot;grep hello /file/that/definitely/exists&quot;).outmy_text_processor(text)```Pipeline errors are not masked (like bash's `set -o pipefail`):```pythonX(&quot;grep hello /non/existent/file | tee new_file&quot;) # tee gets nothing from grep, creates an empty file, and exits with status 0# ^ Raises ShellCommandError```## Why?&gt; Why not just use bash with `set -e` and `set -o pipefail`?Because writing anything remotely complicated in bash kinda sucks :)One of the primary advantages of ShellRunner's approach is that you can seamlessly swap between the shell and Python. Some things are just easier to do in a shell (e.g. pipelines) and a lot of things are easier/better in Python (control flow, error handling, etc).Also, users of [fish](https://github.com/fish-shell/fish-shell) might know that it [does not offer a way to easily exit a script if a command fails](https://github.com/fish-shell/fish-shell/issues/510). ShellRunner adds `set -e` and `pipefail` like functionality to any shell. Leverage the improved syntax of your preferred shell and the (optional) saftey of bash.### Similar Projects- [zxpy](https://github.com/tusharsadhwani/zxpy)- [shellpy](https://github.com/lamerman/shellpy)- [plumbum](https://github.com/tomerfiliba/plumbum)ShellRunner is very similar to zxpy and shellpy but aims to be more simple in its implementation and has a focus on adding safety to scripts.## Advanced UsageA note on compatability: ShellRunner should work with on any POSIX-compliant system (and shell). No Windows support at this time.Confirmed compatible with `sh` (dash), `bash`, `zsh`, and `fish`.Commands are automatically run with the shell that invoked your python script (this can be [overridden](#options)):```python# my_script.pyX(&quot;echo hello | string match hello&quot;)# Works if my_script.py is executed under fish. Will obviously fail if using bash.```### Shell Command Result`X` returns a `ShellCommandResult` (`NamedTuple`) containing the following:- `out: str`: The `stdout` and `stderr` of the command.- `status: int`: The overall exit status of the command. If the command was a pipeline that failed, `status` will be equal to the status of the last failing command (like bash's `pipefail`).- `pipestatus: list[int]`: A list of statuses for each command in the pipeline.```pythonresult = X(&quot;echo hello&quot;)print(f'Got output &quot;{result.out}&quot; with exit status {result.status} / {result.pipestatus}')# Or unpackoutput, status, pipestatus = X(&quot;echo hello&quot;)# output = &quot;hello&quot;# status = 0# pipestatus = [0]``````pythonresult = X(&quot;(exit 1) | (exit 2) | echo hello&quot;)# result.out = &quot;hello&quot;# result.status = 2# result.pipestatus = [1, 2, 0]```If using a shell that does not support `PIPESTATUS` such as `sh`, you will only ever get the status of the last command in a pipeline. **This also means that in this case ShellRunner cannot detect if an error occurred in a pipeline:**```pythonresult = X(&quot;(exit 1) | echo hello&quot;)# if invoked with bash: ShellCommandError is raised, status = 1, pipestatus = [1, 0]# if invoked with sh: No exception is raised, status = 0, pipestatus = [0]```### Exception Handling`ShellCommandError` also receives the information from the failed command, which means you can do something like this:```pythontry:    X(&quot;echo hello &amp;&amp; false&quot;) # Pretend this is some command that prints something but exits with a non-zero statusexcept ShellCommandError as e:    print(f'Command failed. Got output &quot;{e.out}&quot; with exit status {e.status}')```### Multiple Commands / Persisting EnvironmentEach call of `X` invokes a new instance of the shell, so things like environment variables or directory changes don't persist.Sometimes you might want to do something like this:```pythonX(&quot;MY_VAR=hello&quot;)X(&quot;grep $MY_VAR /file/that/exists&quot;) # MY_VAR doesn't exist# ^ Raises ShellCommandError```A (bad) solution would be to do this:```pythonX(&quot;MY_VAR=hello; grep $MY_VAR /file/that/exists&quot;)```This sort of defeats the purpose of ShellRunner because that would be run as one command, so no error handling can take place on commands before the last one.Instead, `X` also accepts a list of commands where each command is run in the same shell instance and goes through the normal error handling:```pythonX([&quot;MY_VAR=hello&quot;,&quot;grep $MY_VAR /file/that/exists&quot;,])# Works!```## OptionsThere are a few keyword arguments you can provide to adjust the behavior of `X`:```pythonX(&quot;command&quot;, shell=&quot;bash&quot;, check=True, show_output=True, show_commands=True)````shell: str` (Default: the invoking shell) - Shell that will be used to execute the commands. Can be a path or simply the name (e.g. &quot;/bin/bash&quot;, &quot;bash&quot;).`check: bool` (Default: True) - If True, an error will be thrown if a command exits with a non-zero status.`show_output: bool` (Default: True) - If True, command output will be printed.`show_commands: bool` (Default: True) - If True, the current command will be printed before execution.### OutputSay you do this:```pythonX(&quot;echo hello world&quot;)```This will print the following to your terminal:```shellrunner: echo hello worldhello world```To hide the `shellrunner:` lines, set `show_commands=False`.To hide actual command output, set `show_output=False`.### Environment VariablesEach option also has a corresponding environment variable to allow you to set these options &quot;globally&quot; for your script:`shell` = `SHELLRUNNER_SHELL``check` = `SHELLRUNNER_CHECK``show_output` = `SHELLRUNNER_SHOW_OUTPUT``show_commands` = `SHELLRUNNER_SHOW_COMMANDS`Environment variables are evaluated on each call of `X`, so you could also do something like this:```python# Pretend that before running this file you set: export SHELLRUNNER_SHOW_OUTPUT=&quot;False&quot;X(&quot;echo hello&quot;)# No output# Now you want to see outputos.environ[&quot;SHELLRUNNER_SHOW_OUTPUT&quot;] = &quot;True&quot;X(&quot;echo hello&quot;)# hello```## ExamplesPrints out installed python packages and their dependencies:```pythonfrom shellrunner import Xpackages = X(&quot;pip list -l | sed 1,2d | awk '{print $1}'&quot;).outpackages = packages.splitlines()for package in packages:    print(f&quot;=== {package} ===&quot;)    X(f&quot;pip show {package} | grep -E 'Requires|Required-by'&quot;, show_commands=False)```</longdescription>
</pkgmetadata>