<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>NetStruct=========NetStruct is a `struct &lt;http://docs.python.org/library/struct.html&gt;`_-likemodule for Python designed to make it a bit easier to send and received packedbinary data.NetStruct is available under the `Apache License, Version 2.0&lt;http://www.apache.org/licenses/LICENSE-2.0.html&gt;`_.Install=======NetStruct can be installed using `pip &lt;http://http://pypi.python.org/pypi/pip&gt;`_:    pip install netstructYou can also grab the latest code from the `git &lt;http://git-scm.com/&gt;`_)repository:    git clone git://github.com/stendec/netstructNetStruct runs on `Python 2.6+ &lt;http://python.org&gt;`_, PyPy, and Python 3(though only Python 3.3 has been tested).Differences from ``struct``===========================NetStruct has two differences from ``struct``.First, it defaults to using network byte-order, rather than native byte-order,on the assumption that you'll be using it to send data over the network and,thus, it's saving you time.Additionally, the generated strings don't have any padding when usingnon-native byte-order.Second, NetStruct supports a new formatting character, the dollar sign (``$``).The dollar sign represents a variable-length string, encoded with its lengthpreceeding the string itself. To accomplish this, the formatting characterdirectly before the dollar sign is assumed to represent the string's length.Examples========This is as basic as it gets::    &gt;&gt;&gt; import netstruct    &gt;&gt;&gt; netstruct.pack(b&quot;b$&quot;, b&quot;Hello World!&quot;)    b'\x0cHello World!'Alternatively::    &gt;&gt;&gt; netstruct.unpack(b&quot;b$&quot;, b&quot;\x0cHello World!&quot;)    [b'Hello World!']You can get a bit more complex, if you'd like::    &gt;&gt;&gt; netstruct.pack(b&quot;ih$5b&quot;, 1298, b&quot;largeBiomes&quot;, 0, 0, 1, 0, 8)    b'\x00\x00\x05\x12\x00\x0blargeBiomes\x00\x00\x01\x00\x08'And, of course, you can unpack complex data too::    &gt;&gt;&gt; netstruct.unpack(b&quot;bh$h$i&quot;, b&quot;'\x00\x07stendec\x00\tlocalhost\x00\x00c\xdd&quot;)    [39, b'stendec', b'localhost', 25565]You just have to be sure to use a long enough string::    &gt;&gt;&gt; netstruct.unpack(b&quot;bh$h$i&quot;, b&quot;'\x00\x07stendec\x00\tlocalhost\x00&quot;)    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;      File &quot;site-packages/netstruct.py&quot;, line 275, in unpack        return NetStruct(format).unpack(data)      File &quot;site-packages/netstruct.py&quot;, line 165, in unpack        raise error(&quot;unpack requires a string argument of length %d&quot; % (len(data) + out))    struct.error: unpack requires a string argument of length 25But wait, you say. How am I supposed to provide a long enough string tounpack the data when I can't possibly know the length ahead of time?Simply put, you *can* know the length::    &gt;&gt;&gt; it = netstruct.iter_unpack(b&quot;ih$5b&quot;)    &gt;&gt;&gt; next(it)    11The ``iter_unpack`` function returns an iterator. Each time you call thatiterator with ``next()``, or call its ``.send()`` method, it can return one oftwo values. Either it'll return the number of bytes it wants you to read next,or it'll return the completed object.Let's continue from above::    &gt;&gt;&gt; it.send(b&quot;\x00\x00\x05\x12\x00\x0b&quot;)    16    &gt;&gt;&gt; it.send(b&quot;largeBiomes&quot;)    5    &gt;&gt;&gt; it.send(b&quot;\x00\x00\x01\x00\x08   more&quot;)    [1298, b'largeBiomes', 0, 0, 1, 0, 8]There. I've sent enough data, so it returned the completed list of theunpacked data. At this point, I can take my data, and do whatever it is I wantwith it.But wait! I just sent too much data to that iterator, and now I've lost someof my string, haven't I? That's not a problem either. You can call the iteratorone final time and it will return the unconsumed remainder of the data::    &gt;&gt;&gt; next(it)    b'   more'It's just that simple. Of course, not everyone likes iterators, even if they*are* quicker and less memory intensive than a class instance. NetStruct isprepared, with its ``Unpacker`` class and ``obj_unpack``. Let's try that lastexample one more time::    &gt;&gt;&gt; obj = netstruct.obj_unpack(b&quot;ih$5b&quot;)    &gt;&gt;&gt; obj.remaining    11    &gt;&gt;&gt; obj.feed(b&quot;\x00\x00\x05\x12\x00\x0b&quot;)    16    &gt;&gt;&gt; obj.feed(b&quot;largeBiomes&quot;)    5    &gt;&gt;&gt; obj.feed(b&quot;\x00\x00\x01\x00\x08   more&quot;)    0    &gt;&gt;&gt; obj.result    [1298, b'largeBiomes', 0, 0, 1, 0, 8]    &gt;&gt;&gt; obj.unused_data    b'   more'Enjoy.</longdescription>
</pkgmetadata>