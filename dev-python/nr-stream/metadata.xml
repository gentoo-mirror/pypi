<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># nr-streamThis package provides utilities for writing functional-style code in Python. The package originally contained onlythe `Stream` class, hence the name, but since we've adopted the terminology for letting us *streamline* large chunksof our code.## API### Optional objectsRepresents an optional value, i.e. one that either has a valid value or is `None`. The class is useful tochain modifications and have them execute based on whether a value is available or not.__Example__```pyimport osfrom nr.stream import Optionalopt = Optional(os.getenv(&quot;SOMEVAR&quot;))value = opt.or_else_get(lambda: do_something_else())value = opt.or_else_raise(lambda: Exception(&quot;SOMEVAR not set&quot;))opt = opt.map(lambda value: value + &quot; another value&quot;)len(opt.stream().count())  # 0 or 1```### Refreshable objectsA Refreshable is a container for a value that can be updated and inform listeners. A chained operations on arefreshable will be replayed if the parent refreshable is updated. This is eager evaluation, not lazy evaluationand allows performant calls to `.get()` without going through a lazy chain of operations each time.Unlike `Optional` or `Stream`, the `Refreshable` knows no &quot;empty&quot; state.This class is often useful to pass configuration data around in your application. It allows making modificationsto the configuration and have it automatically propagate throughout the application.__Example__```pyfrom nr.stream import Refreshableroot = Refreshable[int | None](None)child = root.map(lambda v: 42 if v is None else v)print(root.get())  # Noneprint(child.get()) # 42root.update(10)print(root.get())  # 10print(child.get()) # 10```### Stream objectsThe Stream class wraps an iterable and allows you to build a chain of modifiers on top of it. This oftengreatly simplifies consecutive operations on an iterable object and its items.__Example__```pyfrom nr.stream import Streamvalues = [3, 6, 4, 7, 1, 2, 5]assert list(Stream(values).chunks(values, 3, fill=0).map(sum)) == [13, 10, 5]```&gt; __Important__: Stream objects always immediately convert the object passed to an iterator. This means&gt; that you cannot branch stream objects, as both forks will share the same initial iterator.### Supplier objectsThe Supplier class allows you to lazily evaluate the retrieval of a value, as well as chain modificationson top of it and even trace the lineage of these modifications. It provides convenience methods such as`.map()`, `.once()`, `.get_or_raise()`. Unlike an `Optional`, a supplier will treat `None` as a valid valueand instead separately track the state of &quot;no value&quot;.Trying to read a value from an empty supplier raises a `Supplier.Empty` exception. Note that suppliers _always_evaluate lazily, unlike `Optional`.__Example__```pyfrom nr.stream import Suppliersup = Supplier.of(42)sup = sup.map(lambda value: print(value))assert sup.get() == None  # prints: 42assert sup.get() == None  # prints: 42Supplier.void().get()  # raises Supplier.Empty```</longdescription>
</pkgmetadata>