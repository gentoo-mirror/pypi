<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![codecov](https://codecov.io/gh/monomonedula/nvelope/branch/master/graph/badge.svg?token=yunFiDdUEK)](https://codecov.io/gh/monomonedula/nvelope)[![Build Status](https://app.travis-ci.com/monomonedula/nvelope.svg?branch=master)](https://app.travis-ci.com/monomonedula/nvelope)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![Downloads](https://pepy.tech/badge/nvelope)](https://pepy.tech/project/nvelope)# nvelopeDefine your JSON schema as Python dataclassesIt's kinda like Pydantic but better.Now with JSON-schema generation!## Installation`pip install nvelope`## The problem it solvesWith `nvelope` you can define dataclasses which know how to convert themselves from/to JSON.All with custom checks and custom defined conversions from/to JSON for any type you want to put into your dataclass.This library was designed with extensibility in mind, so it relies on interfaces (for the most part) rather than some weird inheritance stuff and other magic.You can (and probably should) take a look at the code! The code base is microscopic compared to Pydantic.## UsageSay you have a JSON representing a user in your app looking something like this```json{    &quot;id&quot;: 530716139,    &quot;username&quot;: &quot;johndoe&quot;,    &quot;language_code&quot;: &quot;en&quot;}```You define an envelope for it```pythonfrom dataclasses import dataclassfrom nvelope import (Obj, int_conv, string_conv)@dataclass      # note the @dataclass decorator, it is importantclass User(Obj):    _conversion = {        &quot;id&quot;: int_conv,        &quot;language_code&quot;: string_conv,        &quot;username&quot;: string_conv,    }    id: int    language_code: str    username: str```Now you have a model that knows how to read data from the JSON (not the raw string, actually, but to the types that are allowed by thestandard `json.dumps` function e.g. `dict`, `list`, `str`, `int`, `float`, `bool`, `None` ) ...```pythonuser = User.from_json(    {        &quot;id&quot;: 530716139,        &quot;username&quot;: &quot;johndoe&quot;,        &quot;language_code&quot;: &quot;en&quot;    })```... and knows how to convert itself into JSON ```pythonUser(    id=530716139,    username=&quot;johndoe&quot;,    language_code=&quot;en&quot;,).as_json() # returns a dictionary {#     &quot;id&quot;: 530716139,#     &quot;username&quot;: &quot;johndoe&quot;,#     &quot;language_code&quot;: &quot;en&quot;# }```### Compound envelopesYou can also define compound envelopes.Say we want to define a message and include info about the sender.Having defined the `User` envelope, we can do it like this:```pythonfrom nvelope import CompoundConv@dataclassclass Message(Obj):    _conversion = {        &quot;message_id&quot;: int_conv,        &quot;from_&quot;: CompoundConv(User),        &quot;text&quot;: string_conv,    }    from_: User    text: str    message_id: int```and use it the same way:```python# reading an obj from parsed json like thisMessage.from_json(    {        &quot;message_id&quot;: 44,        &quot;text&quot;: &quot;hello there&quot;,        &quot;from_&quot;: {            &quot;id&quot;: 530716139,            &quot;username&quot;: &quot;johndoe&quot;,            &quot;language_code&quot;: &quot;en&quot;        }    })# and dumping an object to json like thisimport jsonjson.dumps(    Message(        message_id=44,        text=&quot;whatever&quot;,        from_=User(            id=530716139,            username=&quot;johndoe&quot;,            language_code=&quot;en&quot;,        )    ).as_json())```### ArraysThis is how you define arrays:```pythonfrom nvelope import Arr, CompoundConvclass Users(Arr):    conversion = CompoundConv(User)# Same API inherited from nvelope.Compound interfaceUsers.from_json(    [        {            &quot;id&quot;: 530716139,            &quot;username&quot;: &quot;johndoe&quot;,            &quot;language_code&quot;: &quot;en&quot;,        },        {            &quot;id&quot;: 452341341,            &quot;username&quot;: &quot;ivandrago&quot;,            &quot;language_code&quot;: &quot;ru&quot;,        }    ])Users(    [        User(            id=530716139,            username=&quot;johndoe&quot;,            language_code=&quot;en&quot;,        ),        User(            id=452341341,            username=&quot;ivandrago&quot;,            language_code=&quot;ru&quot;,        ),    ]).as_json()```### Field aliasesAt some point you may need to define an envelope for an API containing certain field names which cannot beused in python since they are reserved keywords (such as `def`, `from`, etc.).There's a solution for this:```pythonfrom dataclasses import dataclassfrom nvelope import Obj, string_conv, CompoundConv, AliasTable@dataclassclass Comment(Obj):    _conversion = {        &quot;text&quot;: string_conv,        &quot;from_&quot;: CompoundConv(User),    }            _alias_table = AliasTable({&quot;from_&quot;: &quot;from&quot;})                text: str    from_: User```In this case `from` key gets replaced by `from_` in the python model. The `from_` field gets translated back to `from` when calling `.as_json()`### Missing and optional fieldsThere's a difference between fields that can be set to `None` and fields which may be missing in the JSON at all.This is how you specify that a some field may be missing from the JSON and that's OK:```pythonfrom dataclasses import dataclassfrom typing import Optionalfrom nvelope import MaybeMissing, Obj, OptionalConv, AliasTable@dataclassclass Comment(Obj):    _alias_table = AliasTable(        {&quot;from_&quot;: &quot;from&quot;}    )        text: str    img: Optional[str]          # this field can be set to None (null), but is must always be present in the JSON    from_: MaybeMissing[User]   # this field can be missing from JSON body    _conversion = {        &quot;text&quot;: string_conv,        &quot;img&quot;: OptionalConv(string_conv),   # note the wrapping with OptionalConv        &quot;from_&quot;: CompoundConv(User),    }```This is how you check if the `MaybeMissing` field is actually missing```pythoncomment.from_.has()     # returns False if the field is missing```and this is how you get the value:```pythoncomment.value()     # raises an error if there's no value,                     # so it is recommended to check the output of .has()                    #  before calling .value() ```### Json-schema supportThe `Comment` model from we have defined generates schema like this:```python    Comment.schema()```with the returned schema looking like this:```python{    &quot;type&quot;: &quot;object&quot;,    &quot;properties&quot;: {        &quot;from&quot;: {            &quot;properties&quot;: {                &quot;id&quot;: {&quot;type&quot;: &quot;integer&quot;},                &quot;language_code&quot;: {&quot;type&quot;: &quot;string&quot;},                &quot;username&quot;: {&quot;type&quot;: &quot;string&quot;},            },            &quot;required&quot;: [&quot;id&quot;, &quot;language_code&quot;, &quot;username&quot;],            &quot;type&quot;: &quot;object&quot;,        },        &quot;img&quot;: {&quot;type&quot;: [&quot;string&quot;, &quot;null&quot;]},        &quot;text&quot;: {&quot;type&quot;: &quot;string&quot;},    },    &quot;required&quot;: [&quot;text&quot;, &quot;img&quot;],}```**NOTE**: `nvelope` does not perform json schema checks.### Custom conversionsYou may define a custom conversions inheriting from `nvelope.nvelope.Conversion` abstract base class or using `nvelope.nvelope.ConversionOf` class. For example, this is how `datetime_iso_format_conv` is defined:```pythonfrom nvelope import WithTypeCheckOnDump, ConversionOfdatetime_iso_format_conv = WithTypeCheckOnDump(    datetime.datetime,    ConversionOf(        to_json=lambda v: v.isoformat(),        from_json=lambda s: datetime.datetime.fromisoformat(s),    ),)```Say we want to jsonify a `datetime` field as POSIX timestamp, instead of storing it in ISO string format.```pythondatetime_timestamp_conv = ConversionOf(    to_json=lambda v: v.timestamp(),    from_json=lambda s: datetime.datetime.fromtimestamp(s),    schema={&quot;type&quot;: &quot;number&quot;},)```We could also add `WithTypeCheckOnDump` wrapper in order to add explicit check that the value passed into `.from_json()`is indeed `float`.```pythonfrom nvelope import ConversionOfdatetime_timestamp_conv = WithTypeCheckOnDump(    float,    ConversionOf(        to_json=lambda v: v.timestamp(),        from_json=lambda s: datetime.datetime.fromtimestamp(s),        schema={&quot;type&quot;: &quot;number&quot;},    ))```You may also go further and implement custom conversion.Inherit from `nvelope.Conversion` interface, implement its abstract methods, and you are good to go.### Custom compoundsYou can also define custom alternatives to `nvelope.Obj` and `nvelope.Arr`.It will work fine as long as they inherit `nvelope.Compound` interface.It currently required 3 methods:- `from_json` - `as_json`- `schema`</longdescription>
</pkgmetadata>