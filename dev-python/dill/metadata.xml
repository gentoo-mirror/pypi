<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>-----------------------------dill: serialize all of Python-----------------------------About Dill==========``dill`` extends Python's ``pickle`` module for serializing and de-serializingPython objects to the majority of the built-in Python types. Serializationis the process of converting an object to a byte stream, and the inverseof which is converting a byte stream back to a Python object hierarchy.``dill`` provides the user the same interface as the ``pickle`` module, andalso includes some additional features. In addition to pickling Pythonobjects, ``dill`` provides the ability to save the state of an interpretersession in a single command.  Hence, it would be feasible to save aninterpreter session, close the interpreter, ship the pickled file toanother computer, open a new interpreter, unpickle the session andthus continue from the 'saved' state of the original interpretersession.``dill`` can be used to store Python objects to a file, but the primaryusage is to send Python objects across the network as a byte stream.``dill`` is quite flexible, and allows arbitrary user defined classesand functions to be serialized.  Thus ``dill`` is not intended to besecure against erroneously or maliciously constructed data. It isleft to the user to decide whether the data they unpickle is froma trustworthy source.``dill`` is part of ``pathos``, a Python framework for heterogeneous computing.``dill`` is in active development, so any user feedback, bug reports, comments,or suggestions are highly appreciated.  A list of issues is located athttps://github.com/uqfoundation/dill/issues, with a legacy list maintained athttps://uqfoundation.github.io/project/pathos/query.Major Features==============``dill`` can pickle the following standard types:    - none, type, bool, int, float, complex, bytes, str,    - tuple, list, dict, file, buffer, builtin,    - Python classes, namedtuples, dataclasses, metaclasses,    - instances of classes,    - set, frozenset, array, functions, exceptions``dill`` can also pickle more 'exotic' standard types:    - functions with yields, nested functions, lambdas,    - cell, method, unboundmethod, module, code, methodwrapper,    - methoddescriptor, getsetdescriptor, memberdescriptor, wrapperdescriptor,    - dictproxy, slice, notimplemented, ellipsis, quit``dill`` cannot yet pickle these standard types:    - frame, generator, traceback``dill`` also provides the capability to:    - save and load Python interpreter sessions    - save and extract the source code from functions and classes    - interactively diagnose pickling errorsCurrent Release===============The latest released version of ``dill`` is available from:    https://pypi.org/project/dill``dill`` is distributed under a 3-clause BSD license.Development Version===================You can get the latest development version with all the shiny new features at:    https://github.com/uqfoundationIf you have a new contribution, please submit a pull request.Installation============``dill`` can be installed with ``pip``::    $ pip install dillTo optionally include the ``objgraph`` diagnostic tool in the install::    $ pip install dill[graph]For windows users, to optionally install session history tools::    $ pip install dill[readline]Requirements============``dill`` requires:    - ``python`` (or ``pypy``), **&gt;=3.7**    - ``setuptools``, **&gt;=42**Optional requirements:    - ``objgraph``, **&gt;=1.7.2**    - ``pyreadline``, **&gt;=1.7.1** (on windows)Basic Usage===========``dill`` is a drop-in replacement for ``pickle``. Existing code can beupdated to allow complete pickling using::    &gt;&gt;&gt; import dill as pickleor::    &gt;&gt;&gt; from dill import dumps, loads``dumps`` converts the object to a unique byte string, and ``loads`` performsthe inverse operation::    &gt;&gt;&gt; squared = lambda x: x**2    &gt;&gt;&gt; loads(dumps(squared))(3)    9There are a number of options to control serialization which are providedas keyword arguments to several ``dill`` functions:* with *protocol*, the pickle protocol level can be set. This uses the  same value as the ``pickle`` module, *DEFAULT_PROTOCOL*.* with *byref=True*, ``dill`` to behave a lot more like pickle with  certain objects (like modules) pickled by reference as opposed to  attempting to pickle the object itself.* with *recurse=True*, objects referred to in the global dictionary are  recursively traced and pickled, instead of the default behavior of  attempting to store the entire global dictionary.* with *fmode*, the contents of the file can be pickled along with the file  handle, which is useful if the object is being sent over the wire to a  remote system which does not have the original file on disk. Options are  *HANDLE_FMODE* for just the handle, *CONTENTS_FMODE* for the file content  and *FILE_FMODE* for content and handle.* with *ignore=False*, objects reconstructed with types defined in the  top-level script environment use the existing type in the environment  rather than a possibly different reconstructed type.The default serialization can also be set globally in *dill.settings*.Thus, we can modify how ``dill`` handles references to the global dictionarylocally or globally::    &gt;&gt;&gt; import dill.settings    &gt;&gt;&gt; dumps(absolute) == dumps(absolute, recurse=True)    False    &gt;&gt;&gt; dill.settings['recurse'] = True    &gt;&gt;&gt; dumps(absolute) == dumps(absolute, recurse=True)    True``dill`` also includes source code inspection, as an alternate to pickling::    &gt;&gt;&gt; import dill.source    &gt;&gt;&gt; print(dill.source.getsource(squared))    squared = lambda x:x**2To aid in debugging pickling issues, use *dill.detect* which providestools like pickle tracing::    &gt;&gt;&gt; import dill.detect    &gt;&gt;&gt; with dill.detect.trace():    &gt;&gt;&gt;     dumps(squared)    ┬ F1: &lt;function &lt;lambda&gt; at 0x7fe074f8c280&gt;    ├┬ F2: &lt;function _create_function at 0x7fe074c49c10&gt;    │└ # F2 [34 B]    ├┬ Co: &lt;code object &lt;lambda&gt; at 0x7fe07501eb30, file &quot;&lt;stdin&gt;&quot;, line 1&gt;    │├┬ F2: &lt;function _create_code at 0x7fe074c49ca0&gt;    ││└ # F2 [19 B]    │└ # Co [87 B]    ├┬ D1: &lt;dict object at 0x7fe0750d4680&gt;    │└ # D1 [22 B]    ├┬ D2: &lt;dict object at 0x7fe074c5a1c0&gt;    │└ # D2 [2 B]    ├┬ D2: &lt;dict object at 0x7fe074f903c0&gt;    │├┬ D2: &lt;dict object at 0x7fe074f8ebc0&gt;    ││└ # D2 [2 B]    │└ # D2 [23 B]    └ # F1 [180 B]With trace, we see how ``dill`` stored the lambda (``F1``) by first storing``_create_function``, the underlying code object (``Co``) and ``_create_code``(which is used to handle code objects), then we handle the reference tothe global dict (``D2``) plus other dictionaries (``D1`` and ``D2``) thatsave the lambda object's state. A ``#`` marks when the object is actually stored.More Information================Probably the best way to get started is to look at the documentation athttp://dill.rtfd.io. Also see ``dill.tests`` for a set of scripts thatdemonstrate how ``dill`` can serialize different Python objects. You canrun the test suite with ``python -m dill.tests``. The contents of anypickle file can be examined with ``undill``.  As ``dill`` conforms tothe ``pickle`` interface, the examples and documentation found athttp://docs.python.org/library/pickle.html also apply to ``dill``if one will ``import dill as pickle``. The source code is also generallywell documented, so further questions may be resolved by inspecting thecode itself. Please feel free to submit a ticket on github, or ask aquestion on stackoverflow (**@Mike McKerns**).If you would like to share how you use ``dill`` in your work, please sendan email (to **mmckerns at uqfoundation dot org**).Citation========If you use ``dill`` to do research that leads to publication, we ask that youacknowledge use of ``dill`` by citing the following in your publication::    M.M. McKerns, L. Strand, T. Sullivan, A. Fang, M.A.G. Aivazis,    &quot;Building a framework for predictive science&quot;, Proceedings of    the 10th Python in Science Conference, 2011;    http://arxiv.org/pdf/1202.1056    Michael McKerns and Michael Aivazis,    &quot;pathos: a framework for heterogeneous computing&quot;, 2010- ;    https://uqfoundation.github.io/project/pathosPlease see https://uqfoundation.github.io/project/pathos orhttp://arxiv.org/pdf/1202.1056 for further information.</longdescription>
</pkgmetadata>