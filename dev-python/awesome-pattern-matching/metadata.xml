<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Awesome Pattern Matching (_apm_) for Python[![Github Actions](https://github.com/scravy/awesome-pattern-matching/workflows/Python%20application/badge.svg)](https://github.com/scravy/awesome-pattern-matching/actions)[![Downloads](https://pepy.tech/badge/awesome-pattern-matching)](https://pepy.tech/project/awesome-pattern-matching)[![PyPI version](https://badge.fury.io/py/awesome-pattern-matching.svg)](https://pypi.org/project/awesome-pattern-matching/)```bashpip install awesome-pattern-matching```- Simple- Powerful- Extensible- Composable- Functional- Python 3.7+, PyPy3.7+- Typed (IDE friendly)- Offers different styles (expression, declarative, statement, ...)There's a ton of pattern matching libraries available for python, all with varying degrees of maintenance and usability;also [since Python 3.10 there is the PEP-634 `match` statement](https://www.python.org/dev/peps/pep-0634/). However,this library still offers functionality that PEP-634 doesn't offer, as well as pattern matching for python versionsbefore 3.10. [A detailed comparison of PEP-634 and _`apm`_ is available](https://github.com/scravy/awesome-pattern-matching/blob/main/docs/apm_vs_pep634.md)._`apm`_ defines patterns as objects which are _composable_ and _reusable_. Pieces can be matched and captured intovariables, much like pattern matching in Haskell or Scala (a feature which most libraries actually lack, but which alsomakes pattern matching useful in the first place - the capability to easily extract data). Here is an example:```pythonfrom apm import *if result := match([1, 2, 3, 4, 5], [1, '2nd' @ _, '3rd' @ _, 'tail' @ Remaining(...)]):    print(result['2nd'])   # 2    print(result['3rd'])   # 3    print(result['tail'])  # [4, 5]# If you find it more readable, '&gt;&gt;' can be used instead of '@' to capture a variablematch([1, 2, 3, 4, 5], [1, _ &gt;&gt; '2nd', _ &gt;&gt; '3rd', Remaining(...) &gt;&gt; 'tail'])```Patterns can be composed using `&amp;`, `|`, and `^`, or via their more explicit counterparts `AllOf`, `OneOf`, and `Either`. Since patterns are objects, they can be stored in variables and be reused.```pythonpositive_integer = InstanceOf(int) &amp; Check(lambda x: x &gt;= 0)```Some fancy matching patterns are available out of the box:```pythonfrom apm import *def f(x: int, y: float) -&gt; int:    passif match(f, Arguments(int, float) &amp; Returns(int)):    print(&quot;Function satisfies required signature&quot;)```## Multiple StylesFor matching and selecting from multiple cases, choose your style:```pythonfrom apm import *value = 7# The simple styleif match(value, Between(1, 10)):    print(&quot;It's between 1 and 10&quot;)elif match(value, Between(11, 20)):    print(&quot;It's between 11 and 20&quot;)else:    print(&quot;It's not between 1 and 20&quot;)# The expression stylecase(value) \    .of(Between(1, 10), lambda: print(&quot;It's between 1 and 10&quot;)) \    .of(Between(11, 20), lambda: print(&quot;It's between 11 and 20&quot;)) \    .otherwise(lambda: print(&quot;It's not between 1 and 20&quot;))# The statement styletry:    match(value)except Case(Between(1, 10)):    print(&quot;It's between 1 and 10&quot;)except Case(Between(11, 20)):    print(&quot;It's between 11 and 20&quot;)except Default:    print(&quot;It's not between 1 and 20&quot;)# The declarative style@case_distinctiondef f(n: Match(Between(1, 10))):    print(&quot;It's between 1 and 10&quot;)@case_distinctiondef f(n: Match(Between(11, 20))):    print(&quot;It's between 11 and 20&quot;)@case_distinctiondef f(n):    print(&quot;It's not between 1 and 20&quot;)f(value)# The terse (pampy) stylematch(value,      Between( 1, 10), lambda: print(&quot;It's between 1 and 10&quot;),      Between(11, 20), lambda: print(&quot;It's between 11 and 20&quot;),      _,               lambda: print(&quot;It's not between 1 and 20&quot;))```## Nested pattern matchesPatterns are applied recursively, such that nested structures can be matched arbitrarily deep.This is super useful for extracting data from complicated structures:```pythonfrom apm import *sample_k8s_response = {    &quot;containers&quot;: [        {            &quot;args&quot;: [                &quot;--cert-dir=/tmp&quot;,                &quot;--secure-port=4443&quot;,                &quot;--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname&quot;,                &quot;--kubelet-use-node-status-port&quot;            ],            &quot;image&quot;: &quot;k8s.gcr.io/metrics-server/metrics-server:v0.4.1&quot;,            &quot;imagePullPolicy&quot;: &quot;IfNotPresent&quot;,            &quot;name&quot;: &quot;metrics-server&quot;,            &quot;ports&quot;: [                {                    &quot;containerPort&quot;: 4443,                    &quot;name&quot;: &quot;https&quot;,                    &quot;protocol&quot;: &quot;TCP&quot;                }            ]        }    ]}if result := match(sample_k8s_response, {        &quot;containers&quot;: Each({            &quot;image&quot;: 'image' @ _,            &quot;name&quot;: 'name' @ _,            &quot;ports&quot;: Each({                &quot;containerPort&quot;: 'port' @ _            }),        })    }):    print(f&quot;Image: {result['image']}, Name: {result['name']}, Port: {result['port']}&quot;)```The above will print```Image: k8s.gcr.io/metrics-server/metrics-server:v0.4.1, Name: metrics-server, Port: 4443```## MultimatchBy default `match` records only the last match for captures. If for example `'item' @ InstanceOf(int)` matches multiple times,the last match will be recorded in `result['item']`. `match` can record all captures using the `multimatch=True` flag:```pythonif result := match([{'foo': 5}, 3, {'foo': 7, 'bar': 9}], Each(OneOf({'foo': 'item' @ _}, ...)), multimatch=True):    print(result['item'])  # [5, 7]# The default since v0.15.0 is multimatch=Falseif result := match([{'foo': 5}, 3, {'foo': 7, 'bar': 9}], Each(OneOf({'foo': 'item' @ _}, ...))):  print(result['item'])  # 7```## Strict vs non-strict matchesAny value which occurs verbatim in a pattern is matched verbatim (`int`, `str`, `list`, ...), except Dictionaries (anything which has an `items()` actually).Thus:```pythonsome_very_complex_object = {    &quot;A&quot;: 1,    &quot;B&quot;: 2,    &quot;C&quot;: 3,}match(some_very_complex_object, {&quot;C&quot;: 3})  # matches!```If you do not want unknown keys to be ignored, wrap the pattern in a `Strict`:```python# does not match, only matches exactly `{&quot;C&quot;: 3}`match(some_very_complex_object, Strict({&quot;C&quot;: 3}))```Lists (anything iterable which does not have an `items()` actually) are also compared as they are, i.e.:```pythonls = [1, 2, 3]match(ls, [1, 2, 3])  # matchesmatch(ls, [1, 2])  # does not match```## Match head and tail of a listIt is possible to match the remainder of a list though:```pythonmatch(ls, [1, 2, Remaining(InstanceOf(int))])```And each item:```pythonmatch(ls, Each(InstanceOf(int)))```Patterns can be joined using `&amp;`, `|`, and `^`:```pythonmatch(ls, Each(InstanceOf(int) &amp; Between(1, 3)))```Wild-card matches are supported using Ellipsis (`...`):```pythonmatch(ls, [1, Remaining(..., at_least=2)])```The above example also showcases how `Remaining` can be made to match`at_least` _n_ number of items (`Each` also has an `at_least` keyword argument).## Wildcard matches anything using `_`A wildcard pattern can be expressed using `_`. `_` is a `Pattern` and thus `&gt;&gt;` and `@` can be used with it.```pythonmatch([1, 2, 3, 4], [1, _, 3, _])```## Wildcard matches anything using `...`The `Ellipsis` can be used as a wildcard match, too. It is however not a `Pattern` (so `|`, `&amp;`, `@`, etc. can notbe used on it). If you actually want to match `Ellipsis`, wrap it using `Value(...)`.Otherwise `...` is equivalent for most intents and purposes to `_`:```pythonmatch([1, 2, 3, 4], [1, ..., 3, ...])```## Support for dataclasses```python@dataclassclass User:    first_name: str    last_name: strvalue = User(&quot;Jane&quot;, &quot;Doe&quot;)if match(value, User(_, &quot;Doe&quot;)):    print(&quot;Welcome, member of the Doe family!&quot;)elif match(value, User(_, _)):    print(&quot;Welcome, anyone!&quot;)```## The different styles in detail### Simple style- ðŸ’š has access to result captures- ðŸ’š vanilla python- ðŸ’” no case guards- ðŸ’” can not return values (since it's a statement, not an expression)- ðŸ–¤ a bit repetetive- ðŸ’š simplest and most easy to understand style- ðŸ–¤ fastest of them all```pythonfrom apm import *value = {&quot;a&quot;: 7, &quot;b&quot;: &quot;foo&quot;, &quot;c&quot;: &quot;bar&quot;}if result := match(value, EachItem(_, 'value' @ InstanceOf(str) | ...), multimatch=True):    print(result['value'])  # [&quot;foo&quot;, &quot;bar&quot;]```#### pre `:=` version (Python 3.7)`bind()` can be used on a `MatchResult` to bind the matched items to an existing dictionary.```pythonfrom apm import *value = {&quot;a&quot;: 7, &quot;b&quot;: &quot;foo&quot;, &quot;c&quot;: &quot;bar&quot;}result = {}if match(value, EachItem(_, 'value' @ InstanceOf(str) | ...)).bind(result):    print(result['value'])  # [&quot;foo&quot;, &quot;bar&quot;]elif match(value, {&quot;quux&quot;: _ &gt;&gt; 'quux'}).bind(result):    print(result['quux'])```### Expression style- ðŸ’š has access to result captures- ðŸ’š vanilla python- ðŸ’š can return values directly as it is an expression- ðŸ’š can use case guards via `when=` or `guarded`- ðŸ–¤ so terse that it is sometimes hard to readThe expression style is summarized:```pythoncase(value).of(pattern, action) ... .otherwise(default_action)```...where action is either a value or a callable. The captures from the matching result are bound to the namedparameters of the given callable, i.e. `result['foo']` and `result['bar']` from `'foo' @ _` and `'bar' @ _` will bebound to `foo` and `bar` respectively in `lambda foo, bar: ...`.```pythonfrom apm import *display_name = case({'user': 'some-user-id', 'first_name': &quot;Jane&quot;, 'last_name': &quot;Doe&quot;}) \    .of({'first_name': 'first' @ _, 'last_name': 'last' @ _}, lambda first, last: f&quot;{first}, {last}&quot;) \    .of({'user': 'user_id' @ _}, lambda user_id: f&quot;#{user_id}&quot;) \    .otherwise(&quot;anonymous&quot;)```_Note: To return a value an `.otherwise(...)` case must always be present._### Statement styleThis is arguable the most hacky style in _`apm`_, as it re-uses the `try .. except`mechanism. It is nevertheless quite readable.- ðŸ’š has access to result captures- ðŸ’š very readable- ðŸ’” can not return values (since it's a statement, not an expression)- ðŸ’š can use case guards via `when=`- ðŸ–¤ misuse of the `try .. except` statement```pythonfrom apm import *try:    match({'user': 'some-user-id', 'first_name': &quot;Jane&quot;, 'last_name': &quot;Doe&quot;})except Case({'first_name': 'first' @ _, 'last_name': 'last' @ _}) as result:    user = f&quot;{result['first']} {result['last']}&quot;except Case({'user': 'user_id' @ _}) as result:    user = f&quot;#{result['user_id']}&quot;except Default:    user = &quot;anonymous&quot;print(user)  # &quot;Jane Doe&quot;```### Declarative style- ðŸ’” does not have access to result captures- ðŸ’š very readable- ðŸ’š can use case guards via `when=`- ðŸ’š can return values- ðŸ–¤ the most bloated version of all styles```pythonfrom apm import *@case_distinctiondef fib(n: Match(OneOf(0, 1))):   return n@case_distinctiondef fib(n):    return fib(n - 2) + fib(n - 1)for i in range(0, 6):    print(fib(i))```#### Nota bene: Overloading using `@case_distinction`If not for its pattern matching capabilities, `@case_distinction` can be usedto implement overloading. In fact, it can be imported as `@overload`.The mechanism is aware of arity and argument types.```pythonfrom apm.overload import overload@overloaddef add(a: str, b: str):    return &quot;&quot;.join([a, b])@overloaddef add(a: int, b: int):    return a + badd(&quot;a&quot;, &quot;b&quot;)add(1, 2)```### Terse style- ðŸ’š has access to result captures- ðŸ’š can use case guards via `guarded`- ðŸ’š very concise- ðŸ’š can return values- ðŸ–¤ very readable when formatted nicely- ðŸ–¤ not so well suited for larger match actions- ðŸ–¤ slowest of them allAs the name indicates the &quot;terse&quot; style is terse. It is inspired by the `pampy`pattern matching library and mimics some of its behavior. Despite a slim surfacearea it also comes with some simplifications:- A type given as a pattern is matched against as if it was wrapped in an `InstanceOf`- `re.Pattern` objects (result of `re.compile`) are matched against as if it was given via `Regex`- Captures are passed to actions in the same order as they occur in the pattern (not by name)```pythonfrom apm import *def fibonacci(n):  return match(n,               1, 1,               2, 1,               _, lambda x: fibonacci(x - 1) + fibonacci(x - 2)               )fibonacci(6)  # -&gt; 8 class Animal:        passclass Hippo(Animal): passclass Zebra(Animal): passclass Horse(Animal): passdef what_am_i(x):  return match(x,               Hippo,  'hippopotamus',               Zebra,  'zebra',               Animal, 'some other animal',               _,      'not at all an animal',               )what_am_i(Hippo())  # -&gt; 'hippopotamus'what_am_i(Zebra())  # -&gt; 'zebra'what_am_i(Horse())  # -&gt; 'some other animal'what_am_i(42)       # -&gt; 'not at all an animal'```## Available patterns### `Capture(pattern, name=&lt;str&gt;)`Captures a piece of the thing being matched by name.```pythonif result := match([1, 2, 3, 4], [1, 2, Capture(Remaining(InstanceOf(int)), name='tail')]):    print(result['tail'])  ## -&gt; [3, 4]```As this syntax is rather verbose, two shorthand notations can be used:```python# using the matrix multiplication operator '@' (syntax resembles that of Haskell and Scala)if result := match([1, 2, 3, 4], [1, 2, 'tail' @ Remaining(InstanceOf(int))]):    print(result['tail'])  ## -&gt; [3, 4]# using the right shift operatorif result := match([1, 2, 3, 4], [1, 2, Remaining(InstanceOf(int)) &gt;&gt; 'tail']):    print(result['tail'])  ## -&gt; [3, 4]```### `Strict(pattern)`Performs a strict pattern match. A strict pattern match also compares the type of verbatim values. That is, while_`apm`_ would match `3` with `3.0` it would not do so when using `Strict`. Also _`apm`_ performs partial matches ofdictionaries (that is: it ignores unknown keys). It will perform an exact match for dictionaries using `Strict`.```python# The following will matchmatch({&quot;a&quot;: 3, &quot;b&quot;: 7}, {&quot;a&quot;: ...})match(3.0, 3)# These will not matchmatch({&quot;a&quot;: 3, &quot;b&quot;: 7}, Strict({&quot;a&quot;: ...}))match(3.0, Strict(3))```### `OneOf(*pattern)`Matches against any of the provided patterns. Equivalent to `p1 | p2 | p3 | ..`(but operator overloading does not work with values that do not inherit from `Pattern`)```pythonmatch(&quot;quux&quot;, OneOf(&quot;bar&quot;, &quot;baz&quot;, &quot;quux&quot;))``````pythonmatch(3, OneOf(InstanceOf(int), None))```Patterns can also be joined using `|` to form a `OneOf` pattern:```pythonmatch(3, InstanceOf(int) | InstanceOf(float))```The above example is rather contrived, as `InstanceOf` already accepts multiple types natively:```pythonmatch(3, InstanceOf(int, float))```Since bare values do not inherit from `Pattern` they can be wrapped in `Value`:```pythonmatch(&quot;quux&quot;, Value(&quot;foo&quot;) | Value(&quot;quux&quot;))```### `AllOf(*pattern)`Checks whether the value matches all of the given pattern. Equivalent to `p1 &amp; p2 &amp; p3 &amp; ..`(but operator overloading does not work with values that do not inherit from `Pattern`)```pythonmatch(&quot;quux&quot;, AllOf(InstanceOf(&quot;str&quot;), Regex(&quot;[a-z]+&quot;)))```### `NoneOf(*pattern)`Same as `Not(OneOf(*pattern))` (also `~OneOf(*pattern)`).### `Not(pattern)`Matches if the given pattern does not match.```pythonmatch(3, Not(4))  # matchesmatch(5, Not(4))  # matchesmatch(4, Not(4))  # does not match```The bitflip prefix operator (`~`) can be used to express the same thing. Note that it does not work on bare values,so they need to be wrapped in `Value`.```pythonmatch(3, ~Value(4))  # matchesmatch(5, ~Value(4))  # matchesmatch(4, ~Value(4))  # does not match````Not` can be used do create a `NoneOf` kind of pattern:```pythonmatch(&quot;string&quot;, ~OneOf(&quot;foo&quot;, &quot;bar&quot;))  # matches everything except &quot;foo&quot; and &quot;bar&quot;````Not` can be used to create a pattern that never matches:```pythonNot(...)```### `Each(pattern [, at_least=]`Matches each item in an iterable.```pythonmatch(range(1, 10), Each(Between(1, 9)))```### `EachItem(key_pattern, value_pattern)`Matches an object if each key satisfies `key_pattern` and each value satisfies `value_pattern`.```pythonmatch({&quot;a&quot;: 1, &quot;b&quot;: 2}, EachItem(Regex(&quot;[a-z]+&quot;), InstanceOf(int)))```### `Some(pattern)` (aka `Many` and `Remaining`)Matches a sequence of items within a list:```pythonif result := match(range(1, 10), [1, 'a' @ Some(...), 4, 'b' @ Some(...), 8, 9]):    print(result['a'])  # [2, 3]    print(result['b'])  # [5, 6, 7]```Takes the optional values `exactly`, `at_least`, and `at_most` which makes `Some` matcheither `exactly` _n_ items, `at_least` _n_, or `at_most` _n_ items (`at_least` and `at_most` can be given at the sametime, but not together with `exactly`).Note the difference between `Some(1, 2)` and `Some([1, 2])`. The first version matches subsequences, the secondversion matches items which are themselves lists:```pythonmatch([0,  1, 2 ,  1, 2 , 3], [0, Some( 1, 2 ), 3])  # matches the subsequence 1, 2 twicematch([0, [1, 2], [1, 2], 3], [0, Some([1, 2]), 3])  # matches the item [1, 2] twice, which happen to be lists````Some` also goes by the names of `Many` and `Remaining`, which is sometimes nice to convey meaning:```pythonmatch(range(1, 10), [1, 2, 'remaining' @ Remaining()])match([0, 1, 1, 1, 2, 1], [0, Many(1), Remaining(InstanceOf(int))])```When used with no arguments, `Some()` is the same as `Some(...)`.### `Remainder(pattern)`Can be used to match the unmatched parts of a Dictionary/Mapping.```pythonresult = match({    &quot;foo&quot;: 1,    &quot;bar&quot;: 2,    &quot;qux&quot;: 4,    &quot;quuz&quot;: 8,}, {&quot;foo&quot;: 'foo' @ _, &quot;bar&quot;: 'bar' @ _} ** Remainder('rs' @ _))print(result.foo)  # 1print(result.bar)  # 2print(result.rs)   # {'qux': 4, 'quuz': 8}````Remainder` is, strictly speaking, not a `Pattern` and only works in conjunction with `**` on dictionaries,and it only works on the right-hand side of the dictionary.### `Between(lower, upper)`Matches an object if it is between `lower` and `upper` (inclusive). The optional keyword arguments`lower_bound_exclusive` and `upper_bound_exclusive` can be set to `True` respectively to exclude thelower/upper from the range of matching values.### `Length(length)`Matches an object if it has the given length. Alternatively also accepts `at_least` and `at_most` keyword arguments.```pythonmatch(&quot;abc&quot;, Length(3))match(&quot;abc&quot;, Length(at_least=2))match(&quot;abc&quot;, Length(at_most=4))match(&quot;abc&quot;, Length(at_least=2, at_most=4))```### `Contains(item)`Matches an object if it contains the given item (as per the same logic as the `in` operator).```pythonmatch(&quot;hello there, world&quot;, Contains(&quot;there&quot;))match([1, 2, 3], Contains(2) &amp; Contains(3))match({'foo': 1, 'bar': 2}, Contains('quux') | Contains('bar'))```### `Regex(regex_pattern, bind_groups: bool = True)`Matches a string if it completely matches the given regex, as per `re.fullmatch`.If the regular expression pattern contains named capturing groups and `bind_groups` is set to `True`,this pattern will bind the captured results in the `MatchResult` (the default).To mimic `re.match` or `re.search` the given regular expression `x` can be augmented as `x.*` or `.*x.*`respectively.### `Check(predicate)`Matches an object if it satisfies the given predicate.```pythonmatch(2, Check(lambda x: x % 2 == 0))```### `InstanceOf(*types)`Matches an object if it is an instance of any of the given types.```pythonmatch(1, InstanceOf(int, flaot))```### `SubclassOf(*types)`Matches if the matched type is a subclass of any of the given types.```pythonmatch(int, SubclassOf(int, float))```### `Parameters(...)`Matches the parameters of a callable.```pythondef f(x: int, *xs: float, y: str, **kwargs: bool):    passmatch(f, Parameters(int, VarArgs(float), y=str, KwArgs(bool)))```Each argument to Parameters is expected to be the type of a positional argument.`Parameters` matches function signatures if their positional arguments match completely, i.e.```pythondef f(x: int, y: float):    passprint(bool(match(f, Parameters(int))))  # Falseprint(bool(match(f, Parameters(int, float))))  # Trueprint(bool(match(f, Parameters(int, Remaining(_)))))  # True```Keyword arguments are matched only if they are keyword only arguments. In contrast to positional arguments it matchesalso impartially (which aligns with the non-strict matching behavior with respect to dictionaries):```pythondef f(x: int, *, y: str, z: float):    passprint(bool(match(f, Parameters(int))))  # Trueprint(bool(match(f, Parameters(y=str))))  # False â€“ positional parameters not matchedprint(bool(match(f, Parameters(int, y=str))))  # True```This can be changed with `Strict`:```pythondef f(x: int, *, y: str, z: float):    passprint(bool(match(f, Strict(Parameters(int)))))  # Falseprint(bool(match(f, Strict(Parameters(int, y=str)))))  # False  (z not mentioned but present)print(bool(match(f, Strict(Parameters(int, y=str, z=float)))))  # True  (has y and z exactly)```### `Arguments(*types)`&lt;span style=&quot;color: red&quot;&gt;**DEPRECATED, use `Parameters` instead (see above)**&lt;/span&gt;Matches a callable if it's type annotations correspond to the given types.```pythondef f(x: int, y: float, z):    ...match(f, Arguments(int, float, None))```Arguments has an alternate form which can be used to match keyword arguments:```pythondef f(x: int, y: float, z: str):    ...match(f, Arguments(x=int, y=float))```The strictness rules are the same as for dictionaries (which is why the above example works).```python# given the f from abovematch(f, Strict(Arguments(x=int, y=float)))  # does not matchmatch(f, Strict(Arguments(x=int, y=float, z=str)))  # matches```### `Returns(type)`Matches a callable if it's type annotations denote the given return type.```pythondef g(x: int) -&gt; str:    ...match(g, Arguments(int) &amp; Returns(str))```### `Transformed(function, pattern)`Transforms the currently looked at value by applying `function` on it and matches the result against `pattern`. InHaskell and other languages this is known as a [_viewpattern_](https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns).```pythondef sha256(v: str) -&gt; str:    import hashlib    return hashlib.new('sha256', v.encode('utf8')).hexdigest()match(&quot;hello&quot;, Transformed(sha256, &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot;))```This is handy for matching data types like `datetime.date` as this pattern won't match if the transformationfunction errored out with an exception.```pythonfrom apm import *from datetime import dateif result := match(&quot;2020-08-27&quot;, Transformed(date.fromisoformat, 'date' @ _):    print(repr(result['date']))  # result['date'] is a datetime.date```### `At(path, pattern)`Checks whether the nested object to be matched satisfies pattern at the given path. The match fails if the given pathcan not be resolved.```pythonrecord = {    &quot;foo&quot;: {        &quot;bar&quot;: {            &quot;quux&quot;: {                &quot;value&quot;: &quot;deeply nested&quot;            }        }    }}result := match(record, At(&quot;foo.bar.quux&quot;, {&quot;value&quot;: Capture(..., name=&quot;value&quot;)}))result['value']  # &quot;deeply nested&quot;# alternate formresult := match(record, At(['foo', 'bar', 'quux'], {&quot;value&quot;: Capture(..., name=&quot;value&quot;)}))```### `Items(**kwargs))`Mostly syntactic sugar to match a dictionary nicely (and anything that provides an `.items()` method).```pythonfrom apm import *from datetime import datetimerequest = {    &quot;api_version&quot;: &quot;v1&quot;,    &quot;job&quot;: {        &quot;run_at&quot;: &quot;2020-08-27 14:09:30&quot;,        &quot;command&quot;: &quot;echo 'booya'&quot;,    }}if result := match(request, Items(    api_version=&quot;v1&quot;,    job=Object(        run_at=Transformed(datetime.fromisoformat, 'time' @ _),    ) &amp; OneOf(        Items(command='command' @ InstanceOf(str)),        Items(spawn='container' @ InstanceOf(str)),    ))):    print(repr(result['time']))      # datetime(2020, 8, 27, 14, 9, 30)    print('container' not in result) # True    print(result['command'])         # &quot;echo 'booya'&quot;```### `Object(type, *args, **kwargs)`Matches any object of the specific type with the given attrs as in `**kwargs`.It respects the `__match_args__` introduced by PEP-634.```pythonfrom apm import *from typing import Literal, Tupleclass Click:    __match_args__ = (&quot;position&quot;, &quot;button&quot;)    def __init__(self, pos: Tuple[int, int], btn: Literal['left', 'right', 'middle']):        self.position = pos        self.button = btnassert match(Click((1, 2), 'left'), Object(Click, (1, 2)))assert match(Click((1, 2), 'left'), Object(Click, (1, 2), 'left'))assert match(Click((1, 2), 'left'), Object(Click, (1, 2), button='left'))```## ExtensibleNew patterns can be added, just like the ones in `apm.patterns.*`. Simply extend the `apm.Pattern` class:```pythonclass Min(Pattern):    def __init__(self, min):        self.min = min    def match(self, value, *, ctx: MatchContext, strict=False) -&gt; MatchResult:        return ctx.match_if(value &gt;= self.min)match(3, Min(1))  # matchesmatch(3, Min(5))  # does not match```</longdescription>
</pkgmetadata>