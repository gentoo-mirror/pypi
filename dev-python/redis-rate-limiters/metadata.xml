<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Redis rate limitersA library which regulates traffic, with respect to concurrency or time.It implements sync and async context managers for a [semaphore](#semaphore)- and a [token bucket](#token-bucket)-implementation.The rate limiters are distributed, using Redis, and leverages Lua scripts toimprove performance and simplify the code. Lua scriptsrun on Redis, and make each implementation fully atomic, whilealso reducing the number of round-trips required.Use is supported for standalone redis instances, and clusters.We currently only support Python 3.11, but can add support for older versions if needed.## Installation```pip install redis-rate-limiters```## Usage### SemaphoreThe semaphore classes are useful when you have concurrency restrictions;e.g., say you're allowed 5 active requests at the time for a given API token.Beware that the client will block until the Semaphore is acquired,or the `max_sleep` limit is exceeded. If the `max_sleep` limit is exceeded, a `MaxSleepExceededError` is raised.Here's how you might use the async version:```pythonimport asynciofrom httpx import AsyncClientfrom redis.asyncio import Redisfrom limiters import AsyncSemaphorelimiter = AsyncSemaphore(    name=&quot;foo&quot;,    # name of the resource you are limiting traffic for    capacity=5,    # allow 5 concurrent requests    max_sleep=30,  # raise an error if it takes longer than 30 seconds to acquire the semaphore    expiry=30,      # set expiry on the semaphore keys in Redis to prevent deadlocks    connection=Redis.from_url(&quot;redis://localhost:6379&quot;),)async def get_foo():    async with AsyncClient() as client:        async with limiter:            client.get(...)async def main():    await asyncio.gather(        get_foo() for i in range(100)    )```and here is how you might use the sync version:```pythonimport requestsfrom redis import Redisfrom limiters import SyncSemaphorelimiter = SyncSemaphore(    name=&quot;foo&quot;,    capacity=5,    max_sleep=30,    expiry=30,    connection=Redis.from_url(&quot;redis://localhost:6379&quot;),)def main():    with limiter:        requests.get(...)```### Token bucketThe `TocketBucket` classes are useful if you're working with time-basedrate limits. Say, you are allowed 100 requests per minute, for a given API token.If the `max_sleep` limit is exceeded, a `MaxSleepExceededError` is raised.Here's how you might use the async version:```pythonimport asynciofrom httpx import AsyncClientfrom redis.asyncio import Redisfrom limiters import AsyncTokenBucketlimiter = AsyncTokenBucket(    name=&quot;foo&quot;,          # name of the resource you are limiting traffic for    capacity=5,          # hold up to 5 tokens    refill_frequency=1,  # add tokens every second    refill_amount=1,     # add 1 token when refilling    max_sleep=30,        # raise an error there are no free tokens for 30 seconds    connection=Redis.from_url(&quot;redis://localhost:6379&quot;),)async def get_foo():    async with AsyncClient() as client:        async with limiter:            client.get(...)async def main():    await asyncio.gather(        get_foo() for i in range(100)    )```and here is how you might use the sync version:```pythonimport requestsfrom redis import Redisfrom limiters import SyncTokenBucketlimiter = SyncTokenBucket(    name=&quot;foo&quot;,    capacity=5,    refill_frequency=1,    refill_amount=1,    max_sleep=30,    connection=Redis.from_url(&quot;redis://localhost:6379&quot;),)def main():    with limiter:        requests.get(...)```### Using them as a decoratorWe don't ship decorators in the package, but if you wouldlike to limit the rate at which a whole function is run,you can create your own, like this:```pythonfrom limiters import AsyncSemaphore# Define a decorator functiondef limit(name, capacity):  def middle(f):    async def inner(*args, **kwargs):      async with AsyncSemaphore(name=name, capacity=capacity):        return await f(*args, **kwargs)    return inner  return middle# Then pass the relevant limiter arguments like this@limit(name=&quot;foo&quot;, capacity=5)def fetch_foo(id: UUID) -&gt; Foo:```## ContributingContributions are very welcome. Here's how to get started:- Set up a Python 3.11+ venv, and `pip install poetry`- Install dependencies with `poetry install`- Run `pre-commit install` to set up pre-commit- Install [just](https://just.systems/man/en/) and run `just setup`  If you prefer not to install just, just take a look at the justfile and  run the commands yourself.- Make your code changes, with tests- Commit your changes and open a PR## Publishing a new versionTo publish a new version:- Update the package version in the `pyproject.toml`- Open [Github releases](https://github.com/otovo/redis-rate-limiters/releases)- Press &quot;Draft a new release&quot;- Set a tag matching the new version (for example, `v0.4.2`)- Set the title matching the tag- Add some release notes, explaining what has changed- PublishOnce the release is published, our [publish workflow](https://github.com/otovo/redis-rate-limiters/blob/main/.github/workflows/publish.yaml) should be triggeredto push the new version to PyPI.</longdescription>
</pkgmetadata>