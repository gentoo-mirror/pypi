<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Build Status](https://api.travis-ci.org/kolypto/py-smsframework.png?branch=master)](https://travis-ci.org/kolypto/py-smsframework)[![Pythons](https://img.shields.io/badge/python-2.7%20%7C%203.4%E2%80%933.7%20%7C%20pypy-blue.svg)](.travis.yml)SMSframework============SMS framework with pluggable providers.Key features:* Send messages* Receive messages* Delivery confirmations* Handle multiple pluggable providers with a single gateway* Synchronous message receipt through events* Reliable message handling* Supports provider APIs (like getting the balance)* Providers use [Flask microframework](http://flask.pocoo.org) for message receivers (not required)* 0 dependencies* Unit-testedTable of Contents=================* &lt;a href=&quot;#tutorial&quot;&gt;Tutorial&lt;/a&gt;* &lt;a href=&quot;#user-content-supported-providers&quot;&gt;Supported Providers&lt;/a&gt;* &lt;a href=&quot;#user-content-installation&quot;&gt;Installation&lt;/a&gt;* &lt;a href=&quot;#user-content-gateway&quot;&gt;Gateway&lt;/a&gt;    * &lt;a href=&quot;#user-content-providers&quot;&gt;Providers&lt;/a&gt;        * &lt;a href=&quot;#user-content-gatewayadd_providername-provider-configiprovider&quot;&gt;Gateway.add_provider(name, Provider, **config):IProvider&lt;/a&gt;        * &lt;a href=&quot;#user-content-gatewaydefault_provider&quot;&gt;Gateway.default_provider&lt;/a&gt;        * &lt;a href=&quot;#user-content-gatewayget_providernameiprovider&quot;&gt;Gateway.get_provider(name):IProvider&lt;/a&gt;    * &lt;a href=&quot;#user-content-sending-messages&quot;&gt;Sending Messages&lt;/a&gt;        * &lt;a href=&quot;#user-content-gatewaysendmessageoutgoingmessage&quot;&gt;Gateway.send(message):OutgoingMessage&lt;/a&gt;    * &lt;a href=&quot;#user-content-event-hooks&quot;&gt;Event Hooks&lt;/a&gt;        * &lt;a href=&quot;#user-content-gatewayonsend&quot;&gt;Gateway.onSend&lt;/a&gt;        * &lt;a href=&quot;#user-content-gatewayonreceive&quot;&gt;Gateway.onReceive&lt;/a&gt;        * &lt;a href=&quot;#user-content-gatewayonstatus&quot;&gt;Gateway.onStatus&lt;/a&gt;* &lt;a href=&quot;#user-content-data-objects&quot;&gt;Data Objects&lt;/a&gt;    * &lt;a href=&quot;#user-content-incomingmessage&quot;&gt;IncomingMessage&lt;/a&gt;    * &lt;a href=&quot;#user-content-outgoingmessage&quot;&gt;OutgoingMessage&lt;/a&gt;    * &lt;a href=&quot;#user-content-messagestatus&quot;&gt;MessageStatus&lt;/a&gt;    * &lt;a href=&quot;#user-content-exceptions&quot;&gt;Exceptions&lt;/a&gt;* &lt;a href=&quot;#user-content-provider-http-receivers&quot;&gt;Provider HTTP Receivers&lt;/a&gt;    * &lt;a href=&quot;#user-content-gatewayreceiver_blueprint_forname-flaskblueprint&quot;&gt;Gateway.receiver_blueprint_for(name): flask.Blueprint&lt;/a&gt;    * &lt;a href=&quot;#user-content-gatewayreceiver_blueprintsname-flaskblueprint&quot;&gt;Gateway.receiver_blueprints():(name, flask.Blueprint)*&lt;/a&gt;    * &lt;a href=&quot;#user-content-gatewayreceiver_blueprints_registerapp-prefixflaskflask&quot;&gt;Gateway.receiver_blueprints_register(app, prefix='/'):flask.Flask&lt;/a&gt;* &lt;a href=&quot;#user-content-message-routing&quot;&gt;Message Routing&lt;/a&gt;* &lt;a href=&quot;#user-content-bundled-providers&quot;&gt;Bundled Providers&lt;/a&gt;    * &lt;a href=&quot;#user-content-nullprovider&quot;&gt;NullProvider&lt;/a&gt;    * &lt;a href=&quot;#user-content-logprovider&quot;&gt;LogProvider&lt;/a&gt;    * &lt;a href=&quot;#user-content-loopbackprovider&quot;&gt;LoopbackProvider&lt;/a&gt;        * &lt;a href=&quot;#user-content-loopbackproviderget_trafficlist&quot;&gt;LoopbackProvider.get_traffic():list&lt;/a&gt;        * &lt;a href=&quot;#user-content-loopbackproviderreceivedsrc-bodyincomingmessage&quot;&gt;LoopbackProvider.received(src, body):IncomingMessage&lt;/a&gt;        * &lt;a href=&quot;#user-content-loopbackprovidersubscribenumber-callbackiprovider&quot;&gt;LoopbackProvider.subscribe(number, callback):IProvider&lt;/a&gt;    * &lt;a href=&quot;#user-content-forwardserverprovider-forwardclientprovider&quot;&gt;ForwardServerProvider, ForwardClientProvider&lt;/a&gt;        * &lt;a href=&quot;#user-content-forwardclientprovider&quot;&gt;ForwardClientProvider&lt;/a&gt;        * &lt;a href=&quot;#user-content-forwardserverprovider&quot;&gt;ForwardServerProvider&lt;/a&gt;            * &lt;a href=&quot;#user-content-routing-server&quot;&gt;Routing Server&lt;/a&gt; Tutorial========## Sending MessagesIn order to send a message, you will use a `Gateway`:```pythonfrom smsframework import Gatewaygateway = Gateway()```By itself, it cannot do anything. However, if you install a *provider* -- a library that implements some SMS service --you can add it to the `Gateway` and configure it to send your messages through a provider:```pythonfrom smsframework_clickatell import ClickatellProvidergateway.add_provider('main', ClickatellProvider)  # the default one```The first provider defined becomes the default one. (If you have multiple providers, `Gateway` supports routing: rules that select which provider to use).Now, let's send a message:```pythonfrom smsframework import OutgoingMessagegateway.send(OutgoingMessage('+123456789', 'hi there!'))``` ## Receiving MessagesIn order to receive messages, you will use the same `Gateway` object and ask it to generate an HTTP API endpointfor you. It uses Flask framework, and you'll need to run a Flask application in order to receive SMS messages:```pyhonfrom flask import Flaskapp = Flask()bp = gateway.receiver_blueprint_for('main')  # SMS receiverapp.register_blueprint(bp, url_prefix='/sms/main')  # register it with Flask```Now, use Clickatell's web interface and register the following URL: `http://example.com/sms/main`.It will send you messages to the application.Next, you need to handle the incoming messages in your code.To to this, you need to subscribe your handler to the `gateway.onReceive` event:```pythondef on_receive(message):    &quot;&quot;&quot; :type message: IncomingMessage &quot;&quot;&quot;    pass  # Your logic heregateway.onReceive += on_receive```In addition to receiving messages, you can receive status reports about the messages you have sent.See &lt;a href=&quot;#user-content-gatewayonstatus&quot;&gt;Gateway.onStatus&lt;/a&gt; for more information.Supported Providers===================SMSframework supports the following bundled providers:* [log](#logprovider): log provider for testing. Bundled.* [null](#nullprovider): null provider for testing. Bundled.* [loopback](#loopbackprovider): loopback provider for testing. Bundled.Supported providers list:* [Clickatell](https://github.com/kolypto/py-smsframework-clickatell)* [Vianett](https://github.com/kolypto/py-smsframework-vianett)* [PSWin](https://github.com/dignio/py-smsframework-pswin)* [Twilio Studio](https://github.com/dignio/py-smsframework-twiliostudio)* Expecting more!Also see the [full list of providers](https://pypi.python.org/pypi?%3Aaction=search&amp;term=smsframework).Installation============Install from pypi:    $ pip install smsframeworkInstall with some additional providers:    $ pip install smsframework[clickatell]To receive SMS messages, you need to ensure that [Flask microframework](http://flask.pocoo.org) is also installed:    $ pip install smsframework[clickatell,receiver]Gateway=======SMSframework handles the whole messaging thing with a single *Gateway* object.Let's start with initializing a gateway:```pythonfrom smsframework import Gatewaygateway = Gateway()```The `Gateway()` constructor currently has no arguments.Providers---------A *Provider* is a package which implements the logic for a specific SMS provider.Each provider reside in an individual package `smsframework_*`.You'll probably want to install [some of these](#supported-providers) first.### Gateway.add_provider(name, Provider, **config):IProviderRegister a provider on the gatewayArguments:* `provider: str` Provider name that will be used to uniquely identify it* `Provider: type` Provider class that inherits from `smsframework.IProvider`  You'll use this string in order to send messages via a specific provider.* `**config` Provider configuration. Please refer to the Provider documentation.```pythonfrom smsframework.providers import NullProviderfrom smsframework_clickatell import ClickatellProvidergateway.add_provider('main', ClickatellProvider)  # the default onegateway.add_provider('null', NullProvider)```The first provider defined becomes the default one: used in case the routing function has no better idea.See: [Message Routing](#message-routing).### Gateway.default_providerProperty which contains the default provider name. You can change it to something else:```pythongateway.default_provider = 'null'```### Gateway.get_provider(name):IProviderGet a provider by nameYou don't normally need this, unless the provider has some public API:refer to the provider documentation for the details.Sending Messages----------------### Gateway.send(message):OutgoingMessageTo send a message, you first create the [`OutgoingMessage`](#outgoingmessage) objectand then pass it as the first argument.Arguments:* `message: OutgoingMessage`: The messasge to sendExceptions:* `AssertionError`: Wrong provider name encountered (returned by the router, or provided to OutgoingMessage)* `ProviderError`: Generic provider error* `ConnectionError`: Connection failed* `MessageSendError`: Generic sending error* `RequestError`: Request error: likely, validation errors* `UnsupportedError`: The requested operation is not supported* `ServerError`: Server error: sevice unavailable, etc* `AuthError`: Provider authentication failed* `LimitsError`: Sending limits exceeded* `CreditError`: Not enough money on the accountReturns: the same `OutgoingMessage`, with some additional fields populated: `msgid`, `meta`, ..```pythonfrom smsframework import OutgoingMessagemsg = gateway.send(OutgoingMessage('+123456789', 'hi there!'))```A message sending fail when the provider raises an exception. This typically occurs when the wrapped HTTP APIhas returned an immediate error. Note that some errors occur later, and are typically reported with status messages:see [`MessageStatus`](#messagestatus)Event Hooks-----------The `Gateway` object has three events you can subscribe to.The event is a simple object that implements the `+=` and `-=` operators which allow you to subscribe to the eventand unsubscribe respectively.Event hook is a python callable which accepts arguments explained in the further sections.Note that if you accidentally replace the hook with a callable (using the `=` operator instead of `+=`), you'll endup having a single hook, but smsframework will continue to work normally: thanks to the implementation.See [smsframework/lib/events.py](smsframework/lib/events.py).### Gateway.onSendOutgoing Message: a message that was successfully sent.Arguments:* `message: OutgoingMessage`: The message that was sent. See [OutgoingMessage](#outgoingmessage).The message object is populated with the additional information from the provider, namely, the `msgid` and `meta` fields.Note that if the hook raises an Exception, it will propagate to the place where `Gateway.send()` was called!```pythondef on_send(message):    &quot;&quot;&quot; :type message: OutgoingMessage &quot;&quot;&quot;    print(message)gw.onSend += on_send```### Gateway.onReceiveIncoming Message: a message that was received from the provider.Arguments:* `message: IncomingMessage`: The received message. See [IncomingMessage](#incomingmessage).Note that if the hook raises an Exception, the Provider will report the error to the sms service.Most services will retry the message delivery with increasing delays.```pythondef on_receive(message):    &quot;&quot;&quot; :type message: IncomingMessage &quot;&quot;&quot;    print(message)gw.onReceive += on_receive```### Gateway.onStatusMessage Status: a message status reported by the provider.A status report is only delivered when explicitly requested with `OutgoingMessage.options(status_report=True)`.Arguments:* `status: MessageStatus`: The status info. See [MessageStatus](#messagestatus) and its subclasses.Note that if the hook raises an Exception, the Provider will report the error to the sms service.Most services will retry the status delivery with increasing delays.```pythondef on_status(status):    &quot;&quot;&quot; :type status: MessageStatus &quot;&quot;&quot;    print(status)gw.onStatus += on_status```Data Objects============SMSframework uses the following objects to represent message flows.Note that internally all non-digit characters are removed from all phone numbers, both outgoing and incoming.Phone numbers are typically provided in international formats, though some local providers may be less strict with this.IncomingMessage---------------A messsage received from the provider.Source: [smsframework/data/IncomingMessage.py](smsframework/data/IncomingMessage.py).OutgoingMessage--------------A message being sent.Source: [smsframework/data/OutgoingMessage.py](smsframework/data/OutgoingMessage.py).MessageStatus-------------A status report received from the provider.Source: [smsframework/data/MessageStatus.py](smsframework/data/MessageStatus.py).Exceptions----------Source: [smsframework/exc.py](smsframework/exc.py).Provider HTTP Receivers=======================Note: the whole receiver feature is optional. Skip this section if you only need to send messages.In order to receive messages, most providers need an HTTP handler.To get standardized, by default providers use [Flask microframework](http://flask.pocoo.org) for this:a provider defines a [Blueprint](http://flask.pocoo.org/docs/blueprints/) which can be registered on your Flaskapplication as the receiver endpoint.The resources are provider-dependent: refer to the provider documentation for the details.The recommended approach is to use `/im` for incoming messages, and `/status` for status reports.## Gateway.receiver_blueprint_for(name): flask.BlueprintGet a Flask blueprint for the named provider that handles incoming messages &amp; status reports.Returns: [flask.Blueprint](http://flask.pocoo.org/docs/blueprints/)Errors:* `KeyError`: provider not found* `NotImplementedError`: Provider does not implement a receiverThis method is mostly internal, as the following ones are usually much more convenient.## Gateway.receiver_blueprints():(name, flask.Blueprint)*Get Flask blueprints for every provider that supports it.The method is a generator that yields `(name, blueprint)` tuples,where `blueprint` is `flask.Blueprint` for provider named `name`.Use this method to register your receivers manually:```pythonfrom flask import Flaskapp = Flask()for name, bp in gateway.receiver_blueprints():    app.register_blueprint(bp, url_prefix='/sms/'+name)```With the example above, each receivers will be registered under */name* prefix.Assuming the *'clickatell'* provider defines */im* and */status* receivers and your app is running on *http://localhost:5000/*,you will configure the SMS service to send messages to:* http://localhost:5000/sms/clickatell/im* http://localhost:5000/sms/clickatell/status## Gateway.receiver_blueprints_register(app, prefix='/'):flask.FlaskRegister all provider receivers on the provided Flask application under '/{prefix}/provider-name'.This is a convenience method to register all blueprints at once using the following recommended rules:* If `prefix` is provided, all blueprints are registered under this prefix* Provider receivers are registered under '/provider-name' pathIt's adviced to mount the receivers under some difficult-to-guess prefix: otherwise, attackers can sendfake messages into your system!Secure example:```jsgateway.receiver_blueprints_register(app, '/24fb0d6963f/');```NOTE: Other mechanisms, such as basic authentication, are not typically useful as some services do not support that.Message Routing===============SMSframework requires you to explicitly specify the provider for each message:otherwise, it uses the first defined provider by default.In real world conditions with multiple providers, you may want a router function that decides on which provider to useand which options to pick.In order to achieve flexible message routing, we need to associate some metadata with each message, for instance:* `module`: name of the sending module: e.g. &quot;users&quot;* `type`: type of the message: e.g. &quot;notification&quot;These 2 arbitrary strings need to be standardized in the application code, thus offering the possibility to definecomplex routing rules.When creating the message, use `OutgoingMessage.route()` function to specify these values:```pythongateway.send(OutgoingMessage('+1234', 'hi').route('users', 'notification'))```Now, set a router function on the gateway:a function which gets an outgoing message + some additional routing values, and decides on the provider to use:```pythongateway.add_provider('primary', ClickatellProvider, ...)gateway.add_provider('quick', ClickatellProvider, ...)gateway.add_provider('usa', ClickatellProvider, ...)def router(message, module, type):    &quot;&quot;&quot; Custom router function &quot;&quot;&quot;    if message.dst.startswith('1'):        return 'usa'  # Use 'usa' for all messages sent to the United States    elif type == 'notification':        return 'quick'  # use the 'quick' for all notifications    else:        return None  # Use the default provider ('primary') for everything else    self.gw.router = router```Router function is also the right place to specify provider-specific options.Bundled Providers=================The following providers are bundled with SMSframework and thus require no additional packages.NullProvider------------Source: [smsframework/providers/null.py](smsframework/providers/null.py)The `'null'` provider just ignores all outgoing messages.Configuration: noneSending: does nothing, but increments message.msgidReceipt: Not implementedStatus: Not implemented```pythonfrom smsframework.providers import NullProvidergw.add_provider('null', NullProvider)```LogProvider-----------Source: [smsframework/providers/log.py](smsframework/providers/log.py)Logs the outgoing messages to a python logger provided as the config option.Configuration:* `logger: logging.Logger`: The logger to use. Default logger is used if nothing provided.Sending: does nothing, increments message.msgid, prints the message to the logReceipt: Not implementedStatus: Not implementedExample:```pythonimport loggingfrom smsframework.providers import LogProvidergw.add_provider('log', LogProvider, logger=logging.getLogger(__name__))```LoopbackProvider----------------Source: [smsframework/providers/loopback.py](smsframework/providers/loopback.py)The `'loopback'` provider is used as a dummy for testing purposes.All messages are stored in the local log and can be retrieved as a list.The provider even supports status &amp; delivery notifications.In addition, is supports virtual subscribers: callbacks bound to some phone numbers which are called when anysimulated message is sent to their phone number. Replies are also supported!Configuration: noneSending: sends message to a registered subscriber (see: :meth:`LoopbackProvider.subscribe`),    silently ignores other messages.Receipt: simulation with a methodStatus: always reports success### LoopbackProvider.get_traffic():listLoopbackProvider stores all messages that go through it: both IncomingMessage and OutgoingMessage.To get those messages, call `.get_traffic()`.This method empties the message log and returns its previous state:```pythonfrom smsframework.providers import LoopbackProvidergateway.add_provider('lo', LoopbackProvider);gateway.send(OutgoingMessage('+123', 'hi'))traffic = gateway.get_provider('lo').get_traffic()print(traffic[0].body)  #-&gt; 'hi'```### LoopbackProvider.received(src, body):IncomingMessageSimulate an incoming message.The message is reported to the Gateway as if it has been received from the sms service.Arguments:* `src: str`: Source number* `body: str | unicode`: Message textReturns: IncomingMessage### LoopbackProvider.subscribe(number, callback):IProviderRegister a virtual subscriber which receives messages to the matching number.Arguments:* `number: str`: Subscriber phone number* `callback: `: A `callback(OutgoingMessage)` which handles the messages directed to the subscriber.    The message object is augmented with the `.reply(str)` method which allows to send a reply easily!```pythondef subscriber(message):    print(message)  #-&gt; OutgoingMessage('1', 'obey me')    message.reply('got it')  # use the augmented reply methodprovider = gateway.get_provider('lo')provider.subscribe('+1', subscriber)  # register the subscribergateway.send('+1', 'obey me')```ForwardServerProvider, ForwardClientProvider--------------------------------------------Source: [smsframework/providers/forward/provider.py](smsframework/providers/forward/provider.py)A pair of providers to bind two application instances together:* `ForwardClientProvider` can be used to send and receive messages using a remote server as a proxy* `ForwardServerProvider` is the remote server which:    * Gets outgoing messages from clients and loops them back to the gateway so they're sent with another provider    * Hooks into the gateway and passes all incoming messages and statuses to the clientsTwo providers are bound together using two pairs of receivers. You are not required to care about this :)Remote errors will be transparently re-raised on the local host.To support message receipt, include the necessary dependencies:    pip install smsframework[receiver,async]### ForwardClientProviderExample setup:```pythonfrom smsframework.providers import ForwardClientProvidergw.add_provider('fwd', ForwardClientProvider,                 server_url='http://sms.example.com/sms/fwd')```Configuration:* `server_url`: URL to ForwardServerProvider installed on a remote host.        All outgoing messages will be sent through it instead.### ForwardServerProviderExample setup:```pythonfrom smsframework.providers import ForwardServerProvidergw.add_provider(....)  # Default providergw.add_provider('fwd', ForwardServerProvider, clients=[    'http://a.example.com/sms/fwd',    'http://b.example.com/sms/fwd',])```Configuration:* `clients`: List of URLs to ForwardClientProvider installed on remote hosts.    All incoming messages and statuses will be forwarded to all specified clients.#### Routing ServerIf you want to forward only specific messages, you need to override the `choose_clients` method:given an object, which is either [`IncomingMessage`](#incomingmessage) or [`MessageStatus`](#messagestatus), it shouldreturn a list of client URLs the object should be forwarded to.Example: send all messages to &quot;a.example.com&quot;, and status reports to &quot;b.example.com&quot;:```pythonfrom smsframework import ForwardServerProviderfrom smsframework.data import OutgoingMessage, MessageStatusclass RoutingProvider(ForwardServerProvider):    def choose_clients(self, obj):        if isinstance(obj, OutgoingMessage):            return [ self.clients[0] ]        else:            return [ self.clients[1] ]gw.add_provider(....)  # Default providergw.add_provider('fwd', RoutingProvider, clients=[    'http://a.example.com/sms/fwd',    'http://b.example.com/sms/fwd',])```#### AsyncIf your Server is going to forward messages to multiple clients simultaneously, you will probably want this to happenin parallel.Just install the `asynctools` dependency:    pip install smsframework[receiver,async]#### AuthenticationBoth Client and Server support HTTP basic authentication in URLs:    http://user:password@a.example.com/sms/fwdFor requests. Server-side authentication is your responsibility ;)</longdescription>
</pkgmetadata>