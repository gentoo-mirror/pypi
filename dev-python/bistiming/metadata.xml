<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>BisTiming=========.. image:: https://travis-ci.com/ianlini/bistiming.svg?branch=master   :target: https://travis-ci.com/ianlini/bistiming.. image:: https://readthedocs.org/projects/pip/badge/   :target: https://bistiming.readthedocs.io/.. image:: https://img.shields.io/pypi/v/bistiming.svg   :target: https://pypi.org/project/bistiming/.. image:: https://img.shields.io/pypi/l/bistiming.svg   :target: https://github.com/ianlini/bistiming/blob/master/LICENSE.. image:: https://img.shields.io/github/stars/ianlini/bistiming.svg?style=social   :target: https://github.com/ianlini/bistimingA logging-friendly stopwatch and profiling tool for Python.When we search the stopwatch or timing module for Python on the internet, we can find alot of code snippets, but none of them is powerful or convenient enough to do our dailyjobs.BisTiming aims at implementing all the missing functions in those code snippets andprevents us from reinventing the wheel.It is very useful when we want to log something with some timing information or optimize the performance of our code.This package is tested with Python 2.7, 3.5, 3.6 and 3.7, but might also work in otherPython versions... contents::Installation------------.. code:: bash   pip install bistimingGetting Started---------------BisTiming has a context manager interface that logs the running time of a code blockeasily, and it also offers a low-level API to help time multiple segments or loops ofcode easily.See `examples &lt;https://github.com/ianlini/bistiming/blob/master/examples/&gt;`_for all the useful examples.Context Manager+++++++++++++++The simplest way to use BisTiming is by using the context manager ``Stopwatch``and include the code we want to evaluate:&gt;&gt;&gt; from bistiming import Stopwatch&gt;&gt;&gt; from time import sleep&gt;&gt;&gt; with Stopwatch(&quot;Waiting&quot;):...     print(&quot;do something&quot;)...     sleep(0.1)...     print(&quot;finished something&quot;)......Waitingdo somethingfinished something...Waiting done in 0:00:00.100330We can use the parameter `logger` and `logging_level` to tell the stopwatch to outputusing a logger:&gt;&gt;&gt; import logging&gt;&gt;&gt; logging.basicConfig(...     level=logging.DEBUG,...     format=&quot;[%(asctime)s] %(levelname)s: %(name)s: %(message)s&quot;)&gt;&gt;&gt; logger = logging.getLogger(__name__)&gt;&gt;&gt; with Stopwatch(&quot;Waiting&quot;, logger=logger, logging_level=logging.DEBUG):...     print(&quot;do something&quot;)...     sleep(0.1)...     print(&quot;finished something&quot;)...[2019-04-24 22:27:52,347] DEBUG: __main__: ...Waitingdo somethingfinished something[2019-04-24 22:27:52,448] DEBUG: __main__: ...Waiting done in 0:00:00.100344Another common use case is to evaluate the running time of a specific code segmentin a loop, we can initialize the stopwatch outside the loop, and reuse it in the loop:&gt;&gt;&gt; timer = Stopwatch(&quot;Waiting&quot;)&gt;&gt;&gt; for i in range(2):...     with timer:...         print(&quot;do something 1&quot;)...         sleep(0.1)...         print(&quot;finished something 1&quot;)...     print(&quot;do something 2&quot;)...     sleep(0.1)...     print(&quot;finished something 2&quot;)......Waitingdo something 1finished something 1...Waiting done in 0:00:00.100468do something 2finished something 2...Waitingdo something 1finished something 1...Waiting done in 0:00:00.100440do something 2finished something 2&gt;&gt;&gt; timer.split_elapsed_time[datetime.timedelta(microseconds=100468), datetime.timedelta(microseconds=100440)]&gt;&gt;&gt; timer.get_cumulative_elapsed_time()datetime.timedelta(microseconds=200908)Each item in ``split_elapsed_time`` is the running time ofthe code segment in each iteration, and we can use``get_cumulative_elapsed_time()``to get the total running time of the code segment.Low-level API+++++++++++++The low-level API is similar to a stopwatch in real life.A simple use case using the low-level API is:&gt;&gt;&gt; from time import sleep&gt;&gt;&gt; from bistiming import Stopwatch&gt;&gt;&gt; timer = Stopwatch(&quot;Waiting&quot;).start()...Waiting&gt;&gt;&gt; sleep(0.2)  # do the first step of my program&gt;&gt;&gt; timer.split()...Waiting done in 0:00:00.201457&gt;&gt;&gt; sleep(0.1)  # do the second step of my program&gt;&gt;&gt; timer.split()...Waiting done in 0:00:00.100982The context manager&gt;&gt;&gt; with Stopwatch(&quot;Waiting&quot;):...     sleep(0.1)...Waiting...Waiting done in 0:00:00.100330is actually equivalent to the low-level API:&gt;&gt;&gt; timer = Stopwatch(&quot;Waiting&quot;).start()...Waiting&gt;&gt;&gt; sleep(0.1)&gt;&gt;&gt; timer.pause()&gt;&gt;&gt; timer.split()...Waiting done in 0:00:00.100330Advance Profiling+++++++++++++++++``MultiStopwatch`` in this package contains multiple``Stopwatch``, so we can use them to define each code segmentwe want to evaluate and compare easily:&gt;&gt;&gt; from time import sleep&gt;&gt;&gt; from bistiming import MultiStopwatch&gt;&gt;&gt; timers = MultiStopwatch(2, verbose=False)&gt;&gt;&gt; for i in range(5):...    for i in range(2):...       with timers[0]:...             sleep(0.1)...    with timers[1]:...       sleep(0.1)...&gt;&gt;&gt; print(timers.format_statistics())╒═══════════════════════════╤══════════════╤════════════╤══════════════════╕│ cumulative_elapsed_time   │   percentage │   n_splits │ mean_per_split   │╞═══════════════════════════╪══════════════╪════════════╪══════════════════╡│ 0:00:01.002417            │     0.666377 │         10 │ 0:00:00.100242   │├───────────────────────────┼──────────────┼────────────┼──────────────────┤│ 0:00:00.501861            │     0.333623 │          5 │ 0:00:00.100372   │╘═══════════════════════════╧══════════════╧════════════╧══════════════════╛Documentation-------------There are a lot more ways to use this package.See the `documentation &lt;https://bistiming.readthedocs.io&gt;`_ for more information.</longdescription>
</pkgmetadata>