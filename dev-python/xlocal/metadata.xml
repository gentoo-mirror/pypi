<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>execution locals: killing global state (including thread locals)===================================================================This module provides execution locals aka &quot;xlocal&quot; objects which implementa more restricted variant of &quot;thread locals&quot;.  An execution local allows tomanage attributes on a per-execution basis in a manner similar to how reallocals work:- Invoked functions cannot change the binding for the invoking function- existence of a binding is local to a code block (and everything it calls)Attribute bindings for an xlocal objects will not leak outside acontext-managed code block and they will not leak to other threads ofgreenlets.  By contrast, both process-globals and so called &quot;threadlocals&quot; do not implement the above properties.Let's look at a basic example::    # content of example.py    from xlocal import xlocal    xcurrent = xlocal()    def output():        print &quot;hello world&quot;, xcurrent.x    if __name__ == &quot;__main__&quot;:        with xcurrent(x=1):            output()If we execute this module, the ``output()`` function will see a ``xcurrent.x==1`` binding::    $ python example.py    hello world 1Here is what happens in detail: ``xcurrent(x=1)`` returns a context manager which sets/resets the ``x`` attribute on the ``xcurrent`` object.  While remainingin the same thread/greenlet, all code triggered by the with-body (in this casejust the ``output()`` function) can access ``xcurrent.x``.  Outside the with-body ``xcurrent.x`` would raise an AttributeError.  It is also not allowedto directly set ``xcurrent`` attributes; you always have to explicitely mark theirlife-cycle with a with-statement.  This means that invoked code:- cannot rebind xlocal state of its invoking functions (no side effects, yay!)- xlocal state does not leak outside the with-context (lifecylcle control)Another module may now reuse the example code::    # content of example_call.py    import example        with example.xcurrent(x=3):        example.output()which when running ...::    $ python example_call.py    hello world 3will cause the ``example.output()`` function to print the ``xcurrent.x`` bindingas defined at the invoking ``with xcurrent(x=3)`` statement.Other threads or greenlets will never see this ``xcurrent.x`` binding; they may even set and read their own distincit ``xcurrent.x`` object.  This means that all threads/greenlets can concurrently call into a function which will alwayssee the execution specific ``x`` attribute.Usage in frameworks and libraries invoking &quot;handlers&quot;-----------------------------------------------------------When invoking plugin code or handler code to perform work, you may notwant to pass around all state that might ever be needed.  Instead of usinga global or thread local you can safely pass around such state in execution locals. Here is a pseudo example::    xcurrent = xlocal()    def with_xlocal(func, **kwargs):        with xcurrent(**kwargs):            func()    def handle_request(request):        func = gethandler(request)  # some user code        spawn(with_xlocal(func, request=request))``handle_request`` will run a user-provided handler function in a newlyspawned execution unit (for example spawn might map to``threading.Thread(...).start()`` or to ``gevent.spawn(...)``).  Thegeneric ``with_xlocal`` helper wraps the execution of the handlerfunction so that it will see a ``xcurrent.request`` binding.  Multiplespawns may execute concurrently and ``xcurrent.request`` willcarry the execution-specific request object in each of them.Issues worth noting---------------------------------------If a method memorizes an attribute of an execution local, forexample the above ``xcurrent.request``, then it will keep a reference tothe exact request object, not the per-execution one.  If you want tokeep a per-execution local, you can do it this way for example::    Class Renderer:        @property        def request(self):            return xcurrent.requestthis means that Renderer instances will have an execution-local``self.request`` object even if the life-cycle of the instance crossesexecution units.Another issue is that if you spawn new execution units, they will not implicitely inherit execution locals.  Instead you have to wrapyour spawning function to explicitely set execution locals, similar towhat we did in the above &quot;invoking handlers&quot; section.Copyright / inspiration-------------------------------------This code is based on discussions with Armin Ronacher and othersin response to a `tweet of mine &lt;https://twitter.com/hpk42/status/268012251888353280&gt;`_. It extracts and refines some ideas found in Armin's &quot;werzeug.local&quot; moduleand friends.:copyright: (c) 2012 by Holger Krekel, partially Armin Ronacher:license: BSD, see LICENSE for more details.</longdescription>
</pkgmetadata>