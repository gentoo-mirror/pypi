<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>lib_shopware6_api=================Version v2.0.2.3 as of 2022-06-30 see `Changelog`_|build_badge| |license| |jupyter| |pypi| |pypi-downloads| |black||codecov| |better_code| |cc_maintain| |cc_issues| |cc_coverage| |snyk|.. |build_badge| image:: https://github.com/bitranox/lib_shopware6_api/actions/workflows/python-package.yml/badge.svg   :target: https://github.com/bitranox/lib_shopware6_api/actions/workflows/python-package.yml.. |license| image:: https://img.shields.io/github/license/webcomics/pywine.svg   :target: http://en.wikipedia.org/wiki/MIT_License.. |jupyter| image:: https://mybinder.org/badge_logo.svg   :target: https://mybinder.org/v2/gh/bitranox/lib_shopware6_api/master?filepath=lib_shopware6_api.ipynb.. for the pypi status link note the dashes, not the underscore !.. |pypi| image:: https://img.shields.io/pypi/status/lib-shopware6-api?label=PyPI%20Package   :target: https://badge.fury.io/py/lib_shopware6_api.. |codecov| image:: https://img.shields.io/codecov/c/github/bitranox/lib_shopware6_api   :target: https://codecov.io/gh/bitranox/lib_shopware6_api.. |better_code| image:: https://bettercodehub.com/edge/badge/bitranox/lib_shopware6_api?branch=master   :target: https://bettercodehub.com/results/bitranox/lib_shopware6_api.. |cc_maintain| image:: https://img.shields.io/codeclimate/maintainability-percentage/bitranox/lib_shopware6_api?label=CC%20maintainability   :target: https://codeclimate.com/github/bitranox/lib_shopware6_api/maintainability   :alt: Maintainability.. |cc_issues| image:: https://img.shields.io/codeclimate/issues/bitranox/lib_shopware6_api?label=CC%20issues   :target: https://codeclimate.com/github/bitranox/lib_shopware6_api/maintainability   :alt: Maintainability.. |cc_coverage| image:: https://img.shields.io/codeclimate/coverage/bitranox/lib_shopware6_api?label=CC%20coverage   :target: https://codeclimate.com/github/bitranox/lib_shopware6_api/test_coverage   :alt: Code Coverage.. |snyk| image:: https://img.shields.io/snyk/vulnerabilities/github/bitranox/lib_shopware6_api   :target: https://snyk.io/test/github/bitranox/lib_shopware6_api.. |black| image:: https://img.shields.io/badge/code%20style-black-000000.svg   :target: https://github.com/psf/black.. |pypi-downloads| image:: https://img.shields.io/pypi/dm/lib-shopware6-api   :target: https://pypi.org/project/lib-shopware6-api/   :alt: PyPI - Downloadsshopware6 higher level API client, based on `lib_shopware_api_base &lt;https://github.com/bitranox/lib_shopware6_api_base&gt;`_this might be a good example for Your own API Client Functions - to be further extended----automated tests, Travis Matrix, Documentation, Badges, etc. are managed with `PizzaCutter &lt;https://github.com/bitranox/PizzaCutter&gt;`_ (cookiecutter on steroids)Python version required: 3.6.0 or newertested on recent linux with python 3.6, 3.7, 3.8, 3.9, 3.10, pypy-3.8 - architectures: amd64`100% code coverage &lt;https://codecov.io/gh/bitranox/lib_shopware6_api&gt;`_, flake8 style checking ,mypy static type checking ,----- `Try it Online`_- `Usage`_- `Usage from Commandline`_- `Installation and Upgrade`_- `Requirements`_- `Acknowledgements`_- `Contribute`_- `Report Issues &lt;https://github.com/bitranox/lib_shopware6_api/blob/master/ISSUE_TEMPLATE.md&gt;`_- `Pull Request &lt;https://github.com/bitranox/lib_shopware6_api/blob/master/PULL_REQUEST_TEMPLATE.md&gt;`_- `Code of Conduct &lt;https://github.com/bitranox/lib_shopware6_api/blob/master/CODE_OF_CONDUCT.md&gt;`_- `License`_- `Changelog`_----Try it Online-------------You might try it right away in Jupyter Notebook by using the &quot;launch binder&quot; badge, or click `here &lt;https://mybinder.org/v2/gh/{{rst_include.repository_slug}}/master?filepath=lib_shopware6_api.ipynb&gt;`_Usage-----------Overview========- `API`_- `Currency`_- `DeliveryTime`_- `Media`_- `Product`_- `Tax`_- `Unit`_-------------------API===back to `Overview`_.. code-block:: python    class Shopware6API(object):        def __init__(self, config: Optional[ConfShopware6ApiBase] = None, use_docker_test_container: bool = False) -&gt; None:            &quot;&quot;&quot;            :param config, type ConfShopware6ApiBase            :param use_docker_test_container: if to use the docker test container            &gt;&gt;&gt; my_api=Shopware6API()            &gt;&gt;&gt; my_api_currency=my_api.currency            &gt;&gt;&gt; my_api_delivery_time=my_api.delivery_time            &gt;&gt;&gt; my_api_media=my_api.media            &gt;&gt;&gt; my_api_product=my_api.product            &gt;&gt;&gt; my_api_tax=my_api.tax            &gt;&gt;&gt; my_api_unit=my_api.unit            &quot;&quot;&quot;Currency========back to `Overview`_.. code-block:: python    class Currency(object):        def __init__(            self, admin_client: Optional[Shopware6AdminAPIClientBase] = None, config: Optional[ConfShopware6ApiBase] = None, use_docker_test_container: bool = False        ) -&gt; None:            &quot;&quot;&quot;            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Currency()            &quot;&quot;&quot;.. code-block:: python        @lru_cache(maxsize=None)        def get_currency_id_by_iso_code(self, currency_iso_code: str = &quot;EUR&quot;) -&gt; str:            &quot;&quot;&quot;            :param currency_iso_code: the currency iso code, like 'EUR', 'CHF', ...            :returns: the id of the currency record            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Currency()            &gt;&gt;&gt; # test get currency id            &gt;&gt;&gt; my_currency_id = my_api.get_currency_id_by_iso_code('EUR')            &gt;&gt;&gt; assert 32 == len(my_currency_id)            &gt;&gt;&gt; # test not existing (int)            &gt;&gt;&gt; my_api.get_currency_id_by_iso_code(currency_iso_code='not_existing')            Traceback (most recent call last):                ...            FileNotFoundError: currency record with isoCode &quot;not_existing&quot; not found            &gt;&gt;&gt; # Test clear Cache - the Cache has to be cleared if currencies are inserted or deleted            &gt;&gt;&gt; my_api.get_currency_id_by_iso_code.cache_clear()            &quot;&quot;&quot;.. code-block:: python        def get_currencies(self, payload: Optional[Dict[str, Any]] = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            get all currency records - filters and so on can be set in the payload            we read paginated (in junks of 100 items) - this is done automatically by function base_client.request_get_paginated()            :parameters                payload, to set filters etc.            :returns                l_dict_data,            sample payload :                page and limit will be overridden by function base_client.request_get_paginated() and will be ignored            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Currency()            &gt;&gt;&gt; my_l_dict_data = my_api.get_currencies()            &quot;&quot;&quot;DeliveryTime============back to `Overview`_.. code-block:: python    class DeliveryTime(object):        def __init__(            self, admin_client: Optional[Shopware6AdminAPIClientBase] = None, config: Optional[ConfShopware6ApiBase] = None, use_docker_test_container: bool = False        ) -&gt; None:            &quot;&quot;&quot;            :param admin_client:            :param config:            :param use_docker_test_container:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = DeliveryTime()            &quot;&quot;&quot;.. code-block:: python        def cache_clear_delivery_time(self) -&gt; None:            &quot;&quot;&quot;            Cache of some functions has to be cleared if delivery_time records are inserted or deleted            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = DeliveryTime()            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_api.cache_clear_delivery_time()            &quot;&quot;&quot;.. code-block:: python        @lru_cache(maxsize=None)        def get_delivery_times(self, payload: Optional[Dict[str, Any]] = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            get all delivery-time records - filters and so on can be set in the payload            we read paginated (in junks of 100 items) - this is done automatically by function base_client.request_get_paginated()            :parameters                payload, to set filters etc.            :returns                l_dict_data,            sample payload :                page and limit will be overridden by function base_client.request_get_paginated() and will be ignored            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = DeliveryTime()            &gt;&gt;&gt; my_l_dict_data = my_api.get_delivery_times()            &quot;&quot;&quot;.. code-block:: python        def search_delivery_times(self, payload: PayLoad = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            search delivery-time records            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = DeliveryTime()            &gt;&gt;&gt; # insert article            &gt;&gt;&gt; ignore = my_api.search_delivery_times()            &quot;&quot;&quot;.. code-block:: python        @lru_cache(maxsize=None)        def get_delivery_times_sorted_by_min_days(self) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            returns a list of 'id' and 'name' of delivery_times, sorted by minimal time            the key 'position' starts with 10, 20 ....            :returns : [{'name': '...', 'id': '...', 'position': 10}, ...]            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = DeliveryTime()            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_api.get_delivery_times_sorted_by_min_days()            [{'name': '...', 'id': '...', 'position': 10}, ...]            &quot;&quot;&quot;Media=====back to `Overview`_.. code-block:: python    class Media(object):        def __init__(            self, admin_client: Optional[Shopware6AdminAPIClientBase] = None, config: Optional[ConfShopware6ApiBase] = None, use_docker_test_container: bool = False        ) -&gt; None:            &quot;&quot;&quot;            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &quot;&quot;&quot;.. code-block:: python        def cache_clear_media(self) -&gt; None:            &quot;&quot;&quot;            Cache of some functions has to be cleared if media is inserted or deleted            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # test            &gt;&gt;&gt; my_api.cache_clear_media()            &quot;&quot;&quot;.. code-block:: python        def cache_clear_media_folder(self) -&gt; None:            &quot;&quot;&quot;            Cache of some functions has to be cleared if media_folders are inserted or deleted            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # test            &gt;&gt;&gt; my_api.cache_clear_media_folder()            &quot;&quot;&quot;.. code-block:: python        @staticmethod        def calc_media_filename_from_product_number(            product_number: Union[int, str],            position: int,            url: str,        ) -&gt; str:            &quot;&quot;&quot;            media_filenamescan only exist once - so we build the filename from product_number, position, and extension of the url            :param product_number:            :param position:            :param url:             we take the extension from here            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_api.calc_media_filename_from_product_number(product_number=123456789, position=1, url='something.jpg')            '123456789_1.jpg'            &gt;&gt;&gt; my_api.calc_media_filename_from_product_number(product_number='test_get_media_filename_from_product_number', position=1, url='something.jpg')            'test_get_media_filename_from_product_number_1.jpg'            &quot;&quot;&quot;.. code-block:: python        @staticmethod        def calc_new_media_id(media_filename: PathMedia) -&gt; str:            &quot;&quot;&quot;            calculates a new media_id (to insert) from media_filename.            since a media_filename (with extension) must only exist once in shopware6,            we can calculate the is from that name.            :param media_filename: filename (or url) with extension            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_new_media_id = my_api.calc_new_media_id(media_filename='123.jpg')            &gt;&gt;&gt; assert 32 == len(my_new_media_id)            &gt;&gt;&gt; # Test no extension            &gt;&gt;&gt; my_new_media_id = my_api.calc_new_media_id(media_filename='123')            Traceback (most recent call last):                ...            ValueError: media_filename &quot;123&quot; must have an extension            &quot;&quot;&quot;.. code-block:: python        def calc_path_media_folder_from_product_number(self, product_number: Union[int, str]) -&gt; str:            &quot;&quot;&quot;            get the path of the complete media folder for a given product_number.            the directory structure will be created as follows :            'xxxx...' the md5-hash buil out of the product number            conf_path_media_folder_root/xx/xx/xx/xxxxxxxxxxxxxxxxxxxxxxxxxx            that gives us 16.7 Million directories, in order to spread products evenly in folders (sharding).            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # test            &gt;&gt;&gt; my_api.calc_path_media_folder_from_product_number(product_number=456789)            '/Product Media/api_imported/e3/5c/f7/b66449df565f93c607d5a81d09'            &gt;&gt;&gt; # test2            &gt;&gt;&gt; my_api.calc_path_media_folder_from_product_number(product_number='123456789abcdefg')            '/Product Media/api_imported/94/08/f8/da307c543595e92ded30cf4193'            &quot;&quot;&quot;.. code-block:: python        def delete_media_by_id(self, media_id: str) -&gt; None:            &quot;&quot;&quot;            :param media_id: the media_id            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; import time            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; my_media_folder_id = my_api.upsert_media_folders_by_path('/Product Media/test_delete_media_by_id')            &gt;&gt;&gt; # insert two medias            &gt;&gt;&gt; ignore1 = my_api.insert_media(media_folder_id=my_media_folder_id, url='https://pics.rotek.at/test/test001/bilder/test001_01_1280.jpg')            &gt;&gt;&gt; ignore2 = my_api.insert_media(media_folder_id=my_media_folder_id, url='https://pics.rotek.at/test/test001/bilder/test001_02_1280.jpg')            &gt;&gt;&gt; # Test delete            &gt;&gt;&gt; my_api.delete_media_by_id(media_id=my_api.get_media_id_by_media_filename(media_filename='test001_01_1280.jpg'))  # noqa            &gt;&gt;&gt; my_api.delete_media_by_id(media_id=my_api.get_media_id_by_media_filename(media_filename='test001_02_1280.jpg'))  # noqa            &gt;&gt;&gt; # teardown            &gt;&gt;&gt; my_api.delete_media_folder_by_path('/Product Media/test_delete_media_by_id', force=True)            &quot;&quot;&quot;.. code-block:: python        def delete_media_folder(self, media_folder_id: Optional[str], force: bool = False) -&gt; None:            &quot;&quot;&quot;            delete a media folder. on force, also containing media is deleted            DANGER - API DELETES FOLDERS RUTHLESS - including Subfolders and pictures            :param media_folder_id: the folder to delete            :param force: if True, delete even if there are Subfolders or Media in that folder            :return:    None            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # insert Folder            &gt;&gt;&gt; my_media_folder_id = my_api.upsert_media_folders_by_path('/Product Media/test_delete_media_folder')            &gt;&gt;&gt; assert True == my_api.is_media_folder_existing_by_path('/Product Media/test_delete_media_folder')            &gt;&gt;&gt; # delete the inserted Folder            &gt;&gt;&gt; my_api.delete_media_folder(media_folder_id=my_media_folder_id)            &gt;&gt;&gt; assert False == my_api.is_media_folder_existing_by_path('/Product Media/test_delete_media_folder')            &gt;&gt;&gt; # insert Folder with subfolder            &gt;&gt;&gt; my_media_sub_folder_id = my_api.upsert_media_folders_by_path('/Product Media/test_delete_media_folder/subfolder')            &gt;&gt;&gt; assert True == my_api.is_media_folder_existing_by_path('/Product Media/test_delete_media_folder/subfolder')            &gt;&gt;&gt; # can not delete non-empty Folder            &gt;&gt;&gt; my_media_folder_id = my_api.get_media_folder_id_by_path('/Product Media/test_delete_media_folder')            &gt;&gt;&gt; my_api.delete_media_folder(media_folder_id=my_media_folder_id)            Traceback (most recent call last):                ...            OSError: media_folder_id &quot;...&quot; is not empty            &gt;&gt;&gt; # force-delete non-empty Folder            &gt;&gt;&gt; my_api.delete_media_folder(media_folder_id=my_media_folder_id, force=True)            &gt;&gt;&gt; assert False == my_api.is_media_folder_existing_by_path('/Product Media/test_delete_media_folder')            &gt;&gt;&gt; # try to delete Root Folder            &gt;&gt;&gt; my_api.delete_media_folder(media_folder_id=None)            Traceback (most recent call last):                ...            OSError: the root folder can not be deleted            &quot;&quot;&quot;.. code-block:: python        def delete_media_folder_by_path(self, path_media_folder: PathMediaFolder, force: bool = False) -&gt; None:            &quot;&quot;&quot;            delete a media folder by path            DANGER - API DELETES FOLDERS RUTHLESS - including Subfolders and pictures            :param path_media_folder: like '/Product Media/a000/000/001            :param force: if True, delete even if there are Subfolders or Media in that folder            :return:    None            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; ignore = my_api.upsert_media_folders_by_path(path_media_folder='/Product Media/test_delete_media_folder_by_path/subfolder1/subfolder2/subfolder3')            &gt;&gt;&gt; # Test delete Empty Folder            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder='/Product Media/test_delete_media_folder_by_path/subfolder1/subfolder2/subfolder3')            &gt;&gt;&gt; # Test delete Empty Folder without force            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder='/Product Media/test_delete_media_folder_by_path/subfolder1')            Traceback (most recent call last):                ...            OSError: media_folder &quot;/Product Media/test_delete_media_folder_by_path/subfolder1&quot; is not empty            &gt;&gt;&gt; # Test delete Folder with force            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder='/Product Media/test_delete_media_folder_by_path', force=True)            &gt;&gt;&gt; assert False == my_api.is_media_folder_existing_by_path(path_media_folder='/Product Media/test_delete_media_folder_by_path')            &quot;&quot;&quot;.. code-block:: python        @lru_cache(maxsize=None)        def get_media_folder_configuration_id_from_media_folder_name(self, media_folder_name: str = &quot;Product Media&quot;, parent_id: Optional[str] = None) -&gt; str:            &quot;&quot;&quot;            get the configuration_id of a media folder. this configuration_id can be passed to child folders,            in order to inherit the configuration from the parent folder            Parameter :                media_folder_name: the name of the parent folder, like 'Product Media'                parent_id        : the parent id of the Folder            :returns: the configuration id            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # test get 'Product Media' id            &gt;&gt;&gt; my_folder_configuration_id = my_api.get_media_folder_configuration_id_from_media_folder_name()            &gt;&gt;&gt; assert 32 == len(my_folder_configuration_id)            &gt;&gt;&gt; # test not existing (int)            &gt;&gt;&gt; my_api.get_media_folder_configuration_id_from_media_folder_name(media_folder_name='not_existing')            Traceback (most recent call last):                ...            FileNotFoundError: media folder with name &quot;not_existing&quot; not found            &gt;&gt;&gt; # Test clear Cache -the Cache has to be cleared if media_folders are inserted or deleted            &gt;&gt;&gt; my_api.get_media_folder_configuration_id_from_media_folder_name.cache_clear()            &quot;&quot;&quot;.. code-block:: python        def get_media_folder_configurations(self, payload: Optional[Dict[str, Any]] = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            get all media_folder_configurations - filters and so on can be set in the payload            we read paginated (in junks of 100 items) - this is done automatically by function base_client.request_get_paginated()            :parameters                payload, to set filters etc.            :returns                l_dict_data,            sample payload :                page and limit will be overridden by function base_client.request_get_paginated() and will be ignored            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; my_l_dict_data = my_api.get_media_folder_configurations()            &quot;&quot;&quot;.. code-block:: python        @lru_cache(maxsize=None)        def get_media_folder_id(self, name: str, parent_id: Optional[str]) -&gt; str:            &quot;&quot;&quot;            get the id of a media folder            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # Test get existing Folder            &gt;&gt;&gt; assert my_api.get_media_folder_id(name='Product Media', parent_id=None)  # noqa            &gt;&gt;&gt; # Test get non-existing Folder            &gt;&gt;&gt; my_api.get_media_folder_id(name='not-existing', parent_id=None)  # noqa            Traceback (most recent call last):                ...            FileNotFoundError: media_folder, name: &quot;not-existing&quot;, parent_id: &quot;None&quot; not found            &gt;&gt;&gt; # Test clear Cache -the Cache has to be cleared if media_folders are inserted or deleted            &gt;&gt;&gt; my_api.get_media_folder_id.cache_clear()            &quot;&quot;&quot;.. code-block:: python        @lru_cache(maxsize=None)        def get_media_folder_id_by_path(self, path_media_folder: PathMediaFolder) -&gt; Optional[str]:            &quot;&quot;&quot;            get the id of a media folder            :param path_media_folder: path - for instance /Product Media/a000/000/001            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; my_folder_id = my_api.upsert_media_folders_by_path('/Product Media/test_get_media_folder_id_by_path/999/999')            &gt;&gt;&gt; # Test Existing            &gt;&gt;&gt; assert my_folder_id == my_api.get_media_folder_id_by_path('/Product Media/test_get_media_folder_id_by_path/999/999')            &gt;&gt;&gt; # Test Invalid            &gt;&gt;&gt; my_api.get_media_folder_id_by_path('not-existing-folder')            Traceback (most recent call last):                ...            OSError: media_folder path &quot;not-existing-folder&quot; is invalid, it must be absolute            &gt;&gt;&gt; # Test Not Existing            &gt;&gt;&gt; my_api.get_media_folder_id_by_path('/not-existing-folder')            Traceback (most recent call last):                ...            FileNotFoundError: media_folder path &quot;/not-existing-folder&quot; not found            &gt;&gt;&gt; # Test clear Cache -the Cache has to be cleared if media_folders are inserted or deleted            &gt;&gt;&gt; my_api.get_media_folder_id_by_path.cache_clear()            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.delete_media_folder_by_path('/Product Media/test_get_media_folder_id_by_path', force=True)            &quot;&quot;&quot;.. code-block:: python        def get_media_folders(self, payload: Optional[Dict[str, Any]] = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            get all media_folder - filters and so on can be set in the payload            we read paginated (in junks of 100 items) - this is done automatically by function base_client.request_get_paginated()            :parameters                payload, to set filters etc.            :returns                l_dict_data,            sample payload :                page and limit will be overridden by function base_client.request_get_paginated() and will be ignored            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; my_l_dict_data = my_api.get_media_folders()            &quot;&quot;&quot;.. code-block:: python        def get_media_id_by_media_filename(self, media_filename: PathMedia) -&gt; str:            &quot;&quot;&quot;            gets the media_id from media_folder_id and media_filename            this can only work if the picture is already uploaded !            :param media_filename:  the filename (with extension) as string, like 'test001_01_1280.jpg', or the url link that ends with '.../test001_01_1280.jpg'            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; my_media_folder_id = my_api.upsert_media_folders_by_path('/Product Media/test_get_media_id/999/999')            &gt;&gt;&gt; my_media_id = my_api.insert_media(media_folder_id=my_media_folder_id, url='https://pics.rotek.at/test/test001/bilder/test001_07_1280.jpg')            &gt;&gt;&gt; # test existing Folder, existing Media            &gt;&gt;&gt; my_media_filename = 'test001_07_1280.jpg'            &gt;&gt;&gt; assert my_media_id == my_api.get_media_id_by_media_filename(media_filename=my_media_filename)            &gt;&gt;&gt; # test non-existing Media            &gt;&gt;&gt; my_media_filename = 'bat013_77_7777.jpg'            &gt;&gt;&gt; my_api.get_media_id_by_media_filename(media_filename=my_media_filename)            Traceback (most recent call last):                ...            FileNotFoundError: media_filename: &quot;bat013_77_7777.jpg&quot; not found            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder = '/Product Media/test_get_media_id', force=True)            &quot;&quot;&quot;.. code-block:: python        def get_medias(self, payload: Optional[Dict[str, Any]] = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            get all media records - filters and so on can be set in the payload            we read paginated (in junks of 100 items) - this is done automatically by function base_client.request_get_paginated()            :parameters                payload, to set filters etc.            :returns                l_dict_data,            sample payload :                page and limit will be overridden by function base_client.request_get_paginated() and will be ignored            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; my_l_dict_data = my_api.get_medias()            &quot;&quot;&quot;.. code-block:: python        def insert_media(            self,            media_folder_id: Union[str, None],            url: str,            media_alt_txt: Union[str, None] = None,            media_title: Union[str, None] = None,            media_filename: Optional[PathMedia] = None,            upload_media: bool = True,        ) -&gt; str:            &quot;&quot;&quot;            creates a single &quot;media record&quot; and uploads the media from the url - the media filename is taken from the url if not provided            note that the same media_filename must not exist twice in the shop, even if on different media folders !            this should only be used if You upload the media indipendently from products -            otherwise You should use associations to update the product with one request - see :            https://shopware.stoplight.io/docs/admin-api/ZG9jOjEyNjI1Mzkw-media-handling            https://shopware.stoplight.io/docs/admin-api/ZG9jOjEyMzA4NTUw-associationsundefined            if upload_media == False, You can only rely on the returned media_id to find the inserted record -                all other fields are &quot;None&quot; so the api functions is_media_existing, etc. will not work !                You need to store the media_id and upload the media to complete the record.            :param media_folder_id:     id des folders            :param url:                 url des files zum hochladen            :param media_alt_txt:       optional, 'alt'            :param media_title:         optional, 'title'            :param media_filename:      optional, the filename (with extension) as string, like 'test001_01_1280.jpg', otherwise taken from url            :param upload_media         if to upload the media            :return: the new Media ID            see : https://shopware.stoplight.io/docs/admin-api/c2NoOjE0MzUxMjU3-media            see : https://shopware.stoplight.io/docs/admin-api/ZG9jOjEyNjI1Mzkw-media-handling            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; my_media_folder_id = my_api.upsert_media_folders_by_path(path_media_folder='/Product Media/test_insert_media')            &gt;&gt;&gt; # insert media            &gt;&gt;&gt; ignore = my_api.insert_media(media_folder_id=my_media_folder_id, url='https://pics.rotek.at/test/test001/bilder/test001_07_1280.jpg',            ...     media_filename = 'test001_07_1280.jpg')            &gt;&gt;&gt; # insert media, without stating filename            &gt;&gt;&gt; ignore = my_api.insert_media(media_folder_id=my_media_folder_id, url='https://pics.rotek.at/test/test001/bilder/test001_08_1280.jpg')            &gt;&gt;&gt; # cleanup            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder='/Product Media/test_insert_media', force=True)            &quot;&quot;&quot;.. code-block:: python        def insert_media_by_path(self, path_media: PathMedia, url: str, media_alt_txt: Union[str, None] = None, media_title: Union[str, None] = None) -&gt; str:            &quot;&quot;&quot;            Inserts a Media by Path, and upload the media from the url.            note that the same media_filename must not exist twice in the shop, even if on different media folders !            this should only be used if You upload the media indipendently from products -            otherwise You should use associations to update the product with one request - see :            https://shopware.stoplight.io/docs/admin-api/ZG9jOjEyNjI1Mzkw-media-handling            https://shopware.stoplight.io/docs/admin-api/ZG9jOjEyMzA4NTUw-associationsundefined            since associations will only be upserted but not deleted we make following approach :            - delete the product_media relations for a product            -            :param path_media: '/Product Media/a000/123/456/000123456_01_1280.jpg'            :param url:  url='https://pics.rotek.at/test/test003/bilder/test003_01_1280.jpg'            :param media_alt_txt:   optional            :param media_title:     optional            :return: the new media id            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # insert media            &gt;&gt;&gt; ignore = my_api.insert_media_by_path(path_media='/Product Media/insert_media_by_path/test001_07_1280.jpg',            ...     url='https://pics.rotek.at/test/test001/bilder/test001_07_1280.jpg')            &gt;&gt;&gt; # insert media, without stating filename            &gt;&gt;&gt; ignore = my_api.insert_media_by_path(path_media='/Product Media/insert_media_by_path/test001_08_1280.jpg',            ...     url='https://pics.rotek.at/test/test001/bilder/test001_07_1280.jpg')            &gt;&gt;&gt; # cleanup            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder='/Product Media/insert_media_by_path', force=True)            &quot;&quot;&quot;.. code-block:: python        def insert_media_folder_by_name_and_parent_id(self, name: str, parent_id: Optional[str], configuration_id: Optional[str] = None) -&gt; None:            &quot;&quot;&quot;            insert a media folder            :param name:             the name of the folder            :param parent_id:        the id of the parent folder            :param configuration_id: the folder configuration id. taken from parent folder if none            :return: None            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # insert Folder            &gt;&gt;&gt; id_root = my_api.get_media_folder_id(name='Product Media', parent_id=None)  # noqa            &gt;&gt;&gt; my_api.insert_media_folder_by_name_and_parent_id(name='test_insert_media_folder_by_name_and_parent_id', parent_id=id_root)            &gt;&gt;&gt; assert True == my_api.is_media_folder_existing_by_path('/Product Media/test_insert_media_folder_by_name_and_parent_id')            &gt;&gt;&gt; # delete the inserted Folder            &gt;&gt;&gt; my_api.delete_media_folder_by_path('/Product Media/test_insert_media_folder_by_name_and_parent_id')            &quot;&quot;&quot;.. code-block:: python        def is_media_existing(self, media_filename: str) -&gt; bool:            &quot;&quot;&quot;            True if the media ID exists -            the media_id is read from the filename or the filename of the url. filename needs to have extension for the media mime type            :param media_filename: filename or url of the media (if the filename is the same like the name in the url)            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # insert media            &gt;&gt;&gt; ignore01 = my_api.insert_media_by_path(path_media='/Product Media/test_is_media_existing/is_media_existing_01.jpg', \                    url='https://pics.rotek.at/test/test001/bilder/test001_05_1280.jpg')            &gt;&gt;&gt; # test check exist            &gt;&gt;&gt; assert True == my_api.is_media_existing(media_filename='https://pics.rotek.at/test/test001/bilder/is_media_existing_01.jpg')            &gt;&gt;&gt; assert True == my_api.is_media_existing(media_filename='is_media_existing_01.jpg')            &gt;&gt;&gt; # test check not exist            &gt;&gt;&gt; assert False == my_api.is_media_existing(media_filename='does_not_exist.jpg')            &gt;&gt;&gt; # test no extension            &gt;&gt;&gt; my_api.is_media_existing(media_filename='no_extension')            Traceback (most recent call last):                ...            ValueError: media &quot;no_extension&quot; does not have an extension            &gt;&gt;&gt; # cleanup            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder='/Product Media/test_is_media_existing', force=True)            &quot;&quot;&quot;.. code-block:: python        def is_media_existing_by_media_id(self, media_id: str) -&gt; bool:            &quot;&quot;&quot;            :param media_id:            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; my_media_id = my_api.insert_media_by_path(path_media='/Product Media/test_is_media_existing_by_media_id/is_media_existing_by_media_id.jpg', \                    url='https://pics.rotek.at/test/test001/bilder/test001_05_1280.jpg')            &gt;&gt;&gt; # Test Existing            &gt;&gt;&gt; assert True == my_api.is_media_existing_by_media_id(my_media_id)            &gt;&gt;&gt; # Test not Existing            &gt;&gt;&gt; assert False == my_api.is_media_existing_by_media_id('0123456789')            &gt;&gt;&gt; # TearDown            &gt;&gt;&gt; my_api.delete_media_folder_by_path('/Product Media/test_is_media_existing_by_media_id', force=True)            &quot;&quot;&quot;.. code-block:: python        def is_media_folder_containing_subfolders(self, media_folder_id: Optional[str]) -&gt; bool:            &quot;&quot;&quot;            :returns True if there is a subfolder in the media folder            :param media_folder_id:            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; ignore = my_api.upsert_media_folders_by_path(path_media_folder='/Product Media/test_is_media_folder_containing_subfolders')            &gt;&gt;&gt; # Test subfolder existing            &gt;&gt;&gt; my_media_folder_id=my_api.get_media_folder_id_by_path(path_media_folder='/')            &gt;&gt;&gt; assert True == my_api.is_media_folder_containing_subfolders(media_folder_id=my_media_folder_id)            &gt;&gt;&gt; # test no Subfolder            &gt;&gt;&gt; my_media_folder_id=my_api.get_media_folder_id_by_path(path_media_folder='/Product Media/test_is_media_folder_containing_subfolders')            &gt;&gt;&gt; assert False == my_api.is_media_folder_containing_subfolders(media_folder_id=my_media_folder_id)            &gt;&gt;&gt; # test Media Folder not existing            &gt;&gt;&gt; my_api.is_media_folder_containing_subfolders(media_folder_id='0123456789')            Traceback (most recent call last):                ...            FileNotFoundError: media_folder id &quot;0123456789&quot; not found            &gt;&gt;&gt; # teardown            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder='/Product Media/test_is_media_folder_containing_subfolders')            &quot;&quot;&quot;.. code-block:: python        def is_media_folder_empty(self, media_folder_id: Optional[str]) -&gt; bool:            &quot;&quot;&quot;            true if the media_folder does not contain any media files or subfolders            :param media_folder_id:            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; ignore1 = my_api.insert_media_by_path(path_media='/Product Media/test_is_media_folder_empty_with_media/test003_01_1280.jpg',            ...     url='https://pics.rotek.at/test/test003/bilder/test003_01_1280.jpg')            &gt;&gt;&gt; ignore2 = my_api.upsert_media_folders_by_path(path_media_folder='/Product Media/test_is_media_folder_empty_with_subfolder/subfolder')            &gt;&gt;&gt; ignore3 = my_api.upsert_media_folders_by_path(path_media_folder='/Product Media/test_is_media_folder_empty_empty')            &gt;&gt;&gt; # test no subfolder, media files existing            &gt;&gt;&gt; my_media_folder_id=my_api.get_media_folder_id_by_path(path_media_folder='/Product Media/test_is_media_folder_empty_with_media')            &gt;&gt;&gt; assert False == my_api.is_media_folder_containing_subfolders(media_folder_id=my_media_folder_id)            &gt;&gt;&gt; # Test subfolder existing, no media files            &gt;&gt;&gt; my_media_folder_id=my_api.get_media_folder_id_by_path(path_media_folder='/Product Media/test_is_media_folder_empty_with_subfolder')            &gt;&gt;&gt; assert False == my_api.is_media_folder_empty(media_folder_id=my_media_folder_id)            &gt;&gt;&gt; # Test no subfolder, no media files existing            &gt;&gt;&gt; my_media_folder_id=my_api.get_media_folder_id_by_path(path_media_folder='/Product Media/test_is_media_folder_empty_empty')            &gt;&gt;&gt; assert True == my_api.is_media_folder_empty(media_folder_id=my_media_folder_id)            &gt;&gt;&gt; # Test Folder not existing            &gt;&gt;&gt; my_api.is_media_folder_containing_subfolders(media_folder_id='0123456789')            Traceback (most recent call last):                ...            FileNotFoundError: media_folder id &quot;0123456789&quot; not found            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.delete_media_folder_by_path('/Product Media/test_is_media_folder_empty_with_media', force=True)            &gt;&gt;&gt; my_api.delete_media_folder_by_path('/Product Media/test_is_media_folder_empty_with_subfolder', force=True)            &gt;&gt;&gt; my_api.delete_media_folder_by_path('/Product Media/test_is_media_folder_empty_empty', force=True)            &quot;&quot;&quot;.. code-block:: python        def is_media_folder_empty_by_path(self, path_media_folder: PathMediaFolder) -&gt; bool:            &quot;&quot;&quot;            true if the media_folder does not contain any media files or subfolders            :param path_media_folder: like '/Product Media/a000/000/001            :return:                    &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; ignore1 = my_api.insert_media_by_path(path_media='/Product Media/test_is_media_folder_empty_by_path_with_media/test003_01_1280.jpg',            ...     url='https://pics.rotek.at/test/test003/bilder/test003_01_1280.jpg')            &gt;&gt;&gt; ignore2 = my_api.upsert_media_folders_by_path(path_media_folder='/Product Media/test_is_media_folder_empty_by_path_with_subfolder/subfolder')            &gt;&gt;&gt; ignore3 = my_api.upsert_media_folders_by_path(path_media_folder='/Product Media/test_is_media_folder_empty_by_path_empty')            &gt;&gt;&gt; # Test no subfolder, media files existing            &gt;&gt;&gt; assert False == my_api.is_media_folder_empty_by_path(path_media_folder='/Product Media/test_is_media_folder_empty_by_path_with_media')            &gt;&gt;&gt; # Test subfolder existing, no media files            &gt;&gt;&gt; assert False == my_api.is_media_folder_empty_by_path(path_media_folder='/Product Media/test_is_media_folder_empty_by_path_with_subfolder')            &gt;&gt;&gt; # Test no subfolder, no media files existing            &gt;&gt;&gt; assert True == my_api.is_media_folder_empty_by_path(path_media_folder='/Product Media/test_is_media_folder_empty_by_path_empty')            &gt;&gt;&gt; # test Folder not existing            &gt;&gt;&gt; my_api.is_media_folder_containing_subfolders(media_folder_id='0123456789')            Traceback (most recent call last):                ...            FileNotFoundError: media_folder id &quot;0123456789&quot; not found            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.delete_media_folder_by_path('/Product Media/test_is_media_folder_empty_by_path_with_media', force=True)            &gt;&gt;&gt; my_api.delete_media_folder_by_path('/Product Media/test_is_media_folder_empty_by_path_with_subfolder', force=True)            &gt;&gt;&gt; my_api.delete_media_folder_by_path('/Product Media/test_is_media_folder_empty_by_path_empty', force=True)            &quot;&quot;&quot;.. code-block:: python        def is_media_folder_existing(self, media_folder_id: Optional[str]) -&gt; bool:            &quot;&quot;&quot;            True if the folder exists, False if it does not exist            :param media_folder_id:            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # Test media_folder existing            &gt;&gt;&gt; my_media_folder_id=my_api.get_media_folder_id_by_path(path_media_folder='/Product Media')            &gt;&gt;&gt; assert True == my_api.is_media_folder_existing(media_folder_id=my_media_folder_id)            &gt;&gt;&gt; # Test media_folder not existing            &gt;&gt;&gt; assert False == my_api.is_media_folder_existing(media_folder_id='0123456789')            &quot;&quot;&quot;.. code-block:: python        def is_media_folder_existing_by_path(self, path_media_folder: PathMediaFolder) -&gt; bool:            &quot;&quot;&quot;            True if the folder exists, False if it does not exist            :param path_media_folder: like '/Product Media/a000/000/001            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # Test media_folder existing            &gt;&gt;&gt; assert True == my_api.is_media_folder_existing_by_path(path_media_folder='/Product Media')            &gt;&gt;&gt; # Test media_folder not existing            &gt;&gt;&gt; assert False == my_api.is_media_folder_existing_by_path(path_media_folder='/test_is_media_folder_existing_by_path/sub1/sub2')            &quot;&quot;&quot;.. code-block:: python        def is_media_in_media_folder(self, media_folder_id: Optional[str]) -&gt; bool:            &quot;&quot;&quot;            :returns True if there is some media files in the media folder            :param media_folder_id:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; ignore01 = my_api.upsert_media_folders_by_path(path_media_folder='/Product Media/test_is_media_in_media_folder_no_media')            &gt;&gt;&gt; ignore02 = my_api.insert_media_by_path(path_media='/Product Media/test_is_media_in_media_folder_with_media/test001_07_1280.jpg',            ...     url='https://pics.rotek.at/test/test001/bilder/test001_07_1280.jpg')            &gt;&gt;&gt; # Test no Media in Folder            &gt;&gt;&gt; my_media_folder_id = my_api.get_media_folder_id_by_path('/Product Media/test_is_media_in_media_folder_no_media')            &gt;&gt;&gt; assert False == my_api.is_media_in_media_folder(media_folder_id = my_media_folder_id)            &gt;&gt;&gt; # Test Media in Folder            &gt;&gt;&gt; my_media_folder_id = my_api.get_media_folder_id_by_path('/Product Media/test_is_media_in_media_folder_with_media')            &gt;&gt;&gt; assert True == my_api.is_media_in_media_folder(media_folder_id = my_media_folder_id)            &gt;&gt;&gt; # Test Folder not existing            &gt;&gt;&gt; my_api.is_media_in_media_folder(media_folder_id = '01234567890')            Traceback (most recent call last):                ...            FileNotFoundError: media_folder id &quot;01234567890&quot; not found            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder='/Product Media/test_is_media_in_media_folder_no_media', force=True)            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder='/Product Media/test_is_media_in_media_folder_with_media', force=True)            &quot;&quot;&quot;.. code-block:: python        def search_media_folders(self, payload: PayLoad = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            get all the media folders            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # test            &gt;&gt;&gt; my_l_data_dict = my_api.search_media_folders()            &quot;&quot;&quot;.. code-block:: python        def search_medias(self, payload: PayLoad = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            get all the media            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # insert article            &gt;&gt;&gt; ignore = my_api.search_medias()            &quot;&quot;&quot;.. code-block:: python        def update_media(            self,            media_folder_id: Union[str, None],            url: str,            media_alt_txt: Union[str, None] = None,            media_title: Union[str, None] = None,            media_filename: Optional[PathMedia] = None,            upload_media: bool = True,        ) -&gt; str:            &quot;&quot;&quot;            find the media record by media_filename and media_folder_id,            update Media &quot;mediaFolderId&quot;, &quot;alt&quot; and &quot;title&quot;            upload the image from url.            if no &quot;media_filename&quot; is provided, the media filename is taken from the url.            :param media_folder_id:     folder id            :param url:                 url of the file to upload            :param media_alt_txt:       'alt'            :param media_title:         'title'            :param media_filename:      the filename (with extension) as string, like 'test001_01_1280.jpg'            :param upload_media:        if to upload the media            :return: the media_id            see : https://shopware.stoplight.io/docs/admin-api/c2NoOjE0MzUxMjU3-media            see : https://shopware.stoplight.io/docs/admin-api/ZG9jOjEyNjI1Mzkw-media-handling            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; my_media_folder_id = my_api.upsert_media_folders_by_path(path_media_folder='/Product Media/test_update_media')            &gt;&gt;&gt; # insert media            &gt;&gt;&gt; ignore01 = my_api.insert_media(media_folder_id=my_media_folder_id, url='https://pics.rotek.at/test/test001/bilder/test001_09_1280.jpg',            ...     media_filename = 'test001_09_1280.jpg')            &gt;&gt;&gt; # update media, with url different from filename            &gt;&gt;&gt; ignore02 = my_api.update_media(media_folder_id=my_media_folder_id, url='https://pics.rotek.at/test/test003/bilder/test003_01_1280.jpg',            ...     media_filename = 'test001_09_1280.jpg')            &gt;&gt;&gt; # cleanup            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder='/Product Media/test_update_media', force=True)            &quot;&quot;&quot;.. code-block:: python        def upload_media_from_url(self, media_id: str, url: str, filename_suffix: str, filename_stem: str) -&gt; None:            &quot;&quot;&quot;            uploads the media to an existing media_id            note that the same media_filename must not exist twice in the shop, even if on different media folders !            :param media_id:        the media id            :param url:             the url to upload the media from            :param filename_suffix: the extension, like &quot;jpg&quot;            :param filename_stem:   the filename (without extension)            :return:            &quot;&quot;&quot;.. code-block:: python        def upsert_media(            self,            product_number: Union[int, str],            position: int,            url: str,            media_alt: Union[str, None] = None,            media_title: Union[str, None] = None,            upload_media: bool = True,        ) -&gt; str:            &quot;&quot;&quot;            Insert or updates the Media and its folder. On insert, the media_id is calculated from product_number            media folders are created as needed            if upload_media == False, You can only rely on the returned media_id to find the inserted record -                all other fields are &quot;None&quot; so the api functions is_media_existing, etc. will not work !                You need to store the media_id and upload the media to complete the record.            :param product_number: 9 digit rotek artikelnummer            :param position: the position when sorting pictures            :param url:            :param media_alt:            :param media_title:            :param upload_media:            :return: the new, or updated media_id            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; my_api.conf_path_media_folder_root = '/Product Media/api_test_upsert_product_media'            &gt;&gt;&gt; my_url='https://pics.rotek.at/test/test001/bilder/test001_03_1280.jpg'            &gt;&gt;&gt; my_product_number = '997997997'            &gt;&gt;&gt; my_media_filename = my_api.calc_media_filename_from_product_number(            ...     product_number=my_product_number, position=1, url=my_url)            &gt;&gt;&gt; # Test media is not existing now            &gt;&gt;&gt; assert False == my_api.is_media_existing(media_filename=my_media_filename)            &gt;&gt;&gt; # Test media upsert (insert)            &gt;&gt;&gt; ignore01 = my_api.upsert_media(product_number=my_product_number, position=1, url=my_url)            &gt;&gt;&gt; assert True == my_api.is_media_existing(media_filename=my_media_filename)            &gt;&gt;&gt; # Test media upsert (update)            &gt;&gt;&gt; ignore02 = my_api.upsert_media(product_number=my_product_number, position=1, url=my_url)            &gt;&gt;&gt; assert True == my_api.is_media_existing(media_filename=my_media_filename)            &gt;&gt;&gt; assert ignore01 == ignore02            &gt;&gt;&gt; # cleanup            &gt;&gt;&gt; my_api.delete_media_folder_by_path(my_api.conf_path_media_folder_root, force=True)            &quot;&quot;&quot;.. code-block:: python        def upsert_media_folders_by_path(self, path_media_folder: PathMediaFolder, configuration_id: Optional[str] = None) -&gt; Optional[str]:            &quot;&quot;&quot;            upsert media folders - including the parents, exist is ok            :param path_media_folder: like '/Product Media/a000/000/001            :param configuration_id: the folder configuration id. taken from parent folder if none            :return: the id of the last created folder            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Media()            &gt;&gt;&gt; # Test            &gt;&gt;&gt; discard = my_api.upsert_media_folders_by_path(path_media_folder='/Product Media/test_insert_media_folder_by_path/subfolder1/subfolder2')            &gt;&gt;&gt; assert True == my_api.is_media_folder_existing_by_path(path_media_folder='/Product Media/test_insert_media_folder_by_path/subfolder1/subfolder2')            &gt;&gt;&gt; # test Exist = Ok            &gt;&gt;&gt; discard = my_api.upsert_media_folders_by_path(path_media_folder='/Product Media/test_insert_media_folder_by_path/subfolder1/subfolder2')            &gt;&gt;&gt; assert True == my_api.is_media_folder_existing_by_path(path_media_folder='/Product Media/test_insert_media_folder_by_path/subfolder1/subfolder2')            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.delete_media_folder_by_path(path_media_folder='/Product Media/test_insert_media_folder_by_path', force=True)            &quot;&quot;&quot;Product=======back to `Overview`_.. code-block:: python    @attrs.define    class ProductPicture:        &quot;&quot;&quot;        dataclass to upsert a picture        &quot;&quot;&quot;.. code-block:: python    class Product(object):        def __init__(            self, admin_client: Optional[Shopware6AdminAPIClientBase] = None, config: Optional[ConfShopware6ApiBase] = None, use_docker_test_container: bool = False        ) -&gt; None:            &quot;&quot;&quot;            :param admin_client:            :param config:            :param use_docker_test_container:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &quot;&quot;&quot;.. code-block:: python        @staticmethod        def calc_new_product_id(product_number: Union[int, str]) -&gt; str:            &quot;&quot;&quot;            :param product_number:            :return: the new id            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_new_product_id = my_api.calc_new_product_id(product_number='123')            &gt;&gt;&gt; my_new_product_id2 = my_api.calc_new_product_id(product_number='1234')            &gt;&gt;&gt; assert 32 == len(my_new_product_id)            &gt;&gt;&gt; assert my_new_product_id != my_new_product_id2            &quot;&quot;&quot;.. code-block:: python        @staticmethod        def calc_new_product_media_id(product_id: str, position: int) -&gt; str:            &quot;&quot;&quot;            the new product_media_id is calculated from product_id and position            :param product_id:            :param position:            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_new_product_media_id = my_api.calc_new_product_media_id(product_id='123', position=0)            &gt;&gt;&gt; my_new_product_media_id2 = my_api.calc_new_product_media_id(product_id='123', position=1)            &gt;&gt;&gt; assert 32 == len(my_new_product_media_id)            &gt;&gt;&gt; assert my_new_product_media_id != my_new_product_media_id2            &quot;&quot;&quot;.. code-block:: python        def cache_clear_product(self) -&gt; None:            &quot;&quot;&quot;            Cache of some functions has to be cleared if articles are inserted or deleted            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_api.cache_clear_product()            &quot;&quot;&quot;.. code-block:: python        def delete_product_by_id(self, product_id: str) -&gt; None:            &quot;&quot;&quot;            :param product_id:            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; my_article_id = my_api.insert_product(name='rn-doctest-article', product_number='test_delete_article_by_id_001', price_brutto=Decimal(0), stock=0)            &gt;&gt;&gt; # delete_article            &gt;&gt;&gt; my_api.delete_product_by_id(product_id=my_article_id)            &quot;&quot;&quot;.. code-block:: python        @lru_cache(maxsize=None)        def get_product_id_by_product_number(self, product_number: Union[int, str]) -&gt; str:            &quot;&quot;&quot;            :param product_number:            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; my_payload = dal.Criteria(limit=1, page=1)            &gt;&gt;&gt; first_article = my_api._admin_client.request_get(request_url=&quot;product&quot;, payload=my_payload)[&quot;data&quot;][0]            &gt;&gt;&gt; my_article_id = first_article['id']            &gt;&gt;&gt; my_article_product_number = first_article['productNumber']            &gt;&gt;&gt; # Test get article_id            &gt;&gt;&gt; assert my_article_id == my_api.get_product_id_by_product_number(product_number=my_article_product_number)            &gt;&gt;&gt; # test not existing (int)            &gt;&gt;&gt; my_api.get_product_id_by_product_number(product_number='get_article_id_by_product_number9999_not_existing')            Traceback (most recent call last):                ...            FileNotFoundError: article with productNumber(mysql_artikelnummer) &quot;...&quot; not found            &gt;&gt;&gt; # test not existing (str)            &gt;&gt;&gt; my_api.get_product_id_by_product_number(product_number='not_existing')            Traceback (most recent call last):                ...            FileNotFoundError: article with productNumber(mysql_artikelnummer) &quot;not_existing&quot; not found            &gt;&gt;&gt; # Test clear Cache - the Cache has to be cleared if products are inserted or deleted            &gt;&gt;&gt; my_api.get_product_id_by_product_number.cache_clear()            &quot;&quot;&quot;.. code-block:: python        def delete_product_media_relation_by_id(self, product_media_id: str) -&gt; None:            &quot;&quot;&quot;            delete product-media relation - but not the media itself.            :param product_media_id:            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; my_api.media.conf_path_media_folder_root = '/Product Media/api_test_delete_product_media_by_id'            &gt;&gt;&gt; product_number = 'test_delete_product_media_by_id'            &gt;&gt;&gt; my_url='https://pics.rotek.at/test/test001/bilder/test001_01_1280.jpg'            &gt;&gt;&gt; my_position = 10            &gt;&gt;&gt; my_product_id = my_api.insert_product(name='rn-doctest-article', product_number=product_number, price_brutto=Decimal(0), stock=0)            &gt;&gt;&gt; my_media_id = my_api.media.upsert_media(product_number=product_number, position=my_position, url=my_url)            &gt;&gt;&gt; my_product_media_id = my_api.insert_product_media_relation(product_id=my_product_id, media_id=my_media_id, position=my_position)            &gt;&gt;&gt; # Test            &gt;&gt;&gt; assert True == my_api.is_media_used_in_product_media(media_id=my_media_id)            &gt;&gt;&gt; my_api.delete_product_media_relation_by_id(product_media_id=my_product_media_id)            &gt;&gt;&gt; assert False == my_api.is_media_used_in_product_media(media_id=my_media_id)            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.delete_product_by_id(product_id=my_product_id)            &gt;&gt;&gt; my_api.media.delete_media_folder_by_path(my_api.media.conf_path_media_folder_root, force=True)            &quot;&quot;&quot;.. code-block:: python        def delete_product_media_relations_by_product_number(self, product_number: Union[int, str]) -&gt; None:            &quot;&quot;&quot;            Delete all product_media relations of a product , but not the media itself,            because there will be a reorg which deletes unused pictures.            it does not change the cover picture            It is neccessary to delete the product_media_relations before updating them, because otherwise            deletion of pictures on the source database would not be propagated.            If someone need to update the product pictures very frequently on a huge amount of products,            there might be more efficient (but much more complicated) methods.            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; my_api.media.conf_path_media_folder_root = '/Product Media/api_test_delete_product_picture_relations'            &gt;&gt;&gt; my_product_number = 'api_test_delete_product_picture_relations'            &gt;&gt;&gt; my_url='https://pics.rotek.at/test/test001/bilder/test001_01_1280.jpg'            &gt;&gt;&gt; my_product_id = my_api.insert_product(name='test_del_prod_media_rel_by_prod_number_001', product_number=my_product_number, \                    price_brutto=Decimal(0), stock=0)            &gt;&gt;&gt; my_position = 10            &gt;&gt;&gt; my_media_id_10 = my_api.media.upsert_media(product_number=my_product_number, position=my_position, url=my_url)            &gt;&gt;&gt; my_product_media_id_10 = my_api.insert_product_media_relation(product_id=my_product_id, media_id=my_media_id_10, position=my_position)            &gt;&gt;&gt; my_position = 20            &gt;&gt;&gt; my_media_id_20 = my_api.media.upsert_media(product_number=my_product_number, position=my_position, url=my_url)            &gt;&gt;&gt; my_product_media_id_20 = my_api.insert_product_media_relation(product_id=my_product_id, media_id=my_media_id_20, position=my_position)            &gt;&gt;&gt; # Test delete product_media_relations            &gt;&gt;&gt; assert True == my_api.is_media_used_in_product_media(media_id=my_media_id_10)            &gt;&gt;&gt; assert True == my_api.is_media_used_in_product_media(media_id=my_media_id_20)            &gt;&gt;&gt; my_api.delete_product_media_relations_by_product_number(product_number=my_product_number)            &gt;&gt;&gt; assert False == my_api.is_media_used_in_product_media(media_id=my_media_id_10)            &gt;&gt;&gt; assert False == my_api.is_media_used_in_product_media(media_id=my_media_id_20)            &gt;&gt;&gt; # Test delete product_media_relations - product not existing is ok            &gt;&gt;&gt; my_api.delete_product_by_id(product_id=my_product_id)            &gt;&gt;&gt; my_api.delete_product_media_relations_by_product_number(product_number=my_product_number)            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.media.delete_media_folder_by_path(my_api.media.conf_path_media_folder_root, force=True)            &quot;&quot;&quot;.. code-block:: python        def get_product_medias(self, payload: Optional[Dict[str, Any]] = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            get all product_media - filters and so on can be set in the payload            we read paginated (in junks of 100 items) - this is done automatically by function base_client.request_get_paginated()            :parameters                payload, to set filters etc.            :returns                l_dict_data,            sample payload :                page and limit will be overridden by function base_client.request_get_paginated() and will be ignored            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; my_l_dict_data = my_api.get_product_medias()            &quot;&quot;&quot;.. code-block:: python        def get_products(self, payload: Optional[Dict[str, Any]] = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            get all articles back - filters and so on can be set in the payload            we read paginated (in junks of 100 items) - this is done automatically by function base_client.request_get_paginated()            :parameters                payload, to set filters etc.            :returns                l_dict_data,            sample payload :                page and limit will be overridden by function base_client.request_get_paginated() and will be ignored            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; dict_data = my_api.get_products()            &gt;&gt;&gt; assert len(dict_data) &gt; 5            &quot;&quot;&quot;.. code-block:: python        def insert_product(            self,            name: str,            product_number: Union[int, str],            stock: int = 0,            price_brutto: Decimal = Decimal(&quot;0.00&quot;),            price_netto: Decimal = Decimal(&quot;0.00&quot;),            tax_name: str = &quot;Standard rate&quot;,            currency_iso_code: str = &quot;EUR&quot;,            linked: bool = True,        ) -&gt; str:            &quot;&quot;&quot;            see : https://shopware.stoplight.io/docs/admin-api/ZG9jOjEyMzA4NTUy-product-data#simple-payload            :param name:                        'Stromerzeuger GD4-1A-6000-5EBZ'            :param product_number:              productNumber, mysql_artikelnummer            :param stock:                       Anzahl auf Lager (?)            :param tax_name:                    default tax record ('Standard rate')            :param price_brutto:                this price is displayed to customers who see gross prices in the shop            :param price_netto:                 this price is shown to customers who see net prices in the shop                                                if the price_netto is 0.00 it will be calculated from brutto price with the                                                tax rate of the 'tax_name' stated            :param currency_iso_code:           the currency isoCode like 'EUR', 'CHF', ...            :param linked:                      this is a flag for the administration. If it is set to true,                                                the gross or net counterpart is calculated when a price is entered in the administration.            :return: the new product id            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; # insert article            &gt;&gt;&gt; my_new_product_id = my_api.insert_product(name='test_insert_product001', product_number='test_insert_article_by_product_number_999',            ...                                           price_brutto=Decimal(100), stock=0)            &gt;&gt;&gt; assert 32 == len(my_new_product_id)            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.delete_product_by_id(product_id=my_new_product_id)            &quot;&quot;&quot;.. code-block:: python        def upsert_product_payload(self, product_number: Union[int, str], payload: Dict[str, Any]) -&gt; str:.. code-block:: python        def insert_product_media_relation(self, product_id: str, media_id: str, position: int) -&gt; str:            &quot;&quot;&quot;            inserts a single product_media Relation.            the new product_media_relation_id is calculated from product_id and position            this should only be used if You uploaded the media indipendently from products -            otherwise You should use associations to update the product with one request - see :            https://shopware.stoplight.io/docs/admin-api/ZG9jOjEyNjI1Mzkw-media-handling            https://shopware.stoplight.io/docs/admin-api/ZG9jOjEyMzA4NTUw-associationsundefined            :param product_id:            :param media_id:            :param position: 0-based            :return: the new product_media_relation_id            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; my_new_product_id = my_api.insert_product(name='rn-doctest-article', product_number='test_insert_product_media_999')            &gt;&gt;&gt; my_new_media_id = my_api.media.insert_media_by_path( \                    path_media='/Product Media/test_insert_product_media_999/test_insert_product_media_999_01_1280.jpg', \                    url='https://pics.rotek.at/test/test001/bilder/test001_07_1280.jpg')            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_new_product_media_id = my_api.insert_product_media_relation(product_id=my_new_product_id, media_id=my_new_media_id, position=0)            &gt;&gt;&gt; # Assert Media is used in product_media            &gt;&gt;&gt; assert True == my_api.is_media_used_in_product_media(media_id=my_new_media_id)            &gt;&gt;&gt; # Test delete Product, cascading delete to product_media            &gt;&gt;&gt; my_api.delete_product_by_id(product_id=my_new_product_id)            &gt;&gt;&gt; assert False == my_api.is_media_used_in_product_media(media_id=my_new_media_id)            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.media.delete_media_folder_by_path(path_media_folder = '/Product Media/test_insert_product_media_999/', force=True)            &quot;&quot;&quot;.. code-block:: python        def is_media_used_in_product_media(self, media_id: str) -&gt; bool:            &quot;&quot;&quot;            :returns True if the media is used in a product            :param media_id:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; my_new_product_id = my_api.insert_product(name='rn-doctest-article', product_number='test_is_media_used_in_product_media_999')            &gt;&gt;&gt; my_new_media_id = my_api.media.insert_media_by_path(            ...     path_media='/Product Media/test_is_media_used_in_product_media_999/test_is_media_used_in_product_media_999_01_1280.jpg',            ...     url='https://pics.rotek.at/test/test001/bilder/test001_07_1280.jpg')            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_new_product_media_id = my_api.insert_product_media_relation(product_id=my_new_product_id, media_id=my_new_media_id, position=0)            &gt;&gt;&gt; # Assert Media is used in product_media            &gt;&gt;&gt; assert True == my_api.is_media_used_in_product_media(media_id=my_new_media_id)            &gt;&gt;&gt; # Test delete Product, cascading delete to product_media            &gt;&gt;&gt; my_api.delete_product_by_id(product_id=my_new_product_id)            &gt;&gt;&gt; assert False == my_api.is_media_used_in_product_media(media_id=my_new_media_id)            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.media.delete_media_folder_by_path(path_media_folder = '/Product Media/test_is_media_used_in_product_media_999', force=True)            &quot;&quot;&quot;.. code-block:: python        def is_product_number_existing(self, product_number: Union[int, str]) -&gt; bool:            &quot;&quot;&quot;            :param product_number:            :return:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; my_new_product_id = my_api.insert_product(name='test_is_product_number_existing', product_number='is_product_number_existing_999')            &gt;&gt;&gt; # Test            &gt;&gt;&gt; assert True == my_api.is_product_number_existing(product_number = 'is_product_number_existing_999')            &gt;&gt;&gt; assert False == my_api.is_product_number_existing(product_number = 'product_number_does_not_exist')            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.delete_product_by_id(product_id=my_new_product_id)            &quot;&quot;&quot;.. code-block:: python        def search_product_medias(self, payload: PayLoad = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            search product_media            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; # insert article            &gt;&gt;&gt; ignore = my_api.search_product_medias()            &quot;&quot;&quot;.. code-block:: python        def upsert_product_pictures(self, product_number: Union[int, str], l_product_pictures: List[ProductPicture]) -&gt; None:            &quot;&quot;&quot;            upsert product pictures and cover picture. The first picture (by Position Number) is automatically the cover picture            :parameter product_number            :parameter l_product_pictures  list of Pictures            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Product()            &gt;&gt;&gt; my_api.media.conf_path_media_folder_root = '/Product Media/api_test_upsert_product_pictures'            &gt;&gt;&gt; my_product_number = 'test_upsert_product_pictures'            &gt;&gt;&gt; my_product_id = my_api.insert_product(name='test_upsert_product_pictures', product_number=my_product_number, price_brutto=Decimal(0), stock=0)            &gt;&gt;&gt; my_pictures=list()            &gt;&gt;&gt; my_pictures.append(ProductPicture(position=20, url='https://pics.rotek.at/test/test001/bilder/test001_02_1280.jpg', media_alt='', media_title=''))            &gt;&gt;&gt; my_pictures.append(ProductPicture(position=30, url='https://pics.rotek.at/test/test001/bilder/test001_03_1280.jpg', media_alt='', media_title=''))            &gt;&gt;&gt; my_pictures.append(ProductPicture(position=40, url='https://pics.rotek.at/test/test001/bilder/test001_04_1280.jpg', media_alt='', media_title=''))            &gt;&gt;&gt; my_pictures.append(ProductPicture(position=50, url='https://pics.rotek.at/test/test001/bilder/test001_05_1280.jpg', media_alt='', media_title=''))            &gt;&gt;&gt; my_pictures.append(ProductPicture(position=10, url='https://pics.rotek.at/test/test001/bilder/test001_01_1280.jpg', media_alt='', media_title=''))            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_api.upsert_product_pictures(product_number=my_product_number, l_product_pictures=my_pictures)            &gt;&gt;&gt; # Teardown            &gt;&gt;&gt; my_api.delete_product_media_relations_by_product_number(product_number=my_product_number)            &gt;&gt;&gt; my_api.delete_product_by_id(product_id=my_product_id)            &gt;&gt;&gt; my_api.media.delete_media_folder_by_path(my_api.media.conf_path_media_folder_root, force=True)            &quot;&quot;&quot;Tax===back to `Overview`_.. code-block:: python    class Tax(object):        def __init__(            self, admin_client: Optional[Shopware6AdminAPIClientBase] = None, config: Optional[ConfShopware6ApiBase] = None, use_docker_test_container: bool = False        ) -&gt; None:            &quot;&quot;&quot;            :param admin_client:            :param config:            :param use_docker_test_container:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Tax()            &quot;&quot;&quot;.. code-block:: python        def cache_clear_tax(self) -&gt; None:            &quot;&quot;&quot;            Cache of some functions has to be cleared if tax is inserted or deleted            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Tax()            &gt;&gt;&gt; # test            &gt;&gt;&gt; my_api.cache_clear_tax()            &quot;&quot;&quot;.. code-block:: python        @lru_cache(maxsize=None)        def get_tax_id_by_name(self, tax_name: str = &quot;Standard rate&quot;) -&gt; str:            &quot;&quot;&quot;            :param tax_name: the name of the tax record, like 'Standard rate', 'Reduced rate', 'Reduced Rate2'            :returns: the id of the tax record            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Tax()            &gt;&gt;&gt; # test get 'Standard rate' id            &gt;&gt;&gt; my_tax_id = my_api.get_tax_id_by_name()            &gt;&gt;&gt; assert 32 == len(my_tax_id)            &gt;&gt;&gt; # test not existing (int)            &gt;&gt;&gt; my_api.get_tax_id_by_name(tax_name='not_existing')            Traceback (most recent call last):                ...            FileNotFoundError: tax record with name &quot;not_existing&quot; not found            &gt;&gt;&gt; # Test clear Cache -the Cache has to be cleared if tax records are inserted or deleted            &gt;&gt;&gt; my_api.get_tax_id_by_name.cache_clear()            &quot;&quot;&quot;.. code-block:: python        def get_taxes(self, payload: Optional[Dict[str, Any]] = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            get all tax records - filters and so on can be set in the payload            we read paginated (in junks of 100 items) - this is done automatically by function base_client.request_get_paginated()            :parameters                payload, to set filters etc.            :returns                l_dict_data,            sample payload :                page and limit will be overridden by function base_client.request_get_paginated() and will be ignored            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Tax()            &gt;&gt;&gt; my_l_dict_data = my_api.get_taxes()            &quot;&quot;&quot;.. code-block:: python        @lru_cache(maxsize=None)        def get_tax_rate_by_name(self, tax_name: str = &quot;Standard rate&quot;) -&gt; Decimal:            &quot;&quot;&quot;            :param tax_name: the name of the tax record, like 'Standard rate', 'Reduced rate', 'Reduced Rate2'            :returns: the percent , like Decimal('19.00')            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Tax()            &gt;&gt;&gt; # test get 'Standard rate' percentage            &gt;&gt;&gt; my_tax_rate = my_api.get_tax_rate_by_name()            &gt;&gt;&gt; assert Decimal('19.00') == my_tax_rate            &gt;&gt;&gt; # test not existing (int)            &gt;&gt;&gt; my_api.get_tax_rate_by_name(tax_name='not_existing')            Traceback (most recent call last):                ...            FileNotFoundError: tax record with name &quot;not_existing&quot; not found            &gt;&gt;&gt; # Test clear Cache -the Cache has to be cleared if tax records are inserted or deleted            &gt;&gt;&gt; my_api.get_tax_id_by_name.cache_clear()            &quot;&quot;&quot;Unit========back to `Overview`_.. code-block:: python    class Unit(object):        def __init__(            self, admin_client: Optional[Shopware6AdminAPIClientBase] = None, config: Optional[ConfShopware6ApiBase] = None, use_docker_test_container: bool = False        ) -&gt; None:            &quot;&quot;&quot;            :param admin_client:            :param config:            :param use_docker_test_container:            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Unit()            &quot;&quot;&quot;.. code-block:: python        def cache_clear_unit(self) -&gt; None:            &quot;&quot;&quot;            Cache of some functions has to be cleared if unit records are inserted or deleted            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Unit()            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_api.cache_clear_unit()            &quot;&quot;&quot;.. code-block:: python        @lru_cache(maxsize=None)        def get_units(self, payload: Optional[Dict[str, Any]] = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            get all delivery-time records - filters and so on can be set in the payload            we read paginated (in junks of 100 items) - this is done automatically by function base_client.request_get_paginated()            :parameters                payload, to set filters etc.            :returns                l_dict_data,            sample payload :                page and limit will be overridden by function base_client.request_get_paginated() and will be ignored            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Unit()            &gt;&gt;&gt; # Test            &gt;&gt;&gt; my_l_dict_data = my_api.get_units()            &quot;&quot;&quot;.. code-block:: python        def search_units(self, payload: PayLoad = None) -&gt; List[Dict[str, Any]]:            &quot;&quot;&quot;            search delivery-time records            &gt;&gt;&gt; # Setup            &gt;&gt;&gt; my_api = Unit()            &gt;&gt;&gt; # Test            &gt;&gt;&gt; ignore = my_api.search_units()            &quot;&quot;&quot;Usage from Commandline------------------------.. code-block::   Usage: lib_shopware6_api [OPTIONS] COMMAND [ARGS]...     use the shopware 6 api   Options:     --version                     Show the version and exit.     --traceback / --no-traceback  return traceback information on cli     -h, --help                    Show this message and exit.   Commands:     info  get program informationsInstallation and Upgrade------------------------- Before You start, its highly recommended to update pip and setup tools:.. code-block::    python -m pip --upgrade pip    python -m pip --upgrade setuptools- to install the latest release from PyPi via pip (recommended):.. code-block::    python -m pip install --upgrade lib_shopware6_api- to install the latest version from github via pip:.. code-block::    python -m pip install --upgrade git+https://github.com/bitranox/lib_shopware6_api.git- include it into Your requirements.txt:.. code-block::    # Insert following line in Your requirements.txt:    # for the latest Release on pypi:    lib_shopware6_api    # for the latest development version :    lib_shopware6_api @ git+https://github.com/bitranox/lib_shopware6_api.git    # to install and upgrade all modules mentioned in requirements.txt:    python -m pip install --upgrade -r /&lt;path&gt;/requirements.txt- to install the latest development version from source code:.. code-block::    # cd ~    $ git clone https://github.com/bitranox/lib_shopware6_api.git    $ cd lib_shopware6_api    python setup.py install- via makefile:  makefiles are a very convenient way to install. Here we can do much more,  like installing virtual environments, clean caches and so on... code-block:: shell    # from Your shell's homedirectory:    $ git clone https://github.com/bitranox/lib_shopware6_api.git    $ cd lib_shopware6_api    # to run the tests:    $ make test    # to install the package    $ make install    # to clean the package    $ make clean    # uninstall the package    $ make uninstallRequirements------------following modules will be automatically installed :.. code-block:: bash    ## Project Requirements    attrs&gt;=21.3.0    click    cli_exit_tools    lib_detect_testenv    lib_shopware6_api_baseAcknowledgements----------------- special thanks to &quot;uncle bob&quot; Robert C. Martin, especially for his books on &quot;clean code&quot; and &quot;clean architecture&quot;Contribute----------I would love for you to fork and send me pull request for this project.- `please Contribute &lt;https://github.com/bitranox/lib_shopware6_api/blob/master/CONTRIBUTING.md&gt;`_License-------This software is licensed under the `MIT license &lt;http://en.wikipedia.org/wiki/MIT_License&gt;`_---Changelog=========- new MAJOR version for incompatible API changes,- new MINOR version for added functionality in a backwards compatible manner- new PATCH version for backwards compatible bug fixesv2.0.2.3---------2022-06-30: specify correct &quot;attr&quot; version in requirementsv2.0.2.2---------2022-06-02: update to github actions checkout@v3 and setup-python@v3v2.0.2.1--------2022-06-01: update github actions test matrixv2.0.2--------2022-03-29: remedy mypy Untyped decorator makes function &quot;cli_info&quot; untypedv2.0.1--------2022-01-19: update documentation, enhance coveragev2.0.0--------2022-01-19: add function is_product_number_existing, add Unit functions, changed some method namesv1.0.2--------2022-01-18: clean requirements.txtv1.0.1--------2022-01-18: Documentation update, make PyPi packagev1.0.0--------2022-01-17: Initial Release</longdescription>
</pkgmetadata>