<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;      &lt;img alt=&quot;arguably logo&quot; src=&quot;https://raw.githubusercontent.com/treykeown/arguably/main/etc/logo/arguably_black.png&quot;&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;em&gt;        The best Python CLI library, arguably.    &lt;/em&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://github.com/treykeown/arguably/actions/workflows/python-package.yml&quot;&gt;&lt;img src=&quot;https://github.com/treykeown/arguably/actions/workflows/python-package.yml/badge.svg&quot; alt=&quot;Test status&quot;&gt;&lt;/a&gt;    &lt;a href=&quot;https://treykeown.github.io/arguably/coverage/&quot;&gt;&lt;img src=&quot;https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/treykeown/f493b14288af4e8358ea8578c393213a/raw/arguably-coverage-badge.json&quot; alt=&quot;Code coverage&quot;&gt;&lt;/a&gt;    &lt;a href=&quot;https://pypi.org/project/arguably/&quot;&gt;&lt;img src=&quot;https://shields.io/pypi/pyversions/arguably&quot; alt=&quot;Supported Python versions&quot;&gt;&lt;/a&gt;    &lt;a href=&quot;https://pypi.org/project/arguably/&quot;&gt;&lt;img src=&quot;https://shields.io/pypi/v/arguably&quot; alt=&quot;PyPI version&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;`arguably` turns functions and docstrings into command line interfaces (CLIs). `arguably` has a tiny API and isextremely easy to integrate. You can also use it directly through `python3 -m arguably your_script.py`, more on that[here](#no-integration-required).To use `arguably` in a script, decorate any functions that should appear on the command line with `@arguably.command`,then call `arguably.run()`. If multiple functions are decorated, they'll all appear as subcommands. You can even have*multiple levels* of subcommands: `def s3__ls()` becomes `s3 ls`.&lt;div align=&quot;right&quot;&gt;&lt;sub&gt;    &lt;a href=&quot;https://github.com/treykeown/arguably/blob/main/etc/scripts/intro.py&quot;&gt;[source]&lt;/a&gt;&lt;/sub&gt;&lt;/div&gt;```python#!/usr/bin/env python3import arguably@arguably.commanddef some_function(required, not_required=2, *others: int, option: float = 3.14):    &quot;&quot;&quot;    this function is on the command line!    Args:        required: a required argument        not_required: this one isn't required, since it has a default value        *others: all the other positional arguments go here        option: [-x] keyword-only args are options, short name is in brackets    &quot;&quot;&quot;    print(f&quot;{required=}, {not_required=}, {others=}, {option=}&quot;)if __name__ == &quot;__main__&quot;:    arguably.run()```&lt;p align=&quot;center&quot;&gt;&lt;b&gt;&lt;em&gt;becomes&lt;/em&gt;&lt;/b&gt;&lt;/p&gt;```consoleuser@machine:~$ ./intro.py -husage: intro.py [-h] [-x OPTION] required [not-required] [others ...]this function is on the command line!positional arguments:  required             a required argument (type: str)  not-required         this one isn't required, since it has a default value (type: int, default: 2)  others               all the other positional arguments go here (type: int)options:  -h, --help           show this help message and exit  -x, --option OPTION  keyword-only args are options, short name is in brackets (type: float, default: 3.14)```Arguments to the CLI look just like calling the Python function.```pycon&gt;&gt;&gt; from intro import some_function&gt;&gt;&gt; some_function(&quot;asdf&quot;, 0, 7, 8, 9, option=2.71)required='asdf', not_required=0, others=(7, 8, 9), option=2.71``````consoleuser@machine:~$ ./intro.py asdf 0 7 8 9 --option 2.71required='asdf', not_required=0, others=(7, 8, 9), option=2.71````arguably` uses your docstrings to automatically generate help messages. It supports all major formats for docstrings:reStructuredText, Google, Numpydoc, and Epydoc.Type annotations are optional, but `arguably` can use them to automatically convert arguments. It has smart handling formapping built-in types to the command line, including `tuple`, `list`, `enum.Enum`, and `enum.Flag`.There are also a few special behaviors you can attach to a parameter via `Annotated[]` and the `arguably.arg.*`functions. Using `arguably.arg.builder()`, you can even build an object to pass in from the command line (using syntaxinspired by QEMU):&lt;div align=&quot;right&quot;&gt;&lt;sub&gt;    &lt;a href=&quot;https://github.com/treykeown/arguably/blob/main/etc/scripts/build.py&quot;&gt;[source]&lt;/a&gt;&lt;/sub&gt;&lt;/div&gt;```consoleuser@machine:~$ ./build.py --nic tap,model=e1000 --nic user,hostfwd=tcp::10022-:22nic=[TapNic(model='e1000'), UserNic(hostfwd='tcp::10022-:22')]```## No integration requiredDon't want to write any code? Simply pass any Python script to `arguably` to give it a command line interface.&lt;div align=&quot;right&quot;&gt;&lt;sub&gt;    &lt;a href=&quot;https://github.com/treykeown/arguably/blob/main/etc/scripts/party-trick.py&quot;&gt;[source]&lt;/a&gt;&lt;/sub&gt;&lt;/div&gt;```consoleuser@machine:~$ python3 -m arguably party-trick.py -husage: party-trick [-h] [--version] command ...this is the docstring for the whole scriptpositional arguments:  command    hello                   this is hello's docstring    goodbye                 any function from a script can be called    some-class              so can any __init__ for objects defined in the script    some-class.func-static  a @staticmethod on a class can be called    some-class.func-cls     so can a @classmethodoptions:  -h, --help                show this help message and exit  --version                 show program's version number and exit```## InstallationInstall using `pip install arguably`. If you want to install using `conda`, please comment on[this issue](https://github.com/treykeown/arguably/issues/12).## Documentation* Why arguably?: [https://treykeown.github.io/arguably/why/](https://treykeown.github.io/arguably/why/)* Examples: [https://treykeown.github.io/arguably/examples/](https://treykeown.github.io/arguably/examples/)* Tutorial: [https://treykeown.github.io/arguably/tutorial/intro/](https://treykeown.github.io/arguably/tutorial/intro/)* API Reference: [https://treykeown.github.io/arguably/api-reference/](https://treykeown.github.io/arguably/api-reference/)## DependenciesAll of `arguably` is built on top of `argparse`. It has two dependencies:* `docstring-parser` for parsing function docstrings* `typing-extensions` for `Annotated[]` support in Python 3.8 (only needed for that version)## ContributingIdeas and help are very much appreciated! There's a guide for getting started with contributing to `arguably` that showsyou how to run tests and pre-commit hooks.* Contributing: [https://treykeown.github.io/arguably/contributing/](https://treykeown.github.io/arguably/contributing/)## Future roadmapIf you have any interest in these (either as a user or implementer), please leave a comment!* [#8 - Display all enum options in a command group](https://github.com/treykeown/arguably/issues/8)* [#9 - Both positive and negative boolean flags](https://github.com/treykeown/arguably/issues/9)* [#10 - Take inputs from environment variables](https://github.com/treykeown/arguably/issues/10)* [#13 - Implement config interface](https://github.com/treykeown/arguably/issues/13)* [#16 - Integration with rich for formatted CLI output](https://github.com/treykeown/arguably/issues/16)</longdescription>
</pkgmetadata>