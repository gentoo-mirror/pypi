<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># d20[![PyPI version shields.io](https://img.shields.io/pypi/v/d20.svg)](https://pypi.python.org/pypi/d20/)[![PyPI license](https://img.shields.io/pypi/l/d20.svg)](https://pypi.python.org/pypi/d20/)[![PyPI pyversions](https://img.shields.io/pypi/pyversions/d20.svg)](https://pypi.python.org/pypi/d20/)![](https://github.com/avrae/d20/workflows/Test%20Package/badge.svg)[![codecov](https://codecov.io/gh/avrae/d20/branch/master/graph/badge.svg)](https://codecov.io/gh/avrae/d20)[![Documentation Status](https://readthedocs.org/projects/d20/badge/?version=latest)](https://d20.readthedocs.io/en/latest/start.html?badge=latest)A fast, powerful, and extensible dice engine for D&amp;D, d20 systems, and any other system that needs dice!## Key Features- Quick to start - just use `d20.roll()`!- Optimized for speed and memory efficiency- Highly extensible API for custom behaviour and dice stringification- Built-in execution limits against malicious dice expressions- Tree-based dice representation for easy traversal ## Installing**Requires Python 3.6+**.```bashpython3 -m pip install -U d20```## Quickstart```python&gt;&gt;&gt; import d20&gt;&gt;&gt; result = d20.roll(&quot;1d20+5&quot;)&gt;&gt;&gt; str(result)'1d20 (10) + 5 = `15`'&gt;&gt;&gt; result.total15&gt;&gt;&gt; result.crit&lt;CritType.NORMAL: 0&gt;&gt;&gt;&gt; str(result.ast)'1d20 + 5'```## DocumentationCheck out the docs on [Read the Docs](https://d20.readthedocs.io/en/latest/start.html)!## Dice SyntaxThis is the grammar supported by the dice parser, roughly ordered in how tightly the grammar binds.### NumbersThese are the atoms used at the base of the syntax tree.| Name    | Syntax                            | Description           | Examples                       ||---------|-----------------------------------|-----------------------|--------------------------------|| literal | `INT`, `DECIMAL`                  | A literal number.     | `1`, `0.5`, `3.14`             || dice    | `INT? &quot;d&quot; (INT \| &quot;%&quot;)`           | A set of die.         | `d20`, `3d6`                   || set     | `&quot;(&quot; (num (&quot;,&quot; num)* &quot;,&quot;?)? &quot;)&quot;`  | A set of expressions. | `()`, `(2,)`, `(1, 3+3, 1d20)` |Note that `(3d6)` is equivalent to `3d6`, but `(3d6,)` is the set containing the one element `3d6`.### Set OperationsThese operations can be performed on dice and sets.#### Grammar| Name    | Syntax            | Description       | Examples           ||---------|-------------------|-------------------|--------------------|| set_op  | `operation selector` | An operation on a set (see below). | `kh3`, `ro&lt;3` || selector | `seltype INT` | A selection on a set (see below). | `3`, `h1`, `&gt;2` |#### OperatorsOperators are always followed by a selector, and operate on the items in the set that match the selector.| Syntax | Name | Description ||---|---|---|| k | keep | Keeps all matched values. || p | drop | Drops all matched values. || rr | reroll | Rerolls all matched values until none match. (Dice only) || ro | reroll once | Rerolls all matched values once. (Dice only) || ra | reroll and add | Rerolls up to one matched value once, keeping the original roll. (Dice only) || e | explode on | Rolls another die for each matched value. (Dice only) || mi | minimum | Sets the minimum value of each die. (Dice only) || ma | maximum | Sets the maximum value of each die. (Dice only) |#### SelectorsSelectors select from the remaining kept values in a set.| Syntax | Name | Description ||---|---|---|| X | literal | All values in this set that are literally this value. || hX | highest X | The highest X values in the set. || lX | lowest X | The lowest X values in the set. || \&gt;X | greater than X | All values in this set greater than X. || &lt;X | less than X | All values in this set less than X. |### Unary Operations| Syntax | Name | Description ||---|---|---|| +X | positive | Does nothing. || -X | negative | The negative value of X. |### Binary Operations| Syntax | Name ||---|---|| X * Y | multiplication || X / Y | division || X // Y | int division || X % Y | modulo || X + Y | addition || X - Y | subtraction || X == Y | equality || X &gt;= Y | greater/equal || X &lt;= Y | less/equal || X &gt; Y | greater than || X &lt; Y | less than || X != Y | inequality |### Examples```python&gt;&gt;&gt; from d20 import roll&gt;&gt;&gt; r = roll(&quot;4d6kh3&quot;)  # highest 3 of 4 6-sided dice&gt;&gt;&gt; r.total14&gt;&gt;&gt; str(r)'4d6kh3 (4, 4, **6**, ~~3~~) = `14`'&gt;&gt;&gt; r = roll(&quot;2d6ro&lt;3&quot;)  # roll 2d6s, then reroll any 1s or 2s once&gt;&gt;&gt; r.total9&gt;&gt;&gt; str(r)'2d6ro&lt;3 (**~~1~~**, 3, **6**) = `9`'&gt;&gt;&gt; r = roll(&quot;8d6mi2&quot;)  # roll 8d6s, with each die having a minimum roll of 2&gt;&gt;&gt; r.total33&gt;&gt;&gt; str(r)'8d6mi2 (1 -&gt; 2, **6**, 4, 2, **6**, 2, 5, **6**) = `33`'&gt;&gt;&gt; r = roll(&quot;(1d4 + 1, 3, 2d6kl1)kh1&quot;)  # the highest of 1d4+1, 3, and the lower of 2 d6s&gt;&gt;&gt; r.total3&gt;&gt;&gt; str(r)'(1d4 (2) + 1, ~~3~~, ~~2d6kl1 (2, 5)~~)kh1 = `3`'```## Custom StringifierBy default, d20 stringifies the result of each dice roll formatted in Markdown, which may not be useful in your application. To change this behaviour, you can create a subclass of [`d20.Stringifier`](https://github.com/avrae/d20/blob/master/d20/stringifiers.py) (or `d20.SimpleStringifier` as a starting point), and implement the `_str_*` methods to customize how your dice tree is stringified. Then, simply pass an instance of your stringifier into the `roll()` function!```python&gt;&gt;&gt; import d20&gt;&gt;&gt; class MyStringifier(d20.SimpleStringifier):...     def _stringify(self, node):...         if not node.kept:...             return 'X'...         return super()._stringify(node)......     def _str_expression(self, node):...         return f&quot;The result of the roll {self._stringify(node.roll)} was {int(node.total)}&quot;&gt;&gt;&gt; result = d20.roll(&quot;4d6e6kh3&quot;, stringifier=MyStringifier())&gt;&gt;&gt; str(result)'The result of the roll 4d6e6kh3 (X, 5, 6!, 6!, X, X) was 17'```## Annotations and CommentsEach dice node supports value annotations - i.e., a method to &quot;tag&quot; parts of a roll with some indicator. For example,```python&gt;&gt;&gt; from d20 import roll&gt;&gt;&gt; str(roll(&quot;3d6 [fire] + 1d4 [piercing]&quot;))'3d6 (3, 2, 2) [fire] + 1d4 (3) [piercing] = `10`'&gt;&gt;&gt; str(roll(&quot;-(1d8 + 3) [healing]&quot;))'-(1d8 (7) + 3) [healing] = `-10`'&gt;&gt;&gt; str(roll(&quot;(1 [one], 2 [two], 3 [three])&quot;))'(1 [one], 2 [two], 3 [three]) = `6`'```are all examples of valid annotations. Annotations are purely visual and do not affect the evaluation of the roll by default.Additionally, when `allow_comments=True` is passed to `roll()`, the result of the roll may have a comment:```python&gt;&gt;&gt; from d20 import roll&gt;&gt;&gt; result = roll(&quot;1d20 I rolled a d20&quot;, allow_comments=True)&gt;&gt;&gt; str(result)'1d20 (13) = `13`'&gt;&gt;&gt; result.comment'I rolled a d20'```Note that while `allow_comments` is enabled, AST caching is disabled, which may lead to slightly worse performance.## Traversing Dice ResultsThe raw results of dice rolls are returned in [`Expression`](https://github.com/avrae/d20/blob/master/d20/models.py#L76) objects, which can be accessed as such: ```python&gt;&gt;&gt; from d20 import roll&gt;&gt;&gt; result = roll(&quot;3d6 + 1d4 + 3&quot;)&gt;&gt;&gt; str(result)'3d6 (4, **6**, **6**) + 1d4 (**1**) + 3 = `20`'&gt;&gt;&gt; result.expr&lt;Expression roll=&lt;BinOp left=&lt;BinOp left=&lt;Dice num=3 size=6 values=[&lt;Die size=6 values=[&lt;Literal 4&gt;]&gt;, &lt;Die size=6 values=[&lt;Literal 6&gt;]&gt;, &lt;Die size=6 values=[&lt;Literal 6&gt;]&gt;] operations=[]&gt; op=+ right=&lt;Dice num=1 size=4 values=[&lt;Die size=4 values=[&lt;Literal 1&gt;]&gt;] operations=[]&gt;&gt; op=+ right=&lt;Literal 3&gt;&gt; comment=None&gt;```or, in a easier-to-read format,```text&lt;Expression     roll=&lt;BinOp        left=&lt;BinOp            left=&lt;Dice                num=3                size=6                values=[                    &lt;Die size=6 values=[&lt;Literal 4&gt;]&gt;,                    &lt;Die size=6 values=[&lt;Literal 6&gt;]&gt;,                    &lt;Die size=6 values=[&lt;Literal 6&gt;]&gt;                ]                operations=[]            &gt;            op=+            right=&lt;Dice                num=1                size=4                values=[                    &lt;Die size=4 values=[&lt;Literal 1&gt;]&gt;                ]                operations=[]            &gt;        &gt;        op=+        right=&lt;Literal 3&gt;    &gt;    comment=None&gt;```From here, `Expression.children` returns a tree of nodes representing the expression from left to right, each of whichmay have children of their own. This can be used to easily search for specific dice, look for the left-most operand,or modify the result by adding in resistances or other modifications.### ExamplesFinding the left and right-most operands:```python&gt;&gt;&gt; from d20 import roll&gt;&gt;&gt; binop = roll(&quot;1 + 2 + 3 + 4&quot;)&gt;&gt;&gt; left = binop.expr&gt;&gt;&gt; while left.children:...     left = left.children[0]&gt;&gt;&gt; left&lt;Literal 1&gt;&gt;&gt;&gt; right = binop.expr&gt;&gt;&gt; while right.children:...     right = right.children[-1]&gt;&gt;&gt; right&lt;Literal 4&gt;&gt;&gt;&gt; from d20 import utils  # these patterns are available in the utils submodule:&gt;&gt;&gt; utils.leftmost(binop.expr)&lt;Literal 1&gt;&gt;&gt;&gt; utils.rightmost(binop.expr)&lt;Literal 4&gt;```Searching for the d4:```python&gt;&gt;&gt; from d20 import roll, Dice, SimpleStringifier, utils&gt;&gt;&gt; mixed = roll(&quot;-1d8 + 4 - (3, 1d4)kh1&quot;)&gt;&gt;&gt; str(mixed)'-1d8 (**8**) + 4 - (3, ~~1d4 (3)~~)kh1 = `-7`'&gt;&gt;&gt; root = mixed.expr&gt;&gt;&gt; result = utils.dfs(root, lambda node: isinstance(node, Dice) and node.num == 1 and node.size == 4)&gt;&gt;&gt; result&lt;Dice num=1 size=4 values=[&lt;Die size=4 values=[&lt;Literal 3&gt;]&gt;] operations=[]&gt;&gt;&gt;&gt; SimpleStringifier().stringify(result)'1d4 (3)'```As a note, even though a `Dice` object is the parent of `Die` objects, `Dice.children` returns an empty list, since it's more common to look for the dice, and not each individual component of that dice.## PerformanceBy default, the parser caches the 256 most frequently used dice expressions in an LFU cache, allowing for a significant speedup when rolling many of the same kinds of rolls. This caching is disabled when `allow_comments` is True.With caching:```bash$ python3 -m timeit -s &quot;from d20 import roll&quot; &quot;roll('1d20')&quot;10000 loops, best of 5: 21.6 usec per loop$ python3 -m timeit -s &quot;from d20 import roll&quot; &quot;roll('100d20')&quot;500 loops, best of 5: 572 usec per loop$ python3 -m timeit -s &quot;from d20 import roll; expr='1d20+'*50+'1d20'&quot; &quot;roll(expr)&quot;500 loops, best of 5: 732 usec per loop$ python3 -m timeit -s &quot;from d20 import roll&quot; &quot;roll('10d20rr&lt;20')&quot;1000 loops, best of 5: 1.13 msec per loop```Without caching:```bash$ python3 -m timeit -s &quot;from d20 import roll&quot; &quot;roll('1d20')&quot;5000 loops, best of 5: 61.6 usec per loop$ python3 -m timeit -s &quot;from d20 import roll&quot; &quot;roll('100d20')&quot;500 loops, best of 5: 620 usec per loop$ python3 -m timeit -s &quot;from d20 import roll; expr='1d20+'*50+'1d20'&quot; &quot;roll(expr)&quot;500 loops, best of 5: 2.1 msec per loop$ python3 -m timeit -s &quot;from d20 import roll&quot; &quot;roll('10d20rr&lt;20')&quot;1000 loops, best of 5: 1.26 msec per loop```</longdescription>
</pkgmetadata>