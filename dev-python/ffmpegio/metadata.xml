<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>`ffmpegio`: Media I/O with FFmpeg in Python (with NumPy Array Plugin)=====================================================================|pypi| |pypi-status| |pypi-pyvers| |github-license| |github-status|.. |pypi| image:: https://img.shields.io/pypi/v/ffmpegio  :alt: PyPI.. |pypi-status| image:: https://img.shields.io/pypi/status/ffmpegio  :alt: PyPI - Status.. |pypi-pyvers| image:: https://img.shields.io/pypi/pyversions/ffmpegio  :alt: PyPI - Python Version.. |github-license| image:: https://img.shields.io/github/license/python-ffmpegio/python-ffmpegio  :alt: GitHub License.. |github-status| image:: https://img.shields.io/github/workflow/status/python-ffmpegio/python-ffmpegio/Run%20Tests  :alt: GitHub Workflow StatusPython `ffmpegio` package aims to bring the full capability of `FFmpeg &lt;https://ffmpeg.org&gt;`__to read, write, probe, and manipulate multimedia data to Python. FFmpeg is an open-source cross-platform multimedia framework, which can handle most of the multimedia formats available today... note::    Since v0.3.0, `ffmpegio` Python distribution package has been split into `ffmpegio-core` and `ffmpegio` to allow  Numpy-independent installation.Install the full `ffmpegio` package via ``pip``:.. code-block:: bash   pip install ffmpegioIf `numpy.ndarray` data I/O is not needed, instead use .. code-block:: bash   pip install ffmpegio-coreMain Features-------------* Pure-Python light-weight package interacting with FFmpeg executable found in   the system* Transcode a media file to another in Python* Read, write, filter, and create functions for audio, image, and video data* Context-managing `ffmpegio.open` to perform stream read/write operations of video and audio* Automatically detect and convert audio &amp; video formats to and from `numpy.ndarray` properties* Probe media file information* Accepts all FFmpeg options including filter graphs* Supports a user callback whenever FFmpeg updates its progress information file   (see `-progress` FFmpeg option)* `ffconcat` scripter to make the use of `-f concat` demuxer easier* I/O device enumeration to eliminate the need to look up device names. (currently supports only: Windows DirectShow)* More features to followDocumentation-------------Visit our `GitHub page here &lt;https://python-ffmpegio.github.io/python-ffmpegio/&gt;`__Examples--------To import `ffmpegio`.. code-block:: python  &gt;&gt;&gt; import ffmpegio- `Transcoding &lt;ex_trancode&gt;`__- `Read Audio Files &lt;ex_read_audio&gt;`__- `Read Image Files / Capture Video Frames &lt;ex_read_image&gt;`__- `Read Video Files &lt;ex_read_video&gt;`__- `Read Multiple Files or Streams &lt;ex_read_media&gt;`__- `Write Audio, Image, &amp; Video Files &lt;ex_write&gt;`__- `Filter Audio, Image, &amp; Video Data &lt;ex_filter&gt;`__- `Stream I/O &lt;ex_stream&gt;`__- `Device I/O Enumeration &lt;ex_devices&gt;`__- `Progress Callback &lt;ex_progress&gt;`__- `Run FFmpeg and FFprobe Directly &lt;ex_direct&gt;`__.. _ex_trancode:Transcoding^^^^^^^^^^^.. code-block:: python  &gt;&gt;&gt; # transcode, overwrite output file if exists, showing the FFmpeg log  &gt;&gt;&gt; ffmpegio.transcode('input.avi', 'output.mp4', overwrite=True, show_log=True)   &gt;&gt;&gt; # 1-pass H.264 transcoding  &gt;&gt;&gt; ffmpegio.transcode('input.avi', 'output.mkv', vcodec='libx264', show_log=True,  &gt;&gt;&gt;                    preset='slow', crf=22, acodec='copy')   &gt;&gt;&gt; # 2-pass H.264 transcoding  &gt;&gt;&gt; ffmpegio.transcode('input.avi', 'output.mkv', two_pass=True, show_log=True,  &gt;&gt;&gt;                    **{'c:v':'libx264', 'b:v':'2600k', 'c:a':'aac', 'b:a':'128k'})   &gt;&gt;&gt; # concatenate videos using concat demuxer  &gt;&gt;&gt; files = ['/video/video1.mkv','/video/video2.mkv']  &gt;&gt;&gt; ffconcat = ffmpegio.FFConcat()  &gt;&gt;&gt; ffconcat.add_files(files)  &gt;&gt;&gt; with ffconcat: # generates temporary ffconcat file  &gt;&gt;&gt;     ffmpegio.transcode(ffconcat, 'output.mkv', f_in='concat', codec='copy', safe_in=0).. _ex_read_audio:Read Audio Files^^^^^^^^^^^^^^^^.. code-block:: python  &gt;&gt;&gt; # read audio samples in its native sample format and return all channels  &gt;&gt;&gt; fs, x = ffmpegio.audio.read('myaudio.wav')   &gt;&gt;&gt; # fs: sampling rate in samples/second, x: [nsamples x nchannels] numpy array  &gt;&gt;&gt; # read audio samples from 24.15 seconds to 63.2 seconds, pre-convert to mono in float data type   &gt;&gt;&gt; fs, x = ffmpegio.audio.read('myaudio.flac', ss=24.15, to=63.2, sample_fmt='dbl', ac=1)  &gt;&gt;&gt; # read filtered audio samples first 10 seconds  &gt;&gt;&gt; #   filter: equalizer which attenuate 10 dB at 1 kHz with a bandwidth of 200 Hz   &gt;&gt;&gt; fs, x = ffmpegio.audio.read('myaudio.mp3', t=10.0, af='equalizer=f=1000:t=h:width=200:g=-10').. _ex_read_image:Read Image Files / Capture Video Frames^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.. code-block:: python  &gt;&gt;&gt; # list supported image extensions  &gt;&gt;&gt; ffmpegio.caps.muxer_info('image2')['extensions']  ['bmp', 'dpx', 'exr', 'jls', 'jpeg', 'jpg', 'ljpg', 'pam', 'pbm', 'pcx', 'pfm', 'pgm', 'pgmyuv',    'png', 'ppm', 'sgi', 'tga', 'tif', 'tiff', 'jp2', 'j2c', 'j2k', 'xwd', 'sun', 'ras', 'rs', 'im1',    'im8', 'im24', 'sunras', 'xbm', 'xface', 'pix', 'y']  &gt;&gt;&gt; # read BMP image with auto-detected pixel format (rgb24, gray, rgba, or ya8)  &gt;&gt;&gt; I = ffmpegio.image.read('myimage.bmp') # I: [height x width x ncomp] numpy array  &gt;&gt;&gt; # read JPEG image, then convert to grayscale and proportionally scale so the width is 480 pixels  &gt;&gt;&gt; I = ffmpegio.image.read('myimage.jpg', pix_fmt='grayscale', s='480x-1')  &gt;&gt;&gt; # read PNG image with transparency, convert it to plain RGB by filling transparent pixels orange  &gt;&gt;&gt; I = ffmpegio.image.read('myimage.png', pix_fmt='rgb24', fill_color='orange')  &gt;&gt;&gt; # capture video frame at timestamp=4:25.3 and convert non-square pixels to square  &gt;&gt;&gt; I = ffmpegio.image.read('myvideo.mpg', ss='4:25.3', square_pixels='upscale')  &gt;&gt;&gt; # capture 5 video frames and tile them on 3x2 grid with 7px between them, and 2px of initial margin  &gt;&gt;&gt; I = ffmpegio.image.read('myvideo.mp4', vf='tile=3x2:nb_frames=5:padding=7:margin=2')  &gt;&gt;&gt; # create spectrogram of the audio input (must specify pix_fmt if input is audio)  &gt;&gt;&gt; I = ffmpegio.image.read('myaudio.mp3', filter_complex='showspectrumpic=s=960x540', pix_fmt='rgb24').. _ex_read_video:Read Video Files^^^^^^^^^^^^^^^^.. code-block:: python  &gt;&gt;&gt; # read 50 video frames at t=00:32:40 then convert to grayscale  &gt;&gt;&gt; fs, F = ffmpegio.video.read('myvideo.mp4', ss='00:32:40', vframes=50, pix_fmt='gray')  &gt;&gt;&gt; #  fs: frame rate in frames/second, F: [nframes x height x width x ncomp] numpy array  &gt;&gt;&gt; # get running spectrogram of audio input (must specify pix_fmt if input is audio)  &gt;&gt;&gt; fs, F = ffmpegio.video.read('myvideo.mp4', pix_fmt='rgb24', filter_complex='showspectrum=s=1280x480')  .. _ex_read_media:Read Multiple Files or Streams^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.. code-block:: python  &gt;&gt;&gt; # read both video and audio streams (1 ea)  &gt;&gt;&gt; rates, data = ffmpegio.media.read('mymedia.mp4')  &gt;&gt;&gt; #  rates: dict of frame rate and sampling rate: keys=&quot;v:0&quot; and &quot;a:0&quot;  &gt;&gt;&gt; #  data: dict of video frame array and audio sample array: keys=&quot;v:0&quot; and &quot;a:0&quot;  &gt;&gt;&gt; # combine video and audio files  &gt;&gt;&gt; rates, data = ffmpegio.media.read('myvideo.mp4','myaudio.mp3')  &gt;&gt;&gt; # get output of complex filtergraph (can take multiple inputs)  &gt;&gt;&gt; expr = &quot;[v:0]split=2[out0][l1];[l1]edgedetect[out1]&quot;  &gt;&gt;&gt; rates, data = ffmpegio.media.read('myvideo.mp4',filter_complex=expr,map=['[out0]','[out1]'])  &gt;&gt;&gt; #  rates: dict of frame rates: keys=&quot;v:0&quot; and &quot;v:1&quot;  &gt;&gt;&gt; #  data: dict of video frame arrays: keys=&quot;v:0&quot; and &quot;v:1&quot;.. _ex_write:Write Audio, Image, &amp; Video Files^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.. code-block:: python  &gt;&gt;&gt; # create a video file from a numpy array  &gt;&gt;&gt; ffmpegio.video.write('myvideo.mp4', rate, F)  &gt;&gt;&gt; # create an image file from a numpy array  &gt;&gt;&gt; ffmpegio.image.write('myimage.png', F)  &gt;&gt;&gt; # create an audio file from a numpy array  &gt;&gt;&gt; ffmpegio.audio.write('myaudio.mp3', rate, x).. _ex_filter:Filter Audio, Image, &amp; Video Data^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.. code-block:: python  &gt;&gt;&gt; # Add fade-in and fade-out effects to audio data  &gt;&gt;&gt; fs_out, y = ffmpegio.audio.filter('afade=t=in:ss=0:d=15,afade=t=out:st=875:d=25', fs_in, x)  &gt;&gt;&gt; # Apply mirror effect to an image  &gt;&gt;&gt; I_out = ffmpegio.image.filter('crop=iw/2:ih:0:0,split[left][tmp];[tmp]hflip[right];[left][right] hstack', I_in)  &gt;&gt;&gt; # Add text at the center of the video frame  &gt;&gt;&gt; filter = &quot;drawtext=fontsize=30:fontfile=FreeSerif.ttf:text='hello world':x=(w-text_w)/2:y=(h-text_h)/2&quot;  &gt;&gt;&gt; fs_out, F_out = ffmpegio.video.filter(filter, fs_in, F_in).. _ex_stream:Stream I/O^^^^^^^^^^.. code-block:: python  &gt;&gt;&gt; # process video 100 frames at a time and save output as a new video   &gt;&gt;&gt; # with the same frame rate  &gt;&gt;&gt; with ffmpegio.open('myvideo.mp4', 'rv', blocksize=100) as fin,  &gt;&gt;&gt;      ffmpegio.open('myoutput.mp4', 'wv', rate=fin.frame_rate) as fout:  &gt;&gt;&gt;     for frames in fin:  &gt;&gt;&gt;         fout.write(myprocess(frames)).. _ex_devices:Device I/O Enumeration^^^^^^^^^^^^^^^^^^^^^^.. code-block:: python  &gt;&gt;&gt; # record 5 minutes of audio from Windows microphone  &gt;&gt;&gt; fs, x = ffmpegio.audio.read('a:0', f_in='dshow', sample_fmt='dbl', t=300)  &gt;&gt;&gt; # capture Windows' webcam frame  &gt;&gt;&gt; with ffmpegio.open('v:0', 'rv', f_in='dshow') as webcam,  &gt;&gt;&gt;     for frame in webcam:  &gt;&gt;&gt;         process_frame(frame).. _ex_progress:Progress Callback^^^^^^^^^^^^^^^^^.. code-block:: python  &gt;&gt;&gt; import pprint  &gt;&gt;&gt; # progress callback  &gt;&gt;&gt; def progress(info, done):  &gt;&gt;&gt;     pprint(info) # bunch of stats  &gt;&gt;&gt;     if done:  &gt;&gt;&gt;        print('video decoding completed')  &gt;&gt;&gt;     else:  &gt;&gt;&gt;        return check_cancel_command(): # return True to kill immediately    &gt;&gt;&gt; # can be used in any butch processing  &gt;&gt;&gt; rate, F = ffmpegio.video.read('myvideo.mp4', progress=progress)  &gt;&gt;&gt; # as well as for stream processing  &gt;&gt;&gt; with ffmpegio.open('myvideo.mp4', 'rv', blocksize=100, progress=progress) as fin:  &gt;&gt;&gt;     for frames in fin:  &gt;&gt;&gt;         myprocess(frames).. _ex_direct:Run FFmpeg and FFprobe Directly^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.. code-block:: python  &gt;&gt;&gt; from ffmpegio import ffmpeg, FFprobe, ffmpegprocess  &gt;&gt;&gt; from subprocess import PIPE  &gt;&gt;&gt; # call with options as a long string  &gt;&gt;&gt; ffmpeg('-i input.avi -b:v 64k -bufsize 64k output.avi')  &gt;&gt;&gt; # or call with list of options  &gt;&gt;&gt; ffmpeg(['-i', 'input.avi' ,'-r', '24', 'output.avi'])  &gt;&gt;&gt; # the same for ffprobe  &gt;&gt;&gt; ffprobe('ffprobe -show_streams -select_streams a INPUT')  &gt;&gt;&gt; # specify subprocess arguments to capture stdout  &gt;&gt;&gt; out = ffprobe('ffprobe -of json -show_frames INPUT',                     stdout=PIPE, universal_newlines=True).stdout  &gt;&gt;&gt; # use ffmpegprocess to take advantage of ffmpegio's default behaviors  &gt;&gt;&gt; out = ffmpegprocess.run({&quot;inputs&quot;: [(&quot;input.avi&quot;, None)],                               &quot;outputs&quot;: [(&quot;out1.mp4&quot;, None),                                           (&quot;-&quot;, {&quot;f&quot;: &quot;rawvideo&quot;, &quot;vframes&quot;: 1, &quot;pix_fmt&quot;: &quot;gray&quot;, &quot;an&quot;: None})                              }, capture_log=True)  &gt;&gt;&gt; print(out.stderr) # print the captured FFmpeg logs (banner text omitted)   &gt;&gt;&gt; b = out.stdout # width*height bytes of the first frame</longdescription>
</pkgmetadata>