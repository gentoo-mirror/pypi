<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># suprsend-py-sdkThis package can be included in a python3 project to easily integratewith `SuprSend` platform.We're working towards creating SDK in other languages as well.### SuprSend SDKs available in following languages* python3 &gt;= 3.7 (`suprsend-py-sdk`)* node (`suprsend-node-sdk`)* java (`suprsend-java-sdk`)### Installation`suprsend-py-sdk` is available on PyPI. You can install using pip.```bashpip install suprsend-py-sdk```This SDK depends on a system package called `libmagic`. You can install it as follows:```bash# On debian based systemssudo apt install libmagic# If you are using macOSbrew install libmagic```### UsageInitialize the SuprSend SDK```python3from suprsend import Suprsend# Initialize SDKsupr_client = Suprsend(&quot;workspace_key&quot;, &quot;workspace_secret&quot;)```Following example shows a sample request for triggering a workflow.It triggers a notification to a user with id: `distinct_id`,email: `user@example.com` &amp; androidpush(fcm-token): `__android_push_fcm_token__`using template `purchase-made` and notification_category `system````python3from suprsend import Workflow# Prepare Workflow bodyworkflow_body = {    &quot;name&quot;: &quot;Purchase Workflow&quot;,    &quot;template&quot;: &quot;purchase-made&quot;,    &quot;notification_category&quot;: &quot;system&quot;,    # &quot;delay&quot;: &quot;15m&quot;,  # Check duration format below    &quot;users&quot;: [        {          &quot;distinct_id&quot;: &quot;0f988f74-6982-41c5-8752-facb6911fb08&quot;,          # if $channels is present, communication will be tried on mentioned channels only.          # &quot;$channels&quot;: [&quot;email&quot;],          &quot;$email&quot;: [&quot;user@example.com&quot;],          &quot;$androidpush&quot;: [{&quot;token&quot;: &quot;__android_push_token__&quot;, &quot;provider&quot;: &quot;fcm&quot;, &quot;device_id&quot;: &quot;&quot;}],        }    ],    # delivery instruction. how should notifications be sent, and whats the success metric    &quot;delivery&quot;: {        &quot;smart&quot;: False,        &quot;success&quot;: &quot;seen&quot;    },    # data can be any json / serializable python-dictionary    &quot;data&quot;: {        &quot;first_name&quot;: &quot;User&quot;,        &quot;spend_amount&quot;: &quot;$10&quot;,        &quot;nested_key_example&quot;: {            &quot;nested_key1&quot;: &quot;some_value_1&quot;,            &quot;nested_key2&quot;: {              &quot;nested_key3&quot;: &quot;some_value_3&quot;,            },        }    }}wf = Workflow(body=workflow_body)# Trigger workflowresponse = supr_client.trigger_workflow(wf)print(response)```When you call `supr_client.trigger_workflow`, the SDK internally makes an HTTP call to SuprSendPlatform to register this request, and you'll immediately receive a response indicatingthe acceptance status.You can also pass `idempotency-key` while triggering a workflow. Maximum length of idempotency_key can be 64 chars.idempotency_key has multiple uses e.g.1. Avoid duplicate request. If Suprsend receives and processes a request with an idempotency_key,   it will skip processing requests with same idempotency_key for next 24 hours.2. You can use this key to track webhooks related to workflow notifications.```python3from suprsend import Workflowworkflow_body = {...}wf = Workflow(body=workflow_body, idempotency_key=&quot;__uniq_request_id__&quot;)# You can also the brand_id to be used for templates/notificationswf = Workflow(body=workflow_body, idempotency_key=&quot;__uniq_request_id__&quot;, brand_id=&quot;default&quot;)# Trigger workflowresponse = supr_client.trigger_workflow(wf)print(response)```Note: The actual processing/execution of workflow happens asynchronously.```python# If the call succeeds, response will looks like:{    &quot;success&quot;: True,    &quot;status&quot;: &quot;success&quot;,    &quot;status_code&quot;: 202,    &quot;message&quot;: &quot;Message received&quot;,}# In case the call fails. You will receive a response with success=False{    &quot;success&quot;: False,    &quot;status&quot;: &quot;fail&quot;,    &quot;status_code&quot;: 400/500,    &quot;message&quot;: &quot;error message&quot;,}```### Duration Formatformat for specifying duration: `[xx]d[xx]h[xx]m[xx]s`Where* `d` stands for days. value boundary: 0 &lt;= `d`* `h` stands for hours. value boundary: 0 &lt;= `h` &lt;= 23* `m` stands for minutes. value boundary: 0 &lt;= `m` &lt;= 59* `s` stands for seconds. value boundary: 0 &lt;= `s` &lt;= 59Examples:* 2 days, 3 hours, 12 minutes, 23 seconds -&gt; 2d3h12m23s or 02d03h12m23s* 48 hours -&gt; 2d* 30 hours -&gt; 1d6h* 300 seconds -&gt; 5m* 320 seconds -&gt; 5m20s* 60 seconds -&gt; 1m### Delivery instructionAll delivery options:```pythondelivery = {    &quot;smart&quot;: True/False,    &quot;success&quot;: &quot;seen/interaction/&lt;some-user-defined-success-event&gt;&quot;,    &quot;time_to_live&quot;: &quot;&lt;TTL duration&gt;&quot;,    &quot;mandatory_channels&quot;: [] # list of mandatory channels e.g [&quot;email&quot;]}```Where* `smart` (boolean) - whether to optimize for number of notifications sent?  - Possible values: `True` / `False`  - Default value: `False`  - If False, then notifications are sent on all channels at once.  - If True, then notifications are sent one-by-one (on regular interval controlled by `time_to_live`)    on each channel until given `success`-metric is achieved.* `success` - what is your measurement of success for this notification?  - Possible values: `delivered` / `seen` / `interaction` / `&lt;some-user-defined-success-event&gt;`  - Default value: `seen`  - If `delivered`: If notification on any of the channels is successfully delivered, consider it a success.  - If `seen`: If notification on any of the channels is seen by user, consider it a success.  - If `interaction`: If notification on any of the channels is clicked/interacted by the user, consider it a success.  - If `&lt;some-user-defined-success-event&gt;`: If certain event is done by user within the event-window (1 day), consider it a success.    - currently, event-window is not configurable. default set to `1d` (1 day).      success-event must happen within this event-window since notification was sent.* `time_to_live` - What's your buffer-window for sending notification.  - applicable when `smart`=True, otherwise ignored  - Default value: `1h` (1 hour)  - notification on each channel will be sent with time-interval of [`time_to_live / (number_of_valid_channels - 1))`] apart.  - Currently, channels are tried in low-to-high notification-cost order based on `Notification Cost` mentioned in Vendor Config.    If cost is not mentioned, it is considered `0` for order-calculation purpose.  - Process will continue until all channels are exhausted or `success` metric is achieved, whichever occurs first.* `mandatory_channels` - Channels on which notification has to be sent immediately (irrespective of notification-cost).  - applicable when `smart`=True, otherwise ignored  - Default value: [] (empty list)  - possible channels: `email, sms, whatsapp, androidpush, iospush` etc.If delivery instruction is not provided, then default value is```python3{    &quot;smart&quot;: False,    &quot;success&quot;: &quot;seen&quot;}```### Add attachmentsTo add one or more Attachments to a Workflow/Notification (viz. Email),call `Workflow.add_attachment(file_path)` for each file with local-path.Ensure that file_path is proper, otherwise it will raise FileNotFoundError.```pythonfrom suprsend import Workflowworkflow_body = {...}wf_instance = Workflow(body=workflow_body)# this snippet can be used to add attachment to workflow.file_path = &quot;/home/user/billing.pdf&quot;wf_instance.add_attachment(file_path)```#### Attachment structureThe `add_attachment(...)` call appends below structure to `workflow_body-&gt;data-&gt;'$attachments'````json{    &quot;filename&quot;: &quot;billing.pdf&quot;,    &quot;contentType&quot;: &quot;application/pdf&quot;,    &quot;data&quot;: &quot;Q29uZ3JhdHVsYXRpb25zLCB5b3UgY2FuIGJhc2U2NCBkZWNvZGUh&quot;,}```Where* `filename` - name of file.* `contentType` - MIME-type of file content.* `data` - base64-encoded content of file.### Limitation* a single workflow body size must not exceed 800KB (800 * 1024 bytes).* if size exceeds above mentioned limit, SDK raises python's builtin ValueError.### Bulk API for Workflow RequestsYou can send bulk request for workflows in one call. Use `.append()` on bulk_workflows instanceto add however-many-records to call in bulk.```python3from suprsend import Workflowbulk_ins = supr_client.bulk_workflows.new_instance()# one or more workflow instancesworkflow1 = Workflow(body={...}) # body must be a proper workflow request json/dictworkflow2 = Workflow(body={...}) # body must be a proper workflow request json/dict# --- use .append on bulk instance to add one or more recordsbulk_ins.append(workflow1)bulk_ins.append(workflow2)# ORbulk_ins.append(workflow1, workflow2)# -------response = bulk_ins.trigger()print(response)```* There isn't any limit on number-of-records that can be added to bulk_workflows instance.* On calling `bulk_ins.trigger()` the SDK internally makes one-or-more Callable-chunks.* each callable-chunk contains a subset of records, the subset calculation is based on each record's bytes-size  and max allowed chunk-size and chunk-length etc.* for each callable-chunk SDK makes an HTTP call to SuprSend To register the request.### Set channels in User ProfileIf you regularly trigger a workflow for users on some pre-decided channels,then instead of adding user-channel-details in each workflow request, you can set those channel-details in userprofile once, and after that, in workflow trigger request you only need to pass the distinct_id of the user.All associated channels in User profile will be automatically picked when executing the workflow.- First Instantiate a user object```pythondistinct_id = &quot;__uniq_user_id__&quot;  # Unique id of user in your application# Instantiate User profileuser = supr_client.user.get_instance(distinct_id=distinct_id)```- To add channel details to this user (viz. email, sms, whatsapp, androidpush, iospush etc)  use `user.add_*` method(s) as shown in the example below.```python# Add channel details to user-instance. Call relevant add_* methodsuser.add_email(&quot;user@example.com&quot;) # - To add Emailuser.add_sms(&quot;+919999999999&quot;) # - To add SMSuser.add_whatsapp(&quot;+919999999999&quot;) # - To add Whatsappuser.add_androidpush(&quot;__android_push_fcm_token__&quot;) # - by default, token is assumed to be fcm-token# You can set the optional provider value [fcm/xiaomi/oppo] if its not a fcm-tokenuser.add_androidpush(&quot;__android_push_xiaomi_token__&quot;, provider=&quot;xiaomi&quot;)user.add_iospush(&quot;__iospush_token__&quot;)user.add_slack({&quot;email&quot;: &quot;user@example.com&quot;, &quot;access_token&quot;: &quot;xoxb-XXXXXXXXXXXX&quot;})  # - DM user using emailuser.add_slack({&quot;user_id&quot;: &quot;U03XXXXXXXX&quot;, &quot;access_token&quot;: &quot;xoxb-XXXXXXXXXXXX&quot;})  # - DM user using slack member_id if knownuser.add_slack({&quot;channel_id&quot;: &quot;C03XXXXXXXX&quot;, &quot;access_token&quot;: &quot;xoxb-XXXXXXXXXXXX&quot;})  # - Use channel iduser.add_slack({&quot;incoming_webhook&quot;: {&quot;url&quot;: &quot;https://hooks.slack.com/services/TXXXXXXXXX/BXXXXXX/XXXXXXX&quot;}})  # - Use incoming webhook# After setting the channel details on user-instance, call save()response = user.save()print(response)``````python# Response structure{    &quot;success&quot;: True, # if true, request was accepted.    &quot;status&quot;: &quot;success&quot;,    &quot;status_code&quot;: 202, # http status code    &quot;message&quot;: &quot;OK&quot;,}{    &quot;success&quot;: False, # error will be present in message    &quot;status&quot;: &quot;fail&quot;,    &quot;status_code&quot;: 500, # http status code    &quot;message&quot;: &quot;error message&quot;,}```- Similarly, If you want to remove certain channel details from user,you can call `user.remove_*` method as shown in the example below.```python# Remove channel helper methodsuser.remove_email(&quot;user@example.com&quot;)user.remove_sms(&quot;+919999999999&quot;)user.remove_whatsapp(&quot;+919999999999&quot;)user.remove_androidpush(&quot;__android_push_fcm_token__&quot;)user.remove_androidpush(&quot;__android_push_xiaomi_token__&quot;, provider=&quot;xiaomi&quot;)user.remove_iospush(&quot;__iospush_token__&quot;)user.remove_slack({&quot;email&quot;: &quot;user@example.com&quot;, &quot;access_token&quot;: &quot;xoxb-XXXXXXXXXXXX&quot;})  # - DM user using emailuser.remove_slack({&quot;user_id&quot;: &quot;U03XXXXXXXX&quot;, &quot;access_token&quot;: &quot;xoxb-XXXXXXXXXXXX&quot;})  # - DM user using slack member_id if knownuser.remove_slack({&quot;channel_id&quot;: &quot;C03XXXXXXXX&quot;, &quot;access_token&quot;: &quot;xoxb-XXXXXXXXXXXX&quot;})  # - Use channel iduser.remove_slack({&quot;incoming_webhook&quot;: {&quot;url&quot;: &quot;https://hooks.slack.com/services/TXXXXXXXXX/BXXXXXX/XXXXXXX&quot;}})  # - Use incoming webhook# saveresponse = user.save()print(response)```- If you need to delete/unset all emails (or any other channel) of a user,  you can call `unset` method on the user instance.  The method accepts the channel key/s (a single key or list of keys)```python# --- To delete all emails associated with useruser.unset(&quot;$email&quot;)response = user.save()print(response)# what value to pass to unset channels# for email:                $email# for whatsapp:             $whatsapp# for SMS:                  $sms# for androidpush tokens:   $androidpush# for iospush tokens:       $iospush# for webpush tokens:       $webpush# for slack:                $slack# --- multiple channels can also be deleted in one call by passing argument as a listuser.unset([&quot;$email&quot;, &quot;$sms&quot;, &quot;$whatsapp&quot;])user.save()```- You can also set preferred language of user using `set_preferred_language(lang_code)`. Value for lang_code  must be 2-letter code in the `ISO 639-1 Alpha-2 code` format.  e.g. en (for English), es (for Spanish), fr (for French) etc.```python# --- Set 2-letter language code in &quot;ISO 639-1 Alpha-2&quot; formatuser.set_preferred_language(&quot;en&quot;)response = user.save()print(response)```- Note: After calling `add_*`/`remove_*`/`unset`/`set_*` methods, don't forget to call `user.save()`. On call of save(),SDK sends the request to SuprSend platform to update the User-Profile.Once channels details are set at User profile, you only have to mention the user's distinct_idwhile triggering workflow. Associated channels will automatically be picked up from user-profilewhile processing the workflow. In the example below, we are passing only distinct_id of the user:```python3from suprsend import Workflow# Prepare Workflow bodyworkflow_body = {    &quot;name&quot;: &quot;Purchase Workflow&quot;,    &quot;template&quot;: &quot;purchase-made&quot;,    &quot;notification_category&quot;: &quot;system&quot;,    # &quot;delay&quot;: &quot;15m&quot;,    &quot;users&quot;: [        {            &quot;distinct_id&quot;: &quot;0f988f74-6982-41c5-8752-facb6911fb08&quot;,        }    ],    # data can be any json / serializable python-dictionary    &quot;data&quot;: {        &quot;first_name&quot;: &quot;User&quot;,        &quot;spend_amount&quot;: &quot;$10&quot;,        &quot;nested_key_example&quot;: {            &quot;nested_key1&quot;: &quot;some_value_1&quot;,            &quot;nested_key2&quot;: {              &quot;nested_key3&quot;: &quot;some_value_3&quot;,            },        }    }}wf = Workflow(body=workflow_body)# Trigger workflowresponse = supr_client.trigger_workflow(wf)print(response)```#### Bulk API for UsersYou can send multiple subscriber requests in one call. Use `.append()` on bulk_users instanceto add however-many-records to call in bulk.```python3bulk_ins = supr_client.bulk_users.new_instance()# Prepare multiple usersu1 = supr_client.user.get_instance(&quot;distinct_id_1&quot;) # User 1u1.set_email(&quot;u1@example.com&quot;)u2 = supr_client.user.get_instance(&quot;distinct_id_2&quot;) # User 2u2.set_email(&quot;u2@example.com&quot;)# --- use .append on bulk instance to add one or more recordsbulk_ins.append(u1)bulk_ins.append(u2)# ORbulk_ins.append(u1, u2)# -------response = bulk_ins.save()print(response)```### Track and Send EventYou can track and send events to SuprSend platform by using `supr_client.track_event` method.An event is composed of an `event_name`, tracked wrt a user: `distinct_id`, with event-attributes: `properties````python3from suprsend import Event# Exampledistinct_id = &quot;__uniq_user_id__&quot; # Mandatory, Unique id of user in your applicationevent_name = &quot;__event_name__&quot;   # Mandatory, name of the event you're trackingproperties = {} # Optional, default=None, a dict representing event-attributesevent = Event(distinct_id=distinct_id, event_name=event_name, properties=properties)# You can also add Idempotency-keyevent = Event(distinct_id=distinct_id, event_name=event_name, properties=properties,              idempotency_key=&quot;__uniq_request_id__&quot;)# You can also the brand_id to be used for templates/notificationsevent = Event(distinct_id=distinct_id, event_name=event_name, properties=properties,              idempotency_key=&quot;__uniq_request_id__&quot;, brand_id=&quot;default&quot;)# Send eventresponse = supr_client.track_event(event)print(response)``````python# Response structure{    &quot;success&quot;: True, # if true, request was accepted.    &quot;status&quot;: &quot;success&quot;,    &quot;status_code&quot;: 202, # http status code    &quot;message&quot;: &quot;OK&quot;,}{    &quot;success&quot;: False, # error will be present in message    &quot;status&quot;: &quot;fail&quot;,    &quot;status_code&quot;: 500, # http status code    &quot;message&quot;: &quot;error message&quot;,}```#### Bulk API for eventsYou can send multiple events in one call. Use `.append()` on bulk_events instanceto add however-many-records to call in bulk.```python3from suprsend import Eventbulk_ins = supr_client.bulk_events.new_instance()# Examplee1 = Event(&quot;distinct_id1&quot;, &quot;event_name1&quot;, {&quot;k1&quot;: &quot;v1&quot;}) # Event 1e2 = Event(&quot;distinct_id2&quot;, &quot;event_name2&quot;, {&quot;k2&quot;: &quot;v2&quot;}) # Event 2# --- use .append on bulk instance to add one or more recordsbulk_ins.append(e1)bulk_ins.append(e2)# ORbulk_ins.append(e1, e2)# -------response = bulk_ins.trigger()print(response)```</longdescription>
</pkgmetadata>