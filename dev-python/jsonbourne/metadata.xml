<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;a href=&quot;https://github.com/dynamic-graphics-inc/dgpy-libs&quot;&gt;&lt;img align=&quot;right&quot; src=&quot;https://github.com/dynamic-graphics-inc/dgpy-libs/blob/main/docs/images/dgpy_banner.svg?raw=true&quot; alt=&quot;drawing&quot; height=&quot;120&quot; width=&quot;300&quot;/&gt;&lt;/a&gt;# jsonbourne[![Wheel](https://img.shields.io/pypi/wheel/jsonbourne.svg)](https://img.shields.io/pypi/wheel/jsonbourne.svg)[![Version](https://img.shields.io/pypi/v/jsonbourne.svg)](https://img.shields.io/pypi/v/jsonbourne.svg)[![py_versions](https://img.shields.io/pypi/pyversions/jsonbourne.svg)](https://img.shields.io/pypi/pyversions/jsonbourne.svg)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)**Install:** `pip install jsonbourne`- Python json lib/pkg that makes json feel like the JSON module in javascript/typescript:  - `from jsonbourne import JSON; JSON.parse(JSON.stringify({&quot;key&quot;: &quot;value&quot;}))`  - Automatically uses best json-lib-backend avalible (`orjson`/`python-rapidjson`) ~ can be configured- Hybrid dict/class object (`jsonbourne.JsonObj`):  - Dot-notation getting/setting (featuring protected attributes!)  - All your favorite python dictionary methods (`items`, `keys`, `update`, `values`) and more!  - Works with `pydantic` and `attrs`- FastAPI:  - JSONBOURNEResponse ~ auto use the best- No hard dependencies ~ works with python-stdlib-json as well as `orjson` and `python-rapidjson`- `jsonbourne.JsonObj` uses list/dict comprehensions (some are recursive) everywhere because 'why not?' and it is a bit faster## Usage:### JSON ~ `from jsonbourne import JSON`**Importing:**```python# Importing JSON:from jsonbourne import JSON# orimport JSON# Importing jsonbourne:import jsonbourneimport david_webb  # jsonbourne's `True` identity```**JSON basics:**```pythonimport JSON  # Module included with jsonbournestring_stringify = JSON.stringify(    {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3})  # '{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}'string_dumps = JSON.dumps({&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3})  # '{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}'string_dumps```    '{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3}'#### JSON option kwargs ~ `pretty` &amp; `sort_keys`**pretty:**```pythonstring_dumps = JSON.stringify(    {&quot;b&quot;: 2, &quot;a&quot;: 1, &quot;c&quot;: 3}, pretty=True)  # '{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}'print(string_dumps)```    {      &quot;b&quot;: 2,      &quot;a&quot;: 1,      &quot;c&quot;: 3    }**sort_keys:**```pythonstring_dumps = JSON.stringify(    {&quot;b&quot;: 2, &quot;a&quot;: 1, &quot;c&quot;: 3}, pretty=True, sort_keys=True)  # '{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}'print(string_dumps)```    {      &quot;a&quot;: 1,      &quot;b&quot;: 2,      &quot;c&quot;: 3    }### JsonObj &amp; JSON- Python dictionary/object with dot access- Protections against setting class/obj attributes- Is as javascript-y as possible (keys have to be strings -- ints/floats will be converted to strings)- Create a `jsonbourne.JsonObj` with `jsonbourne.JSON`- Recursive jsonification- Allows for kwarging (`**json_obj`)- Works with `pydantic` and `attrs`#### Make an empty JsonObjThe following 3 examples all produce the same thing```pythonfrom jsonbourne import JSONj = JSON()  # j =&gt; JsonObj(**{})# ORimport JSONj = JSON()  # j =&gt; JsonObj(**{})# ORfrom jsonbourne import JsonObjj = JsonObj()  # j =&gt; JsonObj(**{})```#### From a dictionary o data```pythonimport datetimedata = {    &quot;key&quot;: &quot;value&quot;,    &quot;list&quot;: [1, 2, 3, 4, 5],    &quot;dt&quot;: datetime.datetime(1970, 1, 1, 0, 0, 0, 1),    &quot;sub&quot;: {        &quot;b&quot;: 3,        &quot;key&quot;: &quot;val&quot;,        &quot;a&quot;: 1,    },    &quot;timedelta&quot;: datetime.timedelta(days=2),}JSON(data)```&lt;pre&gt;JsonObj(**{    'dt': datetime.datetime(1970, 1, 1, 0, 0, 0, 1),    'key': 'value',    'list': [1, 2, 3, 4, 5],    'sub': {'a': 1, 'b': 3, 'key': 'val'},    'timedelta': datetime.timedelta(days=2)})&lt;/pre&gt;### Dot access```pythonJSON(data).sub.b```    3```pythonstringified_data = JSON(data).stringify(pretty=True)print(stringified_data)```    {      &quot;key&quot;: &quot;value&quot;,      &quot;list&quot;: [        1,        2,        3,        4,        5      ],      &quot;dt&quot;: &quot;1970-01-01T00:00:00.000001&quot;,      &quot;sub&quot;: {        &quot;b&quot;: 3,        &quot;key&quot;: &quot;val&quot;,        &quot;a&quot;: 1      },      &quot;timedelta&quot;: 172800.0    }```pythonparsed_data = JSON(stringified_data)parsed_data```&lt;pre&gt;JsonObj(**{    'dt': '1970-01-01T00:00:00.000001',    'key': 'value',    'list': [1, 2, 3, 4, 5],    'sub': {'a': 1, 'b': 3, 'key': 'val'},    'timedelta': 172800.0})&lt;/pre&gt;```pythonlist(parsed_data.keys())```    ['key', 'list', 'dt', 'sub', 'timedelta']```pythonlist(parsed_data.items())```    [('key', 'value'),     ('list', [1, 2, 3, 4, 5]),     ('dt', '1970-01-01T00:00:00.000001'),     ('sub', JsonObj(**{'b': 3, 'key': 'val', 'a': 1})),     ('timedelta', 172800.0)]```pythonlist(parsed_data.dot_keys())```    [('key',),     ('list',),     ('dt',),     ('sub', 'b'),     ('sub', 'key'),     ('sub', 'a'),     ('timedelta',)]```pythonlist(parsed_data.dot_items())```    [(('key',), 'value'),     (('list',), [1, 2, 3, 4, 5]),     (('dt',), '1970-01-01T00:00:00.000001'),     (('sub', 'b'), 3),     (('sub', 'key'), 'val'),     (('sub', 'a'), 1),     (('timedelta',), 172800.0)]```pythonparsed_data[(&quot;sub&quot;, &quot;key&quot;)]```    'val'```pythonparsed_data.dot_lookup(&quot;sub.key&quot;)```    'val'```python{**parsed_data}```    {'key': 'value',     'list': [1, 2, 3, 4, 5],     'dt': '1970-01-01T00:00:00.000001',     'sub': JsonObj(**{'b': 3, 'key': 'val', 'a': 1}),     'timedelta': 172800.0}```python# fully ejectparsed_data.eject()```    {'key': 'value',     'list': [1, 2, 3, 4, 5],     'dt': '1970-01-01T00:00:00.000001',     'sub': {'b': 3, 'key': 'val', 'a': 1},     'timedelta': 172800.0}#### Protected keys`jsonbourne.JsonObj` protects against setting attributes like `'items'` through dot-notation.```pythonfrom jsonbourne import JSONj = JSON()j.key = &quot;value&quot;try:  # CANNOT set 'items' using dot-access    j.items = [1, 2, 3, 4]except ValueError:    pass# CAN set 'items' through key/item accessj[&quot;items&quot;] = [1, 2, 3, 4]print(j.__dict__)print(j)j_items = j.itemsprint(&quot;items&quot;, j_items)# Getting 'items' through dot-access returns the `items()` methodassert j.items != [1, 2, 3, 4]# Getting 'items' with key-access returns the stored valueassert j[&quot;items&quot;] == [1, 2, 3, 4]```    {'_data': {'key': 'value', 'items': [1, 2, 3, 4]}}    JsonObj(**{        'items': [1, 2, 3, 4], 'key': 'value'    })    items &lt;bound method JsonObj.items of JsonObj(**{'key': 'value', 'items': [1, 2, 3, 4]})&gt;### pydantic &amp; jsonbourne- `from jsonbourne.pydantic import JsonBaseModel`- Allows for aliases when getting/setting attribute(s)- Supports `__post_init__` (like dataclasses)#### Basic usage:```pythonfrom jsonbourne import JsonObjfrom jsonbourne.pydantic import JsonBaseModelclass JsonSubObj(JsonBaseModel):    herm: int    def to_dict(self):        return self.dict()    def to_json(self, *args, **kwargs):        return self.json()    @classmethod    def from_json(cls, json_string: str):        return JsonSubObj(json.loads(json_string))class JsonObjModel(JsonBaseModel):    a: int    b: int    c: str    d: JsonObj    e: JsonSubObj    #    @property    def a_property(self) -&gt; str:        return &quot;prop_value&quot;    def to_json(self, *args, **kwargs):        return self.json()    @classmethod    def from_json(cls, json_string: str):        return cls(**json.loads(json_string))obj = JsonObjModel(    **{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &quot;herm&quot;, &quot;d&quot;: {&quot;nested&quot;: &quot;nestedval&quot;}, &quot;e&quot;: {&quot;herm&quot;: 2}})obj```&lt;pre&gt;JsonObjModel(**{     'a': 1,     'b': 2,     'c': 'herm',     'd': JsonObj(**{'nested': 'nestedval'}),     'e': {'herm': 2}})&lt;/pre&gt;```python# respects properties (which I don't think pydantic does(currently))obj.a_property```    'prop_value'---## JSON backend/lib**`jsonbourne` finds the best json-lib (python-rapidjson/orjson) it can!** On import `jsonbourne` gets towork spying on your python env. `jsonbourne`, the most highly qualified json-CIA-agent, will import the bestpython-json library it can find; if `jsonbourne`'s cover is blown (meaning: theonly json library found is the python stdlib json), `jsonbourne` will fallbacktothe python stdlib json.`jsonbourne` will look for the following json-packages in the following order:1. `rapidjson`2. `orjson`### Custom lib preferences```pythonfrom jsonbourne import import_jsonjson = import_json((&quot;rapidjson&quot;, &quot;orjson&quot;))  # prefer rapidjson over orjsonstring = json.dumps({&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3})print(json)print(string)```    &lt;class 'jsonbourne.jsonlib.RAPIDJSON'&gt;    {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3}### Installing better JSON lib:#### `orjson`- `pip install orjson` [pip]#### `rapidjson`/`python-rapidjson`- `pip install python-rapidjson` [pip]- `conda install -c anaconda python-rapidjson` [conda anaconda/defaults]- `conda install -c conda-forge python-rapidjson` [conda-forge]</longdescription>
</pkgmetadata>