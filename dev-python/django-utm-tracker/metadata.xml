<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Django UTM TrackerDjango app for extracting and storing UTM tracking values.## Django supportThis package support Django 3.2+, and Python 3.7+## BackgroundThis app has been designed to integrate the standard `utm_*` querystringparameters that are used by online advertisers with your Django project.It does _not_ replace analytics (e.g. Google Analytics) and Adwords tracking,but does have one crucial difference - it allows you to assign a specific userto a campaign advert.This may be useful if you are trying to assess the value of multiple channels /campaigns.### Supported querystring parametersParameter | Definition:-- | :--utm_medium | Identifies what type of link was used.utm_source | Identifies which site sent the traffic, and is a required parameter.utm_campaign | Identifies a specific product promotion or strategic campaign.utm_term | Identifies search terms.gclid | Identifies a google click, is used for ad tracking in Google Analytics via Google Ads.aclk | Identifies a Microsoft Ad click (bing), is used for ad tracking.msclkid | Identifies a Microsoft Ad click (MS ad network), is used for ad tracking.twclid | Identifies a Twitter Ad click, is used for ad tracking.fbclid | Identifies a Facebook Ad click, is used for ad tracking.In addition to the fixed list above, you can also specify custom tagsusing the `UTM_TRACKER_CUSTOM_TAGS` setting. Any querystring params thatmatch these tags are stashed in a JSONField called `custom_tags`.## How it worksThe app works as a pair of middleware classes, that extract `utm_`values from any incoming request querystring, and then store thoseparameters against the request.user (if authenticated), or in therequest.session (if not).The following shows this workflow (pseudocode - see`test_utm_and_lead_source` for a real example):```pythonclient = Client()# first request stashes values, but does not create a LeadSource as user is anonymousclient.get(&quot;/?utm_medium=medium&amp;utm_source=source...&quot;)assert utm_values_in_sessionassert LeadSource.objects.count() == 0# subsequent request, with authenticated user, extracts values and stores LeadSourceuser = User.objects.create(username=&quot;fred&quot;)client.force_login(user, backend=settings.FORCED_AUTH_BACKEND)client.get(&quot;/&quot;)assert not utm_values_in_sessionassert LeadSource.objects.count() == 1```### Why split the middleware in two?By splitting the middleware into two classes, we enable the use case where wecan track leads without `utm_` querystring parameters. For instance, if you havean internal referral program, using a simple token, you can capture this as a`LeadSource` by adding sentinel values to the `request.session`:```pythondef referral(request, token):    # do token handling    ...    # medium and source are mandatory for lead source capture    request.session[&quot;utm_medium&quot;] = &quot;referral&quot;    request.session[&quot;utm_source&quot;] = &quot;internal&quot;    # campaign, term and content are optional fields    request.session[&quot;utm_campaign&quot;] = &quot;july&quot;    request.session[&quot;utm_term&quot;] = token    request.session[&quot;utm_content&quot;] = &quot;buy-me&quot;    return render(request, &quot;landing_page.html&quot;)```## ConfigurationAdd the app to `INSTALLED_APPS`:```python# settings.pyINSTALLED_APPS = [    ...    &quot;utm_tracker&quot;]UTM_TRACKER_CUSTOM_TAGS = [&quot;tag1&quot;, &quot;tag2&quot;]```and add both middleware classes to `MIDDLEWARE`:```python# settings.pyMIDDLEWARE = [    ...    &quot;utm_tracker.middleware.UtmSessionMiddleware&quot;,    &quot;utm_tracker.middleware.LeadSourceMiddleware&quot;,]```The `UtmSession` middleware must come before `LeadSource` middleware.</longdescription>
</pkgmetadata>