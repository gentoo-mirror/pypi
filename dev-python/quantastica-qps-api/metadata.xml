<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Quantum Programming Studio APIPython wrapper for [Quantum Programming Studio](https://quantum-circuit.com/) HTTP API.## Quick start**1. Install QPS API package:**```bashpip install quantastica-qps-api```**2. Find your QPS API token:**[Login](https://quantum-circuit.com/login) to Quantum Programming Studio, go to [Profile -&gt; API Access](https://quantum-circuit.com/user_settings/api) and copy your API token.**3. Configure QPS API package with your API token:**```pythonfrom quantastica.qps_api import QPSQPS.save_account(&quot;YOUR_API_TOKEN&quot;)```That will create a local configuration file where your API token will be stored for future use.**Now you are ready to use QPS API.****Quick start example:** find circuit from initial/final vector pairs using Quantum Algorithm Generator```pythonfrom quantastica.qps_api import QPSvector_pairs = [[ [1, 0, 0, 0], [ 0.5+0j,  0.5+0j,  0.5+0j,  0.5+0j ] ],[ [0, 1, 0, 0], [ 0.5+0j,  0+0.5j, -0.5+0j,  0-0.5j ] ],[ [0, 0, 1, 0], [ 0.5+0j, -0.5+0j,  0.5+0j, -0.5+0j ] ],[ [0, 0, 0, 1], [ 0.5+0j,  0-0.5j, -0.5+0j,  0+0.5j ] ]]job_id = QPS.generator.circuit_from_vectors(vector_pairs, settings = { &quot;instruction_set&quot;: [&quot;h&quot;, &quot;cu1&quot;, &quot;swap&quot;] })job = QPS.generator.get_job(job_id, wait=True)job_status = job[&quot;status&quot;]job_output = job[&quot;output&quot;]if(job_status == &quot;error&quot;):print(job_output[&quot;message&quot;])else:for circuit in job_output[&quot;circuits&quot;]:print(circuit[&quot;qasm&quot;])```## Account management**QPS.save_account(api_token, api_url=None)****Run this once** to setup your QPS REST API account. Method will create configuration file and your api token will be stored there for future use.If needed, you can clear your token by running `QPS.save_account(&quot;&quot;)` (or by deleting a configuration file).If `api_url` is not provided then `https://quantum-circuit.com/api/` will be set as default.**QPS.config_path()**You can get config file path by running `QPS.config_path()`.Default configuration file path:- On Unix, directory is obtained from environment variable HOME if it is set; otherwise the current userâ€™s home directory is looked up in the password directory through the built-in module pwd.- On Windows, USERPROFILE will be used if set, otherwise a combination of HOMEPATH and HOMEDRIVE will be used.## Quantum Algorithm Generator API[Quantum Algorithm Generator](https://quantastica.com/#generator) is a tool based on machine learning which reverse engineers quantum circuits from state vectors (wave functions). Additionally, it can be used to find quantum algorithm for boolean function from truth table, to transpile circuits and to decompose unitary matrices.### Generator job managementProblem sent to generator is called a &quot;job&quot;. Each job has unique ID. As generator is resource intensive tool, it is configured to execute only one job at a time. While generator is solving a job, other jobs are queued. When generator finishes executing a job, it takes the next one from the queue.API provides functions for job manipulation: you can list all jobs (filtered by status), stop running job, cancel queued jobs, stop/cancel all jobs, start previously canceled (draft) job, etc.**QPS.generator.list_jobs(status_filter=None)**List all jobs, optionally filtered by status.- `status_filter` String, optional. Can be: `draft`, `queued`, `running`, `error`, `done`.**Example 1** - list all (unfiltered) generator jobs:```pythonfrom quantastica.qps_api import QPSjobs = QPS.generator.list_jobs()print(jobs)```Example output:```{&quot;list&quot;: [{ &quot;_id&quot;: &quot;r9LskFoLPQW5w7HTp&quot;, &quot;name&quot;: &quot;Bell state&quot;, &quot;type&quot;: &quot;vectors&quot;, &quot;status&quot;: &quot;done&quot; },{ &quot;_id&quot;: &quot;R8tJH7XoZ233oTREy&quot;, &quot;name&quot;: &quot;4Q Gauss&quot;, &quot;type&quot;: &quot;vectors&quot;, &quot;status&quot;: &quot;queued&quot; },{ &quot;_id&quot;: &quot;h7fzYbFz8MJvkNhiX&quot;, &quot;name&quot;: &quot;Challenge&quot;, &quot;type&quot;: &quot;unitary&quot;, &quot;status&quot;: &quot;draft&quot; },{ &quot;_id&quot;: &quot;PC5PNXiGqhh2HmkX8&quot;, &quot;name&quot;: &quot;Experiment&quot;, &quot;type&quot;: &quot;vectors&quot;, &quot;status&quot;: &quot;error&quot;},{ &quot;_id&quot;: &quot;SNhiCqSCT2WwRWKCd&quot;, &quot;name&quot;: &quot;Decompose&quot;, &quot;type&quot;: &quot;unitary&quot;, &quot;status&quot;: &quot;running&quot; }]}```**Example 2** - list `running` jobs:```pythonfrom quantastica.qps_api import QPSjobs = QPS.generator.list_jobs(status_filter=&quot;running&quot;)print(jobs)```Example output:```{&quot;list&quot;: [{ &quot;_id&quot;: &quot;SNhiCqSCT2WwRWKCd&quot;, &quot;name&quot;: &quot;Decompose&quot;, &quot;type&quot;: &quot;unitary&quot;, &quot;status&quot;: &quot;running&quot; }]}```**QPS.generator.job_status(job_id)**Get job status.**Example:**```pythonfrom quantastica.qps_api import QPSstatus = QPS.generator.job_status(&quot;PC5PNXiGqhh2HmkX8&quot;)print(status)```Example output:```{ &quot;_id&quot;: &quot;PC5PNXiGqhh2HmkX8&quot;, &quot;name&quot;: &quot;Experiment&quot;, &quot;type&quot;: &quot;vectors&quot;, &quot;status&quot;: &quot;error&quot;, &quot;message&quot;: &quot;connect ECONNREFUSED&quot; }```**QPS.generator.get_job(job_id, wait=True)**Get generator job referenced by ID. If `wait` argument is `True` (default), then function will wait for a job to finish (or fail) before returning. If `wait` is `False`, then job will be immediatelly returned even if it is still running (in which case it will not contain a solution).**Example:**```pythonfrom quantastica.qps_api import QPSjob = QPS.generator.get_job(&quot;r9LskFoLPQW5w7HTp&quot;)print(job)```Example output:```{&quot;_id&quot;: &quot;r9LskFoLPQW5w7HTp&quot;,&quot;name&quot;: &quot;Bell&quot;,&quot;type&quot;: &quot;vectors&quot;,&quot;source&quot;: {&quot;vectors&quot;: {&quot;text1&quot;: &quot;[ 1, 0, 0, 0 ]&quot;,&quot;text2&quot;: &quot;[ 1/sqrt(2), 0, 0, 1/sqrt(2) ]&quot;,&quot;endianness1&quot;: &quot;little&quot;,&quot;endianness2&quot;: &quot;little&quot;}},&quot;problem&quot;: [{&quot;input&quot;: [ 1, 0, 0, 0 ],&quot;output&quot;: [ 0.7071067811865475, 0, 0, 0.7071067811865475 ]}],&quot;settings&quot;: {&quot;max_diff&quot;: 0.001,&quot;diff_method&quot;: &quot;distance&quot;,&quot;single_solution&quot;: False,&quot;pre_processing&quot;: &quot;&quot;,&quot;allowed_gates&quot;: &quot;u3,cx&quot;,&quot;coupling_map&quot;: [],&quot;min_gates&quot;: 0,&quot;max_gates&quot;: 0},&quot;status&quot;: &quot;done&quot;,&quot;output&quot;: {&quot;circuits&quot;: [{&quot;qubits&quot;: 2,&quot;cregs&quot;: [],&quot;diff&quot;: 0,&quot;program&quot;: [{&quot;name&quot;: &quot;u3&quot;,&quot;wires&quot;: [ 0 ],&quot;options&quot;: {&quot;params&quot;: {&quot;theta&quot;: -1.570796370506287,&quot;phi&quot;: -3.141592741012573,&quot;lambda&quot;: -5.327113628387451}}},{&quot;name&quot;: &quot;cx&quot;,&quot;wires&quot;: [ 0, 1 ],&quot;options&quot;: {}}],&quot;index&quot;: 0,&quot;qasm&quot;: &quot;OPENQASM 2.0;\ninclude \&quot;qelib1.inc\&quot;;\nqreg q[2];\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[0];\ncx q[0], q[1];\n&quot;,&quot;qasmExt&quot;: &quot;OPENQASM 2.0;\ninclude \&quot;qelib1.inc\&quot;;\nqreg q[2];\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[0];\ncx q[0], q[1];\n&quot;},{&quot;qubits&quot;: 2,&quot;cregs&quot;: [],&quot;diff&quot;: 0,&quot;program&quot;: [{&quot;name&quot;: &quot;u3&quot;,&quot;wires&quot;: [ 1 ],&quot;options&quot;: {&quot;params&quot;: {&quot;theta&quot;: -1.570796370506287,&quot;phi&quot;: -3.141592741012573,&quot;lambda&quot;: -5.327113628387451}}},{&quot;name&quot;: &quot;cx&quot;,&quot;wires&quot;: [ 1, 0 ],&quot;options&quot;: {}}],&quot;index&quot;: 1,&quot;qasm&quot;: &quot;OPENQASM 2.0;\ninclude \&quot;qelib1.inc\&quot;;\nqreg q[2];\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[1];\ncx q[1], q[0];\n&quot;,&quot;qasmExt&quot;: &quot;OPENQASM 2.0;\ninclude \&quot;qelib1.inc\&quot;;\nqreg q[2];\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[1];\ncx q[1], q[0];\n&quot;}],&quot;error_code&quot;: 0,&quot;message&quot;: &quot;&quot;,&quot;time_taken&quot;: 0.002,&quot;version&quot;: &quot;0.1.0&quot;},&quot;queuedAt&quot;: &quot;2021-02-06T23:39:29.676Z&quot;,&quot;startedAt&quot;: &quot;2021-02-06T23:39:29.926Z&quot;,&quot;finishedAt&quot;: &quot;2021-02-06T23:39:30.383Z&quot;}```**QPS.generator.stop_job(job_id)**Stop running or cancel queued job. Job will be put into `draft` state, and you can start it again later by calling `start_job()`.**Example:**```pythonfrom quantastica.qps_api import QPSresponse = QPS.generator.stop_job(&quot;SNhiCqSCT2WwRWKCd&quot;)print(response)```Example output:```{ _id: &quot;SNhiCqSCT2WwRWKCd&quot;, message: &quot;OK&quot; }```**QPS.generator.stop_all_jobs(status_filter=None)**Stop running job / cancel all queued jobs.- `status_filter` - you can stop only a running job by providing `status_filter=&quot;running&quot;` (after this, next job from the queue will be executed). Or, you can cancel all queued jobs by providing `status_filter=&quot;queued&quot;` (running job will not be affected - it will continue running).**Example 1** - stop running job and remove all jobs from queue:```pythonfrom quantastica.qps_api import QPSstopped = QPS.generator.stop_all_jobs()print(stopped)```Example output:```{&quot;stopped&quot;: [ { &quot;_id&quot;: &quot;SNhiCqSCT2WwRWKCd&quot;, &quot;name&quot;: &quot;Decompose&quot;, &quot;type&quot;: &quot;unitary&quot; },{ &quot;_id&quot;: &quot;R8tJH7XoZ233oTREy&quot;, &quot;name&quot;: &quot;4Q Gauss&quot;, &quot;type&quot;: &quot;vectors&quot; }]}```**Example 2** - stop only a running job. Next job from queue, if any, will start:```pythonfrom quantastica.qps_api import QPSstopped = QPS.generator.stop_all_jobs(status_filter=&quot;running&quot;)print(stopped)```Example output:```{&quot;stopped&quot;: [{ &quot;_id&quot;: &quot;SNhiCqSCT2WwRWKCd&quot;, &quot;name&quot;: &quot;Decompose&quot;, &quot;type&quot;: &quot;unitary&quot; }]}```**Example 3** - cancel all queued jobs. Running job will not be affected:```pythonfrom quantastica.qps_api import QPSstopped = QPS.generator.stop_all_jobs(status_filter=&quot;queued&quot;)print(stopped)```Example output:```{&quot;stopped&quot;: [{ &quot;_id&quot;: &quot;R8tJH7XoZ233oTREy&quot;, &quot;name&quot;: &quot;4Q Gauss&quot;, &quot;type&quot;: &quot;vectors&quot; }]}```**QPS.generator.start_job(job_id)**Start previously stopped/canceled job (can be any job with status `draft`).**Example:**```pythonfrom quantastica.qps_api import QPSresponse = QPS.generator.start_job(&quot;SNhiCqSCT2WwRWKCd&quot;)print(response)```Example output:```{ _id: &quot;SNhiCqSCT2WwRWKCd&quot;, message: &quot;OK&quot; }```### Circuit from vectorsFind quantum circuit from pairs of initial &amp; final state vectors (wave functions).**QPS.generator.circuit_from_vectors(vector_pairs, endianness = &quot;little&quot;, job_name=None, settings = {}, start_job=True)**- `vector_pairs` is list containing vector pairs. Each vector pair is list with 2 elements: initial vector and final vector. All vectors in all pairs must be of same length (same number of qubits).- `endianness` string. Orientation of bits in state vector (most significant bit/first qubit or least significant bit/first qubit). Can be `little` (like Qiskit) or `big`. Default is `little`.- `job_name` string is optional. You can give it a human readable name.- `settings` object is optional. Default is:```python{&quot;allowed_gates&quot;: &quot;u3,cx&quot;,&quot;max_diff&quot;: 1e-3,&quot;diff_method&quot;: &quot;distance&quot;,&quot;single_solution&quot;: True,&quot;pre_processing&quot;: &quot;&quot;}```Note: if `settings` argument is provided, it will overwrite default values, but only provided keys will be overwritten - not entire default settings object.- `start_job` if this argument is `True` (default) the job will be immediatelly sent to execution queue. If `start_job` is `False` then it will stay in `draft` state and you will be able to start it later by calling `start_job()` method.**Example:**```pythonfrom quantastica.qps_api import QPSvector_pairs = [[ [1, 0, 0, 0], [ 0.5+0j,  0.5+0j,  0.5+0j,  0.5+0j ] ],[ [0, 1, 0, 0], [ 0.5+0j,  0+0.5j, -0.5+0j,  0-0.5j ] ],[ [0, 0, 1, 0], [ 0.5+0j, -0.5+0j,  0.5+0j, -0.5+0j ] ],[ [0, 0, 0, 1], [ 0.5+0j,  0-0.5j, -0.5+0j,  0+0.5j ] ]]job_id = QPS.generator.circuit_from_vectors(vector_pairs, settings = { &quot;instruction_set&quot;: [&quot;h&quot;, &quot;cu1&quot;, &quot;swap&quot;], &quot;single_solution&quot;: False })job = QPS.generator.get_job(job_id, wait=True)job_status = job[&quot;status&quot;]job_output = job[&quot;output&quot;]if(job_status == &quot;error&quot;):print(job_output[&quot;message&quot;])else:for circuit in job_output[&quot;circuits&quot;]:print(circuit[&quot;qasm&quot;])```Example output:```OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];h q[1];swap q[0], q[1];cu1 (2.356194496154785) q[0], q[1];h q[1];OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];h q[1];cu1 (2.356194496154785) q[0], q[1];h q[0];swap q[0], q[1];OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];h q[1];cu1 (2.356194496154785) q[0], q[1];swap q[0], q[1];h q[1];OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];swap q[0], q[1];h q[0];cu1 (2.356194496154785) q[0], q[1];h q[1];```### State preparationGet circuit which will transform ground state (all qubits reset) to desired final state vector.**QPS.generator.state_preparation(final_vector, endianness = &quot;little&quot;, job_name=None, settings = {}, start_job=True)**- `final_vector` is target vector.- `endianness` string. Orientation of bits in state vector (most significant bit/first qubit or least significant bit/first qubit). Can be `little` (like Qiskit) or `big`. Default is `little`.- `job_name` string is optional. You can give it a human readable name.- `settings` object is optional. Default: see `QPS.generator.circuit_from_vectors()`.- `start_job` if this argument is `True` (default) the job will be immediatelly sent to execution queue. If `start_job` is `False` then it will stay in `draft` state and you will be able to start it later by calling `start_job()` method.**Example:**```pythonfrom quantastica.qps_api import QPSdesired_state = [0.5, 0.5, 0.5, 0.5]job_id = QPS.generator.state_preparation(desired_state, settings = { &quot;instruction_set&quot;: [&quot;u3&quot;, &quot;cx&quot;] })job = QPS.generator.get_job(job_id, wait=True)job_status = job[&quot;status&quot;]job_output = job[&quot;output&quot;]if(job_status == &quot;error&quot;):print(job_output[&quot;message&quot;])else:for circuit in job_output[&quot;circuits&quot;]:print(circuit[&quot;qasm&quot;])```Example output:```OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];u3 (1.570796370506287, 0, 1.217840194702148) q[0];u3 (1.570796370506287, 0, 0.621559917926788) q[1];```### TranspileTranspile circuit (change instruction set).**QPS.generator.transpile(input_qasm, method=&quot;replace_blocks&quot;, method_options={}, job_name=None, settings = {}, start_job=True)**- `input_qasm` is string containing OpenQASM 2.0 code.- `method` is method name string. Can be one of: &quot;replace_circuit&quot;, &quot;replace_blocks&quot;, &quot;replace_gates&quot;. Default: &quot;replace_blocks&quot;.- `method_options` dict with following structure:- If method is `replace_blocks` then: `{ &quot;block_size&quot;: 2, &quot;two_pass&quot;: False }` (maximum block size is 4).- For other methods: no options (`method_options` is ignored)- `job_name` string is optional. You can give it a human readable name.- `settings` object is optional. Default is:```python{&quot;allowed_gates&quot;: &quot;u3,cx&quot;,&quot;max_diff&quot;: 1e-3,&quot;diff_method&quot;: &quot;distance&quot;,&quot;single_solution&quot;: True,&quot;pre_processing&quot;: &quot;experimental1&quot;}```Default `diff_method` is `distance`, which means that input and output circuit's global phase will match. That also means longer running time and possibly deeper output circuit (especially with new IBM's instruction set `id, x, sx, rz, cx`). If you are relaxed about global phase (like Qiskit's transpile method), then provide `&quot;diff_method&quot;: &quot;ignorephase&quot;` in `settings`.Note: if `settings` argument is provided, it will overwrite default values, but only provided keys will be overwritten - not entire default settings object.- `start_job` if this argument is `True` (default) the job will be immediatelly sent to execution queue. If `start_job` is `False` then it will stay in `draft` state and you will be able to start it later by calling `start_job()` method.**Example:**```pythonfrom quantastica.qps_api import QPSinput_qasm = &quot;&quot;&quot;OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];h q[0];cx q[0], q[1];&quot;&quot;&quot;job_id = QPS.generator.transpile(input_qasm, settings = { &quot;instruction_set&quot;: [&quot;id&quot;, &quot;x&quot;, &quot;sx&quot;, &quot;rz&quot;, &quot;cx&quot;], &quot;diff_method&quot;: &quot;ignorephase&quot; })job = QPS.generator.get_job(job_id, wait=True)job_status = job[&quot;status&quot;]job_output = job[&quot;output&quot;]if(job_status == &quot;error&quot;):print(job_output[&quot;message&quot;])else:for circuit in job_output[&quot;circuits&quot;]:print(circuit[&quot;qasm&quot;])```Example output:```OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];sx q[0];rz (1.570796370506287) q[0];sx q[0];cx q[0], q[1];```### Decompose matrixDecompose unitary matrix (find circuit from matrix).**QPS.generator.decompose_unitary(unitary, endianness = &quot;big&quot;, job_name=None, settings = {}, start_job=True)**- `unitary` matrix operator.- `endianness` - orientation of the matrix. Can be `little` endian (like Qiskit) or `big` endian. Default is `big`. Note that default endianness of the matrix differs from default endianness of vectors in other methods. That's to be aligned with QPS. In Qiskit, both matrices and vectors are `little` endian. So, if you are solving unitary from Qiskit then provide `endianness = &quot;little&quot;` argument.- `job_name` string is optional. You can give it a human readable name.- `settings` object is optional. Default is:```python{&quot;allowed_gates&quot;: &quot;u3,cx&quot;,&quot;max_diff&quot;: 1e-3,&quot;diff_method&quot;: &quot;distance&quot;,&quot;single_solution&quot;: True,&quot;pre_processing&quot;: &quot;&quot;}```Note: if `settings` argument is provided, it will overwrite default values, but only provided keys will be overwritten - not entire default settings object.- `start_job` if this argument is `True` (default) the job will be immediatelly sent to execution queue. If `start_job` is `False` then it will stay in `draft` state and you will be able to start it later by calling `start_job()` method.**Example:**```pythonfrom quantastica.qps_api import QPSunitary = [[ 0.5+0.0j,  0.5+0.0j,  0.5+0.0j,  0.5+0.0j],[ 0.5+0.0j,  0.5+0.0j, -0.5+0.0j, -0.5+0.0j],[ 0.5+0.0j, -0.5+0.0j,  0.0+0.5j,  0.0-0.5j],[ 0.5+0.0j, -0.5+0.0j,  0.0-0.5j,  0.0+0.5j]]job_id = QPS.generator.decompose_unitary(unitary, settings = { &quot;instruction_set&quot;: [&quot;h&quot;, &quot;cu1&quot;, &quot;swap&quot;], &quot;single_solution&quot;: False })job = QPS.generator.get_job(job_id, wait=True)job_status = job[&quot;status&quot;]job_output = job[&quot;output&quot;]if(job_status == &quot;error&quot;):print(job_output[&quot;message&quot;])else:for circuit in job_output[&quot;circuits&quot;]:print(circuit[&quot;qasm&quot;])```Example output:```OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];h q[1];swap q[0], q[1];cu1 (1.570796370506287) q[0], q[1];h q[1];OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];h q[1];cu1 (1.570796370506287) q[0], q[1];h q[0];swap q[0], q[1];OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];h q[1];cu1 (1.570796370506287) q[0], q[1];swap q[0], q[1];h q[1];OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];swap q[0], q[1];h q[0];cu1 (1.570796370506287) q[0], q[1];h q[1];```### Create algorithm from truth tableCreate circuit which implements logical expression whose truth table is given.**QPS.generator.circuit_from_truth_table(truth_table_csv, column_defs, csv_delimiter=None, additional_qubits=1, job_name=None, settings={}, start_job=True)**- `truth_table_csv` is string containing truth table in CSV format- `column_defs` list of strings describing each column from truth table: `&quot;input&quot;`, `&quot;output&quot;` or `&quot;ignore&quot;`- `csv_delimiter` CSV column delimiter char: `None`, `&quot;,&quot;` (comma) or `&quot;\t&quot;` (tab). If delimiter is `None` (default) it will be automatically detected.- `additional_qubits` number of qubits to add (to displace input and output qubits).- `job_name` string is optional. You can give it a human readable name.- `settings` object is optional. Default is:```python{&quot;allowed_gates&quot;: &quot;x,cx,ccx,swap&quot;,&quot;max_diff&quot;: 1e-3,&quot;diff_method&quot;: &quot;distance&quot;,&quot;single_solution&quot;: True,&quot;pre_processing&quot;: &quot;&quot;}```**Example:**```pythonfrom quantastica.qps_api import QPStruth_table = &quot;&quot;&quot;A,B,A_NAND_B0,0,10,1,11,0,11,1,0&quot;&quot;&quot;job_id = QPS.generator.circuit_from_truth_table(truth_table, [&quot;input&quot;, &quot;input&quot;, &quot;output&quot;])job = QPS.generator.get_job(job_id, wait=True)job_status = job[&quot;status&quot;]job_output = job[&quot;output&quot;]if(job_status == &quot;error&quot;):raise Exception(job_output[&quot;message&quot;])else:if(len(job_output[&quot;circuits&quot;]) == 0):raise Exception(&quot;No results.&quot;)else:for circuit in job_output[&quot;circuits&quot;]:print(circuit[&quot;qasm&quot;])```Example output:```OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[3];x q[2];ccx q[0], q[1], q[2];```### Run problem fileSolve problem provided in internal format used by generator.**QPS.generator.solve(problem, settings = {}, start_job=True)**- `problem` object - generator job exported to json from QPS.- `settings` argument is optional. If provided, it will overwrite keys in `problem.settings`. Note that only provided keys will be overwritten - not entire `problem.settings` object.- `start_job` if this argument is `True` (default) the job will be immediatelly sent to execution queue. If `start_job` is `False` then it will stay in `draft` state and you will be able to start it later by calling `start_job()` method.**Example:**```pythonfrom quantastica.qps_api import QPSproblem = {&quot;name&quot;: &quot;Bell&quot;,&quot;type&quot;: &quot;vectors&quot;,&quot;source&quot;: {&quot;vectors&quot;: {&quot;text1&quot;: &quot;[ 1, 0, 0, 0 ]&quot;,&quot;text2&quot;: &quot;[ 1/sqrt(2), 0, 0, 1/sqrt(2) ]&quot;,&quot;endianness1&quot;: &quot;little&quot;,&quot;endianness2&quot;: &quot;little&quot;}},&quot;problem&quot;: [{&quot;input&quot;: [1,0,0,0],&quot;output&quot;: [0.7071067811865475,0,0,0.7071067811865475]}],&quot;settings&quot;: {&quot;allowed_gates&quot;: &quot;u3,cx&quot;,&quot;coupling_map&quot;: [],&quot;min_gates&quot;: 0,&quot;max_gates&quot;: 0,&quot;max_diff&quot;: 0.001,&quot;diff_method&quot;: &quot;distance&quot;,&quot;single_solution&quot;: False,&quot;pre_processing&quot;: &quot;&quot;}}job_id = QPS.generator.solve(problem)job = QPS.generator.get_job(job_id, wait=True)job_status = job[&quot;status&quot;]job_output = job[&quot;output&quot;]if(job_status == &quot;error&quot;):print(job_output[&quot;message&quot;])else:for circuit in job_output[&quot;circuits&quot;]:print(circuit[&quot;qasm&quot;])```Example output:```OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];u3 (-1.570796370506287, -3.141592741012573, -2.675650835037231) q[0];cx q[0], q[1];OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];u3 (-1.570796370506287, -3.141592741012573, -2.675650835037231) q[1];cx q[1], q[0];```### Generator output formatGenerator job object has following structure:```javascript{&quot;name&quot;       : String,&quot;type&quot;       : String,&quot;source&quot;     : Object,&quot;problem&quot;    : Array,&quot;settings&quot;   : Object,&quot;status&quot;     : String,&quot;output&quot;     : Object,&quot;queuedAt&quot;   : String,&quot;startedAt&quot;  : String,&quot;finishedAt&quot; : String}```Keys important to user are:- `name` String: name of the job- `status` String: can be `draft`, `queued`, `running`, `error`, `done`.- `output` Object with following structure:```javascript{&quot;error_code&quot; : Integer,&quot;message&quot;    : String,&quot;time_taken&quot; : Float,&quot;version&quot;    : String,&quot;circuits&quot;   : Array of Object}```- `error_code` Integer: 0 on success, non-zero on error- `message` String: error message if error code is non-zero- `time_taken` Float: number of seconds- `version` String: generator version- `circuits` Array: resulting circuits. Each is object with following structure:```javascript{&quot;qubits&quot;  : Integer,&quot;cregs&quot;   : Array,&quot;program&quot; : Array,&quot;diff&quot;    : Float,&quot;index&quot;   : Integer,&quot;qasm&quot;    : String,&quot;qasmExt&quot; : String}```Keys important to user are:- `qasm` OpenQASM 2.0 source code of the resulting circuit.- `qasmExt` OpenQASM 2.0 with extended instruction set (all gates supported by Quantum Programming Studio).Difference between `qasm` and `qasmExt`: if circuit contains gate supported by QPS but not directly supported by OpenQASM 2.0 then `qasm` will contain equivalent circuit transpiled to OpenQASM 2.0 instruction set, but `qasmExt` will contain gates as is.For example if circuit contains IONQ native gate `gpi2(2.51678906856393)` on first qubit:`qasm` will be:```OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[1];u3 (1.5707963267948966, 0.9459927417690333, -0.9459927417690333) q[0];````qasmExt` will contain:```OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[1];gpi2 (2.51678906856393) q[0];```**Example job object with output:**```python{&quot;_id&quot;: &quot;r9LskFoLPQW5w7HTp&quot;,&quot;name&quot;: &quot;Bell&quot;,&quot;type&quot;: &quot;vectors&quot;,&quot;source&quot;: {&quot;vectors&quot;: {&quot;text1&quot;: &quot;[ 1, 0, 0, 0 ]&quot;,&quot;text2&quot;: &quot;[ 1/sqrt(2), 0, 0, 1/sqrt(2) ]&quot;,&quot;endianness1&quot;: &quot;little&quot;,&quot;endianness2&quot;: &quot;little&quot;}},&quot;problem&quot;: [{&quot;input&quot;: [ 1, 0, 0, 0 ],&quot;output&quot;: [ 0.7071067811865475, 0, 0, 0.7071067811865475 ]}],&quot;settings&quot;: {&quot;max_diff&quot;: 0.001,&quot;diff_method&quot;: &quot;distance&quot;,&quot;single_solution&quot;: False,&quot;pre_processing&quot;: &quot;&quot;,&quot;allowed_gates&quot;: &quot;u3,cx&quot;,&quot;coupling_map&quot;: [],&quot;min_gates&quot;: 0,&quot;max_gates&quot;: 0},&quot;status&quot;: &quot;done&quot;,&quot;output&quot;: {&quot;circuits&quot;: [{&quot;qubits&quot;: 2,&quot;cregs&quot;: [],&quot;diff&quot;: 0,&quot;program&quot;: [{&quot;name&quot;: &quot;u3&quot;,&quot;wires&quot;: [ 0 ],&quot;options&quot;: {&quot;params&quot;: {&quot;theta&quot;: -1.570796370506287,&quot;phi&quot;: -3.141592741012573,&quot;lambda&quot;: -5.327113628387451}}},{&quot;name&quot;: &quot;cx&quot;,&quot;wires&quot;: [ 0, 1 ],&quot;options&quot;: {}}],&quot;index&quot;: 0,&quot;qasm&quot;: &quot;OPENQASM 2.0;\ninclude \&quot;qelib1.inc\&quot;;\nqreg q[2];\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[0];\ncx q[0], q[1];\n&quot;,&quot;qasmExt&quot;: &quot;OPENQASM 2.0;\ninclude \&quot;qelib1.inc\&quot;;\nqreg q[2];\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[0];\ncx q[0], q[1];\n&quot;},{&quot;qubits&quot;: 2,&quot;cregs&quot;: [],&quot;diff&quot;: 0,&quot;program&quot;: [{&quot;name&quot;: &quot;u3&quot;,&quot;wires&quot;: [ 1 ],&quot;options&quot;: {&quot;params&quot;: {&quot;theta&quot;: -1.570796370506287,&quot;phi&quot;: -3.141592741012573,&quot;lambda&quot;: -5.327113628387451}}},{&quot;name&quot;: &quot;cx&quot;,&quot;wires&quot;: [ 1, 0 ],&quot;options&quot;: {}}],&quot;index&quot;: 1,&quot;qasm&quot;: &quot;OPENQASM 2.0;\ninclude \&quot;qelib1.inc\&quot;;\nqreg q[2];\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[1];\ncx q[1], q[0];\n&quot;,&quot;qasmExt&quot;: &quot;OPENQASM 2.0;\ninclude \&quot;qelib1.inc\&quot;;\nqreg q[2];\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[1];\ncx q[1], q[0];\n&quot;}],&quot;error_code&quot;: 0,&quot;message&quot;: &quot;&quot;,&quot;time_taken&quot;: 0.002,&quot;version&quot;: &quot;0.1.0&quot;},&quot;createdAt&quot;: &quot;2021-02-06T23:39:29.108Z&quot;,&quot;modifiedAt&quot;: &quot;2021-02-06T23:39:30.383Z&quot;,&quot;queuedAt&quot;: &quot;2021-02-06T23:39:29.676Z&quot;,&quot;startedAt&quot;: &quot;2021-02-06T23:39:29.926Z&quot;,&quot;finishedAt&quot;: &quot;2021-02-06T23:39:30.383Z&quot;}```### Using Generator with QiskitGenerator is using OpenQASM 2.0 format for input and output, so integration with Qiskit (and other frameworks that support QASM) is easy.**Example** transpile Qiskit circuit:```pythonfrom qiskit import QuantumCircuitfrom qiskit.circuit.random import random_circuitfrom qiskit.quantum_info import Operatorfrom quantastica.qps_api import QPS# Generate random Qiskit circuitqc = random_circuit(5, 5, measure=False)# Get QASM codeinput_qasm = qc.qasm()# Transpile with generatorjob_id = QPS.generator.transpile(input_qasm, settings = { &quot;instruction_set&quot;: [&quot;id&quot;, &quot;u3&quot;, &quot;cx&quot;], &quot;diff_method&quot;: &quot;ignorephase&quot; })job = QPS.generator.get_job(job_id, wait=True)job_status = job[&quot;status&quot;]job_output = job[&quot;output&quot;]if(job_status == &quot;error&quot;):    raise Exception(job_output[&quot;message&quot;])transpiled_circuit = job_output[&quot;circuits&quot;][0]# Get QASM codetranspiled_qasm = transpiled_circuit[&quot;qasm&quot;]# Create Qiskit circuittranspiled_qc = QuantumCircuit.from_qasm_str(transpiled_qasm)# Show circuitprint(&quot;Depth:&quot;, transpiled_qc.depth())print(&quot;Ops:&quot;, sum(j for i, j in transpiled_qc.count_ops().items()))display(transpiled_qc.draw(output=&quot;mpl&quot;))```## Quantum Language Converter API[Quantum Language Converter](https://quantastica.com/#converters) is a tool which converts quantum program between different quantum programming languages and frameworks. It is also available as a [q-convert](https://www.npmjs.com/package/q-convert) command line tool and as a web UI at [https://quantum-circuit.com/qconvert](https://quantum-circuit.com/qconvert).QPS has integrated quantum language converter API which you can access directly from python code:**QPS.converter.convert(input, source, dest)**Converts `input` quantum program given as string from `source` format into `dest` format.- `input` String. Program source code- `source` String. Input format:- `qasm` [OpenQASM 2.0](https://github.com/Qiskit/openqasm) source code- `quil` [Quil](https://arxiv.org/abs/1608.03355) source code- `qobj` [QObj](https://arxiv.org/abs/1809.03452)- `ionq` [IONQ](https://docs.ionq.com/) (json)- `quantum-circuit` [quantum-circuit](https://www.npmjs.com/package/quantum-circuit) object (json)- `toaster` [Qubit Toaster](https://quantastica.com/#toaster) object (json)- `dest` String. Output format:- `qiskit` [Qiskit](https://qiskit.org/documentation/)- `qasm` [OpenQASM 2.0](https://github.com/Qiskit/openqasm)- `qasm-ext` OpenQASM 2.0 with complete instruction set supported by QPS (and other Quantastica tools)- `qobj` [QObj](https://arxiv.org/abs/1809.03452)- `quil` [Quil](https://arxiv.org/abs/1608.03355)- `pyquil` [pyQuil](http://docs.rigetti.com/en/latest/index.html)- `braket` [Braket](https://docs.aws.amazon.com/braket/)- `cirq` [Cirq](https://github.com/quantumlib/Cirq)- `tfq` [TensorFlow Quantum](https://www.tensorflow.org/quantum)- `qsharp` [QSharp](https://docs.microsoft.com/en-us/quantum/language/index?view=qsharp-preview)- `quest` [QuEST](https://quest.qtechtheory.org/)- `js` [quantum-circuit](https://www.npmjs.com/package/quantum-circuit) (javascript)- `quantum-circuit` [quantum-circuit](https://www.npmjs.com/package/quantum-circuit) (json)- `toaster` [Qubit Toaster](https://quantastica.com/toaster/)- `svg` [SVG (standalone)](https://www.w3.org/Graphics/SVG/)- `svg-inline` [SVG (inline)](https://www.w3.org/Graphics/SVG/)**Example 1** - convert QASM 2.0 program to QUIL:```pythonfrom quantastica.qps_api import QPSinput_program = &quot;&quot;&quot;OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];creg c[2];h q[0];cx q[0], q[1];measure q[0] -&gt; c[0];measure q[1] -&gt; c[1];&quot;&quot;&quot;output_program = QPS.converter.convert(input_program, &quot;qasm&quot;, &quot;quil&quot;)print(output_program)```Output:```DECLARE ro BIT[2]H 0CNOT 0 1MEASURE 0 ro[0]MEASURE 1 ro[1]```**Example 2** - convert QASM 2.0 program to circuit drawing as vector image:```pythonfrom quantastica.qps_api import QPSinput_program = &quot;&quot;&quot;OPENQASM 2.0;include &quot;qelib1.inc&quot;;qreg q[2];creg c[2];h q[0];cx q[0], q[1];measure q[0] -&gt; c[0];measure q[1] -&gt; c[1];&quot;&quot;&quot;output_svg = QPS.converter.convert(input_program, &quot;qasm&quot;, &quot;svg&quot;)open(&quot;output.svg&quot;, &quot;w&quot;).write(output_svg)```## Utils API**QPS.utils.random_circuit(num_qubits=5, output_format=&quot;quantum-circuit&quot;, options=None)**Returns random quantum circuit.- `num_qubits` Integer. Number of qubits. Default: `5`.- `format` String. Output format. The same as `QPS.converter.convert()` function's `dest` argument. Example: `&quot;qasm&quot;`. Default: `&quot;quantum-circuit&quot;`.- `options` Dict. Optional. Can contain following keys:- `instruction_set` List of gates to use. Example: `[&quot;u3&quot;, &quot;cx&quot;]`. Default: `[ &quot;u3&quot;, &quot;rx&quot;, &quot;ry&quot;, &quot;rz&quot;, &quot;cx&quot;, &quot;cz&quot; ]`.- `num_gates` Integer. Number of gates in the circuit. Default is `num_qubits * 8`.- `mid_circuit_measurement` Bool. Default: `False`.- `mid_circuit_reset` Bool. Default: `False`.- `classic_control` Bool. Default: `False`.</longdescription>
</pkgmetadata>