<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># `python-ranges`This module provides data structures for representing- Continuous Ranges- Non-continuous Ranges (i.e. sets of continous Ranges)- `dict`-like structures that use ranges as keys## IntroductionOne curious missing feature in Python (and several other programming languages) is the absence of a proper Range data structure - a _continuous_ set of values from somestarting point to some ending point. Python's built-in `range()` produces an objectthat can be used to iterate over numbers, but it's not continuous (e.g. `1.5 in range(1, 2)` returns `False`) and doesn't workfor non-numeric types like dates. Instead, we have to make do with verbose`if`/`else` comparisons:```pythonif value &gt;= start and value &lt; end:    # do something```And to have a graded sequence of ranges with different behavior for each, we haveto chain these `if`/`elif`/`else` blocks together:```python# 2019 U.S. income tax brackets, filing Singleincome = int(input(&quot;What is your income? $&quot;))if income &lt; 9701:    tax = 0.1 * incomeelif 9701 &lt;= income &lt; 39476:    tax = 970 + 0.12 * (income - 9700)elif 39476 &lt;= income &lt; 84201:    tax = 4543 + 0.22 * (income - 39475)elif 84201 &lt;= income &lt; 160726:    tax = 14382.5 + 0.24 * (income - 84200)elif 160726 &lt;= income &lt; 204101:    tax = 32748.5 + 0.32 * (income - 160725)elif 204101 &lt;= income &lt; 510301:    tax = 46628.5 + 0.35 * (income - 204100)else:    tax = 153798.5 + 0.37 * (income - 510300)print(f&quot;Your tax on that income is ${tax:.2f}&quot;)```And if we want to restrict a user input to within certain bounds, we need to do some complicated, verbose construct like this:```pythonuser_input = int(input())value_we_want = min(max(user_input, start), end)```This module, `ranges`, fixes this problem by introducing a data structure `Range` torepresent a continuous range, and a `dict`-like data structure `RangeDict` to mapranges to values. This makes simple range checks more intuitive:```pythonif value in Range(start, end):    # do somethinguser_input = int(input())value_we_want = Range(start, end).clamp(user_input)```and does away with the tedious `if`/`elif`/`else` blocks:```python# 2019 U.S. income tax brackets, filing Singletax_info = RangeDict({    Range(0, 9701):        (0,        0.10, 0),    Range(9701,   39476):  (970,      0.12, 9700),    Range(39476,  84201):  (4543,     0.22, 39475),    Range(84201,  160726): (14382.2,  0.24, 84200),    Range(160726, 204101): (32748.5,  0.32, 160725),    Range(204101, 510301): (46628.5,  0.35, 204100),    Range(start=510301):   (153798.5, 0.37, 510300),})income = int(input(&quot;What is your income? $&quot;))base, marginal_rate, bracket_floor = tax_info[income]tax = base + marginal_rate * (income - bracket_floor)print(f&quot;Your tax on that income is ${tax:.2f}&quot;)```The `Range` data structure also accepts strings, dates, and any other data type, solong as the start value is less than the end value (and so long as checking thatdoesn't raise an error). See [the in-depth documentation](https://python-ranges.readthedocs.io/en/latest/) for more details.## InstallationInstall `python-ranges` via [pip](https://pip.pypa.io/en/stable/):```bash$ pip install python-ranges```Due to use of format strings in the code, this module will only work with**python 3.6 or higher**. Some post-3.9 features are also used in the module'stype hinting, which may pose a problem for earlier versions of python.## UsageSimply import `ranges` like any other python package, or import the `Range`, `RangeSet`, and `RangeDict` classes from it:```pythonimport rangesmy_range = ranges.Range(&quot;anaconda&quot;, &quot;viper&quot;)``````pythonfrom ranges import Rangemy_range = Range(&quot;anaconda&quot;, &quot;viper&quot;)```Then, you can use these data types however you like.### `Range`To make a Range, simply call `Range()` with start and end values. Both of thesework:```pythonrng1 = Range(1.5, 7)rng2 = Range(start=4, end=8.5)```You can also use the `include_start` and `include_end` keyword arguments to specifywhether or not each end of the range should be inclusive. By default, the startis included and the end is excluded, just like python's built-in `range()` function.If you use keyword arguments and don't specify either the `start` or the `end` ofthe range, then the `Range`'s bounds will be negative or positive infinity,respectively. `Range` uses a special notion of infinity that's compatible withnon-numeric data types - so `Range(start=&quot;journey&quot;)` will include *any string* that's lexicographically greater than &quot;journey&quot;, and `Range(end=datetime.date(1989, 10, 4))` will include any date before October 4,1989, despite neither `str` nor `datetime` having any built-in notion of infinity.You can import `Inf` in order to invoke this infinity explicitly:```pythonfrom ranges import Range, InfrngA = Range(-Inf, Inf)rngB = Range()# rng1 and rng2 are identical```and you can check whether a range is infinite on either end by calling `.isinfinite()`:```pythonrngC = Range(end=0)rngD = Range(start=0)rngE = Range(-1, 1)print(rng1.isinfinite(), rng2.isinfinite(), rng3.isinfinite())# True True False```If you're making a range of numbers, then you can also use a single string as anargument, with circle-brackets `()` meaning &quot;exclusive&quot; and square-brackets `[]`meaning &quot;inclusive&quot;:```pythonrng3 = Range(&quot;[1.5, 7)&quot;)rng4 = Range(&quot;[1.5 .. 7)&quot;)````Range`'s interface is similar to the built-in `set`, and the following methodsall act exactly how you'd expect:```pythonprint(rng1.union(rng2))  # [1.5, 8.5)print(rng1.intersection(rng2))  # [4, 7)print(rng1.difference(rng2))  # [1.5, 4)print(rng1.symmetric_difference(rng2))  # {[1.5, 4), [7, 8.5)}```Of course, the operators `|`, `&amp;`, `-`, and `^` can be used in place of thosemethods, just like for python's built-in `set`s.See [the documentation](https://python-ranges.readthedocs.io/en/latest/#ranges.Range) for more details.### `RangeSet`A `RangeSet` is just an ordered set of `Range`s, all of the same kind. Like `Range`,its interface is similar to the built-in `set`. Unlike `Range`, which isn'tmutable, `RangeSet` can be modified just like `set` can, with the methods`.add()`, `.extend()`, `.discard()`, etc.To construct a `RangeSet`, just call `RangeSet()` with a bunch of ranges (oriterables containing ranges) as positional arguments:```pythonrngset1 = RangeSet(&quot;[1, 4.5]&quot;, &quot;(6.5, 10)&quot;)rngset2 = RangeSet([Range(2, 3), Range(7, 8)])````Range` and `RangeSet` objects are mutually compatible for things like `union()`,`intersection()`, `difference()`, and `symmetric_difference()`. If you give thesemethods a range-like object, it'll get automatically converted:```pythonprint(rngset1.union(Range(3, 8)))  # {[1, 10)}print(rngset1.intersection(&quot;[3, 8)&quot;))  # {[3, 4.5], (6.5, 8)}print(rngset1.symmetric_difference(&quot;[3, 8)&quot;))  # {[1, 3), (4.5, 6], [8, 10)}```Of course, `RangeSet`s can operate with each other, too:```pythonprint(rngset1.difference(rngset2))  # {[1, 2), [3, 4.5], (6.5, 7), [8, 10)}```The operators `|`, `&amp;`, `^`, and `-` all work with `RangeSet` as they do with `set`,as do their associated assignment operators `|=`, `&amp;=`, `^=`, and `-=`. Finally, you can iterate through a `RangeSet` to get all of its component ranges:```pythonfor rng in rngset1:    print(rng)# [1, 4.5]# (6.5, 10)```See [the documentation](https://python-ranges.readthedocs.io/en/latest/#ranges.RangeSet) for more details.### ` RangeDict`This data structure is analagous to python's built-in `dict` data structure, exceptit uses `Range`s/`RangeSet`s as keys. As shown above, you can use `RangeDict` toconcisely express different behavior depending on which range a value falls into.To make a `RangeDict`, call `RangeDict()` with an either a `dict` or an iterableof 2-tuples corresponding `Range`s or `RangeSet`s with values. You can also usea tuple of `Range`s as a key.  A `RangeDict` can handle any type of `Range`, or even multiple different types of `Range`s all at once:```pythonadvisors = RangeDict([    (Range(end=&quot;I&quot;), &quot;Gilliam&quot;),    (Range(&quot;I&quot;, &quot;Q&quot;), &quot;Jones&quot;),    (Range(start=&quot;Q&quot;), &quot;Chapman&quot;),])mixmatch = RangeDict({    (Range(0, 8),     Range(&quot;A&quot;, &quot;I&quot;)): &quot;Gilliam&quot;,    (Range(8, 16),    Range(&quot;I&quot;, &quot;Q&quot;)): &quot;Jones&quot;,    (Range(start=16), Range(start=&quot;Q&quot;)): &quot;Chapman&quot;,})```See [the documentation](https://python-ranges.readthedocs.io/en/latest/#ranges.RangeDict) for more details.## Support / ContributingIf you spot any bugs in this module, please [submit an issue](https://github.com/Superbird11/ranges/issues)detailing what youdid, what you were expecting, and what you saw, and I'll make a prompt effortto isolate the root cause and fix it. The error should be reproducible. If, looking through the code, you spot any other improvements that could bemade, then feel free to submit issues detailing those as well. Also feel freeto submit a pull request with improvements to the code.This module is extensively unit-tested. All code contributions should beaccompanied by thorough unit tests for every conceivable use case of the newfunctionality. If you spot any use cases that aren't currently covered by theunit test suite, feel free to either [submit a GitHub issue](https://github.com/Superbird11/ranges/issues) detailing them, orsimply add them yourself and submit a pull request.### Possible To-Do List:- Add a notion of a `PermissiveRangeSet` (name pending) which allows multiple types of `Range`s that are not necessarily mutually comparable. In the initial design Iconsidered a number of ways to implement this, but ran into conceptual difficulties,mainly in terms of handling performance and algorithms. If you can build a `PermissiveRangeSet` or similar class that implements this functionality, along witha suitable set of unit tests, then feel free to do so and submit a pull request (ifyou do, please include the reasoning for your design decisions).- Rewrite `RangeSet.intersection()` to use a pair-steppingalgorithm (akin to the &quot;merge&quot; part of MergeSort - iterate through the two `_LinkedList` data structures simultaneously and only advance one element of onelist at a time) instead of the current &quot;compare every element with every other element&quot; solution. Adding short-circuiting to this (returning early from the methodonce it's clear that there is no longer work to be done, even if the entire listhas not yet been iterated through) would also be useful, and the two approachessynergize nicely. This won't lower the complexity class below its currentworst-case `O(n^2)`, but it could drastically improve performance.- Rewrite `RangeSet.isdisjoint()` to use pair-stepping and short-circuiting. Thereasoning here is the same as for `RangeSet.intersection()`.- Rewrite `RangeDict.getitem()` and `RangeDict.getoverlapitems()` to use a binary search, for efficiency on potentially large dicts.- Add pretty-printing for `RangeSet` and especially `RangeDict`. The `pprint`module does not seem to work on them, unfortunately.- Replace the `_LinkedList` data structure (contained in `_helper.py`) with an[interval list](https://en.wikipedia.org/wiki/Interval_tree), an[`O(sqrt(n))` list](https://github.com/igushev/IgushArray), or some other datastructure more tailored to the particular problem. Linked List was chosen becauseit supported quick insertion/deletion and was easy to implement; the latterconcern is no longer relevant.Any open issues or bugs are also fair game for contribution. See [above](#errors--contributing) for directions.## License[MIT License](LICENSE.txt). Feel free to use `ranges` however you like.</longdescription>
</pkgmetadata>