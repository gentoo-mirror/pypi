<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![Build Status](https://github.com/dranjan/python-plyfile/actions/workflows/python-package.yml/badge.svg)Welcome to the `plyfile` Python module, which provides a simple facilityfor reading and writing ASCII and binary PLY files.The PLY format is documented[elsewhere](https://web.archive.org/web/20161221115231/http://www.cs.virginia.edu/~gfx/Courses/2001/Advanced.spring.01/plylib/Ply.txt).# Installation## Dependencies- python3 &gt;= 3.7- numpy &gt;= 1.17(`plyfile` may or may not work on older versions.)### Optional dependencies- tox (for test suite)- pytest (for test suite)## Installing plyfileQuick way:    pip3 install plyfileOr clone the repository and run from the project root:    pip3 install .Or just copy `plyfile.py` into your GPL-compatible project.## Running test suitePreferred (more comprehensive; requires tox):    tox -v --skip-missing-interpretersAlternate (requires pytest):    pytest test -v# UsageBoth deserialization and serialization of PLY file data is done through`PlyData` and `PlyElement` instances.```Python Console&gt;&gt;&gt; import numpy&gt;&gt;&gt; from plyfile import PlyData, PlyElement&gt;&gt;&gt;```For the code examples that follow, assume the file `tet.ply` containsthe following text:    ply    format ascii 1.0    comment single tetrahedron with colored faces    element vertex 4    comment tetrahedron vertices    property float x    property float y    property float z    element face 4    property list uchar int vertex_indices    property uchar red    property uchar green    property uchar blue    end_header    0 0 0    0 1 1    1 0 1    1 1 0    3 0 1 2 255 255 255    3 0 2 3 255 0 0    3 0 1 3 0 255 0    3 1 2 3 0 0 255(This file is available under the `examples` directory.)## Reading a PLY file```Python Console&gt;&gt;&gt; plydata = PlyData.read('tet.ply')&gt;&gt;&gt;```or```Python Console&gt;&gt;&gt; with open('tet.ply', 'rb') as f:...     plydata = PlyData.read(f)&gt;&gt;&gt;```The static method `PlyData.read` returns a `PlyData` instance, which is`plyfile`'s representation of the data in a PLY file.  A `PlyData`instance has an attribute `elements`, which is a list of `PlyElement`instances, each of which has a `data` attribute which is a `numpy`structured array containing the numerical data.  PLY file elements maponto `numpy` structured arrays in a pretty obvious way.  For a listproperty in an element, the corresponding `numpy` field typeis `object`, with the members being `numpy` arrays (see the`vertex_indices` example below).Concretely:```Python Console&gt;&gt;&gt; plydata.elements[0].name'vertex'&gt;&gt;&gt; plydata.elements[0].data[0](0., 0., 0.)&gt;&gt;&gt; plydata.elements[0].data['x']array([0., 0., 1., 1.], dtype=float32)&gt;&gt;&gt; plydata['face'].data['vertex_indices'][0]array([0, 1, 2], dtype=int32)&gt;&gt;&gt;```For convenience, elements and properties can be looked up by name:```Python Console&gt;&gt;&gt; plydata['vertex']['x']array([0., 0., 1., 1.], dtype=float32)&gt;&gt;&gt;```and elements can be indexed directly without explicitly going throughthe `data` attribute:```Python Console&gt;&gt;&gt; plydata['vertex'][0](0., 0., 0.)&gt;&gt;&gt;```The above expression is equivalent to `plydata['vertex'].data[0]`.`PlyElement` instances also contain metadata:```Python Console&gt;&gt;&gt; plydata.elements[0].properties(PlyProperty('x', 'float'), PlyProperty('y', 'float'), PlyProperty('z', 'float'))&gt;&gt;&gt; plydata.elements[0].count4&gt;&gt;&gt;````PlyProperty` and `PlyListProperty` instances are used internally as aconvenient intermediate representation of PLY element properties thatcan easily be serialized to a PLY header (using `str`) or converted to`numpy`-compatible type descriptions (via the `dtype` method).  It's notextremely common to manipulate them directly, but if needed, theproperty metadata of an element can be accessed as a tuple via the`properties` attribute (as illustrated above) or looked up by name:```Python Console&gt;&gt;&gt; plydata.elements[0].ply_property('x')PlyProperty('x', 'float')&gt;&gt;&gt;```Many (but not necessarily all) types of malformed input files will raise`PlyParseError` when `PlyData.read` is called.  The string value of the`PlyParseError` instance (as well as attributes `element`, `row`, and`prop`) provides additional context for the error if applicable.### Faster reading via memory mappingTo accelerate parsing of binary data, `plyfile` can make use of`numpy`'s memory mapping facilities. The decision to memory map or notis made on a per-element basis. To make this determination, there aretwo cases to consider.#### Case 1: elements with no list propertiesIf an element in a binary PLY file has no list properties, then it willbe memory-mapped by default, subject to the capabilities of theunderlying file object. Memory mapping can be disabled using the`mmap` argument:```Python Console&gt;&gt;&gt; plydata.text = False&gt;&gt;&gt; plydata.byte_order = '&lt;'&gt;&gt;&gt; plydata.write('tet_binary.ply')&gt;&gt;&gt;&gt;&gt;&gt; # `mmap=True` is the default:&gt;&gt;&gt; plydata = PlyData.read('tet_binary.ply')&gt;&gt;&gt; isinstance(plydata['vertex'].data, numpy.memmap)True&gt;&gt;&gt; plydata = PlyData.read('tet_binary.ply', mmap=False)&gt;&gt;&gt; isinstance(plydata['vertex'].data, numpy.memmap)False&gt;&gt;&gt;```#### Case 2: elements with list propertiesIn the general case, elements with list properties cannot bememory-mapped as `numpy` arrays, except in one important case: whenall list properties have fixed and known lengths. In that case, the`known_list_len` argument can be given to `PlyData.read`:```Python Console&gt;&gt;&gt; plydata = PlyData.read('tet_binary.ply',...                        known_list_len={'face': {'vertex_indices': 3}})&gt;&gt;&gt; isinstance(plydata['face'].data, numpy.memmap)True&gt;&gt;&gt;```The implementation will validate the data: if any instance of the listproperty has a length other than the value specified, then`PlyParseError` will be raised.Note that in order to enable memory mapping for a given element,*all* list properties in the element must have their lengths in the`known_list_len` dictionary. If any list property does not have itslength given in `known_list_len`, then memory mapping will not beattempted, and no error will be raised.## Creating a PLY fileThe first step is to get your data into `numpy` structured arrays.  Notethat there are some restrictions: generally speaking, if you know thetypes of properties a PLY file element can contain, you can easilydeduce the restrictions.  For example, PLY files don't contain 64-bitinteger or complex data, so these aren't allowed.For convenience, non-scalar fields **are** allowed; they will beserialized as list properties.  For example, when constructing a &quot;face&quot;element, if all the faces are triangles (a common occurrence), it's okayto have a  &quot;vertex_indices&quot; field of type `'i4'` and shape `(3,)`instead of type `object` and shape `()`.  However, if the serialized PLYfile is read back in using `plyfile`, the &quot;vertex_indices&quot; property willbe represented as an `object`-typed field, each of whose values is anarray of type `'i4'` and length 3.  The reason is simply that the PLYformat provides no way to find out that each &quot;vertex_indices&quot; field haslength 3 without actually reading all the data, so `plyfile` has toassume that this is a variable-length property.  However, see below (and`examples/plot.py`) for an easy way to recover a two-dimensional arrayfrom a list property, and also see the notes above about the`known_list_len` kwarg to speed up the reading of files with lists offixed, known length.For example, if we wanted to create the &quot;vertex&quot; and &quot;face&quot; PLY elementsof the `tet.ply` data directly as `numpy` arrays for the purpose ofserialization, we could do (as in `test/test.py`):```Python Console&gt;&gt;&gt; vertex = numpy.array([(0, 0, 0),...                       (0, 1, 1),...                       (1, 0, 1),...                       (1, 1, 0)],...                      dtype=[('x', 'f4'), ('y', 'f4'),...                             ('z', 'f4')])&gt;&gt;&gt; face = numpy.array([([0, 1, 2], 255, 255, 255),...                     ([0, 2, 3], 255,   0,   0),...                     ([0, 1, 3],   0, 255,   0),...                     ([1, 2, 3],   0,   0, 255)],...                    dtype=[('vertex_indices', 'i4', (3,)),...                           ('red', 'u1'), ('green', 'u1'),...                           ('blue', 'u1')])&gt;&gt;&gt;```Once you have suitably structured array, the static method`PlyElement.describe` can then be used to create the necessary`PlyElement` instances:```Python Console&gt;&gt;&gt; el = PlyElement.describe(vertex, 'vertex')&gt;&gt;&gt;```or```Python Console&gt;&gt;&gt; el = PlyElement.describe(vertex, 'vertex',...                          comments=['comment1',...                                    'comment2'])&gt;&gt;&gt;```Note that there's no need to create `PlyProperty` instances explicitly.This is all done behind the scenes by examining `some_array.dtype.descr`.One slight hiccup here is that variable-length fields in a `numpy` array(i.e., our representation of PLY list properties)must have a type of `object`, so the types of the list length and valuesin the serialized PLY file can't be obtained from the array's `dtype`attribute alone.  For simplicity and predictability, the lengthdefaults to 8-bit unsigned integer, and the value defaults to 32-bitsigned integer, which covers the majority of use cases.  Exceptions mustbe stated explicitly:```Python Console&gt;&gt;&gt; el = PlyElement.describe(face, 'face',...                          val_types={'vertex_indices': 'u2'},...                          len_types={'vertex_indices': 'u4'})&gt;&gt;&gt;```Now you can instantiate `PlyData` and serialize:```Python Console&gt;&gt;&gt; PlyData([el]).write('some_binary.ply')&gt;&gt;&gt; PlyData([el], text=True).write('some_ascii.ply')&gt;&gt;&gt;&gt;&gt;&gt; # Force the byte order of the output to big-endian, independently of&gt;&gt;&gt; # the machine's native byte order&gt;&gt;&gt; PlyData([el],...         byte_order='&gt;').write('some_big_endian_binary.ply')&gt;&gt;&gt;&gt;&gt;&gt; # Use a file object. Binary mode is used here, which will cause&gt;&gt;&gt; # Unix-style line endings to be written on all systems.&gt;&gt;&gt; with open('some_ascii.ply', mode='wb') as f:...     PlyData([el], text=True).write(f)&gt;&gt;&gt;```## Miscellaneous### CommentsHeader comments are supported:```Python Console&gt;&gt;&gt; ply = PlyData([el], comments=['header comment'])&gt;&gt;&gt; ply.comments['header comment']&gt;&gt;&gt;```As of version 0.3, &quot;obj_info&quot; comments are supported as well:```Python Console&gt;&gt;&gt; ply = PlyData([el], obj_info=['obj_info1', 'obj_info2'])&gt;&gt;&gt; ply.obj_info['obj_info1', 'obj_info2']&gt;&gt;&gt;```When written, they will be placed after regular comments after the&quot;format&quot; line.Comments can have leading whitespace, but trailing whitespace may bestripped and should not be relied upon.  Comments may not containembedded newlines.### Getting a two-dimensional array from a list propertyThe PLY format provides no way to assert that all the data for a givenlist property is of the same length, yet this is a relatively commonoccurrence.  For example, all the &quot;vertex_indices&quot; data on a &quot;face&quot;element will have length three for a triangular mesh.  In such cases,it's usually much more convenient to have the data in a two-dimensionalarray, as opposed to a one-dimensional array of type `object`.  Here's apretty easy way to obtain a two dimensional array, assuming we know therow length in advance:```Python Console&gt;&gt;&gt; plydata = PlyData.read('tet.ply')&gt;&gt;&gt; tri_data = plydata['face'].data['vertex_indices']&gt;&gt;&gt; triangles = numpy.vstack(tri_data)&gt;&gt;&gt;```### Instance mutabilityA plausible code pattern is to read a PLY file into a `PlyData`instance, perform some operations on it, possibly modifying data andmetadata in place, and write the result to a new file.  This pattern ispartially supported.  As of version 0.4, the following in-placemutations are supported:- Modifying numerical array data only.- Assigning directly to a `PlyData` instance's `elements`.- Switching format by changing the `text` and `byte_order` attributes of  a `PlyData` instance.   This will switch between `ascii`,  `binary_little_endian`, and `binary_big_endian` PLY formats.- Modifying a `PlyData` instance's `comments` and `obj_info`, and  modifying a `PlyElement` instance's `comments`.- Assigning to an element's `data`.  Note that the property metadata in  `properties` is not touched by this, so for every property in the  `properties` list of the `PlyElement` instance, the `data` array must  have a field with the same name (but possibly different type, and  possibly in different order).  The array can have additional fields as  well, but they won't be output when writing the element to a PLY file.  The properties in the output file will appear as they are in the  `properties` list.  If an array field has a different type than the  corresponding `PlyProperty` instance, then it will be cast when  writing.- Assigning directly to an element's `properties`.  Note that the  `data` array is not touched, and the previous note regarding the  relationship between `properties` and `data` still applies: the field  names of `data` must be a subset of the property names in  `properties`, but they can be in a different order and specify  different types.- Changing a `PlyProperty` or `PlyListProperty` instance's `val_dtype`  or a `PlyListProperty` instance's `len_dtype`, which will perform  casting when writing.Modifying the `name` of a `PlyElement`, `PlyProperty`, or`PlyListProperty` instance is not supported and will raise an error.  Torename a property of a `PlyElement` instance, you can remove theproperty from `properties`, rename the field in `data`, and re-add theproperty to `properties` with the new name by creating a new`PlyProperty` or `PlyListProperty` instance:```Python Console&gt;&gt;&gt; from plyfile import PlyProperty, PlyListProperty&gt;&gt;&gt; face = plydata['face']&gt;&gt;&gt; face.properties = ()&gt;&gt;&gt; face.data.dtype.names = ['idx', 'r', 'g', 'b']&gt;&gt;&gt; face.properties = (PlyListProperty('idx', 'uchar', 'int'),...                    PlyProperty('r', 'uchar'),...                    PlyProperty('g', 'uchar'),...                    PlyProperty('b', 'uchar'))&gt;&gt;&gt;```Note that it is always safe to create a new `PlyElement` or `PlyData`instance instead of modifying one in place, and this is the recommendedstyle:```Python Console&gt;&gt;&gt; # Recommended:&gt;&gt;&gt; plydata = PlyData([plydata['face'], plydata['vertex']],...                   text=False, byte_order='&lt;')&gt;&gt;&gt;&gt;&gt;&gt; # Also supported:&gt;&gt;&gt; plydata.elements = [plydata['face'], plydata['vertex']]&gt;&gt;&gt; plydata.text = False&gt;&gt;&gt; plydata.byte_order = '&lt;'&gt;&gt;&gt; plydata.comments = []&gt;&gt;&gt; plydata.obj_info = []&gt;&gt;&gt;```Objects created by this library don't claim ownership of the otherobjects they refer to, which has implications for both styles (creatingnew instances and modifying in place).  For example, a single`PlyElement` instance can be contained by multiple `PlyData` instances,but modifying that instance will then affect all of those containing`PlyData` instances.### Text-mode streamsInput and output on text-mode streams is supported for ASCII-formatPLY files, but not binary-format PLY files. Input and output onbinary streams is supported for all valid PLY files. Note that`sys.stdout` and `sys.stdin` are text streams, so they can only beused directly for ASCII-format PLY files.# FAQ## How do I initialize a list property from two-dimensional array?```Python Console&gt;&gt;&gt; # Here's a two-dimensional array containing vertex indices.&gt;&gt;&gt; face_data = numpy.array([[0, 1, 2], [3, 4, 5]], dtype='i4')&gt;&gt;&gt;&gt;&gt;&gt; # PlyElement.describe requires a one-dimensional structured array.&gt;&gt;&gt; ply_faces = numpy.empty(len(face_data),...                         dtype=[('vertex_indices', 'i4', (3,))])&gt;&gt;&gt; ply_faces['vertex_indices'] = face_data&gt;&gt;&gt; face = PlyElement.describe(ply_faces, 'face')&gt;&gt;&gt;```## Can I save a PLY file directly to `sys.stdout`?Yes, for an ASCII-format PLY file. For binary-format files, it won'twork directly, since `sys.stdout` is a text-mode stream and binary-formatfiles can only be output to binary streams. (ASCII-format files can beoutput to text or binary streams.)There are a few ways around this.- Write to a named file instead. On Linux and some other Unix-likes, you  can access `stdout` via the named file `/dev/stdout`:    ```Python Console    &gt;&gt;&gt; plydata.write('/dev/stdout')  # doctest: +SKIP    ```- Use `sys.stdout.buffer`:    ```Python Console    &gt;&gt;&gt; plydata.write(sys.stdout.buffer)  # doctest: +SKIP    ```  (source: https://bugs.python.org/issue4571)## Can I read a PLY file from `sys.stdin`?The answer is exactly analogous to the situation with writing to`sys.stdout`: it works for ASCII-format PLY files but not binary-formatfiles. The two workarounds given above also apply: use a named file like`/dev/stdin`, or use `sys.stdin.buffer`.# Design philosophy and rationaleThe design philosophy of `plyfile` can be summed up as follows.- Be familiar to users of `numpy` and reuse existing idioms and concepts  when possible.- Favor simplicity over power or user-friendliness.- Support all valid PLY files.## FamiliarityFor the most part, PLY concepts map nicely to Python and specifically to`numpy`, and leveraging that has strongly influenced the design of thispackage.  The `elements` attribute of a `PlyData` instance is simply a`list` of `PlyElement` instances, and the `data` attribute of a`PlyElement` instance is a `numpy` array, and a list property field of aPLY element datum is referred to in the `data` attribute by a type of`object` with the value being another `numpy` array, etc.## SimplicityWhen applicable, we favor simplicity over power or user-friendliness.Thus, list property types in `PlyElement.describe` always default to thesame, rather than, say, being obtained by looking at an array element.(Which element?  What if the array has length zero?  Whatever default wecould choose in that case could lead to subtle edge-case bugs if theuser isn't vigilant.)  Also, all input and output is done in &quot;one shot&quot;:all the arrays must be created up front rather than being processed in astreaming fashion.## Generality and interpretation issuesWe aim to support all valid PLY files. However, exactly what constitutesa &quot;valid&quot; file isn't obvious, since there doesn't seem to be a singlecomplete and consistent description of the PLY format.  Even the&quot;authoritative&quot;[Ply.txt](https://web.archive.org/web/20161221115231/http://www.cs.virginia.edu/~gfx/Courses/2001/Advanced.spring.01/plylib/Ply.txt)by Greg Turk has some issues.### Comment placementWhere can comments appear in the header?  It appears that in all the&quot;official&quot; examples, all comments immediately follow the &quot;format&quot; line,but the language of the document neither places any such restrictionsnor explicitly allows comments to be placed anywhere else.  Thus, itisn't clear whether comments can appear anywhere in the header or mustimmediately follow the &quot;format&quot; line.  At least one popular reader ofPLY files chokes on comments before the &quot;format&quot; line.  `plyfile`accepts comments anywhere in the header in input but only places them ina few limited places in output, namely immediately after &quot;format&quot; and&quot;element&quot; lines.### Element and property namesAnother ambiguity is names: what strings are allowed as PLY element andproperty names?  `plyfile` accepts as input any name that doesn'tcontain spaces, but this is surely too generous.  This may not be sucha big deal, though: although names are theoretically arbitrary, inpractice, the majority of PLY element and property names probably comefrom a small finite set (&quot;face&quot;, &quot;x&quot;, &quot;nx&quot;, &quot;green&quot;, etc.).### Property syntaxA more serious problem is that the PLY format specification appears tobe inconsistent regarding the syntax of property definitions.  Insome examples, it uses the syntax    property {type} {name}and in others,    property {name} {type}`plyfile` only supports the former, which appears to be standard _defacto_.### Header line endingsThe specification explicitly states that lines in the header mustend with carriage returns, but this rule doesn't seem to be followed byanyone, including the C-language PLY implementation by Greg Turk, theauthor of the format.  Here, we stick to common practice and outputUnix-style line endings (with no carriage returns) but accept any lineending style in input files.# More examplesExamples beyond the scope of this document and the tests are in the`examples` directory.# LicenseCopyright Darsh Ranjan.This software is released under the terms of the GNU General PublicLicense, version 3.  See the file `COPYING` for details.</longdescription>
</pkgmetadata>