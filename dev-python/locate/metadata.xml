<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># LocateThis library provides three callables:- `this_dir()` returns the directory of the current Python file, or when using from an interactive session, it returns  the current working directory.- `append_sys_path(relative_path)` allows importing from a location relative to the running Python file by  resolving `relative_path` relative to `this_dir()` and appending it to `sys.path` (e.g. `relative_path=&quot;../foo/bar&quot;`).  This also works as a context manager to allow temporary effect (e.g. `with append_sys_path(&quot;foo&quot;): ...`).- `prepend_sys_path(relative_path)` is the same as `append_sys_path`, but prepending `sys.path` in order to be the first  import location for Python to search rather than the last.## SafetyThe `*_sys_path` destructors (when exiting the with block) are safe from any side effect your package imports may haveon `sys.path`. It's not a naive implementation such as removing the first/last element or removing the element by value;it employs a string subclass with an additional `id` property to keep tags of `sys.path` insertions. It is, therefore,completely safe and allows for any further nesting of `with *_sys_path` within the import tree.## Examples### Input```pythonimport locatefrom pathlib import Paththis_dir = locate.this_dir()print(f&quot;This file is located in: {this_dir}&quot;)print()# Create files to demonstrate importing from a directoryfoo = Path(locate.this_dir(), &quot;foo&quot;)foo.mkdir(exist_ok=True)Path(foo, &quot;bar1.py&quot;).write_text(&quot;print('Importing bar1')&quot;)Path(foo, &quot;bar2.py&quot;).write_text(&quot;print('Importing bar2')&quot;)Path(foo, &quot;bar3.py&quot;).write_text(&quot;print('Importing bar3')&quot;)Path(foo, &quot;bar4.py&quot;).write_text(&quot;print('Importing bar4')&quot;)# Changing sys.path temporarilywith locate.prepend_sys_path(&quot;foo&quot;):    print(f&quot;I can temporarily import from: {Path(this_dir, 'foo')}&quot;)    import bar1    print()print(f&quot;I can no longer import from: {Path(this_dir, 'foo')}&quot;)try:    import bar2except ImportError:    print(&quot;Cannot import bar2&quot;)print()# Changing sys.path permanentlylocate.prepend_sys_path(&quot;foo&quot;)print(f&quot;I can now always import from: {Path(this_dir, 'foo')}&quot;)import bar3import bar4print()```### Output```This file is located in: C:\Users\simonI can temporarily import from: C:\Users\simon\fooImporting bar1I can no longer import from: C:\Users\simon\fooCannot import bar2I can now always import from: C:\Users\simon\fooImporting bar3Importing bar4```## MotivationThis package is for people who frequently use the directory of their scripts for storing files and custom modules and donot want their pipeline to break from an interactive shell. This is based on how Julia thinks about the immediatedirectory through its [@\_\_DIR\_\_](https://docs.julialang.org/en/v1/base/base/#Base.@__DIR__) macro.`locate.this_dir()` is defined as:- When running a `.py` file, this is the file's base directory.- When running an `.ipyn` notebook, this is the current working directory. This is the desired/expected result since  Jupyter sets the working directory as the `.ipynb` base directory by default.- When running in a REPL, this is also the current working directory. This is similar to  Julia's [@\_\_DIR\_\_](https://docs.julialang.org/en/v1/base/base/#Base.@__DIR__) macro.## Other considerationsFor a good discussion on retrieving the current Python path, see https://stackoverflow.com/questions/3718657</longdescription>
</pkgmetadata>