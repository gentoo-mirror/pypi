<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>|test| |release| |pypi|mmmeta======``mmmeta`` is a command-line toolkit and python library to incrementallysynchronize file metadata between an **archive** that stores all filesand their metadata, **publishers** that add new files to the archive and**consumers** that process these files (or a subset of them).It’s better explained by a concrete example:**Publisher** incrementally scrapes documents and stores them withmetadata in the **archive**.**Consumer** wants to import some files by a given filter criterion andkeep track of the ones that are already imported.As such file collections grow, we only want to transfer as less data aspossible between **archive**, **publisher** and **consumer**.synopsis--------To clarify the terms used in this manual:-  **files**: actual files (like pdfs…)-  **metadata files**: json files that contain metadata for actual files-  **archive**: the “source of truth” where files, metadata files and   metadata db are stored.-  **publisher**: an application that adds new files to the **archive**-  **consumer**: an application that processes the files from   **archive** (with read-only access)-  **state db**: sqlite database, stored only on **consumers**, tracking   local state for files-  **metadir**: a directory named ``_mmmeta`` that is   `synced &lt;#synchronization&gt;`__ between **archive**, **publishers** and   **consumers**-  `store &lt;#store&gt;`__: A simple implementation of a key-value store for   additional informationUsage-----Archive~~~~~~~The archive can be any file-like (remote) location for the actual files,their *metadata files* and the *metadir*. **Publishers** would needwrite access to it, **Consumers** only need read-only.``mmmeta`` usually doesn’t operate on the archive itself (as it would bemost likely just a data bucket), instead, maintaining the archive isdone by **publishers**Publisher~~~~~~~~~An application that writes to the archive. This can be for example ascraper that incrementally adds new files.The usual workflow would look like this:1. `synchronize &lt;#synchronization&gt;`__ *metadir* from archive2. Run application (e.g. scraper) optionally based on synced metadata3. Update *metadir* (see below)4. `synchronize &lt;#synchronization&gt;`__ *metadir* back to archiveupdating *metadir*^^^^^^^^^^^^^^^^^^::   mmmeta generateThis will loop through all json files in the current directory andcreate or add csv data in ``./_mmmeta/db/``For other path locations, see `initialization &lt;#initialization&gt;`__managing files presence^^^^^^^^^^^^^^^^^^^^^^^Per default, ``mmmeta generate`` only adds new files based on the*metadata files* available (it doesn’t even check the presence of theactual files). To “clean up” (e.g. delete non-existing files), the cliinterface provides the following options:::     --replace       Completly replace the meta database     --ensure        Ensure metadata files are present, soft-delete non-existing     --ensure-files  Ensure actual files are present (for local store only),                     soft-delete non-existing     --no-meta       Read in actual files instead of json metadata filesConsumer~~~~~~~~An application that processes the files, e.g. import them into adatabase.``mmmeta`` is used to merge *remote* metadata into the local *state db*(sqlite) and provides some functionallity to query and manage this datain applications.The usual workflow would look like this:1. `synchronize &lt;#synchronization&gt;`__ *metadir* from archive2. Update local *state db* (see below)3. Run application that alters local state (see example below)update local state db^^^^^^^^^^^^^^^^^^^^^via cli:::   mmmeta updateor via python:.. code:: python   from mmmeta import mmmeta   m = mmmeta()   m.update()For other path locations, see `initialization &lt;#initialization&gt;`__consumer application^^^^^^^^^^^^^^^^^^^^The ``files`` object on a metadir is a wrapper to a `datasettable &lt;https://dataset.readthedocs.io/en/latest/api.html#table&gt;`__ withall its functionallity, with the addition that it yields``mmmeta.file.File`` objects that have a bit extra functionality likedirectly saving and access to “proxy values” (see config below).. code:: python   from mmmeta import mmmeta   m = mmmeta()   for file in m.files(document_type=&quot;contract&quot;, imported=False):       download_url = file.remote.url  # see config below       process_download(download_url)       file[&quot;downloaded&quot;] = True       file.save()See `config &lt;#remote&gt;`__ on how to generate remote urls or urisInitialization~~~~~~~~~~~~~~When **mmmeta** is `initialized &lt;#initialization&gt;`__ with a pathargument named ``foo``, the directory ``foo/_mmmeta`` will be the*metadir*The path ``foo`` can be set via env var:::   MMMETA=./foo/ mmmeta updateor in scripts:.. code:: python   from mmmeta import mmmeta   m = mmmeta(&quot;./foo/&quot;)On `publishers &lt;#publishers&gt;`__ there is an additional env var``MMMETA_FILES_ROOT`` if the location for the *actual files* isdifferent.Synchronization---------------This package is totally agnostic about the remote storage backend (couldbe a local filesystem location or cloud storage) and doesn’t handle anyof the local &lt;-&gt; remote synchronization.Therefore the synchronization of the *metadir* ``./foo/_mmmeta`` is upto you with the tool of your choice.Config------``mmmeta`` can optionally have a config stored in``./foo/_mmmeta/config.yml``Example (all settings are optional):.. code:: yaml   metadata:     file_name: _file_name  # key in json metadat for file name     include:  # only include these keys from json metadata in meta db     - reference     - modified_at     - title     - originators     - publisher:name  # nested keys are flattened with &quot;:&quot; between them     unique: content_hash  # unqiue identifier for files   remote:  # simple string replacement to generate `File.remote.&lt;attr&gt;` attributes, like:     url: https://my_bucket.s3.eu-central-1.amazonaws.com/foo/bar/{_file_name}     uri: s3://my_bucket/foo/bar/{_file_name}remote~~~~~~The configuration section ``remote`` from above ensures that the fileobjects have attributes to access the actual files from the remote:.. code:: python   from mmmeta import mmmeta   m = mmmeta()   for file in m.files:       print(file.remote.uri)Store-----``mmmeta`` ships with a simple key-value-store that can be used by boththe *remote* and *client* to store some additional data. The store livesin the *metadir* ``./foo/_mmmeta/_store``You can store any values in it:.. code:: python   from mmmeta import mmmeta   m = mmmeta(&quot;./path/to/metadir/&quot;)   m.store[&quot;new_files&quot;] = 17any machine that `synchronizes &lt;#synchronization&gt;`__ the metadir canread these values:.. code:: python   from mmmeta import mmmeta   m = mmmeta(&quot;./path/to/metadir/&quot;)   new_files = m.store[&quot;new_files&quot;]  # 17For storing timestamps, there is a shorthand via the ``touch`` function:.. code:: python   m.touch(&quot;my_ts_key&quot;)This will save the value of the current ``datetime.now()`` to the key``my_ts_key``. The values are typed (``int``, ``float`` or``timestamp``), so you can easily do something like this:.. code:: python   from mmmeta import mmmeta   m = mmmeta(&quot;./path/to/metadir/&quot;)   if m.store[&quot;remote_last_updated&quot;] &gt; m.store[&quot;local_last_updated&quot;]:       # run scraperInstallation------------Requires python3. Virtualenv use recommended.Additional dependencies will be installed automatically:::   pip install mmmetaAfter this, you should be able to execute in your terminal:::   mmmeta --helpYou should as well be able to import it in your python scripts:.. code:: python   from mmmeta import mmmetacli---.. code:: bash   Usage: mmmeta [OPTIONS] COMMAND [ARGS]...   Options:     --metadir TEXT     Base path for reading meta info and storing state                        [default: &lt;current/working/dir&gt;]     --files-root TEXT  Base path for actual files to generate metadir from                        [default: &lt;current/working/dir&gt;]     --help             Show this message and exit.   Commands:     generate     inspect     updatedevelopement------------Install testing requirements:::   make installTest:::   make test.. |test| image:: https://github.com/simonwoerpel/mmmeta/actions/workflows/test.yml/badge.svg   :target: https://github.com/simonwoerpel/mmmeta/actions/workflows/test.yml.. |release| image:: https://github.com/simonwoerpel/mmmeta/actions/workflows/release.yml/badge.svg   :target: https://github.com/simonwoerpel/mmmeta/actions/workflows/release.yml.. |pypi| image:: https://github.com/simonwoerpel/mmmeta/actions/workflows/publish.yml/badge.svg   :target: https://github.com/simonwoerpel/mmmeta/actions/workflows/publish.yml</longdescription>
</pkgmetadata>