<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![doc](https://img.shields.io/badge/-Documentation-blue)](https://advestis.github.io/transparentpath)[![License: GPL v3](https://img.shields.io/badge/License-GPL%20v3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)#### Status[![pytests](https://github.com/Advestis/transparentpath/actions/workflows/pull-request.yml/badge.svg)](https://github.com/Advestis/transparentpath/actions/workflows/pull-request.yml)[![push-pypi](https://github.com/Advestis/transparentpath/actions/workflows/push-pypi.yml/badge.svg)](https://github.com/Advestis/transparentpath/actions/workflows/push-pypi.yml)[![push-doc](https://github.com/Advestis/transparentpath/actions/workflows/push-doc.yml/badge.svg)](https://github.com/Advestis/transparentpath/actions/workflows/push-doc.yml)![maintained](https://img.shields.io/badge/Maintained%3F-yes-green.svg)![issues](https://img.shields.io/github/issues/Advestis/transparentpath.svg)![pr](https://img.shields.io/github/issues-pr/Advestis/transparentpath.svg)#### Compatibilities![ubuntu](https://img.shields.io/badge/Ubuntu-supported--tested-success)![unix](https://img.shields.io/badge/Other%20Unix-supported--untested-yellow)![Windows](https://img.shields.io/badge/Windows-basic--untested-important)![python](https://img.shields.io/pypi/pyversions/transparentpath)This package is not maintained for python 3.6 anymore. The latest version available for python 3.6 is 0.1.129.It should work on Python 3.7, even though it is not tested with it. Please use python == 3.8. Python 3.9 and abovefail to create the tar.gz.##### Contact[![linkedin](https://img.shields.io/badge/LinkedIn-Advestis-blue)](https://www.linkedin.com/company/advestis/)[![website](https://img.shields.io/badge/website-Advestis.com-blue)](https://www.advestis.com/)[![mail](https://img.shields.io/badge/mail-maintainers-blue)](mailto:pythondev@advestis.com)## TransparentPathA class that allows one to use a path in a local file system or a Google Cloud Storage (GCS) file system in thesame way one would use a *pathlib.Path* object. One can use many different GCP projects at once.### RequirementsYou will need GCP credentials, either as a *.json* file, that you can set in the envvar GOOGLE_APPLICATION_CREDENTIALS, orby running directly in a google cloud instance (VM, pods, etc...).  ### InstallationYou can install this package with pip :```bashpip install transparentpath```### Optional packagesThe vanilla version allows you to declare paths and work with them. You can use them in the builtin `open` method. Optionally, you can also install support for several other packages like pandas, dask, etc... the currently available optionnal packages are accessible through the follownig commands: ```bashpip install transparentpath[pandas]pip install transparentpath[parquet]pip install transparentpath[hdf5]pip install transparentpath[json]pip install transparentpath[excel]pip install transparentpath[dask]```you can install all of those at once```bashpip install transparentpath[all]```### UsageCreate a path that points to GCS, and one that does not:```pythonfrom transparentpath import Path# Or : from transparentpath import TransparentPathp = Path(&quot;gs://mybucket/some_path&quot;, token=&quot;some/cred/file.json&quot;)p2 = p / &quot;foo&quot;  # Will point to gs://mybucket/some_path/foop3 = Path(&quot;bar&quot;)  # Will point to local path &quot;bar&quot;```Set all paths to point to GCS by default:```pythonfrom transparentpath import PathPath.set_global_fs(&quot;gcs&quot;, token=&quot;some/cred/file.json&quot;)p = Path(&quot;mybucket&quot;) / &quot;some_path&quot; # Will point to gs://mybucket/some_pathp2 = p / &quot;foo&quot;  # Will point to gs://mybucket/some_path/foop3 = Path(&quot;bar&quot;, fs=&quot;local&quot;)  # Will point to local path &quot;bar&quot;p4 = Path(&quot;other_bucket&quot;)  # Will point to gs://other_bucket (assuming other_bucket is a bucket on GCS)p5 = Path(&quot;not_a_bucket&quot;)  # Will point to local path &quot;not_a_bucket&quot; (assuming it is indeed, not a bucket on GCS)```Set all paths to point to severral GCS projects by default:```pythonfrom transparentpath import PathPath.set_global_fs(&quot;gcs&quot;, token=&quot;some/cred/file.json&quot;)Path.set_global_fs(&quot;gcs&quot;, token=&quot;some/other/cred/file.json&quot;)p = Path(&quot;mybucket&quot;) / &quot;some_path&quot; # Will point to gs://mybucket/some_pathp2 = p / &quot;foo&quot;  # Will point to gs://mybucket/some_path/foop3 = Path(&quot;bar&quot;, fs=&quot;local&quot;)  # Will point to local path &quot;bar&quot;p4 = Path(&quot;other_bucket&quot;)  # Will point to gs://other_bucket (assuming other_bucket is a bucket on GCS)p5 = Path(&quot;not_a_bucket&quot;)  # Will point to local path &quot;not_a_bucket&quot; (assuming it is indeed, not a bucket on GCS)```Here, *mybucket* and *other_bucket* can be on two different projects, as long as at least one of thecredential files can access them.Set all paths to point to GCS by default, and specify a default bucket:```pythonfrom transparentpath import PathPath.set_global_fs(&quot;gcs&quot;, bucket=&quot;mybucket&quot;, token=&quot;some/cred/file.json&quot;)p = Path(&quot;some_path&quot;)  # Will point to gs://mybucket/some_path/p2 = p / &quot;foo&quot;  # Will point to gs://mybucket/some_path/foop3 = Path(&quot;bar&quot;, fs=&quot;local&quot;)  # Will point to local path &quot;bar&quot;p4 = Path(&quot;other_bucket&quot;)  # Will point to gs://mybucket/other_bucketp5 = Path(&quot;not_a_bucket&quot;)  # Will point to gs://mybucket/not_a_bucket```The latest option is interesting if you have a code that should be able to run with paths being sometimes remote, sometimes local.To do that, you can use the class attribute `nas_dir`. Then when a path is created, if it starts by `nas_dir`'s path, `nas_dir`'s path is replaced by the bucket name. This is useful if, for instance, you have a backup of a bucket locally at let's say */my/local/backup*. Then you can do:```pythonfrom transparentpath import PathPath.nas_dir = &quot;/my/local/backup&quot;Path.set_global_fs(&quot;gcs&quot;, bucket=&quot;mybucket&quot;, token=&quot;some/cred/file.json&quot;)p = Path(&quot;some_path&quot;)  # Will point to gs://mybucket/some_path/p3 = Path(&quot;/my/local/backup&quot;) / &quot;some_path&quot;  # Will ALSO point to gs://mybucket/some_path/``````pythonfrom transparentpath import PathPath.nas_dir = &quot;/my/local/backup&quot;# Path.set_global_fs(&quot;gcs&quot;, bucket=&quot;mybucket&quot;, token=&quot;some/cred/file.json&quot;)p = Path(&quot;some_path&quot;)  # Will point to /my/local/backup/some_path/p3 = Path(&quot;/my/local/backup&quot;) / &quot;some_path&quot;  # Will ALSO point to /my/local/backup/some_path/```In all the previous examples, the `token` argument can be ommited if the environment variable**GOOGLE_APPLICATION_CREDENTIALS** is set and point to a *.json* credential file, or if your code runs on a GCP machine(VM, cluster...) with access to GCS.No matter whether you are using GCS or your local file system, here is a sample of what TransparentPath can do:```pythonfrom transparentpath import Path# Path.set_global_fs(&quot;gcs&quot;, bucket=&quot;bucket_name&quot;, project=&quot;project_name&quot;)# The following lines will also work with the previous line uncommented # Reading a csv into a pandas' DataFrame and saving it as a parquet filemypath = Path(&quot;foo&quot;) / &quot;bar.csv&quot;df = mypath.read(index_col=0, parse_dates=True)otherpath = mypath.with_suffix(&quot;.parquet&quot;)otherpath.write(df)# Reading and writing a HDF5 file works on GCS and on local:import numpy as npmypath = Path(&quot;foo&quot;) / &quot;bar.hdf5&quot;  # can be .h5 toowith mypath.read() as ifile:    arr = np.array(ifile[&quot;store1&quot;])# Doing '..' from 'foo/bar.hdf5' will return 'foo'# Then doing 'foo' + 'babar.hdf5' will return 'foo/babar.hdf5' ('+' and '/' are synonymes)mypath.cd(&quot;..&quot;)  # Does not return a path but modifies inplacewith (mypath  + &quot;babar.hdf5&quot;).write(None) as ofile:    # Note here that we must explicitely give 'None' to the 'write' method in order for it    # to return the open HDF5 file. We could also give a dict of {arr: &quot;store1&quot;} to directly    # write the file.    ofile[&quot;store1&quot;] = arr# Reading a text file. Can also use 'w', 'a', etc... also works with binaries.mypath = Path(&quot;foo&quot;) / &quot;bar.txt&quot;with open(mypath, &quot;r&quot;) as ifile:    lines = ifile.readlines()# open is overriden to understand gs://with open(&quot;gs://bucket/file.txt&quot;, &quot;r&quot;) as ifile:    lines = ifile.readlines()mypath.is_file()mypath.is_dir()mypath.is_file()files = mypath.parent.glob(&quot;*.csv&quot;)  # Returns a Iterator[TransparentPath], can be casted to list```As you can see from the previous example, all methods returning a path from a TransparentPath return a TransparentPath.#### DaskTransparentPath supports writing and reading Dask dataframes from and to csv, excel, parquet and HDF5, both locally andremotely. You need to have dask-dataframe and dask-distributed installed, which will be the case if you ran `pip install transparentpath[dask]`. Writing Dask dataframes does not require any additionnal arguments to be passedfor the type will be checked before calling the appropriate writting method. Reading however requires you to pass the *use_dask* argument to the `read()` method. If the file to read is HDF5, you will also need to specify *set_names*, matching the argument *key* of Dask's `read_hdf()` method.Note that if reading a remote HDF5, the file will be downloaded in your local tmp, then read. If not using Dask, the file is deleted after being read. But since Dask uses delayed processes, deleting the file might occure before the file is actually read, so the file is kept. Up to you to empty your /tmp directory if it is not done automatically by your system.### BehaviorAll instances of TransparentPath are absolute, even if created with relative paths.TransparentPaths are seen as instances of str: ```pythonfrom transparentpath import Pathpath = Path()isinstance(path, str)  # returns True``` This is required to allow ```pythonfrom transparentpath import Pathpath = Path()with open(path, &quot;w/r/a/b...&quot;) as ifile:    ...```to work. If you want to check whether path is actually a TransparentPath and nothing else, use ```pythonfrom transparentpath import Pathpath = Path()assert type(path) == Pathassert issubclass(path, Path)```instead.Any method or attribute valid in fsspec.implementations.local.LocalFileSystem, gcs.GCSFileSystem, pathlib.Path or strcan be used on a TransparentPath object.### Warnings#### Warnings about GCS behaviourif you use GCS:  1. Remember that directories are not a thing on GCS.  2. You do not need the parent directories of a file on GCS to create the file : they will be created if they do not  exist (that is not true localy however).  3. If you delete a file that was alone in its parent directories, those directories disapear.  4. If a file exists at the same path than a directory, then TransparentPath is not able to know which one is the  file and which one is the directory, and will raise a TPMultipleExistenceError upon object creation. This  check for multiplicity is done at almost every method in case an exterior source created a duplicate of the  file/directory. This case can't happen locally. However, it can happen on remote if the cache is not updated  frequently. Doing this check can significantly increase computation time (if using glob on a directory  containing a lot of files for example). You can deactivate it either globally (TransparentPath._do_check =  False and TransparentPath._do_update_cache = False), for a specific path (pass nockeck=True at path  creation), or for glob and ls by passing fast=True as additional argument.#### SpeedTransparentPath on GCS is slow because of the verification for multiple existance and the cache updating.However one can tweak those a bit. As mentionned earlier, cache updating and multiple existence check can bedeactivated for all paths by doing```pythonfrom transparentpath import TransparentPathTransparentPath._do_update_cache = FalseTransparentPath._do_check = False```They can also be deactivated for one path only by doing```pythonp = TransparentPath(&quot;somepath&quot;, nocheck=True, notupdatecache=True)```It is also possible to specify when to do those check : at path creation, path usage (read, write, exists...) or both. Here to it can be set on all paths or only some : ```pythonTransparentPath._when_checked = {&quot;created&quot;: True, &quot;used&quot;: False}  # Default valueTransparentPath._when_updated = {&quot;created&quot;: True, &quot;used&quot;: False}  # Default valuep = TransparentPath(  &quot;somepath&quot;, when_checked={&quot;created&quot;: False, &quot;used&quot;: False}, notupdatecache={&quot;created&quot;: False, &quot;used&quot;: False})```There is also an expiration time in seconds for check and update : the operation is not done if it was done not along time ago. Those expiration times are of 1 second by default and can be changed through :```pythonTransparentPath._check_expire = 10TransparentPath._update_expire = 10p = TransparentPath(&quot;somepath&quot;, check_expire=0, update_expire=0)```glob() and ls() have their own way to be accelerated : ```pythonp.glob(&quot;/*&quot;, fast=True)p.ls(&quot;&quot;, fast=True)```Basically, `fast=True` means &quot;do not check and do not update the cache&quot; for all the items found by the method.#### builtin openBuiltin `open()` is overloaded by TransparentPath to support giving a TransparentPath to it. If a method in a package you did not create uses `open()` in a *with* statement, everything should work out of the box with a TransparentPath. However, if it uses the **output** of `open()`, you will have to create a class to override this method and anything using its ouput. Indeed, `open()` returns a file descriptor, not an IO, and I did not find a way to access file descriptors on gcs. For example, in the FileLock package, the `acquire()` method calls the`_acquire()` method which calls `os.open()`, so I had to do that:```pythonfrom filelock import FileLockfrom transparentpath import TransparentPath as Pathclass MyFileLock(FileLock):    def _acquire(self):        tmp_lock_file = self._lock_file        if not type(tmp_lock_file) == Path:            tmp_lock_file = Path(tmp_lock_file)        try:            fd = tmp_lock_file.open(&quot;x&quot;)        except (IOError, OSError, FileExistsError):            pass        else:            self._lock_file_fd = fd        return None```The original method was:```pythonimport os...def _acquire(self):    open_mode = os.O_WRONLY | os.O_CREAT | os.O_EXCL | os.O_TRUNC    try:        fd = os.open(self._lock_file, open_mode)    except (IOError, OSError):        pass    else:        self._lock_file_fd = fd    return None...```I tried to implement a working version of any method valid in pathlib.Path or in file systems, but futur changesin any of those will not be taken into account quickly. You can report missing supports by opening an issue.</longdescription>
</pkgmetadata>