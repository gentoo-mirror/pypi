<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>htmldoom========[![Documentation](https://api.netlify.com/api/v1/badges/8bedc4f4-508a-494d-8160-02f6a76d4b04/deploy-status)](https://app.netlify.com/sites/htmldoom/deploys)[![PyPI version](https://img.shields.io/pypi/v/htmldoom.svg)](https://pypi.org/project/htmldoom)[![PyPI pyversions](https://img.shields.io/pypi/pyversions/htmldoom.svg)](https://pypi.org/project/htmldoom)[![Build Status](https://travis-ci.org/sayanarijit/htmldoom.svg?branch=master)](https://travis-ci.org/sayanarijit/htmldoom)[![codecov](https://codecov.io/gh/sayanarijit/htmldoom/branch/master/graph/badge.svg)](https://codecov.io/gh/sayanarijit/htmldoom)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/python/black)Introducing htmldoom-----------------------[htmldoom](https://github.com/sayanarijit/htmldoom) is an HTML rendering framework for Python that helps you define yourHTML documents, templates, layouts and contents in an organised way, gives youthe flexibility to use many different syntaxes, option to declare and debugdifferent components and pages separately and more... all without making youworry about the runtime performance.How does it work?-----------------Understanding the working principle will get pretty intuitive if we go onefeature at a time. Let's start with HTML escaping.### HTML escapingIn the center of htmldoom's functionality is the HTML escaping logic. Texts tobe escaped are represented using `str`, while texts that should not be escapedare represented using `bytes`. The `htmldoom.renders()` function receives thetexts as inputs, then for each input, it decides whether to escape it or notbased on if it is `str` or `bytes` and returns the rendered text in `str` format.We can use `htmldoom.txt()` to convert some string into HTML escaped text, and`htmldoom.raw()` to convert some string into HTML unescaped text. It should benoted that both the functions will return text formatted in `bytes` which can bepassed to the `htmldoom.render()` to render it back to `str`.### HTML elementsHTML elements or tags can be defined using the `htmldoom.composite_tag()` andthe `htmldoom.leaf_tag()` functions. Any tag that can have child elements (e.g.`&lt;p&gt;&lt;/p&gt;`) are defined using `htmldoom.composite_tag()`.For example:p = composite_tag(&quot;p&quot;)Tags that cannot have child elements are defined using `htmldoom.leaf_tag()`.For example:input_ = leaf_tag(&quot;input&quot;)So when we call `p(class_=&quot;red&quot;)(&quot;foo&quot;, &quot;bar&quot;)` or `input_(type_=&quot;button&quot;)`,we get `bytes` encoded `&lt;p class=&quot;red&quot;&gt;foobar&lt;/p&gt;` or`&lt;input type=&quot;button&quot; /&gt;` respectively. The `htmldoom.render()` function willrender them back to `str`.### HTML components / layoutsHTML components i.e. combination of several elements (tags and texts) can bedefined using the `@htmldoom.renders()` decorator like below.from htmldoom import renders, elements as e@renders(    e.p(class_=&quot;red&quot;)(&quot;{key1}&quot;, &quot;{key2}&quot;),    e._input(type_=&quot;button&quot;))def my_component(value1, value2):    return {&quot;key1&quot;: value1, &quot;key2&quot;: value2}Now we can render the component by calling it with the required arguments e.g.my_document(value1=&quot;&amp;amp;&quot;, value2=b&quot;&amp;amp;&quot;)This will return a `bytes` encoded text. The `value1` will be escaped to `&amp;amp;amp;` sinceit is `str`. `value2` is in `bytes`, hence it will remain the same and wil berendered in the browser as `&amp;`.Calling this will return `bytes` encoded text&lt;p class=&quot;red&quot;&gt;foobar&lt;/p&gt;&lt;input type=&quot;button&quot; /&gt;which can be rendered into string using `htmldoom.render()`.This mechanism renders the template text during module load time. Hence there should beno performance drop in runtime.&gt; NOTE: It is important to note that every `{` and `}` should be escaped with `{{` and`}}` when it is not being used as a placeholder for some variable.It is also possible to define the components using `yaml` syntax like below.some:  demo:    p:    - class: red    - - &quot;{key1}&quot;      - &quot;{key2}&quot;    input:    - type: buttonAnd then define the component renderer like below.from htmldoom import rendersfrom htmldoom.yaml_loader import loadyaml@renders(loadyaml(&quot;path/to/component.yaml&quot;, (&quot;some&quot;, &quot;demo&quot;)))def my_component(value1, value2):    return {&quot;key1&quot;: value1, &quot;key2&quot;: value2}We can also use escaped and raw loaders with the `htmldoom.loadtxt()` and `htmldoom.loadraw()`functions respectively. We only need to pass the file path as shown in the `yaml` example.We can use the same syntax to define reusable layouts.### Separating values from templateshtmldoom provides us with a friendly way to separate values from layouts or componentstemplates. The `htmldoom.value_loader.loadvalues()` function scans the given directory andreturns a nested namedtuple with the file or directory names as element names and the loadedcontents as the values. We can pass this to components like below.from htmldoom import renders, elements as efrom htmldoom.value_loader import loadvaluesvalues = loadvalues(&quot;path/to/values&quot;)@renders(    e.p()(&quot;{v.title}&quot;),    e.p()(&quot;{v.content.line1}&quot;)    e.p()(&quot;{v.content.line2}&quot;)    e.p()(&quot;{v.content.line3}&quot;))def my_component():    return {&quot;v&quot;: values}So we need a directory structure like below.values├── title.txt└── content    ├── line1.txt    ├── line2.html    └── line3.ymlAs you mught have guessed, this can load the values based of file types. You can useyour own renderer for file types such as `md` or `rst` by extending the`htmldoom.value_loader.EXTENSION_RENDERERS` map and passing is to the`htmldoom.value_loader.loadvalues()` function like below.from htmldoom import rawfrom htmldoom.value_loader import loadvalues, EXTENSION_RENDERERSdef markdown_to_html(path):    &quot;&quot;&quot;Some function that reads the file, converts the content to HTML,    and returns the converted data as string.    &quot;&quot;&quot;    # The logic goes here...MY_EXTENSION_RENDERERS = dict(    md=lambda path: raw(markdown_to_html(path)),    **EXTENSION_RENDERERS)values = loadvalues(&quot;path/to/values&quot;, extension_renderers=MY_EXTENSION_RENDERERS)In fact, this documentation is generated using the same method.</longdescription>
</pkgmetadata>