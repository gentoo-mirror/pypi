<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># ODetaM[![Test](https://github.com/rickh94/ODetaM/actions/workflows/test.yml/badge.svg)](https://github.com/rickh94/ODetaM/actions/workflows/test.yml)[![codecov](https://codecov.io/gh/rickh94/odetam/branch/main/graph/badge.svg?token=BLDIMHU9FB)](https://codecov.io/gh/rickh94/odetam)A simple ODM (Object Document Mapper) for [Deta Base](https://deta.sh) base on[pydantic](https://github.com/samuelcolvin/pydantic/).## Installation`pip install odetam`## UsageCreate pydantic models as normal, but inherit from `DetaModel` instead of pydantic BaseModel. You will need to set the environment variable `DETA_PROJECT_KEY` to your Deta project key so that databases can be accessed/created, instead you are working under deta initialized project. Your also can specify Deta project key in Config class of your model, for migration from Deta Cloud or importing external Collection (read [DetaBase Docs](https://deta.space/docs/en/basics/data)) This is a secret key, so handle it appropriately (hence the environment variable).Bases will be automatically created based on model names (changed from PascalCase/CamelCase case to snake_case). A `key` field (Deta's unique id) will be automatically added to any model. You can supply the key on creation, or Deta will generate one automatically and it will be added to the object when it is saved.## Async SupportAsync/await is now supported! As of version 1.2.0, you can now `from odetam.async_model import AsyncDetaModel`, inherit from that, and run all the examples below just the same, but with `await` in front of the calls.You must `pip install deta[async]`, to use asynchronous base.### Get All`DetaModel.get_all()` should handle large bases better now, but you should consider querying instead of getting everything if possible, because it isunlikely to perform well on large bases.## Example### Basics```pythonimport datetimefrom typing import Listfrom odetam import DetaModelclass Captain(DetaModel):    name: str    joined: datetime.date    ships: List[str]# createkirk = Captain(        name=&quot;James T. Kirk&quot;,        joined=datetime.date(2252, 1, 1),        ships=[&quot;Enterprise&quot;],        )sisko = Captain(        name=&quot;Benjamin Sisko&quot;,        joined=datetime.date(2350, 1, 1),        ships=[&quot;Deep Space 9&quot;, &quot;Defiant&quot;],        )# initial save, key is now setkirk.save()# update the objectkirk.ships.append(&quot;Enterprise-A&quot;)# save again, this will be an updatekirk.save()sisko.save()Captain.get_all()# [#     Captain(#         name=&quot;James T. Kirk&quot;, #         joined=datetime.date(2252, 01, 01), #         ships=[&quot;Enterprise&quot;, &quot;Enterprise-A&quot;],#         key=&quot;key1&quot;,#     ),#     Captain(#         name=&quot;Benjamin Sisko&quot;,#         joined=datetime.date(2350, 01, 01), #         ships=[&quot;Deep Space 9&quot;, &quot;Defiant&quot;],#         key=&quot;key2&quot;,#     ),# ]Captain.get(&quot;key1&quot;)# Captain(#     name=&quot;James T. Kirk&quot;, #     joined=datetime.date(2252, 01, 01), #     ships=[&quot;Enterprise&quot;, &quot;Enterprise-A&quot;],#     key=&quot;key1&quot;,# )Captain.get(&quot;key3&quot;)# Traceback (most recent call last):#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;# odetam.exceptions.ItemNotFoundCaptain.get_or_none(&quot;key3&quot;)# NoneCaptain.query(Captain.name == &quot;James T. Kirk&quot;)# Captain(#     name=&quot;James T. Kirk&quot;, #     joined=datetime.date(2252, 01, 01), #     ships=[&quot;Enterprise&quot;, &quot;Enterprise-A&quot;],#     key=&quot;key1&quot;,# )Captain.query(Captain.ships.contains(&quot;Defiant&quot;))# Captain(#     name=&quot;Benjamin Sisko&quot;,#     joined=datetime.date(2350, 01, 01),#     ships=[&quot;Deep Space 9&quot;, &quot;Defiant&quot;],# )Captain.query(Captain.name.prefix(&quot;Ben&quot;))# Captain(#     name=&quot;Benjamin Sisko&quot;,#     joined=datetime.date(2350, 01, 01),#     ships=[&quot;Deep Space 9&quot;, &quot;Defiant&quot;],# )kirk.delete()Captain.delete_key(&quot;key2&quot;)Captain.get_all()# []# you can also save several at once for better speedCaptain.put_many([kirk, sisko])# [#     Captain(#         name=&quot;James T. Kirk&quot;, #         joined=datetime.date(2252, 01, 01), #         ships=[&quot;Enterprise&quot;, &quot;Enterprise-A&quot;],#         key=&quot;key1&quot;,#     ),#     Captain(#         name=&quot;Benjamin Sisko&quot;,#         joined=datetime.date(2350, 01, 01), #         ships=[&quot;Deep Space 9&quot;, &quot;Defiant&quot;],#         key=&quot;key2&quot;,#     ),# ]```### Async model```pythonimport datetimefrom typing import Listfrom odetam.async_model import AsyncDetaModelclass Captain(AsyncDetaModel):    name: str    joined: datetime.date    ships: List[str]async foo():    items = await Captain.get_all()```### Config```pythonclass Captain(AsyncDetaModel):    name: str    joined: datetime.date    ships: List[str]    class Config:        table_name = &quot;my_custom_table_name&quot;        deta_key = &quot;123_123&quot; # project key from Deta Cloud or Data Key from another Deta Space project```## SaveModels have the `.save()` method which will always behave as an upsert, updating a record if it has a key, otherwise creating it and setting a key. Deta has pure insert behavior, but it's less performant. If you need it, please open a pull request.## QueryingAll basic comparison operators are implemented to map to their equivalents as `(Model.field &gt;= comparison_value)`. There is also a `.contains()` and `.not_contains()` method for strings and lists of strings, as well as a `.prefix()` method for strings. There is also a `.range()` for number types that takes a lower and upper bound. You can also use `&amp;`  as AND and `|` as OR. ORs cannot be nested within ands, use a list of options as comparison instead. You can use as many ORs as you want, as long as they execute after the ANDs in the order of operations. This is due to how the Deta Base api works.## Deta BaseDirect access to the base is available in the dunder attribute `__db__`, though the point is to avoid that.## Exceptions - `DetaError`: Base exception when anything goes wrong. - `ItemNotFound`: Fairly self-explanatory... - `InvalidDetaQuery`: Something is wrong with queries. Make sure you aren't using queries with unsupported types</longdescription>
</pkgmetadata>