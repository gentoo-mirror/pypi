<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># django-json-api[![PyPI version](https://badge.fury.io/py/django-json-api.svg)](https://badge.fury.io/py/django-json-api)[![codecov](https://codecov.io/gh/share-work/django-json-api/branch/develop/graph/badge.svg?token=hTGA39HrJV)](https://codecov.io/gh/share-work/django-json-api)[![Reveal](https://circleci.com/gh/reveal-co/django-json-api.svg?style=shield&amp;circle-token=727d6ee289cf310d7f2a473d02574506f6ea8ef7)](https://app.circleci.com/pipelines/github/reveal-co/django-json-api)[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)**django-json-api** uses Django's ORM interfaces as inspiration to serialize, request anddeserialize entities from databases of other microservices using (and benefiting from) the[JSON:API](https://jsonapi.org/) specification.## InstallationTo install via pip:```shpip install django-json-api```You can also install from the source:```shgit clone git@github.com:reveal-co/django-json-api.gitcd django-json-apigit checkout mainpip install -e .```## Getting startedSuppose you have a `django.db.models.Model` class inside microservice A, such as:```pythonfrom django.db import modelsclass Company(models.Model):    name = models.CharField(max_length=256)    domain = models.CharField(max_length=256)    deleted_at = models.DateTimeField(null=True, default=None)```If you wish to consume it from microservice B, first add this inside the aforementioned model'sdefinition:```python    class JSONAPIMeta:        resource_name = 'companies'```and define an instance of a `django_json_api.models.JSONAPIModel` inside microservice B:```pythonfrom django_json_api.models import JSONAPIModelfrom django_json_api.fields import Attributeclass Company(JSONAPIModel):    class Meta:        api_url = MICROSERVICE_A_API_URL        resource_type = 'companies'    name = Attribute()    domain = Attribute()```PS: `api_url` expects a url with protocol (i.e. starting with `http(s)://`) and ending with a trailing slash `/`.Now, querying companies from microservice B is as easy as:```python  Company.objects.all()  Company.objects.filter(name=&quot;Reveal&quot;)  Company.objects.iterator()  ...```You can also have entities in one microservice relate to entities in another by leveraging both `RelatedJSONAPIField`and `WithJSONAPIQuerySet`. Take a look at this model definition from microservice B:```pythonfrom django.db import modelsfrom django_json_api.django import RelatedJSONAPIFieldclass User(models.Model):    name = models.CharField(max_length=256)    company = RelatedJSONAPIField(json_api_model=Company)    deleted_at = models.DateTimeField(null=True, default=None)```Here, `Company` is the `JSONAPIModel` defined above. This makes it possible, when querying for a user, to alsofetch its related company:```pythonuser = User.objects.get(pk=1)user.company # This will be resolved through an underlying HTTP request```In case of larger querysets, you might want to prefetch the relations as you do with django's `prefetch_related`. Forthat, you imbue `User`'s manager using `WithJSONApiQuerySet`, which will grant the manager a newmethod: `prefetch_jsonapi`.If the remote microservice API supports PATCH request, you can save a record's attributes:```pythonuser = User.objects.get(pk=1)print(user.name)  # Joeuser.name = &quot;Jack&quot;user.save(update_fields=[&quot;name&quot;]) # This will perform a PATCH HTTP requestupdated_user = User.from_cache(pk=1)print(updated_user.name)  # Jack: the updated record with its new attributes is cached```## AuthenticationIt is possible to path a `auth` parameter to the `JSONAPIClient` in order to dynamically set the authorization headers onrequests before sending them to the remote HTTP server.In a similar way, it is possible to specify `auth` in the models' `Meta`.```pythonimport jwtimport timeclass CustomJWTAuth:    def __init__(self: &quot;CustomJWTAuth&quot;, subject: str, secret: str, audience: str) -&gt; None:    self.audience = audience    self.secret = secretself.subject = subject    def __call__(self: &quot;CustomJWTAuth&quot;, request: requests.Request) -&gt; requests.Request:        iat = int(time.time())    token = jwt.encode(    {&quot;sub&quot;: self.subject, &quot;iat&quot;: iat, &quot;exp&quot;: iat + 60, &quot;aud&quot;: self.audience},    self.secret,    &quot;HS256&quot;,)request.headers[&quot;Authorization&quot;] = f&quot;Bearer {token}&quot;return request# This client will generate a new signed JWT for each requestclient = JSONAPIClient(auth=CustomJWTAuth(&quot;myService&quot;, &quot;*******&quot;, &quot;jsonapi&quot;))# This model will rely on JWT as well when fetching data from the remote serviceclass ModelWithJWT(JSONAPIModel):    class Meta:        resource_type = &quot;examples&quot;        auth = CustomJWTAuth(&quot;myService&quot;, &quot;*****&quot;, &quot;jsonapi&quot;)```## License[MIT](LICENSE)</longdescription>
</pkgmetadata>