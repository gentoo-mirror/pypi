<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>==========================logging-formatter-anticrlf==========================--------------------------------------------------------------------------Python logging Formatter for CRLF Injection (CWE-93 / CWE-117) prevention--------------------------------------------------------------------------logging Formatter to sanitize CRLF errors (CWE-93, some forms of CWE-117)This class is a drop-in replacement for ``logging.Formatter``, and has theexact same construction arguments. However, as a final step of formatting alog line, it escapes carriage returns (\\r) and linefeeds (\\n).By default, these are replaced with their escaped equivalents (see `Examples`_),but the ``replacements`` dictionary can be modified to change this behavior.This sanitization should solve CWE-93 errors and CRLF-based versions ofCWE-117. Some CWE-117 errors are concerns about e.g. XSS flaws in logs thatare likely to be viewed in a browser; this formatter can't handle everyform of CWE-117.Installation============::    pip install logging-formatter-anticrlfExamples========::    import anticrlf    handler = logging.StreamHandler(sys.stderr)    handler.setFormatter(anticrlf.LogFormatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))    logger = logging.getLogger(__name__)    logger.addHandler(handler)    logger.setLevel(logging.INFO)    logger.info(&quot;Example text with a newline\nhere&quot;)This results in::    2017-02-03 08:43:52,557 - __main__ - INFO - Example text with a newline\nhereWhereas with the default ``Formatter``, it would be::    2017-02-03 08:43:52,557 - __main__ - INFO - Example text with a newline    hereIf you wanted newlines to be replaced with \\x0A instead, you could::    formatter = anticrlf.LogFormatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')    formatter.replacements[&quot;\n&quot;] = &quot;\\x0A&quot;  # Note the double backslash for literal!    handler.setFormatter(formatter)Changing Replacements=====================The ``replacements`` field of the formatter is a ``SubstitutionMap`` object that behaveslike a ``dict`` with a few exceptions designed to help developers avoid making insecure mistakes.Specifically:* an &quot;empty&quot; ``SubstitutionMap`` object will contain the default mappings for CR and LF chars* calling ``del`` on either the CR or LF key will *reset the value* rather than *delete* the key* any attempt to create a key-value pair that results in any value containing any of the keys  will raise an ``UnsafeSubstitutionError``The rationale for the last item is that the keys of the ``replacements`` field are stringsthat are considered unsafe. Replacing one unsafe string with another defeats the purpose ofusing this module.Additionally, if you assign a regular ``dict`` to the ``replacements`` field, and try to logsomething using that configuration, ``anticrlf.LogFormatter`` will reset the ``replacements``field to its default value and issue a ``UserWarning`` to that effect.That means the following::    formatter.replacements[&quot;\n&quot;] = &quot;\\x0A&quot;  # replace LF chars with '\x0A'    del formatter.replacements[&quot;\n&quot;]        # return to replacing LF with '\n'    formatter.replacements[&quot;\t&quot;] = &quot;\\t&quot;    # replace tabs with '\t'    formatter.replacements[&quot;\n&quot;] = &quot;&lt;\t&gt;&quot;   # raises UnsafeSubstitutionErrorThe last occurs because the value ``&lt;\t&gt;`` contains ``\t``, which was previously created as a key.And::    formatter.replacements = { &quot;\n&quot;: &quot;\r&quot; }  # this is a mistake!    logger.info(&quot;example&quot;)Will result, if that logger is using that formatter, in ``replacements`` being returned to itssafe default value and a ``UserWarning`` about that being issued.</longdescription>
</pkgmetadata>