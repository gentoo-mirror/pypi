<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Welcome to python-Rex=====================.. image:: https://pypip.in/v/python-rex/badge.png   :target: https://crate.io/packages/python-rex.. image:: https://pypip.in/d/python-rex/badge.png   :target: https://crate.io/packages/python-rex.. image:: https://travis-ci.org/cypreess/python-rex.png?branch=master   :target: https://travis-ci.org/cypreess/python-rex.. image:: https://coveralls.io/repos/cypreess/python-rex/badge.png?branch=master   :target: https://coveralls.io/r/cypreess/python-rex?branch=master   Python **Rex** is regular expressions for humans. (**Rex** is also abbreviation from **re** **X** tended).**Rex** is for the `re standard module &lt;http://docs.python.org/2/library/index.html&gt;`_ as`requests &lt;http://docs.python-requests.org/en/latest/&gt;`_ is for `urllib module &lt;http://docs.python.org/2/library/urllib.html&gt;`_.**Rex** also is `latin for &quot;king&quot; &lt;http://en.wikipedia.org/wiki/Rex&gt;`_, and the king of regular expressions is Perl.So **Rex** API tries to mimic at least some Perl's idioms.Supported Python versions: 2.6, 2.7, 3.3Installation============::    pip install python-rexor::      pip install -e git+https://github.com/cypreess/python-rex.git#egg=rex-devThere are no external dependencies. ::      from rex import rexQuickstart==========Do that::   from rex import rex   print (&quot;Your ticket number: XyZ-1047. Have fun!&quot; == rex(&quot;/[a-z]{3}-(\d{4})/i&quot;))[1]    instead of doing that::   import re   regex = re.compile(&quot;[a-z]{3}-(\d{4})&quot;, flags=re.IGNORECASE)   m = regex.search(&quot;Your ticket number: XyZ-1047. Have fun!&quot;)      if m is not None:      print m.group(1)   else:      print None      # or in shorter way   print m.group(1) if m else None(both should print ``1047``).Docs====So far **Rex** supports:* simple matching (first match),* substitution,* all python re flags.Matching --------The most obvious usage - test condition by matching to string::    if 'This is a dog' == rex('/dog/'):        print 'Oh yeah'or::    if 'My lucky 777 number' == rex('/[0-9]+/'):        print 'Number found'You can use Perl notation and prepend ``m`` character to your search::    if 'My lucky 777 number' == rex('m/[0-9]+/'):        print 'Number found'but you can also simply check your match::    if ('My lucky 777 number' == rex('m/[0-9]+/'))[0] == '777':        print 'Number found'or even groups::    if ('My lucky 777 number' == rex('m/(?P&lt;number&gt;[0-9]+)/'))['number'] == '777':        print 'Number found'Remember a mess with re module when it does not match anything? Rex won't let you down,it will kindly return ``None`` for whatever you ask::    &gt;&gt;&gt; print ('My lucky 777 number' == rex('m/(?P&lt;number&gt;[0-9]+)/'))['no_such_group']    None    &gt;&gt;&gt; print (&quot;I don't tell you my lucky number&quot; == rex('m/(?P&lt;number&gt;[0-9]+)/'))['number']    NoneSubstituting------------Substitution can be made by prefixing pattern with ``s`` character (like in perl expression)::    &gt;&gt;&gt; print &quot;This is a cat&quot; == rex('s/CAT/dog/i')    This is a dogFlags-----Every **Rex** pattern as in Perl patterns allows to suffix some flags, e.g. ``rex('/pattern/iu')`` for enabling ``i`` and ``u`` flag. **Rex** supports all standard python re flags:* ``d`` - re.DEBUG* ``i`` - re.IGNORECASE* ``l`` - re.LOCALE* ``m`` - re.MULTILINE* ``s`` - re.DOTALL* ``u`` - re.UNICODE* ``x`` - re.VERBOSECaching-------**Rex** caches all patterns so reusing patterns is super fast. You can always clear **Rex** cache by calling ``rex_clear_cache()`` ordisable caching for specific patterns ``rex('/pattern/', cache=False)``.Rex for orthodox----------------If you are so orthodox pythonist that couldn't leave with overloaded ``==`` operator syntax in your codebase,you can use &quot;orthodox mode&quot; of rex. Just put the string to match/substitute against as a second argument::    &gt;&gt;&gt; bool(rex(&quot;/dog/&quot;, &quot;This is a dog&quot;))    True    &gt;&gt;&gt; rex(&quot;s/cat/dog/&quot;, &quot;This is a cat&quot;)    'This is a dog'Additionally Rex objects are callable. This is especially useful in situations where you need to process many valuesagainst the same regular expression::    &gt;&gt;&gt; my_re = rex(&quot;/foo/&quot;)    &gt;&gt;&gt; for thing in [&quot;foobar&quot;, &quot;bar&quot;, &quot;barfoo&quot;]:    ...     print bool(my_re(thing))    True    False    True</longdescription>
</pkgmetadata>