<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># IntroductionNaludaq (Nalu Data Acquisition) is a backend software package to communicate with Nalu Scientifics hardware. It contains several modules to communicate with the boards, both sending commands, receiving responses and receiving bulk data. It also contains modules to parse and store data.This module is designed to interact with a user interface or used to create automated experiments.The package is designed around the board object, a software representation of the hardware board. It contains a map of the registers found on the hardware system with a mirror of all values sent and received from the board, a connection object handling the connections, and all parameters describing the board. See the `board` section.In the package are different modules, they are designed in layers. Connections and daq are the lowest level, the communications module is one step abstracted with english names for the hardware registers and command builders to send register updates and commands to the board.Above that are controllers, controlling different aspects of the board. The software the user develops should build on top of the controllers primarily and rare cases should a user have to use the communication module.A Quick rundown:The controllers are the modules the users should use to build their interfaces.The controllers manipulate the registers on the FPGA using the communication layer. This is a set of tools to update the different registers on the FPGA.The communication layers communication with the hardware using the connection.There is a mirroring between the hardware board and the software board. The software board carries a mirror of all the params and the connection.A factory supplies the connection to the SW board since the connection can be ethernet, uart or usb.# Getting StartedThis backend is intended to be integrated with either NaluCommand (command line tools), NaluScope (Graphical user interface) or jupyter notebooks.To run the Naludaq standalone you will have to install the package.```pip install naludaq```To install the latest version of the master branch.It is then possible to import the package in your notebook or python script.```pyimport naludaq```## PrerequisitesTo start using the Naludaq as a standalone it's highly recommended to have a virtual envirnoment setup.As a user or developer you will need to run python version 3.9 or later.See the instructions below in the Development installation section.A hardware board is also recommended, it's possible to use the software without hardware using the demo board. It's a software replica with limited functionality.# Development installationThis is the prefered method to get a developement environment up and running.1. Install [Miniconda](https://docs.conda.io/en/latest/miniconda.html).2. Create and activate a virtual envirnoment, minimum Python version is 3.9.```conda create -n nalu-dev python=3.9conda activate nalu-dev```Then pull the repository into a suitable folder:```git clone http://github.com/NaluScientific/naludaq.gitcd naludaq```To get the development environment up and running you have to install the package as an editable package:```pip install -e .[dev]```The package can now be imported in your project and edited in your favorite editor, [VS Code](https://code.visualstudio.com/)## Development with gigabit ethernet backendTo use the gigabit ethernet backend you will need to install the `naludaq_rs` package.1. Clone the package from GitHub2. install the package as an editable package. See instructions in the `naludaq_rs` package.## Pre-commitThis project uses pre-commit hooks to make sure the code is following the style guide.To install the pre-commit hooks, run the following command:```pip install pre-commitpre-commit install```The hooks will run automatically when you commit changes to the repository.The code MUST run the pre-commit hooks before commiting. If the hooks fail, the commit will be rejected.# ExamplesSee the [example repository](https://github.com/NaluScientific/naluexamples).# Development UseOnce the package is installed it's now possible to start using the package.There is a boilerplate interface named `Naludaq` in `naludaq` it contains basic functionality.It's a good starting point to get the software started.If more advanced scripts are required please continue reading below.A datasheet for the board is also required to understand the registers and the commands.# Generate DocumentationThe documentation is auto-generated using sphinx. These are the steps to generate the documentation based on the current base.If major changes are made in the code base the documentation need to re-generated, se `Setup generating documentation` below.To generate the html verison of the documentation navigate to the project folder.```cd docspip install sphinxpip install sphinx_rtd_thememake html```Generating pdf requires more prerequisites. On Windows install [MikTex](https://miktex.org/) and [Perl](http://strawberryperl.com/).From the MikTex console install the ``latexmk`` addon.```cd docspip install sphinxpip install sphinx_rtd_thememake latexpdf```The documentation is generated to the build folder under docs.More settings for the documentation are found in `docs/source/conf.py`.# Command Line UseThe `naludaq` comes with an easy interface conveniently called `naludaq`.It contains high level functionality to operate the board without having to dig deeper into the framework.Startup:```pyimport osfrom naludaq.board import Boardboard_model = &quot;asocv3&quot;board = Board(board_model)working_dir = os.path.curdirnd = naludaq.NaluDaq(board, working_dir)```The naludaq object can then be used to setup the board and readout data.# Package structure```.├── src/naludaq|   ├── backend|   ├── board|   ├── communication|   ├── controllers|   ├── daq|   ├── helpers|   ├── io|   ├── models|   ├── parsers|   └── tools├── tests|   └── ...├── CHANGELOG.md├── LICENSE.txt├── pyproject.toml└── README.md```## BoardThe board module is a state holder for the application and is a software replica of the settings on the hardware board. It holds the connection to the hardware and stores all the settings sent to the hardware. This is a work around since not all registers can be read out.The board is created by a factory taking a connection information dictionary and the board model.The board holds 3 main parts.- parameters describing the hardwares properties, these paramters are used to describe the protocol to parse the captured data and they also determines sampling rate, connections available.- a connection object (optional),- a register map (optional) describing the layout, name and addresses of the different hardware registers.Nalu uses a default register file repository called NaluConfigs which contains the default registers. For everyday use the defaults are the perfect choice and are loaded by leaving out a filepath to the register- and clockfile when loading them.Example:```pyfrom naludaq.board import Board, startup_board# Create a board object for an ASoCv2 boardboard = Board(    'asocv2',    registers= &quot;asocv2.yml&quot; # Can be ommitted if default registers are used    clock= &quot;asocv2_clock.txt&quot; # Can be ommited if default clockprogram is used, accepts pathlib paths.)# Create a connection to the board.board.get_uart_connection(comport=&quot;COM5&quot;, baud=115200)# Or if the FTDI driver is present:board.get_ftdi_connection(serial_number=&quot;XYZ123&quot;, baud=115200)# Run the startup sequence to program the board.startup_board(board)```## CommunicationThe communication module is currently split up in 5 parts depending on what part of the hardware they control. The analog and digital registers control different aspects of the ASICs and the control registers communicate with the FPGA. The i2c talk to the onboard auxillary electronics. While serial is a helper to the analog and digital register, it contains functions to communicate with the ASICs using the serial interface rather than the default parallel. Certain versions of the boards don't have a parallel connection between the FPGA and the ASIC and the serial interface must be used.The communication module is not intended to be used standalone but is used by the controllers.The Analog, Digital, and Control registers, have a common API.Usage:```pywith board as brd:  # Opens a connection to the board    # Write all registers    DigitalRegister(board).write_all()    # Write a specific register    DigitalRegister(board).write(name, value)    # Read all registers    DigitalRegister(board).read_all()    # Read a specific registers    DigitalRegister(board).read(name)```For Control and Digital registers it's possible to read data out from hardware.```py# Returns a dictionary {reg_name: reg_map}# where reg_map is {&quot;value&quot;: value, &quot;address&quot;: addr, &quot;bitposition&quot;: bitposition, &quot;bitwidth&quot;: bitwidth, &quot;readwrite&quot;: read/write, &quot;description&quot;: desc}values_dict = DigitalRegister(board).read_all()# Returns the register map {&quot;value&quot;: value, &quot;address&quot;: addr, &quot;bitposition&quot;: bitposition, &quot;bitwidth&quot;: bitwidth, &quot;readwrite&quot;: read/write, &quot;description&quot;: desc}value = DigitalRegister(board).read(name)```## ControllersThe controllers control one aspects of the board functionality. This means there is one controller for each hardware function on the board.Important to remember that higher level scripts use controllers to orchestrate behaviors such as reading out data, capturing pedestals, scanning trigger levels. This higher level functionalities can be found inThe controllers contains functions to control lower level functionality of the boards, the controllers are recepies to send specific commands to the boards in a certain order to set the mode or state of the board.There are multiple aspects of the board operations and each onboard component or functional aspect has it's own controller. This way it's possible to create custom scripts or extend functionality easily by using thsi code.The following controllers are available:- `board`- `connection`- `external`- `pedestals`- `peripherals`- `project`- `readout`- `si5341`- `trigger`Example:```pyfrom naludaq.controllers.board import get_board_controllerbrd_ctrl = get_board_controller(board)brd_ctrl.start_readout(**readout_params)```or```pyfrom naludaq.controllers.trigger import get_trigger_controllertrigger_ctrl = get_trigger_controller```## DAQThe Data AcQuisition (DAQ) module captures the data stream from the board and processes it.Workers are submodules running as either threads or processes processing aspects of the data stream.The parsers converts the binary data stream to python readable data.There are different types of DAQ objects depending on use.```pyfrom naludaq.daq import get_daqlocation = '/home/username/subfolder' # Linux storage path, replace with yoursdaq = get_daq(board, parsed =False, debug=False, location, start_workers=True)```To parse the return data, you'll need a parser for the board specific protocol.```pyfrom naludaq.parsers import get_parserparams = {    &quot;model&quot;: # Must have, the model of the board used, determines protocol    &quot;samples&quot;: # amount of samples per windows,    &quot;windows&quot;: # max amount of windows the board can readout,    &quot;channels&quot;: # max amount of channels    &quot;data_bitmask&quot;: # how many bits of data we have in a 16-bit package.    &quot;num_lastbits&quot; # how many bits in the bottom to remove    &quot;num_footer&quot;: # how long is the footer at the end of package (xFACE is 2)    &quot;num_evt_headers&quot;: # How many 16-bit packages are event headers in the begining    &quot;num_channel_headers&quot; # How meany headers for each channel    &quot;num_window_headers&quot;: # Header at the end of a window (1-4 channels), currently only AARDVARCv3.}parser = get_parser(params)```Or use the board.params as the input for `get_parser`The DAQ module contains the Preprocessing submodule which is used to process the raw data from the DAQ into human readble data.The preprococessing module wil parse, pedestals correct, timing correct, and ADC2mV convert the data depending on configuration.```pyfrom naludaq.daq.preprocess import PreprocessingPreprocess(board).run(    to_process: dict,  # (Event)    correct_pedestals: bool,    convert_mv: bool,    correct_time: bool,    convert_time: bool,    process_in_place: bool,)```## HelpersContains helper functions.### ExceptionsThere a multiple exceptions unique to the naludaq package. They are found under helpers.exceptions.When developing use these exceptions if they fit. Feel free to create your own if you need to.## ModelsContains a datatype suited for experiments with this package. It's called Acquisition.It's an extended Python [deque](https://docs.python.org/3/library/collections.html#collections.deque).It's designed to hold the events and it stores the pedestals and all the paramters used to capture the data.## ParsersThe hardware sends data in bytes. The return data must be parsed before it can be interpreted. The dataformat is depent on the chip and/or firmware. Select a parser be importing `get_parser(model)`.## ToolsThis module contains higher level tools that changes multiple behaviours of the board such as calibrations and pedestals.# Running the TestsThe tests are using [pytest](https://github.com/pytest-dev/pytest)To run the tests simply do:```pytest tests\```The tests tests the internal package logic and use pytest-mocker to mock the hardware. Actual hardware testing is done manually.# Coding styleAll code is linted with pylint and follow pep8. The code is styled using Google's [style guide](http://google.github.io/styleguide/pyguide.html).Before making any contributions to this package please make sure you lint the code and make sure the documentation follows the style guide. The only exception is the 100 col line width instead of 80.Before commiting code to this repository make use black to autoformat the code:```pip install blackblack naludaq```# VersioningWe use [SemVer](http://semver.org) for versioning. For the versions available, see the [tags](https://github.com/NaluScientific/naludaq/tags) on this repositorySee the [CHANGELOG.rst](CHANGELOG.rst)# Authors* **Ben Rotter*** **Marcus Luck*** **Mitchell Matsumori-Kelly*** **Thomas Yang*** **Alvin Yang*** **Kenneth Laurtizen*** **Emily Lum**# LicenseThis project is licensed under the LGPL License - see the [LICENSE.txt](LICENSE.txt) file for details# Acknowledgments* Hat tip to anyone whose code was used* Inspiration</longdescription>
</pkgmetadata>