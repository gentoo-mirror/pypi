<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>lsm===Fast Python bindings for [SQLite's LSM key/value store](http://www.sqlite.org/src4/doc/trunk/www/lsmusr.wiki&gt;).The LSM storage engine was initially written as part of the experimentalSQLite4 rewrite (now abandoned). More recently, the LSM source code was movedinto the SQLite3 [source tree](https://www.sqlite.org/cgi/src/dir?ci=e148cdad35520e66&amp;name=ext/lsm1)and has seen some improvements and fixes. This project uses the LSM code fromthe SQLite3 source tree.Features:* Embedded zero-conf database.* Keys support in-order traversal using cursors.* Transactional (including nested transactions).* Single writer/multiple reader MVCC based transactional concurrency model.* On-disk database stored in a single file.* Data is durable in the face of application or power failure.* Thread-safe.* Releases GIL for read and write operations  (each connection has own mutex)* Page compression (lz4 or zstd)* Zero dependency static library* Python 3.x.Limitations:The source for Python lsm is[hosted on GitHub](https://github.com/mosquito/python-lsm).If you encounter any bugs in the library, please[open an issue](https://github.com/mosquito/python-lsm/issues/new),including a description of the bug and any related traceback.## Quick-startBelow is a sample interactive console session designed to show some of thebasic features and functionality of the ``lsm`` Python library.To begin, instantiate a `LSM` object, specifying a path to a database file.&lt;!--  name: test_example_db --&gt;```pythonfrom lsm import LSMdb = LSM('test.ldb')assert db.open()```More pythonic variant is using context manager:&lt;!--  name: test_example_db_context_manager --&gt;```pythonfrom lsm import LSMwith LSM(&quot;test.ldb&quot;) as db:    assert db.info()```Not opened database will raise a RuntimeError:&lt;!--  name: test_example_db --&gt;```pythonimport pytestfrom lsm import LSMdb = LSM('test.ldb')with pytest.raises(RuntimeError):    db.info()```### Binary/string modeYou should select mode for opening the database with ``binary: bool = True``argument.For example when you want to store strings just pass ``binary=False``:&lt;!--  name: test_binary_mode --&gt;```pythonfrom lsm import LSMwith LSM(&quot;test_0.ldb&quot;, binary=False) as db:    # must be str for keys and values    db['foo'] = 'bar'    assert db['foo'] == &quot;bar&quot;```Otherwise, you must pass keys and values ad ``bytes`` (default behaviour):&lt;!--  name: test_string_mode --&gt;```pythonfrom lsm import LSMwith LSM(&quot;test.ldb&quot;) as db:    db[b'foo'] = b'bar'    assert db[b'foo'] == b'bar'```### Key/Value Features``lsm`` is a key/value store, and has a dictionary-like API:&lt;!--  name: test_getitem --&gt;```pythonfrom lsm import LSMwith LSM(&quot;test.ldb&quot;, binary=False) as db:    db['foo'] = 'bar'    assert db['foo'] == 'bar'```Database apply changes as soon as possible:&lt;!--  name: test_get_del_item --&gt;```pythonimport pytestfrom lsm import LSMwith LSM(&quot;test.ldb&quot;, binary=False) as db:    for i in range(4):         db[f'k{i}'] = str(i)    assert 'k3' in db    assert 'k4' not in db    del db['k3']    with pytest.raises(KeyError):        print(db['k3'])```By default, when you attempt to look up a key, ``lsm`` will search for anexact match. You can also search for the closest key, if the specific key youare searching for does not exist:&lt;!--  name: test_get_del_item_seek_mode --&gt;```pythonimport pytestfrom lsm import LSM, SEEK_LE, SEEK_GE, SEEK_LEFASTwith LSM(&quot;test.ldb&quot;, binary=False) as db:    for i in range(4):        db[f'k{i}'] = str(i)    # Here we will match &quot;k1&quot;.    assert db['k1xx', SEEK_LE] == '1'    # Here we will match &quot;k1&quot; but do not fetch a value    # In this case the value will always be ``True`` or there will    # be an exception if the key is not found    assert db['k1xx', SEEK_LEFAST] is True    with pytest.raises(KeyError):        print(db['000', SEEK_LEFAST])    # Here we will match &quot;k2&quot;.    assert db['k1xx', SEEK_GE] == &quot;2&quot;````LSM` supports other common dictionary methods such as:* `keys()`* `values()`* `items()`* `update()`### Slices and IterationThe database can be iterated through directly, or sliced. When you are slicingthe database the start and end keys need not exist -- ``lsm`` will find theclosest key (details can be found in the [LSM.fetch_range()](https://lsm-db.readthedocs.io/en/latest/api.html#lsm.LSM.fetch_range)documentation).&lt;!--    name: test_slices;--&gt;```pythonfrom lsm import LSMwith LSM(&quot;test_slices.ldb&quot;, binary=False) as db:    # clean database    for key in db.keys():        del db[key]    db['foo'] = 'bar'    for i in range(3):        db[f'k{i}'] = str(i)    # Can easily iterate over the database items    assert (        sorted(item for item in db.items()) == [            ('foo', 'bar'), ('k0', '0'), ('k1', '1'), ('k2', '2')        ]    )    # However, you will not read the entire database into memory, as special    # iterator objects are used.    assert str(db['k0':'k99']).startswith(&quot;&lt;lsm_slice object at&quot;)    # But you can cast it to the list for example    assert list(db['k0':'k99']) == [('k0', '0'), ('k1', '1'), ('k2', '2')]```You can use open-ended slices. If the lower- or upper-bound is outside therange of keys an empty list is returned.&lt;!--    name: test_slices;    case: open_ended_slices--&gt;```pythonwith LSM(&quot;test_slices.ldb&quot;, binary=False, readonly=True) as db:    assert list(db['k0':]) == [('k0', '0'), ('k1', '1'), ('k2', '2')]    assert list(db[:'k1']) == [('foo', 'bar'), ('k0', '0'), ('k1', '1')]    assert list(db[:'aaa']) == []```To retrieve keys in reverse order or stepping over more than one item,simply use a third slice argument as usual.Negative step value means reverse order, but first and second argumentsmust be ordinarily ordered.&lt;!--    name: test_slices;    case: reverse_slices--&gt;```pythonwith LSM(&quot;test_slices.ldb&quot;, binary=False, readonly=True) as db:    assert list(db['k0':'k99':2]) == [('k0', '0'), ('k2', '2')]    assert list(db['k0'::-1]) == [('k2', '2'), ('k1', '1'), ('k0', '0')]    assert list(db['k0'::-2]) == [('k2', '2'), ('k0', '0')]    assert list(db['k0'::3]) == [('k0', '0')]```You can also **delete** slices of keys, but note that delete **will not**include the keys themselves:&lt;!--    name: test_slices;    case: del_slice--&gt;```pythonwith LSM(&quot;test_slices.ldb&quot;, binary=False) as db:    del db['k0':'k99']    # Note that 'k0' still exists.    assert list(db.items()) == [('foo', 'bar'), ('k0', '0')]```### CursorsWhile slicing may cover most use-cases, for finer-grained control you can usecursors for traversing records.&lt;!--    name: test_cursors;    case: iterate_over_one_item--&gt;```pythonfrom lsm import LSM, SEEK_GE, SEEK_LEwith LSM(&quot;test_cursors.ldb&quot;, binary=False) as db:    del db[&quot;a&quot;:&quot;z&quot;]    db[&quot;spam&quot;] = &quot;spam&quot;    with db.cursor() as cursor:        cursor.seek('spam')        key, value = cursor.retrieve()        assert key == 'spam'        assert value == 'spam'```Seeking over cursors:&lt;!--    name: test_cursors;    case: iterate_over_multiple_items--&gt;```pythonwith LSM(&quot;test_cursors.ldb&quot;, binary=False) as db:    db.update({'k0': '0', 'k1': '1', 'k2': '2', 'k3': '3', 'foo': 'bar'})    with db.cursor() as cursor:        cursor.first()        key, value = cursor.retrieve()        assert key == &quot;foo&quot;        assert value == &quot;bar&quot;        cursor.last()        key, value = cursor.retrieve()        assert key == &quot;spam&quot;        assert value == &quot;spam&quot;        cursor.previous()        key, value = cursor.retrieve()        assert key == &quot;k3&quot;        assert value == &quot;3&quot;```Finding the first match that is greater than or equal to `'k0'` and moveforward until the key is less than `'k99'`&lt;!--    name: test_cursors;    case: iterate_ge_until_k99--&gt;```pythonwith LSM(&quot;test_cursors.ldb&quot;, binary=False) as db:    with db.cursor() as cursor:        cursor.seek(&quot;k0&quot;, SEEK_GE)        results = []        while cursor.compare(&quot;k99&quot;) &gt; 0:            key, value = cursor.retrieve()            results.append((key, value))            cursor.next()    assert results == [('k0', '0'), ('k1', '1'), ('k2', '2'), ('k3', '3')]```Finding the last match that is lower than or equal to `'k99'` and movebackward until the key is less than `'k0'`&lt;!--    name: test_cursors;    case: iterate_le_until_k0--&gt;```pythonwith LSM(&quot;test_cursors.ldb&quot;, binary=False) as db:    with db.cursor() as cursor:        cursor.seek(&quot;k99&quot;, SEEK_LE)        results = []        while cursor.compare(&quot;k0&quot;) &gt;= 0:            key, value = cursor.retrieve()            results.append((key, value))            cursor.previous()    assert results == [('k3', '3'), ('k2', '2'), ('k1', '1'), ('k0', '0')]```It is very important to close a cursor when you are through using it. For thisreason, it is recommended you use the `LSM.cursor()` context-manager, whichensures the cursor is closed properly.### Transactions``lsm`` supports nested transactions. The simplest way to use transactionsis with the `LSM.transaction()` method, which returns a context-manager:&lt;!-- name: test_transactions --&gt;```pythonfrom lsm import LSMwith LSM(&quot;test_tx.ldb&quot;, binary=False) as db:    del db[&quot;a&quot;:&quot;z&quot;]    for i in range(10):        db[f&quot;k{i}&quot;] = f&quot;{i}&quot;with LSM(&quot;test_tx.ldb&quot;, binary=False) as db:    with db.transaction() as tx1:        db['k1'] = '1-mod'        with db.transaction() as tx2:            db['k2'] = '2-mod'            tx2.rollback()    assert db['k1'] == '1-mod'    assert db['k2'] == '2'```You can commit or roll-back transactions part-way through a wrapped block:&lt;!-- name: test_transactions_2 --&gt;```pythonfrom lsm import LSMwith LSM(&quot;test_tx_2.ldb&quot;, binary=False) as db:    del db[&quot;a&quot;:&quot;z&quot;]    for i in range(10):        db[f&quot;k{i}&quot;] = f&quot;{i}&quot;with LSM(&quot;test_tx_2.ldb&quot;, binary=False) as db:    with db.transaction() as txn:        db['k1'] = 'outer txn'        # The write operation is preserved.        txn.commit()        db['k1'] = 'outer txn-2'        with db.transaction() as txn2:            # This is committed after the block ends.            db['k1'] = 'inner-txn'        assert db['k1'] == &quot;inner-txn&quot;        # Rolls back both the changes from txn2 and the preceding write.        txn.rollback()        assert db['k1'] == 'outer txn', db['k1']```If you like, you can also explicitly call `LSM.begin()`, `LSM.commit()`, and`LSM.rollback()`.&lt;!-- name: test_transactions_db --&gt;```pythonfrom lsm import LSM# fill dbwith LSM(&quot;test_db_tx.ldb&quot;, binary=False) as db:    del db[&quot;k&quot;:&quot;z&quot;]    for i in range(10):        db[f&quot;k{i}&quot;] = f&quot;{i}&quot;with LSM(&quot;test_db_tx.ldb&quot;, binary=False) as db:    # start transaction    db.begin()    db['k1'] = '1-mod'    # nested transaction    db.begin()    db['k2'] = '2-mod'    # rolling back nested transaction    db.rollback()    # comitting top-level transaction    db.commit()    assert db['k1'] == '1-mod'    assert db['k2'] == '2'```### Thanks to* [@coleifer](https://github.com/coleifer) - this project was inspired by[coleifer/python-lsm-db](https://github.com/coleifer/python-lsm-db).</longdescription>
</pkgmetadata>