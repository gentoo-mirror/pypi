<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># aiodine[![python](https://img.shields.io/pypi/pyversions/aiodine.svg?logo=python&amp;logoColor=fed749&amp;colorB=3770a0&amp;label=)](https://www.python.org)[![pypi](https://img.shields.io/pypi/v/aiodine.svg)][pypi-url][![travis](https://img.shields.io/travis/bocadilloproject/aiodine.svg)](https://travis-ci.org/bocadilloproject/aiodine)[![black](https://img.shields.io/badge/code_style-black-000000.svg)](https://github.com/ambv/black)[![codecov](https://codecov.io/gh/bocadilloproject/aiodine/branch/master/graph/badge.svg)](https://codecov.io/gh/bocadilloproject/aiodine)[![license](https://img.shields.io/pypi/l/aiodine.svg)][pypi-url][pypi-url]: https://pypi.org/project/aiodine/aiodine provides async-first [dependency injection][di] in the style of [Pytest fixtures](https://docs.pytest.org/en/latest/fixture.html) for Python 3.6+.- [Installation](#installation)- [Concepts](#concepts)- [Usage](#usage)- [FAQ](#faq)- [Changelog](#changelog)## Installation```bashpip install &quot;aiodine==1.*&quot;```## Conceptsaiodine revolves around two concepts:- **Providers** are in charge of setting up, returning and optionally cleaning up _resources_.- **Consumers** can access these resources by declaring the provider as one of their parameters.This approach is an implementation of [Dependency Injection][di] and makes providers and consumers:- **Explicit**: referencing providers by name on the consumer's signature makes dependencies clear and predictable.- **Modular**: a provider can itself consume other providers, allowing to build ecosystems of reusable (and replaceable) dependencies.- **Flexible**: provided values are reused within a given scope, and providers and consumers support a variety of syntaxes (asynchronous/synchronous, function/generator) to make provisioning fun again.aiodine is **async-first** in the sense that:- It was made to work with coroutine functions and the async/await syntax.- Consumers can only be called in an asynchronous setting.- But provider and consumer functions can be regular Python functions and generators too, if only for convenience.## Usage### Providers**Providers** make a _resource_ available to consumers within a certain _scope_. They are created by decorating a **provider function** with `@aiodine.provider`.Here's a &quot;hello world&quot; provider:```pythonimport aiodine@aiodine.providerasync def hello():    return &quot;Hello, aiodine!&quot;```Providers are available in two **scopes**:- `function`: the provider's value is re-computed everytime it is consumed.- `session`: the provider's value is computed only once (the first time it is consumed) and is reused in subsequent calls.By default, providers are function-scoped.### ConsumersOnce a provider has been declared, it can be used by **consumers**. A consumer is built by decorating a **consumer function** with `@aiodine.consumer`. A consumer can declare a provider as one of its parameters and aiodine will inject it at runtime.Here's an example consumer:```python@aiodine.consumerasync def show_friendly_message(hello):    print(hello)```All aiodine consumers are asynchronous, so you'll need to run them in an asynchronous context:```pythonfrom asyncio import runasync def main():    await show_friendly_message()run(main())  # &quot;Hello, aiodine!&quot;```Of course, a consumer can declare non-provider parameters too. aiodine is smart enough to figure out which parameters should be injected via providers, and which should be expected from the callee.```python@aiodine.consumerasync def show_friendly_message(hello, repeat=1):    for _ in range(repeat):        print(hello)async def main():    await show_friendly_message(repeat=10)```### Providers consuming other providersProviders are modular in the sense that they can themselves consume other providers.For this to work however, providers need to be **frozen** first. This ensures that the dependency graph is correctly resolved regardless of the declaration order.```pythonimport aiodine@aiodine.providerdef email():    return &quot;user@example.net&quot;@aiodine.providerasync def send_email(email):    print(f&quot;Sending email to {email}…&quot;)aiodine.freeze()  # &lt;- Ensures that `send_email` has resolved `email`.```**Note**: it is safe to call `.freeze()` multiple times.A context manager syntax is also available:```pythonimport aiodinewith aiodine.exit_freeze():    @aiodine.provider    def email():        return &quot;user@example.net&quot;    @aiodine.provider    async def send_email(email):        print(f&quot;Sending email to {email}…&quot;)```### Generator providersGenerator providers can be used to perform cleanup (finalization) operations after a provider has gone out of scope.```pythonimport osimport aiodine@aiodine.providerasync def complex_resource():    print(&quot;setting up complex resource…&quot;)    yield &quot;complex&quot;    print(&quot;cleaning up complex resource…&quot;)```**Tip**: cleanup code is executed even if an exception occurred in the consumer, so there's no need to surround the `yield` statement with a `try/finally` block.**Important**: session-scoped generator providers will only be cleaned up if using them in the context of a session. See [Sessions](#sessions) for details.### Lazy async providersAsync providers are **eager** by default: their return value is awaited before being injected into the consumer.You can mark a provider as **lazy** in order to defer awaiting the provided value to the consumer. This is useful when the provider needs to be conditionally evaluated.```pythonfrom asyncio import sleepimport aiodine@aiodine.provider(lazy=True)async def expensive_io_call():    await sleep(10)    return 42@aiodine.consumerasync def compute(expensive_io_call, cache=None):    if cache:        return cache    return await expensive_io_call```### Factory providersInstead of returning a scalar value, factory providers return a _function_. Factory providers are useful to implement reusable providers that accept a variety of inputs.&gt; This is a _design pattern_ more than anything else. In fact, there's no extra code in aiodine to support this feature.The following example defines a factory provider for a (simulated) database query:```pythonimport aiodine@aiodine.provider(scope=&quot;session&quot;)async def notes():    # Some hard-coded sticky notes.    return [        {&quot;id&quot;: 1, &quot;text&quot;: &quot;Groceries&quot;},        {&quot;id&quot;: 2, &quot;text&quot;: &quot;Make potatoe smash&quot;},    ]@aiodine.providerasync def get_note(notes):    async def _get_note(pk: int) -&gt; list:        try:            # TODO: fetch from a database instead?            return next(note for note in notes if note[&quot;id&quot;] == pk)        except StopIteration:            raise ValueError(f&quot;Note with ID {pk} does not exist.&quot;)    return _get_note```Example usage in a consumer:```python@aiodine.consumerasync def show_note(pk: int, get_note):    print(await get_note(pk))```**Tip**: you can combine factory providers with [generator providers](#generator-providers) to cleanup any resources the factory needs to use. Here's an example that provides temporary files and removes them on cleanup:```pythonimport osimport aiodine@aiodine.provider(scope=&quot;session&quot;)def tmpfile():    files = set()    async def _create_tmpfile(path: str):        with open(path, &quot;w&quot;) as tmp:            files.add(path)            return tmp    yield _create_tmpfile    for path in files:        os.remove(path)```### Using providers without declaring them as parametersSometimes, a consumer needs to use a provider but doesn't care about the value it returns. In these situations, you can use the `@useprovider` decorator and skip declaring it as a parameter.**Tip**: the `@useprovider` decorator accepts a variable number of providers, which can be given by name or by reference.```pythonimport osimport aiodine@aiodine.providerdef cache():    os.makedirs(&quot;cache&quot;, exist_ok=True)@aiodine.providerdef debug_log_file():    with open(&quot;debug.log&quot;, &quot;w&quot;):        pass    yield    os.remove(&quot;debug.log&quot;)@aiodine.consumer@aiodine.useprovider(&quot;cache&quot;, debug_log_file)async def build_index():    ...```### Auto-used providersAuto-used providers are **automatically activated** (within their configured scope) without having to declare them as a parameter in the consumer.This can typically spare you from decorating all your consumers with an `@useprovider`.For example, the auto-used provider below would result in printing the current date and time to the console every time a consumer is called.```pythonimport datetimeimport aiodine@aiodine.provider(autouse=True)async def logdatetime():    print(datetime.now())```### SessionsA **session** is the context in which _session providers_ live.More specifically, session providers (resp. generator session providers) are instanciated (resp. setup) when entering a session, and destroyed (resp. cleaned up) when exiting the session.To enter a session, use:```pythonawait aiodine.enter_session()```To exit it:```pythonawait aiodine.exit_session()```An async context manager syntax is also available:```pythonasync with aiodine.session():    ...```### Context providers&gt; **WARNING**: this is an experimental feature.Context providers were introduced to solve the problem of injecting **context-local resources**. These resources are typically undefined at the time of provider declaration, but become well-defined when entering some kind of **context**.This may sound abstract, so let's see an example before showing the usage of context providers.#### ExampleLet's say we're in a restaurant. There, a waiter executes orders submitted by customers. Each customer is given an `Order` object which they can `.write()` their desired menu items to.In aiodine terminilogy, the waiter is the [provider](#providers) of the order, and the customer is a [consumer](#consumers).During service, the waiter needs to listen to new customers, create a new `Order` object, provide it to the customer, execute the order as written by the customer, and destroy the executed order.So, in this example, the **context** spans from when an order is created to when it is destroyed, and is specific to a given customer.Here's what code simulating this situation on the waiter's side may look like:```pythonfrom asyncio import Queueimport aiodineclass Order:    def write(self, item: str):        ...class Waiter:    def __init__(self):        self._order = None        self.queue = Queue()        # Create an `order` provider for customers to use.        # NOTE: the actually provided value is not defined yet!        @aiodine.provider        def order():            return self._order    async def _execute(self, order: Order):        ...    async def _serve(self, customer):        # NOTE: we've now entered the *context* of serving        # a particular customer.        # Create a new order that the customer can        # via the `order` provider.        self._order = Order()        await customer()        # Execute the order and destroy it.        await self._execute(self._order)        self._order = None    async def start(self):        while True:            customer = await self.queue.get()            await self._serve(customer)```It's important to note that customers can do _anything_ with the order. In particular, they may take some time to think about what they are going to order. In the meantime, the server will be listening to other customer calls. In this sense, this situation is an _asynchronous_ one.An example customer code may look like this:```pythonfrom asyncio import sleep@aiodine.consumerdef alice(order: Order):    # Pondering while looking at the menu…    await sleep(10)    order.write(&quot;Pizza Margheritta&quot;)```Let's reflect on this for a second. Have you noticed that the waiter holds only _one_ reference to an `Order`? This means that the code works fine as long as only _one_ customer is served at a time.But what if another customer, say `bob`, comes along while `alice` is thinking about what she'll order? With the current implementation, the waiter will simply _forget_ about `alice`'s order, and end up executing `bob`'s order twice. In short: we'll encounter a **race condition**.By using a context provider, we transparently turn the waiter's `order` into a [context variable][contextvars] (a.k.a. `ContextVar`). It is local to the context of each customer, which solves the race condition.[contextvars]: https://docs.python.org/3/library/contextvars.htmlHere's how the code would then look like:```pythonimport aiodineclass Waiter:    def __init__(self):        self.queue = Queue()        self.provider = aiodine.create_context_provider(&quot;order&quot;)    async def _execute(self, order: Order):        ...    async def _serve(self, customer):        order = Order()        with self.provider.assign(order=order):            await customer()            await self._execute(order)    async def start(self):        while True:            customer = await self.queue.get()            await self._serve(customer)```Note:- Customers can use the `order` provider just like before. In fact, it was created when calling `.create_context_provider()`.- The `order` is now **context-local**, i.e. its value won't be forgotten or scrambled if other customers come and make orders concurrently.This situation may look trivial to some, but it is likely to be found in client/server architectures, including in web frameworks.#### UsageTo create a context provider, use `aiodine.create_context_provider()`. This method accepts a variable number of arguments and returns a `ContextProvider`. Each argument is used as the name of a new [`@provider`](#providers) which provides the contents of a [`ContextVar`][contextvars] object.```pythonimport aiodineprovider = aiodine.create_context_provider(&quot;first_name&quot;, &quot;last_name&quot;)```Each context variable contains `None` initially. This means that consumers will receive `None` — unless they are called within the context of an `.assign()` block:```pythonwith provider.assign(first_name=&quot;alice&quot;):    # Consumers called in this block will receive `&quot;alice&quot;`    # if they consume the `first_name` provider.    ...```## FAQ### Why &quot;aiodine&quot;?aiodine contains &quot;aio&quot; as in [asyncio], and &quot;di&quot; as in [Dependency Injection][di]. The last two letters end up making aiodine pronounce like [iodine], the chemical element.[asyncio]: https://docs.python.org/3/library/asyncio.html[di]: https://en.wikipedia.org/wiki/Dependency_injection[iodine]: https://en.wikipedia.org/wiki/Iodine## ChangelogSee [CHANGELOG.md](https://github.com/bocadilloproject/aiodine/blob/master/CHANGELOG.md).## LicenseMIT</longdescription>
</pkgmetadata>