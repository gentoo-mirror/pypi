<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># ASGI RateLimitLimit user access frequency. Base on ASGI.100% coverage. High performance. Support regular matching. Customizable.## Install```# Only installpip install asgi-ratelimit# Use redispip install asgi-ratelimit[redis]# Use jwtpip install asgi-ratelimit[jwt]# Install allpip install asgi-ratelimit[full]```## UsageThe following example will limit users under the `&quot;default&quot;` group to access `/towns` at most once per second and `/forests` at most once per minute. And the users in the `&quot;admin&quot;` group have no restrictions.```pythonfrom typing import Tuplefrom ratelimit import RateLimitMiddleware, Rule# Simple rate-limiter in memory:from ratelimit.backends.simple import MemoryBackendrate_limit = RateLimitMiddleware(    ASGI_APP,    AUTH_FUNCTION,    MemoryBackend(),    {        r&quot;^/towns&quot;: [Rule(second=1, group=&quot;default&quot;), Rule(group=&quot;admin&quot;)],        r&quot;^/forests&quot;: [Rule(minute=1, group=&quot;default&quot;), Rule(group=&quot;admin&quot;)],    },)# with Redis:from redis.asyncio import StrictRedisfrom ratelimit.backends.redis import RedisBackendrate_limit = RateLimitMiddleware(    ASGI_APP,    AUTH_FUNCTION,    RedisBackend(StrictRedis()),    {        r&quot;^/towns&quot;: [Rule(second=1, group=&quot;default&quot;), Rule(group=&quot;admin&quot;)],        r&quot;^/forests&quot;: [Rule(minute=1, group=&quot;default&quot;), Rule(group=&quot;admin&quot;)],    },)```:warning: **The pattern's order is important, rules are set on the first match**: Be careful here !Next, provide a custom authenticate function, or use one of the [existing auth methods](#built-in-auth-functions).```pythonfrom ratelimit.auths import EmptyInformationasync def AUTH_FUNCTION(scope: Scope) -&gt; Tuple[str, str]:    &quot;&quot;&quot;    Resolve the user's unique identifier and the user's group from ASGI SCOPE.    If there is no user information, it should raise `EmptyInformation`.    If there is no group information, it should return &quot;default&quot;.    &quot;&quot;&quot;    # FIXME    # You must write the logic of this function yourself,    # or use the function in the following document directly.    return USER_UNIQUE_ID, GROUP_NAMErate_limit = RateLimitMiddleware(ASGI_APP, AUTH_FUNCTION, ...)```The `Rule` type takes a time unit (e.g. `&quot;second&quot;`), a `&quot;group&quot;`, and a `&quot;method&quot;` as a param. If the `&quot;group&quot;` param is not specified then the `&quot;authenticate&quot;` method needs to return the &quot;default group&quot;. The `&quot;method&quot;` param corresponds to the http method, if it is not specified, the rule will be applied to all http requests.Example:```python    ...    config={        r&quot;^/towns&quot;: [Rule(second=1, method=&quot;get&quot;), Rule(second=10, group=&quot;admin&quot;)],    }    ...async def AUTH_FUNCTION(scope: Scope) -&gt; Tuple[str, str]:    ...    # no group information about this user    if user not in admins_group:        return user_unique_id, 'default'    return user_unique_id, user_group```### Customizable rulesIt is possible to mix the rules to obtain higher level of control.The below example will allow up to 10 requests per second and no more than 200 requests per minute, for everyone, for the same API endpoint.```python    ...    config={        r&quot;^/towns&quot;: [Rule(minute=200, second=10)],    }    ...```Example for a &quot;admin&quot; group with higher limits.```python    ...    config={        r&quot;^/towns&quot;: [            Rule(day=400, minute=200, second=10),            Rule(minute=500, second=25, group=&quot;admin&quot;),        ],    }    ...```Sometimes you may want to specify that some APIs share the same flow control pool. In other words, flow control is performed on the entire set of APIs instead of a single specific API. Only the `zone` parameter needs to be used. **Note**: You can give different rules the same `zone` value, and all rules with the same `zone` value share the same flow control pool.```python    ...    config={        r&quot;/user/\d+&quot;: [            Rule(minute=200, zone=&quot;user-api&quot;),            Rule(second=100, zone=&quot;user-api&quot;, group=&quot;admin&quot;),        ],    }    ...```### Block timeWhen the user's request frequency triggers the upper limit, all requests in the following period of time will be returned with a `429` status code.Example: `Rule(second=5, block_time=60)`, this rule will limit the user to a maximum of 5 visits per second. Once this limit is exceeded, all requests within the next 60 seconds will return `429`.### HTTP MethodIf you want a rate limit a specifc HTTP method on an endpoint, the `Rule` object has a `method` param. If no method is specified, the default value is `&quot;*&quot;` for all HTTP methods.```pythonr&quot;^/towns&quot;: [    Rule(group=&quot;admin&quot;, method=&quot;get&quot;, second=10),    Rule(group=&quot;admin&quot;, method=&quot;post&quot;, second=2)]```### Custom block handlerJust specify `on_blocked` and you can customize the asgi application that is called when blocked.```pythondef yourself_429(retry_after: int):    async def inside_yourself_429(scope: Scope, receive: Receive, send: Send) -&gt; None:        await send({&quot;type&quot;: &quot;http.response.start&quot;, &quot;status&quot;: 429})        await send(            {                &quot;type&quot;: &quot;http.response.body&quot;,                &quot;body&quot;: b&quot;custom 429 page&quot;,                &quot;more_body&quot;: False,            }        )    return inside_yourself_429RateLimitMiddleware(..., on_blocked=yourself_429)```### Built-in auth functions#### Client IP```pythonfrom ratelimit.auths.ip import client_ip```Obtain user IP through `scope[&quot;client&quot;]` or `X-Real-IP`.Note: this auth method will not work if your IP address (such as 127.0.0.1 etc) is not allocated for public networks.#### Starlette Session```pythonfrom ratelimit.auths.session import from_session```Get `user` and `group` from `scope[&quot;session&quot;]`.If key `group` not in session, will return `default`. If key `user` not in session, will raise a `EmptyInformation`.#### Json Web Token```pythonfrom ratelimit.auths.jwt import create_jwt_authjwt_auth = create_jwt_auth(&quot;KEY&quot;, &quot;HS256&quot;)```Get `user` and `group` from JWT that in `Authorization` header.### Custom auth error handlerNormally exceptions raised in the authentication function result in an Internal Server Error, but you can pass a function to handle the errors and send the appropriate response back to the user. For example, if you're using FastAPI or Starlette:```pythonfrom fastapi.responses import JSONResponsefrom ratelimit.types import ASGIAppasync def handle_auth_error(exc: Exception) -&gt; ASGIApp:    return JSONResponse({&quot;message&quot;: &quot;Unauthorized access.&quot;}, status_code=401)RateLimitMiddleware(..., on_auth_error=handle_auth_error)```For advanced usage you can handle the response completely by yourself:```pythonfrom fastapi.responses import JSONResponsefrom ratelimit.types import ASGIApp, Scope, Receive, Sendasync def handle_auth_error(exc: Exception) -&gt; ASGIApp:    async def response(scope: Scope, receive: Receive, send: Send):        # do something here e.g.        # await send({&quot;type&quot;: &quot;http.response.start&quot;, &quot;status&quot;: 429})    return response```</longdescription>
</pkgmetadata>