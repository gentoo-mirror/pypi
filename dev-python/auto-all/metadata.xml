<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>auto-all========Automatically manage the ``__all__`` variable in Python modules... image:: https://badge.fury.io/py/auto-all.svg   :target: https://pypi.org/project/auto-all   :alt: pypi package.. image:: https://api.travis-ci.com/jongracecox/auto-all.svg?branch=master   :target: https://travis-ci.com/jongracecox/auto-all   :alt: build status.. image:: https://img.shields.io/pypi/dm/auto-all.svg   :target: https://pypistats.org/packages/auto-all   :alt: downloads.. image:: https://img.shields.io/github/last-commit/jongracecox/auto-all.svg   :target: https://github.com/jongracecox/auto-all/commits/master   :alt: GitHub last commit.. image:: https://img.shields.io/github/license/jongracecox/auto-all.svg   :target: https://github.com/jongracecox/auto-all/blob/master/LICENSE   :alt: GitHub.. image:: https://img.shields.io/github/stars/jongracecox/auto-all.svg?style=social   :target: https://github.com/jongracecox/auto-all/stargazers   :alt: GitHub starsOverview--------``auto_all`` can be used for controlling what is made availablefor import from a Python module.Advantages:* Easily populate the ``__all__`` variable in modules.* Easily exclude imported objects* Clearly differentiate between internal and external facing objects.* Use simple, intuitive code.* Never worry about forgetting to add new objects to ``__all__``.* Help Python IDE's differentiate between internal and external facing objects.Installation------------.. code-block:: bash   pip install auto-allUsage-----There are two main approaches:.. code-block::     1) Use `start_all` and `end_all` to wrap all public functions and        variables.     2) Use the `@public` decorator to identify publicly facing functions.start_all/end_all approach^^^^^^^^^^^^^^^^^^^^^^^^^^First, import the auto_all functions into your module... code-block:: python   from auto_all import start_all, end_allIf your module has external dependencies then these can be importedand the imported objects can be hidden.  In this example we will importpathlib.Path and show that it doesn't appear on the ``__all__`` list.We're not actually going to use this import, it's just for illustration... code-block:: python   from pathlib import PathNow we can define some internal functions that we want to keep private.We can also do this using underscore prefixes, but ``auto_all`` gives us alittle more granular control... code-block:: python   def a_private_function():       print(&quot;This is a private function.&quot;)Now we are ready to start defining public functions, so we use``start_all()``... code-block:: python   start_all()Now we can define our public functions... code-block:: python   def a_public_function():       print(&quot;This is a public function.&quot;)Finally we use ``end_all()`` to finish defining public functions andcreate the ``__all__`` variable... code-block:: python   end_all()When we look at the ``__all__`` variable we can see only the publicfacing objects are listed... code-block::   &gt;&gt;&gt; print(__all__)   ['a_public_function']Putting this all together, your module should look something like this:.. code-block:: python   from auto_all import start_all, end_all   from pathlib import Path   def a_private_function():       print(&quot;This is a private function.&quot;)   start_all()   def a_public_function():       print(&quot;This is a public function.&quot;)   end_all()It is possible to pass the globals dict to the ``start_all`` and``end_all`` function calls. This is not typically necessary, and isonly included for backward compatibility... code-block:: python   start_all(globals())   def another_public_function():       pass   end_all(globals())   def a_private_function():       pass   print(__all__)``@public`` decorator approach^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^The second approach is to use the ``@public`` decorator. Note that thisapproach is only suitable for functions, and will not work for declaringclasses or variables as public.First, import the decorator:.. code-block:: python   from auto_all import publicWe can define any private functions without any decorator:.. code-block:: python   def a_private_function():       passWe can define public functions by decorating with the ``@public``decorator:.. code-block:: python   @public   def a_public_function():       passThe ``__all__`` variable will only include functions that have beendeclared as public:.. code-block::   &gt;&gt;&gt; print(__all__)   ['a_public_function']Combining the two approaches============================In the event that you need to declare variables and classes as public, andalso want to make use of the ``@public`` decorator for functions you cancombine both methods.Private variables can be defined outside the start/end block:.. code-block:: python   PRIVATE_VARIABLE = &quot;I am private&quot;Public items can be defined between the ``start_all()`` and ``end_all()``function calls:.. code-block:: python   start_all()   PUBLIC_VARIABLE = &quot;I am public&quot;   class PublicClass:       pass   end_all()Private functions can be defined undecorated outside the start/end block:.. code-block:: python   def private_function():   passPublic functions can be decorated with the ``@public`` decorator:.. code-block:: python   @public   def public_function():       passThe ``__all__`` variable will include any object declared between the``start_all`` and ``end_all`` calls, and any function decorated with the``@public`` decorator:.. code-block::   &gt;&gt;&gt; print(__all__)   ['PUBLIC_VARIABLE', 'PublicClass', 'public_function']</longdescription>
</pkgmetadata>