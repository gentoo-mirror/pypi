<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>django-fancy-cache==================Copyright Peter Bengtsson, mail@peterbe.com, 2013-2022License: BSDAbout django-fancy-cache------------------------A Django ``cache_page`` decorator on steroids.Unlike the stock ``django.views.decorators.cache.change_page`` thisdecorator makes it possible to set a ``key_prefix`` that is acallable. This callable is passed the request and if it returns ``None``the page is not cached.Also, you can set another callable called ``post_process_response``(which is passed the response and the request) which can do someadditional changes to the response before it's set in cache.Lastly, you can set ``post_process_response_always=True`` so that the``post_process_response`` callable is always called, even when theresponse is coming from the cache.How to use it-------------In your Django views:.. code:: python    from fancy_cache import cache_page    from django.utils.decorators import method_decorator    from django.views.generic import TemplateView    @cache_page(60 * 60)    def myview(request):        return render(request, 'page1.html')    def prefixer(request):        if request.method != 'GET':            return None        if request.GET.get('no-cache'):            return None        return 'myprefix'    @cache_page(60 * 60, key_prefix=prefixer)    def myotherview(request):        return render(request, 'page2.html')    def post_processor(response, request):        response.content += '&lt;!-- this was post processed --&gt;'        return response    @cache_page(        60 * 60,        key_prefix=prefixer,        post_process_response=post_processor)    def yetanotherotherview(request):        return render(request, 'page3.html')    class MyClassBasedView(TemplateView):        template_name = 'page4.html'        @method_decorator(cache_page(60*60))        def get(self, request, *args, **kwargs):            return super().get(request, *args, **kwargs)Optional uses-------------If you want to you can have ``django-fancy-cache`` record every URL itcaches. This can be useful for things like invalidation or curiousstatistical inspection.You can either switch this on on the decorator itself. Like this:.. code:: python    from fancy_cache import cache_page    @cache_page(60 * 60, remember_all_urls=True)    def myview(request):        return render(request, 'page1.html')Or, more conveniently to apply it to all uses of the ``cache_page``decorator you can set the default in your settings with:.. code:: python    FANCY_REMEMBER_ALL_URLS = TrueNow, suppose you have the this option enabled. Now you can do thingslike this:.. code:: python    &gt;&gt;&gt; from fancy_cache.memory import find_urls    &gt;&gt;&gt; list(find_urls(['/some/searchpath', '/or/like/*/this.*']))    &gt;&gt;&gt; # or, to get all:    &gt;&gt;&gt; list(find_urls([]))There is also another option to this and that is to purge (aka.invalidate) the remembered URLs. You simply all the ``purge=True``option like this:.. code:: python    &gt;&gt;&gt; from fancy_cache.memory import find_urls    &gt;&gt;&gt; list(find_urls([], purge=True))Note: Since ``find_urls()`` returns a generator, the purging won'thappen unless you exhaust the generator. E.g. looping over it orturning it into a list.**If you are using Memcached**, you must enable check-and-set toremember all urls by enabling the ``FANCY_USE_MEMCACHED_CHECK_AND_SET``flag and enabling ``cas`` in your ``CACHES`` settings:.. code:: python    # in settings.py    FANCY_USE_MEMCACHED_CHECK_AND_SET = True    CACHES = {        'default': {            'BACKEND': 'django.core.cache.backends.memcached.PyLibMCCache',            'LOCATION': '127.0.0.1:11211',            # This OPTIONS setting enables Memcached check-and-set which is            # required for remember_all_urls or FANCY_REMEMBER_ALL_URLS.            'OPTIONS': {                'behaviors': {                    'cas': True                }            }        }     }The second way to inspect all recorded URLs is to use the``fancy-cache`` management command. This is only available if you haveadded ``fancy_cache`` to your ``INSTALLED_APPS`` setting. Now you can dothis::    $ ./manage.py fancy-cache --help    $ ./manage.py fancy-cache    $ ./manage.py fancy-cache /some/searchpath /or/like/*/this.*    $ ./manage.py fancy-cache /some/place/* --purge    $ # or to purge them all!    $ ./manage.py fancy-cache --purgeNote, it will only print out URLs that if found (and purged, ifapplicable).The third way to inspect the recorded URLs is to add this to your root``urls.py``:.. code:: python    url(r'fancy-cache', include('fancy_cache.urls')),Now, if you visit ``http://localhost:8000/fancy-cache`` you get a tablelisting every URL that ``django-fancy-cache`` has recorded.Optional uses (for the exceptionally curious)---------------------------------------------If you have enabled ``FANCY_REMEMBER_ALL_URLS`` you can also enable``FANCY_REMEMBER_STATS_ALL_URLS`` in your settings. What this does isthat it attempts to count the number of cache hits and cache missesyou have for each URL.This counting of hits and misses is configured to last &quot;a long time&quot;.Possibly longer than you cache your view. So, over time you can expectto have more than one miss because your view cache expires and itstarts over.You can see the stats whenever you use any of the ways described inthe section above. For example like this:.. code:: python    &gt;&gt;&gt; from fancy_cache.memory import find_urls    &gt;&gt;&gt; found = list(find_urls([]))[0]    &gt;&gt;&gt; found[0]    '/some/page.html'    &gt;&gt;&gt; found[2]    {'hits': 1235, 'misses': 12}There is obviously a small additional performance cost of using the``FANCY_REMEMBER_ALL_URLS`` and/or ``FANCY_REMEMBER_STATS_ALL_URLS`` inyour project so only use it if you don't have any smarter way toinvalidate, for debugging or if you really want make it possible topurge all cached responses when you run an upgrade of your site orsomething.Running the test suite----------------------The simplest way is to simply run::    $ pip install tox    $ toxOr to run it without ``tox`` you can simply run::    $ export PYTHONPATH=`pwd`    $ export DJANGO_SETTINGS_MODULE=fancy_tests.tests.settings    $ django-admin.py testChangelog---------1.3.0    * Enable ``FANCY_COMPRESS_REMEMBERED_URLS`` setting to compress      ``remembered_urls`` dictionary when ``FANCY_REMEMBER_ALL_URLS``      is True.    * Bugfix: use correct location for ``REMEMBERED_URLS``       when using Memcached.    * Add support for Python 3.11, Django 4.1 &amp; 4.2    * Drop support for Python &lt; 3.8, Django &lt; 3.2, Django 4.01.2.1    * Bugfix: conflict between the DummyCache backend when       ``FANCY_USE_MEMCACHED_CHECK_AND_SET`` is ``True``1.2.0    * Restructure the remembered_urls cache dict to clean up stale entries    * Update FancyCacheMiddleware to match latest Django CacheMiddlware      (Also renames to FancyCacheMiddleware)    * Apply Memcached check-and-set to the delete_keys function      if ``settings.FANCY_USE_MEMCACHED_CHECK_AND_SET = True``    * Drop support for Python &lt;3.6    * Add support for Python 3.10 and Django 4.01.1.0    * If you use Memcached you can set      ``settings.FANCY_USE_MEMCACHED_CHECK_AND_SET = True`` so that you      can use ``cache._cache.cas`` which only workd with Memcached1.0.0    * Drop support for Python &lt;3.5 and Django &lt;2.2.00.11.0    * Fix for ``parse_qs`` correctly between Python 2 and Python 30.10.0    * Fix for keeping blank strings in query strings. #390.9.0    * Django 1.10 support0.8.2    * Remove deprecated way to define URL patterns and tests in python 3.50.8.1    * Ability to specify different cache backends to be used      https://github.com/peterbe/django-fancy-cache/pull/310.8.0    * Started keeping a Changelog</longdescription>
</pkgmetadata>