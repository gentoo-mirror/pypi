<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Binary TriePython binary trie implementation, helping with XOR distances.Author: [Guillaume Michel](https://github.com/guillaumemichel)## Purpose[IPFS](https://ipfs.network) and [libp2p](https://libp2p.io/) are built upon the Kademlia DHT, which uses the XOR distance as a distance metric between keys. As explained in this [blogpost](https://metaquestions.me/2014/08/01/shortest-distance-between-two-points-is-not-always-a-straight-line/), the XOR distance is tricky to understand and represent. This distance metric is odd for it is non linear.For instance, $2 \oplus 3 = 1$ but $3 \oplus 4 = 7$. Ordering $N_8$ by XOR distance to 2 gives the following result: $[2,3,0,1,6,7,4,5]$One popular representation for XOR distance is the Binary Trie. A binary brie is a simple [Trie](https://en.wikipedia.org/wiki/Trie) with keyspace $\lbrace0,1\rbrace^n$ with $n$ being the size of the keyspace. The perfect visual representation of the XOR distance would be a N-dimensional binary trie. The example below displays a binary trie containing the keys $[2,3,4,6,7,9,11,13]$.![Alt text](./resources/trie.svg)Each node in the Trie can be associated with some metadata for convenience.## Usage### Install```bashpip install binary-trie```### Import```pythonfrom binary_trie import Trie, bytes_to_bitstring, bitstring_to_bytes, int_to_bitstring, bitstring_to_int```### Creating an empty trie```pythontrie = Trie()```### Adding keysThe `add(key)` method takes a bitstring as input. The bitstring can either be provided directly, or be computer from an `int` or `bytes` using the `int_to_bitstring()` and `bytes_to_bitstring()` functions. Note that the `l` parameter represent the bit length of the binary representation. It is important that all keys share the same bit length. The bit length can be omitted in `bytes_to_bistring()` when working with bit lengths multiple of 8.```pythontrie.add(&quot;0010&quot;)trie.add(4*&quot;0&quot;)trie.add(int_to_bitstring(3, l=4))trie.add(bytes_to_bitstring(b'\x0e', l=4))```The add function returns `True` on success, and `False` if the key was already in the trie (not inserted).### Finding keysThe `find(key)` method returns `True` if the provided key is in the Trie, `False` otherwise.```pythontrie.contains(&quot;0010&quot;) # Truetrie.contains(&quot;0100&quot;) # False```### Key depthThe `depth(key)` method returns the depth of the provided key, if it is in the Trie and `-1` otherwise. The depth of a trie node is defined as the number of its direct ancestors, up to the root of the trie.```pythontrie.depth(&quot;0&quot;)    # 1trie.depth(&quot;0010&quot;) # 3trie.depth(&quot;0111&quot;) # 4trie.depth(&quot;1101&quot;) # 2trie.depth(&quot;11&quot;)   # -1```### Finding the closest keys to a targetThe `n_closest_keys(key, n)` method returns the `n` closest keys to the provided key in the trie, according to the XOR distance. The keys are sorted according to the distance to the target key. Note that only leaves of the trie will be returned, not intermediary nodes.```pythontrie.n_closest_keys(&quot;0001&quot;, 1) # [&quot;0000&quot;]trie.n_closest_keys(&quot;0010&quot;, 3) # [&quot;0010&quot;, &quot;0011&quot;, &quot;0000&quot;]```### Prefix matchingThe `prefix_match_keys(prefix)` will return the list of keys of all leaves of the Trie matching the provided `prefix`.```pythontrie.prefix_match_keys(&quot;00&quot;)   # [&quot;0000&quot;, &quot;0010&quot;, &quot;0011&quot;]trie.prefix_match_keys(&quot;1111&quot;) # []```### Attaching metadata to Trie nodesIt is possible to attach an `object` as metadata to a trie leaf node.```pythonclass MyObj(object):    def __init__(self, key, name):        self.key = key        self.name = nametrie = Trie(MyObj)obj = MyObj(int_to_bitstring(10, 4), &quot;Node 10&quot;)trie.add(obj.key, obj)trie.find(obj.key).name        # &quot;Node 10&quot;trie.n_closest(obj.key, 1)     # [obj]trie.prefix_match(obj.key[:2]) # [obj]```Note that the `find(key)` method is similar to the `contains(key)` method, but returns the associated `metadata` if any, instead of returning a `bool`.The `n_closest(key, n)` method is similar to the `n_closest_keys(key, n)` method, but returns the list of `metadata` associated with the closest keys, instead of the list of keys.### PredicatesIt is possible to assign some boolean variables to `metadata` objects, and make use of them using predicate in `n_closest()`, `n_closest_keys()`, `prefix_match()` and `prefix_match_keys()` methods to filter the results.```pythonclass MyObj(object):    def __init__(self, key, name, some_bool):        self.key = key        self.name = name        self.some_bool = some_booltrie = Trie(MyObj)nodeIDs = [0, 1, 2] # [&quot;0000&quot;, &quot;0001&quot;, &quot;0010&quot;]for i in nodeIDs:    obj = MyObj(int_to_bitstring(i, 4), &quot;Node &quot;+str(i), i % 2 == 0)    trie.add(obj.key, obj)trie.n_closest_keys(&quot;0001&quot;, 2, predicate=lambda n: n.some_bool) # [&quot;0000&quot;, &quot;0010&quot;] trie.prefix_match_keys(&quot;000&quot;, predicate=lambda n: n.some_bool)  # [&quot;0000&quot;]# Note that the key &quot;0001&quot; matched both requests, but wasn't taken into# consideration as it doesn't satisfy the predicate```### HelpersThere are 4 helpers functions to facilitate the use of this implementation with keys being not only `bitstring`, but also `bytes` or `int`. These helper functions help translate `bytes` and `int` to `bitstring` and reciprocally.```pythondef bytes_to_bitstring(data: bytes, l: int=8*len(data)) -&gt; bytes:    ...bytes_to_bitstring(b'\xff\x00') # &quot;1111111100000000&quot;bytes_to_bitstring(b'\xf3',l=4) # &quot;0011&quot;def bitstring_to_bytes(bs: str) -&gt; bytes:    ...bitstring_to_bytes(&quot;1111111100000000&quot;) # b'\xff\x00'bitstring_to_bytes(&quot;0011&quot;)             # b'\x03'def int_to_bitstring(i, l: int) -&gt; bytes:    ...int_to_bitstring(6, 4)  # &quot;0110&quot;int_to_bitstring(6, 16) # &quot;0000000000000110&quot;def bitstring_to_int(bs: str) -&gt; int:    ...bitstring_to_int(&quot;0110&quot;)             # 6bitstring_to_int(&quot;0000000000000110&quot;) # 6```### EncodingThe following functions help uniquely encode a specific binary prefix, that are bistrings of arbitrary size. The bitstrings can be encoded in `int` or in [`unsigned varint`](https://github.com/multiformats/unsigned-varint). The mapping goes as follow:```bitstring       code        varint&quot;&quot;          -&gt;  0       -&gt;  00000000 (0x00)&quot;0&quot;         -&gt;  1       -&gt;  00000001 (0x01)&quot;1&quot;         -&gt;  2       -&gt;  00000010 (0x02)&quot;00&quot;        -&gt;  3       -&gt;  00000011 (0x03)...&quot;0000000&quot;   -&gt;  127     -&gt;  01111111 (0x7f)&quot;0000001&quot;   -&gt;  128     -&gt;  10000000 00000001 (0x8001)...``````pythondef encode_bitstring(bitstring: str) -&gt; int:    ...encode_bitstring(&quot;1&quot;)       # 2encode_bitstring(&quot;010&quot;)     # 9encode_bitstring(&quot;0000001&quot;) # 128def decode_bitstring(code: int) -&gt; str:    ...decode_bitstring(2)   # &quot;1&quot;decode_bitstring(9)   # &quot;010&quot;decode_bitstring(128) # &quot;0000001&quot;def bitstring_to_varint(bitstring: str) -&gt; bytes:    ...bitstring_to_varint(&quot;1&quot;)       # b'\x02'bitstring_to_varint(&quot;010&quot;)     # b'\x09'bitstring_to_varint(&quot;0000001&quot;) # b'\x80\x01'def varint_to_bitstring(varint_bytes: bytes) -&gt; str:    ...varint_to_bitstring(b'\x02')     # &quot;1&quot;varint_to_bitstring(b'\x09')     # &quot;010&quot;varint_to_bitstring(b'\x80\x01') # &quot;0000001&quot;```</longdescription>
</pkgmetadata>