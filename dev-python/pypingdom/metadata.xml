<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Pypingdom=========.. image:: https://img.shields.io/pypi/v/pypingdom.svg    :target: https://pypi.python.org/pypi/pypingdom.. image:: https://img.shields.io/pypi/l/pypingdom.svg    :target: https://pypi.python.org/pypi/pypingdom.. image:: https://img.shields.io/pypi/pyversions/pypingdom.svg    :target: https://pypi.python.org/pypi/pypingdom.. image:: https://travis-ci.org/sekipaolo/pypingdom.svg?branch=master    :target: https://travis-ci.org/sekipaolo/pypingdomPython library for interacting with Pingdom services (REST API and maintenance windows).Features--------* Support for `Multi-User Authentication &lt;https://www.pingdom.com/resources/api#multi-user+authentication&gt;`_* Check management: create, delete, update, list* Maintenance windows: create, delete, list* Fetching outage summaries.. warning::    Since the Pingdom REST API don't support maintenance windows, we interact    with the Website for it. Therefore this feature is highly fragile and can    *break* at any moment due to frontend changes on the Pingdom website.Requirements------------* Pingdom account* requests (0.10.8 or newer)Installation------------.. code-block:: python    pip install pypingdomUsage-----The `client` object will allow you to interact both with the REST API and theGUI (for maintenance windows)... code-block:: python    &gt;&gt;&gt; import pypingdom    &gt;&gt;&gt; client = pypingdom.Client(username=&quot;username@example.com&quot;,                            password=&quot;your_password&quot;,                            apikey=&quot;your_api_key&quot;,                            email=&quot;your_email&quot;)the `email` parameter is required for `Multiuser Authentication &lt;https://www.pingdom.com/resources/api#multi-user+authentication&gt;`_.Checks------Since Pingdom does not treat the check name as identifier (as we probably wantto do) the client object will retrieve the check list from the API and cache itas a dictionary ( check_name =&gt; check_instance). You can access it through the`checks` attribute:.. code-block:: python    &gt;&gt;&gt; client.checks[&quot;my awesome check&quot;]    pingdom.Check &lt;1895866&gt;      autoresolve: 0      alert_policy: 2118909      name: example_com      created: 1448565930      lasterrortime: 1489325292      resolution: 1      lastresponsetime: 558      lasttesttime: 1489847772      alert_policy_name: Production Systems      paused: False      host: hostname.example.com      acktimeout: 0      ipv6: False      use_legacy_notifications: False      type: http      tags: []a better way to retrieve a check would be:.. code-block:: python    &gt;&gt;&gt; client.get_check(&quot;my awesome check&quot;)that will return None if the check doesn't existsList checks with `production` and `frontend` tags:.. code-block:: python    &gt;&gt;&gt; client.get_checks(filters={&quot;tags&quot;: [&quot;production&quot;, &quot;frontend&quot;]})Create a check:.. code-block:: python    &gt;&gt;&gt; check_definition = {            &quot;name&quot;: &quot;My awesome check&quot;,            &quot;paused&quot;: True,            &quot;alert_policy&quot;: 201745,            &quot;type&quot;: &quot;http&quot;,            &quot;host&quot;: &quot;www.google.com&quot;,            &quot;url&quot;: &quot;/&quot;,            &quot;requestheaders&quot;: {                'XCustom': 'my header value'            },            &quot;tags&quot;: [{&quot;name&quot;: &quot;pypingdom-test&quot;}, {&quot;name&quot;: &quot;custom-tag&quot;}],            &quot;encryption&quot;: False        }    &gt;&gt;&gt; client.create_check(check_definition)Refers to `this page &lt;https://www.pingdom.com/resources/api#MethodCreate+New+Check&gt;`_ for the list of options.When you create or modify a check some related entity need to be referenced by id:*Integrations*To enable/disable an integration plugins (like webhooks) use the field `integrationids` (array with integer ids to set or &quot;null&quot; tring to remove it)*Alert policies*To bind an alerting policy use the field `alert_policy` (numeric id to set it or string &quot;null&quot; to disable alerts)Update a check:.. code-block:: python    &gt;&gt;&gt; client.update_check(check, {&quot;paused&quot;: True})this will return True if an effective change was sent to the API and Falseotherwise (useful for idempotent usage, like ansible modules)Delete a check:.. code-block:: python    &gt;&gt;&gt; client.delete_check(check)Maintenance windows-------------------Retreive maintenance windows for production websites in the last 7 days:.. code-block:: python    &gt;&gt;&gt; import datetime    &gt;&gt;&gt; checks = client.get_checks(filters={&quot;tags&quot;: [&quot;production&quot;, &quot;frontend&quot;]})    &gt;&gt;&gt; start = datetime.datetime.now() - datetime.timedelta(days=7)    &gt;&gt;&gt; client.get_maintenances(filters={&quot;checks&quot;: checks, &quot;after&quot;: start})Create a 1 hour maintenance window for production websites:.. code-block:: python    &gt;&gt;&gt; start = datetime.datetime.now() + datetime.timedelta(minutes=10)    &gt;&gt;&gt; end = start + datetime.timedelta(hours=1)    &gt;&gt;&gt; window = client.create_maintenance({&quot;checks&quot;: checks, &quot;name&quot;: &quot;pypingdom test maintenance&quot;, &quot;start&quot;: start, &quot;stop&quot;: end})Delete future maintenance windows:.. code-block:: python    &gt;&gt;&gt; windows = client.get_maintenances(filters={&quot;checks&quot;: checks, &quot;after&quot;: datetime.datetime.now()}):    &gt;&gt;&gt; for m in maintenances:        client.delete_maintenance(m)Reporting/summary-------------------Retrieve average response time and uptime summaries:.. code-block:: python    &gt;&gt;&gt; checkid = client.get_check(&quot;my awesome check&quot;)._id    &gt;&gt;&gt; start = int(time.time()) - 30*24*60*60 # 30 days back    &gt;&gt;&gt; end = time.time()    &gt;&gt;&gt; client.get_summary_average(checkid, start, end, include_uptime=&quot;true&quot;)</longdescription>
</pkgmetadata>