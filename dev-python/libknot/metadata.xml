<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Libknot API in PythonA Python interface for managing the Knot DNS daemon.# Table of contents* [Introduction](#introduction)* [Control module](#control-module)  + [Usage](#using-the-control-module)  + [Example](#control-module-example)* [Probe module](#probe-module)  + [Usage](#using-the-probe-module)  + [Example](#probe-module-example)* [Dname module](#dname-module)  + [Usage](#using-the-dname-module)  + [Example](#dname-module-example)## IntroductionIf the shared `libknot.so` library isn't available in the library search path, it'snecessary to load the library first, e.g.:```python3import libknotlibknot.Knot(&quot;/usr/lib/libknot.so&quot;)```## Control moduleUsing this module it's possible to create scripts for efficient tasks thatwould require complex shell scripts with multiple calls of `knotc`. Forcommunication with the daemon it uses the same mechanism as the `knotc` utility,i.e. communication via a Unix socket.The module API is stored in `libknot.control`.### Using the Control moduleThe module usage consists of several steps:* Initialization and connection to the daemon control socket.* One or more control operations. An operation is called by sending a command  with optional data to the daemon. The operation result has to be received  afterwards.* Closing the connection and deinitialization.### Control module example```python3import jsonimport libknot.control# Initializationctl = libknot.control.KnotCtl()ctl.connect(&quot;/var/run/knot/knot.sock&quot;)ctl.set_timeout(60)try:    # Operation without parameters    ctl.send_block(cmd=&quot;conf-begin&quot;)    resp = ctl.receive_block()    # Operation with parameters    ctl.send_block(cmd=&quot;conf-set&quot;, section=&quot;zone&quot;, item=&quot;domain&quot;, data=&quot;test&quot;)    resp = ctl.receive_block()    ctl.send_block(cmd=&quot;conf-commit&quot;)    resp = ctl.receive_block()    # Operation with a result displayed in JSON format    ctl.send_block(cmd=&quot;conf-read&quot;, section=&quot;zone&quot;, item=&quot;domain&quot;)    resp = ctl.receive_block()    print(json.dumps(resp, indent=4))except libknot.control.KnotCtlError as exc:    # Print libknot error    print(exc)finally:    # Deinitialization    ctl.send(libknot.control.KnotCtlType.END)    ctl.close()``````python3    # List configured zones (including catalog member ones)    ctl.send_block(cmd=&quot;conf-list&quot;, flags=&quot;z&quot;)    resp = ctl.receive_block()    for zone in resp['zone']:        print(zone)```## Probe moduleUsing this module it's possible to receive traffic data from a running daemon withactive probe module.The module API is stored in `libknot.probe`.### Using the Probe moduleThe module usage consists of several steps:* Initialization of one or more probe channels* Periodical receiving of data units from the channels and data processing### Probe module example```python3import libknot.probe# Initialization of the first probe channel stored in `/run/knot`probe = libknot.probe.KnotProbe(&quot;/run/knot&quot;, 1)# Array for storing up to 8 data unitsdata = libknot.probe.KnotProbeDataArray(8)while (True):    # Receiving data units with timeout of 1000 ms    if probe.consume(data, 1000) &gt; 0:        # Printing received data units in the default format        for item in data:            print(item)```## Dname moduleThis module provides a few dname-related operations.### Using the Dname moduleThe dname object is initialized from a string with textual dname.Then the dname can be reformatted to wire format or back to textual format.### Dname module example```python3import libknot.dnamedname = libknot.dname.KnotDname(&quot;e\\120ample.c\om.&quot;)print(dname.size()print(dname.str())print(dname.wire())``````bash13example.com.b'\x07example\x03com\x00'```</longdescription>
</pkgmetadata>