<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pytest-grpcWrite test for gRPC with pytest.## ExampleSee example dir and/or read 'usage'.## UsageFor example you have some proto file with rpc declaration.```protosyntax = &quot;proto3&quot;;package test.v1;service EchoService {    rpc handler(EchoRequest) returns (EchoResponse) {    }}message EchoRequest {    string name = 1;}message EchoResponse {    string name = 1;}```After compile it with grpcio-tools, you get *_pb2.py and *_pb2_grpc.py files, now you can write your service.```pythonfrom stub.test_pb2 import EchoRequest, EchoResponsefrom stub.test_pb2_grpc import EchoServiceServicerclass Servicer(EchoServiceServicer):    def handler(self, request: EchoRequest, context) -&gt; EchoResponse:        return EchoResponse(name=f'test-{request.name}')    def error_handler(self, request: EchoRequest, context) -&gt; EchoResponse:        raise RuntimeError('Some error')```Point pytest with your stubs and service:```pythonimport pytestfrom stub.test_pb2 import EchoRequest@pytest.fixture(scope='module')def grpc_add_to_server():    from stub.test_pb2_grpc import add_EchoServiceServicer_to_server    return add_EchoServiceServicer_to_server@pytest.fixture(scope='module')def grpc_servicer():    from servicer import Servicer    return Servicer()@pytest.fixture(scope='module')def grpc_stub_cls(grpc_channel):    from stub.test_pb2_grpc import EchoServiceStub    return EchoServiceStub```Write little test:```pythondef test_some(grpc_stub):    request = EchoRequest()    response = grpc_stub.handler(request)    assert response.name == f'test-{request.name}'def test_example(grpc_stub):    request = EchoRequest()    response = grpc_stub.error_handler(request)    assert response.name == f'test-{request.name}'``` #### Testing secure server```pythonfrom pathlib import Pathimport pytestimport grpc@pytest.fixture(scope='module')def grpc_add_to_server():    from stub.test_pb2_grpc import add_EchoServiceServicer_to_server    return add_EchoServiceServicer_to_server@pytest.fixture(scope='module')def grpc_servicer():    from servicer import Servicer    return Servicer()@pytest.fixture(scope='module')def grpc_stub_cls(grpc_channel):    from stub.test_pb2_grpc import EchoServiceStub    return EchoServiceStub@pytest.fixture(scope='session')def my_ssl_key_path():    return Path('/path/to/key.pem')@pytest.fixture(scope='session')def my_ssl_cert_path():    return Path('/path/to/cert.pem')@pytest.fixture(scope='module')def grpc_server(_grpc_server, grpc_addr, my_ssl_key_path, my_ssl_cert_path):    &quot;&quot;&quot;    Overwrites default `grpc_server` fixture with ssl credentials    &quot;&quot;&quot;    credentials = grpc.ssl_server_credentials([        (my_ssl_key_path.read_bytes(),         my_ssl_cert_path.read_bytes())    ])    _grpc_server.add_secure_port(grpc_addr, server_credentials=credentials)    _grpc_server.start()    yield _grpc_server    _grpc_server.stop(grace=None)@pytest.fixture(scope='module')def my_channel_ssl_credentials(my_ssl_cert_path):    # If we're using self-signed certificate it's necessarily to pass root certificate to channel    return grpc.ssl_channel_credentials(        root_certificates=my_ssl_cert_path.read_bytes()    )@pytest.fixture(scope='module')def grpc_channel(my_channel_ssl_credentials, create_channel):    &quot;&quot;&quot;    Overwrites default `grpc_channel` fixture with ssl credentials    &quot;&quot;&quot;    with create_channel(my_channel_ssl_credentials) as channel:        yield channel@pytest.fixture(scope='module')def grpc_authorized_channel(my_channel_ssl_credentials, create_channel):    &quot;&quot;&quot;    Channel with authorization header passed    &quot;&quot;&quot;    grpc_channel_credentials = grpc.access_token_call_credentials(&quot;some_token&quot;)    composite_credentials = grpc.composite_channel_credentials(        my_channel_ssl_credentials,        grpc_channel_credentials    )    with create_channel(composite_credentials) as channel:        yield channel@pytest.fixture(scope='module')def my_authorized_stub(grpc_stub_cls, grpc_channel):    &quot;&quot;&quot;    Stub with authorized channel    &quot;&quot;&quot;    return grpc_stub_cls(grpc_channel)```## Run tests against real gRPC serverRun tests against read grpc server worked in another thread:```bashpy.test``````cachedir: .pytest_cacheplugins: grpc-0.0.0collected 2 itemsexample/test_example.py::test_some PASSEDexample/test_example.py::test_example FAILED=================================== FAILURES ====================================_________________________________ test_example __________________________________grpc_stub = &lt;stub.test_pb2_grpc.EchoServiceStub object at 0x107a9b390&gt;    def test_example(grpc_stub):        request = EchoRequest()&gt;       response = grpc_stub.error_handler(request)example/test_example.py:35:_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _.env/lib/python3.7/site-packages/grpc/_channel.py:547: in __call__    return _end_unary_response_blocking(state, call, False, None)_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _state = &lt;grpc._channel._RPCState object at 0x107b263c8&gt;call = &lt;grpc._cython.cygrpc.SegregatedCall object at 0x107b323c8&gt;with_call = False, deadline = None    def _end_unary_response_blocking(state, call, with_call, deadline):        if state.code is grpc.StatusCode.OK:            if with_call:                rendezvous = _Rendezvous(state, call, None, deadline)                return state.response, rendezvous            else:                return state.response        else:&gt;           raise _Rendezvous(state, None, None, deadline)E           grpc._channel._Rendezvous: &lt;_Rendezvous of RPC that terminated with:E           status = StatusCode.UNKNOWNE           details = &quot;Exception calling application: Some error&quot;E           debug_error_string = &quot;{&quot;created&quot;:&quot;@1544451353.148337000&quot;,&quot;description&quot;:&quot;Error received from peer&quot;,&quot;file&quot;:&quot;src/core/lib/surface/call.cc&quot;,&quot;file_line&quot;:1036,&quot;grpc_message&quot;:&quot;Exception calling application: Some error&quot;,&quot;grpc_status&quot;:2}&quot;E           &gt;.env/lib/python3.7/site-packages/grpc/_channel.py:466: _Rendezvous------------------------------- Captured log call -------------------------------_server.py                 397 ERROR    Exception calling application: Some errorTraceback (most recent call last):  File &quot;pytest-grpc/.env/lib/python3.7/site-packages/grpc/_server.py&quot;, line 389, in _call_behavior    return behavior(argument, context), True  File &quot;pytest-grpc/example/src/servicer.py&quot;, line 10, in error_handler    raise RuntimeError('Some error')RuntimeError: Some error================ 1 failed, 1 passed, 1 warnings in 0.16 seconds =================```## Run tests directly to python codeCall handlers directly, with fake grpc internals:```bashpy.test --grpc-fake-server```In this case your get nice direct exceptions:```============================= test session starts =============================cachedir: .pytest_cacheplugins: grpc-0.0.0collected 2 itemsexample/test_example.py::test_some PASSEDexample/test_example.py::test_example FAILED================================== FAILURES ===================================________________________________ test_example _________________________________grpc_stub = &lt;stub.test_pb2_grpc.EchoServiceStub object at 0x10e06f518&gt;    def test_example(grpc_stub):        request = EchoRequest()&gt;       response = grpc_stub.error_handler(request)example/test_example.py:35:_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _pytest_grpc/plugin.py:42: in fake_handler    return real_method(request, context)_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _self = &lt;servicer.Servicer object at 0x10ce75278&gt;, request =context = &lt;pytest_grpc.plugin.FakeContext object at 0x10e083e48&gt;    def error_handler(self, request: EchoRequest, context) -&gt; EchoResponse:&gt;       raise RuntimeError('Some error')E       RuntimeError: Some errorexample/src/servicer.py:10: RuntimeError=============== 1 failed, 1 passed, 1 warnings in 0.10 seconds ================```## Run the servicer on multiple threadsThe number of workers threads for gRPC can be specified in two ways:  - add `--grpc-max-workers=&lt;n&gt;` to the arguments  - test modules can also use a `grpc_max_workers=&lt;n&gt;` variableSee `test_blocking` in example.</longdescription>
</pkgmetadata>