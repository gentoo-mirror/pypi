<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pgnotify: A python library to easily LISTEN to PostgreSQL NOTIFY notifications## ExampleLISTEN to and process NOTIFY events with a simple `for` loop, like so:```pythonfrom pgnotify import await_pg_notificationsfor notification in await_pg_notifications(        'postgresql:///example',        ['channel1', 'channel2']):    print(notification.channel)    print(notification.payload)```## InstallInstallable with any python package manager from the python package index, eg:```shellpip install pgnotify```## All the bells and whistlesYou can also handle timeouts and signals, as in this more fully-fleshed example:```pythonimport signalfrom pgnotify import await_pg_notifications, get_dbapi_connection# the first parameter of the await_pg_notifications# loop is a dbapi connection in autocommit modeCONNECT = &quot;postgresql:///example&quot;# use this convenient method to create the right connection# from a database URLe = get_dbapi_connection(CONNECT)SIGNALS_TO_HANDLE = [signal.SIGINT, signal.SIGTERM]for n in await_pg_notifications(    e,    [&quot;hello&quot;, &quot;hello2&quot;],    timeout=10,    yield_on_timeout=True,    handle_signals=SIGNALS_TO_HANDLE,):    # the integer code of the signal is yielded on each    # occurrence of a handled signal    if isinstance(n, int):        sig = signal.Signals(n)        print(f&quot;handling {sig.name}, stopping&quot;)        break    # the `yield_on_timeout` option makes the    # loop yield `None` on timeout    elif n is None:        print(&quot;timeout, continuing&quot;)    # handle the actual notify occurrences here    else:        print((n.pid, n.channel, n.payload))```Further documentation to come.</longdescription>
</pkgmetadata>