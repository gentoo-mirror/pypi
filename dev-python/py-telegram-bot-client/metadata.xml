<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Telegram Bot API ClientA telegram bot API client is written in python 3.5+ and currently compatible with Telegram Bot API 5.3 and later.The reason for writing this bot utility is that I wish to run multi telegram bots which could have same or different business logic **(route policy)** in one process.I reckon it is lightweight, fast, full implement and only **urllib3** dependent.## Update 6.1Update for Telegram Bot API 6.1## Update 6.0Update for Telegram Bot API 6.0## Update 5.7.0Update for Telegram Bot API 5.7Fix bugs## Update 5.6.0Update for Telegram Bot API 5.6using loop.run_in_executor for synchronous functions## Update 5.5.11fix bugs## Update 5.5.10fix bugs## Update 5.5.9fix bugs## Update 5.5.8fix bugs## Update 5.5.71. code optimization2. fix bugs3. add group method where methods for InlineKeyboard. more detail is in example.callback_query4. change bot.get_file_bytes(file_path, chunk_size) into bot.get_file_bytes(file_obj)## Update 5.5.6add remove and where methods for InlineKeyboard. more detail is in example.callback_query## Update 5.5.5modify router.message_handler(fields) to router.message_handler(*fields)## Update 5.5.41. code optimization2. get_updates returns a iter## Update 5.5.3fix a bug for force reply## Update 5.5.2Remove TelegramRouter from TelegramBot.Do a update dispatch as the update's coming.Have a chance to use yourself route policy on incoming updates.## Update 5.5.11. change cmds of CommandHandler into *cmds2. change errors of ErrorHandler into *errors## Update 5.5Update for the telegram bot api 5.5.Actually, I did nothing on codes. It is compatible with the telegram bot api 5.5.## Update 5.4.21. change a list of regex patterns of regex_match into *args of regex patterns2. add a example/regex_match.py for regex_match's usage## Update  5.4.1Fix bugs## Update 5.4Update for Telegram Bot API 5.4## Update 5.3.7.51. HOT FIX remove &quot;__del__()&quot; from MongoDBStorage## Update 5.3.7.41. check and add storage.__del__() for storages## Update 5.3.7.31. rewrite force_reply. see detail in example.force_reply2. rewrite callback_query. see detail in example.callback_query3. add bot.clear_session method## Update 5.3.7.2 too silly to fix bugs right## Update 5.3.7.1 fix bugs## Update 5.3.71. remove UIHelper2. fix bugs## Update 5.3.6.41. fix bugs## Update 5.3.6.31. optimize codes## Update 5.3.6.21. remove ui stack2. fix bugs## Update 5.3.6.11. add add_lines in ReplyKeyboard. see example/keyboard.py2. fix bugs## Update 5.3.61. update ReplyKeyboard in ui. see example/keyboard.py2. update UIHelper in ui. see example/select.py## Update 5.3.5.7fix bugs and give the bot a get_file_bytes method to download a file. see example/document.py## Update 5.3.5.6optimize codes and remove setup_webhook## Update 5.3.5.5Fix bugs on ErrorHandler## Update 5.3.5.41. compose keyboards see example/keyboard.py2. fix bugs## Update 5.3.5.3Fix bugs## Update 5.3.5.2Fix bugs and add router.remove_handler. see example/dynamic_handler.py## Update 5.3.5.11. Refacted and faster than before.2. Provide a UIHelper in ui for buttons.## Update 5.3.5A large update. I do not write too many details because no one is using it except myself.## Update 5.3.4Add: add get_file_url function in bot## Update 5.3.3Fix bugs and update: support multi emojis for UI buttons## Update 5.3.2Fix bugs and update: add a UI stack for be back to ahead UI, see example.ui_stack.py## Update 5.3.1Change: delete multi keys in session using delete function# Update 5.3Add BotCommandScope Support## Update 5.2.5.1Fix bugs... correct get_file_bytes in TelegramBotAPI## Update 5.2.5Optimize: add a context manager on session implement## Update 5.2.4.1Fix bugs... correct TelegramBotAPIException## Update 5.2.4Optimize: make define your local API host easy, and your API host can use 'http://'## Update 5.2.3Optimize: make all bots call same one TelegramBotAPI instance## Update 5.2.2Add a confirm in ui## Quick to goThis is a simple echo bot.from telegrambotclient import bot_clientfrom telegrambotclient.base import MessageField, ParseMode# define a default router named &quot;default&quot;router = bot_client.router()# decorate a handler callback on incoming message updates that have a text field@router.message_handler(MessageField.TEXT)def on_text_message(bot, message):    # receive and reply    sent_message = bot.send_message(        chat_id=message.chat.id,        text=&quot;I receive: &lt;strong&gt;{0}&lt;/strong&gt;&quot;.format(message.text),        parse_mode=ParseMode.HTML,    )    # pin the sent message    bot.pin_chat_message(chat_id=message.chat.id, message_id=sent_message.message_id)    return bot.stop_call# define a callback for incoming updatesasync def on_update(bot, update):    await router.dispatch(bot, update)# define a botbot = bot_client.create_bot(token=&lt;BOT_TOKEN&gt;)# delete webhook if did or notbot.delete_webhook(drop_pending_updates=True)# run polling to fetch updates in every 10sbot.run_polling(on_update, timeout=10)## Call telegram bot APIstelegrambotclient has same parameter signatures with the official Telegram Bot APIs. Please see [official Telegram Bot API document](https://core.telegram.org/bots/api) when calling telegram bot APIs.### Quick to replyFor send_message api, it provides a shortcut.sent_message = bot.reply_message(        message,        text=&quot;I receive: &lt;strong&gt;{0}&lt;/strong&gt;&quot;.format(message.text),        parse_mode=ParseMode.HTML,    )## Serving on webhookIn my case, I use [fastapi](https://fastapi.tiangolo.com/) and [uvicron](https://www.uvicorn.org/) to provide a HTTP interface to receive updates from the official Telegram Bot Server. For development and testing, [ngrok](https://ngrok.com/) give a HTTPs URL on my localhost server with a real-time HTTP traffic tunnel.# run in terminal and get a https tunnel on port 8000 in Austrliangrok http 8000 --region=ausource code:  from fastapi import FastAPI, Request, statusfrom telegrambotclient import bot_client  from telegrambotclient.base import MessageField, ParseMode    # from ngrok's https url, replace it with yours  WEBHOOK_URL = &quot;https://5f9d0f13b9fb.au.ngrok.io/bot/{0}&quot;bot_token = &quot;&lt;BOT_TOKEN&gt;&quot;    # define a router  router = bot_client.router()@router.message_handler(MessageField.TEXT)def on_text_message(bot, message):    bot.reply_message(message, text=&quot;I receive: &lt;strong&gt;{0}&lt;/strong&gt; from bot1&quot;.format(message.text), parse_mode=ParseMode.HTML)    return bot.stop_callapp = FastAPI()# waiting for incoming updates and dispatch them@app.post(&quot;/bot/{bot_token}&quot;, status_code=status.HTTP_200_OK)async def process_telegram_update(bot_token: str, request: Request):    bot = bot_client.bots.get(bot_token, None)    if bot:await router.dispatch(bot, TelegramObject(**await request.json()))    return &quot;OK&quot;bot = bot_client.create_bot(token=bot_token)bot.setup_webhook(WEBHOOK_URL.format(bot_token))## Serving with multi bots and routers on webhookfrom fastapi import FastAPI, Request, statusfrom telegrambotclient import bot_clientfrom telegrambotclient.base import Message, MessageField, ParseMode# from ngrok's https url, replace it with yoursWEBHOOK_URL = &quot;https://5f9d0f13b9fb.au.ngrok.io/bot/{0}&quot;bot_token_1 = &quot;&lt;BOT_TOKEN_1&gt;&quot;bot_token_2 = &quot;&lt;BOT_TOKEN_2&gt;&quot;    # define 2 default routersrouter1 = bot_client.router(bot_token_1)router2 = bot_client.router(bot_token_2)# bind a handler on router1@router1.message_handler(MessageField.TEXT)def on_router1_message(bot, message):    bot.reply_message(        message,        text=&quot;I receive: &lt;strong&gt;{0}&lt;/strong&gt; from router1&quot;.format(message.text),        parse_mode=ParseMode.HTML,    )# bind a handler on router2@router2.message_handler(MessageField.TEXT)def on_router2_message(bot, message):    bot.reply_message(        message,        text=&quot;I receive: &lt;strong&gt;{0}&lt;/strong&gt; from router2&quot;.format(message.text),        parse_mode=ParseMode.HTML,    )app = FastAPI()# waiting for incoming updates and dispatch them@app.post(&quot;/bot/{bot_token}&quot;, status_code=status.HTTP_200_OK)async def serve_update(bot_token: str, request: Request):    bot = bot_client.bots.get(bot_token, None)    if bot:router = bot_client.routers.get(bot_token, None)if router:      await router.dispatch(bot, TelegramObject(**await request.json()))    return &quot;OK&quot;bot1 = bot_client.create_bot(token=bot_token_1)bot1.setup_webhook(WEBHOOK_URL.format(bot_token_1))bot2 = bot_client.create_bot(token=bot_token_2)bot2.setup_webhook(WEBHOOK_URL.format(bot_token_2))##  Register handlers### decorator@router.message_handler(MessageField.TEXT)def on_message(bot, message):pass### functiona good way to register one callback on multi routersdef on_message(bot, message):    passrouter1.register_message_handler(on_message, MessageField.TEXT)router2.register_message_handler(on_message, MessageField.TEXT)### serve for multi message fields# callback for a animation message that includes 'animation' AND 'document' fields@router.message_handler(MessageField.ANIMATION, MessageField.DOCUMENT)def on_animation(bot, message: Message):    pass## [Please try examples for more detail](https://github.com/songdi/py-telegram-bot-client/tree/main/example)</longdescription>
</pkgmetadata>