<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># IBM Watson Pipelines Python ClientThis package provides various utilities for working with IBM Watson Pipelines. Its primary usage is to enable users to store artifact results of a notebook run.## Usage### Construction`WatsonPipelines` client is constructed from IAM APIKEY, which can be providedin a few ways:* explicitly:  ```python  from ibm_watson_pipelines import WatsonPipelines    client = WatsonPipelines(apikey)  # or  client = WatsonPipelines.from_apikey(apikey)  # or  client = WatsonPipelines.from_token(token)  ```* implicitly:  ```bash  APIKEY=...  export APIKEY  ```  or  ```bash  USER_ACCESS_TOKEN=...  export USER_ACCESS_TOKEN  ```  ```python  from ibm_watson_pipelines import WatsonPipelines  # use APIKEY  client = WatsonPipelines.from_apikey()  # use USER_ACCESS_TOKEN  client = WatsonPipelines.from_token()  # try APIKEY, if absent then USER_ACCESS_TOKEN:  client = WatsonPipelines()  # or  client = WatsonPipelines.new_instance()  ```All of the above may also define `service_name` and `url`.The exact procedure of deciding which authentication method to use:1. If `from_apikey` or `from_token` is used, the method is forced.2. If constructor is used but either `apikey` or `bearer_token` argument  was provided, that method will be forced (if both are present,  an overloading error will be raised). Note that providing a nameless  argument is equivalent to providing `apikey`.3. If constructor or `new_instance` is used, `APIKEY` env-var is used.4. If constructor or `new_instance` is used, but `APIKEY` env-var is not   present, `USER_ACCESS_TOKEN` env-var is used.5. If none of the above matches, an error is returned.### Usage in Python notebooksNotebooks run in IBM Watson Pipelines get inputs and exposeoutputs as a node:```{  &quot;id&quot;: ...,  &quot;type&quot;: &quot;execution_node&quot;,  &quot;op&quot;: &quot;run_container&quot;,  &quot;app_data&quot;: {    &quot;pipeline_data&quot;: {      &quot;name&quot;: ...,      &quot;config&quot;: {        &quot;link&quot;: {          &quot;component_id_ref&quot;: &quot;run-notebook&quot;        }      },      &quot;inputs&quot;: [        ...,        {          &quot;name&quot;: &quot;model_name&quot;,          &quot;group&quot;: &quot;env_variables&quot;,          &quot;type&quot;: &quot;String&quot;,          &quot;value_from&quot;: ...        }      ],      &quot;outputs&quot;: [        {          &quot;name&quot;: &quot;trained_model&quot;,          &quot;group&quot;: &quot;output_variables&quot;,          &quot;type&quot;: {            &quot;CPDPath&quot;: {              &quot;path_type&quot;: &quot;resource&quot;,              &quot;resource_type&quot;: &quot;asset&quot;,              &quot;asset_type&quot;: &quot;wml_model&quot;            }          }        }      ]    }  },  ...}```Inside of the notebook, inputs are available as environmentalvariables:```pythonmodel_name = os.environ['model_name']```Outputs are exposed using sdk method, `store_results`:```pythonclient = WSPipelines.from_apikey(...)client.store_results({  &quot;trained_model&quot;: ... // cpd path to the trained model})```### Extracting credentialsOn public cloud, this client provides a method for easy retrieval of WMLinstance credentials and scope storage credentials:```pythonclient.get_wml_credentials() # the scope passed in notebook# orclient.get_wml_credentials(&quot;cpd:///projects/123456789&quot;)``````pythonclient.get_storage_credentials() # the scope passed in notebook# orclient.get_storage_credentials(&quot;cpd:///projects/123456789&quot;)```Note how the result will vary depending on the authentication methodused to create the client.### CPD-Path manipulationCPD-Path parsing is manipulation is also supported:```pythonfrom ibm_watson_pipelines import CpdScope, WatsonPipelinesclient = WatsonPipelines.from_apikey()scope = CpdScope.from_string(&quot;cpd:///projects/123456789&quot;)assert scope.scope_type() == &quot;projects&quot;assert scope.scope_id() == &quot;123456789&quot;client.get_wml_credentials(scope)```Different kinds of CPD-Paths will have different properties, providing the sameinterface across scopes, resource and file paths:```pythonfrom ibm_watson_pipelines import CpdPathscope_file_path = CpdPath.from_string(&quot;cpd:///projects/123456789/files/abc/def&quot;)assert scope_file_path.scope_type() == &quot;projects&quot;assert scope_file_path.scope_id() == &quot;123456789&quot;assert scope_file_path.file_path() == &quot;/abc/def&quot;connection_path = CpdPath.from_string(&quot;cpd:///projects/123456789/connections/3141592&quot;)assert connection_path.scope_type() == &quot;projects&quot;assert connection_path.scope_id() == &quot;123456789&quot;assert connection_path.resource_type() == &quot;connections&quot;assert connection_path.resource_id() == &quot;3141592&quot;connection_file_path = CpdPath.from_string(&quot;cpd:///projects/123456789/connections/3141592/files/~/abc/def&quot;)assert connection_file_path.scope_type() == &quot;projects&quot;assert connection_file_path.scope_id() == &quot;123456789&quot;assert connection_file_path.resource_type() == &quot;connections&quot;assert connection_file_path.resource_id() == &quot;3141592&quot;assert connection_file_path.bucket_name() == &quot;~&quot;assert connection_file_path.file_path() == &quot;/abc/def&quot;```...additionally, for non-scope paths the scope can be extracted, if present:```pythonfrom ibm_watson_pipelines import CpdPathscope_path = CpdPath.from_string(&quot;cpd:///projects/123456789&quot;)connection_path = CpdPath.from_string(&quot;cpd:///projects/123456789/connections/3141592&quot;)assert connection_path.scope() == scope_path```### Custom components for use in the pipelineA custom pipeline component executes a script you write. You can use custom components to share reusable scripts between pipelines.You create custom components as project assets. You can then use the components in pipelines you create in that project. You can create as many custom components for pipelines as needed. Currently, to create a custom component you must create one programmatically, using a Python function.#### Creating a component as a project assetTo create a custom component, use the Python client to authenticate with IBM Watson Pipelines, code the component, then publish the component to the specified project. After it is available in the project, you can assign it to a node in a pipeline and run it as part of a pipeline flow.This example demonstrates the process of publishing a component that adds two numbers together.Publish a function as a component with the latest Python client. Run the following code in a Jupyter notebook in a project of your Cloud Pak for Data.```python# Install libraries! pip install ibm-watson-pipelines==1.0.0# Authenticationfrom ibm_watson_pipelines import WatsonPipelinesapikey = ''service_url = 'your_host_url'project_id = 'your_project_id'client = WatsonPipelines.from_apikey(apikey, url=service_url)# Define the function of the component# If you define the input parameters, users are required to # input them in the UIdef add_two_numbers(a: int, b: int) -&gt; int:  print('Adding numbers: {} + {}.'.format(a, b))  return a + b + 10  # Other possible functions might be sending a Slack message,# or listing directories in a storage volume, and so on.# Publish the component    client.publish_component(  name='Add numbers', # Appears in UI as component name   func=add_two_numbers,  description='Custom component adding numbers', # Appears in UI as component description   project_id=project_id,  overwrite=True, # Overwrites an existing component with the same name )```#### Manage pipeline components- list components from a project:```pythonclient.get_components(project_id=project_id)```- get a component by ID:```pythonclient.get_component(project_id=project_id, component_id=component_id)```- get a component by name:```pythonclient.get_component(project_id=project_id, name=component_name)```- publish a new component:```pythonclient.publish_component(component name)```- delete a component by ID:```pythonclient.delete_component(project_id=project_id, component_id=component_id)```</longdescription>
</pkgmetadata>