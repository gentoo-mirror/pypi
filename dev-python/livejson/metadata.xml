<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;h1 align=&quot;center&quot;&gt;livejson&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://travis-ci.org/controversial/livejson&quot; align=&quot;center&quot;&gt;        &lt;img alt=&quot;Build Status&quot; src=&quot;https://travis-ci.org/controversial/livejson.svg?branch=master&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://coveralls.io/github/controversial/livejson?branch=master&quot; align=&quot;center&quot;&gt;        &lt;img alt=&quot;Coverage Status&quot; src=&quot;https://coveralls.io/repos/github/controversial/livejson/badge.svg?branch=master&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/&quot; align=&quot;center&quot;&gt;        &lt;img alt=&quot;PEP8&quot; src=&quot;https://img.shields.io/badge/PEP8-compliant-brightgreen.svg&quot;&gt;    &lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;An interface to transparently bind Python objects to JSON files, so that all changes made to the object are reflected in the JSON file&lt;/p&gt;---`livejson` allows you to cleanly manipulate JSON objects as though they were Python `dict`s, with your file transparently updating in the background. It's **pure-python with no dependencies**, and compatible across Python 2 and Python 3.![Demo gif](https://i.imgur.com/yaXzzjG.gif)`livejson` is:- **Easy**: use `livejson` with the same interface as Python `list`s and `dict`s, meaning it can basically be used as a drop-in replacement.- **Flexible**: `livejson` fully supports complex nestings of `list`s and `dict`s, meaning it can represent any valid JSON file.- **Compatible**: `livejson` works perfectly on both Python 2 and Python 3.- **Lightweight**: `livejson` is a single file with no external dependencies. Just install and go!- **Reliable**: by default, no caching is used. Every single time you access a `livejson.Database`, it's read straight from the file. And every time you write to it, the change is instant. No delays, no conflicts. However, if efficiency is important, you can use the context manager to perform &quot;grouped writes&quot;, which allow for performing a large number of operations with only one write at the end.- **100% test covered** Be confident that `livejson` is working properly`livejson` can be used for:- **Database storage**: you can use `livejson` to easily write flexible JSON databases, without having to worry about complex `open` and `close` operations, or learning how to use the `json` module.- **Debugging**: You can use `livejson` to back up your Python objects. If you use a `livejson.Database` instead of a `dict` or a `list` and your script crashes you'll still  have a hard copy of your object. And you barely had to change any of your code.- **General-purpose JSON**: If your script or application needs to interact with JSON files in any way, consider using `livejson`, for simplicity's sake. `livejson` can make your code easier to read and understand, and also save you time.Thanks to [dgelessus](https://github.com/dgelessus) for naming this project.## Installing`livejson` supports both Python 2 and 3, and can be easily installed with `pip`.```bash# Python 2sudo pip install livejson# Python 3sudo pip3 install livejson```After installing, you can just `import livejson` from your code!## Example usageBasic usage:```pythonimport livejsonf = livejson.File(&quot;test.json&quot;)f[&quot;a&quot;] = &quot;b&quot;# That's it, the file has been written to!```As a context manager:```pythonimport livejsonwith livejson.File(&quot;test.json&quot;) as f:    f[&quot;a&quot;] = &quot;b&quot;```</longdescription>
</pkgmetadata>