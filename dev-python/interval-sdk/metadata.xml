<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># interval-sdk## InstallationInstall using pip, (or your python package manager of choice):```pip install interval-sdk```## API*Note:* Proper documentation is in progress!See `src/demos/basic.py` and `src/tests` for a better overview, but in short:```pythonfrom interval_sdk import Interval, IO# Initialize Intervalinterval = Interval(&quot;API_KEY&quot;)# Add an action using the function name as the slug@interval.actionasync def hello_interval():    return {&quot;hello&quot;: &quot;from python!&quot;}# Add an action using a custom slug (can contain hyphens) and additional configuration@interval.action(slug='echo-message', unlisted=True)async def echo_message(io: IO):    [message] = await io.group(io.input.text(&quot;Hello!&quot;, help_text=&quot;From python!&quot;))    return {&quot;message&quot;: message}# Synchronously listen, blocking foreverinterval.listen()```To not block, interval can also be run asynchronously using`interval.listen_async()`. You must provide your own event loop.The task will complete as soon as connection to Interval completes, so youlikely want to run forever or run alongside another permanent task.```pythonimport asyncio# This is what synchronous `listen()` does under the hoodloop = asyncio.get_event_loop()task = loop.create_task(interval.listen_async())def handle_done(task: asyncio.Task[None]):    try:        task.result()    except:        loop.stop()task.add_done_callback(handle_done)loop.run_forever()```If you are using `run_forever()`, you'll probably want to add signal handlersto close the loop gracefully on process termination:```pythonimport asyncio, signalloop = asyncio.get_event_loop()task = loop.create_task(interval.listen_async())def handle_done(task: asyncio.Task[None]):    try:        task.result()    except:        loop.stop()task.add_done_callback(handle_done)for sig in {signal.SIGINT, signal.SIGTERM}:    loop.add_signal_handler(sig, loop.stop)loop.run_forever()```## ContributingThis project uses [Poetry](https://python-poetry.org/) for dependencymanagement1. `poetry install` to install dependencies2. `poetry shell` to activate the virtual environmentTasks are configured using [poethepoet](https://github.com/nat-n/poethepoet)(installed as a dev dependency).- `poe demo [demo_name]` to run a demo (`basic` by default if `demo_name` omitted)- `poe test` to run `pytest` (can also run `pytest` directly in virtual env)Code is formatted using [Black](https://github.com/psf/black). Please configureyour editor to format on save using Black, or run `poe format` to format thecode before committing changes.## Tests*Note:* Tests currently require a local instance of the Interval backend.Tests use [pytest](https://docs.pytest.org/en/7.1.x/) and[playwright](https://playwright.dev/python/).Currently assumes the `test-runner@interval.com` user exists already.Run `yarn test` in the `web` directory at least once to create it beforerunning these.</longdescription>
</pkgmetadata>