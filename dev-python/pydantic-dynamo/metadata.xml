<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pydantic-dynamoA Python repository over DynamoDB, leveraging the excellent [Pydantic](https://docs.pydantic.dev/) library to model records.[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)## ContributingPlease see [the contributing guide](./contributing.md).## InstallationInstall from PyPI:```pip install pydantic-dynamo```Or even better, use [Poetry](https://python-poetry.org/docs/):```poetry add pydantic-dynamo```## UsageAll of the goodness of pydantic data modeling, pointed at your DynamoDB table instead of your REST API.The ideal consumer is a developer of a low-to-medium complexity application. You will losesome benefits of the single-table pattern, specifically the ability to queryand retrieve objects of different types in a single connection. Except the most complex single-table examples, access patterns can be implemented to utilize the `list`/`list_between`and `get_batch` functions, documented below, to prevent N+1 queries and provide sufficient performance.### Table CreationThis package assumes the specified table already exists and the application it isrunning from has sufficient access to the table.The following IAM permissions are required:```yaml- dynamodb:BatchGetItem- dynamodb:BatchWriteItem- dynamodb:GetItem- dynamodb:PutItem- dynamodb:Query- dynamodb:UpdateItem```### ModelingCreate a Pydantic model specifically for storage. This should generally not be sharedin API contracts or other external interfaces to adhere to single-responsibility principle.```pythonfrom pydantic import BaseModelfrom typing import Optionalclass FilmActor(BaseModel):    id: str    name: str    review: Optional[str]    ```#### Reserved Attribute NamesThis package implicitly uses the following attributes, and therefore they should not be used in anyobject model classes.| Attribute            | Usage                                                                                                                   ||----------------------|-------------------------------------------------------------------------------------------------------------------------|| `_table_item_id`     | Default Partition Key name, can be overridden in repository instantiation. *Not a default in v2*                        || `_table_content_id`  | Default Sort Key name, can be overridden in repository instantiation. *Not a default in v2*                             || `_timestamp`         | Automatic ISO-formatted timestamp for when record was created or updated                                                || `_object_version`    | Internal object versioning integer, automatically incremented on update, and can be used to enforce conditional updates || `_ttl`               | Optionally used to store the DynamoDB TTL expiry value, which must be declared in the table's `TimeToLiveSpecification` |## Version 1 (Deprecated)The original repository implementation that still exists but will no longer receive updates.This will be removed in a future release.[V1 Documentation](./docs/v1.md) has been moved to keep the main README a reasonable size.## Version 2 (Experimental)This is the implementation that is intended for longer-term maintenance and will receive updates.### InstantiationV2 removes the `build` convenience function found in V1 and provides only a `__init__` constructor. Since V2 is async-firstthe table and resource objects need to be constructed from [aioboto3](https://aioboto3.readthedocs.io/en/latest/usage.html#dynamodb-examples)A working example can be found in the [integration tests conftest.py](./tests/test_integration/conftest.py)```pythonfrom aioboto3 import Sessionfrom pydantic_dynamo.v2.repository import DynamoRepositoryfrom tests.models import Example # Use your record model insteadsession = Session()boto3_kwargs = {&quot;service_name&quot;: &quot;dynamodb&quot;} # endpoint_url, region_name, etc.async with session.resource(**boto3_kwargs) as resource:    repo = DynamoRepository[Example](        item_class=Example,        partition_prefix=&quot;test&quot;,        partition_name=&quot;integration&quot;,        content_type=&quot;example&quot;,        table_name=&quot;table_name&quot;,        partition_key=&quot;PARTITION_KEY&quot;,        sort_key=&quot;SORT_KEY&quot;,        table=await resource.Table(&quot;table_name&quot;),        resource=resource,    )```There is also a synchronous variant that can be used if you don't want to work with async/await and async generatorsin your business code. Most of the subsequent documentation is focused on the async variant.```pythonfrom aioboto3 import Sessionfrom pydantic_dynamo.v2.repository import DynamoRepositoryfrom pydantic_dynamo.v2.sync_repository import SyncDynamoRepositoryfrom tests.models import Example # Use your record model insteadsession = Session()boto3_kwargs = {&quot;service_name&quot;: &quot;dynamodb&quot;} # endpoint_url, region_name, etc.async with session.resource(**boto3_kwargs) as resource:    repo = DynamoRepository[Example](        item_class=Example,        partition_prefix=&quot;test&quot;,        partition_name=&quot;integration&quot;,        content_type=&quot;example&quot;,        table_name=&quot;table_name&quot;,        partition_key=&quot;PARTITION_KEY&quot;,        sort_key=&quot;SORT_KEY&quot;,        table=await resource.Table(&quot;table_name&quot;),        resource=resource,    )    sync_repo = SyncDynamoRepository[Example](async_repo=repo)```### Saving DataData is saved using an instance of the generic `PartitionedContent[ObjT]` class found in [models.py](./pydantic_dynamo/models.py). The `partition_ids` and `content_ids` are `List[str]`. Each value in the list is concatenated before saving, and prefixed with the repository's configured values.For the `content_ids` field, you can leverage this to achieve degrees of query-ability formore complex use cases, eg: `content_ids=[&quot;usa&quot;, &quot;ny&quot;, &quot;saratoga&quot;, &quot;12020&quot;]` will result in a sort key value of `usa#ny#saratoga#12020` that can be efficiently queried with DynamoDB's `begins_with`condition, utilized in this library's `list` function.It's wise to ensure that any values being used in the partition and content IDs are also retained as fields on the model object as well, which will make updates easier to perform. *This is less critical nowsince the V2 responses include reified `PartitionedContent[ObjT]` objects instead of just the modeled records in V1.*#### Put Single ItemThis leverages the DynamoDB Put operation, and will overwrite an existing item with identical partition and content IDs.```pythonfrom pydantic_dynamo.models import PartitionedContentfrom uuid import uuid4id1 = str(uuid4())actor1 = FilmActor(id=id1, name=&quot;Daniel Day-Lewis&quot;)await repo.put(    PartitionedContent[FilmActor](        partition_ids=[], content_ids=[id1], item=actor1    ))```#### Put Multiple ItemsWhen saving more than one item, you can use a batch operation that will utilize DynamoDB's `write_batch` operation, which will more efficiently buffer data and minimize the total number of network calls compared to calling`put` in a loop.```pythonfrom pydantic_dynamo.models import PartitionedContentfrom uuid import uuid4id1 = str(uuid4())actor1 = FilmActor(id=id1, name=&quot;Daniel Day-Lewis&quot;)id2 = str(uuid4())actor2 = FilmActor(id=id2, name=&quot;Steve Buscemi&quot;)await repo.put_batch(    (        PartitionedContent[FilmActor](            partition_ids=[], content_ids=[id1], item=actor1        ),        PartitionedContent[FilmActor](            partition_ids=[], content_ids=[id2], item=actor2        ),    ))```#### Update an itemNB: Please review the limitation in [issue #1](https://github.com/david-a-jetter/pydantic-dynamo/issues/1)Updates are handled in a somewhat more complex and manual manner using an `UpdateCommand` object. Since this is constructed by sending `Dict[str, Any]`, dictionary entries are validated againstthe pydantic model's schema before sending data to DynamoDB.`set_commands` can be used to map attributes' names to a new value.`increment_attrs` can be used to increment attributes' current values by some integer.`append_attrs` can be used to extend a `List` attribute's values`current_version` can be used to enforce a check on the object's version number toadhere to an object versioning pattern. ```pythonfrom pydantic_dynamo.models import UpdateCommandawait repo.update(    partition_id=None,    content_id=[id1],    command=UpdateCommand(        set_commands={&quot;review&quot;: &quot;Talented, but unfriendly in Gangs of New York&quot;}    ))```### Reading Data#### Get ItemFinally, something simple to document. This gets a single item by its partition and content IDs,returning `None` if no item is found.This example would retrieve just the first actor item.```pythonfrom typing import Optionalfrom pydantic_dynamo.models import PartitionedContentitem: Optional[PartitionedContent[FilmActor]] = await repo.get(partition_id=None, content_id=[id1])```#### Reading Multiple ItemsThis and all subsequent read operations return `AsyncIterable[BatchResponse[ObjT]]` references. These cannot be directly awaited,but rather need to be iterated in an async loop. See [PEP-525](https://peps.python.org/pep-0525/) for details and thisrepository's tests for complete examples.Most DynamoDB batch operations implement a continuation token pattern, where the API will return a subset of the datathat matches the parameters up to some stored size (eg. 1MB) and then includes a continuation token to use in a subsequentAPI call.A single `BatchResponse[ObjT]` represents one API response from DynamoDB, and contains an `Iterable[ObjT]` reference. This leavesyou as the consumer in complete control whether you should lazily stream the records or project them all into a list.#### Get Batch by KeyThis leverages DynamoDB's `batch_get_item` API to collect multiple items by their partition and content IDs.This is often useful after having collected a previous set of records that have potentially relateditems that you want to retrieve, and then associate the two in a subsequent mapping logic layer.This example would retrieve both actor items in a single network request.```pythonfrom typing import Listfrom pydantic_dynamo.models import PartitionedContentitems: List[PartitionedContent[FilmActor]] = [    content     async for response in repo.get_batch([(None, [id1]), (None, [id2])])    for content in response.contents                      ]```#### Listing ItemsThe following two functions leverage DynamoDB's `query` API and offers the ability to filter on partial content ID values, change sort order, limit the quantity of items.These operations support optional kwargs: * `limit` integer to cap the number of records returned* `sort_ascending` boolean to change sort order based on the sort key value, which defaults to `True`##### FilteringYou may also pass an optional `FilterCommand` to filter on non-key attributes. All fieldson this object are optional, and are applied utilizing `and` logic.```pythonfrom pydantic_dynamo.models import FilterCommand# Find actors without a `review` attributefilter1 = FilterCommand(    not_exists={&quot;review&quot;})# Find actors who are talented but unfriendly in Gangs of New Yorkfilter2 = FilterCommand(    equals={&quot;review&quot;: &quot;Talented, but unfriendly in Gangs of New York&quot;})# Find actors who are not talented but unfriendly in Gangs of New Yorkfilter3 = FilterCommand(    not_equals={&quot;review&quot;: &quot;Talented, but unfriendly in Gangs of New York&quot;})```These operations are more interesting with a more complex data model, so let's pretend there might be more than one opinion on a given actor, so we'll store many reviews instead of just my own.Let's define a review model that can be related to an actor:```pythonfrom pydantic import BaseModelfrom datetime import datetimeclass ActorReview(BaseModel):    id: str    actor_id: str    created: datetime    review: str```and then pretend we save a few of them:```pythonfrom datetime import datetime, timezonefrom uuid import uuid4now = datetime.now(tz=timezone.utc)await repo.put_batch(    (        PartitionedContent[ActorReview](            partition_ids=[actor1.id],            content_ids=[now.isoformat()],            item=ActorReview(                id=str(uuid4()),                actor_id=actor1.id,                created=now,                review=&quot;I really thought he was the hero of this movie&quot;            )        ),        PartitionedContent[ActorReview](            partition_ids=[actor1.id],            content_ids=[now.isoformat()],            item=ActorReview(                id=str(uuid4()),                actor_id=actor1.id,                created=now,                review=&quot;He really embodies the New York state of mind&quot;            )        )    ))```##### ListThis function supports filter items with a `begins_with` filter on their content IDs.This example would retrieve all review items for `actor1` that we previously saved.```pythonfrom typing import Listfrom pydantic_dynamo.models import PartitionedContentitems: List[PartitionedContent[ActorReview]] = [    content    async for response in repo.list(        partition_id=[actor1.id],        content_prefix=None,        sort_ascending=True,        limit=None,        filters=None    )    for content in response.contents]```This example would retrieve all of the reviews created on a given year, because ISO-formatted datetimevalues are lexicographically sortable.```pythonfrom typing import Listfrom pydantic_dynamo.models import PartitionedContentitems: List[PartitionedContent[ActorReview]] = [    content    async for response in repo.list(        partition_id=[actor1.id],        content_prefix=[&quot;2023&quot;],        sort_ascending=True,        limit=None,        filters=None    )    for content in response.contents]```##### List BetweenThis function supports filter items with a `between` filter on their content IDs.NB: If `content_start == content_end` this will revert to calling `list` using `begins_with`. This preventsunexpected behavior of returning no records due to how Dynamo's Query API handles `between` conditions.This example would retrieve all reviews for actor1 that were created in or after January 2023 *and* in or before March 2023.```pythonfrom typing import Listfrom pydantic_dynamo.models import PartitionedContentitems: List[PartitionedContent[[FilmActor]] = [    content    async for response in repo.list_between(        partition_id=[actor1.id],        content_start=[&quot;2023-01&quot;],        content_end=[&quot;2023-04&quot;],        sort_ascending=True,        limit=None,        filters=None    )    for content in response.contents]```</longdescription>
</pkgmetadata>