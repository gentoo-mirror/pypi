<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># aioredis_lock[![CircleCI](https://circleci.com/gh/mrasband/aioredis-lock.svg?style=svg)](https://circleci.com/gh/mrasband/aioredis-lock)Implementation of distributed locking with [aioredis](https://github.com/aio-libs/aioredis), an asyncio based redis client.This is a standalone lib until, and if, [aio-libs/aioredis#573](https://github.com/aio-libs/aioredis/pull/573) is accepted.## UsageYou need an `aioredis.RedisConnection` or `aioredis.ConnectionsPool` already created.### Mutex```pythonfrom aioredis_lock import RedisLock, LockTimeoutErrortry:    async with RedisLock(        pool,        key=&quot;foobar&quot;,        # how long until the lock should expire (seconds). this can be extended        # via `await lock.extend(30)`        timeout=30,        # you can customize how long to allow the lock acquisitions to be        # attempted.        wait_timeout=30,    ) as lock:        # If you get here, you now have a lock and are the only program that        # should be running this code at this moment.        # do some work...        # we may want it longer...        await lock.extend(30)except LockTimeoutError:    # The lock could not be acquired by this worker and we should give up    pass```### Simple Leader/Follower(s)Let's suppose you need a simple leader/follower type implementation where you have a number of web-workers but just want 1 to preform a repeated task. In the case the leader fails someone else should pick up the work. Simply pass `wait_timeout=None` to RedisLock allowing the worker to keep trying to get a lock for when the leader eventually fails. The main complication here is extending the lock and validating the leader still owns it.```pythonfrom aioredis_lock import RedisLock# if the lock is lost, we still want to be a followerwhile True:    # wait indefinitely to acquire a lock    async with RedisLock(pool, &quot;shared_key&quot;, wait_timeout=None) as lock:        # hold the lock as long as possible        while True:            if not await lock.is_owner():                logger.debug(&quot;We are no longer the lock owner, falling back&quot;)                break            # do some work            if not await lock.renew():                logger.debug(&quot;We lost the lock, falling back to follower mode&quot;)                break```This mostly delegates the work of selecting and more importantly promoting leaders.</longdescription>
</pkgmetadata>