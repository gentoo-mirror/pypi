<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Pynisher is a library to limit resources of a function call in a synchronous manner.You can use this to ensure that your function doesn't use up more resources than itshould.## UsageLimit the time a process can take```pythonimport pynisherdef sleepy(x: int) -&gt; int:    time.sleep(x)    return x# You can also use `cpu_time` insteadwith pynisher.limit(sleepy, wall_time=7) as limited_sleep:    x = limited_sleep(10)  # Will raise a TimeoutException```Limit the memory usage in a sequential manner```pythonfrom pynisher import limit, MemoryLimitException, WallTimeoutExceptiondef train_memory_hungry_model(X, y) -&gt; Model:    # ... do some thing    return modelmodel_trainer = limit(    train_memory_hungry_model,    memory=(500, &quot;MB&quot;),    wall_time=(1.5, &quot;h&quot;)  # 1h30m)try:    model = model_trainer(X, y)except (WallTimeoutException, MemoryLimitException):    model = None```Passing `raises=False` means it will hide all errors and will return `EMPTY` ifthere is no result to give back.```pythonfrom pynisher import limit, EMPTYdef f():    raise ValueError()limited_f = limit(f, wall_time=(2, &quot;m&quot;), raises=False)result = limited_f()if result is not EMPTY:    # ...```You can even use the decorator, in which case it will always be limited.Please note in [Details](#details) that support for this is limited and mostlyfor Linux.```pythonfrom pynisher import restricted@restricted(wall_time=1, raises=False)def notify_remote_server() -&gt; Response:    &quot;&quot;&quot;We don't care that this fails, just give it a second to try&quot;&quot;&quot;    server = block_until_access(...)    response = server.notify()notify_remote_server()# ... continue on even if it failed```You can safely raise errors from inside your function and the same kind of error will be reraisedwith a traceback.```pythonfrom pynisher import limitdef f():    raise ValueError()limited_f = limit(f)try:    limited_f()except ValueError as e:    ... # do what you need```If returning very large items, prefer to save them to file first and then read the result assending large objects through pipes can be very slow.```pythonfrom pathlib import Pathimport picklefrom pynisher import limitdef train_gpt3(save_path: Path) -&gt; bool:    gpt3 = ...    gpt3.train()    with save_path.open('wb') as f:        pickle.dump(gpt3, f)    return Truepath = Path('gpt3.model')trainer = limit(train_gpt3, memory=(1_000_000, &quot;gb&quot;)):try:    trainer(save_path=path)    with path.open(&quot;rb&quot;) as f:        gpt3 = pickle.load(f)except MemoryLimitException as e:    ...```## DetailsPynisher works by running your function inside of a subprocess.Once in the subprocess, the resources will be limited for that process before running yourfunction. The methods for limiting specific resources can be found within the respective`pynisher/limiters/&lt;platform&gt;.py`.#### FeaturesTo check if a feature is supported on your system:```pythonfrom pynisher import limitfor limit in [&quot;cpu_time&quot;, &quot;wall_time&quot;, &quot;memory&quot;, &quot;decorator&quot;]:    print(f&quot;Supports {limit} - {supports(limit)}&quot;)limited_f = limit(f, ...)if not limited_f.supports(&quot;memory&quot;):    ...```Currently we mainly support Linux with partial support for Mac and Windows:| OS      | `wall_time`        | `cpu_time`              | `memory`                | `@restricted`      || --      | -----------        | ----------              | --------                | -------------      || Linux   | :heavy_check_mark: | :heavy_check_mark:      | :heavy_check_mark:      | :heavy_check_mark: || Windows | :heavy_check_mark: | :heavy_check_mark: (1.) | :heavy_check_mark: (1.) | :x:  (3.)          || Mac     | :heavy_check_mark: | :heavy_check_mark: (4.) | :x: (2.)                | :x:  (3.)          |1. Limiting memory and cputime on Windows is done with the library `pywin32`. There seemto be installation issues when instead of using `conda install &lt;x&gt;`, you use `pip install &lt;x&gt;`inside a conda environment, specifically only with `Python 3.8` and `Python 3.9`.The workaround is to instead install `pywin32` with conda, which can be done with`pip uninstall pywin32; conda install pywin32`.Please see this [issue](https://github.com/mhammond/pywin32/issues/1865) for updates.2. Mac doesn't seem to allow for limiting a processes memory. No workaround has been foundincluding trying `launchctl` which seems global and ignores memory limiting. Possibly `ulimit`could work but needs to be tested. Using `setrlimit(RLIMIT_AS, (soft, hard))` does nothingand will either fail explicitly or silently, hence we advertise it is not supported.However, passing a memory limit on mac is still possible but may not do anything useful oreven raise an error. If you are aware of a solution, please let us know.3. This is something due to how multiprocessing pickling protocols work, hence `@restricted(...)` doesnot work for your Mac/Windows. Please use the `limit` method of limiting resources in this case.(Technically this is supported for Mac Python 3.7 though). This is likely due to the default`spawn` context for Windows and Mac but using other available methods on Mac also seems to not work.For Linux, the `fork` and `forkserver` context seems to work.4. For unknown reasons, using `time.process_time()` to query the cpu time usage within a pynished functionwill cause the `cpu_time` limits to be ignored on Mac, leading to a function that will hang indefinitlyunless using some other limit. Please let us know if this is some known issue or any workarounds areavailable.#### ParametersThe full list of options available with both `limit` and `@restricted` are:```python# The name given to the multiprocessing.Processname: str | None = None# The memory limit to place. Specify the amount of bytes or (int, unit) where unit# can be &quot;B&quot;, &quot;KB&quot;, &quot;MB&quot; or &quot;GB&quot;memory: int | tuple[int, str] | None = None# The cpu time in seconds to limit the process to. This time is only counted while the# process is active.# Can provide in (time, units) such as (1.5, &quot;h&quot;) to indicate one and a half hours.# Units available are &quot;s&quot;, &quot;m&quot;, &quot;h&quot;cpu_time: int | tuple[float, str] | None = None# The wall time in seconds to limit the process to# Can provide in (time, units) such as (1.5, &quot;h&quot;) to indicate one and a half hours.# Units available are &quot;s&quot;, &quot;m&quot;, &quot;h&quot;wall_time: int | tuple[float, str] | None = None# Whether to throw any errors that occured in the subprocess or to silently# throw them away. If `True` and an Error was raised, `None` will be returned.# The errors raised in the subprocess will be the same type that are raised in# the controlling process. The exception to this are MemoryErrors which occur# in the subprocess, we convert these to MemoryLimitException.raises: bool = True# This is the multiprocess context used, please refer to their documentation# https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methodscontext: &quot;fork&quot; | &quot;spawn&quot; | &quot;forkserver&quot; | None = None# Whether to emit warnings from  limit or not. The current warnings:# * When the memory limit is lower than the starting memory of a process# * When trying to remove the memory limit for sending back information#   from the subprocess to the main processwarnings: bool = True# How to handle errors. If `bool` then this decides whether or not to wrap them in# a pynisher exception. If `list`, you can specify which errors get wrapped in a# pynisher exception and if `dict`, you can specify what kind of errors get wrapped# and how. See `pynisher::Pynisher::__init__` for more details on `dict`## * wrap_errors={ &quot;memory&quot;: [ImportError, (OSError, 22)], &quot;pynisher&quot;: [ValueError] }## We check that the exception is explicitly of the same type and not just a subclass.# This is to prevent accidentally wrapping to eagerly.wrap_errors: bool | list[Exception] | dict = False# Whether to terminate child processes of your limited function.# By default, pynisher will kill any subprocesses your function may spawn. If this# is not desired behaviour, please use `daemon=True` with your spawned subprocesses# and set `terminate_child_processes` to `False`terminate_child_processes: bool = True# Whether keyboard interrupts should forceably kill any subprocess or the# pynished function. If True, it will temrinate the process tree of# the pynished function and then reraise the KeyboardInterrupt.forceful_keyboard_interrupt: bool = True```#### ExceptionsPynisher will let all subprocess `Exceptions` buble up to the controlling process.If a subprocess exceeds a limit, one of `CpuTimeoutException`, `WallTimeoutException` or `MemoryLimitException` are raised, but you can use their base classes to cover them more generally.```pythonclass PynisherException(Exception): ...    &quot;&quot;&quot;When a subprocess exceeds a limit&quot;&quot;&quot;class TimeoutException(PynisherException): ...    &quot;&quot;&quot;When a subprocess exceeds a time limit (walltime or cputime)&quot;&quot;&quot;class CpuTimeoutException(TimeoutException): ...    &quot;&quot;&quot;When a subprocess exceeds its cpu time limit&quot;&quot;&quot;class WallTimeoutException(TimeoutException):    &quot;&quot;&quot;When a subprocess exceeds its wall time limit&quot;&quot;&quot;class MemoryLimitException(PynisherException, MemoryError):    &quot;&quot;&quot;When a subprocess tries to allocate memory that would take it over the limit    This also inherits from MemoryError as it is technically a MemoryError that we    catch and convert.    &quot;&quot;&quot;```## Changes from v0.6.0For simplicity, pynisher will no longer try to control `stdout`, `stderr`, insteadusers can use the builtins `redirect_stdout` and `redirect_stderr` of Python tosend things as needed.Pynisher issues warnings through `stderr`. Depending on how you set up the `context`to spawn a new process, using objects may now work as intended. The safest optionis to write to a file if needed.```pythonfrom contextlib import redirect_stderr# You can always disable warningslimited_f = limit(func, warnings=False)# Capture warnings in a file# Only seems to work properly on Linuxwith open(&quot;stderr.txt&quot;, &quot;w&quot;) as stderr, redirect_stderr(stderr):    limited_f()with open(&quot;stderr.txt&quot;, &quot;r&quot;) as stderr:    print(stderr.readlines())```The support for passing a `logger` to `Pynisher` has also been removed. The only diagnosticsinformation that would have been sent to the logger is not communicated with prints to `stderr`.These diagnostic messages only occur when an attempt to limit resources failedThis can be captured or disabled as above.Any other kind of issue will raise an exception with relevant information.The support for checking `exit_status` was removed and the success of a pynisher process canbe handled in the usual Python manner of checking for errors, with a `try: except:`. If youdon't care for the `exit_status` then use `f = limit(func, raises=False)` and you cancheck for output `output = f(...)`. This will be `None` if an error was raised and was `raises=False`.Pynisher no longer times your function for you with `self.wall_clock_time`. If you need to measurethe duration it ran, please do so outside of `Pynisher`.The exceptions were also changed, please see [Exceptions](#Exceptions)## Controlling namespace pollutionAs an advanced use case, sometimes you might want to keep the modules imported for yourlimited function to be local only, preventing this from leaking to the main process thatruns created the limited function. You have three ways to control that the locally importederror does not pollute the main namespace.```pythonimport sysfrom pynisher import PynisherException, limitdef import_sklearn() -&gt; None:    &quot;&quot;&quot;Imports sklearn into a local namespace and has an sklearn object in its args&quot;&quot;&quot;    from sklearn.exceptions import NotFittedError    from sklearn.svm import SVR    assert &quot;sklearn&quot; in sys.modules.keys()    raise NotFittedError(SVR())if __name__ == &quot;__main__&quot;:    # Wrapping all errors    lf = limit(import_sklearn, wrap_errors=True)    try:        lf()    except PynisherException:        assert &quot;sklearn&quot; not in sys.modules.keys()    # Wrapping only specific errors    lf = limit(import_sklearn, wrap_errors=[&quot;NotFittedError&quot;])    try:        lf()    except PynisherException:        assert &quot;sklearn&quot; not in sys.modules.keys()    # Wrapping that error specifically as a PynisherException    lf = limit(import_sklearn, wrap_errors={&quot;pynisher&quot;: [&quot;NotFittedError&quot;]})    try:        lf()    except PynisherException:        assert &quot;sklearn&quot; not in sys.modules.keys()```## Pynisher and MultithreadingWhen Pynisher is used together with the Python Threading library, it is possible to run intoa deadlock when using the standard ``fork`` method to start new processes as described in* https://github.com/Delgan/loguru/issues/231* https://gist.github.com/mfm24/e62ec5d50c672524107ca00a391e6104* https://github.com/dask/dask/issues/3759One way of solving this would be to change the forking behavior as described`here &lt;https://github.com/google/python-atfork/blob/main/atfork/stdlib_fixer.py&gt;`_, but this isalso makes very strong assumptions on how the code is executed. An alternative is passing a`Context &lt;https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods&gt;`_which uses either ``spawn`` or ``forkserver`` as the process startup method.## Nested Pynisher and Multiprocessing contextsBe careful when using multiple contexts for multiprocessing while using `pynisher`. If yourpynished function spawns subprocess using `&quot;forkserver&quot;` while you set `pynisher` to usethe context `&quot;fork&quot;`, then issues can begin to occur when terminate processes.## Project originThis repository is based on Stefan Falkner's https://github.com/sfalkner/pynisher.</longdescription>
</pkgmetadata>