<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>:Author: John Millikin:Copyright: This document has been placed in the public domain.Overview========`JSON &lt;http://json.org/&gt;`_ is a lightweight data-interchange format. Itis often used for exchanging data between a web server and user agent.This module aims to produce a library for serializing and deserializingJSON that conforms strictly to RFC 4627.For the Python 3 version of jsonlib, see `jsonlib-python3&lt;http://pypi.python.org/pypi/jsonlib-python3/&gt;`_.Other JSON implementations of interest include `simplejson&lt;http://pypi.python.org/pypi/simplejson&gt;`_ (available in the standard library asof Python 2.6) and `demjson &lt;http://pypi.python.org/pypi/demjson/&gt;`_... contents::Usage=====jsonlib has two functions of interest, ``read`` and ``write``. It alsodefines some exception: ``ReadError``, ``WriteError``, and``UnknownSerializerError``.For compatibility with the standard library, ``read`` is aliased to``loads`` and ``write`` is aliased to ``dumps``. They do not have thesame set of advanced parameters, but may be used interchangeably forsimple invocations.Deserialization---------------To deserialize a JSON expression, call the ``jsonlib.read`` function withan instance of ``unicode`` or ``bytes``. ::&gt;&gt;&gt; import jsonlib&gt;&gt;&gt; jsonlib.read (b'[&quot;Hello world!&quot;]')[u'Hello world!']Floating-point values~~~~~~~~~~~~~~~~~~~~~By default, ``jsonlib`` will parse values such as &quot;1.1&quot; into an instance of``decimal.Decimal``. To use the built-in value type ``float`` instead, setthe ``use_float`` parameter to ``True``. ``float`` values are much faster toconstruct, so this flag may substantially increase parser performance.Please note that using ``float`` will cause a loss of precision whenparsing some values. ::&gt;&gt;&gt; jsonlib.read ('[3.14159265358979323846]', use_float = True)[3.1415926535897931]Serialization-------------Serialization has more options, but they are set to reasonable defaults.The simplest use is to call ``jsonlib.write`` with a Python value. ::&gt;&gt;&gt; import jsonlib&gt;&gt;&gt; jsonlib.write (['Hello world!'])'[&quot;Hello world!&quot;]'Pretty-Printing~~~~~~~~~~~~~~~To &quot;pretty-print&quot; the output, pass a value for the ``indent`` parameter. ::&gt;&gt;&gt; print (jsonlib.write (['Hello world!'], indent = '    ').decode ('utf8'))[    &quot;Hello world!&quot;]&gt;&gt;&gt; Mapping Key Sorting~~~~~~~~~~~~~~~~~~~By default, mapping keys are serialized in whatever order they arestored by Python. To force a consistent ordering (for example, in doctests)use the ``sort_keys`` parameter. ::&gt;&gt;&gt; jsonlib.write ({'e': 'Hello', 'm': 'World!'})'{&quot;m&quot;:&quot;World!&quot;,&quot;e&quot;:&quot;Hello&quot;}'&gt;&gt;&gt; jsonlib.write ({'e': 'Hello', 'm': 'World!'}, sort_keys = True)'{&quot;e&quot;:&quot;Hello&quot;,&quot;m&quot;:&quot;World!&quot;}'Encoding and Unicode~~~~~~~~~~~~~~~~~~~~By default, the output is encoded in UTF-8. If you require a differentencoding, pass the name of a Python codec as the ``encoding`` parameter. ::&gt;&gt;&gt; jsonlib.write (['Hello world!'], encoding = 'utf-16-be')'\x00[\x00&quot;\x00H\x00e\x00l\x00l\x00o\x00 \x00w\x00o\x00r\x00l\x00d\x00!\x00&quot;\x00]'To retrieve an unencoded ``unicode`` instance, pass ``None`` for theencoding. ::&gt;&gt;&gt; jsonlib.write (['Hello world!'], encoding = None)u'[&quot;Hello world!&quot;]'By default, non-ASCII codepoints are forbidden in the output. To includehigher codepoints in the output, set ``ascii_only`` to ``False``. ::&gt;&gt;&gt; jsonlib.write ([u'Hello \u266a'], encoding = None)u'[&quot;Hello \\u266a&quot;]'&gt;&gt;&gt; jsonlib.write ([u'Hello \u266a'], encoding = None, ascii_only = False)u'[&quot;Hello \u266a&quot;]'Mapping Key Coercion~~~~~~~~~~~~~~~~~~~~Because JSON objects must have string keys, an exception will be raised whennon-string keys are encountered in a mapping. It can be useful to coercemapping keys to strings, so the ``coerce_keys`` parameter is available. ::&gt;&gt;&gt; jsonlib.write ({True: 1})Traceback (most recent call last):WriteError: Only strings may be used as object keys.&gt;&gt;&gt; jsonlib.write ({True: 1}, coerce_keys = True)'{&quot;True&quot;:1}'Serializing Other Types~~~~~~~~~~~~~~~~~~~~~~~If the object implements the iterator or mapping protocol, it will behandled automatically. If the object is intended for use as a basic value,it should subclass one of the supported basic values.String-like objects that do not inherit from ``unicode`` or``UserString.UserString`` will likely be serialized as a list. This willnot be changed. If iterating them returns an instance of the same type, theserializer might crash. This (hopefully) will be changed.To serialize a type not known to jsonlib, use the ``on_unknown`` parameterto ``write``::&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; def unknown_handler (value):...     if isinstance (value, date):...         return str (value)...     raise jsonlib.UnknownSerializerError&gt;&gt;&gt; jsonlib.write ([date (2000, 1, 1)], on_unknown = unknown_handler)'[&quot;2000-01-01&quot;]'Streaming Serializer~~~~~~~~~~~~~~~~~~~~When serializing large objects, the use of an in-memory buffer may causetoo much memory to be used. For these situations, use the ``dump`` functionto write objects to a file-like object::&gt;&gt;&gt; import sys&gt;&gt;&gt; jsonlib.dump ([&quot;Written to stdout&quot;], sys.stdout, encoding = None)[&quot;Written to stdout&quot;]&gt;&gt;&gt; with open (&quot;/dev/null&quot;, &quot;wb&quot;) as out:...     jsonlib.dump ([&quot;Written to a file&quot;], out)&gt;&gt;&gt; Exceptions-----------ReadError~~~~~~~~~Raised by ``read`` if an error was encountered parsing the expression. Willcontain the line, column, and character position of the error.Note that this will report the *character*, not the *byte*, of the characterthat caused the error.WriteError~~~~~~~~~~Raised by ``write`` or ``dump`` if an error was encountered serializingthe passed value.UnknownSerializerError~~~~~~~~~~~~~~~~~~~~~~A subclass of ``WriteError`` that is raised when a value cannot beserialized. See the ``on_unknown`` parameter to ``write``.Change Log==========1.6.1-----* Fixed error in `write()` which could cause output truncation.1.6---* Performance improvements* ``coerce_keys`` no longer attempts to determine the &quot;JSON&quot; format for  a coerced value -- it will simply call ``unicode()``.</longdescription>
</pkgmetadata>