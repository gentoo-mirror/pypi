<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pylambdarest[![CI/CD Status](https://github.com/MarwanDebbiche/pylambdarest/workflows/CI%2FCD/badge.svg?branch=master)](https://github.com/MarwanDebbiche/pylambdarest/actions?query=branch:master)[![Coverage Status](https://coveralls.io/repos/github/MarwanDebbiche/pylambdarest/badge.svg?branch=master)](https://coveralls.io/github/MarwanDebbiche/pylambdarest?branch=master)[![Latest Version](https://img.shields.io/pypi/v/pylambdarest.svg?color=blue)](https://pypi.python.org/pypi/pylambdarest)[![PyPI - Downloads](https://img.shields.io/pypi/dm/pylambdarest?label=pypi%20downloads)](https://pypi.org/project/pylambdarest/)![License](https://img.shields.io/github/license/MarwanDebbiche/pylambdarest)pylambdarest is a lightweight opinionated framework for building REST API using [AWS Lambda](https://aws.amazon.com/lambda/) and [API Gateway](https://aws.amazon.com/api-gateway/).## MotivationWhy another framework ?When using API Gateway and python Lambda functions, the most common pattern is to have a unique Lambda function triggered by a proxy API Gateway resource. The Lambda then uses a framework like [Flask](https://flask.palletsprojects.com/en/1.1.x/) to do all the routing. In an API Gateway + Lambda context, I feel like **the routing should be handled by API Gateway itself**, then forwarding the request to specific Lambda functions for each resource or endpoint.## Features- No routing. Yes, this is a feature. Routing should be handled by API Gateway.- API Gateway event parsing (including request body and path parameters).- Cleaner syntax.- Optional body schema and query parameters validation.## InstallationInstall the package from PyPI using pip:```$ pip install pylambdarest```pylambdarest should also be included in the deployment package of your Lambda functions.## Getting startedpylambdarest provides a `@route` decorator to parse the API Gateway event into a `Request` object available in the handler function as an argument. It also formats the handler's output to the expected Lambda + API Gateway format seamlessly.Turning this:```pythonimport jsondef handler(event, context):    body = json.loads(event[&quot;body&quot;])    query_params = event[&quot;queryStringParameters&quot;]    path_params = event[&quot;pathParameters&quot;]    return {        &quot;statusCode&quot;: 200,        &quot;body&quot;: json.dumps({            &quot;message&quot;: f&quot;Hello from AWS Lambda {body['name']}!!&quot;        })    }```Into this:```pythonfrom pylambdarest import route@route()def handler(request):    body = request.json    query_params = request.query_params    path_params = request.path_params    return 200, {&quot;message&quot;: f&quot;Hello from AWS Lambda {body['name']}!!&quot;}```You can still access the original `event` and `context` arguments from the handler:```pythonfrom pylambdarest import route@route()def handler(request, event, context):    print(event)    body = request.json    return 200, {&quot;message&quot;: f&quot;Hello from AWS Lambda {body['name']}!!&quot;}```&lt;br/&gt;Path parameters defined in API Gateway can also be accessed directly as function argument:&lt;br/&gt;![api-gateway-path-params](https://raw.githubusercontent.com/MarwanDebbiche/pylambdarest/master/images/api-gateway-path-params.png)```pythonfrom pylambdarest import route@route()def get_user(user_id):    print(user_id)    # get user from db    user = {&quot;id&quot;: user_id, &quot;name&quot;: &quot;John Doe&quot;}    return 200, user```## Schema Validationpylambdarest optionally provides schema validation using [jsonschema](https://github.com/Julian/jsonschema):```pythonfrom pylambdarest import routeuser_schema = {    &quot;type&quot;: &quot;object&quot;,    &quot;properties&quot;: {        &quot;name&quot;: {&quot;type&quot;: &quot;string&quot;}    },    &quot;required&quot;: [&quot;name&quot;],    &quot;additionalProperties&quot;: False}@route(body_schema=user_schema)def create_user(request):    # If the request's body does not    # satisfy the user_schema,    # a 400 will be returned    # Create user here    return 201query_params_schema = {    &quot;type&quot;: &quot;object&quot;,    &quot;properties&quot;: {        # Only string types are allowed for query parameters.        # Types casting should be done in the handler.        &quot;page&quot;: {&quot;type&quot;: &quot;string&quot;}    },    &quot;additionalProperties&quot;: False}@route(query_params_schema=query_params_schema)def get_users(request):    page = int(request.query_params.get(&quot;page&quot;, 1))    # request users in db    users = [        {&quot;userId&quot;: i}        for i in range((page - 1) * 50, page * 50)    ]    return 200, users```## ExampleYou can look at the [sample](https://github.com/MarwanDebbiche/pylambdarest/tree/master/sample) for a minimal pylambdarest API.In this sample, we use the [serverless](https://www.serverless.com/) framework to declare the API Gateway -&gt; Lambda routingThe packaging of the Lambda functions is done using the [serverless-python-requirements](https://github.com/UnitedIncome/serverless-python-requirements) plugin.</longdescription>
</pkgmetadata>