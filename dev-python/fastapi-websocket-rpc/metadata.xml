<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://i.ibb.co/m8jL6Zd/RPC.png&quot; alt=&quot;RPC&quot; border=&quot;0&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;## ‚ö° FASTAPI Websocket RPCRPC over Websockets made easy, robust, and production ready&lt;a href=&quot;https://github.com/permitio/fastapi_websocket_rpc/actions?query=workflow%3ATests&quot; target=&quot;_blank&quot;&gt;    &lt;img src=&quot;https://github.com/permitio/fastapi_websocket_rpc/workflows/Tests/badge.svg&quot; alt=&quot;Tests&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://pypi.org/project/fastapi-websocket-rpc/&quot; target=&quot;_blank&quot;&gt;    &lt;img src=&quot;https://img.shields.io/pypi/v/fastapi-websocket-rpc?color=%2331C654&amp;label=PyPi%20package&quot; alt=&quot;Package&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://pepy.tech/project/fastapi-websocket-rpc&quot; target=&quot;_blank&quot;&gt;    &lt;img src=&quot;https://static.pepy.tech/personalized-badge/fastapi-websocket-rpc?period=total&amp;units=international_system&amp;left_color=black&amp;right_color=blue&amp;left_text=Downloads&quot; alt=&quot;Downloads&quot;&gt;&lt;/a&gt;A fast and durable bidirectional JSON RPC channel over Websockets.The easiest way to create a live async channel between two nodes via Python (or other clients).- Both server and clients can easily expose Python methods that can be called by the other side.Method return values are sent back as RPC responses, which the other side can wait on.- Remote methods are easily called via the ```.other.method()``` wrapper - Connections are kept alive with a configurable retry mechanism  (using Tenacity)- As seen at &lt;a href=&quot;https://www.youtube.com/watch?v=KP7tPeKhT3o&quot; target=&quot;_blank&quot;&gt;PyCon IL 2021&lt;/a&gt; and &lt;a href=&quot;https://www.youtube.com/watch?v=IuMZVWEUvGs&quot; target=&quot;_blank&quot;&gt;EuroPython 2021&lt;/a&gt;Supports and tested on Python &gt;= 3.7 ## Installation üõ†Ô∏è```pip install fastapi_websocket_rpc```## RPC call example:Say the server exposes an &quot;add&quot; method, e.g. :```pythonclass RpcCalculator(RpcMethodsBase):    async def add(self, a, b):        return a + b```Calling it is as easy as calling the method under the client's &quot;other&quot; property:```pythonresponse = await client.other.add(a=1,b=2)print(response.result) # 3```getting the response with the return value.## Usage example:### Server:```pythonimport uvicornfrom fastapi import FastAPIfrom fastapi_websocket_rpc import RpcMethodsBase, WebsocketRPCEndpoint# Methods to expose to the clientsclass ConcatServer(RpcMethodsBase):    async def concat(self, a=&quot;&quot;, b=&quot;&quot;):        return a + b    # Init the FAST-API appapp =  FastAPI()# Create an endpoint and load it with the methods to exposeendpoint = WebsocketRPCEndpoint(ConcatServer())# add the endpoint to the appendpoint.register_route(app, &quot;/ws&quot;)# Start the server itselfuvicorn.run(app, host=&quot;0.0.0.0&quot;, port=9000)```### Client```pythonimport asynciofrom fastapi_websocket_rpc import RpcMethodsBase, WebSocketRpcClientasync def run_client(uri):    async with WebSocketRpcClient(uri, RpcMethodsBase()) as client:        # call concat on the other side        response = await client.other.concat(a=&quot;hello&quot;, b=&quot; world&quot;)        # print result        print(response.result)  # will print &quot;hello world&quot;# run the client until it completes interaction with serverasyncio.get_event_loop().run_until_complete(    run_client(&quot;ws://localhost:9000/ws&quot;))```See the [examples](/examples) and [tests](/tests) folders for more server and client examples## Server calling client example:- Clients can call ```client.other.method()```     - which is a shortcut for ```channel.other.method()```- Servers also get the channel object and can call remote methods via ```channel.other.method()```- See the [bidirectional call example](examples/bidirectional_server_example.py) for calling client from server and server events (e.g. ```on_connect```).## What can I do with this?Websockets are ideal to create bi-directional realtime connections over the web. - Push updates - Remote control mechanism - Pub / Sub (see [fastapi_websocket_pubsub](https://github.com/permitio/fastapi_websocket_pubsub)) - Trigger events (see &quot;tests/trigger_flow_test.py&quot;) - Node negotiations (see &quot;tests/advanced_rpc_test.py :: test_recursive_rpc_calls&quot;)## Concepts- [RpcChannel](fastapi_websocket_rpc/rpc_channel.py) - implements the RPC-protocol over the websocket    - Sending RpcRequests per method call     - Creating promises to track them (via unique call ids), and allow waiting for responses     - Executing methods on the remote side and serializing return values as        - Receiving RpcResponses and delivering them to waiting callers- [RpcMethods](fastapi_websocket_rpc/rpc_methods.py) - classes passed to both client and server-endpoint inits to expose callable methods to the other side.    - Simply derive from RpcMethodsBase and add your own async methods    - Note currently only key-word arguments are supported    - Checkout RpcUtilityMethods for example methods, which are also useful debugging utilities- Foundations:    - Based on [asyncio](https://docs.python.org/3/library/asyncio.html) for the power of Python coroutines    - Server Endpoint:        - Based on [FAST-API](https://github.com/tiangolo/fastapi): enjoy all the benefits of a full ASGI platform, including Async-io and dependency injections (for example to authenticate connections)        - Based on [Pydnatic](https://pydantic-docs.helpmanual.io/): easily serialize structured data as part of RPC requests and responses (see 'tests/basic_rpc_test.py :: test_structured_response' for an example)    - Client :        - Based on [Tenacity](https://tenacity.readthedocs.io/en/latest/index.html): allowing configurable retries to keep to connection alive            - see WebSocketRpcClient.__init__'s retry_config         - Based on python [websockets](https://websockets.readthedocs.io/en/stable/intro.html) - a more comprehensive client than the one offered by Fast-api## Logging fastapi-websocket-rpc provides a helper logging module to control how it produces logs for you.See [fastapi_websocket_rpc/logger.py](fastapi_websocket_rpc/logger.py).Use ```logging_config.set_mode``` or the 'WS_RPC_LOGGING' environment variable to choose the logging method you prefer or override completely via default logging config.example:```python# set RPC to log like UVICORNfrom fastapi_websocket_rpc.logger import logging_config, LoggingModeslogging_config.set_mode(LoggingModes.UVICORN)```## Pull requests - welcome!- Please include tests for new features </longdescription>
</pkgmetadata>