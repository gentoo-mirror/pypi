<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Internationalized Domain Names in Applications (IDNA)=====================================================Support for the Internationalized Domain Names inApplications (IDNA) protocol as specified in `RFC 5891&lt;https://tools.ietf.org/html/rfc5891&gt;`_. This is the latest version ofthe protocol and is sometimes referred to as “IDNA 2008”.This library also provides support for Unicode TechnicalStandard 46, `Unicode IDNA Compatibility Processing&lt;https://unicode.org/reports/tr46/&gt;`_.This acts as a suitable replacement for the “encodings.idna”module that comes with the Python standard library, but whichonly supports the older superseded IDNA specification (`RFC 3490&lt;https://tools.ietf.org/html/rfc3490&gt;`_).Basic functions are simply executed:.. code-block:: pycon    &gt;&gt;&gt; import idna    &gt;&gt;&gt; idna.encode('ドメイン.テスト')    b'xn--eckwd4c7c.xn--zckzah'    &gt;&gt;&gt; print(idna.decode('xn--eckwd4c7c.xn--zckzah'))    ドメイン.テストInstallation------------This package is available for installation from PyPI:.. code-block:: bash    $ python3 -m pip install idnaUsage-----For typical usage, the ``encode`` and ``decode`` functions will take adomain name argument and perform a conversion to A-labels or U-labelsrespectively... code-block:: pycon    &gt;&gt;&gt; import idna    &gt;&gt;&gt; idna.encode('ドメイン.テスト')    b'xn--eckwd4c7c.xn--zckzah'    &gt;&gt;&gt; print(idna.decode('xn--eckwd4c7c.xn--zckzah'))    ドメイン.テストYou may use the codec encoding and decoding methods using the``idna.codec`` module:.. code-block:: pycon    &gt;&gt;&gt; import idna.codec    &gt;&gt;&gt; print('домен.испытание'.encode('idna'))    b'xn--d1acufc.xn--80akhbyknj4f'    &gt;&gt;&gt; print(b'xn--d1acufc.xn--80akhbyknj4f'.decode('idna'))    домен.испытаниеConversions can be applied at a per-label basis using the ``ulabel`` or``alabel`` functions if necessary:.. code-block:: pycon    &gt;&gt;&gt; idna.alabel('测试')    b'xn--0zwm56d'Compatibility Mapping (UTS #46)+++++++++++++++++++++++++++++++As described in `RFC 5895 &lt;https://tools.ietf.org/html/rfc5895&gt;`_, theIDNA specification does not normalize input from different potentialways a user may input a domain name. This functionality, known asa “mapping”, is considered by the specification to be a localuser-interface issue distinct from IDNA conversion functionality.This library provides one such mapping, that was developed by theUnicode Consortium. Known as `Unicode IDNA Compatibility Processing&lt;https://unicode.org/reports/tr46/&gt;`_, it provides for both a regularmapping for typical applications, as well as a transitional mapping tohelp migrate from older IDNA 2003 applications.For example, “Königsgäßchen” is not a permissible label as *LATINCAPITAL LETTER K* is not allowed (nor are capital letters in general).UTS 46 will convert this into lower case prior to applying the IDNAconversion... code-block:: pycon    &gt;&gt;&gt; import idna    &gt;&gt;&gt; idna.encode('Königsgäßchen')    ...    idna.core.InvalidCodepoint: Codepoint U+004B at position 1 of 'Königsgäßchen' not allowed    &gt;&gt;&gt; idna.encode('Königsgäßchen', uts46=True)    b'xn--knigsgchen-b4a3dun'    &gt;&gt;&gt; print(idna.decode('xn--knigsgchen-b4a3dun'))    königsgäßchenTransitional processing provides conversions to help transition fromthe older 2003 standard to the current standard. For example, in theoriginal IDNA specification, the *LATIN SMALL LETTER SHARP S* (ß) wasconverted into two *LATIN SMALL LETTER S* (ss), whereas in the currentIDNA specification this conversion is not performed... code-block:: pycon    &gt;&gt;&gt; idna.encode('Königsgäßchen', uts46=True, transitional=True)    'xn--knigsgsschen-lcb0w'Implementors should use transitional processing with caution, only inrare cases where conversion from legacy labels to current labels must beperformed (i.e. IDNA implementations that pre-date 2008). For typicalapplications that just need to convert labels, transitional processingis unlikely to be beneficial and could produce unexpected incompatibleresults.``encodings.idna`` Compatibility++++++++++++++++++++++++++++++++Function calls from the Python built-in ``encodings.idna`` module aremapped to their IDNA 2008 equivalents using the ``idna.compat`` module.Simply substitute the ``import`` clause in your code to refer to the newmodule name.Exceptions----------All errors raised during the conversion following the specificationshould raise an exception derived from the ``idna.IDNAError`` baseclass.More specific exceptions that may be generated as ``idna.IDNABidiError``when the error reflects an illegal combination of left-to-right andright-to-left characters in a label; ``idna.InvalidCodepoint`` whena specific codepoint is an illegal character in an IDN label (i.e.INVALID); and ``idna.InvalidCodepointContext`` when the codepoint isillegal based on its positional context (i.e. it is CONTEXTO or CONTEXTJbut the contextual requirements are not satisfied.)Building and Diagnostics------------------------The IDNA and UTS 46 functionality relies upon pre-calculated lookuptables for performance. These tables are derived from computing againsteligibility criteria in the respective standards. These tables arecomputed using the command-line script ``tools/idna-data``.This tool will fetch relevant codepoint data from the Unicode repositoryand perform the required calculations to identify eligibility. There arethree main modes:* ``idna-data make-libdata``. Generates ``idnadata.py`` and  ``uts46data.py``, the pre-calculated lookup tables using for IDNA and  UTS 46 conversions. Implementors who wish to track this library against  a different Unicode version may use this tool to manually generate a  different version of the ``idnadata.py`` and ``uts46data.py`` files.* ``idna-data make-table``. Generate a table of the IDNA disposition  (e.g. PVALID, CONTEXTJ, CONTEXTO) in the format found in Appendix  B.1 of RFC 5892 and the pre-computed tables published by `IANA  &lt;https://www.iana.org/&gt;`_.* ``idna-data U+0061``. Prints debugging output on the various  properties associated with an individual Unicode codepoint (in this  case, U+0061), that are used to assess the IDNA and UTS 46 status of a  codepoint. This is helpful in debugging or analysis.The tool accepts a number of arguments, described using ``idna-data-h``. Most notably, the ``--version`` argument allows the specificationof the version of Unicode to use in computing the table data. Forexample, ``idna-data --version 9.0.0 make-libdata`` will generatelibrary data against Unicode 9.0.0.Additional Notes----------------* **Packages**. The latest tagged release version is published in the  `Python Package Index &lt;https://pypi.org/project/idna/&gt;`_.* **Version support**. This library supports Python 3.5 and higher.  As this library serves as a low-level toolkit for a variety of  applications, many of which strive for broad compatibility with older  Python versions, there is no rush to remove older intepreter support.  Removing support for older versions should be well justified in that the  maintenance burden has become too high.* **Python 2**. Python 2 is supported by version 2.x of this library.  While active development of the version 2.x series has ended, notable  issues being corrected may be backported to 2.x. Use &quot;idna&lt;3&quot; in your  requirements file if you need this library for a Python 2 application.* **Testing**. The library has a test suite based on each rule of the  IDNA specification, as well as tests that are provided as part of the  Unicode Technical Standard 46, `Unicode IDNA Compatibility Processing  &lt;https://unicode.org/reports/tr46/&gt;`_.* **Emoji**. It is an occasional request to support emoji domains in  this library. Encoding of symbols like emoji is expressly prohibited by  the technical standard IDNA 2008 and emoji domains are broadly phased  out across the domain industry due to associated security risks. For  now, applications that wish need to support these non-compliant labels  may wish to consider trying the encode/decode operation in this library  first, and then falling back to using `encodings.idna`. See `the Github  project &lt;https://github.com/kjd/idna/issues/18&gt;`_ for more discussion.</longdescription>
</pkgmetadata>