<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Kubernetes / openshift templating and deployment engineSimple python templating and deployment engine for openshift/k8 yml files. Detect changes made and only applies therequired objects.## Use caseThis tool was born in the need to a simple templating system which can track changes (similar to terraform) butwith k8s object awareness.## Installation- Python 3.8 or later- `kubectl` or `oc` binary in path```pip install octoploy```## Usage```mermaidgraph  TB    root[Root folder&lt;br&gt;_root.yml]    root --&gt; app1[App 1&lt;br&gt;_index.yml&lt;br&gt;k8s yml files]    root --&gt; app2[App 2&lt;br&gt;_index.yml&lt;br&gt;k8s yml files]```In octoploy you define apps, each app can contain multiple yml files. Additionally, there is a project configurationwhich describes the k8 namespace.All yml files will be pre-processed before they will be imported. This includes replacing any known `${KEY}` variableswith their associate values and merging referenced templates.### Deploy / PlanDeploys everything```octoploy deploy-all```Deploys all object of the app with the give name```octoploy deploy nginx```The same commands are available for `plan` - which will list changes to be applied.```octoploy plan / plan-all```This command executes the `on-config-change` trigger```octoploy reload prometheus```### Config structure```configs|- _root.yml &lt;- Root config|- my-app &lt;- App    |- _index.yml &lt;- App config    |- dc.yml &lt;- Openshift/K8 yml file(s)    |- secrets.yml &lt; Encrypted secrets file```### Root configHere is a sample `_root.yml` file```yml# Name of the namespace / openshift projectnamespace: 'my-oc-project'# K8s context which should be used for deployingcontext: 'my-k8s-cluster-config'# OPTIONAL STUFF# Global variablesvars:  DOMAIN: &quot;dev-core.org&quot;```### App configAn app is represented by a folder containing an `_index.yml` file and any additional openshift yml files. The followingshows all available parameters. Only the first 3 are required.```yml# The type defines how the app will be used.# Can be &quot;app&quot; (default) or &quot;template&quot;type: 'app'# Name of the deployment, available as variable, see belowname: 'my-app'# Template which should be applied, none by defaultapplyTemplates: [ ]# Templates which should be applied AFTER processing the other templates and base yml filespostApplyTemplates: [ ]# Action which should be executed if a configmap has been changedon-config-change:  # Available options:   # deploy (re-deploys the deployment config - openshift specific)  - deploy  # exec (Executes a command inside the running container)  - exec:      command: /bin/sh      args:        - &quot;-c&quot;        - &quot;kill -HUP $(ps a | grep prometheus | grep -v grep | awk '{print $1}')&quot;# Additional variables which are used for replacementsvars:  NSQ_NAME: 'nsq-core'# Required parameters which must be passed to this app.# This can be done via the CLI or if this app is a template the referring app can define it in &quot;vars&quot; params:  - PASSWORD# File based configmapsconfigmaps:  - name: nginx-config    files:      - file: &quot;nginx.conf&quot;```### ConfigmapsIn addition to the regular configmaps you can also define configmaps with a file source. This is done inthe `_index.yml` file:```ymlconfigmaps:  - name: nginx-config    files:      - file: &quot;nginx.conf&quot;```This will create a new configmap from the file `nginx.conf` with the name `nginx-config`. Any changes made to the filewill be automatically deployed.### VariablesYou can refer to variables in yml files by using `${VAR-NAME}`. Variables can also be loaded from files (see loadersbelow).```yml# _index.ymlvars:  # Regular key/value assignment  key: value```It is also possible to decorate objects using variables and merge them into other objects:```yml# _index.ymlvars:  someMerging:    hello: world    replicas: 2``````yml# dc.ymlspec:  replicas: 1  _merge: ${someMerging}```Results in:```ymlspec:  replicas: 2  hello: world```### Global variablesThe following variables are available anywhere inside the yml files by default| Key         | Value                                ||-------------|--------------------------------------| | `APP_NAME`  | Name of the app in the `_index.yml`  || `NAMESPACE` | Name of the namespace in `_root.yml` |### Value LoadersYou can load values from various sources using value loaders```ymlvars:  # This will load the public/private and intermediate certs  # from a pem file and store it in *_KEY, *_PUBLIC, *_CACERT  # where * is the key of the value.  # In this example: CERT_KEY, CERT_PUBLIC, CERT_CACERT  CERT:    loader: pem    file: my-cert.pem  # Load the content of a file into &quot;MY_FILE&quot;  MY_FILE:    loader: file    file: someFile.bin    # Optional: Defines in which encoding the file content should be read    # utf-8 by default, only applicable if &quot;conversion&quot; is not set.    encoding: utf-8    # Optional: Conversion can be used to convert a binary file     # into a string representation, in this base base64     conversion: base64  # Load the content of environment variables into ENV_*  ENV:    loader: env ```### TemplatesYou can use templates to reuse and generate yml files. This might be useful when you wantto attach sidecar containers to multiple apps. To do so you create a new app with the `type` field setto `template`. Other apps can now refer to this template via the `applyTemplates` or `postApplyTemplates` field.Templates can refer to other templates (recursively). Any vars defined are passed to the next template.```mermaidclassDiagram    App &lt;|-- Root: App receives global variables    Template &lt;|-- App: Template receives variables    Template --|&gt;App: Injects yml files into app    class Root{      +variables    }    class App{      +parameters      +k8s yml files    }    class Template{      +parameters      +k8s yml files    }  ```Example:```|- some-template    |- _index.yml    |- dc.yml|- my-app    |- _index.yml &lt;-- Referes to &quot;some-template&quot;    |- others.yml```Will result in```|- my-app    |- _index.yml    |- others.yml    |- dc.yml```#### Object mergingThe template engine support content aware object merging. This allows you to decorate existing templates or enhance appswith features. A common example would be a template which adds a monitoring sidecar container. In the `examples` you canfind the `nsq-template` which defines a sidecar container.Here is a minimal example:```yml# examples/nsq-template/dc.ymlkind: DeploymentapiVersion: apps/v1spec:  template:    spec:      containers:        - name: &quot;nsqd&quot;        image: &quot;nsqio/nsq&quot;``````yml# examples/my-app/dc.ymlkind: DeploymentapiVersion: apps/v1metadata:  name: &quot;${APP_NAME}&quot;spec:  replicas: 1  selector:    name: &quot;${APP_NAME}&quot;  strategy:    type: RollingUpdate  template:    metadata:      labels:        name: &quot;${APP_NAME}&quot;    spec:      containers:        - name: &quot;${APP_NAME}&quot;          image: &quot;docker-registry.default.svc:5000/oc-project/my-app:prod&quot;```If we now apply the nsq-template to our app using `postApplyTemplates: [nsq-template]` the`DeploymentConfig` object gets automatically merged:```yml# Merged result after applying templatekind: DeploymentapiVersion: apps/v1metadata:  name: &quot;${APP_NAME}&quot;spec:  replicas: 1  selector:    name: &quot;${APP_NAME}&quot;  strategy:    type: RollingUpdate  template:    metadata:      labels:        name: &quot;${APP_NAME}&quot;    spec:      containers:        - name: &quot;${APP_NAME}&quot;          image: &quot;docker-registry.default.svc:5000/oc-project/my-app:prod&quot;        # This is the part of the template        - name: &quot;nsqd&quot;          image: &quot;nsqio/nsq&quot;```#### LoopsLoops allow you to apply the same template with different parameters. This is useful when deploying microservices whichall have the same openshift config.```yml# _index.ymlapplyTemplates: [ api-template ]forEach:  # NAME is required for each instance that should be created  - NAME: entity-compare-api    # You can define other vars as well    PORT: 8080  - NAME: favorite-api    PORT: 8081```#### LibraryIt's possible to define whole project as a `library`. This allows all apps and templates to be reused by anotherproject. An example would be the same setup for multiple systems which are separated by projects (e.g. `dev/test/prod`).```yml# testLib/_root.ymltype: library# Required parametersparams:  - domain  - dockerDomain  - imageStreamTag``````yml# prod/_root.ymlnamespace: 'prod-project'inherit: testLib# Required parametersvars:  domain: my-prod.dev-core.org  dockerDomain: prod-docker.com  imageStreamTag: prod```When you now deploy the `prod` project it will inherit all apps inside `testLib`.## SecretsYou can encrypt your k8s secrets using```bashexport OCTOPLOY_KEY=&quot;my password&quot;octoploy encrypt secrets.yml```The file will be updated in place.For deploying encrypted secrets, you'll need to set the environment variable`OCTOPLOY_KEY` with your key used to encrypt the data.## State trackingOctoploy currently uses a ConfigMap called `octoploy-state` to keep track of the object states.The ConfigMap contains  all managed objects and their md5 sum. If this hash has changed the whole object will beapplied. If the object does already exist, but is not listed in the state it will simply be added to the state.You can modify the name of the configmap by setting the `stateName` variable in the `_root.yml` file.Currently, the actual fields of the yml files are not compared, however this is a planned feature.  ## ExamplesAll examples can be found in the `examples` folder.## ContributeThe code should be mostly commented. If you found a bug or want to improve something feel free to open an issue anddiscuss your ideas.</longdescription>
</pkgmetadata>