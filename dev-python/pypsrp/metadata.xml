<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pypsrp - Python PowerShell Remoting Protocol Client library[![Test workflow](https://github.com/jborean93/pypsrp/actions/workflows/ci.yml/badge.svg)](https://github.com/jborean93/pypsrp/actions/workflows/ci.yml)[![codecov](https://codecov.io/gh/jborean93/pypsrp/branch/master/graph/badge.svg)](https://codecov.io/gh/jborean93/pypsrp)[![PyPI version](https://badge.fury.io/py/pypsrp.svg)](https://badge.fury.io/py/pypsrp)pypsrp is a Python client for the PowerShell Remoting Protocol (PSRP) andWindows Remote Management (WinRM) service. It allows your to execute commandson a remote Windows host from any machine that can run Python.This library exposes 4 different types of APIs;* A simple client API that can copy files to and from the remote Windows host as well as execute processes and PowerShell scripts* A WSMan interface to execute various WSMan calls like `Send`, `Create`, `Connect`, `Disconnect`, etc* A Windows Remote Shell (WinRS) layer that executes cmd commands and executables using the base WinRM protocol* A PowerShell Remoting Protocol (PSRP) layer allows you to create remote Runspace Pools and PowerShell pipelinesAt a basic level, you can use this library to;* Execute a cmd command* Run another executable* Execute PowerShell scripts* Copy a file from the localhost to the remote Windows host* Fetch a file from the remote Windows host to the localhost* Create a Runspace Pool that contains one or multiple PowerShell pipelines and execute them asynchronously* Support for a reference host base implementation of PSRP for interactive scriptsCurrently this library only supports the WSMan transport method but is designedto support SSH at some point in the future (PR's are welcome). By default itsupports the following authentication methods with WSMan;* Basic* Certificate* NTLMIt also supports `Negotiate/Kerberos`, and `CredSSP` but require extralibraries to be installed.## RequirementsSee `How to Install` for more details* CPython 3.6+* [cryptography](https://github.com/pyca/cryptography)* [pyspnego](https://github.com/jborean93/pyspnego)* [requests](https://github.com/requests/requests)### Optional RequirementsThe following Python libraries can be installed to add extra features that donot come with the base package:* [python-gssapi](https://github.com/pythongssapi/python-gssapi) for Kerberos authentication on Linux* [pykrb5](https://github.com/jborean93/pykrb5) for Kerberos authentication on Linux* [requests-credssp](https://github.com/jborean93/requests-credssp) for CredSSP authentication## How to InstallTo install pypsrp with all the basic features, run:```bashpip install pypsrp```### Kerberos AuthenticationWhile pypsrp supports Kerberos authentication, it isn't included by default forLinux hosts due to it's reliance on system packages to be present.To install these packages, depending on your distribution, run one of the following script blocks.For Debian/Ubuntu```bash# For Python 2apt-get install gcc python-dev libkrb5-dev# For Python 3apt-get install gcc python3-dev libkrb5-dev# To add NTLM to the GSSAPI SPNEGO auth runapt-get install gss-ntlmssp```For RHEL/Centos```bashyum install gcc python-devel krb5-devel# To add NTLM to the GSSAPI SPNEGO auth runyum install gssntlmssp```For Fedora```bashdnf install gcc python-devel krb5-devel# To add NTLM to the GSSAPI SPNEGO auth rundnf install gssntlmssp```For Arch Linux```bashpacman -S gcc krb5```Once installed you can install the Python packages with```bashpip install pypsrp[kerberos]```Kerberos also needs to be configured to talk to the domain but that is outsidethe scope of this page.### CredSSP AuthenticationLike Kerberos auth, CredSSP is supported but isn't included by default. To addsupport for CredSSP auth try to run the following```bashpip install pypsrp[credssp]```If that fails you may need to update pip and setuptools to a newer version`pip install -U pip setuptools`.## How to UseThere are 3 main components that are in use within this library;* `Transport`: Handles the raw transport of messages to and from the server* `Shell`: Handles the WSMV or PSRP protocol details used to create the remote shell that processes are run on, uses `Connection` to send the details* `Process`: Runs the process or script within a shell### ConnectionCurrently only the connection that is supported is the WSMan protocol over HTTPthrough `pypsrp.wsman.WSMan` and offers mostly all the same features in theWSMV spec including;* Basic, Certificate, Negotiate, Kerberos, and CredSSP authentication* TLS encryption* Message encryption with Negotiate, Kerberos, and CredSSP authentication* Definable proxyThese are the options that can be used to setup `WSMan`;* `server`: The hostname or IP address of the host to connect to* `max_envelope_size`: The maximum envelope size, in bytes, that can be sent to the server, default is `153600`* `operation_timeout`: The operation timeout, in seconds, of each WSMan operation, default is `20`. This should always be lower than `read_timeout`.* `port`: The port to connect to, default is `5986` if `ssl=True` else `5985`* `username`: The username to connect with, required for all auths except `certificate` and optionally required for `negotiate/kerberos`* `password`: The password for `username`. Due to a bug on MacOS/Heimdal GSSAPI implementations, this will persist in the user's ccache when using Negotiate or Kerberos authentication, run `kdestroy` manually to remove this* `ssl`: Whether to connect over `https` or `https`, default is `True`* `path`: The WinRM path to connect to, default is `wsman`* `auth`: The authentication protocol to use, default is `negotiate`, choices are `basic`, `certificate`, `negotiate`, `ntlm`, `kerberos`, `credssp`* `cert_validation`: Whether to validate the server's SSL certificate, default is `True`. Can be `False` to not validate or a path to a PEM file of trusted certificates* `connection_timeout`: The timeout for creating a HTTP connection, default is `30`* `read_timeout`: The timeout for receiving a response from the server after a request has been made, default is `30`* `encryption`: Controls the encryption settings, default is `auto`, choices are `auto`, `always`, `never`. Set to `always` to always run message encryption even over HTTPS, `never` to never use message encryption even over HTTP* `proxy`: The proxy URL used to connect to the remote host* `no_proxy`: Whether to ignore any environment proxy variable and connect directly to the host, default is `False`* `locale`: The `wsmv:Locale` value to set on each WSMan request. This specifies the language in which the cleint wants response text to be translated, default is `en-US`* `data_locale`: The `wsmv:DataLocale` value to set on each WSMan request. This specifies the format in which numerical data is presented in the response text, default is the value of `locale`* `reconnection_retries`: Number of retries on a connection problem, default is `0`* `reconnection_backoff`: Number of seconds to backoff in between reconnection attempts (first sleeps X, then sleeps 2*X, 4*X, 8*X, ...), default is `2.0`* `certificate_key_pem`: The path to the certificate key used in `certificate` authentication* `certificate_pem`: The path to the certificate used in `certificate` authentication* `credssp_auth_mechanism`: The sub-auth mechanism used in CredSSP, default is `auto`, choices are `auto`, `ntlm`, or `kerberos`* `credssp_disable_tlsv1_2`: Whether to used CredSSP auth over the insecure TLSv1.0, default is `False`* `credssp_minimum_version`: The minimum CredSSP server version that the client will connect to, default is `2`* `negotiate_delegate`: Whether to negotiate the credential to the host, default is `False`. This is only valid if `negotiate` auth negotiated Kerberos or `kerberos` was explicitly set* `negotiate_hostname_override`: The hostname used to calculate the host SPN when authenticating the host with Kerberos auth. This is only valid if `negotiate` auth negotiated Kerberos or `kerberos` was explicitly set* `negotiate_send_cbt`: Whether to binding the channel binding token (HTTPS only) to the auth or ignore, default is `True`* `negotiate_service`: Override the service part of the calculated SPN used when authenticating the server, default is `WSMAN`. This is only valid if `negotiate` auth negotiated Kerberos or `kerberos` was explicitly setWhen running over HTTP, this library will enforce encryption by default but ifthat is not supported (Basic auth) or isn't available on the host then eitheruse HTTPS or disable encryption with `encryption=&quot;never&quot;`.There are plans to add support for SSH as a connection but this still needs tobe implemented. SSH will work on hosts that are running PowerShell Core butnot the standard PowerShell.### ShellThere are two shells that can be used in this library, `pypsrp.shell.WinRS` and`pypsrp.powershell.RunspacePool`.`WinRS` is a cmd shell that can be used to issue cmd commands, including butnot limited to other executables. Here are the options that can be used toconfigure a `WinRS` shell;* `wsman`: WinRS only works over WSMan, so this is the `pypsrp.wsman.WSMan` object to run the commands over* `resource_uri`: The resource uri of the shell, defaults to `http://schemas.microsoft.com/wbem/wsman/1/windows/shell/cmd`* `id`: The ID if the shell, this should be kept as `None` as it is created dynamically by the server* `input_streams`: The input stream(s) of the shell, default is `stdin`* `output_streams`: The output stream(s) of the shell, default is `stdout, stderr`* `codepage`: The codepage of the shell, default is the default of the host* `environment`: A dictionary of environment key/values to set for the remote shell* `idle_time_out`: THe idle timeout in seconds of the shell* `lifetime`: The total lifetime of the shell* `name`: The name (description only) of the shell* `no_profile`: Whether to create the shell with the user profile loaded or not* `working_directory`: The default working directory of the created shell`RunspacePool` is a shell used by the PSRP protocol, it is designed to be aclose implementation of the .NET[System.Management.Automation.Runspaces.RunspacePool](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.runspaces.runspacepool?view=powershellsdk-1.1.0)class. The methods and properties are similar and can mostly do the same thing.Here are the options that can be used to configure a `RunspacePool` shell;* `connection`: The connection object used by the RunspacePool to send commands to the remote server, currently only supports `WSMan`* `apartment_state`: The int value of `pypsrp.complex_objects.ApartmentState` for the remote thread, default is `UNKNOWN`* `thread_options`: The int value of `pypsrp.complex_objects.ThreadOptions` that specifies the type of thread to create, default is `DEFAULT`* `host`: The local host info implementation, default is no host* `configuration_name`: The configuration name to connect to, default is `Microsoft.PowerShell` and can be used to specify the Just Enough Administration (JEA) to connect to* `min_runspaces`: The minimuum number of runspaces that a pool can hold, default is 1* `max_runspaces`: The maximum number of runspaces that a pool can hold. Each PowerShell pipeline is run in a single Runspace, default is 1* `session_key_timeout_ms`: The maximum time to wait for a session key transfer from the server### ProcessThere are two process objects that can be used, `pypsrp.shell.Process` for the`WinRS` shell and `pypsrp.powershell.PowerShell` for the `RunspacePool` shell.These objects are ultimately used to execute commands, processes, or scripts onthe remote host.`Process` is used with the `WinRS` shell to execute a cmd command or anotherexecutable. The following options are used to configure the `Process` object;* `shell`: The `WinRS` shell the process is run over* `executable`: The executable or command to run* `arguments`: A list of arguments to the executable or command, default is no arguments* `id`: The ID of the created command, if not specified then this is dynamically created* `no_shell`: Whether to create a command in the cmd shell or bypass it, default is `False`. If `True` then the executable must be the full path to the exe. This only works on older OS' before 2012 R2 (not including)To execute the process, call `.invoke()`, the `stdout`, `stderr`, and `rc`properties contain the output of the command once complete.`PowerShell` is used by the PSRP protocol, it is designed to be a closeimplementation of the[System.Management.Automation.PowerShell](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.powershell?view=powershellsdk-1.1.0)class. The methods and properties are similar and can mostly do the same thing.Here are the options that can be used to configure a `PowerShell` process;* `runspace_pool`: The `RunspacePool` object to run the `PowerShell` process onTo execute the process, call `.invoke()`, the `output`, `had_erros`, and`streams` contains the execution status and output information of the process.Before invoke can be called, cmdlets or scripts must be added. These can bedone with the following methods;* `add_script`: Add a raw PowerShell script to the pending commands* `add_cmdlet`: Add a cmdlet to the pending commands* `add_parameters`: Add a dictionary of key/value parameters to the last added command* `add_argument`: Add a value argument to the last added command* `add_statement`: Set the last command/script to be the end of that pipeline so the next command/script is like a newlineSee the examples below for more details.### ExamplesHow to use the high level client API```pythonfrom pypsrp.client import Client# this takes in the same kwargs as the WSMan objectwith Client(&quot;server&quot;, username=&quot;user&quot;, password=&quot;password&quot;) as client:    # execute a cmd command    stdout, stderr, rc = client.execute_cmd(&quot;dir&quot;)    stdout, stderr, rc = client.execute_cmd(&quot;powershell.exe gci $pwd&quot;)    sanitised_stderr = client.sanitise_clixml(stderr)    # execute a PowerShell script    output, streams, had_errors = client.execute_ps('''$path = &quot;%s&quot;if (Test-Path -Path $path) {    Remove-Item -Path $path -Force -Recurse}New-Item -Path $path -ItemType Directory''' % path)    output, streams, had_errors = client.execute_ps(&quot;New-Item -Path C:\\temp\\folder -ItemType Directory&quot;)    # copy a file from the local host to the remote host    client.copy(&quot;~/file.txt&quot;, &quot;C:\\temp\\file.txt&quot;)    # fetch a file from the remote host to the local host    client.fetch(&quot;C:\\temp\\file.txt&quot;, &quot;~/file.txt&quot;)```How to use WinRS/Process to execute a command```pythonfrom pypsrp.shell import Process, SignalCode, WinRSfrom pypsrp.wsman import WSMan# creates a http connection with no encryption and basic authwsman = WSMan(&quot;server&quot;, ssl=False, auth=&quot;basic&quot;, encryption=&quot;never&quot;,              username=&quot;vagrant&quot;, password=&quot;vagrant&quot;)with wsman, WinRS(wsman) as shell:    process = Process(shell, &quot;dir&quot;)    process.invoke()    process.signal(SignalCode.CTRL_C)    # execute a process with arguments in the background    process = Process(shell, &quot;powershell&quot;, [&quot;gci&quot;, &quot;$pwd&quot;])    process.begin_invoke()  # start the invocation and return immediately    process.poll_invoke()  # update the output stream    process.end_invoke()  # finally wait until the process is finished    process.signal(SignalCode.CTRL_C)```How to use RunspacePool/PowerShell to execute a PowerShell script/command```pythonfrom pypsrp.powershell import PowerShell, RunspacePoolfrom pypsrp.wsman import WSMan# creates a https connection with explicit kerberos auth and implicit credentialswsman = WSMan(&quot;server&quot;, auth=&quot;kerberos&quot;, cert_validation=False))with wsman, RunspacePool(wsman) as pool:    # execute 'Get-Process | Select-Object Name'    ps = PowerShell(pool)    ps.add_cmdlet(&quot;Get-Process&quot;).add_cmdlet(&quot;Select-Object&quot;).add_argument(&quot;Name&quot;)    output = ps.invoke()    # execute 'Get-Process | Select-Object -Property Name'    ps.add_cmdlet(&quot;Get-Process&quot;).add_cmdlet(&quot;Select-Object&quot;)    ps.add_parameter(&quot;Property&quot;, &quot;Name&quot;)    ps.begin_invoke()  # execute process in the background    ps.poll_invoke()  # update the output streams    ps.end_invoke()  # wait until the process is finished    # execute 'Get-Process | Select-Object -Property Name; Get-Service audiosrv'    ps.add_cmdlet(&quot;Get-Process&quot;).add_cmdlet(&quot;Select-Object&quot;).add_parameter(&quot;Property&quot;, &quot;Name&quot;)    ps.add_statement()    ps.add_cmdlet(&quot;Get-Service&quot;).add_argument(&quot;audiosrc&quot;)    ps.invoke()    # execute a PowerShell script with input being sent    script = '''begin {    $DebugPreference = &quot;Continue&quot;    Write-Debug -Message &quot;begin&quot;} process {    Write-Output -InputObject $input} end {    Write-Debug -Message &quot;end&quot;}'''    ps.add_script(script)    ps.invoke([&quot;string&quot;, 1])    print(ps.output)    print(ps.streams.debug)```## LoggingThis library takes advantage of the Python logging configuration and messagesare logged to the `pypsrp` named logger as well as `pypsrp.*` where `*` is eachPython script in the `pypsrp` directory.An easy way to turn on logging for the entire library is to create thefollowing JSON file and run your script with`PYPSRP_LOG_CFG=log.json python script.py` (this does not work with Python2.6).```json{    &quot;version&quot;: 1,    &quot;disable_existing_loggers&quot;: false,    &quot;formatters&quot;: {        &quot;simple&quot;: {            &quot;format&quot;: &quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;        }    },    &quot;handlers&quot;: {        &quot;console&quot;: {            &quot;class&quot;: &quot;logging.StreamHandler&quot;,            &quot;level&quot;: &quot;DEBUG&quot;,            &quot;formatter&quot;: &quot;simple&quot;,            &quot;stream&quot;: &quot;ext://sys.stdout&quot;        }    },    &quot;loggers&quot;: {        &quot;pypsrp&quot;: {            &quot;level&quot;: &quot;DEBUG&quot;,            &quot;handlers&quot;: [&quot;console&quot;],            &quot;propagate&quot;: &quot;no&quot;        }    }}```You can adjust the log level by changing the level value in `logger` to `INFO`._Note: `DEBUG` contains a lot of information and will output all the messagessent to and from the client. This can have the side effect of leaking sensitiveinformation and should only be used for debugging purposes._## TestingAny changes are more than welcome in pull request form, you can run the currenttest suite with tox like so;```bash# make sure tox is installedpip install tox# run the tox suitetox# or run the test manually for the current Python environmentpy.test -v --pep8 --cov pypsrp --cov-report term-missing```A lot of the tests either simulate a remote Windows host but you can also run alot of them against a real Windows host. To do this, set the followingenvironment variables before running the tests;* `PYPSRP_SERVER`: The hostname or IP of the remote host* `PYPSRP_USERNAME`: The username to connect with* `PYPSRP_PASSWORD`: The password to connect with* `PYPSRR_PORT`: The port to connect with (default: `5986`)* `PYPSRP_AUTH`: The authentication protocol to auth with (default: `negotiate`)There are further integration tests that require a specific host setup to runcorrectly. You can use `Vagrant` to set this host up. This is done by runningthe following commands;```bash# download the Vagrant box and start it up based on the Vagrantfilevagrant up# once the above script is complete run the followingvagrant ssh  # password is vagrantpowershell.exeRegister-PSSessionConfiguration -Path &quot;C:\Users\vagrant\Documents\JEARoleSettings.pssc&quot; -Name JEARole -Force$sec_pass = ConvertTo-SecureString -String &quot;vagrant&quot; -AsPlainText -Force$credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList &quot;vagrant&quot;, $sec_pass$thumbprint = (Get-ChildItem -Path Cert:\LocalMachine\TrustedPeople)[0].ThumbprintNew-Item -Path WSMan:\localhost\ClientCertificate `    -Subject &quot;vagrant@localhost&quot; `    -URI * `    -Issuer $thumbprint `    -Credential $credential `    -Force# exit the remote PowerShell sessionexit# exist the SSH sessionexit```Once complete, set the following environment variables to run the integrationtests;* `PYPSRP_RUN_INTEGRATION`: To any value* `PYPSRP_SERVER`: Set to `127.0.0.1`* `PYPSRP_USERNAME`: Set to `vagrant`* `PYPSRP_PASSWORD`: Set to `vagrant`* `PYPSRP_HTTP_PORT`: Set to `55985`* `PYPSRP_HTTPS_PORT`: Set to `55986`* `PYPSRP_CERT_DIR`: Set to the full path of the project directoryFrom here you can run the normal test suite and it will run all the integrationtests.## Backlog* Look at implementing the following transport options    * Named pipes    * SSH* Update CI to use named pipes for integration tests* Add Ansible playbook for better integration tests* Improved serialization between Python and .NET objects* Live interactive console for PSRP</longdescription>
</pkgmetadata>