<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;div align=&quot;center&quot;&gt;&lt;p align=&quot;center&quot;&gt;  &lt;img alt=&quot;logo&quot; src=&quot;https://raw.githubusercontent.com/mbarkhau/lib3to6/master/lib3to6_128.png&quot;&gt;&lt;/p&gt;&lt;/div&gt;# [lib3to6][repo_ref]Compile Python 3.6+ code to Python 2.7+ compatible code. The idea isquite similar to Babel https://babeljs.io/. Develop using the newestinterpreter and use (most) new language features and still maintainbackward compatibility.Project/Repo:[![MIT License][license_img]][license_ref][![Supported Python Versions][pyversions_img]][pyversions_ref][![CalVer v202107.1047][version_img]][version_ref][![PyPI Version][pypi_img]][pypi_ref][![PyPI Downloads][downloads_img]][downloads_ref]Code Quality/CI:[![GitHub CI Status][github_build_img]][github_build_ref][![GitLab CI Status][gitlab_build_img]][gitlab_build_ref][![Type Checked with mypy][mypy_img]][mypy_ref][![Code Coverage][codecov_img]][codecov_ref][![Code Style: sjfmt][style_img]][style_ref]|               Name                  |    role           |  since  | until ||-------------------------------------|-------------------|---------|-------|| Manuel Barkhau (mbarkhau@gmail.com) | author/maintainer | 2018-09 | -     |&lt;!--  To update the TOC:  $ pip install md-toc  $ md_toc -i gitlab README.md -l 2--&gt;[](TOC)- [Ease the Transition from Old Interpreters](#ease-the-transition-from-old-interpreters)- [Python Versions and Compatibility](#python-versions-and-compatibility)- [Usage Caveats](#usage-caveats)- [Per-File Opt-In/Opt-Out](#per-file-opt-inopt-out)- [Integration using `setup.py`](#integration-using-setuppy)- [Automatic Conversions](#automatic-conversions)- [Motivation](#motivation)- [How it works](#how-it-works)- [Contributing](#contributing)- [Project Status (as of 2020-09-01): Beta](#project-status-as-of-2020-09-01-beta)- [Future Work](#future-work)- [Alternatives](#alternatives)- [FAQ](#faq)[](TOC)## Motivation: Ease the Transition from Old InterpretersEspecially for packages, you probably don't want to force all yourusers to already use python 3.10, so maintaining backwardcompatibility is a good idea. Nonetheless, for development it is agood idea to use the newest interpreter you can and ideally you canuse the newer type annotation features to type-check your code, butellide these annotations in the distribution, since they are notneeded at runtime.If your existing project uses Python2.7, it may not be possible todedicate a substantial block of time to update all of your code andthen flip a switch to start running on Python3. To make matters worse,you may continue to write code only for Python2.7, since that is whatyour production code will actually run on. With `lib3to6` you canstart to use Python3 for development and integration (ensuring forwardcompatibility) and still maintain backward compatibility while youhave to deploy for Python2.## Python Versions and CompatibilityThe compiled output is tested using:- Python 3.9- Python 3.8- Python 3.7- Python 3.6- Python 3.5- Python 2.7- PyPy 3.6- PyPy 3.5The test-suite for the transpiler is run using:- Python 3.9- Python 3.8- Python 3.7- Python 3.6- PyPy 3.6The compiled output may work with other versions of python, such as `&lt;=2.6` or `&gt;=3.0 &lt;=3.4`, but these are not tested.## Usage Caveats`lib3to6` does not add any runtime dependencies of its own, but it does inject code, such as temporary variables and imports from the standard library (`itertools` and `builtins` in particular). Any changes will only add a constant `O(1)` overhead.`lib3to6` does optimistic ast transformations, with the assumption that you're not doing anything too crazy in your code. An example of such a transformation is the support for [PEP3102 - Keyword-Only Arguments](https://www.python.org/dev/peps/pep-3102/). `lib3to6` will change the function signature to use `**kwargs` and add locals extracted from `kwargs`.```$ cat kwonly_args_demo.pydef compare(a, b, *, key=None):    ...``````$ lib3to6 kwonly_args_demo.pydef compare(a, b, **kwargs):    key = kwargs.get('key', None)    pass```This means that the function signature you can get using the `inspect` module may not be what you expect for the output of `lib3to6`.## Per-File Opt-In/Opt-OutSince `lib3to6==v202008.1042` there is support to selectively enable/disable transpilation on a per-file basis.Any file which starts with a `# lib3to6: disabled` comment, will not be transpiled. For these, you will have to take care of forward/backward compatibility yourself.```python# -*- coding: utf-8 -*-# lib3to6: disabled&quot;&quot;&quot;A module written to work both with Python2 and 3.This module doesn't need to be transpiled by lib3to6.&quot;&quot;&quot;from __future__ import print_function...import sysPY3 = sys.version_info[0] &gt; 2if PY3:    ...else:    ...```Instead of opt-out, you can also take an opt-in approach. You will have to switch the `default_mode` argument:```python# setup.pypackage_dir = {&quot;&quot;: &quot;src&quot;}if any(arg.startswith(&quot;bdist&quot;) for arg in sys.argv):    import lib3to6    package_dir = lib3to6.fix(package_dir, default_mode='disabled')```This will leave all files untouched, except for those marked with a `# lib3to6: enabled` comment.```python# lib3to6: enabled&quot;&quot;&quot;A module written to work both with Python2 and 3.This module doesn't need to be transpiled by lib3to6.&quot;&quot;&quot;name: str = &quot;Wörld&quot;print(f&quot;Hello {world}!&quot;)```## Integration using `setup.py`The cli command `lib3to6 &lt;filename&gt;` is nice for demo purposes, but for integration with your project, you may prefer to use it in your `setup.py` file. Contributions for other kinds of integration are most welcome.```python# setup.pyimport sysimport setuptoolspackages = setuptools.find_packages(&quot;.&quot;)package_dir = {&quot;&quot;: &quot;.&quot;}install_requires = ['typing;python_version&lt;&quot;3.5&quot;']if any(arg.startswith(&quot;bdist&quot;) for arg in sys.argv):    import lib3to6    package_dir = lib3to6.fix(        package_dir,        target_version=&quot;2.7&quot;,        install_requires=install_requires,        default_mode='enabled',    )setuptools.setup(    name=&quot;my-module&quot;,    version=&quot;0.1.0&quot;,    packages=packages,    package_dir=package_dir,    install_requires=install_requires,    classifiers=[        &quot;Programming Language :: Python&quot;,        &quot;Programming Language :: Python :: 2&quot;,        &quot;Programming Language :: Python :: 3&quot;,        ...    ],)```When you build you package, the contents of the resulting distributionwill be the code that was converted by lib3to6.```bash~/my-module $ python setup.py bdist_wheel --python-tag=py2.py3running bdist_wheel...~/my-module$ ls -1 dist/my_module-201808.1-py2.py3-none-any.whl~/my-module$ python3 -m pip install dist/my_module-201808.1-py2.py3-none-any.whlProcessing ./dist/my_module-201808.1-py2.py3-none-any.whlInstalling collected packages: my-moduleSuccessfully installed my-module-201808.1~/my-module$ python2 -m pip install dist/my_module-201808.1-py2.py3-none-any.whlProcessing ./dist/my_module-201808.1-py2.py3-none-any.whlInstalling collected packages: my-moduleSuccessfully installed my-module-201808.1```When testing, make sure you're not importing `my_module` from your localdirectory, which is probably the original source code. Instead you caneither manipulate your `PYTHONPATH`, or simply switch directories...```bash~/$ python3 -c &quot;import my_module&quot;/home/user/my-module/my_module/__init__.pyHello 世界 from 3.6.5!~/my-module$ cd ..~/$ python3 -c &quot;import my_module&quot;/home/user/envs/py36/lib/python3.6/site-packages/my_module/__init__.pyHello 世界 from 3.6.5!~$ python2 -c &quot;import my_module&quot;/home/user/envs/py27/lib/python2.7/site-packages/my_module/__init__.pyHello 世界 from 2.7.15!```## Automatic ConversionsNot all new language features have a semantic equivalent in olderversions. To the extent these can be detected, an error will bereported when these features are used.Note that a fix is not applied if the lowest version of python thatyou are targeting already supports the newer syntax. The conversionsare ordered by when the feature was introduced.### PEP 572: Assignment Expressions (aka. the walrus operator)```python# Since 3.8if match1 := pattern1.match(data):    result = match1.group(1)# From 2.7 to 3.7match1 = pattern1.match(data)if match1:    result = match1.group(1)```Some expressions nested expressions in a condition are not so easy,in which case lib3to6 will bend over backwards.```python# Since 3.8while (block := f.read(4096)) != '':    process(block)# For [2.7 - 3.7]__loop_condition = Truewhile __loop_condition:    block = f.read(4096)    __loop_condition = block != ''    if __loop_condition:        process(block)```### PEP 563: Postponed Evaluation of Annotations```python# Since 3.7class SelfRef:    def method(self) -&gt; SelfRef:        pass# From 3.0 to 3.6class SelfRef:    def method(self) -&gt; 'SelfRef':        pass```Note that this is not a stupid conversion that is applied to allannotations, it is only applied to annotations that are forwardreferences. Backward references are left as is.```python# Since 3.7class BackRef:    def method(self) -&gt; ForwardRef:        passclass ForwardRef:    def method(self) -&gt; BackRef:        pass# From 3.0 to 3.6class BackRef:    def method(self) -&gt; 'ForwardRef':        passclass ForwardRef:    def method(self) -&gt; BackRef:        pass```If you're supporting python 2.7, the annotation will of course be elided.### PEP 498: formatted string literals.```python# Since 3.6who = &quot;World&quot;print(f&quot;Hello {who}!&quot;)# From 2.7 to 3.5who = &quot;World&quot;print(&quot;Hello {0}!&quot;.format(who))```The fixer also converts the newer `{var=}` syntax, even if you uselib3to6 on a Python version older than 3.8.```python# Since 3.6who = &quot;World&quot;print(f&quot;Hello {who=}!&quot;)# From 2.7 to 3.5print(&quot;Hello who={0}!&quot;.format(who))```### Eliding of Annotations```python# Since 3.0def foo(bar: int) -&gt; str:    pass# In 2.7def foo(bar):    pass```### PEP 515: underscores in numeric literals```python# Since 3.6num = 1_234_567# From 2.7 to 3.5num = 1234567```### Unpacking generalizationsFor literals...```python# Since 3.4x = [*[1, 2], 3]# From 2.7 to 3.3x = [1, 2, 3]```For varargs...```python# Since 3.4foo(0, *a, *b)# From 2.7 to 3.3foo(*([0] + list(a) + list(b))```For kwargs...```python# Since 3.4foo(**x, y=22, **z)# From 2.7 to 3.3import itertoolsfoo(**dict(itertools.chain(x.items(), {'y': 22}.items(), z.items())))```Note that the import will only be added to your module once.### Keyword only arguments```python# Since 3.6def kwonly_func(*, kwonly_arg=1):    ...# From 2.7 to 3.5def kwonly_func(**kwargs):    kwonly_arg = kwargs.get('kwonly_arg', 1)    ...```### Convert class based typing.NamedTuple usage to assignments```pythonimport typing# Since 3.5class Bar(typing.NamedTuple):    x: int    y: str# From 2.7 to 3.4Bar = typing.NamedTuple('Bar', [('x', int), ('y', str)])```### New Style Classes```python# Since 3.0class Bar:  pass# Before 3.0class Bar(object):  pass```### Future ImportsAll `__future__` imports applicable to your target version areprepended to every file.```python# -*- coding: utf-8 -*-# This file is part of the &lt;X&gt; project# ...&quot;&quot;&quot;A docstring.&quot;&quot;&quot;x = True```With `target-version=27` (the default).```python# -*- coding: utf-8 -*-# This file is part of the &lt;X&gt; project# ...&quot;&quot;&quot;A docstring.&quot;&quot;&quot;from __future__ import absolute_importfrom __future__ import divisionfrom __future__ import print_functionfrom __future__ import unicode_literalsx = True```With `target-version=3.7````python# -*- coding: utf-8 -*-# This file is part of the &lt;X&gt; project# ...&quot;&quot;&quot;A docstring.&quot;&quot;&quot;from __future__ import annotationsx = True```Note that `lib3to6` works mostly at the ast level, but an exception ismade for any comments that appear at the top of the file. These arepreserved as is, so your shebang, file encoding and licensing headerswill be preserved.### Not Supported FeaturesAn (obviously non-exhaustive) list of features which are **notsupported**, either because they involve a semantic change, orbecause there is no simple ast transformation to make them workacross different python versions: - PEP 492 - `async`/`await` - PEP 465 - `@`/`__matmul__` operator - PEP 380 - `yield from` syntax - PEP 584 - union operators for `dict` - ordered dictionary (since python 3.6)### Modules with BackportsSome new modules have backports, which lib3to6 will point to: - typing - pathlib -&gt; pathlib2 - secrets -&gt; python2-secrets - ipaddress -&gt; py2-ipaddress - csv -&gt; backports.csv - lzma -&gt; backports.lzma - enum -&gt; enum34For a full list of modules for which these warnings and errors apply,please review [`MAYBE_UNUSABLE_MODULES` insrc/lib3to6/checkers_backports.py](https://gitlab.com/mbarkhau/lib3to6/blob/master/src/lib3to6/checkers_backports.py)For some modules, the backport uses the same module name as the originalmodule in the standard library. By default, lib3to6 will only warn aboutusage of such modules, since it cannot detect if you're using the modulefrom the backported package (good) or from the standard library (bad ifnot available in your target version). If you would like to opt-in to harderror messages, you can whitelist modules for which you have thebackported package as a dependency.A good approach to adding such backports as dependencies is toqualify the requirement with a [dependencyspecification](https://www.python.org/dev/peps/pep-0508/), so thatusers with a newer interpreter use the builtin module and don'tinstall the backport package that they don't need.These work as arguments for `install_requires` and also in`requirements.txt` files.```pythonimport setuptoolssetuptools.setup(    name=&quot;my-package&quot;,    install_requires=['typing;python_version&lt;&quot;3.5&quot;'],    ...)```For testing, you can also pass these as a space separated parameterto the `lib3to6` cli command:```shell$ lib3to6 my_script.py &gt; /dev/nullWARNING - my_script.py@1: Use of import 'enum'.    This module is only available since Python 3.5,    but you configured target_version=2.7.WARNING - my_script.py@2: Use of import 'typing'.    This module is only available since Python 3.5,    but you configured target_version=2.7.import enumimport typing...$ lib3to6 `--install-requires='typing'` my_script.py &gt; /dev/nullTraceback (most recent call last):  ...  File &quot;/home/user/.../lib3to6/src/lib3to6/checkers_backports.py&quot;, line 134, in __call__    raise common.CheckError(errmsg, node)lib3to6.common.CheckError: my_script.py@1 - Prohibited import 'enum'.    This module is available since Python 3.4,    but you configured target_version='2.7'.    Use 'https://pypi.org/project/enum34' instead.$ lib3to6 `--install-requires='typing enum34'` my_script.pyimport enumimport typing...```## MotivationThe main motivation for this project is to be able to use `mypy`without sacrificing compatibility to older versions of python.```python# my_module/__init__.pydef hello(who: str) -&gt; None:    import sys    print(f&quot;Hello {who} from {sys.version.split()[0]}!&quot;)print(__file__)hello(&quot;世界&quot;)``````bash$ pip install lib3to6$ python -m lib3to6 my_module/__init__.py``````python# -*- coding: utf-8 -*-from __future__ import absolute_importfrom __future__ import divisionfrom __future__ import print_functionfrom __future__ import unicode_literalsdef hello(who):    import sys    print('Hello {0} from {1}!'.format(who, sys.version.split()[0]))print(__file__)hello('世界')```Fixes are applied to match the semantics of python3 code asclose as possible, even when running on a python2.7 interpreter.Some fixes that have been applied in the above:    - PEP263 magic comment to declare the coding of the python      source file. This allows the string literal `&quot;世界&quot;` to      be decoded correctly.    - `__future__` imports have been added. This includes the well      known print statement -&gt; function change. The unicode_literals    - Type annotations have been removed    - `f&quot;&quot;` string -&gt; `&quot;&quot;.format()` conversion### Compatibility MattersI've seen a common gut reaction to lib3to6, which is that we shouldn't care about older versions of Python, Python 2.7 in particular. I would humbly suggest you consider the position of people other than developers who have full control over their development environment and only use CPython. As of this writing (August 2020), the most recent language version supported by alternative interpreters is the following:| Interpreter | Version ||-------------|---------|| Stackless   |     3.7 || PyPy        |     3.6 || MicroPython |     3.4 || IronPython  |     2.7 || Jython      |     2.7 |Notice that even Stackless Python, which has the least effort to keep up with new language features, is nonetheless lagging behind CPython. And even if all you care about is CPython, be aware that the most recent interpreter may not be available on platforms that users care about. For example on PythonAnywhere.com, the most recent version of CPython is 3.5 and of PyPy is 2.7.If you are writing a library and it doesn't **need** any of the newer **runtime** features, such as async/await or ordered dictionaries, then I would humbly suggest you do not unnecessarily prevent users of such platforms from using your library.From a users perspective, only supporting the newest versions of Python might be interpreted as arrogance, but your time as a maintainer isn't free, and you don't owe users of your library anything. Lib3to6 exists to minimize your effort to maintain backward compatibility. If you have difficulties integrating lib3to6 into your packaging process, please report an issue: [gitlab.com/mbarkhau/lib3to6/-/issues](https://gitlab.com/mbarkhau/lib3to6/-/issues).### On Testing your ProjectProjects that use lib3to6 should have a test-suite that is executedwith the oldest python version that you want to support, using theconverted output generated by lib3to6. While you can develop using anewer version of python, you should not blindly trust lib3to6 as it isvery easy to introduce backward incompatible changes if you only teston the most recent interpreter. The most obvious example is thatlib3to6 cannot do much to help you if a library produces `bytes` onPython 2 but `str` on Python 3.The easiest way I have found to test a project, is to create adistribution using `python setup.py bdist_wheel` with the abovemodifications to the `setup.py`, install it and run the test-suiteagainst the installed modules.## How it worksThis project works at the level of the python abstract syntaxtree (AST). The AST is transformed so that is only usesconstructs that are also valid in older versions of python. Forexample it will translate f-strings to normal strings using the``str.format`` method.```python&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.version_info'3.6.5'&gt;&gt;&gt; import lib3to6&gt;&gt;&gt; py3_source = 'f&quot;Hello {1 + 1}!&quot;'&gt;&gt;&gt; cfg = {&quot;fixers&quot;: [&quot;f_string_to_str_format&quot;]}&gt;&gt;&gt; py2_source = lib3to6.transpile_module(cfg, py3_source)&gt;&gt;&gt; print(py3_source)f&quot;Hello {1 + 1}!&quot;&gt;&gt;&gt; print(py2_source)# -*- coding: utf-8 -*-&quot;Hello {0}!&quot;.format(1 + 1)```At a lower level, this translation is based on detection of the`ast.JoinedStr` node, which is translated into and AST that can beserialized back into python syntax that will also work on olderversions.```python&gt;&gt;&gt; print(lib3to6.parsedump_ast(py3_source))Module(body=[Expr(value=JoinedStr(values=[    Str(s='Hello '),    FormattedValue(        value=BinOp(left=Num(n=1), op=Add(), right=Num(n=1)),        conversion=-1,        format_spec=None,    ),    Str(s='!'),]))])&gt;&gt;&gt; print(lib3to6.parsedump_ast(py2_source))Module(body=[Expr(value=Call(    func=Attribute(        value=Str(s='Hello {0}!'),        attr='format',        ctx=Load(),    ),    args=[BinOp(left=Num(n=1), op=Add(), right=Num(n=1))],    keywords=[]))])```### Checker ErrorsOf course this does not cover every aspect of compatibility.Changes in APIs cannot be translated automatically in this way.An obvious example, is that there is no way to transpile codewhich uses `async` and `await`. In this case, `lib3to6`will simply raise a CheckError. This applies only to your sourcecode though, so if import use a library which uses `async` and`await`, everything may look fine until you run your testson python 2.7.A more subtle example is the change in semantics of the builtin`open` function.```bash$ cat open_example.pywith open(&quot;myfile.txt&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;) as fobj:    fobj.write(&quot;Hello Wörld!&quot;)$ python2 open_example.pyTraceback (most recent call last):  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;TypeError: 'encoding' is an invalid keyword argument for this function```Usually there are alternative ways to write equivalent code thatworks on all versions of python. For these commonincompatibilities lib3to6 will raise an error and suggest analternative, such as in this case using `io.open` instead.```bash$ lib3to6 open_example.pyTraceback (Most recent call last):11  lib3to6      &lt;module&gt;         --&gt; sys.exit(main())764 core.py      __call__         --&gt; return self.main(*args, **kwargs)717 core.py      main             --&gt; rv = self.invoke(ctx)956 core.py      invoke           --&gt; return ctx.invoke(self.callback, **ctx.params)555 core.py      invoke           --&gt; return callback(*args, **kwargs)55  __main__.py  main             --&gt; fixed_source_text = transpile.transpile_module(cfg, source_text)260 transpile.py transpile_module --&gt; checker(cfg, module_tree)158 checkers.py  __call__         --&gt; raise common.CheckError(msg, node)CheckError: Prohibited keyword argument 'encoding' to builtin.open. on line 1 of open_example.py```Here `lib3to6` you will give you a `CheckError`, however itremains your responsibility to write your code so that thissyntactic translation is semantically equivalent in both python3and python2.`lib3to6` uses the python `ast` module to parse your code. Thismeans that you need a modern python interpreter to transpile frommodern python to legacy python interpreter. You cannot transpilefeatures which your interpreter cannot parse. The intended use isfor developers of libraries who use the most modern pythonversion, but want their libraries to work on older versions.## ContributingThe most basic contribution you can make is to provide minimal,reproducible examples of code that should either be converted orwhich should raise an error.The project is hosted at[gitlab.com/mbarkhau/lib3to6](https://gitlab.com/mbarkhau/lib3to6),mainly because that's where the CI/CD is configured. GitHub is onlyused as a copy/backup (and because that seems to be where many peoplelook for things).You can get started with local development in just a few commands.```shelluser@host:~/ $ git clone https://gitlab.com/mbarkhau/lib3to6.gituser@host:~/ $ cd lib3to6/user@host:~/lib3to6/ ⎇master $ make helpuser@host:~/lib3to6/ ⎇master $ make conda     # creates conda environments...user@host:~/lib3to6/ ⎇master $ ls ~/miniconda3/envs/user@host:~/lib3to6_pypy35 lib3to6_py27 lib3to6_py36 lib3to6_py37 lib3to6_py38```The targets in the makefile are set up to use the virtual environments.```shelluser@host:~/lib3to6/ ⎇master $ make fmtAll done! ✨ 🍰 ✨21 files left unchanged.user@host:~/lib3to6/ ⎇master $ make lint mypy devtestisort ... oksjfmt ... okflake8 .. okmypy .... ok...```For debugging you may wish to activate a virtual environment anyway.```shelluser@host:~/lib3to6/ ⎇master $ source activateuser@host:~/lib3to6/ ⎇master (lib3to6_py38) $ ipythonPython 3.8.2 | packaged by conda-forge | (default, Apr 24 2020, 08:20:52)Type 'copyright', 'credits' or 'license' for more informationIPython 7.14.0 -- An enhanced Interactive Python. Type '?' for help.In [1]: import lib3to6In [2]: lib3to6.__file__Out[2]: '/home/user/lib3to6/src/lib3to6/__init__.py'```## Project Status (as of 2021-01-01): BetaI have tested with Python 3.9 with only minor updates required since Python 3.8. I've been using this library for over two years on a few projectswithout much incident. Examples of such projects are:- [BumpVer](https://pypi.org/project/bumpver/).- [markdown-katex](https://pypi.org/project/markdown-katex/)- [markdown-svgbob](https://pypi.org/project/markdown-svgbob/)- [markdown-aafigure](https://pypi.org/project/markdown-aafigure/)- [pylint-ignore](https://pypi.org/project/pylint-ignore/)- [pretty-traceback](https://pypi.org/project/pretty-traceback/)- [backports.pampy](https://pypi.org/project/backports.pampy/)## Future WorkIn an ideal world, the project would cover all cases documented onhttp://python-future.org and either: 1. Transpile to code that will work on any version 2. Raise an error, ideally pointing to a page and section on    python-future.org or other documentation describing    alternative methods of writing backwards compatible code.https://docs.python.org/3.X/whatsnew/ also contains much info onAPI changes that might be checked for, but checks and fixers forthese will only be written if they are common enough, otherwiseit's just too much work (patches are welcome though).## AlternativesSince starting this project, I've learned of the[py-backwards](https://github.com/nvbn/py-backwards) project, which isvery, very similar in its approach. I have not evaluated it yet, todetermine for what projects it might be a better choice.Some features that might be implemented- PEP 380 - `yield from gen` syntax might be supported in a basic form  by expanding to a `for x in gen: yield x`. That is not semantically  equivalent though and I don't know if it's worth  [implementing it properly](https://www.python.org/dev/peps/pep-0380/#formal-semantics)- PEP 465 - `@` operator could be done by replacing all cases  where the operator is used with a `__matmul__` method call.## FAQ - Q: Isn't the tagline &quot;Compatibility Matters&quot; ironic,   considering that python 3.6+ is required to build a wheel? - A: The irony is not lost. The issue is, how to parse source   code from a newer version of python than the python   interpreter itself supports. You can install lib3to6 on   older versions of python, but you'll be limited to the   features supported by that version. For example, you won't be   able to use f&quot;&quot; strings on python 3.5, but most annotations   will work fine. - Q: Why keep python2.7 alive? Just let it die already! - A: Indeed, and lib3to6 can help with that. Put yourself in the   shoes of somebody who is working on an old codebase. It's not   realistic hold all other development efforts while the   codebase is migrated and tested, while everything else waits.   Instead an incremental approach is usually the only option.   With lib3to6, individual modules of the codebase can be   migrated to python3, leaving the rest of the codebase   untouched. The project can still run in a python 2.7   environment, while developers increasingly move to using   python 3.   Additionally, lib3to6 is not just for compatibility with   python 2.7, it also allows you to use new features like f&quot;&quot;   strings and variable annotations, while still maintaining   compatibility with older versions of python 3. - Q: Why not `lib3to2`? - A: I can't honestly say much about `lib3to2`. It seems to not   be maintained and looking at the source I thought it would be   easier to just write something new that worked on the AST level.   The scope of `lib3to6` is more general than 3to2, as you can   use it even if all you care about is converting from python 3.6   to 3.5.[repo_ref]: https://github.com/mbarkhau/lib3to6[github_build_img]: https://github.com/mbarkhau/lib3to6/workflows/CI/badge.svg[github_build_ref]: https://github.com/mbarkhau/lib3to6/actions?query=workflow%3ACI[gitlab_build_img]: https://gitlab.com/mbarkhau/lib3to6/badges/master/pipeline.svg[gitlab_build_ref]: https://gitlab.com/mbarkhau/lib3to6/pipelines[codecov_img]: https://gitlab.com/mbarkhau/lib3to6/badges/master/coverage.svg[codecov_ref]: https://mbarkhau.gitlab.io/lib3to6/cov[license_img]: https://img.shields.io/badge/License-MIT-blue.svg[license_ref]: https://gitlab.com/mbarkhau/lib3to6/blob/master/LICENSE[mypy_img]: https://img.shields.io/badge/mypy-checked-green.svg[mypy_ref]: https://mbarkhau.gitlab.io/lib3to6/mypycov[style_img]: https://img.shields.io/badge/code%20style-%20sjfmt-f71.svg[style_ref]: https://gitlab.com/mbarkhau/straitjacket/[pypi_img]: https://img.shields.io/badge/PyPI-wheels-green.svg[pypi_ref]: https://pypi.org/project/lib3to6/#files[downloads_img]: https://pepy.tech/badge/lib3to6/month[downloads_ref]: https://pepy.tech/project/lib3to6[version_img]: https://img.shields.io/static/v1.svg?label=CalVer&amp;message=v202107.1047&amp;color=blue[version_ref]: https://pypi.org/project/bumpver/[pyversions_img]: https://img.shields.io/pypi/pyversions/lib3to6.svg[pyversions_ref]: https://pypi.python.org/pypi/lib3to6# Changelog for https://github.com/mbarkhau/lib3to6## v202107.1045 - Fix type annotations with list arguments## v202107.1044 - Fix type annotations with attribute access## v202101.1043 - Fixes for Python 3.9 and mypy 0.800## v202009.1042 - New #6: per-file opt-in/opt-out using `# lib3to6: disabled`/`# lib3to6: enabled`## v202006.1041 - New: Lots more documentation. - New #5: Add detection of invalid imports and point to available backports. Use `install_requires` option to whitelist installed backports. - New: Checkers produce better error messages. - New: Colouring of diffs when using `lib3to6` cli command. - New: Checker for `yield from` syntax on target version doesn't support it - New: Checker for `@` operator when target version doesn't support it - Fix #3: `--target-version` argument is ignored [gitlab../issues/3](https://gitlab.com/mbarkhau/lib3to6/-/issues/3) - Fix #4: Remove `from __future__ import X` when the target version doesn't support it. - Fix #4: Convert Forward Reference Annotations to strings [gitlab../issues/4](https://gitlab.com/mbarkhau/lib3to6/-/issues/4) Thank you [Faidon Liambotis](https://gitlab.com/paravoid) for your help with testing and helping to debug ❤️. - Fix: Don't apply keyword only args fixer for `--target-version=3.0` or above.## v202002.0031 - Compatibility fixes for Python 3.8 - Add support for f-string `=` specifier - Add support for `:=` walrus operator (except inside comprehensions)## v201902.0030 - Fix python 2 builtins were not always overridden correctly. - Fix pypy compatibility testing - Better mypy coverage## v201812.0021-beta - Recursively apply some fixers.## v201812.0020-alpha - Move to gitlab.com - Use bootstrapit - Fix bugs based on use with pycalver## v201809.0019-alpha - CheckErrors include log line numbers - Transpile errors now include filenames - Added fixers for renamed modules, e.g.    .. code-block:: diff        - import queue        + try:        +     import queue        + except ImportError:        +     import Queue as queue## v201808.0014-alpha - Better handling of package_dir - Change to `CalVer Versioning &lt;https://calver.org/&gt;`_ - Remove console script in favour of simple ``python -m lib3to6`` - Rename from ``three2six`` -&gt; ``lib3to6``</longdescription>
</pkgmetadata>