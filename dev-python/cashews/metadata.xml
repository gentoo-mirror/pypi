<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;h1 align=&quot;center&quot;&gt;ðŸ¥” CASHEWS ðŸ¥”&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;    &lt;em&gt;Async cache framework with simple API to build fast and reliable applications&lt;/em&gt;&lt;/p&gt;```bashpip install cashewspip install cashews[redis]pip install cashews[diskcache]pip install cashews[dill] # can cache in redis more types of objectspip install cashews[speedup] # for bloom filters```---## WhyCache plays a significant role in modern applications and everybody want to use all power of async programming and cache.There are a few advanced techniques with cache and async programming that can help you build simple, fast,scalable and reliable applications. This library intends to make it easy to implement such techniques.## Features- Easy to configure and use- Decorator-based API, just decorate and play- Different cache strategies out-of-the-box- Support for multiple storage backends ([In-memory](#in-memory), [Redis](#redis), [DiskCache](diskcache))- Set TTL as a string (&quot;2h5m&quot;), as `timedelta` or use a function in case TTL depends on key parameters- Transactionality- Middlewares- Client-side cache (10x faster than simple cache with redis)- Bloom filters- Different cache invalidation techniques (time-based or tags)- Cache any objects securely with pickle (use [hash key](#redis))- 2x faster then `aiocache` (with client side caching)## Usage Example```pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)  # configure as in-memory cache, but redis/diskcache is also supported# use a decorator-based API@cache(ttl=&quot;3h&quot;, key=&quot;user:{request.user.uid}&quot;)async def long_running_function(request):    ...# or for fine-grained control, use it directly in a functionasync def cache_using_function(request):    await cache.set(key=request.user.uid, value=request.user, expire=&quot;20h&quot;)    ...```More examples [here](https://github.com/Krukov/cashews/tree/master/examples)## Table of Contents- [Configuration](#configuration)- [Available Backends](#available-backends)- [Basic API](#basic-api)- [Disable Cache](#disable-cache)- [Strategies](#strategies)  - [Cache condition](#cache-condition)  - [Keys templating](#template-keys)  - [TTL](#ttl)  - [What can be cached](#what-can-be-cached)- [Cache Invalidation](#cache-invalidation)  - [Cache invalidation on code change](#cache-invalidation-on-code-change)- [Detect the source of a result](#detect-the-source-of-a-result)- [Middleware](#middleware)- [Transactional mode](#transactional)### Configuration`cashews` provides a default cache, that you can setup in two different ways:```pythonfrom cashews import cache# via urlcache.setup(&quot;redis://0.0.0.0/?db=1&amp;socket_connect_timeout=0.5&amp;suppress=0&amp;hash_key=my_secret&amp;enable=1&quot;)# or via kwargscache.setup(&quot;redis://0.0.0.0/&quot;, db=1, wait_for_connection_timeout=0.5, suppress=False, hash_key=b&quot;my_key&quot;, enable=True)```Alternatively, you can create cache instance yourself:```pythonfrom cashews import Cachecache = Cache()cache.setup(...)```Optionally, you can disable cache with `disable`/`enable` parameter (see [Disable Cache](#disable-cache)):```pythoncache.setup(&quot;redis://redis/0?enable=1&quot;)cache.setup(&quot;mem://?size=500&quot;, disable=True)cache.setup(&quot;mem://?size=500&quot;, enable=False)```You can setup different Backends based on a prefix:```pythoncache.setup(&quot;redis://redis/0&quot;)cache.setup(&quot;mem://?size=500&quot;, prefix=&quot;user&quot;)await cache.get(&quot;accounts&quot;)  # will use the redis backendawait cache.get(&quot;user:1&quot;)  # will use the memory backend```### Available Backends#### In-memoryIn-memory cache uses fixed-sized LRU dict to store values. It checks expiration on `get`and periodically purge expired keys.```pythoncache.setup(&quot;mem://&quot;)cache.setup(&quot;mem://?check_interval=10&amp;size=10000&quot;)```#### Redis_Requires [redis](https://github.com/redis/redis-py) package._\This will use Redis as a storage.This backend uses [pickle](https://docs.python.org/3/library/pickle.html) module to serializevalues, but the cashes can store values with sha1-keyed hash.Use `secret` and `digestmod` parameter to protect your application from security vulnerabilities.The `digestmod` is a hashing algorithm that can be used: `sum`, `md5` (default), `sha1` and `sha256`The `secret` is a salt for a hash.Pickle can't serialize any type of objects. In case you need to store more complex typesyou can use [dill](https://github.com/uqfoundation/dill) - set `pickle_type=&quot;dill&quot;`.Dill is great, but less performance.If you need complex serializer for [sqlalchemy](https://docs.sqlalchemy.org/en/14/core/serializer.html) objects you can set `pickle_type=&quot;sqlalchemy&quot;`Any connections errors are suppressed, to disable it use `suppress=False` - a `CacheBackendInteractionError` will be raisedIf you would like to use [client-side cache](https://redis.io/topics/client-side-caching) set `client_side=True`Client side cache will add `cashews:` prefix for each key, to customize it use `client_side_prefix` option.```pythoncache.setup(&quot;redis://0.0.0.0/?db=1&amp;minsize=10&amp;suppress=false&amp;hash_key=my_secret&quot;, prefix=&quot;func&quot;)cache.setup(&quot;redis://0.0.0.0/2&quot;, password=&quot;my_pass&quot;, socket_connect_timeout=0.1, retry_on_timeout=True, hash_key=&quot;my_secret&quot;)cache.setup(&quot;redis://0.0.0.0&quot;, client_side=True, client_side_prefix=&quot;my_prefix:&quot;, pickle_type=&quot;dill&quot;)```For using secure connections to redis (over ssl) uri should have `rediss` as schema```pythoncache.setup(&quot;rediss://0.0.0.0/&quot;, ssl_ca_certs=&quot;path/to/ca.crt&quot;, ssl_keyfile=&quot;path/to/client.key&quot;,ssl_certfile=&quot;path/to/client.crt&quot;,)```#### DiskCache_Requires [diskcache](https://github.com/grantjenks/python-diskcache) package._This will use local sqlite databases (with shards) as storage.It is a good choice if you don't want to use redis, but you need a shared storage, or your cache takes a lot of local memory.Also, it is good choice for client side local storage.You cat setup disk cache with [FanoutCache parameters](http://www.grantjenks.com/docs/diskcache/api.html#fanoutcache)** Warning ** `cache.scan` and `cache.get_match` does not work with this storage (works only if shards are disabled)```pythoncache.setup(&quot;disk://&quot;)cache.setup(&quot;disk://?directory=/tmp/cache&amp;timeout=1&amp;shards=0&quot;)  # disable shardsGb = 1073741824cache.setup(&quot;disk://&quot;, size_limit=3 * Gb, shards=12)```### Basic APIThere are few basic methods to work with cache:```pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)  # configure as in-memory cacheawait cache.set(key=&quot;key&quot;, value=90, expire=60, exist=None)  # -&gt; boolawait cache.set_raw(key=&quot;key&quot;, value=&quot;str&quot;)  # -&gt; boolawait cache.get(&quot;key&quot;, default=None)  # -&gt; Anyawait cache.get_raw(&quot;key&quot;)await cache.get_many(&quot;key1&quot;, &quot;key2&quot;, default=None)async for key, value in cache.get_match(&quot;pattern:*&quot;, batch_size=100):    ...await cache.incr(&quot;key&quot;) # -&gt; intawait cache.delete(&quot;key&quot;)await cache.delete_many(&quot;key1&quot;, &quot;key2&quot;)await cache.delete_match(&quot;pattern:*&quot;)async for key in cache.scan(&quot;pattern:*&quot;):    ...await cache.expire(&quot;key&quot;, timeout=10)await cache.get_expire(&quot;key&quot;)  # -&gt; int seconds to expireawait cache.ping(message=None)  # -&gt; bytesawait cache.clear()await cache.is_locked(&quot;key&quot;, wait=60)  # -&gt; boolasync with cache.lock(&quot;key&quot;, expire=10):    ...await cache.set_lock(&quot;key&quot;, value=&quot;value&quot;, expire=60)  # -&gt; boolawait cache.unlock(&quot;key&quot;, &quot;value&quot;)  # -&gt; boolawait cache.close()```### Disable CacheCache can be disabled not only at setup, but also in runtime. Cashews allow you to disable/enable any call of cache or specific commands:```pythonfrom cashews import cache, Commandcache.setup(&quot;mem://&quot;)  # configure as in-memory cachecache.disable(Command.DELETE)cache.disable()cache.enable(Command.GET, Command.SET)cache.enable()with cache.disabling():  ...```### Strategies- [Simple cache](#simple-cache)- [Fail cache (Failover cache)](#fail-cache-failover-cache)- [Hit cache](#hit-cache)- [Early](#early)- [Soft](#soft)- [Async Iterators](#iterators)- [Locked](#locked)- [Rate limit](#rate-limit)- [Circuit breaker](#circuit-breaker)#### Simple cacheThis is typical cache strategy: execute, store and return from cache until it expired.```pythonfrom datetime import timedeltafrom cashews import cachecache.setup(&quot;mem://&quot;)@cache(ttl=timedelta(hours=3), key=&quot;user:{request.user.uid}&quot;)async def long_running_function(request):    ...```#### Fail cache (Failover cache)Return cache result, if one of the given exceptions is raised (at least one functioncall should be succeed prior that).```pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)# note: the key will be &quot;__module__.get_status:name:{name}&quot;@cache.failover(ttl=&quot;2h&quot;, exceptions=(ValueError, MyException))async def get_status(name):    value = await api_call()    return {&quot;status&quot;: value}```If exceptions didn't get will catch all exceptions or use default if it set by:```pythoncache.set_default_fail_exceptions(ValueError, MyException)```#### Hit cacheExpire cache after given numbers of call `cache_hits`.```pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)@cache.hit(ttl=&quot;2h&quot;, cache_hits=100, update_after=2)async def get(name):    value = await api_call()    return {&quot;status&quot;: value}```#### EarlyCache strategy that tries to solve [Cache stampede problem](https://en.wikipedia.org/wiki/Cache_stampede)with a hot cache recalculating result in a background.```pythonfrom cashews import cache  # or: from cashews import early# if you call this function after 7 min, cache will be updated in a background@cache.early(ttl=&quot;10m&quot;, early_ttl=&quot;7m&quot;)async def get(name):    value = await api_call()    return {&quot;status&quot;: value}```#### SoftLike a simple cache, but with a fail protection base on soft ttl.```pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)# if you call this function after 7 min, cache will be updated and return a new result.# If it fail on recalculation will return current cached value (if it not more then 10 min old)@cache.soft(ttl=&quot;10m&quot;, soft_ttl=&quot;7m&quot;)async def get(name):    value = await api_call()    return {&quot;status&quot;: value}```#### IteratorsAll upper decorators can be use only with coroutines. Cashing async iterators works differently.To cache async iterators use `iterator` decorator```pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)@cache.iterator(ttl=&quot;10m&quot;, key=&quot;get:{name}&quot;)async def get(name):    async for item in get_pages(name):        yield ...```#### LockedDecorator that can help you to solve [Cache stampede problem](https://en.wikipedia.org/wiki/Cache_stampede).Lock following function calls until the first one will be finished.This guarantees exactly one function call for given ttl.&gt; :warning: \*\*Warning: this decorator will not cache the result&gt; To do it you can combine this decorator with any cache decorator or use parameter `lock=True` with `@cache()````pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)@cache.locked(ttl=&quot;10s&quot;)async def get(name):    value = await api_call()    return {&quot;status&quot;: value}```#### Rate limitRate limit for a function call: if rate limit is reached raise an `RateLimitError` exception.&gt; :warning: \*\*Warning: this decorator will not cache the result&gt; To do it you can combine this decorator with any cache failover decorator````pythonfrom cashews import cache, RateLimitErrorcache.setup(&quot;mem://&quot;)# no more than 10 calls per minute or ban for 10 minutes - raise RateLimitError@cache.rate_limit(limit=10, period=&quot;1m&quot;, ttl=&quot;10m&quot;)async def get(name):    value = await api_call()    return {&quot;status&quot;: value}# no more than 100 calls in 10 minute window. if rate limit will rich -&gt; return from cache@cache.failover(ttl=&quot;10m&quot;, exceptions=(RateLimitError, ))@cache.slice_rate_limit(limit=100, period=&quot;10m&quot;)async def get_next(name):    value = await api_call()    return {&quot;status&quot;: value}```#### Circuit breakerCircuit breaker pattern. Count number of failed calls and if error rate rich specified value will raise `CircuitBreakerOpen` exception&gt; :warning: \*\*Warning: this decorator will not cache the result&gt; To do it you can combine this decorator with any cache failover decorator````pythonfrom cashews import cache, CircuitBreakerOpencache.setup(&quot;mem://&quot;)@cache.circuit_breaker(errors_rate=10, period=&quot;1m&quot;, ttl=&quot;5m&quot;)async def get(name):    ...@cache.failover(ttl=&quot;10m&quot;, exceptions=(CircuitBreakerOpen, ))@cache.circuit_breaker(errors_rate=10, period=&quot;10m&quot;, ttl=&quot;5m&quot;, half_open_ttl=&quot;1m&quot;)async def get_next(name):    ...```#### Bloom filter (experimental)Simple Bloom filter:```pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)@cache.bloom(capacity=10_000, false_positives=1)async def email_exists(email: str) -&gt; bool:    ...for email in all_users_emails:    await email_exists.set(email)await email_exists(&quot;example@example.com&quot;)```### Cache conditionBy default, any result of function call is stored, even it is a `None`.Caching decorators have parameter `condition`, that can be:- a callable object that receive result of function call, args, kwargs and a cache key- a string: &quot;not_none&quot; or &quot;skip_none&quot; to do not cache `None` values in```pythonfrom cashews import cache, NOT_NONEcache.setup(&quot;mem://&quot;)@cache(ttl=&quot;1h&quot;, condition=NOT_NONE)async def get():    ...def skit_test_result(result, args, kwargs, key=None) -&gt; bool:    return result != &quot;test&quot;@cache(ttl=&quot;1h&quot;, condition=skit_test_result)async def get():    ...```Also caching decorators have parameter `time_condition` - min latency in seconds (can be set like `ttl`)of getting a result of function call to be cached.```pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)@cache(ttl=&quot;1h&quot;, time_condition=&quot;3s&quot;)  # to cache for 1 hour if execution takes more than 3 secondsasync def get():    ...```### Template KeysOften, to compose a key, you need all the parameters of the function call.By default, Cashews will generate a key using the function name, module names and parameters```pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)@cache(ttl=timedelta(hours=3))async def get_name(user, *args, version=&quot;v1&quot;, **kwargs):    ...# a key template will be &quot;__module__.get_name:user:{user}:{__args__}:version:{version}:{__kwargs__}&quot;await get_name(&quot;me&quot;, version=&quot;v2&quot;)# a key will be &quot;__module__.get_name:user:me::version:v2&quot;await get_name(&quot;me&quot;, version=&quot;v1&quot;, foo=&quot;bar&quot;)# a key will be &quot;__module__.get_name:user:me::version:v1:foo:bar&quot;await get_name(&quot;me&quot;, &quot;opt&quot;, &quot;attr&quot;, opt=&quot;opt&quot;, attr=&quot;attr&quot;)# a key will be &quot;__module__.get_name:user:me:opt:attr:version:v1:attr:attr:opt:opt&quot;```The same with a class method```pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)class MyClass:    @cache(ttl=&quot;2h&quot;)    async def get_name(self, user, version=&quot;v1&quot;):         ...# a key template will be &quot;__module__:MyClass.get_name:self:{self}:user:{user}:version:{version}await MyClass().get_name(&quot;me&quot;, version=&quot;v2&quot;)# a key will be &quot;__module__:MyClass.get_name:self:&lt;__module__.MyClass object at 0x105edd6a0&gt;:user:me:version:v1&quot;```As you can see, there is an ugly reference to the instance in the key. That is not what we expect to see.That cache will not work properly. There are 3 solutions to avoid it:1. define `__str__` magic method in our class```pythonclass MyClass:    @cache(ttl=&quot;2h&quot;)    async def get_name(self, user, version=&quot;v1&quot;):         ...    def __str__(self) -&gt; str:        return self._hostawait MyClass(host=&quot;http://example.com&quot;).get_name(&quot;me&quot;, version=&quot;v2&quot;)# a key will be &quot;__module__:MyClass.get_name:self:http://example.com:user:me:version:v1&quot;```2. Set a key template```pythonclass MyClass:    @cache(ttl=&quot;2h&quot;, key=&quot;{self._host}:name:{user}:{version}&quot;)    async def get_name(self, user, version=&quot;v1&quot;):         ...await MyClass(host=&quot;http://example.com&quot;).get_name(&quot;me&quot;, version=&quot;v2&quot;)# a key will be &quot;http://example.com:name:me:v1&quot;```3. Use `noself` or `noself_cache` if you want to exclude `self` from a key```pythonfrom cashews import cache, noself, noself_cachecache.setup(&quot;mem://&quot;)class MyClass:    @noself(cache)(ttl=&quot;2h&quot;)    async def get_name(self, user, version=&quot;v1&quot;):         ...    @noself_cache(ttl=&quot;2h&quot;)  # for python &lt;= 3.8    async def get_name(self, user, version=&quot;v1&quot;):         ...# a key template will be &quot;__module__:MyClass.get_name:user:{user}:version:{version}await MyClass().get_name(&quot;me&quot;, version=&quot;v2&quot;)# a key will be &quot;__module__:MyClass.get_name:user:me:version:v1&quot;```Sometimes you may need to format the parameters or define yourown template for the key and Cashews allows you to do this:```pythonfrom cashews import default_formatter, cachecache.setup(&quot;mem://&quot;)@cache.failover(key=&quot;name:{user.uid}&quot;)async def get_name(user, version=&quot;v1&quot;):    ...await get_name(user, version=&quot;v2&quot;)# a key will be &quot;fail:name:me&quot;@cache.hit(key=&quot;user:{token:jwt(user_name)}&quot;, prefix=&quot;new&quot;)async def get_name(token):    ...await get_name(&quot;.....&quot;)# a key will be &quot;new:user:alex&quot;@default_formatter.register(&quot;upper&quot;)def _upper(value):    return value.upper()@default_formatter.type_format(Decimal)def _decimal(value: Decimal) -&gt; str:    return value.quantize(Decimal(&quot;0.00&quot;))@cache(key=&quot;price-{item.price}:{item.currency:upper}&quot;)async def get_price(item):    ...await get_name(item)# a key will be &quot;price-10.00:USD&quot;```### TTLCache time to live (`ttl`) is a required parameter for all cache decorators. TTL can be:- an integer as numbers of seconds- a `timedelta`- a string like in golang e.g `1d2h3m50s`- a callable object like a function that receive `args` and `kwargs` of the decorated function and return one of previous format for TTLExamples:```pythonfrom cashews import cachefrom datetime import timedeltacache.setup(&quot;mem://&quot;)@cache(ttl=60 * 10)async def get(item_id: int) -&gt; Item:    pass@cache(ttl=timedelta(minutes=10))async def get(item_id: int) -&gt; Item:    pass@cache(ttl=&quot;10m&quot;)async def get(item_id: int) -&gt; Item:    passdef _ttl(item_id: int) -&gt; str:    return &quot;2h&quot; if item_id &gt; 10 else &quot;1h&quot;@cache(ttl=_ttl)async def get(item_id: int) -&gt; Item:    pass```### What can be cachedCashews mostly use built-in pickle to store a data, but also support others pickle like serialization like dill.Some types of objects are not picklable, in this case cashews have api to define custom encoding/decoding:```pythonfrom cashews.serialize import register_typeasync def my_encoder(value: CustomType, *args, **kwargs) -&gt; bytes:    ...async def my_decoder(value: bytes, *args, **kwargs) -&gt; CustomType:    ...register_type(CustomType, my_encoder, my_decoder)```### Cache invalidationCache invalidation - one of the main Computer Science well known problem.Sometimes, you want to invalidate the cache after some action is triggered.Consider this example:```pythonfrom cashews import cachecache.setup(&quot;mem://&quot;)@cache(ttl=&quot;1h&quot;, key=&quot;items:page:{page}&quot;)async def items(page=1):    ...@cache.invalidate(&quot;items:page:*&quot;)async def create_item(item):   ...```Here, the cache for `items` will be invalidated every time `create_item` is calledThere are two problems:1. with redis backend you cashews will scan a full database to get a keys that match a pattern (`items:page:*`) - not good for performance reasons2. what if we do not specify a key for cache:```python@cache(ttl=&quot;1h&quot;)async def items(page=1):    ...```Cashews provide the tag system: you can tag cache keys, so they will be stored in a separate [SET](https://redis.io/docs/data-types/sets/)to avoid high load on redis storage. To use the tags in a more efficient ways please use it with the client side feature```pythonfrom cashews import cachecache.setup(&quot;redis://&quot;, client_side=True)@cache(ttl=&quot;1h&quot;, tags=[&quot;items&quot;, &quot;page:{page}&quot;])async def items(page=1):    ...await cache.delete_tags(&quot;page:1&quot;)await cache.delete_tags(&quot;items&quot;)# low level apicache.register_tag(&quot;my_tag&quot;, key_template=&quot;key{i}&quot;)await cache.set(&quot;key1&quot;, &quot;value&quot;, expire=&quot;1d&quot;, tags=[&quot;my_tag&quot;])```You can invalidate future call of cache request by context manager:```pythonfrom cashews import cache, invalidate_further@cache(ttl=&quot;3h&quot;)async def items():    ...async def add_item(item: Item) -&gt; List[Item]:    ...    with invalidate_further():        await items```#### Cache invalidation on code changeOften, you may face a problem with invalid cache after code is changed. For example:```python@cache(ttl=timedelta(days=1), key=&quot;user:{user_id}&quot;)async def get_user(user_id):    return {&quot;name&quot;: &quot;Dmitry&quot;, &quot;surname&quot;: &quot;Krykov&quot;}```Then, returned value was changed to:```bash-    return {&quot;name&quot;: &quot;Dmitry&quot;, &quot;surname&quot;: &quot;Krykov&quot;}+    return {&quot;full_name&quot;: &quot;Dmitry Krykov&quot;}```Since function returning a dict, there is no way simple way to automatically detectthat kind of cache invalidityOne way to solve the problem is to add a prefix for this cache:```python@cache(ttl=timedelta(days=1), prefix=&quot;v2&quot;)async def get_user(user_id):    return {&quot;full_name&quot;: &quot;Dmitry Krykov&quot;}```but it is so easy to forget to do it...The best defense against this problem is to use your own datacontainers, like[dataclasses](https://docs.python.org/3/library/dataclasses.html),with defined `__repr__` method.This will add distinctness and `cashews` can detect changes in such structures automaticallyby checking [object representation](https://docs.python.org/3/reference/datamodel.html#object.__repr__).```pythonfrom dataclasses import dataclassfrom cashews import cachecache.setup(&quot;mem://&quot;)@dataclassclass User:    name: str    surname: str# or define your own class with __repr__ methodclass User:    def __init__(self, name, surname):        self.name, self.surname = name, surname    def __repr__(self):        return f&quot;{self.name} {self.surname}&quot;# Will detect changes of a structure@cache(ttl=&quot;1d&quot;, prefix=&quot;v2&quot;)async def get_user(user_id):    return User(&quot;Dima&quot;, &quot;Krykov&quot;)```### Detect the source of a resultDecorators give us a very simple API but also make it difficult to understand whereresult is coming from - cache or direct call.To solve this problem `cashews` has `detect` context manager:```pythonfrom cashews import cachewith cache.detect as detector:    response = await something_that_use_cache()    calls = detector.callsprint(calls)# &gt;&gt;&gt; {&quot;my:key&quot;: [{&quot;ttl&quot;: 10, &quot;name&quot;: &quot;simple&quot;, &quot;backend&quot;: &quot;redis&quot;}, ], &quot;fail:key&quot;: [{&quot;ttl&quot;: 10, &quot;exc&quot;: RateLimit}, &quot;name&quot;: &quot;fail&quot;, &quot;backend&quot;: &quot;mem&quot;],}```E.g. A simple middleware to use it in a web app:```python@app.middleware(&quot;http&quot;)async def add_from_cache_headers(request: Request, call_next):    with cache.detect as detector:        response = await call_next(request)        if detector.keys:            key = list(detector.keys.keys())[0]            response.headers[&quot;X-From-Cache&quot;] = key            expire = await cache.get_expire(key)            response.headers[&quot;X-From-Cache-Expire-In-Seconds&quot;] = str(expire)    return response```### MiddlewareCashews provide the interface for a &quot;middleware&quot; pattern:```pythonimport loggingfrom cashews import cachelogger = logging.getLogger(__name__)async def logging_middleware(call, cmd: Command, backend: Backend, *args, **kwargs):    key = args[0] if args else kwargs.get(&quot;key&quot;, kwargs.get(&quot;pattern&quot;, &quot;&quot;))    logger.info(&quot;=&gt; Cache request: %s &quot;, cmd.value, extra={&quot;args&quot;: args, &quot;cache_key&quot;: key})    return await call(*args, **kwargs)cache.setup(&quot;mem://&quot;, middlewares=(logging_middleware, ))```### TransactionalApplications more often based on database with transaction (OLTP) usage. Usually cache support transactions poorly.Here just simple example how we can make our cache inconsistent:```pythonasync def my_handler():    async with db.transaction():        await db.insert(user)        await cache.set(f&quot;key:{user.id}&quot;, user)        await api.service.register(user)```Here the api call may fail, the database transaction will rollback, but the cache will not.Of course, at this code we can solve it by moving the cache call outside transaction, but in real code it may not so easy.Another case: we want to make bulk operations with group of keys to keep it consistent:```pythonasync def login(user, token, session):    ...    old_session = await cache.get(f&quot;current_session:{user.id}&quot;)    await cache.incr(f&quot;sessions_count:{user.id}&quot;)    await cache.set(f&quot;current_session:{user.id}&quot;, session)    await cache.set(f&quot;token:{token.id}&quot;, user)    return old_session```Here we want to have some way to protect our code from race conditions and do operations with cache simultaneously.Cashews support transaction operations:&gt; :warning: \*\*Warning: transaction operations are `set`, `set_many`, `delete`, `delete_many`, `delete_match` and `incr````pythonfrom cashews import cache...@cache.transaction()async def my_handler():    async with db.transaction():        await db.insert(user)        await cache.set(f&quot;key:{user.id}&quot;, user)        await api.service.register(user)# orasync def login(user, token, session):    async with cache.transaction() as tx:        old_session = await cache.get(f&quot;current_session:{user.id}&quot;)        await cache.incr(f&quot;sessions_count:{user.id}&quot;)        await cache.set(f&quot;current_session:{user.id}&quot;, session)        await cache.set(f&quot;token:{token.id}&quot;, user)        if ...:            tx.rollback()    return old_session```Transactions in cashews support different mode of &quot;isolation&quot;- fast (0-7% overhead) - memory based, can't protect of race conditions, but may use for atomicity- locked (default - 4-9% overhead) - use kind of shared lock per cache key (in case of redis or disk backend), protect of race conditions- serializable (7-50% overhead) - use global shared lock - one transaction per time (almost useless)```pythonfrom cashews import cache, TransactionMode...@cache.transaction(TransactionMode.SERIALIZABLE, timeout=1)async def my_handler():   ...```## Development### Setup- Clone the project.- After creating a virtual environment, install [pre-commit](https://pre-commit.com/):  ```shell  pip install pre-commit &amp;&amp; pre-commit install --install-hooks  ```### TestsTo run tests you can use `tox`:```shellpip install toxtox -e py  // tests for inmemory backendtox -e py-diskcache  // tests for diskcache backendtox -e py-redis  // tests for redis backend  - you need to run redistox -e py-integration  // tests for integrations with aiohttp and fastapitox // to run all tests for all python that is installed on your machine```Or use `pytest`, but 2 tests always fail, it is OK:```shellpip install .[tests,redis,diskcache,speedup] fastapi aiohttp requestspytest // run all tests with all backendspytest -m &quot;not redis&quot; // all tests without tests for redis backend```</longdescription>
</pkgmetadata>