<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>runtime-type-checker====================![PyPI](https://img.shields.io/pypi/v/runtime-type-checker)![PyPI - License](https://img.shields.io/pypi/l/runtime-type-checker)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)This package performs type-check at runtime with help of type annotations.## How to use this packageThere are two ways to perform type checks using this package.I provide a few simple examples here. For a complete overview, have a look at the package's unit tests.### 1- the `check_type` functionYou can check an object against a type or an annotation via the `check_type` function.The function returns `None` if the check was successful or raises a `TypeError` in case of error.Note that this function does not check recursively for e.g. the attributes of a class.```pythonfrom typing import List, Sequence, Optional, Mappingfrom dataclasses import dataclassfrom runtime_type_checker import check_typecheck_type(&quot;a&quot;, str)  # OKcheck_type([&quot;a&quot;], List[str])  # OKcheck_type([&quot;a&quot;, 1], Sequence[str])  # raises TypeError@dataclassclass Foo:    a: int    b: Optional[Mapping[str, int]] = Nonecheck_type(Foo(1), Foo)  # OKcheck_type(Foo(1), int)  # raises TypeError```### 2- The check_types decoratorYou can also type-check classes upon instance creation and functions or methods upon call through the `check_types`decorator:```pythonfrom typing import Optional, Mappingfrom dataclasses import dataclassfrom runtime_type_checker import check_typesdef run_typed(f):  return check_types(dataclass(f))@check_types@dataclassclass Foo:    a: int    b: Optional[Mapping[str, int]] = NoneFoo(1)              # returns an instance of fooFoo(0, {&quot;a&quot;: &quot;b&quot;})  # raises TypeError@check_typesdef bar(a: bool, **options: str) -&gt; str:    return options.get(&quot;b&quot;, &quot;missing&quot;) if a else &quot;unknown&quot;bar(True, b=&quot;1&quot;)  # returns &quot;1&quot;bar(True, c=1)    # raises TypeError```## Package features and short-comings### 1- Features- _simplicity_: there's only one function and one decorator to keep in mind.- _robustness_: this package relies on the `typing-inspect` for the heavy lifting. This package is maintained bycore contributors to the typing module, which means very little hacks on my side to work with older versions of python.### 2- Short-comings- _coverage_: I don't offer coverage for all features of type annotations: for example Protocol, Generators, IO are notcurrently supported. Generics are not really well handled.</longdescription>
</pkgmetadata>