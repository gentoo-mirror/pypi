<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;h1 align=&quot;center&quot; style=&quot;border-bottom: 0&quot;&gt;  ðŸªµ&lt;br&gt;  Troncos &lt;br/&gt;&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;    &lt;em&gt;        Collection of Python logging, tracing and profiling tools    &lt;/em&gt;    &lt;br&gt;    &lt;a href=&quot;https://github.com/kolonialno/troncos/actions?workflow=CI&quot;&gt;        &lt;img src=&quot;https://github.com/kolonialno/troncos/actions/workflows/ci.yml/badge.svg&quot; alt=&quot;CI status&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://pypi.python.org/pypi/troncos&quot;&gt;        &lt;img src=&quot;https://img.shields.io/pypi/v/troncos.svg&quot;&gt;    &lt;/a&gt;    &lt;img src=&quot;https://img.shields.io/pypi/pyversions/troncos&quot;&gt;    &lt;a href=&quot;https://github.com/kolonialno/troncos/blob/master/LICENSE&quot;&gt;        &lt;img src=&quot;https://img.shields.io/github/license/kolonialno/troncos.svg&quot;&gt;    &lt;/a&gt;&lt;/p&gt;&lt;!-- TOC --&gt;  * [Etymology](#etymology)  * [Installation](#installation)  * [Setup](#setup)    * [Choosing a trace exporter](#choosing-a-trace-exporter)      * [gRPC](#grpc)      * [http](#http)    * [Import order](#import-order)    * [Plain setup](#plain-setup)    * [Starlette with uvicorn](#starlette-with-uvicorn)    * [Django](#django)  * [Logging](#logging)    * [Thoughts on logging](#thoughts-on-logging)    * [Log traces with Gunicorn](#log-traces-with-gunicorn)    * [Structlog](#structlog)  * [Tracing](#tracing)    * [Tracing your code](#tracing-your-code)      * [trace_function](#tracefunction)      * [trace_block](#traceblock)      * [trace_class](#traceclass)      * [trace_module](#tracemodule)      * [trace_ignore](#traceignore)    * [Trace Propagation](#trace-propagation)      * [Send context](#send-context)      * [Receive context](#receive-context)    * [Trace sampling](#trace-sampling)    * [Trace debugging](#trace-debugging)  * [Profiling](#profiling)    * [Setup endpoint](#setup-endpoint)    * [Enable scraping](#enable-scraping)  * [Development](#development)&lt;!-- TOC --&gt;## Etymology&quot;Troncos&quot; is the plural of the spanish word &quot;Tronco&quot;, which translates to &quot;trunk&quot; or &quot;log&quot;.## Installation```console# With pip$ pip install troncos# With poetry (grpc trace exporter)$ poetry add troncos -E grpc# With poetry (http trace exporter)$ poetry add troncos -E http```## Setup&gt; **Note**: It is a good idea to use a `settings.py`-file (or similar) as an authoritative source of variables (service name, environment, whether tracing is enabled or not, log level, etc). In this README we mostly use `os.environ` for the sake of clarity.### Choosing a trace exporterTo export your traces, you have to pick either `grpc` or `http`. Using `grpc` gives you significant performance gains. If you are running a critical service with high load in production, we recommend using `grpc`.#### gRPC```toml[tool.poetry.dependencies]troncos = {version=&quot;?&quot;, extras = [&quot;grpc&quot;]}```#### http```toml[tool.poetry.dependencies]troncos = {version=&quot;?&quot;, extras = [&quot;http&quot;]}```&gt; **Note**: You need to change the `TRACE_PORT` depending on your choice of protocol `http`/`grpc`.### Import orderIt is very important that you do **NOT** import `ddtrace` anywhere before you have initialized troncos! Troncos should give you a warning if this is the case.### Plain setup```pythonfrom os import environfrom troncos.logs import init_logging_basicfrom troncos.traces import init_tracing_basic, http_endpoint_from_envfrom troncos.profiling import init_profiling_basicinit_logging_basic(    level=environ.get(&quot;LOG_LEVEL&quot;, &quot;INFO&quot;),    formatter=environ.get(&quot;LOG_FORMATTER&quot;, &quot;cli&quot;)  # Use &quot;logfmt&quot; or &quot;json&quot; in production)init_tracing_basic(    endpoint=http_endpoint_from_env(&quot;TRACE_HOST&quot;, &quot;TRACE_PORT&quot;, &quot;/v1/traces&quot;),    # endpoint_dd=http_endpoint_from_env(&quot;TRACE_DD_HOST&quot;, &quot;TRACE_DD_PORT&quot;),    service_name=&quot;my_service&quot;,    service_version=environ.get(&quot;VERSION&quot;, &quot;unknown&quot;),    service_env=environ.get(&quot;ENVIRONMENT&quot;, &quot;localdev&quot;),)profiler = init_profiling_basic()# Import all your other stuff ...```### Starlette with uvicorn```pythonfrom os import environfrom troncos.logs import init_logging_basicfrom troncos.traces import init_tracing_basic, http_endpoint_from_envfrom troncos.profiling import init_profiling_basicinit_logging_basic(    level=environ.get(&quot;LOG_LEVEL&quot;, &quot;INFO&quot;),    formatter=environ.get(&quot;LOG_FORMATTER&quot;, &quot;cli&quot;)  # Use &quot;logfmt&quot; or &quot;json&quot; in production)init_tracing_basic(    endpoint=http_endpoint_from_env(&quot;TRACE_HOST&quot;, &quot;TRACE_PORT&quot;, &quot;/v1/traces&quot;),    # endpoint_dd=http_endpoint_from_env(&quot;TRACE_DD_HOST&quot;, &quot;TRACE_DD_PORT&quot;),    service_name=&quot;my_service&quot;,    service_version=environ.get(&quot;VERSION&quot;, &quot;unknown&quot;),    service_env=environ.get(&quot;ENVIRONMENT&quot;, &quot;localdev&quot;),)profiler = init_profiling_basic()# Import all your other stuff ...from fastapi import FastAPIfrom troncos.frameworks.starlette.uvicorn import init_uvicorn_loggingapp = FastAPI(title=&quot;my_service&quot;)init_uvicorn_logging(    app=app,    log_access_ignored_paths=[&quot;/health&quot;, &quot;/metrics&quot;],)```&gt; **Note**: If you are running starlette but not calling `init_uvicorn_logging`, traces might not be logged.### DjangoAdd this logging and trace initialization to your `settings.py` file:```pythonimport environfrom troncos.traces import init_tracing_basicenv = environ.Env()APP_NAME = &quot;my_service&quot;VERSION = env.str(&quot;VERSION&quot;, default=&quot;unknown&quot;)ENVIRONMENT = env.str(&quot;ENVIRONMENT&quot;, default=&quot;localhost&quot;)# ... All your settings here ...# Configure loggingLOG_FORMATTER = env.str(&quot;LOG_FORMATTER&quot;, &quot;logfmt&quot;)LOG_LEVEL = env.str(&quot;LOG_LEVEL&quot;, &quot;INFO&quot;)LOGGING = {    &quot;version&quot;: 1,    &quot;disable_existing_loggers&quot;: True,    &quot;filters&quot;: {        &quot;trace_id&quot;: {&quot;()&quot;: &quot;troncos.logs.filters.TraceIdFilter&quot;},    },    &quot;formatters&quot;: {        &quot;cli&quot;: {&quot;()&quot;: &quot;troncos.logs.formatters.PrettyFormatter&quot;},        &quot;json&quot;: {&quot;()&quot;: &quot;troncos.logs.formatters.JsonFormatter&quot;},        &quot;logfmt&quot;: {&quot;()&quot;: &quot;troncos.logs.formatters.LogfmtFormatter&quot;},    },    &quot;handlers&quot;: {        &quot;console&quot;: {            &quot;class&quot;: &quot;logging.StreamHandler&quot;,            &quot;formatter&quot;: LOG_FORMATTER,            &quot;filters&quot;: [&quot;trace_id&quot;],        }    },    &quot;loggers&quot;: {        APP_NAME: {&quot;handlers&quot;: [&quot;console&quot;], &quot;level&quot;: LOG_LEVEL},        &quot;django&quot;: {&quot;handlers&quot;: [&quot;console&quot;], &quot;level&quot;: LOG_LEVEL},        &quot;django.server&quot;: {            &quot;handlers&quot;: [&quot;console&quot;],            &quot;level&quot;: LOG_LEVEL,            &quot;propagate&quot;: False,        },        &quot;gunicorn.error&quot;: {            &quot;handlers&quot;: [&quot;console&quot;],            &quot;level&quot;: LOG_LEVEL,        },    },}# Configure tracingTRACING_ENABLED = env.bool(&quot;OPENTELEMETRY_TRACING_ENABLED&quot;, default=False)TRACING_HOST = env.str(&quot;OPENTELEMETRY_TRACING_HOST&quot;, default=&quot;localhost&quot;)TRACING_PORT = env.int(&quot;OPENTELEMETRY_TRACING_PORT&quot;, default=4318)init_tracing_basic(    service_name=APP_NAME,    service_version=VERSION,    service_env=ENVIRONMENT,    endpoint=f&quot;http://{TRACING_HOST}:{TRACING_PORT}/v1/traces&quot;    if TRACING_ENABLED    else None,    # endpoint_dd=f&quot;http://{TRACING_DD_HOST}:{TRACING_DD_PORT}&quot;    # if TRACING_DD_ENABLED    # else None,)```&gt; **Note**: This will not log traces of all incoming requests. See [log traces with Gunicorn](#log-traces-with-gunicorn) section on how to do that.## Logging### Thoughts on loggingMore often then not, you want all loggers to propagate their records to the `root` logger and make the `root` logger handle everything. Depending on your project, this might require some additional configuration. Looking at the [python logging flow](https://docs.python.org/3/howto/logging.html#logging-flow) can help you understand how child loggers can propagate records to the `root` logger. Note that propagating to `root` is the default behaviour.There is a nice helper function that will print all loggers in troncos called `print_loggers`:```pythonfrom troncos.logs import print_loggersprint_loggers(verbose=False)  # To visualize loggers```After calling the `init_logging_basic` function in a simple project you should see something like this printed `print_loggers`:```consoleLoggers:[ root                 ] logging.RootLogger LEVEL: 20 PROPAGATE: True  â”” HANDLER logging.StreamHandler  LEVEL: 20    â”” FILTER troncos.logs.filters.TraceIdFilter    â”” FORMATTER troncos.logs.formatters.PrettyFormatter```So in general, after the initial setup you can use any logger and that will propagate the log record to root:```pythonimport logginglogging.getLogger(&quot;my.random.logger&quot;).info(&quot;Root will handle this record&quot;)```### Log traces with GunicornCreate a `gunicorn/config.py` file in your project:```pythonimport timedef post_fork(server, worker):    passdef pre_request(worker, req):    req._gunicorn_start_time = time.time()    worker.log.info(&quot;[begin] %s %s&quot;, req.method, req.path)    passdef post_request(worker, req, environ, resp):    duration = time.time() - req._gunicorn_start_time    trace_id = next(iter([v for k, v in req.headers if k == &quot;X-B3-TRACEID&quot;]), None)    worker.log.info(        &quot;[status=%s] %s %s duration=%s traceID=%s&quot;,        resp.status,        req.method,        req.path,        duration,        trace_id,    )```Then when running gunicorn, specify what config file to use:```consolegunicorn myapp.wsgi:application --config python:myapp.gunicorn.config ...```### StructlogYou can substitute `init_logging_basic` with `init_logging_structlog` to setup structlog:```pythonimport structlogfrom os import environfrom troncos.frameworks.structlog.setup import init_logging_structloginit_logging_structlog(    level=environ.get(&quot;LOG_LEVEL&quot;, &quot;INFO&quot;),    formatter=environ.get(&quot;LOG_FORMATTER&quot;, &quot;cli&quot;),  # Use &quot;logfmt&quot; in production)log = structlog.get_logger()log.info(&quot;Some Message&quot;)```Alternatively you can add trace injection into your own structlog setup:```pythonimport structlogfrom structlog.dev import ConsoleRendererfrom troncos.frameworks.structlog.processors import trace_injection_processorstructlog.configure(    processors=[        trace_injection_processor,        ConsoleRenderer(),    ],)log = structlog.get_logger()log.info(&quot;Some Message&quot;)```## Tracing### Tracing your codeAfter initializing tracing in your project you can use different methods to trace your code.#### trace_functionThis decorator adds tracing to a function. You can supply a tracer provider, if none is supplied, the global tracer provider will be used:```pythonfrom troncos.traces.decorate import trace_function@trace_functiondef myfunc1():    return &quot;This will be traced&quot;@trace_function(service=&quot;my_custom_service&quot;)def myfunc2():    return &quot;This will be traced as my_custom_service&quot;```#### trace_blockTrace using a with statement. You can supply a tracer provider, if none is supplied, the global tracer provider will be used.```pythonfrom troncos.traces.decorate import trace_blockwith trace_block(name=&quot;action&quot;, resource=&quot;thing&quot;, attributes={&quot;some&quot;: &quot;attribute&quot;}):    print(&quot;... do an action to a thing...&quot;)```#### trace_classThis decorator adds a tracing decorator to every method of the decorated class. If you don't want some methods to be traced, you can add the [trace_ignore](#traceignore) decorator to them. You can supply a tracer provider, if none is supplied, the global tracer provider will be used:```pythonfrom troncos.traces.decorate import trace_class, trace_ignore@trace_classclass MyClass1:    def m1(self):        return &quot;This will be traced&quot;    @trace_ignore    def m2(self):        return &quot;This will not traced&quot;@trace_class(service=&quot;my_custom_service&quot;)class MyClass2:    def m3(self):        return &quot;This will be traced as my_custom_service&quot;```#### trace_moduleThis function adds a tracing decorator to every function of the calling module. If you don't want some functions to be traced, you can add the [trace_ignore](#traceignore) decorator to them. You can supply a tracer provider, if none is supplied, the global tracer provider will be used:```pythonfrom troncos.traces.decorate import trace_ignore, trace_moduledef my_function():    return &quot;This func will be traced&quot;@trace_ignoredef my_function():    return &quot;This func will not be traced&quot;trace_module()```#### trace_ignoreA decorator that will make [trace_class](#traceclass) and [trace_module](#tracemodule) ignore the decorated function/method.### Trace Propagation&gt; **Warning**: Traces with IDs bigger than `64` bits are not propagated correctly because of limitations of [ddtrace](https://github.com/DataDog/dd-trace-py/blob/1e1de001d3fd694d3bcf0fff604a927ef891b19e/ddtrace/propagation/http.py#L102-L108). Default trace ID size for OTEL is `128` bits.If you want to propagate your trace to the next service, you need to send/receive special headers with your request/message. If you are using plain `requests` that should be handled automatically by troncos. Here is how you do this manually:#### Send context```pythonfrom troncos.traces.propagation import get_propagation_value# Get header valuevalue = get_propagation_value()# Send it somewhere```or```pythonfrom troncos.traces.propagation import add_context_to_dictsome_dict = {}# Add propagation headers to dictadd_context_to_dict(some_dict)# Send it somewhere```#### Receive contextAgain, troncos should in most cases do this automatically for you, but here is how you do it manually:```pythonfrom troncos.traces.propagation import activate_context_from_dictfrom troncos.traces.decorate import trace_blocksome_dict = {} activate_context_from_dict(some_dict)with trace_block(&quot;my_block&quot;):    print(&quot;... do something ...&quot;)```### Trace samplingSet these variables to turn on trace sampling:```consoleOTEL_TRACES_SAMPLER=parentbased_traceidratioOTEL_TRACES_SAMPLER_ARG=0.05DD_TRACE_SAMPLE_RATE=0.05```### Trace debuggingYou can enable trace debugging by setting the environmental variable `OTEL_TRACE_DEBUG=true`. That will print all spans to the console. If you would rather get the spans in a file you can also provide the variable `OTEL_TRACE_DEBUG_FILE=/tmp/traces`.## Profiling&gt; **Warning**: Profiling while using Python 3.11 is [not yet fully supported](https://github.com/DataDog/dd-trace-py/issues/4149).### Setup endpointSimply add a `/debug/pprof` endpoint that returns the profile:```pythonfrom fastapi import FastAPIfrom starlette.responses import Responsefrom troncos.profiling import init_profiling_basicprofiler = init_profiling_basic()app = FastAPI(title=&quot;my_service&quot;)@app.get(&quot;/debug/pprof&quot;, response_model=str)async def debug_pprof() -&gt; Response:    content, headers = profiler()    return Response(content=content, headers=headers)```You can verify that your setup works with the [pprof](https://github.com/google/pprof) cli:```console$ pprof -http :6060 &quot;http://localhost:8080/debug/pprof&quot;```&gt; **Note**: You will get an empty string from `profiler()` until the first profile has been collected.### Enable scrapingWhen you deploy your application, be sure to use the custom oda annotation for scraping:```yamlannotations:    phlare.oda.com/port: &quot;8080&quot;    phlare.oda.com/scrape: &quot;true&quot;```## DevelopmentWhen developing troncos you should be constantly aware of the fact that under no circumstances should you import `ddtrace` into your module. That would cause the tracer to initialize with default values that would not change when the user initializes the tracer.For this reason, if you need to use any parts of `ddtrace` in your code, consider using the `_ddlazy` module, that gives you access lazily. If that does not satisfy your requirements you can always import `ddtrace` in your functions (not at the top of your module).You can compare performance of your local version, to some older version of troncos using the [performance test setup](./perf).</longdescription>
</pkgmetadata>