<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>#################django-polymodels#################A django application that provides a simple way to retrieve models type castedto their original ``ContentType``... image:: https://travis-ci.org/charettes/django-polymodels.svg?branch=master    :target: https://travis-ci.org/charettes/django-polymodels.. image:: https://coveralls.io/repos/charettes/django-polymodels/badge.svg?branch=master&amp;service=github    :target: https://coveralls.io/github/charettes/django-polymodels?branch=master************Installation************&gt;&gt;&gt; pip install django-polymodelsMake sure ``'django.contrib.contenttypes'`` and ``'polymodels'`` are inyour `INSTALLED_APPS`::    INSTALLED_APPS += ('django.contrib.contenttypes', 'polymodels')*****Usage*****Subclass ``PolymorphicModel``, an abstract model class.::    from django.db import models    from polymodels.models import PolymorphicModel    class Animal(PolymorphicModel):        name = models.CharField(max_length=255)        def __str__(self):            return self.name    class Mammal(Animal):        pass    class Dog(Mammal):        pass    class Reptile(Animal):        pass    class Snake(Reptile):        class Meta:            proxy = TrueObjects are created the same way as usual and their associated ``ContentType``is saved automatically:&gt;&gt;&gt; animal = Animal.objects.create(name='animal')&gt;&gt;&gt; mammal = Mammal.objects.create(name='mammal')&gt;&gt;&gt; reptile = Reptile.objects.create(name='reptile')&gt;&gt;&gt; snake = Snake.objects.create(name='snake')To retreive *type casted* instances from the ``Animal.objects`` manager you justhave to use the ``select_subclasses`` method.&gt;&gt;&gt; Animal.objects.select_subclasses()[&lt;Animal: animal&gt;, &lt;Mammal: mammal&gt;, &lt;Reptile: reptile&gt;, &lt;Snake: snake&gt;]You can also retreive a subset of the subclasses by passing them as arguments to``select_subclass``.&gt;&gt;&gt; Animal.objects.select_subclasses(Reptile)[&lt;Reptile: reptile&gt;, &lt;Snake: snake&gt;]Or directly from subclasses managers.&gt;&gt;&gt; Reptile.objects.select_subclasses(Snake)[&lt;Snake: snake&gt;]Note that you can also retrieve original results by avoiding the``select_subclasses`` call.&gt;&gt;&gt; Animal.objects.all()[&lt;Animal: animal&gt;, &lt;Animal: mammal&gt;, &lt;Animal: reptile&gt;, &lt;Animal: snake&gt;]It's also possible to select only instances of the model to which themanager is attached by using the ``exclude_subclasses`` method.&gt;&gt;&gt; Mammal.objects.all()[&lt;Mammal: mammal&gt;]Each instance of ``PolymorphicModel`` has a ``type_cast`` method that knows howto convert itself to the correct ``ContentType``.&gt;&gt;&gt; animal_snake = Animal.objects.get(pk=snake.pk)&lt;Animal: snake&gt;&gt;&gt;&gt; animal_snake.type_cast()&lt;Snake: snake&gt;&gt;&gt;&gt; animal_snake.type_cast(Reptile)&lt;Reptile: snake&gt;If the ``PolymorphicModel.content_type`` fields conflicts with one of yourexisting fields you just have to subclass``polymodels.models.BasePolymorphicModel`` and specify which field *polymodels*should use instead by defining a ``CONTENT_TYPE_FIELD`` attribute on your model.This field must be a ``ForeignKey`` to ``ContentType``.::    from django.contrib.contenttypes.models import ContentType    from django.db import models    from polymodels.models import BasePolymorphicModel    class MyModel(BasePolymorphicModel):        CONTENT_TYPE_FIELD = 'polymorphic_ct'        polymorphic_ct = models.ForeignKey(ContentType)************How it works************Under the hood ``select_subclasses`` calls ``seleted_related`` to avoidunnecessary queries and ``filter`` if you pass some classes to it. On querysetiteration, the fetched instanced are converted to their correct type by calling``BasePolymorphicModel.type_cast``. Note that those lookups are cached on classcreation to avoid computing them on every single query.******************Note of the author******************I'm aware there's already plenty of existing projects tackling the whole**model-inheritance-type-casting-thing** such as `django-polymorphic`_. HoweverI wanted to implement this feature in a lightweight way: no``__metaclass__`` or ``__init__`` overrides while using django's public API asmuch as possible. In the end, this was really just an extraction of`django-mutant`_'s own mecanism of handling this since I needed it as astandalone app for another project... _django-polymorphic: https://github.com/chrisglass/django_polymorphic.. _django-mutant: https://github.com/charettes/django-mutant**********Contribute**********If you happen to encounter a bug or would like to suggest a feature additionplease `file an issue`_ or `create a pull request`_ containing **tests**... _file an issue: https://github.com/charettes/django-polymodels/issues.. _create a pull request: https://github.com/charettes/django-polymodels/pulls*******Credits******** Inspired by a `post of Jeff Elmores`_... _post of Jeff Elmores: http://jeffelmore.org/2010/11/11/automatic-downcasting-of-inherited-models-in-django/</longdescription>
</pkgmetadata>