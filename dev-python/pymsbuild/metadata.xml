<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pymsbuildThis is a PEP 517 backend for building packages via MSBuild or `dotnet build`.# Configuration fileThe file is named `_msbuild.py`, and is executed by running `python -m pymsbuild`.The package definition specifies all the files that end up in the released packages.```pythonfrom pymsbuild import *METADATA = {    &quot;Metadata-Version&quot;: &quot;2.1&quot;,    &quot;Name&quot;: &quot;package&quot;,    &quot;Version&quot;: &quot;1.0.0&quot;,    &quot;Author&quot;: &quot;My Name&quot;,    &quot;Author-email&quot;: &quot;myemail@example.com&quot;,    &quot;Description&quot;: File(&quot;README.md&quot;),    &quot;Description-Content-Type&quot;: &quot;text/markdown&quot;,    &quot;Classifier&quot;: [        &quot;Development Status :: 3 - Alpha&quot;,        &quot;Intended Audience :: Developers&quot;,        &quot;Programming Language :: Python :: 3.9&quot;,    ],}PACKAGE = Package(    &quot;my_package&quot;,    PyFile(r&quot;my_package\*.py&quot;),    PydFile(        &quot;_accelerator&quot;,        CSourceFile(r&quot;win32\*.c&quot;),        IncludeFile(r&quot;win32\*.h&quot;),    ),    Package(        &quot;subpackage&quot;,        PyFile(r&quot;subpackage\*.py&quot;),    ),)```Note that subpackages _must_ be specified as a `Package` element, as thenesting of `Package` elements determines the destination path. Otherwise youwill find all of your files flattened. Recursive wildcards, while partiallysupported, are not going to work!Also note that without a `source=` named argument, all source paths arerelative to the configuration file.# pyproject.toml fileYou will need this file in order for `pip` to build your sdist, but otherwise it'sgenerally easier and faster to use `pymsbuild` directly.```[build-system]requires = [&quot;pymsbuild&quot;]build-backend = &quot;pymsbuild&quot;```On Windows, a [Visual Studio](https://www.visualstudio.com) installation will berequired. It will be automatically detected, or the path to MSBuild can beprovided as the `MSBUILD` environment variable.On other platforms, the [.NET SDK](https://dotnet.microsoft.com/download) will berequired. The `dotnet` command must be available on `PATH` or specified as the`MSBUILD` environment variable.If you have additional requirements for building either sdist or wheels, addthem as `BuildSdistRequires` or `BuildWheelRequires` values in `METADATA`. Theywill be parsed after `init_METADATA` and/or `init_PACKAGE` have been called, somay be modified by these functions.# Usage## Rebuild the current project in-place.```python -m pymsbuild```## Interactively generate the `_msbuild.py` file with project spec.(Or at least, it will, once implemented.)```python -m pymsbuild init```## Build the project and output an sdist```python -m pymsbuild sdist```Output is put into `dist` by default, but can be overridden with `--dist-dir`(`-d`).## Build the project and output a wheel```python -m pymsbuild wheel```Output is put into `dist` by default, but can be overridden with `--dist-dir`(`-d`).## Clean any recent builds```python -m pymsbuild clean```# Advanced Examples## Dynamic METADATAMetadata may be dynamically generated, either on import or with the`init_METADATA` function. This function is called and must eitherreturn the metadata dict to use, or update `METADATA` directly.However, if a `PKG-INFO` file is found adjacent to the configurationfile, it will be used verbatim. Sdist generation adds this file, so allmetadata is static from that point onward. `init_METADATA` is notcalled in this case.```pythonfrom pymsbuild import *METADATA = {    &quot;Metadata-Version&quot;: &quot;2.1&quot;,    &quot;Name&quot;: &quot;package&quot;,    &quot;Version&quot;: os.getenv(&quot;VERSION&quot;, &quot;1.0.0&quot;),    &quot;Author&quot;: &quot;My Name&quot;,    &quot;Author-email&quot;: &quot;myemail@example.com&quot;,    &quot;Description&quot;: File(&quot;README.md&quot;),    &quot;Description-Content-Type&quot;: &quot;text/markdown&quot;,    &quot;Classifier&quot;: [        &quot;Development Status :: 3 - Alpha&quot;,        &quot;Intended Audience :: Developers&quot;,        &quot;Programming Language :: Python :: 3.9&quot;,    ],}def init_METADATA():    if os.getenv(&quot;BUILD_BUILDNUMBER&quot;):        METADATA[&quot;Version&quot;] = f&quot;1.0.{os.getenv('BUILD_BUILDNUMBER', '')}&quot;    # Updated METADATA directly, so no need to return anything```## Separate packagesPackages are just Python objects, so they may be kept in variables andused later. They also expose a `members` attribute, which is a list, sothat members can be added or inserted later.After the entire module is executed, the package in `PACKAGE` is theonly one used to generate output.```pythonP1 = Package(    &quot;submodule&quot;,    PyFile(r&quot;src\submodule\__init__.py&quot;))P2 = Package(    &quot;submodule_2&quot;,    PyFile(r&quot;src\submodule_2\__init__.py&quot;))PACKAGE = Package(&quot;my_package&quot;, P1)PACKAGE.members.append(P2)```## Dynamic packagesAfter import, if an `init_PACKAGE(tag=None)` function exists it will becalled with the intended platform tag. It must modify or return`PACKAGE`. This function is called for in-place, sdist and wheelgeneration, however, for sdists (and any scenario that should notgenerate binaries), `tag` will be `None`. Otherwise, it will be astring like `cp38-cp38-win32`.```pythonPACKAGE = Package(    &quot;my_package&quot;,    PyFile(r&quot;my_package\*.py&quot;),)def init_PACKAGE(tag=None):    if tag and tag.endswith(&quot;-win_amd64&quot;):        data_file = generate_data_amd64()        PACKAGE.members.append(File(data_file))```Note that all files to be included in an sdist must be referenced when`tag` is `None`. Conditional compilation is best performed using conditionsin the package elements, rather than using `init_PACKAGE`. However, if youare going to use `init_PACKAGE`, you should _remove_ elements rather thanadding them if they should be included in your sdist.Files added as part of a wildcard can be removed by adding a `RemoveFile`element. These may be added dynamically during `init_PACKAGE`, and mustappear after the element that included the files.```pythonPACKAGE = Package(    &quot;my_package&quot;,    PyFile(r&quot;my_package\*.py&quot;),    RemoveFile(PyFile, r&quot;my_package\_internal.py&quot;),)```To exclude files from a wildcard in the first place, chain the `.excluding`method on the original element. The pattern will be evaluated in exactly thesame way as the inclusion pattern, and any paths that match will be omitted.```pythonPACKAGE = Package(    &quot;my_package&quot;,    PyFile(r&quot;my_package\*.py&quot;).excluding(&quot;my_package\internal*.py&quot;),)```Alternatively, a condition may be added to the file pattern to only includefiles matching MSBuild style conditions. Because these will be applied toitem groups, the `%()` metadata syntax should be used to access informationfor the element being added. Either the `.if_` method or the`ConditionalValue` wrapper may be used.```pythonPACKAGE = Package(    &quot;my_package&quot;,    PyFile(r&quot;my_package\*.py&quot;).if_(&quot;%(Filename) != '_internal'&quot;),    File(ConditionalValue(&quot;*.txt&quot;, condition=&quot;%(Filename.StartsWith(`internal`))&quot;)),)```## Source offsetsIf you keep your source in a `src` folder (recommended), provide the`source=` argument to `Package` in order to properly offset filenames.Because it is a named argument, it must be provided last.This is important for sdist generation and in-place builds, which needto match package layout with source layout. Simply prefixing filenamepatterns with the additional directory is not always sufficient.Note that this will also offset subpackages, and that subpackages mayinclude additional `source` arguments. However, it only affectssources, while the package name (the first argument) determines wherein the output the package will be located. In-place builds will createnew folders in your source tree if it does not match the finalstructure.```pythonPACKAGE = Package(    &quot;my_package&quot;,    PyFile(r&quot;my_package\__init__.py&quot;),    source=&quot;src&quot;,)```## Project file overrideBoth `Package` and `PydFile` types generate MSBuild project files andexecute them as part of build, including sdists. For highly customisedbuilds, this generation may be overridden completely by specifying the`project_file` named argument. All members are then ignored.By doing this, you take full responsibility for a valid build,including providing a number of undocumented and unsupported targets.Recommendations:* lock your `pymsbuild` dependency to a specific version in `pyproject.toml`* generate project files first and modify, rather than writing by hand* read the `pymsbuild` source code, especially the `targets` folder* consider contributing/requesting your feature```pythonPACKAGE = Package(    &quot;my_package&quot;,    PydFile(&quot;_accelerator&quot;, project_file=r&quot;src\accelerator.vcxproj&quot;))```## Compiler/linker argumentsRather than overriding the entire project file, there are a number ofways to inject arbitrary values into a project. These requirefamiliarity with MSBuild files and the toolsets you are building with.The `Property` element inserts a `&lt;PropertyGroup&gt;` with the value youspecifiy at the position in the project the element appears.Note that project files also interpret (most) named arguments asproperties, so the two properties shown here are equivalent.```pythonPYD = PydFile(    &quot;module&quot;,    Property(&quot;WindowsSdkVersion&quot;, &quot;10.0.18363.0&quot;),    WindowsSdkVersion=&quot;10.0.18363.0&quot;,    ...)```The `ItemDefinition` element inserts an `&lt;ItemDefinitionGroup&gt;` withthe type and metadata you specify at the position in the project theelement appears.```pythonPYD = PydFile(    &quot;module&quot;,    ItemDefinition(&quot;ClCompile&quot;, PreprocessorDefinitions=&quot;Py_LIMITED_API&quot;),    ...)```The `ConditionalValue` item may wrap any element value to addconditions or concatenate the value. This may also be used on sourcearguments for file elements.```python    ...    Property(&quot;Arch&quot;, ConditionalValue(&quot;x86&quot;, condition=&quot;$(Platform) == 'Win32'&quot;)),    Property(&quot;Arch&quot;, ConditionalValue(&quot;x64&quot;, if_empty=True)),    ...    ItemDefinition(        &quot;ClCompile&quot;,        AdditionalIncludeDirectories=            ConditionalValue(INCLUDES + &quot;;&quot;, prepend=True),        ProprocessorDefinitions=            ConditionalValue(&quot;;Py_LIMITED_API&quot;, append=True),    ),    ...```The `Prepend` shortcut may be used to reduce the amount of text forproperty values. Remember to include the appropriate separator.```python    ...    ItemDefinition(        &quot;ClCompile&quot;,        AdditionalIncludeDirectories=Prepend(INCLUDES + &quot;;&quot;),        ProprocessorDefinitions=Prepend(&quot;Py_LIMITED_API;&quot;),    ),    ...````ConditionalValue` may also be used to dynamically update values in the`init_PACKAGE` function, allowing you to keep the structure mostlystatic but insert values from the current `METADATA` (which is fullyevaluated by the time `init_PACKAGE` is called). This saves having toaccess internal members of other types in order to replace literalvalues.```pythonVER = ConditionalValue(&quot;1.0.0&quot;)PYD = PydFile(    &quot;module&quot;,    Property(&quot;Version&quot;, VER),    CSourceFile(r&quot;src\*.c&quot;),    IncludeFile(r&quot;src\*.h&quot;),)def init_PACKAGE(tag):    VER.value = METADATA[&quot;Version&quot;]```As a last resort, the `LiteralXml` element inserts plain text directlyinto the generated file. It will be inserted as a child of thetop-level `Project` element.```python    ...    LiteralXml(&quot;&lt;Import Project='my_props.props' /&gt;&quot;),    ...```## Alternate config fileTo use a configuration file other than `_msbuild.py`, specify the`--config` (`-c`) argument or the `PYMSBUILD_CONFIG` environmentvariable.```powershellpython -m pymsbuild --config build-spec.py sdistpython -m pymsbuild --config build-spec.py wheel# Alternatively$env:PYMSBUILD_CONFIG = &quot;build-spec.py&quot;python -m pymsbuild sdist wheel```Generated sdists will rename the configuration file back to`_msbuild.py` in the package to ensure that builds work correctly.There is no need to override the configuration file path whenbuilding from sdists.Note that this is different from the `PYMSBUILD_CONFIGURATION`variable, which is used to select debug/release settings for compiledmodules.## Cross-compiling wheelsCross compilation may be used by overriding the wheel tag, ABI tag,or build platform, as well as the source for Python's includes andlibraries. These all use environment variables, to ensure that thesame setting can flow through a package installer's own process.It is also possible to permanently override the wheel tag by addinga `'WheelTag'` metadata value, or the ABI tag by adding an `'AbiTag'`metadata value.The wheel tag is used for the generated wheel file, and to fill in amissing ABI tag and platform.The ABI tag is used for any native extension modules, and to fill ina missing platform.Any `*` elements in the wheel tag are filled in from other locations.For example, specifying `*-none-any` will infer the interpreter fieldfrom the current runtime, whil `py3-none-*` will infer the platformfrom the currnet system (or a specific ABI tag).The platform is used to determine the MSBuild target platform. Itcannot yet automatically select the correct Python libraries, and soyou will need to set `PYTHON_INCLUDES` and `PYTHON_LIBS` (or with a`PYMSBULID_` prefix) environment variables as well to locate thecorrect files.You can override the platform toolset with the `'PlatformToolset'`metadata value, for scenarios where this information ought to beincluded in an sdist.The set of valid platforms for auto-generated `.pyd` project files arehard-coded into `pymsbuild` and are currently `Win32`, `x64`, `ARM` and`ARM64`. Custom project files may use whatever they like. Theseplatforms should behave properly cross-platform, though in general only`x64` and `ARM64` are supported.```powershell# Directly specify the resulting wheel tag# This is used for the wheel filename/metadata$env:PYMSBUILD_WHEEL_TAG = &quot;py38-cp38-win_arm64&quot;# Directly set the ABI tag (or else taken from wheel tag)# This is used for extension module filenames$env:PYMSBUILD_ABI_TAG = &quot;cp38-win_arm64&quot;# Specify the Python platform (or else taken from ABI tag)# This is used for MSBuild options$env:PYMSBUILD_PLATFORM = &quot;win_arm64&quot;# Specify the paths to ARM64 headers and libs$env:PYTHON_INCLUDES = &quot;$pyarm64\Include&quot;$env:PYTHON_LIBS = &quot;$pyarm64\libs&quot;# If necessary, specify an alternate C++ toolset$env:PLATFORMTOOLSET = &quot;Intel C++ Compiler 19.1&quot;```## CythonCython support is available from the `pymsbuild.cython` module.```pythonfrom pymsbuild import PydFile, ItemDefinitionfrom pymsbuild.cython import CythonIncludeFile, CythonPydFile, PyxFilePACKAGE = CythonPydFile(    &quot;cython_module&quot;,    ItemDefinition(&quot;PyxCompile&quot;, IncludeDirs=PYD_INCLUDES),    CythonIncludeFile(&quot;mod.pxd&quot;),    PyxFile(&quot;mod.pyx&quot;),)```The `CythonPydFile` type derives from the regular `PydFile` and alsogenerates a C++ project, so all options that would be available there mayalso be used.The `PyxCompile.IncludeDirs` metadata specifies search paths for Cythonheaders (`*.pxd`). You may also need to specify`ClCompile.AdditionalIncludeDirectories` for any C/C++ headers.## Two-Step BuildsBy default, the `sdist` and `wheel` commands will perform the entireprocess in a single invocation. However, sometimes there are build stepsthat must be manually performed between compilation and packaging.To run the build in two stages, invoke as normal, but add the`--layout-dir` argument followed by a directory. The package will belaid out in this directory so that you can perform any extra processing.Later, use the `pack` command and specify the `--layout-dir` again. Ifyou have added new files into the layout directory, specify each with an`--add` option (filenames starting with `@` are treated asnewline-separated, UTF-8 encoded text files listing each new file). Thesepaths may be absolute or relative to the layout directory, but only fileslocated within the layout directory will be included.All other options are retained from the original invocation.```python -m pymsbuild sdist --layout-dir tmp# Generate additional metadata in tmp/EXTRA.txtpython -m pymsbuild pack --layout-dir tmp --add tmp/EXTRA.txt```# Experimental Features## DLL Packing**Experimental. Windows only.**DLL Packing is a way to compile a complete Python package (`.py` sourceand resource files) into a Windows DLL. It is fundamentally equivalentto packing in a ZIP file, except that additional native code may also beincluded (though not an entire native module), and the whole file may becryptographically signed and validated by the operating system.`DllPackage` is a drop-in substitute for the `Package` type.```pythonfrom pymsbuild import *from pymsbuild.dllpack import *PACKAGE = DllPackage(    &quot;packed_package&quot;,    PyFile(&quot;__init__.py&quot;),    File(&quot;data.txt&quot;),    ...)````DllPackage` is a subclass of `PydFile`, and so all logic or elementsby that type are also available. `ClCompile` elements will be compiledand linked into the output and functions may be exposed in the root ofthe package using the `Function` element.```c// extra.cPyObject *my_func(PyObject *, PyObject *args, PyObject **kwargs) {    ...}``````pythonPACKAGE = DllPackage(    &quot;packed_package&quot;,    PyFile(&quot;__init__.py&quot;),    CSourceFile(&quot;extra.c&quot;),    CFunction(&quot;my_func&quot;),    ...)```## Cross-platform builds**Experimental.**With the [.NET SDK](https://dotnet.microsoft.com/download) installed,`pymsbuild` is able to run builds on platforms other than Windows.The `dotnet` command must be available on `PATH` or specified as the`MSBUILD` environment variable.In general, no platform-specific modifications to a build script arerequired. Cython and pyd builds are transparently mapped to the targetsystem. To run build-time actions for specific platforms, add them to`init_PACKAGE` and check the tag argument to determine the targetplatform.When building native components on POSIX, a `python3-config` script isneeded to determine compilation options. By default, only the locationadjacent to the running interpreter is checked. This may be overriddenby setting the `PYTHON_CONFIG` variable to the preferred command.</longdescription>
</pkgmetadata>