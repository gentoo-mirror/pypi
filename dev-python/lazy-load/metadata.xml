<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>ℒazy-ℒoad=========.. image:: https://img.shields.io/pypi/v/lazy_load.svg    :target: https://pypi.python.org/pypi/lazy_load    :alt: Latest PyPI version.. image:: https://travis-ci.org/kutoga/lazy-load.png   :target: https://travis-ci.org/kutoga/lazy-load   :alt: Latest Travis CI build statusA minimalistic interface that allows lazy evaluation of expressions and function calls.Note: This small library is heavily based on `python-lazy-object-proxy`.Why using ℒazy-ℒoad? Lazy loading in general may make some software implementations much more efficient.Especially if it is not known if some data has to be loaded or not. Often the resulting code is less efficient,because eager loading is used or the code is not elegant, because one has to program (somehow) lazy loading.Advantages of this library are that lazy-loading may be used quite elegant and effective.Examples^^^^^^^^In a loop it might happen that a special condition appears once or even more often. If this is the case,an expensive function `expensive_function` is called and on the resulting object an operation hasto be done. If the expensive function had to called more than once, than the result object may be reused.Possible implementation:.. code:: python    def expensive_function():        print(&quot;function evaluation&quot;)        ...        return result    obj = None    for x, y, p in get_coordinates():        if test_for_something(x, y, p):            if obj is None:                obj = expensive_function()            obj.do_something(x, y)Given this library, it might be done like this:.. code:: python    from lazy_load import lazy    def expensive_function():        print(&quot;function evaluation&quot;)        ...        return result    obj = lazy(expensive_function)    for x, y, p in get_coordinates():        if test_for_something(x, y, p):            obj.do_something(x, y)There are similar situations outside of loops. The implementation without `lazy-load` might look like this:.. code:: python    def expensive_function():        print(&quot;function evaluation&quot;)        ...        return result    obj = None    def get_obj():        global obj        if obj is None:            obj = expensive_function()        return obj    if condition_a:        get_obj().xyz()    if condition_b:        do_something()    if condition_c:        get_obj().abc()This code can be realized much easier with `lazy-load`. Not only is the code shorter, but it is also more readable:.. code:: python    from lazy_load import lazy    def expensive_function():        print(&quot;function evaluation&quot;)        ...        return result    obj = lazy(expensive_function)    if condition_a:        obj.xyz()    if condition_b:        do_something()    if condition_c:        obj.abc()It might be the case that the expensive function is used more often and always a lazy evaluation is done.In this case, a decorator might be used to indicate that all function calls to this function shall be lazilyevaluated. This makes it possible to normally use the function. The behaviour is still the same like in the first example:.. code:: python    from lazy_load import lazy_func    @lazy_func    def expensive_function():        print(&quot;function evaluation&quot;)        ...        return result    obj = expensive_function()    for x, y, p in get_coordinates():        if test_for_something(x, y, p):            obj.do_something(x, y)A lazy evaluation of functions / methods calls might be done with the `@lazy_func` decorator of with the `lazy`-call. This was alreadyshown, therefore the following examples show how to do a one-shot lazy evaluation of a function call:.. code:: python    from lazy_load import lazy, lz    def expensive_func(x, y):        print(f&quot;function evaluation with arguments x={x}, y={y}&quot;)        ...        return result    # Possibility 1: Use `lazy` with a callable    obj = lazy(lambda: expensive_func(a, b))    # Possibility 2: If it doesn't matter if the argument expressions for the expensive-function are eager evaluated, the call may be simplified:    obj = lazy(expensive_func, a, b)    # Possibility 3: `lazy` has a short version / alias: `lz`    obj = lz(expensive_func, a, b)Python allows it to pass functions around: This is often used for callbacks, but also for other use cases.Assuming an expensive function is passed to an object which calls this function and stores the result ofthe function call in an attribute. Later it might happen that this attribute is used. Depending on theprogram flow it also might happen that this attribute is not used. With a lazily evaluated function theexpensive function call is only executed if the result is really used. The lazily evaluated version ofa function has the exact same signature as the original function.One might now like to have the possibility to on-the-fly convert a callable to a lazily evaluated callable.This might be done in the following way:.. code:: python    from lazy_load import lazy_func, lf    def expensive_func(x):        print(f&quot;function evaluation with argument x={x}&quot;)        ...        return result    # Possibility 1: Use `lazy_func`.    my_obj.do_something(f=lazy_func(expensive_func))    # Possibility 2: Use `lf` which is an alias of `lazy_func`    my_obj.do_something(f=lf(expensive_func))    # Possibility 3: Use the `ℒ`-&quot;operator&quot;    my_obj.do_something(f=ℒ[expensive_func])Actually, I want to go deeper into the `ℒ`azy- or `ℒ`-&quot;operator&quot;. This operator converts on-the-fly a functionto a lazily evaluated function. Another example:.. code:: python    from lazy_load import ℒ    def test(name):        print(f&quot;hey {name}&quot;)        return True    res = test(&quot;peter&quot;)    # prints &quot;hey peter&quot;    test_l = ℒ[test]    res = test_l(&quot;hans&quot;)    # prints nothing    if res:        print(&quot;res is True&quot;)    # prints &quot;hey hans\nres is True&quot;It is also possible to convert multiple functions to lazily evaluated functions using `ℒ`:.. code:: python    from lazy_load import ℒ    def f1(x):        print(f&quot;f1 {x}&quot;)        return True    def f2(x):        print(f&quot;f1 {x}&quot;)        return True    f1_l, f2_l, f3_l = ℒ[f1, f2, lambda x: x == 1]    # This is equal to:    f1_l = ℒ[f1]    f2_l = ℒ[f2]    f3_l = ℒ[lambda x: x == 1]Finally, one might like to decorate a class in a way that all its public methods which have a returnvalue are lazily evaluated. Public methods are all methods that have a name not starting with `_`.Methods with a return value are identificated by the given return type hint which must not be `None`.This behaviour might be done with the `@lazy_class`-decorator (alias: `lc`):.. code:: python    from lazy_load import lazy_class    @lazy_class    class MyClass:        def __init__(self):            # Method name starts with &quot;_&quot; =&gt; is not public; therefore it is eager evaluated            pass        def setX(x) -&gt; None:            # Method does not return a value =&gt; therefore it is eager evaluated            ...        def do():            # Method does not hav a return value type hint =&gt;  therefore it is eager evaluated            ...        def compute() -&gt; int:            # Method will always be lazily evaluated            ...            return resultFinally, it is also possible to force the evaluation of a lazy loading object by using `force_eval` (alias `fe`).This function can safely to used to non-lazy loading objects: It is then just equal to the identity function... code:: python    from lazy_load import lazy, force_eval    def f1(x):        print(f&quot;f1 {x}&quot;)        return True    lazy_obj = lazy(f1, 1)    # The following expression prints &quot;f1 1&quot; and returns &quot;True&quot;    force_eval(lazy_obj)The `force_eval` function may also be applied to lazy-functions (which are created with `lazy_func(x)`, `@lazy_func`or with `ℒ`). This restores the original non-lazy / eager function. For non-lazy functions this call has no effect:.. code:: python    from lazy_load import lazy_func, force_eval    @lazy_func    def f(x):        print(&quot;hey&quot;)        return x**2    # The following line prints nothing    obj = f(2)    f_eager = force_eval(f)    # The following line prints &quot;hey&quot; and &quot;obj&quot; has immediatly the value &quot;4&quot;    obj = f_eager(2)Installation------------`pip install lazy-load`Requirements^^^^^^^^^^^^Python 3.6 or Python 3.7.Licence-------MITAuthors-------`lazy_load` was written by `Benjamin Bruno Meier &lt;benjamin.meier70@gmail.com&gt;`_.</longdescription>
</pkgmetadata>