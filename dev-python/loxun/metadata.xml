<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>loxun is a Python module to write large output in XML using Unicode andnamespaces. Of course you can also use it for small XML output with plain 8bit strings and no namespaces.loxun's features are:* **small memory foot print**: the document is created on the fly by writing to  an output stream, no need to keep all of it in memory.* **easy to use namespaces**: simply add a namespace and refer to it using the  standard ``namespace:tag`` syntax.* **mix unicode and io.BytesIO**: pass both unicode or plain 8 bit strings to any  of the methods. Internally loxun converts them to unicode, so once a  parameter got accepted by the API you can rely on it not causing any  messy ``UnicodeError`` trouble.* **automatic escaping**: no need to manually handle special characters such  as ``&lt;`` or ``&amp;`` when writing text and attribute values.* **robustness**: while you write the document, sanity checks are performed on  everything you do. Many silly mistakes immediately result in an  ``XmlError``, for example missing end elements or references to undeclared  namespaces.* **open source**: distributed under the GNU Lesser General Public License 3  or later.Here is a very basic example. First you have to create an output stream. Inmany cases this would be a file, but for the sake of simplicity we use a``io.BytesIO`` here:    &gt;&gt;&gt; from __future__ import unicode_literals    &gt;&gt;&gt; import io    &gt;&gt;&gt; out = io.BytesIO()Then you can create an `XmlWriter` to write to this output:    &gt;&gt;&gt; xml = XmlWriter(out)Now write the content:    &gt;&gt;&gt; xml.addNamespace(&quot;xhtml&quot;, &quot;http://www.w3.org/1999/xhtml&quot;)    &gt;&gt;&gt; xml.startTag(&quot;xhtml:html&quot;)    &gt;&gt;&gt; xml.startTag(&quot;xhtml:body&quot;)    &gt;&gt;&gt; xml.text(&quot;Hello world!&quot;)    &gt;&gt;&gt; xml.tag(&quot;xhtml:img&quot;, {&quot;src&quot;: &quot;smile.png&quot;, &quot;alt&quot;: &quot;:-)&quot;})    &gt;&gt;&gt; xml.endTag()    &gt;&gt;&gt; xml.endTag()    &gt;&gt;&gt; xml.close()And the result is:    &gt;&gt;&gt; print out.getvalue().rstrip(&quot;\r\n&quot;)    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    &lt;xhtml:html xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&gt;      &lt;xhtml:body&gt;        Hello world!        &lt;xhtml:img alt=&quot;:-)&quot; src=&quot;smile.png&quot; /&gt;      &lt;/xhtml:body&gt;    &lt;/xhtml:html&gt;Writing a simple document=========================The following example creates a very simple XHTML document.To make it simple, the output goes to a ``BytesIO``, but you could also usea binary file that has been created using ``io.open(filename, &quot;wb&quot;)``.    &gt;&gt;&gt; from __future__ import unicode_literals    &gt;&gt;&gt; import io    &gt;&gt;&gt; out = io.BytesIO()First create an `XmlWriter` to write the XML code to the specified output:    &gt;&gt;&gt; xml = XmlWriter(out)This automatically adds the XML prolog:    &gt;&gt;&gt; print out.getvalue().rstrip(&quot;\r\n&quot;)    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;Next add the ``&lt;html&gt;`` start tag:    &gt;&gt;&gt; xml.startTag(&quot;html&quot;)Now comes the &lt;body&gt;. To pass attributes, specify them in a dictionary.So in order to add::    &lt;body id=&quot;top&quot;&gt;use:    &gt;&gt;&gt; xml.startTag(&quot;body&quot;, {&quot;id&quot;: &quot;top&quot;})Let' add a little text so there is something to look at:    &gt;&gt;&gt; xml.text(&quot;Hello world!&quot;)Wrap it up: close all elements and the document.    &gt;&gt;&gt; xml.endTag()    &gt;&gt;&gt; xml.endTag()    &gt;&gt;&gt; xml.close()And this is what we get:    &gt;&gt;&gt; print out.getvalue().rstrip(&quot;\r\n&quot;)    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    &lt;html&gt;      &lt;body id=&quot;top&quot;&gt;        Hello world!      &lt;/body&gt;    &lt;/html&gt;Specifying attributesFirst create a writer:    &gt;&gt;&gt; import io    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out)Now write the content:    &gt;&gt;&gt; xml.tag(&quot;img&quot;, {&quot;src&quot;: &quot;smile.png&quot;, &quot;alt&quot;: &quot;:-)&quot;})Attribute values do not have to be strings, other types will be converted toUnicode using Python's ``unicode()`` function:    &gt;&gt;&gt; xml.tag(&quot;img&quot;, {&quot;src&quot;: &quot;wink.png&quot;, &quot;alt&quot;: &quot;;-)&quot;, &quot;width&quot;: 32, &quot;height&quot;: 24})And the result is:    &gt;&gt;&gt; print out.getvalue().rstrip(&quot;\r\n&quot;)    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    &lt;img alt=&quot;:-)&quot; src=&quot;smile.png&quot; /&gt;    &lt;img alt=&quot;;-)&quot; height=&quot;24&quot; src=&quot;wink.png&quot; width=&quot;32&quot; /&gt;Using namespaces================Now the same thing but with a namespace. First create the prologand header like above:    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out)Next add the namespace:    &gt;&gt;&gt; xml.addNamespace(&quot;xhtml&quot;, &quot;http://www.w3.org/1999/xhtml&quot;)Now elements can use qualified tag names using a colon (:) to separatenamespace and tag name:    &gt;&gt;&gt; xml.startTag(&quot;xhtml:html&quot;)    &gt;&gt;&gt; xml.startTag(&quot;xhtml:body&quot;)    &gt;&gt;&gt; xml.text(&quot;Hello world!&quot;)    &gt;&gt;&gt; xml.endTag()    &gt;&gt;&gt; xml.endTag()    &gt;&gt;&gt; xml.close()As a result, tag names are now prefixed with &quot;xhtml:&quot;:    &gt;&gt;&gt; print out.getvalue().rstrip(&quot;\r\n&quot;)    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    &lt;xhtml:html xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&gt;      &lt;xhtml:body&gt;        Hello world!      &lt;/xhtml:body&gt;    &lt;/xhtml:html&gt;Working with non ASCII characters=================================Sometimes you want to use characters outside the ASCII range, for exampleGerman Umlauts, the Euro symbol or Japanese Kanji. The easiest and performancewise best way is to use Unicode strings. For example:    &gt;&gt;&gt; import io    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out, prolog=False)    &gt;&gt;&gt; xml.text(u&quot;The price is \u20ac 100&quot;) # Unicode of Euro symbol    &gt;&gt;&gt; out.getvalue().rstrip(&quot;\r\n&quot;)    'The price is \xe2\x82\xac 100'Notice the &quot;u&quot; before the string passed to `XmlWriter.text()`, it declares thestring to be a unicode string that can hold any character, even those that arebeyond the 8 bit range.Also notice that in the output the Euro symbol looks very different from theinput. This is because the output encoding is UTF-8 (the default), whichhas the advantage of keeping all ASCII characters the same and turning anycharacters with a code of 128 or more into a sequence of 8 bit bytes thatcan easily fit into an output stream to a binary file or ``io.BytesIO``.If you have to stick to classic 8 bit string parameters, loxun attempts toconvert them to unicode. By default it assumes ASCII encoding, which doesnot work out as soon as you use a character outside the ASCII range:    &gt;&gt;&gt; import io    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out, prolog=False)    &gt;&gt;&gt; xml.text(&quot;The price is \xa4 100&quot;) # ISO-8859-15 code of Euro symbol    Traceback (most recent call last):        ...    UnicodeDecodeError: 'ascii' codec can't decode byte 0xa4 in position 13: ordinal not in range(128)In this case you have to tell the writer the encoding you use by specifyingthe the ``sourceEncoding``:    &gt;&gt;&gt; import io    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out, prolog=False, sourceEncoding=&quot;iso-8859-15&quot;)Now everything works out again:    &gt;&gt;&gt; xml.text(&quot;The price is \xa4 100&quot;) # ISO-8859-15 code of Euro symbol    &gt;&gt;&gt; out.getvalue().rstrip(&quot;\r\n&quot;)    'The price is \xe2\x82\xac 100'Of course in practice you will not mess around with hex codes to pass yourtexts. Instead you just specify the source encoding using the mechanismsdescribed in PEP 263,`Defining Python Source Code Encodings &lt;http://www.python.org/dev/peps/pep-0263/&gt;`_.Pretty printing and indentation===============================By default, loxun starts a new line for each ``startTag`` and indents thecontent with two spaces. You can change the spaces to any number of spaces andtabs you like:    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out, indent=&quot;    &quot;) # &lt;-- Indent with 4 spaces.    &gt;&gt;&gt; xml.startTag(&quot;html&quot;)    &gt;&gt;&gt; xml.startTag(&quot;body&quot;)    &gt;&gt;&gt; xml.text(&quot;Hello world!&quot;)    &gt;&gt;&gt; xml.endTag()    &gt;&gt;&gt; xml.endTag()    &gt;&gt;&gt; xml.close()    &gt;&gt;&gt; print out.getvalue().rstrip(&quot;\r\n&quot;)    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    &lt;html&gt;        &lt;body&gt;            Hello world!        &lt;/body&gt;    &lt;/html&gt;You can disable pretty printing all together using ``pretty=False``, resultingin an output of a single large line:    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out, pretty=False) # &lt;-- Disable pretty printing.    &gt;&gt;&gt; xml.startTag(&quot;html&quot;)    &gt;&gt;&gt; xml.startTag(&quot;body&quot;)    &gt;&gt;&gt; xml.text(&quot;Hello world!&quot;)    &gt;&gt;&gt; xml.endTag()    &gt;&gt;&gt; xml.endTag()    &gt;&gt;&gt; xml.close()    &gt;&gt;&gt; print out.getvalue().rstrip(&quot;\r\n&quot;)    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;html&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/html&gt;Changing the XML prolog=======================When you create a writer, it automatically write an XML prologprocessing instruction to the output. This is what the default prologlooks like:    &gt;&gt;&gt; import io    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out)    &gt;&gt;&gt; print out.getvalue().rstrip(&quot;\r\n&quot;)    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;You can change the version or encoding:    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out, encoding=u&quot;ascii&quot;, version=u&quot;1.1&quot;)    &gt;&gt;&gt; print out.getvalue().rstrip(&quot;\r\n&quot;)    &lt;?xml version=&quot;1.1&quot; encoding=&quot;ascii&quot;?&gt;To completely omit the prolog, set the parameter ``prolog=False``:    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out, prolog=False)    &gt;&gt;&gt; out.getvalue()    ''Adding other content====================Apart from text and tags, XML provides a few more things you can add todocuments. Here's an example that shows how to do it with loxun.First, create a writer:    &gt;&gt;&gt; import io    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out)Let's add a document type definition:    &gt;&gt;&gt; xml.raw(&quot;&lt;!DOCTYPE html PUBLIC \&quot;-//W3C//DTD XHTML 1.0 Strict//EN\&quot; SYSTEM \&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\&quot;&gt;&quot;)    &gt;&gt;&gt; xml.newline()Notice that loxun uses the generic `XmlWriter.raw()` for that, which allows toadd any content without validation or escaping. You can do all sorts of nastythings with ``raw()`` that will result in invalid XML, but this is one of itsreasonable uses.Next, let's add a comment:    &gt;&gt;&gt; xml.comment(&quot;Show case some rarely used XML constructs&quot;)Here is a processing instruction:    &gt;&gt;&gt; xml.processingInstruction(&quot;xml-stylesheet&quot;, &quot;href=\&quot;default.css\&quot; type=\&quot;text/css\&quot;&quot;)And finally a CDATA section:    &gt;&gt;&gt; xml.cdata(&quot;&gt;&gt; this will not be parsed &lt;&lt;&quot;)And the result is:    &gt;&gt;&gt; print out.getvalue().rstrip(&quot;\r\n&quot;)    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; SYSTEM &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;    &lt;!-- Show case some rarely used XML constructs --&gt;    &lt;?xml-stylesheet href=&quot;default.css&quot; type=&quot;text/css&quot;?&gt;    &lt;![CDATA[&gt;&gt; this will not be parsed &lt;&lt;]]&gt;Optimization============Loxun automatically optimized pairs of empty start/end tags. For example:    &gt;&gt;&gt; out = io.BytesIO()    &gt;&gt;&gt; xml = XmlWriter(out)    &gt;&gt;&gt; xml.startTag(&quot;customers&quot;)    &gt;&gt;&gt; xml.startTag(&quot;person&quot;, {&quot;id&quot;: &quot;12345&quot;, &quot;name&quot;: &quot;Doe, John&quot;})    &gt;&gt;&gt; xml.endTag(&quot;person&quot;) # without optimization, this would add &lt;/person&gt;.    &gt;&gt;&gt; xml.endTag()    &gt;&gt;&gt; xml.close()    &gt;&gt;&gt; print out.getvalue().rstrip(&quot;\r\n&quot;)    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    &lt;customers&gt;      &lt;person id=&quot;12345&quot; name=&quot;Doe, John&quot; /&gt;    &lt;/customers&gt;Despite the explicit ``startTag(&quot;person&quot;)`` and matching ``endtag()``, theoutput only contains a simple ``&lt;person ... /&gt;`` tag.Contributing------------If you want to help improve loxun, you can access the source code at&lt;http://github.com/roskakori/loxun&gt;.Future======Currently loxun does what it was built for.There are is no real plans to improve it in the near future, but here is a listof features that might be added at some point:* Add validation of tag and attribute names to ensure that all characters used  are allowed. For instance, currently loxun does not complain about a tag  named &quot;a#b*c$d_&quot;.* Raise an `XmlError` when namespaces are added with attributes instead of  `XmlWriter.addNamespace()`.* Logging support to simplify debugging of the calling code. Probably  `XmlWriter` would get a property ``logger`` which is a standard  ``logging.Logger``. By default it could log original exceptions that  loxun turns into an `XmlError` and namespaces opened and closed.  Changing it to ``logging.DEBUG`` would log each tag and XML construct  written, including additional information about the internal tag stack.  That way you could dynamically increase or decrease logging output.* Rethink pretty printing. Instead of a global property that can only be set  when initializing an `XmlWriter`, it could be a optional parameter for  `XmlWriter.startTag()` where it could be turned on and off as needed. And  the property could be named ``literal`` instead of ``pretty`` (with an  inverse logic).* Add a ``DomWriter`` that creates a ``xml.dom.minidom.Document``.Some features other XML libraries support but I never saw any real use for:* Specify attribute order for tags.Version history===============Version 2.0, 2014-07-28* Added support for Python 3.2+ while retaining the option to run with  Python 2.6+ (issue #5; thanks go to `Stefan Schwarzer`_ who offered his  guidance during a &quot;Python 2 to 3&quot; sprint at EuroPython 2014).* Dropped support for Python 2.5, keep using loxun 1.3 if you are stuck  with with this version... _Stefan Schwarzer: http://www.sschwarzer.netVersion 1.3, 2012-01-01* Added ``endTags()`` to close several or all open tags (issue #3,  contributed by Anton Kolechkin).* Added ``ChainXmlWriter`` which is similar to ``XmlWriter`` and allows to  chain methods for more concise source code (issue #3, contributed by Anton  Kolechkin).Version 1.2, 2011-03-12* Fixed ``AttributeError`` when ``XmlWriter(..., encoding=...)`` was set.Version 1.1, 08-Jan-2011* Fixed ``AssertionError`` when ``pretty`` was set to ``False``  (issue #1; fixed by David Cramer).Version 1.0, 11-Oct-2010* Added support for Python's ``with`` so you don not have to manually call  `XmlWriter.close()` anymore.* Added Git repository at &lt;http://github.com/roskakori/loxun&gt;.Version 0.8, 11-Jul-2010* Added possibility to pass attributes to `XmlWriter.startTag()` and  `XmlWriter.tag()` with values that have other types than ``str`` or  ``unicode``. When written to XML, the value is converted using Python's  built-in ``unicode()`` function.* Added a couple of files missing from the distribution, most important the  test suite.Version 0.7, 03-Jul-2010* Added optimization of matching start and end tag without any content in  between. For example, ``x.startTag(&quot;some&quot;); x.endTag()`` results in  ``&lt;some /&gt;`` instead of ``&lt;some&gt;&lt;/some&gt;``.* Fixed handling of unknown name spaces. They now raise an `XmlError` instead   of ``ValueError``.Version 0.6, 03-Jun-2010* Added option ``indent`` to specify the indentation text each new line starts with.* Added option ``newline`` to specify how lines written should end.* Fixed that `XmlWriter.tag()` did not remove namespaces declared immediately  before it.* Cleaned up documentation.Version 0.5, 25-May-2010* Fixed typo in namespace attribute name.* Fixed adding of namespaces before calls to `XmlWriter.tag()` which resulted  in an `XmlError`.Version 0.4, 21-May-2010* Added option ``sourceEncoding`` to simplify processing of classic strings.  The manual section &quot;Working with non ASCII characters&quot; explains how to use  it.Version 0.3, 17-May-2010* Added scoped namespaces which are removed automatically by  `XmlWriter.endTag()`.* Changed ``text()`` to normalize newlines and white space if pretty printing  is enabled.* Moved writing of XML prolog to the constructor and removed  ``XmlWriter.prolog()``. To omit the prolog, specify ``prolog=False`` when  creating the `XmlWriter`. If you later want to write the prolog yourself,  use `XmlWriter.processingInstruction()`.* Renamed ``*Element()`` to ``*Tag`` because they really only write tags, not  whole elements.Version 0.2, 16-May-2010* Added `XmlWriter.comment()`, `XmlWriter.cdata()` and  `XmlWriter.processingInstruction()` to write these specific XML constructs.* Added indentation and automatic newline to text if pretty printing is  enabled.* Removed newline from prolog in case pretty printing is disabled.* Fixed missing &quot;?&quot; in prolog.Version 0.1, 15-May-2010* Initial release.</longdescription>
</pkgmetadata>