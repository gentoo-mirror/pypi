<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># flask-siwadoc**flask-siwadoc**是一个兼具**数据校验**和openapi(swagger)**文档自动生成**的项目## 特性### 1、API接口自动生成文档只需要初始化一个`siwa=SiwaDoc(app)`,利用装饰器 `siwa.doc()`修饰flask视图函数，即可将该视图对应的路由加入openapi的paths中。### 2、支持多种参数指定可以将请求参数放置在 `query`、`path`、`header`、`cookie`、`body(json、formdata)`5种不同的地方，完全支持openapi规范所定义的5种参数方式。### 3、参数校验与自动转换基于`pydantic`，请求参数可自动转换为对应的数据类型### 4、ui切换flask-siwadoc内置了`swagger`（默认）、`redoc`、`rapidoc`等多种UI界面### 5、支持标签与分组### 6、可设置访问权限配置参数：* SIWA_USER：登录用户名* SIWA_PASSWORD: 登录密码只有同时设置了用户名和密码访问文档才需要登录权限，该场景用在正式环境中，防止接口文档被匿名访问## 安装```pip install flask-siwadoc```## 快速开始### example 1```pythonfrom flask import Flaskfrom flask_siwadoc import SiwaDocapp = Flask(__name__)siwa = SiwaDoc(app, title=&quot;siwadocapi&quot;, description=&quot;一个自动生成openapi文档的库&quot;)# 或者使用工厂模式# siwa = SiwaDoc(title=&quot;siwadocapi&quot;, description=&quot;一个自动生成openapi文档的库&quot;)# siwa.init_app(app)@app.route(&quot;/hello&quot;, methods=[&quot;GET&quot;])@siwa.doc()def hello():    return &quot;hello siwadoc&quot;if __name__ == '__main__':    app.run()```运行后，访问 [http://127.0.0.1:5000/docs](http://127.0.0.1:5000/docs) 就可以看到openapi文档页面![20220722101346.png](./screnshots/20220722101346.png)### example 2：指定 query 参数```pythonfrom pydantic import BaseModel, FieldUSERS = [    {&quot;username&quot;: &quot;siwa1&quot;, &quot;id&quot;: 1},    {&quot;username&quot;: &quot;siwa2&quot;, &quot;id&quot;: 2},    {&quot;username&quot;: &quot;siwa3&quot;, &quot;id&quot;: 3},]class QueryModel(BaseModel):    page: int = Field(default=1, title=&quot;current page number&quot;)    size: int = Field(default=20, title=&quot;size of page&quot;, ge=10, le=100)    keyword: str = None@app.route(&quot;/users&quot;, methods=[&quot;GET&quot;])@siwa.doc(query=QueryModel, tags=[&quot;user&quot;], group=&quot;user&quot;)def users_list(query: QueryModel):    &quot;&quot;&quot;    user list    &quot;&quot;&quot;    print(query.page)  # 1    return {&quot;data&quot;: USERS[:query.size]}```以查询参数方式接收数据时，例如：`/path?page=1&amp;size=10`1. 定义一个继承自`pydantic.BaseModel`的子类：`QueryModel`2. `@siwa.doc(query=QueryModel)` ：`doc`装饰器中接收名为`query`的对象，用于在文档中展示参数列表3. `users_list(query: QueryModel)` 视图函数中定义名字为`query`的参数，主要是方便开发者直接通过`query`对象获取参数值![20220722100939.png](./screnshots/20220722100939.png)### example3: 指定 header 参数```pythonclass TokenModel(BaseModel):    token: str@app.route(&quot;/me&quot;, methods=[&quot;GET&quot;])@siwa.doc(header=TokenModel, tags=['auth'], group='admin')def param_in_header():    token = request.headers.get(&quot;token&quot;)    print(&quot;token:&quot;, token)    return {&quot;token&quot;: token}```header中的参数可直接通过 `request.headers.get` 获取![20220722102652.png](./screnshots/20220722102652.png)### example4:指定 cookie 参数```pythonclass CookieModel(BaseModel):    foo: str@app.route(&quot;/cookie&quot;, methods=[&quot;GET&quot;])@siwa.doc(cookie=CookieModel, tags=['auth'], group='admin')def param_in_cookie():    foo = request.cookies.get(&quot;foo&quot;)    print(&quot;foo:&quot;, foo)    return {&quot;foo&quot;: foo}```![](./screnshots/20220722103100.png)### example5 :指定请求 body以请求body接收数据时，例如：```shellcurl -X 'POST' \  'http://127.0.0.1:5000/user/login' \  -H 'accept: */*' \  -H 'Content-Type: application/json' \  -d '{  &quot;password&quot;: &quot;string&quot;,  &quot;username&quot;: &quot;string&quot;}'``````pythonclass LoginModel(BaseModel):    username: str    password: str@app.route(&quot;/user/login&quot;, methods=[&quot;POST&quot;])@siwa.doc(body=LoginModel, tags=['auth'])def user_login(body: LoginModel):    return {        &quot;username&quot;: body.username,        &quot;password&quot;: body.password,        &quot;id&quot;: 1}```1. 定义一个继承自`pydantic.BaseModel`的子类：`LoginModel`2. `@siwa.doc(body=LoginModel)` ：`doc`装饰器中接收名为`body`的对象，用于在文档中展示参数列表3. `users_list(body: LoginModel)` 视图函数中定义名字为`body`的参数，方便开发者直接通过`body`对象获取参数值![20220722104304.png](./screnshots/20220722104304.png)### example6: 使用formdata请求example5中使用`json`作为请求体，当请求文件等复杂数据类型时，需要使用`formdata`#### 情形一：没有文件等复杂数据类型时，例如```pythonclass UserModel(BaseModel):    id: int    username: str@app.post('/form')@siwa.doc(form=UserModel)def test_form(form: UserModel):    print(form.id)    print(form.username)    return form.username```1. 定义一个继承自`pydantic.BaseModel`的子类：`UserModel`2. `@siwa.doc(form=UserModel)` ：`doc`装饰器中接收名为`form`的对象，用于在文档中展示参数列表3. `test_form(form: UserModel)` 视图函数中定义名字为`form`的参数，方便开发者直接通过`form`对象获取参数值![20230310094000.png](./screnshots/20230310094000.png)#### 情形二：请求体中包含基础数据类型数据，也包含文件对象参数时，例如：```python@app.post('/form_with_files')@siwa.doc(form=UserModel, files={'file1': {&quot;required&quot;: True, &quot;single&quot;: False}, 'file2': {&quot;required&quot;: False, &quot;single&quot;: True}})def test_form_with_files(form: UserModel, files: dict):    print(form.id)    print(form.username)    print(files.keys())    return form.username```1. 定义一个继承自`pydantic.BaseModel`的子类：`UserModel`2. `@siwa.doc(form=UserModel, files={'file1': {&quot;required&quot;: True, &quot;single&quot;: False}, 'file2': {&quot;required&quot;: False, &quot;single&quot;: True}})` ：`doc`装饰器中接收名为`form`的对象、名为`files`的字典。`form`对象用于在文档中展示参数列表，`files`字典用于定义文件参数列表以及文件参数配置（`required`配置此文件参数是否必传，默认`False`；`single`配置此文件参数接收单文件还是文件列表，默认`True`）3. `test_form_with_files(form: UserModel, files: dict)` 视图函数中定义名字为`form`的参数，方便开发者直接通过`form`对象获取基本数据类型的参数值; `files`字典用于获取文件对象![20230310094500.png](./screnshots/20230310094500.png)#### 情形三：请求体中只包含文件对象参数时，例如：```python@app.post('/form_only_files')@siwa.doc(form=BaseModel, files={'file1': {&quot;required&quot;: True, &quot;single&quot;: False}, 'file2': {&quot;required&quot;: False, &quot;single&quot;: True}})def test_form_only_files(files: dict):    print(files.keys())    return 'success'```1. `@siwa.doc(form=BaseModel, files={'file1': {&quot;required&quot;: True, &quot;single&quot;: False}, 'file2': {&quot;required&quot;: False, &quot;single&quot;: True}})` ：`doc`装饰器中接收名为`form`的对象、名为`files`的字典。`form`对象指定为基类`BaseModel`，`files`同情形二2. `test_form_only_files(files: dict)` 视图函数中定义名字`files`的字典，用于获取文件对象![20230310094400.png](./screnshots/20230310094400.png)### example7: 指定返回体 responses需要告诉客户端接口返回的字段时，指定参数`resp````pythonclass UserModel(BaseModel):    id: int    username: str@app.route(&quot;/users&quot;, methods=[&quot;GET&quot;])@siwa.doc(query=QueryModel, resp=UserModel)def users_list(query: QueryModel):    &quot;&quot;&quot;    user list    &quot;&quot;&quot;    return {&quot;data&quot;: USERS[:query.size]}```1. 定义一个继承自`pydantic.BaseModel`的子类：`UserModel`2. `@siwa.doc(resp=UserModel)` ：`doc`装饰器中接收名为`resp`的对象，用于在文档中展示返回的字段列表![20220722110623.png](./screnshots/20220722110623.png)### example8: 指定标签分类 tags项目中如果接口太多，我们可以对接口根据业务划分不同的模块标签来分类管理。```python@siwa.doc(resp=UserModel, tags=[&quot;user&quot;])```指定`tags`参数，tags参数是一个列表，一个接口可支持多个标签。### example9: 指定分组  group除了可以指定标签外，我们还可以指定分组```python@app.route(&quot;/admin/login&quot;, methods=[&quot;POST&quot;])@siwa.doc(body=LoginModel, resp=UserModel, tags=['auth'], group='admin')def admin_login(body: LoginModel):    return {&quot;username&quot;: body.username, &quot;id&quot;: 1}```完整示例可参考 [example.py](./example/__init__.py)### UI切换文档默认使用`swagger`进行渲染，你可以在路径上指定参数`?ui=swagger`切换成 `swagger` 渲染文档。```pythonhttp://127.0.0.1:5000/docs/?ui=swagger```![20220604203420.png](./screnshots/20220604203420.png)### 扩展数据校验报错时，flask-siwadoc 会抛出异常`flask_siwadoc.error.ValidationError`，ValidationError 继承自`pydantic.ValidationError`例如：```pythonclass QueryModel(BaseModel):    keyword: str@app.route(&quot;/users&quot;, methods=[&quot;GET&quot;])@siwa.doc(query=QueryModel, tags=[&quot;user&quot;])def hello(query: QueryModel):    print(query)    return &quot;hello&quot;```该接口中，keyword是必选的查询参数，如果url中没有keyword参数，就会抛出异常```raise ValidationError(e)flask_siwadoc.error.ValidationError: 2 validation errors for Auth    usernamefield required (type=value_error.missing)passwordfield required (type=value_error.missing)```使用flask的 `errorhandler()` 装饰函数来注册`ValidationError`错误，这样错误异常就可以被`validate_error`函数捕获，开发者可以给前端直接一个友好的错误响应体```python@app.errorhandler(ValidationError)def validate_error(e: ValidationError):    return dict(code=-1, msg=&quot;请求参数错误&quot;, error_info=e.errors()), 400```![20220604214851.png](./screnshots/20220604214851.png)reference1. https://pydantic-docs.helpmanual.io/2. https://github.com/tiangolo/fastapi3. https://github.com/bauerji/flask-pydantic4. https://github.com/kemingy/flaskerk任何问题欢迎发issue或者加我微信 lzjun567 交流，欢迎PR， 如果对你有帮助或者给你的工作带来了极大的便利，可考虑赞赏作者![赞赏](./screnshots/6802366f4419fd9db9fb3c730f873d2.jpg)</longdescription>
</pkgmetadata>