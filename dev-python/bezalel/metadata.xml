<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># bezalelA library for ingesting data provided by paginated HTTP APIs# Usage## Basic use caseIf you have to pull data from HTTP API that has an endpoint accepting parameters:```pageNumber=1,2,...```And returning JSON:```json{    &quot;pageCount&quot;: 5,    &quot;entities&quot;: [      {&quot;key&quot;:  &quot;val1&quot;, ...},      {&quot;key&quot;:  &quot;val2&quot;, ...},      ...    ]}```Then you can iterate over all pages with following code:```pythonimport requestsfrom bezalel import PaginatedApiIteratorfor page in PaginatedApiIterator(requests.Session(), url=f&quot;http://localhost:5000/page-api&quot;,                                     request_page_number_param_name=&quot;pageNumber&quot;,                                     response_page_count_field_name=&quot;pageCount&quot;,                                     response_records_field_name=&quot;entities&quot;):    print(f&quot;Page: {page}&quot;)```It will print:```Page: [{&quot;key&quot;:  &quot;val1&quot;, ...}, {&quot;key&quot;:  &quot;val2&quot;, ...}, ...]Page: [{&quot;key&quot;:  &quot;val100&quot;, ...}, {&quot;key&quot;:  &quot;val101&quot;, ...}, ...]Page: [{&quot;key&quot;:  &quot;val200&quot;, ...}, {&quot;key&quot;:  &quot;val201&quot;, ...}, ...]...```## Grouping with `BufferingIterator`If HTTP API doesn't allow you setting high number of records per page, use `BufferingIterator`.```pythonimport requestsfrom bezalel import PaginatedApiIterator, BufferingIteratorfor page in BufferingIterator(PaginatedApiIterator(requests.Session(), url=f&quot;http://localhost:5000/page-api&quot;,                                                       request_page_number_param_name=&quot;pageNumber&quot;,                                                       response_page_count_field_name=&quot;pageCount&quot;,                                                       response_records_field_name=&quot;entities&quot;), buffer_size=2):    print(f&quot;Page: {page}&quot;)```It will combine multiple pages into one array, so that ```Page: [{&quot;key&quot;:  &quot;val1&quot;, ...}, {&quot;key&quot;:  &quot;val2&quot;, ...}, ..., {&quot;key&quot;:  &quot;val100&quot;, ...}, {&quot;key&quot;:  &quot;val101&quot;, ...}, ...]Page: [{&quot;key&quot;:  &quot;val200&quot;, ...}, {&quot;key&quot;:  &quot;val201&quot;, ...}, ..., {&quot;key&quot;:  &quot;val300&quot;, ...}, {&quot;key&quot;:  &quot;val301&quot;, ...}, ...]...```This is useful for fetching many records and storing them in fewer files (every file would be bigger). ## Iterating over all recordsTODO: this API will be improved in future release.```pythonimport itertoolsimport requestsfrom bezalel import PaginatedApiIteratorall_elems = list(itertools.chain.from_iterable(PaginatedApiIterator(requests.Session(), url=f&quot;https://your/api&quot;,                                                   request_page_number_param_name=&quot;pageNumber&quot;,                                                   response_page_count_field_name=&quot;pageCount&quot;,                                                   response_records_field_name=&quot;entities&quot;))):print(f&quot;len={len(all_elems)}: {all_elems}&quot;)```will print```len=12300: [{&quot;key&quot;:  &quot;val1&quot;, ...}, {&quot;key&quot;:  &quot;val2&quot;, ...}, ...]```## Helper function: `normalize_with_prototype()`Normalize python dict, so that it has all the fields and only the fields specified in a prototype dict.```pythonfrom bezalel import normalize_with_prototypeobject_from_api = {    &quot;id&quot;: 123,    &quot;name:&quot;: &quot;John&quot;,    &quot;country&quot;: &quot;Poland&quot;,    &quot;customDict&quot;: {        &quot;some&quot;: 123,        &quot;complex&quot;: 345,        &quot;structure&quot;: 546    },    # city is not provided here (but present in prototype)    &quot;pets&quot;: [        {&quot;id&quot;: 101, &quot;type&quot;: &quot;dog&quot;, &quot;name&quot;: &quot;Barky&quot;},        {&quot;id&quot;: 102, &quot;type&quot;: &quot;snail&quot;},   # name is not provided here (but present in prototype)    ],    &quot;unspecifiedField&quot;: 123     # this field is not present in prototype below}prototype_from_swagger = {    &quot;id&quot;: 0,    &quot;name:&quot;: &quot;&quot;,    &quot;country&quot;: &quot;&quot;,    &quot;customDict&quot;: {},    &quot;city&quot;: &quot;&quot;,    &quot;pets&quot;: [        {&quot;id&quot;: 0, &quot;type&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;},    ]}result = normalize_with_prototype(prototype_from_swagger, object_from_api, pass_through_paths=[&quot;.customDict&quot;])# pass_through_paths is optional and it marks an object as something that should not be normalized```would return```pythonresult = {    &quot;id&quot;: 123,    &quot;name:&quot;: &quot;John&quot;,    &quot;country&quot;: &quot;Poland&quot;,    &quot;customDict&quot;: {        &quot;some&quot;: 123,        &quot;complex&quot;: 345,        &quot;structure&quot;: 546    },    &quot;city&quot;: None,   # city was added    &quot;pets&quot;: [        {&quot;id&quot;: 101, &quot;type&quot;: &quot;dog&quot;, &quot;name&quot;: &quot;Barky&quot;},        {&quot;id&quot;: 102, &quot;type&quot;: &quot;snail&quot;, &quot;name&quot;: None}, # name was added    ]}```## Helper function: `normalize_dicts()`Normalize list of nested python dicts to a list of one-level dicts.Example:```pythonfrom bezalel import normalize_dictsdata = [    {        &quot;id&quot;: 1, &quot;name&quot;: &quot;John Smith&quot;,        &quot;pets&quot;: [            {&quot;id&quot;: 101, &quot;type&quot;: &quot;cat&quot;, &quot;name&quot;: &quot;Kitty&quot;, &quot;toys&quot;: [{&quot;name&quot;: &quot;toy1&quot;}, {&quot;name&quot;: &quot;toy2&quot;}]},            {&quot;id&quot;: 102, &quot;type&quot;: &quot;dog&quot;, &quot;name&quot;: &quot;Barky&quot;, &quot;toys&quot;: [{&quot;name&quot;: &quot;toy3&quot;}]}        ]    },    {        &quot;id&quot;: 2, &quot;name&quot;: &quot;Sue Smith&quot;,        &quot;pets&quot;: [            {&quot;id&quot;: 201, &quot;type&quot;: &quot;cat&quot;, &quot;name&quot;: &quot;Kitten&quot;, &quot;toys&quot;: [{&quot;name&quot;: &quot;toy4&quot;}, {&quot;name&quot;: &quot;toy5&quot;}, {&quot;name&quot;: &quot;toy6&quot;}]},            {&quot;id&quot;: 202, &quot;type&quot;: &quot;dog&quot;, &quot;name&quot;: &quot;Fury&quot;, &quot;toys&quot;: []}        ]    },]normalize_dicts(data, [&quot;pets&quot;, &quot;toys&quot;])```would return:```python[{'id': 1, 'name': 'John Smith', 'pets.id': 101, 'pets.type': 'cat', 'pets.name': 'Kitty', 'pets.toys.name': 'toy1'}, {'id': 1, 'name': 'John Smith', 'pets.id': 101, 'pets.type': 'cat', 'pets.name': 'Kitty', 'pets.toys.name': 'toy2'}, {'id': 1, 'name': 'John Smith', 'pets.id': 102, 'pets.type': 'dog', 'pets.name': 'Barky', 'pets.toys.name': 'toy3'}, {'id': 2, 'name': 'Sue Smith', 'pets.id': 201, 'pets.type': 'cat', 'pets.name': 'Kitten', 'pets.toys.name': 'toy4'}, {'id': 2, 'name': 'Sue Smith', 'pets.id': 201, 'pets.type': 'cat', 'pets.name': 'Kitten', 'pets.toys.name': 'toy5'}, {'id': 2, 'name': 'Sue Smith', 'pets.id': 201, 'pets.type': 'cat', 'pets.name': 'Kitten', 'pets.toys.name': 'toy6'}, {'id': 2, 'name': 'Sue Smith', 'pets.id': 202, 'pets.type': 'dog', 'pets.name': 'Fury'}]```Presence of the last record can be controlled by flag `return_incomplete_records`. If `return_incomplete_records=False`then last record in the example would not have been returned.Additional options:- jsonify_lists - when set to True, then if a list is encountered (not in main path), it is dumped as a JSON string.- jsonify_dicts - list of paths for where to expect a dict. That dict will be then dumped as a JSON string.</longdescription>
</pkgmetadata>