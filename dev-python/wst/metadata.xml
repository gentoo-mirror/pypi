<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Workspace tool`ws` is a lightweight tool for managing a collection of code repositories. It isintended to handle coarse dependencies between projects, building multipleprojects in the right order and passing the correct flags to each (such as`PKG_CONFIG_PATH` and similar). It is not intended to be a full-fledged buildsystem, but instead should merely build each project in the right order and withthe right environment glue. Everything it does can be done by-hand, so ratherthan a replacing existing build tools, it merely automates the tedious task ofmanually specifying `--prefix`, setting env vars, and rebuilding projects in theright order when they change.Inside each workspace, projects are installed inside a localized `install`directory so that no installations ever leak out of a workspace. Projectsdependent on other projects automatically link to the other projects' installdirectories by setting `PKG_CONFIG_PATH`, `LD_LIBRARY_PATH`, and everything elsenecessary.Note that `ws` does not directly handle source code syncing. That job is left to[repo](https://code.google.com/archive/p/git-repo/) and similar tools.## Dependencies`ws` depends on the Python 3 PyYAML, which you can get either with `sudo aptinstall python3-yaml` or via `pip3 install -r requirements.txt` from the top ofthe repository.## InstallingTo install `ws`, you can use the `setup.py` script at the top level of therepository: `python3 setup.py install &lt;add any custom options here&gt;`. You canalso use pip: `pip3 install .` from the top of the repository. Finally, if youwant the installed `ws` to directly symlink into your source directory insteadof being a one-time copy of the code, use `pip3 install -e .`, which activatespip &quot;developer mode&quot;. This way, code changes immediately take effect withoutre-running the install step.## wsThe `ws` script is the main point of interaction with your workspaces. Itassumes you have already synced a bunch of code using `repo` or some other tooland, unless you use special options, it assumes you are currently somewhereinside the root of the source that `ws` manages. However, you can be anywhereinside that tree and do not have to be at the top of it.The normal workflow for `ws` is as follows:```repo init -u MANIFEST-REPO-URLrepo syncws init -s repows build```By default, `ws init` will look for a file called `ws-manifest.yaml` at the rootof the repository containing the `git-repo` manifest (the one we passed `-u`into when we called `repo init`). This file contains dependency and build systeminformation for the projects that `ws` manages. Note that `ws` does not have tomanage all the same projects that `repo` manages, but it can. The full formatfor `ws-manifest.yaml` is at the bottom of the README.If you don't use the `git-repo` tool, you can instead pass in your own wsmanifest via `ws init -s fs -m`. This lets you manage the manifest however youlike (e.g. submodules, or manually).## bash-completionIf you like bash-completions and typing things fast, you can do:```. bash-completion/ws```And get auto-completion for ws commands.### ws initWhen you run `ws init`, ws creates a `.ws` directory in the current workingdirectory. This directory can contain multiple workspaces, but there is alwaysa default workspace, which is the one that gets used if you don't specify analternate workspace with the `-w` option. One reason to create multipleworkspaces is to manage multiple build configurations, such as separate debugand release builds. However, all workspaces in the same `.ws` directory willstill operate on the same source code (the repositories configured in`ws-manifest.yaml`).If you wish to create multiple workspaces, you can use `ws init` with anargument to do so. For example, `ws init new` would create a new workspacecalled `new`. However, it would not be used by default until you run `wsdefault new`. That said, you can also use `-w` to operate on it (e.g. `ws -wnew build`).If you specify `-m`, you can manually point to a `ws-manifest.yaml` to use. Bydefault, this is relative to a repository containing a git-repo manifest (e.g.if you have a `.repo` directory after running `repo init`, then it is relativeto `.repo/manifests`). If you specify `-s fs`, then it can pointanywhere on the filesystem instead.### ws default`ws default` is used to change the default workspace (the one used when youdon't specify a `-w` option).### ws build`ws build` is the main command you run. If you specify no arguments, it willbuild every project that repo knows about. If you instead specify a project orlist of projects, it will build only those, plus any dependencies of them.Additionally, `ws` will checksum the source code on a per-repo basis and avoidrebuilding anything that hasn't changed. The checksumming logic uses git forspeed and reliability, so source managed by `ws` has to use git.### ws clean`ws clean` cleans the specified projects, or all projects if no argumentsare given. By default, it just runs the clean command for the underlying buildsystem (meson, cmake, etc.). If you also use the `-f/--force` switch, it willinstead remove the entire build directory instead of trusting the underlyingbuild system.### ws env`ws env` allows you to enter the build environment for a given project. If givenno arguments, it gives you an interactive shell inside the build directory forthe project. If given arguments, it instead runs the specified command from thatdirectory. In both cases, it sets up the right build enviroment so buildcommands you might use will work correctly and you can inspect if somethingseems wrong.An example use of `ws env` is to manually build something or to tweak the buildconfiguration of a given project in a way that `ws` doesn't know how to handle.### ws test`ws test` allows you to run unit tests on a project that you built. The testsare configured in the `ws` manifest  file and can be any set of arbitrarycommands. The tests will be run from the build directory of the project as ifyou had run `ws env -b PROJECT TEST`.The `cwd` paremeter to the tests allows tests to run in an alternate directorythat the build directory. Any of the template variables listed below can be usedfor this.### ws config`ws config` sets either workspace-wide or per-project configuration settings.The following settings are supported:Workspace-wide settings:- `type`: `debug` or `release`. This specifies the workspace build type.Per-project settings:- `enable`: sets whether or not to build the given project. Typically you want to  build everything, but you might satisfy a particular dependency from the  distro, or manually build and install it outside of the workspace.- `args`: sets build arguments for a particular project, which get directly passed  to the builder (e.g. `cmake` or `meson`). An example would be passing `-D  KEY=VAL` to set a preprocessor variable.## ws manifestThe `ws` manifest is a YAML file specifying a few things about the projects `ws`manages:- What build system they use (currently supports `meson`, `cmake`, and  `setuptools`).- What dependencies they have on other projects managed by `ws`.- Any special environment variables they need.- Any special builder options needed (e.g. `-DCMAKE_` type of options). These  options are passed straight through into each build system without  modification.- Any other manifests that should be included. Include paths can be absolute or  relative. If they are relative, they are interpreted relative to the parent  directory of the including manifest. Directories can also be included, in  which case every manifest file in the directory file is included.- Any search paths to search for manifests listed in &quot;include&quot;. Can be either  absolute or relative. If relative, it's relative to the parent directory of  this manifest.The syntax is as follows:```include:    - some-other-manifest.yaml    - some-directory-of-manifestssearch-path:    - ../projects # a directory containing manifestsprojects:    some-project:        build: meson        deps:            - gstreamer            - ...        targets:            - docs            - install        env:            GST_PLUGIN_PATH: ${LIBDIR}/gstreamer-1.0        tests:            - some test command here            - some other test command here            - cwd: ${SRCDIR}              cmds:                  - these commands                  - will be run from the source directory                  - instead of the build directory    gstreamer:        build: meson        args:            - -D gtk_doc=disabled```In this case, `some-project` builds with `meson`, and requires `gstreamer` andsome other dependencies. In order to find gstreamer plugins, it needs`GST_PLUGIN_PATH` set. It uses template syntax to refer to `${LIBDIR}`, which willbe filled in with the library path for the project.Here is the complete list of usable template variables:```- ${BUILDDIR}: the project build directory- ${SRCDIR}: the project source directory (top of the project's git repository)- ${LIBDIR}: the library path for the project (what `LD_LIBRARY_PATH` will be  set to for the project's build environment.- ${PREFIX}: the project's prefix (what you would pass to `--prefix`).```</longdescription>
</pkgmetadata>