<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># RQLAlchemy[![Build Status](https://travis-ci.org/pjwerneck/rqlalchemy.svg?branch=develop)](https://travis-ci.org/pjwerneck/rqlalchemy)Resource Query Language extension for SQLAlchemy## OverviewResource Query Language (RQL) is a query language designed for use in URIs, with object-style data structures.rqlalchemy is an RQL extension for SQLAlchemy. It easily allows exposing SQLAlchemy tables or models as an HTTP API endpoint and performing complex queries using only querystring parameters.## Installing```pip install rqlalchemy```## UsageRQL queries can be supported by an application using SQLAlchemy by adding the `rqlalchemy.RQLQueryMixIn` class as a mix-in class to your base `Query` class:```pythonfrom sqlalchemy import sessionmakerfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import Query as BaseQueryfrom rqlalchemy import RQLQueryMixIn# create the declarative baseBase = declarative_base()# create the custom query classclass RQLQuery(BaseQuery, RQLQueryMixIn):    _rql_default_limit = 10    _rql_max_limit = 100# pass the custom query class as a keyworkd argument to the sessionmakersession = sessionmaker(bind=engine, query_cls=RQLQuery)```If you're using Flask-SQLAlchemy, you can pass it as a session option:```from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy(session_options={&quot;query_cls&quot;: RQLQuery})```With that in place, you can perform RQL queries by passing the querystring to the query `rql()` method. For example, if you have a Flask HTTP API with an users collection endpoint querying your `User` model:```pythonfrom urllib.parse import unquotefrom flask import request@app.route('/users')def get_users_collection():    qs = unquote(request.query_string.decode(request.charset))    query = session.query(User).rql(qs)    users = query.rql_all()    return render_response(users)```### AggregatesAs with the base SQLAlchemy Query class, you can retrieve results with the `all()` method, or by iterating over the query, however, if you want to support RQL expressions with aggregate functions or querying functions that result in a subset of columns, you must retrieve the results with `rql_all()`.### PaginationRQLAlchemy offers limit/offset pagination with the `rql_paginate()` method, which returns the requested page, the RQL expressions for previous and next pages if available, and the total number of items.```pythonfrom urllib.parse import unquotefrom flask import request@app.route('/users')def get_users_collection():    qs = unquote(request.query_string.decode(request.charset))    query = session.query(User).rql(qs)    page, previous_page, next_page, total = query.rql_paginate()    response = {&quot;data&quot;: page,                &quot;total&quot;: total,               }    if previous_page:        response[&quot;previous&quot;] = '/users?' + previous_page    if next_page:        response[&quot;next&quot;] = '/users?' + next_page    return render_response(response)```Keep in mind that pagination requires a limit, either a `_rql_default_limit` value, a querystring `limit(x)`, or the `limit` parameter to the `rql()` method. Calling `rql_paginate()` without a limit will raise `RQLQueryError`.## Reference Table| RQL                     | SQLAlchemy                                         | Obs.                                                                                                                            ||-------------------------|----------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|| QUERYING                |                                                    |                                                                                                                                 || select(a,b,c,...)       | .query(Model.a, Model.b, Model.c,...)              |                                                                                                                                 || values(a)               | [o.a for o in query.from_self(a)]                  |                                                                                                                                 || limit(count,start?)     | .limit(count).offset(start)                        |                                                                                                                                 || sort(attr1)             | .order_by(attr)                                    |                                                                                                                                 || sort(-attr1)            | .order_by(attr.desc())                             |                                                                                                                                 || distinct()              | .distinct()                                        |                                                                                                                                 || first()                 | .limit(1)                                          |                                                                                                                                 || one()                   | [query.one()]                                      |                                                                                                                                 || FILTERING               |                                                    |                                                                                                                                 || eq(attr,value)          | .filter(Model.attr == value)                       |                                                                                                                                 || ne(attr,value)          | .filter(Model.attr != value)                       |                                                                                                                                 || lt(attr,value)          | .filter(Model.attr &lt; value)                        |                                                                                                                                 || le(attr,value)          | .filter(Model.attr &lt;= value)                       |                                                                                                                                 || gt(attr,value)          | .filter(Model.attr &gt; value)                        |                                                                                                                                 || ge(attr,value)          | .filter(Model.attr &gt;= value)                       |                                                                                                                                 || in(attr,value)          | .filter(Model.attr.in_(value)                      |                                                                                                                                 || out(attr,value)         | .filter(not_(Model.attr.in_(value)))               |                                                                                                                                 || contains(attr,value)    | .filter(Model.contains(value))                     | Produces a LIKE expression when filtering against a string, or an IN expression when filtering against an iterable relationship || excludes(attr,value)    | .filter(not_(Model.contains(value)))               | See above.                                                                                                                      || and(expr1,expr2,...)    | .filter(and_(expr1, expr2, ...))                   |                                                                                                                                 || or(expr1,expr2,...)     | .filter(or_(expr1, expr2, ...))                    |                                                                                                                                 || AGGREGATING             |                                                    | All aggregation functions return scalar results.                                                                                || aggregate(a,b\(c\),...) | .query(Model.a, func.b(Model.c)).group_by(Model.a) |                                                                                                                                 || sum(attr)               | .query(func.sum(Model.attr))                       |                                                                                                                                 || mean(attr)              | .query(func.avg(Model.attr))                       |                                                                                                                                 || max(attr)               | .query(func.max(Model.attr))                       |                                                                                                                                 || min(attr)               | .query(func.min(Model.attr))                       |                                                                                                                                 || count()                 | .query(func.count())                               |                                                                                                                                 |</longdescription>
</pkgmetadata>