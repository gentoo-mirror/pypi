<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://raw.githubusercontent.com/rajivsarvepalli/mock-alchemy/master/docs/_static/alchemy.svg&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rajivsarvepalli/mock-alchemy/master/docs/_static/alchemy.svg&quot; alt=&quot;alchemy bottle icon&quot; height=&quot;60&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;h1 align=&quot;center&quot;&gt;mock-alchemy&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;Simple and intuitive SQLAlchemy mock helpers.&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://mock-alchemy.readthedocs.io/en/latest/?badge=latest&quot;&gt;&lt;img src=&quot;https://readthedocs.org/projects/mock-alchemy/badge/?version=latest&quot;/&gt;&lt;/a&gt;    &lt;a href=&quot;https://pypi.org/project/mock-alchemy/&quot;&gt;&lt;img src=&quot;https://img.shields.io/pypi/v/mock-alchemy.svg&quot;/&gt;&lt;/a&gt;    &lt;a href=&quot;https://github.com/rajivsarvepalli/mock-alchemy/actions?workflow=Tests&quot;&gt;&lt;img src=&quot;https://github.com/rajivsarvepalli/mock-alchemy/workflows/Tests/badge.svg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://codecov.io/gh/rajivsarvepalli/mock-alchemy&quot;&gt;&lt;img src=&quot;https://codecov.io/gh/rajivsarvepalli/mock-alchemy/branch/master/graph/badge.svg&quot;/&gt;&lt;/a&gt;    &lt;a href=&quot;https://pypi.org/project/mock-alchemy/&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/rajivsarvepalli/mock-alchemy/master/imgs/python_versions.svg&quot;/&gt;&lt;/a&gt;        &lt;a href=&quot;https://pepy.tech/project/mock-alchemy&quot;&gt;&lt;img src=&quot;https://pepy.tech/badge/mock-alchemy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;## ðŸ¤– Mocking SQLAlchemySQLAlchemy is awesome.Unittests are great.Accessing DB during tests -not so much. This library provides an easy way to mock SQLAlchemy'ssession in unittests while preserving the ability to do sane asserts.- Free software: MIT license- GitHub: &lt;https://github.com/rajivsarvepalli/mock-alchemy&gt;## ðŸ“š DocumentationFull documentation is available at &lt;http://mock-alchemy.rtfd.io/&gt;. Onthe documentation, you should be able to select a version of your choicein order to view documentation of an older version if need be.This README includes some basic examples, but more detailed examples areincluded in the documentation, especially in the [user guide][]. If youare looking for an API reference, it is also available on the[documentation][].## ðŸ“¦ InstallingYou can install `mock-alchemy` using pip:    $ pip install mock-alchemyIf you want to use this package on Python 2.7 or Python 3.6, theninstall `mock-alchemy` using:    $ pip install &quot;mock-alchemy&gt;=0.1.0,&lt;0.2.0&quot;Pip should auto-detect the correct version but this ensures the correctversion is downloaded for your needs.[user guide]: https://mock-alchemy.readthedocs.io/en/latest/user_guide/[documentation]: https://mock-alchemy.readthedocs.io/en/latest/api_reference/mock_alchemy.mocking.html# ðŸ”– VersioningThere are several different versions of `mock-alchemy` availabledepending on your needs. The versions `0.1.x` are available for use onPython 2.7, Python 3.6+. The newer versions serve users who are onPython 3.7+. For people interested in contributing, if you want to workon Python 2.7 version checkout the branch &lt;spanclass=&quot;title-ref&quot;&gt;0.1.x&lt;/span&gt; and then create pull-requests to thatbranch. There is a set of specific tests run for that branch on pushesand pull-requests since there are different tests for the newer versionsof `mock-alchemy`. Check out [contributor guide][] for more information.Documentation for the 0.1.0 version is [available][]. However, thecurrent documentation should do a sufficient job at illustrating boththe past and the features of the present version at least as of now.Therefore, I suggest using the most recent documentation for now, and ifyou want, you can switch using the readthedocs version system (click onthe drop-down menu on the bottom right of the screen on thedocumentation or go to the [project page][]).# ðŸ“¤ CreditThe original library (`alchemy-mock`) was created by MiroslavShubernetskiy and Serkan Hoscai. This is a forked version due to a lackof updates in the original library. It appeared that the `alchemy-mock`project was no longer supported. Therefore, since I desired to add somebasic support for deleting, I created my own version of the library.Full credit goes to the original creators for starting and building thisproject. You can find the original package on [PyPi][] and [Github][].[contributor guide]: http://mock-alchemy.rtfd.io/en/latest/contributor_guide[available]: https://mock-alchemy.readthedocs.io/en/v0.1.0/[project page]: https://readthedocs.org/projects/mock-alchemy/[pypi]: https://pypi.org/project/alchemy-mock/[github]: https://github.com/miki725/alchemy-mock# âš™ UsingNormally SQLAlchemy's expressions cannot be easily comparedas comparison on binary expression produces yet another binary expression:    &gt;&gt;&gt; type((Model.foo == 5) == (Model.bar == 5))    &lt;class 'sqlalchemy.sql.elements.BinaryExpression'&gt;But they can be compared with this library:    &gt;&gt;&gt; ExpressionMatcher(Model.foo == 5) == (Model.bar == 5)    False`ExpressionMatcher` can be directly used:    &gt;&gt;&gt; from mock_alchemy.comparison import ExpressionMatcher    &gt;&gt;&gt; ExpressionMatcher(Model.foo == 5) == (Model.foo == 5)    TrueAlternatively `AlchemyMagicMock` can be used to mock out SQLAlchemy session:    &gt;&gt;&gt; from mock_alchemy.mocking import AlchemyMagicMock    &gt;&gt;&gt; session = AlchemyMagicMock()    &gt;&gt;&gt; session.query(Model).filter(Model.foo == 5).all()    &gt;&gt;&gt; session.query.return_value.filter.assert_called_once_with(Model.foo == 5)In real world though session can be interacted with multiple times to query some data.In those cases `UnifiedAlchemyMagicMock` can be used which combines various calls for easier assertions:    &gt;&gt;&gt; from mock_alchemy.mocking import UnifiedAlchemyMagicMock    &gt;&gt;&gt; session = UnifiedAlchemyMagicMock()    &gt;&gt;&gt; m = session.query(Model)    &gt;&gt;&gt; q = m.filter(Model.foo == 5)    &gt;&gt;&gt; if condition:    ...     q = q.filter(Model.bar &gt; 10).all()    &gt;&gt;&gt; data1 = q.all()    &gt;&gt;&gt; data2 = m.filter(Model.note == 'hello world').all()    &gt;&gt;&gt; session.filter.assert_has_calls([    ...     mock.call(Model.foo == 5, Model.bar &gt; 10),    ...     mock.call(Model.note == 'hello world'),    ... ])Also real-data can be stubbed by criteria:    &gt;&gt;&gt; from mock_alchemy.mocking import UnifiedAlchemyMagicMock    &gt;&gt;&gt; session = UnifiedAlchemyMagicMock(data=[    ...     (    ...         [mock.call.query(Model),    ...          mock.call.filter(Model.foo == 5, Model.bar &gt; 10)],    ...         [Model(foo=5, bar=11)]    ...     ),    ...     (    ...         [mock.call.query(Model),    ...          mock.call.filter(Model.note == 'hello world')],    ...         [Model(note='hello world')]    ...     ),    ...     (    ...         [mock.call.query(AnotherModel),    ...          mock.call.filter(Model.foo == 5, Model.bar &gt; 10)],    ...         [AnotherModel(foo=5, bar=17)]    ...     ),    ... ])    &gt;&gt;&gt; session.query(Model).filter(Model.foo == 5).filter(Model.bar &gt; 10).all()    [Model(foo=5, bar=11)]    &gt;&gt;&gt; session.query(Model).filter(Model.note == 'hello world').all()    [Model(note='hello world')]    &gt;&gt;&gt; session.query(AnotherModel).filter(Model.foo == 5).filter(Model.bar &gt; 10).all()    [AnotherModel(foo=5, bar=17)]    &gt;&gt;&gt; session.query(AnotherModel).filter(Model.note == 'hello world').all()    []The `UnifiedAlchemyMagicMock` can partially fake session mutationssuch as `session.add(instance)`. For example:    &gt;&gt;&gt; session = UnifiedAlchemyMagicMock()    &gt;&gt;&gt; session.add(Model(pk=1, foo='bar'))    &gt;&gt;&gt; session.add(Model(pk=2, foo='baz'))    &gt;&gt;&gt; session.query(Model).all()    [Model(foo='bar'), Model(foo='baz')]    &gt;&gt;&gt; session.query(Model).get(1)    Model(foo='bar')    &gt;&gt;&gt; session.query(Model).get(2)    Model(foo='baz')Note that its partially correct since if added models are filtered on,session is unable to actually apply any filters so it returns everything:    &gt;&gt;&gt; session.query(Model).filter(Model.foo == 'bar').all()    [Model(foo='bar'), Model(foo='baz')]Finally, `UnifiedAlchemyMagicMock` can partially fake deleting. Anything that can beaccessed with `all` can also be deleted. For example:    &gt;&gt;&gt; s = UnifiedAlchemyMagicMock()    &gt;&gt;&gt; s.add(SomeClass(pk1=1, pk2=1))    &gt;&gt;&gt; s.add_all([SomeClass(pk1=2, pk2=2)])    &gt;&gt;&gt; s.query(SomeClass).all()    [1, 2]    &gt;&gt;&gt; s.query(SomeClass).delete()    2    &gt;&gt;&gt; s.query(SomeClass).all()    []Note the limitation for dynamic sessions remains the same. Additionally, the delete will not be propagated acrossqueries (only unified in the exact same query). As in, if there are multiple queries in which the 'same'object is present, this library considers them separate objects. For example:    &gt;&gt;&gt; s = UnifiedAlchemyMagicMock(data=[    ...     (    ...         [mock.call.query('foo'),    ...          mock.call.filter(c == 'one', c == 'two')],    ...         [SomeClass(pk1=1, pk2=1), SomeClass(pk1=2, pk2=2)]    ...     ),    ...     (    ...         [mock.call.query('foo'),    ...          mock.call.filter(c == 'one', c == 'two'),    ...          mock.call.order_by(c)],    ...         [SomeClass(pk1=2, pk2=2), SomeClass(pk1=1, pk2=1)]    ...     ),    ...     (    ...         [mock.call.filter(c == 'three')],    ...         [SomeClass(pk1=3, pk2=3)]    ...     ),    ...     (    ...         [mock.call.query('foo'),    ...          mock.call.filter(c == 'one', c == 'two', c == 'three')],    ...         [SomeClass(pk1=1, pk2=1), SomeClass(pk1=2, pk2=2), SomeClass(pk1=3, pk2=3)]    ...     ),    ... ])    &gt;&gt;&gt; s.query('foo').filter(c == 'three').delete()    1    &gt;&gt;&gt; s.query('foo').filter(c == 'three').all()    []    &gt;&gt;&gt; s.query('foo').filter(c == 'one').filter(c == 'two').filter(c == 'three').all()    [1, 2, 3]The item referred to by `c == 'three'` is still present in the filtered query despite the individual item being deleted.# ðŸ‘· ContributingContributions are welcome. To learn more, see the [Contributor Guide][].# ðŸ“• LicenseDistributed under the terms of the [MIT][] license, _mock-alchemy_ isfree and open source software.# ðŸ’¥ IssuesIf you encounter any issues or problems, please [file an issue][] alongwith a detailed description.[contributor guide]: https://mock-alchemy.readthedocs.io/en/latest/contributor_guide/[mit]: http://opensource.org/licenses/MIT[file an issue]: https://github.com/rajivsarvepalli/mock-alchemy/issues</longdescription>
</pkgmetadata>