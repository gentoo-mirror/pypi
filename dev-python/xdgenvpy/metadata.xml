<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># xdgenvpy[![pipeline](https://gitlab.com/deliberist/xdgenvpy/badges/msin/pipeline.svg)](https://gitlab.com/deliberist/xdgenvpy/pipelines)[![Build status](https://ci.appveyor.com/api/projects/status/7r48ku66l9a995jw?svg=true)](https://ci.appveyor.com/project/rbprogrammer/xdgenvpy-uuvxv)[![codecov](https://codecov.io/gl/deliberist/xdgenvpy/branch/main/graph/badge.svg)](https://codecov.io/gl/deliberist/xdgenvpy)[![pypi](https://img.shields.io/pypi/v/xdgenvpy.svg)](https://pypi.org/project/xdgenvpy)`xdgenvpy` is yet another Python utility for the[XDG Base Directory Specification](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html),but one that provides Pythonic access as well as a CLI utility.  `xdgenvpy`adheres to the XDG Base Directory spec on Unix systems, and also providessimilar for Windows-based systems.## How to use### PythonThere are three main ways to use xdgenvpy as a Python package,1. Retrieve XDG environment variables, or the specification defaults.1. Determine _package_ specific directories based on the XDG spec.1. Or pedantically create _package_ specific directories before attempting to    use the directory.To use xdgenvpy as a simple XDG base directory getter, simply create a new`xdgenvpy.XDG` object and use the properties it exposes.```pythonfrom xdgenvpy import XDGxdg = XDG()print(xdg.XDG_DATA_HOME)        # /home/user/.local/shareprint(xdg.XDG_CONFIG_HOME)      # /home/user/.configprint(xdg.XDG_CACHE_HOME)       # /home/user/.cacheprint(xdg.XDG_RUNTIME_DIR)      # /run/user/1000print(xdg.XDG_DATA_DIRS)        # /home/user/.local/share:/usr/local/share/:/usr/share/print(xdg.XDG_CONFIG_DIRS)      # /home/user/.config:/etc/xdg```But sometimes you want to use package specific directories derived from the XDGbase directories.  This can be done with the `xdgenvpy.XDGPackage` class.```pythonfrom xdgenvpy import XDGPackagexdg = XDGPackage('mypackage')print(xdg.XDG_DATA_HOME)        # /home/user/.local/share/mypackageprint(xdg.XDG_CONFIG_HOME)      # /home/user/.config/mypackageprint(xdg.XDG_CACHE_HOME)       # /home/user/.cache/mypackageprint(xdg.XDG_RUNTIME_DIR)      # /run/user/1000/mypackageprint(xdg.XDG_DATA_DIRS)        # /home/user/.local/share/mypackage:/usr/local/share/:/usr/share/print(xdg.XDG_CONFIG_DIRS)      # /home/user/.config/mypackage:/etc/xdg')```Lastly, you could also use `xdgenvpy.XDGPedanticPackage` to ensure each of thepackage specific directories exist before the calling code attempts to use thedirectory.  Instances of the `xdgenvpy.XDGPedanticPackage` class will not createsystem level directories, only package directories on the DATA, CONFIG, CACHE,and RUNTIME variables.```pythonfrom xdgenvpy import XDGPedanticPackagexdg = XDGPedanticPackage('mypackage')print(xdg.XDG_DATA_HOME)        # /home/user/.local/share/mypackageprint(xdg.XDG_CONFIG_HOME)      # /home/user/.config/mypackageprint(xdg.XDG_CACHE_HOME)       # /home/user/.cache/mypackageprint(xdg.XDG_RUNTIME_DIR)      # /run/user/1000/mypackageprint(xdg.XDG_DATA_DIRS)        # /home/user/.local/share/mypackage:/usr/local/share/:/usr/share/print(xdg.XDG_CONFIG_DIRS)      # /home/user/.config/mypackage:/etc/xdg```### CLIxdgenvpy also includes a runnable module, which is easily accessible via thescript `xdg-env`.  Pip will normally install scripts under something like:`~/.local/bin`The installed `xdg-env` command essentially takes a list of XDG variables, andan optional package name.  For each XDG variable specified, `xdg-env` willprint its corresponding value based on the specification.  It can optionallytake the name of a package and include that into the variable's values.But can't we just `echo` the XDG variables like so?```bashecho ${XDG_DATA_HOME}echo ${XDG_CONFIG_HOME}echo ${XDG_CACHE_HOME}echo ${XDG_RUNTIME_DIR}echo ${XDG_DATA_DIRS}echo ${XDG_CONFIG_DIRS}```Well, yes.  But there is a problem when the variables are not defined.  The`xdg-env` command will *always* print a value that adheres to the spec.  If theenvironment variable does not exist, then the default value will be returned, asdefined by the[XDG Base Directory Specification](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html).Although the Python package supports a _pedantic_ mode, the `xdg-env` commandwill not change the file system.  Even if a package name is supplied and thedirectories do not exist, `xdg-env` will not create any files/directories.  Thiswas simply a design decision to keep the shell command as file-system safe aspossible.## How to installInstall locally as a normal user:```bashpip3 install --user xdgenvpy```Or install globally as the all powerful root:```bashsudo pip3 install xdgenvpy```## A Word About WindowsThe[XDG Base Directory Specification](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html).does not mention how the spec should be implemented on Windows-based platforms.That said, many applications on Windows still follow a very similar conventionto the XDG base directory spec.  And that is to generally place config filesunder `%APPDATA%/MyPackage/configs`.If we squint, it kind of looks like we can simply replace the POSIX tilde `~`with the Windows `%APPDATA%` variable.  Then there's a directory that is theapplication's name.  And finally, any configs or data files the applicationneeds to save is under that directory.Generally, xdgenvpy works in this way on Windows-based platforms.  Though thisis not a perfect solution as Windows applications can put configs and data filesunder any of the directories `Local`, `LocalLow`, and `Roaming` (where the`Roaming` directory typically is pointed to by `%APPDATA%`).  Additionally, someXDG variables do not make much sense on Windows-based platforms.`XDG_RUNTIME_DIR` is one such example.  On Unix systems it defaults to`/run/user/USERID`.  There is no close equivalent to a Windows-based directory.As such, xdgenvpy does not do anything fancy other than prepend `%APPDATA%` tomost directories and drop any `.` prefixes for hidden directories/files.That said, if you use xdgenvpy extensively on Windows platforms and would likebetter support, create GitLab issues on the project or submit Merge Requests.Let's all make xdgenvpy as useful as possible, even if it needs to implement XDGbase directory spec-like features on non-Unix platforms.</longdescription>
</pkgmetadata>