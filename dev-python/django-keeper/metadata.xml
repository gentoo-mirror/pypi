<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># django-keeperAuthorization library for Django, not depends on models.* Won't depend on models* Won't depend on datastores* Won't depend on Django's permission system* Won't depend on Django's User modelSupported versions:* Python3.8* Python 3.9* Django 2.2* Django 3.0* Django 3.1* Django 3.2* Django 4.1* Django 4.2## Install```bash$ pip install django-keeper```And add to INSTALLED_APPS```pythonINSTALLED_APPS = [    ...    'keeper',]```## At A GlanceDeclarative permission mapping for models.```pythonfrom django.conf import settingsfrom keeper.security import Allowfrom keeper.operators import Everyone, Authenticated, IsUserclass Issue(models.Model):    author = models.ForeignKey(settings.AUTH_USER_MODEL)    ...    def __acl__(self):        return [            (Allow, Everyone, 'view'),            (Allow, Authenticated, 'add_comment'),            (Allow, IsUser(self.author), 'edit'),        ]```Instances of model allow:* Every requests to view* Autheticated requests to add comments* it's author to editThen, apply `@keeper` for views.```pythonfrom keeper.views import keeper# Model Permissions@keeper(    'view',    model=Issue,    mapper=lambda request, issue_id: {'id': issue_id},)def issue_detail(request, issue_id):    &quot;&quot;&quot; View requires 'view' permission of Issue model    * An issue object will be retrieved    * keeper will check whether the rquests has 'view' permission for the issue    The third argument function can return keyword argument to retrieve the issue object.    &quot;&quot;&quot;    request.k_context  # Will be instance of the issue object    ...@keeper(    'add_comment',    model=Issue,    mapper=lambda request, issue_id: {'id': issue_id},)def add_comment(request, issue_id):    ...```## Global PermissionNot just for model permissions `django-keeper` can handle global permissions.First, write class having `__acl__` method in models.py.```pythonclass Root:    def __acl__(self):        return [            (Allow, Authenticated, 'view_dashboard'),            (Allow, Authenticated, 'add_issue'),        ]```It's not necessary to put it in `models.py`,but easy to understand.And specify it in settings.```pythonKEEPER_GLOBAL_CONTEXT = 'myapp.models.Root'```Then you can use global permission in views.Simply just apply `@keeper` and permission names.```python@keeper('add_issue')def issue_list(request):    &quot;&quot;&quot; View requires 'add_issue' permission of Root Context    &quot;&quot;&quot;```## OperatorsOperators is just `Callable[[HttpRequest], bool]`.By default django-keeper has these operators:* `keeper.operators.Everyone`* `keeper.operators.Authenticated`* `keeper.operators.IsUser`* `keeper.operators.Staff`Also you can create your own operators easily.```pythonfrom keeper.operators import Authenticated, Operatorclass IsIP(Operator):    def __init__(self, ip):        self.ip = ip    def __call__(self, request):        return request.META.get('REMOTE_ADDR') == self.ipclass BelongsTeam(Authenticated):    def __init__(self, team, role):        self.team = team    def __call__(self, request):        if not super().__call__(request):            return False        return  request.user.team == self.team```Use it in ACL```pythonclass Article(models.Model):    team = models.ForeignKey(Team)    def __acl__(self):        return [            (Allow, Everyone, 'view'),            (Allow, BelongsTeam(self.team), 'edit'),            (Allow, IsIP(settings.COMPANY_IP_ADDRESS), 'edit'),        ]```### Combining operatorsYou can use bitwise operators to combine multiple &quot;Operators&quot;.```pythonclass Article(models.Model):    def __acl__(self):        return [            (Allow, Authenticated() &amp; IsIP(settings.COMPANY_IP_ADDRESS), 'view'),        ]```There operators can be used* `a &amp; b`* `a | b`* `a ^ b`* `~a`## On Fail ActionsYou can change actions when requests can't pass ACLs.```pythonfrom keeper.views import keeper, login_required@keeper(    'view_articles',    on_fail=login_required(),)def dashboard(request):    ...```This view will behave just like `@login_required` decorator of Djangowhen requests don't have 'view' permission.Also you can use other actions.* `keeper.views.login_required`* `keeper.views.permission_denied`* `keeper.views.not_found`* `keeper.views.redirect`## Use in templateHandling permissions in templates is also supported.```django{% load keeper %}{% has_permission issue 'edit' as can_edit %}{% if can_edit %}    &lt;a href=&quot;...&quot;&gt;Edit&lt;/a&gt;{% endif %}```When checking global permission, use `has_global_permission`.```django{% load keeper %}{% has_global_permission 'add_issue' as can_add_issue %}{% if can_add_issue %}    &lt;a href=&quot;...&quot;&gt;New Issue&lt;/a&gt;{% endif %}```## With Django CoreAdd the authentication backend:```pythonAUTHENTICATION_BACKENDS = (    'keeper.permissions.ObjectPermissionBackend',    'django.contrib.auth.backends.ModelBackend',)```Now `User.has_perm` method will consider permissions of django-keeper.## Alternative* [django-guardian](https://github.com/django-guardian/django-guardian)    * It depends on databases    * Not way to handle global permissions, not just for a model* [django-rules](https://github.com/dfunckt/django-rules)    * Basiaclly, rules is used with Django's permissions, but keeper isn't (basiacally).    * rules doesn't support view decorators or mixins for it's &quot;rules&quot; system (for Django's permission, yes).## FAQ* Can I filter models by using ACL?    * Not supported</longdescription>
</pkgmetadata>