<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>aiorwlock=========.. image:: https://github.com/aio-libs/aiorwlock/workflows/CI/badge.svg   :target: https://github.com/aio-libs/aiorwlock/actions?query=workflow%3ACI.. image:: https://codecov.io/gh/aio-libs/aiorwlock/branch/master/graph/badge.svg   :target: https://codecov.io/gh/aio-libs/aiorwlock.. image:: https://badges.gitter.im/Join%20Chat.svg   :target: https://gitter.im/aio-libs/Lobby   :alt: Chat on GitterRead write lock for asyncio_ . A ``RWLock`` maintains a pair of associatedlocks, one for read-only operations and one for writing. The read lock may beheld simultaneously by multiple reader tasks, so long as there areno writers. The write lock is exclusive.Whether or not a read-write lock will improve performance over the use ofa mutual exclusion lock depends on the frequency that the data is *read*compared to being *modified*. For example, a collection that is initiallypopulated with data and thereafter infrequently modified, while beingfrequently searched is an ideal candidate for the use of a read-write lock.However, if updates become frequent then the data spends most of its timebeing exclusively locked and there is little, if any increase in concurrency.Implementation is almost direct port from this patch_.Example-------Requires Python 3.5.3+.. code:: python   import asyncio   import aiorwlock   async def go():       rwlock = aiorwlock.RWLock()       # acquire reader lock, multiple coroutines allowed to hold the lock       async with rwlock.reader_lock:           print('inside reader lock')           await asyncio.sleep(0.1)       # acquire writer lock, only one coroutine can hold the lock       async with rwlock.writer_lock:           print('inside writer lock')           await asyncio.sleep(0.1)   loop = asyncio.get_event_loop()   loop.run_until_complete(go())Fast path---------By default `RWLock` switches context on lock acquiring. That allows toother waiting tasks get the lock even if task that holds the lockdoesn't contain context switches (`await fut` statements).The default behavior can be switched off by `fast` argument:`RWLock(fast=True)`.Long story short:  lock is safe by  default, but if you  sure you havecontext switches (`await`,  `async with`, `async for`  or `yield from`statements) inside  locked code  you may want  to use  `fast=True` forminor speedup.TLA+ Specification------------------TLA+ specification of ``aiorwlock`` provided in this repository.License-------``aiorwlock`` is offered under the Apache 2 license... _asyncio: http://docs.python.org/3.8/library/asyncio.html.. _patch: http://bugs.python.org/issue8800Changes-------1.3.0 (2022-1-18)^^^^^^^^^^^^^^^^^^* Dropped Python 3.6 support* Python 3.10 is officially supported* Drop deprecated `loop` parameter from `RWLock` constructor1.2.0 (2021-11-09)^^^^^^^^^^^^^^^^^^* Fix a bug that makes concurrent writes possible under some (rare) conjunctions (#235)1.1.0 (2021-09-27)^^^^^^^^^^^^^^^^^^* Remove explicit loop usage in `asyncio.sleep()` call, make the library forward  compatible with Python 3.101.0.0 (2020-12-32)^^^^^^^^^^^^^^^^^^* Fix a bug with cancelation during acquire #170 (thanks @romasku)* Deprecate passing explicit `loop` argument to `RWLock` constructor* Deprecate creation of `RWLock` instance outside of async function context* Minimal supported version is Python 3.6* The library works with Python 3.8 and Python 3.9 seamlessly0.6.0 (2018-12-18)^^^^^^^^^^^^^^^^^^* Wake up all readers after writer releases lock #60 (thanks @ranyixu)* Fixed Python 3.7 compatibility* Removed old `yield from` syntax* Minimal supported version is Python 3.5.3* Removed support for none async context managers0.5.0 (2017-12-03)^^^^^^^^^^^^^^^^^^* Fix corner cases and deadlock when we upgrade lock from write to  read #39* Use loop.create_future instead asyncio.Future if possible0.4.0 (2015-09-20)^^^^^^^^^^^^^^^^^^* Support Python 3.5 and `async with` statement* rename `.reader_lock` -&gt; `.reader`, `.writer_lock` -&gt;  `.writer`. Backward compatibility is preserved.0.3.0 (2014-02-11)^^^^^^^^^^^^^^^^^^* Add `.locked` property0.2.0 (2014-02-09)^^^^^^^^^^^^^^^^^^* Make `.release()` non-coroutine0.1.0 (2014-12-22)^^^^^^^^^^^^^^^^^^* Initial release</longdescription>
</pkgmetadata>