<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Clinner[![Build Status](https://travis-ci.org/PeRDy/clinner.svg?branch=master)](https://travis-ci.org/PeRDy/clinner)[![codecov](https://codecov.io/gh/PeRDy/clinner/branch/master/graph/badge.svg)](https://codecov.io/gh/PeRDy/clinner)[![PyPI version](https://badge.fury.io/py/clinner.svg)](https://badge.fury.io/py/clinner)* **Version:** 1.12.3* **Status:** Production/Stable* **Author:** José Antonio Perdiguero LópezClinner is a library that provides some useful tools to create command line interfaces for your applicationCheck [Clinner docs].## FeaturesCan **define commands** in multiple way:* List of shell commands such as `[&quot;docker build&quot;, &quot;docker push&quot;]`.* Python functions.* Python async functions.Clinner provides a set of **commands ready to use** like:* Black.* Flake8.* Isort.* Nosetest.* Prospector.* Pytest.* Sphinx.* Tox.Hooks for **injecting variables** or **add global arguments** to your script.## Quick startInstall this package using pip:```bashpip install clinner```Create a command```pythonfrom clinner.command import command@commanddef foo(*args, **kwargs):    return True```Create a main file:```pythonfrom clinner.run.main import Mainif __name__ == '__main__':    sys.exit(Main().run())```## CommandsCommands are declared using a decorator to register given functions. Commands are functions with the follow parameters:1. `func`: Function that will be called when command would be executed.2. `command_type`: Type of the command, could be a *bash* or *python* command.3. `args`: Parser arguments for this command.4. `parser_opts`: Command subparser's keywords, such as description.This decorator allows to be used as a common decorator without arguments, where default type (*python*) will be used:```python@commanddef foobar(*args, **kwargs):    pass```Or specifying the type:```python@command(command_type=CommandType.PYTHON)def foobar(*args, **kwargs):    pass```But also is possible to provide command line arguments, as expected by argparse.ArgumentParser.add_argument:```python@command(args=((('-f', '--foo'), {'help': 'Foo argument that does nothing'}),                   # Command argument               (('--bar',), {'action': 'store_true', 'help': 'Bar argument stored as True'})),  # Another argument         parser_opts={'title': 'foobar_command', 'help': 'Help for foobar_command'})            # Parser parametersdef foobar(*args, **kwargs):    pass```All commands will be registered in a command register that can be accessed through ``command.register``. Each entry inthis register is a dictionary with the fields declared at the beginning of this section.### Shell commandExample of running `ls -la` shell command.```python@command(command_type=CommandType.SHELL)def lsla(*args, **kwargs):    return [shlex.split(&quot;ls -la&quot;)]```### Python functionRun a python function.```python@commanddef foo(*args, **kwargs):    return &quot;foo&quot;```### Python async functionRun a python async function.```python@commandasync def bar(*args, **kwargs):    await asyncio.sleep(1)    return &quot;bar&quot;```## MainA main class is defined to ease the creation of command line applications. This class follows the process:1. Create a parser using ``argparse.ArgumentParser`` for the application:        a) Calling all ``add_arguments(parser)`` methods from all super classes, e.g: ``clinner.mixins.HealthCheckMixin``.        b) Addding a subparser for each command with their specific arguments.2. Parse arguments using the argument parser created previously.3. Inject variables into environment calling all super classes methods whose name starts with ``inject_``.## ExamplesSome Clinner examples.### Simple MainExample of a simple main with two defined commands `foo` and `bar`.```python#!/usr/bin/env pythonimport shleximport sysfrom clinner.command import command, Type as CommandTypefrom clinner.run.main import Main@command(command_type=CommandType.SHELL,         args=(('-i', '--input'),               ('-o', '--output')),         parser_opts={'help': 'Foo command'})def foo(*args, **kwargs):    &quot;&quot;&quot;List of foo commands&quot;&quot;&quot;    ls_cmd = shlex.split('ls')    wc_cmd = shlex.split('wc')    wc_cmd += [kwargs['input'], kwargs['output']]    return [ls_cmd, wc_cmd]@command(command_type=CommandType.PYTHON,         parser_opts={'help': 'Bar command'})def bar(*args, **kwargs):    &quot;&quot;&quot;Do a bar.&quot;&quot;&quot;    return Trueif __name__ == '__main__':    sys.exit(Main().run())```### Builder MainExample of main module with build utilities such as unit tests, lint, sphinx doc, tox and dist packaging:```python#!/usr/bin/env pythonimport sysfrom clinner.run import Mainclass Build(Main):    commands = (        'clinner.run.commands.black.black',        'clinner.run.commands.flake8.flake8',        'clinner.run.commands.isort.isort',        'clinner.run.commands.pytest.pytest',        'clinner.run.commands.sphinx.sphinx',        'clinner.run.commands.tox.tox',    )if __name__ == '__main__':    sys.exit(Build().run())```Check [Clinner docs] to see more advanced examples.[Clinner docs]: http://clinner.readthedocs.io</longdescription>
</pkgmetadata>