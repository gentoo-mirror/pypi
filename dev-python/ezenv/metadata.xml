<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>EZ-Environment================*&quot;For easy access, baby!¬† ‚Ä¶That's right.'&quot;‚ÄîEazy-E*Have you ever thought handling environment variables in Python should be easier?It is now.TL;DR:.. code:: python    &gt;&gt;&gt; import env    &gt;&gt;&gt; env.SERVER_PORT.int    8080*&quot;BAM!&quot; ‚ÄîEmeril Lagasse*The E.Z.E.nvironment module also has its own`theme song &lt;https://youtu.be/Igxl7YtS1vQ?t=1m08s&gt;`_:    *&quot;We want Eazy!&quot;*    | *EAZY!*    | *Everybody come on!*    | *EAZY!*    | *Who yall came to see?*    | *EAZY!*    | *A little louder come on!*    | *EAZY!*    | *Get those hands in the air!*    | *EAZY!*    | *Come on, come on say it!*    | *EAZY!*    | *A little louder come on!*    | *EAZY!*    | *Come on make some noise!*    |    | *A miracle of modern creation‚Ä¶*    | *EZ E's on the set, hyped up with the bass*    | *And a little bit of what ya love*    | *From a brother who's smooth like a criminal*    | *I mean subliminal‚Ä¶*Background---------------It's always been a tad clumsy to access environment variables and combine themwith other strings in Python‚Äî\compared to shell languages at least.For example, look how easy it is in (ba)sh:.. code:: shell    ‚èµ echo &quot;Libraries: $PWD/lib&quot;    Libraries: /usr/local/libUnfortunately over in Python-land,required, escaped quotes and bracketsserve mostly to complicate and add to visual clutter,reducing speed of comprehension... code:: python    &gt;&gt;&gt; from os import environ    &gt;&gt;&gt; from os.path import join    &gt;&gt;&gt; join(environ['PWD'], 'lib')    '/usr/local/lib'Even the new-fangled string interpolation doesn't help as much as might beexpected:.. code:: python    &gt;&gt;&gt; print(f'Libraries: {environ[&quot;PWD&quot;]}/lib')    Libraries: /usr/local/libWith that in mind, allow me to introduce the ``env`` module.With it I've tried to whittle complexity down,primarily through direct attribute access:.. code:: python    &gt;&gt;&gt; import env    &gt;&gt;&gt; print('Term:', env.TERM)    Term: xterm-256color    &gt;&gt;&gt; print(f'Libraries: {env.PWD}/lib')    Libraries: /usr/local/libBut wait, there's more!Install---------------.. code:: shell    ‚èµ pip3 install --user ezenv  # env was taken :-/¬†‚òõ LGPL licensed. ‚òöEnvironment and options------------------------On import the module loads the environment into its namespace,thereby working like a dictionary with convenient attribute access.So, no additional mapping instance has to be created or imported,unless you'd like to configure the interface further.The following options are available to customize:.. code:: python    &gt;&gt;&gt; from env import Environment    &gt;&gt;&gt; env = Environment(            environ=os.environ,            sensitive=True|False,  # case: platform default            writable=False,            pathsep=os.pathsep,        )Param: environ~~~~~~~~~~~~~~A mapping of your own choosing may optionally be passed in as the first argument,for testing and/or other purposes.I've recently learned that`os.environb &lt;https://docs.python.org/3/library/os.html#os.environb&gt;`_(bytes interface) is a thing that could be passed,for example... ~ Noneify.. ~ ~~~~~~~~~~~~.. ~ Enabled by default,.. ~ this one signals non-existent variables by returning None... ~ It allows one to easily test for a variable and not have to worry about.. ~ catching exceptions... ~ If the variable is not set,.. ~ None will be returned instead:.. ~ .. code:: python    .. ~ &gt;&gt;&gt; if env.COLORTERM:   # is not None or ''            .. ~ pass.. ~ **Default Values**.. ~ The one drawback to returning ``None`` is that there is no ``.get()`` method.. ~ to return a default when the variable isn't found... ~ That's easily rectified like so:.. ~ .. code:: python    .. ~ &gt;&gt;&gt; env.FOO or 'bar'    .. ~ 'bar'.. ~ Blankify.. ~ ~~~~~~~~~~~~.. ~ Off by default,.. ~ this option mimics the behavior of most command-line shells... ~ Namely if the variable isn't found,.. ~ it doesn't complain and returns an empty string instead... ~ This can make some cases simpler,.. ~ as fewer checks for errors are needed when checking contents::    .. ~ if env.LANG.endswith('UTF-8'):        .. ~ pass.. ~ instead of the Noneify version::    .. ~ if env.LANG and env.LANG.endswith('UTF-8'):        .. ~ pass.. ~ However,.. ~ it may be a bug-magnet in the case the variable is misspelled,.. ~ It is here if you need it for compatibility... ~ Blankify takes precedence over Noneify if enabled.Param: writable~~~~~~~~~~~~~~~By default the Environment object/module does not allow modification sincewriting is rarely needed.This default helps to remind us of that fact,though the object can be easily be changed to writable if need be by enablingthis option.Param: sensitivity üò¢~~~~~~~~~~~~~~~~~~~~~~Variables are case-sensitive by default on Unix,*insensitive* under Windows.While case sensitivity can be disabled to use variable names in mixed orlower-case,be aware that variables and dictionary methods are in the same namespace,which could potentially be problematic if they are not divided by case.For this reason, using variable names such as &quot;keys&quot; and &quot;items&quot;are not a good idea while in insensitive mode.*shrug*Workaround: use &quot;get item&quot; / dictionary-style syntax if needed:.. code:: python    env['keys']  # :-/.. ~ varname = 'COLORTERM'.. ~ env[varname]Entry Objects----------------While using ``env`` at the interactive prompt,you may be surprised that a variable value is not a simple string but ratheran extended string-like object called an &quot;Entry.&quot;This is most evident at the prompt since it prints a &quot;representation&quot;form by default:.. code:: python    &gt;&gt;&gt; env.PWD                         # a.k.a. repr()    Entry('PWD', '/usr/local')The reason behind this custom object is so that the variables can offeradditional functionality,such as parsing or conversion of the value to another type,while not crashing on a non-existent attribute access.No matter however,as we've seen in the previous sections,just about any operation renders the string value as normal.Attributes ``.name`` and ``.value`` are also available for belt &amp;suspenders types:.. code:: python    &gt;&gt;&gt; print(env.PWD)    /usr/local    &gt;&gt;&gt; env.PWD.name, env.PWD.value, str(env.PWD)    ('PWD', '/tmp', '/tmp')Remember the ``env`` object/module is also a standard dictionary,while entry values are also strings,so full Python functionality is available:.. code:: python    &gt;&gt;&gt; for key, value in env.items():  # it's a dict*            print(key, value)    # USER¬†fred‚Ä¶    &gt;&gt;&gt; env.USER.title()                # it's a str*    'Fred'    &gt;&gt;&gt; env.TERM.partition('-')         # tip: a safer split    ('xterm', '-', '256color')*¬† Sung to the tune, *&quot;It's a Sin,&quot;* by the Pet Shop Boys.Conversions &amp; Parsing-----------------------Another handy feature of Entry objects is convenient type conversion andparsing of values from strings.Additional properties for this functionality are available.For example:.. code:: python    &gt;&gt;&gt; env.PI.float    3.1416    &gt;&gt;&gt; env.STATUS.int    5150    &gt;&gt;&gt; env.DATA.from_json    {'one': 1, 'two': 2, 'three': 3}Truthy Values~~~~~~~~~~~~~~~~~~~~Variable entries may contain boolean-*like* string values,such as ``0, 1, yes, no, true, false``, etc.To interpret them in a case-insensitive manner use the ``.truthy`` property:.. code:: python    &gt;&gt;&gt; env.QT_ACCESSIBILITY    Entry('QT_ACCESSIBILITY', '1')    &gt;&gt;&gt; env.QT_ACCESSIBILITY.truthy    True    &gt;&gt;&gt; env = Environment(writable=True)    &gt;&gt;&gt; env.QT_ACCESSIBILITY = '0'          #¬†set to '0'    &gt;&gt;&gt; env.QT_ACCESSIBILITY.truthy    FalseStandard Boolean Tests++++++++++++++++++++++++As always, standard tests or ``bool()`` on the entry can be done to check astring.Remember, such a test checks merely if the string is empty or not,and would also return ``True`` on ``'0'`` or ``'false'``.Paths~~~~~~~~Environment vars often contain a list of filesystem paths.To split such path strings on ``os.pathsep``\`üîó &lt;https://docs.python.org/3/library/os.html#os.pathsep&gt;`_,with optional conversion to ``pathlib.Path``\`üîó¬≤ &lt;https://docs.python.org/3/library/pathlib.html&gt;`_objects,use one or more of the following:.. code:: python    &gt;&gt;&gt; env.XDG_DATA_DIRS.list    ['/usr/local/share', '/usr/share', ...]  #¬†strings    &gt;&gt;&gt; env.SSH_AUTH_SOCK.path    Path('/run/user/1000/keyring/ssh')    &gt;&gt;&gt; env.XDG_DATA_DIRS.path_list    [Path('/usr/local/share'), Path('/usr/share'), ...]To split on a different character,simply do the split/partition on the string manually... ~ (There is a ._pathsep variable that can be set on each entry,.. ~ but not particularly more convenient.)Examples---------------There are generally three cases for environment variables:**Variable exists, has value:**.. code:: python    &gt;&gt;&gt; env.USER                            # exists, repr    Entry('USER', 'fred')    &gt;&gt;&gt; env.USER + '_suffix'                # str ops    'fred_suffix'    &gt;&gt;&gt; env.USER.title()                    # str ops II    'Fred'    &gt;&gt;&gt; print(f'term: {env.TERM}')          # via interpolation    term: xterm-256color    &gt;&gt;&gt; bool(env.USER)                      # check exists &amp; not empty    True    &gt;&gt;&gt; key_name = 'PI'    &gt;&gt;&gt; env[key_name]                       # getitem syntax    '3.1416'    &gt;&gt;&gt; env.PI.float                        # type conversion    3.1416    &gt;&gt;&gt; env.PORT.int or 9000                #¬†type conv. w/ default    5150    &gt;&gt;&gt; env.QT_ACCESSIBILITY.truthy         # 0/1/yes/no/true/false    True    &gt;&gt;&gt; env.JSON_DATA.from_json.keys()    ['one', 'three', 'two']    &gt;&gt;&gt; env.XDG_DATA_DIRS.list    ['/usr/local/share', '/usr/share']**Variable exists, but is blank:**.. code:: python    &gt;&gt;&gt; 'EMPTY' in env                      # check existence    True    &gt;&gt;&gt; env.EMPTY                           #¬†exists but empty    Entry('EMPTY', '')    &gt;&gt;&gt; bool(env.EMPTY)                     # check exists &amp; not empty    False    &gt;&gt;&gt; env.EMPTY or 'default'              #¬†exists, blank¬†w/ default    'default'**Variable doesn't exist:**.. code:: python    &gt;&gt;&gt; 'NO_EXISTO' in env                  # check existence    False    &gt;&gt;&gt; env.NO_EXISTO or 'default'          #¬†DNE¬†with default    'default'    &gt;&gt;&gt; env.NO_EXISTO                       #¬†Doesn't exist repr    NullEntry('NO_EXISTO')    &gt;&gt;&gt; bool(env.NO_EXISTO)                 # check exists &amp; not empty    False    &gt;&gt;&gt; env.XDG_DATA_DIRz.list              # DNE fallback    []    for data_dir in env.XDG_DATA_DIR.list:        # Don't need to worry if this exists or not,        # if not, it will be skipped.        passCompatibility---------------*&quot;What's the frequency Kenneth?&quot;*This module attempts compatibility with KR's existing`env &lt;https://github.com/kennethreitz/env&gt;`_package by implementing its ``prefix`` and ``map`` functions:.. code:: python    &gt;&gt;&gt; env.prefix('XDG_')  #¬†from_prefix preferred    {'config_dirs': '/etc/xdg/xdg-mate:/etc/xdg', ...}    &gt;&gt;&gt; env.map(username='USER')    {'username': 'fred'}The lowercase transform can be disabled by passing another false-like valueas the second argument to ``prefix().``While the package above has the coveted ``env`` namespace on PyPI,ezenv uses the same simple module name and provides an implementation of theinterface.Tests---------------Can be run here:.. code:: shell    ‚èµ python3 -m env -vThough this module works under Python2,several of the tests *don't*,because Py2 does Unicode differently ordoesn't have the facilities available to handle them by default(pathlib/f-string).Haven't had the urge to work around that due to declining interest.FYI, a reference to the original module object is kept at ``env._module``just in case it is needed for some reason.Testing *with* ezenv~~~~~~~~~~~~~~~~~~~~~When you've used ``ezenv`` in your project,it is easy to create a custom environment to operate under:.. code:: python    from env import Environment    def test_foo():        import mymodule        mymodule.env = Environment(environ=dict(NO_COLOR='1'))        assert mymodule.color_is_disabled() == TruePricing---------------*&quot;I'd buy THAT for a dollar!&quot; :-D*</longdescription>
</pkgmetadata>