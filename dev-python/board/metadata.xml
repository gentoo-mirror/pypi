<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Board Game for Python Dojos===========================Introduction------------Often, when running a Python Dojo, we've ended up with a challengebased around some kind of board or tile-based landscape. In thesesituations it's not uncommon to spend a lot of the time building upyour basic board functionality in order to support the more interestinggameplay algorithm.This module implements a general-purpose board structure whichhas the functionality needed for a range of purposes, and lends itselfto being subclassed for those particular needs.Dependencies------------None - stdlib onlyTests-----Fairly decent coverage (not actually checked with coverage.py): test.pyGetting Started---------------Install with pip::    pip install boardAbsolutely basic usage::    import board    #    # Produce a 3x3 board    #    b = board.Board((3, 3))    b[0, 0] = &quot;X&quot;    b[1, 0] = &quot;O&quot;Usage-----Board is an n-dimensional board, any of which dimensions can be ofinfinite size. (So if you have, say, 3 infinite dimensions, you havethe basis for a Minecraft layout). Dimensions are zero-based andnegative indexes operate as they usually do in Python: working fromthe end of the dimension backwards.Cells on the board are accessed by item access, eg board[1, 2] orlandscape[1, 1, 10].A board can be copied, optionally along with its data by means of the.copy method. Or a section of a board can be linked to the originalboard by slicing the original board::    b1 = board.Board((9, 9))    b1[1, 1] = 1    b2 = b1.copy()    b3 = b1[:3, :3]Note that the slice must include all the dimensions of the originalboard, but any of those subdimensions can be of length 1::    b1 = board.Board((9, 9, 9))    b2 = b1[:3, :3, :1]A sentinel value of Empty indicates a position which is not populatedbecause it has never had a value, or because its value has been deleted::    b1 = board.Board((3, 3))    assert b1[1, 1] is board.Empty    b1.populate(&quot;abcdefghi&quot;)    assert b1[1, 1] == &quot;e&quot;    del b1[1, 1]    assert b1[1, 1] is board.EmptyIterating over the board yields its coordinates::    b1 = board.Board((2, 2))    for coord in b1:        print(coord)    #    # =&gt; (0, 0), (0, 1) etc.    #Iteration over a board with one or more infinite dimensions will workby iterating in chunks::    b1 = board.Board((3, 3, board.Infinity))    for coord in b1:        print(b1)To see coordinates with their data items, use iterdata::    b1 = board.Board((2, 2))    b1.populate(&quot;abcd&quot;)    for coord, data in b1.iterdata():        print(coord, &quot;=&gt;&quot;, data)To read, write and empty the data at a board position, use indexing::    b1 = board.Board((3, 3))    b1.populate(&quot;abcdef&quot;)    print(b1[0, 0]) # &quot;a&quot;    b1[0, 0] = &quot;*&quot;    print(b1[0, 0]) # &quot;*&quot;    b1[-1, -1] = &quot;*&quot;    print(b1[2, 2]) # &quot;*&quot;    del b1[0, 0]    print(b1[0, 0]) # &lt;Empty&gt;To test whether a coordinate is contained with the local coordinate space, use in::    b1 = board.Board((3, 3))    (1, 1) in b1 # True    (4, 4) in b1 # False    (1, 1, 1) in b1 # InvalidDimensionsErrorOne board is equal to another if it has the same dimensionality andeach data item is equal::    b1 = board.Board((3, 3))    b1.populate(&quot;abcdef&quot;)    b2 = b1.copy()    b1 == b2 # True    b2[0, 0] = &quot;*&quot;    b1 == b2 # False    b2 = board.Board((2, 2))    b2.populate(&quot;abcdef&quot;)    b1 == b2 # FalseTo populate the board from an arbitrary iterator, use .populate::    def random_letters():        import random, string        while True:            yield random.choice(string.ascii_uppercase)    b1 = board.Board((4, 4))    b1.populate(random_letters())To clear the board, use .clear::    b1 = board.Board((3, 3))    b1.populate(range(10))    b1.clear()    list(b1.iterdata()) # []A board is True if it has any data, False if it has none::    b1 = board.Board((2, 2))    b1.populate(&quot;abcd&quot;)    bool(b1) # True    b1.clear()    bool(b1) # FalseThe length of the board is the product of its dimension lengths. If anydimension is infinite, the board length is infinite. NB to find theamount of data on the board, use lendata::    b1 = board.Board((4, 4))    len(b1) # 16    b1.populate(&quot;abcd&quot;)    len(b1) # 16    b1.lendata() # 4    b2 = board.Board((2, board.Infinity))    len(b2) # InfinityTo determine the bounding box of the board which contains data, use .occupied::    b1 = board.Board((3, 3))    b1.populate(&quot;abcd&quot;)    list(c for (c, d) in b1.iterdata()) # [(0, 0), (0, 1), (0, 2), (1, 0)]    b1.occupied() # ((0, 0), (1, 2))For the common case of slicing a board around its occupied space,use .occupied_board::    b1 = board.Board((3, 3))    b1.populate(&quot;abcd&quot;)    b1.draw()    b2 = b1.occupied_board()    b2.draw()To test whether a position is on any edge of the board, use .is_edge::    b1 = board.Board((3, 3))    b1.is_edge((0, 0)) # True    b1.is_edge((1, 1)) # False    b1.is_edge((2, 0)) # TrueTo find the immediate on-board neighbours to a position along all dimensions::    b1 = board.Board((3, 3, 3))    list(b1.neighbours((0, 0, 0)))    # [(0, 1, 1), (1, 1, 0), ..., (1, 0, 1), (0, 1, 0)]To iterate over all the coords in the rectangular space betweentwo corners, use .itercoords::    b1 = board.Board((3, 3))    list(b1.itercoords((0, 0), (1, 1))) # [(0, 0), (0, 1), (1, 0), (1, 1)]To iterate over all the on-board positions from one point in aparticular direction, use .iterline::    b1 = board.Board((4, 4))    start_from = 1, 1    direction = 1, 1    list(b1.iterline(start_from, direction)) # [(1, 1), (2, 2), (3, 3)]    direction = 0, 2    list(b1.iterline(start_from, direction)) # [(1, 1), (1, 3)]or .iterlinedata to generate the data at each point::    b1 = board.Board((3, 3))    b1.populate(&quot;ABCDEFGHJ&quot;)    start_from = 1, 1    direction = 1, 0    list(b1.iterlinedata(start_from, direction)) # ['A', 'D', 'G']Both iterline and iterdata can take a maximum number of steps, eg forgames like Connect 4 or Battleships::    b1 = board.Board((8, 8))    #    # Draw a Battleship    #    b1.populate(&quot;BBBB&quot;, b1.iterline((2, 2), (1, 0)))As a convenience for games which need to look for a run of so manythings, the .run_of_n method combines iterline with data to yieldevery possible line on the board which is of a certain length alongwith its data::    b1 = board.Board((3, 3))    b1[0, 0] = 'X'    b1[1, 1] = 'O'    b1[0, 1] = 'X'    for line, data in b1.runs_of_n(3):        if all(d == &quot;O&quot; for d in data):            print(&quot;O wins&quot;)            break        elif all(d == &quot;X&quot; for d in data):            print(&quot;X wins&quot;)            breakTo iterate over the corners of the board, use .corners::    b1 = board.Board((3, 3))    corners() # [(0, 0), (0, 2), (2, 0), (2, 2)]Properties----------To determine whether a board is offset from another (ie the result of a slice)::    b1 = board.Board((3, 3))    b1.is_offset # False    b2 = b1[:1, :1]    b2.is_offset # TrueTo determine whether a board has any infinite or finite dimensions::    b1 = board.Board((3, board.Infinity))    b1.has_finite_dimensions # True    b1.has_infinite_dimensions # True    b2 = board.Board((3, 3))    b1.has_infinite_dimensions # False    b3 = board.Board((board.Infinity, board.Infinity))    b3.has_finite_dimensions # FalseDisplay the Board-----------------To get a crude view of the contents of the board, use .dump::    b1 = board.Board((3, 3))    b1.populate(&quot;abcdef&quot;)    b1.dump()To get a grid view of a 2-dimensional board, use .draw::    b1 = board.Board((3, 3))    b1.populate(&quot;OX  XXOO &quot;)    b1.draw()If you don't want the borders drawn, eg because you're using the boardto render ASCII art, pass use_borders=False::    b1 = board.Board((8, 8))    for coord in b1.iterline((0, 0), (1, 1)):        b1[coord] = &quot;*&quot;    for coord in b1.iterline((7, 0), (-1, 1)):        b1[coord] = &quot;*&quot;    b1.draw(use_borders=False)To render to an image using Pillow (which isn't a hard dependency) use paint.The default renderer treats the data items as text and renders then, scaledto fit, into each cell. This works, obviously, for things like Noughts &amp; Crossesassuming that you store something like &quot;O&quot; and &quot;X&quot;. But it also works forword searches and even simple battleships where the data items are objectswhose __str__ returns blank (for undiscovered), &quot;+&quot; for a single hit, and &quot;*&quot;for a destroyed vessel::    b1 = board.Board((3, 3))    b1[0, 0] = &quot;X&quot;    b1[1, 1] = &quot;O&quot;    b1[0, 2] = &quot;X&quot;    b1.paint(&quot;board.png&quot;)    # ... and now look at board.pngThe text painting is achieved internally by means of a callback calledtext_sprite. An alternative ready-cooked callback for paint() isimagefile_sprite. This looks for a .png file in the current directory(or another; you can specify).Local and Global coordinates----------------------------Since one board can represent a slice of another, there are two levelsof coordinates: local and global. Coordinates passed to or returned fromany of the public API methods are always local for that board. Theyrepresent the natural coordinate space for the board. Internally, themodule will use global coordinates, translating as necessary.Say you're managing a viewport of a tile-based dungeon game where themaster dungeon board is 100 x 100 but the visible board is 10 x 10.Your viewport board is currently representing the slice of the masterboard from (5, 5) to (14, 14). Changing the item at position (2, 2) onthe viewport board will change the item at position (7, 7) on the masterboard (and vice versa).As a user of the API you don't need to know this, except to understandthat a board slice is essentially a view on its parent. If you wishto subclass or otherwise extend the board, you'll need to note wherecoordinate translations are necessary.</longdescription>
</pkgmetadata>