<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Type-safe data interchange for PythonJSON is a popular message interchange format employed in API design for its simplicity, readability, flexibility and wide support. However, `json.dump` and `json.load` offer no direct support when working with Python data classes employing type annotations. This package offers services for working with strongly-typed Python classes: serializing objects to JSON, deserializing JSON to objects, and producing a JSON schema that matches the data class, e.g. to be used in an OpenAPI specification.Unlike [orjson](https://github.com/ijl/orjson), this package supports both serializing and deserializing complex types such as data classes, UUIDs, decimals, etc., and allows specifying custom serialization and deserialization hooks. It doesn't require introducing custom classes in your class inheritance chain (such as `BaseModel` in [pydantic dataclasses](https://pydantic-docs.helpmanual.io/usage/dataclasses/)), making it suitable for operating on classes defined in third-party modules.## FeaturesThis package offers the following services:* JSON serialization and de-serialization    * Generate a JSON object from a Python object (`serialization.object_to_json`)    * Parse a JSON object into a Python object (`serialization.json_to_object`)* JSON schema    * Generate a JSON schema from a Python type (`schema.classdef_to_schema`)    * Validate a JSON object against a Python type (`schema.validate_object`)* Type information    * Extract documentation strings (a.k.a. docstring) from types (`docstring.parse_type`)    * Inspect types, including generics (package `inspection`)These services come with full support for complex types like data classes, named tuples and generics.In the context of this package, a *JSON object* is the (intermediate) Python object representation produced by `json.loads` from a *JSON string*. In contrast, a *JSON string* is the string representation generated by `json.dumps` from the (intermediate) Python object representation.## Use cases* Writing a cloud function (lambda) that communicates with JSON messages received as HTTP payload or websocket text messages* Verifying if an API endpoint receives well-formed input* Generating a type schema for an OpenAPI specification to impose constraints on what messages an API can receive (see [python-openapi](https://pypi.org/project/python-openapi/))* Parsing JSON configuration files into a Python object## UsageConsider the following class definition:```python@dataclassclass Example:    &quot;A simple data class with multiple properties.&quot;    bool_value: bool = True    int_value: int = 23    float_value: float = 4.5    str_value: str = &quot;string&quot;    datetime_value: datetime.datetime = datetime.datetime(1989, 10, 23, 1, 45, 50)    guid_value: uuid.UUID = uuid.UUID(&quot;f81d4fae-7dec-11d0-a765-00a0c91e6bf6&quot;)```First, we serialize the object to JSON with```pythonsource = Example()json_obj = object_to_json(source)```Here, the variable `json_obj` has the value:```python{    &quot;bool_value&quot;: True,    &quot;int_value&quot;: 23,    &quot;float_value&quot;: 4.5,    &quot;str_value&quot;: &quot;string&quot;,    &quot;datetime_value&quot;: &quot;1989-10-23T01:45:50&quot;,    &quot;guid_value&quot;: &quot;f81d4fae-7dec-11d0-a765-00a0c91e6bf6&quot;,}```Next, we restore the object from JSON with```pythontarget = json_to_object(Example, json_obj)```Here, `target` holds the restored data class object:```pythonExample(    bool_value=True,    int_value=23,    float_value=4.5,    str_value=&quot;string&quot;,    datetime_value=datetime.datetime(1989, 10, 23, 1, 45, 50),    guid_value=uuid.UUID(&quot;f81d4fae-7dec-11d0-a765-00a0c91e6bf6&quot;),)```We can also produce the JSON schema corresponding to the Python class:```pythonjson_schema = json.dumps(classdef_to_schema(Example), indent=4)```which yields```json{    &quot;$schema&quot;: &quot;https://json-schema.org/draft/2020-12/schema&quot;,    &quot;type&quot;: &quot;object&quot;,    &quot;properties&quot;: {        &quot;bool_value&quot;: {            &quot;type&quot;: &quot;boolean&quot;,            &quot;default&quot;: true        },        &quot;int_value&quot;: {            &quot;type&quot;: &quot;integer&quot;,            &quot;default&quot;: 23        },        &quot;float_value&quot;: {            &quot;type&quot;: &quot;number&quot;,            &quot;default&quot;: 4.5        },        &quot;str_value&quot;: {            &quot;type&quot;: &quot;string&quot;,            &quot;default&quot;: &quot;string&quot;        },        &quot;datetime_value&quot;: {            &quot;type&quot;: &quot;string&quot;,            &quot;format&quot;: &quot;date-time&quot;,            &quot;default&quot;: &quot;1989-10-23T01:45:50&quot;        },        &quot;guid_value&quot;: {            &quot;type&quot;: &quot;string&quot;,            &quot;format&quot;: &quot;uuid&quot;        }    },    &quot;additionalProperties&quot;: false,    &quot;required&quot;: [        &quot;bool_value&quot;,        &quot;int_value&quot;,        &quot;float_value&quot;,        &quot;str_value&quot;,        &quot;datetime_value&quot;,        &quot;guid_value&quot;    ],    &quot;title&quot;: &quot;A simple data class with multiple properties.&quot;}```If a type has a Python docstring, then `title` and `description` fields in the JSON schema are populated from the text in the documentation string.## StandardsFor producing a JSON schema, the following JSON schema standards are supported:* [Draft 7](https://json-schema.org/specification-links.html#draft-7)* [Draft 2019-09](https://json-schema.org/specification-links.html#draft-2019-09-formerly-known-as-draft-8)* [Draft 2020-12](https://json-schema.org/specification-links.html#2020-12)## Conversion tableThe following table shows the conversion types the package employs:| Python type | JSON schema type | Behavior || -- | -- | -- || None | null || bool | boolean || int | integer || float | number || str | string || decimal.Decimal | number || bytes | string | represented with Base64 content encoding || datetime | string | constrained to match ISO 8601 format `2018-11-13T20:20:39+00:00` || date | string | constrained to match ISO 8601 format `2018-11-13` || time | string | constrained to match ISO 8601 format `20:20:39+00:00` || UUID | string | constrained to match UUID format `f81d4fae-7dec-11d0-a765-00a0c91e6bf6` || Enum | *value type* | stores the enumeration value type (typically integer or string) || Optional[**T**] | *depends on inner type* | reads and writes **T** if present || Union[**T1**, **T2**, ...] | *depends on concrete type* | serializes to the appropriate inner type; deserializes from the first matching type || List[**T**] | array | recursive in **T** || Dict[**K**, **V**] | object | recursive in **V**, keys are coerced into string || Dict[Enum, **V**] | object | recursive in **V**, keys are of enumeration value type and coerced into string || Set[**T**] | array | recursive in **T**, container has uniqueness constraint || Tuple[**T1**, **T2**, ...] | array | array has fixed length, each element has specific type || Literal[**const**] | *type matching* **const** | export the literal value as a constant value || data class | object | iterates over fields of data class || named tuple | object | iterates over fields of named tuple || regular class | object | iterates over `dir(obj)` || JsonArray | array | untyped JSON array || JsonObject | object | untyped JSON object || Any | oneOf | a union of all basic JSON schema types || Annotated[**T**, ...] | *depends on* **T** | outputs value for **T**, applies constraints and format based on auxiliary type information |## JSON schema examples### Simple basic types| Python type | JSON schema || -- | -- || bool | `{&quot;type&quot;: &quot;boolean&quot;}` || int | `{&quot;type&quot;: &quot;integer&quot;}` || float | `{&quot;type&quot;: &quot;number&quot;}` || str | `{&quot;type&quot;: &quot;string&quot;}` || bytes | `{&quot;type&quot;: &quot;string&quot;, &quot;contentEncoding&quot;: &quot;base64&quot;}` |### Simple built-in types| Python type | JSON schema || -- | -- || decimal.Decimal | `{&quot;type&quot;: &quot;number&quot;}` || datetime.date | `{&quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;date&quot;}` || uuid.UUID | `{&quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;uuid&quot;}` |### Enumeration types```pythonclass Side(enum.Enum):    LEFT = &quot;L&quot;    RIGHT = &quot;R&quot;``````json{&quot;enum&quot;: [&quot;L&quot;, &quot;R&quot;], &quot;type&quot;: &quot;string&quot;}```### Container types| Python type | JSON schema || -- | -- || List[int] | `{&quot;type&quot;: &quot;array&quot;, &quot;items&quot;: {&quot;type&quot;: &quot;integer&quot;}}` || Dict[str, int] | `{&quot;type&quot;: &quot;object&quot;, &quot;additionalProperties&quot;: {&quot;type&quot;: &quot;integer&quot;}}` || Set[int] | `{&quot;type&quot;: &quot;array&quot;, &quot;items&quot;: {&quot;type&quot;: &quot;integer&quot;}, &quot;uniqueItems&quot;: True}}` || Tuple[int, str] | `{&quot;type&quot;: &quot;array&quot;, &quot;minItems&quot;: 2, &quot;maxItems&quot;: 2, &quot;prefixItems&quot;: [{&quot;type&quot;: &quot;integer&quot;}, {&quot;type&quot;: &quot;string&quot;}]}` |### Annotated typesRange:```pythonAnnotated[int, IntegerRange(23, 82)])``````json{    &quot;type&quot;: &quot;integer&quot;,    &quot;minimum&quot;: 23,    &quot;maximum&quot;: 82,}```Precision:```pythonAnnotated[decimal.Decimal, Precision(9, 6)])``````json{    &quot;type&quot;: &quot;number&quot;,    &quot;multipleOf&quot;: 0.000001,    &quot;exclusiveMinimum&quot;: -1000,    &quot;exclusiveMaximum&quot;: 1000,}```### Fixed-width typesFixed-width integer (e.g. `uint64`) and floating-point (e.g. `float32`) types are annotated types defined in the package `strong_typing.auxiliary`. Their signature is recognized when generating a schema, and a `format` property is written instead of minimum and maximum constraints.`int32`:```pythonint32 = Annotated[int, Signed(True), Storage(4), IntegerRange(-2147483648, 2147483647)]``````json{&quot;format&quot;: &quot;int32&quot;, &quot;type&quot;: &quot;integer&quot;}````uint64`:```pythonuint64 = Annotated[int, Signed(False), Storage(8), IntegerRange(0, 18446744073709551615)]``````json{&quot;format&quot;: &quot;uint64&quot;, &quot;type&quot;: &quot;integer&quot;}```### Any type```json{    &quot;oneOf&quot;: [        {&quot;type&quot;: &quot;null&quot;},        {&quot;type&quot;: &quot;boolean&quot;},        {&quot;type&quot;: &quot;number&quot;},        {&quot;type&quot;: &quot;string&quot;},        {&quot;type&quot;: &quot;array&quot;},        {&quot;type&quot;: &quot;object&quot;},    ]}```## Custom serialization and de-serializationIf a composite object (e.g. a dataclass or a plain Python class) has a `to_json` member function, then this function is invoked to produce a JSON object representation from an instance.If a composite object has a `from_json` class function (a.k.a. `@classmethod`), then this function is invoked, passing the JSON object as an argument, to produce an instance of the corresponding type.## Custom typesIt is possible to declare custom types when generating a JSON schema. For example, the following class definition has the annotation `@json_schema_type`, which will register a JSON schema subtype definition under the path `#/definitions/AzureBlob`, which will be referenced later with `$ref`:```python_regexp_azure_url = re.compile(    r&quot;^https?://([^.]+)\.blob\.core\.windows\.net/([^/]+)/(.*)$&quot;)@dataclass@json_schema_type(    schema={        &quot;type&quot;: &quot;object&quot;,        &quot;properties&quot;: {            &quot;mimeType&quot;: {&quot;type&quot;: &quot;string&quot;},            &quot;blob&quot;: {                &quot;type&quot;: &quot;string&quot;,                &quot;pattern&quot;: _regexp_azure_url.pattern,            },        },        &quot;required&quot;: [&quot;mimeType&quot;, &quot;blob&quot;],        &quot;additionalProperties&quot;: False,    })class AzureBlob(Blob):    ...```You can use `@json_schema_type` without the `schema` parameter to register the type name but have the schema definition automatically derived from the Python type. This is useful if the type is reused across the type hierarchy:```python@json_schema_typeclass Image:    ...class Study:    left: Image    right: Image```Here, the two properties of `Study` (`left` and `right`) will refer to the same subtype `#/definitions/Image`.## Union typesSerializing a union type entails serializing the active member type.De-serializing discriminated (tagged) union types is based on a disjoint set of property values with type annotation `Literal[...]`. Consider the following example:```python@dataclassclass ClassA:    name: Literal[&quot;A&quot;, &quot;a&quot;]    value: str@dataclassclass ClassB:    name: Literal[&quot;B&quot;, &quot;b&quot;]    value: str```Here, JSON representations of `ClassA` and `ClassB` are indistinguishable based on property names alone. However, the property `name` for `ClassA` can only take values `&quot;A&quot;` and `&quot;a&quot;`, and property `name` for `ClassB` can only take values `&quot;B&quot;` and `&quot;b&quot;`, hence a JSON object such as```json{ &quot;name&quot;: &quot;A&quot;, &quot;value&quot;: &quot;string&quot; }```uniquely identifies `ClassA`, and can never match `ClassB`. The de-serializer can instantiate the appropriate class, and populate properties of the newly created instance.Tagged union types must have at least one property of a literal type, and the values for that type must be all different.When de-serializing regular union types that have no type tags, the first successfully matching type is selected. It is a parse error if all union member types have been exhausted without a finding match.## Name manglingIf a Python class has a property augmented with an underscore (`_`) as per [PEP 8](https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles) to avoid conflict with a Python keyword (e.g. `for` or `in`), the underscore is removed when reading from or writing to JSON.</longdescription>
</pkgmetadata>