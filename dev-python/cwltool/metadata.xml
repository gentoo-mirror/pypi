<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>#############################################################################################``cwltool``: The reference reference implementation of the Common Workflow Language standards#############################################################################################|Linux Status| |Coverage Status| |Docs Status|PyPI: |PyPI Version| |PyPI Downloads Month| |Total PyPI Downloads|Conda: |Conda Version| |Conda Installs|Debian: |Debian Testing package| |Debian Stable package|Quay.io (Docker): |Quay.io Container|.. |Linux Status| image:: https://github.com/common-workflow-language/cwltool/actions/workflows/ci-tests.yml/badge.svg?branch=main   :target: https://github.com/common-workflow-language/cwltool/actions/workflows/ci-tests.yml.. |Debian Stable package| image:: https://badges.debian.net/badges/debian/stable/cwltool/version.svg   :target: https://packages.debian.org/stable/cwltool.. |Debian Testing package| image:: https://badges.debian.net/badges/debian/testing/cwltool/version.svg   :target: https://packages.debian.org/testing/cwltool.. |Coverage Status| image:: https://img.shields.io/codecov/c/github/common-workflow-language/cwltool.svg   :target: https://codecov.io/gh/common-workflow-language/cwltool.. |PyPI Version| image:: https://badge.fury.io/py/cwltool.svg   :target: https://badge.fury.io/py/cwltool.. |PyPI Downloads Month| image:: https://pepy.tech/badge/cwltool/month   :target: https://pepy.tech/project/cwltool.. |Total PyPI Downloads| image:: https://static.pepy.tech/personalized-badge/cwltool?period=total&amp;units=international_system&amp;left_color=black&amp;right_color=orange&amp;left_text=Total%20PyPI%20Downloads   :target: https://pepy.tech/project/cwltool.. |Conda Version| image:: https://anaconda.org/conda-forge/cwltool/badges/version.svg   :target: https://anaconda.org/conda-forge/cwltool.. |Conda Installs| image:: https://anaconda.org/conda-forge/cwltool/badges/downloads.svg   :target: https://anaconda.org/conda-forge/cwltool.. |Quay.io Container| image:: https://quay.io/repository/commonwl/cwltool/status   :target: https://quay.io/repository/commonwl/cwltool.. |Docs Status| image:: https://readthedocs.org/projects/cwltool/badge/?version=latest   :target: https://cwltool.readthedocs.io/en/latest/?badge=latest   :alt: Documentation StatusThis is the reference implementation of the `Common Workflow Language openstandards &lt;https://www.commonwl.org/&gt;`_.  It is intended to be feature completeand provide comprehensive validation of CWLfiles as well as provide other tools related to working with CWL.``cwltool`` is written and tested for`Python &lt;https://www.python.org/&gt;`_ ``3.x {x = 6, 8, 9, 10, 11}``The reference implementation consists of two packages.  The ``cwltool`` packageis the primary Python module containing the reference implementation in the``cwltool`` module and console executable by the same name.The ``cwlref-runner`` package is optional and provides an additional entry pointunder the alias ``cwl-runner``, which is the implementation-agnostic name for thedefault CWL interpreter installed on a host.``cwltool`` is provided by the CWL project, `a member project of Software Freedom Conservancy &lt;https://sfconservancy.org/news/2018/apr/11/cwl-new-member-project/&gt;`_and our `many contributors &lt;https://github.com/common-workflow-language/cwltool/graphs/contributors&gt;`_... contents:: Table of Contents*******Install*******``cwltool`` packages====================Your operating system may offer cwltool directly. For `Debian &lt;https://tracker.debian.org/pkg/cwltool&gt;`_, `Ubuntu &lt;https://launchpad.net/ubuntu/+source/cwltool&gt;`_,and similar Linux distribution try.. code:: bash   sudo apt-get install cwltoolIf you encounter an error, first try to update package information by using.. code:: bash   sudo apt-get updateIf you are running macOS X or other UNIXes and you want to use packages prepared by the conda-forge project, thenplease follow the install instructions for `conda-forge &lt;https://conda-forge.org/#about&gt;`_ (if you haven't already) and then.. code:: bash   conda install -c conda-forge cwltoolAll of the above methods of installing ``cwltool`` use packages that might contain bugs already fixed in newer versions or be missing desired features.If the packaged version of ``cwltool`` available to you is too old, then we recommend installing using ``pip`` and ``venv``.. code:: bash   python3 -m venv env      # Create a virtual environment named 'env' in the current directory   source env/bin/activate  # Activate environment before installing `cwltool`Then install the latest ``cwlref-runner`` package from PyPi (which will install the latest ``cwltool`` package aswell).. code:: bash  pip install cwlref-runnerIf installing alongside another CWL implementation (like ``toil-cwl-runner`` or ``arvados-cwl-runner``) then instead run.. code:: bash  pip install cwltoolMS Windows users================1. `Install Windows Subsystem for Linux 2 and Docker Desktop &lt;https://docs.docker.com/docker-for-windows/wsl/#prerequisites&gt;`_. 2. `Install Debian from the Microsoft Store &lt;https://www.microsoft.com/en-us/p/debian/9msvkqc78pk6&gt;`_.3. Set Debian as your default WSL 2 distro: ``wsl --set-default debian``.4. Return to the Docker Desktop, choose ``Settings`` → ``Resources`` → ``WSL Integration`` and under &quot;Enable integration with additional distros&quot; select &quot;Debian&quot;,5. Reboot if you have not yet already.6. Launch Debian and follow the Linux instructions above (``apt-get install cwltool`` or use the ``venv`` method)Network problems from within WSL2? Try `these instructions &lt;https://github.com/microsoft/WSL/issues/4731#issuecomment-702176954&gt;`_ followed by ``wsl --shutdown``.``cwltool`` development version===============================Or you can skip the direct ``pip`` commands above and install the latest development version of ``cwltool``:.. code:: bash  git clone https://github.com/common-workflow-language/cwltool.git # clone (copy) the cwltool git repository  cd cwltool           # Change to source directory that git clone just downloaded  pip install .[deps]  # Installs ``cwltool`` from source  cwltool --version    # Check if the installation works correctlyRemember, if co-installing multiple CWL implementations, then you need tomaintain which implementation ``cwl-runner`` points to via a symbolic filesystem link or `another facility &lt;https://wiki.debian.org/DebianAlternatives&gt;`_.Recommended Software====================We strongly suggested to have the following installed:* One of the following software container engines  * `Podman &lt;https://podman.io/getting-started/installation&gt;`_  * `Docker &lt;https://docs.docker.com/engine/install/&gt;`_  * Singularity/Apptainer: See `Using Singularity`_  * udocker: See `Using uDocker`_* `node.js &lt;https://nodejs.org/en/download/&gt;`_ for evaluating CWL Expressions quickly  (required for `udocker` users, optional but recommended for the other container engines).Without these, some examples in the CWL tutorials at http://www.commonwl.org/user_guide/ may not work.***********************Run on the command line***********************Simple command::  cwl-runner my_workflow.cwl my_inputs.yamlOr if you have multiple CWL implementations installed and you want to overridethe default cwl-runner then use::  cwltool my_workflow.cwl my_inputs.ymlYou can set cwltool options in the environment with ``CWLTOOL_OPTIONS``,these will be inserted at the beginning of the command line::  export CWLTOOL_OPTIONS=&quot;--debug&quot;Use with boot2docker on macOS=============================boot2docker runs Docker inside a virtual machine, and it only mounts ``Users``on it. The default behavior of CWL is to create temporary directories under e.g.``/Var`` which is not accessible to Docker containers.To run CWL successfully with boot2docker you need to set the ``--tmpdir-prefix``and ``--tmp-outdir-prefix`` to somewhere under ``/Users``::    $ cwl-runner --tmp-outdir-prefix=/Users/username/project --tmpdir-prefix=/Users/username/project wc-tool.cwl wc-job.jsonUsing uDocker=============Some shared computing environments don't support Docker software containers for technical or policy reasons.As a workaround, the CWL reference runner supports using the `udocker &lt;https://github.com/indigo-dc/udocker&gt;`_program on Linux using ``--udocker``.udocker installation: https://indigo-dc.github.io/udocker/installation_manual.htmlRun `cwltool` just as you usually would, but with ``--udocker`` prior to the workflow path:.. code:: bash  cwltool --udocker https://github.com/common-workflow-language/common-workflow-language/raw/main/v1.0/v1.0/test-cwl-out2.cwl https://github.com/common-workflow-language/common-workflow-language/raw/main/v1.0/v1.0/empty.jsonAs was mentioned in the `Recommended Software`_ section,Using Singularity=================``cwltool`` can also use `Singularity &lt;https://github.com/hpcng/singularity/releases/&gt;`_ version 2.6.1or later as a Docker container runtime.``cwltool`` with Singularity will run software containers specified in``DockerRequirement`` and therefore works with Docker images only, nativeSingularity images are not supported. To use Singularity as the Docker containerruntime, provide ``--singularity`` command line option to ``cwltool``.With Singularity, ``cwltool`` can pass all CWL v1.0 conformance tests, exceptthose involving Docker container ENTRYPOINTs.Example.. code:: bash  cwltool --singularity https://github.com/common-workflow-language/common-workflow-language/raw/main/v1.0/v1.0/cat3-tool-mediumcut.cwl https://github.com/common-workflow-language/common-workflow-language/raw/main/v1.0/v1.0/cat-job.jsonRunning a tool or workflow from remote or local locations=========================================================``cwltool`` can run tool and workflow descriptions on both local and remotesystems via its support for HTTP[S] URLs.Input job files and Workflow steps (via the `run` directive) can reference CWLdocuments using absolute or relative local filesystem paths. If a relative pathis referenced and that document isn't found in the current directory, then thefollowing locations will be searched:http://www.commonwl.org/v1.0/CommandLineTool.html#Discovering_CWL_documents_on_a_local_filesystemYou can also use `cwldep &lt;https://github.com/common-workflow-language/cwldep&gt;`_to manage dependencies on external tools and workflows.Overriding workflow requirements at load time=============================================Sometimes a workflow needs additional requirements to run in a particularenvironment or with a particular dataset.  To avoid the need to modify theunderlying workflow, cwltool supports requirement &quot;overrides&quot;.The format of the &quot;overrides&quot; object is a mapping of item identifier (workflow,workflow step, or command line tool) to the process requirements that should be applied... code:: yaml  cwltool:overrides:    echo.cwl:      requirements:        EnvVarRequirement:          envDef:            MESSAGE: override_valueOverrides can be specified either on the command line, or as part of the jobinput document.  Workflow steps are identified using the name of the workflowfile followed by the step name as a document fragment identifier &quot;#id&quot;.Override identifiers are relative to the top-level workflow document... code:: bash  cwltool --overrides overrides.yml my-tool.cwl my-job.yml.. code:: yaml  input_parameter1: value1  input_parameter2: value2  cwltool:overrides:    workflow.cwl#step1:      requirements:        EnvVarRequirement:          envDef:            MESSAGE: override_value.. code:: bash  cwltool my-tool.cwl my-job-with-overrides.ymlCombining parts of a workflow into a single document====================================================Use ``--pack`` to combine a workflow made up of multiple files into asingle compound document.  This operation takes all the CWL filesreferenced by a workflow and builds a new CWL document with allProcess objects (CommandLineTool and Workflow) in a list in the``$graph`` field.  Cross references (such as ``run:`` and ``source:``fields) are updated to internal references within the new packeddocument.  The top-level workflow is named ``#main``... code:: bash  cwltool --pack my-wf.cwl &gt; my-packed-wf.cwlRunning only part of a workflow===============================You can run a partial workflow with the ``--target`` (``-t``) option.  Thistakes the name of an output parameter, workflow step, or inputparameter in the top-level workflow.  You may provide multipletargets... code:: bash  cwltool --target step3 my-wf.cwlIf a target is an output parameter, it will only run only the stepsthat contribute to that output.  If a target is a workflow step, itwill run the workflow starting from that step.  If a target is aninput parameter, it will only run the steps connected tothat input.Use ``--print-targets`` to get a listing of the targets of a workflow.To see which steps will run, use ``--print-subgraph`` with``--target`` to get a printout of the workflow subgraph for theselected targets... code:: bash  cwltool --print-targets my-wf.cwl  cwltool --target step3 --print-subgraph my-wf.cwl &gt; my-wf-starting-from-step3.cwlVisualizing a CWL document==========================The ``--print-dot`` option will print a file suitable for Graphviz ``dot`` program.  Here is a bash onliner to generate a Scalable Vector Graphic (SVG) file:.. code:: bash  cwltool --print-dot my-wf.cwl | dot -Tsvg &gt; my-wf.svgModeling a CWL document as RDF==============================CWL documents can be expressed as RDF triple graphs... code:: bash  cwltool --print-rdf --rdf-serializer=turtle mywf.cwlEnvironment Variables in cwltool================================This reference implementation supports several ways of settingenvironment variables for tools, in addition to the standard``EnvVarRequirement``. The sequence of steps applied to create theenvironment is:0. If the ``--preserve-entire-environment`` flag is present, then begin with the current   environment, else begin with an empty environment.1. Add any variables specified by ``--preserve-environment`` option(s).2. Set ``TMPDIR`` and ``HOME`` per `the CWL v1.0+ CommandLineTool specification &lt;https://www.commonwl.org/v1.0/CommandLineTool.html#Runtime_environment&gt;`_.3. Apply any ``EnvVarRequirement`` from the ``CommandLineTool`` description.4. Apply any manipulations required by any ``cwltool:MPIRequirement`` extensions.5. Substitute any secrets required by ``Secrets`` extension.6. Modify the environment in response to ``SoftwareRequirement`` (see below).Leveraging SoftwareRequirements (Beta)--------------------------------------CWL tools may be decorated with ``SoftwareRequirement`` hints that cwltoolmay in turn use to resolve to packages in various package managers ordependency management systems such as `Environment Modules&lt;http://modules.sourceforge.net/&gt;`__.Utilizing ``SoftwareRequirement`` hints using cwltool requires an optionaldependency, for this reason be sure to use specify the ``deps`` modifier wheninstalling cwltool. For instance::  $ pip install 'cwltool[deps]'Installing cwltool in this fashion enables several new command line options.The most general of these options is ``--beta-dependency-resolvers-configuration``.This option allows one to specify a dependency resolver's configuration file.This file may be specified as either XML or YAML and very simply describes variousplugins to enable to &quot;resolve&quot; ``SoftwareRequirement`` dependencies.Using these hints will allow cwltool to modify the environment inwhich your tool runs, for example by loading one or more EnvironmentModules. The environment is constructed as above, then the environmentmay modified by the selected tool resolver.  This currently means thatyou cannot override any environment variables set by the selected toolresolver. Note that the environment given to the configured dependencyresolver has the variable `_CWLTOOL` set to `1` to allow introspection.To discuss some of these plugins and how to configure them, first consider thefollowing ``hint`` definition for an example CWL tool... code:: yaml  SoftwareRequirement:    packages:    - package: seqtk      version:      - r93Now imagine deploying cwltool on a cluster with Software Modules installedand that a ``seqtk`` module is available at version ``r93``. This means clusterusers likely won't have the binary ``seqtk`` on their ``PATH`` by default, but aftersourcing this module with the command ``modulecmd sh load seqtk/r93`` ``seqtk`` isavailable on the ``PATH``. A simple dependency resolvers configuration file, called``dependency-resolvers-conf.yml`` for instance, that would enable cwltool to sourcethe correct module environment before executing the above tool would simply be:.. code:: yaml  - type: modulesThe outer list indicates that one plugin is being enabled, the plugin parameters aredefined as a dictionary for this one list item. There is only one required parameterfor the plugin above, this is ``type`` and defines the plugin type. This parameteris required for all plugins. The available plugins and the parametersavailable for each are documented (incompletely) `here&lt;https://docs.galaxyproject.org/en/latest/admin/dependency_resolvers.html&gt;`__.Unfortunately, this documentation is in the context of Galaxy tool``requirement`` s instead of CWL ``SoftwareRequirement`` s, but the concepts map fairly directly.cwltool is distributed with an example of such seqtk tool and sample correspondingjob. It could executed from the cwltool root using a dependency resolversconfiguration file such as the above one using the command::  cwltool --beta-dependency-resolvers-configuration /path/to/dependency-resolvers-conf.yml \      tests/seqtk_seq.cwl \      tests/seqtk_seq_job.jsonThis example demonstrates both that cwltool can leverageexisting software installations and also handle workflows with dependencieson different versions of the same software and libraries. However the aboveexample does require an existing module setup so it is impossible to test this example&quot;out of the box&quot; with cwltool. For a more isolated test that demonstrates allthe same concepts - the resolver plugin type ``galaxy_packages`` can be used.&quot;Galaxy packages&quot; are a lighter-weight alternative to Environment Modules that arereally just defined by a way to lay out directories into packages and versionsto find little scripts that are sourced to modify the environment. They havebeen used for years in Galaxy community to adapt Galaxy tools to clusterenvironments but require neither knowledge of Galaxy nor any special tools tosetup. These should work just fine for CWL tools.The cwltool source code repository's test directory is setup with a very simpledirectory that defines a set of &quot;Galaxy  packages&quot; (but really just defines onepackage named ``random-lines``). The directory layout is simply::  tests/test_deps_env/    random-lines/      1.0/        env.shIf the ``galaxy_packages`` plugin is enabled and pointed at the``tests/test_deps_env`` directory in cwltool's root and a ``SoftwareRequirement``such as the following is encountered... code:: yaml  hints:    SoftwareRequirement:      packages:      - package: 'random-lines'        version:        - '1.0'Then cwltool will simply find that ``env.sh`` file and source it before executingthe corresponding tool. That ``env.sh`` script is only responsible for modifyingthe job's ``PATH`` to add the required binaries.This is a full example that works since resolving &quot;Galaxy packages&quot; has noexternal requirements. Try it out by executing the following command from cwltool'sroot directory::  cwltool --beta-dependency-resolvers-configuration tests/test_deps_env_resolvers_conf.yml \      tests/random_lines.cwl \      tests/random_lines_job.jsonThe resolvers configuration file in the above example was simply:.. code:: yaml  - type: galaxy_packages    base_path: ./tests/test_deps_envIt is possible that the ``SoftwareRequirement`` s in a given CWL tool will notmatch the module names for a given cluster. Such requirements can be re-mappedto specific deployed packages or versions using another file specified usingthe resolver plugin parameter `mapping_files`. We willdemonstrate this using `galaxy_packages,` but the concepts apply equally wellto Environment Modules or Conda packages (described below), for instance.So consider the resolvers configuration file.(`tests/test_deps_env_resolvers_conf_rewrite.yml`):.. code:: yaml  - type: galaxy_packages    base_path: ./tests/test_deps_env    mapping_files: ./tests/test_deps_mapping.ymlAnd the corresponding mapping configuration file (`tests/test_deps_mapping.yml`):.. code:: yaml  - from:      name: randomLines      version: 1.0.0-rc1    to:      name: random-lines      version: '1.0'This is saying if cwltool encounters a requirement of ``randomLines`` at version``1.0.0-rc1`` in a tool, to rewrite to our specific plugin as ``random-lines`` atversion ``1.0``. cwltool has such a test tool called ``random_lines_mapping.cwl``that contains such a source ``SoftwareRequirement``. To try out this example withmapping, execute the following command from the cwltool root directory::  cwltool --beta-dependency-resolvers-configuration tests/test_deps_env_resolvers_conf_rewrite.yml \      tests/random_lines_mapping.cwl \      tests/random_lines_job.jsonThe previous examples demonstrated leveraging existing infrastructure toprovide requirements for CWL tools. If instead a real package manager is usedcwltool has the opportunity to install requirements as needed. While initialsupport for Homebrew/Linuxbrew plugins is available, the most developed suchplugin is for the `Conda &lt;https://conda.io/docs/#&gt;`__ package manager. Conda has the nice propertiesof allowing multiple versions of a package to be installed simultaneously,not requiring evaluated permissions to install Conda itself or packages usingConda, and being cross-platform. For these reasons, cwltool may run as a normaluser, install its own Conda environment and manage multiple versions of Conda packageson Linux and Mac OS X.The Conda plugin can be endlessly configured, but a sensible set of defaultsthat has proven a powerful stack for dependency management within the Galaxy tooldevelopment ecosystem can be enabled by simply passing cwltool the``--beta-conda-dependencies`` flag.With this, we can use the seqtk example above without Docker or any externally managed services - cwltool should install everything it needsand create an environment for the tool. Try it out with the following command::  cwltool --beta-conda-dependencies tests/seqtk_seq.cwl tests/seqtk_seq_job.jsonThe CWL specification allows URIs to be attached to ``SoftwareRequirement`` sthat allow disambiguation of package names. If the mapping files described aboveallow deployers to adapt tools to their infrastructure, this mechanism allowstools to adapt their requirements to multiple package managers. To demonstratethis within the context of the seqtk, we can simply break the package name weuse and then specify a specific Conda package as follows:.. code:: yaml  hints:    SoftwareRequirement:      packages:      - package: seqtk_seq        version:        - '1.2'        specs:        - https://anaconda.org/bioconda/seqtk        - https://packages.debian.org/sid/seqtkThe example can be executed using the command::  cwltool --beta-conda-dependencies tests/seqtk_seq_wrong_name.cwl tests/seqtk_seq_job.jsonThe plugin framework for managing the resolution of these software requirementsas maintained as part of `galaxy-tool-util &lt;https://github.com/galaxyproject/galaxy/tree/dev/packages/tool_util&gt;`__ - a small,portable subset of the Galaxy project. More information on configuration and implementation can be foundat the following links:- `Dependency Resolvers in Galaxy &lt;https://docs.galaxyproject.org/en/latest/admin/dependency_resolvers.html&gt;`__- `Conda for [Galaxy] Tool Dependencies &lt;https://docs.galaxyproject.org/en/latest/admin/conda_faq.html&gt;`__- `Mapping Files - Implementation &lt;https://github.com/galaxyproject/galaxy/commit/495802d229967771df5b64a2f79b88a0eaf00edb&gt;`__- `Specifications - Implementation &lt;https://github.com/galaxyproject/galaxy/commit/81d71d2e740ee07754785306e4448f8425f890bc&gt;`__- `Initial cwltool Integration Pull Request &lt;https://github.com/common-workflow-language/cwltool/pull/214&gt;`__Use with GA4GH Tool Registry API================================Cwltool can launch tools directly from `GA4GH Tool Registry API`_ endpoints.By default, cwltool searches https://dockstore.org/ .  Use ``--add-tool-registry`` to add other registries to the search path.For example ::  cwltool quay.io/collaboratory/dockstore-tool-bamstats:develop test.jsonand (defaults to latest when a version is not specified) ::  cwltool quay.io/collaboratory/dockstore-tool-bamstats test.jsonFor this example, grab the test.json (and input file) from https://github.com/CancerCollaboratory/dockstore-tool-bamstats ::  wget https://dockstore.org/api/api/ga4gh/v2/tools/quay.io%2Fbriandoconnor%2Fdockstore-tool-bamstats/versions/develop/PLAIN-CWL/descriptor/test.json  wget https://github.com/CancerCollaboratory/dockstore-tool-bamstats/raw/develop/rna.SRR948778.bam.. _`GA4GH Tool Registry API`: https://github.com/ga4gh/tool-registry-schemasRunning MPI-based tools that need to be launched================================================Cwltool supports an extension to the CWL spec``http://commonwl.org/cwltool#MPIRequirement``. When the tooldefinition has this in its ``requirements``/``hints`` section, andcwltool has been run with ``--enable-ext``, then the tool's commandline will be extended with the commands needed to launch it with``mpirun`` or similar. You can specify the number of processes tostart as either a literal integer or an expression (that will resultin an integer). For example::  #!/usr/bin/env cwl-runner  cwlVersion: v1.1  class: CommandLineTool  $namespaces:    cwltool: &quot;http://commonwl.org/cwltool#&quot;  requirements:    cwltool:MPIRequirement:      processes: $(inputs.nproc)  inputs:    nproc:      type: intInteraction with containers: the MPIRequirement currently prepends itscommands to the front of the command line that is constructed. If youwish to run a containerized application in parallel, for simple usecases, this does work with Singularity, depending upon the platformsetup. However, this combination should be considered &quot;alpha&quot; -- pleasedo report any issues you have! This does not work with Docker at themoment. (More precisely, you get `n` copies of the same single processimage run at the same time that cannot communicate with each other.)The host-specific parameters are configured in a simple YAML file(specified with the ``--mpi-config-file`` flag). The allowed keys aregiven in the following table; all are optional.+----------------+------------------+----------+------------------------------+| Key            | Type             | Default  | Description                  |+================+==================+==========+==============================+| runner         | str              | &quot;mpirun&quot; | The primary command to use.  |+----------------+------------------+----------+------------------------------+| nproc_flag     | str              | &quot;-n&quot;     | Flag to set number of        ||                |                  |          | processes to start.          |+----------------+------------------+----------+------------------------------+| default_nproc  | int              | 1        | Default number of processes. |+----------------+------------------+----------+------------------------------+| extra_flags    | List[str]        | []       | A list of any other flags to ||                |                  |          | be added to the runner's     ||                |                  |          | command line before          ||                |                  |          | the ``baseCommand``.         |+----------------+------------------+----------+------------------------------+| env_pass       | List[str]        | []       | A list of environment        ||                |                  |          | variables that should be     ||                |                  |          | passed from the host         ||                |                  |          | environment through to the   ||                |                  |          | tool (e.g., giving the       ||                |                  |          | node list as set by your     ||                |                  |          | scheduler).                  |+----------------+------------------+----------+------------------------------+| env_pass_regex | List[str]        | []       | A list of python regular     ||                |                  |          | expressions that will be     ||                |                  |          | matched against the host's   ||                |                  |          | environment. Those that match||                |                  |          | will be passed through.      |+----------------+------------------+----------+------------------------------+| env_set        | Mapping[str,str] | {}       | A dictionary whose keys are  ||                |                  |          | the environment variables set||                |                  |          | and the values being the     ||                |                  |          | values.                      |+----------------+------------------+----------+------------------------------+Enabling Fast Parser (experimental)===================================For very large workflows, `cwltool` can spend a lot of time ininitialization, before the first step runs.  There is an experimentalflag ``--fast-parser`` which can dramatically reduce theinitialization overhead, however as of this writing it has several limitations:- Error reporting in general is worse than the standard parser, you will want to use it with workflows that you know are already correct.- It does not check for dangling links (these will become runtime errors instead of loading errors)- Several other cases fail, as documented in https://github.com/common-workflow-language/cwltool/pull/1720***********Development***********Running tests locally=====================-  Running basic tests ``(/tests)``:To run the basic tests after installing `cwltool` execute the following:.. code:: bash  pip install -rtest-requirements.txt  pytest   ## N.B. This requires node.js or docker to be availableTo run various tests in all supported Python environments, we use `tox &lt;https://github.com/common-workflow-language/cwltool/tree/main/tox.ini&gt;`_. To run the test suite in all supported Python environmentsfirst clone the complete code repository (see the ``git clone`` instructions above) and then runthe following in the terminal:``pip install &quot;tox&lt;4&quot;; tox -p``List of all environment can be seen using:``tox --listenvs``and running a specific test env using:``tox -e &lt;env name&gt;``and additionally run a specific test using this format:``tox -e py310-unit -- -v tests/test_examples.py::test_scandeps``-  Running the entire suite of CWL conformance tests:The GitHub repository for the CWL specifications contains a script that tests a CWLimplementation against a wide array of valid CWL files using the `cwltest &lt;https://github.com/common-workflow-language/cwltest&gt;`_programInstructions for running these tests can be found in the Common Workflow Language Specification repository at https://github.com/common-workflow-language/common-workflow-language/blob/main/CONFORMANCE_TESTS.md .Import as a module==================Add.. code:: python  import cwltoolto your script.The easiest way to use cwltool to run a tool or workflow from Python is to use a Factory.. code:: python  import cwltool.factory  fac = cwltool.factory.Factory()  echo = fac.make(&quot;echo.cwl&quot;)  result = echo(inp=&quot;foo&quot;)  # result[&quot;out&quot;] == &quot;foo&quot;CWL Tool Control Flow=====================Technical outline of how cwltool works internally, for maintainers.#. Use CWL ``load_tool()`` to load document.   #. Fetches the document from file or URL   #. Applies preprocessing (syntax/identifier expansion and normalization)   #. Validates the document based on cwlVersion   #. If necessary, updates the document to the latest spec   #. Constructs a Process object using ``make_tool()``` callback.  This yields a      CommandLineTool, Workflow, or ExpressionTool.  For workflows, this      recursively constructs each workflow step.   #. To construct custom types for CommandLineTool, Workflow, or      ExpressionTool, provide a custom ``make_tool()``#. Iterate on the ``job()`` method of the Process object to get back runnable jobs.   #. ``job()`` is a generator method (uses the Python iterator protocol)   #. Each time the ``job()`` method is invoked in an iteration, it returns one      of: a runnable item (an object with a ``run()`` method), ``None`` (indicating      there is currently no work ready to run) or end of iteration (indicating      the process is complete.)   #. Invoke the runnable item by calling ``run()``.  This runs the tool and gets output.   #. An output callback reports the output of a process.   #. ``job()`` may be iterated over multiple times.  It will yield all the work      that is currently ready to run and then yield None.#. ``Workflow`` objects create a corresponding ``WorkflowJob`` and ``WorkflowJobStep`` objects to hold the workflow state for the duration of the job invocation.   #. The WorkflowJob iterates over each WorkflowJobStep and determines if the      inputs the step are ready.   #. When a step is ready, it constructs an input object for that step and      iterates on the ``job()`` method of the workflow job step.   #. Each runnable item is yielded back up to top-level run loop   #. When a step job completes and receives an output callback, the      job outputs are assigned to the output of the workflow step.   #. When all steps are complete, the intermediate files are moved to a final      workflow output, intermediate directories are deleted, and the workflow's output callback is called.#. ``CommandLineTool`` job() objects yield a single runnable object.   #. The CommandLineTool ``job()`` method calls ``make_job_runner()`` to create a      ``CommandLineJob`` object   #. The job method configures the CommandLineJob object by setting public      attributes   #. The job method iterates over file and directories inputs to the      CommandLineTool and creates a &quot;path map&quot;.   #. Files are mapped from their &quot;resolved&quot; location to a &quot;target&quot; path where      they will appear at tool invocation (for example, a location inside a      Docker container.)  The target paths are used on the command line.   #. Files are staged to targets paths using either Docker volume binds (when      using containers) or symlinks (if not).  This staging step enables files      to be logically rearranged or renamed independent of their source layout.   #. The ``run()`` method of CommandLineJob executes the command line tool or      Docker container, waits for it to complete, collects output, and makes      the output callback.Extension points================The following functions can be passed to main() to override or augmentthe listed behaviors.executor  ::    executor(tool, job_order_object, runtimeContext, logger)      (Process, Dict[Text, Any], RuntimeContext) -&gt; Tuple[Dict[Text, Any], Text]  An implementation of the top-level workflow execution loop should  synchronously run a process object to completion and return the  output object.versionfunc  ::    ()      () -&gt; Text  Return version string.logger_handler  ::    logger_handler      logging.Handler  Handler object for logging.The following functions can be set in LoadingContext to override oraugment the listed behaviors.fetcher_constructor  ::    fetcher_constructor(cache, session)      (Dict[unicode, unicode], requests.sessions.Session) -&gt; Fetcher  Construct a Fetcher object with the supplied cache and HTTP session.resolver  ::    resolver(document_loader, document)      (Loader, Union[Text, dict[Text, Any]]) -&gt; Text  Resolve a relative document identifier to an absolute one that can be fetched.The following functions can be set in RuntimeContext to override oraugment the listed behaviors.construct_tool_object  ::    construct_tool_object(toolpath_object, loadingContext)      (MutableMapping[Text, Any], LoadingContext) -&gt; Process  Hook to construct a Process object (eg CommandLineTool) object from a document.select_resources  ::    selectResources(request)      (Dict[str, int], RuntimeContext) -&gt; Dict[Text, int]  Take a resource request and turn it into a concrete resource assignment.make_fs_access  ::    make_fs_access(basedir)      (Text) -&gt; StdFsAccess  Return a file system access object.In addition, when providing custom subclasses of Process objects, you can override the following methods:CommandLineTool.make_job_runner  ::    make_job_runner(RuntimeContext)      (RuntimeContext) -&gt; Type[JobBase]  Create and return a job runner object (this implements concrete execution of a command line tool).Workflow.make_workflow_step  ::    make_workflow_step(toolpath_object, pos, loadingContext, parentworkflowProv)      (Dict[Text, Any], int, LoadingContext, Optional[ProvenanceProfile]) -&gt; WorkflowStep  Create and return a workflow step object.</longdescription>
</pkgmetadata>