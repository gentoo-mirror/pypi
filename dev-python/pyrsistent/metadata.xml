<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Pyrsistent==========.. image:: https://github.com/tobgu/pyrsistent/actions/workflows/tests.yaml/badge.svg    :target: https://github.com/tobgu/pyrsistent/actions/workflows/tests.yaml.. _Pyrthon: https://www.github.com/tobgu/pyrthon.. _Pyrsistent_extras: https://github.com/mingmingrr/pyrsistent-extrasPyrsistent is a number of persistent collections (by some referred to as functional data structures). Persistent inthe sense that they are immutable.All methods on a data structure that would normally mutate it instead return a new copy of the structure containing therequested updates. The original structure is left untouched.This will simplify the reasoning about what a program does since no hidden side effects ever can take place to thesedata structures. You can rest assured that the object you hold a reference to will remain the same throughout itslifetime and need not worry that somewhere five stack levels below you in the darkest corner of your applicationsomeone has decided to remove that element that you expected to be there.Pyrsistent is influenced by persistent data structures such as those found in the standard library of Clojure. Thedata structures are designed to share common elements through path copying.It aims at taking these concepts and make them as pythonic as possible so that they can be easily integrated into any pythonprogram without hassle.If you want use literal syntax to define them in your code ratherthan function calls check out Pyrthon_. Be aware, that one is experimental, unmaintained and alpha software. If you cannot find the persistent data structure you're looking for here you may want to take a look atPyrsistent_extras_ which is maintained by @mingmingrr. If you still don't find what you're looking for pleaseopen an issue for discussion. If we agree that functionality is missing you may want to go ahead and createa Pull Request implement the missing functionality.Examples--------.. _Sequence: collections_.. _Hashable: collections_.. _Mapping: collections_.. _Mappings: collections_.. _Set: collections_.. _collections: https://docs.python.org/3/library/collections.abc.html.. _documentation: http://pyrsistent.readthedocs.org/The collection types and key features currently implemented are:* PVector_, similar to a python list* PMap_, similar to dict* PSet_, similar to set* PRecord_, a PMap on steroids with fixed fields, optional type and invariant checking and much more* PClass_, a Python class fixed fields, optional type and invariant checking and much more* `Checked collections`_, PVector, PMap and PSet with optional type and invariance checks and more* PBag, similar to collections.Counter* PList, a classic singly linked list* PDeque, similar to collections.deque* Immutable object type (immutable) built on the named tuple* freeze_ and thaw_ functions to convert between pythons standard collections and pyrsistent collections.* Flexible transformations_ of arbitrarily complex structures built from PMaps and PVectors.Below are examples of common usage patterns for some of the structures and features. More information andfull documentation for all data structures is available in the documentation_... _PVector:PVector~~~~~~~With full support for the Sequence_ protocol PVector is meant as a drop in replacement to the built in list from a readerspoint of view. Write operations of course differ since no in place mutation is done but naming should be in linewith corresponding operations on the built in list.Support for the Hashable_ protocol also means that it can be used as key in Mappings_.Appends are amortized O(1). Random access and insert is log32(n) where n is the size of the vector... code:: python    &gt;&gt;&gt; from pyrsistent import v, pvector    # No mutation of vectors once created, instead they    # are &quot;evolved&quot; leaving the original untouched    &gt;&gt;&gt; v1 = v(1, 2, 3)    &gt;&gt;&gt; v2 = v1.append(4)    &gt;&gt;&gt; v3 = v2.set(1, 5)    &gt;&gt;&gt; v1    pvector([1, 2, 3])    &gt;&gt;&gt; v2    pvector([1, 2, 3, 4])    &gt;&gt;&gt; v3    pvector([1, 5, 3, 4])    # Random access and slicing    &gt;&gt;&gt; v3[1]    5    &gt;&gt;&gt; v3[1:3]    pvector([5, 3])    # Iteration    &gt;&gt;&gt; list(x + 1 for x in v3)    [2, 6, 4, 5]    &gt;&gt;&gt; pvector(2 * x for x in range(3))    pvector([0, 2, 4]).. _PMap:PMap~~~~With full support for the Mapping_ protocol PMap is meant as a drop in replacement to the built in dict from a readers pointof view. Support for the Hashable_ protocol also means that it can be used as key in other Mappings_.Random access and insert is log32(n) where n is the size of the map... code:: python    &gt;&gt;&gt; from pyrsistent import m, pmap, v    # No mutation of maps once created, instead they are    # &quot;evolved&quot; leaving the original untouched    &gt;&gt;&gt; m1 = m(a=1, b=2)    &gt;&gt;&gt; m2 = m1.set('c', 3)    &gt;&gt;&gt; m3 = m2.set('a', 5)    &gt;&gt;&gt; m1    pmap({'a': 1, 'b': 2})    &gt;&gt;&gt; m2    pmap({'a': 1, 'c': 3, 'b': 2})    &gt;&gt;&gt; m3    pmap({'a': 5, 'c': 3, 'b': 2})    &gt;&gt;&gt; m3['a']    5    # Evolution of nested persistent structures    &gt;&gt;&gt; m4 = m(a=5, b=6, c=v(1, 2))    &gt;&gt;&gt; m4.transform(('c', 1), 17)    pmap({'a': 5, 'c': pvector([1, 17]), 'b': 6})    &gt;&gt;&gt; m5 = m(a=1, b=2)    # Evolve by merging with other mappings    &gt;&gt;&gt; m5.update(m(a=2, c=3), {'a': 17, 'd': 35})    pmap({'a': 17, 'c': 3, 'b': 2, 'd': 35})    &gt;&gt;&gt; pmap({'x': 1, 'y': 2}) + pmap({'y': 3, 'z': 4})    pmap({'y': 3, 'x': 1, 'z': 4})    # Dict-like methods to convert to list and iterate    &gt;&gt;&gt; m3.items()    pvector([('a', 5), ('c', 3), ('b', 2)])    &gt;&gt;&gt; list(m3)    ['a', 'c', 'b'].. _PSet:PSet~~~~With full support for the Set_ protocol PSet is meant as a drop in replacement to the built in set from a readers pointof view. Support for the Hashable_ protocol also means that it can be used as key in Mappings_.Random access and insert is log32(n) where n is the size of the set... code:: python    &gt;&gt;&gt; from pyrsistent import s    # No mutation of sets once created, you know the story...    &gt;&gt;&gt; s1 = s(1, 2, 3, 2)    &gt;&gt;&gt; s2 = s1.add(4)    &gt;&gt;&gt; s3 = s1.remove(1)    &gt;&gt;&gt; s1    pset([1, 2, 3])    &gt;&gt;&gt; s2    pset([1, 2, 3, 4])    &gt;&gt;&gt; s3    pset([2, 3])    # Full support for set operations    &gt;&gt;&gt; s1 | s(3, 4, 5)    pset([1, 2, 3, 4, 5])    &gt;&gt;&gt; s1 &amp; s(3, 4, 5)    pset([3])    &gt;&gt;&gt; s1 &lt; s2    True    &gt;&gt;&gt; s1 &lt; s(3, 4, 5)    False.. _PRecord:PRecord~~~~~~~A PRecord is a PMap with a fixed set of specified fields. Records are declared as python classes inheritingfrom PRecord. Because it is a PMap it has full support for all Mapping methods such as iteration and elementaccess using subscript notation... code:: python    &gt;&gt;&gt; from pyrsistent import PRecord, field    &gt;&gt;&gt; class ARecord(PRecord):    ...     x = field()    ...    &gt;&gt;&gt; r = ARecord(x=3)    &gt;&gt;&gt; r    ARecord(x=3)    &gt;&gt;&gt; r.x    3    &gt;&gt;&gt; r.set(x=2)    ARecord(x=2)    &gt;&gt;&gt; r.set(y=2)    Traceback (most recent call last):    AttributeError: 'y' is not among the specified fields for ARecordType information****************It is possible to add type information to the record to enforce type checks. Multiple allowed types can be specifiedby providing an iterable of types... code:: python    &gt;&gt;&gt; class BRecord(PRecord):    ...     x = field(type=int)    ...     y = field(type=(int, type(None)))    ...    &gt;&gt;&gt; BRecord(x=3, y=None)    BRecord(y=None, x=3)    &gt;&gt;&gt; BRecord(x=3.0)    Traceback (most recent call last):    PTypeError: Invalid type for field BRecord.x, was floatCustom types (classes) that are iterable should be wrapped in a tuple to prevent theirmembers being added to the set of valid types.  Although Enums in particular are nowsupported without wrapping, see #83 for more information.Mandatory fields****************Fields are not mandatory by default but can be specified as such. If fields are missing an*InvariantException* will be thrown which contains information about the missing fields... code:: python    &gt;&gt;&gt; from pyrsistent import InvariantException    &gt;&gt;&gt; class CRecord(PRecord):    ...     x = field(mandatory=True)    ...    &gt;&gt;&gt; r = CRecord(x=3)    &gt;&gt;&gt; try:    ...    r.discard('x')    ... except InvariantException as e:    ...    print(e.missing_fields)    ...    ('CRecord.x',)Invariants**********It is possible to add invariants that must hold when evolving the record. Invariants can bespecified on both field and record level. If invariants fail an *InvariantException* will bethrown which contains information about the failing invariants. An invariant function shouldreturn a tuple consisting of a boolean that tells if the invariant holds or not and an objectdescribing the invariant. This object can later be used to identify which invariant that failed.The global invariant function is only executed if all field invariants hold.Global invariants are inherited to subclasses... code:: python    &gt;&gt;&gt; class RestrictedVector(PRecord):    ...     __invariant__ = lambda r: (r.y &gt;= r.x, 'x larger than y')    ...     x = field(invariant=lambda x: (x &gt; 0, 'x negative'))    ...     y = field(invariant=lambda y: (y &gt; 0, 'y negative'))    ...    &gt;&gt;&gt; r = RestrictedVector(y=3, x=2)    &gt;&gt;&gt; try:    ...    r.set(x=-1, y=-2)    ... except InvariantException as e:    ...    print(e.invariant_errors)    ...    ('y negative', 'x negative')    &gt;&gt;&gt; try:    ...    r.set(x=2, y=1)    ... except InvariantException as e:    ...    print(e.invariant_errors)    ...    ('x larger than y',)Invariants may also contain multiple assertions. For those cases the invariant function shouldreturn a tuple of invariant tuples as described above. This structure is reflected in theinvariant_errors attribute of the exception which will contain tuples with data from all failedinvariants. Eg:.. code:: python    &gt;&gt;&gt; class EvenX(PRecord):    ...     x = field(invariant=lambda x: ((x &gt; 0, 'x negative'), (x % 2 == 0, 'x odd')))    ...    &gt;&gt;&gt; try:    ...    EvenX(x=-1)    ... except InvariantException as e:    ...    print(e.invariant_errors)    ...    (('x negative', 'x odd'),)Factories*********It's possible to specify factory functions for fields. The factory function receives whateveris supplied as field value and the actual returned by the factory is assigned to the fieldgiven that any type and invariant checks hold.PRecords have a default factory specified as a static function on the class, create(). It takesa *Mapping* as argument and returns an instance of the specific record.If a record has fields of type PRecord the create() method of that record willbe called to create the &quot;sub record&quot; if no factory has explicitly been specified to overridethis behaviour... code:: python    &gt;&gt;&gt; class DRecord(PRecord):    ...     x = field(factory=int)    ...    &gt;&gt;&gt; class ERecord(PRecord):    ...     d = field(type=DRecord)    ...    &gt;&gt;&gt; ERecord.create({'d': {'x': '1'}})    ERecord(d=DRecord(x=1))Collection fields*****************It is also possible to have fields with ``pyrsistent`` collections... code:: python   &gt;&gt;&gt; from pyrsistent import pset_field, pmap_field, pvector_field   &gt;&gt;&gt; class MultiRecord(PRecord):   ...     set_of_ints = pset_field(int)   ...     map_int_to_str = pmap_field(int, str)   ...     vector_of_strs = pvector_field(str)   ...Serialization*************PRecords support serialization back to dicts. Default serialization will take keys and values&quot;as is&quot; and output them into a dict. It is possible to specify custom serialization functionsto take care of fields that require special treatment... code:: python    &gt;&gt;&gt; from datetime import date    &gt;&gt;&gt; class Person(PRecord):    ...     name = field(type=unicode)    ...     birth_date = field(type=date,    ...                        serializer=lambda format, d: d.strftime(format['date']))    ...    &gt;&gt;&gt; john = Person(name=u'John', birth_date=date(1985, 10, 21))    &gt;&gt;&gt; john.serialize({'date': '%Y-%m-%d'})    {'birth_date': '1985-10-21', 'name': u'John'}.. _instar: https://github.com/boxed/instar/.. _PClass:PClass~~~~~~A PClass is a python class with a fixed set of specified fields. PClasses are declared as python classes inheritingfrom PClass. It is defined the same way that PRecords are and behaves like a PRecord in all aspects except that itis not a PMap and hence not a collection but rather a plain Python object... code:: python    &gt;&gt;&gt; from pyrsistent import PClass, field    &gt;&gt;&gt; class AClass(PClass):    ...     x = field()    ...    &gt;&gt;&gt; a = AClass(x=3)    &gt;&gt;&gt; a    AClass(x=3)    &gt;&gt;&gt; a.x    3Checked collections~~~~~~~~~~~~~~~~~~~Checked collections currently come in three flavors: CheckedPVector, CheckedPMap and CheckedPSet... code:: python    &gt;&gt;&gt; from pyrsistent import CheckedPVector, CheckedPMap, CheckedPSet, thaw    &gt;&gt;&gt; class Positives(CheckedPSet):    ...     __type__ = (long, int)    ...     __invariant__ = lambda n: (n &gt;= 0, 'Negative')    ...    &gt;&gt;&gt; class Lottery(PRecord):    ...     name = field(type=str)    ...     numbers = field(type=Positives, invariant=lambda p: (len(p) &gt; 0, 'No numbers'))    ...    &gt;&gt;&gt; class Lotteries(CheckedPVector):    ...     __type__ = Lottery    ...    &gt;&gt;&gt; class LotteriesByDate(CheckedPMap):    ...     __key_type__ = date    ...     __value_type__ = Lotteries    ...    &gt;&gt;&gt; lotteries = LotteriesByDate.create({date(2015, 2, 15): [{'name': 'SuperLotto', 'numbers': {1, 2, 3}},    ...                                                         {'name': 'MegaLotto',  'numbers': {4, 5, 6}}],    ...                                     date(2015, 2, 16): [{'name': 'SuperLotto', 'numbers': {3, 2, 1}},    ...                                                         {'name': 'MegaLotto',  'numbers': {6, 5, 4}}]})    &gt;&gt;&gt; lotteries    LotteriesByDate({datetime.date(2015, 2, 15): Lotteries([Lottery(numbers=Positives([1, 2, 3]), name='SuperLotto'), Lottery(numbers=Positives([4, 5, 6]), name='MegaLotto')]), datetime.date(2015, 2, 16): Lotteries([Lottery(numbers=Positives([1, 2, 3]), name='SuperLotto'), Lottery(numbers=Positives([4, 5, 6]), name='MegaLotto')])})    # The checked versions support all operations that the corresponding    # unchecked types do    &gt;&gt;&gt; lottery_0215 = lotteries[date(2015, 2, 15)]    &gt;&gt;&gt; lottery_0215.transform([0, 'name'], 'SuperDuperLotto')    Lotteries([Lottery(numbers=Positives([1, 2, 3]), name='SuperDuperLotto'), Lottery(numbers=Positives([4, 5, 6]), name='MegaLotto')])    # But also makes asserts that types and invariants hold    &gt;&gt;&gt; lottery_0215.transform([0, 'name'], 999)    Traceback (most recent call last):    PTypeError: Invalid type for field Lottery.name, was int    &gt;&gt;&gt; lottery_0215.transform([0, 'numbers'], set())    Traceback (most recent call last):    InvariantException: Field invariant failed    # They can be converted back to python built ins with either thaw()    # or serialize() (which provides possibilities to customize serialization)    &gt;&gt;&gt; thaw(lottery_0215)    [{'numbers': set([1, 2, 3]), 'name': 'SuperLotto'}, {'numbers': set([4, 5, 6]), 'name': 'MegaLotto'}]    &gt;&gt;&gt; lottery_0215.serialize()    [{'numbers': set([1, 2, 3]), 'name': 'SuperLotto'}, {'numbers': set([4, 5, 6]), 'name': 'MegaLotto'}].. _transformations:Transformations~~~~~~~~~~~~~~~Transformations are inspired by the cool library instar_ for Clojure. They let you evolve PMaps and PVectorswith arbitrarily deep/complex nesting using simple syntax and flexible matching syntax.The first argument to transformation is the path that points out the value to transform. Thesecond is the transformation to perform. If the transformation is callable it will be appliedto the value(s) matching the path. The path may also contain callables. In that case they aretreated as matchers. If the matcher returns True for a specific key it is considered for transformation... code:: python    # Basic examples    &gt;&gt;&gt; from pyrsistent import inc, freeze, thaw, rex, ny, discard    &gt;&gt;&gt; v1 = freeze([1, 2, 3, 4, 5])    &gt;&gt;&gt; v1.transform([2], inc)    pvector([1, 2, 4, 4, 5])    &gt;&gt;&gt; v1.transform([lambda ix: 0 &lt; ix &lt; 4], 8)    pvector([1, 8, 8, 8, 5])    &gt;&gt;&gt; v1.transform([lambda ix, v: ix == 0 or v == 5], 0)    pvector([0, 2, 3, 4, 0])    # The (a)ny matcher can be used to match anything    &gt;&gt;&gt; v1.transform([ny], 8)    pvector([8, 8, 8, 8, 8])    # Regular expressions can be used for matching    &gt;&gt;&gt; scores = freeze({'John': 12, 'Joseph': 34, 'Sara': 23})    &gt;&gt;&gt; scores.transform([rex('^Jo')], 0)    pmap({'Joseph': 0, 'Sara': 23, 'John': 0})    # Transformations can be done on arbitrarily deep structures    &gt;&gt;&gt; news_paper = freeze({'articles': [{'author': 'Sara', 'content': 'A short article'},    ...                                   {'author': 'Steve', 'content': 'A slightly longer article'}],    ...                      'weather': {'temperature': '11C', 'wind': '5m/s'}})    &gt;&gt;&gt; short_news = news_paper.transform(['articles', ny, 'content'], lambda c: c[:25] + '...' if len(c) &gt; 25 else c)    &gt;&gt;&gt; very_short_news = news_paper.transform(['articles', ny, 'content'], lambda c: c[:15] + '...' if len(c) &gt; 15 else c)    &gt;&gt;&gt; very_short_news.articles[0].content    'A short article'    &gt;&gt;&gt; very_short_news.articles[1].content    'A slightly long...'    # When nothing has been transformed the original data structure is kept    &gt;&gt;&gt; short_news is news_paper    True    &gt;&gt;&gt; very_short_news is news_paper    False    &gt;&gt;&gt; very_short_news.articles[0] is news_paper.articles[0]    True    # There is a special transformation that can be used to discard elements. Also    # multiple transformations can be applied in one call    &gt;&gt;&gt; thaw(news_paper.transform(['weather'], discard, ['articles', ny, 'content'], discard))    {'articles': [{'author': 'Sara'}, {'author': 'Steve'}]}Evolvers~~~~~~~~PVector, PMap and PSet all have support for a concept dubbed *evolvers*. An evolver acts like a mutableview of the underlying persistent data structure with &quot;transaction like&quot; semantics. No updates of the originaldata structure is ever performed, it is still fully immutable.The evolvers have a very limited API by design to discourage excessive, and inappropriate, usage as that wouldtake us down the mutable road. In principle only basic mutation and element access functions are supported.Check out the documentation_ of each data structure for specific examples.Examples of when you may want to use an evolver instead of working directly with the data structure include:* Multiple updates are done to the same data structure and the intermediate results are of no  interest. In this case using an evolver may be a more efficient and easier to work with.* You need to pass a vector into a legacy function or a function that you have no control  over which performs in place mutations. In this case pass an evolver instance  instead and then create a new pvector from the evolver once the function returns... code:: python    &gt;&gt;&gt; from pyrsistent import v    # In place mutation as when working with the built in counterpart    &gt;&gt;&gt; v1 = v(1, 2, 3)    &gt;&gt;&gt; e = v1.evolver()    &gt;&gt;&gt; e[1] = 22    &gt;&gt;&gt; e = e.append(4)    &gt;&gt;&gt; e = e.extend([5, 6])    &gt;&gt;&gt; e[5] += 1    &gt;&gt;&gt; len(e)    6    # The evolver is considered *dirty* when it contains changes compared to the underlying vector    &gt;&gt;&gt; e.is_dirty()    True    # But the underlying pvector still remains untouched    &gt;&gt;&gt; v1    pvector([1, 2, 3])    # Once satisfied with the updates you can produce a new pvector containing the updates.    # The new pvector will share data with the original pvector in the same way that would have    # been done if only using operations on the pvector.    &gt;&gt;&gt; v2 = e.persistent()    &gt;&gt;&gt; v2    pvector([1, 22, 3, 4, 5, 7])    # The evolver is now no longer considered *dirty* as it contains no differences compared to the    # pvector just produced.    &gt;&gt;&gt; e.is_dirty()    False    # You may continue to work with the same evolver without affecting the content of v2    &gt;&gt;&gt; e[0] = 11    # Or create a new evolver from v2. The two evolvers can be updated independently but will both    # share data with v2 where possible.    &gt;&gt;&gt; e2 = v2.evolver()    &gt;&gt;&gt; e2[0] = 1111    &gt;&gt;&gt; e.persistent()    pvector([11, 22, 3, 4, 5, 7])    &gt;&gt;&gt; e2.persistent()    pvector([1111, 22, 3, 4, 5, 7]).. _freeze:.. _thaw:freeze and thaw~~~~~~~~~~~~~~~These functions are great when your cozy immutable world has to interact with the evil mutable world outside... code:: python    &gt;&gt;&gt; from pyrsistent import freeze, thaw, v, m    &gt;&gt;&gt; freeze([1, {'a': 3}])    pvector([1, pmap({'a': 3})])    &gt;&gt;&gt; thaw(v(1, m(a=3)))    [1, {'a': 3}]By default, freeze will also recursively convert values inside PVectors and PMaps. This behaviour can be changed by providing freeze with the flag strict=False... code:: python    &gt;&gt;&gt; from pyrsistent import freeze, v, m    &gt;&gt;&gt; freeze(v(1, v(2, [3])))    pvector([1, pvector([2, pvector([3])])])    &gt;&gt;&gt; freeze(v(1, v(2, [3])), strict=False)    pvector([1, pvector([2, [3]])])    &gt;&gt;&gt; freeze(m(a=m(b={'c': 1})))    pmap({'a': pmap({'b': pmap({'c': 1})})})    &gt;&gt;&gt; freeze(m(a=m(b={'c': 1})), strict=False)    pmap({'a': pmap({'b': {'c': 1}})})In this regard, thaw operates as the inverse of freeze so will thaw values inside native data structures unless passed the strict=False flag.Compatibility-------------Pyrsistent is developed and tested on Python 3.7+ and PyPy3.Performance-----------Pyrsistent is developed with performance in mind. Still, while some operations are nearly on par with their built in,mutable, counterparts in terms of speed, other operations are slower. In the cases where attempts atoptimizations have been done, speed has generally been valued over space.Pyrsistent comes with two API compatible flavors of PVector (on which PMap and PSet are based), one pure Pythonimplementation and one implemented as a C extension. The latter generally being 2 - 20 times faster than the former.The C extension will be used automatically when possible.The pure python implementation is fully PyPy compatible. Running it under PyPy speeds operations up considerably ifthe structures are used heavily (if JITed), for some cases the performance is almost on par with the built in counterparts.Type hints----------PEP 561 style type hints for use with mypy and various editors are available for most types and functions in pyrsistent.Type classes for annotating your own code with pyrsistent types are also available under pyrsistent.typing.Installation------------pip install pyrsistentDocumentation-------------Available at http://pyrsistent.readthedocs.org/Brief presentation available at http://slides.com/tobiasgustafsson/immutability-and-python/Contributors------------Tobias Gustafsson https://github.com/tobguChristopher Armstrong https://github.com/radixAnders Hovmöller https://github.com/boxedItamar Turner-Trauring https://github.com/itamarstJonathan Lange https://github.com/jmlRichard Futrell https://github.com/FutrellJakob Hollenstein https://github.com/jkbjhDavid Honour https://github.com/foolswoodDavid R. MacIver https://github.com/DRMacIverMarcus Ewert https://github.com/sarum90Jean-Paul Calderone https://github.com/exarkunDouglas Treadwell https://github.com/douglas-treadwellTravis Parker https://github.com/teeparkJulian Berman https://github.com/JulianDennis Tomas https://github.com/dtomasNeil Vyas https://github.com/neilvyasdoozr https://github.com/doozrKamil Galuszka https://github.com/galuszkakTsuyoshi Hombashi https://github.com/thombashinattofriends https://github.com/nattofriendsagberk https://github.com/agberkWaleed Khan https://github.com/arxanasJean-Louis Fuchs https://github.com/ganwellCarlos Corbacho https://github.com/ccorbachoFelix Yan https://github.com/felixonmarsbenrg https://github.com/benrgJere Lahelma https://github.com/je-lMax Taggart https://github.com/MaxTaggartVincent Philippon https://github.com/vphilipponSemen Zhydenko https://github.com/ss18Till Varoquaux  https://github.com/till-varoquauxMichal Kowalik https://github.com/michalviossdev07 https://github.com/ossdev07Kerry Olesen https://github.com/qheszjohnthagen https://github.com/johnthagenBastien Vallet https://github.com/djaillaRam Rachum  https://github.com/cool-RRVincent Philippon https://github.com/vphilipponAndrey Bienkowski https://github.com/hexagonrecursionEthan McCue https://github.com/bowbahdoeJason R. Coombs https://github.com/jaracoNathan https://github.com/ndowensGeert Barentsen https://github.com/barentsenphil-arh https://github.com/phil-arhTamás Nepusz https://github.com/ntamasHugo van Kemenade https://github.com/hugovkBen Beasley https://github.com/musicinmybrainNoah C. Benson https://github.com/noahbensondscrofts https://github.com/dscroftsAndy Reagan https://github.com/andyreaganAaron Durant https://github.com/Aaron-DurantContributing------------Want to contribute? That's great! If you experience problems please log them on GitHub. If you want to contribute code,please fork the repository and submit a pull request.Run tests~~~~~~~~~.. _tox: https://tox.readthedocs.io/en/latest/Tests can be executed using tox_.Install tox: ``pip install tox``Run test for Python 3.8: ``tox -e py38``Release~~~~~~~* `pip install -r requirements.txt`* Update CHANGES.txt* Update README.rst with any new contributors and potential info needed.* Update _pyrsistent_version.py* Commit and tag with new version: `git add -u . &amp;&amp; git commit -m 'Prepare version vX.Y.Z' &amp;&amp; git tag -a vX.Y.Z -m 'vX.Y.Z'`* Push commit and tags: `git push --follow-tags`* Build new release using Github actionsProject status--------------Pyrsistent can be considered stable and mature (who knows, there may even be a 1.0 some day :-)). The project ismaintained, bugs fixed, PRs reviewed and merged and new releases made. I currently do not have time for developmentof new features or functionality which I don't have use for myself. I'm more than happy to take PRs for newfunctionality though!There are a bunch of issues marked with ``enhancement`` and ``help wanted`` that contain requests for new functionalitythat would be nice to include. The level of difficulty and extend of the issues varies, please reach out to me if you'reinterested in working on any of them.If you feel that you have a grand master plan for where you would like Pyrsistent to go and have the time to put intoit please don't hesitate to discuss this with me and submit PRs for it. If all goes well I'd be more than happy to addadditional maintainers to the project!</longdescription>
</pkgmetadata>