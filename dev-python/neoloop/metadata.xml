<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Neo-loop Finder***************.. image:: https://codeocean.com/codeocean-assets/badge/open-in-code-ocean.svg   :target: https://codeocean.com/capsule/8407443/tree/v1.. image:: https://static.pepy.tech/personalized-badge/neoloop?period=total&amp;units=international_system&amp;left_color=black&amp;right_color=orange&amp;left_text=Downloads   :target: https://pepy.tech/project/neoloopAlthough recent efforts have shown that structural variations (SVs) can disrupt the 3D genomeorganization and induce enhancer-hijacking, no computational tools exist to detect such eventsfrom chromatin interaction data, such as Hi-C. Here, we develop NeoLoopFinder, a computationalframework to identify the chromatin interactions induced by SVs, such as inter-chromosomaltranslocations, large deletions, and inversions. Our framework can automatically reconstructlocal Hi-C maps surrounding the breakpoints, normalize copy number variation and allele effects,and capture local optimal signals. We applied NeoLoopFinder in Hi-C data from 50 cancer celllines and primary tumors and identified tens of recurrent genes associated with enhancer-hijackingin different cancer types. To validate the algorithm, we deleted hijacked enhancers by CRISPR/Cas9and showed that the deletions resulted in the reduction of the target oncogene expression. Insummary, NeoLoopFinder is a novel tool for identifying potential tumorigenic mechanisms andsuggesting new diagnostic and therapeutic targets.Citation========Wang, X., Xu, J., Zhang, B., Hou, Y., Song, F., Lyu, H., Yue, F. Genome-wide detection ofenhancer-hijacking events from chromatin interaction data in re-arranged genomes. Nat Methods. 2021.Installation============NeoLoopFinder and all the dependencies can be installed using either `mamba &lt;https://mamba.readthedocs.io/en/latest/installation.html&gt;`_or `pip &lt;https://pypi.org/project/pip/&gt;`_::    $ conda config --add channels r    $ conda config --add channels defaults    $ conda config --add channels bioconda    $ conda config --add channels conda-forge    $ conda config --set channel_priority strict    $ mamba create -n neoloop cooler matplotlib pyensembl pybigwig intervaltree scikit-learn=1.1.2 joblib=1.1.0 rpy2 r-mgcv    $ mamba activate neoloop    $ pip install -U neoloop TADLib pomegranateOverview========neoloop-finder is distributed with 9 scripts. You can learn the basic usage of each scriptby typing ``command [-h]`` in a terminal window, where &quot;command&quot; is one of the followingscript names:- calculate-cnv  Calculate the copy number variation profile from Hi-C map using a generalized additive  model with the Poisson link function- segment-cnv  Perform HMM segmentation on a pre-calculated copy number variation profile.- plot-cnv    Plot genome-wide CNV profiles and segments.- correct-cnv  Remove copy number variation effects from cancer Hi-C.- simulate-cnv  Simulate CNV effects on a normal Hi-C. The inputs are the Hi-C matrix of a normal cell in .cool format,  the Hi-C matrix of a cancer cell in .cool format, and the CNV segmentation file of the same cancer cell  in bedGraph format.- assemble-complexSVs  Assemble complex SVs. The inputs are a list of simple SVs and the Hi-C matrix of the same sample.- neoloop-caller  Identify neo-loops across SV breakpoints. The required inputs are the output SV assemblies from  ``assemble-complexSVs`` and the corresponding Hi-C map in .cool format.- neotad-caller  Identify neo-TADs. The inputs are the same as ``neoloop-caller``.- searchSVbyGene  Search SV assemblies by gene name.Tutorial========This tutorial will cover the overall pipeline of `NeoLoopFinder &lt;https://www.nature.com/articles/s41592-021-01164-w/figures/1&gt;`_.Given a Hi-C map in `.cool/.mcool &lt;https://cooler.readthedocs.io/en/latest/schema.html#multi-resolution&gt;`_format and an SV list in the same sample, NeoLoopFinder starts with the inference ofthe genome-wide copy number variation (CNV) profile and remove the CNV effects fromHi-C. Then it resolves complex SVs and reconstructs local Hi-C matrices surrounding SVbreakpoints. And finally, it detects chromatin loops on each SV/complex SV assembly,including both loops in the regions not affected by SVs and loops across the breakpoints.Copy number inference from Hi-C map-----------------------------------.. note::   If the chromosome names in your .cool files do not have the &quot;chr&quot; prefix,   please make sure to add the &quot;chr&quot; prefix using `add_prefix_to_cool.py &lt;https://raw.githubusercontent.com/XiaoTaoWang/NeoLoopFinder/master/scripts/add_prefix_to_cool.py&gt;`_   before you run ``calculate-cnv`` (`issue #1 &lt;https://github.com/XiaoTaoWang/NeoLoopFinder/issues/1&gt;`_).   Also make sure you have run ``cooler balance`` on your cool files before   you run ``correct-cnv`` (`issue #8 &lt;https://github.com/XiaoTaoWang/NeoLoopFinder/issues/8&gt;`_).First, let's download a processed Hi-C dataset in SK-N-MC (a neuroepithelioma cell line)::    $ wget -O SKNMC-MboI-allReps-filtered.mcool -L https://www.dropbox.com/s/tuhhrecipkp1u8k/SKNMC-MboI-allReps-filtered.mcool?dl=0The downloaded &quot;.mcool&quot; file contains contact matrices at multiple resolutions. To list allindividual cool URIs within it, execute the ``cooler ls`` command below::    $ cooler ls SKNMC-MboI-allReps-filtered.mcool    SKNMC-MboI-allReps-filtered.mcool::/resolutions/5000    SKNMC-MboI-allReps-filtered.mcool::/resolutions/10000    SKNMC-MboI-allReps-filtered.mcool::/resolutions/25000    SKNMC-MboI-allReps-filtered.mcool::/resolutions/50000    SKNMC-MboI-allReps-filtered.mcool::/resolutions/100000    SKNMC-MboI-allReps-filtered.mcool::/resolutions/250000    SKNMC-MboI-allReps-filtered.mcool::/resolutions/500000    SKNMC-MboI-allReps-filtered.mcool::/resolutions/1000000    SKNMC-MboI-allReps-filtered.mcool::/resolutions/2500000    SKNMC-MboI-allReps-filtered.mcool::/resolutions/5000000To infer the genome-wide CNV profile at a specific resolution, just run *calculate-cnv*using the cool URI at that resolution as input. For example, the following command willcalculate the CNV profile at the 25kb resolution::    $ calculate-cnv -H SKNMC-MboI-allReps-filtered.mcool::resolutions/25000 -g hg38 \                    -e MboI --output SKNMC_25k.CNV-profile.bedGraphHere the ``-g`` parameter indicates the reference genome you used for mappingyour Hi-C data, which currently supports *hg38*, *hg19*, *mm10*, and *mm9*.And the &quot;-e&quot; parameter indicates the restriction enzyme used in yourHi-C experiment, which currently supports *HindIII*, *MboI*, *DpnII*, *BglII*,*Arima*, and *uniform*, where *uniform* may be specified when the genome wascutted using a sequence-independent/uniform-cutting enzyme(please refer to `issue 24 &lt;https://github.com/XiaoTaoWang/NeoLoopFinder/issues/24&gt;`_).The inferred CNV values for each 25kb bin will be reported in the bedGraph formatas follows::    $ head SKNMC_25k.CNV-profile.bedGraph    chr10250000.3622223616602325    chr125000500000.16018489189648388    chr150000750000.6700770894724766    chr1750001000000.29407421138399936    chr11000001250000.7064836696780397    chr11250001500000.18356628377821504    chr11500001750000.008115191530591481    chr11750002000001.9345786937265874    chr12000002250001.1066640487666337    chr12250002500000.0Since the raw CNV profiles are usually relatively noisy, the next step is toidentify CNV segments from the original signals::    $ segment-cnv --cnv-file SKNMC_25k.CNV-profile.bedGraph --binsize 25000 \                  --ploidy 2 --output SKNMC_25k.CNV-seg.bedGraph --nproc 4Here the ``--ploidy`` parameter indicates the ploidy or on average how many chromosomecopies are there in your sample's cell nucleus. For example, in our analysis,we set this parameter to 2 for diploid/pseudodiploid cells, 3 for triploid/hypotriploidcells, 4 for hypotetraploid cells, and 5 for hypopentaploid cells. This informationis usually obtained from karyotyping, but if you are not sure about it for your samples,you can safely set it to 2.So how does the inferred CNV look like? For this job, you can use the *plot-cnv* command::    $ plot-cnv --cnv-profile SKNMC_25k.CNV-profile.bedGraph \               --cnv-segment SKNMC_25k.CNV-seg.bedGraph \               --output-figure-name SKNMC_25k.CNV.genome-wide.png \               --dot-size 0.5 --dot-alpha 0.2 --line-width 1 --boundary-width 0.5 \               --label-size 7 --tick-label-size 6 --clean-mode.. image:: ./images/SKNMC_25k.CNV.genome-wide.png        :align: centerIf you want to zoom into specific chromosomes, you can specify the chromosome labelson the command using the ``-C`` parameter::    $ plot-cnv --cnv-profile SKNMC_25k.CNV-profile.bedGraph \               --cnv-segment SKNMC_25k.CNV-seg.bedGraph \               --output-figure-name SKNMC_25k.CNV.bychrom.png \               --dot-size 1.5 --dot-alpha 0.3 --line-width 1.5 --boundary-width 1 \               --label-size 7 --tick-label-size 6 --maximum-value 3 \               --minimum-value -5 -C 3 4 5 6 7 8.. image:: ./images/SKNMC_25k.CNV.bychrom.png        :align: centerNote that most key parameters of the CNV segmentation algorithm is now tunable sincev0.4.1, so if you are not satisfied with the segmentation outputted by the defaultparameters, it would always be a good idea to tune those parameters yourself to findthe best solution (see an example here `issue #3 &lt;https://github.com/XiaoTaoWang/NeoLoopFinder/issues/3#issuecomment-1261176468&gt;`_).At the end of this section, let's compute the CNV profiles and CNV segments at 10kband 5kb resolutions as well::    $ calculate-cnv -H SKNMC-MboI-allReps-filtered.mcool::resolutions/10000 -g hg38 \                    -e MboI --output SKNMC_10k.CNV-profile.bedGraph    $ segment-cnv --cnv-file SKNMC_10k.CNV-profile.bedGraph --binsize 10000 \                  --ploidy 2 --output SKNMC_10k.CNV-seg.bedGraph --nproc 4     $ calculate-cnv -H SKNMC-MboI-allReps-filtered.mcool::resolutions/5000 -g hg38 \                    -e MboI --output SKNMC_5k.CNV-profile.bedGraph    $ segment-cnv --cnv-file SKNMC_5k.CNV-profile.bedGraph --binsize 5000 \                  --ploidy 2 --output SKNMC_5k.CNV-seg.bedGraph --nproc 4Remove CNV biases from Hi-C contacts------------------------------------As copy number variations (CNVs) can greatly distort Hi-C signals in cancer cells, wesuggest using the *correct-cnv* command to remove such effects along with other systematicbiases including mappability, GC content, and restriction fragment sizes from the Hi-Cdata.The command below will perform this CNV normalization on the above SK-N-MC Hi-C at the 25kbresolution::    $ correct-cnv -H SKNMC-MboI-allReps-filtered.mcool::resolutions/25000 \                  --cnv-file SKNMC_25k.CNV-seg.bedGraph --nproc 4 -f*correct-cnv* takes the Cool URI at a certain resolution and the CNV segmentation file at thesame resolution as inputs, and after this command has been executed, a bias vector will bereported in the &quot;sweight&quot; column in the `bins &lt;https://cooler.readthedocs.io/en/latest/datamodel.html#bins&gt;`_table of the cool file, which can be further used to normalize the Hi-C contacts.Again, let's perform the CNV normalization at the 10kb and 5kb resolutions as well::    $ correct-cnv -H SKNMC-MboI-allReps-filtered.mcool::resolutions/10000 \                  --cnv-file SKNMC_10k.CNV-seg.bedGraph --nproc 4 -f    $ correct-cnv -H SKNMC-MboI-allReps-filtered.mcool::resolutions/5000 \                  --cnv-file SKNMC_5k.CNV-seg.bedGraph --nproc 4 -fAssemble complex SVs--------------------.. note::   By default, ``assemble-complexSVs``, ``neoloop-caller``, and ``neotad-caller``   will use the &quot;sweight&quot; column to normalize the Hi-C matrix. However, you can   change this option to ICE normalization by specifying ``--balance-type ICE``.After you have obtained the CNV-normalized Hi-C matrices, the next step ofNeoLoopFinder is to reconstruct the Hi-C map for the rearranged genomicregions surrounding SV breakpoints. This job can be done by the *assemble-complexSVs*command.In addition to cool URIs, another required input to *assemble-complexSVs* isa file containing a list of SVs identified from the same sample. Our recentlydeveloped software `EagleC &lt;https://github.com/XiaoTaoWang/EagleC&gt;`_ can predicta full range of SVs from Hi-C and report SVs in a format that can be directlyused here. If your SVs were identified by other software or platforms, pleaseprepare your SV list in a 6-column TXT format like this::    chr7    chr14   ++      14000000        37500000        translocation    chr7    chr14   --      7901149 37573191        translocation1. **chrA**: The chromosome name of the 1st breakpoint.2. **chrB**: The chromosome name of the 2nd breakpoint.3. **orientation**: The orientation type of the fusion, one of ++, +-, -+, or --.4. **b1**: The position of the 1st breakpoint on *chrA*.5. **b2**: The position of the 2nd breakpoint on *chrB*.6. **type**: SV type. Allowable choices are: *deletion*, *inversion*, *duplication*, and *translocation*.For this tutorial, let's directly run *assemble-complexSVs* with a pre-identifiedSV list in SK-N-MC (by EagleC)::    $ wget -O SKNMC-EagleC.SV.txt -L https://www.dropbox.com/s/g1wa799wgwta9p4/SK-N-MC.EagleC.txt?dl=0    $ assemble-complexSVs -O SKNMC -B SKNMC-EagleC.SV.txt --balance-type CNV --protocol insitu --nproc 6 \                          -H SKNMC-MboI-allReps-filtered.mcool::resolutions/25000 \                             SKNMC-MboI-allReps-filtered.mcool::resolutions/10000 \                             SKNMC-MboI-allReps-filtered.mcool::resolutions/5000 \Here you can pass either one cool URI or a list of cool URIs at multiple resolutionsto the ``-H`` parameter. And if multiple cool URIs are provided, the program willfirst detect complex SVs from each individual resolution, and then combine resultsfrom all resolutions in a non-redundant way.The job should be finished in ~6 minutes, and all candidate local assemblies will be reportedinto a TXT file named &quot;SKNMC.assemblies.txt&quot;::    $ head SKNMC.assemblies.txt    A0inversion,8,132915000,+,8,130825000,+deletion,8,130800000,-,8,129520000,+8,1321550008,129375000    A1inversion,11,84315000,-,11,83565000,-inversion,11,84315000,+,11,83565000,+11,8505000011,82625000    A2deletion,8,130800000,-,8,129520000,+deletion,8,129375000,-,8,127880000,+8,1308350008,126215000    C0translocation,1,10260000,+,X,21495000,-1,9380000X,22205000    C1translocation,1,10260000,-,X,21495000,+1,10630000X,20080000    C2inversion,11,83565000,+,11,84315000,+11,8263000011,84245000    C3inversion,11,83565000,-,11,84315000,-11,8364500011,84855000    C4translocation,11,128790000,+,15,50540000,-11,12795000015,51475000    C5translocation,11,128790000,-,22,29290000,+11,12953500022,28520000    C6translocation,15,50545000,+,22,29285000,-15,4983500022,30330000Identify chromatin loops on local SV assemblies-----------------------------------------------To identify chromatin loops on each assembly, simply execute the command below::    $ neoloop-caller -O SKNMC.neo-loops.txt --assembly SKNMC.assemblies.txt \                     --balance-type CNV --protocol insitu --prob 0.95 --nproc 4 \                     -H SKNMC-MboI-allReps-filtered.mcool::resolutions/25000 \                        SKNMC-MboI-allReps-filtered.mcool::resolutions/10000 \                        SKNMC-MboI-allReps-filtered.mcool::resolutions/5000 \Wait ~10 minutes. The loop coordinates in both shuffled (neo-loops) and undisruptedregions near SV breakpoints will be reported into &quot;SKNMC.neo-loops.txt&quot; in`BEDPE &lt;https://bedtools.readthedocs.io/en/latest/content/general-usage.html&gt;`_ format::    $ head SKNMC.neo-loops.txt    chr194900009500000chr198600009870000C0,370000,0    chr195000009505000chr195700009575000C0,80000,0,C0,70000,0    chr196200009630000chrX2173000021740000C0,880000,1,C0,900000,1    chr196250009650000chr198500009875000C0,225000,0    chr196250009650000chrX2172500021750000C0,900000,1    chr196300009635000chr198650009870000C0,240000,0,C0,235000,0,C0,225000,0    chr196300009640000chrX2170000021710000C0,840000,1    chr196400009645000chr198500009855000C0,210000,0,C0,225000,0    chr197000009710000chr198500009860000C0,150000,0    chr197200009725000chr198600009865000C0,140000,0The last column records the assembly IDs, the genomic distance between two loop anchorson the assembly, and whether this is a neo-loop. For example, for the 5th row above, the loopwas detected on the assemblies &quot;C0&quot;, the genomic distance between the two anchors on thisassembly is 900K, and it is a neo-loop as indicated by &quot;1&quot;.Visualize neo-loops on local assemblies---------------------------------------In our paper, we showed that neo-loops frequently involved oncogenes or tumor-suppressorgenes in cancer. But how can we know whether a specific gene is involved in neo-loops ornot in a sample? For this job, we provide the *searchSVbyGene* command, which takes aloop file returned by *neoloop-caller* and a gene name as inputs, and outputs a list ofSV assemblies, where the input gene is involved in neo-loops on those assemblies::    $ searchSVbyGene -L SKNMC.neo-loops.txt -G MYC    C16    A2In this case, we searched for the MYC gene, and from the result, we can see MYC isinvolved in neo-loops on the assembles &quot;C16&quot; and &quot;A2&quot;::    A2deletion,8,130800000,-,8,129520000,+deletion,8,129375000,-,8,127880000,+8,1308350008,126215000    C16deletion,8,127880000,+,8,129375000,-8,1262150008,130125000Finally, let's plot the Hi-C matrix, the identified neo-loops, and the gene track on the&quot;C16&quot; assembly, using the built-in visualization module of NeoLoopFinder::    &gt;&gt;&gt; from neoloop.visualize.core import *     &gt;&gt;&gt; import cooler    &gt;&gt;&gt; clr = cooler.Cooler('SKNMC-MboI-allReps-filtered.mcool::resolutions/5000')    &gt;&gt;&gt; assembly = 'C16deletion,8,127880000,+,8,129375000,-8,1262150008,130125000'    &gt;&gt;&gt; vis = Triangle(clr, assembly, n_rows=3, figsize=(7, 4.2),         track_partition=[5, 0.4, 0.5], correct='sweight', span=500000,        slopes={(0,0):1, (0,1):0.3, (1,1):1})    &gt;&gt;&gt; vis.matrix_plot(vmin=0)    &gt;&gt;&gt; vis.plot_chromosome_bounds(linewidth=2)    &gt;&gt;&gt; vis.plot_loops('SKNMC.neo-loops.txt', face_color='none', marker_size=40,        cluster=False, filter_by_res=True, onlyneo=True)    &gt;&gt;&gt; vis.plot_genes(filter_=['MYC', 'PVT1'],label_aligns={'MYC':'right'}, fontsize=9)     &gt;&gt;&gt; vis.plot_chromosome_bar(name_size=10, coord_size=9)    &gt;&gt;&gt; vis.outfig('SKNMC.C16.pdf').. image:: ./images/SKNMC.C16.png        :align: centerGallery=======In addtion to the reconstructed Hi-C maps (.cool), loops (.bedpe), and genes, the visualization module also supports plottingRNA-Seq/ChIP-Seq/ATAC-Seq signals (.bigwig), peaks (.bed), and motifs (.bed). Below I'm going to share more examples and thecode snippets used to generate the figure.Code Snippet 1:    &gt;&gt;&gt; from neoloop.visualize.core import *     &gt;&gt;&gt; import cooler    &gt;&gt;&gt; clr = cooler.Cooler('SCABER-Arima-allReps.10K.cool')    &gt;&gt;&gt; List = [line.rstrip() for line in open('demo/allOnco-genes.txt')] # please find allOnco-genes.txt in the demo folder of this repository    &gt;&gt;&gt; assembly = 'A3      deletion,9,38180000,-,9,14660000,+      inversion,9,13870000,-,9,22260000,-     9,38480000      9,24220000'    &gt;&gt;&gt; vis = Triangle(clr, assembly, n_rows=5, figsize=(7, 5.2), track_partition=[5, 0.8, 0.8, 0.2, 0.5], correct='weight', span=300000, space=0.08)    &gt;&gt;&gt; vis.matrix_plot(vmin=0, cbr_fontsize=9)    &gt;&gt;&gt; vis.plot_chromosome_bounds(linewidth=2)    &gt;&gt;&gt; vis.plot_signal('RNA-Seq', 'enc_SCABER_RNASeq_rep1.bw', label_size=10, data_range_size=9, max_value=0.5, color='#E31A1C')    &gt;&gt;&gt; vis.plot_signal('H3K27ac', 'SCABER_H3K27ac_pool.bw', label_size=10, data_range_size=9, max_value=20, color='#6A3D9A')    &gt;&gt;&gt; vis.plot_genes(release=75, filter_=List, fontsize=10)    &gt;&gt;&gt; vis.plot_chromosome_bar(name_size=13, coord_size=10)    &gt;&gt;&gt; vis.outfig('SCaBER.NFIB.png', dpi=300)Figure output 1:.. image:: ./images/SCaBER.NFIB.png        :align: centerNote that when you initialize a plotting object, the figure size (**figsize**), the number of tracks (**n_rows**), and the height of eachtrack (**track_partition**) can all be configured flexibly.Code Snippet 2:    &gt;&gt;&gt; from neoloop.visualize.core import *     &gt;&gt;&gt; import cooler    &gt;&gt;&gt; clr = cooler.Cooler('LNCaP-WT-Arima-allReps-filtered.mcool::resolutions/10000')    &gt;&gt;&gt; assembly = 'C26     translocation,7,14158275,+,14,37516423,+        7,13140000      14,36390000'    &gt;&gt;&gt; vis = Triangle(clr, assembly, n_rows=6, figsize=(7, 5.3), track_partition=[5, 0.4, 0.8, 0.3, 0.3, 0.5], correct='weight', span=600000, space=0.03)    &gt;&gt;&gt; vis.matrix_plot(vmin=0, cbr_fontsize=9)    &gt;&gt;&gt; vis.plot_chromosome_bounds(linewidth=2)    &gt;&gt;&gt; vis.plot_genes(filter_=['ETV1', 'DGKB', 'MIPOL1'],label_aligns={'DGKB':'right', 'ETV1':'right'}, fontsize=10)     &gt;&gt;&gt; vis.plot_signal('DNase-Seq', 'LNCaP.DNase2.hg38.bw', label_size=10, data_range_size=9, max_value=1.8, color='#6A3D9A')    &gt;&gt;&gt; vis.plot_motif('demo/LNCaP.CTCF-motifs.hg38.txt', subset='+') # an example file LNCaP.CTCF-motifs.hg38.txt can be found at the demo folder of this repository    &gt;&gt;&gt; vis.plot_motif('demo/LNCaP.CTCF-motifs.hg38.txt', subset='-')    &gt;&gt;&gt; vis.plot_chromosome_bar(name_size=13, coord_size=10, color_by_order=['#1F78B4','#33A02C'])    &gt;&gt;&gt; vis.outfig('LNCaP.CTCF-motifs.png', dpi=300)Figure output 2:.. image:: ./images/LNCaP.CTCF-motifs.png        :align: centerCode Snippet 3:    &gt;&gt;&gt; from neoloop.visualize.core import *     &gt;&gt;&gt; import cooler    &gt;&gt;&gt; clr = cooler.Cooler('LNCaP-WT-Arima-allReps-filtered.mcool::resolutions/10000')    &gt;&gt;&gt; assembly = 'C26     translocation,7,14158275,+,14,37516423,+        7,13140000      14,36390000'    &gt;&gt;&gt; vis = Triangle(clr, assembly, n_rows=5, figsize=(7, 5.3), track_partition=[5, 0.4, 0.8, 0.8, 0.5], correct='weight', span=600000, space=0.03)    &gt;&gt;&gt; vis.matrix_plot(vmin=0, cbr_fontsize=9)    &gt;&gt;&gt; vis.plot_chromosome_bounds(linewidth=2)    &gt;&gt;&gt; vis.plot_loops('LNCaP.neoloops.txt', face_color='none', marker_size=40, cluster=True, onlyneo=True) # only show neo-loops    &gt;&gt;&gt; vis.plot_genes(filter_=['ETV1', 'DGKB', 'MIPOL1'],label_aligns={'DGKB':'right', 'ETV1':'right'}, fontsize=10)    &gt;&gt;&gt; vis.plot_signal('DNase-Seq', 'LNCaP.DNase2.hg38.bw', label_size=10, data_range_size=9, max_value=1.8, color='#6A3D9A')    &gt;&gt;&gt; vis.plot_arcs(lw=1.5, cutoff='top', gene_filter=['ETV1'], arc_color='#666666') # ETV1-related neo-loops    &gt;&gt;&gt; vis.plot_chromosome_bar(name_size=13, coord_size=10, color_by_order=['#1F78B4','#33A02C'])    &gt;&gt;&gt; vis.outfig('LNCaP.arcs.png', dpi=300)Figure output 3:.. image:: ./images/LNCaP.arcs.png        :align: centerNote that both **plot_loops** and **plot_genes** need to be called before **plot_arcs**.Release Notes=============Version 0.4.0 (09/16/2022)--------------------------1. Made it compatible with the latest versions of dependent packages2. Changed to Peakachu v2.0 models3. Moved all reference data to the 3D genome browser server (http://3dgenome.fsm.northwestern.edu/)Version 0.4.2 (09/28/2022)--------------------------1. For CNV segmentation, changed to use the genome-wide CNV profiles to train HMM models2. Made key parameters of the CNV segmentation algorithm tunable</longdescription>
</pkgmetadata>