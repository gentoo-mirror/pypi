<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># json-stream[![Tests](https://github.com/daggaz/json-stream/actions/workflows/tests.yml/badge.svg)](https://github.com/daggaz/json-stream/actions/workflows/tests.yml)[![PyPI package and version badge](https://img.shields.io/pypi/v/json-stream)](https://pypi.org/project/json-stream)[![Supported Python versions badge](https://img.shields.io/pypi/pyversions/json-stream)](https://pypi.org/project/json-stream/)[![Donate](https://img.shields.io/badge/buy%20me%20a%20coffee-donate-blue.svg)](https://www.buymeacoffee.com/daggaz)Simple streaming JSON parser and encoder.When [reading](#reading) JSON data, `json-stream` can decode JSON data in a streaming manner, providing a pythonic dict/list-like interface, or a[visitor-based interfeace](#visitor). Can stream from files, [URLs](#urls) or [iterators](#iterators).When [writing](#writing) JSON data, `json-stream` can stream JSON objects as you generate them.These techniques allow you to [reduce memory consumption and latency](#standard-json-problems).# &lt;a id=&quot;reading&quot;&gt;&lt;/a&gt; Reading`json-stream` is a JSON parser just like the standard library's [`json.load()`](https://docs.python.org/3/library/json.html#json.load). It  will read a JSON document and convert it into native python types.```pythonimport json_streamdata = json_stream.load(f)```Features:* stream all JSON data types (objects, lists and simple types)* stream nested data* simple pythonic `list`-like/`dict`-like interface* stream truncated or malformed JSON data (up to the first error)* [native code parsing speedups](#rust-tokenizer) for most common platforms * pure python fallback if native extensions not availableUnlike `json.load()`, `json-stream` can _stream_ JSON data from any file-like or[iterable](#iterators) object. This has the following benefits:* it does not require the whole json document to be read into memory up-front* it can start producing data before the entire document has finished loading* it only requires enough memory to hold the data currently being parsedThere are specific integrations for streaming JSON data from [URLs](#urls) using the [`requests`](#requests), [`httpx`](#httpx), or [`urllib`](#urllib).The objects that `json-stream` produces can be [re-output](#encoding-json-stream-objects)using `json.dump()` with a little work.## Usage### `json_stream.load()``json_stream.load()` has two modes of operation, controlled bythe `persistent` argument (default false).It is also possible to &quot;mix&quot; the modes as you consume the data.#### Transient mode (default)This mode is appropriate if you can consume the data iteratively. You cannot move backwards through the stream to read data that has already been skippedover. It is the mode you **must** use if you want to process large amounts ofJSON data without consuming large amounts of memory.In transient mode, only the data currently being read is stored in memory. Anydata previously read from the stream is discarded (it's up to you what to do with it) and attempting to access this data results in a`TransientAccessException`.```pythonimport json_stream# JSON: {&quot;count&quot;: 3, &quot;results&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}data = json_stream.load(f)  # data is a transient dict-like object # stream has been read up to &quot;{&quot;# use data like a dictresults = data[&quot;results&quot;]  # results is a transient list-like object# stream has been read up to &quot;[&quot;, we now cannot read &quot;count&quot;# iterate transient listfor result in results:    print(result)  # prints a, b, c# stream has been read up to &quot;]&quot;# attempt to read &quot;count&quot; from earlier in streamcount = data[&quot;count&quot;]  # will raise exception# stream is now exhausted# attempt to read from list that has already been iteratedfor result in results:  # will raise exception    pass```#### Persistent modeIn persistent mode all previously read data is stored in memory asit is parsed. The returned `dict`-like or `list`-like objectscan be used just like normal data structures.If you request an index or key that has already been read from the streamthen it is retrieved from memory. If you request an index or key that hasnot yet been read from the stream, then the request blocks until that itemis found in the stream.```pythonimport json_stream# JSON: {&quot;count&quot;: 1, &quot;results&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}data = json_stream.load(f, persistent=True)# data is a streaming  dict-like object # stream has been read up to &quot;{&quot;# use data like a dictresults = data[&quot;results&quot;]  # results is a streaming list-like object# stream has been read up to &quot;[&quot;# count has been stored data# use results like a lista_result = results[1]  # a_result = &quot;b&quot;# stream has been read up to the middle of list# &quot;a&quot; and &quot;b&quot; have been stored in results# read earlier data from memorycount = data[&quot;count&quot;]  # count = 1# consume rest of listresults.read_all()# stream has been read up to &quot;}&quot;# &quot;c&quot; is now stored in results too# results.is_streaming() == False# consume everythingdata.read_all()# stream is now exhausted# data.is_streaming() == False```Persistent mode is not appropriate if you care about memory consumption, butprovides an identical experience compared to `json.load()`.#### Mixed modeIn some cases you will need to be able to randomly access some part of the data, but still only have that specific data taking up memory resources.For example, you might have a very long list of objects, but you cannot always access the keys of the objects in stream order. You want to be able to iteratethe list transiently, but access the result objects persistently.This can be achieved using the `persistent()` method of all the `list` or`dict`-like objects json_stream produces. Calling `persistent()` causes the existingtransient object to produce persistent child objects.Note that the `persistent()` method makes the children of the object itis called on persistent, not the object it is called on.```pythonimport json_stream# JSON: {&quot;results&quot;: [{&quot;x&quot;: 1, &quot;y&quot;: 3}, {&quot;y&quot;: 4, &quot;x&quot;: 2}]}# note that the keys of the inner objects are not ordered data = json_stream.load(f)  # data is a transient dict-like object # iterate transient list, but produce persistent itemsfor result in data['results'].persistent():    # result is a persistent dict-like object    print(result['x'])  # print x    print(result['y'])  # print y (error on second result without .persistent())    print(result['x'])  # print x again (error without .persistent())```The opposite is also possible, going from persistent mode to transient mode, though the use cases for this are more esoteric.```python# JSON: {&quot;a&quot;: 1, &quot;x&quot;: [&quot;long&quot;, &quot;list&quot;, &quot;I&quot;, &quot;don't&quot;, &quot;want&quot;, &quot;in&quot;, &quot;memory&quot;], &quot;b&quot;: 2}data = load(StringIO(json), persistent=True).transient()# data is a persistent dict-list object that produces transient childrenprint(data[&quot;a&quot;])  # prints 1x = data[&quot;x&quot;]  # x is a transient list, you can use it accordinglyprint(x[0])  # prints long# access earlier data from memoryprint(data[&quot;a&quot;])  # this would have raised an exception if data was transientprint(data[&quot;b&quot;])  # prints 2# we have now moved past all the data in the transient listprint(x[0])  # will raise exception```### &lt;a id=&quot;visitor&quot;&gt;&lt;/a&gt;visitor patternYou can also parse using a visitor-style approach where a function you supplyis called for each data item as it is parsed (depth-first).This uses a transient parser under the hood, so does not consume memory forthe whole document.```pythonimport json_stream# JSON: {&quot;x&quot;: 1, &quot;y&quot;: {}, &quot;xxxx&quot;: [1,2, {&quot;yyyy&quot;: 1}, &quot;z&quot;, 1, []]}def visitor(item, path):    print(f&quot;{item} at path {path}&quot;)json_stream.visit(f, visitor)```Output:```1 at path ('x',){} at path ('y',)1 at path ('xxxx', 0)2 at path ('xxxx', 1)1 at path ('xxxx', 2, 'yyyy')z at path ('xxxx', 3)1 at path ('xxxx', 4)[] at path ('xxxx', 5)```### &lt;a id=&quot;urls&quot;&gt;&lt;/a&gt; Stream a URL`json_stream` knows how to stream directly from a URL using a variety of packages.Supported packages include:- Python's batteries-included [`urllib`](#urllib) package- The popular [`requests`](#requests) library- The newer [`httpx`](#httpx) library#### &lt;a id=&quot;urllib&quot;&gt;&lt;/a&gt; urllib[`urllib`](https://docs.python.org/3/library/urllib.html)'s response objects are alreadyfile-like objects, so we can just pass them directly to `json-stream`.```pythonimport urllib.requestimport json_streamwith urllib.request.urlopen('http://example.com/data.json') as response:    data = json_stream.load(response)```#### &lt;a id=&quot;requests&quot;&gt;&lt;/a&gt;requestsTo stream JSON data from [`requests`](https://requests.readthedocs.io/en/latest/), you mustpass `stream=True` when making a request, and call `json_stream.requests.load()` passing the response. ```pythonimport requestsimport json_stream.requestswith requests.get('http://example.com/data.json', stream=True) as response:    data = json_stream.requests.load(response)```&lt;a id=&quot;requests-chunk-size&quot;&gt;&lt;/a&gt;Note: these functions use[`response.iter_content()`](https://requests.readthedocs.io/en/latest/api/#requests.Response.iter_content) under thehood with a `chunk_size` of 10k bytes. This default allows us to perform effective reads from the response stream and lower CPU usage. The drawback to this is that `requests` will buffer each read until up to 10k bytes have been read before passing the data back to `json_stream`. If you need to consume data more responsively the only option is to tune`chunk_size` back to 1 to disable buffering.#### &lt;a id=&quot;httpx&quot;&gt;&lt;/a&gt; httpxTo stream JSON data from [`httpx`](https://www.python-httpx.org/), you must call[`stream()`](https://www.python-httpx.org/quickstart/#streaming-responses) whenmaking your request, and call `json_stream.httpx.load()` passing the response.```pythonimport httpximport json_stream.httpxwith httpx.Client() as client, client.stream('GET', 'http://example.com/data.json') as response:    data = json_stream.httpx.load(response)```Under the hood, this works similarly to the [`requests`](#requests) version above, including the caveat about [`chunk_size`](#requests-chunk-size).### Stream a URL (with visitor)The visitor pattern also works with URL streams.#### urllib```pythonimport urllib.requestimport json_streamdef visitor(item, path):    print(f&quot;{item} at path {path}&quot;)    with urllib.request.urlopen('http://example.com/data.json') as response:    json_stream.visit(response, visitor)```#### requests```pythonimport requestsimport json_stream.requestsdef visitor(item, path):    print(f&quot;{item} at path {path}&quot;)    with requests.get('http://example.com/data.json', stream=True) as response:    json_stream.requests.visit(response, visitor)```The [`chunk_size`](#requests-chunk-size) note also applies to `visit()`.#### httpx```pythonimport httpximport json_stream.httpxdef visitor(item, path):    print(f&quot;{item} at path {path}&quot;)    with httpx.Client() as client, client.stream('GET', 'http://example.com/data.json') as response:    json_stream.httpx.visit(response, visitor)```### &lt;a id=&quot;iterators&quot;&gt;&lt;/a&gt; Stream an iterable`json-stream`'s parsing functions can take any iterable object that produces encoded JSON as`byte` objects.```pythonimport json_streamdef some_iterator():    yield b'{&quot;some&quot;:'    yield b' &quot;JSON&quot;}'data = json_stream.load(some_iterator())assert data['some'] == &quot;JSON&quot;```This is actually how the [`requests`](#requests) and [`httpx`](#httpx) extensions work, asboth libraries provide methods to iterate over the response content.### &lt;a id=&quot;encoding-json-stream-objects&quot;&gt;&lt;/a&gt; Encoding json-stream objectsYou can re-output (encode) _persistent_ json-stream `dict`-like and `list`-like object back to JSON using the built-in`json.dump()` or `json.dumps()` functions, but with a little additional work:```pythonimport jsonimport json_streamfrom json_stream.dump import JSONStreamEncoder, defaultdata = json_stream.load(f, persistent=True)# Option 1: supply json_stream.encoding.default as the default argumentprint(json.dumps(data, default=default))# Option 2: supply json_stream.encoding.JSONStreamEncoder as the cls argument# This allows you to create your own subclass to further customise encodingprint(json.dumps(data, cls=JSONStreamEncoder))```If you are using a library that internally takes data you pass it and encodesit using `json.dump()`. You can also use JSONStreamEncoder() as a context manager.It works by monkey-patching the built-in `JSONEncoder.default` method during thescope of the `with` statement.```python # library codedef some_library_function_out_of_your_control(arg):    json.dumps(arg)# your codewith JSONStreamEncoder():    some_library_function_out_of_your_control(data)```### Converting to standard Python typesTo convert a json-stream `dict`-like or `list`-like object and all itsdescendants to a standard `list` and `dict`, you can use the`json_stream.to_standard_types` utility:```python# JSON: {&quot;round&quot;: 1, &quot;results&quot;: [1, 2, 3]}data = json_stream.load(f)results = data[&quot;results&quot;]print(results)  # prints &lt;TransientStreamingJSONList: TRANSIENT, STREAMING&gt;converted = json_stream.to_standard_types(results)print(converted)  # prints [1, 2, 3]```#### Thread safety (experimental)There is also a thread-safe version of the `json.dump` context manager:```pythonfrom json_stream.dump.threading import ThreadSafeJSONStreamEncoder# your codewith ThreadSafeJSONStreamEncoder():   some_library_function_out_of_your_control(data)```The thread-safe implementation will ensure that concurrent uses of the context manager will only apply the patch for the first thread enteringthe patched section(s) and will only remove the patch when the lastthread exits the patched sections(s)Additionally, if the patch is somehow called by a thread that is _not_currently in a patched section (i.e. some other thread calling `json.dump`) then that thread will block until the patch has beenremoved. While such an un-patched thread is active, any thread attemptingto apply the patch is blocked.### &lt;a id=&quot;rust-tokenizer&quot;&gt;&lt;/a&gt; Rust tokenizer speedupsBy default `json-stream` uses the [`json-stream-rs-tokenizer`](https://pypi.org/project/json-stream-rs-tokenizer/)native extension.This is a 3rd party Rust-based tokenizer implementations that providessignificant parsing speedup compared to pure python implementation.`json-stream` will fallback to its pure python tokenizer implementationif `json-stream-rs-tokenizer` is not available.### Custom tokenizerYou can supply an alternative JSON tokenizer implementation. Simply pass a tokenizer to the `load()` or `visit()` methods.```pythonjson_stream.load(f, tokenizer=some_tokenizer)```The requests methods also accept a customer tokenizer parameter.# WritingThe standard library's `json.dump()` function can only accept standardpython types such as `dict`, `list`, `str`.`json-stream` allows you to write streaming JSON output based on pythongenerators instead.For actually encoding and writing to the stream, `json-stream` still uses the standard library's `json.dump()` function, but provideswrappers that adapt python generators into `dict`/`list` subclasses that `json.dump()` can use.The means that you do not have to generate all of your data upfrontbefore calling `json.dump()`.## UsageTo use `json-stream` to generate JSON data iteratively, you must first write python generators (or use any other iterable).To output JSON objects, the iterable must yield key/value pairs.To output JSON lists, the iterable must yield individual items.The values yielded can be either be standard python types or another other`Streamable` object, allowing lists and object to be arbitrarily nested.`streamable_list`/`streamable_dict` can be used to wrap an existingiterable:```pythonimport sysimport jsonfrom json_stream import streamable_list# wrap existing iterabledata = streamable_list(range(10))# consume iterable with standard json.dump()json.dump(data, sys.stdout)```Or they can be used as decorators on generator functions:```pythonimport jsonimport sysfrom json_stream import streamable_dict# declare a new streamable dict generator function@streamable_dictdef generate_dict_of_squares(n):    for i in range(n):        # this could be some memory intensive operation        # or just a really large value of n        yield i, i ** 2# data is will already be Streamable because# of the decoratordata = generate_dict_of_squares(10)json.dump(data, sys.stdout)```## ExampleThe following example generates a JSON object with a nested JSON list.It uses `time.sleep()` to slow down the generation and show that theoutput is indeed written as the data is created.```pythonimport sysimport jsonimport timefrom json_stream.writer import streamable_dict, streamable_list# define a list data generator that (slowly) yields # items that will be written as a JSON list@streamable_listdef generate_list(n):    # output n numbers and their squares    for i in range(n):  # range is itself a generator        yield i        time.sleep(1)# define a dictionary data generator that (slowly) yields # key/value pairs that will be written as a JSON dict@streamable_dictdef generate_dict(n):    # output n numbers and their squares    for i in range(n):  # range is itself a generator        yield i, i ** 2        time.sleep(1)    # yield another dictionary item key, with the value    # being a streamed nested list    yield &quot;a list&quot;, generate_list(n)# get a streamable generatordata = generate_dict(5)# use json.dump() to write dict generator to stdoutjson.dump(data, sys.stdout, indent=2)# if you already have an iterable object, you can just# call streamable_* on it to make it writabledata = streamable_list(range(10))json.dump(data, sys.stdout)```Output:```json{  &quot;0&quot;: 0,  &quot;1&quot;: 1,  &quot;2&quot;: 4,  &quot;3&quot;: 9,  &quot;4&quot;: 16,  &quot;a list&quot;: [    0,    1,    2,    3,    4  ]}```# &lt;a id=&quot;standard-json-problems&quot;&gt;&lt;/a&gt; What are the problems with the standard `json` package?## Reading with `json.load()`The problem with the `json.load()` stem from the fact that it must readthe whole JSON document into memory before parsing it.### Memory usage`json.load()` first reads the whole document into memory as a string. Itthen starts parsing that string and converting the whole document into pythontypes again stored in memory. For a very large document, this could be morememory than you have available to your system.`json_stream.load()` does not read the whole document into memory, it onlybuffers enough from the stream to produce the next item of data.Additionally, in the default transient mode (see below) `json-stream` doesn't store up all of the parsed data in memory.### Latency`json.load()` produces all the data after parsing the whole document. If youonly care about the first 10 items in a list of 2 million items, then youhave wait until all 2 million items have been parsed first.`json_stream.load()` produces data as soon as it is available in the stream.## &lt;a id=&quot;writing&quot;&gt;&lt;/a&gt; Writing### Memory usageWhile `json.dump()` does iteratively write JSON data to the givenfile-like object, you must first produce the entire document to be written as standard python types (`dict`, `list`, etc). For a verylarge document, this could be more memory than you have available to your system.`json-stream` allows you iteratively generate your data one item ata time, and thus consumes only the memory required to generate thatone item.### Latency`json.dump()` can only start writing to the output file once all thedata has been generated up front at standard python types.The iterative generation of JSON items provided by `json-stream`allows the data to be written as it is produced.# Future improvements* Allow long strings in the JSON to be read as streams themselves* Allow transient mode on seekable streams to seek to data earlier inthe stream instead of raising a `TransientAccessException`* A more efficient tokenizer?# Alternatives## NAYA[NAYA](https://github.com/danielyule/naya) is a pure python JSON parser forparsing a simple JSON list as a stream.### Why not NAYA?* It can only stream JSON containing a top-level list * It does not provide a pythonic `dict`/`list`-like interface ## Yajl-Py[Yajl-Py](https://pykler.github.io/yajl-py/) is a wrapper around the C YAJL JSON library that can be used to generate SAX style events while parsing JSON.### Why not Yajl-Py?* No pure python implementation* It does not provide a pythonic `dict`/`list`-like interface ## jsonslicer[jsonslicer](https://github.com/AMDmi3/jsonslicer) is another wrapper around the YAJL C library with apath lookup based interface.### Why not jsonslicer?* No pure python implementation* It does not provide a pythonic `dict`/`list`-like interface* Must know all data paths lookup in advance (or make multiple passes)# ContributingSee the project [contribution guide](https://github.com/daggaz/json-stream/blob/master/CONTRIBUTING.md).# Donations[![PayPal](https://www.paypalobjects.com/webstatic/mktg/Logo/pp-logo-100px.png)](https://paypal.me/JCockburn307?country.x=GB&amp;locale.x=en_GB)OR[![&quot;Buy Me A Coffee&quot;](https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png)](https://www.buymeacoffee.com/daggaz)# AcknowledgementsThe JSON tokenizer used in the project was taken from the[NAYA](https://github.com/danielyule/naya) project.</longdescription>
</pkgmetadata>