<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>***************************************Overview***************************************    The Ruffus module is a lightweight way to add support    for running computational pipelines.    Computational pipelines are often conceptually quite simple, especially    if we breakdown the process into simple stages, or separate **tasks**.    Each stage or **task** in a computational pipeline is represented by a python function    Each python function can be called in parallel to run multiple **jobs**.    Ruffus was originally designed for use in bioinformatics to analyse multiple genome    data sets.***************************************Documentation***************************************    Ruffus documentation can be found `here &lt;http://www.ruffus.org.uk&gt;`__ ,    with `download notes &lt;http://www.ruffus.org.uk/installation.html&gt;`__ ,    a `tutorial &lt;http://www.ruffus.org.uk/tutorials/new_tutorial/introduction.html&gt;`__ and    an `in-depth manual &lt;http://www.ruffus.org.uk/tutorials/new_tutorial/manual_contents.html&gt;`__ .***************************************Background***************************************    The purpose of a pipeline is to determine automatically which parts of a multi-stage    process needs to be run and in what order in order to reach an objective (&quot;targets&quot;)    Computational pipelines, especially for analysing large scientific datasets are    in widespread use.    However, even a conceptually simple series of steps can be difficult to set up and    maintain.***************************************Design***************************************    The ruffus module has the following design goals:        * Lightweight        * Scalable / Flexible / Powerful        * Standard Python        * Unintrusive        * As simple as possible***************************************Features***************************************    Automatic support for        * Managing dependencies        * Parallel jobs, including dispatching work to computational clusters        * Re-starting from arbitrary points, especially after errors (checkpointing)        * Display of the pipeline as a flowchart        * Managing complex pipeline topologies***************************************A Simple example***************************************        Use the **@follows(...)** python decorator before the function definitions::            from ruffus import *            import sys            def first_task():                print &quot;First task&quot;            @follows(first_task)            def second_task():                print &quot;Second task&quot;            @follows(second_task)            def final_task():                print &quot;Final task&quot;        the ``@follows`` decorator indicate that the ``first_task`` function precedes ``second_task`` in        the pipeline.        The canonical Ruffus decorator is ``@transform`` which **transforms** data flowing down a        computational pipeline from one stage to teh next.********Usage********    Each stage or **task** in a computational pipeline is represented by a python function    Each python function can be called in parallel to run multiple **jobs**.    1. Import module::            import ruffus    1. Annotate functions with python decorators    2. Print dependency graph if you necessary        - For a graphical flowchart in ``jpg``, ``svg``, ``dot``, ``png``, ``ps``, ``gif`` formats::            pipeline_printout_graph (&quot;flowchart.svg&quot;)        This requires ``dot`` to be installed        - For a text printout of all jobs ::            pipeline_printout(sys.stdout)    3. Run the pipeline::        pipeline_run()</longdescription>
</pkgmetadata>