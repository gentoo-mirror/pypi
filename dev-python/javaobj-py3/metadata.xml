<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># javaobj-py3&lt;p&gt;    &lt;a href=&quot;https://pypi.python.org/pypi/javaobj-py3/&quot;&gt;        &lt;img src=&quot;https://img.shields.io/pypi/v/javaobj-py3.svg&quot; alt=&quot;Latest Version&quot; /&gt;        &lt;img src=&quot;https://img.shields.io/pypi/l/javaobj-py3.svg&quot; alt=&quot;License&quot; /&gt;    &lt;/a&gt;    &lt;a href=&quot;https://travis-ci.org/tcalmant/python-javaobj&quot;&gt;    &lt;img src=&quot;https://travis-ci.org/tcalmant/python-javaobj.svg?branch=master&quot;        alt=&quot;Travis-CI status&quot; /&gt;    &lt;/a&gt;    &lt;a href=&quot;https://coveralls.io/r/tcalmant/python-javaobj?branch=master&quot;&gt;        &lt;img src=&quot;https://coveralls.io/repos/tcalmant/python-javaobj/badge.svg?branch=master&quot;            alt=&quot;Coveralls status&quot; /&gt;    &lt;/a&gt;&lt;/p&gt;*python-javaobj* is a python library that provides functions for reading andwriting (writing is WIP currently) Java objects serialized or will bedeserialized by `ObjectOutputStream`. This form of object representation is astandard data interchange format in Java world.The `javaobj` module exposes an API familiar to users of the standard library`marshal`, `pickle` and `json` modules.## About this repositoryThis project is a fork of *python-javaobj* by Volodymyr Buell, originally from[Google Code](http://code.google.com/p/python-javaobj/) and now hosted on[GitHub](https://github.com/vbuell/python-javaobj).This fork intends to work both on Python 2.7 and Python 3.4+.## Compatibility Warnings### New implementation of the parser| Implementations | Version  ||-----------------|----------|| `v1`, `v2`      | `0.4.0+` |Since version 0.4.0, two implementations of the parser are available:* `v1`: the *classic* implementation of `javaobj`, with a work in progress  implementation of a writer.* `v2`: the *new* implementation, which is a port of the Java project  [`jdeserialize`](https://github.com/frohoff/jdeserialize/),  with support of the object transformer (with a new API) and of the `numpy`  arrays loading.You can use the `v1` parser to ensure that the behaviour of your scriptsdoesn't change and to keep the ability to write down files.You can use the `v2` parser for new developments*which won't require marshalling* and as a *fallback* if the `v1`fails to parse a file.### Object transformers V1| Implementations | Version  ||-----------------|----------|| `v1`            | `0.2.0+` |As of version 0.2.0, the notion of *object transformer* from the originalproject as been replaced by an *object creator*.The *object creator* is called before the deserialization.This allows to store the reference of the converted object before deserializingit, and avoids a mismatch between the referenced object and the transformed one.### Object transformers V2| Implementations | Version  ||-----------------|----------|| `v2`            | `0.4.0+` |The `v2` implementation provides a new API for the object transformers.Please look at the *Usage (V2)* section in this file.### Bytes arrays| Implementations | Version  ||-----------------|----------|| `v1`            | `0.2.3+` |As of version 0.2.3, bytes arrays are loaded as a `bytes` object instead ofan array of integers.### Custom Transformer| Implementations | Version  ||-----------------|----------|| `v2`            | `0.4.2+` |A new transformer API has been proposed to handle objects written with a customJava writer.You can find a sample usage in the *Custom Transformer* section in this file.## Features* Java object instance un-marshalling* Java classes un-marshalling* Primitive values un-marshalling* Automatic conversion of Java Collections to python ones  (`HashMap` =&gt; `dict`, `ArrayList` =&gt; `list`, etc.)* Basic marshalling of simple Java objects (`v1` implementation only)* Automatically uncompresses GZipped files## Requirements* Python &gt;= 2.7 or Python &gt;= 3.4* `enum34` and `typing` when using Python &lt;= 3.4 (installable with `pip`)* Maven 2+ (for building test data of serialized objects.  You can skip it if you do not plan to run `tests.py`)## Usage (V1 implementation)Un-marshalling of Java serialised object:```pythonimport javaobjwith open(&quot;obj5.ser&quot;, &quot;rb&quot;) as fd:    jobj = fd.read()pobj = javaobj.loads(jobj)print(pobj)```Or, you can use `JavaObjectUnmarshaller` object directly:```pythonimport javaobjwith open(&quot;objCollections.ser&quot;, &quot;rb&quot;) as fd:    marshaller = javaobj.JavaObjectUnmarshaller(fd)    pobj = marshaller.readObject()    print(pobj.value, &quot;should be&quot;, 17)    print(pobj.next, &quot;should be&quot;, True)    pobj = marshaller.readObject()```**Note:** The objects and methods provided by `javaobj` module are shortcutsto the `javaobj.v1` package, for Compatibility purpose.It is **recommended** to explicitly import methods and classes from the `v1`(or `v2`) package when writing new code, in order to be sure that your codewon't need import updates in the future.## Usage (V2 implementation)The following methods are provided by the `javaobj.v2` package:* `load(fd, *transformers, use_numpy_arrays=False)`:  Parses the content of the given file descriptor, opened in binary mode (`rb`).  The method accepts a list of custom object transformers. The default object  transformer is always added to the list.  The `use_numpy_arrays` flag indicates that the arrays of primitive type  elements must be loaded using `numpy` (if available) instead of using the  standard parsing technic.* `loads(bytes, *transformers, use_numpy_arrays=False)`:  This the a shortcut to the `load()` method, providing it the binary data  using a `BytesIO` object.**Note:** The V2 parser doesn't have the marshalling capability.Sample usage:```pythonimport javaobj.v2 as javaobjwith open(&quot;obj5.ser&quot;, &quot;rb&quot;) as fd:    pobj = javaobj.load(fd)print(pobj.dump())```### Object TransformerAn object transformer can be called during the parsing of a Java objectinstance or while loading an array.The Java object instance parsing works in two main steps:1. The transformer is called to create an instance of a bean that inherits   `JavaInstance`.1. The latter bean is then called:   * When the object is written with a custom block data   * After the fields and annotations have been parsed, to update the content   of the Python bean.Here is an example for a Java `HashMap` object. You can look at the code ofthe `javaobj.v2.transformer` module to see the whole implementation.```pythonclass JavaMap(dict, javaobj.v2.beans.JavaInstance):    &quot;&quot;&quot;    Inherits from dict for Python usage, JavaInstance for parsing purpose    &quot;&quot;&quot;    def __init__(self):        # Don't forget to call both constructors        dict.__init__(self)        JavaInstance.__init__(self)    def load_from_blockdata(self, parser, reader, indent=0):    &quot;&quot;&quot;    Reads content stored in a block data.    This method is called only if the class description has both the    `SC_EXTERNALIZABLE` and `SC_BLOCK_DATA` flags set.    The stream parsing will stop and fail if this method returns False.    :param parser: The JavaStreamParser in use    :param reader: The underlying data stream reader    :param indent: Indentation to use in logs    :return: True on success, False on error    &quot;&quot;&quot;    # This kind of class is not supposed to have the SC_BLOCK_DATA flag set    return False    def load_from_instance(self, indent=0):        # type: (int) -&gt; bool        &quot;&quot;&quot;        Load content from the parsed instance object.        This method is called after the block data (if any), the fields and        the annotations have been loaded.        :param indent: Indentation to use while logging        :return: True on success (currently ignored)        &quot;&quot;&quot;        # Maps have their content in their annotations        for cd, annotations in self.annotations.items():            # Annotations are associated to their definition class            if cd.name == &quot;java.util.HashMap&quot;:                # We are in the annotation created by the handled class                # Group annotation elements 2 by 2                # (storage is: key, value, key, value, ...)                args = [iter(annotations[1:])] * 2                for key, value in zip(*args):                    self[key] = value                # Job done                return True        # Couldn't load the data        return Falseclass MapObjectTransformer(javaobj.v2.api.ObjectTransformer):    &quot;&quot;&quot;    Creates a JavaInstance object with custom loading methods for the    classes it can handle    &quot;&quot;&quot;    def create_instance(self, classdesc):        # type: (JavaClassDesc) -&gt; Optional[JavaInstance]        &quot;&quot;&quot;        Transforms a parsed Java object into a Python object        :param classdesc: The description of a Java class        :return: The Python form of the object, or the original JavaObject        &quot;&quot;&quot;        if classdesc.name == &quot;java.util.HashMap&quot;:            # We can handle this class description            return JavaMap()        else:            # Return None if the class is not handled            return None```### Custom Object TransformerThe custom transformer is called when the class is not handled by the defaultobject transformer.A custom object transformer still inherits from the `ObjectTransformer` class,but it also implements the `load_custom_writeObject` method.The sample given here is used in the unit tests.#### Java sampleOn the Java side, we create various classes and write them as we wish:```javaclass CustomClass implements Serializable {    private static final long serialVersionUID = 1;    public void start(ObjectOutputStream out) throws Exception {        this.writeObject(out);    }    private void writeObject(ObjectOutputStream out) throws IOException {        CustomWriter custom = new CustomWriter(42);        out.writeObject(custom);        out.flush();    }}class RandomChild extends Random {    private static final long serialVersionUID = 1;    private int num = 1;    private double doub = 4.5;    RandomChild(int seed) {        super(seed);    }}class CustomWriter implements Serializable {    protected RandomChild custom_obj;    CustomWriter(int seed) {        custom_obj = new RandomChild(seed);    }    private static final long serialVersionUID = 1;    private static final int CURRENT_SERIAL_VERSION = 0;    private void writeObject(ObjectOutputStream out) throws IOException {        out.writeInt(CURRENT_SERIAL_VERSION);        out.writeObject(custom_obj);    }}```An here is a sample writing of that kind of object:```javaObjectOutputStream oos = new ObjectOutputStream(    new FileOutputStream(&quot;custom_objects.ser&quot;));CustomClass writer = new CustomClass();writer.start(oos);oos.flush();oos.close();```#### Python sampleOn the Python side, the first step is to define the custom transformers.They are children of the `javaobj.v2.transformers.ObjectTransformer` class.```pythonclass BaseTransformer(javaobj.v2.transformers.ObjectTransformer):    &quot;&quot;&quot;    Creates a JavaInstance object with custom loading methods for the    classes it can handle    &quot;&quot;&quot;    def __init__(self, handled_classes=None):        self.instance = None        self.handled_classes = handled_classes or {}    def create_instance(self, classdesc):        &quot;&quot;&quot;        Transforms a parsed Java object into a Python object        :param classdesc: The description of a Java class        :return: The Python form of the object, or the original JavaObject        &quot;&quot;&quot;        if classdesc.name in self.handled_classes:            self.instance = self.handled_classes[classdesc.name]()            return self.instance        return Noneclass RandomChildTransformer(BaseTransformer):    def __init__(self):        super(RandomChildTransformer, self).__init__(            {&quot;RandomChild&quot;: RandomChildInstance}        )class CustomWriterTransformer(BaseTransformer):    def __init__(self):        super(CustomWriterTransformer, self).__init__(            {&quot;CustomWriter&quot;: CustomWriterInstance}        )class JavaRandomTransformer(BaseTransformer):    def __init__(self):        super(JavaRandomTransformer, self).__init__()        self.name = &quot;java.util.Random&quot;        self.field_names = [&quot;haveNextNextGaussian&quot;, &quot;nextNextGaussian&quot;, &quot;seed&quot;]        self.field_types = [            javaobj.v2.beans.FieldType.BOOLEAN,            javaobj.v2.beans.FieldType.DOUBLE,            javaobj.v2.beans.FieldType.LONG,        ]    def load_custom_writeObject(self, parser, reader, name):        if name != self.name:            return None        fields = []        values = []        for f_name, f_type in zip(self.field_names, self.field_types):            values.append(parser._read_field_value(f_type))            fields.append(javaobj.beans.JavaField(f_type, f_name))        class_desc = javaobj.beans.JavaClassDesc(            javaobj.beans.ClassDescType.NORMALCLASS        )        class_desc.name = self.name        class_desc.desc_flags = javaobj.beans.ClassDataType.EXTERNAL_CONTENTS        class_desc.fields = fields        class_desc.field_data = values        return class_desc```Second step is defining the representation of the instances, where the realobject loading occurs. Those classes inherit from`javaobj.v2.beans.JavaInstance`.```pythonclass CustomWriterInstance(javaobj.v2.beans.JavaInstance):    def __init__(self):        javaobj.v2.beans.JavaInstance.__init__(self)    def load_from_instance(self):        &quot;&quot;&quot;        Updates the content of this instance        from its parsed fields and annotations        :return: True on success, False on error        &quot;&quot;&quot;        if self.classdesc and self.classdesc in self.annotations:            # Here, we known there is something written before the fields,            # even if it's not declared in the class description            fields = [&quot;int_not_in_fields&quot;] + self.classdesc.fields_names            raw_data = self.annotations[self.classdesc]            int_not_in_fields = struct.unpack(                &quot;&gt;i&quot;, BytesIO(raw_data[0].data).read(4)            )[0]            custom_obj = raw_data[1]            values = [int_not_in_fields, custom_obj]            self.field_data = dict(zip(fields, values))            return True        return Falseclass RandomChildInstance(javaobj.v2.beans.JavaInstance):    def load_from_instance(self):        &quot;&quot;&quot;        Updates the content of this instance        from its parsed fields and annotations        :return: True on success, False on error        &quot;&quot;&quot;        if self.classdesc and self.classdesc in self.field_data:            fields = self.classdesc.fields_names            values = [                self.field_data[self.classdesc][self.classdesc.fields[i]]                for i in range(len(fields))            ]            self.field_data = dict(zip(fields, values))            if (                self.classdesc.super_class                and self.classdesc.super_class in self.annotations            ):                super_class = self.annotations[self.classdesc.super_class][0]                self.annotations = dict(                    zip(super_class.fields_names, super_class.field_data)                )            return True        return False```Finally we can use the transformers in the loading process.Note that even if it is not explicitly given, the `DefaultObjectTransformer`will be also be used, as it is added automatically by `javaobj` if it ismissing from the given list.```python# Load the object using those transformerstransformers = [    CustomWriterTransformer(),    RandomChildTransformer(),    JavaRandomTransformer()]pobj = javaobj.loads(&quot;custom_objects.ser&quot;, *transformers)# Here we show a field that isn't visible from the class description# The field belongs to the class but it's not serialized by default because# it's static. See: https://stackoverflow.com/a/16477421/12621168print(pobj.field_data[&quot;int_not_in_fields&quot;])```</longdescription>
</pkgmetadata>