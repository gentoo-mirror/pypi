<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># MatchSpecA Conda MatchSpec implementation in pure Rust. This allows you to parse a matchspec and validate it against a package to see if it matches.# Python LibraryThis library exposes a few simple functions:## `match_against_matchspec()`Takes a `matchspec` as a `str` and matches it against a `package_name` and `version` (both `str`). Returns a `bool`.``` pythonimport rust_matchspecrust_matchspec.match_against_matchspec('python&gt;=3.0', 'python', '3.10.1') # returns True```## `filter_package_list()`Takes a `list` of `dicts` and returns all the dicts inside that match a given matchspec. The `dicts` must have a `name` key with a `str` value, but all other fields are optional.```pythonimport rust_matchspeclist = [{'name': 'tensorflow', 'version': '2.10.0'},{'name': 'pytorch', 'version': '2.0.0'},{'name': 'pytorch', 'version': '1.11.1'}]rust_matchspec.filter_package_list('pytorch&gt;1.12', list) # returns [PackageCandidate(name=pytorch)]```Possible keys:| Key          | Expected Type | Required? ||--------------|---------------|-----------|| name         | str           | yes       || version      | str           |           || build        | str           |           || build_number | u32           |           || depends      | [str]         |           || license      | str           |           || md5          | str           |           || sha256       | str           |           || size         | u64           |           || subdir       | str           |           || timestamp    | u64           |           |## `parallel_filter_package_list()`Using all available cores will take a `list` of `dicts` and returns all the dicts inside that match a given matchspec. The `dicts` must have a `name` key with a `str` value, but all other fields are optional.**Note** Probably won't show any noticable speed improvements until your list of packages is in the millions.```pythonimport rust_matchspeclist = [{'name': 'tensorflow', 'version': '2.10.0'},{'name': 'pytorch', 'version': '2.0.0'},{'name': 'pytorch', 'version': '1.11.1'}]rust_matchspec.parallel_filter_package_list('pytorch&gt;1.12', list) # returns [PackageCandidate(name=pytorch)]```## `parallel_filter_package_list_with_matchspec_list()`Using all available cores will take a `list` of `dicts` and a `list` of Matchspecs (as `str`) and returns all the dicts inside that match any given matchspec. The `dicts` must have a `name` key with a `str` value, but all other fields are optional. **May contain duplicates** since it runs all of the matchspecs against the package list in parallel and does not dedup the resulting matches.In my testing this has a very small overhead, but matching 4 matchspecs is approximately the same speed as matching a single matchspec with the other functions.```pythonimport rust_matchspecpackage_list = [{'name': 'tensorflow', 'version': '2.10.0'},{'name': 'pytorch', 'version': '2.0.0'},{'name': 'pytorch', 'version': '1.11.1'}]matchspec_list = ['python&gt;=3.9.1', 'pytorch&gt;1.12']rust_matchspec.parallel_filter_package_list_with_matchspec_list(matchspec_list, package_list) # returns [PackageCandidate(name=pytorch)]```# Rust Library## ExampleThe way you instantiate a MatchSpec is by parsing a string into the type:```rustuse rust_matchspec::{CompoundSelector, MatchSpec, Selector};// Create the MatchSpec by parsing a String or &amp;strlet matchspec: MatchSpec = &quot;main/linux-64::pytorch&gt;1.10.2&quot;.parse().unwrap();// You then have the data accessible inside the MatchSpec struct if you want it// Package name is the only mandatory field in a matchspecassert_eq!(&amp;matchspec.package, &quot;pytorch&quot;);// These are optional, so they will be wrapped in an Optionassert_eq!(matchspec.channel, Some(&quot;main&quot;.to_string()));assert_eq!(matchspec.version,Some(CompoundSelector::Single {selector: Selector::GreaterThan,version: &quot;1.10.2&quot;.to_string(),}));// You can also check to see if a package name and version match the spec.// This is a faster function that allows us to bypass some sometimes unnecessary tests like channel or subdirassert!(matchspec.is_package_version_match(&amp;&quot;pytorch&quot;, &amp;&quot;1.11.0&quot;))```## BenchmarkingThis library contains benchmarks aimed at checking the speed of our implementation against other languages and ensure speed doesn't regress. These are contrived benchmarks to test raw speed, so take them (and all benchmarks) with a bit of skepticism. Benchmark harnesses and the data all need to be identical for a benchmark to really provide value.### PythonThe Python benchmarks use [pytest-benchmark](https://pytest-benchmark.readthedocs.io/en/stable/).Steps to run the benchmarks:```bash# Setup the conda envconda env create -f ./environment.ymlconda activate rust_matchspec# Build an optimized wheelmaturin build --release# install itpip install ./target/wheels/rust_matchspec*.whl# Finally, run the benchmarkpytest```### RustThe Rust benchmarks use [Criterion.rs](https://bheisler.github.io/criterion.rs/book/criterion_rs.html) to provide the benchmarking framework. Its pretty easy to run the benchmarks on stable rust:```bashcargo bench # Or if you're on mac and get errors with Invalid Symbols:cargo bench --no-default-features```This will automatically track benchmark timings across runs. If you do this on a laptop or workstation be aware that you may have regressions show up if you have background processes or other things happening. I would recommend always running the benchmarks at a similar level of CPU load. If you want consistent testing its probably best to quit your browser or anything in the background that might be eating CPU or doing IO.</longdescription>
</pkgmetadata>