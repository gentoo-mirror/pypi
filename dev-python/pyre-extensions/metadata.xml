<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Pyre ExtensionsThis module defines extensions to the standard “typing” module that are supported by the [Pyre typechecker](https://pypi.org/project/pyre-check/).## `none_throws`Function to make assumptions about `Optional`s explicit. The function will raise anassertion error if passed `None` and return the value otherwise.## ParameterSpecification`ParameterSpecification`s are a special kind of type variable that captures callable parameterspecifications (known as argspecs in the runtime and inspect library) instead of types, allowingthe typing of decorators which transform the return type of the given callable.For example:```from typing import TypeVar, Callable, Listfrom pyre_extensions import ParameterSpecificationTParams = ParameterSpecification(&quot;TParams&quot;)TReturn = TypeVar(&quot;TReturn&quot;)def unwrap(f: Callable[TParams, List[TReturn]]) -&gt; Callable[TParams, TReturn]:    def inner(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; TReturn:        return f(*args, **kwargs)[0]    return inner@unwrapdef foo(x: int, y: str, z: bool = False) -&gt; List[int]:    return [1, 2, 3]```decorates foo into a callable that returns int, but still has the same parameters, including theirnames and whether they are required.These `ParameterSpecification` variables also have two special properties, `args` and `kwargs`,which correspond to the positional and keyword arguments for a specific call to the`ParameterSpecification` function.  Because the division of parameters into these two argumentcollections can be different each invocation, these special annotations can only be used in onemanner: together, in a function definition, as `*args` and `**kwargs` with no other parameterslisted.## Safe JSONThe `safe_json` module provides a type-safe way to parse JSON. It is meant as a drop-in replacementfor the builtin `json` module but instead of returning an object of undefined shape (i.e. `Any`)allows you to specify the shape of the JSON you're expecting. The parser will validate whether theinput matches the expected type and raise an exception if it does not.### ExamplesFor trivial JSON structures you can use builtin types:```python&gt;&gt;&gt; from pyre_extensions import safe_json&gt;&gt;&gt; from typing import List, Dict&gt;&gt;&gt; safe_json.loads(&quot;[1, 2, 3]&quot;, List[int])[1, 2, 3]&gt;&gt;&gt; safe_json.loads(&quot;[1, 2, 3]&quot;, List[str])# Raises `pyre_extensions.safe_json.InvalidJson`&gt;&gt;&gt; safe_json.loads('{&quot;key&quot;: &quot;value&quot;}', Dict[str, str]){'key': 'value'}&gt;&gt;&gt; safe_json.loads('{&quot;key&quot;: &quot;value&quot;}', Dict[str, int])# Raises `pyre_extensions.safe_json.InvalidJson````For more complicated, nested structures, typed dictionaries are the way to go:```python&gt;&gt;&gt; from typing import TypedDict&gt;&gt;&gt; class Movie(TypedDict):...     name: str...     year: int...&gt;&gt;&gt; safe_json.loads('{&quot;name&quot;: &quot;Blade Runner&quot;, &quot;year&quot;: 1982 }', Movie){'name': 'Blade Runner', 'year': 1982}&gt;&gt;&gt; safe_json.loads('{&quot;name&quot;: &quot;Blade Runner&quot;, &quot;year&quot;: &quot;1982&quot; }', Movie)# Raises `pyre_extensions.safe_json.InvalidJson````Validate if data is expected type:```python&gt;&gt;&gt; from pyre_extensions import safe_json&gt;&gt;&gt; from typing import List, Dict&gt;&gt;&gt; data = {&quot;foo&quot;: 23}&gt;&gt;&gt; safe_json.validate(data, Dict[str, str])# Raises `pyre_extensions.safe_json.InvalidJson`&gt;&gt;&gt; safe_json.validate(data, Dict[str, int]){&quot;foo&quot;: 23}```</longdescription>
</pkgmetadata>