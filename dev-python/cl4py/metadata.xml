<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>cl4py - Common Lisp for Python==============================The library cl4py (pronounce as *clappy*) allows Python programs to callCommon Lisp libraries.  Its official mascot is the cl4py-bird:.. image:: ./cl4py.pngMotivation----------You are a Python programmer, but you want access to some of the powerfulfeatures of Lisp, for example to compile code at run time?  Or you want touse some `awesome Lisp libraries &lt;http://codys.club/awesome-cl/&gt;`_?  Oryou are a Lisp programmer and want to show your work to your Pythonfriends.  In all these cases, cl4py is here to help you.Tutorial--------You can start any number of Lisp subprocesses within Python, like this:.. code:: python    &gt;&gt;&gt; import cl4py    &gt;&gt;&gt; lisp = cl4py.Lisp()Of course, this requires you have some Lisp installed. If not, usesomething like ``apt install sbcl``, ``pacman -S sbcl`` or ``brew installsbcl`` to correct this deficiency.  Once you have a running Lisp process,you can execute Lisp code on it:.. code:: python    # In Lisp, numbers evaluate to themselves.    &gt;&gt;&gt; lisp.eval( 42 )    42    # ('+', 2, 3) is a short notation for cl4py.List(cl4py.Symbol('+'), 2, 3).    # For convenience, whenever a Python tuple is converted to Lisp    # data, any strings therein are automatically converted to Lisp symbols.    &gt;&gt;&gt; lisp.eval( ('+', 2, 3) )    5    # Nested expressions are allowed, too.    &gt;&gt;&gt; lisp.eval( ('/', ('*', 3, 5), 2) )    Fraction(15, 2)    # Use cl4py.List instead of tuples to avoid the automatic conversion of    # strings to symbols.    &gt;&gt;&gt; lisp.eval( cl4py.List(cl4py.Symbol('STRING='), 'foo', 'bar') )    ()    &gt;&gt;&gt; lisp.eval( cl4py.List(cl4py.Symbol('STRING='), 'foo', 'foo') )    True    # Here is how you can lookup a symbol's value:    &gt;&gt;&gt; lisp.eval(cl4py.Symbol('*PRINT-BASE*', 'COMMON-LISP'))    10    # Of course you can also use Lisp macros:    &gt;&gt;&gt; lisp.eval( ('loop', 'for', 'i', 'below', 5, 'collect', 'i') )    List(0, 1, 2, 3, 4)    &gt;&gt;&gt; lisp.eval( ('with-output-to-string', ('stream',),                      ('princ', 12, 'stream'),                      ('princ', 34, 'stream')) )    '1234'A cl4py.Lisp object not only provides ``eval``, but also methods forlooking up functions and packages:.. code:: python    &gt;&gt;&gt; add = lisp.function('+')    &gt;&gt;&gt; add(1, 2, 3, 4)    10    &gt;&gt;&gt; div = lisp.function('/')    &gt;&gt;&gt; div(2, 4)    Fraction(1, 2)    # Lisp packages are automatically converted to Python modules.    &gt;&gt;&gt; cl = lisp.find_package('CL')    &gt;&gt;&gt; cl.oddp(5)    True    &gt;&gt;&gt; cl.cons(5, None)    List(5)    &gt;&gt;&gt; cl.remove(5, [1, -5, 2, 7, 5, 9], key=cl.abs)    [1, 2, 7, 9]    # Higher-order functions work, too!    &gt;&gt;&gt; cl.mapcar(cl.constantly(4), (1, 2, 3))    List(4, 4, 4)    # cl4py even supports macros and special forms as a thin    # wrapper around lisp.eval.    &gt;&gt;&gt; cl.loop('repeat', 5, 'collect', 42)    List(42, 42, 42, 42, 42)    &gt;&gt;&gt; cl.progn(5, 6, 7, ('+', 4, 4))    8When converting Common Lisp packages to Python modules, we run into theproblem that not every Common Lisp symbol name is a valid Pythonidentifier.  As a remedy, so we attempt to substitute problematiccharacters and symbols with something that Python can digest.  Here you cansee this substitution rules in action:.. code:: python    # hyphens are turned into underscores    &gt;&gt;&gt; cl.type_of(&quot;foo&quot;)    List(Symbol(&quot;SIMPLE-ARRAY&quot;, &quot;COMMON-LISP&quot;), Symbol(&quot;CHARACTER&quot;, &quot;COMMON-LISP&quot;), List(3))    # The functions +, -, *, /, 1+, and 1- are renamed to add, sub,    # mul, div, inc, and dec, respectively.    &gt;&gt;&gt; cl.add(2,3,4,5)    14    # Within a string, occurrences of -, *, +, &lt;=, &lt;, =, /=, &gt;=, gt, and ~,    # are replaced by _, O, X, le, lt, sim, ne, ge, ge, gt, and tilde, respectively.    &gt;&gt;&gt; cl.stringgt('baz', 'bar')    2    # Earmuffs are stripped    &gt;&gt;&gt; cl.print_base    10    # Constants are capitalized    &gt;&gt;&gt; cl.MOST_POSITIVE_DOUBLE_FLOAT    1.7976931348623157e+308The cl4py module provides a Cons class that mimics cons cells in Lisp... code:: python    &gt;&gt;&gt; lisp.eval( ('CONS', 1, 2) )    Cons(1, 2)    &gt;&gt;&gt; lst = lisp.eval( ('CONS', 1, ('CONS', 2, () )) )    List(1, 2)    &gt;&gt;&gt; lst.car    1    &gt;&gt;&gt; lst.cdr    List(2) # an abbreviation for Cons(2, ())    # cl4py Conses are iterable!    &gt;&gt;&gt; list(lst)    [1, 2]    &gt;&gt;&gt; sum(lst)    3    # cl4py also supports dotted and circular lists.    &gt;&gt;&gt; lisp.eval( ('CONS', 1, ('CONS', 2, 3 )) )    DottedList(1, 2, 3)    &gt;&gt;&gt; twos = cl.cons(2,2)    &gt;&gt;&gt; twos.cdr = twos    &gt;&gt;&gt; twos    DottedList(2, ...)    &gt;&gt;&gt; cl.mapcar(lisp.function('+'), (1, 2, 3, 4), twos)    List(3, 4, 5, 6)Frequently Asked Problems-------------------------Why does my Lisp subprocess complain about ``Package QL does not exist``.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^By default, cl4py starts a Lisp subprocess with ``sbcl --script``.  Thismeans, that the Lisp process will ignore any user initialization files,including the Quicklisp setup.  However, we provide an extra option forinstalling and loading Quicklisp automatically: ``quicklisp=True``.. code:: python    &gt;&gt;&gt; lisp = cl4py.Lisp(quicklisp=True);    &gt;&gt;&gt; ql = lisp.find_package('QL')    &gt;&gt;&gt; ql.quickload('YOUR-SYSTEM')Related Projects-----------------  `burgled-batteries &lt;https://github.com/pinterface/burgled-batteries&gt;`_   - A bridge between Python and Lisp. The goal is that Lisp programs can   use Python libraries, which is in some sense the opposite of   cl4py. Furthermore it relies on the less portable mechanism of FFI   calls.-  `CLAUDE &lt;https://www.nicklevine.org/claude/&gt;`_   - An earlier attempt to access Lisp libraries from Python. The key   difference is that cl4py does not run Lisp directly in the host   process. This makes cl4py more portable, but complicates the exchange of   data.-  `cl-python &lt;https://github.com/metawilm/cl-python&gt;`_   - A much heavier solution than cl4py --- let's simply implement Python   in Lisp! An amazing project. However, cl-python cannot access foreign   libraries, e.g., NumPy. And people are probably hesitant to migrate away   from CPython.-  `Hy &lt;http://docs.hylang.org/en/stable/&gt;`_   - Python, but with Lisp syntax. This project is certainly a great way to   get started with Lisp. It allows you to study the advantages of Lisp's   seemingly weird syntax, without leaving the comfortable Python   ecosystem. Once you understand the advantages of Lisp, you will doubly   appreciate cl4py for your projects.-  `py4cl &lt;https://github.com/bendudson/py4cl&gt;`_   - A library that allows Common Lisp code to access Python libraries.  It   is basically the inverse of cl4py.</longdescription>
</pkgmetadata>