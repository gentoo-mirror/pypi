<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://github.com/viktor-ktorvi/mlpf/assets/69254199/333dfd18-7c60-4874-a89b-92eecf32ac96?raw=True&quot; width=&quot;650&quot;&gt;&lt;/p&gt;__MLPF__ is a python library for (optimal) power flow calculations with machine learning.It offers a few main features such as::chart_with_downwards_trend: Efficient loss functions compatible with both _PyTorch_ &lt;img src=&quot;https://pytorch.org/assets/images/pytorch-logo.png&quot; height=30&gt;&lt;/img&gt; and _scikit-learn_ &lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/0/05/Scikit_learn_logo_small.svg&quot; height=30&gt;&lt;/img&gt;.ðŸ’± Conversion functions to go from [PPCs](https://rwl.github.io/PYPOWER/api/pypower.caseformat-module.html) to _NumPy_ arrays or _Torch_ tensors.&lt;br&gt;As well as some optional high level utilities:ðŸ—‚ï¸ Data classes that make it easy to go from PPCs to custom (or [PyTorch Geometric](https://pytorch-geometric.readthedocs.io/en/latest/)&lt;img src=&quot;https://raw.githubusercontent.com/pyg-team/pyg_sphinx_theme/master/pyg_sphinx_theme/static/img/pyg_logo.png&quot; height=30&gt;&lt;/img&gt; ) data objects with all the info needed for (O)PF extracted.ðŸ“Š Metrics specific to (O)PF for logging and evaluation.ðŸ”Ž Visualization and description tools to take a quick look at your data.Contributions welcome!## Installation```commandlinepip install mlpf```The previous command will install all the dependencies for working with numpy and scikit-learn. It will **not**, however, install all the dependencies needed forworking with torch. To use the torch functionalities, pleaseinstall [PyTorch](https://pytorch.org/), [PyTorch Geometric](https://pytorch-geometric.readthedocs.io/en/latest/install/installation.html) with its dependencies(torch-scatter etc.)and optionally [TorchMetrics](https://torchmetrics.readthedocs.io/en/stable/).## Basic usage:cd: :file_folder:    Load your data in the [PYPOWER case format](https://rwl.github.io/PYPOWER/api/pypower.caseformat-module.html).:open_file_folder: :arrow_heading_up:    Extract powers, voltages, limits and cost coefficients from the PPCs into either _NumPy_ arrays or _torch_ tensors.ðŸ‹ðŸ»â€â™€ï¸ :chart_with_downwards_trend:    Plug the data into your machine learning models.:chart_with_upwards_trend: :bar_chart:     Use the loss functions to evaluate your results or to train your models(the _torch_ versions of the loss functions are differentiable!).### Losses#### Power flow&lt;details&gt;&lt;summary&gt;ppc&lt;/summary&gt;```pythonimport copyimport pandapower as ppimport pandapower.networks as pnfrom pypower.ppoption import ppoptionfrom pypower.runpf import runpfnet = pn.case118()ppc = pp.converter.to_ppc(net, init=&quot;flat&quot;)ppopt = ppoption(OUT_ALL=0, VERBOSE=0)ppc, converged = runpf(copy.deepcopy(ppc), ppopt=ppopt)```&lt;/details&gt;##### NumPy/scikit-learn```pythonimport numpy as npfrom mlpf.data.conversion.numpy.power_flow import (  extract_line_arrays,  extract_power_arrays,  extract_voltage_arrays)from mlpf.loss.numpy.power_flow import (  active_power_errors,  reactive_power_errors)# extract quantitiesactive_powers, reactive_powers = extract_power_arrays(ppc)voltage_magnitudes, voltage_angles = extract_voltage_arrays(ppc)edge_index, conductances, susceptances = extract_line_arrays(ppc)active_errors = active_power_errors(edge_index, active_powers, voltage_magnitudes, voltage_angles, conductances, susceptances)reactive_errors = reactive_power_errors(edge_index, reactive_powers, voltage_magnitudes, voltage_angles, conductances, susceptances)print(f&quot;Total P loss = {np.sum(active_errors):.3e} p.u.&quot;)print(f&quot;Total Q loss = {np.sum(reactive_errors):.3e} p.u.&quot;)```##### Torch```pythonimport torchfrom mlpf.data.conversion.torch.power_flow import (  extract_line_tensors,  extract_power_tensors,  extract_voltage_tensors)from mlpf.loss.torch.power_flow import (  active_power_errors,  reactive_power_errors)# extract quantities# note: going from float64 to float32(the standard in torch) will increase the PF loss significantlyactive_powers, reactive_powers = extract_power_tensors(ppc, dtype=torch.float64)voltage_magnitudes, voltage_angles = extract_voltage_tensors(ppc, dtype=torch.float64)edge_index, conductances, susceptances = extract_line_tensors(ppc, dtype=torch.float64)active_errors = active_power_errors(edge_index, active_powers, voltage_magnitudes, voltage_angles, conductances, susceptances)reactive_errors = reactive_power_errors(edge_index, reactive_powers, voltage_magnitudes, voltage_angles, conductances, susceptances)print(f&quot;Total P loss = {torch.sum(active_errors):.3e} p.u.&quot;)print(f&quot;Total Q loss = {torch.sum(reactive_errors):.3e} p.u.&quot;)```#### Optimal power flow&lt;details&gt;&lt;summary&gt;ppc&lt;/summary&gt;```pythonimport copyimport pandapower as ppimport pandapower.networks as pnfrom pypower.ppoption import ppoptionfrom pypower.runopf import runopfnet = pn.case118()ppc = pp.converter.to_ppc(net, init=&quot;flat&quot;)ppopt = ppoption(OUT_ALL=0, VERBOSE=0)ppc = runopf(copy.deepcopy(ppc), ppopt=ppopt)```&lt;/details&gt;##### NumPy/scikit-learn```pythonimport numpy as npfrom mlpf.data.conversion.numpy.optimal_power_flow import (  extract_active_power_limits_arrays,  extract_cost_coefficients_array,  extract_demand_arrays,  extract_reactive_power_limits_arrays,  extract_voltage_limits_arrays,)from mlpf.data.conversion.numpy.power_flow import (  extract_power_arrays,  extract_voltage_arrays)from mlpf.loss.numpy.bound_errors import (  lower_bound_errors,  upper_bound_errors)from mlpf.loss.numpy.costs import polynomial_costs# extract quantitiesactive_powers, reactive_powers = extract_power_arrays(ppc)voltage_magnitudes, voltage_angles = extract_voltage_arrays(ppc)voltages_min, voltages_max = extract_voltage_limits_arrays(ppc)active_powers_min, active_powers_max = extract_active_power_limits_arrays(ppc)reactive_powers_min, reactive_powers_max = extract_reactive_power_limits_arrays(ppc)active_power_demands, _ = extract_demand_arrays(ppc)active_powers_generation = (active_powers + active_power_demands) * ppc[&quot;baseMVA&quot;]cost_coefficients = extract_cost_coefficients_array(ppc)# calculate errorsvoltage_upper_errors = upper_bound_errors(voltage_magnitudes, voltages_max)voltage_lower_errors = lower_bound_errors(voltage_magnitudes, voltages_min)active_upper_errors = upper_bound_errors(active_powers, active_powers_max)active_lower_errors = lower_bound_errors(active_powers, active_powers_min)reactive_upper_errors = upper_bound_errors(reactive_powers, reactive_powers_max)reactive_lower_errors = lower_bound_errors(reactive_powers, reactive_powers_min)cost_errors = np.sum(polynomial_costs(active_powers_generation, cost_coefficients)) - ppc[&quot;f&quot;]print(f&quot;Total V max violation = {np.sum(voltage_upper_errors):.3e} p.u.&quot;)print(f&quot;Total V min violation = {np.sum(voltage_lower_errors):.3e} p.u.&quot;)print(f&quot;Total P max violation = {np.sum(active_upper_errors):.3e} p.u.&quot;)print(f&quot;Total P min violation = {np.sum(active_lower_errors):.3e} p.u.&quot;)print(f&quot;Total Q max violation = {np.sum(reactive_upper_errors):.3e} p.u.&quot;)print(f&quot;Total Q min violation = {np.sum(reactive_lower_errors):.3e} p.u.&quot;)print(f&quot;Total costs = {cost_errors:.3e} $/h&quot;)``````pythonimport torchfrom mlpf.data.conversion.torch.optimal_power_flow import (  extract_active_power_limits_tensors,  extract_cost_coefficients_tensor,  extract_demand_tensors,  extract_reactive_power_limits_tensors,  extract_voltage_limits_tensors,)from mlpf.data.conversion.torch.power_flow import (  extract_power_tensors,  extract_voltage_tensors)from mlpf.loss.torch.bound_errors import (  lower_bound_errors,  upper_bound_errors)from mlpf.loss.torch.costs import polynomial_costs# extract quantitiesactive_powers, reactive_powers = extract_power_tensors(ppc, dtype=torch.float64)voltage_magnitudes, voltage_angles = extract_voltage_tensors(ppc, dtype=torch.float64)voltages_min, voltages_max = extract_voltage_limits_tensors(ppc, dtype=torch.float64)active_powers_min, active_powers_max = extract_active_power_limits_tensors(ppc, dtype=torch.float64)reactive_powers_min, reactive_powers_max = extract_reactive_power_limits_tensors(ppc, dtype=torch.float64)active_power_demands, _ = extract_demand_tensors(ppc, dtype=torch.float64)active_powers_generation = (active_powers + active_power_demands) * ppc[&quot;baseMVA&quot;]cost_coefficients = extract_cost_coefficients_tensor(ppc, dtype=torch.float64)# calculate errorsvoltage_upper_errors = upper_bound_errors(voltage_magnitudes, voltages_max)voltage_lower_errors = lower_bound_errors(voltage_magnitudes, voltages_min)active_upper_errors = upper_bound_errors(active_powers, active_powers_max)active_lower_errors = lower_bound_errors(active_powers, active_powers_min)reactive_upper_errors = upper_bound_errors(reactive_powers, reactive_powers_max)reactive_lower_errors = lower_bound_errors(reactive_powers, reactive_powers_min)cost_errors = torch.sum(polynomial_costs(active_powers_generation, cost_coefficients)) - ppc[&quot;f&quot;]print(f&quot;Total V max violation = {torch.sum(voltage_upper_errors):.3e} p.u.&quot;)print(f&quot;Total V min violation = {torch.sum(voltage_lower_errors):.3e} p.u.&quot;)print(f&quot;Total P max violation = {torch.sum(active_upper_errors):.3e} p.u.&quot;)print(f&quot;Total P min violation = {torch.sum(active_lower_errors):.3e} p.u.&quot;)print(f&quot;Total Q max violation = {torch.sum(reactive_upper_errors):.3e} p.u.&quot;)print(f&quot;Total Q min violation = {torch.sum(reactive_lower_errors):.3e} p.u.&quot;)print(f&quot;Total costs = {cost_errors:.3e} $/h&quot;)```##### Torch### Examples|                          | Power flow                                                                                                                                                                                                                                   | Optimal power flow                                                                                                                                                                                                                                                   ||--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | Data extraction and loss | &lt;ul&gt;&lt;li&gt;[NumPy/scikit-learn](examples/sklearn/loss/power_flow.py)&lt;/li&gt;&lt;li&gt;[torch](examples/torch/loss/power_flow.py)&lt;/li&gt;&lt;/ul&gt;                                                                                                               | &lt;ul&gt;&lt;li&gt;[NumPy/scikit-learn](examples/sklearn/loss/optimal_power_flow.py)&lt;/li&gt;&lt;li&gt;[torch](examples/torch/loss/optimal_power_flow.py)&lt;/li&gt;&lt;/ul&gt;                                                                                                                       | | Supervised               | &lt;ul&gt;&lt;li&gt;[scikit-learn linear regression](examples/sklearn/supervised/power_flow/linear_regression.py)&lt;li&gt;[torch MLP](examples/torch/supervised/power_flow/mlp.py)&lt;/li&gt;&lt;li&gt;[torch GCN](examples/torch/supervised/power_flow/gcn.py)&lt;/li&gt;&lt;/ul&gt; | &lt;ul&gt;&lt;li&gt;[scikit-learn linear regression](examples/sklearn/supervised/optimal_power_flow/linear_regression.py)&lt;li&gt;[torch MLP](examples/torch/supervised/optimal_power_flow/mlp.py)&lt;/li&gt;&lt;li&gt;[torch GCN](examples/torch/supervised/optimal_power_flow/gcn.py)&lt;/li&gt;&lt;/ul&gt; || Unsupervised             | &lt;ul&gt;&lt;li&gt;[torch MLP](examples/torch/unsupervised/power_flow/mlp.py)&lt;/li&gt;&lt;li&gt;[torch GCN](examples/torch/unsupervised/power_flow/gcn.py)&lt;/li&gt;&lt;/ul&gt;                                                                                              | &lt;ul&gt;&lt;li&gt;[torch MLP](examples/torch/unsupervised/optimal_power_flow/mlp.py)&lt;/li&gt;&lt;li&gt;[torch GCN](examples/torch/unsupervised/optimal_power_flow/gcn.py)&lt;/li&gt;&lt;/ul&gt;                                                                                                      |### Development```git clone https://github.com/viktor-ktorvi/mlpf.gitcd mlpfconda env create -f environment.ymlconda activate mlpfenv```</longdescription>
</pkgmetadata>