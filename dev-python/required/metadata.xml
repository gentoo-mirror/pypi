<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># required: Easy multi-field validation[![PyPI](https://img.shields.io/pypi/v/required.svg)]()[![Build Status](https://travis-ci.org/shezadkhan137/required.svg?branch=master)](https://travis-ci.org/shezadkhan137/required)[![Coverage Status](https://coveralls.io/repos/github/shezadkhan137/required/badge.svg?branch=master)](https://coveralls.io/github/shezadkhan137/required?branch=master)Required is a simple library which allows you to validate dependenciesacross multiple fields. The goal is to make writing things like forms, seralizers and functions much easier by providing a declarative way to encode validation logic. It aims to:-  Have a declarative way to encode validation logic-  Allow you to maintain validation logic easily-  Allow you to reuse your validation logic easily-  Be flexible with what you want to validateIf this all sounds good. Read On!## Installation Install using `pip````pip install required```## QuickstartYou can use required in a number of ways. The easiest way is to use the `validate` decorator to validate inputs to function calls. ```pythonfrom required import validate@validatedef calculate_sum(positive_number, negative_number):    &quot;&quot;&quot;    positive_number -&gt; positive_number &gt; 0    negative_number -&gt; negative_number &lt; 0    &quot;&quot;&quot;    return positive_number + negative_number# the following will raise a validation exceptioncalculate_sum(1, 1)# this will pass validationcalculate_sum(1, -1) # 0```If you want to have other information in the docstring, the validation rules can be wrapped inside of `Requires { }` as shown below:```python@validatedef calculate_sum(positive_number, negative_number):    &quot;&quot;&quot;    Other documentation relating to calculate_sum    Requires {        positive_number -&gt; positive_number &gt; 0        negative_number -&gt; negative_number &lt; 0    }    You can also put information after the requires rules    &quot;&quot;&quot;    return positive_number + negative_number```Validation rules are written in the doc string of the function. They look like: `[param] -&gt; [expression_1] [comparator] [expression_2]`When `param` is present, it requires `expression_1 [comparator] expression_2` to evaluate to true. The most simple expressions are just variables passed into the function to validate, however they can be more complex. See cookbook for more examples.The comparator can be one of the standard python comparator operations; `==`, `!=`, `in`, `&gt;=` `&lt;=`, `&gt;`, `&lt;`.## CookbookThe following shows some examples for writing validation rules```# Arithmetic on the objects follow normal maths rules.# you need to put brackets to define expressionsx -&gt; (x + 1) &lt; 1x -&gt; (x - y) == 1# A value `x` needs to be in an arrayx -&gt; x in arr# The length of x must be 10# see section on registering functionsx -&gt; len(x) == 10# The length of x and y must be the samex -&gt; len(x) == len(y)# when x is present y must not be present# TODO: not implemented in DSL yetx -&gt; x == &lt;empty&gt;# x must be equal to the return value of a functionx -&gt; x == func(x)# Partial dependencies can be also specified# when x == 1 then y must be 2x == 1 -&gt; y == 2# when x == 1 then y must be setx == 1 -&gt; y```## Registering callablesYou can register callables into the validation scope. This is useful when you want to call normal python builtins or custom callables. ```pythonfrom required import validatescoped_validate = validate.register_callables({ &quot;len&quot;: len, &quot;abs&quot;: abs})@scoped_validatedef return_first_element(arr):    &quot;&quot;&quot;    arr -&gt; len(arr) &gt;= 1    &quot;&quot;&quot;    return arr[0]# validation scoped callables can also be nested# len, abs and my_func are available in the second_scoped_validate decoratorsecond_scoped_validate = scoped_validate.register_callables({    &quot;my_func&quot;: my_func})# or inserted at function level@validate(callable_dict={&quot;new_func&quot;: new_func})def other_function(var):    &quot;&quot;&quot;    var -&gt; new_func(var) &gt;= 1    &quot;&quot;&quot;    return var```## Contributing If you want to contribute you are most welcome! This project is distributed under the [MIT](https://choosealicense.com/licenses/mit/) licence. It is tested using [tox](https://pypi.python.org/pypi/tox) against Python 2.7 and 3.4+</longdescription>
</pkgmetadata>