<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Welcome to _BatchX' python toolbox_, or _&quot;the toolbox&quot;_ for short.The toolbox makes the life of BatchX (python) developers **more pleasant**.To do so, it provides tools that help devs to work more effectively.# Table of Contents- [Installation](https://github.com/batchx/python-toolbox#installation)    - [Local](https://github.com/batchx/python-toolbox#local)    - [Inside Docker image](https://github.com/batchx/python-toolbox#inside-docker-image)- [The manifest as single source of truth](https://github.com/batchx/python-toolbox#the-manifest-as-single-source-of-truth)- [`bx-readme`](https://github.com/batchx/python-toolbox#bx-readme)- [CommandBuilder](https://github.com/batchx/python-toolbox#commandbuilder)    - [Connecting CLI parameters to BatchX parameters](https://github.com/batchx/python-toolbox#connecting-tool-parameters-to-batchx-parameters)    - [Understanding parameter types](https://github.com/batchx/python-toolbox#understanding-parameter-types)    - [Add action](https://github.com/batchx/python-toolbox#add-actions)    - [Specify constraints](https://github.com/batchx/python-toolbox#specify-constraints)    # InstallationThe toolbox is available on [PyPi](https://pypi.org/project/batchx-dev/).## LocalSimple: do a `pip install````shellpython -m pip install batchx-dev```For reproducibility, it often makes sense to 'lock' yourself into a specific version.This can be done as follows:```shellpython -m pip install batchx-dev==1.0.63```## Inside Docker imageInstallation of the toolbox inside the docker image of a BatchX tool is _almost_ identical to a local install, except for the fact that the `pip install` command now has to be part of the Dockerfile.For the sake of argument, we assume that you are working on bringing a bioinformatics tool called `biotool` into BatchX, and that your directory structure looks like this,```biotool├── Dockerfile├── run_biotool.py└── manifest    ├── manifest.json    ├── picture.png    └── readme.md```Suppose that, initially, `biotool/Dockerfile` looked as follows;```dockerfileFROM amd64/python:3.10.4-bullseyeRUN python -m pip install biotool==2.4.2RUN mkdir batchxRUN chmod -R 777 /batchxCOPY run_biotool.py /batchxENTRYPOINT python /batchx/run_biotool.pyLABEL io.batchx.manifest=10COPY manifest /batchx/manifest```installation of the toolbox inside the image requires the addition of a single line,```dockerfileRUN python -m pip install batchx-dev==1.0.63```which yields a `Dockerfile` that looks like this:```dockerfileFROM amd64/python:3.10.4-bullseyeRUN python -m pip install batchx-dev==1.0.63RUN python -m pip install biotool==2.4.2RUN mkdir batchxRUN chmod -R 777 /batchxCOPY run_biotool.py /batchxENTRYPOINT python /batchx/run_biotool.pyLABEL io.batchx.manifest=10COPY manifest /batchx/manifest```That's it.Note that, in a Dockerfile, **you really should 'pin' a specific version of the packages you install**. If you do not do so, the Docker image may differ depending on when it was last built. # The manifest as single source of truthUltimately, the manifest is of utmost importance in BatchX.On an abstract level, much of what the toolbox achieves comes down to making your code understand the manifest properly. Therefore, much of the explanations below are example-driven, showcasing different scenarios in which a manifest needs proper interpretation.# `bx-readme`The toolbox comes with a **`bx-readme` command** that helps to keep the `manifest.json` and the `readme.md` in sync.We assume the following directory structure,```biotool├── Dockerfile├── run_biotool.py└── manifest    ├── manifest.json    ├── picture.png    └── readme.md└── python-toolbox    ├── manifest.json    ├── ...```The manifest (i.e. `manifest/manifest.json`) is the [single source of truth](#the-manifest-as-single-source-of-truth), but the human-readable readme (i.e. `manifest/readme.md`) repeats a lot of that information.As a consequence, changes in the manifest need to be reflected in the readme and vice-versa. This synchronisation process is prone to human error, which is why the toolbox steps in.## QuickstartEnsure that your terminal is in the `/manifest` directory (`cd manifest`), and do,```shellbx-readme```This will likely do what you want.This command looks at `manifest.json` and `readme.md` and does its best to improve both.### In-depth explanationRun```shellbx-readme --help```for the latest information on the CLI.Additionally, it is interesting to know that the `bx-readme` command internally relies on two objects:- the `ManifestImprover` and- the `ReadmeImprover`.Those objects are responsible for exactly what their names suggest. The `bx-readme` command is nothing more than a single script that initializes those objects, configures them, runs them and saves the results.However, much more is possible beyond the &quot;one size fits all approach&quot; of that particular script.To get an idea of all the possibilities, the best reference is to study their respective integration tests.- [ManifestImprover integration test](test/mf-improver.ipynb)- [ReadmeImprover integration test](test/rm-improver.ipynb)- [ManifestImprover-ReadmeImprover end-to-end integration test](test/mfi-rmi-end-to-end.ipynb)                # CommandBuilderApart from `bx-readme`, this toolbox also comes in handy when incorporating a bioinformatics tool into [batchx.io](https://www.batchx.io/).In this section, we highlight some of its functionalities in that regard.## Initialize the CommandBuilderThe `CommandBuilder` relies on a few additional datastructures, namely `Manifest` and `Filesystem` objects.```pythonfrom batchx_dev.toolbox import FileSystem, Manifest, CommandBuilderfs = FileSystem(tool=&quot;biotool&quot;) # data-structure (approximately a dict) capturing the internal directory structure of a tool's docker image.mf = Manifest(fs.mfp)  # load manifest.jsoncb = CommandBuilder(mf, tool=&quot;biotool&quot;, filesystem=fs) # Initialize the CommandBuilder```## Connecting CLI parameters to BatchX parametersSuppose the `biotool` CLI has an optional parameter `--maximum-length````shellbiotool --input genome.fasta --maximum-length 1000```which appears in the manifest as follows,```json&quot;maximumLength&quot;: {    &quot;type&quot;: &quot;integer&quot;,    &quot;required&quot;: false,    &quot;default&quot;: 250,    &quot;description&quot;: &quot;Maximum length (in bp) for which biotool makes sense.&quot;},```Obviously, the `biotool` parameter (`--maximum-length`) has a different name than the BatchX parameter (`maximumLength`).But, in order to pass the user-provided value for this parameter from BatchX (CLI or web interface) into the underlying `biotool` CLI, this _obvious and trivial_ knowledge still needs to be represented _explicitly_ somewhere in the wrapper script `run_biotool.py`. This leads to code that looks like this, ```pythonmaximum_length = parsed_json[&quot;maximumLength&quot;]...command = &quot;biotool &quot;if maximum_length is not None:    command += &quot;--maximum_length {}&quot;.format(maximum_length)```which is _not wrong_, but this is a lot of code _just_ to link `maximum_length` and `maximumLength` together.In particular, note that this - parses a json;- looks up the user-provided value of the parameter of interest (`maximumLength`);- creates a new python variable (`maximum_length`) to house that value;- checks if that variable has an _actual_ value (i.e. `is not None`);- if yes:    - creates a substring `--maximum_length`;    - injects the value of your python variable `maximum_length` into that string;    - and finally, extends the command string with this substring.Whereas the only thing you _really had to do_ was to explain to your computer that `maximumLength` is a synonym for `--maximum_length` in this context.Here, however, linking  `maximumLength` and `--maximum_length` gets intertwined with value-passing and actual command-generation.Mixing all of this is suboptimal, because value-passing and actual command-generation of the `biotool` CLI command is something that needs to happen anyway, for any parameter:that part is perfectly suitable for automation.The linking together is _the only thing_ that requires actual human intervention here.The toolbox allows you to do just that:```pythoncb.add_command(cmd=&quot;maximum_length&quot;, key=&quot;maximumLength&quot;)```The commandbuilder now knows that `maximumLength` is a synonym for `maximum_length`, and upon command generation will do what it needs to do.### Example: Tool parameters to BatchX parametersTo illustrate, given this `input.json`,```json&quot;fasta&quot;: &quot;some_genome.fasta&quot;,&quot;maximumLength&quot;: 200```this `run_biotool.py` implementation```pythonfrom batchx_dev.toolbox import FileSystem, Manifest, CommandBuilderfs = FileSystem(tool=&quot;biotool&quot;) # data-structure (approximately a dict) capturing the internal directory structure of a tool's docker image.mf = Manifest(fs.mfp)  # load manifest.json (mfp = manifest filepath)ip = Input(fs.ifp) # load input.json (ifp = input filepath)cb = CommandBuilder(mf, tool=&quot;biotool&quot;, filesystem=fs) # Initialize the CommandBuildercb.add_command(cmd=&quot;input&quot;, key=&quot;fasta&quot;)cb.add_command(cmd=&quot;maximum_length&quot;, key=&quot;maximumLength&quot;)cb.build_command(ip)```yields the following command:```shellbiotool --input some_genome.fasta --maximum-length 200```## Understanding parameter typesSuppose the `biotool` CLI has an optional _flag_ `--no-qc`, which allows users to run `biotool` without its built-in quality control mechanism,forcing it to produce more but potentially less relevant outputs.Since it is a _flag_, its mere presence indicates that this option is active. That is, this command```shellbiotool --input genome.fasta --maximum-length 1000 --no-qc```runs `biotool` with quality control _disabled_, whereas this command```shellbiotool --input genome.fasta --maximum-length 1000```runs `biotool` with quality control _enabled_.Note the difference with &quot;regular&quot; command line _arguments_ (i.e. &quot;key-value style&quot;), such as `--input`  and `--maximum-length` that have to be followed by an actual value;in flags, the value is implicit.In a BatchX manifest, this flag can be described as follows,```json&quot;noQC&quot;: {    &quot;type&quot;: &quot;bool&quot;,    &quot;required&quot;: false,    &quot;default&quot;: false,    &quot;description&quot;: &quot;Flag that indicates whether or not biotool's internal quality control mechanism should be bypassed.&quot;},```Apart from linking the `biotool` parameter (`--no-qc`) and the BatchX parameter (`noQC`), developers now must also encode particular logic to inject this parameter's value into the final command, i.e.:- if `noQC==True`, the flag must be present, - if `noQC==False` nothing needs to be added.Obviously, this differs from how a command is built for regular (key-value style) arguments, which leads to code that looks like this, ```pythonmaximum_length = parsed_json[&quot;maximumLength&quot;]no_qc = parsed_json[&quot;noQC&quot;]...command = &quot;biotool &quot;if maximum_length is not None:    command += &quot;--maximum_length {}&quot;.format(maximum_length)if no_qc:    command += &quot;--no_qc&quot;```again, nothing inherently wrong about this, but this intertwines proper understanding of the manifest and the parsing of the actual input. Another disadvantage is the fact that _readers_ of this code need to pay very close attention to figure out which parameters are _flags_ and which are _key-value_.The toolbox, on the other hand, simply allows you to _explicitly_ state that a particular parameter is a flag,```pythoncb.add_command(cmd=&quot;maximum_length&quot;, key=&quot;maximumLength&quot;)cb.add_command(cmd=&quot;no-qc&quot;, key=&quot;noQC&quot;).set_kind(kind=&quot;flag&quot;)```The commandbuilder now knows that `noQC` is a flag (and so do readers of this code!), and takes this into account when generating commands.### Example: Understanding parameter typesTo illustrate, given this `input.json`,```json&quot;fasta&quot;: &quot;some_genome.fasta&quot;,&quot;maximumLength&quot;: 200,&quot;noQC&quot;: true```this `run_biotool.py` implementation```pythonfrom batchx_dev.toolbox import FileSystem, Manifest, CommandBuilderfs = FileSystem(tool=&quot;biotool&quot;) # data-structure (approximately a dict) capturing the internal directory structure of a tool's docker image.ip = Input(fs.ifp) # load input.jsonmf = Manifest(fs.mfp)  # load manifest.jsoncb = CommandBuilder(mf, tool=&quot;biotool&quot;, filesystem=fs) # Initialize the CommandBuildercb.add_command(cmd=&quot;input&quot;, key=&quot;fasta&quot;)cb.add_command(cmd=&quot;maximum_length&quot;, key=&quot;maximumLength&quot;)cb.add_command(cmd=&quot;no-qc&quot;, key=&quot;noQC&quot;).set_kind(kind=&quot;flag&quot;)cb.build_command(ip)```yields the following command:```shellbiotool --input some_genome.fasta --maximum-length 200 --no-qc```whereas given this `input.json`,```json&quot;fasta&quot;: &quot;some_genome.fasta&quot;,&quot;maximumLength&quot;: 200,&quot;noQC&quot;: false```it generates this command instead:```shellbiotool --input some_genome.fasta --maximum-length 200```## Add actions### Example: Attaching an action to a parameterTo illustrate, given this `input.json`,```json&quot;fasta&quot;: &quot;some_genome.fasta.gz&quot;,&quot;maximumLength&quot;: 2000,&quot;noQC&quot;: true```this `run_biotool.py` implementation```pythonfrom batchx_dev.toolbox import FileSystem, Manifest, CommandBuilder# define a useful functiondef conditional_unzip_gzip(input, manifest, fp):    &quot;&quot;&quot;    For constraints &amp; actions:        - First argument is always the Input object.        - Second argument is always the Manifest object.        - Third argument is always the value of the command with which the constraint is associated.    &quot;&quot;&quot;    def is_gz_file(fp: str | Path):        with open(fp, &quot;rb&quot;) as f:            return f.read(2) == b&quot;\x1f\x8b&quot;    def unzip_gzip(gzip_fp, unzip_fp=None):        &quot;&quot;&quot;Unzips a gzipped file with pgiz.&quot;&quot;&quot;        gzip_fp = Path(gzip_fp)        assert gzip_fp.suffix == &quot;.gz&quot;, &quot;Not the expected `.gz` extension!&quot;        if unzip_fp is None:            unzip_fp = gzip_fp.parent / gzip_fp.stem  # removes .gz suffix        print(&quot;Extracting target file {} using pigz&quot;.format(gzip_fp), flush=True)        with open(unzip_fp, &quot;w&quot;) as f:            pigz = subprocess.call([&quot;pigz&quot;, &quot;-dc&quot;, str(gzip_fp)], stdout=f)            if pigz != 0:                sys.exit(pigz)        return unzip_fp    fp = Path(fp)    if fp.suffix == &quot;.gz&quot;:        if is_gz_file(fp):            return unzip_gzip(fp)        else:            msg = &quot;&quot;&quot;            Assumed that file {f} is gzipped.            However, upon closer inspection (via `is_gz_file`),            it turns out this is not the case.             Please resolve this issue.            &quot;&quot;&quot;.format(                f=str(fp)            )            raise ValueError(msg)    else:        return fpfs = FileSystem(tool=&quot;biotool&quot;) # data-structure (approximately a dict) capturing the internal directory structure of a tool's docker image.ip = Input(fs.ifp) # load input.jsonmf = Manifest(fs.mfp)  # load manifest.jsoncb = CommandBuilder(mf, tool=&quot;biotool&quot;, filesystem=fs) # Initialize the CommandBuildercb.add_command(cmd=&quot;input&quot;, key=&quot;fasta&quot;).add_action(conditional_unzip_gzip)cb.add_command(cmd=&quot;maximum_length&quot;, key=&quot;maximumLength&quot;)cb.add_command(cmd=&quot;no-qc&quot;, key=&quot;noQC&quot;).set_kind(kind=&quot;flag&quot;)cb.build_command(ip)```yields the following command:```shellbiotool --input some_genome.fasta --maximum-length 2000 --no-qc```where `some_genome.fasta` exists (although the input was `some_genome.fasta.gz`!), because the action you attached to that parameter took care of that via running the function `conditional_gzip_unzip`.## Specify constraints ### Example: Specify constraintsTo illustrate, given this `input.json`,```json&quot;fasta&quot;: &quot;some_genome.fasta&quot;,&quot;maximumLength&quot;: 2000,&quot;noQC&quot;: true&quot;callLargeVariants&quot;: true```this `run_biotool.py` implementation```pythonfrom batchx_dev.toolbox import FileSystem, Manifest, CommandBuilderfs = FileSystem(tool=&quot;biotool&quot;) # data-structure (approximately a dict) capturing the internal directory structure of a tool's docker image.ip = Input(fs.ifp) # load input.jsonmf = Manifest(fs.mfp)  # load manifest.jsoncb = CommandBuilder(mf, tool=&quot;biotool&quot;, filesystem=fs) # Initialize the CommandBuildercb.add_command(cmd=&quot;input&quot;, key=&quot;fasta&quot;)cb.add_command(cmd=&quot;maximum_length&quot;, key=&quot;maximumLength&quot;)cb.add_command(cmd=&quot;no-qc&quot;, key=&quot;noQC&quot;).set_kind(kind=&quot;flag&quot;)def large_variants_constraint(input, manifest, value, k: str=&quot;maximumLength&quot;, threshold: int=200):    &quot;&quot;&quot;    For constraints &amp; actions:        - First argument is always the Input object.        - Second argument is always the Manifest object.        - Third argument is always the value of the command with which the constraint is associated.        Other arguments have to be keyword arguments, and can be passed whilst adding the     constraint to the CommandBuilder    &quot;&quot;&quot;    return ip.get(k) &gt; threshold    cb.add_command(cmd=&quot;large-variants&quot;, key=&quot;callLargeVariants&quot;)    .set_kind(kind=&quot;flag&quot;)    .add_constraint(large_variants_constraint, threshold=1000)cb.build_command(ip)```yields the following command:```shellbiotool --input some_genome.fasta --maximum-length 2000 --no-qc --large-variants```Whereas the same implementation, given this input,```json&quot;fasta&quot;: &quot;some_genome.fasta&quot;,&quot;maximumLength&quot;: 200,&quot;noQC&quot;: true&quot;callLargeVariants&quot;: true```would not produce any command at all and throw an error, due to the fact that `&quot;maximumLength&quot;: 200` is incompatible with the `callLargeVariants` flag. Indeed, the `callLargeVariants` flag only makes sense if  `maximumLength &gt; 1000`.# Feature requestsPlease add it to this [project board](https://github.com/orgs/batchx/projects/7).</longdescription>
</pkgmetadata>