<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># YAML Data Class Config[![Test](https://github.com/yukihiko-shinoda/yaml-dataclass-config/workflows/Test/badge.svg)](https://github.com/yukihiko-shinoda/yaml-dataclass-config/actions?query=workflow%3ATest)[![Test Coverage](https://api.codeclimate.com/v1/badges/9b89a5c842c2af41d02e/test_coverage)](https://codeclimate.com/github/yukihiko-shinoda/yaml-dataclass-config/test_coverage)[![Maintainability](https://api.codeclimate.com/v1/badges/9b89a5c842c2af41d02e/maintainability)](https://codeclimate.com/github/yukihiko-shinoda/yaml-dataclass-config/maintainability)[![Code Climate technical debt](https://img.shields.io/codeclimate/tech-debt/yukihiko-shinoda/yaml-dataclass-config)](https://codeclimate.com/github/yukihiko-shinoda/yaml-dataclass-config)[![Updates](https://pyup.io/repos/github/yukihiko-shinoda/yaml-dataclass-config/shield.svg)](https://pyup.io/repos/github/yukihiko-shinoda/yaml-dataclass-config/)[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/yamldataclassconfig)](https://pypi.org/project/yamldataclassconfig/)[![PyPI - Downloads](https://img.shields.io/pypi/dm/yamldataclassconfig)](https://pypi.org/project/yamldataclassconfig/)[![Twitter URL](https://img.shields.io/twitter/url?url=https%3A%2F%2Fgithub.com%2Fyukihiko-shinoda%2Fyaml-dataclass-config)](http://twitter.com/share?text=YAML%20Data%20Class%20Config&amp;url=https://pypi.org/project/yamldataclassconfig/&amp;hashtags=python)This project helps you to import config file writen by YAML toPython [Data Classes](https://docs.python.org/3/library/dataclasses.html).## Advantage1. Type safe import from YAML to Data Classes2. Global access and easy unit testing### 1. Type safe import from YAML to Data classesWhen using pyyaml to import YAML, values be dict and list objects.Using dict or list object will cause such confuses:- Reference non exist properties for unexpected instance type- Typo of index or key nameTo prevent these confuse, one of good way is to use object as model,and python has a good module[Data Classes](https://docs.python.org/3/library/dataclasses.html) for this purpose.### 2. Global access and easy unit testingYou will want to refer config as globalbecause it's troublesome to pass config value as argument over and over like a bucket brigade.However, when unit testing,if YAML file was loaded automatically on importing global definition,you will face problem thatyou can't replace config YAML file with the one for unit testing.YAML Data Class Config can divide timings between definition global instance andloading YAML file so you can replace YAML file for unit testing.## Quickstart### 1. Install```consolepip install yamldataclassconfig```### 2. Prepare config YAML filePut `config.yml`YAML Data class Config loads `config.yml` on Python execution directory by default.```yamlproperty_a: 1property_b: '2'part_config:  property_c: '2019-06-25 13:33:30'```### 3. Create config classAnywhere is OK, for example, I prefer to place on `myproduct/config.py````pythonfrom dataclasses import dataclass, fieldfrom datetime import datetimefrom dataclasses_json import DataClassJsonMixinfrom marshmallow import fieldsfrom yamldataclassconfig.config import YamlDataClassConfig@dataclassclass PartConfig(DataClassJsonMixin):    property_c: datetime = field(metadata={'dataclasses_json': {        'encoder': datetime.isoformat,        'decoder': datetime.fromisoformat,        'mm_field': fields.DateTime(format='iso')    }})@dataclassclass Config(YamlDataClassConfig):    property_a: int = None    property_b: str = None    part_config: PartConfig = field(        default=None,        metadata={'dataclasses_json': {'mm_field': PartConfig}}    )```### 4. Define as globalAlso, anywhere is OK, for example, I prefer to place on `myproduct/__init__.py````pythonfrom myproduct.config import ConfigCONFIG: Config = Config()```### 5. Call load before reference config value```pythonfrom myproduct import CONFIGdef main():    CONFIG.load()    print(CONFIG.property_a)    print(CONFIG.property_b)    print(CONFIG.part_config.property_c)if __name__ == '__main__':    main()```&lt;!-- markdownlint-disable no-trailing-punctuation --&gt;## How do I...&lt;!-- markdownlint-enable no-trailing-punctuation --&gt;&lt;!-- markdownlint-disable no-trailing-punctuation --&gt;### Fix path to yaml file independent on the Python execution directory?&lt;!-- markdownlint-enable no-trailing-punctuation --&gt;override `FILE_PATH` property.Ex:```pythonfrom dataclasses import dataclassfrom pathlib import Pathfrom yamldataclassconfig import create_file_path_fieldfrom yamldataclassconfig.config import YamlDataClassConfig@dataclassclass Config(YamlDataClassConfig):    some_property: str = None    # ...    FILE_PATH: Path = create_file_path_field(Path(__file__).parent.parent / 'config.yml')```&lt;!-- markdownlint-disable no-trailing-punctuation --&gt;### Switch target YAML config file to the one for unit testing?&lt;!-- markdownlint-enable no-trailing-punctuation --&gt;When setup on unit testing, you can call `Config.load()` with argument.Case when unittest:```pythonfrom pathlib import Pathimport unittestfrom yourproduct import CONFIGclass ConfigurableTestCase(unittest.TestCase):    def setUp(self):        CONFIG.load(Path('path/to/yaml'))```Case when pytest:```pythonfrom pathlib import Pathimport pytestfrom yourproduct import CONFIG@pytest.fixturedef yaml_config():    CONFIG.load(Path('path/to/yaml'))    yielddef test_something(yaml_config):    &quot;&quot;&quot;test something&quot;&quot;&quot;```&lt;!-- markdownlint-disable no-trailing-punctuation --&gt;### Use path to YAML config file as same as production when test?&lt;!-- markdownlint-enable no-trailing-punctuation --&gt;[fixturefilehandler](https://pypi.org/project/fixturefilehandler/)can replace config.yml with tests/config.yml.dist easily.Please call all `DeployerFactory.create` with `YamlConfigFilePathBuilder` instance argumentto create ConfigDeployer.Then, set target directory which config.yml should be placed into `path_target_directory`.Case when unittest:```pythonfrom pathlib import Pathimport unittestfrom fixturefilehandler.factories import DeployerFactoryfrom fixturefilehandler.file_paths import YamlConfigFilePathBuilderfrom yourproduct import CONFIGConfigDeployer = DeployerFactory.create(YamlConfigFilePathBuilder(path_target_directory=Path(__file__).parent.parent))class ConfigurableTestCase(unittest.TestCase):    def setUp(self):        ConfigDeployer.setup()        CONFIG.load()    def doCleanups(self):        ConfigDeployer.teardown()```Case when pytest:```pythonfrom pathlib import Pathimport pytestfrom fixturefilehandler.factories import DeployerFactoryfrom fixturefilehandler.file_paths import YamlConfigFilePathBuilderfrom yourproduct import CONFIGConfigDeployer = DeployerFactory.create(YamlConfigFilePathBuilder(path_target_directory=Path(__file__).parent.parent))@pytest.fixturedef yaml_config():    ConfigDeployer.setup()    CONFIG.load()    yield    ConfigDeployer.teardown()def test_something(yaml_config):    &quot;&quot;&quot;test something&quot;&quot;&quot;```</longdescription>
</pkgmetadata>