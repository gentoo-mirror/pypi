<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Tmux-ConfThis is meant for users running tmux on multiple hosts, not alwaysrunning the same version of tmux.This generates tmux config files where version checks can be used, sothat features not working on a given version can be handled gracefully.Either replaced by something suitable for that version, or just skipped.This gets rid of annoying startup error messages for features not beingavailable on the running version and failure to parse the rest of the config.The optional [plugin](docs/PLUGINS.md) handling is also automated in thesense that plugins not usable on the given version of tmux are skipped.If any plugins are defined they will be auto-installed on first run.This in combination with hostname matching makes it easy to adopt agiven environment based both on tmux version available, and whatfeatures are relevant for that host. Managing a music player isprobably not all that meaningful on a remote cloud host :)The generation of a tmux.conf takes only a fraction of a second, so Iuse some scripts to regenerate the config each time I start tmux onthat system.This will make new features automatically activated as soon as that nodegets a tmux version supporting it, without having to give it anythought.I sometimes also bind keys for functionality not available on a givenversion of tmux to display a message like &quot;Popup scratchpad sessionneeds 3.2&quot;. So that I never have to wonder why nothing happened if Iattempt something not supported on that system.## AvailabilitySimplest way to install is using `pip install tmux-conf`## Suggested approachDrop your current tmux.conf inside a content() method, wrapping stuffto be written to the conf file inside write() statements. If youexperience version glitches, wrap those items inside vers_ok()statements.If so desired also migrating your current plugins setup into plugin_XXmethods. Thus they will also be version checked.## General features- First scans for plugins available for this version and creates a list  of those plugins. This list can be used when defining the status line  to only include parts relevant for plugins being used.- Plugins are version checked, incompatible plugins are ignored.- If tpm is used it will be installed if not present on startup.- All version compatible plugins are installed on startup, regrdless  if tpm or manual plugin handling is used.- Check if the current tmux matches a version limit with vers_ok()  to decide if something should be included.- Conf file defines $TMUX_BIN, pointing to the actual tmux/tmate bin  used to run this environment, and can be used in scripts and plugins  to use the right binary.- Built in script handling for tasks that would just be painful to  mangle into tmux commands with all the escaping that entails.  Scripts will either be embedded or stored in separate files.- Filters out -N bind notes automatically if current tmux doesn't  support the feature, so just leave them in if you prefer to use them.- Lazy adopting, initially just drop in your current config.  If at some point you experience a version complaining about something,  just wrap that inside a vers_ok() clause and its done. No need to  over-analyze your entire setup unless you experiment with older  versions of tmux.- Supports config inheritance, you can have your basic config,  and then subclass it and define things like what plugins are being  used on a per node basis.- Platform dependent plugins can be auto filtered## Conditional status bar snippetsBlindly including plugin related code in the status bar can lead toissues, especially if the status bar snippet calls an external script.If the script is not present, it will trigger an error, and if thescript is present, but that plugin isn't intended to be used at themoment, it can lead to unintended side effects.Recommended approach is to first check what plugins are currently usedby calling self.plugins.found().This returns the names of all defined plugins matching the current tmuxversion and can be used to only include relevant items in thestatus bar.```python    w = self.write    used_plugins = self.plugins.found()    if &quot;tmux-packet-loss&quot; in used_plugins:        sb_right = &quot;#{packet_loss}&quot; + sb_right    if &quot;tmux-prefix-highlight&quot; in used_plugins:        sb_right += &quot;#{prefix_highlight}&quot;    w(f&quot;set -g  status-right '{sb_right}'&quot;)```## Version TestingCombining this with using for example asdf to build multiple versionsof tmux, this is a convenient way to test plugins you are working onfor version compatibility.And if so desired a test bench to get your plugins to work with oldertmux versions.## My usage caseIn my case i have set it up with some basic plugins I normally alwaysexpect to be available, then for my laptop I have added ones thatwould only make sense on a local system, like that music player.A few very limited systems have more resource heavy standard pluginsdisabled automatically.The end result is that I have one single tmux config I use on allsystems. You can check it out at[jaclu/my_tmux_conf](https://github.com/jaclu/my_tmux_conf)I don't have to think about what version of tmux is available, myconfig takes care of adopting. When I start using a feature from anew version of tmux, I can just put it in my standard config with aversion check preventing it from being used on older tmuxes.As versions gets updated the new feature automatically becomes morewidely available.## Version checksParameter for calls to vers_ok() is flexible, can be either int, float orstring. In most cases a float is sufficient, like 2.8Since some versions include a trailing letter, like 3.3a, then a stringparam would be needed. If version is given as int, it will be appendedwith .0## Example snippetsIf you notice version glitches, start wrapping those inside conditions:```python    if self.vers_ok(3.2):        w(&quot;set -s  extended-keys on&quot;)        #        #  Not needed for all terminal apps, but since it doesn't hurt,        #  it makes sense to always include it        #        w(&quot;set -as terminal-features 'xterm*:extkeys'&quot;)```A more complex example, with multiple version considerations.Since there is no real fall back option doing something similar forolder versions, if the running tmux is to old, a notice that thefeature is not available is bound to the key.```python    scrpad_key = &quot;O&quot;  # P being taken, this is pOpup :)    if self.vers_ok(3.2):        display_popup = &quot;display-popup -h 70% -w 70% -E &quot;        if self.vers_ok(3.3):            display_popup += &quot;-T &quot; '&quot;#[align=centre] pOpup Scratchpad Session &quot; '        w(            f'bind -N &quot;pOpup scratchpad session&quot;  {scrpad_key}  '            f'{display_popup} &quot;$TMUX_BIN -u new-session -ADs scratch&quot;'        )    else:        w(            f'bind -N &quot;pOpup not available warning&quot;  {scrpad_key}  '            f'display &quot;pOpup scratchpad session needs 3.2&quot;'        )```## ScriptingThis package handles using regular scripts for more complex tasksthat would just be painful to wrap inside tmux notation.Such scripts can either be saved as embedded in the tmux conf file oras external files in scripts/ next to plugins/See [docs/scripting.md](docs/scripting.md) for more info.</longdescription>
</pkgmetadata>