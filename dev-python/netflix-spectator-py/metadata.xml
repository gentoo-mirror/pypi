<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Snapshot](https://github.com/Netflix/spectator-py/actions/workflows/snapshot.yml/badge.svg)](https://github.com/Netflix/spectator-py/actions/workflows/snapshot.yml)## IntroductionPython thin-client metrics library for use with [Atlas] and [SpectatorD].Supports Python &gt;= 3.5. This version is chosen as the baseline, because it is the oldest systemPython available in our operating environments. [Atlas]: https://github.com/Netflix/atlas[SpectatorD]: https://github.com/Netflix-Skunkworks/spectatord## Local DevelopmentInstall [pyenv](https://github.com/pyenv/pyenv), possibly with [Homebrew](https://brew.sh/), andinstall a recent Python version.```shellmake setup-venvmake testmake coverage```## Usage## InstallingInstall this library for your project as follows:```pip3 install netflix-spectator-py```Publishing metrics requires a [SpectatorD] process running on your instance.## Importing### Standard UsageAt Netflix, your initialization script should load the environment, to ensure that the standardvariables are available to the Python application.```bashsource /etc/nflx/environment```Importing the `GlobalRegistry` instantiates a `Registry` with a default configuration that appliesprocess-specific common tags based on environment variables and opens a socket to the [SpectatorD]sidecar. The remainder of the instance-specific common tags are provided by SpectatorD.```pythonfrom spectator import GlobalRegistry```Once the `GlobalRegistry` is imported, it is used to create and manage Meters.### LoggingThis package provides the following loggers:* `spectator.MeterId`* `spectator.SidecarWriter`The `MeterId` logger is used to report invalid meters which have not-a-str tag keys or values.When troubleshooting metrics collection and reporting, you should set the `SidecarWriter` loggingto the `DEBUG` level, before the first metric is recorded. For example:```pythonimport logging# record the human-readable time, name of the logger, logging level, thread id and messagelogging.basicConfig(    level=logging.DEBUG,    format='%(asctime)s - %(name)s - %(levelname)s - %(thread)d - %(message)s')logging.getLogger('spectator.SidecarWriter').setLevel(logging.DEBUG)```There is approximately a 10% performance penalty in UDP write performance when debug logging isenabled. It may be more, depending on the exact logging configuration (i.e. flushing to slow disk).## Working with IDsThe IDs used for identifying a meter in the `GlobalRegistry` consist of a name and a set of tags.IDs will be consumed by users many times after the data has been reported, so they should bechosen thoughtfully, while considering how they will be used. See the [naming conventions] pagefor general guidelines.IDs are immutable, so they can be freely passed around and used in a concurrent context. Tags canbe added to an ID when it is created, to track the dimensionality of the metric. **All tag keysand values must be strings.** For example, if you want to keep track of the number of successfulrequests, you must cast integers to strings.```pythonfrom spectator import GlobalRegistryrequests_id = GlobalRegistry.counter(&quot;server.numRequests&quot;, {&quot;statusCode&quot;: str(200)})requests_id.increment()```[naming conventions]: https://netflix.github.io/atlas-docs/concepts/naming/## Meter Types### Age GaugesThe value is the time in seconds since the epoch at which an event has successfully occurred, or`0` to use the current time in epoch seconds. After an Age Gauge has been set, it will continuereporting the number of seconds since the last time recorded, for as long as the SpectatorDprocess runs. The purpose of this metric type is to enable users to more easily implement theTime Since Last Success alerting pattern.To set a specific time as the last success:```pythonfrom spectator import GlobalRegistryGlobalRegistry.age_gauge(&quot;time.sinceLastSuccess&quot;).set(1611081000)```To set `now()` as the last success:```pythonfrom spectator import GlobalRegistryGlobalRegistry.age_gauge(&quot;time.sinceLastSuccess&quot;).set(0)```By default, a maximum of `1000` Age Gauges are allowed per `spectatord` process, because there is nomechanism for cleaning them up. This value may be tuned with the `--age_gauge_limit` flag on the`spectatord` binary.### CountersA Counter is used to measure the rate at which an event is occurring. Considering an APIendpoint, a Counter could be used to measure the rate at which it is being accessed.Counters are reported to the backend as a rate-per-second. In Atlas, the `:per-step` operatorcan be used to convert them back into a value-per-step on a graph.Call `increment()` when an event occurs:```pythonfrom spectator import GlobalRegistryGlobalRegistry.counter(&quot;server.numRequests&quot;).increment()```You can also pass a value to `increment()`. This is useful when a collection of events happenstogether:```pythonfrom spectator import GlobalRegistryGlobalRegistry.counter(&quot;queue.itemsAdded&quot;).increment(10)```### Distribution SummariesA Distribution Summary is used to track the distribution of events. It is similar to a Timer, butmore general, in that the size does not have to be a period of time. For example, a DistributionSummary could be used to measure the payload sizes of requests hitting a server.Always use base units when recording data, to ensure that the tick labels presented on Atlas graphsare readable. If you are measuring payload size, then use bytes, not kilobytes (or some other unit).This means that a `4K` tick label will represent 4 kilobytes, rather than 4 kilo-kilobytes.Call `record()` with a value:```pythonfrom spectator import GlobalRegistryGlobalRegistry.distribution_summary(&quot;server.requestSize&quot;).record(10)```### Percentile Distribution SummariesThe value tracks the distribution of events, with percentile estimates. It is similar to aPercentile Timer, but more general, because the size does not have to be a period of time.For example, it can be used to measure the payload sizes of requests hitting a server or thenumber of records returned from a query.In order to maintain the data distribution, they have a higher storage cost, with a worst-case ofup to 300X that of a standard Distribution Summary. Be diligent about any additional dimensionsadded to Percentile Distribution Summaries and ensure that they have a small bounded cardinality.Call `record()` with a value:```pythonfrom spectator import GlobalRegistryGlobalRegistry.pct_distribution_summary(&quot;server.requestSize&quot;).record(10)```### GaugesA gauge is a value that is sampled at some point in time. Typical examples for gauges would bethe size of a queue or number of threads in a running state. Since gauges are not updated inlinewhen a state change occurs, there is no information about what might have occurred between samples.Consider monitoring the behavior of a queue of tasks. If the data is being collected once a minute,then a gauge for the size will show the size when it was sampled. The size may have been muchhigher or lower at some point during interval, but that is not known.Call `set()` with a value:```pythonfrom spectator import GlobalRegistryGlobalRegistry.gauge(&quot;server.queueSize&quot;).set(10)```Gauges will report the last set value for 15 minutes. This done so that updates to the values donot need to be collected on a tight 1-minute schedule to ensure that Atlas shows unbroken lines ingraphs. A custom TTL may be configured for gauges. SpectatorD enforces a minimum TTL of 5 seconds.```pythonfrom spectator import GlobalRegistryGlobalRegistry.gauge(&quot;server.queueSize&quot;, ttl_seconds=120).set(10)```### TimersA Timer is used to measure how long (in seconds) some event is taking.Call `record()` with a value:```pythonfrom spectator import GlobalRegistryGlobalRegistry.timer(&quot;server.requestLatency&quot;).record(0.01)```A `stopwatch()` method is available which may be used as a [Context Manager](https://docs.python.org/3/reference/datamodel.html#context-managers)to automatically record the number of seconds that have elapsed while executing a block of code:```pythonimport timefrom spectator import GlobalRegistryt = GlobalRegistry.timer(&quot;thread.sleep&quot;)with t.stopwatch():    time.sleep(5)```Internally, Timers will keep track of the following statistics as they are used:* `count`* `totalTime`* `totalOfSquares`* `max`### Percentile TimersThe value is the number of seconds that have elapsed for an event, with percentile estimates.This metric type will track the data distribution by maintaining a set of Counters. Thedistribution can then be used on the server side to estimate percentiles, while stillallowing for arbitrary slicing and dicing based on dimensions.In order to maintain the data distribution, they have a higher storage cost, with a worst-case ofup to 300X that of a standard Timer. Be diligent about any additional dimensions added to PercentileTimers and ensure that they have a small bounded cardinality.Call `record()` with a value:```pythonfrom spectator import GlobalRegistryGlobalRegistry.pct_timer(&quot;server.requestLatency&quot;).record(0.01)```A `stopwatch()` method is available which may be used as a [Context Manager](https://docs.python.org/3/reference/datamodel.html#context-managers)to automatically record the number of seconds that have elapsed while executing a block of code:```pythonimport timefrom spectator import GlobalRegistryt = GlobalRegistry.pct_timer(&quot;thread.sleep&quot;)with t.stopwatch():    time.sleep(5)```## asyncio SupportThe `GlobalRegistry` provides a `UdpWriter` implementation of the `SidecarWriter` by default. UDPis a non-blocking, unordered and connectionless protocol, which is ideal for communicating with alocal SpectatorD process in a variety of circumstances. The `UdpWriter` should be used in asyncioapplications.The `PrintWriter` implementation, which can be used to communicate with the SpectatorD Unix domainsocket, does not offer asyncio support at this time.## IPv6 SupportBy default, SpectatorD will listen on `IPv6 UDP *:1234`, without setting the `v6_only(true)`flag. On dual-stacked systems, this means that it will receive packets from both IPv4 and IPv6,and the IPv4 addresses will show up on the server as IPv4-mapped IPv6 addresses.By default, the `GlobalRegistry` will write UDP packets to `127.0.0.1:1234`, which will allowfor communication with SpectatorD on dual-stacked systems.On IPv6-only systems, it may be necessary to change the default configuration using one of thefollowing methods:* Configure the following environment variable, which will override the default configuration ofthe `GlobalRegistry`:      export SPECTATOR_OUTPUT_LOCATION=&quot;udp://[::1]:1234&quot;* Configure a custom Registry, instead of using the `GlobalRegistry`:      from spectator import Registry      from spectator.sidecarconfig import SidecarConfig            r = Registry(config=SidecarConfig({&quot;sidecar.output-location&quot;: &quot;udp://[::1]:1234&quot;}))      r.counter(&quot;test&quot;).increment()## Writing TestsTo write tests against this library, instantiate a test instance of the Registry and configure itto use the [MemoryWriter](https://github.com/Netflix/spectator-py/blob/main/spectator/sidecarwriter.py#L63-L80),which stores all updates in a List. Use the `writer()` method on the Registry to access the writer,then inspect the `last_line()` or `get()` all messages to verify your metrics updates.```pythonimport unittestfrom spectator import Registryfrom spectator.sidecarconfig import SidecarConfigclass MetricsTest(unittest.TestCase):    def test_counter(self):        r = Registry(config=SidecarConfig({&quot;sidecar.output-location&quot;: &quot;memory&quot;}))        c = r.counter(&quot;test&quot;)        self.assertTrue(r.writer().is_empty())        c.increment()        self.assertEqual(&quot;c:test:1&quot;, r.writer().last_line())```If you need to override the default output location (udp) of the `GlobalRegistry`, then you canset a `SPECTATOR_OUTPUT_LOCATION` environment variable to one of the following values supportedby the `SidecarConfig` class:* `none` - Disable output.* `memory` - Write to memory.* `stdout` - Write to standard out for the process.* `stderr` - Write to standard error for the process.* `file://$path_to_file` - Write to a file (e.g. `file:///tmp/foo/bar`).* `udp://$host:$port` - Write to a UDP socket.If you want to disable metrics publishing from the `GlobalRegistry`, then you can set:```shellexport SPECTATOR_OUTPUT_LOCATION=none```If you want to validate the metrics that will be published through the `GlobalRegistry`in tests, then you can set:```shellexport SPECTATOR_OUTPUT_LOCATION=memory```The `MemoryWriter` subclass offers a few methods to inspect the values that it captures:* `clear()` - Delete the contents of the internal list.* `get()` - Return the internal list.* `is_empty()` - Is the internal list empty?* `last_line()` - Return the last element of the internal list.Lastly, a SpectatorD line protocol parser is available, which is intended to be used for validatingthe results captured by a `MemoryWriter`. It may be used as follows:```pythonimport unittestfrom spectator.counter import Counterfrom spectator.protocolparser import parse_protocol_lineclass ProtocolParserTest(unittest.TestCase):    def test_parse_counter_with_multiple_tags(self):        meter_class, meter_id, value = parse_protocol_line(&quot;c:test,foo=bar,baz=quux:1&quot;)        self.assertEqual(Counter, meter_class)        self.assertEqual(&quot;test&quot;, meter_id.name)        self.assertEqual({&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;quux&quot;}, meter_id.tags())        self.assertEqual(&quot;1&quot;, value)```## Migrating from 0.1.X to 0.2.X* This library no longer publishes directly to the Atlas backends. It now publishes to the[SpectatorD] sidecar which is bundled with all standard AMIs and containers. If you musthave the previous direct publishing behavior, because SpectatorD is not yet available on theplatform where your code runs, then you can pin to version `0.1.18`.* The internal Netflix configuration companion library is no longer required and this dependencymay be dropped from your project.* The API surface area remains unchanged to avoid breaking library consumers, and standard uses of`GlobalRegistry` helper methods for publishing metrics continue to work as expected. Several helpermethods on meter classes are now no-ops, always returning values such as `0` or `nan`. If you wantto write tests to validate metrics publication, take a look at the tests in this library for a fewexamples of how that can be done. The core idea is to capture the lines which will be written outto SpectatorD.* Replace uses of `PercentileDistributionSummary` with direct use of the Registry`pct_distribution_summary` method.    ```    # before    from spectator import GlobalRegistry    from spectator.histogram import PercentileDistributionSummary        d = PercentileDistributionSummary(GlobalRegistry, &quot;server.requestSize&quot;)    d.record(10)    ```    ```    # after    from spectator import GlobalRegistry        GlobalRegistry.pct_distribution_summary(&quot;server.requestSize&quot;).record(10)    ```* Replace uses of `PercentileTimer` with direct use of the Registry `pct_timer` method.    ```    # before    from spectator import GlobalRegistry    from spectator.histogram import PercentileTimer        t = PercentileTimer(GlobalRegistry, &quot;server.requestSize&quot;)    t.record(0.01)    ```        ```    # after    from spectator import GlobalRegistry        GlobalRegistry.pct_timer(&quot;server.requestSize&quot;).record(0.1)    ```* Implemented new meter types supported by [SpectatorD]: `age_gauge`, `max_gauge` and`monotonic_counter`. See the SpectatorD documentation or the class docstrings formore details.</longdescription>
</pkgmetadata>