<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;  &lt;img src=&quot;assets/migri-w-text.png&quot; width=&quot;200&quot; title=&quot;Migri Logo&quot; alt=&quot;Migri Logo&quot;&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://github.com/RonquilloAeon/migri/actions&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://github.com/RonquilloAeon/migri/workflows/Tests/badge.svg&quot; alt=&quot;Tests workflow status&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://pypi.org/project/migri/&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://badge.fury.io/py/migri.svg&quot; alt=&quot;PyPI version&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://pypi.org/project/migri/&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://img.shields.io/pypi/pyversions/migri.svg&quot; alt=&quot;PyPI Python versions&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://pepy.tech/project/migri&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://pepy.tech/badge/migri/month&quot; alt=&quot;Migri downloads per month&quot;&gt;    &lt;/a&gt;&lt;/p&gt;---Migri is a simple async Python migration tool. You can use the CLI (run yourself or from a shell script) or import theexposed functions and run programatically. Currently supports PostgreSQL([asyncpg](https://github.com/MagicStack/asyncpg)), SQLite ([aiosqlite](https://github.com/omnilib/aiosqlite)),and MySQL ([aiomysql](https://github.com/aio-libs/aiomysql)).**`migri` is currently in alpha and although unlikely, the implementation may change**## MotivationUsing async database libraries is useful when a service/application is already using anasync library. It's extra overhead to install a synchronous library just to run migrations.Practically speaking, though, there isn't much benefit to running migrations asynchronouslysince migrations must be applied synchronously. Besides, the number of migrations for aservice is generally small.## Getting started### Install `migri````pip install migri[mysql]pip install migri[postgresql]pip install migri[sqlite]```### Create migrationsCreate a `migrations` directory and add your migrations. Migrations are applied in lexicographical order (e.g. `0001_initial.sql` then `0002_add_user_data.py` and so on).Currently `.sql` and `.py` files are supported. If you write a Python migration file, ensure that it contains an async function `migrate`. An instance of asyncpg's `Connection`class will be passed into the function.```pythonasync def migrate(conn) -&gt; bool:    await conn.execute(&quot;INSERT INTO categories (name) VALUES ($1)&quot;, &quot;Animals&quot;)    return True```### MigrateRun `migri migrate`. Provide database credentials via arguments or environment variables:- `--db-name` or `DB_NAME` (required)- `--db-user` or `DB_USER`- `--db-pass` or `DB_PASS`- `--db-host` or `DB_HOST`- `--db-port` or `DB_PORT`Other options:- `-d, --dialect` or `DB_DIALECT` (`mysql`, `postgresql`, `sqlite`,  note that currently only `postgresql` is supported. If not set,  `migri` will attempt to infer the dialect (and library to use)  using the database port.)- `-l, --log-level` or `LOG_LEVEL` (default `error`)When you run `migrate`, `migri` will create a table called `applied_migration` (if itdoesn't exist). This is how `migri` tracks which migrations have already been applied.#### Dry run modeIf you want to test your migrations without applying them, you can use the dry runflag: `--dry-run`.**Unfortunately, dry run mode does not work with SQLite at this moment. If you want to try to get it to work, seethe [issue](https://github.com/RonquilloAeon/migri/issues/33).****Dry run mode also doesn't work w/ MySQL because DDL statements implicitly commit.**### Migrate programmaticallyMigri can be called with a shell script (e.g. when a container is starting) or you canapply migrations from your application:```pythonfrom migri import apply_migrations, PostgreSQLConnectionasync def migrate():    conn = PostgreSQLConnection(        &quot;sampledb&quot;,        db_user=&quot;user&quot;,        db_pass=&quot;passpass&quot;,        db_host=&quot;localhost&quot;,        db_port=5432    )    async with conn:        await apply_migrations(&quot;migrations&quot;, conn)```## Testing1. Set up local Python versions (e.g. `pyenv local 3.7.7 3.8.3`)2. Run `docker-compose up` to start Postgresql.3. Install nox with `pip install nox`.4. Run `nox`.## DocsDocstrings are formatted in the [Sphinx](https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html)format.## Todos- [x] Don't record empty migrations - warn user- [x] Add dry run mode for testing migrations- [x] Output migration results- [x] Test modules not found- [x] Test/handle incorrect migrate function signature (in migration Python files)- [ ] Add colorful output üç≠ for enhanced readability- [ ] Make error output more readable</longdescription>
</pkgmetadata>