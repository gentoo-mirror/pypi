<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;br /&gt;&lt;p align=&quot;center&quot;&gt;    &lt;!--    Note that this README will be used for both GitHub and PyPI.    We therefore:    - Keep all image URLs absolute.    - In the GitHub action we use for publishing, strip some HTML tags that aren't supported by PyPI.    --&gt;        &lt;img alt=&quot;tyro logo&quot; src=&quot;https://brentyi.github.io/tyro/_static/logo-light.svg&quot; width=&quot;200px&quot; /&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;em&gt;&lt;a href=&quot;https://brentyi.github.io/tyro&quot;&gt;Documentation&lt;/a&gt;&lt;/em&gt;    &amp;nbsp;&amp;nbsp;&amp;bull;&amp;nbsp;&amp;nbsp;    &lt;em&gt;&lt;code&gt;pip install tyro&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;img alt=&quot;build&quot; src=&quot;https://github.com/brentyi/tyro/workflows/build/badge.svg&quot; /&gt;    &lt;img alt=&quot;mypy&quot; src=&quot;https://github.com/brentyi/tyro/workflows/mypy/badge.svg?branch=main&quot; /&gt;    &lt;img alt=&quot;lint&quot; src=&quot;https://github.com/brentyi/tyro/workflows/lint/badge.svg&quot; /&gt;    &lt;a href=&quot;https://codecov.io/gh/brentyi/tyro&quot;&gt;        &lt;img alt=&quot;codecov&quot; src=&quot;https://codecov.io/gh/brentyi/tyro/branch/main/graph/badge.svg&quot; /&gt;    &lt;/a&gt;    &lt;a href=&quot;https://pypi.org/project/tyro/&quot;&gt;        &lt;img alt=&quot;codecov&quot; src=&quot;https://img.shields.io/pypi/pyversions/tyro&quot; /&gt;    &lt;/a&gt;&lt;/p&gt;&lt;br /&gt;&lt;strong&gt;&lt;code&gt;tyro&lt;/code&gt;&lt;/strong&gt; is a tool for building command-lineinterfaces and configuration objects in Python.Our core interface, `tyro.cli()`, generates command-line interfaces fromtype-annotated callables.---### Brief walkthroughTo summarize how `tyro.cli()` can be used, let's consider a script based on`argparse`. We define two inputs and print the sum:```python&quot;&quot;&quot;Sum two numbers from argparse.&quot;&quot;&quot;import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;--a&quot;, type=int, required=True)parser.add_argument(&quot;--b&quot;, type=int, default=3)args = parser.parse_args()total = args.a + args.bprint(total)```This pattern is dramatically cleaner than manually parsing `sys.argv`, but hasseveral issues: it lacks type checking and IDE support (consider: jumping todefinitions, finding references, docstrings, refactoring and renaming tools),requires a significant amount of parsing-specific boilerplate, and becomesdifficult to manage for larger projects.The basic goal of `tyro.cli()` is to provide a wrapper for `argparse` thatsolves these issues.**(1) Command-line interfaces from functions.**We can write the same script as above using `tyro.cli()`:```python&quot;&quot;&quot;Sum two numbers by calling a function with tyro.&quot;&quot;&quot;import tyrodef add(a: int, b: int = 3) -&gt; int:    return a + b# Populate the inputs of add(), call it, then return the output.total = tyro.cli(add)print(total)```Or, more succinctly:```python&quot;&quot;&quot;Sum two numbers by calling a function with tyro.&quot;&quot;&quot;import tyrodef add(a: int, b: int = 3) -&gt; None:    print(a + b)tyro.cli(add)  # Returns `None`.```**(2) Command-line interfaces from config objects.**A class in Python can be treated as a function that returns an instance. Thismakes it easy to populate explicit configuration structures:```python&quot;&quot;&quot;Sum two numbers by instantiating a dataclass with tyro.&quot;&quot;&quot;from dataclasses import dataclassimport tyro@dataclassclass Args:    a: int    b: int = 3args = tyro.cli(Args)print(args.a + args.b)```Unlike directly using `argparse`, both the function-based and dataclass-basedapproaches are compatible with static analysis; tab completion and type checkingwill work out-of-the-box.**(3) Additional features.**These examples only scratch the surface of what's possible. `tyro` aims tosupport all reasonable type annotations, which can help us define things likehierarchical structures, enums, unions, variable-length inputs, and subcommands.See [documentation](https://brentyi.github.io/tyro) for examples.### In the wild`tyro` is still a new library, but being stress tested in several projects!- [nerfstudio-project/nerfstudio](https://github.com/nerfstudio-project/nerfstudio/)  provides a set of tools for end-to-end training, testing, and rendering of  neural radiance fields.- [Sea-Snell/JAXSeq](https://github.com/Sea-Snell/JAXSeq/) is a library for  distributed training of large language models in JAX.- [kevinzakka/obj2mjcf](https://github.com/kevinzakka/obj2mjcf) is an interface  for processing composite Wavefront OBJ files for Mujoco.- [blurgyy/jaxngp](https://github.com/blurgyy/jaxngp) is a CUDA-accelerated  implementation of [instant-ngp](https://nvlabs.github.io/instant-ngp/),  implemented in JAX.- [NVIDIAGameWorks/kaolin-wisp](https://github.com/NVIDIAGameWorks/kaolin-wisp)  combines `tyro` with [`hydra-zen`](https://github.com/mit-ll-responsible-ai/hydra-zen)  for neural fields in PyTorch.- [openrlbenchmark/openrlbenchmark](https://github.com/openrlbenchmark/openrlbenchmark)  is a collection of tracked experiments for reinforcement learning.</longdescription>
</pkgmetadata>