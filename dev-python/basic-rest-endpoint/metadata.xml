<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># basic-rest-endpointFor a REST API, use the BasicRestEndpoint class.This class allows easily creating a task for an endpoint. For example, say we want to integrate with example.com'sindicator API. Here is a table of what their API looks like.EndpointHTTP MethodURL Parametershttps://example.com/api/indicatorGETindicator_id (int)https://example.com/api/indicatorPOST/PATCHindicator_name, indicator_valuehttps://example.com/api/indicator/{id}DELETE(none)So we have 3 endpoints, each with different HTTP Methods and parameters, but the same base URL.We can create a superclass for this integration, let's call it ExampleIntegration```pythonfrom basic_rest_endpoint import BasicRestEndpointclass ExampleIntegration(BasicRestEndpoint):    def __init__(self, context):        super(ExampleIntegration, self).__init__(context.asset[&quot;host&quot;]        # raise_for_status=False  # If we wanted to supress non-200 http codes being raised, set this to False        )```## Basic RequestTo make a request using this library, you just use `self.request(&lt;method&gt;, &lt;endpoint&gt;, **kwargs)`Where `&lt;method&gt;` is an HTTP method, `&lt;endpoint&gt;` is the URL relative to the host, and `**kwargs`are optional params to pass into the requests.request(...) call## Basic GET ExampleNow we create a task, say for the GET /api/indicator endpoint```pythonfrom sw_example import ExampleIntegration  # Import our superclass from aboveclass SwMain(ExampleIntegration):    endpoint = &quot;/api/indicator&quot;    method = &quot;GET&quot;    def __init__(self, context):        super(SwMain, self).__init__(context)        self.kwargs['params'] = {&quot;indicator_id&quot;: context.inputs[&quot;indicator_id&quot;]}  # Get indicator from inputs```But we didn't actually make a request here! It is all handled by the BasicRestEndpoint superclass.The params kwarg is passed into self.request which is used to create the full url with self.host thatends up like https://example.com/api/indicator?indicator_id=&lt;id&gt;## Basic POST ExampleBut what if the data required from the API isn't in the URL params? And what if the data returned fromwthe API isn't suitable for just returning, or needs some parsing?Let's take a look at the second endpoint, the POST /api/indicator.```pythonfrom sw_example import ExampleIntegration  # Import our superclass from aboveclass SwMain(ExampleIntegration):    endpoint = &quot;/api/indicator&quot;    method = &quot;POST&quot;    def parse_response(self, response):        data = response.json()  # Basically json.loads(response.text)        return data[&quot;data&quot;]    def __init__(self, context):        super(SwMain, self).__init__(context)        self.kwargs['json'] = {            &quot;indicator_name&quot;: context.inputs[&quot;indicator_name&quot;],  # Get indicator from inputs            &quot;indicator_value&quot;: context.inputs[&quot;indicator_value&quot;]        }}```This time, the data is passed in under the `json` parameter to requests which automatically formats our data forus in the POST body. If the data were non-json, we would use `data` instead. We also parsed out the data returned,only returning the JSON under the `data` key.## Basic DELETE ExampleSimilarly to a variable request method, we can have a variable URL. This is quite trivial```pythonclass SwMain(ExampleIntegration):    method = &quot;DELETE&quot;    def __init__(self, context):        super(SwMain, self).__init__(context)        self.endpoint = f&quot;/api/indicator/{context.inputs['iid']}&quot;```## AuthenticationBut what if example.com required authentication to make those calls?There are options for these authentication methods, Basic Auth, Header Auth, Param Auth, and Custom Auth.### Basic Auth```pythonfrom basic_rest_endpoint import BasicRestEndpointclass ExampleIntegration(BasicRestEndpoint):    def __init__(self, context):        super(ExampleIntegration, self).__init__(            host=context.asset[&quot;host&quot;],            auth=(context.asset[&quot;username&quot;], context.asset[&quot;password&quot;])        )```This auth is handled by requests directly, and automatically parses it out and inserts it into the headers for us### Header Auth```pythonfrom basic_rest_endpoint import BasicRestEndpoint, HeaderAuthclass ExampleIntegration(BasicRestEndpoint):    def __init__(self, context):        super(ExampleIntegration, self).__init__(            host=context.asset[&quot;host&quot;],            auth=HeaderAuth({&quot;X-api-key&quot;: context.asset[&quot;api_key&quot;]})        )```This auth is when an API requires a certain header to be sent in each request### Param Auth```pythonfrom basic_rest_endpoint import BasicRestEndpoint, ParamAuthclass ExampleIntegration(BasicRestEndpoint):    def __init__(self, context):        super(ExampleIntegration, self).__init__(            host=context.asset[&quot;host&quot;],            auth=ParamAuth({&quot;username&quot;: context.asset[&quot;username&quot;], &quot;password&quot; context.asset[&quot;password&quot;]})        )``````This auth is used when the URL contains the authenticating information, like https://example.com/api/indicator?indicator_id=&lt;id&gt;&amp;username=&lt;username&gt;&amp;password=&lt;password&gt;## Polling RequestsSometimes an API will return a status that indicates that they are still processing your request, and you will need to send requests until the processing is complete. We can use the polling request here.```python# def poll_request(self, method, endpoint, step=5, timeout=60, poll_func=None, **kwargs):# By default the polling stops if you receive a 200# Poll /my/endpoint with default settingsself.poll_request(&quot;GET&quot;, &quot;/my/endpoint&quot;)# Poll /my/endpoint every 5 seconds, giving up after 20 secondsself.poll_request(&quot;GET&quot;, &quot;/my/endpoint&quot;, step=5, timeout=60)# Custom polling function to check if the json returned says it's finisheddef my_poll_func(poll_method, poll_endpoint, poll_kwargs):    result = self.request(poll_method, poll_endpoint, **poll_kwargs)    if r.json()[&quot;status&quot;].lower() == &quot;done&quot;:        return result  # Return the final response    else:        return False  # If what we return is falsey, then it will continue to pollself.poll_request(&quot;GET&quot; &quot;/my/endpoint&quot;, poll_func=my_poll_func)```## Basic PaginationAn API may return a single page in a list of results of pages. To make this easy to process,inherit from BasicPaginationEndpoint and implement the following functions```pythonfrom basic_rest_endpoint import BasicRestPaginationEndpointdef MyIntegration(BasicRestPaginationEndpoint):    def __init__(self, context):        # Same init as BasicRestEndpoint, excluding in example    def get_next_page(self, response):        data = response.json()        if &quot;next&quot; in data:            return data[&quot;next&quot;]  # Return the URL for the next call        else:            return None  # If this function returns None, all pages have been seen    def parse_response(self, response):        data = response.json()        data.pop(&quot;next&quot;, None)  # Remove useless keys/clean data of each response here        return data    def combine_responses(self, results):        # Results is a list of parsed responses, from self.parse_response        all_data = []        for result in results:            all_data.extend(result)  # Use .extend to take [1,2,3] + [4,5] -&gt; [1,2,3,4,5]        return all_data```## Link Headers PaginationSome (very few) APIs implement a standard called &quot;Link Headers&quot; which makes pagination very easy.This implementation is completely done so all you have to do is implement combine_responses```pythonfrom basic_rest_endpoint import LinkHeadersPaginationEndpointdef MyIntegration(LinkHeadersPaginationEndpoint):    def __init__(self, context):        # Same init as BasicRestEndpoint, excluding in example    def combine_responses(self, results):        # do parsing here```## Asset ParserThe `asset_parser` function is used to split the incoming Context object into a super() call for BasicRestEndpointIn the following example, the Context object is parsed, and with auth set to &quot;basic&quot; the username and password are automatically set up for Basic HTTP auth.```pythonfrom basic_rest_endpoint import BasicRestEndpoint, asset_parserclass MyIntegration(BasicRestEndpoint):    def __init__(self, context):        super(MyIntegration, self).__init__(**asset_parser(context, auth=&quot;basic&quot;))class Context(object):    asset = {        &quot;host&quot;: &quot;abc.com&quot;,        &quot;username&quot;: &quot;bb&quot;,        &quot;password&quot;: &quot;cc&quot;,        &quot;verify_ssl&quot;: False,        &quot;http_proxy&quot;: None    }```</longdescription>
</pkgmetadata>