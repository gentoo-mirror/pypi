<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>## Reasoning[FastAPI](https://github.com/tiangolo/fastapi) is an awesome framework that simplifiesthe process of creating APIs. One of the most exciting features is that it can generateOpenAPI specs out of the box. But what if.. you have an OpenAPI spec and you need tocreate an API from it?One day we faced that problem — we had to create an API from multiple OpenAPI specs, andmake sure that the incoming requests and the outgoing responses were aligned with themodels defined the specs.&gt; ⚠️ This library was created to cover only our own needs first. So for now it's not&gt; suitable for everyone and has a lot of technical restrictions. Please consider it as&gt; experimental stuff## InstallationThe package is available on PyPi:```bashpip install openapi-to-fastapi```## Generating FastAPI routesThe main purpose of this library is to generate FastAPI routes from OpenAPI specs. Thisis done by:```pythonfrom pathlib import Pathfrom openapi_to_fastapi.routes import SpecRouterspecs = Path(&quot;./specs&quot;)router = SpecRouter(specs).to_fastapi_router()```The code above will create a FastAPI router that can be either included into the mainrouter, or used as the default one.Imagine you have a following spec (some parts are cut off for brevity):```json{  &quot;openapi&quot;: &quot;3.0.2&quot;,  &quot;paths&quot;: {    &quot;/Company/BasicInfo&quot;: {      &quot;post&quot;: {        &quot;requestBody&quot;: {          &quot;required&quot;: true,          &quot;content&quot;: {            &quot;application/json&quot;: {              &quot;schema&quot;: {                &quot;$ref&quot;: &quot;#/components/schemas/BasicCompanyInfoRequest&quot;,                &quot;responses&quot;: {                  &quot;200&quot;: {                    &quot;content&quot;: {                      &quot;application/json&quot;: {                        &quot;schema&quot;: {                          &quot;$ref&quot;: &quot;#/components/schemas/BasicCompanyInfoResponse&quot;                        }                      }                    }                  }                }              }            }          }        }      },      &quot;components&quot;: {        &quot;schemas&quot;: {          &quot;BasicCompanyInfoRequest&quot;: {            &quot;title&quot;: &quot;BasicCompanyInfoRequest&quot;,            &quot;required&quot;: [&quot;companyId&quot;],            &quot;type&quot;: &quot;object&quot;,            &quot;properties&quot;: {              &quot;companyId&quot;: {                &quot;title&quot;: &quot;Company Id&quot;,                &quot;type&quot;: &quot;string&quot;,                &quot;example&quot;: &quot;2464491-9&quot;              }            }          },          &quot;BasicCompanyInfoResponse&quot;: {            &quot;title&quot;: &quot;BasicCompanyInfoResponse&quot;,            &quot;required&quot;: [&quot;name&quot;, &quot;companyId&quot;, &quot;companyForm&quot;],            &quot;type&quot;: &quot;object&quot;,            &quot;properties&quot;: {              &quot;name&quot;: {                &quot;title&quot;: &quot;Name of the company&quot;,                &quot;type&quot;: &quot;string&quot;              },              &quot;companyId&quot;: {                &quot;title&quot;: &quot;ID of the company&quot;,                &quot;type&quot;: &quot;string&quot;              },              &quot;companyForm&quot;: {                &quot;title&quot;: &quot;The company form of the company&quot;,                &quot;type&quot;: &quot;string&quot;              }            }          }        }      }    }  }}```The FastAPI route equivalent could look like this:```pythonclass BasicCompanyInfoRequest(pydantic.BaseModel):    companyId: strclass BasicCompanyInfoResponse(pydantic.BaseModel):    name: str    companyId: str    companyForm: str@router.post(&quot;/Company/BasicInfo&quot;, response_model=BasicCompanyInfoResponse)def _route(request: BasicCompanyInfoRequest):    return {}```And `openapi-to-fastapi` can create it automagically.### Custom routesIn most cases it makes no sense to create an API without any business logic.Here's how to define it:```pythonfrom fastapi import Header, HTTPExceptionfrom openapi_to_fastapi.routes import SpecRouterspec_router = SpecRouter(&quot;./specs&quot;)# Default handler for all POST endpoints found in the spec@spec_router.post()def hello_world(params, x_my_token: str = Header(...)):    if x_my_token != &quot;my_token&quot;:        raise HTTPException(status_code=403, detail=&quot;Sorry&quot;)    return {&quot;Hello&quot;: &quot;World&quot;}# Specific endpoint for a &quot;/pet&quot; route@spec_router.post(&quot;/pet&quot;)def create_pet(params):    pet = db.make_pet(name=params.name)    return pet.to_dict()router = spec_router.to_fastapi_router()```### API DocumentationNow after you have a lot of routes, you might want to leverage another great feature ofFastAPI — auto documentation.Request and response models are already handled. But to display documentation nicely,FastAPI needs to assign a name for each endpoint. Here is how you can provide such name:```pythonfrom openapi_to_fastapi.routes import SpecRouterspec_router = SpecRouter(&quot;./specs&quot;)@spec_router.post(    &quot;/pet&quot;,    name=&quot;Create a pet&quot;,    description=&quot;Create a pet&quot;,    response_description=&quot;A Pet&quot;,    tags=[&quot;pets&quot;],)def create_pet(params):    return {}# Or you can set the dynamic name based on API pathdef name_factory(path: str, **kwargs):    return path.replace(&quot;/&quot;, &quot; &quot;)@spec_router.post(name_factory=name_factory)def create_pet(params):    return {}```## OpenAPI validationThis package also provides a CLI entrypoint to validate OpenAPI specs. It's especiallyuseful when you need to define you own set of rules for validation.Imagine your API specs are stored in a separate repository and maintained by anotherteam. You also expect that all OpenAPI specs have only one endpoint defined (someinternal agreement).Now you can set up a CI check and validate them on every push.Firstly create a file with a custom validator:```python# my_validator.pyfrom openapi_to_fastapi.validator import BaseValidator, OpenApiValidationErrorclass CustomError(OpenApiValidationError):    pass# important: must be inherited from BaseValidatorclass MyValidator(BaseValidator):    # implement this single method    def validate_spec(self, spec: dict):        if len(spec[&quot;paths&quot;]) != 1:            raise CustomError(&quot;Only one endpoint allowed&quot;)```Then run the tool:```openapi-validator --path ./standards -m my_validator.py -v MyValidator===============================================================================OpenAPI specs root path: ./standardsValidators: DefaultValidator, MyValidator===============================================================================File: ./standards/Current.json[PASSED]-------------------------------------------------------------------------------File: ./standards/Metric.json[PASSED]-------------------------------------------------------------------------------File: ./standards/BasicInfo.json[PASSED]-------------------------------------------------------------------------------===============================================================================Summary:Total : 3Passed: 3Failed: 0===============================================================================```This validator can also be reused when generating routes:```pythonrouter = SpecRouter(specs, validators=[MyValidator])```## DevelopmentYou will need:- Python 3.7+ (though 3.11+ might have some issues with dependencies)- [pre-commit](https://pre-commit.com/#install)Before working on the project, make sure you run:```shellpre-commit install```After making changes you can run tests:```shellpoetry run invoke test```## LicenseThis code is released under the BSD 3-Clause license. Details in the[LICENSE](./LICENSE) file.</longdescription>
</pkgmetadata>