<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># dicomtrolley[![CI](https://github.com/sjoerdk/dicomtrolley/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/sjoerdk/dicomtrolley/actions/workflows/build.yml?query=branch%3Amaster)[![PyPI](https://img.shields.io/pypi/v/dicomtrolley)](https://pypi.org/project/dicomtrolley/)[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/dicomtrolley)](https://pypi.org/project/dicomtrolley/)[![Code Climate](https://codeclimate.com/github/sjoerdk/dicomtrolley/badges/gpa.svg)](https://codeclimate.com/github/sjoerdk/dicomtrolley)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![Checked with mypy](http://www.mypy-lang.org/static/mypy_badge.svg)](http://mypy-lang.org/)Retrieve medical images via WADO, MINT, RAD69 and DICOM-QR* Requires python 3.7, 3.8 or 3.9* Uses `pydicom` and `pynetdicom`. Images and query results are `pydicom.Dataset` instances* Multi-threaded downloading using `requests-futures`![A trolley](docs/resources/trolley.png)## Installation```pip install dicomtrolley``` ## Usage### Basic example```python# Create a http sessionsession = create_session(&quot;https://server/login&quot;,user,password,realm)                           # Use this session to create a trolley using MINT and WADOtrolley = Trolley(searcher=Mint(session, &quot;https://server/mint&quot;),                  wado=Wado(session, &quot;https://server/wado&quot;))# find some studies (using MINT)studies = trolley.find_studies(Query(PatientName='B*'))  # download the fist one (using WADO)trolley.download(studies[0], output_dir='/tmp/trolley')```### Finding studies```pythonstudies = trolley.find_studies(Query(PatientName='B*'))```Basic query parameters can be found in [core.Query](dicomtrolley/core.py#L274). Valid include fields (which information gets sent back) can be found in [fields.py](dicomtrolley/fields.py):```pythonstudies = trolley.find_studies(    Query(modalitiesInStudy='CT*',                patientSex=&quot;F&quot;,                min_study_date=datetime(year=2015, month=3, day=1),               max_study_date=datetime(year=2020, month=3, day=1),               include_fields=['PatientBirthDate', 'SOPClassesInStudy']))```### Finding series and instance detailsTo include series and instance level information as well, use the `queryLevel` parameter```pythonstudies = trolley.find_studies(      # find studies series and instances    Query(studyInstanceID='B*',           query_level=QueryLevels.INSTANCE))a_series = studies.series[0]         # studies now contain series    an_instance = a_series.instances[0]  # and series contain instances```### Downloading dataAny study, series or instance can be downloaded```pythonstudies = trolley.find_studies(Query(PatientName='B*',                                     query_level=QueryLevels.INSTANCE))path = '/tmp/trolley'trolley.download(studies, path)                             # all studiestrolley.download(studies[0]), path                          # a single studytrolley.download(studies[0].series[0], path)                # a single seriestrolley.download(studies[0].series[0].instances[:3], path)  # first 3 instances```More control over download: obtain `pydicom.Dataset` instances directly ```pythonstudies = trolley.find_studies(              # find study including instances    Query(PatientID='1234',           query_level=QueryLevels.INSTANCE)for ds in trolley.get_dataset(studies):      # obtain Dataset for each instance    ds.save_as(f'/tmp/{ds.SOPInstanceUID}.dcm')```Multi-threaded downloading```pythontrolley.download(studies, path,                  use_async=True,  # enable multi-threaded downloading                  max_workers=4)   # optionally set number of concurrent workers                                  # defaults to None which lets python decide```Using WADO only, without search```pythonfrom dicomtrolley.wado import Wadofrom dicomtrolley.core import InstanceReferenceinstance = InstanceReference(series_instance_uid='1.2.1', study_instance_uid='1.2.2', sop_instance_uid='1.2.3')wado = Wado(session, wado_url)for ds in wado.datasets([instance]):  ds.save_as(f'/tmp/{ds.SOPInstanceUID}.dcm')```### DICOM-QR`Trolley` can use DICOM-QR instead of MINT as a search method. See [dicom_qr.DICOMQuery](dicomtrolley/dicom_qr.py#L30) for query details.```pythondicom_qr = DICOMQR(host,port,aet,aec)trolley = Trolley(searcher=dicom_qr, downloader=wado)# Finding is similar to MINT, but a DICOMQuery is used insteadtrolley.find_studies(      query=DICOMQuery(PatientName=&quot;BAL*&quot;,                        min_study_date=datetime(year=2015, month=3, day=1),                     max_study_date=datetime(year=2015, month=4, day=1),                     include_fields=[&quot;PatientBirthDate&quot;, &quot;SOPClassesInStudy&quot;],                     query_level=QueryRetrieveLevels.STUDY)) ```### RAD69The [RAD69](https://gazelle.ihe.net/content/rad-69-retrieve-imaging-document-set) protocol is an alternative to wado for downloading DICOM images.```pythondicom_qr = DICOMQR(host,port,aet,aec)trolley = Trolley(searcher=dicom_qr,                   downloader=Rad69(session=session,                                   url=&quot;https://server/rad69&quot;))studies = trolley.find_studies(Query(PatientName=&quot;AB*&quot;))trolley.download(studies[0], path)  # rad69 download works exactly like wado trolley.download(studies[1], path,                   use_async=True)    # multi-threaded download is supported```#### Ignoring errorsBy default, any error returned by a rad69 server will raise an exception. To ignore certain errors  and keep trying to download, pass theexception class to the Rad69 constructor:```pythonfrom dicomtrolley.rad69 import XDSMissingDocumentErrortrolley = Trolley(searcher=dicom_qr,                   downloader=Rad69(session=session,                                   url=&quot;https://server/rad69&quot;,                                   errors_to_ignore = [XDSMissingDocumentError]))study = trolley.find_study(Query(PatientName=&quot;AB*&quot;))trolley.download(study, path) # will skip series raising XDSMissingDocumentError```### Download formatBy default, trolley writes downloads to disk as `StudyID/SeriesID/InstanceID`, sorting files into separatestudy and series folders. You can change this by passing a `DICOMDiskStorage` instance to trolley:```pythonfrom dicomtrolley.storage import FlatStorageDir#  Creates no sub-folders, just write to single flat filestorage = FlatStorageDir(path=tmpdir)trolley = Trolley(searcher=mint, downloader=wado,                  storage=storage)```You can create your own custom storage method by subclassing [storage.DICOMDiskStorage](dicomtrolley/storage.py#L8):```pythonfrom dicomtrolley.storage import DICOMDiskStorageclass MyStorage(DICOMDiskStorage):  &quot;&quot;&quot;Saves to unique uid filename&quot;&quot;&quot;  def save(self, dataset, path):        dataset.save_as(Path(path) / uuid.uuid4())trolley = Trolley(searcher=mint, downloader=wado,                  storage=MyStorage())```### LoggingDicomtrolley uses the standard [logging](https://docs.python.org/3/howto/logging.html) module. The root logger is called &quot;trolley&quot;. To print log messages, add the following to your code```pythonimport logginglogging.basicConfig(level=logging.DEBUG)# get the root logger to set specific propertiesroot_logger = logging.getLogger('trolley')```### DICOM Query typesFor most DICOM queries you can use a [Query](dicomtrolley/core.py#L322) instance:```pythonfrom dicomtrolley.core import QueryLevels trolley.find_studies(Query(PatientID='1234',                            query_level=QueryLevels.INSTANCE)```If you want to have more control over backend-specific options you can use a backend-specificquery like [MintQuery](dicomtrolley/mint.py#L140) or [DICOMQuery](dicomtrolley/dicom_qr.py#L38). The query then needs to match the backend:```pythontrolley = Trolley(searcher=Mint(session, &quot;https://server/mint&quot;),                  wado=Wado(session, &quot;https://server/wado&quot;]))trolley.find_studies(MintQuery(PatientID='1234', limit=5))```## Examples* [Search for studies in MINT](examples/search_for_studies_mint.py) * [Search for studies in DICOM-QR](examples/search_for_studies_dicom_qr.py)* [Find and download studies](examples/go_shopping.py)* [Using WADO only](examples/use_wado_only.py)* [Download studies with rad69](examples/go_shopping_rad69.py)## Alternatives* [dicomweb-client](https://github.com/MGHComputationalPathology/dicomweb-client) - Active library supporting QIDO-RS, WADO-RS and STOW-RS. * [pynetdicom](https://github.com/pydicom/pynetdicom) - dicomtrolley's DICOM-QR support is based on pynetdicom. Pynetdicom supports a broad range of DICOM networking interactions and can be used as a stand alone application.## CaveatsDicomtrolley has been developed for and tested on a Vitrea Connection 8.2.0.1 system. This claims tobe consistent with WADO and MINT 1.2 interfaces, but does not implement all parts of these standards. Certain query parameter values and restraints might be specific to Vitrea Connection 8.2.0.1. For example,the exact list of DICOM elements that can be returned from a query might be different for different servers.# ContributingYou can contribute in different ways## Report bugsReport bugs at https://github.com/sjoerdk/dicomtrolley/issues.## Contribute code### Get the codeFork this repo, create a feature branch### Set up environmentdicomtrolley uses [poetry](https://python-poetry.org/docs/) for dependency and package management * Install poetry (see [poetry docs](https://python-poetry.org/docs/#installation))* Create a virtual env. Go to the folder where cloned dicomtrolley and use   ```    poetry install   ``` * Install [pre-commit](https://pre-commit.com) hooks.  ```  pre-commit install  ```  ### Add your code Make your code contributions. Make sure document and add tests for new features.To automatically publish to pypi, increment the version number and push to master. See below. ### Lint your code* Run all tests* Run [pre-commit](https://pre-commit.com):  ```  pre-commit run  ```### PublishCreate a pull request### Incrementing the version numberA merged pull request will only be published to pypi if it has a new version number. To bump dicomtrolley's version, do the following.* dicomtrolley uses [semantic versioning](https://semver.org/) Check whether your addition is a PATCH, MINOR or MAJOR version.* Manually increment the version number:  * `pyproject.toml` -&gt; `version = &quot;0.1.2&quot;`  * Add a brief description of your updates new version to `HISTORY.md`</longdescription>
</pkgmetadata>