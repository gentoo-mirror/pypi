<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># net:cal - Uncertainty Calibration&lt;div style=&quot;text-align: justify&quot;&gt;The **net:cal** calibration framework is a Python 3 library for measuring and mitigating miscalibration of uncertainty estimates, e.g., by a neural network. For full API reference documentation, visit&lt;https://efs-opensource.github.io/calibration-framework&gt;.Copyright &amp;copy; 2019-2023 Ruhr West University of Applied Sciences,Bottrop, Germany AND e:fs TechHub GmbH, Gaimersheim, Germany.This Source Code Form is subject to the terms of the Apache License 2.0.If a copy of the APL2 was not distributed with this file, You can obtainone at &lt;https://www.apache.org/licenses/LICENSE-2.0.txt&gt;.**Important: updated references!** If you use this framework(*classification or detection*) or parts of it for your research, pleasecite it by:```@InProceedings{Kueppers_2020_CVPR_Workshops,   author = {Küppers, Fabian and Kronenberger, Jan and Shantia, Amirhossein and Haselhoff, Anselm},   title = {Multivariate Confidence Calibration for Object Detection},   booktitle = {The IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR) Workshops},   month = {June},   year = {2020}}```*If you use Bayesian calibration methods with uncertainty, please citeit by*:```@InProceedings{Kueppers_2021_IV,   author = {Küppers, Fabian and Kronenberger, Jan and Schneider, Jonas and Haselhoff, Anselm},   title = {Bayesian Confidence Calibration for Epistemic Uncertainty Modelling},   booktitle = {Proceedings of the IEEE Intelligent Vehicles Symposium (IV)},   month = {July},   year = {2021},}```*If you use Regression calibration methods, please cite it by*:```@InProceedings{Kueppers_2022_ECCV_Workshops,  author    = {Küppers, Fabian and Schneider, Jonas and Haselhoff, Anselm},  title     = {Parametric and Multivariate Uncertainty Calibration for Regression and Object Detection},  booktitle = {European Conference on Computer Vision (ECCV) Workshops},  year      = {2022},  month     = {October},  publisher = {Springer},}```## Table of Contents- [Overview](#overview)  - [Update on version 1.3](#update-on-version-13)  - [Update on version 1.2](#update-on-version-12)  - [Update on version 1.1](#update-on-version-11)- [Installation](#installation)- [Requirements](#requirements)- [Calibration Metrics](#calibration-metrics)  - [Confidence Calibration Metrics](#confidence-calibration-metrics)  - [Regression Calibration Metrics](#regression-calibration-metrics)- [Methods](#methods)  - [Confidence Calibration Methods](#confidence-calibration-methods)    - [Binning](#binning)    - [Scaling](#scaling)    - [Regularization](#regularization)  - [Regression Calibration Methods](#regression-calibration-methods)    - [Non-parametric calibration](#non-parametric-calibration)    - [Parametric calibration](#parametric-calibration)- [Visualization](#visualization)- [Examples](#examples)  - [Classification](#classification)    - [Post-hoc Calibration for Classification](#post-hoc-calibration-for-classification)    - [Measuring Miscalibration for Classification](#measuring-miscalibration-for-classification)    - [Visualizing Miscalibration for Classification](#visualizing-miscalibration-for-classification)  - [Detection (Confidence of Objects)](#detection-confidence-of-objects)    - [Post-hoc Calibration for Detection](#post-hoc-calibration-for-detection)    - [Measuring Miscalibration for Detection](#measuring-miscalibration-for-detection)    - [Visualizing Miscalibration for Detection](#visualizing-miscalibration-for-detection)  - [Uncertainty in Confidence Calibration](#uncertainty-in-confidence-calibration)    - [Post-hoc Calibration with Uncertainty](#post-hoc-calibration-with-uncertainty)    - [Measuing Miscalibration with Uncertainty](#measuring-miscalibration-with-uncertainty)  - [Probabilistic Regression](#probabilistic-regression)    - [Post-hoc Calibration (Parametric)](#post-hoc-calibration-parametric)    - [Post-hoc Calibration (Non-Parametric)](#post-hoc-calibration-non-parametric)    - [Correlation Estimation and Recalibration](#correlation-estimation-and-recalibration)    - [Measuring Miscalibration for Regression](#measuring-miscalibration-for-regression)    - [Visualizing Miscalibration for Regression](#visualizing-miscalibration-for-regression)- [References](#references)## OverviewThis framework is designed to calibrate the confidence estimates ofclassifiers like neural networks. Modern neural networks are likely tobe overconfident with their predictions. However, reliable confidenceestimates of such classifiers are crucial especially in safety-criticalapplications.For example: given 100 predictions with a confidence of 80% of eachprediction, the observed accuracy should also match 80% (neither morenor less). This behaviour is achievable with several calibrationmethods.### Update on version 1.3TL;DR:- Regression calibration methods: train and infer methods to rescale the uncertainty of probabilistic regression models- New package: *netcal.regression* with regression calibration methods:     - Isotonic Regression (*netcal.regression.IsotonicRegression*)  - Variance Scaling (*netcal.regression.VarianceScaling*)  - GP-Beta (*netcal.regression.GPBeta*)  - GP-Normal (*netcal.regression.GPNormal*)  - GP-Cauchy (*netcal.regression.GPCauchy*)- Implement *netcal.regression.GPNormal* method with correlation estimation and recalibration- Restructured *netcal.metrics* package to distinguish between (semantic) confidence calibration in *netcal.confidence* and regression uncertainty calibration in *netcal.regression*:  - Expected Calibration Error (ECE - *netcal.confidence.ECE*)  - Maximum Calibration Error (MCE - *netcal.confidence.MCE*)  - Average Calibration Error (ACE - *netcal.confidence.ACE*)  - Maximum Mean Calibration Error (MMCE - *netcal.confidence.MMCE*)  - Negative Log Likelihood (NLL - *netcal.regression.NLL*)  - Prediction Interval Coverage Probability (PICP - *netcal.regression.PICP*)  - Pinball loss (*netcal.regression.PinballLoss*)  - Uncertainty Calibration Error (UCE - *netcal.regression.UCE*)  - Expected Normalized Calibration Error (ENCE - *netcal.regression.ENCE*)  - Quantile Calibration Error (QCE - *netcal.regression.QCE*)- Added new types of reliability diagrams to visualize regression calibration properties:     - Reliability Regression diagram to visualize calibration for different quantile levels (preferred - *netcal.presentation.ReliabilityRegression*)  - Reliability QCE diagram to visualize QCE over stddev (*netcal.presentation.QCE*)- Updated examples- Minor bugfixes- Use library [tikzplotlib](https://github.com/texworld/tikzplotlib) within the *netcal.presentation* package to enable a direct conversion of *matplotlib.Figure* objects to Tikz-Code (e.g., can be used for LaTeX figures)Within this release, we provide a new package *netcal.regression* toenable recalibration of probabilistic regression tasks. Withinprobabilistic regression, a regression model does not output a singlescore for each prediction but rather a probability distribution (e.g.,Gaussian with mean/variance) that targets the true output score. Similarto (semantic) confidence calibration, regression calibration requiresthat the estimated uncertainty matches the observed error distribution.There exist several definitions for regression calibration which theprovided calibration methods aim to mitigate (cf. README within the*netcal.regression* package). We distinguish the provided calibrationmethods into non-parametric and parametric methods. Non-parametriccalibration methods take a probability distribution as input and applyrecalibration in terms of quantiles on the cumulative (CDF). This leadsto a recalibrated probability distribution that, however, has noanalytical representation but is given by certain points defining a CDFdistribution. Non-parametric calibration methods are*netcal.regression.IsotonicRegression* and *netcal.regression.GPBeta*.In contrast, parametric calibration methods also take a probabilitydistribution as input and provide a recalibrated distribution that hasan analytical expression (e.g., Gaussian). Parametric calibrationmethods are *netcal.regression.VarianceScaling*,*netcal.regression.GPNormal*, and *netcal.regression.GPCauchy*.The calibration methods are designed to also work with multipleindependent dimensions. The methods*netcal.regression.IsotonicRegression* and*netcal.regression.VarianceScaling* apply a recalibration of eachdimension independently of each other. In contrast, the GP methods*netcal.regression.GPBeta*, *netcal.regression.GPNormal*, and*netcal.regression.GPCauchy* use a single GP to apply recalibration.Furthermore, the GP-Normal *netcal.regression.GPNormal* is can modelpossible correlations within the training data to transform multipleunivariate probability distributions of a single sample to a jointmultivariate (normal) distribution with possible correlations. Thiscalibration scheme is denoted as *correlation estimation*. Additionally,the GP-Normal is also able to take a multivariate (normal) distributionwith correlations as input and applies a recalibration of the wholecovariance matrix. This is referred to as *correlation recalibration*.Besides the recalibration methods, we restructured the *netcal.metrics*package which now also holds several metrics for regression calibration(cf. *netcal.metrics* package documentation for detailed information).Finally, we provide several ways to visualize regression miscalibrationwithin the *netcal.presentation* package.All plot-methods within the *netcal.presentation* package now supportthe option &quot;tikz=True&quot; which switches from standard*matplotlib.Figure* objects to strings with Tikz-Code. Tikz-code can bedirectly used for LaTeX documents to render images as vector graphicswith high quality. Thus, this option helps to improve the quality ofyour reliability diagrams if you are planning to use this library forany type of publication/document### Update on version 1.2TL;DR:- Bayesian confidence calibration: train and infer scaling methods using variational inference (VI) and MCMC sampling- New metrics: MMCE [[13]](#ref13) and PICP [[14]](#ref14) (*netcal.metrics.MMCE* and *netcal.metrics.PICP*)- New regularization methods: MMCE [[13]](#ref13) and DCA [[15]](#ref15) (*netcal.regularization.MMCEPenalty* and *netcal.regularization.DCAPenalty*)- Updated examples- Switched license from MPL2 to APL2Now you can also use Bayesian methods to obtain uncertainty within acalibration mapping mainly in the *netcal.scaling* package. We adaptedMarkov-Chain Monte-Carlo sampling (MCMC) as well as VariationalInference (VI) on common calibration methods. It is also easily possibleto bring the scaling methods to CUDA in order to speed-up thecomputations. We further provide new metrics to evaluate confidencecalibration (MMCE) and to evaluate the quality of prediction intervals(PICP). Finally, we updated our framework by new regularization methodsthat can be used during model training (MMCE and DCA).### Update on version 1.1This framework can also be used to calibrate object detection models. Ithas recently been shown that calibration on object detection alsodepends on the position and/or scale of a predicted object [[12]](#ref12). Weprovide calibration methods to perform confidence calibration w.r.t. theadditional box regression branch. For this purpose, we extended thecommonly used Histogram Binning [[3]](#ref3), Logistic Calibration alias Plattscaling [[10]](#ref10) and the Beta Calibration method [[2]](#ref2) to also include thebounding box information into a calibration mapping. Furthermore, weprovide two new methods called the *Dependent Logistic Calibration* andthe *Dependent Beta Calibration* that are not only able to perform acalibration mapping w.r.t. additional bounding box information but alsoto model correlations and dependencies between all given quantities [[12]](#ref12).Those methods should be preffered over their counterparts in objectdetection mode.The framework is structured as follows:    netcal      .binning         # binning methods (confidence calibration)      .scaling         # scaling methods (confidence calibration)      .regularization  # regularization methods (confidence calibration)      .presentation    # presentation methods (confidence/regression calibration)      .metrics         # metrics for measuring miscalibration (confidence/regression calibration)      .regression      # methods for regression uncertainty calibration (regression calibration)    examples           # example code snippets## InstallationThe installation of the calibration suite is quite easy as it registeredin the Python Package Index (PyPI). You can either install thisframework using PIP:```shell$ python3 -m pip install netcal```Or simply invoke the following command to install the calibration suite when installing from source:```shell$ git clone https://github.com/EFS-OpenSource/calibration-framework$ cd calibration-framework$ python3 -m pip install .```Note: with update 1.3, we switched from *setup.py* to *pyproject.toml*according to PEP-518. The *setup.py* is only for backwardscompatibility.### RequirementsAccording to *requierments.txt*:-   numpy\&gt;=1.18-   scipy\&gt;=1.4-   matplotlib\&gt;=3.3-   scikit-learn\&gt;=0.24-   torch\&gt;=1.9-   torchvision\&gt;=0.10.0-   tqdm\&gt;=4.40-   pyro-ppl\&gt;=1.8-   tikzplotlib\&gt;=0.9.8-   tensorboard\&gt;=2.2-   gpytorch\&gt;=1.5.1## Calibration MetricsWe further distinguish between *onfidence calibration* which aims torecalibrate confidence estimates in the [0, 1] interval, and*regression uncertainty calibration* which addresses the problem ofcalibration in probabilistic regression settings.### Confidence Calibration MetricsThe most common metric to determine miscalibration in the scope ofclassification is the *Expected Calibration Error* (ECE) [[1]](#ref1). Thismetric divides the confidence space into several bins and measures theobserved accuracy in each bin. The bin gaps between observed accuracyand bin confidence are summed up and weighted by the amount of samplesin each bin. The *Maximum Calibration Error* (MCE) denotes the highestgap over all bins. The *Average Calibration Error* (ACE) [[11]](#ref11) denotesthe average miscalibration where each bin gets weighted equally. Forobject detection, we implemented the *Detection Calibration Error*(D-ECE) [[12]](#ref12) that is the natural extension of the ECE to objectdetection tasks. The miscalibration is determined w.r.t. the boundingbox information provided (e.g. box location and/or scale). For thispurpose, all available information gets binned in a multidimensionalhistogram. The accuracy is then calculated in each bin separately todetermine the mean deviation between confidence and accuracy.- (Detection) Expected Calibration Error [[1]](#ref1), [[12]](#ref12) (*netcal.metrics.ECE*)- (Detection) Maximum Calibration Error [[1]](#ref1), [[12]](#ref12)  (*netcal.metrics.MCE*)- (Detection) Average Calibration Error [[11]](#ref11), [[12]](#ref12) (*netcal.metrics.ACE*)- Maximum Mean Calibration Error (MMCE) [[13]](#ref13) (*netcal.metrics.MMCE*) (no position-dependency)### Regression Calibration MetricsIn regression calibration, the most common metric is the *Negative LogLikelihood* (NLL) to measure the quality of a predicted probabilitydistribution w.r.t. the ground-truth:- Negative Log Likelihood (NLL) (*netcal.metrics.NLL*)The metrics *Pinball Loss*, *Prediction Interval Coverage Probability*(PICP), and *Quantile Calibration Error* (QCE) evaluate the estimateddistributions by means of the predicted quantiles. For example, if aforecaster makes 100 predictions using a probability distribution foreach estimate targeting the true ground-truth, we can measure thecoverage of the ground-truth samples for a certain quantile level (e.g.,95% quantile). If the relative amount of ground-truth samples fallinginto a certain predicted quantile is above or below the specifiedquantile level, a forecaster is told to be miscalibrated in terms of*quantile calibration*. Appropriate metrics in this context are- Pinball Loss (*netcal.metrics.PinballLoss*)- Prediction Interval Coverage Probability (PICP) [[14]](#ref14) (*netcal.metrics.PICP*)- Quantile Calibration Error (QCE) [[15]](#ref15) (*netcal.metrics.QCE*)Finally, if we work with normal distributions, we can measure thequality of the predicted variance/stddev estimates. For *variancecalibration*, it is required that the predicted variance mathes theobserved error variance which is equivalent to then Mean Squared Error(MSE). Metrics for *variance calibration* are- Expected Normalized Calibration Error (ENCE) [[17]](#ref17) (*netcal.metrics.ENCE*)- Uncertainty Calibration Error (UCE) [[18]](#ref18) (*netcal.metrics.UCE*)## MethodsWe further give an overview about the post-hoc calibration methods for(semantic) confidence calibration as well as about the methods forregression uncertainty calibration.### Confidence Calibration MethodsThe post-hoc calibration methods are separated into binning and scalingmethods. The binning methods divide the available information intoseveral bins (like ECE or D-ECE) and perform calibration on each bin.The scaling methods scale the confidence estimates or logits directly tocalibrated confidence estimates - on detection calibration, this is donew.r.t. the additional regression branch of a network.Important: if you use the detection mode, you need to specifiy the flag&quot;detection=True&quot; in the constructor of the according method (this isnot necessary for *netcal.scaling.LogisticCalibrationDependent* and*netcal.scaling.BetaCalibrationDependent*).Most of the calibration methods are designed for binary classificationtasks. For binning methods, multi-class calibration is performed in&quot;one vs. all&quot; by default.Some methods such as &quot;Isotonic Regression&quot; utilize methods from thescikit-learn API [[9]](#ref9).Another group are the regularization tools which are added to the lossduring the training of a Neural Network.#### BinningImplemented binning methods are:- Histogram Binning for classification [[3]](#ref3), [[4]](#ref4) and object detection [[12]](#ref12) (*netcal.binning.HistogramBinning*)- Isotonic Regression [[4]](#ref4),[[5]](#ref5) (*netcal.binning.IsotonicRegression*)- Bayesian Binning into Quantiles (BBQ) [[1]](#ref1) (*netcal.binning.BBQ*)- Ensemble of Near Isotonic Regression (ENIR) [[6]](#ref6) (*netcal.binning.ENIR*)#### ScalingImplemented scaling methods are:- Logistic Calibration/Platt Scaling for classification [[10]](#ref10) and object detection [[12]](#ref12) (*netcal.scaling.LogisticCalibration*)- Dependent Logistic Calibration for object detection [[12]](#ref12) (*netcal.scaling.LogisticCalibrationDependent*) - on detection, this method is able to capture correlations between all input quantities and should be preferred over Logistic Calibration for object detection- Temperature Scaling for classification [[7]](#ref7) and object detection [[12]](#ref12) (*netcal.scaling.TemperatureScaling*)- Beta Calibration for classification [[2]](#ref2) and object detection [[12]](#ref12) (*netcal.scaling.BetaCalibration*)- Dependent Beta Calibration for object detection [[12]](#ref12) (*netcal.scaling.BetaCalibrationDependent*) - on detection, this method is able to capture correlations between all input quantities and should be preferred over Beta Calibration for object detection**New on version 1.2:** you can provide a parameter named &quot;method&quot; tothe constructor of each scaling method. This parameter could be one ofthe following: - 'mle': use the method feed-forward with maximumlikelihood estimates on the calibration parameters (standard) -'momentum': use non-convex momentum optimization (e.g. default ondependent beta calibration) - 'mcmc': use Markov-Chain Monte-Carlosampling to obtain multiple parameter sets in order to quantifyuncertainty in the calibration - 'variational': use VariationalInference to obtain multiple parameter sets in order to quantifyuncertainty in the calibration#### RegularizationWith some effort, it is also possible to push the model training towardscalibrated confidences by regularization. Implemented regularizationmethods are:- Confidence Penalty [[8]](#ref8) (*netcal.regularization.confidence\_penalty* and *netcal.regularization.ConfidencePenalty* - the latter one is a PyTorch implementation that might be used as a regularization term)- Maximum Mean Calibration Error (MMCE) [[13]](#ref13) (*netcal.regularization.MMCEPenalty* - PyTorch regularization module)- DCA [[15]](#ref15) (*netcal.regularization.DCAPenalty* - PyTorch regularization module)### Regression Calibration MethodsThe *netcal* library provides post-hoc methods to recalibrate theuncertainty of probabilistic regression tasks. We distinguish thecalibration methods into non-parametric and parametric methods.Non-parametric calibration methods take a probability distribution asinput and apply recalibration in terms of quantiles on the cumulative(CDF). This leads to a recalibrated probability distribution that,however, has no analytical representation but is given by certain pointsdefining a CDF distribution. In contrast, parametric calibration methodsalso take a probability distribution as input and provide a recalibrateddistribution that has an analytical expression (e.g., Gaussian).#### Non-parametric calibrationThe common non-parametric recalibration methods use the predictedcumulative (CDF) distribution functions to learn a mapping from theuncalibrated quantiles to the observed quantile coverage. Using arecalibrated CDF, it is possible to derive the respective densityfunctions (PDF) or to extract statistical moments such as mean andvariance. Non-parametric calibration methods within the*netcal.regression* package are- Isotonic Regression [[19]](#ref19) which applies a (marginal) recalibration of the CDF (*netcal.regression.IsotonicRegression*)- GP-Beta [[20]](#ref20) which applies an input-dependent recalibration of the CDF using a Gaussian process for parameter estimation (*netcal.regression.GPBeta*)#### Parametric calibrationThe parametric recalibration methods apply a recalibration of theestimated distributions so that the resulting distribution is given interms of a distribution with an analytical expression (e.g., aGaussian). These methods are suitable for applications where aparametric distribution is required for subsequent applications, e.g.,within Kalman filtering. We implemented the following parametriccalibration methods:- Variance Scaling [[17]](#ref17), [[18]](#ref18) which is nothing else but a temperature scaling for the predicted variance (*netcal.regression.VarianceScaling*)- GP-Normal [[16]](#ref16) which applies an input-dependent rescaling of the predicted variance (*netcal.regression.GPNormal*). Note: this method is also able to capture correlations between multiple input dimensions and can return a joint multivariate normal distribution as calibration output (cf. examples section).- GP-Cauchy [[16]](#ref16) is similar to GP-Normal but utilizes a Cauchy distribution as calibration output (*netcal.regression.GPCauchy*)## VisualizationFor visualization of miscalibration, one can use a Confidence Histograms&amp; Reliability Diagrams for (semantic) confidence calibration as well asfor regression uncertainty calibration. Within confidence calibration,these diagrams are similar to ECE. The output space is divided intoequally spaced bins. The calibration gap between bin accuracy and binconfidence is visualized as a histogram.For detection calibration, the miscalibration can be visualized eitheralong one additional box information (e.g. the x-position of thepredictions) or distributed over two additional box information in termsof a heatmap.For regression uncertainty calibration, the reliability diagram showsthe relative prediction interval coverage of the ground-truth samplesfor different quantile levels.- Reliability Diagram [[1]](#ref1), [[12]](#ref12) (*netcal.presentation.ReliabilityDiagram*)- Reliability Diagram for regression calibration (*netcal.presentation.ReliabilityRegression*)- Reliability QCE Diagram [[16]](#ref16) shows the Quantile Calibration Error (QCE) for different variance levels (*netcal.presentation.ReliabilityQCE*)**New on version 1.3:** All plot-methods within the*netcal.presentation* package now support the option &quot;tikz=True&quot; whichswitches from standard *matplotlib.Figure* objects to strings withTikz-Code. Tikz-code can be directly used for LaTeX documents to renderimages as vector graphics with high quality. Thus, this option helps toimprove the quality of your reliability diagrams if you are planning touse this library for any type of publication/document## ExamplesThe calibration methods work with the predicted confidence estimates ofa neural network and on detection also with the bounding box regressionbranch.### ClassificationThis is a basic example which uses softmax predictions of aclassification task with 10 classes and the given NumPy arrays:```pythonground_truth  # this is a NumPy 1-D array with ground truth digits between 0-9 - shape: (n_samples,)confidences   # this is a NumPy 2-D array with confidence estimates between 0-1 - shape: (n_samples, n_classes)```#### Post-hoc Calibration for ClassificationThis is an example for *netcal.scaling.TemperatureScaling* but alsoworks for every calibration method (remind different constructorparameters):```pythonimport numpy as npfrom netcal.scaling import TemperatureScalingtemperature = TemperatureScaling()temperature.fit(confidences, ground_truth)calibrated = temperature.transform(confidences)```#### Measuring Miscalibration for ClassificationThe miscalibration can be determined with the ECE:```pythonfrom netcal.metrics import ECEn_bins = 10ece = ECE(n_bins)uncalibrated_score = ece.measure(confidences, ground_truth)calibrated_score = ece.measure(calibrated, ground_truth)```#### Visualizing Miscalibration for ClassificationThe miscalibration can be visualized with a Reliability Diagram:```pythonfrom netcal.presentation import ReliabilityDiagramn_bins = 10diagram = ReliabilityDiagram(n_bins)diagram.plot(confidences, ground_truth)  # visualize miscalibration of uncalibrateddiagram.plot(calibrated, ground_truth)   # visualize miscalibration of calibrated# you can also use this method to create a tikz file with tikz code# that can be directly used within LaTeX documents:diagram.plot(confidences, ground_truth, tikz=True, filename=&quot;diagram.tikz&quot;)```### Detection (Confidence of Objects)In this example we use confidence predictions of an object detectionmodel with the according x-position of the predicted bounding boxes. Ourground-truth provided to the calibration algorithm denotes if a boundingbox has matched a ground-truth box with a certain IoU and the correctclass label.```pythonmatched                # binary NumPy 1-D array (0, 1) that indicates if a bounding box has matched a ground truth at a certain IoU with the right label - shape: (n_samples,)confidences            # NumPy 1-D array with confidence estimates between 0-1 - shape: (n_samples,)relative_x_position    # NumPy 1-D array with relative center-x position between 0-1 of each prediction - shape: (n_samples,)```#### Post-hoc Calibration for DetectionThis is an example for *netcal.scaling.LogisticCalibration* and*netcal.scaling.LogisticCalibrationDependent* but also works for everycalibration method (remind different constructor parameters):```pythonimport numpy as npfrom netcal.scaling import LogisticCalibration, LogisticCalibrationDependentinput = np.stack((confidences, relative_x_position), axis=1)lr = LogisticCalibration(detection=True, use_cuda=False)    # flag 'detection=True' is mandatory for this methodlr.fit(input, matched)calibrated = lr.transform(input)lr_dependent = LogisticCalibrationDependent(use_cuda=False) # flag 'detection=True' is not necessary as this method is only defined for detectionlr_dependent.fit(input, matched)calibrated = lr_dependent.transform(input)```#### Measuring Miscalibration for DetectionThe miscalibration can be determined with the D-ECE:```pythonfrom netcal.metrics import ECEn_bins = [10, 10]input_calibrated = np.stack((calibrated, relative_x_position), axis=1)ece = ECE(n_bins, detection=True)           # flag 'detection=True' is mandatory for this methoduncalibrated_score = ece.measure(input, matched)calibrated_score = ece.measure(input_calibrated, matched)```#### Visualizing Miscalibration for DetectionThe miscalibration can be visualized with a Reliability Diagram:```pythonfrom netcal.presentation import ReliabilityDiagramn_bins = [10, 10]diagram = ReliabilityDiagram(n_bins, detection=True)    # flag 'detection=True' is mandatory for this methoddiagram.plot(input, matched)                # visualize miscalibration of uncalibrateddiagram.plot(input_calibrated, matched)     # visualize miscalibration of calibrated# you can also use this method to create a tikz file with tikz code# that can be directly used within LaTeX documents:diagram.plot(input, matched, tikz=True, filename=&quot;diagram.tikz&quot;)```### Uncertainty in Confidence CalibrationWe can also quantify the uncertainty in a calibration mapping if we usea Bayesian view on the calibration models. We can sample multipleparameter sets using MCMC sampling or VI. In this example, we reuse thedata of the previous detection example.```pythonmatched                # binary NumPy 1-D array (0, 1) that indicates if a bounding box has matched a ground truth at a certain IoU with the right label - shape: (n_samples,)confidences            # NumPy 1-D array with confidence estimates between 0-1 - shape: (n_samples,)relative_x_position    # NumPy 1-D array with relative center-x position between 0-1 of each prediction - shape: (n_samples,)```#### Post-hoc Calibration with UncertaintyThis is an example for *netcal.scaling.LogisticCalibration* and*netcal.scaling.LogisticCalibrationDependent* but also works for everycalibration method (remind different constructor parameters):```pythonimport numpy as npfrom netcal.scaling import LogisticCalibration, LogisticCalibrationDependentinput = np.stack((confidences, relative_x_position), axis=1)# flag 'detection=True' is mandatory for this method# use Variational Inference with 2000 optimization steps for creating this calibration mappinglr = LogisticCalibration(detection=True, method'variational', vi_epochs=2000, use_cuda=False)lr.fit(input, matched)# 'num_samples=1000': sample 1000 parameter sets from VI# thus, 'calibrated' has shape [1000, n_samples]calibrated = lr.transform(input, num_samples=1000)# flag 'detection=True' is not necessary as this method is only defined for detection# this time, use Markov-Chain Monte-Carlo sampling with 250 warm-up steps, 250 parameter samples and one chainlr_dependent = LogisticCalibrationDependent(method='mcmc',                                            mcmc_warmup_steps=250, mcmc_steps=250, mcmc_chains=1,                                            use_cuda=False)lr_dependent.fit(input, matched)# 'num_samples=1000': although we have only sampled 250 different parameter sets,# we can randomly sample 1000 parameter sets from MCMCcalibrated = lr_dependent.transform(input)```#### Measuring Miscalibration with UncertaintyYou can directly pass the output to the D-ECE and PICP instance tomeasure miscalibration and mask quality:```pythonfrom netcal.metrics import ECEfrom netcal.metrics import PICPn_bins = 10ece = ECE(n_bins, detection=True)picp = PICP(n_bins, detection=True)# the following function calls are equivalent:miscalibration = ece.measure(calibrated, matched, uncertainty=&quot;mean&quot;)miscalibration = ece.measure(np.mean(calibrated, axis=0), matched)# now determine uncertainty qualityuncertainty = picp.measure(calibrated, matched, kind=&quot;confidence&quot;)print(&quot;D-ECE:&quot;, miscalibration)print(&quot;PICP:&quot;, uncertainty.picp) # prediction coverage probabilityprint(&quot;MPIW:&quot;, uncertainty.mpiw) # mean prediction interval width```If we want to measure miscalibration and uncertainty quality by means ofthe relative x position, we need to broadcast the according information:```python# broadcast and stack x information to calibrated informationbroadcasted = np.broadcast_to(relative_x_position, calibrated.shape)calibrated = np.stack((calibrated, broadcasted), axis=2)n_bins = [10, 10]ece = ECE(n_bins, detection=True)picp = PICP(n_bins, detection=True)# the following function calls are equivalent:miscalibration = ece.measure(calibrated, matched, uncertainty=&quot;mean&quot;)miscalibration = ece.measure(np.mean(calibrated, axis=0), matched)# now determine uncertainty qualityuncertainty = picp.measure(calibrated, matched, uncertainty=&quot;mean&quot;)print(&quot;D-ECE:&quot;, miscalibration)print(&quot;PICP:&quot;, uncertainty.picp) # prediction coverage probabilityprint(&quot;MPIW:&quot;, uncertainty.mpiw) # mean prediction interval width```### Probabilistic RegressionThe following example shows how to use the post-hoc calibration methodsfor probabilistic regression tasks. Within probabilistic regression, aforecaster (e.g. with Gaussian prior) outputs a mean and a variancetargeting the true ground-truth score. Thus, the following informationis required to construct the calibration methods:```pythonmean          # NumPy n-D array holding the estimated mean of shape (n, d) with n samples and d dimensionsstddev        # NumPy n-D array holding the estimated stddev (independent) of shape (n, d) with n samples and d dimensionsground_truth  # NumPy n-D array holding the ground-truth scores of shape (n, d) with n samples and d dimensions```#### Post-hoc Calibration (Parametric)These information might result e.g. from object detection where theposition information of the objects (bounding boxes) are parametrized bynormal distributions. We start by using parametric calibration methodssuch as Variance Scaling:```pythonfrom netcal.regression import VarianceScaling, GPNormal# the initialization of the Variance Scaling method is pretty simplevarscaling = VarianceScaling()# the GP-Normal requires a little bit more parameters to parametrize the underlying GPgpnormal = GPNormal(    n_inducing_points=12,    # number of inducing points    n_random_samples=256,    # random samples used for likelihood    n_epochs=256,            # optimization epochs    use_cuda=False,          # can also use CUDA for computations)# fit the Variance Scaling# note that we need to pass the first argument as tuple as the input distributions# are parametrized by mean and variancevarscaling.fit((mean, stddev), ground_truth)# fit GP-Normal - similar parameters here!gpnormal.fit((mean, stddev), ground_truth)# transform distributions to obtain recalibrated stddevsstddev_varscaling = varscaling.transform((mean, stddev))  # NumPy array with stddev - has shape (n, d)stddev_gpnormal = gpnormal.transform((mean, stddev))  # NumPy array with stddev - has shape (n, d)```#### Post-hoc Calibration (Non-Parametric)We can also use non-parametric calibration methods. In this case, thecalibrated distributions are defined by their density (PDF) andcumulative (CDF) functions:```pythonfrom netcal.regression import IsotonicRegression, GPBeta# the initialization of the Isotonic Regression method is pretty simpleisotonic = IsotonicRegression()# the GP-Normal requires a little bit more parameters to parametrize the underlying GPgpbeta = GPBeta(    n_inducing_points=12,    # number of inducing points    n_random_samples=256,    # random samples used for likelihood    n_epochs=256,            # optimization epochs    use_cuda=False,          # can also use CUDA for computations)# fit the Isotonic Regression# note that we need to pass the first argument as tuple as the input distributions# are parametrized by mean and varianceisotonic.fit((mean, stddev), ground_truth)# fit GP-Beta - similar parameters here!gpbeta.fit((mean, stddev), ground_truth)# transform distributions to obtain recalibrated distributionst_isotonic, pdf_isotonic, cdf_isotonic = varscaling.transform((mean, stddev))t_gpbeta, pdf_gpbeta, cdf_gpbeta = gpbeta.transform((mean, stddev))# Note: the transformation results are NumPy n-d arrays with shape (t, n, d)# with t as the number of points that define the PDF/CDF,# with n as the number of samples, and# with d as the number of dimensions.# The resulting variables can be interpreted as follows:# - t_isotonic/t_gpbeta: x-values of the PDF/CDF with shape (t, n, d)# - pdf_isotonic/pdf_gpbeta: y-values of the PDF with shape (t, n, d)# - cdf_isotonic/cdf_gpbeta: y-values of the CDF with shape (t, n, d)```You can visualize the non-parametric distribution of a single samplewithin a single dimension using Matplotlib:```pythonfrom matplotlib import pyplot as pltfig, (ax1, ax2) = plt.subplots(2, 1)# plot the recalibrated PDF within a single axis after calibrationax1.plot(    t_isotonic[:, 0, 0], pdf_isotonic[:, 0, 0],    t_gpbeta[:, 0, 0], pdf_gpbeta[:, 0, 0],)# plot the recalibrated PDF within a single axis after calibrationax2.plot(    t_isotonic[:, 0, 0], cdf_isotonic[:, 0, 0],    t_gpbeta[:, 0, 0], cdf_gpbeta[:, 0, 0],)plt.show()```We provide a method to extract the statistical moments expectation andvariance from the recalibrated cumulative (CDF). Note that we advise touse one of the parametric calibration methods if you need e.g. aGaussian for subsequent applications such as Kalman filtering.```pythonfrom netcal import cumulative_moments# extract the expectation (mean) and the variance from the recalibrated CDFymean_isotonic, yvar_isotonic = cumulative_moments(t_isotonic, cdf_isotonic)ymean_gpbeta, yvar_gpbeta = cumulative_moments(t_gpbeta, cdf_gpbeta)# each of these variables has shape (n, d) and holds the# mean/variance for each sample and in each dimension```#### Correlation Estimation and RecalibrationWith the GP-Normal *netcal.regression.GPNormal*, it is also possible todetect possible correlations between multiple input dimensions that haveoriginally been trained/modelled independently from each other:```pythonfrom netcal.regression import GPNormal# the GP-Normal requires a little bit more parameters to parametrize the underlying GPgpnormal = GPNormal(    n_inducing_points=12,    # number of inducing points    n_random_samples=256,    # random samples used for likelihood    n_epochs=256,            # optimization epochs    use_cuda=False,          # can also use CUDA for computations    correlations=True,       # enable correlation capturing between the input dimensions)# fit GP-Normal# note that we need to pass the first argument as tuple as the input distributions# are parametrized by mean and variancegpnormal.fit((mean, stddev), ground_truth)# transform distributions to obtain recalibrated covariance matricescov = gpnormal.transform((mean, stddev))  # NumPy array with covariance - has shape (n, d, d)# note: if the input is already given by multivariate normal distributions# (stddev is covariance and has shape (n, d, d)), the methods works similar# and simply applies a covariance recalibration of the input```#### Measuring Miscalibration for RegressionMeasuring miscalibration is as simple as the training of the methods:```pythonimport numpy as npfrom netcal.metrics import NLL, PinballLoss, QCE# define the quantile levels that are used to evaluate the pinball loss and the QCEquantiles = np.linspace(0.1, 0.9, 9)# initialize NLL, Pinball, and QCE objectsnll = NLL()pinball = PinballLoss()qce = QCE(marginal=True)  # if &quot;marginal=False&quot;, we can also measure the QCE by means of the predicted variance levels (realized by binning the variance space)# measure miscalibration with the initialized metrics# Note: the parameter &quot;reduction&quot; has a major influence to the return shape of the metrics# see the method docstrings for detailed informationnll.measure((mean, stddev), ground_truth, reduction=&quot;mean&quot;)pinball.measure((mean, stddev), ground_truth, q=quantiles, reduction=&quot;mean&quot;)qce.measure((mean, stddev), ground_truth, q=quantiles, reduction=&quot;mean&quot;)```#### Visualizing Miscalibration for RegressionExample visualization code block using the*netcal.presentation.ReliabilityRegression* class:```pythonfrom netcal.presentation import ReliabilityRegression# define the quantile levels that are used for the quantile evaluationquantiles = np.linspace(0.1, 0.9, 9)# initialize the diagram objectdiagram = ReliabilityRegression(quantiles=quantiles)# visualize miscalibration with the initialized objectdiagram.plot((mean, stddev), ground_truth)# you can also use this method to create a tikz file with tikz code# that can be directly used within LaTeX documents:diagram.plot((mean, stddev), ground_truth, tikz=True, filename=&quot;diagram.tikz&quot;)```&lt;/div&gt;## References&lt;a name=&quot;ref1&quot;&gt;[1]&lt;/a&gt; Naeini, Mahdi Pakdaman, Gregory Cooper, and Milos Hauskrecht: &quot;Obtaining well calibrated probabilities using bayesian binning.&quot; Twenty-Ninth AAAI Conference on Artificial Intelligence, 2015.&lt;a name=&quot;ref2&quot;&gt;[2]&lt;/a&gt; Kull, Meelis, Telmo Silva Filho, and Peter Flach: &quot;Beta calibration: a well-founded and easily implemented improvement on logistic calibration for binary classifiers.&quot; Artificial Intelligence and Statistics, PMLR 54:623-631, 2017.&lt;a name=&quot;ref3&quot;&gt;[3]&lt;/a&gt; Zadrozny, Bianca and Elkan, Charles: &quot;Obtaining calibrated probability estimates from decision trees and naive bayesian classifiers.&quot; In ICML, pp. 609–616, 2001.&lt;a name=&quot;ref4&quot;&gt;[4]&lt;/a&gt; Zadrozny, Bianca and Elkan, Charles: &quot;Transforming classifier scores into accurate multiclass probability estimates.&quot; In KDD, pp. 694–699, 2002.&lt;a name=&quot;ref5&quot;&gt;[5]&lt;/a&gt; Ryan J Tibshirani, Holger Hoefling, and Robert Tibshirani: &quot;Nearly-isotonic regression.&quot; Technometrics, 53(1):54–61, 2011.&lt;a name=&quot;ref6&quot;&gt;[6]&lt;/a&gt; Naeini, Mahdi Pakdaman, and Gregory F. Cooper: &quot;Binary classifier calibration using an ensemble of near isotonic regression models.&quot; 2016 IEEE 16th International Conference on Data Mining (ICDM). IEEE, 2016.&lt;a name=&quot;ref7&quot;&gt;[7]&lt;/a&gt; Chuan Guo, Geoff Pleiss, Yu Sun and Kilian Q. Weinberger: &quot;On Calibration of Modern Neural Networks.&quot; Proceedings of the 34th International Conference on Machine Learning, 2017.&lt;a name=&quot;ref8&quot;&gt;[8]&lt;/a&gt; Pereyra, G., Tucker, G., Chorowski, J., Kaiser, L. and Hinton, G.: “Regularizing neural networks by penalizing confident output distributions.” CoRR, 2017.&lt;a name=&quot;ref9&quot;&gt;[9]&lt;/a&gt; Pedregosa, F., Varoquaux, G., Gramfort, A., Michel, V., Thirion, B., Grisel, O., Blondel, M., Prettenhofer, P., Weiss, R., Dubourg, V., Vanderplas, J., Passos, A., Cournapeau, D., Brucher, M., Perrot, M. and Duchesnay, E.: &quot;Scikit-learn: Machine Learning in Python.&quot; In Journal of Machine Learning Research, volume 12 pp 2825-2830, 2011.&lt;a name=&quot;ref10&quot;&gt;[10]&lt;/a&gt; Platt, John: &quot;Probabilistic outputs for support vector machines and comparisons to regularized likelihood methods.&quot; Advances in large margin classifiers, 10(3): 61–74, 1999.&lt;a name=&quot;ref11&quot;&gt;[11]&lt;/a&gt; Neumann, Lukas, Andrew Zisserman, and Andrea Vedaldi: &quot;Relaxed Softmax: Efficient Confidence Auto-Calibration for Safe Pedestrian Detection.&quot; Conference on Neural Information Processing Systems (NIPS) Workshop MLITS, 2018.&lt;a name=&quot;ref12&quot;&gt;[12]&lt;/a&gt; Fabian Küppers, Jan Kronenberger, Amirhossein Shantia, and Anselm Haselhoff: &quot;Multivariate Confidence Calibration for Object Detection&quot;.&quot; The IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR) Workshops, 2020&lt;a name=&quot;ref13&quot;&gt;[13]&lt;/a&gt; Kumar, Aviral, Sunita Sarawagi, and Ujjwal Jain: &quot;Trainable calibration measures for neural networks from _kernel mean embeddings.&quot; International Conference on Machine Learning. 2018&lt;a name=&quot;ref14&quot;&gt;[14]&lt;/a&gt; Jiayu  Yao,  Weiwei  Pan,  Soumya  Ghosh,  and  Finale  Doshi-Velez: &quot;Quality of Uncertainty Quantification for Bayesian Neural Network Inference.&quot; Workshop on Uncertainty and Robustness in Deep Learning, ICML, 2019&lt;a name=&quot;ref15&quot;&gt;[15]&lt;/a&gt; Liang, Gongbo, et al.: &quot;Improved trainable calibration method for neural networks on medical imaging classification.&quot; arXiv preprint arXiv:2009.04057 (2020)&lt;a name=&quot;ref16&quot;&gt;[16]&lt;/a&gt; Fabian Küppers, Jonas Schneider, Jonas, and Anselm Haselhoff: &quot;Parametric and Multivariate Uncertainty Calibration for Regression and Object Detection.&quot; In: Proceedings of the European Conference on Computer Vision (ECCV) Workshops, Springer, October 2022&lt;a name=&quot;ref17&quot;&gt;[17]&lt;/a&gt; Levi, Dan, et al.: &quot;Evaluating and calibrating uncertainty prediction in regression tasks.&quot; arXiv preprint arXiv:1905.11659 (2019).&lt;a name=&quot;ref18&quot;&gt;[18]&lt;/a&gt; Laves, Max-Heinrich, et al.: &quot;Well-calibrated regression uncertainty in medical imaging with deep learning.&quot; Medical Imaging with Deep Learning. PMLR, 2020.&lt;a name=&quot;ref19&quot;&gt;[19]&lt;/a&gt; Volodymyr Kuleshov, Nathan Fenner, and Stefano Ermon: &quot;Accurate uncertainties for deep learning using calibrated regression.&quot; International Conference on Machine Learning. PMLR, 2018.&lt;a name=&quot;ref20&quot;&gt;[20]&lt;/a&gt; Hao Song, Tom Diethe, Meelis Kull and Peter Flach: &quot;Distribution calibration for regression.&quot; International Conference on Machine Learning. PMLR, 2019.</longdescription>
</pkgmetadata>