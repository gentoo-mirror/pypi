<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># NatsAPI## Table of Contents&lt;!-- vim-markdown-toc GitLab --&gt;* [Installation](#installation)* [Usage](#usage)    * [Docs](#docs)    * [Examples](#examples)        * [Basic](#basic)        * [Error handling with sentry](#error-handling-with-sentry)        * [Reload](#reload)    * [Generating documentation (asyncapi)](#generating-documentation-asyncapi)    * [Plugins](#plugins)* [History](#history)&lt;!-- vim-markdown-toc --&gt;NatsAPI is a framework to develop Python3 applications that uses [nats](https://nats.io) as communication medium instead of http. With nats you have a smaller footprint, faster req/s, pub/sub and better observability.It is highly inspired by [FastAPI](https://github.com/tiangolo/fastapi) and has the same development style. NatsAPI produces an [AsyncAPI](https://www.asyncapi.com/) schema out of the box, **this schema is not fully compatible with the standard**.## Installation```$ pip install natsapi```## Usage### Docs&gt; UNDER CONSTRUCTION### Examples#### Basic```pythonfrom natsapi import NatsAPI, SubjectRouterfrom pydantic import BaseModelclass Message(BaseModel):    message: strclass Person(BaseModel):    first_name: str    last_name: strapp = NatsAPI(&quot;natsapi&quot;)router = SubjectRouter()@router.request(&quot;persons.greet&quot;, result=Message)async def greet_person(app: NatsAPI, person: Person):    return {&quot;message&quot;: f&quot;Greetings {person.first_name} {person.last_name}!&quot;}app.include_router(router)if __name__ == &quot;__main__&quot;:    app.run()```Run as follows:```bash$ python app.py```Docs will be rendered as:![Example of redoc](./doc/minimal.png)Send a request:```pythonfrom natsapi import NatsAPIimport asyncioasync def main():    app = await NatsAPI(&quot;client&quot;).startup()    params = {&quot;person&quot;: {&quot;first_name&quot;: &quot;Foo&quot;, &quot;last_name&quot;: &quot;Bar&quot;}}    r = await app.nc.request(&quot;natsapi.persons.greet&quot;, params=params, timeout=5)    print(r.result)asyncio.run(main())#&gt; {'message': 'Greetings Foo Bar!'}```or on the command line```shell$ nats request natsapi.persons.greet '{&quot;params&quot;: {&quot;person&quot;: {&quot;first_name&quot;: &quot;Foo&quot;, &quot;last_name&quot;: &quot;Bar&quot;}}}'                                                                                                    18:19:00 Sending request on &quot;natsapi.persons.greet&quot;18:19:00 Received on &quot;_INBOX.dpBgTyG9XC5NhagdqRHTcp.eMkVkru8&quot; rtt 1.052463ms{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: &quot;c2bc2d20-dbd5-4e39-a22d-c22a8631c5a3&quot;, &quot;result&quot;: {&quot;message&quot;: &quot;Greetings Foo Bar!&quot;}, &quot;error&quot;: null}```#### Error handling with sentry```pythonfrom natsapi import NatsAPI, SubjectRouterimport loggingfrom pydantic import ValidationErrorfrom sentry_sdk import configure_scopefrom natsapi.models import JsonRPCRequest, JsonRPCErrorfrom pydantic import BaseModelclass StatusResult(BaseModel):    status: strapp = NatsAPI(&quot;natsapi-example&quot;)router = SubjectRouter()@router.request(&quot;healthz&quot;, result=StatusResult)async def handle_user(app: NatsAPI):    return {&quot;status&quot;: &quot;OK&quot;}app.include_router(router)def configure_sentry(auth):    with configure_scope() as scope:        scope.user = {            &quot;email&quot;: auth.get(&quot;email&quot;),            &quot;id&quot;: auth.get(&quot;uid&quot;),            &quot;ip_address&quot;: auth.get(&quot;ip_address&quot;),        }@app.exception_handler(ValidationError)async def handle_validation_exception(exc: ValidationError, request: JsonRPCRequest, subject: str) -&gt; JsonRPCError:    auth = request.params.get(&quot;auth&quot;) or {}    configure_sentry(auth)    logging.error(        exc,        exc_info=True,        stack_info=True,        extra={&quot;auth&quot;: auth, &quot;json&quot;: request.dict(), &quot;subject&quot;: subject, &quot;NATS&quot;: True, &quot;code&quot;: -32003},    )    return JsonRPCError(code=-90001, message=&quot;VALIDATION_ERROR&quot;, data={&quot;error_str&quot;: str(exc)})if __name__ == &quot;__main__&quot;:    app.run(reload=False)```#### ReloadWhen running from a file you can add a reload flag (hot-reload on file change) or use the `NATSAPI_RELOAD` env var.```if __name__ == &quot;__main__&quot;:    app.run(reload=True)```### Generating documentation (asyncapi)To see the documentation, you can use the binary to run the server. Root path is `natsapi-example` so:```bash$ ./nats-redoc 4222 master.trinity-testingServer runningDocs can be found on localhost:8090connected to nats on port 4222```When surfing to [localhost:8090](http://127.0.0.1:8090), the documentation should look like this:![Example of redoc](./doc/readme-example-redoc.png)### PluginsPlugins can be added and are found in `natsapi/plugin.py`.- [natsapi_mock](./natsapi/plugin.py): A handy mock fixture to intercept nats requests and to fake nats responses for any subject.</longdescription>
</pkgmetadata>