<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>django-scopes=============![Build status](https://github.com/raphaelm/django-scopes/actions/workflows/tests.yml/badge.svg)![PyPI](https://img.shields.io/pypi/v/django-scopes.svg)[![Python versions](https://img.shields.io/pypi/pyversions/django-scopes.svg)](https://pypi.org/project/django-scopes/)![PyPI - Django Version](https://img.shields.io/pypi/djversions/django-scopes)Motivation----------Many of us use Django to build multi-tenant applications where every user only evergets access to a small, separated fraction of the data in our application, whileat the same time having *some* global functionality that makes separate databases perclient infeasible. While Django does a great job protecting us from building SQLinjection vulnerabilities and similar errors, Django can't protect us from logicerrors and one of the most dangerous types of security issues for multi-tenantapplications is that we leak data across tenants.It's so easy to forget that one ``.filter`` call and it's hard to catch these errorsin both manual and automated testing, since you usually do not have a lot of clientsin your development setup. Leaving [radical, database-dependent ideas](https://github.com/bernardopires/django-tenant-schemas)aside, there aren't many approaches available in the ecosystem to prevent these mistakesfrom happening aside from rigorous code review.We'd like to propose this module as a flexible line of defense. It is meant to havelittle impact on your day-to-day work, but act as a safeguard in case you build afaulty query.Installation------------There's nothing required apart from a simplepip install django-scopesCompatibility-------------This library is tested against **Python 3.8-3.10** and **Django 3.2-4.0**.Usage-----Let's assume we have a multi-tenant blog application consisting of the three models ``Site``,``Post``, and ``Comment``:```pythonfrom django.db import modelsclass Site(models.Model):name = models.CharField(…)class Post(models.Model):site = models.ForeignKey(Site, …)title = models.CharField(…)class Comment(models.Model):post = models.ForeignKey(Post, …)text = models.CharField(…)```In this case, our model `Site` acts as the tenant for the blog posts and their comments, henceour application will probably be full of statements like``Post.objects.filter(site=current_site)``, ``Comment.objects.filter(post__site=current_site)``,or more complex when more flexible permission handling is involved. With **django-scopes**, weencourage you to still write these queries with your custom permission-based filters, butwe add a custom model manager that has knowledge about posts and comments being part of atenant scope:```pythonfrom django_scopes import ScopedManagerclass Post(models.Model):site = models.ForeignKey(Site, …)title = models.CharField(…)objects = ScopedManager(site='site')class Comment(models.Model):post = models.ForeignKey(Post, …)text = models.CharField(…)objects = ScopedManager(site='post__site')```The keyword argument ``site`` defines the name of our **scope dimension**, while the string``'site'`` or ``'post__site'`` tells us how we can look up the value for this scope dimensionin ORM queries.You could have multi-dimensional scopes by passing multiple keyword arguments to``ScopedManager``, e.g. ``ScopedManager(site='post__site', user='author')`` if that isrelevant to your usecase.Now, with this custom manager, all queries are banned at first:&gt;&gt;&gt; Comment.objects.all()ScopeError: A scope on dimension &quot;site&quot; needs to be active for this query.The only thing that will work is ``Comment.objects.none()``, which is useful e.g. for Djangogeneric view definitions.### Activate scopes in contextsYou can now use our context manager to specifically allow queries to a specific blogging site,e.g.:```pythonfrom django_scopes import scopewith scope(site=current_site):Comment.objects.all()```This will *automatically* add a ``.filter(post__site=current_site)`` to all of your queries.Again, we recommend that you *still* write them explicitly, but it is nice to know to have asafeguard.Of course, you can still explicitly enter a non-scoped context to access all the objects in yoursystem:```pythonwith scope(site=None):Comment.objects.all()```This also works correctly nested within a previously defined scope. You can also activate multiplevalues at once:```pythonwith scope(site=[site1, site2]):Comment.objects.all()```Sounds cumbersome to put those ``with`` statements everywhere? Maybe not at all: You probablyalready have a middleware that determines the site (or tenant, in general) for every requestbased on URL or logged in user, and you can easily use it there to just automatically wrapit around all your tenant-specific views.Functions can opt out of this behavior by using```pythonfrom django_scopes import scopes_disabledwith scopes_disabled():    …# OR@scopes_disabled()def fun(…):    …```Please note that **django-scopes** is also active during migrations, so if you are writing adata migration – or have written one in the past! – you'll have to add appropriate scopingor use the ``scopes_disabled`` context.### Custom manager classesIf you were already using a custom manager class, you can pass it to a `ScopedManager` with the `_manager_class`keyword like this:from django.db import models```pythonfrom django.db import modelsclass SiteManager(models.Manager):def get_queryset(self):return super().get_queryset().exclude(name__startswith='test')class Site(models.Model):name = models.CharField(…)objects = ScopedManager(site='site', _manager_class=SiteManager)```### Scoping the User modelAssume you've got two models `User` and `Post`. Using the examples above, you can ensure that users only ever see their own diary posts. But how about leaking other users to the currently logged in user? If you application doesn't have much (or any) interaction between users, you can scope the user model. Please note that you'll need a [custom user model](https://docs.djangoproject.com/en/dev/topics/auth/customizing/#specifying-a-custom-user-model). Which base classes your user and manager work off will very between projects.```pythonclass User(AbstractUser):objects = ScopedManager(user='pk', _manager_class=UserManager)# (...)```Activating the scope comes with a little caveat - you need to use the users primary key, not the whole object:```pythonwith scope(user=request.user.pk):# do something :)```Caveats-------### Admin**django-scopes** is not compatible with the django admin out of the box, integration requires acustom middleware. (If you write one, please open a PR to include it in this package!)### TestingWe want to enforce scoping by default to stay safe, which unfortunatelybreaks the Django test runner as well as pytest-django. For now, we haven't founda better solution than to monkeypatch it:```pythonfrom django.test import utilsfrom django_scopes import scopes_disabledutils.setup_databases = scopes_disabled()(utils.setup_databases)```You can wrap many of your test and fixtures inside ``scopes_disabled()`` as well, but we wouldn't advise to do it with all of them: Especially when writing higher-level functional tests, such as tests using Django's test client or tests testing celery tasks, you should make sure that your application code runs as it does in production. Therefore, writing tests for a project using django-scopes often looks like this:```python@pytest.mark.django_dbdef test_a_view(client):    with scopes_disabled():        u = User.objects.create(...)    client.post('/user/{}/delete'.format(u.pk))    with scopes_disabled():    assert not User.objects.filter(pk=u.pk).exists()```If you want to disable scoping or activate a certain scope whenever a specific fixture is used, you can do so in py.test like this:```python@pytest.fixturedef site():    s = Site.objects.create(...)    with scope(site=s):        yield s```When trying to port a project with *lots* of fixtures, it can be helpful to roll a small py.test plugin in your ``conftest.py`` to just globally disable scoping for all fixtures which are not yielding fixtures (like the one above):```python@pytest.hookimpl(hookwrapper=True)def pytest_fixture_setup(fixturedef, request):    if inspect.isgeneratorfunction(fixturedef.func):        yield    else:        with scopes_disabled():            yield```### ModelFormsWhen using model forms, Django will automatically generate choice fields on foreignkeys and many-to-many fields. This won't work here, so we supply helper fieldclasses ``SafeModelChoiceField`` and ``SafeModelMultipleChoiceField`` that use anempty queryset instead:```pythonfrom django.forms import ModelFormfrom django_scopes.forms import SafeModelChoiceFieldclass PostMethodForm(ModelForm):    class Meta:        model = Comment        field_classes = {            'post': SafeModelChoiceField,        }```### django-filterWe noticed that ``django-filter`` also runs some queries when generating filtersets.Currently, our best workaround is this:```pythonfrom django_scopes import scopes_disabledwith scopes_disabled():    class CommentFilter(FilterSet):        …```### UniquenessOne subtle class of bug that can be introduced by adding django-scopes to your project is if you try to generate unique identifiers in your database with a pattern like this:```pythondef generate_unique_value():    while True:        key = _generate_random_key()        if not Model.objects.filter(key=key).exists():            return key```If you want keys to be unique across tenants, make sure to wrap such functions with ``scopes_disabled()``!When using a [ModelForm](https://docs.djangoproject.com/en/dev/topics/forms/modelforms/) (or [class based view](https://docs.djangoproject.com/en/dev/topics/class-based-views/)) to create or update a model, unexpected IntegrityErrors may occur. ModelForms perform a uniqueness check before actually saving the model. If that check runs in a scoped context, it cannot find conflicting instances, leading to an IntegrityErrors once the actual `.save()` happens. To combat this, wrap the call in ``scopes_disabled()``.```pythonclass Site(models.Model):    name = models.CharField(unique=True, …)    # (...)    def validate_unique(self, *args, **kwargs):        with scopes_disabled():            super().validate_unique(*args, **kwargs)```## Further readingIf you'd like to read more about the practical use of django-scopes, there is a [blogpost](https://behind.pretix.eu/2019/06/17/scopes/) about its introduction in the [pretix](https://pretix.eu) project.[Here](https://rixx.de/blog/using-the-django-shell-with-django-scopes/) is a guide on how to write a ``shell_scoped``django-admin command to provide a scoped Django shell.</longdescription>
</pkgmetadata>