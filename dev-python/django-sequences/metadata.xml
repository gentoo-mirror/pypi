<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>django-sequences################By default, Django gives each model an auto-incrementing integer primary key.These primary keys look like they generate a continuous sequence of integers.However, this behavior isn't guaranteed.If a transaction inserts a row and then is rolled back, the sequence counterisn't rolled back for performance reasons, creating a gap in primary keys.Such gaps may happen on all databases natively supported by Django:* `PostgreSQL &lt;https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL&gt;`_* `MariaDB &lt;https://mariadb.com/kb/en/auto_increment/#missing-values&gt;`_ / MySQL* `Oracle &lt;https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/CREATE-SEQUENCE.html&gt;`_* `SQLite &lt;https://sqlite.org/autoinc.html#the_autoincrement_keyword&gt;`_They may also happen on most databases supported via third-party backends.This can cause compliance issues for some use cases such as accounting.This risk isn't well known. Since most transactions succeed, values looksequential. Gaps will only be revealed by audits.django-sequences solves this problem with a ``get_next_value`` functiondesigned to be used as follows:.. code:: python    from django.db import transaction    from sequences import get_next_value    from invoices.models import Invoice    with transaction.atomic():        Invoice.objects.create(number=get_next_value(&quot;invoice_numbers&quot;))Or, if you'd rather use an object-oriented API:.. code:: python    from django.db import transaction    from sequences import Sequence    from invoices.models import Invoice    invoice_numbers = Sequence(&quot;invoice_numbers&quot;)    with transaction.atomic():        Invoice.objects.create(number=next(invoice_numbers))``get_next_value`` relies on the database's transactional integrity to ensurethat each value is returned exactly once. As a consequence, **the guaranteesof django-sequences apply only if you call** ``get_next_value`` **and save itsreturn value to the database within the same transaction!**Table of contents=================* `Getting started`_* `API`_* `Database support`_* `Multiple databases`_* `Isolation levels`_* `Contributing`_* `Releasing`_* `Changelog`_Getting started===============django-sequences is tested with Django 3.2 (LTS), 4.0, 4.1, and 4.2.It is also tested with all database backends built-in to Django: MySQL/MariaDB,Oracle, PostgreSQL and SQLite.It is released under the BSD license, like Django itself.Install django-sequences:.. code:: shell-session    $ pip install django-sequencesAdd it to the list of applications in your project's settings:.. code:: python    INSTALLED_APPS = [        ...,        &quot;sequences.apps.SequencesConfig&quot;,        ...    ]Run migrations:.. code:: shell-session    $ django-admin migrateAPI===``get_next_value``------------------.. code:: pycon    &gt;&gt;&gt; from sequences import get_next_valueThis function generates a gapless sequence of integer values:.. code:: pycon    &gt;&gt;&gt; get_next_value()    1    &gt;&gt;&gt; get_next_value()    2    &gt;&gt;&gt; get_next_value()    3It supports multiple independent sequences:.. code:: pycon    &gt;&gt;&gt; get_next_value(&quot;cases&quot;)    1    &gt;&gt;&gt; get_next_value(&quot;cases&quot;)    2    &gt;&gt;&gt; get_next_value(&quot;invoices&quot;)    1    &gt;&gt;&gt; get_next_value(&quot;invoices&quot;)    2The first value defaults to 1. It can be customized:.. code:: pycon    &gt;&gt;&gt; get_next_value(&quot;customers&quot;, initial_value=1000)  # pro growth hackingThe ``initial_value`` parameter only matters when ``get_next_value`` is calledfor the first time for a given sequence â€” assuming the corresponding databasetransaction gets committed; as discussed above, if the transaction is rolledback, the generated value isn't consumed. It's also possible to initialize asequence in a data migration and not use ``initial_value`` in actual code.Sequences can loop:.. code:: pycon    &gt;&gt;&gt; get_next_value(&quot;seconds&quot;, initial_value=0, reset_value=60)When the sequence reaches ``reset_value``, it restarts at ``initial_value``.In other words, it generates ``reset_value - 2``, ``reset_value - 1``,``initial_value``, ``initial_value + 1``, etc. In that case, each call to``get_next_value`` must provide ``initial_value`` when it isn't the defaultand ``reset_value``.**Database transactions that call** ``get_next_value`` **for a given sequenceare serialized.** As a consequence, when you call ``get_next_value`` in adatabase transaction, other callers trying to get a value from the samesequence block until the transaction completes, either with a commit or arollback. You should keep such transactions short to minimize the impact onperformance.This is why databases default to a faster behavior that may create gaps.Passing ``nowait=True`` makes ``get_next_value`` raise an exception instead ofblocking in this scenario. This is rarely useful. Also it doesn't work for thefirst call. (This is a bug but it's harmless and hard to fix.)Calls to ``get_next_value`` for distinct sequences don't interact with oneanother.Finally, passing ``using=&quot;...&quot;`` allows selecting the database on which thecurrent sequence value is stored. When this parameter isn't provided, itdefaults to the default database for writing models of the ``sequences``application. See `Multiple databases`_ for details.To sum up, the complete signature of ``get_next_value`` is:.. code:: python    get_next_value(        sequence_name=&quot;default&quot;,        initial_value=1,        reset_value=None,        *,        nowait=False,        using=None,    )``get_last_value``------------------.. code:: pycon    &gt;&gt;&gt; from sequences import get_last_valueThis function returns the last value generated by a sequence:.. code:: pycon    &gt;&gt;&gt; get_last_value()    None    &gt;&gt;&gt; get_next_value()    1    &gt;&gt;&gt; get_last_value()    1    &gt;&gt;&gt; get_next_value()    2    &gt;&gt;&gt; get_last_value()    2If the sequence hasn't generated a value yet, ``get_last_value`` returns``None``.It supports independent sequences like ``get_next_value``:.. code:: pycon    &gt;&gt;&gt; get_next_value(&quot;cases&quot;)    1    &gt;&gt;&gt; get_last_value(&quot;cases&quot;)    1    &gt;&gt;&gt; get_next_value(&quot;invoices&quot;)    1    &gt;&gt;&gt; get_last_value(&quot;invoices&quot;)    1It accepts ``using=&quot;...&quot;`` for selecting the database on which the currentsequence value is stored, defaulting to the default database for readingmodels of the ``sequences`` application.The complete signature of ``get_last_value`` is:.. code:: python    get_last_value(        sequence_name=&quot;default&quot;,        *,        using=None,    )``get_last_value`` **is a convenient and fast way to tell how many values asequence generated but it makes no guarantees.** Concurrent calls to``get_next_value`` may produce unexpected results of ``get_last_value``.``Sequence``------------.. code:: pycon    &gt;&gt;&gt; from sequences import Sequence(not to be confused with ``sequences.models.Sequence``, a private API)This class stores parameters for a sequence and provides ``get_next_value``and ``get_last_value`` methods:.. code:: pycon    &gt;&gt;&gt; claim_ids = Sequence(&quot;claims&quot;)    &gt;&gt;&gt; claim_ids.get_next_value()    1    &gt;&gt;&gt; claim_ids.get_next_value()    2    &gt;&gt;&gt; claim_ids.get_last_value()    2This reduces the risk of errors when the same sequence is used in multipleplaces.Instances of ``Sequence`` are also infinite iterators:.. code:: pycon    &gt;&gt;&gt; next(claim_ids)    3    &gt;&gt;&gt; next(claim_ids)    4The complete API is:.. code:: python    Sequence(        sequence_name=&quot;default&quot;,        initial_value=1,        reset_value=None,        *,        using=None,    )    Sequence.get_next_value(        self,        *,        nowait=False,    )    Sequence.get_last_value(        self,    )All parameters have the same meaning as in the ``get_next_value`` and``get_last_value`` functions.Examples========Per-date sequences------------------If you want independent sequences per day, month, or year, use the appropriatedate fragment in the sequence name. For example:.. code:: python    from django.utils import timezone    from sequences import get_next_value    # Per-day sequence    get_next_value(f&quot;books-{timezone.now().date().isoformat()}&quot;)    # Per-year sequence    get_next_value(f&quot;prototocol-{timezone.now().year}&quot;)The above calls will result in separate sequences like ``books-2023-03-15``or ``protocol-2022``, respectively.Database support================django-sequences is tested on PostgreSQL, MariaDB / MySQL, Oracle, and SQLite.MySQL only supports the ``nowait`` parameter from version 8.0.1.MariaDB only supports ``nowait`` from version 10.3.Multiple databases==================Since django-sequences relies on the database to guarantee transactionalintegrity, the current value for a given sequence must be stored in the samedatabase as models containing generated values.In a project that uses multiple databases, you must write a suitable databaserouter to create tables for the ``sequences`` application on all databasesstoring models containing sequential numbers.Each database has its own namespace: a sequence with the same name stored intwo databases will have independent counters in each database.Isolation levels================Since django-sequences relies on the database's transactional integrity, usinga non-default transaction isolation level requires special care.* **read uncommitted:** django-sequences cannot work at this isolation level.  Indeed, concurrent transactions can create gaps, as in this scenario:  * Transaction A reads N and writes N + 1;  * Transaction B reads N + 1 (dirty read) and writes N + 2;  * Transaction A is rolled back;  * Transaction B is committed;  * N + 1 is a gap.  The read uncommitted isolation level doesn't provide sufficient guarantees.  It will never be supported.* **read committed:** django-sequences works best at this isolation level,  like Django itself.* **repeatable read:** django-sequences also works at this isolation level,  provided your code handles serialization failures and retries transactions.  This requirement isn't specific to django-sequences. It's generally needed  when running at the repeatable read isolation level.  Here's a scenario where only one of two concurrent transactions can  complete on PostgreSQL:  * Transaction A reads N and writes N + 1;  * Transaction B attemps to read; it must wait until transaction A completes;  * Transaction A is committed;  * Transaction B is aborted.  On PostgreSQL, serialization failures are reported as: ``OperationalError:  could not serialize access due to concurrent update``.  On MySQL, they result in: ``OperationalError: (1213, 'Deadlock found when  trying to get lock; try restarting transaction')``.  Concurrent transactions initializing the same sequence are also vulnerable,  although that's hardly ever a problem in practice.  On PostgreSQL, this manifests as ``IntegrityError: duplicate key value  violates unique constraint &quot;sequences_sequence_pkey&quot;``.* **serializable:** the situation is identical to the repeatable read level.  SQLite always runs at the serializable isolation level. Serialization  failures result in: ``OperationalError: database is locked``.Contributing============Prepare a development environment:* Install Poetry_.* Run ``poetry install``.* Run ``poetry shell`` to load the development environment.Prepare testing databases:* Install PostgreSQL, MariaDB, and Oracle.* Create a database called ``sequences``, owned by a user called ``sequences``  with password ``sequences``, with permissions to create a ``test_sequences``  test database. You may override these values with environment variables; see  ``tests/*_settings.py`` for details.Make changes:* Make changes to the code, tests, or docs.* Run ``make style`` and fix any flake8 violations.* Run ``make test`` to run the set suite on all databases.Iterate until you're happy.Check quality and submit your changes:* Install tox_.* Run ``tox`` to test on all Python and Django versions and all databases.* Submit a pull request... _Poetry: https://python-poetry.org/.. _tox: https://tox.readthedocs.io/Releasing=========Increment version number X.Y in ``pyproject.toml``.Commit, tag, and push the change:.. code:: shell-session    $ git commit -m &quot;Bump version number&quot;.    $ git tag X.Y    $ git push    $ git push --tagsBuild and publish the new version:.. code:: shell-session    $ poetry build    $ poetry publishChangelog=========2.8---* No significant changes.2.7---* Sequence values can go up to ``2 ** 63 - 1`` instead of ``2 ** 31 - 1``  previously. The exact limit depends on the database backend.  Migration ``0002_alter_sequence_last.py`` changes the field storing sequence  values from ``PositiveIntegerField`` to ``PositiveBigIntegerField``. Running  it requires an exclusive lock on the table, which prevents other operations,  including reads.  If you have many distinct sequences, e.g. if you create one sequence per user  and you have millions of users, review how the migration will affect your app  before running it or skip it with ``migrate --fake``.2.6---* Improve documentation.2.5---* Fix Japanese and Turkish translations.* Restore compatibility with Python 3.5.* Support relabeling the ``sequences`` app with a custom ``AppConfig``.2.4---* Add the ``get_last_value`` function.* Add the ``Sequence`` class.2.3---* Optimize performance on MySQL.* Test on MySQL, SQLite and Oracle.2.2---* Optimize performance on PostgreSQL â‰¥ 9.5.2.1---* Provide looping sequences with ``reset_value``.2.0---* Add support for multiple databases.* Add translations.* ``nowait`` becomes keyword-only argument.* Drop support for Python 2.1.0---* Initial stable release.</longdescription>
</pkgmetadata>