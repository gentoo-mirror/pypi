<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># locks[![PyPI version](https://img.shields.io/pypi/v/locks.svg?style=flat-square)](https://pypi.org/project/locks/)[![Build status](https://img.shields.io/travis/rossmacarthur/locks/master.svg?style=flat-square)](https://travis-ci.org/rossmacarthur/locks)POSIX file system locking using [flock](https://linux.die.net/man/2/flock).## Getting startedInstall this package with```shpip install locks```## UsageThe simplest usage is to block indefinitely until the lock is acquired```pythonfrom locks import Mutexwith Mutex('/tmp/file.lock'):    # do exclusive stuff here```Alternatively, block until a timeout is reached```pythonfrom locks import Mutextry:    with Mutex('/tmp/file.lock', timeout=0.5):        # do exclusive stuff hereexcept BlockingIOError:    # handle the failure to acquire the lock```Finally, a common paradigm is to attempt to acquire the lock without blocking,do something, and then block indefinitely. Here `callback` will be called onceif we cannot immediately acquire the lock, and then we will block indefinitely.```pythondef callback():    print(&quot;Blocking: waiting for file lock on '/tmp/file.lock'&quot;)with Mutex('/tmp/file.lock', callback=callback):    # do exclusive stuff here```If both `callback` and `timeout` are used then we will attempt toacquire the lock until the `timeout` is reached, and then we will blockindefinitely.## LicenseThis project is licensed under the MIT License. See the [LICENSE] file.[LICENSE]: LICENSE</longdescription>
</pkgmetadata>