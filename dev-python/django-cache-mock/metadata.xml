<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># django-cache-mockUse in-process mocks to avoid setting up external caches for Django duringdevelopment.Django has a limited built-in `django.core.cache.backends.locmem.LocMemCache`,to help development, but Django do some magic to always give you a workingconnection.I have some reasons to abuse Django cache this way:* Thread safety: Django spin one connection per thread to avoid issues withthread unsafe drivers.* Good defaults: Django run connections with good defaults.* Connection reuse: Django already have a pool running and in most cases it isbetter to use it.## Install```shell$ pip install django-cache-mock```Also, it is possible to install with the backends you want.For `mockcache`, it installs [`mockcache3`](https://pypi.org/project/mockcache3/),a fork from original package because it doesnÂ´t work for new versions of Python.```shell$ pip install django-cache-mock[mockcache]$ pip install django-cache-mock[fakeredis]$ pip install django-cache-mock[redislite]```## How to useIn your Django settings you already have `CACHES` defined.For `memcached`, it's something like that:```pythonCACHES = {    &quot;default&quot;: {        &quot;BACKEND&quot;: &quot;django.core.cache.backends.memcached.PyMemcacheCache&quot;,        &quot;LOCATION&quot;: os.getenv(&quot;MEMCACHED_HOSTS&quot;),        &quot;OPTIONS&quot;: {            &quot;no_delay&quot;: True,            &quot;ignore_exc&quot;: True,            &quot;max_pool_size&quot;: 4,            &quot;use_pooling&quot;: True,        },    },}```Just make a call to `django_cache_mock.patch` to replace with a mock backend.**The lib will patch only when cache LOCATION is not defined.**```pythonimport django_cache_mockif DEBUG:  # Apply it only in debug mode to be extra careful.    django_cache_mock.patch(CACHES, &quot;default&quot;, &quot;mockcache&quot;)```This patch replace cache with a mocked one. For mockcache,## Custom cache optionsThe `patch` function accepts custom params. It can be used to override mockbehaviours, like the db file `redislite` will use, defined by `LOCATION`:```pythondjango_cache_mock.patch(CACHES, &quot;default&quot;, &quot;redislite&quot;, {&quot;LOCATION&quot;: &quot;data/redis.db&quot;})```## Redis backendsRedis has several options to run. This lib implements `fakeredis` and `redislite`,with `django.core.cache` or `django-redis`.By default, the lib try to maintain the same behavior of the original implementation.If config uses `django-redis`, when you set use backend `fakeredis`, it will useit as `fakeredis[django-redis]`.```python# Force to use django-redis. It is not necessary, the lib already try to use# django-redis if cache uses `django_redis.cache.cache.RedisCache`.django_cache_mock.patch(CACHES, &quot;redis&quot;, &quot;fakeredis[django-redis]&quot;)django_cache_mock.patch(CACHES, &quot;redis&quot;, &quot;redislite[django-redis]&quot;)```## How to access connectionsTo get Django memcached and redis clients from cache:```pythonfrom django.core.cache import cachesdef give_me_memcached():    return caches[&quot;memcached&quot;]._cache# for django.core.cache.backends.redisdef give_me_primary_redis():    return caches[&quot;redis&quot;]._cache.get_client(write=True)def give_me_secondary_redis():    return caches[&quot;redis&quot;]._cache.get_client()# for django-redisdef give_me_primary_redis():    return caches[&quot;redis&quot;].client.get_client()def give_me_secondary_redis():    return caches[&quot;redis&quot;].client.get_client(write=False)# Yes, django and django-redis have different write flag defaults.```</longdescription>
</pkgmetadata>