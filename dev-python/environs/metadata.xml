<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># environs: simplified environment variable parsing[![Latest version](https://badgen.net/pypi/v/environs)](https://pypi.org/project/environs/)[![Build Status](https://dev.azure.com/sloria/sloria/_apis/build/status/sloria.environs?branchName=master)](https://dev.azure.com/sloria/sloria/_build/latest?definitionId=12&amp;branchName=master)[![marshmallow 3 compatible](https://badgen.net/badge/marshmallow/3)](https://marshmallow.readthedocs.io/en/latest/upgrading.html)[![Black code style](https://badgen.net/badge/code%20style/black/000)](https://github.com/ambv/black)**environs** is a Python library for parsing environment variables.It allows you to store configuration separate from your code, as per[The Twelve-Factor App](https://12factor.net/config) methodology.## Contents- [Features](#features)- [Install](#install)- [Basic usage](#basic-usage)- [Supported types](#supported-types)- [Reading .env files](#reading-env-files)  - [Reading a specific file](#reading-a-specific-file)- [Handling prefixes](#handling-prefixes)- [Variable expansion](#variable-expansion)- [Validation](#validation)- [Deferred validation](#deferred-validation)- [Serialization](#serialization)- [Defining custom parser behavior](#defining-custom-parser-behavior)- [Usage with Flask](#usage-with-flask)- [Usage with Django](#usage-with-django)- [Why...?](#why)  - [Why envvars?](#why-envvars)  - [Why not os.environ?](#why-not-osenviron)  - [Why another library?](#why-another-library)- [License](#license)## Features- Type-casting- Read `.env` files into `os.environ` (useful for local development)- Validation- Define custom parser behavior- Framework-agnostic, but integrates well with [Flask](#usage-with-flask) and [Django](#usage-with-django)## Install    pip install environs## Basic usageWith some environment variables set...```bashexport GITHUB_USER=sloriaexport MAX_CONNECTIONS=100export SHIP_DATE='1984-06-25'export TTL=42export ENABLE_LOGIN=trueexport GITHUB_REPOS=webargs,konch,pedexport GITHUB_REPO_PRIORITY=&quot;webargs=2,konch=3&quot;export COORDINATES=23.3,50.0export LOG_LEVEL=DEBUG```Parse them with environs...```pythonfrom environs import Envenv = Env()env.read_env()  # read .env file, if it exists# required variablesgh_user = env(&quot;GITHUB_USER&quot;)  # =&gt; 'sloria'secret = env(&quot;SECRET&quot;)  # =&gt; raises error if not set# castingmax_connections = env.int(&quot;MAX_CONNECTIONS&quot;)  # =&gt; 100ship_date = env.date(&quot;SHIP_DATE&quot;)  # =&gt; datetime.date(1984, 6, 25)ttl = env.timedelta(&quot;TTL&quot;)  # =&gt; datetime.timedelta(0, 42)log_level = env.log_level(&quot;LOG_LEVEL&quot;)  # =&gt; logging.DEBUG# providing a default valueenable_login = env.bool(&quot;ENABLE_LOGIN&quot;, False)  # =&gt; Trueenable_feature_x = env.bool(&quot;ENABLE_FEATURE_X&quot;, False)  # =&gt; False# parsing listsgh_repos = env.list(&quot;GITHUB_REPOS&quot;)  # =&gt; ['webargs', 'konch', 'ped']coords = env.list(&quot;COORDINATES&quot;, subcast=float)  # =&gt; [23.3, 50.0]# parsing dictsgh_repos_priorities = env.dict(    &quot;GITHUB_REPO_PRIORITY&quot;, subcast_values=int)  # =&gt; {'webargs': 2, 'konch': 3}```## Supported typesThe following are all type-casting methods of `Env`:- `env.str`- `env.bool`- `env.int`- `env.float`- `env.decimal`- `env.list` (accepts optional `subcast` and `delimiter` keyword arguments)- `env.dict` (accepts optional `subcast_keys` and `subcast_values` keyword arguments)- `env.json`- `env.datetime`- `env.date`- `env.time`- `env.timedelta` (assumes value is an integer in seconds)- `env.url`- `env.uuid`- `env.log_level`- `env.path` (casts to a [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html))- `env.enum` (casts to any given enum type specified in `type` keyword argument, accepts optional `ignore_case` keyword argument)## Reading `.env` files```bash# .envDEBUG=truePORT=4567```Call `Env.read_env` before parsing variables.```pythonfrom environs import Envenv = Env()# Read .env into os.environenv.read_env()env.bool(&quot;DEBUG&quot;)  # =&gt; Trueenv.int(&quot;PORT&quot;)  # =&gt; 4567```### Reading a specific fileBy default, `Env.read_env` will look for a `.env` file in currentdirectory and (if no .env exists in the CWD) recurseupwards until a `.env` file is found.You can also read a specific file:```pythonfrom environs import Envwith open(&quot;.env.test&quot;, &quot;w&quot;) as fobj:    fobj.write(&quot;A=foo\n&quot;)    fobj.write(&quot;B=123\n&quot;)env = Env()env.read_env(&quot;.env.test&quot;, recurse=False)assert env(&quot;A&quot;) == &quot;foo&quot;assert env.int(&quot;B&quot;) == 123```## Handling prefixes```python# export MYAPP_HOST=lolcathost# export MYAPP_PORT=3000with env.prefixed(&quot;MYAPP_&quot;):    host = env(&quot;HOST&quot;, &quot;localhost&quot;)  # =&gt; 'lolcathost'    port = env.int(&quot;PORT&quot;, 5000)  # =&gt; 3000# nested prefixes are also supported:# export MYAPP_DB_HOST=lolcathost# export MYAPP_DB_PORT=10101with env.prefixed(&quot;MYAPP_&quot;):    with env.prefixed(&quot;DB_&quot;):        db_host = env(&quot;HOST&quot;, &quot;lolcathost&quot;)        db_port = env.int(&quot;PORT&quot;, 10101)```## Variable expansion```python# export CONNECTION_URL=https://${USER:-sloria}:${PASSWORD}@${HOST:-localhost}/# export PASSWORD=secret# export YEAR=${CURRENT_YEAR:-2020}from environs import Envenv = Env(expand_vars=True)connection_url = env(&quot;CONNECTION_URL&quot;)  # =&gt;'https://sloria:secret@localhost'year = env.int(&quot;YEAR&quot;)  # =&gt;2020```## Validation```python# export TTL=-2# export NODE_ENV='invalid'# export EMAIL='^_^'from environs import Envfrom marshmallow.validate import OneOf, Length, Emailenv = Env()# simple validatorenv.int(&quot;TTL&quot;, validate=lambda n: n &gt; 0)# =&gt; Environment variable &quot;TTL&quot; invalid: ['Invalid value.']# using marshmallow validatorsenv.str(    &quot;NODE_ENV&quot;,    validate=OneOf(        [&quot;production&quot;, &quot;development&quot;], error=&quot;NODE_ENV must be one of: {choices}&quot;    ),)# =&gt; Environment variable &quot;NODE_ENV&quot; invalid: ['NODE_ENV must be one of: production, development']# multiple validatorsenv.str(&quot;EMAIL&quot;, validate=[Length(min=4), Email()])# =&gt; Environment variable &quot;EMAIL&quot; invalid: ['Shorter than minimum length 4.', 'Not a valid email address.']```## Deferred validationBy default, a validation error is raised immediately upon calling a parser method for an invalid environment variable.To defer validation and raise an exception with the combined error messages for all invalid variables, pass `eager=False` to `Env`.Call `env.seal()` after all variables have been parsed.```python# export TTL=-2# export NODE_ENV='invalid'# export EMAIL='^_^'from environs import Envfrom marshmallow.validate import OneOf, Email, Length, Rangeenv = Env(eager=False)TTL = env.int(&quot;TTL&quot;, validate=Range(min=0, max=100))NODE_ENV = env.str(    &quot;NODE_ENV&quot;,    validate=OneOf(        [&quot;production&quot;, &quot;development&quot;], error=&quot;NODE_ENV must be one of: {choices}&quot;    ),)EMAIL = env.str(&quot;EMAIL&quot;, validate=[Length(min=4), Email()])env.seal()# environs.EnvValidationError: Environment variables invalid: {'TTL': ['Must be greater than or equal to 0 and less than or equal to 100.'], 'NODE_ENV': ['NODE_ENV must be one of: production, development'], 'EMAIL': ['Shorter than minimum length 4.', 'Not a valid email address.']}````env.seal()` validates all parsed variables and prevents further parsing (calling a parser method will raise an error).## Serialization```python# serialize to a dictionary of simple types (numbers and strings)env.dump()# {'COORDINATES': [23.3, 50.0],# 'ENABLE_FEATURE_X': False,# 'ENABLE_LOGIN': True,# 'GITHUB_REPOS': ['webargs', 'konch', 'ped'],# 'GITHUB_USER': 'sloria',# 'MAX_CONNECTIONS': 100,# 'MYAPP_HOST': 'lolcathost',# 'MYAPP_PORT': 3000,# 'SHIP_DATE': '1984-06-25',# 'TTL': 42}```## Defining custom parser behavior```python# export DOMAIN='http://myapp.com'# export COLOR=invalidfrom furl import furl# Register a new parser method for paths@env.parser_for(&quot;furl&quot;)def furl_parser(value):    return furl(value)domain = env.furl(&quot;DOMAIN&quot;)  # =&gt; furl('https://myapp.com')# Custom parsers can take extra keyword arguments@env.parser_for(&quot;choice&quot;)def choice_parser(value, choices):    if value not in choices:        raise environs.EnvError(&quot;Invalid!&quot;)    return valuecolor = env.choice(&quot;COLOR&quot;, choices=[&quot;black&quot;])  # =&gt; raises EnvError```## Usage with Flask```python# myapp/settings.pyfrom environs import Envenv = Env()env.read_env()# Override in .env for local developmentDEBUG = env.bool(&quot;FLASK_DEBUG&quot;, default=False)# SECRET_KEY is requiredSECRET_KEY = env.str(&quot;SECRET_KEY&quot;)```Load the configuration after you initialize your app.```python# myapp/app.pyfrom flask import Flaskapp = Flask(__name__)app.config.from_object(&quot;myapp.settings&quot;)```For local development, use a `.env` file to override the defaultconfiguration.```bash# .envDEBUG=trueSECRET_KEY=&quot;not so secret&quot;```Note: Because environs depends on [python-dotenv](https://github.com/theskumar/python-dotenv),the `flask` CLI will automatically read .env and .flaskenv files.## Usage with Djangoenvirons includes a number of helpers for parsing connection URLs. Toinstall environs with django support:    pip install environs[django]Use `env.dj_db_url`, `env.dj_cache_url` and `env.dj_email_url` to parse the `DATABASE_URL`, `CACHE_URL`and `EMAIL_URL` environment variables, respectively.For more details on URL patterns, see the following projects that environs is using for converting URLs.- [dj-database-url](https://github.com/jacobian/dj-database-url)- [django-cache-url](https://github.com/epicserve/django-cache-url)- [dj-email-url](https://github.com/migonzalvar/dj-email-url)Basic example:```python# myproject/settings.pyfrom environs import Envenv = Env()env.read_env()# Override in .env for local developmentDEBUG = env.bool(&quot;DEBUG&quot;, default=False)# SECRET_KEY is requiredSECRET_KEY = env.str(&quot;SECRET_KEY&quot;)# Parse database URLs, e.g.  &quot;postgres://localhost:5432/mydb&quot;DATABASES = {&quot;default&quot;: env.dj_db_url(&quot;DATABASE_URL&quot;)}# Parse email URLs, e.g. &quot;smtp://&quot;email = env.dj_email_url(&quot;EMAIL_URL&quot;, default=&quot;smtp://&quot;)EMAIL_HOST = email[&quot;EMAIL_HOST&quot;]EMAIL_PORT = email[&quot;EMAIL_PORT&quot;]EMAIL_HOST_PASSWORD = email[&quot;EMAIL_HOST_PASSWORD&quot;]EMAIL_HOST_USER = email[&quot;EMAIL_HOST_USER&quot;]EMAIL_USE_TLS = email[&quot;EMAIL_USE_TLS&quot;]# Parse cache URLS, e.g &quot;redis://localhost:6379/0&quot;CACHES = {&quot;default&quot;: env.dj_cache_url(&quot;CACHE_URL&quot;)}```For local development, use a `.env` file to override the defaultconfiguration.```bash# .envDEBUG=trueSECRET_KEY=&quot;not so secret&quot;```For a more complete example, see[django_example.py](https://github.com/sloria/environs/blob/master/examples/django_example.py)in the `examples/` directory.## Why\...?### Why envvars?See [The 12-factor App](http://12factor.net/config) section on[configuration](http://12factor.net/config).### Why not `os.environ`?While `os.environ` is enough for simple use cases, a typical applicationwill need a way to manipulate and validate raw environment variables.environs abstracts common tasks for handling environment variables.environs will help you- cast envvars to the correct type- specify required envvars- define default values- validate envvars- parse list and dict values- parse dates, datetimes, and timedeltas- parse expanded variables- serialize your configuration to JSON, YAML, etc.### Why another library?There are many great Python libraries for parsing environment variables.In fact, most of the credit for environs\' public API goes to theauthors of [envparse](https://github.com/rconradharris/envparse) and[django-environ](https://github.com/joke2k/django-environ).environs aims to meet three additional goals:1.  Make it easy to extend parsing behavior and develop plugins.2.  Leverage the deserialization and validation functionality provided    by a separate library (marshmallow).3.  Clean up redundant API.See [this GitHubissue](https://github.com/rconradharris/envparse/issues/12#issue-151036722)which details specific differences with envparse.## LicenseMIT licensed. See the[LICENSE](https://github.com/sloria/environs/blob/master/LICENSE) filefor more details.</longdescription>
</pkgmetadata>