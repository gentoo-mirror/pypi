<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># aioscheduleraioscheduler is a scalable and high-performance task scheduler for asyncio.It schedules execution of coroutines at a specific time in a single task, making it lightweight and extremely scalable by adding a manager for multiple schedulers.Tests have shown that aioscheduler can run up to 10 million timed tasks with up to 20 finishing per second when using 20 schedulers. Single tasks can easily schedule up to 10.000 tasks. This is based on tests on a Xeon E5 1650v3.## Installation`pip install aioscheduler`## Usageaioscheduler provides several Scheduler classes that runs a main task to consume coroutines.There are `QueuedScheduler/LifoQueuedScheduler` and `TimedScheduler`, whereas TimedScheduler is the default for Managers.The TimedScheduler compares datetime objects to UTC by default, to disable it, pass `prefer_utc=False` to the constructor.```pyimport asynciofrom datetime import datetime, timedeltafrom aioscheduler import TimedSchedulerasync def work(n: int) -&gt; None:    print(f&quot;I am doing heavy work: {n}&quot;)async def main() -&gt; None:    starting_time = datetime.utcnow()    scheduler = TimedScheduler()    scheduler.start()    for i in range(60):        scheduler.schedule(work(i), starting_time + timedelta(seconds=5 + i))    await asyncio.sleep(65)asyncio.run(main())```In this example, 60 tasks are scheduled to run in 5 seconds from now, 1 of them per second over a time of 1 minute.The QueuedScheduler works identical, but consumes tasks in scheduling order immediately and only takes a single coroutine as argument to `schedule()`.To scale even further, aioscheduler offers the Manager (example with QueuedScheduler backend):```pyimport asynciofrom datetime import datetime, timedeltafrom aioscheduler import Manager, QueuedSchedulerasync def work(n: int) -&gt; None:    print(f&quot;I am doing heavy work: {n}&quot;)async def main() -&gt; None:    starting_time = datetime.utcnow()    manager = Manager(5, cls=QueuedScheduler)  # The number of Schedulers to use                                               # Leaving out cls defaults to TimedScheduler    manager.start()    for i in range(30000):        manager.schedule(work(i))    await asyncio.sleep(5)asyncio.run(main())```The manager distributes the tasks across multiple schedulers internally and acts as a load-balancer.`schedule()` returns a Task object, you may cancel a task after scheduling by running `scheduler.cancel(task)` (or `manager.cancel(task)`). The manager is less efficient for cancelling.To limit the amount of tasks scheduled, there is a `max_tasks` argument that takes a positive integer. It is advised to use this in production enviroments of known task queue sizes and available on both Scheduler and Manager.## LicenseMIT</longdescription>
</pkgmetadata>