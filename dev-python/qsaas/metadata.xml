<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Status[![Project Status: Active â€“ The project has reached a stable, usable state and is being actively developed.](https://www.repostatus.org/badges/latest/active.svg)](https://www.repostatus.org/#active)# qsaasA wrapper for the Qlik Sense Enterprise SaaS APIs.### Intended audienceDevelopers -- familiarity with the [Qlik Sense Enterprise APIs](https://qlik.dev/apis) is required.### High-level benefits:1. Automatic pagination on GETs, returning all results.2. Ability to asynchronously make POSTs, PUTs, and PATCHs, where one can input the amount of threads you'd like (default is 10), dramatically decreasing processing time.3. Ease of establishing and managing connections to multiple tenants.4. Ability to connect to any API endpoint.# Table of Contents1. [Installation](#installation)2. [Configuration](#configuration)3. [Basic Usage](#basic-usage)4. [Advanced Usage](#advanced-usage)5. [Complete list of functions](#complete-list-of-functions)6. [Additional Notes](#additional-notes)# Installation```pip install qsaas```#### Dependencies (auto-installed by pip):```requestsrequests_toolbeltaiohttpasyncio```# ConfigurationTo import qsaas, as qsaas only currently has one class, `Tenant`, the simplest way is:```pythonfrom qsaas.qsaas import Tenant```From there, one can instantiate a new `Tenant` object by executing```pythonq = Tenant(&lt;args&gt;)```### Option AIf connecting locally, the simplest way can be to use a json file for each tenant, as these files can be securely stored locally. The file must be a valid json file with the following structure:```json{    &quot;api_key&quot;: &quot;&lt;API_KEY&gt;&quot;,    &quot;tenant_fqdn&quot;: &quot;&lt;TENANT&gt;.&lt;REGION&gt;.qlikcloud.com&quot;,    &quot;tenant_id&quot;: &quot;&lt;TENANT_ID&gt;&quot;}```When creating a new `Tenant` object then, the named param `config` can be used as follows (in this case, the file name is &quot;config.json&quot;:```pythonq = Tenant(config=&quot;config.json&quot;)```### Option BIf it's preferred to feed in the api_key, tenant_fqdn, and tenant_id in a different manner, one can instead execute:```pythonq = Tenant(api_key=&lt;API_KEY&gt;, tenant=&lt;TENANT_FQDN&gt;, tenant_id=&lt;TENANT_ID&gt;)```# Basic Usage#### Get all users from a tenant and print their IDs```pythonusers = q.get('users')for user in users:    print(user['id'])```#### Get a specific user from a tenant```pythonuser = q.get('users', params={&quot;subject&quot;:&quot;QLIK-POC\dpi&quot;})```#### Get all apps from a tenant and print their names```pythonapps = q.get('items', params={&quot;resourceType&quot;:&quot;app&quot;})for app in apps:    print(app['name'])```#### Get all spaces from a tenant```pythonspaces = q.get('spaces')```#### Create a new user```pythonbody = {    &quot;tenantId&quot;: q.tenant_id,    &quot;subject&quot;: 'WORKSHOP\\Qlik1',    &quot;name&quot;: 'Qlik1',    &quot;email&quot;: 'Qlik1@workshop.com',    &quot;status&quot;: &quot;active&quot;}q.post('users', body)```#### Reload an application```pythonreload = q.post('reloads', json.dumps({&quot;appId&quot;: &quot;&lt;APP_ID&gt;&quot;}))```#### Reload an application and wait```pythonreload_id = q.post('reloads', json.dumps({&quot;appId&quot;: &quot;&lt;APP_ID&gt;&quot;}))['id']status = Nonewhile status not in ['SUCCEEDED', 'FAILED']:    time.sleep(1)    status = q.get('reloads/' + reload_id)['status']```#### Publish an application```pythonapp_id = &lt;APP_ID&gt;space_id = &lt;SPACE_ID&gt;app = q.post('apps/' + app_id + '/publish', json.dumps({&quot;spaceId&quot;: space_id}))payload = {    &quot;name&quot;: app['attributes']['name'],    &quot;resourceId&quot;: app['attributes']['id'],    &quot;description&quot;: app['attributes']['description'],    &quot;resourceType&quot;: &quot;app&quot;,    &quot;resourceAttributes&quot;: app['attributes'],    &quot;resourceCustomAttributes&quot;: {},    &quot;resourceCreatedAt&quot;: app['attributes']['createdDate'],    &quot;resourceCreatedBySubject&quot;: app['attributes']['owner'],    &quot;spaceId&quot;: space_id}q.post('items', json.dumps(payload))```#### Change the owner of an application```pythonapp_id = &lt;APP_ID&gt;user_id = &lt;USER_ID&gt;q.put('apps/' + app_id + '/owner', json.dumps({&quot;ownerId&quot;: user_id}))```#### Import an application```pythonwith open('&lt;APP-NAME&gt;.qvf', 'rb') as f:    data = f.read()app = q.post('apps/import', data,             params={&quot;name&quot;: &quot;&lt;APP-NAME-NEW&gt;&quot;})payload = {    &quot;name&quot;: app['attributes']['name'],    &quot;resourceId&quot;: app['attributes']['id'],    &quot;description&quot;: app['attributes']['description'],    &quot;resourceType&quot;: &quot;app&quot;,    &quot;resourceAttributes&quot;: app['attributes'],    &quot;resourceCustomAttributes&quot;: {},    &quot;resourceCreatedAt&quot;: app['attributes']['createdDate'],    &quot;resourceCreatedBySubject&quot;: app['attributes']['owner']}q.post('items', json.dumps(payload))```# Advanced Usage#### Upload a file to DataFiles```pythonfile_path = directory_path + '\\' + file_namebody = open(file_path, 'rb')q.post('qix-datafiles', body,        params={&quot;connectionId&quot;: conn_id, &quot;name&quot;: file_name})```#### Asynchronously reload multiple applications_Note:_ The default threading is 10 at a time--to modify this, add the named param `chunks=x`, where x is an integer. Do not make this integer too high to avoid rate limiting.```pythonapp_ids = ['&lt;APP_ID1&gt;','&lt;APP_ID2&gt;','&lt;APP_ID3&gt;']payloads = [json.dumps({&quot;appId&quot;: app_id}) for app_id in app_ids]q.async_post('reloads', payloads=payloads)```#### Asynchronously delete apps that have the name &quot;delete_me&quot;_Note:_ This process currently requires deleting both from the `apps` and `items` endpoints. The default threading is 10 at a time--to modify this, add the named param `chunks=x`, where x is an integer. Do not make this integer too high to avoid rate limiting.```pythonitems = q.get('items', params={&quot;resourceType&quot;: &quot;app&quot;, &quot;name&quot;: &quot;delete_me&quot;})delete_dict = {}delete_dict['items'] = [item['id'] for item in items]delete_dict['apps'] = [item['resourceId'] for item in items]for e in delete_dict:    q.async_delete(e, ids=delete_dict[e])```#### Asychronously add users_Note:_ The default threading is 10 at a time--to modify this, add the named param `chunks=x`, where x is an integer. Do not make this integer too high to avoid rate limiting.```pythonpayloads = []for i in range(10):    user_subject = 'WORKSHOP\\Qlik' + str(i+1)    user_name = 'Qlik' + str(i+1)    user_email = 'Qlik' + str(i+1) + '@workshop.com'    body = {        &quot;tenantId&quot;: q.tenant_id,        &quot;subject&quot;: user_subject,        &quot;name&quot;: user_name,        &quot;email&quot;: user_email,        &quot;status&quot;: &quot;active&quot;    }    payloads.append(body)q.async_post('users', payloads=payloads)```#### Asynchronously copy applications and assign them to new owners_Note:_ This is the only &quot;custom&quot; style function in all of qsaas, due to the fact that it has hardcoded endpoints and has an multi-step process--as it can copy applications and then assign those applications ot new owners in one go. The default threading is 10 at a time--to modify this, add the named param `chunks=x`, where x is an integer. Do not make this integer too high to avoid rate limiting.**Copy app and assign ownership to new users**```pythonq.async_app_copy('&lt;GUID&gt;',users=['&lt;UserId-1&gt;','&lt;UserId-2&gt;'])```**Simply copy an app 10 times, without assigning new ownership**```pythonq.async_app_copy('&lt;GUID&gt;',copies=10)```#### Customize Headers_Note:_ This is available for all functions, but should largely not be needed (most headers are automatically generated by the Python libraries used). If the need arises to pass in custom headers, or to overwrite the existing headers, one can leverage the keyword param `headers` as per below.**Upload an image to an application**```pythondata = open('your_image.png', 'rb').read()q.put('apps/&lt;GUID&gt;/media/files/your_image.png',      data, headers={&quot;Content-Type&quot;: &quot;image/png&quot;})```# Complete list of functions- `q.get()`- `q.post()`- `q.put()`- `q.patch()`- `q.delete()`- `q.async_post()`- `q.async_put()`- `q.async_patch()`- `q.async_app_copy()` *only custom functionFor each function, one can always refer to the docstring for a helpful description, and most provide examples. For instance, `help(q.get)` will output:```    Description    --------------------    GETs and paginates all results. Takes optional params.    Mandatory parameters    --------------------    endpoint (str), exclude api/{version}    Optional parameters    --------------------    params (dict)    Example Usage    --------------------    Example 1:        get('users')        This will return all users.    Example 2:        get('items', params={&quot;resourceType&quot;:&quot;app&quot;})        This will return all apps from items.```# Additional Notes#### API DocumentationIt is highly encouraged to review the API documentation at [the qlik.dev portal](https://qlik.dev/apis). As this wrapper does not have wrapped Qlik functions (aside from the `async_app_copy` function), it is integral to know the API appropriate endpoints to call.#### SupportThis project is built and maintained by Daniel Pilla, a Principal Analytics Platform Architect at Qlik. This project is however not supported by Qlik, and is only supported through Daniel.</longdescription>
</pkgmetadata>