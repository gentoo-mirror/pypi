<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># YAML Path and Command-Line Tools[![build](https://github.com/wwkimball/yamlpath/actions/workflows/build.yml/badge.svg)](https://github.com/wwkimball/yamlpath/actions/workflows/build.yml)[![Python versions](https://img.shields.io/pypi/pyversions/yamlpath.svg)](https://pypi.org/project/yamlpath/)[![PyPI version](https://badge.fury.io/py/yamlpath.svg)](https://pypi.org/project/yamlpath/)[![Downloads](https://pepy.tech/badge/yamlpath)](https://pepy.tech/project/yamlpath)[![Coverage Status](https://coveralls.io/repos/github/wwkimball/yamlpath/badge.svg?branch=master)](https://coveralls.io/github/wwkimball/yamlpath?branch=master)[![Codacy Badge](https://app.codacy.com/project/badge/Grade/b146b032a098413cbc2825cdf73fd7b2)](https://www.codacy.com/gh/wwkimball/yamlpath/dashboard?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=wwkimball/yamlpath&amp;amp;utm_campaign=Badge_Grade)Along with providing a[standard for defining YAML Paths](https://github.com/wwkimball/yamlpath/wiki/Segments-of-a-YAML-Path),this project aims to provide[generally-useful command-line tools](https://github.com/wwkimball/yamlpath/wiki/Command-Line-(CLI)-Tools)which implement YAML Paths.  These bring intuitive YAML, EYAML, JSON, andcompatible data parsing and editing capabilties to the command-line.  It isalso a[Python library](https://github.com/wwkimball/yamlpath/wiki/Python-Library)for other projects to readily employ YAML Paths.## Contents1. [Introduction](#introduction)2. [Illustration](#illustration)3. [Supported YAML Path Segments](#supported-yaml-path-segments)4. [Installing](#installing)   1. [Requirements](#requirements)   2. [Using pip](#using-pip)      1. [Very Old Versions of pip or its setuptools Dependency](#very-old-versions-of-pip-or-its-setuptools-dependency)   3. [Installing EYAML (Optional)](#installing-eyaml-optional)5. [Based on ruamel.yaml](#based-on-ruamelyaml)6. [The Files of This Project](#the-files-of-this-project)   1. [Command-Line Tools](#command-line-tools)   2. [Libraries](#libraries)7. [Basic Usage](#basic-usage)   1. [Basic Usage:  Command-Line Tools](#basic-usage--command-line-tools)      1. [Rotate Your EYAML Keys](#rotate-your-eyaml-keys)      2. [Get the Differences Between Two Documents](#get-the-differences-between-two-documents)      3. [Get a YAML/JSON/Compatible Value](#get-a-yamljsoncompatible-value)      4. [Search For YAML Paths](#search-for-yaml-paths)      5. [Change a YAML/JSON/Compatible Value](#change-a-yamljsoncompatible-value)      6. [Merge YAML/JSON/Compatible Files](#merge-yamljsoncompatible-files)      7. [Validate YAML/JSON/Compatible Documents](#validate-yamljsoncompatible-documents)   2. [Basic Usage:  Libraries](#basic-usage--libraries)      1. [Initialize ruamel.yaml and These Helpers](#initialize-ruamelyaml-and-these-helpers)      2. [Searching for YAML Nodes](#searching-for-yaml-nodes)      3. [Changing Values](#changing-values)      4. [Merging Documents](#merging-documents)## IntroductionThis project presents and utilizes YAML Paths, which are a powerful, intuitivemeans of identifying one *or more* nodes within [YAML](https://yaml.org/),[EYAML](https://github.com/voxpupuli/hiera-eyaml), or compatible data structureslike [JSON](https://www.json.org/).  Both dot-notation (inspired by[Hiera](https://github.com/puppetlabs/hiera)) and forward-slash-notation(influenced by [XPath](https://www.w3schools.com/xml/xml_xpath.asp)) aresupported.  The [libraries](#libraries) (modules) and several [command-line toolimplementations](#command-line-tools) are provided.  With these, you can buildYAML Path support right into your own application or easily use its capabilitiesright away from the command-line to retrieve, update, merge, validate, and scanYAML/JSON/Compatible data.This implementation of YAML Path is a *query language* in addition to a *nodedescriptor*.  With it, you can describe or select a single precise node orsearch for any number of nodes that match some criteria.  Keys, values,elements, anchors, and aliases can all be searched at any number of levelswithin the data structure using the same query.  Collectors can also be used togather and further select from otherwise disparate parts of the source data.The [project Wiki](https://github.com/wwkimball/yamlpath/wiki) provides adeeper dive into these concepts.## IllustrationTo illustrate some of these concepts, consider these samples:```yaml---hash:  child_attr:    key: 5280```This value, `5280`, can be identified via YAML Path as any of:1. `hash.child_attr.key` (dot-notation)2. `hash.child_attr[.=key]` (search all child keys for one named, `key`, and   yield its value)3. `/hash/child_attr/key` (same as 1 but in forward-slash notation)4. `/hash/child_attr[.=key]` (same as 2 but in forward-slash notation)```yaml---aliases:  - &amp;first_anchor Simple string value```With YAML Path, you can select this anchored value by any of these equivalentexpressions:1. `aliases[0]` (explicit array element number)2. `aliases.0` (implicit array element number in dot-notation)3. `aliases[&amp;first_anchor]` (search by Anchor name)4. `aliases[.^Simple]` (search for any elements starting with &quot;Simple&quot;)5. `aliases[.%string]` (search for any elements containing &quot;string&quot;)6. `aliases[.$value]` (search for any elements ending with &quot;value&quot;)7. `aliases[.=~/^(\b[Ss][a-z]+\s){2}[a-z]+$/]` (search for any elements matching   a complex Python Regular Expression, which happens to match the example)8. `/aliases[0]` (same as 1 but in forward-slash notation)9. `/aliases/0` (same as 2 but in forward-slash notation)10. `/aliases[&amp;first_anchor]` (same as 3 but in forward-slash notation)```yaml---users:  - name: User One    password: ENC[PKCS7,MIIBiQY...Jk==]    roles:      - Writers  - name: User Two    password: ENC[PKCS7,MIIBiQY...vF==]    roles:      - Power Users      - Editors```With an example like this, YAML Path enables:* selection of single nodes: `/users/0/roles/0` = `Writers`* all children nodes of any given parent: `/users/1/roles` =  `[&quot;Power Users&quot;, &quot;Editors&quot;]`* searching by a child attribute: `/users[name=&quot;User One&quot;]/password` =  `Some decrypted value, provided you have the appropriate EYAML keys`* pass-through selections against arrays-of-hashes: `/users/roles` =  `[&quot;Writers&quot;]\n[&quot;Power Users&quot;, &quot;Editors&quot;]` (each user's list of roles are a  separate result)* collection of disparate results: `(/users/name)` =  `[&quot;User One&quot;, &quot;User Two&quot;]` (all names appear in a single result instead of  one per line)For a deeper exploration of YAML Path's capabilities, please visit the[project Wiki](https://github.com/wwkimball/yamlpath/wiki).## Supported YAML Path SegmentsA YAML Path *segment* is the text between separators which identifies zero ormore parent or leaf nodes within the data structure.  For dot-notation, a pathlike `hash.key` identifies two segments:  `hash` (a parent node) and `key` (aleaf node).  The same path in forward-slash notation would be:  `/hash/key`.YAML Path understands these segment types:* Top-level Hash key selection: `key`* Explicit top-level array element selection: `[#]` where `#` is the zero-based  element number; `#` can also be negative, causing the element to be selected  from the end of the Array* Implicit array element selection **or** numbered hash key selection: `#`  where `#` is the 0-based element number **or** exact name of a hash key which  is itself a number* Top-level (Hash) Anchor lookups: `&amp;anchor_name` (the `&amp;` is required to  indicate you are seeking an Anchor by name)* Hash sub-keys:  `hash.child.key` or `/hash/child/key`* Demarcation for dotted Hash keys:  `hash.'dotted.child.key'` or  `hash.&quot;dotted.child.key&quot;` (not necessary when using forward-slash notation,  `/hash/dotted.child.key`)* Named Array element selection:  `array[#]`, `array.#`, `/array[#]`, or  `/array/#` where `array` is the name of the Hash key containing Array data  and `#` is the 0-based element number* Anchor lookups in named Arrays:  `array[&amp;anchor_name]`  where `array` is the  name of the Hash key containing Array data and both of the `[]` pair and `&amp;`  are required to indicate you are seeking an Anchor by name within an Array* Array slicing: `array[start#:stop#]` where `start#` is the first inclusive,  zero-based element and `stop#` is the last exclusive element to select;  either or both can be negative, causing the elements to be selected from the  end of the Array; when `start#` and `stop#` are identical, it is the same as  `array[start#]`* Hash slicing: `hash[min:max]` where `min` and `max` are alphanumeric terms  between which the Hash's keys are compared* Escape symbol recognition:  `hash.dotted\.child\.key`,  `/hash/whacked\/child\/key`, and `keys_with_\\slashes`* Hash attribute searches (which can return zero or more matches):  * Exact match:  `hash[name=admin]`  * Starts With match:  `hash[name^adm]`  * Ends With match:  `hash[name$min]`  * Contains match:  `hash[name%dmi]`  * Less Than match: `hash[access_level&lt;500]`  * Greater Than match: `hash[access_level&gt;0]`  * Less Than or Equal match: `hash[access_level&lt;=100]`  * Greater Than or Equal match: `hash[access_level&gt;=0]`  * [Python Regular Expression](https://docs.python.org/3/library/re.html)    matches: `hash[access_level=~/^\D+$/]` (the `/` Regular    Expression delimiter can be substituted for any character you need, except    white-space; note that `/` does not interfere with forward-slash notation    *and it does not need to be escaped* because the entire search expression is    contained within a `[]` pair)  * Invert any match with `!`, like: `hash[name!=admin]` or even    `hash[!name=admin]` (the former syntax is used when YAML Paths are    stringified but both forms are equivalent)  * Demarcate and/or escape expression operands, like:    `hash[full\ name=&quot;Some User\'s Name&quot;]` (note that embedded, single `'` and    `&quot;` must be escaped lest they be deemed unmatched demarcation pairings)  * Multi-level matching: `hash[name%admin].pass[encrypted!^ENC\[]` or    `/hash[name%admin]/pass[encrypted!^ENC\[]`  * Descendent node searches:    `structure[has.descendant.with=something].has.another.field` or    `/structure[/has/descendant/with=something]/has/another/field`* Array element searches with all of the search methods above via `.` (yields  any matching elements): `array[.&gt;9000]`* Hash key-name searches with all of the search methods above via `.` (yields  their values, not the keys themselves): `hash[.^app_]`* Array-of-Hashes Pass-Through Selection:  Omit a selector for the elements of  an Array-of-Hashes and all matching Hash attributes at that level will be  yielded (or searched when there is more to the path).  For example,  `warriors[1].power_level` or `/warriors[1]/power_level` will return the  power_level attribute of only the second Hash in an Array-of-Hashes while  `warriors.power_level` or `/warriors/power_level` will return the power_level  attribute of every Hash in the same Array-of-Hashes.  Of course these results  can be filtered in multiple ways, like `warriors[power_level&gt;9000]`,  `/warriors[power_level&gt;9000]`, `warriors.power_level[.&gt;9000]`, and  `/warriors/power_level[.&gt;9000]` all yield only the power_level from *all*  warriors with power_levels over 9,000 within the same array of warrior hashes.* Unordered Set value accessing and searching with all above search methods.* Wildcard Searches: The `*` symbol can be used as shorthand for the `[]`  search operator against text keys and values: `/warriors/name/Go*`; it also  returns every immediate child, regardless its key or value.* Deep Traversals:  The `**` symbol pair deeply traverses the document:  * When it is the last or only segment of a YAML Path, it selects every leaf    node from the remainder of the document's tree: `/shows/**`  * When another segment follows, it matches every node within the remainder    of the document's tree for which the following (and subsequent) segments    match: `/shows/**/name/Star*`* Search Keywords:  Advanced search capabilities not otherwise possible using  other YAML Path segments.  Taking the form of `[KEYWORD(PARAMETERS)]`, these  keywords are  [deeply explored on the Wiki](https://github.com/wwkimball/yamlpath/wiki/Search-Keywords)  and include:  * `[distinct(NAME)]`: Match exactly one of every value within collections,    discarding duplicates; i.e.:  [1, 2, 2, 3] has distinct values, [1, 2, 3]  * `[has_child(NAME)]`: Match nodes having a named child key  * `[max([NAME])]`: Match nodes having the maximum value  * `[min([NAME])]`: Match nodes having the minimum value  * `[name()]`: Match only the name of the present node, discarding all    children  * `[parent([STEPS])]`, Step up 1-N levels in the document from the present    node  * `[unique(NAME)]`: Match only values which have no duplicates within    collections; i.e.:  [1, 2, 2, 3] has unique values, [1, 3]* Collectors:  Placing any portion of the YAML Path within parenthesis defines a  virtual list collector, like `(YAML Path)`; concatenation, exclusion, and  intersection operators are supported -- `+`, `-`, and `&amp;`, respectively --  along with nesting, like `(...)-((...)+(...))&amp;(...)`* Complex combinations:  `some::deep.hierarchy[with!=&quot;&quot;].'any.valid'[.=~/(yaml|json)/][data%structure].or.complexity[4].2`  or `/some::deep/hierarchy[with!=&quot;&quot;]/any*.*valid[.=~/(yaml|json)/][data%structure]/or/compl*xity[4]/2/**`This implementation of YAML Path encourages creativity.  Use whichever notationand segment types that make the most sense to you in each application.The [project Wiki provides more illustrative details of YAML Path Segments](https://github.com/wwkimball/yamlpath/wiki/Segments-of-a-YAML-Path).## InstallingSome OS distributions offer some versions of yamlpath -- and its dependencies-- via packages.  While these versions of yamlpath are often outdated, they canbe convenient to install using your OS' native package manager (`apt`, `yum`,`npm`, and such).  Otherwise, Python's own package manager `pip` will alwaysoffer the latest version of yamlpath and -- even better -- can be isolated toephemeral or longer-lasting virtual Python environments.### RequirementsThis project requires [Python](https://www.python.org/) 3.  It is rigorouslytested against Pythons 3.6 through 3.11.  Most operating systems anddistributions have access to Python 3 even if only Python 2 -- or no Python, atall -- came pre-installed.  It is generally safe to have more than one versionof Python on your system at the same time, especially when using[virtual Python environments](https://docs.python.org/3/library/venv.html).*yamlpath* depends on *ruamel.yaml* (derived from and greatly extending PyYAML)and *python-dateutil*.  When using OS-native packages or `pip`, you do not needto pre-install these libraries yourself except under extraordinarycircumstances like using very old versions of `pip` or its own dependency,*setuptools*.### Using pipLike most others, this Python project is published to [PyPI](https://pypi.org/)so that it can be easily installed via Python's `pip` command (or itsversion-specific `pip3`, `pip3.7`, and such depending on how your Python wasinstalled).Python's `pip` command is ever-changing.  It is updated very frequently.  Thiscommand further depends on other libraries to do its job, namely *setuptools*.It so happens that *setuptools* is also updated very frequently.  Both of theseare separate from Python itself, despite versions of them being pre-installedwith Python.  It is your responsibility to keep `pip` and *setuptools*up-to-date.  When `pip` or *setuptools* become outdated, _you will experienceerrors_ when trying to install newer Python packages like *yamlpath* **unlessyou preinstall such packages' dependencies**.  In the case of *yamlpath*, thismeans you'd need to preinstall *ruamel.yaml* and *python-dateutil* if youcannot or choose not to upgrade `pip` and/or *setuptools*.As long as your `pip` and *setuptools* are up-to-date, installing *yamlpath* isas simple as a single command (the &quot;3.7&quot; suffix to the `pip` command isoptional, depending on how your Python 3 was installed):```shellpip3.7 install yamlpath```#### Very Old Versions of pip or its setuptools DependencyVery old versions of Python 3 ship with seriously outdated versions of `pip` andits *setuptools* dependency.  When using versions of `pip` older than **18.1**or *setuptools* older than version **46.4.0**, you will not be able to install*yamlpath* with a single command.  In this case, you have two options:  eitherpre-install *ruamel.yaml* and *python-dateutil* before installing *yamlpath* orupdate `pip` and/or *setuptools* to at least the minimum required versions so`pip` can auto-determine and install dependencies.  This issue is not unique to*yamlpath*.Upgrading `pip` and *setuptools* is trivially simple as long as you havesufficient access rights to do so on your local machine.  Depending on yoursituation, you may need to prefix these with `sudo` and/or you may need tosubstitute `python3` and `pip3` for `python` and `pip`, or even `python3.7` and`pip3.7` (or another specific version of Python 3), respectively.  To reiteratethat this project requires Python 3, these sample commands will bedemonstrated using such prefixes:```shellpython3.7 -m pip install --upgrade pippip3.7 install --upgrade setuptools```When you cannot or will not update `pip` or *setuptools*, just pre-install*ruamel.yaml* and *python-dateutil* before yamlpath.  Each must be installedseparately and in order, like this (you **cannot** combine these installationsinto a single command):```shellpip3.7 install ruamel.yaml python-dateutilpip3.7 install yamlpath```The downside to choosing this manual installation path is that you may end upwith an incompatible version of *ruamel.yaml* or *python-dateutil*.  This willmanifest either as an inability to install *yamlpath* at all, or only certainversions of *yamlpath*, or *yamlpath* may experience unexpected errors causedby the incompatible code.  For the best experience, you are strongly encouragedto just keep `pip` and *setuptools* up-to-date, particularly as a routine partof installing any new Python packages.### Installing EYAML (Optional)EYAML support is entirely optional.  You do not need EYAML to use YAML Path.That YAML Path supports EYAML is a service to a substantial audience:  Puppetusers.  At the time of this writing, EYAML (classified as a Hieraback-end/plug-in) is available only as a Ruby Gem.  That said, it provides acommand-line tool, `eyaml`, which can be employed by this otherwise Pythonproject.  To enjoy EYAML support, install compatible versions of ruby andrubygems, then execute:```shellgem install hiera-eyaml```If this puts the `eyaml` command on your system `PATH`, nothing more need bedone apart from generating or obtaining your encryption keys.  Otherwise, youcan tell YAML Path library and tools where to find the `eyaml` command.## Based on ruamel.yamlIn order to support the best available YAML editing capability (so called,round-trip editing with support for comment preservation), this project is basedon [ruamel.yaml](https://sourceforge.net/projects/ruamel-yaml/) forPython 3.  While ruamel.yaml is based on PyYAML --Python's &quot;standard&quot; YAML library -- ruamel.yaml is [objectively better thanPyYAML](https://yaml.readthedocs.io/en/latest/pyyaml.html), which lacks criticalround-trip editing capabilities as well as up-to-date YAML/Compatible dataparsing capabilities (at the time of this writing).Should PyYAML ever merge with -- or at least, catch up with -- ruamel.yaml, thisproject can be (lightly) adapted to depend on it, instead.  These conversationsmay offer some insight into when or whether this might happen:* [Is this time to pass the baton?](https://github.com/yaml/pyyaml/issues/31)* [Rebase off ruamel? - many new valuable features](https://github.com/yaml/pyyaml/issues/46)## The Files of This ProjectThis repository contains:1. Generally-useful Python library files.  These contain the reusable core of   this project's YAML Path capabilities.2. Some implementations of those libraries, exhibiting their capabilities and   simple-to-use APIs as command-line tools.3. Various support, documentation, and build files.### Command-Line ToolsThis project provides some command-line tool implementations which utilize YAMLPath.  For some use-case examples of these tools,[see below](#basic-usage--command-line-tools).The supplied command-line tools include:* [eyaml-rotate-keys](yamlpath/commands/eyaml_rotate_keys.py)```textusage: eyaml-rotate-keys [-h] [-V] [-d | -v | -q] [-b] [-x EYAML]                         -i OLDPRIVATEKEY -c OLDPUBLICKEY                         -r NEWPRIVATEKEY -u NEWPUBLICKEY                         YAML_FILE [YAML_FILE ...]Rotates the encryption keys used for all EYAML values within a set of YAMLfiles, decrypting with old keys and re-encrypting using replacement keys.positional arguments:  YAML_FILE             one or more YAML files containing EYAML valuesoptional arguments:  -h, --help            show this help message and exit  -V, --version         show program's version number and exit  -d, --debug           output debugging details  -v, --verbose         increase output verbosity  -q, --quiet           suppress all output except errors  -b, --backup          save a backup of each modified YAML_FILE with an extra                        .bak file-extension  -x EYAML, --eyaml EYAML                        the eyaml binary to use when it isn't on the PATHEYAML_KEYS:  All key arguments are required  -r NEWPRIVATEKEY, --newprivatekey NEWPRIVATEKEY                        the new EYAML private key  -u NEWPUBLICKEY, --newpublickey NEWPUBLICKEY                        the new EYAML public key  -i OLDPRIVATEKEY, --oldprivatekey OLDPRIVATEKEY                        the old EYAML private key  -c OLDPUBLICKEY, --oldpublickey OLDPUBLICKEY                        the old EYAML public keyAny YAML_FILEs lacking EYAML values will not be modified (or backed up, evenwhen -b/--backup is specified).```* [yaml-diff](yamlpath/commands/yaml_diff.py)```textusage: yaml-diff [-h] [-V] [-a] [-s | -o]                 [-t ['.', '/', 'auto', 'dot', 'fslash']] [-x EYAML]                 [-r PRIVATEKEY] [-u PUBLICKEY] [-E] [-d | -v | -q]                 YAML_FILE YAML_FILECalculate the functional difference between two YAML/JSON/Compatibledocuments. Immaterial differences (which YAML/JSON parsers discard) areignored. EYAML can be employed to compare encrypted values.positional arguments:  YAML_FILE             exactly two YAML/JSON/compatible files to compare; use                        - to read one document from STDINoptional arguments:  -h, --help            show this help message and exit  -V, --version         show program's version number and exit  -a, --sync-arrays     Synchronize array elements before comparing them,                        resulting only in ADD, DELETE, and SAME differences                        (no CHANGEs because the positions of elements are                        disregarded); Array-of-Hash elements must completely                        and perfectly match or they will be deemed additions                        or deletions  -s, --same            Show all nodes which are the same in addition to                        differences  -o, --onlysame        Show only nodes which are the same, still reporting                        that differences exist -- when they do -- with an                        exit-state of 1  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']                        indicate which YAML Path separator to use when                        rendering results; default=dot  -d, --debug           output debugging details  -v, --verbose         increase output verbosity  -q, --quiet           suppress all output except system errorsEYAML options:  Left unset, the EYAML keys will default to your system or user defaults.  Both keys must be set either here or in your system or user EYAML  configuration file when using EYAML.  -x EYAML, --eyaml EYAML                        the eyaml binary to use when it isn't on the PATH  -r PRIVATEKEY, --privatekey PRIVATEKEY                        EYAML private key  -u PUBLICKEY, --publickey PUBLICKEY                        EYAML public key  -E, --ignore-eyaml-values                        Do not use EYAML to compare encrypted data; rather,                        treat ENC[...] values as regular stringsOnly one YAML_FILE may be the - pseudo-file for reading from STDIN. For moreinformation about YAML Paths, please visithttps://github.com/wwkimball/yamlpath.```* [yaml-get](yamlpath/commands/yaml_get.py)```textusage: yaml-get [-h] [-V] -p YAML_PATH                [-t ['.', '/', 'auto', 'dot', 'fslash']] [-S] [-x EYAML]                [-r PRIVATEKEY] [-u PUBLICKEY] [-d | -v | -q]                [YAML_FILE]Retrieves one or more values from a YAML/JSON/Compatible file at a specifiedYAML Path. Output is printed to STDOUT, one line per result. When a result isa complex data-type (Array or Hash), a JSON dump is produced to represent it.EYAML can be employed to decrypt the values.positional arguments:  YAML_FILE             the YAML file to query; omit or use - to read from                        STDINoptional arguments:  -h, --help            show this help message and exit  -V, --version         show program's version number and exit  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']                        indicate which YAML Path separator to use when                        rendering results; default=dot  -S, --nostdin         Do not implicitly read from STDIN, even when YAML_FILE                        is not set and the session is non-TTY  -d, --debug           output debugging details  -v, --verbose         increase output verbosity  -q, --quiet           suppress all output except errorsrequired settings:  -p YAML_PATH, --query YAML_PATH                        YAML Path to queryEYAML options:  Left unset, the EYAML keys will default to your system or user defaults.  Both keys must be set either here or in your system or user EYAML  configuration file when using EYAML.  -x EYAML, --eyaml EYAML                        the eyaml binary to use when it isn't on the PATH  -r PRIVATEKEY, --privatekey PRIVATEKEY                        EYAML private key  -u PUBLICKEY, --publickey PUBLICKEY                        EYAML public keyFor more information about YAML Paths, please visithttps://github.com/wwkimball/yamlpath.```* [yaml-merge](yamlpath/commands/yaml_merge.py)```textusage: yaml-merge [-h] [-V] [-c CONFIG] [-a {stop,left,right,rename}]                  [-A {all,left,right,unique}] [-H {deep,left,right}]                  [-O {all,deep,left,right,unique}] [-m YAML_PATH]                  [-o OUTPUT | -w OVERWRITE] [-b] [-D {auto,json,yaml}] [-S]                  [-d | -v | -q]                  [YAML_FILE [YAML_FILE ...]]Merges two or more YAML/JSON/Compatible files together.positional arguments:  YAML_FILE             one or more YAML files to merge, order-significant;                        omit or use - to read from STDINoptional arguments:  -h, --help            show this help message and exit  -V, --version         show program's version number and exit  -c CONFIG, --config CONFIG                        INI syle configuration file for YAML Path specified                        merge control options  -a {stop,left,right,rename}, --anchors {stop,left,right,rename}                        means by which Anchor name conflicts are resolved                        (overrides [defaults]anchors set via --config|-c and                        cannot be overridden by [rules] because Anchors apply                        to the whole file); default=stop  -A {all,left,right,unique}, --arrays {all,left,right,unique}                        default means by which Arrays are merged together                        (overrides [defaults]arrays but is overridden on a                        YAML Path basis via --config|-c); default=all  -H {deep,left,right}, --hashes {deep,left,right}                        default means by which Hashes are merged together                        (overrides [defaults]hashes but is overridden on a                        YAML Path basis in [rules] set via --config|-c);                        default=deep  -O {all,deep,left,right,unique}, --aoh {all,deep,left,right,unique}                        default means by which Arrays-of-Hashes are merged                        together (overrides [defaults]aoh but is overridden on                        a YAML Path basis in [rules] set via --config|-c);                        default=all  -m YAML_PATH, --mergeat YAML_PATH                        YAML Path indicating where in left YAML_FILE the right                        YAML_FILE content is to be merged; default=/  -o OUTPUT, --output OUTPUT                        Write the merged result to the indicated nonexistent                        file  -w OVERWRITE, --overwrite OVERWRITE                        Write the merged result to the indicated file; will                        replace the file when it already exists  -b, --backup          save a backup OVERWRITE file with an extra .bak                        file-extension; applies only to OVERWRITE  -D {auto,json,yaml}, --document-format {auto,json,yaml}                        Force the merged result to be presented in one of the                        supported formats or let it automatically match the                        known file-name extension of OUTPUT|OVERWRITE (when                        provided), or match the type of the first document;                        default=auto  -S, --nostdin         Do not implicitly read from STDIN, even when there are                        no - pseudo-files in YAML_FILEs with a non-TTY session  -d, --debug           output debugging details  -v, --verbose         increase output verbosity  -q, --quiet           suppress all output except errors (implied when                        -o|--output is not set)            The CONFIG file is an INI file with up to three sections:            [defaults] Sets equivalents of -a|--anchors, -A|--arrays,                       -H|--hashes, and -O|--aoh.            [rules]    Each entry is a YAML Path assigning -A|--arrays,                       -H|--hashes, or -O|--aoh for precise nodes.            [keys]     Wherever -O|--aoh=DEEP, each entry is treated as a                       record with an identity key.  In order to match RHS                       records to LHS records, a key must be known and is                       identified on a YAML Path basis via this section.                       Where not specified, the first attribute of the first                       record in the Array-of-Hashes is presumed the identity                       key for all records in the set.            The left-to-right order of YAML_FILEs is significant.  Except            when this behavior is deliberately altered by your options, data            from files on the right overrides data in files to their left.            Only one input file may be the - pseudo-file (read from STDIN).            When no YAML_FILEs are provided, - will be inferred as long as you            are running this program without a TTY (unless you set            --nostdin|-S).  Any file, including input from STDIN, may be a            multi-document YAML or JSON file.            For more information about YAML Paths, please visit            https://github.com/wwkimball/yamlpath.```* [yaml-paths](yamlpath/commands/yaml_paths.py)```textusage: yaml-paths [-h] [-V] -s EXPRESSION [-c EXPRESSION] [-m] [-L] [-F] [-X]                  [-P] [-n] [-t ['.', '/', 'auto', 'dot', 'fslash']]                  [-i | -k | -K] [-a] [-A | -Y | -y | -l] [-e] [-x EYAML]                  [-r PRIVATEKEY] [-u PUBLICKEY] [-S] [-d | -v | -q]                  [YAML_FILE [YAML_FILE ...]]Returns zero or more YAML Paths indicating where in given YAML/JSON/Compatibledata one or more search expressions match. Values, keys, and/or anchors can besearched. EYAML can be employed to search encrypted values.positional arguments:  YAML_FILE             one or more YAML files to search; omit or use - to                        read from STDINoptional arguments:  -h, --help            show this help message and exit  -V, --version         show program's version number and exit  -c EXPRESSION, --except EXPRESSION                        except results matching this search expression; can be                        set more than once  -m, --expand          expand matching parent nodes to list all permissible                        child leaf nodes (see &quot;reference handling options&quot; for                        restrictions)  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']                        indicate which YAML Path separator to use when                        rendering results; default=dot  -a, --refnames        also search the names of &amp;anchor and *alias references  -S, --nostdin         Do not implicitly read from STDIN, even when there are                        no - pseudo-files in YAML_FILEs with a non-TTY session  -d, --debug           output debugging details  -v, --verbose         increase output verbosity  -q, --quiet           suppress all non-result output except errorsrequired settings:  -s EXPRESSION, --search EXPRESSION                        the search expression; can be set more than onceresult printing options:  -L, --values          print the values or elements along with each YAML Path                        (complex results are emitted as JSON; use --expand to                        emit only simple values)  -F, --nofile          omit source file path and name decorators from the                        output (applies only when searching multiple files)  -X, --noexpression    omit search expression decorators from the output  -P, --noyamlpath      omit YAML Paths from the output (useful with --values                        or to indicate whether a file has any matches without                        printing them all, perhaps especially with                        --noexpression)  -n, --noescape        omit escape characters from special characters in                        printed YAML Paths; this is unsafe for feeding the                        resulting YAML Paths into other YAML Path commands                        because the symbols that would be escaped have special                        meaning to YAML Path processorskey name searching options:  -i, --ignorekeynames  (default) do not search key names  -k, --keynames        search key names in addition to values and array                        elements  -K, --onlykeynames    only search key names (ignore all values and array                        elements)reference handling options:  Indicate how to treat anchor and alias references. An anchor is an  original, reusable key or value. All aliases become replaced by the  anchors they reference when YAML data is read. These options specify how  to handle this duplication of keys and values. Note that the default  behavior includes all aliased keys but not aliased values.  -A, --anchorsonly     include only original matching key and value anchors                        in results, discarding all aliased keys and values                        (including child nodes)  -Y, --allowkeyaliases                        (default) include matching key aliases, permitting                        search traversal into their child nodes  -y, --allowvaluealiases                        include matching value aliases (does not permit search                        traversal into aliased keys)  -l, --allowaliases    include all matching key and value aliasesEYAML options:  Left unset, the EYAML keys will default to your system or user defaults.  Both keys must be set either here or in your system or user EYAML  configuration file when using EYAML.  -e, --decrypt         decrypt EYAML values in order to search them                        (otherwise, search the encrypted blob)  -x EYAML, --eyaml EYAML                        the eyaml binary to use when it isn't on the PATH  -r PRIVATEKEY, --privatekey PRIVATEKEY                        EYAML private key  -u PUBLICKEY, --publickey PUBLICKEY                        EYAML public keyA search or exception EXPRESSION takes the form of a YAML Path search operator-- %, $, =, ^, &gt;, &lt;, &gt;=, &lt;=, =~, or ! -- followed by the search term, omittingthe left-hand operand. For more information about YAML Paths, please visithttps://github.com/wwkimball/yamlpath/wiki. To report issues with this tool orto request enhancements, please visithttps://github.com/wwkimball/yamlpath/issues.```* [yaml-set](yamlpath/commands/yaml_set.py)```textusage: yaml-set [-h] [-V] -g YAML_PATH                [-a VALUE | -A ANCHOR | -f FILE | -i | -R LENGTH | -N | -D]                [-F {bare,boolean,default,dquote,float,folded,int,literal,squote}]                [-c CHECK] [-s YAML_PATH] [-m] [-b]                [-t ['.', '/', 'auto', 'dot', 'fslash']] [-M CHARS] [-H ANCHOR]                [-T TAG] [-e] [-x EYAML] [-r PRIVATEKEY] [-u PUBLICKEY] [-S]                [-d | -v | -q]                [YAML_FILE]Changes one or more Scalar values in a YAML/JSON/Compatible document at aspecified YAML Path. Matched values can be checked before they are replaced tomitigate accidental change. When matching singular results, the value can bearchived to another key before it is replaced. Further, EYAML can be employed toencrypt the new values and/or decrypt an old value before checking it.positional arguments:  YAML_FILE             the YAML file to update; omit or use - to read from                        STDINoptional arguments:  -h, --help            show this help message and exit  -V, --version         show program's version number and exit  -F {bare,boolean,default,dquote,float,folded,int,literal,squote}, --format {bare,boolean,default,dquote,float,folded,int,literal,squote}                        override automatic formatting of the new value  -c CHECK, --check CHECK                        check the value before replacing it  -s YAML_PATH, --saveto YAML_PATH                        save the old value to YAML_PATH before replacing it;                        implies --mustexist  -m, --mustexist       require that the --change YAML_PATH already exist in                        YAML_FILE  -b, --backup          save a backup YAML_FILE with an extra .bak file-                        extension  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']                        indicate which YAML Path separator to use when rendering                        results; default=dot  -M CHARS, --random-from CHARS                        characters from which to build a value for --random;                        default=all upper- and lower-case letters and all digits  -H ANCHOR, --anchor ANCHOR                        when --aliasof|-A points to a value which is not already                        Anchored, a new Anchor with this name is created;                        renames an existing Anchor if already set  -T TAG, --tag TAG     assign a custom YAML (data-type) tag to the changed                        nodes; can be used without other input options to assign                        or change a tag  -S, --nostdin         Do not implicitly read from STDIN, even when there is no                        YAML_FILE with a non-TTY session  -d, --debug           output debugging details  -v, --verbose         increase output verbosity  -q, --quiet           suppress all output except errorsrequired settings:  -g YAML_PATH, --change YAML_PATH                        YAML Path where the target value is foundinput options:  -a VALUE, --value VALUE                        set the new value from the command-line instead of STDIN  -A ANCHOR, --aliasof ANCHOR                        set the value as a YAML Alias of an existing Anchor, by                        name (merely copies the target value for non-YAML files)  -f FILE, --file FILE  read the new value from file (discarding any trailing                        new-lines)  -i, --stdin           accept the new value from STDIN (best for sensitive                        data)  -R LENGTH, --random LENGTH                        randomly generate a replacement value of a set length  -N, --null            sets the value to null  -D, --delete          delete rather than change target node(s); implies                        --mustexist|-mEYAML options:  Left unset, the EYAML keys will default to your system or user defaults. You  do not need to supply a private key unless you enable --check and the old  value is encrypted.  -e, --eyamlcrypt      encrypt the new value using EYAML  -x EYAML, --eyaml EYAML                        the eyaml binary to use when it isn't on the PATH  -r PRIVATEKEY, --privatekey PRIVATEKEY                        EYAML private key  -u PUBLICKEY, --publickey PUBLICKEY                        EYAML public keyWhen no changes are made, no backup is created, even when -b/--backup isspecified. For more information about YAML Paths, please visithttps://github.com/wwkimball/yamlpath/wiki. To report issues with this tool orto request enhancements, please visithttps://github.com/wwkimball/yamlpath/issues.```* [yaml-validate](yamlpath/commands/yaml_validate.py)```textusage: yaml-validate [-h] [-V] [-S] [-d | -v | -q] [YAML_FILE [YAML_FILE ...]]Validate YAML, JSON, and compatible files.positional arguments:  YAML_FILE      one or more single- or multi-document YAML/JSON/compatible                 files to validate; omit or use - to read from STDINoptional arguments:  -h, --help     show this help message and exit  -V, --version  show program's version number and exit  -S, --nostdin  Do not implicitly read from STDIN, even when there are no -                 pseudo-files in YAML_FILEs with a non-TTY session  -d, --debug    output debugging details  -v, --verbose  increase output verbosity (show valid documents)  -q, --quiet    suppress all output except system errorsExcept when suppressing all report output with --quiet|-q, validation issuesare printed to STDOUT (not STDERR). Further, the exit-state will report 0 whenthere are no issues, 1 when there is an issue with the supplied command-linearguments, or 2 when validation has failed for any document.```### LibrariesWhile there are several supporting library files like enumerations, types, andexceptions, the most interesting library files include:* [yamlpath.py](yamlpath/yamlpath.py) -- The core YAML Path parser logic.* [processor.py](yamlpath/processor.py) -- Processes YAMLPath instances to read  or write data to YAML/Compatible sources.* [eyamlprocessor.py](yamlpath/eyaml/eyamlprocessor.py) -- Extends the  Processor class to support EYAML data encryption and decryption.* [merger.py](yamlpath/merger/merger.py) -- The core document merging logic.## Basic UsageThe files of this project can be used either as command-line tools or aslibraries to supplement your own work.### Basic Usage:  Command-Line ToolsThe command-line tools are self-documented and [their documentation is capturedabove](#command-line-tools) for easy reference.  Simply pass `--help` to them inorder to obtain the same detailed documentation.Please review [the comprehensive test_commands_*.py unit tests](/tests/) toexplore samples of YAML files and the many ways these tools help get and settheir data.The following are some simple examples of their typical use-cases.#### Rotate Your EYAML KeysIf the eyaml command is already on your PATH (if not, be sure to also supplythe optional `--eyaml` or `-x` argument):```shelleyaml-rotate-keys \  --oldprivatekey=~/old-keys/private_key.pkcs7.pem \  --oldpublickey=~/old-keys/public_key.pkcs7.pem \  --newprivatekey=~/new-keys/private_key.pkcs7.pem \  --newpublickey=~/new-keys/public_key.pkcs7.pem \  my_1st_yaml_file.yaml my_2nd_yaml_file.eyaml ... my_Nth_yaml_file.yaml```You could combine this with `find` and `xargs` if your E/YAML file aredispersed through a directory hierarchy, as with Hiera data.##### EYAML Compatibility AlertThe maintainers of the hiera-eyaml project have released version 3.x and it is*not backward compatible* with encryption certificates generated forhiera-eyaml version 2.x.  This has nothing to do with YAML Path and is alertedhere only as a courtesy to YAML Path users.  **If you upgrade yourinstallation of hiera-eyaml without first updating your encryptioncertificates and using a tool like eyaml-rotate-keys (provided here) tore-encrypt your data with the replacement certificates, hiera-eyaml 3.x willfail to decrypt your data!**  This is *not* a problem with YAML Path.hiera-eyaml certificate compatibility is well outside the purview of YAML Pathand its tools.#### Get the Differences Between Two DocumentsFor routine use:```shellyaml-diff yaml_file1.yaml yaml_file2.yaml```Output is very similar to that of standard GNU diff against text files, exceptit is generated against the *data* within the input files.  This excludesevaluating purely structural and immaterial differences between them like valuedemarcation, white-space, and comments.  When you need to evaluate the twofiles as if they were just text files, use GNU diff or any of its clones.To see all identical entries along with differences:```shellyaml-diff --same yaml_file1.yaml yaml_file2.yaml```To see *only* entries which are identical between the documents:```shellyaml-diff --onlysame yaml_file1.yaml yaml_file2.yaml```Advanced:  Arrays can be evaluated such that they are synchronized beforeevaluation.  Rather than compare elements by identical index in bothdocuments -- reporting differences between them as changes and any additionalelements as additions or deletions -- they can instead be compared by matchingup all identical elements and then reporting only those values which are uniqueto either document (and optionally identical matches).```shellyaml-diff --sync-arrays yaml_file1.yaml yaml_file2.yaml```#### Get a YAML/JSON/Compatible ValueAt its simplest:```shellyaml-get \  --query=see.documentation.above.for.many.samples \  my_yaml_file.yaml```#### Search For YAML PathsSimplest use:```shellyaml-paths \  --search=%word \  /some/directory/*.yaml```Search for multiple expressions and exclude unwanted results:```shellyaml-paths \  --search=^another \  --search=$word \  --except=%bad \  /some/directory/*.yaml```Return all leaf nodes under matching parents (most useful when matching against Hash keys and you only want the original leaf nodes beneath them):```shellyaml-paths \  --expand \  --keynames \  --search==parent_node \  /some/directory/*.yaml```#### Change a YAML/JSON/Compatible ValueFor a no-frills change to a YAML file with deeply nested Hash structures:```shellyaml-set \  --change=see.documentation.above.for.many.samples \  --value=&quot;New Value&quot; \  my_yaml_file.yaml```To rotate a password, preserving the old password perhaps so your automation canapply the new password to your application(s):```shellyaml-set \  --mustexist \  --change=the.new.password \  --saveto=the.old.password \  --value=&quot;New Password&quot; \  my_yaml_file.yaml```For the extremely cautious, you could check the old password before rotatingit and save a backup of the original file:```shellyaml-set \  --mustexist \  --change=the.new.password \  --saveto=the.old.password \  --check=&quot;Old Password&quot; \  --value=&quot;New Password&quot; \  --backup \  my_yaml_file.yaml```You can also add EYAML encryption (assuming the `eyaml` command is on yourPATH; if not, you can pass `--eyaml` to specify its location).  In this example,I add the optional `--format=folded` so that the long EYAML value is broken upinto a multi-line value rather than one very long string.  This is the preferredformat for human legibility as well as EYAML consumers like[Puppet](http://puppet.com).  Note that `--format` has several other settingsand applies only to new values.```shellyaml-set \  --change=the.new.password \  --mustexist \  --saveto=the.old.password \  --check=&quot;Old Password&quot; \  --value=&quot;New Password&quot; \  --eyamlcrypt \  --format=folded \  --backup \  my_yaml_file.yaml```You can even tell EYAML which keys to use, if not your default system or userkeys:```shellyaml-set \  --change=the.new.password \  --mustexist \  --saveto=the.old.password \  --check=&quot;Old Password&quot; \  --value=&quot;New Password&quot; \  --eyamlcrypt \  --format=folded \  --privatekey=/secret/keys/private_key.pkcs7.pem \  --publickey=/secret/keys/public_key.pkcs7.pem \  --backup \  my_yaml_file.yaml```Note that for even greater security scenarios, you can keep the new value off ofyour command-line, process list, and command history by swapping out `--value`for one of `--stdin`, `--file`, or even `--random LENGTH` (use Python'sstrongest random value generator if you don't need to specify the replacementvalue in advance).#### Merge YAML/JSON/Compatible FilesAt its simplest, the `yaml-merge` command accepts two or more input files andmerges them together from left-to-right, writing the result to STDOUT:```shellyaml-merge leftmost.yaml middle.yaml right.json```If you'd rather write the results to a new output file (which must not alreadyexist):```shellyaml-merge \  --output=newfile.yaml \  leftmost.yaml \  middle.yaml \  right.json```Should you wish to merge the content of the files into a specific location (oreven multiple locations) within the leftmost document, specify a YAML Path viathe `--mergeat` or `-m` argument:```shellyaml-merge \  --mergeat=/anywhere/within/the/document \  leftmost.yaml \  middle.yaml \  right.json```To write arbitrary data from STDIN into a document, use the `-` pseudo-file:```shellecho &quot;{arbitrary: [document, structure]}&quot; | yaml-merge target.yaml -```Combine `--mergeat` or `-m` with the STDIN pseudo-file to control where thedata is to be written:```shellecho &quot;{arbitrary: [document, structure]}&quot; | \  yaml-merge \    --mergeat=/anywhere/within/the/document \    target.yaml -```There are many options for precisely controlling how the merge is performed,including the ability to specify complex rules on a YAML Path basis via aconfiguration file.  Review the command's `--help` or the[related Wiki](https://github.com/wwkimball/yamlpath/wiki/yaml-merge) formore detail.#### Validate YAML/JSON/Compatible DocumentsValidating the structure of YAML, JSON, and compatible files is as simple asrunning:```shellyaml-validate /path/to/any/files.yaml /path/to/more/files.json```In this default configuration, the command will output no report when all inputdocuments are valid.  It will also report an exit-state of zero (0).  Shouldthere be any validation errors, each will be printed to the screen and theexit-state will be 2.  An exit-state of 1 means your command-line argumentswere incorrect and an appropritae user error message will be displayed.When there are validation issues, the offending file-name(s) and sub-documentindex(es) (zero-based) will be displayed along with a detailed validation errormessage.### Basic Usage:  LibrariesAs for the libraries, they are also heavily documented and the exampleimplementations may perhaps serve as good copy-paste fodder (provided you givecredit to the source).  That said, here's a general flow/synopsis.#### Initialize ruamel.yaml and These HelpersYour preferences may differ, but I use this setup for round-trip YAML parsingand editing with ruamel.yaml.  When you need to process EYAML encrypted data,replace `yamlpath.Processor` with `yamlpath.eyaml.EYAMLProcessor` and add errorhandling for `yamlpath.eyaml.EYAMLCommandException`.Note also that these examples use `ConsolePrinter` to handle STDOUT and STDERRmessaging.  You don't have to.  However, some kind of logger must be passed tothese libraries so they can write messages _somewhere_.  Your custom messagehandler or logger must provide the same API as `ConsolePrinter`; review theheader documentation in [consoleprinter.py](yamlpath/wrappers/consoleprinter.py)for details.  Generally speaking, it would be trivial to write your own customwrapper for Python's standard logging facilities if you require targets otherthan STDOUT and STDERR.```pythonfrom types import SimpleNamespacefrom yamlpath.common import Parsersfrom yamlpath.wrappers import ConsolePrinterfrom yamlpath import Processor# The various classes of this library must be able to write messages somewhere# when things go bad.  This project provides a CLI-centric logging class named# ConsolePrinter.  Even when not writing a CLI tool, you must still configure# and pass ConsolePrinter or a class of your own with the same public API.  For# just muting logging output -- except for unrecoverable errors -- you can use# this simple configuration object:logging_args = SimpleNamespace(quiet=True, verbose=False, debug=False)log = ConsolePrinter(logging_args)# Prep the YAML parser and round-trip editor (tweak to your needs).  You do not# have to use Parsers.get_yaml_editor() but you must create a properly-# configured instance of ruamel.yaml.YAML.yaml = Parsers.get_yaml_editor()# At this point, you'd load or parse your YAML file, stream, or string.  This# example demonstrates loading YAML data from an external file.  You could also# use the same function to load data from STDIN or even a String variable.  See# the Parser class for more detail.yaml_file = &quot;your-file.yaml&quot;(yaml_data, doc_loaded) = Parsers.get_yaml_data(yaml, log, yaml_file)if not doc_loaded:    # There was an issue loading the file; an error message has already been    # printed via ConsolePrinter.    exit(1)# Pass the logging facility and parsed YAML data to the YAMLPath Processorprocessor = Processor(log, yaml_data)# At this point, the Processor is ready to handle YAML Paths```#### Searching for YAML NodesThese libraries use [Generators](https://wiki.python.org/moin/Generators) to getnodes from parsed YAML data.  Identify which node(s) to get via YAML Pathstrings.  You should also catch `yamlpath.exceptions.YAMLPathException`sunless you prefer Python's native stack traces.  When using EYAML, you shouldalso catch `yamlpath.eyaml.exceptions.EYAMLCommandException`s for the samereason.  Whether you are working with a single result or many, you shouldconsume the Generator output with a pattern similar to:```pythonfrom yamlpath import YAMLPathfrom yamlpath.exceptions import YAMLPathExceptionyaml_path = YAMLPath(&quot;see.documentation.above.for.many.samples&quot;)try:    for node_coordinate in processor.get_nodes(yaml_path, mustexist=True):        log.debug(&quot;Got {} from '{}'.&quot;.format(node_coordinate, yaml_path))        # Do something with each node_coordinate.node (the actual data)except YAMLPathException as ex:    # If merely retrieving data, this exception may be deemed non-critical    # unless your later code absolutely depends upon a result.    log.error(ex)```#### Changing ValuesAt its simplest, you only need to supply the the YAML Path to one or more nodesto update, and the value to apply to them.  Catching`yamlpath.exceptions.YAMLPathException` is optional but usually preferred overallowing Python to dump the call stack in front of your users.  When usingEYAML, the same applies to `yamlpath.eyaml.exceptions.EYAMLCommandException`.```pythonfrom yamlpath.exceptions import YAMLPathExceptiontry:    processor.set_value(yaml_path, new_value)except YAMLPathException as ex:    log.critical(ex, 119)except EYAMLCommandException as ex:    log.critical(ex, 120)```#### Merging DocumentsA document merge naturally requires at least two documents.  At the code-level,this means two populated DOM objects (populated instances of `yaml_data` fromabove).  You do not need to use a `Processor` for merging.  In the least amountof code, a merge looks like:```pythonfrom yamlpath.exceptions import YAMLPathExceptionfrom yamlpath.merger.exceptions import MergeExceptionfrom yamlpath.merger import Merger, MergerConfig# Obtain or build the lhs_data and rhs_data objects using get_yaml_data or# equivalent.# You'll still need to supply a logger and some arguments used by the merge# engine.  For purely default behavior, you could create args as a bare# SimpleNamespace.  Initialize the new Merger instance with the LHS document.merger = Merger(log, lhs_data, MergerConfig(log, args))# Merge RHS into LHStry:    merger.merge_with(rhs_data)except MergeException as mex:    log.critical(mex, 129)except YAMLPathException as yex:    log.critical(yex, 130)# At this point, merger.data is the merged result; do what you will with it,# including merging more data into it.  When you are ready to dump (write)# out the merged data, you must prepare the document and your# ruamel.yaml.YAML instance -- usually obtained from func.get_yaml_editor()# -- like this:merger.prepare_for_dump(my_yaml_editor)```</longdescription>
</pkgmetadata>