<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;h2 align=&quot;center&quot;&gt;Send responses to HTTPX using pytest&lt;/h2&gt;&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://pypi.org/project/pytest-httpx/&quot;&gt;&lt;img alt=&quot;pypi version&quot; src=&quot;https://img.shields.io/pypi/v/pytest_httpx&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Colin-b/pytest_httpx/actions&quot;&gt;&lt;img alt=&quot;Build status&quot; src=&quot;https://github.com/Colin-b/pytest_httpx/workflows/Release/badge.svg&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Colin-b/pytest_httpx/actions&quot;&gt;&lt;img alt=&quot;Coverage&quot; src=&quot;https://img.shields.io/badge/coverage-100%25-brightgreen&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/psf/black&quot;&gt;&lt;img alt=&quot;Code style: black&quot; src=&quot;https://img.shields.io/badge/code%20style-black-000000.svg&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Colin-b/pytest_httpx/actions&quot;&gt;&lt;img alt=&quot;Number of tests&quot; src=&quot;https://img.shields.io/badge/tests-168 passed-blue&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://pypi.org/project/pytest-httpx/&quot;&gt;&lt;img alt=&quot;Number of downloads&quot; src=&quot;https://img.shields.io/pypi/dm/pytest_httpx&quot;&gt;&lt;/a&gt;&lt;/p&gt;&gt; Version 1.0.0 will be released once httpx is considered as stable (release of 1.0.0).&gt;&gt; However, current state can be considered as stable.Once installed, `httpx_mock` [`pytest`](https://docs.pytest.org/en/latest/) fixture will make sure every [`httpx`](https://www.python-httpx.org) request will be replied to with user provided responses.- [Add responses](#add-responses)  - [JSON body](#add-json-response)  - [Custom body](#reply-with-custom-body)  - [Multipart body (files, ...)](#add-multipart-response)  - [HTTP status code](#add-non-200-response)  - [HTTP headers](#reply-with-custom-headers)  - [HTTP/2.0](#add-http/2.0-response)- [Add dynamic responses](#dynamic-responses)- [Raising exceptions](#raising-exceptions)- [Check requests](#check-sent-requests)- [Do not mock some requests](#do-not-mock-some-requests)- [Migrating](#migrating-to-pytest-httpx)  - [responses](#from-responses)  - [aioresponses](#from-aioresponses)## Add responsesYou can register responses for both sync and async [`HTTPX`](https://www.python-httpx.org) requests.```pythonimport pytestimport httpxdef test_something(httpx_mock):    httpx_mock.add_response()    with httpx.Client() as client:        response = client.get(&quot;https://test_url&quot;)@pytest.mark.asyncioasync def test_something_async(httpx_mock):    httpx_mock.add_response()    async with httpx.AsyncClient() as client:        response = await client.get(&quot;https://test_url&quot;)```If all registered responses are not sent back during test execution, the test case will fail at teardown.This behavior can be disabled thanks to the `assert_all_responses_were_requested` fixture:```pythonimport pytest@pytest.fixturedef assert_all_responses_were_requested() -&gt; bool:    return False```Default response is a HTTP/1.1 200 (OK) without any body.### How response is selectedIn case more than one response match request, the first one not yet sent (according to the registration order) will be sent.In case all matching responses have been sent, the last one (according to the registration order) will be sent.You can add criteria so that response will be sent only in case of a more specific matching.#### Matching on URL`url` parameter can either be a string, a python [re.Pattern](https://docs.python.org/3/library/re.html) instance or a [httpx.URL](https://www.python-httpx.org/api/#url) instance.Matching is performed on the full URL, query parameters included.Order of parameters in the query string does not matter, however order of values do matter if the same parameter is provided more than once.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_url(httpx_mock: HTTPXMock):    httpx_mock.add_response(url=&quot;https://test_url?a=1&amp;b=2&quot;)    with httpx.Client() as client:        response1 = client.delete(&quot;https://test_url?a=1&amp;b=2&quot;)        response2 = client.get(&quot;https://test_url?b=2&amp;a=1&quot;)```#### Matching on HTTP methodUse `method` parameter to specify the HTTP method (POST, PUT, DELETE, PATCH, HEAD) to reply to.`method` parameter must be a string. It will be upper-cased, so it can be provided lower cased.Matching is performed on equality.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_post(httpx_mock: HTTPXMock):    httpx_mock.add_response(method=&quot;POST&quot;)    with httpx.Client() as client:        response = client.post(&quot;https://test_url&quot;)def test_put(httpx_mock: HTTPXMock):    httpx_mock.add_response(method=&quot;PUT&quot;)    with httpx.Client() as client:        response = client.put(&quot;https://test_url&quot;)def test_delete(httpx_mock: HTTPXMock):    httpx_mock.add_response(method=&quot;DELETE&quot;)    with httpx.Client() as client:        response = client.delete(&quot;https://test_url&quot;)def test_patch(httpx_mock: HTTPXMock):    httpx_mock.add_response(method=&quot;PATCH&quot;)    with httpx.Client() as client:        response = client.patch(&quot;https://test_url&quot;)def test_head(httpx_mock: HTTPXMock):    httpx_mock.add_response(method=&quot;HEAD&quot;)    with httpx.Client() as client:        response = client.head(&quot;https://test_url&quot;)    ```#### Matching on HTTP headersUse `match_headers` parameter to specify the HTTP headers to reply to.Matching is performed on equality for each provided header.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_headers_matching(httpx_mock: HTTPXMock):    httpx_mock.add_response(match_headers={'user-agent': 'python-httpx/0.23.0'})    with httpx.Client() as client:        response = client.get(&quot;https://test_url&quot;)```#### Matching on HTTP bodyUse `match_content` parameter to specify the full HTTP body to reply to.Matching is performed on equality.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_content_matching(httpx_mock: HTTPXMock):    httpx_mock.add_response(match_content=b&quot;This is the body&quot;)    with httpx.Client() as client:        response = client.post(&quot;https://test_url&quot;, content=b&quot;This is the body&quot;)```### Add JSON responseUse `json` parameter to add a JSON response using python values.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_json(httpx_mock: HTTPXMock):    httpx_mock.add_response(json=[{&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}])    with httpx.Client() as client:        assert client.get(&quot;https://test_url&quot;).json() == [{&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}]    ```Note that the `content-type` header will be set to `application/json` by default in the response.### Reply with custom bodyUse `text` parameter to reply with a custom body by providing UTF-8 encoded string.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_str_body(httpx_mock: HTTPXMock):    httpx_mock.add_response(text=&quot;This is my UTF-8 content&quot;)    with httpx.Client() as client:        assert client.get(&quot;https://test_url&quot;).text == &quot;This is my UTF-8 content&quot;```Use `content` parameter to reply with a custom body by providing bytes.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_bytes_body(httpx_mock: HTTPXMock):    httpx_mock.add_response(content=b&quot;This is my bytes content&quot;)    with httpx.Client() as client:        assert client.get(&quot;https://test_url&quot;).content == b&quot;This is my bytes content&quot;    ```Use `html` parameter to reply with a custom body by providing UTF-8 encoded string.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_html_body(httpx_mock: HTTPXMock):    httpx_mock.add_response(html=&quot;&lt;body&gt;This is &lt;p&gt; HTML content&lt;/body&gt;&quot;)    with httpx.Client() as client:        assert client.get(&quot;https://test_url&quot;).text == &quot;&lt;body&gt;This is &lt;p&gt; HTML content&lt;/body&gt;&quot;```### Reply by streaming chunksUse `stream` parameter to stream chunks that you specify.```pythonimport httpximport pytestfrom pytest_httpx import HTTPXMock, IteratorStreamdef test_sync_streaming(httpx_mock: HTTPXMock):    httpx_mock.add_response(stream=IteratorStream([b&quot;part 1&quot;, b&quot;part 2&quot;]))    with httpx.Client() as client:        with client.stream(method=&quot;GET&quot;, url=&quot;https://test_url&quot;) as response:            assert list(response.iter_raw()) == [b&quot;part 1&quot;, b&quot;part 2&quot;]@pytest.mark.asyncioasync def test_async_streaming(httpx_mock: HTTPXMock):    httpx_mock.add_response(stream=IteratorStream([b&quot;part 1&quot;, b&quot;part 2&quot;]))    async with httpx.AsyncClient() as client:        async with client.stream(method=&quot;GET&quot;, url=&quot;https://test_url&quot;) as response:            assert [part async for part in response.aiter_raw()] == [b&quot;part 1&quot;, b&quot;part 2&quot;]    ```### Add multipart responseUse the httpx `MultipartStream` via the `stream` parameter to send a multipart response.Reach out to `httpx` developers if you need this publicly exposed as [this is not a standard use case](https://github.com/encode/httpx/issues/872#issuecomment-633584819).```pythonimport httpxfrom httpx._multipart import MultipartStreamfrom pytest_httpx import HTTPXMockdef test_multipart_body(httpx_mock: HTTPXMock):    httpx_mock.add_response(stream=MultipartStream(data={&quot;key1&quot;: &quot;value1&quot;}, files={&quot;file1&quot;: b&quot;content of file 1&quot;}, boundary=b&quot;2256d3a36d2a61a1eba35a22bee5c74a&quot;))    with httpx.Client() as client:        assert client.get(&quot;https://test_url&quot;).text == '''--2256d3a36d2a61a1eba35a22bee5c74a\rContent-Disposition: form-data; name=&quot;key1&quot;\r\rvalue1\r--2256d3a36d2a61a1eba35a22bee5c74a\rContent-Disposition: form-data; name=&quot;file1&quot;; filename=&quot;upload&quot;\rContent-Type: application/octet-stream\r\rcontent of file 1\r--2256d3a36d2a61a1eba35a22bee5c74a--\r'''    ```### Add non 200 responseUse `status_code` parameter to specify the HTTP status code of the response.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_status_code(httpx_mock: HTTPXMock):    httpx_mock.add_response(status_code=404)    with httpx.Client() as client:        assert client.get(&quot;https://test_url&quot;).status_code == 404```### Reply with custom headersUse `headers` parameter to specify the extra headers of the response.Any valid httpx headers type is supported, you can submit headers as a dict (str or bytes), a list of 2-tuples (str or bytes) or a `httpx.Header` instance.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_headers_as_str_dict(httpx_mock: HTTPXMock):    httpx_mock.add_response(headers={&quot;X-Header1&quot;: &quot;Test value&quot;})    with httpx.Client() as client:        assert client.get(&quot;https://test_url&quot;).headers[&quot;x-header1&quot;] == &quot;Test value&quot;def test_headers_as_str_tuple_list(httpx_mock: HTTPXMock):    httpx_mock.add_response(headers=[(&quot;X-Header1&quot;, &quot;Test value&quot;)])    with httpx.Client() as client:        assert client.get(&quot;https://test_url&quot;).headers[&quot;x-header1&quot;] == &quot;Test value&quot;def test_headers_as_httpx_headers(httpx_mock: HTTPXMock):    httpx_mock.add_response(headers=httpx.Headers({b&quot;X-Header1&quot;: b&quot;Test value&quot;}))    with httpx.Client() as client:        assert client.get(&quot;https://test_url&quot;).headers[&quot;x-header1&quot;] == &quot;Test value&quot;```#### Reply with cookiesCookies are sent in the `set-cookie` HTTP header.You can then send cookies in the response by setting the `set-cookie` header with [the value following key=value format]((https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie)).```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_cookie(httpx_mock: HTTPXMock):    httpx_mock.add_response(headers={&quot;set-cookie&quot;: &quot;key=value&quot;})    with httpx.Client() as client:        response = client.get(&quot;https://test_url&quot;)    assert dict(response.cookies) == {&quot;key&quot;: &quot;value&quot;}def test_cookies(httpx_mock: HTTPXMock):    httpx_mock.add_response(headers=[(&quot;set-cookie&quot;, &quot;key=value&quot;), (&quot;set-cookie&quot;, &quot;key2=value2&quot;)])    with httpx.Client() as client:        response = client.get(&quot;https://test_url&quot;)    assert dict(response.cookies) == {&quot;key&quot;: &quot;value&quot;, &quot;key2&quot;: &quot;value2&quot;}```### Add HTTP/2.0 responseUse `http_version` parameter to specify the HTTP protocol version of the response.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_http_version(httpx_mock: HTTPXMock):    httpx_mock.add_response(http_version=&quot;HTTP/2.0&quot;)    with httpx.Client() as client:        assert client.get(&quot;https://test_url&quot;).http_version == &quot;HTTP/2.0&quot;```## Add callbacksYou can perform custom manipulation upon request reception by registering callbacks.Callback should expect one parameter, the received [`httpx.Request`](https://www.python-httpx.org/api/#request).If all callbacks are not executed during test execution, the test case will fail at teardown.This behavior can be disabled thanks to the `assert_all_responses_were_requested` fixture:```pythonimport pytest@pytest.fixturedef assert_all_responses_were_requested() -&gt; bool:    return False```Note that callbacks are considered as responses, and thus are [selected the same way](#how-response-is-selected).### Dynamic responsesCallback should return a `httpx.Response`.```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_dynamic_response(httpx_mock: HTTPXMock):    def custom_response(request: httpx.Request):        return httpx.Response(            status_code=200, json={&quot;url&quot;: str(request.url)},        )    httpx_mock.add_callback(custom_response)    with httpx.Client() as client:        response = client.get(&quot;https://test_url&quot;)        assert response.json() == {&quot;url&quot;: &quot;https://test_url&quot;}```Alternatively, callbacks can also be asynchronous.As in the following sample simulating network latency on some responses only.```pythonimport asyncioimport httpximport pytestfrom pytest_httpx import HTTPXMock@pytest.mark.asyncioasync def test_dynamic_async_response(httpx_mock: HTTPXMock):    async def simulate_network_latency(request: httpx.Request):        await asyncio.sleep(1)        return httpx.Response(            status_code=200, json={&quot;url&quot;: str(request.url)},        )    httpx_mock.add_callback(simulate_network_latency)    httpx_mock.add_response()    async with httpx.AsyncClient() as client:        responses = await asyncio.gather(            # Response will be received after one second            client.get(&quot;https://test_url&quot;),            # Response will instantly be received (1 second before the first request)            client.get(&quot;https://test_url&quot;)        )```### Raising exceptionsYou can simulate HTTPX exception throwing by raising an exception in your callback or use `httpx_mock.add_exception` with the exception instance.This can be useful if you want to assert that your code handles HTTPX exceptions properly.```pythonimport httpximport pytestfrom pytest_httpx import HTTPXMockdef test_exception_raising(httpx_mock: HTTPXMock):    httpx_mock.add_exception(httpx.ReadTimeout(&quot;Unable to read within timeout&quot;))        with httpx.Client() as client:        with pytest.raises(httpx.ReadTimeout):            client.get(&quot;https://test_url&quot;)```Note that default behavior is to send an `httpx.TimeoutException` in case no response can be found. You can then test this kind of exception this way:```pythonimport httpximport pytestfrom pytest_httpx import HTTPXMockdef test_timeout(httpx_mock: HTTPXMock):    with httpx.Client() as client:        with pytest.raises(httpx.TimeoutException):            client.get(&quot;https://test_url&quot;)```## Check sent requestsThe best way to ensure the content of your requests is still to use the `match_headers` and / or `match_content` parameters when adding a response.In the same spirit, ensuring that no request was issued does not necessarily requires any code.In any case, you always have the ability to retrieve the requests that were issued.As in the following samples:```pythonimport httpxfrom pytest_httpx import HTTPXMockdef test_many_requests(httpx_mock: HTTPXMock):    httpx_mock.add_response()    with httpx.Client() as client:        response1 = client.get(&quot;https://test_url&quot;)        response2 = client.get(&quot;https://test_url&quot;)    requests = httpx_mock.get_requests()def test_single_request(httpx_mock: HTTPXMock):    httpx_mock.add_response()    with httpx.Client() as client:        response = client.get(&quot;https://test_url&quot;)    request = httpx_mock.get_request()def test_no_request(httpx_mock: HTTPXMock):    assert not httpx_mock.get_request()```### How requests are selectedYou can add criteria so that requests will be returned only in case of a more specific matching.#### Matching on URL`url` parameter can either be a string, a python [re.Pattern](https://docs.python.org/3/library/re.html) instance or a [httpx.URL](https://www.python-httpx.org/api/#url) instance.Matching is performed on the full URL, query parameters included.#### Matching on HTTP methodUse `method` parameter to specify the HTTP method (POST, PUT, DELETE, PATCH, HEAD) of the requests to retrieve.`method` parameter must be a string. It will be upper-cased, so it can be provided lower cased.Matching is performed on equality.#### Matching on HTTP headersUse `match_headers` parameter to specify the HTTP headers executing the callback.Matching is performed on equality for each provided header.#### Matching on HTTP bodyUse `match_content` parameter to specify the full HTTP body executing the callback.Matching is performed on equality.## Do not mock some requestsBy default, `pytest-httpx` will mock every request.But, for instance, in case you want to write integration tests with other servers, you might want to let some requests go through.To do so, you can use the `non_mocked_hosts` fixture:```pythonimport pytest@pytest.fixturedef non_mocked_hosts() -&gt; list:    return [&quot;my_local_test_host&quot;, &quot;my_other_test_host&quot;]```Every other requested hosts will be mocked as in the following example```pythonimport pytestimport httpx@pytest.fixturedef non_mocked_hosts() -&gt; list:    return [&quot;my_local_test_host&quot;]def test_partial_mock(httpx_mock):    httpx_mock.add_response()    with httpx.Client() as client:        # This request will NOT be mocked        response1 = client.get(&quot;https://www.my_local_test_host/sub?param=value&quot;)        # This request will be mocked        response2 = client.get(&quot;https://test_url&quot;)```## Migrating to pytest-httpxHere is how to migrate from well-known testing libraries to `pytest-httpx`.### From responses| Feature           | responses                  | pytest-httpx                ||:------------------|:---------------------------|:----------------------------|| Add a response    | `responses.add()`          | `httpx_mock.add_response()` || Add a callback    | `responses.add_callback()` | `httpx_mock.add_callback()` || Retrieve requests | `responses.calls`          | `httpx_mock.get_requests()` |#### Add a response or a callbackUndocumented parameters means that they are unchanged between `responses` and `pytest-httpx`.Below is a list of parameters that will require a change in your code.| Parameter            | responses                           | pytest-httpx                                                         ||:---------------------|:------------------------------------|:---------------------------------------------------------------------|| method               | `method=responses.GET`              | `method=&quot;GET&quot;`                                                       || body (as bytes)      | `body=b&quot;sample&quot;`                    | `content=b&quot;sample&quot;`                                                  || body (as str)        | `body=&quot;sample&quot;`                     | `text=&quot;sample&quot;`                                                      || status code          | `status=201`                        | `status_code=201`                                                    || headers              | `adding_headers={&quot;name&quot;: &quot;value&quot;}`  | `headers={&quot;name&quot;: &quot;value&quot;}`                                          || content-type header  | `content_type=&quot;application/custom&quot;` | `headers={&quot;content-type&quot;: &quot;application/custom&quot;}`                     || Match the full query | `match_querystring=True`            | The full query is always matched when providing the `url` parameter. |Sample adding a response with `responses`:```pythonfrom responses import RequestsMockdef test_response(responses: RequestsMock):    responses.add(        method=responses.GET,        url=&quot;https://test_url&quot;,        body=b&quot;This is the response content&quot;,        status=400,    )```Sample adding the same response with `pytest-httpx`:```pythonfrom pytest_httpx import HTTPXMockdef test_response(httpx_mock: HTTPXMock):    httpx_mock.add_response(        method=&quot;GET&quot;,        url=&quot;https://test_url&quot;,        content=b&quot;This is the response content&quot;,        status_code=400,    )```### From aioresponses| Feature        | aioresponses            | pytest-httpx                               ||:---------------|:------------------------|:-------------------------------------------|| Add a response | `aioresponses.method()` | `httpx_mock.add_response(method=&quot;METHOD&quot;)` || Add a callback | `aioresponses.method()` | `httpx_mock.add_callback(method=&quot;METHOD&quot;)` |#### Add a response or a callbackUndocumented parameters means that they are unchanged between `responses` and `pytest-httpx`.Below is a list of parameters that will require a change in your code.| Parameter       | responses            | pytest-httpx        ||:----------------|:---------------------|:--------------------|| body (as bytes) | `body=b&quot;sample&quot;`     | `content=b&quot;sample&quot;` || body (as str)   | `body=&quot;sample&quot;`      | `text=&quot;sample&quot;`     || body (as JSON)  | `payload=[&quot;sample&quot;]` | `json=[&quot;sample&quot;]`   || status code     | `status=201`         | `status_code=201`   |Sample adding a response with `aioresponses`:```pythonimport pytestfrom aioresponses import aioresponses@pytest.fixturedef mock_aioresponse():    with aioresponses() as m:        yield mdef test_response(mock_aioresponse):    mock_aioresponse.get(        url=&quot;https://test_url&quot;,        body=b&quot;This is the response content&quot;,        status=400,    )```Sample adding the same response with `pytest-httpx`:```pythondef test_response(httpx_mock):    httpx_mock.add_response(        method=&quot;GET&quot;,        url=&quot;https://test_url&quot;,        content=b&quot;This is the response content&quot;,        status_code=400,    )```</longdescription>
</pkgmetadata>