<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># aiothrottler [![CircleCI](https://circleci.com/gh/michalc/aiothrottler.svg?style=svg)](https://circleci.com/gh/michalc/aiothrottler) [![Test Coverage](https://api.codeclimate.com/v1/badges/e52e294a919c8974c133/test_coverage)](https://codeclimate.com/github/michalc/aiothrottler/test_coverage)Throttler for asyncio Python## Installation```bashpip install aiothrottler```## UsageCreate a shared `Throttler`, passing a minimum interval, e.g. `0.5` seconds```pythonfrom aiothrottler import Throttlerthrottler = Throttler(min_interval=0.5)```and then just before the piece(s) of code to be throttled, _call_ this and `await` its result.```pythonawait throttler()# There will be a gap of at least 0.5 seconds# between executions reaching this line```## Example: multiple tasks throttled```pythonimport asyncioimport timefrom aiothrottler import Throttlerasync def main():    throttler = Throttler(min_interval=0.5)    await asyncio.gather(*[        worker(throttler) for _ in range(10)    ])async def worker(throttler):    await throttler()    # Interval of at least 0.5 seconds between prints    # even though all workers started together    print(time.time())loop = asyncio.get_event_loop()loop.run_until_complete(main())loop.close()```## Example: single task throttled/smoothed```pythonimport asyncioimport randomimport timefrom aiothrottler import Throttlerasync def main():    throttler = Throttler(min_interval=0.5)    for _ in range(10):        await throttler()        # Interval of at least 0.5 seconds between prints        # even though each sleep is random        print(time.time())        await asyncio.sleep(random.random())loop = asyncio.get_event_loop()loop.run_until_complete(main())loop.close()```## Differences to alternatives- The API features a function to call to `await` its result [some use a context manager]- The API is imperative [some use a functional approach/higher-order function]- No polling is used [some use polling internally]- A _minimum interval between resolutions_ is used to throttle [rather that a _max resolutions per time interval_, which can cause an irregular pattern of resolutions]- The tests cover edge cases, such as asserting on throttling after tasks being throttled have been cancelled [some alternatives do not]</longdescription>
</pkgmetadata>