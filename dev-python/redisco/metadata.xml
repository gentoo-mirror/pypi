<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=======Redisco=======Python Containers and Simple Models for RedisDescription-----------Redisco allows you to store objects in Redis_. It is inspired by the Ruby libraryOhm_ and its design and code are loosely based on Ohm and the Django ORM.It is built on top of redis-py_. It includes container classes that alloweasier access to Redis sets, lists, and sorted sets.Installation------------Redisco requires redis-py 2.0.0 so get it first.    pip install redisThen install redisco.    pip install rediscoModels------::    from redisco import models    class Person(models.Model):        name = models.Attribute(required=True)        created_at = models.DateTimeField(auto_now_add=True)        fave_colors = models.ListField(str)    &gt;&gt;&gt; person = Person(name=&quot;Conchita&quot;)    &gt;&gt;&gt; person.is_valid()    True    &gt;&gt;&gt; person.save()    True    &gt;&gt;&gt; conchita = Person.objects.filter(name='Conchita')[0]    &gt;&gt;&gt; conchita.name    'Conchita'    &gt;&gt;&gt; conchita.created_at    datetime.datetime(2010, 5, 24, 16, 0, 31, 954704)Model Attributes----------------Attribute    Stores unicode strings. If used for large bodies of text,    turn indexing of this field off by setting indexed=True.IntegerField    Stores an int. Ints are stringified using unicode() before saving to    Redis.Counter    An IntegerField that can only be accessed via Model.incr and Model.decr.DateTimeField    Can store a DateTime object. Saved in the Redis store as a float.DateField    Can store a Date object. Saved in Redis as a float.FloatField    Can store floats.BooleanField    Can store bools. Saved in Redis as 1's and 0's.ReferenceField    Can reference other redisco model.ListField    Can store a list of unicode, int, float, as well as other redisco models.Attribute Options-----------------required    If True, the attirbute cannot be None or empty. Strings are stripped to    check if they are empty. Default is False.default    Sets the default value of the attribute. Default is None.indexed    If True, redisco will create index entries for the attribute. Indexes    are used in filtering and ordering results of queries. For large bodies    of strings, this should be set to False. Default is True.validator    Set this to a callable that accepts two arguments -- the field name and    the value of the attribute. The callable should return a list of tuples    with the first item is the field name, and the second item is the error.unique    The field must be unique. Default is False.DateField and DateTimeField Optionsauto_now_add    Automatically set the datetime/date field to now/today when the object    is first created. Default is False.auto_now    Automatically set the datetime/date field to now/today everytime the object    is saved. Default is False.Saving and Validating---------------------To save an object, call its save method. This returns True on success (i.e. whenthe object is valid) and False otherwise.Calling Model.is_valid will validate the attributes and lists. Model.is_validis called when the instance is being saved. When there are invalid fields,Model.errors will hold the list of tuples containing the invalid fields andthe reason for its invalidity. E.g.[('name', 'required'),('name', 'too short')]Fields can be validated using the validator argument of the attribute. Justpass a callable that accepts two arguments -- the field name and the valueof the attribute. The callable should return a list of errors.Model.validate will also be called before saving the instance. Override itto validate instances not related to attributes.::    def not_me(field_name, value):        if value == 'Me':            return ((field_name, 'it is me'),)    class Person(models.Model):        name = models.Attribute(required=True, validator=not_me)        age = models.IntegerField()        def validate(self):            if self.age and self.age &lt; 21:                self._errors.append(('age', 'below 21'))    &gt;&gt;&gt; person = Person(name='Me')    &gt;&gt;&gt; person.is_valid()    False    &gt;&gt;&gt; person.errors    [('name', 'it is me')]Queries-------Queries are executed using a manager, accessed via the objects classattribute.::    Person.objects.all()    Person.objects.filter(name='Conchita')    Person.objects.filter(name='Conchita').first()    Person.objects.all().order('name')    Person.objects.filter(fave_colors='Red')Ranged Queries--------------Redisco has a limited support for queries involving ranges -- it can onlyfilter fields that are numeric, i.e. DateField, DateTimeField, IntegerField,and FloatField. The zfilter method of the manager is used for these queries.::    Person.objects.zfilter(created_at__lt=datetime(2010, 4, 20, 5, 2, 0))    Person.objects.zfilter(created_at__gte=datetime(2010, 4, 20, 5, 2, 0))    Person.objects.zfilter(created_at__in=(datetime(2010, 4, 20, 5, 2, 0), datetime(2010, 5, 1)))Containers----------Redisco has three containers that roughly match Redis's supported datastructures: lists, sets, sorted set. Anything done to the container ispersisted to Redis.Sets    &gt;&gt;&gt; from redisco.containers import Set    &gt;&gt;&gt; s = Set('myset')    &gt;&gt;&gt; s.add('apple')    &gt;&gt;&gt; s.add('orange')    &gt;&gt;&gt; s.members    set(['orange', 'apple'])    &gt;&gt;&gt; t = Set('nset')    &gt;&gt;&gt; t.add('kiwi')    &gt;&gt;&gt; t.add('guava')    &gt;&gt;&gt; t.members    set(['kiwi', 'guava'])    &gt;&gt;&gt; s.update(t)    &gt;&gt;&gt; s.members    set(['kiwi', 'orange', 'guava', 'apple'])Lists    &gt;&gt;&gt; import redis    &gt;&gt;&gt; from redisco.containers import List    &gt;&gt;&gt; l = List('alpha')    &gt;&gt;&gt; l.append('a')    &gt;&gt;&gt; l.append('b')    &gt;&gt;&gt; l.append('c')    &gt;&gt;&gt; 'a' in l    True    &gt;&gt;&gt; 'd' in l    False    &gt;&gt;&gt; len(l)    3    &gt;&gt;&gt; l.index('b')    1    &gt;&gt;&gt; l.members    ['a', 'b', 'c']Sorted Sets    &gt;&gt;&gt; zset = SortedSet('zset')    &gt;&gt;&gt; zset.members    ['d', 'a', 'b', 'c']    &gt;&gt;&gt; 'e' in zset    False    &gt;&gt;&gt; 'a' in zset    True    &gt;&gt;&gt; zset.rank('d')    0    &gt;&gt;&gt; zset.rank('b')    2    &gt;&gt;&gt; zset[1]    'a'    &gt;&gt;&gt; zset.add('f', 200)    &gt;&gt;&gt; zset.members    ['d', 'a', 'b', 'c', 'f']    &gt;&gt;&gt; zset.add('d', 99)    &gt;&gt;&gt; zset.members    ['a', 'b', 'c', 'd', 'f']Dicts/Hashes    &gt;&gt;&gt; h = cont.Hash('hkey')    &gt;&gt;&gt; len(h)    0    &gt;&gt;&gt; h['name'] = &quot;Richard Cypher&quot;    &gt;&gt;&gt; h['real_name'] = &quot;Richard Rahl&quot;    &gt;&gt;&gt; h    &lt;Hash 'hkey' {'name': 'Richard Cypher', 'real_name': 'Richard Rahl'}&gt;    &gt;&gt;&gt; h.dict    {'name': 'Richard Cypher', 'real_name': 'Richard Rahl'}Additional Info on Containers-----------------------------Some methods of the Redis client that require the key as the first argumentcan be accessed from the container itself.    &gt;&gt;&gt; l = List('mylist')    &gt;&gt;&gt; l.lrange(0, -1)    0    &gt;&gt;&gt; l.rpush('b')    &gt;&gt;&gt; l.rpush('c')    &gt;&gt;&gt; l.lpush('a')    &gt;&gt;&gt; l.lrange(0, -1)    ['a', 'b', 'c']    &gt;&gt;&gt; h = Hash('hkey')    &gt;&gt;&gt; h.hset('name', 'Richard Rahl')    &gt;&gt;&gt; h    &lt;Hash 'hkey' {'name': 'Richard Rahl'}&gt;Connecting to Redis-------------------All models and containers use a global Redis client object tointeract with the key-value storage. By default, it connectsto localhost:6379, selecting db 0. If you wish to specify settings:::    import redisco    redisco.connection_setup(host='localhost', port=6380, db=10)The arguments to connect are simply passed to the redis.Redis init method.For the containers, you can specify a second argument as the Redis client.That client object will be used instead of the default.    &gt;&gt;&gt; import redis    &gt;&gt;&gt; r = redis.Redis(host='localhost', port=6381)    &gt;&gt;&gt; Set('someset', r)Credits-------Most of the concepts are taken from `Soveran`_'s Redis related Ruby libraries.cyx_ for sharing his expertise in indexing in Redis.Django, of course, for the popular model API... _Redis: http://code.google.com/p/redis/.. _Ohm: http://github.com/soveran/ohm/.. _redis-py: http://github.com/andymccurdy/redis-py/.. _`Soveran`: http://github.com/soveran.. _cyx: http://github.com/cyx</longdescription>
</pkgmetadata>