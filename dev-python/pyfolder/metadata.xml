<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>==============pyfolder 0.0.2==============`PyFolder` is a package for managing a filesystem folders as a dictionary... image:: https://badge.fury.io/py/pyfolder.svg    :target: https://badge.fury.io/py/pyfolder.. image:: https://travis-ci.org/ipazc/pyfolder.svg?branch=master    :target: https://travis-ci.org/ipazc/pyfolder.. image:: https://coveralls.io/repos/github/ipazc/pyfolder/badge.svg?branch=master    :target: https://coveralls.io/github/ipazc/pyfolder?branch=master.. image:: https://landscape.io/github/ipazc/pyfolder/master/landscape.svg?style=flat   :target: https://landscape.io/github/ipazc/pyfolder/master   :alt: Code HealthInstallation============Currently it is only supported **Python 3.4.1** onwards:.. code:: bash    sudo pip3 install pyfolderExample=======.. code:: python    &gt;&gt;&gt; from pyfolder import PyFolder    &gt;&gt;&gt;     &gt;&gt;&gt; pyfolder = PyFolder(&quot;/path/to/folder&quot;)    &gt;&gt;&gt; pyfolder[&quot;file.txt&quot;] = &quot;hello, this is going to be instantly the content of this file.&quot;Basic Usage===========`PyFolder` can easily store or read content from the filesystem. The usage is the same as a normal dictionary:* **Create a file with specific binary content:**.. code:: python    &gt;&gt;&gt; from pyfolder import PyFolder    &gt;&gt;&gt;     &gt;&gt;&gt; pyfolder = PyFolder(&quot;/path/to/folder&quot;)    &gt;&gt;&gt; pyfolder['file.bin'] = b&quot;Content as bytes&quot;    &gt;&gt;&gt; pyfolder['file.txt'] = &quot;Content as text&quot;    &gt;&gt;&gt; pyfolder['file.json'] = {&quot;content&quot;: &quot;Content as JSON&quot;}`PyFolder` automatically detects the kind of content to store.It is also possible to reference the creation of a file in relative file URI notation:.. code:: python    &gt;&gt;&gt; pyfolder[&quot;folder1/folder2/file.txt&quot;] = &quot;content&quot;If folder specified doesn't exist, by default it will be created automatically unless the flag `auto_create_folder` is set to `False` during instantiation:.. code:: python    &gt;&gt;&gt; pyfolder = PyFolder(&quot;/path/to/folder&quot;, auto_create_folder=False)Note that &quot;.&quot; or &quot;..&quot; chars are not allowed in URI notation, it must be relative URIs to the root.* **Get specific content:**.. code:: python    &gt;&gt;&gt; pyfolder = PyFolder(&quot;/path/to/folder&quot;)    &gt;&gt;&gt; pyfolder['file.bin']    b&quot;Content as bytes&quot;    &gt;&gt;&gt; pyfolder['file.txt']    &quot;Content as text&quot;    &gt;&gt;&gt; pyfolder['file.json']    {&quot;content&quot;: &quot;Content as JSON&quot;}    &gt;&gt;&gt; pyfolder['folder1/folder2/file.bin']    b&quot;Other content&quot;By default `PyFolder` will attempt to load the content with the best interpreter it has, based on the file extension. If no interpreter is found fora content, it will return the content in bytes format. This behaviour can be disabled with the flag `interpret=False` during instantiation:.. code:: python    &gt;&gt;&gt; pyfolder = PyFolder(&quot;/path/to/folder&quot;, interpret=False)* **Edit content:**`PyFolder` won't allow modification or removal of elements unless the flag `allow_override` is specified during instantiation:.. code:: python    &gt;&gt;&gt; pyfolder = PyFolder(&quot;/path/to/folder&quot;, allow_override=True)    &gt;&gt;&gt; pyfolder['file.bin'] = b&quot;replaced_content_bytes&quot;* **Remove content:**.. code:: python    &gt;&gt;&gt; del pyfolder['file.bin']Note that a folder can also be removed:.. code:: python    &gt;&gt;&gt; del pyfolder['folder1']    &gt;&gt;&gt; del pyfolder['.']  # deletes PyFolder root folderBy default PyFolder won't remove a folder unless its content is empty. In order to be able to remove folders without restriction, enable the flag `allow_remove_folders_with_content`.. code:: python    &gt;&gt;&gt; pyfolder = PyFolder(&quot;/path/to/folder&quot;, allow_remove_folders_with_content=True)* **Iterate over the files:**By default `PyFolder` allows iteration over files, including the folders:.. code:: python    &gt;&gt;&gt; for file_name in pyfolder:    &gt;&gt;&gt;    print(file_name)If it is wanted to access also the content, it can be done with the `items()` method:.. code:: python    &gt;&gt;&gt; for file_name, content in pyfolder.items():    &gt;&gt;&gt;    print(file_name, content)If only files are wanted, the `files()` method exists to serve the purpose:.. code:: python    &gt;&gt;&gt; for file_name in pyfolder.files()    ...    &gt;&gt;&gt; for file_name, content in pyfolder.files_items()* **Iterate over folders:**.. code:: python    &gt;&gt;&gt; for folder_name in pyfolder.folders():    ...it is also possible to iterate over the folder name and its content at the same time:.. code:: python    &gt;&gt;&gt; for folder_name, folder_content in pyfolder.folders_items():    ...In `PyFolder`, each folder is a `PyFolder` object. It is perfectly possible to nest folders as follows:.. code:: python    &gt;&gt;&gt; pyfolder[&quot;folder1&quot;][&quot;folder2&quot;]    &gt;&gt;&gt; pyfolder[&quot;folder1/folder2&quot;]  # Equivalent in relative URI notation* **Search for files:**`PyFolder` eases the search of a file/folder by matching a name. It will return the list of relative URIs of the file-names found:.. code:: python    &gt;&gt;&gt; pyfolder.index(&quot;name.bin&quot;)    &gt;&gt;&gt; ['path/to/name.bin', 'path2/to/name.bin']LICENSE=======It is released under the MIT license.</longdescription>
</pkgmetadata>