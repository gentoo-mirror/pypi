<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># TextRL: Text Generation with Reinforcement Learning&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://pypi.org/project/textrl/&quot;&gt;        &lt;img alt=&quot;PyPI&quot; src=&quot;https://img.shields.io/pypi/v/textrl&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://github.com/voidful/tfkit&quot;&gt;        &lt;img alt=&quot;Download&quot; src=&quot;https://img.shields.io/pypi/dm/textrl&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://github.com/voidful/tfkit&quot;&gt;        &lt;img alt=&quot;Last Commit&quot; src=&quot;https://img.shields.io/github/last-commit/voidful/textrl&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://www.codefactor.io/repository/github/voidful/textrl&quot;&gt;        &lt;img src=&quot;https://www.codefactor.io/repository/github/voidful/textrl/badge&quot; alt=&quot;CodeFactor&quot; /&gt;    &lt;/a&gt;    &lt;a href=&quot;https://github.com/voidful/textrl&quot;&gt;        &lt;img src=&quot;https://visitor-badge.glitch.me/badge?page_id=voidful.textrl&quot; alt=&quot;Visitor&quot; /&gt;    &lt;/a&gt;&lt;/p&gt;TextRL is a Python library that aims to improve text generation using reinforcement learning, building upon Hugging Face's Transformers, PFRL, and OpenAI GYM. TextRL is designed to be easily customizable and can be applied to various text-generation models.![TextRL](https://github.com/voidful/TextRL/raw/main/img/Designer.png)## Table of Contents- [Introduction](#introduction)- [Examples](#examples)  - [GPT-2 Example](#gpt-2-example)  - [FLAN-T5 Example](#flan-t5-example)  - [Bigscience/BLOOMZ-7B1-MT Example](#bigsciencebloomz-7b1-mt-example)  - [176B BLOOM Example](#176b-bloom-example)  - [Controllable Generation via RL Example](#controllable-generation-via-rl-example)- [Installation](#installation)  - [Pip Install](#pip-install)  - [Build from Source](#build-from-source)- [Usage](#usage)  - [Initialize Agent and Environment](#initialize-agent-and-environment)  - [Setup Reward Function for Environment](#setup-reward-function-for-environment)  - [Prepare for Training](#prepare-for-training)  - [Training](#training)- [Dump Model](#dump-trained-model-to-huggingfaces-model)- [Key Parameters for RL Training](#key-parameters-for-rl-training)## IntroductionTextRL utilizes reinforcement learning to fine-tune text generation models. It is built upon the following libraries:- [Hugging Face's Transformers](https://github.com/huggingface/transformers)- [PFRL](https://github.com/pfnet/pfrl)- [OpenAI GYM](https://gym.openai.com)## Example - `gpt2`&lt;details&gt;&lt;summary&gt;CLICK ME&lt;/summary&gt;&lt;p&gt;#### GPT2 Example```pythonimport pfrlfrom textrl import TextRLEnv, TextRLActor, train_agent_with_evaluationfrom transformers import AutoModelForCausalLM, AutoTokenizerimport loggingimport syslogging.basicConfig(level=logging.INFO, stream=sys.stdout, format='')checkpoint = &quot;gpt2&quot;tokenizer = AutoTokenizer.from_pretrained(checkpoint)model = AutoModelForCausalLM.from_pretrained(checkpoint, torch_dtype=&quot;auto&quot;, device_map=&quot;auto&quot;)model = model.cuda()class MyRLEnv(TextRLEnv):    def get_reward(self, input_item, predicted_list, finish):  # predicted will be the list of predicted token        reward = [0]        if finish:            reward = [1]  # calculate reward score base on predicted_list        return rewardobservaton_list = [{&quot;input&quot;:&quot;explain how attention work in seq2seq model&quot;}]env = TextRLEnv(model, tokenizer, observation_input=observaton_list, max_length=20, compare_sample=2)actor = TextRLActor(env, model, tokenizer,                    act_deterministically=False,                    temperature=1.0,                    top_k=0,                    top_p=1.0,                    repetition_penalty=2)agent = actor.agent_ppo(update_interval=2, minibatch_size=2, epochs=10)print(actor.predict(observaton_list[0]))train_agent_with_evaluation(    agent,    env,    steps=100,    eval_n_steps=None,    eval_n_episodes=1,    eval_interval=2,    outdir='bloom—test',)print(actor.predict(observaton_list[0]))```&lt;/p&gt;&lt;/details&gt;## Example - `flan-t5`&lt;details&gt;&lt;summary&gt;CLICK ME&lt;/summary&gt;&lt;p&gt;#### Example Codecolabexample: [google/flan-t5-base](https://colab.research.google.com/drive/1DYHt0mi6cyl8ZTMJEkMNpsSZCCvR4jM1?usp=sharing)```pythonimport pfrlfrom textrl import TextRLEnv, TextRLActor, train_agent_with_evaluationfrom transformers import AutoModelForSeq2SeqLM, AutoTokenizerimport loggingimport syslogging.basicConfig(level=logging.INFO, stream=sys.stdout, format='')tokenizer = AutoTokenizer.from_pretrained(&quot;google/flan-t5-base&quot;)  model = AutoModelForSeq2SeqLM.from_pretrained(&quot;google/flan-t5-base&quot;)model.eval()model.cuda()sentiment = pipeline('sentiment-analysis',model=&quot;cardiffnlp/twitter-roberta-base-sentiment&quot;,tokenizer=&quot;cardiffnlp/twitter-roberta-base-sentiment&quot;,device=0,return_all_scores=True)class MyRLEnv(TextRLEnv):    def get_reward(self, input_item, predicted_list, finish): # predicted will be the list of predicted token      reward = 0      if finish or len(predicted_list[0]) &gt;= self.env_max_length:        predicted_text = tokenizer.convert_tokens_to_string(predicted_list[0])        # sentiment classifier        reward = sentiment(input_item['input']+predicted_text)[0][0]['score'] * 10      return rewardobservaton_list = [{'input':'i think dogecoin is'}]env = MyRLEnv(model, tokenizer, observation_input=observaton_list, compare_sample=1)actor = TextRLActor(env,model,tokenizer,optimizer='adamw',                    temperature=0.8,                    top_k=100,                    top_p=0.85,)agent = actor.agent_ppo(update_interval=50, minibatch_size=3, epochs=10,lr=3e-4)print(actor.predict(observaton_list[0]))pfrl.experiments.train_agent_with_evaluation(    agent,    env,    steps=3000,    eval_n_steps=None,    eval_n_episodes=1,           train_max_episode_len=100,      eval_interval=10,    outdir='checkpoint', )agent.load(&quot;./checkpoint/best&quot;)print(actor.predict(observaton_list[0]))```&lt;/p&gt;&lt;/details&gt;## Example - `bigscience/bloomz-7b1-mt`&lt;details&gt;&lt;summary&gt;CLICK ME&lt;/summary&gt;&lt;p&gt;#### bloomz-7b1-mt Example```pythonimport pfrlfrom textrl import TextRLEnv, TextRLActor, train_agent_with_evaluationfrom transformers import AutoModelForCausalLM, AutoTokenizerimport loggingimport syslogging.basicConfig(level=logging.INFO, stream=sys.stdout, format='')checkpoint = &quot;bigscience/bloomz-7b1-mt&quot;tokenizer = AutoTokenizer.from_pretrained(checkpoint)model = AutoModelForCausalLM.from_pretrained(checkpoint, torch_dtype=&quot;auto&quot;, device_map=&quot;auto&quot;)model = model.cuda()class MyRLEnv(TextRLEnv):    def get_reward(self, input_item, predicted_list, finish):  # predicted will be the list of predicted token        reward = [0]        if finish:            reward = [1]  # calculate reward score base on predicted_list        return rewardobservaton_list = [{&quot;input&quot;:&quot;explain how attention work in seq2seq model&quot;}]env = TextRLEnv(model, tokenizer, observation_input=observaton_list, max_length=20, compare_sample=2)actor = TextRLActor(env, model, tokenizer,                    act_deterministically=False,                    temperature=1.0,                    top_k=0,                    top_p=1.0,                    repetition_penalty=2)agent = actor.agent_ppo(update_interval=2, minibatch_size=2, epochs=10)print(actor.predict(observaton_list[0]))train_agent_with_evaluation(    agent,    env,    steps=100,    eval_n_steps=None,    eval_n_episodes=1,    eval_interval=2,    outdir='bloom—test',)print(actor.predict(observaton_list[0]))```&lt;/p&gt;&lt;/details&gt;## Example - 176B BLOOM&lt;details&gt;&lt;summary&gt;CLICK ME&lt;/summary&gt;&lt;p&gt;#### bloomz-176B ExampleStrongly recommend contribute on public swarm to increase petals capacityhttps://github.com/bigscience-workshop/petalsinstall `pip install petals -U` first```pythonimport pfrlfrom textrl import TextRLEnv, TextRLActor, train_agent_with_evaluationfrom transformers import BloomTokenizerFastfrom petals import DistributedBloomForCausalLMimport loggingimport syslogging.basicConfig(level=logging.INFO, stream=sys.stdout, format='')MODEL_NAME = &quot;bigscience/bloom-petals&quot;tokenizer = BloomTokenizerFast.from_pretrained(MODEL_NAME)model = DistributedBloomForCausalLM.from_pretrained(MODEL_NAME)model = model.cuda()class MyRLEnv(TextRLEnv):    def get_reward(self, input_item, predicted_list, finish):  # predicted will be the list of predicted token        reward = [0]        if finish:            reward = [1]  # calculate reward score base on predicted_list        return rewardobservaton_list = [{&quot;input&quot;:&quot;explain how attention work in seq2seq model&quot;}]env = TextRLEnv(model, tokenizer, observation_input=observaton_list, max_length=20, compare_sample=2)actor = TextRLActor(env, model, tokenizer,                    act_deterministically=False,                    temperature=1.0,                    top_k=0,                    top_p=1.0,                    repetition_penalty=2)agent = actor.agent_ppo(update_interval=2, minibatch_size=2, epochs=10)print(actor.predict(observaton_list[0]))train_agent_with_evaluation(    agent,    env,    steps=100,    eval_n_steps=None,    eval_n_episodes=1,    eval_interval=2,    outdir='bloom—test',)print(actor.predict(observaton_list[0]))```&lt;/p&gt;&lt;/details&gt;## Example - Controllable generation via RL to let Elon Musk speak ill of DOGE&lt;details&gt;&lt;summary&gt;CLICK ME&lt;/summary&gt;&lt;p&gt;[Controllable generation via RL to let Elon Musk speak ill of DOGE](https://github.com/voidful/TextRL/blob/main/example/2022-12-10-textrl-elon-musk.ipynb)colabexample: [bigscience/bloom-560m](https://colab.research.google.com/drive/1ThSHtkfzC2dDc6JOdeCTthuDovTCheRf?usp=sharing)colabexmaple: [huggingtweets/elonmusk](https://colab.research.google.com/drive/149MG6uxu7CjMU1pXnYXfSvJ6HEdwcOFt?usp=sharing)before: `i think dogecoin is a great idea.`    after: `i think dogecoin is a great idea, but I think it is a little overused.`&lt;/p&gt;&lt;/details&gt;## Installation### pip install```bashpip install pfrl@git+https://github.com/voidful/pfrl.gitpip install textrl```### Build from sourcegit clone and cd into this project.```bashpip install -e .```## Usage### Initialize agent and environment```pythonimport torchfrom textrl import TextRLEnv, TextRLActor, train_agent_with_evaluationfrom transformers import AutoModelForCausalLM, AutoTokenizercheckpoint = &quot;bigscience/bloomz-7b1-mt&quot;tokenizer = AutoTokenizer.from_pretrained(checkpoint)model = AutoModelForCausalLM.from_pretrained(checkpoint, torch_dtype=&quot;auto&quot;, device_map=&quot;auto&quot;)model = model.cuda()```### Set up reward function for environment- predicted(list\[str]): will be the list of predicted tokens- finish(bool): whether the end of sentence has been reached or not```pythonclass MyRLEnv(TextRLEnv):    def get_reward(self, input_item, predicted_list, finish):        if finish:            reward = [0]  # calculate reward score based on predicted_list        return reward```### Prepare for training- observation\_list should be a list of all possible input strings for model training  Example: `observation_list = [{&quot;input&quot;:'testing sent 1'},{&quot;input&quot;:'testing sent 2'}]````pythonenv = MyRLEnv(model, tokenizer, observation_input=observation_list)actor = TextRLActor(env, model, tokenizer)agent = actor.agent_ppo(update_interval=10, minibatch_size=2000, epochs=20)```### Train```pythonn_episodes = 1000max_episode_len = 200  # max sentence lengthfor i in range(1, n_episodes + 1):    obs = env.reset()    R = 0    t = 0    while True:        action = agent.act(obs)        obs, reward, done, pred = env.step(action)        R += reward        t += 1        reset = t == max_episode_len        agent.observe(obs, reward, done, reset)        if done or reset:            break    if i % 10 == 0:        print('episode:', i, 'R:', R)    if i % 50 == 0:        print('statistics:', agent.get_statistics())print('Finished.')```Another way to train:```pythonimport loggingimport syslogging.basicConfig(level=logging.INFO, stream=sys.stdout, format='')train_agent_with_evaluation(    agent,    env,    steps=1000,    eval_n_steps=None,    eval_n_episodes=1500,    train_max_episode_len=50,    eval_interval=10000,    outdir='somewhere',)```### Prediction```pythonagent.load(&quot;somewhere/best&quot;)  # loading the best modelactor.predict(&quot;input text&quot;)```This updated usage section provides a comprehensive guide on how to initialize the agent and environment, set up the reward function for the environment, prepare for training, train the model, and make predictions. It also includes an alternative way to train the model using the `train_agent_with_evaluation` function.## Dump trained model to huggingface's model```shelltextrl-dump --model ./model_path_before_rl --rl ./rl_path --dump ./output_dir```## Key Parameters for RL TrainingTo finetune a language model using RL, you need to modify the reward function:```pythonfrom textrl import TextRLEnvclass MyRLEnv(TextRLEnv):    def get_reward(self, input_item, predicted_list, finish):        # input_item is the prompt input for the model, it will be one of your observation        # an observation will be a list of sentence of eg: ['inputted sentence','xxx','yyy']        # only the first input will feed to the model 'inputted sentence', and         # the remaining can be the reference for reward calculation        # predicted_list is the list of predicted sentences of RL model generated,        # it will be used for ranking reward calculation        # finish is the end of sentences flags, get_reward will be called during generating each word, and         # when finish is True, it means the sentence is finished, it will use for sentence level reward calculation.        # reward should be the list equal to the length of predicted_list        return reward```Parameters for sampling diverse examples:```pythonactor = TextRLActor(env, model, tokenizer,                    act_deterministically=False,  # select the max probability token for each step or not                    temperature=1,                # temperature for sampling                    compare_sample=2,             # num of sample to rank                    top_k=0,                      # top k sampling                    top_p=1.0,                    # top p sampling                    repetition_penalty=2)         # repetition penalty from CTRL paper (https://arxiv.org/abs/1909.05858)```When training a reinforcement learning (RL) model, several key parameters need to be tuned to ensure optimal performance. Here is a list of important parameters and their descriptions:1. **Update Interval**: This determines how often the RL agent updates its policy based on collected experiences. A smaller update interval means the agent learns more frequently from recent experiences, while a larger interval allows more experiences to accumulate before learning. In the example above, the update interval is set to 10.```pythonupdate_interval=10```2. **Minibatch Size**: The number of experiences sampled from the experience replay buffer to compute the gradient update. A larger minibatch size helps to stabilize learning and reduce variance, but at the cost of increased computational requirements.```pythonminibatch_size=2000```3. **Epochs**: The number of times the agent iterates through the entire minibatch to update its policy. More epochs can lead to better learning but may increase the risk of overfitting.```pythonepochs=20```4. **Discount Factor (Gamma)**: This parameter determines how much future rewards are discounted when calculating the expected return. A value closer to 1 makes the agent more farsighted, while a value closer to 0 makes the agent more focused on immediate rewards.```pythongamma=0.99```5. **Learning Rate**: The step size used for updating the policy. A larger learning rate allows for faster convergence but may lead to instability in learning, while a smaller learning rate ensures stable learning at the cost of slower convergence.```pythonlr=1e-4```6. **Epsilon**: A parameter used in the PPO algorithm to clip the policy ratio. This helps to control the magnitude of policy updates, preventing excessively large updates that can destabilize learning.```pythonepsilon=0.2```7. **Entropy Coefficient**: This parameter encourages exploration by adding a bonus reward for taking less certain actions. A higher entropy coefficient promotes more exploration, while a lower coefficient focuses the agent on exploiting known strategies.```pythonentropy_coef=0.01```8. **Training Steps**: The total number of steps the agent takes during training. More steps typically lead to better learning but may require more computational time.```pythonsteps=1000```9. **Evaluation Interval**: The number of training steps between evaluations. Increasing the evaluation interval reduces the computational time spent on evaluation, but it may also reduce the frequency at which you can monitor the agent's progress.```pythoneval_interval=10000```10. **Max Episode Length**: The maximum number of steps allowed in a single episode during training. This can prevent the agent from getting stuck in long, unproductive episodes.```pythontrain_max_episode_len=50```These parameters need to be carefully tuned based on the specific problem and environment to achieve the best performance. It is generally recommended to start with default values and then adjust them based on the observed learning behavior.</longdescription>
</pkgmetadata>