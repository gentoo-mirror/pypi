<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># netdimmCollection of routines written in Python for remotely controlling a SEGA Net Dimmattached to a Naomi, Triforce or Chihiro system. Originally based off of the oldtriforcetools.py script floating around the web, this has been upgraded to Python 3,fully typed and massively improved. It requires a minimum of Python 3.6 to operate.## NetDimmThe NetDimm class provides high-level access to a net dimm accessible from the network.It handles uploading and downloading data, querying status and changing modes of thenet dimm.### Default ConstructorTakes a single string containing thet IP of the net dimm you wish to connect to andmanages that connection. All query and update methods found in this class can becalled directly and they will connect to the net dimm, perform their action and thendisconnect. However, it can be faster to maintain that connection. For that, see the`connection()` context manager below. Optionally, the second argument (or keywordargument) version can be given. This is a `NetDimmVersionEnum` which allows you toset the version of the net dimm you are talking to. This matters in a few rare cases.Optionally, the third argument (or keyword argument) target can be given. This is a`NetDimmTargetEnum` which allows you to set the target the net dimm is talking to. Thismatters for default timeouts. Optionally, the forth argument (or keyword argument) logcan be given. This can either be a function in the form of`log(msg: str, *, newline: bool = True) -&gt; None` or it can be given the `print` function.In either case, if this is provided, various verbose information will be logged.Optionally, the firth argument (or keyword argument) timeout can be given. This shouldbe an integer representing the number of seconds before a send or receive should timeout when the net dimm does not talk. This is normally determined automatically givena correct target keyword but you can also specify it manually.### crc() static methodTakes either a bytes or a `FileBytes` object and runs a CRC over the entire contentsin the same way that the net dimm would CRC the same data. Use this to calculate whatthe expected CRC should be for a given chunk of data you might wish to upload to a netdimm or to compare against the CRC returned in an `info()` call to see if what youwant to send is already running on the net dimm.### connection() context managerTakes no arguments, and when run like `with inst.connection():` will manage the connectionto the net dimm for you. You do not need to use this function. However, if you are issuingmany commands to the net dimm in a row, it is much faster to wrapp all of those functioncalls in a connection in order to remove the time it takes to connect and disconnect betweenevery command.### info() methodReturns a `NetDimmInfo` containing information about the net dimm you have pointed at. The`NetDimmInfo` object has the following properties. The `current_game_crc` is an integerrepresenting the CRC of the game currently running on the net dimm. Compare it to the outputof the `crc()` static method for the same data. The `current_game_size` is an integerrepresenting the size in bytes of the game currently running on the net dimm. The`game_crc_status` property is a `CRCStatusEnum` representing the current status of theCRC on the system, such as `CRCStatusEnum.STATUS_VALID` or `CRCStatusEnum.STATUS_INVALID`.This allows you to check whether the net dimm thinks the onboard CRC matches the onboard data.The `memory_size` property is an integer representing the number of megabytes of RAM installedin the net dimm. The `available_game_memory` represents the maximum size in bytes of agame that may be stored on the net dimm. The `firmware_version` property is a`NetDimmVersionEnum` representing the version of the net dimm firmware running. Note thatwhen you call the `info()` method, the version property on your net dimm instance will beupdated accordingly.### send() methodSend a game to the net dimm. Takes a data argument which can either be bytes or `FileBytes`and sends it to the net dimm. This also takes care of setting the net dimm informationand setting the onbaord DES key. If you give the optional key argument, that key willbe used to encrypt the game data as well as set the crypto key on the net dimm. Bydefault you do not need to use this. If you give the optional boolean disable_crc_checkargument then the net dimm will not CRC the data after you send it and will instead bootdirectly into it. When this mode is set, the `game_crc_status` returned from the `info()`call will have a value of `CRCStatusEnum.STATUS_DISABLED`. If you give it the optionalprogress_callback argument in the form of a function that takes two integer parametersand returns nothing, then this function will call that function periodically with thecurrent send location and the send size in bytes to inform you of the send progress whichcan take awhile.### receive() methodReceive a previously sent game from the net dimm. Ensures that the game itself on the netdimm is valid and then downloads the entire contents before returning it as bytes. If thegame could not be retrieved because it has an invalid CRC or there is no game installed,this returns None. Much like the `send()` method, this takes an optional progress_callbackargument in the form of a function with two integer parameters and returning nothing. Ifthis is provided, the callack will be called periodically with the current location andreceive size of the game being downloaded.### send_chunk() methodSend a chunk of binary data to the net dimm, stored at an offset. Takes two parameters, thefirst being the integer offset from the beginning of the net dimm writeable memory to putthe binary data, and the second being either bytes or `FileBytes` and sends the entirechunk to that location. Note that this is not to be used to upload game data as it doesnot attempt to calculate or update the CRC. Using this to change data within the CRC'dsection of a valid sent game will cause it to become invalid on the next boot. If yousend data to a running game, you can subsequently read that data using the cartridgeread interface on running target.### receive_chunk() methodReceive a chunk of binary data from the net dimm. Takes two parameters, the first beingan integer offset from the beginning of the net dimm writeable memory to get the binarydata, and the second being an integer length in bytes of the amount of data to receive.Note that if you use the cartridge write interface on the running target to write datato the cart, it will be available to read using this function.### reboot() methodReboot the net dimm after sending a game in order to boot the game. This can be issued atany time, but it makes most sense to do so after finishing an upload.### peek() methodGiven an address as an integer and a type in the form of either `PeekPokeTypeEnum.TYPE_BYTE`,`PeekPokeTypeEnum.TYPE_SHORT` or `PeekPokeTypeEnum.TYPE_LONG`, attempts to read that sizeof data from that address from the target system running the net dimm. Returns the actualvalue or 0 if it could not be retrieved.### poke() methodGiven an address as an integer, a type in the form of either `PeekPokeTypeEnum.TYPE_BYTE`,`PeekPokeTypeEnum.TYPE_SHORT` or `PeekPokeTypeEnum.TYPE_LONG` and a data value, attemptsto write that size of data to that address on the target system running the net dimm.## Naomi Homebrew Messaging ProtocolThe netdimm module provides a series of functions that are capable of talking to aNaomi homebrew program through a net dimm. Both low level packet-based and slightlyhigher-level message-based functions are provided for you depending on your needs.They correspond to the functions implemented in `naomi/message/packet.h` and`naomi/message/message.h` respectively. The packet-based interface provides theability to read or write one packet at a time, read from or write to two scratchregisters and read from a configuration register. The message-based interfaceprovides the ability to send or receive optionally-compressed messages (binarydata with a type) which can be up to 64kb in size.The `MAX_MESSAGE_LENGTH` constant gives you the size that you should not exceedwhen sending messages, and the `MAX_PACKET_LENGTH` constant gives you the size youshould not exceed when sending packets.The `Message` class is available for you when sending and receiving messages. Itsconstructor takes a type argument which should be an integer in the range 0x0-0x7FFFand optionally a data argument containing up to MAX_MESSAGE_LENGTH bytes as themessage payload. The packet type is available on instantiated `Message` classesusing the `id` attribute, and optional data is available on the `data` attribute.Note that when a message contains no data, the `data` attribute will be Null.The protocol is entirely host-driven. The Naomi program will not discard or attemptto send or receive a packet or message without the host driving it. This is becausethe Naomi has no way of requesting a net dimm send a packet, but the host has theability to request peek and poke messages that are performed on the Naomi's mainRAM. Thus, it is your responsibility to call either `receive_packet` or `receive_message`in an event loop in order to keep the Naomi ROM's buffers from filling.### send_packetTakes an instantiated `NetDimm` class and a bytes object representing between 1and 253 bytes of data to send to the Naomi program. Returns True if the packetwas successfully sent or False otherwise.### receive_packetTakes an instantiated `NetDimm` class and attempts to receive a single packetbetween 1 and 253 bytes long from the Naomi program. If successful, the bytedata inside the packet will be returned. Otherwise, None is returned.### read_scratch1_registerAttempts to read the 32-bit scratch1 register (usable for anything you want).Returns the 32-bit value on success or None if the register could not be read.### read_scratch2_registerAttempts to read the 32-bit scratch2 register (usable for anything you want).Returns the 32-bit value on success or None if the register could not be read.### write_scratch1_registerAttempts to write an integer parameter to the 32-bit scratch1 register. Thereis no checking that this operation succeeded, though it generally does. If youwish to be sure, you can read back the contents.### write_scratch2_registerAttempts to write an integer parameter to the 32-bit scratch2 register. Thereis no checking that this operation succeeded, though it generally does. If youwish to be sure, you can read back the contents.### send_messageTakes an instantiated `NetDimm` class and an instance of `Message` and attemptsto send that message to a Naomi program. Raises `MessageException` on failureto send the message. This can happen if the Naomi program isn't running the messageprotocol or if the program has crashed.### receive_messageTakes an instantiated `NetDimm` class and attempts to receive a message from aNaomi program. Raises `MessageException ` on critical failures, such as malformedpackets or if the Naomi program isn't running the message protocol. Returns aninstance of `Message` representing the received message on success, and returnsNone if there was no message ready to receive.Note that correctly configured Naomi homebrew programs that have installed thestdio redirect hooks to send stdout and stderr to a communicating host will sendmessage of type `MESSAGE_HOST_STDOUT` and `MESSAGE_HOST_STDERR` when the respectivestreams have data. These are flushed when a newline is received and contain thatnewline in the data. To correctly display these, it is recommended to decode themas utf-8 data and display them verbatum.</longdescription>
</pkgmetadata>