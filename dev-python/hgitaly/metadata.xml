<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># HGitalyHGitaly is Gitaly server for Mercurial.## LoggingHGitaly is using the standard `logging` Python module, and the`loggingmod` Mercurial extension to emit logs from the Mercurial coreand other extensions. Therefore, the logging configuration is donefrom the Mercurial configuration, typically from one of the HeptapodHGRC files.The general convention is that all logs emitted by `hgitaly.service`provide GitLab's `correlation_id` in the `extra` dict, making itavailable in the format string. Here is a minimal example:```[correlation_id=%(correlation_id)s] [%(levelname)s] [%(name)s] %(message)s&quot;```Conversely, the format strings for logs emitted outside of`hgitaly.service` must not use `correlation_id`, as subpackages such as`hgitaly.branch`, `hgitaly.message`, etc. cannnot provide avalue: it is a hard error to use a format that relies on someextra if the emitter does not provide it.To summarize the resulting policy:- in `hgitaly.service`, all logging must be done through  `hgitaly.logging.LoggerAdapter`. Using `correlation_id` in the  format is strongly encouraged.- outside of `hgitaly.service`, logging should be self-contained  useful without an obvious link to the calling gRPC method. For  instance a repository inconsistency should be logged at `WARNING`  level, with a message including the path.## Automated tests and Continuous Integration### How to run the testsUsually, that would be in a virtualenv, but it's not necessary.```  python3 -m pip install -r test-requirements.txt  ./run-all-tests```Hint: Check the contents of `run-all-tests`, it's just `pytest` witha standard set of options (mostly for coverage, see below).### Unit and Mercurial integration testsThese are the main tests. They lie inside the `hgitaly`and `hgext3rd.hgitaly` Python packages. The layout follows the style whereeach subpackage has its own tests package, to facilitate future refactorings.The Mercurial integration tests are written with the [mercurial-testhelpers]library. Their duty is to assert that HGitaly works as expected and maintainscompatibility with several versions of Mercurial and possibly otherdependencies, such as [grpcio].The implicit assumption with these tests is that the test authors actuallyknew what was expected. HGitaly being meant to be a direct replacement, orrather a translation of Gitaly in Mercurial terms, those expectation areactually a mix of:- Design choices, such as mapping rules between branch/topic combinations  and GitLab branches.- Gitaly documentation and source code.- sampling of Gitaly responses.### Gitaly comparison testsIf an appropriate Gitaly installation is found, `run-all-tests` will alsorun the tests from the `tests_with_gitaly` package. This happens automaticallyfrom within a [HDK] workspace.These are precisely meant for what the Mercurial integration tests can't do:check that HGitaly responses take the form expected by the various Gitalyclients, by comparing directly with the reference Gitaly implementation.The comparisons work by using the conversions to Git provided by`py-heptapod`, which are precisely what HGitaly aims to replace as a meanto expose Mercurial content to GitLab.Once there is no ambiguity with what Gitaly clients expect, the correctnessof the implementation, with its various corner cases,should be left to the Mercurial integration tests.### Test coverageThis project is being developed with a strong test coverage policy, enforced byCI: without the Gitaly comparison tests, the coverage has to stay at 100%.This does not mean that a contribution has to meet this goal to be worthwile,or even considered. Contributors can expect Maintainers to help themachieving the required 100% coverage mark, especially if they are newcomers.Of course, Contributors cannot expect Maintainers to goas far as write missing tests for them, even if that can still happenfor critical urgent issues.Selected statements can of course be excluded for good reasons, using`# pragma no cover`.Coverage exclusions depending on the Mercurial version areprovided by the coverage plugin of [mercurial-testhelpers].Unexpected drop of coverage in different Mercurial versions is a powerfulwarning system that something not obvious is getting wrong, but theGitaly comparison tests are run in CI against a fixed set ofdependencies, hence 100% coverage must be achieved without the Gitalycomparison tests.On the other hand, Gitaly comparison tests will warn us when we bump upstreamGitLab if some critical behaviour has changed.### Tests Q&amp;A and development hints#### Doesn't the 100% coverage rule without the Gitaly comparison tests mean writing the same tests twice?In some cases, yes, but it's limited.For example, the comparison testscan tell us that the `FindAllBranchNames` is actually expected to returnGitLab refs (`refs/heads/some-branch`), not GitLab branch names. That canbe settled with a few, very basic, test cases. There is no need to test allthe mapping rules for topics, and even less the various related corner casesin the comparison tests. These, on the other hand depend strongly on Mercurialinternals, and absolutely have to be fully tested continuously against variousMercurial versions.Also, it is possible to deduplicate scenarios that are almost identical inMercurial integration tests and Gitaly comparison tests: factorize out thecommon code in a helper function made available for both. The question is ifit is worth the effort.Finally, comparison tests should focus on the fact that Gitaly and HGitalyresults agree, not on what they contain. In the above example,a comparison for `FindAllBranchNames` could simply assert equality of thereturned sets of branch names. This is a bit less cumbersome, and easierto maintain.### How to reproduce a drop in coverage found by the `compat` CI stage?These are often due to statements being covered by the Gitaly comparisontests only, leading to 100% coverage in the `main` stage, but not in the`compat` stage.The first thing to do is to run without the Gitaly comparison tests:```SKIP_GITALY_COMPARISON_TESTS=yes ./run-all-tests```(any non empty value in that environment variable, even `no` or `false` willtrigger the skipping)In some rare cases, the drop in coverage could be due to an actual changebetween Mercurial versions. If that happens, there are good chances that anactual bug is lurking around.### How to run the tests with coverage of the Gitaly comparison tests```./run-all-tests --cov tests_with_gitaly --cov-report html```The HTML report will be nice if you don't have 100% coverage. To display it,just do```firefox htmlcov/index.html```By default, the Gitaly comparison tests themselves are not covered, indeed.This is because `run-all-tests` does not know whether they will be skipped forlack of a Gitaly installation â€“ which would be legitimate.But they *are* covered in the CI jobs that launch them, because Gitaly isassumed to be available. For these, the coverage would tell us that somethingwas broken, preventing the tests to run.### How to poke into Gitaly protocol?The Gitaly comparison tests provide exactly a harness for that: take a test,modify it as needed, insert a `pdb` breakpoint, and get going.The big advantage here is that startup of the Gitaly comparison tests isalmost instantaneous, especially compared with RSpec, wich takes about a minuteto start even a completely trivial test.Of course that will raise the question whether it'll be useful to make truetests of these experiments.### When is a Gitaly comparison test required?Each time there's a need to be sure of what's expected and it can help answerthat question. It doesn't have to do more than that.### When to prefer writing RSpec tests in Heptapod Rails over Gitaly comparison tests in HGitaly?If you need to make sure that Heptapod Rails, as a Gitaly client, sendsthe proper requests, because that can depend on specific dispatch code.For instance, we are currently still converting to Git on the Rails side.A source of bugs would be to send Git commit ids to HGitaly.Apart from that, it is expected to be vastly more efficient to useGitaly comparison tests.The more Heptapod progresses, the less complicated all of this should be.## Updating the Gitaly gRPC protocolThe virtualenv has to be activated1. `pip install -r dev-requirements.txt`2. Copy the new `proto` files from a Gitaly checkout with   version matching the wanted GitLab upstream version.   Example in a HDK context:   ```   cp ../gitaly/proto/*.proto protos/  # we dont want the `go` subdir   ```3. run `./generate-stubs`4. run the tests: `./run-all-tests`5. perform necessary `hg add` after close inspection of `hg status`## Updating the HGitaly specific gRPC protocolThis package defines and implements an additional gRPC protocol, withgRPC services and methods that are specific to Mercurial, or more generallyHeptapod.### Protocol specificationThe sources are `proto` files in the `protos/` directory, same as for theGitaly protocol.They distinguish themselves by this declaration:```package hgitaly;```Each time a change is made to the protocol, the libraries for allprovided programming languages have to be regenerated and committed, ideallytogether with the protocol change.### Python libraryIt has a special status, being versioned together with the protocol and theserver implementation. It is provided as the [hgitaly.stub](hgitaly/stub)package.The Python stubs are produced by the same script that takes care of Gitaly`proto` files:```./generate-stubs```### Ruby librarySee [the separate documentation](ruby/README.md)### Other languagesA Go library will probably be necessary quite soon for Workhorse or perhapsHeptapod Shell.A Rust library would be nice to have[mercurial-testhelpers]: https://pypi.org/project/mercurial-testhelpers/[grpcio]: https://pypi.org/project/grpcio/[HDK]: https://foss.heptapod.net/heptapod/heptapod-development-kit</longdescription>
</pkgmetadata>