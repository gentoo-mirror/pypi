<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># kubedevDevOps command line tool that standardizes workflows for Microservices in Kubernetes for teams:&gt; Develop, Build, Secure, Deploy.It builds on well-known and field-proven tools:- [docker](https://docker.com/)- [tilt](https://tilt.dev/)- [helm](https://helm.sh/)- [kind](https://kind.sigs.k8s.io/)- Security audits:  - [Fairwinds Polaris](https://github.com/FairwindsOps/polaris)- CI providers:  - [GitLab](https://gitlab.com/)## kubedev Principles- `kubedev` wants to help you quickly and easily build microservices that are independent, but at the same time follow a common pattern in regards to building, documenting and deploying. This makes it easier to add new services, and to onboard new developers.- `kubedev` aims to be a thin wrapper around the commands it builds on, and just wants to make it easier for teams to call them appropriately.- `kubedev` always prints the commands that it executes, so that you know what is going on.- `kubedev` heavily relies on environment variables for service configuration.- `kubedev` helps you build your services &quot;secure by default&quot;.## Current state of development`kubedev` is in early development and used internally at Gira.## Synopsis`kubedev` commands are based on the definitions found in `kubedev.json`, which include the minimum necessary information that is required to execute common cloud-dev related tasks.A kubedev.json describes an &quot;Service&quot;, which in turn can contain &quot;Apps&quot; that may be deployments or cronjobs.Schema of kubedev.json:```jsonc{    &quot;name&quot;: &quot;myservice&quot;,    &quot;description&quot;: &quot;My fancy service ðŸŽ†&quot;,    &quot;imagePullSecrets&quot;: &quot;foo-creds&quot;, # Your docker registry auth credentials    &quot;imageRegistry&quot;: &quot;foo-registry&quot;, # Your docker registry    &quot;helmReleaseName&quot;: &quot;myservice-v1&quot;, # An optional name of the helm release. If not specified, 'name' will be used.    &quot;securityChecks&quot;: {      &quot;polaris&quot;: { # Optional, specify a custom polaris configuration        &quot;configFile&quot;: &quot;polaris-config-cli.yaml&quot;, # Local file name of the polaris config        &quot;configDownload&quot;: { # Optional, download the polaris config to the local file before running the audit          &quot;url&quot;: &quot;https://url-to-your-polaris-config&quot;,          &quot;headers&quot;: { # Optional, specify headers added to the GET request to download the polaris config            &quot;Authentication&quot;: &quot;Bearer ${YOUR_BEARER_TOKEN}&quot;          }        }      },      &quot;variables&quot;: {        &quot;MYDEPLOY_FLASK_ENV&quot;: &quot;development&quot; # You can override variables here that are set when calling `helm template` to pipe into the security checker      }    },    &quot;required-envs&quot;: {      &quot;MYSERVICE_ENV&quot;: {        &quot;documentation&quot;: &quot;Describe MYSERVICE_ENV here, so that other devs on your team know how to set them in their own env&quot;,        &quot;container&quot;: true, # Use this environment variable when running containers        &quot;build&quot;: true # Use this environment variable for building the container      }    },    &quot;deployments&quot;: {        &quot;mydeploy&quot;: { # An App `mydeploy' of type deployment            &quot;usedFrameworks&quot;: [&quot;python&quot;, &quot;pipenv&quot;, &quot;npm&quot;, &quot;vue&quot;], # Not implemented, yet. usedFrameworks are used to e.g. fill in Tiltfile live_update, ignore, etc.            &quot;ports&quot;: {              &quot;https&quot;: {                  &quot;container&quot;: &quot;8081&quot;, # This is the port that your actual dockerized service is bound to                  &quot;service&quot;: &quot;8082&quot;,   # This is the port that the Kubernetes service serves on. Will be redirected to the container-port of the pods.                  &quot;dev&quot;: &quot;8083&quot; # This is the port used for local development by either `tilt` or `kubedev run`. Will be available on localhost when using `tilt up` or `kubedev run`.              }            },            &quot;volumes&quot;: {              &quot;dev&quot;: {                &quot;other_path&quot;: &quot;/short/path&quot; # Shorthand to mount a path read-write,                &quot;host_path&quot;: {                  &quot;path&quot;: &quot;/container/path&quot;, # Mount local directories to container directories when running via `kubedev run`                  &quot;readOnly&quot;: true # mount them read-only                },                &quot;inline_content.txt&quot;: {                  &quot;content&quot;: &quot;Hello, World!&quot;, # Mount fixed, plain-text content to a file at 'path'                  &quot;path&quot;: &quot;/container/path&quot;,                  &quot;readOnly&quot;: true # mount file read-only                },                &quot;inline_content_base64.txt&quot;: {                  &quot;path&quot;: &quot;/container/path&quot;, # Mount fixed, base64-encoded content to a file at 'path'                  &quot;base64&quot;: &quot;SGVsbG8sIFdvcmxkIQ==&quot;,                  &quot;readOnly&quot;: true # mount file read-only                }              }            },            &quot;required-envs&quot;: {                &quot;MYDEPLOY_FLASK_ENV&quot;: {                    &quot;documentation&quot;: &quot;...&quot;                },                &quot;MYDEPLOY_COMPLEX&quot;: {                  &quot;documentation&quot;: &quot;This is a variable with content that can not be passed to the helm chart on the command line and must be base64-encoded.&quot;,                  &quot;transform&quot;: &quot;base64&quot;                }            },            # Defines the system test for this app. System tests must be defined in the directory ./systemTest/&lt;app-name&gt;/ and must include a Dockerfile:            &quot;systemTest&quot;: {                &quot;variables&quot;: {                  # Defines variables that are passed as environment variables into the test container and all services:                  &quot;TEST_GLOBAL_VAR&quot;: &quot;value&quot;                },                &quot;testContainer&quot;: {                    &quot;volumes&quot;: {                        &quot;local_file&quot;: &quot;/tmp/container_file&quot; # You can mount volumes into the testContainer                    },                    &quot;variables&quot;: {                        # Defines environment variables that are passed to the system-test container                        &quot;TEST_HOSTNAME&quot;: &quot;myservice-test&quot;                    },                    &quot;buildArgs&quot;: {                        # Defines build arguments for the system test container                        &quot;TEST_BUILD_X&quot;: &quot;X&quot;                  }                },                # Services run in the background, in an isolated docker network, while the system test container is executed                &quot;services&quot;: {                    # Services can reference deployments defined in this kubedev.json and will use the latest available image tag,                    # as generated by e.g. `kubedev build`.                    &quot;{mydeploy}&quot;: {                        &quot;hostname&quot;: &quot;myservice-test&quot;, # The system test container can access this service by this hostname                        &quot;ports&quot;: [8081], # Ports that are accessible from other containers                        &quot;cmd&quot;: [&quot;--some&quot;, &quot;commandline&quot;, &quot;--args&quot;, &quot;${SHELL_EXPANDED_VARIABLE}&quot;], # Arguments passed to 'docker run...' after the image-name                        &quot;variables&quot;: {                            # Environment variables that are passed to this service.                            # All required-envs for this deployment are passed, too, but can be overwritten here:                            &quot;MYSERVICE_ENV&quot;: &quot;test-value&quot;                        }                    },                    # Services can use public images or images from your private repository, too:                    &quot;postgres:13&quot;: {                        &quot;hostname&quot;: &quot;postgres-test&quot;,                        &quot;ports&quot;: [5432], # Ports that are accessible from other containers                        &quot;variables&quot;: {                            &quot;POSTGRES_USER&quot;: &quot;tempuser&quot;,                            &quot;POSTGRES_PASSWORD&quot;: &quot;correct horse battery staple&quot;                        }                    }                }            }        }    },    &quot;cronjobs&quot;: {        &quot;myjob&quot;: {            &quot;volumes&quot;: {              &quot;dev&quot;: {                  &quot;job_files/&quot;: &quot;/tmp/job_files/&quot;              }            },            &quot;required-envs&quot;: {                &quot;MYJOB_VAR&quot;: {                    &quot;documentation&quot;: &quot;...&quot;                }            },            &quot;systemTest&quot;: {                # See the detailed documentation on system tests below.                &quot;services&quot;: {                    # Services can use public images or images from your private repository, too:                    &quot;postgres:13&quot;: {                        &quot;hostname&quot;: &quot;postgres-test&quot;,                        &quot;ports&quot;: [5432], # Ports that are accessible from other containers                        &quot;variables&quot;: {                            &quot;POSTGRES_USER&quot;: &quot;tempuser&quot;,                            &quot;POSTGRES_PASSWORD&quot;: &quot;correct horse battery staple&quot;                        }                    }                }            }        }    },    &quot;generic&quot;: {        &quot;something&quot;: {            &quot;required-envs&quot;: {              # Put some required-envs here that are not used by something that is built as a container          }      }    }}```## Naming conventions`kubedev` will work with artifacts that follow certain naming conventions that are built from the \&lt;service name\&gt; (top level &quot;name&quot;), the \&lt;app name\&gt; (the &quot;name&quot; inside of &quot;deployments&quot; and &quot;cronjobs&quot;) and a tag, which will be used as the image tag.|Artifact|Naming Convention||--------|-----------------||helm chart name|The helm chart is generated with the name `&lt;service name&gt;`.||helm release name|The release name is either directly specified using `helmReleaseName` in `kubedev.json`, or is the same as the helm chart name if `helmReleaseName` is not specified.||kubernetes labels|All kubernetes definitions include the labels `kubedev-deployment` or `kubedev-cronjob` (\&lt;service name\&gt;) and `kubedev-app` \&lt;app name\&gt;.||image name|The image name is built using `&lt;imageRegistry&gt;/&lt;service name&gt;-&lt;app name&gt;`, except when \&lt;app name&gt; is the same as \&lt;service name\&gt;, in which case it is collapsed to just `&lt;imageRegistry&gt;/&lt;app name&gt;`||image tag|The tag is either built using `&quot;${CI_COMMIT_SHORT_SHA}_${CI_COMMIT_REF_NAME}&quot;`, if both these environment variables are set, or to `none` otherwise.|## Automatic docker loginWhen kubedev needs to access docker registries, it writes the content of `${DOCKER_AUTH_CONFIG}` to the file `${HOME}/.docker/config.json`, if:- `~/.docker/config.json` does not exist.- The environment variable `${HOME}` is set.- The environment variable `${CI}` is set.- The environment variable `${DOCKER_AUTH_CONFIG}` is set.## Environment Variable TransformationEnvironment Variables are passed to `helm` and `docker` by shell expansion. This has some limitations of values that are not &quot;shell-safe&quot;, such as when they contain double-quotes or special characters. To make it safe and possible to pass these values, kubedev provides a few transformations.A transformation will take the content of the variable from the environment where kubedev is called, and pass it in a transformed way into `helm --set` and `docker --build-arg / --env`.Available transformations are:|Transformation|Description||--------------|-----------||base64|Base64 encodes the value|You can enable a transformation by setting the attribute `transform` in `required-envs` to the desired transformation, e.g. `base64`.## kubedev generateCreates artifacts that kick-starts your microservice development.The following files are created for by - with secure defaults:- Tiltfile- .gitlab-ci.yml- helm-chart/ with all required kubernetes ressources- \&lt;your-service\&gt;/DockerfileSee [Naming Conventions](#naming-conventions).The following &quot;usedFrameworks&quot; are supported by `kubedev generate`.### pipenvWhen &quot;pipenv&quot; is included in the &quot;usedFrameworks&quot; by either an app or globally, the following files are generated inside the \&lt;app\&gt;'s sub-directory:|File|Description||----|-----------||Dockerfile|Includes pipenv-specific instructions||app.py|An empty python script||Pipfile|A Pipfile using python 3.8. No packages or dev-packages are added.||Pipfile.lock|The result of locking the empty Pipfile.|## kubedev checkReads kubedev.json and checks whether all environment variables from the configuration is set in the current environment. It prints missing variables, including it's documentation.`kubdev check`'s scope can be narrowed down by optional command line arguments:- `kubedev check` without additional arguments checks whether all environment variables used for build and runtime exist, and prints the missing environment variables.- `kubedev check [cmd]` checks only the environment variables required for the specified task. E.g. `kubedev check build` will check for the existance of environment variables where &quot;build&quot; is set to `true` (or &quot;build&quot; is not specified, which defaults to `true`).- `kuebdev check [cmd] [app2] [app2] ...` checks only the environment variables that are required for the specified task (e.g. `kubedev check build`) for the given apps (`deployments`, `cronjobs` or `generic`).## kubedev auditAudits the k8s specification using [Fairwind's Polaris](https://github.com/FairwindsOps/polaris).A custom configuration file can be specified via the configuration options `securityChecks.polaris`, see the example.Possible configuration options:|JSON field|Description||----------|-----------||`securityChecks.variables`|A dictionary with variables and values that are used to override the current environment's values. You can use these to set specific values when executing `helm template` to generate the Kubernetes ressources that are checked by `polaris`.||`securityChecks.polaris.configFile`|A path to a local configuration file that is passed to `polaris`. The file must exist or `configDownload` must be specified. Environment variables will be expanded.||`securityChecks.polaris.configDownload`|An optional object that can be used to specify a download path where `kubedev audit` will fetch the polaris configuration from.||`securityChecks.polaris.configDownload.url`|The URL to the polaris config. Environment variables will be expanded. When the object `configDownload` exists, the field `url` is mandatory.||`securityChecks.polaris.configDownload.headers`|An optional dictionary that can contain custom headers that will be passed to the polaris config download. Both the header names and values can include environment variables.|*Note:* The polaris executable needs to be available in your $PATH.## kubedev build \&lt;app\&gt;Runs `docker build` for \&lt;app\&gt; with all docker build args as defined in kubedev.json.See [Naming Conventions](#naming-conventions).This commands writes the content of `${DOCKER_AUTH_CONFIG}` to the file `${HOME}/.docker/config.json`, if:- `~/.docker/config.json` does not exist.- The environment variable `${CI}` is set.- The environment variable `{DOCKER_AUTH_CONFIG}` is set.`kubedev build` is used inside the CI/CD build jobs generated by `kubedev generate` and internally by the `kubedev run` command.## kubedev push \&lt;app\&gt;Runs `docker push` for \&lt;app\&gt;.See [Naming Conventions](#naming-conventions).See [Automatic docker login](#automatic-docker-login)`kubedev push` is used inside the CI/CD build jobs generated by `kubedev generate`.## kubedev run \&lt;app\&gt;Builds an image using `kubedev build` with a random tag and then runs it.The following parameters are passed to `docker run`, some of them can be configured in `kubedev.json`:- `--interactive` and `--rm` are always passed- If kubedev is called from a terminal, `--tty` is passed.- `required-envs` are forwarded to the container.- All `ports.\&lt;port-name\&gt;.dev` will be forwarded to `ports.\&lt;port-name\&gt;.container`- `volumes.dev` are passed to the container. kubedev will auto-detect a WSL + Docker Desktop environment and convert the source path to a Windows path using `wsl-path -aw`.## kubedev deployReads a kube config from the env var $KUBEDEV_KUBECONFIG (required), writes it to *\&lt;temp-kubeconfig-file\&gt;* and optionally a context from $KUBEDEV_KUBECONTEXT and then runs `helm upgrade --install --kube-config &quot;&lt;temp-kubeconfig-file&gt;` with appropriate arguments and all required env vars from `kubedev.json`.See [Naming Conventions](#naming-conventions).The generated image tag is passed to the template using the environment variable KUBEDEV_TAG.`kubedev deploy` is used inside the CI/CD build jobs generated by `kubedev generate`.## kubedev templateBasically runs `helm template` with appropriate arguments and env vars from `kubedev.json`.See [Naming Conventions](#naming-conventions).The generated image tag is passed to the template using the environment variable KUBEDEV_TAG.`kubedev template` is used inside the Tiltfile generated by `kubedev generate`.## kubedev system-test \&lt;app name\&gt;### System Tests for DeploymentsIf \&lt;app-name\&gt; is a deployment, the system-test is run in &quot;deployment&quot;-mode, which is different and much quicker than the &quot;cronjob&quot;-mode (see below).In &quot;deployment&quot;-mode, a system-test container is run against defined services, which can either be services defined in `kubedev.json`, or services pulled from a registry such as a database or a service defined in another repository. The system-test container and the services run directly in docker and not in Kubernetes.**Note that** local kubedev invocations behave differently from its invocationsbeing inside a CI pipeline. When running `kubedev system-test &lt;app&gt;` locally,all container images necessary for a given system-test are built. When runningin CI, only the system-test images themselves are built. Deployments &amp;CronJob images are expected to be pullable. Hence, in CI `system-tests` may neverpreceed their corresponding `build-push` stage.See [Automatic docker login](#automatic-docker-login)`kubedev system-test`'s behaviour is defined in a &quot;systemTest&quot; sub-element of the deployment definition. See the thorough example at the beginning of the README.md.The following configuration options are available:|Configuration element|Description|Mandatory||---------------------|-----------|---------||`systemTest.variables`|Defines global variables that are passed as environment variables into the services (if defined) and the system test container|No||`systemTest.testContainer.variables`|Defines variables  that are passed as environment variables into the system test container, but not the services|No||`systemTest.testContainer.buildArgs`|Defines build args that are used when building the system test container|No||`systemTest.testContainer.services`|Defines services that are run in the background when running the system test container. Use the syntax `{\&lt;app name\&gt;` to reference deployments that are defined in this `kubedev.json`, and the image name will be built automatically according to the same rules as `kubedev build`. The app's `volumes.dev` are passed to the container as `kubedev run` does.|No||`systemTest.testContainer.services[...].hostname`|This service will be available by this hostname from the system test container|Yes||`systemTest.testContainer.services[...].ports`|Defines ports that are published from this service|No||`systemTest.testContainer.services[...].cmd`|A list of command line arguments passed to the `docker run...` command.|No||`systemTest.testContainer.services[...].variables`|Defines additional environment variables that are passed to this service. When this service references a kubedev deployment, additionally all `required-envs` for this deployment are passed into the service. These values can be overwritten using this variables.|No|The schematic flow when running the system-test is as follows:1. Build the system test container from `./systemTest/\&lt;app-name\&gt;/`.2. Create a temporary docker network.3. Try to remove left-over services from previous run.4. Run all defined services in the background.5. Wait for all services to become ready.6. __Run the system test container in the foreground.__7. Remove the services containers.8. Remove the temporary docker network.### System Tests for CronJobs#### IntroductionIf \&lt;app-name\&gt; is a cronjob, the sytsem-test is run in &quot;cronjob&quot;-mode, which spins up a temporary Kubernetes cluster using `kind`.You can pass `--reuse-cluster &lt;some-cluster-name&gt;` to speed up successive runs of system-tests. On the first run, if the `kind` cluster does not exist, it is created. On all successive runs this cluster is re-used, which speeds up test execution time. The details in the section &quot;Flow&quot; below.See [Automatic docker login](#automatic-docker-login)`kubedev system-test`'s behaviour is defined in a &quot;systemTest&quot; sub-element of the cronjob definition.#### ConfigurationThe following configuration options are available:|Configuration element|Description|Mandatory||---------------------|-----------|---------||`systemTest.clusterInitChart`|Defines a path to a helm chart that is deployed after cluster creation. This helm chart can contain prerequisites for your service|No||`systemTest.variables`|Defines global variables that are passed as environment variables into the services (if defined) and the system test container|No||`systemTest.testContainer.variables`|Defines variables that are passed as environment variables into the system test container, but not the services|No||`systemTest.testContainer.buildArgs`|Defines build args that are used when building the system test container|No||`systemTest.testContainer.services`|Defines services that are run outside of the cluster when running the system test container. This can not reference apps from the `kubedev.json`, because the whole service is deployed to the cluster and hence all apps run, anyways.|No||`systemTest.testContainer.services[...].hostname`|This service will be available by this hostname from the system test container|Yes||`systemTest.testContainer.services[...].ports`|Defines ports that are published from this service|No||`systemTest.testContainer.services[...].cmd`|A list of command line arguments passed to the `docker run...` command.|No||`systemTest.testContainer.services[...].variables`|Defines additional environment variables that are passed to this service.|No|#### FlowThe schematic flow when running the system-test is as follows:1. Build the system test container from `./systemTest/\&lt;app-name\&gt;/`.2. Build and push all apps from `kubedev.json`.3. Spin up a new [kind](https://kind.sigs.k8s.io/) cluster. (This step is skipped when re-using a cluster.)4. Run a [special service](https://github.com/daniel-kun/kubedev-systemtest-daemon) that can be used by the system-tests to easily start the CronJob. See the API description below.5. Cluster initialization: , install `tiller` using `helm init`. (This step is skipped when re-using a cluster.)- Create a `tiller` service-account with cluster-admin permissions. (This step is skipped when re-using a cluster.)- Run `helm init` to install tiller. (This step is skipped when re-using a cluster.)- Create the secret defined by `imagePullSecrets` with the content `.dockerconfigjson: &lt;base64-encoded ${DOCKER_AUTH_CONFIG}`. (This step is skipped when re-using a cluster.)- Wait for `tiller` to become ready. (This step is skipped when re-using a cluster.)6. Deploy the `clusterInitChart`, if specified.7. Deploy this service.8. Run the system-test container.#### Run the CronJob from within the system-testA convenience service is provided for the system-tests to easily start the CronJob and fetch the logs.Use this endpoint to trigger the endpoint:```POST http://${KUBEDEV_SYSTEMTEST_DAEMON_ENDPOINT}/executeApi-Key: ${KUBEDEV_SYSTEMTEST_DAEMON_APIKEY}```e.g. using curl you can use:```bashcurl -X POST -H &quot;Api-Key: ${KUBEDEV_SYSTEMTEST_DAEMON_APIKEY}&quot; ${KUBEDEV_SYSTEMTEST_DAEMON_ENDPOINT}```The service will send individual lines, first consisting of the commands that it executes, and then with the log output of the CronJob.A system test case should be designed to first set up the environment - such as the database or whathever is required by the CronJob, then run the CronJob using this convenience service and afterwards either inspect the logs or check the environment for expected changes - such as a new or updated entry in the database.</longdescription>
</pkgmetadata>