<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Build Status](https://travis-ci.com/RENCI/tx-parallex.svg?branch=master)](https://travis-ci.com/RENCI/tx-parallex)# `parallex`## System RequirementsPython &gt;= 3.8## installDefault object store```pip install tx-parallex```Plasma store https://arrow.apache.org/```pip install tx-parallex[arrow]```## Install from source1. Clone the repo2. Easy install instructions:```# Create a virtual environment called 'px'conda create -n px python=3.8# start-up the environment you just createdconda activate px# install the rest of the tx-parallex pre-requirementspip install -r requirements.txt```3. Test```# run the tests, a number of test 'specs'PYTHONPATH=src pytest -x -vv --full-trace -s --timeout 60# deactivate the environment (if desired)conda deactivate```## set log levelset environment variable LOG_LEVEL to one of Python's logging library setLevel.## IntroductionA queue with dependencies## Usage```from tx.parallex import run_pythonret = run_python(number_of_workers = 4, pyf = &quot;spec.py&quot;, dataf = &quot;data.yml&quot;)```## Spec`tx-parallex` specs can be written in YAML or a Python-like DSL. The Python-like DSL is translated to YAML by `tx-parallex`. Each object in a spec specifies a task. When the task is executed, it is given a dict called `data`. The pipeline will return a dictionary.### YAMLAssuming you have a function `sqr` defined in module `math` which returns the square of its argument.```def sqr(x):  return x * x```#### `let`The `let` task sets `data` for its subtask. It adds a new var value pair into `data` within the scope of its subtask, and executes that task.Syntax:```type: letvar: &lt;var&gt;obj: &lt;value&gt;sub: &lt;subtask&gt;```Example:```type: letvar: aobj:  data: 1sub:  type: python  name: y  mod: math  func: sqr  params:     x:      name: a```### `map`The `map` task reads a list `coll` from `data` and applies a subtask to each member of the list. The members will be assigned to `var` in `data` passed to those tasksSyntax:```type: mapcoll: &lt;value&gt;var: &lt;variable name&gt;sub: &lt;subtask&gt;````&lt;value&gt;` is an object of the form:Reference an entry in `data` or the name of a task```&quot;name&quot;: &lt;variable name&gt;```Constant```&quot;data&quot;: &lt;constant&gt;```Example:```type: mapcoll:   data:  - 1  - 2  - 3var: asub:  type: python  name: y  mod: math  func: sqr  params:     x:      name: a```### `cond`The `cond` task reads a boolean value and if it is true then it executes the `then` task otherwise it executes the `else` task.Syntax:```type: condon: &lt;value&gt;then: &lt;subtask&gt;else: &lt;subtask&gt;```Example:```type: condon:   data:    truethen:  type: ret  obj:    data: 1else:  type: ret  obj:    data: 0```### `python`You can use any Python module.The `python` task runs a Python function. It reads parameters from `data`. The return value must be pickleable.Syntax:```type: pythonname: &lt;name&gt;mod: &lt;module&gt;func: &lt;function&gt;params: &lt;parameters&gt;````&lt;parameters&gt;` is an object of the form:```&lt;param&gt; : &lt;value&gt;...&lt;param&gt; : &lt;value&gt;```where `&lt;param&gt;` can be either name or position.Example:```  type: python  name: y  mod: math  func: sqr  params:     x:      data: 1```### `top`The `top` task toplogically sorts subtasks based on their dependencies and ensure the tasks are executed in parallel in the order compatible with those dependencies. Syntax:```type: topsub: &lt;subtasks&gt;```It reads the `name` properties of subtasks that are not in data.Example:```type: topsub:- type: python  name: y  mod: math  func: sqr  params:     x:      data: 1- type: python  name: z  mod: math  func: sqr  params:     x:      name: y```### `seq`The `seq` task forces all subtasks to be run sequentially. Syntax:```type: topsub: &lt;subtasks&gt;```It reads the `name` properties of subtasks that are not in data.Example:```type: seqsub:- type: python  name: y  mod: math  func: sqr  params:     x:      data: 1- type: python  name: z  mod: math  func: sqr  params:     x:      name: y```### `ret``ret` specify a value. The pipeline will return a dictionary. When a task appears under a `map` task, it is prefix with the index of the element in that collection as following ```&lt;index&gt;```For nested maps, the indices will be chained together as followings```&lt;index&gt;. ... .&lt;index&gt;```Syntax:```type: retobj: &lt;value&gt;```Example:```type: retobj:     name: z```## PythonA dsl block contains a subset of Python.* There is a semantic difference from python. Any assignment in block is not visiable outside of the block.* Assignment within a block are unordered* return statementAvailable syntax:### import```from &lt;module&gt; import *from &lt;module&gt; import &lt;func&gt;, ..., &lt;func&gt;```import names from module`&lt;module&gt;` absolute module names### assignment```&lt;var&gt; = &lt;const&gt;```where```&lt;const&gt; = &lt;integer&gt; | &lt;number&gt; | &lt;boolean&gt; | &lt;string&gt; | &lt;list&gt; | &lt;dict&gt;```This translates to `let`.Example:```a = 1y = sqr(x=a)yield y```### function application```&lt;var&gt; = [&lt;module&gt;.]&lt;func&gt;(&lt;param&gt;=&lt;expr&gt;, ...) | &lt;expr&gt;```This translate to `python`.where `&lt;var&gt;` is `name``&lt;expr&gt;` is```&lt;expr&gt; = &lt;expr&gt; if &lt;expr&gt; else &lt;expr&gt; | &lt;expr&gt; &lt;binop&gt; &lt;expr&gt; | &lt;expr&gt; &lt;boolop&gt; &lt;expr&gt; | &lt;expr&gt; &lt;compare&gt; &lt;expr&gt; | &lt;unaryop&gt; &lt;expr&gt; | &lt;var&gt; | &lt;const&gt;````&lt;binop&gt;`, `&lt;boolop&gt;` and `&lt;compare&gt;` and `&lt;unaryop&gt;` are python BinOp, BoolOp, Compare, and UnaryOp. `&lt;expr&gt;` is translated to a set of assignments, `name`, or `data` depending on its content.Example:```y = math.sqr(1)z = math.sqr(y)return z```### parallel for```for &lt;var&gt; in &lt;expr&gt;:    ...```This translates to `map`.Example:```for a in [1, 2, 3]:  y = math.sqr(a)  yield y```### if```if &lt;expr&gt;:    ...else:    ...```This translates to `cond`.Example:```if z:    yield 1else:    yield 0```The semantics of if is different from python, variables inside if is not visible outside### with```with Seq:    ...```This translates to `seq`. Example:```with Seq:    y = math.sqr(1)    return y```### yield```yield &lt;expr&gt;```This translates to `ret`. Example:```y = math.sqr(1)return y```## Datadata can be arbitrary yaml</longdescription>
</pkgmetadata>