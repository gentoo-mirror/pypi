<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># hypothesis-graphql[![Build](https://github.com/Stranger6667/hypothesis-graphql/workflows/build/badge.svg)](https://github.com/Stranger6667/hypothesis-graphql/actions)[![Coverage](https://codecov.io/gh/Stranger6667/hypothesis-graphql/branch/master/graph/badge.svg)](https://codecov.io/gh/Stranger6667/hypothesis-graphql/branch/master)[![Version](https://img.shields.io/pypi/v/hypothesis-graphql.svg)](https://pypi.org/project/hypothesis-graphql/)[![Python versions](https://img.shields.io/pypi/pyversions/hypothesis-graphql.svg)](https://pypi.org/project/hypothesis-graphql/)[![Chat](https://img.shields.io/discord/938139740912369755)](https://discord.gg/VnxfdFmBUp)[![License](https://img.shields.io/pypi/l/hypothesis-graphql.svg)](https://opensource.org/licenses/MIT)&lt;h4 align=&quot;center&quot;&gt;Generate queries matching your GraphQL schema, and use them to verify your backend implementation&lt;/h4&gt;It is a Python library that provides a set of [Hypothesis](https://github.com/HypothesisWorks/hypothesis/tree/master/hypothesis-python) strategies thatlet you write tests parametrized by a source of examples.Generated queries have arbitrary depth and may contain any subset of GraphQL types defined in the input schema.They expose edge cases in your code that are unlikely to be found otherwise.[Schemathesis](https://github.com/schemathesis/schemathesis) provides a higher-level interface around this library and finds server crashes automatically.## Usage`hypothesis-graphql` provides the `from_schema` function, which takes a GraphQL schema and returns a Hypothesis strategy forGraphQL queries matching the schema:```pythonfrom hypothesis import givenfrom hypothesis_graphql import from_schemaimport requests# Strings and `graphql.GraphQLSchema` are supportedSCHEMA = &quot;&quot;&quot;type Book {  title: String  author: Author}type Author {  name: String  books: [Book]}type Query {  getBooks: [Book]  getAuthors: [Author]}type Mutation {  addBook(title: String!, author: String!): Book!  addAuthor(name: String!): Author!}&quot;&quot;&quot;@given(from_schema(SCHEMA))def test_graphql(query):    # Will generate samples like these:    #    # {    #   getBooks {    #     title    #   }    # }    #    # mutation {    #   addBook(title: &quot;H4Z\u7869&quot;, author: &quot;\u00d2&quot;){    #     title    #   }    # }    response = requests.post(&quot;http://127.0.0.1/graphql&quot;, json={&quot;query&quot;: query})    assert response.status_code == 200    assert response.json().get(&quot;errors&quot;) is None```It is also possible to generate queries or mutations separately with `hypothesis_graphql.queries` and `hypothesis_graphql.mutations`.### CustomizationTo restrict the set of fields in generated operations use the `fields` argument:```python@given(from_schema(SCHEMA, fields=[&quot;getAuthors&quot;]))def test_graphql(query):    # Only `getAuthors` will be generated    ...```It is also possible to generate custom scalars. For example, `Date`:```pythonfrom hypothesis import strategies as st, givenfrom hypothesis_graphql import from_schema, nodesSCHEMA = &quot;&quot;&quot;scalar Datetype Query {  getByDate(created: Date!): Int}&quot;&quot;&quot;@given(    from_schema(        SCHEMA,        custom_scalars={            # Standard scalars work out of the box, for custom ones you need            # to pass custom strategies that generate proper AST nodes            &quot;Date&quot;: st.dates().map(nodes.String)        },    ))def test_graphql(query):    # Example:    #    #  { getByDate(created: &quot;2000-01-01&quot;) }    #    ...```The `hypothesis_graphql.nodes` module includes a few helpers to generate various node types:- `String` -&gt; `graphql.StringValueNode`- `Float` -&gt; `graphql.FloatValueNode`- `Int` -&gt; `graphql.IntValueNode`- `Object` -&gt; `graphql.ObjectValueNode`- `List` -&gt; `graphql.ListValueNode`- `Boolean` -&gt; `graphql.BooleanValueNode`- `Enum` -&gt; `graphql.EnumValueNode`- `Null` -&gt; `graphql.NullValueNode` (a constant, not a function)They exist because classes like `graphql.StringValueNode` can't be directly used in `map` calls due to kwarg-only arguments.## LicenseThe code in this project is licensed under [MIT license](https://opensource.org/licenses/MIT).By contributing to `hypothesis-graphql`, you agree that your contributions will be licensed under its MIT license.</longdescription>
</pkgmetadata>