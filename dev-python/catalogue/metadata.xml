<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;a href=&quot;https://explosion.ai&quot;&gt;&lt;img src=&quot;https://explosion.ai/assets/img/logo.svg&quot; width=&quot;125&quot; height=&quot;125&quot; align=&quot;right&quot; /&gt;&lt;/a&gt;# catalogue: Super lightweight function registries for your library`catalogue` is a tiny, zero-dependencies library that makes it easy to **addfunction (or object) registries** to your code. Function registries are helpfulwhen you have objects that need to be both easily serializable and fullycustomizable. Instead of passing a function into your object, you pass in anidentifier name, which the object can use to lookup the function from theregistry. This makes the object easy to serialize, because the name is a simplestring. If you instead saved the function, you'd have to use Pickle forserialization, which has many drawbacks.[![tests](https://github.com/explosion/catalogue/actions/workflows/tests.yml/badge.svg)](https://github.com/explosion/catalogue/actions/workflows/tests.yml)[![Current Release Version](https://img.shields.io/github/v/release/explosion/catalogue.svg?style=flat-square&amp;include_prereleases&amp;logo=github)](https://github.com/explosion/catalogue/releases)[![pypi Version](https://img.shields.io/pypi/v/catalogue.svg?style=flat-square&amp;logo=pypi&amp;logoColor=white)](https://pypi.org/project/catalogue/)[![conda Version](https://img.shields.io/conda/vn/conda-forge/catalogue.svg?style=flat-square&amp;logo=conda-forge&amp;logoColor=white)](https://anaconda.org/conda-forge/catalogue)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg?style=flat-square)](https://github.com/ambv/black)## ‚è≥ Installation```bashpip install catalogue``````bashconda install -c conda-forge catalogue```&gt; ‚ö†Ô∏è **Important note:** `catalogue` v2.0+ is only compatible with Python 3.6+.&gt; For Python 2.7+ compatibility, use `catalogue` v1.x.## üë©üíª UsageLet's imagine you're developing a Python package that needs to load datasomewhere. You've already implemented some loader functions for the most commondata types, but you want to allow the user to easily add their own. Using`catalogue.create` you can create a new registry under the namespace`your_package` &amp;rarr; `loaders`.```python# YOUR PACKAGEimport catalogueloaders = catalogue.create(&quot;your_package&quot;, &quot;loaders&quot;)```This gives you a `loaders.register` decorator that your users can import anddecorate their custom loader functions with.```python# USER CODEfrom your_package import loaders@loaders.register(&quot;custom_loader&quot;)def custom_loader(data):    # Load something here...    return data```The decorated function will be registered automatically and in your package,you'll be able to access all loaders by calling `loaders.get_all`.```python# YOUR PACKAGEdef load_data(data, loader_id):    print(&quot;All loaders:&quot;, loaders.get_all()) # {&quot;custom_loader&quot;: &lt;custom_loader&gt;}    loader = loaders.get(loader_id)    return loader(data)```The user can now refer to their custom loader using only its string name(`&quot;custom_loader&quot;`) and your application will know what to do and will use theircustom function.```python# USER CODEfrom your_package import load_dataload_data(data, loader_id=&quot;custom_loader&quot;)```## ‚ùì FAQ#### But can't the user just pass in the `custom_loader` function directly?Sure, that's the more classic callback approach. Instead of a string ID,`load_data` could also take a function, in which case you wouldn't need apackage like this. `catalogue` helps you when you need to produce a serializablerecord of which functions were passed in. For instance, you might want to writea log message, or save a config to load back your object later. With`catalogue`, your functions can be parameterized by strings, so logging andserialization remains easy ‚Äì while still giving you full extensibility.#### How do I make sure all of the registration decorators have run?Decorators normally run when modules are imported. Relying on this side-effectcan sometimes lead to confusion, especially if there's no other reason themodule would be imported. One solution is to use[entry points](https://packaging.python.org/specifications/entry-points/).For instance, in [spaCy](https://spacy.io) we're starting to use functionregistries to make the pipeline components much more customizable. Let's say oneuser, Jo, develops a better tagging model using new machine learning research.End-users of Jo's package should be able to write`spacy.load(&quot;jo_tagging_model&quot;)`. They shouldn't need to remember to write`import jos_tagged_model` first, just to run the function registries as aside-effect. With entry points, the registration happens at install time ‚Äì soyou don't need to rely on the import side-effects.## üéõ API### &lt;kbd&gt;function&lt;/kbd&gt; `catalogue.create`Create a new registry for a given namespace. Returns a setter function that canbe used as a decorator or called with a name and `func` keyword argument. If`entry_points=True` is set, the registry will check for[Python entry points](https://packaging.python.org/tutorials/packaging-projects/#entry-points)advertised for the given namespace, e.g. the entry point group`spacy_architectures` for the namespace `&quot;spacy&quot;, &quot;architectures&quot;`, in`Registry.get` and `Registry.get_all`. This allows other packages toauto-register functions.| Argument       | Type       | Description                                                                                    || -------------- | ---------- | ---------------------------------------------------------------------------------------------- || `*namespace`   | str        | The namespace, e.g. `&quot;spacy&quot;` or `&quot;spacy&quot;, &quot;architectures&quot;`.                                   || `entry_points` | bool       | Whether to check for entry points of the given namespace and pre-populate the global registry. || **RETURNS**    | `Registry` | The `Registry` object with methods to register and retrieve functions.                         |```pythonarchitectures = catalogue.create(&quot;spacy&quot;, &quot;architectures&quot;)# Use as decorator@architectures.register(&quot;custom_architecture&quot;)def custom_architecture():    pass# Use as regular functionarchitectures.register(&quot;custom_architecture&quot;, func=custom_architecture)```### &lt;kbd&gt;class&lt;/kbd&gt; `Registry`The registry object that can be used to register and retrieve functions. It'susually created internally when you call `catalogue.create`.#### &lt;kbd&gt;method&lt;/kbd&gt; `Registry.__init__`Initialize a new registry. If `entry_points=True` is set, the registry willcheck for[Python entry points](https://packaging.python.org/tutorials/packaging-projects/#entry-points)advertised for the given namespace, e.g. the entry point group`spacy_architectures` for the namespace `&quot;spacy&quot;, &quot;architectures&quot;`, in`Registry.get` and `Registry.get_all`.| Argument       | Type       | Description                                                                      || -------------- | ---------- | -------------------------------------------------------------------------------- || `namespace`    | Tuple[str] | The namespace, e.g. `&quot;spacy&quot;` or `&quot;spacy&quot;, &quot;architectures&quot;`.                     || `entry_points` | bool       | Whether to check for entry points of the given namespace in `get` and `get_all`. || **RETURNS**    | `Registry` | The newly created object.                                                        |```python# User-facing APIarchitectures = catalogue.create(&quot;spacy&quot;, &quot;architectures&quot;)# Internal APIarchitectures = Registry((&quot;spacy&quot;, &quot;architectures&quot;))```#### &lt;kbd&gt;method&lt;/kbd&gt; `Registry.__contains__`Check whether a name is in the registry.| Argument    | Type | Description                          || ----------- | ---- | ------------------------------------ || `name`      | str  | The name to check.                   || **RETURNS** | bool | Whether the name is in the registry. |```pythonarchitectures = catalogue.create(&quot;spacy&quot;, &quot;architectures&quot;)@architectures.register(&quot;custom_architecture&quot;)def custom_architecture():    passassert &quot;custom_architecture&quot; in architectures```#### &lt;kbd&gt;method&lt;/kbd&gt; `Registry.__call__`Register a function in the registry's namespace. Can be used as a decorator orcalled as a function with the `func` keyword argument supplying the function toregister. Delegates to `Registry.register`.#### &lt;kbd&gt;method&lt;/kbd&gt; `Registry.register`Register a function in the registry's namespace. Can be used as a decorator orcalled as a function with the `func` keyword argument supplying the function toregister.| Argument    | Type     | Description                                               || ----------- | -------- | --------------------------------------------------------- || `name`      | str      | The name to register under the namespace.                 || `func`      | Any      | Optional function to register (if not used as decorator). || **RETURNS** | Callable | The decorator that takes one argument, the name.          |```pythonarchitectures = catalogue.create(&quot;spacy&quot;, &quot;architectures&quot;)# Use as decorator@architectures.register(&quot;custom_architecture&quot;)def custom_architecture():    pass# Use as regular functionarchitectures.register(&quot;custom_architecture&quot;, func=custom_architecture)```#### &lt;kbd&gt;method&lt;/kbd&gt; `Registry.get`Get a function registered in the namespace.| Argument    | Type | Description              || ----------- | ---- | ------------------------ || `name`      | str  | The name.                || **RETURNS** | Any  | The registered function. |```pythoncustom_architecture = architectures.get(&quot;custom_architecture&quot;)```#### &lt;kbd&gt;method&lt;/kbd&gt; `Registry.get_all`Get all functions in the registry's namespace.| Argument    | Type           | Description                              || ----------- | -------------- | ---------------------------------------- || **RETURNS** | Dict[str, Any] | The registered functions, keyed by name. |```pythonall_architectures = architectures.get_all()# {&quot;custom_architecture&quot;: &lt;custom_architecture&gt;}```#### &lt;kbd&gt;method&lt;/kbd&gt; `Registry.get_entry_points`Get registered entry points from other packages for this namespace. The name ofthe entry point group is the namespace joined by `_`.| Argument    | Type           | Description                             || ----------- | -------------- | --------------------------------------- || **RETURNS** | Dict[str, Any] | The loaded entry points, keyed by name. |```pythonarchitectures = catalogue.create(&quot;spacy&quot;, &quot;architectures&quot;, entry_points=True)# Will get all entry points of the group &quot;spacy_architectures&quot;all_entry_points = architectures.get_entry_points()```#### &lt;kbd&gt;method&lt;/kbd&gt; `Registry.get_entry_point`Check if registered entry point is available for a given name in the namespaceand load it. Otherwise, return the default value.| Argument    | Type | Description                                      || ----------- | ---- | ------------------------------------------------ || `name`      | str  | Name of entry point to load.                     || `default`   | Any  | The default value to return. Defaults to `None`. || **RETURNS** | Any  | The loaded entry point or the default value.     |```pythonarchitectures = catalogue.create(&quot;spacy&quot;, &quot;architectures&quot;, entry_points=True)# Will get entry point &quot;custom_architecture&quot; of the group &quot;spacy_architectures&quot;custom_architecture = architectures.get_entry_point(&quot;custom_architecture&quot;)```#### &lt;kbd&gt;method&lt;/kbd&gt; `Registry.find`Find the information about a registered function, including the module and pathto the file it's defined in, the line number and the docstring, if available.| Argument    | Type                       | Description                         || ----------- | -------------------------- | ----------------------------------- || `name`      | str                        | Name of the registered function.    || **RETURNS** | Dict[str, Union[str, int]] | The information about the function. |```pythonimport cataloguearchitectures = catalogue.create(&quot;spacy&quot;, &quot;architectures&quot;, entry_points=True)@architectures(&quot;my_architecture&quot;)def my_architecture():    &quot;&quot;&quot;This is an architecture&quot;&quot;&quot;    passinfo = architectures.find(&quot;my_architecture&quot;)# {'module': 'your_package.architectures',#  'file': '/path/to/your_package/architectures.py',#  'line_no': 5,#  'docstring': 'This is an architecture'}```### &lt;kbd&gt;function&lt;/kbd&gt; `catalogue.check_exists`Check if a namespace exists.| Argument     | Type | Description                                                  || ------------ | ---- | ------------------------------------------------------------ || `*namespace` | str  | The namespace, e.g. `&quot;spacy&quot;` or `&quot;spacy&quot;, &quot;architectures&quot;`. || **RETURNS**  | bool | Whether the namespace exists.                                |</longdescription>
</pkgmetadata>