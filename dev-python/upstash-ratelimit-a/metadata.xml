<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Upstash Rate Limit - python editionupstash-ratelimit is a connectionless rate limiting library for python, designed to be used in serverless environments such as:- AWS Lambda- Google Cloud Functions- and other environments where HTTP is preferred over TCP.The sdk is currently compatible with python 3.10 and above.&lt;!-- toc --&gt;- [Quick Start](#quick-start)  - [Install](#install)    - [PyPi](#pypi)  - [Setup database client](#setup-database-client)  - [Usage](#usage)  - [Telemetry](#telemetry)  - [Block until ready](#block-until-ready)  - [Timeout](#timeout)  - [Rate-limiting outbound requests](#rate-limiting-outbound-requests)- [Ratelimiting algorithms](#ratelimiting-algorithms)  - [Fixed Window](#fixed-window)    - [Pros:](#pros)    - [Cons:](#cons)    - [Usage:](#usage)  - [Sliding Window](#sliding-window)    - [Pros:](#pros-1)    - [Cons:](#cons-1)    - [Usage:](#usage-1)  - [Token Bucket](#token-bucket)    - [Pros:](#pros-2)    - [Cons:](#cons-2)    - [Usage:](#usage-2)- [Contributing](#contributing)  - [Preparing the environment](#preparing-the-environment)  - [Adding new algorithms](#adding-new-algorithms)  - [Running tests](#running-tests)  - [Releasing](#releasing)&lt;!-- tocstop --&gt;# Quick Start## Install### PyPi```bashpip install upstash-ratelimit```If you are using a packaging and dependency management tool like [Poetry](https://python-poetry.org), you might want to checkthe respective docs in regard to adding a dependency. For example, in a Poetry-managed virtual environment, you can use:```bashpoetry add upstash-ratelimit```## Setup database clientTo be able to use upstash-ratelimit, you need to create a database on [Upstash](https://console.upstash.com/) and instantiatea client with the serverless driver:```pythonfrom upstash_redis.client import Redisredis = Redis(url=&quot;UPSTASH_REDIS_REST_URL&quot;, token=&quot;UPSTASH_REDIS_REST_TOKEN&quot;)```Or, if you want to automatically load the credentials from the environment:```pythonfrom upstash_redis.client import Redisredis = Redis.from_env()```The constructor can take even more optional parameters, some of them being (types expanded):```pythonurl: strtoken: strrest_encoding: Literal[&quot;base64&quot;] | Literal[False] = &quot;base64&quot;rest_retries: int = 1rest_retry_interval: int = 3 # In seconds.allow_deprecated: bool = Falseformat_return: bool = Trueallow_telemetry: bool = True```## Usage```pythonfrom upstash_ratelimit.limiter import RateLimitfrom upstash_ratelimit.schema.response import RateLimitResponsefrom upstash_redis.client import Redis# Create a ratelimit instance and load the Redis credentials from the environment.rate_limit = RateLimit(Redis.from_env())  # Optionally, pass your own client instance.# Chose one algorithm.fixed_window = rate_limit.fixed_window(    max_number_of_requests=1,    window=3,    unit=&quot;s&quot;)&quot;&quot;&quot;Use a constant to limit all the requests together.For enforcing individual limits, use some kind of identifying variable (IP address, API key, etc.).&quot;&quot;&quot;identifier: str = &quot;constant&quot;async def main() -&gt; str:    request_result: RateLimitResponse = await fixed_window.limit(identifier)    if not request_result[&quot;is_allowed&quot;]:        return f&quot;{identifier} is rate-limited!&quot;    else:        return &quot;Request passed!&quot;```You can also pass a `prefix` to the `RateLimit` constructor to distinguish between the keys used for rate limiting and others.It defaults to `&quot;ratelimit&quot;`.The `limit` method also returns some metadata that might be useful :```pythonfrom typing import TypedDictclass RateLimitResponse(TypedDict):    &quot;&quot;&quot;    The response given by the rate-limiting methods, with additional metadata.    &quot;&quot;&quot;    is_allowed: bool    # The maximum number of requests allowed within a window.    limit: int    # How many requests can still be made within the window. If negative, it means the limit has been exceeded.    remaining: int    # The unix time in milliseconds when the next window begins.    reset: int```## TelemetryThe underlying serverless driver can collect the following anonymous telemetry:  - the runtime (ex: `python@v.3.10.0`)  - the sdk or sdks you're using (ex: `upstash-py@development, upstash-ratelimit@v.0.1.0`)  - the platform you're running on (ex: `AWS-lambda`)If you want to opt-out, simply pass `allow_telemetry=False` to the Redis client.## Block until readyYou also have the option to try and wait for a request to pass in the given timeout.If the first request is blocked and the timeout exceeds the time needed for the next interval to come,we wait and retry once that happens.```pythonfrom upstash_ratelimit.limiter import RateLimitfrom upstash_ratelimit.schema.response import RateLimitResponsefrom upstash_redis.client import Redisrate_limit = RateLimit(Redis.from_env())fixed_window = rate_limit.fixed_window(    max_number_of_requests=1,    window=3,    unit=&quot;s&quot;)identifier: str = &quot;constant&quot;async def main() -&gt; str:    request_result: RateLimitResponse = await fixed_window.block_until_ready(identifier, timeout=2000)    if not request_result[&quot;is_allowed&quot;]:        return f&quot;The {identifier}'s request cannot be processed, even after 2 seconds.&quot;    else:        return &quot;Request passed!&quot;```## TimeoutIf you worry that network issues can cause your application to reject requests, you can use python's `wait_for` to allow the requests which exceed a given timeout to pass regardless of what the current limit is.```pythonfrom upstash_ratelimit.limiter import RateLimitfrom upstash_ratelimit.schema.response import RateLimitResponsefrom upstash_redis.client import Redisfrom asyncio import wait_forrate_limit = RateLimit(Redis.from_env())fixed_window = rate_limit.fixed_window(    max_number_of_requests=1,    window=3,    unit=&quot;s&quot;)identifier: str = &quot;constant&quot;async def main() -&gt; str:    try:        request_result: RateLimitResponse = await wait_for(fixed_window.limit(identifier), 2.0)  # Wait for two seconds.        if not request_result[&quot;is_allowed&quot;]:            return f&quot;{identifier} is rate-limited!&quot;        return &quot;Request passed!&quot;    except TimeoutError:        return &quot;Request passed&quot;```## Rate-limiting outbound requestsIt's also possible to limit the number of requests you're making to an external API.```pythonfrom upstash_ratelimit.limiter import RateLimitfrom upstash_ratelimit.schema.response import RateLimitResponsefrom upstash_redis.client import Redisrate_limit = RateLimit(Redis.from_env())fixed_window = rate_limit.fixed_window(    max_number_of_requests=1,    window=3,    unit=&quot;s&quot;)identifier: str = &quot;constant&quot;  # Or, use an identifier to limit your requests to a certain endpoint.async def main() -&gt; str:    request_result: RateLimitResponse = await fixed_window.limit(identifier)    if not request_result[&quot;is_allowed&quot;]:        return f&quot;{identifier} is rate-limited!&quot;    else:        # Call the API        # ...        return &quot;Request passed!&quot;```# Ratelimiting algorithms## Fixed WindowThe time is divided into windows of fixed length and each window has a maximum number of allowed requests.### Pros- Very cheap in terms of data size and computation- Newer requests are not starved due to a high burst in the past### Cons- Can cause high bursts at the window boundaries to leak through### Usage```pythonfrom upstash_ratelimit.limiter import RateLimitfrom upstash_redis.client import Redisrate_limit = RateLimit(Redis.from_env())fixed_window = rate_limit.fixed_window(    max_number_of_requests=1,    window=3,    unit=&quot;s&quot;)```## Sliding WindowCombined approach of sliding window and sliding logs that calculates a weighted score between two windowsto decide if a request should pass.### Pros- Approaches the issue near boundaries from fixed window.### Cons- More expensive in terms of storage and computation- It's only an approximation because it assumes a uniform request flow in the previous window### Usage```pythonfrom upstash_ratelimit.limiter import RateLimitfrom upstash_redis.client import Redisrate_limit = RateLimit(Redis.from_env())sliding_window = rate_limit.sliding_window(    max_number_of_requests=1,    window=3,    unit=&quot;s&quot;)```## Token BucketA bucket is filled with &quot;max_number_of_tokens&quot; that refill at &quot;refill_rate&quot; per &quot;interval&quot;.Each request tries to consume one token and if the bucket is empty, the request is rejected.### Pros- Bursts of requests are smoothed out, and you can process them at a constant rate- Allows setting a higher initial burst limit by setting maxTokens higher than refillRate### Cons- Expensive in terms of computation### Usage```pythonfrom upstash_ratelimit.limiter import RateLimitfrom upstash_redis.client import Redisrate_limit = RateLimit(Redis.from_env())token_bucket = rate_limit.token_bucket(    max_number_of_tokens=2,    refill_rate=1,    interval=3,    unit=&quot;s&quot;)```# Contributing## Preparing the environmentThis project uses [Poetry](https://python-poetry.org) for packaging and dependency management. See [this](https://python-poetry.org/docs/basic-usage/#using-your-virtual-environment) for a detailed explanation on howto work with the virtual environment.You will also need a database on [Upstash](https://console.upstash.com/). If you already have one, make sure to empty it before running tests. You can do so by sending `FLUSHDB` from the console.## Adding new algorithmsAll the algorithms subclass and implement abstract [RateLimitAlgorithm](upstash_ratelimit/algorithm.py)'s methods.They are also grouped in the [RateLimit](upstash_ratelimit/limiter.py) class for ease of use.## Running testsAll tests live in the [test](./tests) folder.Only the logic of 100%-accuracy algorithms and other utility functions are unit-tested.To run all the tests, make sure you are in the `tests` folder and have the poetry virtual environment activated with all the necessary dependencies. Set the `UPSTASH_REDIS_REST_URL` and `UPSTASH_REDIS_REST_TOKEN` environment variables and run:```bashpoetry run pytest --import-mode importlib```The reason we need to use the `importlib` mode is because there are multiple test files with the same name. See the [pytest docs](https://docs.pytest.org/en/stable/explanation/pythonpath.html#import-modes) for more info.**Warning**: The current evaluation speed of the tests does not take the HTTP requests duration into account. Because of that, if a request takes more than 2 seconds to complete, a test might fail.## ReleasingTo create a new release, first use Poetry's [version](https://python-poetry.org/docs/cli/#version) command.You will then need to connect your PyPi API token to Poetry. A simple tutorial showcasing how to do it was posted by Tony Tran[on DigitalOcean](https://www.digitalocean.com/community/tutorials/how-to-publish-python-packages-to-pypi-using-poetry-on-ubuntu-22-04)From there, use `poetry publish --build`.</longdescription>
</pkgmetadata>