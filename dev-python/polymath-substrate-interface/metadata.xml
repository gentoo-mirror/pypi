<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>#### This project is forked from https://github.com/polkascan/py-substrate-interface# Python Polymath Substrate Interface[![Latest Version](https://img.shields.io/pypi/v/polymath-substrate-interface.svg)](https://pypi.org/project/polymath-substrate-interface/)[![Supported Python versions](https://img.shields.io/pypi/pyversions/polymath-substrate-interface.svg)](https://pypi.org/project/polymath-substrate-interface/)Python Polymath Substrate Interface Library## DescriptionThis library specializes in interfacing with a Polymesh node, providing additional convenience methods to deal withSCALE encoding/decoding (the default output and input format of the Substrate JSONRPC), metadata parsing, type registrymanagement and versioning of types.## Table of Contents* [Documentation](#documentation)* [Installation](#installation)* [Initialization](#hello-world--the-flipper)  * [Autodiscover mode](#autodiscover-mode)  * [Manually set required properties](#manually-set-required-properties)    * [Substrate Node Template](#substrate-node-template)* [Features](#features)  * [Get extrinsics for a certain block](#retrieve-extrinsics-for-a-certain-block)  * [Subscribe to new block headers](#subscribe-to-new-block-headers)  * [Storage queries](#storage-queries)  * [Storage subscriptions](#storage-subscriptions)  * [Query a mapped storage function](#query-a-mapped-storage-function)  * [Create and send signed extrinsics](#create-and-send-signed-extrinsics)  * [Examining the ExtrinsicReceipt object](#examining-the-extrinsicreceipt-object)  * [ink! contract interfacing](#ink-contract-interfacing)  * [Create mortal extrinsics](#create-mortal-extrinsics)  * [Keypair creation and signing](#keypair-creation-and-signing)  * [Creating keypairs with soft and hard key derivation paths](#creating-keypairs-with-soft-and-hard-key-derivation-paths)  * [Getting estimate of network fees for extrinsic in advance](#getting-estimate-of-network-fees-for-extrinsic-in-advance)  * [Offline signing of extrinsics](#offline-signing-of-extrinsics)  * [Accessing runtime constants](#accessing-runtime-constants)* [Keeping type registry presets up to date](#keeping-type-registry-presets-up-to-date)* [Cleanup and context manager](#cleanup-and-context-manager)  * [License](#license)## Documentationhttps://polkascan.github.io/py-substrate-interface/## Installation```bashpip install polymath-substrate-interface```## InitializationThe following examples show how to initialize for Polymesh chain:Westend```pythonsubstrate = SubstrateInterface(    url=&quot;wss://westend-rpc.polkadot.io&quot;,    ss58_format=42,    type_registry_preset='westend')```### Substrate Node TemplateCompatible with https://github.com/substrate-developer-hub/substrate-node-template ```pythonsubstrate = SubstrateInterface(    url=&quot;ws://127.0.0.1:9944&quot;,    ss58_format=42,    type_registry_preset='substrate-node-template')```If custom types are introduced in the Substrate chain, the following example will add compatibility by creating a custom type registry JSON file and including this during initialization:```json{  &quot;runtime_id&quot;: 2,  &quot;types&quot;: {    &quot;MyCustomInt&quot;: &quot;u32&quot;,    &quot;MyStruct&quot;: {      &quot;type&quot;: &quot;struct&quot;,      &quot;type_mapping&quot;: [         [&quot;account&quot;, &quot;AccountId&quot;],         [&quot;message&quot;, &quot;Vec&lt;u8&gt;&quot;]      ]    }  },  &quot;versioning&quot;: [  ]}``````pythoncustom_type_registry = load_type_registry_file(&quot;my-custom-types.json&quot;)substrate = SubstrateInterface(    url=&quot;ws://127.0.0.1:9944&quot;,    ss58_format=42,    type_registry_preset='substrate-node-template',    type_registry=custom_type_registry)```## Keeping type registry presets up to dateWhen on-chain runtime upgrades occur, types used in call- or storage functions can be added or modified. Therefor it isimportant to keep the type registry presets up to date. At the moment the type registry for Polymesh is being actively maintained for this library and an check and update procedure can be triggered with:```pythonsubstrate.update_type_registry_presets()```   ## Examples### Get extrinsics for a certain block```python# Set block_hash to None for chaintipblock_hash = &quot;0x51d15792ff3c5ee9c6b24ddccd95b377d5cccc759b8e76e5de9250cf58225087&quot;# Retrieve extrinsics in blockresult = substrate.get_block(block_hash=block_hash)for extrinsic in result['extrinsics']:    if extrinsic.address:        signed_by_address = extrinsic.address.value    else:        signed_by_address = None    print('\nPallet: {}\nCall: {}\nSigned by: {}'.format(        extrinsic.call_module.name,        extrinsic.call.name,        signed_by_address    ))    # Loop through call params    for param in extrinsic.params:        if param['type'] == 'Compact&lt;Balance&gt;':            param['value'] = '{} {}'.format(param['value'] / 10 ** substrate.token_decimals, substrate.token_symbol)        print(&quot;Param '{}': {}&quot;.format(param['name'], param['value']))```### Subscribe to new block headers```pythondef subscription_handler(obj, update_nr, subscription_id):    print(f&quot;New block #{obj['header']['number']} produced by {obj['author']}&quot;)    if update_nr &gt; 10:        return {'message': 'Subscription will cancel when a value is returned', 'updates_processed': update_nr}result = substrate.subscribe_block_headers(subscription_handler, include_author=True)```### Storage queriesThe modules and storage functions are provided in the metadata (see `substrate.get_metadata_storage_functions()`),parameters will be automatically converted to SCALE-bytes (also including decoding of SS58 addresses).Example: ```pythonresult = substrate.query(    module='System',    storage_function='Account',    params=['F4xQKRUagnSGjFqafyhajLs94e7Vvzvr8ebwYJceKpr8R7T'])print(result.value['nonce']) #  7695print(result.value['data']['free']) # 635278638077956496```Or get the account info at a specific block hash:```pythonaccount_info = substrate.query(    module='System',    storage_function='Account',    params=['F4xQKRUagnSGjFqafyhajLs94e7Vvzvr8ebwYJceKpr8R7T'],    block_hash='0x176e064454388fd78941a0bace38db424e71db9d5d5ed0272ead7003a02234fa')print(account_info.value['nonce']) #  7673print(account_info.value['data']['free']) # 637747267365404068```### Storage subscriptionsWhen a callable is passed as kwarg `subscription_handler`, there will be a subscription created for given storage query. Updates will be pushed to the callable and will block execution until a final value is returned. This value will be returnedas a result of the query and finally automatically unsubscribed from further updates.```pythondef subscription_handler(account_info_obj, update_nr, subscription_id):    if update_nr == 0:        print('Initial account data:', account_info_obj.value)    if update_nr &gt; 0:        # Do something with the update        print('Account data changed:', account_info_obj.value)    # The execution will block until an arbitrary value is returned, which will be the result of the `query`    if update_nr &gt; 5:        return account_info_objresult = substrate.query(&quot;System&quot;, &quot;Account&quot;, [&quot;5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY&quot;],                         subscription_handler=subscription_handler)print(result)```### Query a mapped storage functionMapped storage functions can be iterated over all key/value pairs, for these type of storage functions `query_map` can be used.The result is a `QueryMapResult` object, which is an iterator:```python# Retrieve the first 199 System.Account entriesresult = substrate.query_map('System', 'Account', max_results=199)for account, account_info in result:    print(f&quot;Free balance of account '{account.value}': {account_info.value['data']['free']}&quot;)```These results are transparantly retrieved in batches capped by the `page_size` kwarg, currently the maximum `page_size` restricted by the RPC node is 1000    ```python# Retrieve all System.Account entries in batches of 200 (automatically appended by `QueryMapResult` iterator)result = substrate.query_map('System', 'Account', page_size=200, max_results=400)for account, account_info in result:    print(f&quot;Free balance of account '{account.value}': {account_info.value['data']['free']}&quot;)```Querying a `DoubleMap` storage function:```pythonera_stakers = substrate.query_map(    module='Staking',    storage_function='ErasStakers',    params=[2100])```### Create and send signed extrinsicsThe following code snippet illustrates how to create a call, wrap it in a signed extrinsic and send it to the network:```pythonfrom substrateinterface import SubstrateInterface, Keypairfrom substrateinterface.exceptions import SubstrateRequestExceptionsubstrate = SubstrateInterface(    url=&quot;ws://127.0.0.1:9944&quot;,    ss58_format=42,    type_registry_preset='kusama')keypair = Keypair.create_from_mnemonic('episode together nose spoon dose oil faculty zoo ankle evoke admit walnut')call = substrate.compose_call(    call_module='Balances',    call_function='transfer',    call_params={        'dest': '5E9oDs9PjpsBbxXxRE9uMaZZhnBAV38n2ouLB28oecBDdeQo',        'value': 1 * 10**12    })extrinsic = substrate.create_signed_extrinsic(call=call, keypair=keypair)try:    receipt = substrate.submit_extrinsic(extrinsic, wait_for_inclusion=True)    print(&quot;Extrinsic '{}' sent and included in block '{}'&quot;.format(receipt.extrinsic_hash, receipt.block_hash))except SubstrateRequestException as e:    print(&quot;Failed to send: {}&quot;.format(e))```The `wait_for_inclusion` keyword argument used in the example above will block giving the result until it gets confirmation from the node that the extrinsic is succesfully included in a block. The `wait_for_finalization` keywordwill wait until extrinsic is finalized. Note this feature is only available for websocket connections. ### Examining the ExtrinsicReceipt objectThe `substrate.submit_extrinsic` example above returns an `ExtrinsicReceipt` object, which contains information about the on-chain execution of the extrinsic. Because the `block_hash` is necessary to retrieve the triggered events from storage, mostinformation is only available when `wait_for_inclusion=True` or `wait_for_finalization=True` is used when submittingan extrinsic. Examples:```pythonreceipt = substrate.submit_extrinsic(extrinsic, wait_for_inclusion=True)print(receipt.is_success) # Falseprint(receipt.weight) # 216625000print(receipt.total_fee_amount) # 2749998966print(receipt.error_message['name']) # 'LiquidityRestrictions'````ExtrinsicReceipt` objects can also be created for all existing extrinsics on-chain:```pythonreceipt = ExtrinsicReceipt(    substrate=substrate,    extrinsic_hash=&quot;0x56fea3010910bd8c0c97253ffe308dc13d1613b7e952e7e2028257d2b83c027a&quot;,    block_hash=&quot;0x04fb003f8bc999eeb284aa8e74f2c6f63cf5bd5c00d0d0da4cd4d253a643e4c9&quot;)print(receipt.is_success) # Falseprint(receipt.extrinsic.call_module.name) # 'Identity'print(receipt.extrinsic.call.name) # 'remove_sub'print(receipt.weight) # 359262000print(receipt.total_fee_amount) # 2483332406print(receipt.error_message['docs']) # [' Sender is not a sub-account.']for event in receipt.triggered_events:    print(f'* {event.value}')```### ink! contract interfacing#### Deploy a contract Tested on [canvas-node](https://github.com/paritytech/canvas-node) with the [Flipper contract from the tutorial](https://substrate.dev/substrate-contracts-workshop/#/0/deploy-contract)_:```pythonsubstrate = SubstrateInterface(    url=&quot;ws://127.0.0.1:9944&quot;,    type_registry_preset='canvas')keypair = Keypair.create_from_uri('//Alice')# Deploy contractcode = ContractCode.create_from_contract_files(    metadata_file=os.path.join(os.path.dirname(__file__), 'assets', 'flipper.json'),    wasm_file=os.path.join(os.path.dirname(__file__), 'assets', 'flipper.wasm'),    substrate=substrate)contract = code.deploy(    keypair=keypair,    endowment=10 ** 15,    gas_limit=1000000000000,    constructor=&quot;new&quot;,    args={'init_value': True},    upload_code=True)print(f'✅ Deployed @ {contract.contract_address}')```#### Work with an existing instance:```python# Create contract instance from deterministic addresscontract = ContractInstance.create_from_address(    contract_address=contract_address,    metadata_file=os.path.join(os.path.dirname(__file__), 'assets', 'flipper.json'),    substrate=substrate)```#### Read data from a contract:```pythonresult = contract.read(keypair, 'get')print('Current value of &quot;get&quot;:', result.contract_result_data)```#### Execute a contract call```python # Do a gas estimation of the messagegas_predit_result = contract.read(keypair, 'flip')print('Result of dry-run: ', gas_predit_result.contract_result_data)print('Gas estimate: ', gas_predit_result.gas_consumed)# Do the actual transferprint('Executing contract call...')contract_receipt = contract.exec(keypair, 'flip', args={}, gas_limit=gas_predit_result.gas_consumed)print(f'Events triggered in contract: {contract_receipt.contract_events}')```See complete [code example](https://github.com/polkascan/py-substrate-interface/blob/master/examples/create_and_exec_contract.py) for more details### Create mortal extrinsicsBy default, _immortal_ extrinsics are created, which means they have an indefinite lifetime for being included in a block. However, it is recommended to use specify an expiry window, so you know after a certain amount of time if the extrinsic is not included in a block, it will be invalidated.```python extrinsic = substrate.create_signed_extrinsic(call=call, keypair=keypair, era={'period': 64})```The `period` specifies the number of blocks the extrinsic is valid counted from current head.### Keypair creation and signing```pythonmnemonic = Keypair.generate_mnemonic()keypair = Keypair.create_from_mnemonic(mnemonic)signature = keypair.sign(&quot;Test123&quot;)if keypair.verify(&quot;Test123&quot;, signature):    print('Verified')```By default, a keypair is using SR25519 cryptography, alternatively ED25519 can be explictly specified:```pythonkeypair = Keypair.create_from_mnemonic(mnemonic, crypto_type=KeypairType.ED25519)```### Creating keypairs with soft and hard key derivation paths```pythonmnemonic = Keypair.generate_mnemonic()keypair = Keypair.create_from_uri(mnemonic + '//hard/soft')```By omitting the mnemonic the default development mnemonic is used: ```pythonkeypair = Keypair.create_from_uri('//Alice')```### Getting estimate of network fees for extrinsic in advance```pythonkeypair = Keypair(ss58_address=&quot;EaG2CRhJWPb7qmdcJvy3LiWdh26Jreu9Dx6R1rXxPmYXoDk&quot;)call = substrate.compose_call(    call_module='Balances',    call_function='transfer',    call_params={        'dest': 'EaG2CRhJWPb7qmdcJvy3LiWdh26Jreu9Dx6R1rXxPmYXoDk',        'value': 2 * 10 ** 3    })payment_info = substrate.get_payment_info(call=call, keypair=keypair)# {'class': 'normal', 'partialFee': 2499999066, 'weight': 216625000}```### Offline signing of extrinsicsThis example generates a signature payload which can be signed on another (offline) machine and later on sent to the network with the generated signature.- Generate signature payload on online machine:```pythonsubstrate = SubstrateInterface(    url=&quot;ws://127.0.0.1:9944&quot;,    ss58_format=42,    type_registry_preset='substrate-node-template',)call = substrate.compose_call(    call_module='Balances',    call_function='transfer',    call_params={        'dest': '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY',        'value': 2 * 10**8    })era = {'period': 64, 'current': 22719}nonce = 0signature_payload = substrate.generate_signature_payload(call=call, era=era, nonce=nonce)```- Then on another (offline) machine generate the signature with given `signature_payload`:```pythonkeypair = Keypair.create_from_mnemonic(&quot;nature exchange gasp toy result bacon coin broccoli rule oyster believe lyrics&quot;)signature = keypair.sign(signature_payload)```- Finally on the online machine send the extrinsic with generated signature:```pythonkeypair = Keypair(ss58_address=&quot;5EChUec3ZQhUvY1g52ZbfBVkqjUY9Kcr6mcEvQMbmd38shQL&quot;)extrinsic = substrate.create_signed_extrinsic(    call=call,    keypair=keypair,    era=era,    nonce=nonce,    signature=signature)result = substrate.submit_extrinsic(    extrinsic=extrinsic)print(result.extrinsic_hash)```### Accessing runtime constantsAll runtime constants are provided in the metadata (see `substrate.get_metadata_constants()`),to access these as a decoded `ScaleType` you can use the function `substrate.get_constant()`:```pythonconstant = substrate.get_constant(&quot;Balances&quot;, &quot;ExistentialDeposit&quot;)print(constant.value) # 10000000000```## Cleanup and context managerAt the end of the lifecycle of a `SubstrateInterface` instance, calling the `close()` method will do all the necessary cleanup, like closing the websocket connection.When using the context manager this will be done automatically:```pythonwith SubstrateInterface(url=&quot;wss://rpc.polkadot.io&quot;) as substrate:    events = substrate.query(&quot;System&quot;, &quot;Events&quot;)# connection is now closed```## Keeping type registry presets up to dateWhen on-chain runtime upgrades occur, types used in call- or storage functions can be added or modified. Therefor it isimportant to keep the type registry presets up to date, otherwise this can lead to decoding errors like `RemainingScaleBytesNotEmptyException`. At the moment the type registry presets for Polkadot, Kusama, Rococo andWestend are being actively maintained for this library, and a check and update procedure can be triggered with:```pythonsubstrate.reload_type_registry()```This will also activate the updated preset for the current instance.It is also possible to always use the remote type registry preset from Github with the `use_remote_preset` kwarg when instantiating:```pythonsubstrate = SubstrateInterface(    url=&quot;wss://rpc.polkadot.io&quot;,    ss58_format=0,    type_registry_preset='polkadot',    use_remote_preset=True)```To check for updates after instantiating the `substrate` object, using `substrate.reload_type_registry()` will download the most recent type registry preset from Github and apply changes to current object.  ## Licensehttps://github.com/PolymathNetwork/py-substrate-interface/blob/master/LICENSE</longdescription>
</pkgmetadata>