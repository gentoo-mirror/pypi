<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>AutoFaker is a Python library designed to minimize the setup/arrange phase of your unit tests by removing the need to manually write code to create anonymous variables as part of a test cases setup/arrange phase. This library is heavily inspired by [AutoFixture](https://github.com/AutoFixture/AutoFixture) and was initially created for simplifying how to write unit tests for ETL (Extract-Transform-Load) code running from a python library on an Apache Spark cluster in Big Data solutions.When writing unit tests you normally start with creating objects that represent the initial state of the test.This phase is called the **arrange** or setup phase of the test.In most cases, the system you want to test will force you to specify much more information than you really care about, so you frequently end up creating objects with no influence on the test itself just simply to satisfy the compiler/interpreter[AutoFaker](https://pypi.org/project/autofaker/) is available from PyPI and should be installed using `pip````pip install autofaker```AutoFaker can help by creating such anonymous variables for you. Here's a simple example:```pythonimport unittestfrom autofaker import Autodataclass Calculator:  def add(self, number1: int, number2: int):    return number1 + number2class CalculatorTests(unittest.TestCase):    def test_can_add_two_numbers(self):              # arrange        numbers = Autodata.create_many(int, 2)        sut = Autodata.create(Calculator)                # act        result = sut.add(numbers[0], numbers[1])                # assert        self.assertEqual(numbers[0] + numbers[1], result)```Since the point of this library is to simplify the **arrange** step of writing unit tests, we can use the`@autodata` and `@fakedata` are available to explicitly state whether to use anonymous variables or fake data and construct our system under test.To use this you can either define the types or the arguments as function arguments to the decorator, or specify argument annotations```pythonimport unittestfrom autofaker import autodataclass Calculator:  def add(self, number1: int, number2: int):    return number1 + number2class CalculatorTests(unittest.TestCase):    @autodata(Calculator, int, int)    def test_can_add_two_numbers_using_test_arguments(self, sut, number1, number2):        result = sut.add(number1, number2)        self.assertEqual(number1 + number2, result)    @autodata()    def test_can_add_two_numbers_using_annotated_arguments(self,                                                            sut: Calculator,                                                            number1: int,                                                            number2: int):        result = sut.add(number1, number2)        self.assertEqual(number1 + number2, result)```There are times when completely anonymous variables don't make much sense, especially in data centric scenarios. For these use cases this library uses [Faker](https://github.com/joke2k/faker) for generating fake data. This option is enabled by setting `use_fake_data` to `True` when calling the `Autodata.create()` function```pythonfrom dataclasses import dataclassfrom autofaker import Autodata@dataclassclass DataClass:    id: int    first_name: str    last_name: str    address: str    job: strdata = Autodata.create(DataClass, use_fake_data=True)print(f'id:     {data.id}')print(f'name:   {data.name}')print(f'job:    {data.job}\n')```The following code above might output something like:```id:     8952name:   Justin Wisejob:    Chief Operating Officer```## Supported data typesCurrently autofaker supports creating anonymous variables for the following data types:Built-in types:- int- float- str- complex- range- bytes- bytearrayDatetime types:- datetime- dateClasses:- Simple classes- @dataclass- Nested classes (and recursion)- Classes containing lists of other types- Enum classesDataframes:- Pandas dataframe## Example usagesCreate anonymous built-in types like `int`, `float`, `str` and datetime types like `datetime` and `date````pythonprint(f'anonymous string:    {Autodata.create(str)}')print(f'anonymous int:       {Autodata.create(int)}')print(f'anonymous float:     {Autodata.create(float)}')print(f'anonymous complex:   {Autodata.create(complex)}')print(f'anonymous range:     {Autodata.create(range)}')print(f'anonymous bytes:     {Autodata.create(bytes)}')print(f'anonymous bytearray: {Autodata.create(bytearray)}')print(f'anonymous datetime:  {Autodata.create(datetime)}')print(f'anonymous date:      {Autodata.create(datetime.date)}')```The code above might output the following```anonymous string:    f91954f1-96df-463f-a427-665c99213395anonymous int:       2066712686anonymous float:     725758222.8712853anonymous datetime:  2017-06-19 02:40:41.000084anonymous date:      2019-11-10 00:00:00```Creates an anonymous class```pythonclass SimpleClass:    id = -1    text = 'test'cls = Autodata.create(SimpleClass)print(f'id = {cls.id}')print(f'text = {cls.text}')```The code above might output the following```id = 2020177162text = ac54a65d-b4a3-4eda-a840-eb948ad10d5f```Create a collection of an anonymous class```pythonclass SimpleClass:    id = -1    text = 'test'classes = Autodata.create_many(SimpleClass)for cls in classes:  print(f'id = {cls.id}')  print(f'text = {cls.text}')  print()```The code above might output the following```id = 242996515text = 5bb60504-ccca-4104-9b7f-b978e52a6518id = 836984239text = 079df61e-a87e-4f26-8196-3f44157aabd6id = 570703150text = a3b86f08-c73a-4730-bde7-4bdff5360ef4```Creates an anonymous dataclass```pythonfrom dataclasses import dataclass@dataclassclass DataClass:    id: int    text: strcls = Autodata.create(DataClass)print(f'id = {cls.id}')print(f'text = {cls.text}')```The code above might output the following```id = 314075507text = 4a3b3cae-f4cf-4502-a7f3-61115a1e0d2a```Creates an anonymous dataclass using fake data```python@dataclassclass DataClass:    id: int    name: str    address: str    job: str    country: str    currency_name: str    currency_code: str    email: str    safe_email: str    company_email: str    hostname: str    ipv4: str    ipv6: str    text: strdata = Autodata.create(DataClass, use_fake_data=True)print(f'id:               {data.id}')print(f'name:             {data.name}')print(f'job:              {data.job}\n')print(f'address:\n{data.address}\n')print(f'country:          {data.country}')print(f'currency name:    {data.currency_name}')print(f'currency code:    {data.currency_code}\n')print(f'email:            {data.email}')print(f'safe email:       {data.safe_email}')print(f'work email:       {data.company_email}\n')print(f'hostname:         {data.hostname}')print(f'IPv4:             {data.ipv4}')print(f'IPv6:             {data.ipv6}\n')print(f'text:\n{data.text}')```The code above might output the following```id:               8952name:             Justin Wisejob:              Chief Operating Officeraddress:65939 Hernandez ParksRochaport, NC 41760country:          Equatorial Guineacurrency name:    Burmese kyatcurrency code:    ERNemail:            smithjohn@example.comsafe email:       kent11@example.comwork email:       marissagreen@brown-cole.comhostname:         db-90.hendricks-west.orgIPv4:             66.139.143.242IPv6:             895d:82f7:7c13:e7cb:f35d:c93:aeb2:8eebtext:Movie author culture represent. Enjoy myself over physical green lead but home.Share wind factor far minute produce significant. Sense might fact leader.```Create an anonymous class with nested types```pythonclass NestedClass:    id = -1    text = 'test'    inner = SimpleClass()cls = Autodata.create(NestedClass)print(f'id = {cls.id}')print(f'text = {cls.text}')print(f'inner.id = {cls.inner.id}')print(f'inner.text = {cls.inner.text}')```The code above might output the following```id = 1565737216text = e66ecd5c-c17a-4426-b755-36dfd2082672inner.id = 390282329inner.text = eef94b5c-aa95-427a-a9e6-d99e2cc1ffb2```Create a collection of an anonymous class with nested types```pythonclass NestedClass:    id = -1    text = 'test'    inner = SimpleClass()classes = Autodata.create_many(NestedClass)for cls in classes:  print(f'id = {cls.id}')  print(f'text = {cls.text}')  print(f'inner.id = {cls.inner.id}')  print(f'inner.text = {cls.inner.text}')  print()```The code above might output the following```id = 1116454042text = ceeecf0c-7375-4f3a-8d4b-6d7a4f2b20fdinner.id = 1067027444inner.text = 079573ce-1ef4-408d-8984-1dbc7b0d0b80id = 730390288text = ff3ca474-a69d-4ff6-95b4-fbdb1bea7cdbinner.id = 1632771208inner.text = 9423e824-dc8f-4145-ba47-7301351a91f8id = 187364960text = b31ca191-5031-43a2-870a-7bc7c99e4110inner.id = 1705149100inner.text = e703a117-ba4f-4201-a31b-10ab8e54a673```Create a Pandas DataFrame using anonymous data generated from a specified type```pythonclass DataClass:    id = -1    type = ''     value = 0pdf = Autodata.create_pandas_dataframe(DataClass)print(pdf)```The code above might output the following```          id                                  type       value0  778090854  13537c5a-62e7-488b-836e-a4b17f2f3ae9  10490156951  602015506  c043ca8d-e280-466a-8bba-ec1e0539fe28  10163593532  387753717  986b3b1c-abf4-4bc1-95cf-0e979390e4f3   766159839```Create a Pandas DataFrame using fake data generated from a specified type```pythonclass DataClass:    id = -1    type = ''     value = 0pdf = Autodata.create_pandas_dataframe(DataClass, use_fake_data=True)print(pdf)```The code above might output the following```  first_name    id last_name          phone_number0   Lawrence  7670   Jimenez  001-172-307-0561x4711      Bryan  9084    Walker         (697)893-67672       Paul  9824    Thomas    960.555.3577x65487```#For tips and tricks on software development, check out [my blog](https://christianhelle.com)If you find this useful and feel a bit generous then feel free to [buy me a coffee ☕](https://www.buymeacoffee.com/christianhelle)</longdescription>
</pkgmetadata>