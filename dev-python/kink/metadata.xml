<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Kink ![PyPI](https://img.shields.io/pypi/v/kink) ![Linting and Tests](https://github.com/kodemore/kink/workflows/Linting%20and%20Tests/badge.svg?branch=master) [![codecov](https://codecov.io/gh/kodemore/kink/branch/master/graph/badge.svg)](https://codecov.io/gh/kodemore/kink) [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)Dependency injection container made for python## Features- Easy to use interface- Extensible with custom dependency resolvers- Automatic dependency injection (Autowiring)- Lightweight- Support for async with asyncio## Installation### Pip```shellpip install kink```### PoetryIf you don't know poetry, I highly recommend visiting their [webpage](https://python-poetry.org)```shellpoetry add kink```# Why using dependency injection in python?## Short story Because python is a multi paradigm language and this should encourage you to use best OOP practices improving your workflow and your code and have more timefor your hobbies and families instead monkey-patching entire world.## Long storyDependency happens when one component (component might be a class, or a function) `A` uses other component `B`. We say than that `A` depends on `B`.Instead hardcoding dependency inside your components and making your code tightly coupledyou are loosing it by providing(injecting) required behaviour either by subclassing orplugging additional code. This is called `Inversion of Control` which keeps your codeoriented around behaviour rather than control. There are many benefits coming out of it:- increased modularity- better extensibility and flexibility- it helps you understand higher concepts like event driven programmingThis is where dependency injection comes in place. Dependency injection is a specificstyle of inversion of control, which generally says instead hardcoding dependency passdependant object as a parameter to a method rather than having method creating it itself.( who would thought it is so easy :)? ). It can go even further than that; when you passa dependency don't rely on a particular implementation rely on an abstraction (`Dependency Inversion Principle`).So you might ask why do I need it? Here is couple reasons:### Relying on the global state is evilCoding is hard enough ( business requirements are changing all the time, deadlines areshortening, clients wants more, there are so many unknowns you have to figure out), relying on unpredictable state makes it even harder:- it might introduce potential bugs- makes code harder to maintain- concurrency becomes harder to achieve- balancing mokey-patching well is a hard task### Great, but now I have additional work I have to manage now all my dependencies write more code and deadlines are coming even closer!True, that is why you should pick up Dependency Injection Container to do all this work for you. Kink gives you one decorator and simple `dict-like` object to bootstrap and manipulateyour container.No need for manual work and manual dependency management. Give it a try and you will love it!# UsageTo fully utilise the potential of kink it is recommended to bootstrap your initial dependencies(config values, or instances of classes that are standalone, requires no other dependencies than themselves).Some people prefer to keep it in `__init__.py` in the top module of your application, othercreate separate `bootstra.py` file for this purpose. Once all is setup the only step left is to decorate your classes/functions with `@inject` decorator.## Bootstrapping/Adding services manually### Adding *service* to di containerDependency container is a dict-like object, adding new service to dependency container is as simple as the following example:```pythonfrom kink import difrom os import getenvdi[&quot;db_name&quot;] = getenv(&quot;DB_NAME&quot;)di[&quot;db_password&quot;] = getenv(&quot;DB_PASSWORD&quot;)```### Adding *on-demand service* to dependency injection containerKink also supports on-demand service creation. In order to define such a service, lambda function should be used: ```pythonfrom kink import difrom sqlite3 import connectdi[&quot;db_connection&quot;] = lambda di: connect(di[&quot;db_name&quot;])```In this scenario connection to database will not be established until service is requested.### Adding factorised services to dependency injectionFactorised services are services that are instantiated every time they are requested.```pythonfrom kink import difrom sqlite3 import connectdi.factories[&quot;db_connection&quot;] = lambda di: connect(di[&quot;db_name&quot;])connection_1 = di[&quot;db_connection&quot;]connection_2 = di[&quot;db_connection&quot;]connection_1 != connection_2```In the above example we defined factorised service `db_connection`, and below by accessing the service from di we createdtwo separate connection to database.## Requesting services from dependency injection containerTo access given service just reference it inside `di` like you would do this witha normal dictionary, full example below:```pythonfrom kink import difrom sqlite3 import connect# Bootstrappingdi[&quot;db_name&quot;] = &quot;test_db.db&quot;di[&quot;db_connection&quot;] = lambda di: connect(di[&quot;db_name&quot;])# Getting a serviceconnection = di[&quot;db_connection&quot;] # will return instance of sqlite3.Connectionassert connection == di[&quot;db_connection&quot;] # True```## Autowiring dependenciesAutowiring is the ability of the container to automatically create and inject dependencies.It detects dependencies of the component tries to search for references in the containerand if all references are present an instance of requested service is returned.Autowiring system in kink works in two ways:- matching argument's names- matching argument's type annotation### How dependencies are prioritised by autowiring mechanismAutowiring mechanism priorities dependencies automatically, so when multiplematches are found for the service this is how it works;Firstly passed arguments are prioritied - if you pass arguments manually to the servicethey will take precendence over anything else. Next argument's names are taken intoconsideration and last but not least argument's type annotations.### Matching argument's namesIf you don't like type annotations or would like to take advantage of autowiring's precedence mechanism use this style.This is a very simple mechanism we have already seen in previous examples. Autowiring system checks function argument's names and tries to search for services with the same names inside the container. ### Matching argument's type annotationsIf you are like me and like type annotations and use static analysis tools this isa preferred way working with DI container. In this scenario names are ignored instead argument's type annotations are inspectedand looked up inside di container. This requires aliases when bootstrapping your services in DI container or simply adding them to container in the way thatits type is the key by which service is accessed. Please consider the following example:```pythonfrom kink import di, injectfrom sqlite3 import connect, Connectiondi[&quot;db_name&quot;] = &quot;test_db.db&quot;di[Connection] = lambda di: connect(di[&quot;db_name&quot;])  # sqlite connection can be accessed by its type@inject # Constructor injection will happen hereclass UserRepository:  def __init__(self, db: Connection): # `db` argument will be resolved because `Connection` instance is present in the container.     self.db = dbrepo = di[UserRepository]assert repo.db == di[Connection] # True```## Constructor injection```pythonfrom kink import inject, diimport MySQLdb# Set dependenciesdi[&quot;db_host&quot;] = &quot;localhost&quot;di[&quot;db_name&quot;] = &quot;test&quot;di[&quot;db_user&quot;] = &quot;user&quot;di[&quot;db_password&quot;] = &quot;password&quot;di[&quot;db_connection&quot;] = lambda di: MySQLdb.connect(host=di[&quot;db_host&quot;], user=di[&quot;db_user&quot;], passwd=di[&quot;db_password&quot;], db=di[&quot;db_name&quot;])@injectclass AbstractRepository:    def __init__(self, db_connection):        self.connection = db_connectionclass UserRepository(AbstractRepository):    ...repository = di[UserRepository] # will retrieve instance of UserRepository from di containerrepository.connection # mysql db connection is resolved and available to use.```When class is annotated by `inject` annotation it will be automatically added to the container for future use (eg autowiring).## Services aliasingWhen you register a service with `@inject` decorator you can attach your own alias name, please consider the following example:```pythonfrom kink import injectfrom typing import Protocolclass IUserRepository(Protocol):    ...@inject(alias=IUserRepository)class UserRepository:    ...assert di[IUserRepository] == di[UserRepository] # returns true```For more examples check [tests](/tests) directory### Retrieving all instances with the same aliasAliases in `kink` do not have to be unique, but by default when autowiring mechnism is called the service thatwas registered first within given alias will be returned. If for some reason you would like to retrieve allservices that alias to the same name (eg implementing strategy pattern), `kink` provides a useful functionalityfor doing so. Please consider the following example:```pythonfrom kink import injectfrom typing import Protocol, Listclass IUserRepository(Protocol):    ...@inject(alias=IUserRepository)class MongoUserRepository:    ...@inject(alias=IUserRepository)class MySQLUserRepository:    ...@inject()class UserRepository:    def __init__(self, repos: List[IUserRepository]) -&gt; None: # all services that alias to IUserRepository will be passed here        self._repos = repos            def store_to_mysql(self, user: ...):        self._repos[1].store(user)        def store_to_mongo(self, user: ...):        self._repos[0].store(user)```## Clearing di cacheSometimes it might come handy to clear cached services in di container. Simple way of doing this is calling `di.clear_cache()` method like in the following example.```pythonfrom kink import inject, di... # set and accesss your servicesdi.clear_cache() # this will clear cache of all services inside di container that are not factorised services```## Integration with FastAPI```pythonfrom fastapi import APIRouter, Depends, statusfrom fastapi.responses import JSONResponse, Responsefrom kink import dirouter = APIRouter()# register service in the DI containerdi[ClientService] = ClientService()@router.post(    &quot;/clients&quot;,    response_model=ClientDTO,    responses={400: {&quot;model&quot;: APIErrorMessage}, 500: {&quot;model&quot;: APIErrorMessage}},    tags=[&quot;clients&quot;],)async def create_client(    request: CreateClientDTO, service: ClientService = Depends(lambda: di[ClientService])) -&gt; JSONResponse:    result = service.create(request)    return JSONResponse(content=result.dict(), status_code=status.HTTP_201_CREATED)```A complete example, together with tests you can find it [here](https://github.com/szymon6927/hexagonal-architecture-python).# Articles on Kink- [https://www.netguru.com/codestories/dependency-injection-with-python-make-it-easy](https://www.netguru.com/codestories/dependency-injection-with-python-make-it-easy)</longdescription>
</pkgmetadata>