<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># customlibA few tools for day to day work.---### Installation:```commandlinepython -m pip install [--upgrade] customlib```---### Available tools:&lt;details&gt;&lt;summary&gt;FileHandler&lt;/summary&gt;&lt;p&gt;This is a file handler that can be used as a context-manager with thread &amp; file locking.How to:```pythonfrom customlib.filehandlers import FileHandlerfh = FileHandler(&quot;test_file.txt&quot;, &quot;a&quot;, encoding=&quot;UTF-8&quot;)fh.write(&quot;Just testing out this cool new filehandler.\n&quot;)fh.close()```or even beter:```pythonwith FileHandler(&quot;test_file.txt&quot;, &quot;a&quot;, encoding=&quot;UTF-8&quot;) as fh:    fh.write(&quot;Just testing out this cool new filehandler.\n&quot;)```&lt;/p&gt;&lt;/details&gt;---&lt;details&gt;&lt;summary&gt;FileLocker&lt;/summary&gt;&lt;p&gt;This is a file locker that can also be used as a context-manager.How to:```pythonfrom customlib.filelockers import FileLocker, LOCKfl1 = FileLocker()if __name__ == '__main__':    fh1 = open(&quot;just_a_file.txt&quot;, &quot;w&quot;, encoding=&quot;UTF-8&quot;)    fl1.acquire(fh1, flags=LOCK.EX)    fh1.write(&quot;Just testing the locking system...\n&quot;)    fl1.release(fh1)    fh1.close()```**Lock types:**- `LOCK.EX`: int (0x1), exclusive lock- `LOCK.SH`: int (0x2), shared lock**Lock flags:**- `LOCK.NB`: int (0x4), non-blocking**Manually unlock (only needed internally):**- `LOCK.UN`: int (0), unlock&lt;/p&gt;&lt;/details&gt;---&lt;details&gt;&lt;summary&gt;Vault&lt;/summary&gt;&lt;p&gt;This is a handler that makes use of keyring for password safe-keeping.How to:```pythonfrom customlib.keyvault import Vaultvault = Vault()password: str = vault.generate(exclude=&quot;\'\&quot;\\&quot;, length=16)vault.set_password(service=&quot;test_service&quot;, username=&quot;test_username&quot;, password=password)if __name__ == '__main__':    password: str = vault.get_password(service=&quot;test_service&quot;, username=&quot;test_username&quot;)    print(password)    vault.del_password(service=&quot;test_service&quot;, username=&quot;test_username&quot;)````generate` params:* `include`: The character set(s) to be used when generating the password.    * `u`: ascii_uppercase    * `l`: ascii_lowercase    * `d`: digits    * `p`: punctuation* `exclude`: The characters to be excluded from the password.* `length`: The number of characters our password should have.This is not so different from `keyring`, after all, it is making use of its methods.It exists only to serve as a base class for `KeyVault`!&lt;/p&gt;&lt;/details&gt;---&lt;details&gt;&lt;summary&gt;KeyVault&lt;/summary&gt;&lt;p&gt;This is a handler that makes use of keyring for password safe-keeping using encryption.How to:```pythonfrom customlib.keyvault import KeyVaultvault = KeyVault()vault.password(    value=vault.generate(exclude=&quot;\'\&quot;\\&quot;, length=16),    salt=vault.generate(exclude=&quot;\'\&quot;\\&quot;, length=16))if __name__ == '__main__':    vault.set_password(service=&quot;test_service&quot;, username=&quot;test_username&quot;, password=&quot;test_password&quot;)    print(vault.get_password(service=&quot;test_service&quot;, username=&quot;test_username&quot;))    vault.del_password(service=&quot;test_service&quot;, username=&quot;test_username&quot;)````generate` params:* `include`: The character set(s) to be used when generating the password.    * `u`: ascii_uppercase    * `l`: ascii_lowercase    * `d`: digits    * `p`: punctuation* `exclude`: The characters to be excluded from the password.* `length`: The number of characters our password should have.&lt;/p&gt;&lt;/details&gt;---&lt;details&gt;&lt;summary&gt;ClassRegistry&lt;/summary&gt;&lt;p&gt;Immutable class registry handler.Example:```pythonfrom customlib.registry import ClassRegistry@ClassRegistry.register(&quot;some_name&quot;)class SomeClass(object):    def __init__(self, var: str):        self.var = varif __name__ == '__main__':    # instantiating 'SomeClass':    some_class = ClassRegistry.get(&quot;some_name&quot;, &quot;var_value&quot;)    print(some_class.var)```&lt;/p&gt;&lt;/details&gt;---&lt;details&gt;&lt;summary&gt;MutableClassRegistry&lt;/summary&gt;&lt;p&gt;Mutable class registry handler.If a key already exists in `__register__` it will be updated.Example:```pythonfrom customlib.registry import MutableClassRegistry@MutableClassRegistry.register(&quot;some_name&quot;)class SomeClass(object):    def __init__(self, var: str):        self.var = varif __name__ == '__main__':    # instantiating 'SomeClass'    some_class = MutableClassRegistry.get(&quot;some_name&quot;, &quot;var_value&quot;)    print(some_class.var)```&lt;/p&gt;&lt;/details&gt;---&lt;details&gt;&lt;summary&gt;OsSleepInhibitor&lt;/summary&gt;&lt;p&gt;With this handler we can prevent the operating system from going to sleep.Works in `Windows` and it might work as well in `Linux` and `Darwin` systems (not tested!).How to:```pythonfrom customlib.systemhandlers import OsSleepInhibitorif __name__ == '__main__':    with OsSleepInhibitor(keep_screen_awake=True) as osi:        print(&quot;I just did something that took a lot of time...&quot;)```&lt;/p&gt;&lt;/details&gt;---&lt;details&gt;&lt;summary&gt;MetaSingleton&lt;/summary&gt;&lt;p&gt;Singleton metaclass for restricting `non-strict` classes to only one instance per runtime.How to:```pythonfrom customlib.singletons import MetaSingletonclass CfgParser(object, metaclass=MetaSingleton):    &quot;&quot;&quot;test&quot;&quot;&quot;if __name__ == '__main__':    cfg1 = CfgParser()    cfg2 = CfgParser()    print(&quot;*&quot; * 80)    print(&quot;cfg1 == cfg2:&quot;, cfg1 == cfg2)    print(&quot;cfg1 is cfg2:&quot;, cfg1 is cfg2)``````cfg1 == cfg2: Truecfg1 is cfg2: True```&lt;/p&gt;&lt;/details&gt;---&lt;details&gt;&lt;summary&gt;singleton&lt;/summary&gt;&lt;p&gt;Singleton decorator for `metaclass`.Restrict object to only one instance per runtime.How to:```pythonfrom customlib.singletons import singleton@singletonclass CfgParser(object):    &quot;&quot;&quot;test&quot;&quot;&quot;if __name__ == '__main__':    cfg1 = CfgParser()    cfg2 = CfgParser()    print(&quot;*&quot; * 80)    print(&quot;cfg1 == cfg2:&quot;, cfg1 == cfg2)    print(&quot;cfg1 is cfg2:&quot;, cfg1 is cfg2)``````cfg1 == cfg2: Truecfg1 is cfg2: True```&lt;/p&gt;&lt;/details&gt;---&lt;details&gt;&lt;summary&gt;del_prefix&lt;/summary&gt;&lt;p&gt;If `target` starts with the `prefix` string and `prefix` is not empty, return `string[len(prefix):]`.Otherwise, return a copy of the original string.How to:```pythonfrom customlib.utils import del_prefixa = &quot;some cool string&quot;if __name__ == '__main__':    b = del_prefix(target=a, prefix=&quot;some &quot;)    print(b)  # --&gt; &quot;cool string&quot;```&lt;/p&gt;&lt;/details&gt;---&lt;details&gt;&lt;summary&gt;del_suffix&lt;/summary&gt;&lt;p&gt;If `target` ends with the `suffix` string and `suffix` is not empty, return `string[:-len(suffix)]`.Otherwise, return a copy of the original string.How to:```pythonfrom customlib.utils import del_suffixa = &quot;some cool string&quot;if __name__ == '__main__':    b = del_suffix(target=a, suffix=&quot; string&quot;)    print(b)  # --&gt; &quot;some cool&quot;```&lt;/p&gt;&lt;/details&gt;---### WARNING:As of version `v6.0.0` the following modules are no longer in this library:* `logging` (now [logpie](https://github.com/ClaudiuDrug/logpie))* `config` (now [cfgpie](https://github.com/ClaudiuDrug/cfgpie))* `sqlite` (now [sqlitepie](https://github.com/ClaudiuDrug/sqlitepie))---### Note:This is still work in progress!---</longdescription>
</pkgmetadata>