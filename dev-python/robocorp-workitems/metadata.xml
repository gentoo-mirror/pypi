<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># robocorp-workitemsWork items are used in Robocorp Control Room for managing data that go throughmultiple steps and tasks inside a process. Each step of a process receives inputwork items from the previous step, and creates output work items for the nextstep.## InstallationThe library can be installed from pip:```bashpip install robocorp-workitems```## UsageThe library exposes two objects, `inputs` and `outputs`, which are the main wayto interact with work item queues. The former deals with the reading input workitems, and the latter with creating output work items.Iterating over inputs and creating outputs is easy:```pythonfrom robocorp import workitemsdef read_inputs_and_create_outputs():    for item in workitems.inputs:        print(&quot;Received payload:&quot;, item.payload)        workitems.outputs.create(payload={&quot;key&quot;: &quot;value&quot;})```## Work item structureA work item's data payload is JSON and allows storing anything that is JSONserializable. By default the payload is a mapping of key-value pairs.In addition to the payload section, a work item can also contain files, whichare stored within Robocorp Control Room. Adding and using files with work itemsrequires no additional setup from the user.## Reserving and releasing input itemsWhen an execution in Control Room starts, the first input item is automaticallyreserved. This first item is also loaded by the library when the task executionstarts.After an item has been handled, it should be released as either passed orfailed. There can only be one reserved input item at a time.Reserving can be done explicitly by calling the reserve method, which also actsas a context manager:```pythonwith workitems.inputs.reserve() as item:    print(&quot;Handling item!&quot;)```Another option is to loop through all inputs, which implicitly reserves andreleases the corresponding items:```pythonfor item in workitems.inputs:    print(&quot;Handling item!&quot;)```Releasing can also be done explicitly to set specific errors, or to mark itemsas done before exiting the block:```pythonfor item in workitems.inputs:    order_id = item.payload[&quot;order_id&quot;]    if not is_valid_id(order_id):        item.fail(code=&quot;INVALID_ID&quot;, message=f&quot;Invalid order id: {order_id}&quot;)    ...    item.done()```## Creating outputsFor each input work item, you can create any amount of output work items.These will be forwarded to the next step of a process, or set as the finalresult if there are no further steps.In most cases, it's enough to create an output item directly usingthe `outputs` object:```pythonworkitems.outputs.create(    payload={&quot;key&quot;: &quot;value&quot;},    files=[&quot;path/to/file.txt&quot;],)```Internally, Control Room keeps a relationship between the parent and childwork items. The above example always uses the currently reserved item as theparent, but it's also possible to create an output explicitly fromthe input item:```pythonwith workitems.inputs.reserve() as input_item:    input_item.create_output(payload={&quot;key&quot;: &quot;value&quot;})```In some cases, it's also useful to create an output item and then modify itbefore saving:```pythonitem = workitems.outputs.create(save=False)for index, path in enumerate(directory.glob(&quot;*.pdf&quot;)):    item.add_file(path, name=f&quot;document-{index}&quot;)item.save()```## Email triggeringSince a process can be started in Control Room by sending an email, the payloadand files can contain the email metadata, text, and possible attached files.This requires the `Parse email` configuration option to be enabled.The input work item in this library has a helper method `email()`, which canbe used to parse it into a typed container:```pythonitem = workitems.inputs.currentemail = item.email()print(&quot;Email sent by:&quot;, email.from_.address)print(&quot;Email subject:&quot;, email.subject)payload = json.loads(email.text)print(&quot;Received JSON payload:&quot;, payload)```To learn more about email triggering, see[the docs page](https://robocorp.com/docs/control-room/attended-or-unattended/email-trigger).## Local development### Using the VSCode extensionIf you are developing in VSCode with the [Robocorp Code extension](https://robocorp.com/docs/setup/development-environment#visual-studio-code-with-robocorp-extensions),you can utilize the built in local development features described in the[Developing with work items locally](https://robocorp.com/docs/development-guide/control-room/work-items#developing-with-work-items-locally)section of the [Using work items](https://robocorp.com/docs/development-guide/control-room/work-items)development guide.This allows you to develop and test your work items before deployingto Control Room.### Using a custom editorIt's also possible to develop locally with a custom editor, but it requiressome configuration.To enable the development mode for the library, you should set the environmentvariable `RC_WORKITEM_ADAPTER` with the value `FileAdapter`. This tells thelibrary to use local files for simulating input and output queues for workitems, in the form of JSON files.The environment variables `RC_WORKITEM_INPUT_PATH` and `RC_WORKITEM_OUTPUT_PATH`are also required, and should contain the paths to the input and output JSONfiles. The output file will be created by the library, but the input fileshould be created manually.An example of an input file with one work item:```json[    {        &quot;payload&quot;: {            &quot;variable1&quot;: &quot;a-string-value&quot;,            &quot;variable2&quot;: [&quot;a&quot;, &quot;list&quot;, &quot;value&quot;]        },        &quot;files&quot;: {            &quot;file1&quot;: &quot;path/to/file.ext&quot;        }    }]```</longdescription>
</pkgmetadata>