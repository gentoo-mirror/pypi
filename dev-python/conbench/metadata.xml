<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;https://github.com/conbench/conbench/blob/main/.github/workflows/actions.yml&quot;&gt;&lt;img alt=&quot;Build Status&quot; src=&quot;https://github.com/conbench/conbench/actions/workflows/actions.yml/badge.svg?branch=main&quot;&gt;&lt;/a&gt;&lt;/p&gt;# ConbenchCheck out the docs at https://conbench.github.io/conbench.&lt;img src=&quot;https://raw.githubusercontent.com/conbench/conbench/main/conbench.png&quot; alt=&quot;Language-independent Continuous Benchmarking (CB) Framework&quot;&gt;Conbench allows you to write benchmarks in any language, publish theresults as JSON via an API, and persist them for comparison whileiterating on performance improvements or to guard against regressions.Conbench includes a runner which can be used as a stand-alone libraryfor traditional macro benchmark authoring. The runner will time a unit ofwork (or measure throughput), collect machine information that may be relevantfor hardware specific optimizations, and return JSON formatted results.You can optionally host a Conbench server (API &amp; dashboard) to sharebenchmark results more widely, explore the changes over time, andcompare results across varying benchmark machines, languages, and cases.There is also a Conbench command line interface, useful for ContinuousBenchmarking (CB) orchestration alongside your development pipeline.&lt;p align=&quot;center&quot;&gt;    &lt;img src=&quot;https://arrow.apache.org/img/arrow.png&quot; alt=&quot;Apache Arrow&quot; height=&quot;100&quot;&gt;&lt;/p&gt;The [Apache Arrow](https://arrow.apache.org/) project is using Conbenchfor Continuous Benchmarking. They have both native Python Conbenchbenchmarks, and Conbench benchmarks written in Python that know how toexecute their external C++/R/Java/JavaScript benchmarks and record those resultstoo. Those benchmarks can be found in the[ursacomputing/benchmarks](https://github.com/ursacomputing/benchmarks)repository, and the results are hosted on the[Arrow Conbench Server](https://conbench.ursa.dev/).- May 2021: https://ursalabs.org/blog/announcing-conbench/&lt;br&gt;## InstallationAll packages in this repo can be installed from PyPI. Each package uses[CalVer](https://calver.org/) for versioning. No stability is guaranteed between PyPIversions, so consider pinning packages to a specific version in your code.```bashpip install benchadaptpip install benchalertspip install benchclientspip install benchconnectpip install benchrunpip install conbench  # legacy CLI```We typically publish to PyPI often, when new features or bugfixes are needed by users,but not on every merge to `main`. To install the latest development version, installfrom git like so:```bashpip install 'benchadapt@git+https://github.com/conbench/conbench.git@main#subdirectory=benchadapt/python'pip install 'benchalerts@git+https://github.com/conbench/conbench.git@main#subdirectory=benchalerts'pip install 'benchclients@git+https://github.com/conbench/conbench.git@main#subdirectory=benchclients/python'pip install 'benchconnect@git+https://github.com/conbench/conbench.git@main#subdirectory=benchconnect'pip install 'benchrun@git+https://github.com/conbench/conbench.git@main#subdirectory=benchrun/python'pip install 'conbench@git+https://github.com/conbench/conbench.git@main'```## Developer environment### Dependencies- [`make`](https://www.gnu.org/software/make/), [`docker compose`](https://docs.docker.com/compose/install/): common developer tasks depend on these tools. They need to be set up on your system.- `GITHUB_API_TOKEN` environment variable: set up a GitHub API token using [GitHub's instructions](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token). It's recommended to only give the token read-only permissions to public repositories (which is the default for fine-grained personal access tokens). Run `export GITHUB_API_TOKEN=&quot;{token}&quot;` in your current shell.### Makefile targetsThe following Makefile targets implement common developer tasks. They assume to be run in the root folder of the repository.* `make run-app`: This command lets you experiment with Conbench locally.It runs the stack in a containerized fashion.It rebuilds container images from the current checkout, spawnsmultiple containers (including one for the database), and then exposes Conbench'sHTTP server on the host at http://127.0.0.1:5000.The command will stay in the foreground of your terminal, showing log output of all containers.Once you see access log lines like `GET /api/ping/ HTTP/1.1&quot; 200` you can point your browser to http://127.0.0.1:5000.You can use `Ctrl+C` to terminate the containerized stack (this only stops containers, and the next invocation of `make run-app` will use previous database state -- invoke `make teardown-app` to stop and remove containers).If you wish to clear all database tables during local development you can hit http://127.0.0.1:5000/api/wipe-db with the browser or with e.g. curl.* `make run-app-dev`: Similar to `make run-app`, but also mounts the repository's root directory into the container.Code changes are (should be) detected automatically and result in automatic code reload.* `make tests`: The nobrainer command to run the test suite just like CI does.For more fine-grained control see further below.* `make lint`: Performs invasive code linting in your local checkout.May modify files. Analogue to what CI requires.It requires for some commands to be available in your current shell.Dependencies can be installed with `pip install -r requirements-dev.txt`.* `make alembic-new-migration`: Attempts to generate a new migration Python module in `migrations/versions/`.Requires setting the environment variable `ALEMBIC_MIGRATION_NAME` before invocation.Example: `export ALEMBIC_MIGRATION_NAME='repo_url_lenth'`.After the file was created you may want to change its permissions and re-format it with `black`.* `make conbench-on-minikube`: requires [minikube](https://minikube.sigs.k8s.io/docs/start/).Deploys the Conbench API server to a local minikube-powered Kubernetes cluster.This also deploys a kube-prometheus-based observability stack.Use this target for local development in this area.* `make docs-build`: Builds HTML docs locally so you may check that they render  correctly with no linting problems. Dependencies can be installed with  `pip install -r requirements-dev.txt`. Also, if you're working on the docstrings of  any of this repo's python packages, ensure the package is installed locally before  using this command.  In CI, we use `make build-docs SPHINXOPTS='-W --keep-going'` to fail the build if  there are Sphinx warnings. When using this command locally, you can just do  `make build-docs`, but keep an eye on the warnings.### View API documentationPoint your browser to http://127.0.0.1:5000/api/docs/.### Python environment on the hostCI and common developer commands use containerized workflows where dependencies are defined and easy to reason about via `Dockerfile`s.Note that the CPython version that Conbench is tested with in CI and that it is recommended to be deployed with is currently the latest 3.11.x release, as also defined in `Dockerfile` at the root of this repository.Some developer tasks may involve running Conbench tooling straight on the host.Here is how to install the Python dependencies for the Conbench web application:```bashpip install -r requirements-webapp.txt```Dependencies for running code analysis and tests straight on the host can be installed with```bashpip install -r requirements-dev.txt```Dependencies for the (legacy) `conbench` CLI can be installed with```bashpip install -r requirements-cli.txt```### Fine-grained test invocationIf `make test` is too coarse-grained, then this is how to take control of the containerized `pytest` test runner:```bashdocker compose down &amp;&amp; docker compose build app &amp;&amp; \    docker compose run app \    pytest -vv conbench/tests```This command attempts to stop and remove previously spawned test runner containers, and it rebuilds the `app` container image prior to running tests to pick up code changes in the local checkout.Useful command line arguments for local development (can be combined as desired):* `... pytest -k test_login`: run only string-matching tests* `... pytest -x`: exit upon first error* `... pytest -s`: do not swallow log output during run* `... run -e CONBENCH_LOG_LEVEL_STDERR=DEBUG app ...`### Legacy commandsThe following commands are not guaranteed to work as documented, but provide valuable inspiration:#### To autogenerate a migration    (conbench) $ brew services start postgres    (conbench) $ dropdb conbench_prod    (conbench) $ createdb conbench_prod    (conbench) $ git checkout main &amp;&amp; git pull    (conbench) $ alembic upgrade head    (conbench) $ git checkout your-branch    (conbench) $ alembic revision --autogenerate -m &quot;new&quot;#### To populate local conbench with sample runs and benchmarks1. Start conbench app in Terminal window 1:        (conbench) $ dropdb conbench_prod &amp;&amp; createdb conbench_prod &amp;&amp; alembic upgrade head &amp;&amp; flask run2. Run `conbench.tests.populate_local_conbench` in Terminal window 2 while conbench app is running:        (conbench) $ python -m conbench.tests.populate_local_conbench### To upload new version of packages to PyPIKick off a new run of the &quot;Build and upload a package to PyPI&quot; workflow on the [Actionspage](https://github.com/conbench/conbench/actions).### To add new documentation pagesTo add a new page to our GitHub Pages-hosted documentation:1. Add a Markdown file to `docs/pages/`.2. In the toctree in the `docs/index.rst` file, add `pages/your_new_page`, where   `your_new_page` is your new filename without the `.md` file suffix.To test that your new pages pass our documentation linter, run the `make docs-build`command, as described above.## Configuring the web applicationThe conbench web application can be configured with various environment variables asdefined in[config.py](https://github.com/conbench/conbench/blob/main/conbench/config.py).Instructions are in that file.## Creating accountsBy default, conbench has open read access, so a user account is not required toview results or read from the API. An account is required only if the conbenchinstance is private or to write data to conbench.If you do need an account, follow the login screen's &quot;Sign Up&quot; link, and use theregistration key specified in the server configuration above. If you are a userof conbench, you may need to talk to your user administrator to get theregistration key. SSO can be configured to avoid requiring the registration key.If you have an account and need to create an additional account (say for a machineuser of the API) either repeat the process if you have the registration key, or ifyou don't have the registration key (say if your account uses SSO), when logged in,go to the gear menu / Users and use the &quot;Add User&quot; button to create a new accountwithout the registration key.## Authoring benchmarksThere are three main types of benchmarks: &quot;simple benchmarks&quot; that time theexecution of a unit of work, &quot;external benchmarks&quot; that just record benchmarkresults that were obtained from some other benchmarking tool, and &quot;casebenchmarks&quot; which benchmark a unit of work under different scenarios (cases).Included in this repository are contrived, minimal examples of these differentkinds of benchmarks to be used as templates for benchmark authoring. Theseexample benchmarks and their tests can be found here:* [_example_benchmarks.py](https://github.com/conbench/conbench/blob/main/conbench/tests/benchmark/_example_benchmarks.py)* [test_cli.py](https://github.com/conbench/conbench/blob/main/conbench/tests/benchmark/test_cli.py)* [test_runner.py](https://github.com/conbench/conbench/blob/main/conbench/tests/benchmark/test_runner.py)### Example simple benchmarksA &quot;simple benchmark&quot; runs and records the execution time of a unit of work.Implementation details: Note that this benchmark extends`conbench.runner.Benchmark`, implements the minimum required `run()`method, and registers itself with the `@conbench.runner.register_benchmark`decorator.```pythonimport conbench.runner@conbench.runner.register_benchmarkclass SimpleBenchmark(conbench.runner.Benchmark):    name = &quot;addition&quot;    def run(self, **kwargs):        yield self.conbench.benchmark(            self._get_benchmark_function(), self.name, options=kwargs        )    def _get_benchmark_function(self):        return lambda: 1 + 1```Successfully registered benchmarks appear in the `conbench --help` list.For this benchmark to appear, the file must match the following paterns (documented in the [`utils.py:register_benchmarks` function](https://github.com/conbench/conbench/blob/35fde9954e2b365e36472f16b46fe3067e9dc455/conbench/util.py#L104):* `benchmark*.py`* `*benchmark.py`* `*benchmarks.py````(conbench) $ cd ~/workspace/conbench/conbench/tests/benchmark/(conbench) $ conbench --helpUsage: conbench [OPTIONS] COMMAND [ARGS]...  Conbench: Language-independent Continuous Benchmarking (CB) FrameworkOptions:  --help  Show this message and exit.Commands:  addition            Run addition benchmark.  external            Run external benchmark.  external-r          Run external-r benchmark.  external-r-options  Run external-r-options benchmark.  list                List of benchmarks (for orchestration).  matrix              Run matrix benchmark(s).  version             Display Conbench version.```Benchmarks can be run from command line within the directory where thebenchmarks are defined.Benchmark classes can also be imported and executed via the `run` method whichaccepts the same arguments that appear in the command line help.```(conbench) $ cd ~/workspace/conbench/conbench/tests/benchmark/(conbench) $ conbench addition --helpUsage: conbench addition [OPTIONS]  Run addition benchmark.Options:  --iterations INTEGER   [default: 1]  --drop-caches BOOLEAN  [default: false]  --gc-collect BOOLEAN   [default: true]  --gc-disable BOOLEAN   [default: true]  --show-result BOOLEAN  [default: true]  --show-output BOOLEAN  [default: false]  --run-id TEXT          Group executions together with a run id.  --run-name TEXT        Free-text name of run (commit ABC, pull request 123,                         etc).  --run-reason TEXT      Low-cardinality reason for run (commit, pull request,                         manual, etc).  --help                 Show this message and exit.```Example command line execution:```(conbench) $ cd ~/workspace/conbench/conbench/tests/benchmark/(conbench) $ conbench additionBenchmark result:{    &quot;batch_id&quot;: &quot;c9db942c27db4359923eb08aa553beb7&quot;,    &quot;run_id&quot;: &quot;f6c7d0b3b3f146f9b1ad297fc6e5776b&quot;,    &quot;timestamp&quot;: &quot;2021-11-09T22:09:17.790397+00:00&quot;,    &quot;context&quot;: {        &quot;benchmark_language&quot;: &quot;Python&quot;    },    &quot;github&quot;: {        &quot;commit&quot;: &quot;61dec915b9dd230ca5029f5e586f8bd95c3e0c05&quot;,        &quot;repository&quot;: &quot;https://github.com/conbench/conbench&quot;    },    &quot;info&quot;: {        &quot;benchmark_language_version&quot;: &quot;Python 3.9.7&quot;    },    &quot;machine_info&quot;: {        &quot;architecture_name&quot;: &quot;arm64&quot;,        &quot;cpu_core_count&quot;: &quot;8&quot;,        &quot;cpu_frequency_max_hz&quot;: &quot;0&quot;,        &quot;cpu_l1d_cache_bytes&quot;: &quot;65536&quot;,        &quot;cpu_l1i_cache_bytes&quot;: &quot;131072&quot;,        &quot;cpu_l2_cache_bytes&quot;: &quot;4194304&quot;,        &quot;cpu_l3_cache_bytes&quot;: &quot;0&quot;,        &quot;cpu_model_name&quot;: &quot;Apple M1&quot;,        &quot;cpu_thread_count&quot;: &quot;8&quot;,        &quot;gpu_count&quot;: &quot;0&quot;,        &quot;gpu_product_names&quot;: [],        &quot;kernel_name&quot;: &quot;20.6.0&quot;,        &quot;memory_bytes&quot;: &quot;17179869184&quot;,        &quot;name&quot;: &quot;diana&quot;,        &quot;os_name&quot;: &quot;macOS&quot;,        &quot;os_version&quot;: &quot;11.5.2&quot;    },    &quot;stats&quot;: {        &quot;data&quot;: [            &quot;0.000001&quot;        ],        &quot;iqr&quot;: &quot;0.000000&quot;,        &quot;iterations&quot;: 1,        &quot;max&quot;: &quot;0.000001&quot;,        &quot;mean&quot;: &quot;0.000001&quot;,        &quot;median&quot;: &quot;0.000001&quot;,        &quot;min&quot;: &quot;0.000001&quot;,        &quot;q1&quot;: &quot;0.000001&quot;,        &quot;q3&quot;: &quot;0.000001&quot;,        &quot;stdev&quot;: 0,        &quot;time_unit&quot;: &quot;s&quot;,        &quot;times&quot;: [],        &quot;unit&quot;: &quot;s&quot;    },    &quot;tags&quot;: {        &quot;name&quot;: &quot;addition&quot;    }}```Example Python execution:```(conbench) $ python&gt;&gt;&gt; import json&gt;&gt;&gt; from conbench.tests.benchmark import _example_benchmarks&gt;&gt;&gt; benchmark = _example_benchmarks.SimpleBenchmark()&gt;&gt;&gt; [(result, output)] = benchmark.run(iterations=10)&gt;&gt;&gt; output2&gt;&gt;&gt; print(json.dumps(result, indent=2)){  &quot;run_id&quot;: &quot;dfe3a816ca9e451a9da7d940a974cb95&quot;,  &quot;batch_id&quot;: &quot;0e869934b391424a8199c485dfbbc066&quot;,  &quot;timestamp&quot;: &quot;2021-11-09T22:11:25.262330+00:00&quot;,  &quot;stats&quot;: {    &quot;data&quot;: [      &quot;0.000002&quot;,      &quot;0.000001&quot;,      &quot;0.000000&quot;,      &quot;0.000001&quot;,      &quot;0.000001&quot;,      &quot;0.000001&quot;,      &quot;0.000001&quot;,      &quot;0.000000&quot;,      &quot;0.000001&quot;,      &quot;0.000001&quot;    ],    &quot;times&quot;: [],    &quot;unit&quot;: &quot;s&quot;,    &quot;time_unit&quot;: &quot;s&quot;,    &quot;iterations&quot;: 10,    &quot;mean&quot;: &quot;0.000001&quot;,    &quot;median&quot;: &quot;0.000001&quot;,    &quot;min&quot;: &quot;0.000000&quot;,    &quot;max&quot;: &quot;0.000002&quot;,    &quot;stdev&quot;: &quot;0.000001&quot;,    &quot;q1&quot;: &quot;0.000001&quot;,    &quot;q3&quot;: &quot;0.000001&quot;,    &quot;iqr&quot;: &quot;0.000000&quot;  },  &quot;machine_info&quot;: {    &quot;name&quot;: &quot;diana&quot;,    &quot;os_name&quot;: &quot;macOS&quot;,    &quot;os_version&quot;: &quot;11.5.2&quot;,    &quot;architecture_name&quot;: &quot;arm64&quot;,    &quot;kernel_name&quot;: &quot;20.6.0&quot;,    &quot;memory_bytes&quot;: &quot;17179869184&quot;,    &quot;cpu_model_name&quot;: &quot;Apple M1&quot;,    &quot;cpu_core_count&quot;: &quot;8&quot;,    &quot;cpu_thread_count&quot;: &quot;8&quot;,    &quot;cpu_l1d_cache_bytes&quot;: &quot;65536&quot;,    &quot;cpu_l1i_cache_bytes&quot;: &quot;131072&quot;,    &quot;cpu_l2_cache_bytes&quot;: &quot;4194304&quot;,    &quot;cpu_l3_cache_bytes&quot;: &quot;0&quot;,    &quot;cpu_frequency_max_hz&quot;: &quot;0&quot;,    &quot;gpu_count&quot;: &quot;0&quot;,    &quot;gpu_product_names&quot;: []  },  &quot;context&quot;: {    &quot;benchmark_language&quot;: &quot;Python&quot;  },  &quot;info&quot;: {    &quot;benchmark_language_version&quot;: &quot;Python 3.9.7&quot;  },  &quot;tags&quot;: {    &quot;name&quot;: &quot;addition&quot;  },  &quot;github&quot;: {    &quot;commit&quot;: &quot;61dec915b9dd230ca5029f5e586f8bd95c3e0c05&quot;,    &quot;repository&quot;: &quot;https://github.com/conbench/conbench&quot;  }}```By default, Conbench will try to publish your results to a Conbench server. Ifyou don't have one running or are missing a `.conbench` credentials file, you'llsee error messages like the following when you execute benchmarks.```POST http://localhost:5000/api/login/ failed{  &quot;code&quot;: 400,  &quot;description&quot;: {    &quot;_errors&quot;: [      &quot;Invalid email or password.&quot;    ]  },  &quot;name&quot;: &quot;Bad Request&quot;}POST http://localhost:5000/api/benchmarks/ failed{  &quot;code&quot;: 401,  &quot;name&quot;: &quot;Unauthorized&quot;}```To publish your results to a Conbench server, place a `.conbench` file in thesame directory as your benchmarks. The `cat` command below shows the contentsof an example `.conbench` config file.```(conbench) $ cd ~/workspace/conbench/conbench/tests/benchmark/(conbench) $ cat .conbenchurl: http://localhost:5000email: you@example.compassword: conbench```If you don't yet have a Conbench server user account, you'll need to create oneto publish results (registration key defaults to `conbench`).- http://localhost:5000/register/### Example external benchmarksAn &quot;external benchmark&quot; records results that were obtained from some otherbenchmarking tool (like executing an R benchmark from command line, parsingthe resulting JSON, and recording those results).Implementation details: Note that the following benchmark sets`external = True`, and calls `self.conbench.record()` rather than`self.conbench.benchmark()` as the example above does.```pythonimport conbench.runner@conbench.runner.register_benchmarkclass ExternalBenchmark(conbench.runner.Benchmark):    &quot;&quot;&quot;Example benchmark that just records external results.&quot;&quot;&quot;    external = True    name = &quot;external&quot;    def run(self, **kwargs):        # external results from an API call, command line execution, etc        result = {            &quot;data&quot;: [100, 200, 300],            &quot;unit&quot;: &quot;i/s&quot;,            &quot;times&quot;: [0.100, 0.200, 0.300],            &quot;time_unit&quot;: &quot;s&quot;,        }        context = {&quot;benchmark_language&quot;: &quot;C++&quot;}        yield self.conbench.record(            result, self.name, context=context, options=kwargs, output=result        )``````(conbench) $ cd ~/workspace/conbench/conbench/tests/benchmark/(conbench) $ conbench external --helpUsage: conbench external [OPTIONS]  Run external benchmark.Options:  --show-result BOOLEAN  [default: true]  --show-output BOOLEAN  [default: false]  --run-id TEXT          Group executions together with a run id.  --run-name TEXT        Free-text name of run (commit ABC, pull request 123,                         etc).  --run-reason TEXT      Low-cardinality reason for run (commit, pull request,                         manual, etc).  --help                 Show this message and exit.```Note that the use of `--iterations=3` results in 3 runs of the benchmark, andthe `mean`, `stdev`, etc calculated.```(conbench) $ cd ~/workspace/conbench/conbench/tests/benchmark/(conbench) $ conbench external --iterations=3Benchmark result:{    &quot;run_id&quot;: &quot;8058dde1491b49e5bd514646797c2a20&quot;,    &quot;batch_id&quot;: &quot;8058dde1491b49e5bd514646797c2a20&quot;,    &quot;timestamp&quot;: &quot;2021-06-21T22:16:54.786499+00:00&quot;,    &quot;context&quot;: {        &quot;benchmark_language&quot;: &quot;C++&quot;    },    &quot;github&quot;: {        &quot;commit&quot;: &quot;58fb35dc593dca82c917cf18c1c65c059b9fb12c&quot;,        &quot;repository&quot;: &quot;https://github.com/conbench/conbench&quot;    },    &quot;info&quot;: {},    &quot;machine_info&quot;: {        &quot;architecture_name&quot;: &quot;x86_64&quot;,        &quot;cpu_core_count&quot;: &quot;2&quot;,        &quot;cpu_frequency_max_hz&quot;: &quot;3500000000&quot;,        &quot;cpu_l1d_cache_bytes&quot;: &quot;32768&quot;,        &quot;cpu_l1i_cache_bytes&quot;: &quot;32768&quot;,        &quot;cpu_l2_cache_bytes&quot;: &quot;262144&quot;,        &quot;cpu_l3_cache_bytes&quot;: &quot;4194304&quot;,        &quot;cpu_model_name&quot;: &quot;Intel(R) Core(TM) i7-7567U CPU @ 3.50GHz&quot;,        &quot;cpu_thread_count&quot;: &quot;4&quot;,        &quot;kernel_name&quot;: &quot;20.5.0&quot;,        &quot;memory_bytes&quot;: &quot;17179869184&quot;,        &quot;name&quot;: &quot;machine-abc&quot;,        &quot;os_name&quot;: &quot;macOS&quot;,        &quot;os_version&quot;: &quot;10.16&quot;    },    &quot;stats&quot;: {        &quot;data&quot;: [            &quot;100.000000&quot;,            &quot;200.000000&quot;,            &quot;300.000000&quot;        ],        &quot;iqr&quot;: &quot;100.000000&quot;,        &quot;iterations&quot;: 3,        &quot;max&quot;: &quot;300.000000&quot;,        &quot;mean&quot;: &quot;200.000000&quot;,        &quot;median&quot;: &quot;200.000000&quot;,        &quot;min&quot;: &quot;100.000000&quot;,        &quot;q1&quot;: &quot;150.000000&quot;,        &quot;q3&quot;: &quot;250.000000&quot;,        &quot;stdev&quot;: &quot;100.000000&quot;,        &quot;time_unit&quot;: &quot;s&quot;,        &quot;times&quot;: [            &quot;0.100000&quot;,            &quot;0.200000&quot;,            &quot;0.300000&quot;        ],        &quot;unit&quot;: &quot;i/s&quot;    },    &quot;tags&quot;: {        &quot;name&quot;: &quot;external&quot;    }}```### Example simple benchmarks executed on machine cluster instead of one machineIf your benchmark is executed on a machine cluster instead of one machine, youcan capture cluster info in the following manner.Note that a benchmark will have a continuous history on a specific cluster as long as cluster's `name` and `info` do not change.There is also an `optional_info` field for information that should not impact the cluster's hash (and thus disrupt the distribution history), but should still be recorded.```pythonimport conbench.runner@conbench.runner.register_benchmarkclass SimpleBenchmarkWithClusterInfo(conbench.runner.Benchmark):    name = &quot;product&quot;    def run(self, **kwargs):        cluster_info = {            &quot;name&quot;: &quot;cluster 1&quot;,            &quot;info&quot;: {&quot;gpu&quot;: 1},            &quot;optional_info&quot;: {&quot;workers&quot;: 2},        }        yield self.conbench.benchmark(            self._get_benchmark_function(),            self.name,            cluster_info=cluster_info,            options=kwargs,        )    def _get_benchmark_function(self):        return lambda: 1 * 2```### Example case benchmarksA &quot;case benchmark&quot; is a either a &quot;simple benchmark&quot; or an &quot;external benchmark&quot;executed under various predefined scenarios (cases).Implementation details: Note that the following benchmark declares the validcombinations in `valid_cases`, which reads like a CSV (the first row containsthe cases names).```pythonimport conbench.runner@conbench.runner.register_benchmarkclass CasesBenchmark(conbench.runner.Benchmark):    &quot;&quot;&quot;Example benchmark with cases.&quot;&quot;&quot;    name = &quot;matrix&quot;    valid_cases = (        (&quot;rows&quot;, &quot;columns&quot;),        (&quot;10&quot;, &quot;10&quot;),        (&quot;2&quot;, &quot;10&quot;),        (&quot;10&quot;, &quot;2&quot;),    )    def run(self, case=None, **kwargs):        for case in self.get_cases(case, kwargs):            rows, columns = case            tags = {&quot;rows&quot;: rows, &quot;columns&quot;: columns}            func = self._get_benchmark_function(rows, columns)            benchmark, output = self.conbench.benchmark(                func,                self.name,                tags=tags,                options=kwargs,            )            yield benchmark, output    def _get_benchmark_function(self, rows, columns):        return lambda: int(rows) * [int(columns) * [0]]``````(conbench) $ cd ~/workspace/conbench/conbench/tests/benchmark/(conbench) $ conbench matrix --helpUsage: conbench matrix [OPTIONS]  Run matrix benchmark(s).  For each benchmark option, the first option value is the default.  Valid benchmark combinations:  --rows=10 --columns=10  --rows=2 --columns=10  --rows=10 --columns=2  To run all combinations:  $ conbench matrix --all=trueOptions:  --rows [10|2]  --columns [10|2]  --all BOOLEAN          [default: false]  --iterations INTEGER   [default: 1]  --drop-caches BOOLEAN  [default: false]  --gc-collect BOOLEAN   [default: true]  --gc-disable BOOLEAN   [default: true]  --show-result BOOLEAN  [default: true]  --show-output BOOLEAN  [default: false]  --run-id TEXT          Group executions together with a run id.  --run-name TEXT        Free-text name of run (commit ABC, pull request 123,                         etc).  --run-reason TEXT      Low-cardinality reason for run (commit, pull request,                         manual, etc).  --help                 Show this message and exit.    &quot;&quot;&quot;```Note that the use of `--all=true` results in 3 benchmark results, one for eachcase (`10 x 10`, `2, x 10`, and `10, x 2`).```(conbench) $ cd ~/workspace/conbench/conbench/tests/benchmark/(conbench) $ conbench matrix --all=trueBenchmark result:{    &quot;batch_id&quot;: &quot;13b87cc6d9a84f2188df279d8c513933&quot;,    &quot;run_id&quot;: &quot;48acd853b8294df9a1f5457f192456f3&quot;,    &quot;timestamp&quot;: &quot;2021-11-09T22:15:23.501923+00:00&quot;,    &quot;context&quot;: {        &quot;benchmark_language&quot;: &quot;Python&quot;    },    &quot;github&quot;: {        &quot;commit&quot;: &quot;61dec915b9dd230ca5029f5e586f8bd95c3e0c05&quot;,        &quot;repository&quot;: &quot;https://github.com/conbench/conbench&quot;    },    &quot;info&quot;: {        &quot;benchmark_language_version&quot;: &quot;Python 3.9.7&quot;    },    &quot;machine_info&quot;: {        &quot;architecture_name&quot;: &quot;arm64&quot;,        &quot;cpu_core_count&quot;: &quot;8&quot;,        &quot;cpu_frequency_max_hz&quot;: &quot;0&quot;,        &quot;cpu_l1d_cache_bytes&quot;: &quot;65536&quot;,        &quot;cpu_l1i_cache_bytes&quot;: &quot;131072&quot;,        &quot;cpu_l2_cache_bytes&quot;: &quot;4194304&quot;,        &quot;cpu_l3_cache_bytes&quot;: &quot;0&quot;,        &quot;cpu_model_name&quot;: &quot;Apple M1&quot;,        &quot;cpu_thread_count&quot;: &quot;8&quot;,        &quot;gpu_count&quot;: &quot;0&quot;,        &quot;gpu_product_names&quot;: [],        &quot;kernel_name&quot;: &quot;20.6.0&quot;,        &quot;memory_bytes&quot;: &quot;17179869184&quot;,        &quot;name&quot;: &quot;diana&quot;,        &quot;os_name&quot;: &quot;macOS&quot;,        &quot;os_version&quot;: &quot;11.5.2&quot;    },    &quot;run_id&quot;: &quot;48acd853b8294df9a1f5457f192456f3&quot;,    &quot;stats&quot;: {        &quot;data&quot;: [            &quot;0.000004&quot;        ],        &quot;iqr&quot;: &quot;0.000000&quot;,        &quot;iterations&quot;: 1,        &quot;max&quot;: &quot;0.000004&quot;,        &quot;mean&quot;: &quot;0.000004&quot;,        &quot;median&quot;: &quot;0.000004&quot;,        &quot;min&quot;: &quot;0.000004&quot;,        &quot;q1&quot;: &quot;0.000004&quot;,        &quot;q3&quot;: &quot;0.000004&quot;,        &quot;stdev&quot;: 0,        &quot;time_unit&quot;: &quot;s&quot;,        &quot;times&quot;: [],        &quot;unit&quot;: &quot;s&quot;    },    &quot;tags&quot;: {        &quot;columns&quot;: &quot;10&quot;,        &quot;name&quot;: &quot;matrix&quot;,        &quot;rows&quot;: &quot;10&quot;    },    &quot;timestamp&quot;: &quot;2021-11-09T22:15:23.397819+00:00&quot;}Benchmark result:{    &quot;batch_id&quot;: &quot;13b87cc6d9a84f2188df279d8c513933&quot;,    &quot;context&quot;: {        &quot;benchmark_language&quot;: &quot;Python&quot;    },    &quot;github&quot;: {        &quot;commit&quot;: &quot;61dec915b9dd230ca5029f5e586f8bd95c3e0c05&quot;,        &quot;repository&quot;: &quot;https://github.com/conbench/conbench&quot;    },    &quot;info&quot;: {        &quot;benchmark_language_version&quot;: &quot;Python 3.9.7&quot;    },    &quot;machine_info&quot;: {        &quot;architecture_name&quot;: &quot;arm64&quot;,        &quot;cpu_core_count&quot;: &quot;8&quot;,        &quot;cpu_frequency_max_hz&quot;: &quot;0&quot;,        &quot;cpu_l1d_cache_bytes&quot;: &quot;65536&quot;,        &quot;cpu_l1i_cache_bytes&quot;: &quot;131072&quot;,        &quot;cpu_l2_cache_bytes&quot;: &quot;4194304&quot;,        &quot;cpu_l3_cache_bytes&quot;: &quot;0&quot;,        &quot;cpu_model_name&quot;: &quot;Apple M1&quot;,        &quot;cpu_thread_count&quot;: &quot;8&quot;,        &quot;gpu_count&quot;: &quot;0&quot;,        &quot;gpu_product_names&quot;: [],        &quot;kernel_name&quot;: &quot;20.6.0&quot;,        &quot;memory_bytes&quot;: &quot;17179869184&quot;,        &quot;name&quot;: &quot;diana&quot;,        &quot;os_name&quot;: &quot;macOS&quot;,        &quot;os_version&quot;: &quot;11.5.2&quot;    },    &quot;stats&quot;: {        &quot;data&quot;: [            &quot;0.000004&quot;        ],        &quot;iqr&quot;: &quot;0.000000&quot;,        &quot;iterations&quot;: 1,        &quot;max&quot;: &quot;0.000004&quot;,        &quot;mean&quot;: &quot;0.000004&quot;,        &quot;median&quot;: &quot;0.000004&quot;,        &quot;min&quot;: &quot;0.000004&quot;,        &quot;q1&quot;: &quot;0.000004&quot;,        &quot;q3&quot;: &quot;0.000004&quot;,        &quot;stdev&quot;: 0,        &quot;time_unit&quot;: &quot;s&quot;,        &quot;times&quot;: [],        &quot;unit&quot;: &quot;s&quot;    },    &quot;tags&quot;: {        &quot;columns&quot;: &quot;10&quot;,        &quot;name&quot;: &quot;matrix&quot;,        &quot;rows&quot;: &quot;2&quot;    }}Benchmark result:{    &quot;batch_id&quot;: &quot;13b87cc6d9a84f2188df279d8c513933&quot;,    &quot;run_id&quot;: &quot;48acd853b8294df9a1f5457f192456f3&quot;,    &quot;timestamp&quot;: &quot;2021-11-09T22:15:23.509211+00:00&quot;,    &quot;context&quot;: {        &quot;benchmark_language&quot;: &quot;Python&quot;    },    &quot;github&quot;: {        &quot;commit&quot;: &quot;61dec915b9dd230ca5029f5e586f8bd95c3e0c05&quot;,        &quot;repository&quot;: &quot;https://github.com/conbench/conbench&quot;    },    &quot;info&quot;: {        &quot;benchmark_language_version&quot;: &quot;Python 3.9.7&quot;    },    &quot;machine_info&quot;: {        &quot;architecture_name&quot;: &quot;arm64&quot;,        &quot;cpu_core_count&quot;: &quot;8&quot;,        &quot;cpu_frequency_max_hz&quot;: &quot;0&quot;,        &quot;cpu_l1d_cache_bytes&quot;: &quot;65536&quot;,        &quot;cpu_l1i_cache_bytes&quot;: &quot;131072&quot;,        &quot;cpu_l2_cache_bytes&quot;: &quot;4194304&quot;,        &quot;cpu_l3_cache_bytes&quot;: &quot;0&quot;,        &quot;cpu_model_name&quot;: &quot;Apple M1&quot;,        &quot;cpu_thread_count&quot;: &quot;8&quot;,        &quot;gpu_count&quot;: &quot;0&quot;,        &quot;gpu_product_names&quot;: [],        &quot;kernel_name&quot;: &quot;20.6.0&quot;,        &quot;memory_bytes&quot;: &quot;17179869184&quot;,        &quot;name&quot;: &quot;diana&quot;,        &quot;os_name&quot;: &quot;macOS&quot;,        &quot;os_version&quot;: &quot;11.5.2&quot;    },    &quot;stats&quot;: {        &quot;data&quot;: [            &quot;0.000002&quot;        ],        &quot;iqr&quot;: &quot;0.000000&quot;,        &quot;iterations&quot;: 1,        &quot;max&quot;: &quot;0.000002&quot;,        &quot;mean&quot;: &quot;0.000002&quot;,        &quot;median&quot;: &quot;0.000002&quot;,        &quot;min&quot;: &quot;0.000002&quot;,        &quot;q1&quot;: &quot;0.000002&quot;,        &quot;q3&quot;: &quot;0.000002&quot;,        &quot;stdev&quot;: 0,        &quot;time_unit&quot;: &quot;s&quot;,        &quot;times&quot;: [],        &quot;unit&quot;: &quot;s&quot;    },    &quot;tags&quot;: {        &quot;columns&quot;: &quot;2&quot;,        &quot;name&quot;: &quot;matrix&quot;,        &quot;rows&quot;: &quot;10&quot;    }}```### Example R benchmarksHere are a few examples illustrating how to integrate R benchmarks withConbench.The first one just times `1 + 1` in R, and the second one executes an Rbenchmark from a library of R benchmarks (in this case[arrowbench](https://github.com/ursacomputing/arrowbench)).If you find yourself wrapping a lot of R benchmarks in Python to integrate themwith Conbench (to get uniform JSON benchmark results which you can persist andpublish on a Conbench server), you'll probably want to extract much of theboilerplate out into a base class.```pythonimport conbench.runner@conbench.runner.register_benchmarkclass ExternalBenchmarkR(conbench.runner.Benchmark):    &quot;&quot;&quot;Example benchmark that records an R benchmark result.&quot;&quot;&quot;    external = True    name = &quot;external-r&quot;    def run(self, **kwargs):        result, output = self._run_r_command()        info, context = self.conbench.get_r_info_and_context()        yield self.conbench.record(            {&quot;data&quot;: [result], &quot;unit&quot;: &quot;s&quot;},            self.name,            info=info,            context=context,            options=kwargs,            output=output,        )    def _run_r_command(self):        output, _ = self.conbench.execute_r_command(self._get_r_command())        result = float(output.split(&quot;\n&quot;)[-1].split(&quot;[1] &quot;)[1])        return result, output    def _get_r_command(self):        return (            f&quot;addition &lt;- function() { 1 + 1 }; &quot;            &quot;start_time &lt;- Sys.time();&quot;            &quot;addition(); &quot;            &quot;end_time &lt;- Sys.time(); &quot;            &quot;result &lt;- end_time - start_time; &quot;            &quot;as.numeric(result); &quot;        )``````(conbench) $ cd ~/workspace/conbench/conbench/tests/benchmark/(conbench) $ conbench external-r --helpUsage: conbench external-r [OPTIONS]  Run external-r benchmark.Options:  --show-result BOOLEAN  [default: true]  --show-output BOOLEAN  [default: false]  --run-id TEXT          Group executions together with a run id.  --run-name TEXT        Free-text name of run (commit ABC, pull request 123,                         etc).  --run-reason TEXT      Low-cardinality reason for run (commit, pull request,                         manual, etc).  --help                 Show this message and exit.``````pythonimport jsonimport conbench.runner@conbench.runner.register_benchmarkclass ExternalBenchmarkOptionsR(conbench.runner.Benchmark):    &quot;&quot;&quot;Example benchmark that records an R benchmark result (with options).&quot;&quot;&quot;    external = True    name = &quot;external-r-options&quot;    options = {        &quot;iterations&quot;: {&quot;default&quot;: 1, &quot;type&quot;: int},        &quot;drop_caches&quot;: {&quot;type&quot;: bool, &quot;default&quot;: &quot;false&quot;},    }    def run(self, **kwargs):        data, iterations = [], kwargs.get(&quot;iterations&quot;, 1)        info, context = self.conbench.get_r_info_and_context()        for _ in range(iterations):            if kwargs.get(&quot;drop_caches&quot;, False):                self.conbench.sync_and_drop_caches()            result, output = self._run_r_command()            data.append(result[&quot;result&quot;][0][&quot;real&quot;])        yield self.conbench.record(            {&quot;data&quot;: data, &quot;unit&quot;: &quot;s&quot;},            self.name,            info=info,            context=context,            options=kwargs,            output=output,        )    def _run_r_command(self):        r_command = self._get_r_command()        self.conbench.execute_r_command(r_command)        with open(&quot;placebo.json&quot;) as json_file:            data = json.load(json_file)        return data, json.dumps(data, indent=2)    def _get_r_command(self):        return (            &quot;library(arrowbench); &quot;            &quot;out &lt;- run_one(arrowbench:::placebo); &quot;            &quot;cat(jsonlite::toJSON(out), file='placebo.json'); &quot;        )``````(conbench) $ cd ~/workspace/conbench/conbench/tests/benchmark/(conbench) $ conbench external-r --helpUsage: conbench external-r-options [OPTIONS]  Run external-r-options benchmark.Options:  --iterations INTEGER   [default: 1]  --drop-caches BOOLEAN  [default: false]  --show-result BOOLEAN  [default: true]  --show-output BOOLEAN  [default: false]  --run-id TEXT          Group executions together with a run id.  --run-name TEXT        Free-text name of run (commit ABC, pull request 123,                         etc).  --run-reason TEXT      Low-cardinality reason for run (commit, pull request,                         manual, etc).  --help                 Show this message and exit.```</longdescription>
</pkgmetadata>