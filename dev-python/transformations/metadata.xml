<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Homogeneous Transformation Matrices and Quaternions===================================================Transformations is a Python library for calculating 4x4 matrices fortranslating, rotating, reflecting, scaling, shearing, projecting,orthogonalizing, and superimposing arrays of 3D homogeneous coordinatesas well as for converting between rotation matrices, Euler angles,and quaternions. Also includes an Arcball control object andfunctions to decompose transformation matrices.:Author: `Christoph Gohlke &lt;https://www.cgohlke.com&gt;`_:License: BSD 3-Clause:Version: 2022.9.26Requirements------------This release has been tested with the following requirements and dependencies(other versions may work):- `CPython 3.8.10, 3.9.13, 3.10.7, 3.11.0rc2 &lt;https://www.python.org&gt;`_- `NumPy 1.22.4 &lt;https://pypi.org/project/numpy/&gt;`_Revisions---------2022.9.26- Add dimension check on superimposition_matrix (#2).2022.8.26- Update metadata- Remove support for Python 3.7 (NEP 29).2021.6.6- Remove support for Python 3.6 (NEP 29).2020.1.1- Remove support for Python 2.7 and 3.5.2019.4.22- Fix setup requirements.Notes-----Transformations.py is no longer actively developed and has a few known issuesand numerical instabilities. The module is mostly superseded by other modulesfor 3D transformations and quaternions:- `Scipy.spatial.transform &lt;https://github.com/scipy/scipy/tree/master/  scipy/spatial/transform&gt;`_- `Transforms3d &lt;https://github.com/matthew-brett/transforms3d&gt;`_  (includes most code of this module)- `Pytransform3d &lt;https://github.com/rock-learning/pytransform3d&gt;`_- `Numpy-quaternion &lt;https://github.com/moble/quaternion&gt;`_- `Blender.mathutils &lt;https://docs.blender.org/api/master/mathutils.html&gt;`_The API is not stable yet and is expected to change between revisions.This Python code is not optimized for speed. Refer to the transformations.cmodule for a faster implementation of some functions.Documentation in HTML format can be generated with epydoc.Matrices (M) can be inverted using numpy.linalg.inv(M), be concatenated usingnumpy.dot(M0, M1), or transform homogeneous coordinate arrays (v) usingnumpy.dot(M, v) for shape (4, -1) column vectors, respectivelynumpy.dot(v, M.T) for shape (-1, 4) row vectors (&quot;array of points&quot;).This module follows the &quot;column vectors on the right&quot; and &quot;row major storage&quot;(C contiguous) conventions. The translation components are in the right columnof the transformation matrix, i.e. M[:3, 3].The transpose of the transformation matrices may have to be used to interfacewith other graphics systems, e.g. OpenGL's glMultMatrixd(). See also [16].Calculations are carried out with numpy.float64 precision.Vector, point, quaternion, and matrix function arguments are expected to be&quot;array like&quot;, i.e. tuple, list, or numpy arrays.Return types are numpy arrays unless specified otherwise.Angles are in radians unless specified otherwise.Quaternions w+ix+jy+kz are represented as [w, x, y, z].A triple of Euler angles can be applied/interpreted in 24 ways, which canbe specified using a 4 character string or encoded 4-tuple:  *Axes 4-string*: e.g. 'sxyz' or 'ryxy'  - first character : rotations are applied to 's'tatic or 'r'otating frame  - remaining characters : successive rotation axis 'x', 'y', or 'z'  *Axes 4-tuple*: e.g. (0, 0, 0, 0) or (1, 1, 1, 1)  - inner axis: code of axis ('x':0, 'y':1, 'z':2) of rightmost matrix.  - parity : even (0) if inner axis 'x' is followed by 'y', 'y' is followed    by 'z', or 'z' is followed by 'x'. Otherwise odd (1).  - repetition : first and last axis are same (1) or different (0).  - frame : rotations are applied to static (0) or rotating (1) frame.References----------1.  Matrices and transformations. Ronald Goldman.    In &quot;Graphics Gems I&quot;, pp 472-475. Morgan Kaufmann, 1990.2.  More matrices and transformations: shear and pseudo-perspective.    Ronald Goldman. In &quot;Graphics Gems II&quot;, pp 320-323. Morgan Kaufmann, 1991.3.  Decomposing a matrix into simple transformations. Spencer Thomas.    In &quot;Graphics Gems II&quot;, pp 320-323. Morgan Kaufmann, 1991.4.  Recovering the data from the transformation matrix. Ronald Goldman.    In &quot;Graphics Gems II&quot;, pp 324-331. Morgan Kaufmann, 1991.5.  Euler angle conversion. Ken Shoemake.    In &quot;Graphics Gems IV&quot;, pp 222-229. Morgan Kaufmann, 1994.6.  Arcball rotation control. Ken Shoemake.    In &quot;Graphics Gems IV&quot;, pp 175-192. Morgan Kaufmann, 1994.7.  Representing attitude: Euler angles, unit quaternions, and rotation    vectors. James Diebel. 2006.8.  A discussion of the solution for the best rotation to relate two sets    of vectors. W Kabsch. Acta Cryst. 1978. A34, 827-828.9.  Closed-form solution of absolute orientation using unit quaternions.    BKP Horn. J Opt Soc Am A. 1987. 4(4):629-642.10. Quaternions. Ken Shoemake.    http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf11. From quaternion to matrix and back. JMP van Waveren. 2005.    http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm12. Uniform random rotations. Ken Shoemake.    In &quot;Graphics Gems III&quot;, pp 124-132. Morgan Kaufmann, 1992.13. Quaternion in molecular modeling. CFF Karney.    J Mol Graph Mod, 25(5):595-60414. New method for extracting the quaternion from a rotation matrix.    Itzhack Y Bar-Itzhack, J Guid Contr Dynam. 2000. 23(6): 1085-1087.15. Multiple View Geometry in Computer Vision. Hartley and Zissermann.    Cambridge University Press; 2nd Ed. 2004. Chapter 4, Algorithm 4.7, p 130.16. Column Vectors vs. Row Vectors.    http://steve.hollasch.net/cgindex/math/matrix/column-vec.htmlExamples--------&gt;&gt;&gt; alpha, beta, gamma = 0.123, -1.234, 2.345&gt;&gt;&gt; origin, xaxis, yaxis, zaxis = [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]&gt;&gt;&gt; I = identity_matrix()&gt;&gt;&gt; Rx = rotation_matrix(alpha, xaxis)&gt;&gt;&gt; Ry = rotation_matrix(beta, yaxis)&gt;&gt;&gt; Rz = rotation_matrix(gamma, zaxis)&gt;&gt;&gt; R = concatenate_matrices(Rx, Ry, Rz)&gt;&gt;&gt; euler = euler_from_matrix(R, 'rxyz')&gt;&gt;&gt; numpy.allclose([alpha, beta, gamma], euler)True&gt;&gt;&gt; Re = euler_matrix(alpha, beta, gamma, 'rxyz')&gt;&gt;&gt; is_same_transform(R, Re)True&gt;&gt;&gt; al, be, ga = euler_from_matrix(Re, 'rxyz')&gt;&gt;&gt; is_same_transform(Re, euler_matrix(al, be, ga, 'rxyz'))True&gt;&gt;&gt; qx = quaternion_about_axis(alpha, xaxis)&gt;&gt;&gt; qy = quaternion_about_axis(beta, yaxis)&gt;&gt;&gt; qz = quaternion_about_axis(gamma, zaxis)&gt;&gt;&gt; q = quaternion_multiply(qx, qy)&gt;&gt;&gt; q = quaternion_multiply(q, qz)&gt;&gt;&gt; Rq = quaternion_matrix(q)&gt;&gt;&gt; is_same_transform(R, Rq)True&gt;&gt;&gt; S = scale_matrix(1.23, origin)&gt;&gt;&gt; T = translation_matrix([1, 2, 3])&gt;&gt;&gt; Z = shear_matrix(beta, xaxis, origin, zaxis)&gt;&gt;&gt; R = random_rotation_matrix(numpy.random.rand(3))&gt;&gt;&gt; M = concatenate_matrices(T, R, Z, S)&gt;&gt;&gt; scale, shear, angles, trans, persp = decompose_matrix(M)&gt;&gt;&gt; numpy.allclose(scale, 1.23)True&gt;&gt;&gt; numpy.allclose(trans, [1, 2, 3])True&gt;&gt;&gt; numpy.allclose(shear, [0, math.tan(beta), 0])True&gt;&gt;&gt; is_same_transform(R, euler_matrix(axes='sxyz', *angles))True&gt;&gt;&gt; M1 = compose_matrix(scale, shear, angles, trans, persp)&gt;&gt;&gt; is_same_transform(M, M1)True&gt;&gt;&gt; v0, v1 = random_vector(3), random_vector(3)&gt;&gt;&gt; M = rotation_matrix(angle_between_vectors(v0, v1), vector_product(v0, v1))&gt;&gt;&gt; v2 = numpy.dot(v0, M[:3,:3].T)&gt;&gt;&gt; numpy.allclose(unit_vector(v1), unit_vector(v2))True</longdescription>
</pkgmetadata>