<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># FastAPI Injector![Workflow status](https://github.com/matyasrichter/fastapi-injector/actions/workflows/build.yml/badge.svg?branch=main)[![Coverage status](https://coveralls.io/repos/github/matyasrichter/fastapi-injector/badge.svg)](https://coveralls.io/github/matyasrichter/fastapi-injector?branch=main)Integrates [injector](https://github.com/alecthomas/injector) with [FastAPI](https://github.com/tiangolo/fastapi).Github: https://github.com/matyasrichter/fastapi-injector  PyPI: https://pypi.org/project/fastapi-injector/## Installation```shellpip install fastapi-injector```## UsageWhen creating your FastAPI app, attach the injector to it:```python# app.pyfrom fastapi import FastAPIfrom injector import Injectorfrom fastapi_injector import attach_injectordef create_app(injector: Injector) -&gt; FastAPI:    app = FastAPI()    app.include_router(...)    ...    attach_injector(app, injector)    return app```Then, use `Injected` in your routes. Under the hood, `Injected` is `Depends`, so you can use it anywhere `Depends` can be used. In the following example, `InterfaceType` issomething you've bound an implementation to in your injector instance.```pythonfrom fastapi import APIRouterfrom fastapi_injector import Injectedrouter = APIRouter()@router.get(&quot;/&quot;)async def get_root(integer: int = Injected(InterfaceType)):    return integer```A more complete example could look like this (your FastAPI code only depends on `InterfaceType`,its implementation only depends on a domain layer port etc.):```python# ------------------------# interface.pyimport abcfrom abc import abstractmethodclass SomeInterface(abc.ABC):    @abstractmethod    async def create_some_entity(self) -&gt; None:        &quot;&quot;&quot;Creates and saves an entity.&quot;&quot;&quot;# ------------------------# service.pyimport abcfrom .interface import SomeInterfaceclass SomeSavePort(abc.ABC):    @abc.abstractmethod    async def save_something(self, something: Entity) -&gt; None:        &quot;&quot;&quot;Saves an entity.&quot;&quot;&quot;class SomeService(SomeInterface):    def __init__(self, save_port: Inject[SomeSavePort]):        self.save_port = save_port    async def create_some_entity(self) -&gt; None:        entity = Entity(attr1=1, attr2=2)        await self.save_port.save_something(entity)# ------------------------# repository.pyfrom .service import SomeSavePortclass SomeRepository(SomeSavePort):    async def save_something(self, something: Entity) -&gt; None:# code that saves the entity to the DB```## Request scopeA common requirement is to have a dependency resolved to the same instance multiple times in the same request,but to create new instances for other requests. An example usecase for this behaviour is managing per-request DB connections.This library provides a `RequestScope` that fulfills this requirement.Under the hood, it uses [Context Variables](https://docs.python.org/3/library/contextvars.html)introduced in Python 3.7, generates a UUID4 for each request, and caches dependencies in a dictionarywith this uuid as the key.```pythonfrom injector import Injectorfrom fastapi import FastAPIfrom fastapi_injector import InjectorMiddleware, request_scope, attach_injectorfrom foo.bar import Interface, Implementationinj = Injector()# Use request_scope when binding the dependencyinj.binder.bind(Interface, to=Implementation, scope=request_scope)app = FastAPI()# Add the injector middleware to the app instanceapp.add_middleware(InjectorMiddleware, injector=inj)attach_injector(app, inj)```Your dependencies will then be cached within a request's resolution tree.Caching works both for top-level and nested dependencies(e.g. when you inject a DB connection to multiple repository classes).```python@app.get(&quot;/&quot;)def get_root(    foo: Interface = Injected(Interface),    bar: Interface = Injected(Interface),):    # the following assert will pass because both are the same instance.    assert foo is bar```### SyncInjectedThe dependency constructed by `Injected` is asynchronous. This causes it to run on the main thread. Should your usecase require a synchronous dependency, there's also an alternative - `SyncInjected`. Synchronous dependencies created by `SyncInjected` will be run on a separate thread from the threadpool. See the [FastAPI docs on this behaviour](https://fastapi.tiangolo.com/async/#dependencies).## Testing with fastapi-injectorTo use your app in tests with overridden dependencies, modify the injector before each test:```python# ------------------------# app entrypointimport pytestfrom injector import Injectorapp = create_app(inj)if __name__ == &quot;__main__&quot;:    uvicorn.run(&quot;app&quot;, ...)# ------------------------# composition rootdef create_injector() -&gt; Injector:    inj = Injector()    # note that this still gets executed,    # so if you need to get rid of a DB connection, for example,    # you would need to use a callable provider.    inj.binder.bind(int, 1)    return inj# ------------------------# testsfrom fastapi import FastAPIfrom fastapi.testclient import TestClientfrom path.to.app.factory import create_app@pytest.fixturedef app() -&gt; FastAPI:    inj = Injector()    inj.binder.bind(int, 2)    return create_app(inj)def some_test(app: FastAPI):    # use test client with the new app    client = TestClient(app)```## ContributingAll contributions are welcome. Please raise an issue and/or open a pull request if you'd like to help to make `fastapi-injector` better.- Use [poetry](https://python-poetry.org/docs/) to install dependencies- Use [pre-commit](https://pre-commit.com/) to run linters and formatters before committing and pushing- Write tests for your code</longdescription>
</pkgmetadata>