<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Ledger Bitcoin application client## OverviewClient library for Ledger Bitcoin application.Main repository and documentation: https://github.com/LedgerHQ/app-bitcoin-new## InstallIf you just want to communicate through TCP socket (for example with the Speculos emulator), there is no dependency:```bash$ pip install ledger_bitcoin```otherwise, [hidapi](https://github.com/trezor/cython-hidapi) must be installed as an extra dependency:```bash$ pip install ledger_bitcoin[hid]```## Getting startedThe main method exported by the library is `createClient`, which queries the hardware wallet for the version of the running app, and then returns the appropriate implementation of the `Client` class.See the documentation of the class and the example below for the supported methods.When running on a legacy version of the app (below version `2.0.0`), only the features that were available on the app are supported. Any unsopported method (e.g.: multisig registration or addresses, taproot addresses) will raise a `NotImplementedError`.### Running with speculosIt is possible to run the app and the library with the [speculos](https://github.com/LedgerHQ/speculos) emulator.⚠️ Currently, speculos does not correctly emulate the version of the app, always returning a dummy value; in order to use the library, it is necessary to set the `SPECULOS_APPNAME` environment variable before starting speculos, for example with:```$ export SPECULOS_APPNAME=&quot;Bitcoin Test:2.1.0&quot;```Similarly, to test the library behavior on a legacy version of the app, one can set the version to `1.6.5` (the final version of the 1.X series).The expected application name is `Bitcoin` for mainnet, `Bitcoin Test` for testnet.### ExampleThe following example showcases all the main methods of the `Client`'s interface.If you are not using the context manager syntax when creating the client, remember to call the `stop()` method to release the communication channel.Testing the `sign_psbt` method requires producing a valid PSBT (with any external tool that supports either PSBTv0 or PSBTv2), and provide the corresponding wallet policy; it is skipped by default in the following example.```pythonfrom typing import Optionalfrom ledger_bitcoin import createClient, Chain, MultisigWallet, MultisigWallet, WalletPolicy, AddressType, TransportClientfrom ledger_bitcoin.psbt import PSBTdef main():    # speculos on default host/port    # with createClient(TransportClient(), chain=Chain.TEST) as client:    # Ledger Nano connected via USB    with createClient(chain=Chain.TEST) as client:        # ==&gt; Get the master key fingerprint        fpr = client.get_master_fingerprint().hex()        print(f&quot;Master key fingerprint: {fpr}&quot;)        # ==&gt; Get and display on screen the first taproot address        first_taproot_account_pubkey = client.get_extended_pubkey(&quot;m/86'/1'/0'&quot;)        first_taproot_account_policy = WalletPolicy(            &quot;&quot;,            &quot;tr(@0/**)&quot;,            [                f&quot;[{fpr}/86'/1'/0']{first_taproot_account_pubkey}/**&quot;            ],        )        first_taproot_account_address = client.get_wallet_address(            first_taproot_account_policy,            None,            change=0,            address_index=0,            display=True # show address on the wallet's screen        )        print(f&quot;First taproot account receive address: {first_taproot_account_address}&quot;)        # ==&gt; Register a multisig wallet named &quot;Cold storage&quot;        our_pubkey = client.get_extended_pubkey(&quot;m/48'/1'/0'/2'&quot;)        other_key_info = &quot;[76223a6e/48'/1'/0'/2']tpubDE7NQymr4AFtewpAsWtnreyq9ghkzQBXpCZjWLFVRAvnbf7vya2eMTvT2fPapNqL8SuVvLQdbUbMfWLVDCZKnsEBqp6UK93QEzL8Ck23AwF/**&quot;        multisig_policy = MultisigWallet(            name=&quot;Cold storage&quot;,            address_type=AddressType.WIT,            threshold=2,            keys_info=[                other_key_info,                       # some other bitcoiner                f&quot;[{fpr}/48'/1'/0'/2']{our_pubkey}&quot;,  # that's us            ],        )        policy_id, policy_hmac = client.register_wallet(multisig_policy)        print(f&quot;Policy hmac: {policy_hmac.hex()}. Store it safely (together with the policy).&quot;)        assert policy_id == multisig_policy.id  # should never fail        # ==&gt; Derive and show an address for &quot;Cold storage&quot;        multisig_address = client.get_wallet_address(multisig_policy, policy_hmac, change=0, address_index=0, display=True)        print(f&quot;Multisig wallet address: {multisig_address}&quot;)        # ==&gt; Sign a psbt        # TODO: set a wallet policy and a valid psbt file in order to test psbt signing        psbt_filename: Optional[str] = None        signing_policy: Optional[WalletPolicy] = None        signing_policy_hmac: Optional[bytes] = None        if not psbt_filename or not signing_policy:            print(&quot;Nothing to sign :(&quot;)            return        raw_psbt_base64 = open(psbt_filename, &quot;r&quot;).read()        psbt = PSBT()        psbt.deserialize(raw_psbt_base64)        result = client.sign_psbt(psbt, signing_policy, signing_policy_hmac)        print(&quot;Returned signatures:&quot;)        print(result)if __name__ == &quot;__main__&quot;:    main()```</longdescription>
</pkgmetadata>