<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># anicli-apiПрограммный интерфейс набора парсеров аниме с различных источников.# requirements```pythonht```Присутствует поддержка sync и async методов с помощью `httpx` библиотекиПарсеры работают на REST-API (если у источника есть доступ), parsel и обёртки scrape-schema# install`pip install anicli-api`# OverviewСтруктура проекта```anicli_api├── base.py - базовый класс модуля-парсера├── _http.py - сконфигурированный классы httpx├── _logger.py - логгер├── player - модули получения ссылок на видео│     ├── __template__.py - шаблон модуля PlayerExtractor│     ├── ...  ready-made модули│     ...├── source - модули парсеров с источников│     ├── __template__.py│     ├─ ... ready-made парсеры│     ...└── tools - прочие модули```Модули имеют следующий алгоритм пошагового получения объектов:```shell# Extractor works schema:    [Extractor]        | search(&lt;query&gt;)/ongoing()  -&gt; List[Search | Ongoing]        V                             [Search | Ongoing]                   | get_anime()  -&gt; AnimeInfo         V                              [Anime]                             | get_episodes()  -&gt; List[Episode]          V                               [Episode]                              | get_videos()  -&gt; List[Video]                      V                               [Source]        | get_source()  -&gt; MetaVideo or Str        V    Video(type, quality, url, extra_headers) or url```# Quickstart exampleДемонстрация простого prompt-line приложения.```pythonfrom anicli_api.source.animejoy import Extractor # или любой другой источникif __name__ == '__main__':    ex = Extractor()    while True:        print(&quot;PRESS CTRL + C for exit&quot;)        results = ex.search(input(&quot;search query &gt; &quot;))        print(*[f&quot;{i}) {r}&quot; for i, r in enumerate(results)], sep=&quot;\n&quot;)        anime = results[int(input(&quot;anime &gt; &quot;))].get_anime()        episodes = anime.get_episodes()        print(*[f&quot;{i}) {ep}&quot; for i, ep in enumerate(episodes)], sep=&quot;\n&quot;)        episode = episodes[int(input(&quot;episode &gt; &quot;))]        sources = episode.get_sources()        print(*[f&quot;{i}) {source}&quot; for i, source in enumerate(sources)])        source = sources[int(input(&quot;source &gt; &quot;))]        videos = source.get_videos()        print(*videos, sep=&quot;\n&quot;)        video = videos[int(input(&quot;video &gt; &quot;))]        print(video.type, video.quality, video.url, video.headers)```С asyncio аналогично, но методы получения объектов имеют префикс `a_` # VideoОбъект `Video` (полученный из `Source.get_video` или `Source.a_get_video`) имеет следующую структуру:* type - тип видео* quality - разрешение видео* url - прямая ссылка на видео* headers - заголовки требуемые для воспроизведения видео. Если возвращает пустой словарь - заголовки не нужны# ПримечанияПроект разработан преимущественно на личное, некоммерческое использование с client-side стороны. Автор проекта не несет ответственности за поломки, убытки в высоко нагруженных проектах и решениепредоставляется &quot;Как есть&quot; в соответствии с [MIT](LIENSE) лицензией.**Этот проект не включает инструменты кеширования и сохранения всех полученных данных, только готовые реализации парсеров**</longdescription>
</pkgmetadata>