<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Pydantic-resolve[![CI](https://github.com/allmonday/pydantic_resolve/actions/workflows/ci.yml/badge.svg)](https://github.com/allmonday/pydantic_resolve/actions/workflows/ci.yml)![Python Versions](https://img.shields.io/pypi/pyversions/pydantic-resolve)![Test Coverage](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/allmonday/6f1661c6310e1b31c9a10b0d09d52d11/raw/covbadge.json)[![pypi](https://img.shields.io/pypi/v/pydantic-resolve.svg)](https://pypi.python.org/pypi/pydantic-resolve)[![Downloads](https://static.pepy.tech/personalized-badge/pydantic-resolve?period=month&amp;units=abbreviation&amp;left_color=grey&amp;right_color=orange&amp;left_text=Downloads)](https://pepy.tech/project/pydantic-resolve)&gt; A small yet powerful package which can run resolvers to generate deep nested datasets.**example**:```python# define loader functionsasync def friends_batch_load_fn(names):    mock_db = {        'tangkikodo': ['tom', 'jerry'],        'john': ['mike', 'wallace'],        'trump': ['sam', 'jim'],        'sally': ['sindy', 'lydia'],    }    return [mock_db.get(name, []) for name in names]async def contact_batch_load_fn(names):    mock_db = {        'tom': 100, 'jerry':200, 'mike': 3000, 'wallace': 400, 'sam': 500,        'jim': 600, 'sindy': 700, 'lydia': 800, 'tangkikodo': 900, 'john': 1000,        'trump': 1200, 'sally': 1300,    }    return [mock_db.get(name, None) for name in names]# define schemasclass Contact(BaseModel):    number: Optional[int]class Friend(BaseModel):    name: str    contact: int = 0    @mapper(lambda n: Contact(number=n))    def resolve_contact(self, loader=LoaderDepend(contact_batch_load_fn)):        return loader.load(self.name)class User(BaseModel):    name: str    age: int    greeting: str = ''    def resolve_greeting(self):        return f&quot;hello, i'm {self.name}, {self.age} years old.&quot;    contact: int = 0    @mapper(lambda n: Contact(number=n))    def resolve_contact(self, loader=LoaderDepend(contact_batch_load_fn)):        return loader.load(self.name)    friends: List[Friend] = []    @mapper(lambda items: [Friend(name=item) for item in items])  # transform after data received    def resolve_friends(self, loader=LoaderDepend(friends_batch_load_fn)):        return loader.load(self.name)class Root(BaseModel):    users: List[User] = []    def resolve_users(self):        return [          {&quot;name&quot;: &quot;tangkikodo&quot;, &quot;age&quot;: 19},            User(name=&quot;tangkikodo&quot;, age=19),  # transform first            User(name='john', age=21),            # User(name='trump', age=59),            # User(name='sally', age=21),            # User(name='some one', age=0)        ]async def main():    import json    root = await Resolver().resolve(Root())    dct = root.dict()    print(json.dumps(dct, indent=4))asyncio.run(main())```**output**:```json{  &quot;users&quot;: [    {      &quot;name&quot;: &quot;tangkikodo&quot;,      &quot;age&quot;: 19,      &quot;greeting&quot;: &quot;hello, i'm tangkikodo, 19 years old.&quot;,      &quot;contact&quot;: {        &quot;number&quot;: 900      },      &quot;friends&quot;: [        {          &quot;name&quot;: &quot;tom&quot;,          &quot;contact&quot;: {            &quot;number&quot;: 100          }        },        {          &quot;name&quot;: &quot;jerry&quot;,          &quot;contact&quot;: {            &quot;number&quot;: 200          }        }      ]    },    {      &quot;name&quot;: &quot;john&quot;,      &quot;age&quot;: 21,      &quot;greeting&quot;: &quot;hello, i'm john, 21 years old.&quot;,      &quot;contact&quot;: {        &quot;number&quot;: 1000      },      &quot;friends&quot;: [        {          &quot;name&quot;: &quot;mike&quot;,          &quot;contact&quot;: {            &quot;number&quot;: 3000          }        },        {          &quot;name&quot;: &quot;wallace&quot;,          &quot;contact&quot;: {            &quot;number&quot;: 400          }        }      ]    }  ]}```- Full-feature [example](./examples/6_sqlalchemy_loaderdepend_global_filter.py) which includes `dataloader`, `LoaderDepend` and global `loader_filters`- Helps you asynchoronously, resursively resolve a pydantic object (or dataclass object)- When used in conjunction with aiodataloader, allows you to easily generate nested data structures without worrying about generating N+1 queries.- say byebye to contextvars when using dataloader.- Inspired by [GraphQL](https://graphql.org/) and [graphene](https://graphene-python.org/)## Install```shellpip install pydantic-resolvepip install &quot;pydantic-resolve[dataloader]&quot;  # install with aiodataloader, from v1.0, aiodataloader is a default dependency, [dataloader] is removed.```- use `resolve` for simple scenario,- use `Resolver` and `LoaderDepend` for complicated nested batch query.```pythonfrom pydantic_resolve import (    resolve,                     # handle simple resolving task    Resolver, LoaderDepend,      # handle schema resolving with LoaderDepend and DataLoader    ResolverTargetAttrNotFound, DataloaderDependCantBeResolved, LoaderFieldNotProvidedError)```## Run FastAPI example```shellpoetry shellcd examplesuvicorn fastapi_demo.main:app# http://localhost:8000/docs#/default/get_tasks_tasks_get```## Some documentations.- [Reason](./doc/reason-en.md)- [How LoaderDepend works](./doc/loader-en.md)- [Comparsion with common solutions](./doc/compare-en.md)For more examples, please explore [examples](./examples/) folder.## Unittest```shellpoetry run python -m unittest  # orpoetry run pytest  # orpoetry run tox```## Coverage```shellpoetry run coverage run -m pytestpoetry run coverage report -m```</longdescription>
</pkgmetadata>