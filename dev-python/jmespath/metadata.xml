<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>JMESPath========.. image:: https://badges.gitter.im/Join Chat.svg   :target: https://gitter.im/jmespath/chatJMESPath (pronounced &quot;james path&quot;) allows you to declaratively specify how toextract elements from a JSON document.For example, given this document::    {&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}The jmespath expression ``foo.bar`` will return &quot;baz&quot;.JMESPath also supports:Referencing elements in a list.  Given the data::    {&quot;foo&quot;: {&quot;bar&quot;: [&quot;one&quot;, &quot;two&quot;]}}The expression: ``foo.bar[0]`` will return &quot;one&quot;.You can also reference all the items in a list using the ``*``syntax::   {&quot;foo&quot;: {&quot;bar&quot;: [{&quot;name&quot;: &quot;one&quot;}, {&quot;name&quot;: &quot;two&quot;}]}}The expression: ``foo.bar[*].name`` will return [&quot;one&quot;, &quot;two&quot;].Negative indexing is also supported (-1 refers to the last elementin the list).  Given the data above, the expression``foo.bar[-1].name`` will return &quot;two&quot;.The ``*`` can also be used for hash types::   {&quot;foo&quot;: {&quot;bar&quot;: {&quot;name&quot;: &quot;one&quot;}, &quot;baz&quot;: {&quot;name&quot;: &quot;two&quot;}}}The expression: ``foo.*.name`` will return [&quot;one&quot;, &quot;two&quot;].Installation============You can install JMESPath from pypi with:.. code:: bash    pip install jmespathAPI===The ``jmespath.py`` library has two functionsthat operate on python data structures.  You can use ``search``and give it the jmespath expression and the data:.. code:: python    &gt;&gt;&gt; import jmespath    &gt;&gt;&gt; path = jmespath.search('foo.bar', {'foo': {'bar': 'baz'}})    'baz'Similar to the ``re`` module, you can use the ``compile`` functionto compile the JMESPath expression and use this parsed expressionto perform repeated searches:.. code:: python    &gt;&gt;&gt; import jmespath    &gt;&gt;&gt; expression = jmespath.compile('foo.bar')    &gt;&gt;&gt; expression.search({'foo': {'bar': 'baz'}})    'baz'    &gt;&gt;&gt; expression.search({'foo': {'bar': 'other'}})    'other'This is useful if you're going to use the same jmespath expression tosearch multiple documents.  This avoids having to reparse theJMESPath expression each time you search a new document.Options-------You can provide an instance of ``jmespath.Options`` to control howa JMESPath expression is evaluated.  The most common scenario forusing an ``Options`` instance is if you want to have ordered outputof your dict keys.  To do this you can use either of these options:.. code:: python    &gt;&gt;&gt; import jmespath    &gt;&gt;&gt; jmespath.search('{a: a, b: b}',    ...                 mydata,    ...                 jmespath.Options(dict_cls=collections.OrderedDict))    &gt;&gt;&gt; import jmespath    &gt;&gt;&gt; parsed = jmespath.compile('{a: a, b: b}')    &gt;&gt;&gt; parsed.search(mydata,    ...               jmespath.Options(dict_cls=collections.OrderedDict))Custom Functions~~~~~~~~~~~~~~~~The JMESPath language has numerous`built-in functions&lt;http://jmespath.org/specification.html#built-in-functions&gt;`__, but it isalso possible to add your own custom functions.  Keep in mind thatcustom function support in jmespath.py is experimental and the API maychange based on feedback.**If you have a custom function that you've found useful, consider submittingit to jmespath.site and propose that it be added to the JMESPath language.**You can submit proposals`here &lt;https://github.com/jmespath/jmespath.site/issues&gt;`__.To create custom functions:* Create a subclass of ``jmespath.functions.Functions``.* Create a method with the name ``_func_&lt;your function name&gt;``.* Apply the ``jmespath.functions.signature`` decorator that indicates  the expected types of the function arguments.* Provide an instance of your subclass in a ``jmespath.Options`` object.Below are a few examples:.. code:: python    import jmespath    from jmespath import functions    # 1. Create a subclass of functions.Functions.    #    The function.Functions base class has logic    #    that introspects all of its methods and automatically    #    registers your custom functions in its function table.    class CustomFunctions(functions.Functions):        # 2 and 3.  Create a function that starts with _func_        # and decorate it with @signature which indicates its        # expected types.        # In this example, we're creating a jmespath function        # called &quot;unique_letters&quot; that accepts a single argument        # with an expected type &quot;string&quot;.        @functions.signature({'types': ['string']})        def _func_unique_letters(self, s):            # Given a string s, return a sorted            # string of unique letters: 'ccbbadd' -&gt;  'abcd'            return ''.join(sorted(set(s)))        # Here's another example.  This is creating        # a jmespath function called &quot;my_add&quot; that expects        # two arguments, both of which should be of type number.        @functions.signature({'types': ['number']}, {'types': ['number']})        def _func_my_add(self, x, y):            return x + y    # 4. Provide an instance of your subclass in a Options object.    options = jmespath.Options(custom_functions=CustomFunctions())    # Provide this value to jmespath.search:    # This will print 3    print(        jmespath.search(            'my_add(`1`, `2`)', {}, options=options)    )    # This will print &quot;abcd&quot;    print(        jmespath.search(            'foo.bar | unique_letters(@)',            {'foo': {'bar': 'ccbbadd'}},            options=options)    )Again, if you come up with useful functions that you think makesense in the JMESPath language (and make sense to implement in allJMESPath libraries, not just python), please let us know at`jmespath.site &lt;https://github.com/jmespath/jmespath.site/issues&gt;`__.Specification=============If you'd like to learn more about the JMESPath language, you can check outthe `JMESPath tutorial &lt;http://jmespath.org/tutorial.html&gt;`__.  Also checkout the `JMESPath examples page &lt;http://jmespath.org/examples.html&gt;`__ forexamples of more complex jmespath queries.The grammar is specified using ABNF, as described in`RFC4234 &lt;http://www.ietf.org/rfc/rfc4234.txt&gt;`_.You can find the most up to date`grammar for JMESPath here &lt;http://jmespath.org/specification.html#grammar&gt;`__.You can read the full`JMESPath specification here &lt;http://jmespath.org/specification.html&gt;`__.Testing=======In addition to the unit tests for the jmespath modules,there is a ``tests/compliance`` directory that contains.json files with test cases.  This allows other implementationsto verify they are producing the correct output.  Each jsonfile is grouped by feature.Discuss=======Join us on our `Gitter channel &lt;https://gitter.im/jmespath/chat&gt;`__if you want to chat or if you have any questions.</longdescription>
</pkgmetadata>