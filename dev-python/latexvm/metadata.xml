<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Latex-VM (Virtual Machine)[![Coverage](https://sonarcloud.io/api/project_badges/measure?project=TheGreatWaves_Latex-VM&amp;metric=coverage)](https://sonarcloud.io/summary/new_code?id=TheGreatWaves_Latex-VM)[![Bugs](https://sonarcloud.io/api/project_badges/measure?project=TheGreatWaves_Latex-VM&amp;metric=bugs)](https://sonarcloud.io/summary/new_code?id=TheGreatWaves_Latex-VM)[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=TheGreatWaves_Latex-VM&amp;metric=alert_status)](https://sonarcloud.io/summary/new_code?id=TheGreatWaves_Latex-VM)[![Code Smells](https://sonarcloud.io/api/project_badges/measure?project=TheGreatWaves_Latex-VM&amp;metric=code_smells)](https://sonarcloud.io/summary/new_code?id=TheGreatWaves_Latex-VM)Latex-VM is a simple context environment for mathematical expressions in LaTeX. It supports variable and function declaration.### Type Aliases| Type                | Definition                 ||---------------------|----------------------------|| Varname             | `str`                      || ExpressionStr       | `str`                      || EnvironmentVariables| `Dict[Varname, Any]`       |### API```pyclass ActionResult:    def ok(self) -&gt; boolclass GraphSession:    @staticmethod    def new(env: EnvironmentVariables = {}, rules: Dict[str, str] = {}) -&gt; &quot;GraphSession&quot;    def execute(self, input: str, simplify: bool = False) -&gt; ActionResult[CalculatorAction, str]    def get_env_functions(self) -&gt; EnvironmentVariables    def get_env_variables(self) -&gt; EnvironmentVariables    def get_env(self) -&gt; EnvironmentVariables    def force_resolve_function(self, input: str, use_sub_rule: bool = True) -&gt; ActionResult[None, str]    def add_sub_rule(self, pattern: str, replacement: str) -&gt; None    def remove_sub_rule(self, pattern: str) -&gt; None    def get_sub_rules(self) -&gt; Dict[str, str]    def clear_session(self) -&gt; None```### Example Usage```python# Create a new graph sessionsession = GraphSession.new()# Assignment expressionsession.execute(&quot;y = 20&quot;)                                 # Action: CalculatorAction.VARIABLE_ASSIGNMENT, Ok(20)# Function declaration expressionsession.execute(&quot;double(x) = x * 2&quot;)                      # Action: CalculatorAction.FUNCTION_DEFINITION, Ok(double_func(x) = x * 2)session.execute(&quot;pow(x) = x^2&quot;)                           # Action: CalculatorAction.FUNCTION_DEFINITION, Ok(pow_func(x) = x^2)# Statement expressionsession.execute(&quot;double(pow(2))&quot;)                         # Action: CalculatorAction.STATEMENT_EXECUTION, Ok(8)# Function force-resolve (Does not converge to a value)session.force_resolve_function(&quot;double(pow(x+2))&quot;)        # Ok((x + 2)**2*2)```### Environment Variables and Value Retrieval**Note**: All getters returns a copy in order to prevent mutation of internal variables.```pythonsession = GraphSession.new()session.execute(&quot;y = 20&quot;)session.execute(&quot;double(x) = x * 2&quot;)# Get all environment variablessession.get_env()                       # {'y': '20', 'double_func': (['x'], 'x * 2')}# Get only function varaiblessession.get_env_functions()             # {'double_func': (['x'], 'x * 2')}# Get only variablessession.get_env_variables()             # {'y': '20'}# Session can be clearedsession.clear_session()```### Result and Error HandlingMethods which returns the `ActionResult` type conforms to the following handling.\**Note**: `ActionResult.action` holds the action value.```python...result = session.execute(...)if result.ok():  ...  # use the result value  # Note: The result.message contains the valueelse:  ...  # handle errors...  # Note: The result.message contains the error message  ```### Session LoadingSessions can easily be loaded by passing in pre-existing environment variables.```pysession_1 = GraphSession.new()session_1.execute(&quot;double(x) = x * 2&quot;)session_2 = GraphSession.new(session.get_env())res = session_2.execute(&quot;double(5)&quot;)print(res.message) # 10```### SimplificationExpression simplification is optional. In cases where the input latex is very complex, it can greatly affectperformance. For this reason, the `simplify` flag is defaulted to `False`. Addtionally, the simplify functionis run with a timeout of `3` seconds, if failed, it will just yield the result without simplifying.```pythonsession = GraphSession.new()# Action: CalculatorAction.FUNCTION_DEFINITION, Ok(f_func(x) = \frac{x}{3} + 3 + 20 + 20 + 20)session.execute(r&quot;f(x) = \frac{x}{3} + 3 + y + y + y&quot;)# Action: CalculatorAction.FUNCTION_DEFINITION, Ok(f_func(x) = \frac{x}{3} + 63)session.execute(r&quot;f(x) = \frac{x}{3} + 3 + y + y + y&quot;, simplify=True)```### Substitution RulesThe `GraphSession.force_resolve_function` method returns a Pythonic representation of the input. However, this representation may need to be modified in order to be usable. For this reason, there are substitution rules that can be applied to the output.&gt; This behavior is enabled default, to resolve without using substitution rules, set `use_sub_rule` to `False`.```pythongs.execute(r&quot;make_abs(x) = \left|x\right|&quot;)gs.execute(r&quot;pow(a, b) = a^{b}&quot;)# Without any substituion ruleprint(gs.force_resolve_function(r&quot;pow(make_abs(x), make_abs(y))&quot;))   # Ok(Abs(x)**Abs(y))# We want abs(...) instead of Abs(...)gs.add_sub_rule(&quot;Abs&quot;, &quot;abs&quot;)gs.force_resolve_function(r&quot;pow(make_abs(x), make_abs(y))&quot;)   # Ok(abs(x)**abs(y))# We need pow expressed using '^'gs.add_sub_rule(r&quot;\*\*&quot;, &quot;^&quot;)gs.force_resolve_function(r&quot;pow(make_abs(x), make_abs(y))&quot;)   # Ok(abs(x)^abs(y))# Resolve without using substitution rulesgs.force_resolve_function(r&quot;pow(make_abs(x), make_abs(y))&quot;, use_sub_rule=False) # Ok(Abs(x)**Abs(y))```### LaTeX overrideYou can override LaTeX functions by declaring a function with the same name. This allows you to customize the functionality of the function according to your needs.```python# Works perfectly fineprint(gs.force_resolve_function(r&quot;\sin\left(x\right)&quot;)) # Ok(sin(x))# Overridegs.execute(&quot;double(x) = 2 x&quot;)gs.execute(&quot;sin(a) = double(a)&quot;)# Sin is now overriddenprint(gs.force_resolve_function(r&quot;\sin\left(x\right)&quot;)) # Ok(x*2)```</longdescription>
</pkgmetadata>