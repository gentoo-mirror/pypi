<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Pipetools=========|tests-badge| |coverage-badge| |pypi-badge|.. |tests-badge| image:: https://github.com/0101/pipetools/actions/workflows/tests.yml/badge.svg  :target: https://github.com/0101/pipetools/actions/workflows/tests.yml.. |coverage-badge| image:: https://raw.githubusercontent.com/0101/pipetools/master/coverage.svg  :target: https://github.com/0101/pipetools/actions/workflows/tests.yml.. |pypi-badge| image:: https://img.shields.io/pypi/dm/pipetools.svg  :target: https://pypi.org/project/pipetools/`Complete documentation &lt;https://0101.github.io/pipetools/doc/&gt;`_``pipetools`` enables function composition similar to using Unix pipes.It allows forward-composition and piping of arbitrary functions - no need to decorate them or do anything extra.It also packs a bunch of utils that make common operations more convenient and readable.Source is on github_... _github: https://github.com/0101/pipetoolsWhy?----Piping and function composition are some of the most natural operations there are forplenty of programming tasks. Yet Python doesn't have a built-in way of performing them.That forces you to either deep nesting of function calls or adding extra **glue code**.Example-------Say you want to create a list of python files in a given directory, ordered byfilename length, as a string, each file on one line and also with line numbers:.. code-block:: pycon    &gt;&gt;&gt; print(pyfiles_by_length('../pipetools'))    1. ds_builder.py    2. __init__.py    3. compat.py    4. utils.py    5. main.pyAll the ingredients are already there, you just have to glue them together. You might write it like this:.. code-block:: python    def pyfiles_by_length(directory):        all_files = os.listdir(directory)        py_files = [f for f in all_files if f.endswith('.py')]        sorted_files = sorted(py_files, key=len, reverse=True)        numbered = enumerate(py_files, 1)        rows = (&quot;{0}. {1}&quot;.format(i, f) for i, f in numbered)        return '\n'.join(rows)Or perhaps like this:.. code-block:: python    def pyfiles_by_length(directory):        return '\n'.join('{0}. {1}'.format(*x) for x in enumerate(reversed(sorted(            [f for f in os.listdir(directory) if f.endswith('.py')], key=len)), 1))Or, if you're a mad scientist, you would probably do it like this:.. code-block:: python    pyfiles_by_length = lambda d: (reduce('{0}\n{1}'.format,        map(lambda x: '%d. %s' % x, enumerate(reversed(sorted(            filter(lambda f: f.endswith('.py'), os.listdir(d)), key=len))))))But *there should be one -- and preferably only one -- obvious way to do it*.So which one is it? Well, to redeem the situation, ``pipetools`` give you yetanother possibility!.. code-block:: python    pyfiles_by_length = (pipe        | os.listdir        | where(X.endswith('.py'))        | sort_by(len).descending        | (enumerate, X, 1)        | foreach(&quot;{0}. {1}&quot;)        | '\n'.join)*Why would I do that*, you ask? Comparing to the *native* Python code, it's- **Easier to read** -- minimal extra clutter- **Easier to understand** -- one-way data flow from one step to the next, nothing else to keep track of- **Easier to change** -- want more processing? just add a step to the pipeline- **Removes some bug opportunities** -- did you spot the bug in the first example?Of course it won't solve all your problems, but a great deal of code *can*be expressed as a pipeline, giving you the above benefits. Read on to see how it works!Installation------------.. code-block:: console    $ pip install pipetools`Uh, what's that? &lt;https://pip.pypa.io&gt;`_Usage-----.. _the-pipe:The pipe&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;The ``pipe`` object can be used to pipe functions together toform new functions, and it works like this:.. code-block:: python    from pipetools import pipe    f = pipe | a | b | c    # is the same as:    def f(x):        return c(b(a(x)))A real example, sum of odd numbers from 0 to *x*:.. code-block:: python    from functools import partial    from pipetools import pipe    odd_sum = pipe | range | partial(filter, lambda x: x % 2) | sum    odd_sum(10)  # -&gt; 25Note that the chain up to the `sum` is lazy.Automatic partial application in the pipe&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;As partial application is often useful when piping things together, it is doneautomatically when the *pipe* encounters a tuple, so this produces the sameresult as the previous example:.. code-block:: python    odd_sum = pipe | range | (filter, lambda x: x % 2) | sumAs of ``0.1.9``, this is even more powerful, see `X-partial  &lt;https://0101.github.io/pipetools/doc/xpartial.html&gt;`_.Built-in tools&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;Pipetools contain a set of *pipe-utils* that solve some common tasks. Forexample there is a shortcut for the filter class from our example, called`where() &lt;https://0101.github.io/pipetools/doc/pipeutils.html#pipetools.utils.where&gt;`_:.. code-block:: python    from pipetools import pipe, where    odd_sum = pipe | range | where(lambda x: x % 2) | sumWell that might be a bit more readable, but not really a huge improvement, butwait!If a *pipe-util* is used as first or second item in the pipe (which happensquite often) the ``pipe`` at the beginning can be omitted:.. code-block:: python    odd_sum = range | where(lambda x: x % 2) | sumSee `pipe-utils' documentation &lt;https://0101.github.io/pipetools/doc/pipeutils.html&gt;`_.OK, but what about the ugly lambda?&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;`where() &lt;https://0101.github.io/pipetools/doc/pipeutils.html#pipetools.utils.where&gt;`_, but also `foreach() &lt;https://0101.github.io/pipetools/doc/pipeutils.html#pipetools.utils.foreach&gt;`_,`sort_by() &lt;https://0101.github.io/pipetools/doc/pipeutils.html#pipetools.utils.sort_by&gt;`_ and other `pipe-utils &lt;https://0101.github.io/pipetools/doc/pipeutils.html&gt;`_ can bequite useful, but require a function as an argument, which can either be a namedfunction -- which is OK if it does something complicated -- but often it'ssomething simple, so it's appropriate to use a ``lambda``. Except Python'slambdas are quite verbose for simple tasks and the code gets cluttered...**X object** to the rescue!.. code-block:: python    from pipetools import where, X    odd_sum = range | where(X % 2) | sumHow 'bout that.`Read more about the X object and it's limitations. &lt;https://0101.github.io/pipetools/doc/xobject.html&gt;`_.. _auto-string-formatting:Automatic string formatting&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;Since it doesn't make sense to compose functions with strings, when a pipe (or a`pipe-util &lt;https://0101.github.io/pipetools/doc/pipeutils.html&gt;`_) encounters a string, it attempts to use it for`(advanced) formatting`_:.. code-block:: pycon    &gt;&gt;&gt; countdown = pipe | (range, 1) | reversed | foreach('{}...') | ' '.join | '{} boom'    &gt;&gt;&gt; countdown(5)    '4... 3... 2... 1... boom'.. _(advanced) formatting: http://docs.python.org/library/string.html#formatstringsFeeding the pipe&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;Sometimes it's useful to create a one-off pipe and immediately run some inputthrough it. And since this is somewhat awkward (and not very readable,especially when the pipe spans multiple lines):.. code-block:: python    result = (pipe | foo | bar | boo)(some_input)It can also be done using the ``&gt;`` operator:.. code-block:: python    result = some_input &gt; pipe | foo | bar | boo.. note::    Note that the above method of input won't work if the input object    defines `__gt__ &lt;https://docs.python.org/3/reference/datamodel.html#object.__gt__&gt;`_    for *any* object - including the pipe. This can be the case for example with    some objects from math libraries such as NumPy. If you experience strange    results try falling back to the standard way of passing input into a pipe.But wait, there is more-----------------------Checkout `the Maybe pipe &lt;https://0101.github.io/pipetools/doc/maybe&gt;`_, `partial application on steroids &lt;https://0101.github.io/pipetools/doc/xpartial&gt;`_or `automatic data structure creation &lt;https://0101.github.io/pipetools/doc/pipeutils#automatic-data-structure-creation&gt;`_in the `full documentation &lt;https://0101.github.io/pipetools/doc/#contents&gt;`_.</longdescription>
</pkgmetadata>