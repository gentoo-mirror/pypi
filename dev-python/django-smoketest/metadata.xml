<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>django-smoketest================[![Actions Status](https://github.com/ccnmtl/django-smoketest/workflows/build-and-test/badge.svg)](https://github.com/ccnmtl/django-smoketest/actions)[![Coverage Status](https://coveralls.io/repos/github/ccnmtl/django-smoketest/badge.svg?branch=master)](https://coveralls.io/github/ccnmtl/django-smoketest?branch=master)Motivation----------Smoke test framework for Django.Smoke tests are tests that are run on a production environment toquickly detect major systemic problems. Eg, after you run a deploy,you want to quickly check that everything is running properly so youcan roll back quickly instead if there are problems. Too often, thisjust means visiting the site and manually clicking around through afew links (at best).You probably already have unit tests verifying the correctness of lowlevel parts of your code, and integration and acceptance tests runningon a staging server or CI system. Maybe you've even got automaticconfiguration management ensuring that your staging server isconfigured as an exact replica of production. So logically, if yourcode passes all the tests on the staging server and the productionserver is configured the same, everything *must* work right inproduction. Right? Wouldn't it be wonderful if the world were sosimple? Of course we know that it's not. That's why we want smoketests to actually verify that at least the major components of thesystem are all basically functional and able to talk to each other andwe didn't do something stupid like writing code that depends on a newenvironment variable that hasn't been set to the correct value onproduction yet.You probably don't want to run your unit tests or integration testsin production with production settings in effect. Who knows what kindof insanity would result? Test data sprayed all through yourproduction database, deleting user data from the file system, the sunrising in the west and setting in the east?This is what smoke tests are for. Smoke tests should be *safe* to runin production. Verify that the application can connect to thedatabase, that whatever filesystem mounts are expected are in place,etc. bridging that last gap between existing test coverage and thewilderness of production. But all while stepping carefully around theproduction data.I also find myself frequently writing small views to support ad-hocmonitoring. Eg, if an application relies on an NFS mount for someinfrequent operation and that mount has a tendency to go stale, a cronjob that runs every few minutes (or via nagios or some othermonitoring application) and has the application try to read afile off the mount can help ensure that we are alerted to the stalemount before users encounter it.Getting Started---------------Install django-smoketest    $ pip install django-smoketestAdd `smoketest` to your `INSTALLED_APPS`.In each application of yours that you want to define smoke tests for,make a `smoke.py` file or a `smoke` directory with an`__init__.py` and one or more python files with your tests.In your `urls.py`, add something like:    ('smoketest/', include('smoketest.urls'))To your `urlpatterns`.In your `smoke.py` (or module), you put something like this:    from smoketest import SmokeTest    from myapp.models import FooModel            class DemoTest(SmokeTest):        def test_foomodel_reads(self):            &quot;&quot;&quot; just make sure we can read data from the db &quot;&quot;&quot;            cnt = FooModel.objects.all().count()            self.assertTrue(cnt &gt; 0)            def test_foomodel_writes(self):            &quot;&quot;&quot; make sure we can also write to the database            but do not leave any test detritus around. Smoketestsare automatically rolled back.            &quot;&quot;&quot;            f = FooModel.objects.create()        Now, if you make a `GET` to `http://yourapp/smoketest/`,django-smoketest will go through your code, finding any `smoke`modules, and run the tests you have defined (if you've used unittestor nose, you get the idea):    PASS    test classes: 1    tests run: 3    tests passed: 3    tests failed: 0    tests errored: 0    time: 1200.307861328msSo you can just check the result for `PASS` if you are calling it froma monitoring script or as part of an automated deploy.If tests fail or error out, you instead get something like:    FAIL    test classes: 1    tests run: 8    tests passed: 5    tests failed: 2    tests errored: 1    time: 3300.07861328ms    module1.smoke.DemoTest.test_foo failed    module1.smoke.DemoTest.test_bar failed    module1.smoke.DemoTest.test_baz erroredIf your HTTP client makes the request with `application/json` in the`Accept:` headers, responses will be JSON objects with the sameinformation in a more easily parseable form:    $ curl -H &quot;Accept: application/json&quot; http://yourapp/smoketest/    {&quot;status&quot;: &quot;FAIL&quot;, &quot;tests_failed&quot;: 2,     &quot;errored_tests&quot;: [&quot;module1.smoke.DemoTest.test_baz&quot;],     &quot;tests_run&quot;: 8, &quot;test_classes&quot;: 1, &quot;tests_passed&quot;: 5,     &quot;failed_tests&quot;: [&quot;module1.smoke.DemoTest.test_foo&quot;,     &quot;module1.smoke.DemoTest.test_foo&quot;], &quot;tests_errored&quot;: 1,     &quot;time&quot;: 1.6458759307861328}QUESTION: I'm thinking about keeping the output simple to parseautomatically, but maybe we ought to just stick with unittest'sexisting output format instead?API---The main class is `smoketests.SmokeTest`, which should be though of asequivalent to `unittest.TestCase`. It will do basically the usualstuff there, running `setUp` and `tearDown` methods, and supportingthe usual array of `assertEquals`, `assertRaises`, `assertTrue`methods.All smoketests are wrapped in a database transaction which is thenrolled back after running. This frees you up to do potentiallydestructive things and just let the DB clean up for you. The usualcaveats apply about making sure you are using a database that supportstransactions and that it can only roll back database operations, notother side effects.By default, django-smoketest will search through all apps mentioned inyour `INSTALLED_APPS`, looking for smoketests. If you define a`SMOKETEST_SKIP_APPS` setting with a list of apps, django-smoketestwill bypass any mentioned there.Asserts supported (so far):* assertEqual(a, b)* assertNotEqual(a, b)* assertTrue(t)* assertFalse(x)* assertIs(a, b)* assertIsNot(a, b)* assertIsNone(x)* assertIsNotNone(x)* assertIn(a, b)* assertNotIn(a, b)* assertIsInstance(a, b)* assertNotIsInstance(a, b)* assertRaises(exception, function)* assertLess(a, b)* assertLessEqual(a, b)* assertGreater(a, b)* assertGreaterEqual(a, b)* assertAlmostEqual(a, b)* assertNotAlmostEqual(a, b)All call accepts custom message as the last parameter (msg) just likeall assert calls in unittest libraries.Open Questions--------------What other unittest/nose flags, conventions, etc should we support?`--failfast`? output verbosity? ability to target or skip specifictests in certain cases? Automatic timeouts (a lot of smoke testsinvolve trying to connect to an external service and failing if ittakes more than a specified period of time)?Progress--------TODO:* I think it only handles `smoke.py` files or `smoke/__init__.py` and  won't yet find subclasses in submodules like `smoke/foo.py`.* setUpClass/tearDownClass* extended assert* methods (listed in `smoketest/__init__.py`)DONE:* walk `INSTALLED_APPLICATIONS` and find/run smoke tests* report numbers in simple text format* run setUp and tearDown methods* when tests fail/error, report which ones failed/errored* proper `module.class.method` info on test failures/errors report* support the basic expected set of assert* methods from unittest* JSON output* time test runs and include in output* run tests in a rolled back transaction* report additional info (exception/tracebacks) on errors (Kristijan Mitrovic &lt;kmitrovic&gt;)* support messages on asserts (Kristijan Mitrovic &lt;kmitrovic&gt;)* `SMOKETEST_SKIP_APPS`</longdescription>
</pkgmetadata>