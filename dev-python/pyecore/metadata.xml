<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>====================================================================PyEcore: A Pythonic Implementation of the Eclipse Modeling Framework====================================================================|pypi-version| |master-build| |coverage| |code-quality| |license|.. |master-build| image:: https://travis-ci.org/pyecore/pyecore.svg?branch=master    :target: https://travis-ci.org/pyecore/pyecore.. |develop-build| image:: https://travis-ci.org/pyecore/pyecore.svg?branch=develop    :target: https://travis-ci.org/pyecore/pyecore.. |pypi-version| image:: https://badge.fury.io/py/pyecore.svg    :target: https://badge.fury.io/py/pyecore.. |coverage| image:: https://coveralls.io/repos/github/pyecore/pyecore/badge.svg?branch=master    :target: https://coveralls.io/github/pyecore/pyecore?branch=master.. |license| image:: https://img.shields.io/badge/license-New%20BSD-blue.svg    :target: https://raw.githubusercontent.com/pyecore/pyecore/master/LICENSE.. |code-quality| image:: https://api.codacy.com/project/badge/Grade/ed038354821f43e7a4579c6a14185cdf    :target: https://www.codacy.com/app/aranega/pyecorePyEcore is a Model Driven Engineering (MDE) framework written for Python.Precisely, it is an implementation of `EMF/Ecore&lt;https://www.eclipse.org/modeling/emf/&gt;`_ for Python, and it tries to give anAPI which is compatible with the original EMF Java implementation.PyEcore allows you to handle models and metamodels (structured data model), andgives the key you need for building MDE-based tools and other applications basedon a structured data model. It supports out-of-the-box:* Data inheritance,* Two-ways relationship management (opposite references),* XMI (de)serialization,* JSON (de)serialization,* Notification system,* Reflexive API...Let see how to create on a very simple &quot;dynamic&quot; metamodel (in opposite tostatic ones, see the `documentation &lt;https://pyecore.readthedocs.io/en/latest/&gt;`_for more details):.. code-block:: python    &gt;&gt;&gt; from pyecore.ecore import EClass, EAttribute, EString, EObject    &gt;&gt;&gt; Graph = EClass('Graph')  # We create a 'Graph' concept    &gt;&gt;&gt; Node = EClass('Node')  # We create a 'Node' concept    &gt;&gt;&gt;    &gt;&gt;&gt; # We add a &quot;name&quot; attribute to the Graph concept    &gt;&gt;&gt; Graph.eStructuralFeatures.append(EAttribute('name', EString,                                                    default_value='new_name'))    &gt;&gt;&gt; # And one on the 'Node' concept    &gt;&gt;&gt; Node.eStructuralFeatures.append(EAttribute('name', EString))    &gt;&gt;&gt;    &gt;&gt;&gt; # We now introduce a containment relation between Graph and Node    &gt;&gt;&gt; contains_nodes = EReference('nodes', Node, upper=-1, containment=True)    &gt;&gt;&gt; Graph.eStructuralFeatures.append(contains_nodes)    &gt;&gt;&gt; # We add an opposite relation between Graph and Node    &gt;&gt;&gt; Node.eStructuralFeatures.append(EReference('owned_by', Graph, eOpposite=contains_nodes))With this code, we have defined two concepts: ``Graph`` and ``Node``. Both havea ``name``, and it exists a containment relationship between them. This relationis bi-directionnal, which means that each time a ``Node`` object is added to the``nodes`` relationship of a ``Graph``, the ``owned_by`` relation of the ``Node``is updated also (it also work in the other way).Let's create some instances of our freshly created metamodel:.. code-block:: python    &gt;&gt;&gt; # We create a Graph    &gt;&gt;&gt; g1 = Graph(name='Graph 1')    &gt;&gt;&gt; g1    &lt;pyecore.ecore.Graph at 0x7f0055554dd8&gt;    &gt;&gt;&gt;    &gt;&gt;&gt; # And two node instances    &gt;&gt;&gt; n1 = Node(name='Node 1')    &gt;&gt;&gt; n2 = Node(name='Node 2')    &gt;&gt;&gt; n1, n2    (&lt;pyecore.ecore.Node at 0x7f0055550588&gt;,     &lt;pyecore.ecore.Node at 0x7f00555502b0&gt;)    &gt;&gt;&gt;    &gt;&gt;&gt; # We add them to the Graph    &gt;&gt;&gt; g1.nodes.extend([n1, n2])    &gt;&gt;&gt; g1.nodes    EOrderedSet([&lt;pyecore.ecore.Node object at 0x7f0055550588&gt;,                 &lt;pyecore.ecore.Node object at 0x7f00555502b0&gt;])    &gt;&gt;&gt;    &gt;&gt;&gt; # bi-directional references are updated    &gt;&gt;&gt; n1.owned_by    &lt;pyecore.ecore.Graph at 0x7f0055554dd8&gt;This example gives a quick overview of some of the features you get for freewhen using PyEcore.*The project slowly grows and it still requires more love.*Installation============PyEcore is available on ``pypi``, you can simply install it using ``pip``:.. code-block:: bash    $ pip install pyecoreThe installation can also be performed manually (better in a virtualenv):.. code-block:: bash    $ python setup.py installDocumentation=============You can read the documentation at this address:https://pyecore.readthedocs.io/en/latest/Dependencies============The dependencies required by pyecore are:* ordered-set which is used for the ``ordered`` and ``unique`` collections expressed in the metamodel,* lxml which is used for the XMI parsing.These dependencies are directly installed if you choose to use ``pip``.Run the Tests=============Tests uses `py.test` and 'coverage'. Everything is driven by `Tox`, so in orderto run the tests simply run:.. code-block:: bash    $ toxLiberty Regarding the Java EMF Implementation=============================================* There is some meta-property that could be missing inside PyEcore. If you see one missing, please open a new ticket!* Proxies are not &quot;removed&quot; once resolved as in the the Java version, instead they acts as transparent proxies and redirect each calls to the 'proxied' object.* PyEcore is able to automatically load some model/metamodel dependencies on its own.State=====In the current state, the project implements:* the dynamic/static metamodel definitions,* reflexive API,* inheritance,* enumerations,* abstract metaclasses,* runtime typechecking,* attribute/reference creations,* collections (attribute/references with upper bound set to ``-1``),* reference eopposite,* containment reference,* introspection,* select/reject on collections,* Eclipse XMI import (partially, only single root models),* Eclipse XMI export (partially, only single root models),* simple notification/Event system,* EOperations support,* code generator for the static part,* EMF proxies (first version),* object deletion (first version),* EMF commands (first version),* EMF basic command stack,* EMF very basic Editing Domain,* JSON import (simple JSON format),* JSON export (simple JSON format),* introduce behavior @runtime,* resources auto-load for some cross-references,* derived collections,* multiple roots ressources,* ``xsi:schemaLocation`` support for XMI resources,* URI mapper like,* ``EGeneric`` support (first simple version),* URI converter likeThe things that are in the roadmap:* new implementation of ``EOrderedSet``, ``EList``, ``ESet`` and ``EBag``,* new implementation of ``EStringToStringMapEntry`` and ``EFeatureMapEntry``,* improve documentation,* copy/paste (?).Existing Projects=================There is not so much projects proposing to handle model and metamodel in Python.The only projects I found are:* PyEMOF (http://www.lifl.fr/~marvie/software/pyemof.html)* EMF4CPP (https://github.com/catedrasaes-umu/emf4cpp)* PyEMOFUC (http://www.istr.unican.es/pyemofuc/index_En.html)PyEMOF proposes an implementation of the OMG's EMOF in Python. The projecttargets Python2, only supports Class/Primitive Types (no Enumeration), XMIimport/export and does not provide a reflexion layer. The project didn't movesince 2005.EMF4CPP proposes a C++ implementation of EMF. This implementation alsointroduces Python scripts to call the generated C++ code from a Pythonenvironment. It seems that the EMF4CPP does not provide a reflexive layereither.PyEMOFUC proposes, like PyEMOF, a pure Python implementation of the OMG's EMOF.If we stick to a kind of EMF terminology, PyEMOFUC only supports dynamicmetamodels and seems to provide a reflexive layer. The project does not appearseems to have moved since a while.Contributors============Thanks for making PyEcore better!* Mike Pagel (`@moltob &lt;https://github.com/moltob&gt;`_), which is also the author  of `pyecoregen &lt;https://github.com/pyecore/pyecoregen&gt;`_ and `pymultigen &lt;https://github.com/moltob/pymultigen&gt;`_ (on which pyecoregen is based)* Terry Kingston (`@TerryKingston &lt;https://github.com/TerryKingston&gt;`_)* Afonso Pinto (`@afonsobspinto &lt;https://github.com/afonsobspinto&gt;`_)* Andy (`@CFAndy &lt;https://github.com/CFAndy&gt;`_)* annighoefer (`@annighoefer &lt;https://github.com/annighoefer&gt;`_)* Rodriguez Facundo (`@rodriguez-facundo &lt;https://github.com/rodriguez-facundo&gt;`_)* Filippo Ledda (`@filippometacell &lt;https://github.com/filippometacell&gt;`_)* Ewoud Werkman (`@ewoudwerkman &lt;https://github.com/ewoudwerkman&gt;`_)* Eugene (`@4ekin &lt;https://github.com/4ekin&gt;`_)* Alexandre Acebedo (`@aacebedo &lt;https://github.com/aacebedo&gt;`_)* Jinhu (`@jinhu &lt;https://github.com/jinhu&gt;`_)* Pablo Campillo (`@pablo-campillo &lt;https://github.com/pablo-campillo&gt;`_)* Jose Antonio Moral (`@jamoralp &lt;https://github.com/jamoralp&gt;`_)* Marco Heinemann (`@ubmarco &lt;https://github.com/ubmarco&gt;`_)Additional Resources====================* `This article &lt;http://modeling-languages.com/pyecore-python-eclipse-modeling-framework&gt;`_  on the blog of the Professor Jordi Cabot gives more information and  implementations details about PyEcore.</longdescription>
</pkgmetadata>