<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># python-simple-http-server[![PyPI version](https://badge.fury.io/py/simple-http-server.png)](https://badge.fury.io/py/simple-http-server)## DiscriptionThis is a simple http server, use MVC like design.## Support Python VersionPython 3.7+## Why choose* Lightway.* Functional programing.* Filter chain support.* Session support, and can support distributed session by [this extention](https://github.com/keijack/python-simple-http-server-redis-session).* Spring MVC like request mapping.* SSL support.* Websocket support* Easy to use.* Free style controller writing.* Easily integraded with WSGI servers. * Easily integraded with ASGI servers. Websocket will be supported when ASGI server enable websocket functions.* Coroutine mode support.## DependenciesThere are no other dependencies needed to run this project. However, if you want to run the unitests in the `tests` folder, you need to install `websocket` via pip:```shellpython3 -m pip install websocket-client```## How to use### Install```shellpython3 -m pip install simple_http_server```### Minimum code / component requirement setupMinimum code to get things started should have at least one controller function,&lt;br /&gt; using the route and server modules from simple_http_server```pythonfrom simple_http_server import route, server    @route(&quot;/&quot;)def index():    return {&quot;hello&quot;: &quot;world&quot;}   server.start(port=9090)```### Write Controllers```pythonfrom simple_http_server import request_mapfrom simple_http_server import Responsefrom simple_http_server import MultipartFilefrom simple_http_server import Parameterfrom simple_http_server import Parametersfrom simple_http_server import Headerfrom simple_http_server import JSONBodyfrom simple_http_server import HttpErrorfrom simple_http_server import StaticFilefrom simple_http_server import Headersfrom simple_http_server import Cookiesfrom simple_http_server import Cookiefrom simple_http_server import Redirectfrom simple_http_server import ModelDict# request_map has an alias name `route`, you can select the one you familiar with.@request_map(&quot;/index&quot;)def my_ctrl():    return {&quot;code&quot;: 0, &quot;message&quot;: &quot;success&quot;}  # You can return a dictionary, a string or a `simple_http_server.simple_http_server.Response` object.@route(&quot;/say_hello&quot;, method=[&quot;GET&quot;, &quot;POST&quot;])def my_ctrl2(name, name2=Parameter(&quot;name&quot;, default=&quot;KEIJACK&quot;), model=ModelDict()):    &quot;&quot;&quot;name and name2 is the same&quot;&quot;&quot;    name == name2 # True    name == model[&quot;name&quot;] # True    return &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;hello, %s, %s&lt;/body&gt;&lt;/html&gt;&quot; % (name, name2)@request_map(&quot;/error&quot;)def my_ctrl3():    return Response(status_code=500)@request_map(&quot;/exception&quot;)def exception_ctrl():    raise HttpError(400, &quot;Exception&quot;)@request_map(&quot;/upload&quot;, method=&quot;GET&quot;)def show_upload():    root = os.path.dirname(os.path.abspath(__file__))    return StaticFile(&quot;%s/my_dev/my_test_index.html&quot; % root, &quot;text/html; charset=utf-8&quot;)@request_map(&quot;/upload&quot;, method=&quot;POST&quot;)def my_upload(img=MultipartFile(&quot;img&quot;)):    root = os.path.dirname(os.path.abspath(__file__))    img.save_to_file(root + &quot;/my_dev/imgs/&quot; + img.filename)    return &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;upload ok!&lt;/body&gt;&lt;/html&gt;&quot;@request_map(&quot;/post_txt&quot;, method=&quot;POST&quot;)def normal_form_post(txt):    return &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;hi, %s&lt;/body&gt;&lt;/html&gt;&quot; % txt@request_map(&quot;/tuple&quot;)def tuple_results():    # The order here is not important, we consider the first `int` value as status code,    # All `Headers` object will be sent to the response    # And the first valid object whose type in (str, unicode, dict, StaticFile, bytes) will    # be considered as the body    return 200, Headers({&quot;my-header&quot;: &quot;headers&quot;}), {&quot;success&quot;: True}&quot;&quot;&quot;&quot; Cookie_sc will not be written to response. It's just some kind of default&quot; value&quot;&quot;&quot;@request_map(&quot;tuple_cookie&quot;)def tuple_with_cookies(all_cookies=Cookies(), cookie_sc=Cookie(&quot;sc&quot;)):    print(&quot;=====&gt; cookies &quot;)    print(all_cookies)    print(&quot;=====&gt; cookie sc &quot;)    print(cookie_sc)    print(&quot;======&lt;&quot;)    import datetime    expires = datetime.datetime(2018, 12, 31)    cks = Cookies()    # cks = cookies.SimpleCookie() # you could also use the build-in cookie objects    cks[&quot;ck1&quot;] = &quot;keijack&quot;request    cks[&quot;ck1&quot;][&quot;path&quot;] = &quot;/&quot;    cks[&quot;ck1&quot;][&quot;expires&quot;] = expires.strftime(Cookies.EXPIRE_DATE_FORMAT)    # You can ignore status code, headers, cookies even body in this tuple.    return Header({&quot;xx&quot;: &quot;yyy&quot;}), cks, &quot;&lt;html&gt;&lt;body&gt;OK&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;&quot;&quot; If you visit /a/b/xyz/x，this controller function will be called, and `path_val` will be `xyz`&quot;&quot;&quot;@request_map(&quot;/a/b/{path_val}/x&quot;)def my_path_val_ctr(path_val=PathValue()):    return f&quot;&lt;html&gt;&lt;body&gt;{path_val}&lt;/body&gt;&lt;/html&gt;&quot;@request_map(&quot;/star/*&quot;) # /star/c will find this controller, but /star/c/d not.@request_map(&quot;*/star&quot;) # /c/star will find this controller, but /c/d/star not.def star_path(path_val=PathValue()):    return f&quot;&lt;html&gt;&lt;body&gt;{path_val}&lt;/body&gt;&lt;/html&gt;&quot;@request_map(&quot;/star/**&quot;) # Both /star/c and /star/c/d will find this controller.@request_map(&quot;**/star&quot;) # Both /c/star and /c/d/stars will find this controller.def star_path(path_val=PathValue()):    return f&quot;&lt;html&gt;&lt;body&gt;{path_val}&lt;/body&gt;&lt;/html&gt;&quot;@request_map(&quot;/redirect&quot;)def redirect():    return Redirect(&quot;/index&quot;)@request_map(&quot;session&quot;)def test_session(session=Session(), invalid=False):    ins = session.get_attribute(&quot;in-session&quot;)    if not ins:        session.set_attribute(&quot;in-session&quot;, &quot;Hello, Session!&quot;)    __logger.info(&quot;session id: %s&quot; % session.id)    if invalid:        __logger.info(&quot;session[%s] is being invalidated. &quot; % session.id)        session.invalidate()    return &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;&quot; % str(ins)# use coroutine, these controller functions will work both in a coroutine mode or threading mode.async def say(sth: str = &quot;&quot;):    _logger.info(f&quot;Say: {sth}&quot;)    return f&quot;Success! {sth}&quot;@request_map(&quot;/中文/coroutine&quot;)async def coroutine_ctrl(hey: str = &quot;Hey!&quot;):    return await say(hey)@route(&quot;/res/write/bytes&quot;)def res_writer(response: Response):    response.status_code = 200    response.add_header(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;)    response.write_bytes(b'abcd')    response.write_bytes(bytearray(b'efg'))    response.close()```Beside using the default values, you can also use variable annotations to specify your controller function's variables.```python@request_map(&quot;/say_hello/to/{name}&quot;, method=[&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;])def your_ctroller_function(        user_name: str, # req.parameter[&quot;user_name&quot;]，400 error will raise when there's no such parameter in the query string.        password: str, # req.parameter[&quot;password&quot;]，400 error will raise when there's no such parameter in the query string.        skills: list, # req.parameters[&quot;skills&quot;]，400 error will raise when there's no such parameter in the query string.        all_headers: Headers, # req.headers        user_token: Header, # req.headers[&quot;user_token&quot;]，400 error will raise when there's no such parameter in the quest headers.        all_cookies: Cookies, # req.cookies, return all cookies        user_info: Cookie, # req.cookies[&quot;user_info&quot;]，400 error will raise when there's no such parameter in the cookies.        name: PathValue, # req.path_values[&quot;name&quot;]，get the {name} value from your path.        session: Session # req.getSession(True)，get the session, if there is no sessions, create one.    ):    return &quot;&lt;html&gt;&lt;body&gt;Hello, World!&lt;/body&gt;&lt;/html&gt;&quot;# you can use `params` to narrow the controller mapping, the following examples shows only the `params` mapping, ignoring the # `headers` examples for the usage is almost the same as the `params`. @request(&quot;/exact_params&quot;, method=&quot;GET&quot;, params=&quot;a=b&quot;)def exact_params(a: str):    print(f&quot;{a}&quot;) # b    return {&quot;result&quot;: &quot;ok&quot;}@request(&quot;/exact_params&quot;, method=&quot;GET&quot;, params=&quot;a!=b&quot;)def exact_not_params(a: str):    print(f&quot;{a}&quot;) # b    return {&quot;result&quot;: &quot;ok&quot;}@request(&quot;/exact_params&quot;, method=&quot;GET&quot;, params=&quot;a^=b&quot;)def exact_startwith_params(a: str):    print(f&quot;{a}&quot;) # b    return {&quot;result&quot;: &quot;ok&quot;}@request(&quot;/exact_params&quot;, method=&quot;GET&quot;, params=&quot;!a&quot;)def no_params():    return {&quot;result&quot;: &quot;ok&quot;}@request(&quot;/exact_params&quot;, method=&quot;GET&quot;, params=&quot;a&quot;)def must_has_params():    return {&quot;result&quot;: &quot;ok&quot;}# If multiple expressions are set, all expressions must be matched to enter this controller function.@request(&quot;/exact_params&quot;, method=&quot;GET&quot;, params=[&quot;a=b&quot;, &quot;c!=d&quot;])def multipul_params():    return {&quot;result&quot;: &quot;ok&quot;}# You can set `match_all_params_expressions` to False to make that the url can enter this controller function even only one expression is matched.@request(&quot;/exact_params&quot;, method=&quot;GET&quot;, params=[&quot;a=b&quot;, &quot;c!=d&quot;], match_all_params_expressions=False)def multipul_params():    return {&quot;result&quot;: &quot;ok&quot;}```We recommend using functional programing to write controller functions. but if you realy want to use Object, you can use `@request_map` in a class method. For doing this, every time a new request comes, a new MyController object will be created.```pythonclass MyController:    def __init__(self) -&gt; None:        self._name = &quot;ctr object&quot;    @request_map(&quot;/obj/say_hello&quot;, method=&quot;GET&quot;)    def my_ctrl_mth(self, name: str):        return {&quot;message&quot;: f&quot;hello, {name}, {self._name} says. &quot;}```If you want a singleton, you can add a `@controller` decorator to the class.```python@controllerclass MyController:    def __init__(self) -&gt; None:        self._name = &quot;ctr object&quot;    @request_map(&quot;/obj/say_hello&quot;, method=&quot;GET&quot;)    def my_ctrl_mth(self, name: str):        return {&quot;message&quot;: f&quot;hello, {name}, {self._name} says. &quot;}```You can also add the `@request_map` to your class, this will be as the part of the url.```python@controller@request_map(&quot;/obj&quot;, method=&quot;GET&quot;)class MyController:    def __init__(self) -&gt; None:        self._name = &quot;ctr object&quot;    @request_map    def my_ctrl_default_mth(self, name: str):        return {&quot;message&quot;: f&quot;hello, {name}, {self._name} says. &quot;}    @request_map(&quot;/say_hello&quot;, method=(&quot;GET&quot;, &quot;POST&quot;))    def my_ctrl_mth(self, name: str):        return {&quot;message&quot;: f&quot;hello, {name}, {self._name} says. &quot;}```You can specify the `init` variables in `@controller` decorator. ```python@controller(args=[&quot;ctr_name&quot;], kwargs={&quot;desc&quot;: &quot;this is a key word argument&quot;})@request_map(&quot;/obj&quot;, method=&quot;GET&quot;)class MyController:    def __init__(self, name, desc=&quot;&quot;) -&gt; None:        self._name = f&quot;ctr[{name}] - {desc}&quot;    @request_map    def my_ctrl_default_mth(self, name: str):        return {&quot;message&quot;: f&quot;hello, {name}, {self._name} says. &quot;}    @request_map(&quot;/say_hello&quot;, method=(&quot;GET&quot;, &quot;POST&quot;))    def my_ctrl_mth(self, name: str):        return {&quot;message&quot;: f&quot;hello, {name}, {self._name} says. &quot;}```From `0.7.0`, `@request_map` support regular expression mapping. ```python# url `/reg/abcef/aref/xxx` can map the flowing controller:@route(regexp=&quot;^(reg/(.+))$&quot;, method=&quot;GET&quot;)def my_reg_ctr(reg_groups: RegGroups, reg_group: RegGroup = RegGroup(1)):    print(reg_groups) # will output (&quot;reg/abcef/aref/xxx&quot;, &quot;abcef/aref/xxx&quot;)    print(reg_group) # will output &quot;abcef/aref/xxx&quot;    return f&quot;{self._name}, {reg_group.group},{reg_group}&quot;```Regular expression mapping a class:```python@controller(args=[&quot;ctr_name&quot;], kwargs={&quot;desc&quot;: &quot;this is a key word argument&quot;})@request_map(&quot;/obj&quot;, method=&quot;GET&quot;) # regexp do not work here, method will still availableclass MyController:    def __init__(self, name, desc=&quot;&quot;) -&gt; None:        self._name = f&quot;ctr[{name}] - {desc}&quot;    @request_map    def my_ctrl_default_mth(self, name: str):        return {&quot;message&quot;: f&quot;hello, {name}, {self._name} says. &quot;}    @route(regexp=&quot;^(reg/(.+))$&quot;) # prefix `/obj`  from class decorator will be ignored, but `method`(GET in this example) from class decorator will still work.    def my_ctrl_mth(self, name: str):        return {&quot;message&quot;: f&quot;hello, {name}, {self._name} says. &quot;}```### SessionDefaultly, the session is stored in local, you can extend `SessionFactory` and `Session` classes to implement your own session storage requirement (like store all data in redis or memcache)```pythonfrom simple_http_server import Session, SessionFactory, set_session_factoryclass MySessionImpl(Session):    def __init__(self):        super().__init__()        # your own implementation    @property    def id(self) -&gt; str:        # your own implementation    @property    def creation_time(self) -&gt; float:        # your own implementation    @property    def last_accessed_time(self) -&gt; float:        # your own implementation    @property    def is_new(self) -&gt; bool:        # your own implementation    @property    def attribute_names(self) -&gt; Tuple:        # your own implementation    def get_attribute(self, name: str) -&gt; Any:        # your own implementation    def set_attribute(self, name: str, value: Any) -&gt; None:        # your own implementation    def invalidate(self) -&gt; None:        # your own implementationclass MySessionFacImpl(SessionFactory):    def __init__(self):        super().__init__()        # your own implementation        def get_session(self, session_id: str, create: bool = False) -&gt; Session:        # your own implementation        return MySessionImpl()set_session_factory(MySessionFacImpl())```There is an offical Redis implementation here: https://github.com/keijack/python-simple-http-server-redis-session.git### WebsocketTo handle a websocket session, you should handle multiple events, so it's more reasonable to use a class rather than functions to do it. In this framework, you should use `@websocket_handler` to decorate the class you want to handle websocket session. Specific event listener methods should be defined in a fixed way. However, the easiest way to do it is to inherit `simple_http_server.WebsocketHandler` class, and choose the event you want to implement. But this inheritance is not compulsory.You can configure `endpoit` or `regexp` in `@websocket_handler` to setup which url the class should handle. Alongside, there is a `singleton` field, which is set to `True` by default. Which means that all connections are handle by ONE object of this class. If this field is set to `False`, objects will be created when every `WebsocketSession` try to connect.```pythonfrom simple_http_server import WebsocketHandler, WebsocketRequest,WebsocketSession, websocket_handler@websocket_handler(endpoint=&quot;/ws/{path_val}&quot;)class WSHandler(WebsocketHandler):    def on_handshake(self, request: WebsocketRequest):        &quot;&quot;&quot;        &quot;        &quot; You can get path/headers/path_values/cookies/query_string/query_parameters from request.        &quot;         &quot; You should return a tuple means (http_status_code, headers)        &quot;        &quot; If status code in (0, None, 101), the websocket will be connected, or will return the status you return.         &quot;        &quot; All headers will be send to client        &quot;        &quot;&quot;&quot;        _logger.info(f&quot;&gt;&gt;{session.id}&lt;&lt; open! {request.path_values}&quot;)        return 0, {}    def on_open(self, session: WebsocketSession):        &quot;&quot;&quot;        &quot;         &quot; Will be called when the connection opened.        &quot;        &quot;&quot;&quot;        _logger.info(f&quot;&gt;&gt;{session.id}&lt;&lt; open! {session.request.path_values}&quot;)    def on_close(self, session: WebsocketSession, reason: str):        &quot;&quot;&quot;        &quot;        &quot; Will be called when the connection closed.        &quot;        &quot;&quot;&quot;        _logger.info(f&quot;&gt;&gt;{session.id}&lt;&lt; close::{reason}&quot;)    def on_ping_message(self, session: WebsocketSession = None, message: bytes = b''):        &quot;&quot;&quot;        &quot;        &quot; Will be called when receive a ping message. Will send all the message bytes back to client by default.        &quot;        &quot;&quot;&quot;        session.send_pone(message)    def on_pong_message(self, session: WebsocketSession = None, message: bytes = &quot;&quot;):        &quot;&quot;&quot;        &quot;        &quot; Will be called when receive a pong message.        &quot;        &quot;&quot;&quot;        pass    def on_text_message(self, session: WebsocketSession, message: str):        &quot;&quot;&quot;        &quot;        &quot; Will be called when receive a text message.        &quot;        &quot;&quot;&quot;        _logger.info(f&quot;&gt;&gt;{session.id}&lt;&lt; on text message: {message}&quot;)        session.send(message)    def on_binary_message(self, session: WebsocketSession = None, message: bytes = b''):        &quot;&quot;&quot;        &quot;        &quot; Will be called when receive a binary message if you have not consumed all the bytes in `on_binary_frame`         &quot; method.        &quot;        &quot;&quot;&quot;        pass    def on_binary_frame(self, session: WebsocketSession = None, fin: bool = False, frame_payload: bytes = b''):        &quot;&quot;&quot;        &quot;        &quot; If you are sending a continuation binary message to server, this will be called every time a frame is         &quot; received, you can consumed all the bytes in this method, e.g. save all bytes to a file. By doing so,         &quot; you should not return and value in this method.         &quot;        &quot; If you does not implement this method or return a True in this method, all the bytes will be caced in        &quot; memory and be sent to your `on_binary_message` method.        &quot;        &quot;&quot;&quot;        return True@websocket_handler(regexp=&quot;^/ws-reg/([a-zA-Z0-9]+)$&quot;, singleton=False)class WSHandler(WebsocketHandler):    &quot;&quot;&quot;    &quot; You code here    &quot;&quot;&quot;```### Error pagesYou can use `@error_message` to specify your own error page. See:```pythonfrom simple_http_server import error_message# map specified codes@error_message(&quot;403&quot;, &quot;404&quot;)def my_40x_page(message: str, explain=&quot;&quot;):    return f&quot;&quot;&quot;    &lt;html&gt;        &lt;head&gt;            &lt;title&gt;发生错误！&lt;/title&gt;        &lt;head&gt;        &lt;body&gt;            message: {message}, explain: {explain}        &lt;/body&gt;    &lt;/html&gt;    &quot;&quot;&quot;# map specified code rangs@error_message(&quot;40x&quot;, &quot;50x&quot;)def my_error_message(code, message, explain=&quot;&quot;):    return f&quot;{code}-{message}-{explain}&quot;# map all error page@error_messagedef my_error_message(code, message, explain=&quot;&quot;):    return f&quot;{code}-{message}-{explain}&quot;```### Write filtersThis server support filters, you can use `request_filter` decorator to define your filters.```pythonfrom simple_http_server import request_filter@request_filter(&quot;/tuple/**&quot;) # use wildcard@request_filter(regexp=&quot;^/tuple&quot;) # use regular expressiondef filter_tuple(ctx):    print(&quot;---------- through filter ---------------&quot;)    # add a header to request header    ctx.request.headers[&quot;filter-set&quot;] = &quot;through filter&quot;    if &quot;user_name&quot; not in ctx.request.parameter:        ctx.response.send_redirect(&quot;/index&quot;)    elif &quot;pass&quot; not in ctx.request.parameter:        ctx.response.send_error(400, &quot;pass should be passed&quot;)        # you can also raise a HttpError        # raise HttpError(400, &quot;pass should be passed&quot;)    else:        # you should always use do_chain method to go to the next        ctx.do_chain()```### Start your server```python# If you place the controllers method in the other files, you should import them here.import simple_http_server.server as serverimport my_test_ctrldef main(*args):    # The following method can import several controller files once.    server.scan(&quot;my_ctr_pkg&quot;, r&quot;.*controller.*&quot;)    server.start()if __name__ == &quot;__main__&quot;:    main()```If you want to specify the host and port:```python    server.start(host=&quot;&quot;, port=8080)```If you want to specify the resources path: ```python     server.start(resources={&quot;/path_prefix/*&quot;, &quot;/absolute/dir/root/path&quot;, # Match the files in the given folder with a special path prefix.                            &quot;/path_prefix/**&quot;, &quot;/absolute/dir/root/path&quot;, # Match all the files in the given folder and its sub-folders with a special path prefix.                            &quot;*.suffix&quot;, &quot;/absolute/dir/root/path&quot;, # Match the specific files in the given folder.                            &quot;**.suffix&quot;, &quot;/absolute/dir/root/path&quot;, # Match the specific files in the given folder and its sub-folders.                            })```If you want to use ssl:```python    server.start(host=&quot;&quot;,                  port=8443,                 ssl=True,                 ssl_protocol=ssl.PROTOCOL_TLS_SERVER, # Optional, default is ssl.PROTOCOL_TLS_SERVER, which will auto detect the highted protocol version that both server and client support.                  ssl_check_hostname=False, #Optional, if set to True, if the hostname is not match the certificat, it cannot establish the connection, default is False.                 keyfile=&quot;/path/to/your/keyfile.key&quot;,                 certfile=&quot;/path/to/your/certfile.cert&quot;,                 keypass=&quot;&quot;, # Optional, your private key's password                 )```### CoroutineFrom `0.12.0`, you can use coroutine tasks than threads to handle requests, you can set the `prefer_coroutine` parameter in start method to enable the coroutine mode. ```python    server.start(prefer_coroutine=True)```From `0.13.0`, coroutine mode uses the coroutine server, that means all requests will use the async I/O rather than block I/O. So you can now use `async def` to define all your controllers including the Websocket event callback methods.If you call the server starting in a async function, you can all its async version, by doing this, there sever will use the same event loop with your other async functions. ```python    await server.start_async(prefer_coroutine=True)```## LoggerThe default logger is try to write logs to the screen, you can specify the logger handler to write it to a file.```pythonimport simple_http_server.logger as loggerimport logging_formatter = logging.Formatter(fmt='[%(asctime)s]-[%(name)s]-%(levelname)-4s: %(message)s')_handler = logging.TimedRotatingFileHandler(&quot;/var/log/simple_http_server.log&quot;, when=&quot;midnight&quot;, backupCount=7)_handler.setFormatter(_formatter)_handler.setLevel(&quot;INFO&quot;)logger.set_handler(_handler)```If you want to add a handler rather than replace the inner one, you can use:```pythonlogger.add_handler(_handler)```If you want to change the logger level:```pythonlogger.set_level(&quot;DEBUG&quot;)```You can get a stand alone logger which is independent from the framework one via a new class `logger.LoggerFactory`. ```pythonimport simple_http_server.logger as loggerlog = logger.get_logger(&quot;my_service&quot;, &quot;my_log_fac&quot;)# If you want to set a different log level to this logger factory: log_fac = logger.get_logger_factory(&quot;my_log_fac&quot;)log_fac.log_level = &quot;DEBUG&quot;log = log_fac.get_logger(&quot;my_service&quot;)log.info(...)```## WSGI SupportYou can use this module in WSGI apps. ```pythonimport simple_http_server.server as serverimport osfrom simple_http_server import request_map# scan all your controllersserver.scan(&quot;tests/ctrls&quot;, r'.*controllers.*')# or define a new controller function here@request_map(&quot;/hello_wsgi&quot;)def my_controller(name: str):    return 200, &quot;Hello, WSGI!&quot;# resources is optionalwsgi_proxy = server.init_wsgi_proxy(resources={&quot;/public/*&quot;: f&quot;/you/static/files/path&quot;})# wsgi app entrance. def simple_app(environ, start_response):    return wsgi_proxy.app_proxy(environ, start_response)# If your entrance is async:async def simple_app(envion, start_response):    return await wsgi_proxy.async_app_proxy(environ, start_response)```## ASGI SupportYou can use this module in ASGI server, take `uvicorn` fro example:```pythonimport asyncioimport uvicornimport simple_http_server.server as serverfrom simple_http_server.server import ASGIProxyasgi_proxy: ASGIProxy = Noneinit_asgi_proxy_lock: asyncio.Lock = asyncio.Lock()async def init_asgi_proxy():    global asgi_proxy    if asgi_proxy == None:        async with init_asgi_proxy_lock:            if asgi_proxy == None:                server.scan(base_dir=&quot;tests/ctrls&quot;, regx=r'.*controllers.*')                asgi_proxy = server.init_asgi_proxy(resources={&quot;/public/*&quot;: &quot;tests/static&quot;})async def app(scope, receive, send):    await init_asgi_proxy()    await asgi_proxy.app_proxy(scope, receive, send)def main():    config = uvicorn.Config(&quot;main:app&quot;, host=&quot;0.0.0.0&quot;, port=9090, log_level=&quot;info&quot;)    asgi_server = uvicorn.Server(config)    asgi_server.run()if __name__ == &quot;__main__&quot;:    main()```## ThanksThe code that process websocket comes from the following project: https://github.com/Pithikos/python-websocket-server</longdescription>
</pkgmetadata>