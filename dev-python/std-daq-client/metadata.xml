<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Standard DAQ clientPython client and CLI tools for interacting with Standard DAQ.Install with Pip:```bashpip install std_daq_client```The only dependency is the **requests** library.## Getting started### Python client```pythonfrom std_daq_client import StdDaqClientrest_server_url = 'http://localhost:5000'client = StdDaqClient(url_base=rest_server_url)client.get_status()client.get_config()client.set_config(daq_config={'bit_depth': 16, 'writer_user_id': 0})client.get_logs(n_last_logs=5)client.get_stats()client.get_deployment_status()client.start_writer_async({'output_file': '/tmp/output.h5', 'n_images': 10})client.start_writer_sync({'output_file': '/tmp/output.h5', 'n_images': 10})client.stop_writer()```### CLI interface- std_cli_get_status- std_cli_get_config- std_cli_set_config [config_file]- std_cli_get_logs- std_cli_get_stats- std_cli_get_deploy_status- std_cli_write_async [output_file] [n_images]- std_cli_write_sync [output_file] [n_images]- std_cli_write_stopAll CLI tools accept the **--url\_base** parameter used to point the client to the correct API base url. Contact your DAQ integrator to find out this address.### Redis interfaceSystem state is available also on Redis in the form of Redis Streams. Each Redis instance represents a DAQ instance. Contact your DAQ integrator to find out the host and port on which Redis is running - generally this should be the same network interface as the REST api, on the default Redis port.Currently available streams:- daq:status (DAQ status updates with 1Hz, **DAQ status** json)- daq:config (DAQ config pushed on change, **DAQ config** json)- daq:log (DAQ logs about created files, **DAQ logs** json)- daq:stat (DAQ performance statistics, **DAQ stats** json)The JSON object encoded in UTF-8 is stored in the **b\'json\'** field.Example on how to access the status stream:```pythonimport jsonfrom redis.client import Redisredis = Redis()# Start listening for new statuses.last_status_id = '$'while True:    # Block until new status is available.    response = redis.xread({&quot;daq:writer_status&quot;: last_status_id}, block=0)    # Decode status from 'json' field.    last_status_id, status = response[0][0], json.loads(response[0][1][b'json'])        print(status)```## Interface objectsEvery call returns a dictionary with some values inside. In case of state or logic problems with your request, an instance of **StdDaqAdminException** will be thrown. For everything else an instance of **RuntimeError** will be raised.Below we will describe the different returned objects and describe their fields.### DAQ statusRepresents the current state of the DAQ with the current state of the last acquisition (either completedor still running).This object is returned by:- get_status- start_writer_async- start_writer_sync- stop_writer- Redis stream daq:status ```json{  &quot;acquisition&quot;: {                        // Stats about the currently running or last finished acquisition    &quot;info&quot;: {                             //   User request that generated this acquisition      &quot;n_images&quot;: 100,                    //     Number of images      &quot;output_file&quot;: &quot;/tmp/test.h5&quot;,      //     Output file      &quot;run_id&quot;: 1684930336122153839       //     Run_id (request timestamp by default, generated by the API)    },    &quot;message&quot;: &quot;Completed.&quot;,              // User displayable message from the writer.    &quot;state&quot;: &quot;FINISHED&quot;,                  // State of the acquisition.    &quot;stats&quot;: {                                  &quot;n_write_completed&quot;: 100,           //   Number of completed writes      &quot;n_write_requested&quot;: 100,           //   Number of requested writers from the driver      &quot;start_time&quot;: 1684930336.1252322,   //   Start time of request as seen by writer driver      &quot;stop_time&quot;: 1684930345.2723851     //   Stop time of request as seen by writer driver    }  },  &quot;state&quot;: &quot;READY&quot;                        // State of the writer: READY (to write), WRITING}```#### output_file The path will always be an absolute path or null (when no acquisition happened on the system yet).#### state| State            | Description                                                                    ||------------------|--------------------------------------------------------------------------------|| READY            | DAQ is ready to start writing.                                                 || WRITING          | DAQ is writing at the moment. Wait for it to finish or call Stop to interrupt. || UNKNOWN          | The DAQ is in an unknown state (usually after reboot). Call Stop to reset.     |When the state of the writer is **READY**, the writer can receive the next write request. Otherwise, the request will be rejected. A **Stop** request can always be sent and will reset the writer status to READY (use the Stop request when the writer state is UNKNOWN to try to reset it).#### acquisition/state| State              | Description                                                 ||--------------------|-------------------------------------------------------------|| FINISHED           | The acquisition has finished successfully.                  || FAILED             | The acquisition has failed.                                 || WRITING            | Currently receiving and writing images.                     || WAITING_IMAGES     | Writer is ready and waiting for images.                     || ACQUIRING_IMAGES   | DAQ is receiving images but writer is not writing them yet. || FLUSHING_IMAGES    | All needed images acquired, writer is flushing the buffer.  |In case of a **FAILED** acquisition, the acquisition/message will be set to the error that caused it to fail.#### acquisition/message| Message         | Description                                                        ||-----------------|--------------------------------------------------------------------|| Completed.      | The acquisition has written all the images.                        || Interrupted.    | The acquisition was interrupted before it acquired all the images. || ERROR:...       | An error happened during the acquisition.                          |In case of ERROR, the message will reflect what caused the acquisition to fail.#### acquisition/stats/start_time, acquisition/stats/stop_timeAll timestamps are Unix timestamps generated on the DAQ machineand are not really correlated with external sources (clock skew can be up to 100s of milliseconds). In particular casesany of the timestamp can be null (when no acquisition happened on the system yet).### DAQ configRepresents the DAQ configuration that is loaded by all services. This configuration describes the data source and the way the data source is processed by stream processors.This object is returned by:- get_config- set_config- Redis stream daq:config```json{  &quot;bit_depth&quot;: 16,                   // Bit depth of the image. Supported values are dependent on the detector.  &quot;detector_name&quot;: &quot;EG9M&quot;,           // Name of the detector. Must be unique, used as internal DAQ identifier.  &quot;detector_type&quot;: &quot;eiger&quot;,          // Type of detector. Currently supported: eiger, jungfrau, gigafrost, bsread  &quot;image_pixel_height&quot;: 3264,        // Assembled image height in pixels, including gap pixels.  &quot;image_pixel_width&quot;: 3106,         // Assembled image width in pixels, including gap pixels.  &quot;n_modules&quot;: 2,                    // Number of modules to assemble.  &quot;start_udp_port&quot;: 50000,           // Start UDP port where the detector is streaming modules.  &quot;writer_user_id&quot;: 12345,           // User_id under which the writer will create and write files.  &quot;module_positions&quot;: {              // Dictionary with mapping between module number -&gt; image position.    &quot;0&quot;: [0, 3263, 513, 3008 ],      //   Format: [start_x, start_y, end_x, end_y]    &quot;1&quot;: [516, 3263, 1029, 3008 ]  }}```#### writer_user_idMust be an integer representing the user_id. For e-accounts, it's simply the number after the 'e'. For example e12345 has a user_id of 12345. For other users you can find out their user_id by running:```bashid -u [user_name]```#### detector_typePossible values: eiger, gigafrost, jungfrau, bsreadThis is not something you usually change without hardware changes on the beamline.### DAQ statisticsCurrent data flow statistics of the DAQ.This object is returned by:- get_stats- Redis stream daq:stat```json{  &quot;detector&quot;: {                 // Detector statistics    &quot;bytes_per_second&quot;: 0.0,    //   Throughput    &quot;images_per_second&quot;: 0.0    //   Frequency  },  &quot;writer&quot;: {                   // Writer statistics    &quot;bytes_per_second&quot;: 0.0,    //   Throughput    &quot;images_per_second&quot;: 0.0    //   Frequency  }}```The statistics is refreshed and aggregated with 1 Hz.### DAQ logsLog of all acquisitions that produced a file. It is a list of acquisition objects in reverse chronological order.This object is returned by:- get_logs- Redis stream daq:log```json[  {                                           &quot;info&quot;: {                             //   User request that generated this acquisition      &quot;n_images&quot;: 100,                    //     Number of images      &quot;output_file&quot;: &quot;/tmp/test.h5&quot;,      //     Output file      &quot;run_id&quot;: 1684930336122153839       //     Run_id (request timestamp by default, generated by the API)    },    &quot;message&quot;: &quot;Completed.&quot;,              // User displayable message from the writer.    &quot;state&quot;: &quot;FINISHED&quot;,                  // Final state of the acquisition.    &quot;stats&quot;: {                            // Stats of the acquisition      &quot;n_write_completed&quot;: 100,           //   Number of completed writes      &quot;n_write_requested&quot;: 100,           //   Number of requested writers      &quot;start_time&quot;: 1684930336.1252322,   //   Start time of request as seen by writer driver      &quot;stop_time&quot;: 1684930345.2723851     //   Stop time of request as seen by writer driver    }  },  { ... }]```In case the file could not be created or another error occurred this will not be logged in the acquisition log.</longdescription>
</pkgmetadata>