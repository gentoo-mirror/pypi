<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![Validate Build](https://github.com/ScholarPack/cookie-manager/workflows/Validate%20Build/badge.svg?branch=master)# Cookie-ManagerSigned cookie manager for communication between multiple trusted services.Signs, verifies, and manages multiple cookies from trusted environments. Designed for use by services all within the same secure network (AWS VPC etc).Wraps [itsdangerous](https://github.com/pallets/itsdangerous) for the signing and verification (but this could change in the future). Specifically, this handles:- Managing multiple different cookies - one for every environment or paired service- Error correction around sign/verify commandsThis package is designed to sign and verify cookies - either ingoing or outgoing. These cookies are not encrypted, so stick to benign data, and only transmit within a trusted environment such as an AWS VPC.# InstallationInstall and update using `pip`:```bash pip install -U Cookie-Manager```# UsageImport:```pythonfrom cookie_manager.cookie_manager import CookieManager```Cookie-Manager is designed to use multiple different signing/verifying keys -- one (or more) per environment.Configure your keys in a dict:```pythonkeys = {&quot;key1&quot;: &quot;SECRET&quot;, &quot;key2&quot;: &quot;SECRET2&quot;}```Create an instance (and seed it with your keys):```pythoncookie_manager = CookieManager(keys=keys)```## SigningTo sign a cookie, start with a dict payload containing your data:```pythonpayload = {&quot;key&quot;: &quot;value&quot;}```Then sign the payload, making sure to pass a valid `key_id` as previously configured. The `sign` method willretrieve your signing key `SECRET` to sign requests (based on the `key_id` you pass in). This WILL override anyexisting key with the name `key_id`.```pythonsigned_cookie = cookie_manager.sign(cookie=payload, key_id=&quot;key1&quot;)```This will return you a signed cookie (with an additional `key_id` pair added in):```python'{&quot;key&quot;: &quot;value&quot;, &quot;key_id&quot;: &quot;key1&quot;}.XepkCA.CUZtVTCXHbqoalWVCh5xOa4S4WE'```## VerifyingWhen reading in a signed cookie, verification happens through the cookie payload -&gt; whatever comes in needs to have a `key_id` in the payload, which is used to lookup the verification key (configured during instantiation). This is addedfor you by `sign`:```pythonincoming_signed_cookie = '{&quot;key&quot;: &quot;value&quot;, &quot;key_id&quot;, &quot;key1&quot;}.XepkCA.CUZtVTCXHbqoalWVCh5xOa4S4WE'```Verify this cookie (during which Cookie-Manager will extract `key_id` from the payload, and lookup the key used to sign the cookie):```pythonpayload = cookie_manager.verify(signed_cookie=signed_cookie)```Now, you can access data inside the `payload` object. The `verify` function will raise errors if it cannot verify.## ConfigurationYou can pass an optional config dictionary into the constructor to override existing options.```pythoncookie_manager = CookieManager(keys=keys, config={&quot;VERIFY_MAX_COOKIE_AGE&quot;: 10})```This example will override the max age of a cookie that is allowed, when verifying.# Custom LoggingThis package uses dependency injection to log errors with Python's `print`. To use your own logger, pass in alogger object which implements `critical`, `error`, `warning`, `debug`, and `info` functions. Here's how to patchin the Flask logger, but any object will work providing it meets the Duck Typing rules:```pythoncookie_manager = CookieManager(keys=keys, logger=app.logger)```This will result in logging calls firing to `app.logger.&lt;logger-level&gt;` with a string passed in.# Custom ExceptionsLike logging, this package uses custom error handling if you need it. By default, all errors will raise as&quot;Exception&quot;, but you can pass in a custom object to raise specific errors.This class will raise `Unauthorized`, `ServiceUnavailable`, and `BadRequest`.Here's how to pass in a [Werkzeug](https://github.com/pallets/werkzeug) exception object:```pythonfrom werkzeug import exceptionscookie_manager = CookieManager(keys=keys, exceptions=exceptions)```# Security DecoratorsIf using this package in *flask*, you can decorate routes to only allow access to certain cookies.There are 2 ways of protecting a route, allow any signed cookie or allow cookies signed with specific keys.To make use of the decorators, you will need to create a cookie manager that has all the keys you want to use forprotecting routes and create an instance of the `CookieSecurityDecorator`.*Decorator instance (e.g. util.py)*```pythonfrom cookie_manager import CookieSecurityDecoratorcookie_security = CookieSecurityDecorator()``````pythonfrom cookie_manager import CookieManagerfrom project.util import cookie_securityfrom flask import requestcookie_manager = CookieManager(    keys={&quot;key_1&quot;: &quot;&quot;, &quot;key_2&quot;: &quot;&quot;, &quot;key_3&quot;: &quot;&quot;}, # These are the keys that will be used to protect all routes    exceptions=exceptions,)cookie_security.init_app(request=request, cookie_manager=cookie_manager, cookie_name=&quot;cookie_name&quot;)```The string supplied for `cookie_name` is the name of the cookie in the request to use for protecting the routes.Now you are able to use the decorator as detailed below.**Option 1** - Allow access to any signed cookieLets say we want to have a route that can be accessed by any cookie that has been signed using one of the keyssupplied to the cookie manager used to create the decorator. If we decorate the route like the following example,only signed cookies will be allowed to access this route.```pythonfrom project.util import cookie_security@cookie_security.keys_required()def my_route():    #...```**Option 2** - Allow access to specific signed cookiesLets say we want to have a route that can only be accessed by a cookie that has been signed using a subset of keys supplied tothe cookie manager used to create the decorator. If we decorate the route like the following example, only cookies signed witha provided key will be allowed to access this route.```pythonfrom project.util import cookie_security@cookie_security.keys_required([&quot;key_1&quot;, &quot;key_2&quot;])def my_route():    #...```# Developing__The build pipeline require your tests to pass and code to be formatted__Make sure you have Python 3.x installed on your machine (use [pyenv](https://github.com/pyenv/pyenv)).Install the dependencies with [pipenv](https://github.com/pypa/pipenv) (making sure to include dev and pre-release packages):```bashpipenv install --dev --pre```Configure your environment:```bashpipenv shell &amp;&amp; export PYTHONPATH=&quot;$PWD&quot;```Run the tests:```bashpytest```Or with logging:```bashpytest -s```Or tests with coverage:```bashpytest --cov=./```Format the code with [Black](https://github.com/psf/black):```bashblack $PWD```# ReleasesCleanup the (.gitignored) `dist` folder (if you have one):```bashrm -rf dist```Notch up the version number in `setup.py` and build:```bashpython3 setup.py sdist bdist_wheel```Push to PyPi (using the ScholarPack credentials when prompted)```bashpython3 -m twine upload --repository-url https://upload.pypi.org/legacy/ dist/*```# Links* Releases: https://pypi.org/project/cookie-manager/* Code: https://github.com/ScholarPack/cookie-manager/</longdescription>
</pkgmetadata>