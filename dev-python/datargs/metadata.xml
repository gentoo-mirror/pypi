<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># datargsA paper-thin wrapper around `argparse` that creates type-safe parsersfrom `dataclass` and `attrs` classes.## QuickstartInstall `datargs`:```bashpip install datargs```Create a `dataclass` (or an `attrs` class) describing your command line interface, and call`datargs.parse()` with the class:```python# script.pyfrom dataclasses import dataclassfrom pathlib import Pathfrom datargs import parse@dataclass  # or @attr.s(auto_attribs=True)class Args:    url: str    output_path: Path    verbose: bool    retries: int = 3def main():    args = parse(Args)    print(args)if __name__ == &quot;__main__&quot;:    main()```***(experimental)*** Alternatively: convert an existing parser to a dataclass:```python# script.pyparser = ArgumentParser()parser.add_argument(...)from datargs import convertconvert(parser)````convert()` prints a class definition to the console.Copy it to your script.Mypy and pycharm correctly infer the type of `args` as `Args`, and your script is good to go!```bash$ python script.py -husage: test.py [-h] --url URL --output-path OUTPUT_PATH [--retries RETRIES]               [--verbose]optional arguments:  -h, --help            show this help message and exit  --url URL  --output-path OUTPUT_PATH  --retries RETRIES  --verbose$ python script.py --url &quot;https://...&quot; --output-path out --retries 4 --verboseArgs(url=&quot;https://...&quot;, output_path=Path(&quot;out&quot;), retries=4, verbose=True)```## Table of Contents&lt;!-- toc --&gt;- [Features](#features)  * [Static verification](#static-verification)  * [`dataclass`/`attr.s` agnostic](#dataclassattrs-agnostic)  * [Aliases](#aliases)  * [`ArgumentParser` options](#argumentparser-options)  * [Enums](#enums)  * [Sequences, Optionals, and Literals](#sequences-optionals-and-literals)  * [Sub Commands](#sub-commands)- [&quot;Why not&quot;s and design choices](#why-nots-and-design-choices)  * [Just use argparse?](#just-use-argparse)  * [Use `click`](#use-clickhttpsclickpalletsprojectscomen7x)?  * [Use `clout`](#use-clouthttpscloutreadthedocsioenlatestindexhtml)?  * [Use `simple-parsing`](#use-simple-parsinghttpspypiorgprojectsimple-parsing)?  * [Use `argparse-dataclass`](#use-argparse-dataclasshttpspypiorgprojectargparse-dataclass)?  * [Use `argparse-dataclasses`](#use-argparse-dataclasseshttpspypiorgprojectargparse-dataclasses)?- [FAQs](#faqs)  * [Is this cross-platform?](#is-this-cross-platform)  * [Why are mutually exclusive options not supported?](#why-are-mutually-exclusive-options-not-supported)&lt;!-- tocstop --&gt;## Features### Static verificationMypy/Pycharm have your back when you when you make a mistake:```python...def main():    args = parse(Args)    args.urll  # typo...```Pycharm says: `Unresolved attribute reference 'urll' for class 'Args'`.Mypy says: `script.py:15: error: &quot;Args&quot; has no attribute &quot;urll&quot;; maybe &quot;url&quot;?`### `dataclass`/`attr.s` agnostic```pycon&gt;&gt;&gt; import attr, datargs&gt;&gt;&gt; @attr.s... class Args:...     flag: bool = attr.ib()&gt;&gt;&gt; datargs.parse(Args, [])Args(flag=False)```### AliasesAliases and `ArgumentParser.add_argument()` parameters are taken from `metadata`:```pycon&gt;&gt;&gt; from dataclasses import dataclass, field&gt;&gt;&gt; from datargs import parse&gt;&gt;&gt; @dataclass... class Args:...     retries: int = field(default=3, metadata=dict(help=&quot;number of retries&quot;, aliases=[&quot;-r&quot;], metavar=&quot;RETRIES&quot;))&gt;&gt;&gt; parse(Args, [&quot;-h&quot;])usage: ...optional arguments:  -h, --help            show this help message and exit  --retries RETRIES, -r RETRIES&gt;&gt;&gt; parse(Args, [&quot;-r&quot;, &quot;4&quot;])Args(retries=4)````arg` is a replacement for `field` that puts `add_argument()` parameters in `metadata`.Use it to save precious keystrokes:```pycon&gt;&gt;&gt; from dataclasses import dataclass&gt;&gt;&gt; from datargs import parse, arg&gt;&gt;&gt; @dataclass... class Args:...     retries: int = arg(default=3, help=&quot;number of retries&quot;, aliases=[&quot;-r&quot;], metavar=&quot;RETRIES&quot;)&gt;&gt;&gt; parse(Args, [&quot;-h&quot;])# exactly the same as before```**NOTE**: `arg()` does not currently work with `attr.s`.`arg()` also supports all `field`/`attr.ib()` keyword arguments.### `ArgumentParser` optionsYou can pass `ArgumnetParser` keyword arguments to `argsclass`.Description is its own parameter - the rest are passed as the `parser_params` parameter as a `dict`.When a class is used as a subcommand (see below), `parser_params` are passed to `add_parser`, including `aliases`.```pycon&gt;&gt;&gt; from datargs import parse, argsclass&gt;&gt;&gt; @argsclass(description=&quot;Romans go home!&quot;, parser_params=dict(prog=&quot;messiah.py&quot;))... class Args:...     flag: bool&gt;&gt;&gt; parse(Args, [&quot;-h&quot;], parser=parser)usage: messiah.py [-h] [--flag]Romans go home!...```or you can pass your own parser:```pycon&gt;&gt;&gt; from argparse import ArgumentParser&gt;&gt;&gt; from datargs import parse, argsclass&gt;&gt;&gt; @argsclass... class Args:...     flag: bool&gt;&gt;&gt; parser = ArgumentParser(description=&quot;Romans go home!&quot;, prog=&quot;messiah.py&quot;)&gt;&gt;&gt; parse(Args, [&quot;-h&quot;], parser=parser)usage: messiah.py [-h] [--flag]Romans go home!...```Use `make_parser()` to create a parser and save it for later:```pycon&gt;&gt;&gt; from datargs import make_parser&gt;&gt;&gt; @dataclass... class Args:...     ...&gt;&gt;&gt; parser = make_parser(Args)  # pass `parser=...` to modify an existing parser```**NOTE**: passing your own parser ignores `ArgumentParser` params passed to `argsclass()`.### EnumsWith `datargs`, enums Just Workâ„¢:```pycon&gt;&gt;&gt; import enum, attr, datargs&gt;&gt;&gt; class FoodEnum(enum.Enum):...     ham = 0...     spam = 1&gt;&gt;&gt; @attr.dataclass... class Args:...     food: FoodEnum&gt;&gt;&gt; datargs.parse(Args, [&quot;--food&quot;, &quot;ham&quot;])Args(food=&lt;FoodEnum.ham: 0&gt;)&gt;&gt;&gt; datargs.parse(Args, [&quot;--food&quot;, &quot;eggs&quot;])usage: enum_test.py [-h] --food {ham,spam}enum_test.py: error: argument --food: invalid choice: 'eggs' (choose from ['ham', 'spam'])```**NOTE**: enums are passed by name on the command line and not by value.## Sequences, Optionals, and LiteralsHave a `Sequence` or a `List` of something toautomatically use `nargs`:```pythonfrom pathlib import Pathfrom dataclasses import dataclassfrom typing import Sequencefrom datargs import parse@dataclassclass Args:    # same as nargs='*'    files: Sequence[Path] = ()args = parse(Args, [&quot;--files&quot;, &quot;foo.txt&quot;, &quot;bar.txt&quot;])assert args.files == [Path(&quot;foo.txt&quot;), Path(&quot;bar.txt&quot;)]```Specify a list of positional parameters like so:```pythonfrom datargs import argsclass, arg@argsclassclass Args:    arg: Sequence[int] = arg(default=(), positional=True)````Optional` arguments default to `None`:```pythonfrom pathlib import Pathfrom dataclasses import dataclassfrom typing import Optionalfrom datargs import parse@dataclassclass Args:    path: Optional[Path] = Noneargs = parse(Args, [&quot;--path&quot;, &quot;foo.txt&quot;])assert args.path == Path(&quot;foo.txt&quot;)args = parse(Args, [])assert args.path is None```And `Literal` can be used to specify choices:```pythonfrom pathlib import Pathfrom dataclasses import dataclassfrom typing import Literalfrom datargs import parse@dataclassclass Args:    path: Literal[Path(&quot;foo.txt&quot;), Path(&quot;bar.txt&quot;)]args = parse(Args, [&quot;--path&quot;, &quot;foo.txt&quot;])assert args.path == Path(&quot;foo.txt&quot;)# Throws an error!args = parse(Args, [&quot;--path&quot;, &quot;bad-option.txt&quot;])```### Sub CommandsNo need to specify a useless `dest` to dispatch on different commands.A `Union` of dataclasses/attrs classes automatically becomes a group of subparsers.The attribute holding the `Union` holds the appropriate instanceupon parsing, making your code type-safe:```pythonimport typing, loggingfrom datargs import argsclass, arg, parse@argsclass(description=&quot;install package&quot;)class Install:    package: str = arg(positional=True, help=&quot;package to install&quot;)@argsclass(description=&quot;show all packages&quot;)class Show:    verbose: bool = arg(help=&quot;show extra info&quot;)@argsclass(description=&quot;Pip Install Packages!&quot;)class Pip:    action: typing.Union[Install, Show]    log: str = Noneargs = parse(Pip, [&quot;--log&quot;, &quot;debug.log&quot;, &quot;install&quot;, &quot;my_package&quot;])print(args)# prints: Pip(action=Install(package='my_package'), log='debug.log')# Consume arguments:if args.log:    logging.basicConfig(filename=args.log)if isinstance(args.action, Install):    install_package(args.action.package)    # static type error: args.action.verboseelif isinstance(args.action, Show):    list_all_packages(verbose=args.action.verbose)else:    assert False, &quot;Unreachable code&quot;```Command name is derived from class name. To change this, use the `name` parameter to `@argsclass`.As with all other parameters to `add_parser`,`aliases` can be passed as a key in `parser_params` to add subcommand aliases.**NOTE**: if the commented-out line above does not issue a type error, try adding an `@dataclass/@attr.s`before or instead of `@argsclass()`:```python@argsclass(description=&quot;Pip Install Packages!&quot;)  # optional@dataclassclass Pip:    action: typing.Union[Install, Show]    log: str = None...if isinstance(args.action, Install):    install_package(args.action.package)    # this should now produce a type error: args.action.verbose```## &quot;Why not&quot;s and design choicesMany libraries out there do similar things. This list serves as documentation for existing solutions and differences.So, why not...### Just use argparse?That's easy. The interface is clumsy and repetitive, a.k.a boilerplate. Additionally, `ArgumentParser.parse_args()` returns a `Namespace`, which isequivalent to `Any`, meaning that it any attribute access is legal when type checking. Alas, invalid attribute access will fail at runtime. For example:```pythondef parse_args():    parser = ArgumentParser()    parser.add_argument(&quot;--url&quot;)    return parser.parse_args()def main():    args = parse_args()    print(args.url)```Let's say for some reason `--url` is changed to `--uri`:```pythonparser.add_argument(&quot;--uri&quot;)...print(args.url)  # oops```You won't discover you made a mistake until you run the code. With `datargs`, a static type checker will issue an error.Also, why use a carriage when you have a spaceship?### Use [`click`](https://click.palletsprojects.com/en/7.x/)?`click` is a great library. It provides many utilities for command line programs.Use `datargs` if you believe user interface should not be coupled with implementation, or if youwant to use `argparse` without boilerplate.Use `click` if you don't care.### Use [`clout`](https://clout.readthedocs.io/en/latest/index.html)?It seems that `clout` aims to be an end-to-end solution for command line programs Ã  la click.Use it if you need a broader solution. Use `datargs` if you want to use `argparse` without boilerplate.### Use [`simple-parsing`](https://pypi.org/project/simple-parsing/)?This is another impressive library.Use it if you have deeply-nested options, or if the following points don't applyto you.Use `datargs` if you:* need `attrs` support* want as little magic as possible* don't have many options or they're not nested* prefer dashes (`--like-this`) over underscores (`--like_this`)### Use [`argparse-dataclass`](https://pypi.org/project/argparse-dataclass/)?It's similar to this library. The main differences I found are:* no `attrs` support* not on github, so who you gonna call?### Use [`argparse-dataclasses`](https://pypi.org/project/argparse-dataclasses/)?Same points `argparse-dataclass` but also [Uses inheritance](https://refactoring.guru/replace-inheritance-with-delegation).## FAQs### Is this cross-platform?Yes, just like `argparse`.If you find a bug on a certain platform (or any other bug), please report it.### Why are mutually exclusive options not supported?This library is based on the idea of a one-to-one correspondence between most parsersand simple classes. Conceptually, mutually exclusive options are analogous to[sum types](https://en.wikipedia.org/wiki/Tagged_union), just like [subparsers](#sub-commands) are,but writing a class for each flag is not ergonomic enough.Contact me if you want this feature or if you come up with a better solution.</longdescription>
</pkgmetadata>