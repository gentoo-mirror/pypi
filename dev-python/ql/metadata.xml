<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># quillquill is the &quot;driver&quot; for [spin.systems](https://spin.systems),and packaged on PyPi as [ql](https://pypi.org/project/ql/).A more detailed description of the package namespace can be found below,but for everyday usage the commands needed are:```pyimport quill as qlql.ssm.check_manifest() # Check all component repos' statusql.ssm.repos_df # print the summary dataframeql.fold.wire.standup() # build or rebuild any 'wire' module MMD documents as HTML pagesql.fold.cut.standup() # build or rebuild any 'cut' module Jinja templates as HTML pagesql.remote_push_manifest() # Add/commit/push any dirty repos, triggering CI build```The last step will also rebuild any sites which have dirty repos (to avoid content partially falling behind,when for instance the templates for a site are changed).## Structure- `ql`⠶`scan`: Read `.mmd` files  - `scan`⠶`lever`: Parse `.mmd` file format- `ql`⠶`manifest`: Read `spin.systems` configuration- `ql`⠶`fold`: Manage `*.spin.systems` subdomains  - `fold`⠶`address`: Manage subdomain address shorthand  - `fold`⠶`wire`: Emit HTML websites from `.mmd` files  - `fold`⠶`cut`: Emit HTML websites from `.html` Jinja templates and `.md` files## Helper CLI&gt; Note: for reasons unknown, the `defopt` CLI only works on 3.10+Installation adds a `ql` command (for deployment) and `cyl` (for local preview).These two commands handle repo-internal and -external output of generated sites respectively(`cyl` currently only for the `fold.cut` module, not `fold.wire`,so not yet sufficient to replace in the CI pipeline).```shql -h```⇣```usage: ql [-h] [-d [DOMAINS_LIST ...]] [--internal | --no-internal]          [--incremental | --no-incremental]          [-n | --no-render | --no-no-render] [-r | --recheck | --no-recheck]          [-w | --watch | --no-watch] [-v | --verbose | --no-verbose]options:  -h, --help            show this help message and exit  -d [DOMAINS_LIST ...], --domains-list [DOMAINS_LIST ...]                        (default: None)  --internal, --no-internal                        (default: True)  --incremental, --no-incremental                        (default: False)  -n, --no-render, --no-no-render                        (default: False)  -r, --recheck, --no-recheck                        (default: False)  -w, --watch, --no-watch                        (default: False)  -v, --verbose, --no-verbose                        (default: True)```So for example:```shcyl -d pore```Populates `~/spin/cyl/pore` with the `cut` module's portion of _pore.spin.systems_### Incremental builds, rechecking, and watchingTowards the goal of implementing an incremental build system on CI, quill has 2 extra modes:- an _incremental_ build mode: where in addition to building the entire site (or domain list),  MD5 checksums are computed for each of the generated files. In this mode, the _build auditer_ is activated,  and stores a log as it generates the templates. Use the `-i` flag when you want to recreate the  inventory of template MD5 hashes.To run a build for the same domain as above, in incremental mode, run:```shcyl -d pore -i```- a _recheck_ build mode: a subset of incremental builds in which only files whose input checksum  has changed since the last incremental run are regenerated. This makes the build substantially faster  as there is a reduced scope of templates to transform. Use the `-r` flag (alongside `-i`) when you  want to double check only the files in the template hash inventory and only regenerate what differs on disk.To run a recheck afterwards, and only build any files that changed in between builds, run:```shcyl -d pore -i -r```- a _watch_ build mode: incompatible with incremental/recheck, this is for continuously rebuilding  (incremental mode is designed for repeated use, like on an incremental build system). Use the `-w`  flag when you want to have the page rebuild automatically in the background.Watching is incompatible with incremental mode, but rebuilds following changes to a file.The corresponding command to the ones above would be:```shcyl -d pore -w```## Usage memo- Requires directory of static site repositories at  location specified in [`spin.ini`](spin.ini) (by default  this is as a sibling directory `../ss/`), containing  a file `manifest.mmd` beginning with the apex domain and  immediately followed by a subdomain list.Below is a demo of accessing the `spin.systems` manifest file(`ssm`) which implements the `MMD` class, subclassing `Doc`,which parses the file contents in a structured way (specifically,as a list of colon-separated values).```py&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt; from quill import ssm&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; ssmParsed MMD file (Document of 1 block, containing 1 list)&gt;&gt;&gt; ssm.listHeadered list with 16 items&gt;&gt;&gt; pprint(ssm.list.all_nodes)[-spin.systems:spin-systems:master www:, -:cal:qu-cal:master www, -,:log:spin-log:master www, -,:conf:qu-conf:master www, -,:pore:qu-pore:master www, -,:ocu:naiveoculus:master www, -,:arc:appendens:master www, -,:qrx:qu-arx:master www, -,:erg:spin-erg:master www, -,:opt:spin-opt:master www, -,:poll:qu-poll:master www, -,:arb:spin-arb:master www, -,:reed:qu-reed:master www, -,:noto:qu-noto:master www, -,:plot:qu-plot:master www, -,:doc:spin-doc:master www, -,:labs:qu-labs:master www]```Similarly `ssm.list.nodes` gives just the subdomains, and `ssm.list.header` gives the main sitedomain.```py&gt;&gt;&gt; ssm.list.header-spin.systems:spin-systems:&gt;&gt;&gt; ssm.list.header.parts['spin.systems', 'spin-systems', 'master www']&gt;&gt;&gt; ssm.list.nodes[0].parts['cal', 'qu-cal', 'master www']&gt;&gt;&gt; ssm.list.nodes[1].parts['log', 'spin-log', 'master www']&gt;&gt;&gt; ssm.list.nodes[2].parts['conf', 'qu-conf', 'master www']&gt;&gt;&gt; pprint(ssm.all_parts)[['spin.systems', 'spin-systems', 'master www'], ['cal', 'qu-cal', 'master www'], ['log', 'spin-log', 'master www'], ['conf', 'qu-conf', 'master www'], ['pore', 'qu-pore', 'master www'], ['ocu', 'naiveoculus', 'master www'], ['arc', 'appendens', 'master www'], ['qrx', 'qu-arx', 'master www'], ['erg', 'spin-erg', 'master www'], ['opt', 'spin-opt', 'master www'], ['poll', 'qu-poll', 'master www'], ['arb', 'spin-arb', 'master www'], ['reed', 'qu-reed', 'master www'], ['noto', 'qu-noto', 'master www'], ['plot', 'qu-plot', 'master www'], ['doc', 'spin-doc', 'master www'], ['labs', 'qu-labs', 'master www']]&gt;&gt;&gt; ssm.as_df()          domain     repo_name    branches0   spin.systems  spin-systems  master www1            cal        qu-cal  master www2            log      spin-log  master www3           conf       qu-conf  master www4           pore       qu-pore  master www5            ocu   naiveoculus  master www6            arc     appendens  master www7            qrx        qu-arx  master www8            erg      spin-erg  master www9            opt      spin-opt  master www10          poll       qu-poll  master www11           arb      spin-arb  master www12          reed       qu-reed  master www13          noto       qu-noto  master www14          plot       qu-plot  master www15           doc      spin-doc  master www16          labs       qu-labs  master www```This is just for review purposes currently, and any further info can be added as longas all the lines (&quot;nodes&quot;) have the same number of colon-separated values.The manifest is parsed in [`manifest`⠶`parsing`](src/quill/manifest/parsing.py) by`parse_man_node` which is wrapped into `ssm.repos`,which will print out the repos' git addresses for each CNAME domain or subdomain:```STDOUT('spin.systems', 'git@gitlab.com:spin-systems/spin-systems.gitlab.io.git')('cal', 'git@gitlab.com:qu-cal/qu-cal.gitlab.io.git')('log', 'git@gitlab.com:spin-log/spin-log.gitlab.io.git')('conf', 'git@gitlab.com:qu-conf/qu-conf.gitlab.io.git')('pore', 'git@gitlab.com:qu-pore/qu-pore.gitlab.io.git')('ocu', 'git@gitlab.com:naiveoculus/naiveoculus.gitlab.io.git')('arc', 'git@gitlab.com:appendens/appendens.gitlab.io.git')('qrx', 'git@gitlab.com:qu-arx/qu-arx.gitlab.io.git')('erg', 'git@gitlab.com:spin-erg/spin-erg.gitlab.io.git')('opt', 'git@gitlab.com:spin-opt/spin-opt.gitlab.io.git')('poll', 'git@gitlab.com:qu-poll/qu-poll.gitlab.io.git')('arb', 'git@gitlab.com:spin-arb/spin-arb.gitlab.io.git')('reed', 'git@gitlab.com:qu-reed/qu-reed.gitlab.io.git')('noto', 'git@gitlab.com:qu-noto/qu-noto.gitlab.io.git')('plot', 'git@gitlab.com:qu-plot/qu-plot.gitlab.io.git')('doc', 'git@gitlab.com:spin-doc/spin-doc.gitlab.io.git')('labs', 'git@gitlab.com:qu-labs/qu-labs.gitlab.io.git')```as well as a DataFrame which is modified by the `ql.ssm.check_manifest()` to include 'live' views onthe repos (note that this method takes a `add_before_check=True` argument, which controls whether`git add --all` is run on each repo to check if it's 'dirty').```py&gt;&gt;&gt; ssm.repos_df          domain     repo_name    branches                                                 git_url0   spin.systems  spin-systems  master www  git@gitlab.com:spin-systems/spin-systems.gitlab.io.git1            cal        qu-cal  master www              git@gitlab.com:qu-cal/qu-cal.gitlab.io.git2            log      spin-log  master www          git@gitlab.com:spin-log/spin-log.gitlab.io.git3           conf       qu-conf  master www            git@gitlab.com:qu-conf/qu-conf.gitlab.io.git4           pore       qu-pore  master www            git@gitlab.com:qu-pore/qu-pore.gitlab.io.git5            ocu   naiveoculus  master www    git@gitlab.com:naiveoculus/naiveoculus.gitlab.io.git6            arc     appendens  master www        git@gitlab.com:appendens/appendens.gitlab.io.git7            qrx        qu-arx  master www              git@gitlab.com:qu-arx/qu-arx.gitlab.io.git8            erg      spin-erg  master www          git@gitlab.com:spin-erg/spin-erg.gitlab.io.git9            opt      spin-opt  master www          git@gitlab.com:spin-opt/spin-opt.gitlab.io.git10          poll       qu-poll  master www            git@gitlab.com:qu-poll/qu-poll.gitlab.io.git11           arb      spin-arb  master www          git@gitlab.com:spin-arb/spin-arb.gitlab.io.git12          reed       qu-reed  master www            git@gitlab.com:qu-reed/qu-reed.gitlab.io.git13          noto       qu-noto  master www            git@gitlab.com:qu-noto/qu-noto.gitlab.io.git14          plot       qu-plot  master www            git@gitlab.com:qu-plot/qu-plot.gitlab.io.git15           doc      spin-doc  master www          git@gitlab.com:spin-doc/spin-doc.gitlab.io.git16          labs       qu-labs  master www            git@gitlab.com:qu-labs/qu-labs.gitlab.io.git&gt;&gt;&gt; ssm.check_manifest()          domain     repo_name    branches                                                 git_url  branch  local  clean0   spin.systems  spin-systems  master www  git@gitlab.com:spin-systems/spin-systems.gitlab.io.git     www   True   True1            cal        qu-cal  master www              git@gitlab.com:qu-cal/qu-cal.gitlab.io.git     www   True   True2            log      spin-log  master www          git@gitlab.com:spin-log/spin-log.gitlab.io.git     www   True   True3           conf       qu-conf  master www            git@gitlab.com:qu-conf/qu-conf.gitlab.io.git     www   True   True4           pore       qu-pore  master www            git@gitlab.com:qu-pore/qu-pore.gitlab.io.git     www   True   True5            ocu   naiveoculus  master www    git@gitlab.com:naiveoculus/naiveoculus.gitlab.io.git     www   True   True6            arc     appendens  master www        git@gitlab.com:appendens/appendens.gitlab.io.git     www   True   True7            qrx        qu-arx  master www              git@gitlab.com:qu-arx/qu-arx.gitlab.io.git     www   True   True8            erg      spin-erg  master www          git@gitlab.com:spin-erg/spin-erg.gitlab.io.git     www   True   True9            opt      spin-opt  master www          git@gitlab.com:spin-opt/spin-opt.gitlab.io.git     www   True   True10          poll       qu-poll  master www            git@gitlab.com:qu-poll/qu-poll.gitlab.io.git  master   True   True11           arb      spin-arb  master www          git@gitlab.com:spin-arb/spin-arb.gitlab.io.git     www   True   True12          reed       qu-reed  master www            git@gitlab.com:qu-reed/qu-reed.gitlab.io.git     www   True   True13          noto       qu-noto  master www            git@gitlab.com:qu-noto/qu-noto.gitlab.io.git     www   True   True14          plot       qu-plot  master www            git@gitlab.com:qu-plot/qu-plot.gitlab.io.git     www   True   True15           doc      spin-doc  master www          git@gitlab.com:spin-doc/spin-doc.gitlab.io.git     www   True   True16          labs       qu-labs  master www            git@gitlab.com:qu-labs/qu-labs.gitlab.io.git     www   True   True```In this example, the `poll` repo is on the master branch, and the rest are on the www (web deploy) branch.Obviously this can then be used to clone the repositories locally(or address them for any other `git`-related task)- One nice feature of GitLab (which at the time of writing GitHub doesn't  provide to my knowledge) is that these repos can all be private, and only  the static site will be hosted publicly (specified in 'Settings' &gt; 'General')To clone a given repo (testing has all been with SSH URLs), there is the `ql.clone()` function,and subsequently the namespace can be `refresh`ed to reflect the new addition (this isdone automatically within the `clone` function).```py&gt;&gt;&gt; ql.ns{}&gt;&gt;&gt; ql.clone(ql.ssm.repos_df.git_url[0], &quot;spin.systems&quot;)Cloning into 'spin.systems'...remote: Enumerating objects: 6, done.remote: Counting objects: 100% (6/6), done.remote: Compressing objects: 100% (6/6), done.remote: Total 236 (delta 1), reused 0 (delta 0), pack-reused 230Receiving objects: 100% (236/236), 34.16 KiB | 210.00 KiB/s, done.Resolving deltas: 100% (123/123), done.&gt;&gt;&gt; ql.ns{'spin.systems': 'https://gitlab.com/spin-systems/spin-systems.gitlab.io'}```Lastly, the entire manifest of repos can be sourced from `ssm` and `clone`d into the`ns_path` directory. This is done on CI to build each site when a change takes placein one of the source repos or the quill repo (the 'engine').```pyql.source_manifest()```For now, if the directory named as the `domain` entry of the row in the `ssm.repos_df`table exists, it will simply not touch it. If it doesn't exist, it will try to clone it.Et voila the namespace now contains all the repos (stored in the sibling `ss` directory)```py&gt;&gt;&gt; pprint(ql.ns){'arb': 'https://gitlab.com/spin-arb/spin-arb.gitlab.io', 'arc': 'https://gitlab.com/appendens/appendens.gitlab.io', 'cal': 'https://gitlab.com/qu-cal/qu-cal.gitlab.io', 'conf': 'https://gitlab.com/qu-conf/qu-conf.gitlab.io', 'doc': 'https://gitlab.com/spin-doc/spin-doc.gitlab.io', 'erg': 'https://gitlab.com/spin-erg/spin-erg.gitlab.io', 'labs': 'https://gitlab.com/qu-labs/qu-labs.gitlab.io', 'log': 'https://gitlab.com/spin-log/spin-log.gitlab.io', 'noto': 'https://gitlab.com/qu-noto/qu-noto.gitlab.io', 'ocu': 'https://gitlab.com/naiveoculus/naiveoculus.gitlab.io', 'opt': 'https://gitlab.com/spin-opt/spin-opt.gitlab.io', 'plot': 'https://gitlab.com/qu-plot/qu-plot.gitlab.io', 'poll': 'https://gitlab.com/qu-poll/qu-poll.gitlab.io', 'pore': 'https://gitlab.com/qu-pore/qu-pore.gitlab.io', 'qrx': 'https://gitlab.com/qu-arx/qu-arx.gitlab.io', 'reed': 'https://gitlab.com/qu-reed/qu-reed.gitlab.io', 'spin.systems': 'https://gitlab.com/spin-systems/spin-systems.gitlab.io'}```At the end of `source_manifest`, the `ssm.repos_df` DataFrame is updated with a column `local`indicating whether each domain in the manifest is now in the `ns` namespace (i.e. whether alocal repo has been created), via the `check_manifest` method which `ssm`'s `MMD` class inheritsfrom the `Doc` class.- This `update_manifest` method will be expanded to supplement the `repos_df` DataFrame with  other information worth knowing to do with the `git` status of the repo in question, for those  which are locally available. This ensures no unnecessary computation is done before the extra  information is needed.The next thing we can do (having established that these are now cloned locally) is to read the CI YAMLas the 'layout' for each site, checking they're valid (according to the[reference](https://docs.gitlab.com/ee/ci/yaml/#pages) on YAML configs for GitLab Pages)```py&gt;&gt;&gt; manifests = ql.yaml_manifests(as_dicts=False)&gt;&gt;&gt; for k,m in manifests.items(): print(k, end=&quot;\t&quot;); pprint(m)spin.systems    SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}cal     SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}log     SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}conf    SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}pore    SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}ocu     SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}arc     SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}qrx     SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}erg     SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}opt     SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}poll    SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}arb     SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}reed    SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}noto    SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}plot    SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}doc     SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}labs    SiteCI: PagesJob: {Stage.Deploy, Script &lt;subdirectory='site'&gt;, Artifacts &lt;paths=['public']&gt;, Only &lt;branch=['www']&gt;}```- Obviously these could all be made more elaborate for less trivial scripts, this is a first draft showing basic functionality and to enforce/check standardisation across all repos- This setup is deliberately brittle, so any changes will need to be validated in the `fold.yaml_util` module,  and so the library itself incorporates testing (simple `assert` statements based on a clear expected implementation)The build directory can be set with `change_build_dir`, and using this I set all of the repos tobuild from &quot;site&quot; (but this can be changed at a later date):```pyfor d in ql.alias_df.domain: ql.change_build_dir(d, &quot;site&quot;)```⇣```STDOUTMoved build path for log from 'site' --&gt; /home/louis/spin/ss/log/siteCreated build path for ocu at /home/louis/spin/ss/ocu/siteMoved build path for arc from 'site' --&gt; /home/louis/spin/ss/arc/siteCreated build path for erg at /home/louis/spin/ss/erg/siteCreated build path for opt at /home/louis/spin/ss/opt/siteCreated build path for arb at /home/louis/spin/ss/arb/siteCreated build path for doc at /home/louis/spin/ss/doc/siteCreated build path for cal at /home/louis/spin/ss/cal/siteMoved build path for conf from 'docs' --&gt; /home/louis/spin/ss/conf/siteCreated build path for pore at /home/louis/spin/ss/pore/siteCreated build path for qrx at /home/louis/spin/ss/qrx/siteCreated build path for poll at /home/louis/spin/ss/poll/siteCreated build path for reed at /home/louis/spin/ss/reed/siteCreated build path for noto at /home/louis/spin/ss/noto/siteCreated build path for plot at /home/louis/spin/ss/plot/siteCreated build path for labs at /home/louis/spin/ss/labs/site```To commit these changes, I added some more functions to manage the `git` repos.`ql.ssm.check_manifest()` now has a column referring to whether the working treeis clean or has changes to tracked files not staged for commit.The output will be something like this example (where the README in `arc`was moved):```pyql.remote_push_manifest()```⇣```STDERRSkipping 'repo_dir=/home/louis/spin/ss/spin.systems' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/cal' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/log' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/conf' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/pore' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/ocu' (working tree clean)Commit [repo_dir=/home/louis/spin/ss/arc] ⠶ Renamed site/README.md -&gt; README.md⇢ Pushing ⠶ originSkipping 'repo_dir=/home/louis/spin/ss/qrx' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/erg' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/opt' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/poll' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/arb' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/reed' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/noto' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/plot' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/doc' (working tree clean)Skipping 'repo_dir=/home/louis/spin/ss/labs' (working tree clean)```This function takes a `refspec` argument which indicates a particular path to add and push in each repo,a `specific_domains` argument which can be a string of a single domain, or list of multiple,and will be evaluated as the list of all domains if left as `None`.Running `ssm.check_manifest()` again is required to update `ssm.repos_df`.This `repos_df` dataframe is also useful for comparing whateverother properties you might want to check, e.g. which have a README```py&gt;&gt;&gt; df = ql.ssm.repos_df&gt;&gt;&gt; df[&quot;has_README&quot;] = [&quot;README.md&quot; in [x.name for x in (ql.ns_path / d).iterdir()] for d in df.domain]&gt;&gt;&gt; df          domain     repo_name    branches  ... local clean  has_README0   spin.systems  spin-systems  master www  ...  True  True        True1            cal        qu-cal  master www  ...  True  True       False2            log      spin-log  master www  ...  True  True        True3           conf       qu-conf  master www  ...  True  True        True4           pore       qu-pore  master www  ...  True  True       False5            ocu   naiveoculus  master www  ...  True  True        True6            arc     appendens  master www  ...  True  True        True7            qrx        qu-arx  master www  ...  True  True       False8            erg      spin-erg  master www  ...  True  True       False9            opt      spin-opt  master www  ...  True  True       False10          poll       qu-poll  master www  ...  True  True       False11           arb      spin-arb  master www  ...  True  True       False12          reed       qu-reed  master www  ...  True  True       False13          noto       qu-noto  master www  ...  True  True       False14          plot       qu-plot  master www  ...  True  True        True15           doc      spin-doc  master www  ...  True  True       False16          labs       qu-labs  master www  ...  True  True       False```Obviously this is the kind of thing to then follow up manually,but it helps to have programmatic ways to view the set of directories.If after reviewing `ssm.repos_df` you want to push, you can do soeither with an automated commit message or by passing it as the `commit_msg`argument to `remote_push_manifest` (which will reuse the same commit messageif multiple repos are not clean).- Note you can always manually go in and check the `git diff` beforehand## `static`, `src`, and `wire`To build all sites with a `src` and/or `static` directory, run `ql.fold.cut.standup()`.This builds templates from the `src` folder with `staticjinja`, and the static filesare just copied over (directly under `site/`).To build all sites with a wire config, run `ql.fold.wire.standup()`.&lt;details&gt;&lt;summary&gt;More details&lt;/summary&gt;&lt;p&gt;In fact, `standup` returns a dictionary of the domains, though for nowonly one domain is in use with wires.```pyemitters = ql.fold.wire.standup(verbose=False)emitters```⇣```STDOUT{'poll': &lt;quill.fold.wire.emitters.WireEmitter object at 0x7f304980eb20&gt;}```&lt;/p&gt;&lt;/details&gt;Then to push the sites 'live', run `ql.remote_push_manifest(&quot;Commit message goes here&quot;)`.## AliasesThe &quot;canonical names&quot; displayed in the README are the aliases, which by and largeare the same as the domain names.These provide the titles of the index pages of each site.I might make more use of these in future, I originally only needed theseas it turns out the description on GitHub/GitLab isn't stored in the git repoitself (silly as there's a `description` built in to `git`?)Using this let me generate a nice README for the spin.systems superrepo:&gt; # spin.systems&gt; &gt; spin.systems: [`ss`](https://gitlab.com/spin.systems/spin.systems.gitlab.io)&gt; &gt; - `cal`: [q ⠶ cal](https://gitlab.com/qu-cal/qu-cal.gitlab.io)&gt; - `log`: [∫ ⠶ log](https://gitlab.com/spin-log/spin-log.gitlab.io)&gt; - `conf`: [q ⠶ conf](https://gitlab.com/qu-conf/qu-conf.gitlab.io)&gt; - `pore`: [q ⠶ biorx](https://gitlab.com/qu-pore/qu-pore.gitlab.io)&gt; - `ocu`: [∫ ⠶ ocu](https://gitlab.com/naiveoculus/naiveoculus.gitlab.io)&gt; - `arc`: [∫ ⠶ app](https://gitlab.com/appendens/appendens.gitlab.io)&gt; - `qrx`: [q ⠶ arx](https://gitlab.com/qu-arx/qu-arx.gitlab.io)&gt; - `erg`: [∫ ⠶ erg](https://gitlab.com/spin-erg/spin-erg.gitlab.io)&gt; - `opt`: [∫ ⠶ opt](https://gitlab.com/spin-opt/spin-opt.gitlab.io)&gt; - `poll`: [q ⠶ poll](https://gitlab.com/qu-poll/qu-poll.gitlab.io)&gt; - `arb`: [∫ ⠶ arb](https://gitlab.com/spin-arb/spin-arb.gitlab.io)&gt; - `reed`: [q ⠶ reed](https://gitlab.com/qu-reed/qu-reed.gitlab.io)&gt; - `noto`: [q ⠶ ruinoto](https://gitlab.com/qu-noto/qu-noto.gitlab.io)&gt; - `plot`: [q ⠶ plotspot](https://gitlab.com/qu-plot/qu-plot.gitlab.io)&gt; - `doc`: [∫ ⠶ doc](https://gitlab.com/spin-doc/spin-doc.gitlab.io)&gt; - `labs`: [q ⠶ labs](https://gitlab.com/qu-labs/qu-labs.gitlab.io)## Addresses&quot;Spin addresses&quot; follow the above &quot;{namespace}⠶{domain|alias}&quot; format, and additionally:- Some (initially only `∫⠶log`) subdomain repos are 'deploy' stage counterparts  to local 'dev' stage directories.- Some (initially only `∫⠶log`) subdomain repos will be 'addressed' with a date  [and a zero-based counter for same-day entries]```py&gt;&gt;&gt; example = &quot;∫⠶log⠶20⠶oct⠶25⠶0&quot;&gt;&gt;&gt; eg_addr = ql.AddressPath(example)&gt;&gt;&gt; eg_addr['∫', 'log', '20', 'oct', '25', '0']```The path has been parsed (&quot;strictly&quot; by default) into parts which are'typed' strings.```pypprint(list(map(type, eg_addr)))```⇣```STDOUT[&lt;class 'ql.src.quill.scan.address.paths.NameSpaceString'&gt;, &lt;class 'ql.src.quill.scan.address.paths.DomainString'&gt;, &lt;class 'ql.src.quill.scan.address.paths.YyDigitString'&gt;, &lt;class 'ql.src.quill.scan.address.paths.mmmString'&gt;, &lt;class 'ql.src.quill.scan.address.paths.DdDigitString'&gt;, &lt;class 'ql.src.quill.scan.address.paths.FileIntString'&gt;]```A file path can be obtained from this using `interpret_filepath`,which is bound to the class as the `filepath` property:```py&gt;&gt;&gt; eg_addr.filepathPosixPath('/home/louis/spin/l/20/10oct/25/0_digitalising_spin_addresses.mmd')&gt;&gt;&gt; eg_addr.filepath.exists()True&gt;&gt;&gt; ql.mmd(eg_addr.filepath)Parsed MMD file (Document of 4 blocks)```This comes in handy when building components of the spin.systems site such as[`tap`](https://github.com/lmmx/tap) which can then build parts for a particular domainwith```py&gt;&gt;&gt; eg_addr = ql.AddressPath.from_parts(domain=&quot;poll&quot;, ymd=(2021, 2, 17))&gt;&gt;&gt; eg_addr.filepathPosixPath('/home/louis/spin/ss/poll/transmission/21/02feb/17')```This gives a simple date-based interface obeying the storage structure of quill,though unlike files, paths to directories in this way may not exist(instead they can be created as needed).## TODO- [x] A next step could be a class representing the state of the websites [beyond CI], which can  then be cross-referenced against the `repos_df` (but the goal is not to entirely Python-ise  the site development, just the management of key aspects to do with the version control on disk)- [x] Make a pip installable binary wheel (bdist not currently working with SCM, just sdist)- [x] Make package capable of downloading missing data files in the event it is being distributed</longdescription>
</pkgmetadata>