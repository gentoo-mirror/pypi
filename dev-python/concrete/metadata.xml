<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Tutorial========.. image:: https://travis-ci.org/hltcoe/concrete-python.svg   :target: https://travis-ci.org/hltcoe/concrete-python.. image:: https://ci.appveyor.com/api/projects/status/0346c3lu11vj8xqj?svg=true   :target: https://ci.appveyor.com/project/cjmay/concrete-python-f3iqfConcrete-python is the Python interface to Concrete_, anatural language processing data format and set of service protocolsthat work across different operating systems and programming languagesvia `Apache Thrift`_.  Concrete-python contains generated Pythonclasses, utility classes and functions, and scripts.  It does not contain theThrift schema for Concrete, which can be found in the`Concrete GitHub repository`_.This document provides a quick tutorial of concrete-python installation andusage.  For more information, including an API reference and developmentinformation, please see the `online documentation`_... contents:: **Table of Contents**   :local:   :backlinks: noneLicense-------Copyright 2012-2019 Johns Hopkins University HLTCOE. All rightsreserved.  This software is released under the 2-clause BSD license.Please see LICENSE_ for more information.Requirements------------concrete-python is tested on Python 3.5 and requires theThrift Python library, among other Python libraries.  These areinstalled automatically by ``setup.py`` or ``pip``.  The Thriftcompiler is *not* required.**Note**: The accelerated protocol offers a (de)serialization speedupof 10x or more; if you would like to use it, ensure a C++ compiler isavailable on your system before installing concrete-python.(If a compiler is not available, concrete-python will fall back to theunaccelerated protocol automatically.)  If you are on Linux, a suitableC++ compiler will be listed as ``g++`` or ``gcc-c++`` in your packagemanager.If you are using macOS Mojave with the Homebrew package manager(https://brew.sh), you can install the accelerated protocol usingthe script ``install-mojave-homebrew-accelerated-thrift.sh``.Installation------------You can install Concrete using the ``pip`` package manager::    pip install concreteor by cloning the repository and running ``setup.py``::    git clone https://github.com/hltcoe/concrete-python.git    cd concrete-python    python setup.py installBasic usage-----------Here and in the following sections we make use of an example ConcreteCommunication file included in the concrete-python source distribution.The *Communication* type represents an article, book, post, Tweet, orany other kind of document that we might want to store and analyze.Copy it from ``tests/testdata/serif_dog-bites-man.concrete`` if youhave the concrete-python source distribution or download itseparately here: serif_dog-bites-man.concrete_.First we use the ``concrete-inspect.py`` tool (explained in more detailin the following section) to inspect some of the contents of theCommunication::    concrete-inspect.py --text serif_dog-bites-man.concreteThis command prints the text of the Communication to the console.  Inour case the text is a short article formatted in SGML::    &lt;DOC id=&quot;dog-bites-man&quot; type=&quot;other&quot;&gt;    &lt;HEADLINE&gt;    Dog Bites Man    &lt;/HEADLINE&gt;    &lt;TEXT&gt;    &lt;P&gt;    John Smith, manager of ACMÉ INC, was bit by a dog on March 10th, 2013.    &lt;/P&gt;    &lt;P&gt;    He died!    &lt;/P&gt;    &lt;P&gt;    John's daughter Mary expressed sorrow.    &lt;/P&gt;    &lt;/TEXT&gt;    &lt;/DOC&gt;Now run the following command to inspect some of the annotations storedin that Communication::    concrete-inspect.py --ner --pos --dependency serif_dog-bites-man.concreteThis command shows a tokenization, part-of-speech tagging, named entitytagging, and dependency parse in a CoNLL_-like columnar format::    INDEXTOKENPOSNERHEADDEPREL    --------------------------    1JohnNNPPER2compound    2SmithNNPPER10nsubjpass    3,,    4managerNN2appos    5ofIN7case    6ACMÉNNPORG7compound    7INCNNPORG4nmod    8,,    9wasVBD10auxpass    10bitNN0ROOT    11byIN13case    12aDT13det    13dogNN10nmod    14onIN15case    15MarchDATE-NNP13nmod    1610thJJ15amod    17,,    182013CD13amod    19..    1HePRP2nsubj    2diedVBD0ROOT    3!.    1JohnNNPPER3nmod:poss    2'sPOS1case    3daughterNN5dep    4MaryNNPPER5nsubj    5expressedVBD0ROOT    6sorrowNN5dobj    7..Reading Concrete~~~~~~~~~~~~~~~~There are even more annotations stored in this Communication, but fornow we move on to demonstrate handling of the Communication in Python.The example file contains a single Communication, but many (ifnot most) files contain several.  The same code can be used to readCommunications in a regular file, tar archive, or ziparchive::    from concrete.util import CommunicationReader    for (comm, filename) in CommunicationReader('serif_dog-bites-man.concrete'):        print(comm.id)        print()        print(comm.text)This loop prints the unique ID and text (the same text we sawbefore) of our one Communication::    tests/testdata/serif_dog-bites-man.xml    &lt;DOC id=&quot;dog-bites-man&quot; type=&quot;other&quot;&gt;    &lt;HEADLINE&gt;    Dog Bites Man    &lt;/HEADLINE&gt;    &lt;TEXT&gt;    &lt;P&gt;    John Smith, manager of ACMÉ INC, was bit by a dog on March 10th, 2013.    &lt;/P&gt;    &lt;P&gt;    He died!    &lt;/P&gt;    &lt;P&gt;    John's daughter Mary expressed sorrow.    &lt;/P&gt;    &lt;/TEXT&gt;    &lt;/DOC&gt;In addition to the general-purpose ``CommunicationReader`` there is aconvenience function for reading a single Communication from a regularfile::    from concrete.util import read_communication_from_file    comm = read_communication_from_file('serif_dog-bites-man.concrete')Communications are broken into *Sections*, which are in turn brokeninto *Sentences*, which are in turn broken into *Tokens* (and that'sonly scratching the surface).  To traverse this decomposition::    from concrete.util import lun, get_tokens    for section in lun(comm.sectionList):        print('* section')        for sentence in lun(section.sentenceList):            print('  + sentence')            for token in get_tokens(sentence.tokenization):                print('    - ' + token.text)The output is::    * section    * section      + sentence        - John        - Smith        - ,        - manager        - of        - ACMÉ        - INC        - ,        - was        - bit        - by        - a        - dog        - on        - March        - 10th        - ,        - 2013        - .    * section      + sentence        - He        - died        - !    * section      + sentence        - John        - 's        - daughter        - Mary        - expressed        - sorrow        - .Here we used ``get_tokens``, which abstracts the process of extractinga sequence of *Tokens* from a *Tokenization*, and ``lun``, whichreturns its argument or (if its argument is ``None``) an empty listand stands for &quot;list un-none&quot;.  Many fields in Concrete are optional,including ``Communication.sectionList`` and ``Section.sentenceList``;checking for ``None`` quickly becomes tedious.In this Communication the tokens have been annotated withpart-of-speech tags, as we saw previously using``concrete-inspect.py``.  We can print them with the following code::    from concrete.util import get_tagged_tokens    for section in lun(comm.sectionList):        print('* section')        for sentence in lun(section.sentenceList):            print('  + sentence')            for token_tag in get_tagged_tokens(sentence.tokenization, 'POS'):                print('    - ' + token_tag.tag)The output is::    * section    * section      + sentence        - NNP        - NNP        - ,        - NN        - IN        - NNP        - NNP        - ,        - VBD        - NN        - IN        - DT        - NN        - IN        - DATE-NNP        - JJ        - ,        - CD        - .    * section      + sentence        - PRP        - VBD        - .    * section      + sentence        - NNP        - POS        - NN        - NNP        - VBD        - NN        - .Writing Concrete~~~~~~~~~~~~~~~~We can add a new part-of-speech tagging to the Communication as well.Let's add a simplified version of the current tagging::    from concrete.util import AnalyticUUIDGeneratorFactory, now_timestamp    from concrete import TokenTagging, TaggedToken, AnnotationMetadata    augf = AnalyticUUIDGeneratorFactory(comm)    aug = augf.create()    for section in lun(comm.sectionList):        for sentence in lun(section.sentenceList):            sentence.tokenization.tokenTaggingList.append(TokenTagging(                uuid=aug.next(),                metadata=AnnotationMetadata(                    tool='Simple POS',                    timestamp=now_timestamp(),                    kBest=1                ),                taggingType='POS',                taggedTokenList=[                    TaggedToken(                        tokenIndex=original.tokenIndex,                        tag=original.tag.split('-')[-1][:2],                    )                    for original                    in get_tagged_tokens(sentence.tokenization, 'POS')                ]            ))Here we used ``AnalyticUUIDGeneratorFactory``, which creates generators ofConcrete *UUID* objects (see `Working with UUIDs`_ for more information).We also used ``now_timestamp``, which returns a Concrete timestamp representingthe current time.  But now how do we know which tagging is ours?  Eachannotation's metadata contains a *tool* name, and we can use it todistinguish between competing annotations::    from concrete.util import get_tagged_tokens    for section in lun(comm.sectionList):        print('* section')        for sentence in lun(section.sentenceList):            print('  + sentence')            token_tag_pairs = zip(                get_tagged_tokens(sentence.tokenization, 'POS', tool='Serif: part-of-speech'),                get_tagged_tokens(sentence.tokenization, 'POS', tool='Simple POS')            )            for (old_tag, new_tag) in token_tag_pairs:                print('    - ' + old_tag.tag + ' -&gt; ' + new_tag.tag)The output shows our new part-of-speech tagging has a smaller, simplerset of possible values::    * section    * section      + sentence        - NNP -&gt; NN        - NNP -&gt; NN        - , -&gt; ,        - NN -&gt; NN        - IN -&gt; IN        - NNP -&gt; NN        - NNP -&gt; NN        - , -&gt; ,        - VBD -&gt; VB        - NN -&gt; NN        - IN -&gt; IN        - DT -&gt; DT        - NN -&gt; NN        - IN -&gt; IN        - DATE-NNP -&gt; NN        - JJ -&gt; JJ        - , -&gt; ,        - CD -&gt; CD        - . -&gt; .    * section      + sentence        - PRP -&gt; PR        - VBD -&gt; VB        - . -&gt; .    * section      + sentence        - NNP -&gt; NN        - POS -&gt; PO        - NN -&gt; NN        - NNP -&gt; NN        - VBD -&gt; VB        - NN -&gt; NN        - . -&gt; .Finally, let's write our newly annotated Communication back to disk::    from concrete.util import CommunicationWriter    with CommunicationWriter('serif_dog-bites-man.concrete') as writer:        writer.write(comm)Note there are many other useful classes and functions in the``concrete.util`` library.  See the API reference in the`online documentation`_ for details.concrete-inspect.py-------------------Use ``concrete-inspect.py`` to quickly explore the contents of aCommunication from the command line.  ``concrete-inspect.py`` and otherscripts are installed to the path along with the concrete-pythonlibrary.--id~~~~Run the following command to print the unique ID of our modifiedexample Communication::    concrete-inspect.py --id serif_dog-bites-man.concreteOutput::    tests/testdata/serif_dog-bites-man.xml--metadata~~~~~~~~~~Use ``--metadata`` to print the stored annotations along with theirtool names::    concrete-inspect.py --metadata serif_dog-bites-man.concreteOutput::    Communication:  concrete_serif v3.10.1pre      Tokenization:  Serif: tokens        Dependency Parse:  Stanford        Parse:  Serif: parse        TokenTagging:  Serif: names        TokenTagging:  Serif: part-of-speech        TokenTagging:  Simple POS      EntityMentionSet #0:  Serif: names      EntityMentionSet #1:  Serif: values      EntityMentionSet #2:  Serif: mentions      EntitySet #0:  Serif: doc-entities      EntitySet #1:  Serif: doc-values      SituationMentionSet #0:  Serif: relations      SituationMentionSet #1:  Serif: events      SituationSet #0:  Serif: relations      SituationSet #1:  Serif: events      CommunicationTagging:  lda      CommunicationTagging:  urgency--sections~~~~~~~~~~Use ``--sections`` to print the text of the Communication, broken outby section::    concrete-inspect.py --sections serif_dog-bites-man.concreteOutput::    Section 0 (0ab68635-c83d-4b02-b8c3-288626968e05)[kind: SectionKind.PASSAGE], from 81 to 82:    Section 1 (54902d75-1841-4d8d-b4c5-390d4ef1a47a)[kind: SectionKind.PASSAGE], from 85 to 162:    John Smith, manager of ACMÉ INC, was bit by a dog on March 10th, 2013.    &lt;/P&gt;    Section 2 (7ec8b7d9-6be0-4c62-af57-3c6c48bad711)[kind: SectionKind.PASSAGE], from 165 to 180:    He died!    &lt;/P&gt;    Section 3 (68da91a1-5beb-4129-943d-170c40c7d0f7)[kind: SectionKind.PASSAGE], from 183 to 228:    John's daughter Mary expressed sorrow.    &lt;/P&gt;--entities~~~~~~~~~~Use ``--entities`` to print the named entities detected in theCommunication::    concrete-inspect.py --entities serif_dog-bites-man.concreteOutput::    Entity Set 0 (Serif: doc-entities):      Entity 0-0:          EntityMention 0-0-0:              tokens:     John Smith              text:       John Smith              entityType: PER              phraseType: PhraseType.NAME          EntityMention 0-0-1:              tokens:     John Smith , manager of ACMÉ INC ,              text:       John Smith, manager of ACMÉ INC,              entityType: PER              phraseType: PhraseType.APPOSITIVE              child EntityMention #0:                  tokens:     John Smith                  text:       John Smith                  entityType: PER                  phraseType: PhraseType.NAME              child EntityMention #1:                  tokens:     manager of ACMÉ INC                  text:       manager of ACMÉ INC                  entityType: PER                  phraseType: PhraseType.COMMON_NOUN          EntityMention 0-0-2:              tokens:     manager of ACMÉ INC              text:       manager of ACMÉ INC              entityType: PER              phraseType: PhraseType.COMMON_NOUN          EntityMention 0-0-3:              tokens:     He              text:       He              entityType: PER              phraseType: PhraseType.PRONOUN          EntityMention 0-0-4:              tokens:     John              text:       John              entityType: PER.Individual              phraseType: PhraseType.NAME      Entity 0-1:          EntityMention 0-1-0:              tokens:     ACMÉ INC              text:       ACMÉ INC              entityType: ORG              phraseType: PhraseType.NAME      Entity 0-2:          EntityMention 0-2-0:              tokens:     John 's daughter Mary              text:       John's daughter Mary              entityType: PER.Individual              phraseType: PhraseType.NAME              child EntityMention #0:                  tokens:     Mary                  text:       Mary                  entityType: PER                  phraseType: PhraseType.OTHER          EntityMention 0-2-1:              tokens:     daughter              text:       daughter              entityType: PER              phraseType: PhraseType.COMMON_NOUN    Entity Set 1 (Serif: doc-values):      Entity 1-0:          EntityMention 1-0-0:              tokens:     March 10th , 2013              text:       March 10th, 2013              entityType: TIMEX2.TIME              phraseType: PhraseType.OTHER--mentions~~~~~~~~~~Use ``--mentions`` to show the named entity *mentions* in theCommunication, annotated on the text::    concrete-inspect.py --mentions serif_dog-bites-man.concreteOutput::    &lt;ENTITY ID=0&gt;&lt;ENTITY ID=0&gt;John Smith&lt;/ENTITY&gt; , &lt;ENTITY ID=0&gt;manager of &lt;ENTITY ID=1&gt;ACMÉ INC&lt;/ENTITY&gt;&lt;/ENTITY&gt; ,&lt;/ENTITY&gt; was bit by a dog on &lt;ENTITY ID=3&gt;March 10th , 2013&lt;/ENTITY&gt; .    &lt;ENTITY ID=0&gt;He&lt;/ENTITY&gt; died !    &lt;ENTITY ID=2&gt;&lt;ENTITY ID=0&gt;John&lt;/ENTITY&gt; 's &lt;ENTITY ID=2&gt;daughter&lt;/ENTITY&gt; Mary&lt;/ENTITY&gt; expressed sorrow .--situations~~~~~~~~~~~~Use ``--situations`` to show the situations detected in theCommunication::    concrete-inspect.py --situations serif_dog-bites-man.concreteOutput::    Situation Set 0 (Serif: relations):    Situation Set 1 (Serif: events):      Situation 1-0:          situationType:    Life.Die--treebank~~~~~~~~~~Use ``--treebank`` to show constituency parse trees of the sentences inthe Communication::    concrete-inspect.py --treebank serif_dog-bites-man.concreteOutput::    (S (NP (NPP (NNP john)                (NNP smith))           (, ,)           (NP (NPA (NN manager))               (PP (IN of)                   (NPP (NNP acme)                        (NNP inc))))           (, ,))       (VP (VBD was)           (NP (NPA (NN bit))               (PP (IN by)                   (NP (NPA (DT a)                            (NN dog))                       (PP (IN on)                           (NP (DATE (DATE-NNP march)                                     (JJ 10th))                               (, ,)                               (NPA (CD 2013))))))))       (. .))    (S (NPA (PRP he))       (VP (VBD died))       (. !))    (S (NPA (NPPOS (NPP (NNP john))                   (POS 's))            (NN daughter)            (NPP (NNP mary)))       (VP (VBD expressed)           (NPA (NN sorrow)))       (. .))Other options~~~~~~~~~~~~~Use ``--ner``, ``--pos``, ``--lemmas``, and ``--dependency`` (togetheror independently) to show respective token-level information in aCoNLL-like format, and use ``--text`` to print the text of theCommunication, as described in a previous section.Run ``concrete-inspect.py --help`` to show a detailed help messageexplaining the options discussed above and others.  Allconcrete-python scripts have such help messages.create-comm.py--------------Use ``create-comm.py`` to generate a simple Communication from a textfile.  For example, create a file called ``history-of-the-world.txt``containing the following text::    The dog ran .    The cat jumped .    The dolphin teleported .Then run the following command to convert it to a ConcreteCommunication, creating Sections, Sentences, and Tokens based onwhitespace::    create-comm.py --annotation-level token history-of-the-world.txt history-of-the-world.concreteUse ``concrete-inspect.py`` as shown previously to verify thestructure of the Communication::    concrete-inspect.py --sections history-of-the-world.concreteOutput::    Section 0 (a188dcdd-1ade-be5d-41c4-fd4d81f71685)[kind: passage], from 0 to 30:    The dog ran .    The cat jumped .    Section 1 (a188dcdd-1ade-be5d-41c4-fd4d81f7168a)[kind: passage], from 32 to 57:    The dolphin teleported .Other scripts-------------concrete-python provides a number of other scripts, including but notlimited to:``concrete2json.py``    reads in a Concrete Communication and prints a    JSON version of the Communication to stdout.  The JSON is &quot;pretty    printed&quot; with indentation and whitespace, which makes the JSON    easier to read and to use for diffs.``create-comm-tarball.py``    like ``create-comm.py`` but for multiple files: reads in a tar.gz    archive of text files, parses them into sections and sentences based    on whitespace, and writes them back out as Concrete Communications    in another tar.gz archive.``fetch-client.py``    connects to a FetchCommunicationService, retrieves one or more    Communications (as specified on the command line), and writes them    to disk.``fetch-server.py``    implements FetchCommunicationService, serving Communications to    clients from a file or directory of Communications on disk.``search-client.py``    connects to a SearchService, reading queries from the console and    printing out results as Communication ids in a loop.``validate-communication.py``    reads in a Concrete Communication file and prints out information    about any invalid fields.  This script is a command-line wrapper    around the functionality in the ``concrete.validate`` library.Use the ``--help`` flag for details about the scripts' command linearguments.Working with UUIDs------------------Each *UUID* object contains a single string,``uuidString``, which can be used as a universally unique identifier for theobject the *UUID* is attached to.  The ``AnalyticUUIDGeneratorFactory`` produces*UUID* generators for a *Communication,* one for each analytic (tool) used toprocess the *Communication.*  In contrast to the Python ``uuid`` library, the``AnalyticUUIDGeneratorFactory`` yields UUIDs that have common prefixes within a*Communication* and within annotations produced by the same analytic, enablingcommon compression algorithms to much more efficiently store the UUIDs in each*Communication.*  See the ``AnalyticUUIDGeneratorFactory`` class in the APIreference in the `online documentation`_ for more information.Note that ``uuidString`` is generated bya random process, so running the same code twice will result in twocompletely different sets of identifiers.  Concretely, if you run a parser toproduce a part-of-speech *TokenTagging* for each *Tokenization* in a*Communication,* save the modified *Communication,* then run the parser again onthe same original *Communication,* you will get two different identifiers foreach *TokenTagging,* even though the contents of each pair of*TokenTaggings*---the part-of-speech tags---may be the identical.Validating Concrete Communications----------------------------------The Python version of the Thrift Libraries does not perform anyvalidation of Thrift objects.  You should use the``validate_communication()`` function after reading and before writinga Concrete Communication::    from concrete.util import read_communication_from_file    from concrete.validate import validate_communication    comm = read_communication_from_file('tests/testdata/serif_dog-bites-man.concrete')    # Returns True|False, logs details using Python stdlib 'logging' module    validate_communication(comm)Thrift fields have three levels of requiredness:* explicitly labeled as **required*** explicitly labeled as **optional*** no requiredness label given (&quot;default required&quot;)Other Concrete tools will raise an exception if a **required** field ismissing on deserialization or serialization, and will raise anexception if a &quot;default required&quot; field is missing on serialization.By default, concrete-python does not perform any validation of Thriftobjects on serialization or deserialization.  The Python Thrift classesdo provide shallow ``validate()`` methods, but they only check forexplicitly **required** fields (not &quot;default required&quot; fields) and donot validate nested objects.The ``validate_communication()`` function recursively checks aCommunication object for required fields, plus additional checks forUUID mismatches... _Concrete: http://hltcoe.github.io/concrete/.. _`online documentation`: http://hltcoe.github.io/concrete-python/.. _`Apache Thrift`: http://thrift.apache.org.. _`Concrete GitHub repository`: https://github.com/hltcoe/concrete.. _serif_dog-bites-man.concrete: https://github.com/hltcoe/concrete-python/raw/main/tests/testdata/serif_dog-bites-man.concrete.. _CoNLL: http://ufal.mff.cuni.cz/conll2009-st/task-description.html.. _LICENSE: https://github.com/hltcoe/concrete-python/blob/main/LICENSE</longdescription>
</pkgmetadata>