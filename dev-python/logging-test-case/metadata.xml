<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>logging-test-case=================Production systems rely heavily upon logging. Unit tests should verifylogs are correct. ``unittest.assertLogs()`` allows developers to verifylogs are correct. Including this context manager in every test casebecomes tiresome. Also, if the test fails, the logs are not displayed.This project provides the function decorator ``@capturelogs``.``@capturelogs`` is similar to ``unittest.assertLogs()``, but it is afunction decorator, reducing the clutter inside the test function.This project provides the class ``LoggingTestCase``, which inherits from``unittest.TestCase``. For every test run, logs are automaticallycaptured to ``self.captured_logs``. If the test fails, the contents of``self.captured_logs`` are written to the test output for easydebugging.  ``LoggingTestCase`` provides context manager ``assertNoLogs``to verify no logs were emitted within the context.-  Use ``@capturelogs`` if only a few tests involve log files.-  Use ``LoggingTestCase`` if most of the tests involve logs. This   avoids putting a function decorator for each function.Installation============This package is at pypi at:https://pypi.python.org/pypi/logging-test-caseTo install using pip:``pip install logging-test-case``Requirements============-  Python 3.4 or higher.@capturelogs============``capturelogs(logger=None, level=None, display_logs=DisplayLogs.FAILURE, assert_no_logs=False)``* logger: Name of logger, or an actual logger. Defaults to root logger.* level: Log level as a text string. Defaults to 'INFO'.* display_logs: Determines when to display logs    - DisplayLogs.NEVER: Never display the logs. The logs will always be discarded.        + This is the current behavior of ``unittest.assertLogs()``.    - DisplayLogs.FAILURE: Display the logs only if the test case fails. (default)        + This can be useful for debugging test failures because the logs are still written out.    - DisplayLogs.ALWAYS: Always displays the logs - pass or fail.        + This can be useful when manually running the tests and the developer wants to visually inspect the logging output.* assert_no_logs: If True, raise an AssertionError if any logs are emitted.Examples are located at: ``examples/capturelogs_example.py``unittest.assertLogs example---------------------------::    class CaptureLogsExample(unittest.TestCase):        def test_assert_logs(self):            &quot;&quot;&quot;Verify logs using built-in self.assertLogs().&quot;&quot;&quot;            with self.assertLogs('foo', level='INFO') as logs:                logging.getLogger('foo').info('first message')                logging.getLogger('foo.bar').error('second message')            self.assertEqual(logs.output, ['INFO:foo:first message',                                           'ERROR:foo.bar:second message'])@capturelogs example--------------------::    import unittest    import logging    import loggingtestcase    class CaptureLogsExample(unittest.TestCase):        @loggingtestcase.capturelogs('foo', level='INFO')        def test_capture_logs(self, logs):            &quot;&quot;&quot;Verify logs using @capturelogs decorator.&quot;&quot;&quot;            logging.getLogger('foo').info('first message')            logging.getLogger('foo.bar').error('second message')            self.assertEqual(logs.output, ['INFO:foo:first message',                                           'ERROR:foo.bar:second message'])In the above example, there is less clutter and indenting inside of thetest function. For this simple example, it doesn't matter. But if thetest involves multiple patches and ``self.assertRaises`` and many othercontext managers, the function becomes crowded very quickly. The``@capturelogs`` function decorator allows the developer to reduce thecontents and indent level inside of the function.@capturelogs display example----------------------------::    import unittest    import logging    import loggingtestcase    class CaptureLogsExample(unittest.TestCase):        @loggingtestcase.capturelogs('foo', level='INFO',                                     display_logs=loggingtestcase.DisplayLogs.ALWAYS)        def test_always_display_logs(self, logs):            &quot;&quot;&quot;The logs are always written to the original handler(s).&quot;&quot;&quot;            logging.getLogger('foo').info('first message')            self.assertTrue(False)            self.assertEqual(logs.output, ['INFO:foo:first message'])In the above example, the test fails, the logs are be displayed.@capturelogs assert_no_logs example-----------------------------------::    import unittest    import logging    import loggingtestcase    class CaptureLogsExample(unittest.TestCase):        @loggingtestcase.capturelogs('foo', level='INFO', assert_no_logs=True)        def test_assert_no_logs(self, logs):            &quot;&quot;&quot;This test fails because logs are emitted.            Output::                AssertionError: In test_assert_no_logs(), the follow messages were unexpectedly logged:                    INFO:foo:first message                    ERROR:foo.bar:second message            &quot;&quot;&quot;            logging.getLogger('foo').info('first message')            logging.getLogger('foo.bar').error('second message')LoggingTestCase Examples========================Example1--------``examples/loggingtestcase_example.py``::    import unittest    import logging    import loggingtestcase    class LoggingTestCaseExample(loggingtestcase.LoggingTestCase):        def __init__(self, methodName='runTest', testlogger=None, testlevel=None):            &quot;&quot;&quot;            To change the logger or log level, override __init__.            By default, the root logger is used and the log level is logging.INFO.            &quot;&quot;&quot;            # testlevel = logging.ERROR            super().__init__(methodName, testlogger, testlevel)        def setUp(self):            self.logger = logging.getLogger(__name__)            pass        def test_pass(self):            &quot;&quot;&quot;            Run a test that logs an info message and            verify the info is correctly logged.            Notice that the info message is not logged to the console.            When all your tests pass, your console output is nice and clean.            &quot;&quot;&quot;            self.logger.info(&quot;Starting request...&quot;)            self.logger.info(&quot;Done with request.&quot;)            self.assertListEqual(self.captured_logs.output,                                 ['INFO:examples.loggingtestcase_example:Starting request...',                                  'INFO:examples.loggingtestcase_example:Done with request.'])        def test_fail(self):            &quot;&quot;&quot;            Run a test that fails.            Notice that the error message is logged to the console.            This allows for easier debugging.            Here is the output:            ======================================================================            ERROR: test_fail (examples.example1.Example1)            ----------------------------------------------------------------------            Traceback (most recent call last):              File &quot;D:\Git\logging-test-case\examples\loggingtestcase_example.py.py&quot;, line 61,              in test_fail raise FileNotFoundError(&quot;Failed to open file.&quot;)            FileNotFoundError: Failed to open file.            ERROR:examples.example1:Failed to open file.            ----------------------------------------------------------------------            &quot;&quot;&quot;            self.logger.error(&quot;Failed to open file.&quot;)            raise FileNotFoundError(&quot;Failed to open file.&quot;)    if __name__ == &quot;__main__&quot;:        unittest.main()In the above example, notice how ``test_pass()`` and ``test_fail()`` donot have any function decorators or context managers. The captured logsare automatically available in ``self.captured_logs.output``.Example2 - assertNoLogs-----------------------``examples/assertnologs_example1.py``::    import unittest    import logging    import loggingtestcase    class AssertNoLogsExample(loggingtestcase.LoggingTestCase):        &quot;&quot;&quot;Example on how to use LoggingTestCase and no logging.&quot;&quot;&quot;        def __init__(self, methodName='runTest', testlogger=None, testlevel=None):            &quot;&quot;&quot;            To change the logger or log level, override __init__.            By default, the root logger is used and the log level is logging.INFO.            &quot;&quot;&quot;            # testlevel = logging.ERROR            super().__init__(methodName, testlogger, testlevel)        def setUp(self):            self.logger = logging.getLogger(__name__)        def test_assert_no_logs_fail(self):            &quot;&quot;&quot;The test fails because logs are emitted.            Here is the output:            E               AssertionError: The follow messages were unexpectedly logged:            E                   ERROR:examples.assertnologs_example1:first message            E                   ERROR:examples.assertnologs_example1:second message            &quot;&quot;&quot;            with self.assertNoLogs():                self.logger.error('first message')                self.logger.error('second message')        def test_assert_no_logs_pass(self):            &quot;&quot;&quot;The test passes because no logs are emitted inside the context manager.&quot;&quot;&quot;            self.logger.error('first message')            with self.assertNoLogs():                pass            self.logger.error('second message')    if __name__ == &quot;__main__&quot;:        unittest.main()Changelog=========release-1.4.1-------------* Fixed example in ``README.rst``.  Thanks to julianstirling!release-1.4-----------* Added support for verifying no logs are emitted during a test.    - Added method ``assertNoLogs()`` to class ``LoggingTestCase``.    - Added parameter ``assert_no_logs`` to function decorator ``capturelogs``.release-1.3-----------* Support for Python 3.4, 3.5, and 3.6.    -  Previously only Python 3.6 worked.* Support for pytest.    - Previously only unittest worked.  Now both unittest and pytest work.Thanks to jayvdb on GitHub for providing both fixes!release-1.2-----------Fixed the following error on Python &lt; 3.6:::    /usr/local/lib/python3.5/dist-packages/loggingtestcase/capturelogs.py:31: in &lt;module&gt;        from enum import Enum, auto    E   ImportError: cannot import name 'auto'This is because ``enum.auto()`` is new in Python 3.6.  To preserve backward compatibility,``auto()`` is no longer used.release-1.1.2-------------Added ``README.rst`` so this readme shows up on PyPI.release-1.1-----------Added ``@capturelogs``.release-1.0-----------Added ``LoggingTestCase``.Tests=====Manual Tests------------``tests/manual.py``~~~~~~~~~~~~~~~~~~~Run this file manually. All the tests are commented out. Uncomment andrun each test one at a time. Verify the console output.This module is not named ``manual_test.py`` because these tests are notmeant to be run automatically.Automated Tests---------------To run all the tests from the command line, simply use pytest:::    pytesttests/loggingtestcase\_test.py~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~This module tests class ``LoggingTestCase``. It uses``subprocess.check_output`` to run each test case one at a time,capturing the output. The output is examined to verify it is correct.``loggingtestcase_test.py`` run tests in module``simpleloggingtests.py``.Even though automated tests are included, it is still a good idea to runthe manual tests and visually look at the output of each test case.tests/assertnologs\_test.py~~~~~~~~~~~~~~~~~~~~~~~~~~~Tests context manager ``assertNoLogs`` in class ``LoggingTestCase``.tests/capturelogs\_test.py~~~~~~~~~~~~~~~~~~~~~~~~~~This module tests ``@capturelogs``, defined in``loggingtestcase/capturelogs.py``.</longdescription>
</pkgmetadata>