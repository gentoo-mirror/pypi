<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Thread-pool Controls [![Build Status](https://dev.azure.com/joblib/threadpoolctl/_apis/build/status/joblib.threadpoolctl?branchName=master)](https://dev.azure.com/joblib/threadpoolctl/_build/latest?definitionId=1&amp;branchName=master) [![codecov](https://codecov.io/gh/joblib/threadpoolctl/branch/master/graph/badge.svg)](https://codecov.io/gh/joblib/threadpoolctl)Python helpers to limit the number of threads used in thethreadpool-backed of common native libraries used for scientificcomputing and data science (e.g. BLAS and OpenMP).Fine control of the underlying thread-pool size can be useful inworkloads that involve nested parallelism so as to mitigateoversubscription issues.## Installation- For users, install the last published version from PyPI:  ```bash  pip install threadpoolctl  ```- For contributors, install from the source repository in developer  mode:  ```bash  pip install -r dev-requirements.txt  flit install --symlink  ```  then you run the tests with pytest:  ```bash  pytest  ```## Usage### Command Line InterfaceGet a JSON description of thread-pools initialized when importing pythonpackages such as numpy or scipy for instance:```python -m threadpoolctl -i numpy scipy.linalg[  {    &quot;filepath&quot;: &quot;/home/ogrisel/miniconda3/envs/tmp/lib/libmkl_rt.so&quot;,    &quot;prefix&quot;: &quot;libmkl_rt&quot;,    &quot;user_api&quot;: &quot;blas&quot;,    &quot;internal_api&quot;: &quot;mkl&quot;,    &quot;version&quot;: &quot;2019.0.4&quot;,    &quot;num_threads&quot;: 2,    &quot;threading_layer&quot;: &quot;intel&quot;  },  {    &quot;filepath&quot;: &quot;/home/ogrisel/miniconda3/envs/tmp/lib/libiomp5.so&quot;,    &quot;prefix&quot;: &quot;libiomp&quot;,    &quot;user_api&quot;: &quot;openmp&quot;,    &quot;internal_api&quot;: &quot;openmp&quot;,    &quot;version&quot;: null,    &quot;num_threads&quot;: 4  }]```The JSON information is written on STDOUT. If some of the packages are missing,a warning message is displayed on STDERR.### Python Runtime Programmatic IntrospectionIntrospect the current state of the threadpool-enabled runtime librariesthat are loaded when importing Python packages:```python&gt;&gt;&gt; from threadpoolctl import threadpool_info&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt; pprint(threadpool_info())[]&gt;&gt;&gt; import numpy&gt;&gt;&gt; pprint(threadpool_info())[{'filepath': '/home/ogrisel/miniconda3/envs/tmp/lib/libmkl_rt.so',  'internal_api': 'mkl',  'num_threads': 2,  'prefix': 'libmkl_rt',  'threading_layer': 'intel',  'user_api': 'blas',  'version': '2019.0.4'}, {'filepath': '/home/ogrisel/miniconda3/envs/tmp/lib/libiomp5.so',  'internal_api': 'openmp',  'num_threads': 4,  'prefix': 'libiomp',  'user_api': 'openmp',  'version': None}]&gt;&gt;&gt; import xgboost&gt;&gt;&gt; pprint(threadpool_info())[{'filepath': '/home/ogrisel/miniconda3/envs/tmp/lib/libmkl_rt.so',  'internal_api': 'mkl',  'num_threads': 2,  'prefix': 'libmkl_rt',  'threading_layer': 'intel',  'user_api': 'blas',  'version': '2019.0.4'}, {'filepath': '/home/ogrisel/miniconda3/envs/tmp/lib/libiomp5.so',  'internal_api': 'openmp',  'num_threads': 4,  'prefix': 'libiomp',  'user_api': 'openmp',  'version': None}, {'filepath': '/home/ogrisel/miniconda3/envs/tmp/lib/libgomp.so.1.0.0',  'internal_api': 'openmp',  'num_threads': 4,  'prefix': 'libgomp',  'user_api': 'openmp',  'version': None}]```In the above example, `numpy` was installed from the default anaconda channel and comeswith MKL and its Intel OpenMP (`libiomp5`) implementation while `xgboost` was installedfrom pypi.org and links against GNU OpenMP (`libgomp`) so both OpenMP runtimes areloaded in the same Python program.The state of these libraries is also accessible through the object oriented API:```python&gt;&gt;&gt; from threadpoolctl import ThreadpoolController, threadpool_info&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt; import numpy&gt;&gt;&gt; controller = ThreadpoolController()&gt;&gt;&gt; pprint(controller.info())[{'architecture': 'Haswell',  'filepath': '/home/jeremie/miniconda/envs/dev/lib/libopenblasp-r0.3.17.so',  'internal_api': 'openblas',  'num_threads': 4,  'prefix': 'libopenblas',  'threading_layer': 'pthreads',  'user_api': 'blas',  'version': '0.3.17'}]&gt;&gt;&gt; controller.info() == threadpool_info()True```### Setting the Maximum Size of Thread-PoolsControl the number of threads used by the underlying runtime librariesin specific sections of your Python program:```python&gt;&gt;&gt; from threadpoolctl import threadpool_limits&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; with threadpool_limits(limits=1, user_api='blas'):...     # In this block, calls to blas implementation (like openblas or MKL)...     # will be limited to use only one thread. They can thus be used jointly...     # with thread-parallelism....     a = np.random.randn(1000, 1000)...     a_squared = a @ a```The threadpools can also be controlled via the object oriented API, which is especiallyuseful to avoid searching through all the loaded shared libraries each time. It willhowever not act on libraries loaded after the instantiation of the`ThreadpoolController`:```python&gt;&gt;&gt; from threadpoolctl import ThreadpoolController&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; controller = ThreadpoolController()&gt;&gt;&gt; with controller.limit(limits=1, user_api='blas'):...     a = np.random.randn(1000, 1000)...     a_squared = a @ a```### Restricting the limits to the scope of a function`threadpool_limits` and `ThreadpoolController` can also be used as decorators to setthe maximum number of threads used by the supported libraries at a function level. Thedecorators are accessible through their `wrap` method:```python&gt;&gt;&gt; from threadpoolctl import ThreadpoolController, threadpool_limits&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; controller = ThreadpoolController()&gt;&gt;&gt; @controller.wrap(limits=1, user_api='blas')... # or @threadpool_limits.wrap(limits=1, user_api='blas')... def my_func():...     # Inside this function, calls to blas implementation (like openblas or MKL)...     # will be limited to use only one thread....     a = np.random.randn(1000, 1000)...     a_squared = a @ a...```### Sequential BLAS within OpenMP parallel regionWhen one wants to have sequential BLAS calls within an OpenMP parallel region, it'ssafer to set `limits=&quot;sequential_blas_under_openmp&quot;` since setting `limits=1` and `user_api=&quot;blas&quot;` might not lead to the expected behavior in some configurations(e.g. OpenBLAS with the OpenMP threading layerhttps://github.com/xianyi/OpenBLAS/issues/2985).### Known Limitations- `threadpool_limits` can fail to limit the number of inner threads when nesting  parallel loops managed by distinct OpenMP runtime implementations (for instance  libgomp from GCC and libomp from clang/llvm or libiomp from ICC).  See the `test_openmp_nesting` function in [tests/test_threadpoolctl.py](  https://github.com/joblib/threadpoolctl/blob/master/tests/test_threadpoolctl.py)  for an example. More information can be found at:  https://github.com/jeremiedbb/Nested_OpenMP  Note however that this problem does not happen when `threadpool_limits` is  used to limit the number of threads used internally by BLAS calls that are  themselves nested under OpenMP parallel loops. `threadpool_limits` works as  expected, even if the inner BLAS implementation relies on a distinct OpenMP  implementation.- Using Intel OpenMP (ICC) and LLVM OpenMP (clang) in the same Python program  under Linux is known to cause problems. See the following guide for more details  and workarounds:  https://github.com/joblib/threadpoolctl/blob/master/multiple_openmp.md- Setting the maximum number of threads of the OpenMP and BLAS libraries has a global  effect and impacts the whole Python process. There is no thread level isolation as  these libraries do not offer thread-local APIs to configure the number of threads to  use in nested parallel calls.## MaintainersTo make a release:Bump the version number (`__version__`) in `threadpoolctl.py`.Build the distribution archives:```bashpip install flitflit build```Check the contents of `dist/`.If everything is fine, make a commit for the release, tag it, push thetag to github and then:```bashflit publish```### CreditsThe initial dynamic library introspection code was written by @anton-malakhovfor the smp package available at https://github.com/IntelPython/smp .threadpoolctl extends this for other operating systems. Contrary to smp,threadpoolctl does not attempt to limit the size of Python multiprocessingpools (threads or processes) or set operating system-level CPU affinityconstraints: threadpoolctl only interacts with native libraries via theirpublic runtime APIs.</longdescription>
</pkgmetadata>