<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>A Python driver for CQL that adheres to py-dbapi v2 (PEP249, Python Database API Specification v2.0:  http://www.python.org/dev/peps/pep-0249/).Standard use: &gt;&gt; import cql &gt;&gt; con = cql.connect(host, port, keyspace) &gt;&gt; cursor = con.cursor() &gt;&gt; cursor.execute(&quot;CQL QUERY&quot;, dict(kw='Foo', kw2='Bar, etc...))    - cursor.description  # None initially, list of N tuples that represent                              the N columns in a row after an execute. Only                               contains type and name info, not values.    - cursor.rowcount     # -1 initially, N after an execute    - cursor.arraysize    # variable size of a fetchmany call    - cursor.fetchone()   # returns  a single row    - cursor.fetchmany()  # returns  self.arraysize # of rows    - cursor.fetchall()   # returns  all rows, don't do this. &gt;&gt; cursor.execute(&quot;ANOTHER QUERY&quot;, **more_kwargs) &gt;&gt; for row in cursor:  # Iteration is equivalent to lots of fetchone() calls &gt;&gt;     doRowMagic(row) &gt;&gt; cursor.close() &gt;&gt; con.close()Query substitution: - Use named parameters and a dictionary of names and values.     e.g. execute(&quot;SELECT * FROM CF WHERE name=:name&quot;, {&quot;name&quot;: &quot;Foo&quot;})</longdescription>
</pkgmetadata>