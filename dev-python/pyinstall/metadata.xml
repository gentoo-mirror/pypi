<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>**NOTE:** pyinstall has been renamed to **pip**: please seehttp://pip.openplans.org or http://pypi.python.org/pypi/pip.. contents::Introduction------------pyinstall is a replacement for `easy_install&lt;http://peak.telecommunity.com/DevCenter/EasyInstall&gt;`_.  It uses mostly thesame techniques for finding packages, so packages that were madeeasy_installable should be pyinstallable as well.pyinstall is meant to improve on easy_install.  Some of the improvements:* All packages are downloaded before installation.  Partially-completed  installation doesn't occur as a result.* Care is taken to present useful output on the console.* The reasons for actions are kept track of.  For instance, if a package is  being installed, pyinstall keeps track of why that package was required.* Error messages should be useful.* The code is relatively concise and cohesive, making it easier to use  programmatically.* Packages don't have to be installed as egg archives, they can be installed  flat (while keeping the egg metadata).* Maybe features like native support for other version control systems, or  uninstallation, will get added.  (They might get added to easy_install, but I  think the chance for pyinstall is higher.)Also, pyinstall will eventually be merged directly with poacheggs, making itsimple to define fixed sets of requirements and reliably reproduce a set ofpackages.pyinstall is complementary with `virtualenv&lt;http://pypi.python.org/pypi/virtualenv&gt;`_, and it is encouraged that you usevirtualenv to isolate your installation.Community---------The homepage for pyinstall is temporarily located `on PyPI&lt;http://pypi.python.org/pypi/pyinstall&gt;`_ -- a more proper homepagewill follow.  Bugs can go on the `poacheggs Trac instance&lt;http://trac.openplans.org/poacheggs/&gt;`_ (probably that will changetoo).  Discussion should happen on the `virtualenv email group&lt;http://groups.google.com/group/python-virtualenv?hl=en&gt;`_.Differences From easy_install-----------------------------pyinstall cannot install some packages.  Specifically:* It cannot install from eggs.  It only installs from source.  (Maybe this will  be changed sometime, but it's low priority.)* It doesn't understand Setuptools extras (like ``package[test]``).  This should  be added eventually.* It is incompatible with some packages that customize distutils or setuptools  in their ``setup.py`` files.* Maybe it doesn't work on Windows.  At least, the author doesn't test on  Windows often.* It also has some extra features.  Extra features the author thinks are great... _`requirements file`:Requirements Files------------------When installing software, and Python packages in particular, it's common thatyou get a lot of libraries installed.  You just did ``easy_install MyPackage``and you get a dozen packages.  Each of these packages has its own version.Maybe you ran that installation and it works.  Great!  Will it keep working? Did you have to provide special options to get it to find everything?  Did youhave to install a bunch of other optional pieces?  Most of all, will you be ableto do it again?If you've ever tried to setup an application on a new system, or with slightlyupdated pieces, and had it fail, pyinstall requirements are for you.  If youhaven't had this problem then you will eventually, so pyinstall requirements arefor you too -- requirements make explicit, repeatable installation of packages.So what are requirements files?  They are very simple: lists of packages toinstall.  Instead of running something like ``pyinstall MyApp`` and gettingwhatever libraries come along, you can create a requirements file something like::    MyApp    Framework==0.9.4    Library&gt;=0.2Then, regardless of what MyApp lists in ``setup.py``, you'll get a specificversion of Framework and at least the 0.2 version of Library.  (You might thinkyou could list these specific versions in ``setup.py`` -- try it and you'llquickly see why that doesn't work.)  You can add optional libraries and supporttools that MyApp doesn't strictly require.You can also include &quot;editable&quot; packages -- packages that are checked out fromsubversion (in the future other VCS will be supported).  These are just likeusing the ``-e`` option to pyinstall.  They look like::    -e svn+http://myrepo/svn/MyApp#egg=MyAppYou have to start the URL with ``svn+`` (eventually you'll be able to use``hg+`` etc), and you have to include ``#egg=Package`` so pyinstall knows whatto expect at that URL.  You can also include ``@rev`` in the URL, e.g., ``@275``to check out revision 275.Freezing Requirements---------------------So you have a working set of packages, and you want to be able to install themelsewhere.  `Requirements files`_ let you install exact versions, but it won'ttell you what all the exact versions are.To create a new requirements file from a known working environment, use::    $ pyinstall.py --freeze=stable-req.txtThis will write a listing of *all* installed libraries to ``stable-req.txt``with exact versions for every library.  You may want to edit the file down aftergenerating (e.g., to eliminate unnecessary libraries), but it'll give you astable starting point for constructing your requirements file.You can also give it an existing requirements file, and it will use that as asort of template for the new file.  So if you do::    $ pyinstall.py --freeze=stable-req.txt -r devel-req.txtit will keep the packages listed in ``devel-req.txt`` in order and preservecomments.Bundles-------Another way to distribute a set of libraries is a bundle format (specific topyinstall).  This format is not stable at this time (there simply hasn't beenany feedback, nor a great deal of thought).  A bundle file contains all thesource for your package, and you can have pyinstall install then all together. Once you have the bundle file further network access won't be necessary.  Tobuild a bundle file, do::    $ pyinstall.py --bundle=MyApp.pybundle MyApp(Using a `requirements file`_ would be wise.)  Then someone else can get thefile ``MyApp.pybundle`` and run::    $ pyinstall.py MyApp.pybundleThis is *not* a binary format.  This only packages source.  If you have binarypackages, then the person who installs the files will have to have a compiler,any necessary headers installed, etc.  Binary packages are hard, this isrelatively easy.Using pyinstall With virtualenv-------------------------------pyinstall is most nutritious when used with `virtualenv&lt;http://pypi.python.org/pypi/virtualenv&gt;`_.  One of the reasons pyinstalldoesn't install &quot;multi-version&quot; eggs is that virtualenv removes much of the needfor it.pyinstall does not have to be installed to use it, you can run ``pythonpyinstall.py`` and it will work.  This is intended to avoid the bootstrappingproblem of installation.  You can also run pyinstall inside any virtualenvenvironment, like::    $ virtualenv new-env/    ... creates new-env/ ...    $ pyinstall.py -E new-env/ MyPackageThis is exactly equivalent to::    $ ./new-env/bin/python pyinstall.py MyPackageExcept, if you have ``virtualenv`` installed and the path ``new-env/``doesn't exist, then a new virtualenv will be created.</longdescription>
</pkgmetadata>