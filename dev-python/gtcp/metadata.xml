<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># GTCPSimple and secure TCP framework## Features- TCP server and TCP client- Simple event based messaging- Secure automatic RSA encryption## InstallationUsing pip:```shell$ pip install gtcp```In Python:```pythonfrom gtcp import server, client```## Documentation- [Server](#server)  - [Initialization](#initialization)  - [Handling connections](#handling-connections)  - [Sending data](#sending-data)  - [Recieving data](#recieving-data)  - [Rooms](#rooms)  - [Handling client disconnect](#handling-client-disconnect)- [Client](#client)  - [Initialization](#initialization-1)  - [Sending data](#sending-data-1)  - [Recieving data](#recieving-data-1)- [Callbacks](#callbacks)## Server### InitializationThe server comes as a class. When creating a server with the class, the constructor takes 1 required parameter: the port the server will run on.```pythonfrom gtcp import server# 's' is a TCP server that runs on port 8080s = server(8080)``` Additionally, the server also takes 1 optional parameter: options. Options should be passed as a dictionary.```pythonfrom gtcp import server# in this case, we are setting the &quot;encrypted&quot; option to trues = server(8080, {&quot;encrypted&quot;: True})```### Handling connectionsServer objects have the ```.connection()``` method to handle new client connections. It takes 1 parameter: a callback function with a parameter for the socket.```python# The socket parameter will be set as an object that represents the connectiondef connectionhandler(socket):    passs.connect(connectionhandler)```The socket object is comprised of the IP address of the client, the socket id, the rooms the socket is in, methods for handling and sending data, and methods for handling rooms.```pythondef connectionhandler(socket):    print(socket.id)    # Output: A random UUIDv4 id    print(socket.ip)    # Output: 0.0.0.0    print(socket.rooms)    # Output: [&lt;the id of the socket&gt;, rooms, the, socket, is, in...]s.connect(connectionhandler)```### Sending dataTo send data, use the ```.emit()``` method. It takes at least two parameters: the event and any amount of data to be sent.You can use the ```.emit()``` method with a server object or a socket object to send to all connected sockets or to a single socket respectively.```pythondef connectionhandler(socket):    # This will send to the specific socket from the parameter    socket.emit(&quot;login&quot;, username, password)    # This will send to all sockets    s.emit(&quot;login&quot;, username, password)s.connect(connectionhandler)# This will send to all socketss.emit(&quot;login&quot;, username, password)```### Recieving dataTo recieve data from a socket, use it's ```.on()``` method. It takes two parameters: the event and a callback function with parameters for all the data.```pythondef connectionhandler(socket):    def loginhandler(username, password):        pass    socket.on(&quot;login&quot;, loginhandler)s.connect(connectionhandler)```### RoomsTo do certain interactions with specific sockets or to simple group and organize sockets, use rooms. Rooms are groups of sockets that you can adress seperately from others.To get a socket to join a room, use the ```.join()``` method.```pythondef connectionhandler(socket):    socket.join(&quot;room1&quot;)    print(socket.rooms)    #  Output: [&lt;the id of the socket&gt;, &quot;room1&quot;]s.connect(connectionhandler)```To get a socket to leave a room (excluding the room of their own id), use the ```.leave()``` method.```pythondef connectionhandler(socket):    socket.leave(&quot;room1&quot;)    print(socket.rooms)    # Output: [&lt;the id of the socket&gt;]    socket.leave(socket.id)    print(socket.rooms)    # Output: [&lt;the id of the socket&gt;]s.connect(connectionhandler)```To get a socket to leave all tooms except for the one is their own id, use the ```.clearrooms()``` method.```pythondef connectionhandler(socket):    socket.clearrooms()    print(socket.rooms)    # Output: [&lt;the id of the socket&gt;]s.connect(connectionhandler)```To send data to a specific room, use server object's ```.to()``` method. It takes one parameter (the room). The ```.to()``` methods can be chained to send to multiple rooms.```pythondef connectionhandler(socket):    passsocket.onconnection()# This will emit to sockets in room1socket.to(&quot;room1&quot;).emit(&quot;hello&quot;, &quot;world&quot;)# This will emit to both room1 and room2socket.to(&quot;room1&quot;).to(&quot;room2&quot;).emit(&quot;hello&quot;, &quot;world&quot;)```### Handling client disconnectTo a socket disconnect, listen with the ```.on()``` method for a the &quot;end&quot; event. The callback function takes no parameters```pythondef connectionhandler(socket):    def endhandler():        pass    socket.on(&quot;end&quot;, endhandler)s.connect(connectionhandler)```## Client### InitializationThe client comes as a class. When creating a client with the class, the constructor takes 1 required parameters: the IP address and port of the server to connect to.```pythonfrom gtcp import client# 'c' is a TCP client connected to a server ran on port 8080 c = client(&quot;localhost:8080&quot;)```Additionally it takes 2 more optional parameters: a callback function to run when the client connects to the server and an options dictionary.```pythonfrom gtcp import client# 'connectionhandler,' which is optional, is ran when it 'c' finishes connecting to the serverdef clientcallback(c):    pass# 'c' is an encrypted TCP client connected to a server ran on port 8080c = client(&quot;localhost:8080&quot;, {&quot;encrypted&quot;: True}, clientcallback)```### Sending dataTo send data to the server, use the ```.emit()``` method. It takes at least two parameters: the event and any amount of data to be sent.```pythondef clientcallback(c):    # This will send to the server    c.emit(&quot;login&quot;, username, password)c = client(&quot;localhost:8080&quot;, clientcallback)# This also sends to the serverc.emit(&quot;login&quot;, username, password)```### Recieving dataTo recieve data from the server, use the client object's ```.on()``` method. It takes two parameters: the event and a callback function with parameters for all the data.```pythondef loginhandler(username, password):    passdef clientcallback(c):    c.on(&quot;login&quot;, loginhandler)c = client(&quot;localhost:8080&quot;, clientcallback)# This also worksc.on(&quot;login&quot;, loginhandler)```## CallbacksSometimes, it is useful to have a more traditional request-response style API. In GTCP, this is achieved with callback functions.Callback functions are any functions that are sent through an ```.emit()```. The function will be ran and supplied with parameters when it is called by the other side.```python# In clientdef clientcallback(c):    def loginCallback(confirm, userToken=&quot;&quot;):        if confirm:            print(userToken)    c.emit(&quot;login&quot;, username, password, loginCallback)c = client(&quot;localhost:8080&quot;, clientcallback)# In serverdef connectionhandler(socket):    def loginhandler(username, password, callback):        if db.exists(&quot;username&quot;, username):            if db.where(&quot;username&quot;, username)[&quot;password&quot;] == password:                callback(1, db.where(&quot;username&quot;, username)[&quot;userToken&quot;])            else:                callback(0)        else:            callback(0)    socket.on(&quot;login&quot;, loginhandler)s.connect(connectionhandler)```</longdescription>
</pkgmetadata>