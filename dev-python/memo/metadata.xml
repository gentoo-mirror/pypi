<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![](https://github.com/koaning/memo/raw/main/docs/header.png)## Installation```pip install memo```## DocumentationThe documentation can be found [here](https://koaning.github.io/memo/).The quickstart guide is found [here](https://koaning.github.io/memo/getting-started.html).## UsageHere's an example of utility functions provided by our library.```pythonimport numpy as npfrom memo import memlist, memfile, grid, time_takendata = []@memfile(filepath=&quot;results.jsonl&quot;)@memlist(data=data)@time_taken()def birthday_experiment(class_size, n_sim):    &quot;&quot;&quot;Simulates the birthday paradox. Vectorized = Fast!&quot;&quot;&quot;    sims = np.random.randint(1, 365 + 1, (n_sim, class_size))    sort_sims = np.sort(sims, axis=1)    n_uniq = (sort_sims[:, 1:] != sort_sims[:, :-1]).sum(axis = 1) + 1    proba = np.mean(n_uniq != class_size)    return {&quot;est_proba&quot;: proba}for settings in grid(class_size=[5, 10, 20, 30], n_sim=[1000, 1_000_000]):    birthday_experiment(**settings)```The decorators `memlist` and `memfile` are making sure that the keyword arugments anddictionary output of the `birthday_experiment` are logged. The contents of the `results.jsonl`-fileand the `data` variable looks like this;```{&quot;class_size&quot;: 5, &quot;n_sim&quot;: 1000, &quot;est_proba&quot;: 0.024, &quot;time_taken&quot;: 0.0004899501800537109}{&quot;class_size&quot;: 5, &quot;n_sim&quot;: 1000000, &quot;est_proba&quot;: 0.027178, &quot;time_taken&quot;: 0.19407916069030762}{&quot;class_size&quot;: 10, &quot;n_sim&quot;: 1000, &quot;est_proba&quot;: 0.104, &quot;time_taken&quot;: 0.000598907470703125}{&quot;class_size&quot;: 10, &quot;n_sim&quot;: 1000000, &quot;est_proba&quot;: 0.117062, &quot;time_taken&quot;: 0.3751380443572998}{&quot;class_size&quot;: 20, &quot;n_sim&quot;: 1000, &quot;est_proba&quot;: 0.415, &quot;time_taken&quot;: 0.0009679794311523438}{&quot;class_size&quot;: 20, &quot;n_sim&quot;: 1000000, &quot;est_proba&quot;: 0.411571, &quot;time_taken&quot;: 0.7928380966186523}{&quot;class_size&quot;: 30, &quot;n_sim&quot;: 1000, &quot;est_proba&quot;: 0.703, &quot;time_taken&quot;: 0.0018239021301269531}{&quot;class_size&quot;: 30, &quot;n_sim&quot;: 1000000, &quot;est_proba&quot;: 0.706033, &quot;time_taken&quot;: 1.1375510692596436}```The nice thing about being able to log results to a file or to the web is thatyou can also more easily parallize your jobs! For example now you can use the `Runner`class to parrallelize the function call with [joblib].[joblib]: https://joblib.readthedocs.io/en/latest/```pythonimport numpy as npfrom memo import memlist, memfile, grid, time_taken, Runnerdata = []@memfile(filepath=&quot;results.jsonl&quot;)@memlist(data=data)@time_taken()def birthday_experiment(class_size, n_sim):    &quot;&quot;&quot;Simulates the birthday paradox. Vectorized = Fast!&quot;&quot;&quot;    sims = np.random.randint(1, 365 + 1, (n_sim, class_size))    sort_sims = np.sort(sims, axis=1)    n_uniq = (sort_sims[:, 1:] != sort_sims[:, :-1]).sum(axis = 1) + 1    proba = np.mean(n_uniq != class_size)    return {&quot;est_proba&quot;: proba}# declare all the settings to loop oversettings = grid(class_size=range(20, 30), n_sim=[100, 10_000, 1_000_000])# use a runner to run over all the settingsrunner = Runner(backend=&quot;threading&quot;, n_jobs=-1)runner.run(func=birthday_experiment, settings=settings, progbar=True)```## FeaturesThis library also offers decorators to pipe to other sources.- `memlists` sends the json blobs to a list- `memfile` sends the json blobs to a file- `memweb` sends the json blobs to a server via http-post requests- `memfunc` sends the data to a callable that you supply, like `print`- `grid` generates a convenient grid for your experiments- `random_grid` generates a randomized grid for your experiments- `time_taken` also logs the time the function takes to runWe also offer an option to parallelize function calls using joblib. Thisis facilitated with a `Runner` class which supports multiple backends.- `Runner(backend=&quot;loky&quot;)`- `Runner(backend=&quot;threading&quot;)`- `Runner(backend=&quot;multiprocessing&quot;)`Check the API docs [here](https://koaning.github.io/memo/util.html) for more information onhow these work.</longdescription>
</pkgmetadata>