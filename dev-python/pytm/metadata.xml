<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![build+test](https://github.com/izar/pytm/workflows/build%2Btest/badge.svg)# pytm: A Pythonic framework for threat modeling![pytm logo](docs/pytm-logo.svg)## IntroductionTraditional threat modeling too often comes late to the party, or sometimes not at all. In addition, creating manual data flows and reports can be extremely time-consuming. The goal of pytm is to shift threat modeling to the left, making threat modeling more automated and developer-centric.## FeaturesBased on your input and definition of the architectural design, pytm can automatically generate the following items:- Data Flow Diagram (DFD)- Sequence Diagram- Relevant threats to your system## Requirements* Linux/MacOS* Python 3.x* Graphviz package* Java (OpenJDK 10 or 11)* [plantuml.jar](http://sourceforge.net/projects/plantuml/files/plantuml.jar/download)## Getting StartedThe `tm.py` is an example model. You can run it to generate the report and diagram image files that it references:```mkdir -p tm./tm.py --report docs/basic_template.md | pandoc -f markdown -t html &gt; tm/report.html./tm.py --dfd | dot -Tpng -o tm/dfd.png./tm.py --seq | java -Djava.awt.headless=true -jar $PLANTUML_PATH -tpng -pipe &gt; tm/seq.png```There's also an example `Makefile` that wraps all these into targets that can be easily shared for multiple models. If you have [GNU make](https://www.gnu.org/software/make/) installed (available by default on Linux distros but not on OSX), simply run:```make```To avoid installing all the dependencies, like `pandoc` or `Java`, the script can be run inside a container:```# do this only onceexport USE_DOCKER=truemake image# call this after every change in your modelmake```## UsageAll available arguments:```textusage: tm.py [-h] [--sqldump SQLDUMP] [--debug] [--dfd] [--report REPORT]             [--exclude EXCLUDE] [--seq] [--list] [--describe DESCRIBE]             [--list-elements] [--json JSON] [--levels LEVELS [LEVELS ...]]             [--stale_days STALE_DAYS]optional arguments:  -h, --help            show this help message and exit  --sqldump SQLDUMP     dumps all threat model elements and findings into the                        named sqlite file (erased if exists)  --debug               print debug messages  --dfd                 output DFD  --report REPORT       output report using the named template file (sample                        template file is under docs/template.md)  --exclude EXCLUDE     specify threat IDs to be ignored  --seq                 output sequential diagram  --list                list all available threats  --describe DESCRIBE   describe the properties available for a given element  --list-elements       list all elements which can be part of a threat model  --json JSON           output a JSON file  --levels LEVELS [LEVELS ...]                        Select levels to be drawn in the threat model (int                        separated by comma).  --stale_days STALE_DAYS                        checks if the delta between the TM script and the code                        described by it is bigger than the specified value in                        days```The *stale_days* argument tries to determine how far apart in days the model script (which you are writing) is from the code that implements the system being modeled. Ideally, they should be pretty close in most cases of an actively developed system. You can run this periodically to measure the pulse of your project and the 'freshness' of your threat model.Currently available elements are: TM, Element, Server, ExternalEntity, Datastore, Actor, Process, SetOfProcesses, Dataflow, Boundary and Lambda.The available properties of an element can be listed by using `--describe` followed by the name of an element:```text(pytm) ➜  pytm git:(master) ✗ ./tm.py --describe ElementElement class attributes:  OS  definesConnectionTimeout        default: False  description  handlesResources                default: False  implementsAuthenticationScheme  default: False  implementsNonce                 default: False  inBoundary  inScope                         Is the element in scope of the threat model, default: True  isAdmin                         default: False  isHardened                      default: False  name                            required  onAWS                           default: False```## Creating a Threat ModelThe following is a sample `tm.py` file that describes a simple application where a User logs into the applicationand posts comments on the app. The app server stores those comments into the database. There is an AWS Lambdathat periodically cleans the Database.```python#!/usr/bin/env python3from pytm.pytm import TM, Server, Datastore, Dataflow, Boundary, Actor, Lambda, Data, Classificationtm = TM(&quot;my test tm&quot;)tm.description = &quot;another test tm&quot;tm.isOrdered = TrueUser_Web = Boundary(&quot;User/Web&quot;)Web_DB = Boundary(&quot;Web/DB&quot;)user = Actor(&quot;User&quot;)user.inBoundary = User_Webweb = Server(&quot;Web Server&quot;)web.OS = &quot;CloudOS&quot;web.isHardened = Trueweb.sourceCode = &quot;server/web.cc&quot;db = Datastore(&quot;SQL Database (*)&quot;)db.OS = &quot;CentOS&quot;db.isHardened = Falsedb.inBoundary = Web_DBdb.isSql = Truedb.inScope = Falsedb.sourceCode = &quot;model/schema.sql&quot;my_lambda = Lambda(&quot;cleanDBevery6hours&quot;)my_lambda.hasAccessControl = Truemy_lambda.inBoundary = Web_DBmy_lambda_to_db = Dataflow(my_lambda, db, &quot;(&amp;lambda;)Periodically cleans DB&quot;)my_lambda_to_db.protocol = &quot;SQL&quot;my_lambda_to_db.dstPort = 3306user_to_web = Dataflow(user, web, &quot;User enters comments (*)&quot;)user_to_web.protocol = &quot;HTTP&quot;user_to_web.dstPort = 80user_to_web.data = Data('Comments in HTML or Markdown', classification=Classification.PUBLIC)web_to_user = Dataflow(web, user, &quot;Comments saved (*)&quot;)web_to_user.protocol = &quot;HTTP&quot;web_to_db = Dataflow(web, db, &quot;Insert query with comments&quot;)web_to_db.protocol = &quot;MySQL&quot;web_to_db.dstPort = 3306db_to_web = Dataflow(db, web, &quot;Comments contents&quot;)db_to_web.protocol = &quot;MySQL&quot;# this is a BAD way of defining a data object, here for a demo on how it# will appear on the sample report. Use Data objects.db_to_web.data = 'Results of insert op'tm.process()```### Generating DiagramsDiagrams are output as [Dot](https://graphviz.gitlab.io/) and [PlantUML](https://plantuml.com/).When `--dfd` argument is passed to the above `tm.py` file it generates output to stdout, which is fed to Graphviz's dot to generate the Data Flow Diagram:```bashtm.py --dfd | dot -Tpng -o sample.png```Generates this diagram:![dfd.png](.gitbook/assets/dfd.png)Adding &quot;.levels = [1,2]&quot; attributes to an element will cause it (and its associated Dataflows if both flow endings are in the same DFD level) to render (or not) depending on the command argument &quot;--levels 1 2&quot;.The following command generates a Sequence diagram.```bashtm.py --seq | java -Djava.awt.headless=true -jar plantuml.jar -tpng -pipe &gt; seq.png```Generates this diagram:![seq.png](.gitbook/assets/seq.png)### Creating a ReportThe diagrams and findings can be included in the template to create a final report:```bashtm.py --report docs/basic_template.md | pandoc -f markdown -t html &gt; report.html```The templating format used in the report template is very simple:```text# Threat Model Sample***## System Description{tm.description}## Dataflow Diagram![Level 0 DFD](dfd.png)## DataflowsName|From|To |Data|Protocol|Port----|----|---|----|--------|----{dataflows:repeat:{{item.name}}|{{item.source.name}}|{{item.sink.name}}|{{item.data}}|{{item.protocol}}|{{item.dstPort}}}## Findings{findings:repeat:* {{item.description}} on element &quot;{{item.target}}&quot;}```To group findings by elements, use a more advanced, nested loop:```text## Findings{elements:repeat:{{item.findings:if:### {{item.name}}{{item.findings:repeat:**Threat**: {{{{item.id}}}} - {{{{item.description}}}}**Severity**: {{{{item.severity}}}}**Mitigations**: {{{{item.mitigations}}}}**References**: {{{{item.references}}}}}}}}}```All items inside a loop must be escaped, doubling the braces, so `{item.name}` becomes `{{item.name}}`.The example above uses two nested loops, so items in the inner loop must be escaped twice, that's why they're using four braces.### OverridesYou can override attributes of findings (threats matching the model assets and/or dataflows), for example to set a custom CVSS score and/or response text:```pythonuser_to_web = Dataflow(user, web, &quot;User enters comments (*)&quot;, protocol=&quot;HTTP&quot;, dstPort=&quot;80&quot;)user_to_web.overrides = [    Finding(        # Overflow Buffers        id=&quot;INP02&quot;,        CVSS=&quot;9.3&quot;,        response=&quot;&quot;&quot;**To Mitigate**: run a memory sanitizer to validate the binary&quot;&quot;&quot;,    )]```## Threats databaseFor the security practitioner, you may supply your own threats file by setting `TM.threatsFile`. It should contain entries like:```json{   &quot;SID&quot;:&quot;INP01&quot;,   &quot;target&quot;: [&quot;Lambda&quot;,&quot;Process&quot;],   &quot;description&quot;: &quot;Buffer Overflow via Environment Variables&quot;,   &quot;details&quot;: &quot;This attack pattern involves causing a buffer overflow through manipulation of environment variables. Once the attacker finds that they can modify an environment variable, they may try to overflow associated buffers. This attack leverages implicit trust often placed in environment variables.&quot;,   &quot;Likelihood Of Attack&quot;: &quot;High&quot;,   &quot;severity&quot;: &quot;High&quot;,   &quot;condition&quot;: &quot;target.usesEnvironmentVariables is True and target.controls.sanitizesInput is False and target.controls.checksInputBounds is False&quot;,   &quot;prerequisites&quot;: &quot;The application uses environment variables.An environment variable exposed to the user is vulnerable to a buffer overflow.The vulnerable environment variable uses untrusted data.Tainted data used in the environment variables is not properly validated. For instance boundary checking is not done before copying the input data to a buffer.&quot;,   &quot;mitigations&quot;: &quot;Do not expose environment variable to the user.Do not use untrusted data in your environment variables. Use a language or compiler that performs automatic bounds checking. There are tools such as Sharefuzz [R.10.3] which is an environment variable fuzzer for Unix that support loading a shared library. You can use Sharefuzz to determine if you are exposing an environment variable vulnerable to buffer overflow.&quot;,   &quot;example&quot;: &quot;Attack Example: Buffer Overflow in $HOME A buffer overflow in sccw allows local users to gain root access via the $HOME environmental variable. Attack Example: Buffer Overflow in TERM A buffer overflow in the rlogin program involves its consumption of the TERM environmental variable.&quot;,   &quot;references&quot;: &quot;https://capec.mitre.org/data/definitions/10.html, CVE-1999-0906, CVE-1999-0046, http://cwe.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/119.html, http://cwe.mitre.org/data/definitions/680.html&quot; }```The `target` field lists classes of model elements to match this threat against.Those can be assets, like: Actor, Datastore, Server, Process, SetOfProcesses, ExternalEntity,Lambda or Element, which is the base class and matches any. It can also be a Dataflow that connects two assets.All other fields (except `condition`) are available for display and can be used in the templateto list findings in the final [report](#report).&gt; **WARNING**&gt;&gt; The `threats.json` file contains strings that run through `eval()`. Make sure the file has correct permissions&gt; or risk having an attacker change the strings and cause you to run code on their behalf.The logic lives in the `condition`, where members of `target` can be logically evaluated.Returning a true means the rule generates a finding, otherwise, it is not a finding.Condition may compare attributes of `target` and/or control attributes of the 'target.control' and also call one of these methods:* `target.oneOf(class, ...)` where `class` is one or more: Actor, Datastore, Server, Process, SetOfProcesses, ExternalEntity, Lambda or Dataflow,* `target.crosses(Boundary)`,* `target.enters(Boundary)`,* `target.exits(Boundary)`,* `target.inside(Boundary)`.If `target` is a Dataflow, remember you can access `target.source` and/or `target.sink` along with other attributes.Conditions on assets can analyze all incoming and outgoing Dataflows by inspectingthe `target.input` and `target.output` attributes. For example, to match a threat only againstservers with incoming traffic, use `any(target.inputs)`. A more advanced example,matching elements connecting to SQL datastores, would be `any(f.sink.oneOf(Datastore) and f.sink.isSQL for f in target.outputs)`.## Currently supported threats```textINP01 - Buffer Overflow via Environment VariablesINP02 - Overflow BuffersINP03 - Server Side Include (SSI) InjectionCR01 - Session SidejackingINP04 - HTTP Request SplittingCR02 - Cross Site TracingINP05 - Command Line Execution through SQL InjectionINP06 - SQL Injection through SOAP Parameter TamperingSC01 - JSON Hijacking (aka JavaScript Hijacking)LB01 - API ManipulationAA01 - Authentication Abuse/ByPassDS01 - ExcavationDE01 - InterceptionDE02 - Double EncodingAPI01 - Exploit Test APIsAC01 - Privilege AbuseINP07 - Buffer ManipulationAC02 - Shared Data ManipulationDO01 - FloodingHA01 - Path TraversalAC03 - Subverting Environment Variable ValuesDO02 - Excessive AllocationDS02 - Try All Common SwitchesINP08 - Format String InjectionINP09 - LDAP InjectionINP10 - Parameter InjectionINP11 - Relative Path TraversalINP12 - Client-side Injection-induced Buffer OverflowAC04 - XML Schema PoisoningDO03 - XML Ping of the DeathAC05 - Content SpoofingINP13 - Command DelimitersINP14 - Input Data ManipulationDE03 - Sniffing AttacksCR03 - Dictionary-based Password AttackAPI02 - Exploit Script-Based APIsHA02 - White Box Reverse EngineeringDS03 - FootprintingAC06 - Using Malicious FilesHA03 - Web Application FingerprintingSC02 - XSS Targeting Non-Script ElementsAC07 - Exploiting Incorrectly Configured Access Control Security LevelsINP15 - IMAP/SMTP Command InjectionHA04 - Reverse EngineeringSC03 - Embedding Scripts within ScriptsINP16 - PHP Remote File InclusionAA02 - Principal SpoofCR04 - Session Credential Falsification through ForgingDO04 - XML Entity ExpansionDS04 - XSS Targeting Error PagesSC04 - XSS Using Alternate SyntaxCR05 - Encryption Brute ForcingAC08 - Manipulate Registry InformationDS05 - Lifting Sensitive Data Embedded in CacheSC05 - Removing Important Client FunctionalityINP17 - XSS Using MIME Type MismatchAA03 - Exploitation of Trusted CredentialsAC09 - Functionality MisuseINP18 - Fuzzing and observing application log data/errors for application mappingCR06 - Communication Channel ManipulationAC10 - Exploiting Incorrectly Configured SSLCR07 - XML Routing Detour AttacksAA04 - Exploiting Trust in ClientCR08 - Client-Server Protocol ManipulationINP19 - XML External Entities BlowupINP20 - iFrame OverlayAC11 - Session Credential Falsification through ManipulationINP21 - DTD InjectionINP22 - XML Attribute BlowupINP23 - File Content InjectionDO05 - XML Nested PayloadsAC12 - Privilege EscalationAC13 - Hijacking a privileged processAC14 - Catching exception throw/signal from privileged blockINP24 - Filter Failure through Buffer OverflowINP25 - Resource InjectionINP26 - Code InjectionINP27 - XSS Targeting HTML AttributesINP28 - XSS Targeting URI PlaceholdersINP29 - XSS Using Doubled CharactersINP30 - XSS Using Invalid CharactersINP31 - Command InjectionINP32 - XML InjectionINP33 - Remote Code InclusionINP34 - SOAP Array OverflowINP35 - Leverage Alternate EncodingDE04 - Audit Log ManipulationAC15 - Schema PoisoningINP36 - HTTP Response SmugglingINP37 - HTTP Request SmugglingINP38 - DOM-Based XSSAC16 - Session Credential Falsification through PredictionINP39 - Reflected XSSINP40 - Stored XSSAC17 - Session Hijacking - ServerSideAC18 - Session Hijacking - ClientSideINP41 - Argument InjectionAC19 - Reusing Session IDs (aka Session Replay) - ServerSideAC20 - Reusing Session IDs (aka Session Replay) - ClientSideAC21 - Cross Site Request Forgery```</longdescription>
</pkgmetadata>