<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://travis-ci.org/pythonprofilers/memory_profiler.svg?branch=master    :target: https://travis-ci.org/pythonprofilers/memory_profiler================= Memory Profiler=================**Note:** This package is no longer actively maintained. I won't be actively responding to issues. If you'd like to volunteer to maintain it, please drop me a line at f@bianp.netThis is a python module for monitoring memory consumption of a processas well as line-by-line analysis of memory consumption for pythonprograms. It is a pure python module which depends on the `psutil&lt;http://pypi.python.org/pypi/psutil&gt;`_ module.============== Installation==============Install via pip::    $ pip install -U memory_profilerThe package is also available on `conda-forge&lt;https://github.com/conda-forge/memory_profiler-feedstock&gt;`_.To install from source, download the package, extract and type::    $ pip install .===========Quick Start===========Use `mprof` to generate a full memory usage report of your executable and to plot it... code-block:: bash    mprof run executable    mprof plotThe plot would be something like this:.. image:: https://i.stack.imgur.com/ixCH4.png======= Usage=======line-by-line memory usage=========================The line-by-line memory usage mode is used much in the same way of the`line_profiler &lt;https://pypi.python.org/pypi/line_profiler/&gt;`_: firstdecorate the function you would like to profile with ``@profile`` andthen run the script with a special script (in this case with specificarguments to the Python interpreter).In the following example, we create a simple function ``my_func`` thatallocates lists ``a``, ``b`` and then deletes ``b``::    @profile    def my_func():        a = [1] * (10 ** 6)        b = [2] * (2 * 10 ** 7)        del b        return a    if __name__ == '__main__':        my_func()Execute the code passing the option ``-m memory_profiler`` to thepython interpreter to load the memory_profiler module and print tostdout the line-by-line analysis. If the file name was example.py,this would result in::    $ python -m memory_profiler example.pyOutput will follow::    Line #    Mem usage    Increment  Occurrences   Line Contents    ============================================================         3   38.816 MiB   38.816 MiB           1   @profile         4                                         def my_func():         5   46.492 MiB    7.676 MiB           1       a = [1] * (10 ** 6)         6  199.117 MiB  152.625 MiB           1       b = [2] * (2 * 10 ** 7)         7   46.629 MiB -152.488 MiB           1       del b         8   46.629 MiB    0.000 MiB           1       return aThe first column represents the line number of the code that has beenprofiled, the second column (*Mem usage*) the memory usage of thePython interpreter after that line has been executed. The third column(*Increment*) represents the difference in memory of the current linewith respect to the last one. The last column (*Line Contents*) printsthe code that has been profiled.Decorator=========A function decorator is also available.  Use as follows::    from memory_profiler import profile    @profile    def my_func():        a = [1] * (10 ** 6)        b = [2] * (2 * 10 ** 7)        del b        return aIn this case the script can be run without specifying ``-mmemory_profiler`` in the command line.In function decorator, you can specify the precision as an argument to thedecorator function.  Use as follows::    from memory_profiler import profile    @profile(precision=4)    def my_func():        a = [1] * (10 ** 6)        b = [2] * (2 * 10 ** 7)        del b        return aIf a python script with decorator ``@profile`` is called using ``-mmemory_profiler`` in the command line, the ``precision`` parameter is ignored.Time-based memory usage==========================Sometimes it is useful to have full memory usage reports as a function oftime (not line-by-line) of external processes (be it Python scripts or not).In this case the executable ``mprof`` might be useful. Use it like::    mprof run &lt;executable&gt;    mprof plotThe first line run the executable and record memory usage along time,in a file written in the current directory.Once it's done, a graph plot can be obtained using the second line.The recorded file contains a timestamps, that allows for severalprofiles to be kept at the same time.Help on each `mprof` subcommand can be obtained with the `-h` flag,e.g. `mprof run -h`.In the case of a Python script, using the previous command does notgive you any information on which function is executed at a giventime. Depending on the case, it can be difficult to identify the partof the code that is causing the highest memory usage.Adding the `profile` decorator to a function(ensure no `from memory_profiler import profile` statement) and running the Pythonscript with    mprof run --python python &lt;script&gt;will record timestamps when entering/leaving the profiled function. Running    mprof plotafterward will plot the result, making plots (using matplotlib) similar to these:.. image:: https://camo.githubusercontent.com/3a584c7cfbae38c9220a755aa21b5ef926c1031d/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313930383631382f3836313332302f63623865376337382d663563632d313165322d386531652d3539373237623636663462322e706e67   :target: https://github.com/scikit-learn/scikit-learn/pull/2248   :height: 350pxor, with ``mprof plot --flame`` (the function and timestamp names will appear on hover):.. image:: ./images/flamegraph.png   :height: 350pxA discussion of these capabilities can be found `here &lt;http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/&gt;`_... warning:: If your Python file imports the memory profiler `from memory_profiler import profile` these timestamps will not be recorded. Comment out the import, leave your functions decorated, and re-run.The available commands for `mprof` are:  - ``mprof run``: running an executable, recording memory usage  - ``mprof plot``: plotting one the recorded memory usage (by default,    the last one)  - ``mprof list``: listing all recorded memory usage files in a    user-friendly way.  - ``mprof clean``: removing all recorded memory usage files.  - ``mprof rm``: removing specific recorded memory usage filesTracking forked child processes===============================In a multiprocessing context the main process will spawn child processes whosesystem resources are allocated separately from the parent process. This canlead to an inaccurate report of memory usage since by default only the parentprocess is being tracked. The ``mprof`` utility provides two mechanisms totrack the usage of child processes: sum the memory of all children to theparent's usage and track each child individual.To create a report that combines memory usage of all the children and theparent, use the ``include-children`` flag in either the ``profile`` decorator oras a command line argument to ``mprof``::    mprof run --include-children &lt;script&gt;The second method tracks each child independently of the main process,serializing child rows by index to the output stream. Use the ``multiprocess``flag and plot as follows::    mprof run --multiprocess &lt;script&gt;    mprof plotThis will create a plot using matplotlib similar to this:.. image:: https://cloud.githubusercontent.com/assets/745966/24075879/2e85b43a-0bfa-11e7-8dfe-654320dbd2ce.png    :target: https://github.com/pythonprofilers/memory_profiler/pull/134    :height: 350pxYou can combine both the ``include-children`` and ``multiprocess`` flags to showthe total memory of the program as well as each child individually. If usingthe API directly, note that the return from ``memory_usage`` will include thechild memory in a nested list along with the main process memory.Plot settings===============================By default, the command line call is set as the graph title. If you wish to customize it, you can use the ``-t`` option to manually set the figure title.    mprof plot -t 'Recorded memory usage'You can also hide the function timestamps using the ``n`` flag, such as    mprof plot -nTrend lines and its numeric slope can be plotted using the ``s`` flag, such as    mprof plot -s.. image:: ./images/trend_slope.png   :height: 350pxThe intended usage of the -s switch is to check the labels' numerical slope over a significant time period for :   - ``&gt;0`` it might mean a memory leak.  - ``~0`` if 0 or near 0, the memory usage may be considered stable.  - ``&lt;0`` to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.The trend lines are for ilustrative purposes and are plotted as (very) small dashed lines.Setting debugger breakpoints=============================It is possible to set breakpoints depending on the amount of memory used.That is, you can specify a threshold and as soon as the program uses morememory than what is specified in the threshold it will stop executionand run into the pdb debugger. To use it, you will have to decoratethe function as done in the previous section with ``@profile`` and thenrun your script with the option ``-m memory_profiler --pdb-mmem=X``,where X is a number representing the memory threshold in MB. For example::    $ python -m memory_profiler --pdb-mmem=100 my_script.pywill run ``my_script.py`` and step into the pdb debugger as soon as the codeuses more than 100 MB in the decorated function... TODO: alternatives to decoration (for example when you don't want to modify    the file where your function lives).===== API=====memory_profiler exposes a number of functions to be used in third-partycode.``memory_usage(proc=-1, interval=.1, timeout=None)`` returns the memory usageover a time interval. The first argument, ``proc`` represents whatshould be monitored.  This can either be the PID of a process (notnecessarily a Python program), a string containing some python code tobe evaluated or a tuple ``(f, args, kw)`` containing a function and itsarguments to be evaluated as ``f(*args, **kw)``. For example,    &gt;&gt;&gt; from memory_profiler import memory_usage    &gt;&gt;&gt; mem_usage = memory_usage(-1, interval=.2, timeout=1)    &gt;&gt;&gt; print(mem_usage)[7.296875, 7.296875, 7.296875, 7.296875, 7.296875]Here I've told memory_profiler to get the memory consumption of thecurrent process over a period of 1 second with a time interval of 0.2seconds. As PID I've given it -1, which is a special number (PIDs areusually positive) that means current process, that is, I'm getting thememory usage of the current Python interpreter. Thus I'm gettingaround 7MB of memory usage from a plain python interpreter. If I trythe same thing on IPython (console) I get 29MB, and if I try the samething on the IPython notebook it scales up to 44MB.If you'd like to get the memory consumption of a Python function, thenyou should specify the function and its arguments in the tuple ``(f,args, kw)``. For example::    &gt;&gt;&gt; # define a simple function    &gt;&gt;&gt; def f(a, n=100):        ...     import time        ...     time.sleep(2)        ...     b = [a] * n        ...     time.sleep(1)        ...     return b        ...    &gt;&gt;&gt; from memory_profiler import memory_usage    &gt;&gt;&gt; memory_usage((f, (1,), {'n' : int(1e6)}))This will execute the code `f(1, n=int(1e6))` and return the memoryconsumption during this execution.=========REPORTING=========The output can be redirected to a log file by passing IO stream asparameter to the decorator like @profile(stream=fp)    &gt;&gt;&gt; fp=open('memory_profiler.log','w+')    &gt;&gt;&gt; @profile(stream=fp)    &gt;&gt;&gt; def my_func():        ...     a = [1] * (10 ** 6)        ...     b = [2] * (2 * 10 ** 7)        ...     del b        ...     return a    For details refer: examples/reporting_file.py``Reporting via logger Module:``Sometime it would be very convenient to use logger module speciallywhen we need to use RotatingFileHandler.The output can be redirected to logger module by simply making use ofLogFile of memory profiler module.    &gt;&gt;&gt; from memory_profiler import LogFile    &gt;&gt;&gt; import sys    &gt;&gt;&gt; sys.stdout = LogFile('memory_profile_log')``Customized reporting:``Sending everything to the log file while running the memory_profilercould be cumbersome and one can choose only entries with incrementsby passing True to reportIncrementFlag, where reportIncrementFlag isa parameter to LogFile class of memory profiler module.    &gt;&gt;&gt; from memory_profiler import LogFile    &gt;&gt;&gt; import sys    &gt;&gt;&gt; sys.stdout = LogFile('memory_profile_log', reportIncrementFlag=False)    For details refer: examples/reporting_logger.py===================== IPython integration=====================After installing the module, if you use IPython, you can use the `%mprun`, `%%mprun`,`%memit` and `%%memit` magics.For IPython 0.11+, you can use the module directly as an extension, with``%load_ext memory_profiler``To activate it whenever you start IPython, edit the configuration file for yourIPython profile, ~/.ipython/profile_default/ipython_config.py, to register theextension like this (If you already have other extensions, just add this one tothe list)::    c.InteractiveShellApp.extensions = [        'memory_profiler',    ](If the config file doesn't already exist, run ``ipython profile create`` ina terminal.)It then can be used directly from IPython to obtain a line-by-linereport using the `%mprun` or `%%mprun` magic command. In this case, you can skipthe `@profile` decorator and instead use the `-f` parameter, likethis. Note however that function my_func must be defined in a file(cannot have been defined interactively in the Python interpreter)::    In [1]: from example import my_func, my_func_2    In [2]: %mprun -f my_func my_func()or in cell mode::    In [3]: %%mprun -f my_func -f my_func_2       ...: my_func()       ...: my_func_2()Another useful magic that we define is `%memit`, which is analogous to`%timeit`. It can be used as follows::    In [1]: %memit range(10000)    peak memory: 21.42 MiB, increment: 0.41 MiB    In [2]: %memit range(1000000)    peak memory: 52.10 MiB, increment: 31.08 MiBor in cell mode (with setup code)::    In [3]: %%memit l=range(1000000)       ...: len(l)       ...:    peak memory: 52.14 MiB, increment: 0.08 MiBFor more details, see the docstrings of the magics.For IPython 0.10, you can install it by editing the IPython configurationfile ~/.ipython/ipy_user_conf.py to add the following lines::    # These two lines are standard and probably already there.    import IPython.ipapi    ip = IPython.ipapi.get()    # These two are the important ones.    import memory_profiler    memory_profiler.load_ipython_extension(ip)===============================Memory tracking backends===============================`memory_profiler` supports different memory tracking backends including: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'.If no specific backend is specified the default is to use &quot;psutil&quot; which measures RSS aka &quot;Resident Set Size&quot;. In some cases (particularly when tracking child processes) RSS may overestimate memory usage (see `example/example_psutil_memory_full_info.py` for an example).For more information on &quot;psutil_pss&quot; (measuring PSS) and &quot;psutil_uss&quot; please refer to:https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info Currently, the backend can be set via the CLI    $ python -m memory_profiler --backend psutil my_script.pyand is exposed by the API    &gt;&gt;&gt; from memory_profiler import memory_usage    &gt;&gt;&gt; mem_usage = memory_usage(-1, interval=.2, timeout=1, backend=&quot;psutil&quot;)    ============================ Frequently Asked Questions============================    * Q: How accurate are the results ?    * A: This module gets the memory consumption by querying the      operating system kernel about the amount of memory the current      process has allocated, which might be slightly different from      the amount of memory that is actually used by the Python      interpreter. Also, because of how the garbage collector works in      Python the result might be different between platforms and even      between runs.    * Q: Does it work under windows ?    * A: Yes, thanks to the      `psutil &lt;http://pypi.python.org/pypi/psutil&gt;`_ module.=========================== Support, bugs &amp; wish list===========================For support, please ask your question on `stack overflow&lt;http://stackoverflow.com/&gt;`_ and add the `*memory-profiling* tag &lt;http://stackoverflow.com/questions/tagged/memory-profiling&gt;`_.Send issues, proposals, etc. to `github's issue tracker&lt;https://github.com/pythonprofilers/memory_profiler/issues&gt;`_ .If you've got questions regarding development, you can email medirectly at f@bianp.net.. image:: http://fa.bianp.net/static/tux_memory_small.png============= Development=============Latest sources are available from github:    https://github.com/pythonprofilers/memory_profiler===============================Projects using memory_profiler===============================`Benchy &lt;https://github.com/python-recsys/benchy&gt;`_`IPython memory usage &lt;https://github.com/ianozsvald/ipython_memory_usage&gt;`_`PySpeedIT &lt;https://github.com/peter1000/PySpeedIT&gt;`_ (uses a reduced version of memory_profiler)`pydio-sync &lt;https://github.com/pydio/pydio-sync&gt;`_ (uses custom wrapper on top of memory_profiler)========= Authors=========This module was written by `Fabian Pedregosa &lt;http://fseoane.net&gt;`_and `Philippe Gervais &lt;https://github.com/pgervais&gt;`_inspired by Robert Kern's `line profiler&lt;http://packages.python.org/line_profiler/&gt;`_.`Tom &lt;http://tomforb.es/&gt;`_ added windows support and speed improvements via the`psutil &lt;http://pypi.python.org/pypi/psutil&gt;`_ module.`Victor &lt;https://github.com/octavo&gt;`_ added python3 support, bugfixes and generalcleanup.`Vlad Niculae &lt;http://vene.ro/&gt;`_ added the `%mprun` and `%memit` IPython magics.`Thomas Kluyver &lt;https://github.com/takluyver&gt;`_ added the IPython extension.`Sagar UDAY KUMAR &lt;https://github.com/sagaru&gt;`_ added Report generation feature and examples.`Dmitriy Novozhilov &lt;https://github.com/demiurg906&gt;`_ and `Sergei Lebedev &lt;https://github.com/superbobry&gt;`_ added support for `tracemalloc &lt;https://docs.python.org/3/library/tracemalloc.html&gt;`_.`Benjamin Bengfort &lt;https://github.com/bbengfort&gt;`_ added support for tracking the usage of individual child processes and plotting them.`Muhammad Haseeb Tariq &lt;https://github.com/mhaseebtariq&gt;`_ fixed issue #152, which made the whole interpreter hang on functions that launched an exception.`Juan Luis Cano &lt;https://github.com/Juanlu001&gt;`_ modernized the infrastructure and helped with various things.`Martin Becker &lt;https://github.com/mgbckr&gt;`_ added PSS and USS tracking via the psutil backend.========= License=========BSD License, see file COPYING for full text.</longdescription>
</pkgmetadata>