<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Documentation Status](https://readthedocs.org/projects/smallab/badge/?version=latest)](https://smallab.readthedocs.io/en/latest/?badge=latest)# smallab:small_blue_diamond: :microscope: :small_blue_diamond:smallab (Small Lab) is an experiment framework designed to be easy to use with your experiment. The code in this repo should be understandable as a whole in at most 10 minutes.![](https://github.com/octopuscabbage/smallab/blob/master/smallab.gif)## Features* Easy to understand and simple* Easy parallelization of experiments* Only runs not previously completed experiments* Hooks allow monitoring batch progress* All parameters to methods use the typing module* Dashboard for monitoring experiment progress## Installation`pip install smallab`or clone here from source## Documentationhttps://smallab.readthedocs.io/en/latest/## UsageCheck out[`the examples folder`](https://github.com/octopuscabbage/smallab/tree/master/examples) or [`demo.py`](https://github.com/octopuscabbage/smallab/blob/master/demo.py) (Copied here)```pythonimport typingimport randomimport osimport dill#What you need to import from smallabfrom smallab.experiment_types.experiment import Experimentfrom smallab.runner.runner import ExperimentRunner#Write a simple experimentclass SimpleExperiment(Experiment):    #Need to implement this method, will be passed the specification    #Return a dictionary of results    def main(self, specification: typing.Dict) -&gt; typing.Dict:        random.seed(specification[&quot;seed&quot;])        for i in range(specification[&quot;num_calls&quot;]): #Advance the random number generator some amount           random.random()        if &quot;fail&quot; in specification and specification[&quot;fail&quot;]:            raise Exception()        return {&quot;number&quot;:random.random()}runner = ExperimentRunner()#Optional: Email yourself when the whole batch is done#Read https://stackoverflow.com/questions/5619914/sendmail-errno61-connection-refused about how to start an stmp serevrfrom smallab.utilities.email_hooks import EmailCallbackBatchOnlyrunner.attach_callbacks([EmailCallbackBatchOnly(&quot;test@test.com&quot;,40)])#Take it back off since we don't actually want to bother Mr. Testrunner.attach_callbacks([])#Set the specifications for our experiments, the author reccomends reading this from a json file!specifications = [{&quot;seed&quot;: 1,&quot;num_calls&quot;:1}, {&quot;seed&quot;:2,&quot;num_calls&quot;:1}]#Fire off the experimentrunner.run(&quot;random_number&quot;,specifications,SimpleExperiment())#Read back our resultsfor root,_,files in os.walk(runner.get_save_directory(&quot;random_number&quot;)):    for fname in files:        if &quot;.pkl&quot; in fname:            with open(os.path.join(root, fname), &quot;rb&quot;) as f:                results = dill.load(f)                print(results[&quot;specification&quot;][&quot;seed&quot;])                print(results[&quot;result&quot;][&quot;number&quot;])from smallab.specification_generator import SpecificationGenerator#If you want to run a lot of experiments but not manual write out each one, use the specification generator.#Note: This is also JSON serializable, so you could store this in a json filegeneration_specification = {&quot;seed&quot;:[1,2,3,4,5,6,7,8],&quot;num_calls&quot;:[1,2,3]}#Call the generate method. Will create the cross product.specifications = SpecificationGenerator().generate(generation_specification)print(specifications)runner.run(&quot;random_number_from_generator&quot;,specifications,SimpleExperiment(),continue_from_last_run=True)#Read back our resultsfor root,_,files in os.walk(runner.get_save_directory(&quot;random_number_from_generator&quot;)):    for fname in files:        if &quot;.pkl&quot; in fname:            with open(os.path.join(root, fname), &quot;rb&quot;) as f:                results = dill.load(f)                print(results[&quot;specification&quot;][&quot;seed&quot;])                print(results[&quot;result&quot;][&quot;number&quot;])#If you have an experiment you want run on a lot of computers you can use the MultiComputerGenerator#You assign each computer a number from 0..number_of_computers-1 and it gives each computer every number_of_computerth specificationfrom smallab.specification_generator import MultiComputerGeneratorall_specifications = SpecificationGenerator().from_json_file('test.json')g1 = MultiComputerGenerator(0,2)g2 = MultiComputerGenerator(1,2)specifications_1 = g1.from_json_file(&quot;test.json&quot;)specifications_2 = g2.from_json_file(&quot;test.json&quot;)assert len(specifications_1) + len(specifications_2) == len(all_specifications)#Need to freeze the sets in order to do set manipulation on dictionariesspecifications_1 = set([frozenset(sorted(x.items())) for x in specifications_1])specifications_2 = set([frozenset(sorted(x.items())) for x in specifications_2])all_specifications = set([frozenset(sorted(x.items())) for x in all_specifications])#This will generate two disjoint sets of specificationsassert specifications_1.isdisjoint(specifications_2)#That together make the whole specificationassert specifications_1.union(specifications_2) == all_specifications#You can use the provided logging callbacks to log completion and failure of specific specifcationsfrom smallab.utilities import logger_callbacksrunner.attach_callbacks([LoggingCallback()])runner.run('with_logging',SpecificationGenerator().from_json_file(&quot;test.json&quot;),SimpleExperiment(),continue_from_last_run=True)```## How it worksThe `ExperimentRunner` class is passed a list of dictionaries of specifications. These dictionaries need to be json serializable.The `ExperimentRunner` looks at the `completed.json` in the folder for the batch name (the name parameter of the `.run` method) and computes which experiments need to be run. The experiments that need to run are the specifications not in the `completed.json`.The `ExperimentRunner` begins runnning the batch either in parallel or single threaded. If the parallel implementation is used each specification is `joblib`'s threaded backend. Once all experiments are either completed or failed (they threw an exception) the results are saved as a `pickle` file. The results are saved in a dictionary that looks like ```python{    &quot;specification&quot;: &lt;the specification the experiment was passed&gt;,    &quot;result&quot;: &lt;what the experiment .main returned&gt;}```The return value of the experiment `.main` function must be `pickle` serializable. ### CallbacksThe runner has several hooks which are called at different times. * `on_specification_complete` called whenever a specification completes running (Ususually a single experiment)* `on_specification_falure` called whenver a specification fails running (Throws an exception)* `on_batch_complete` called after runner `.run` has finished running, passed all the succesfully completed specifications* `on_batch_failure` called after runner `.run` has finished running, passed all the failed specifications### Folder StructureEach experiment is saved in the following structure```experiment_runs/  &lt;name&gt;/                        # The name you provide to runner.run    &lt;specification_hash&gt;/        # A hash of the dictionary you provide as the specification      specification.json         # The specification.json        &lt;specification_hash&gt;.pkl # The results dictionary```</longdescription>
</pkgmetadata>