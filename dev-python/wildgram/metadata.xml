<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Wildgram tokenizes english text into &quot;wild&quot;-grams (tokens of varying word count)that match closely to the the natural pauses of conversation. I originally builtit as the first step in an abstraction pipeline for medical language: sincemedical concepts tend to be phrases of varying lengths, bag-of-words or bigramsdoesn't really cut it.Wildgram works by measuring the size of the noise (stopwords, punctuation, andwhitespace) and breaks up the text against noise of a certain size(it varies slightly depending on the noise).Parameters:textRequired: YesDefault: NoWhat it is: the text you want to wildgram.stopwordsRequired: NoDefault: STOPWORDS list (importable, mostly based on NLTK's stop word list)What it is: a list of stop words that you want to mark as noise, that will act as breaks between tokens.Custom Override: a list of strings that you want to split on.topicwordsRequired: NoDefault: TOPICWORDS list (importable)What it is: a list of stop words that you want to mark as tokens because they have meaning, but often serve to break up larger pieces of text. Examples include numbers, negation words like &quot;won't&quot;, etc. Includes numbers,negations, and that kind of thing. Words that start with a number and end with a non-space, non-digit stringare split up, because the assumption is they are meaningfully distinct -- e.g. &quot;123mg&quot; -&gt; &quot;123&quot;, &quot;mg&quot;.Custom Override: a list of strings that you want to split on. You can also store a mixed list ofdictionaries and strings, dictionaries in the form {token: &quot;text&quot;, tokenType: &quot;custom type&quot;}for example, by default any negation stop words (like &quot;no&quot;) have a tokenType of &quot;negation&quot;.If no tokenType is set, the type is &quot;token&quot;.include1gramRequired: NoDefault: TrueWhat it is: when set to true, wildgram will also return every individual word or token as well as any phrases it finds.Custom Override: Boolean (false). When set to false, wildgram will only return the phrases it finds, not 1grams as well.joinerwordsRequired: NoDefault: JOINERWORDS list (importable, words like &quot;of&quot;)What it is: a list of stop words (must also be included in stop word list if overridden) that join two phrases together. Example: &quot;shortness of breath&quot; -&gt; &quot;shortness&quot;, &quot;breath&quot;, &quot;shortness of breath&quot;.Custom Override: a list of strings you want to join on. WORDS MUST BE IN STOPWORDS LIST FOR THIS TO WORK. The assumption is you wouldn't want a joiner word that is also a topic word.returnNoiseRequired: NoDefault: TrueWhat it is: when set to true, wildgram will also return each individual noise token it created to find the phrases.Custom Override: Boolean (false). When set to false, it will not return the noise tokens.includeParentRequired: NoDefault: FalseNote: In the process of being deprecated, because I didn't find it to be useful in topic organizing.What it is: when set to true, wildgram will also return the &quot;parent&quot; of the token, in a pseudo-dependency tree.This tree is generated using a ranked list of the prior (in the text) styles of punctuation to approximatethe relationships between tokens. Noise tokens act as branching nodes while normal tokens can only be leaf nodes,so in practice this is used to determine the &quot;uncles&quot; of the token. Examples of how this might be useful islinking list like elements under a larger heading or figuring out the unit of a number based on the context (which may not be on the same line). Since noise tokens are the branching nodes, returnNoise must be set to true if includeParent is true.Custom Override: Boolean (True). When set to True, it will not return the parent.Returns:a list of dictionaries, each dictionary in the form:```pythonexample = {&quot;startIndex&quot;: 0,&quot;endIndex&quot;, 5,&quot;token&quot;: &quot;hello&quot;,&quot;tokenType&quot;: &quot;token&quot; # if noise, token type is &quot;noise&quot;&quot;index&quot;: 0}```The list is sorted in ascending (smallest-&gt;largest) order for the startIndex, then the endIndex.Example code:```pythonfrom wildgram import wildgramranges = wildgram(&quot;and was beautiful&quot;, returnNoise=False)#[{#&quot;startIndex&quot;: 8,#&quot;endIndex&quot;, 17,#&quot;token&quot;: &quot;beautiful&quot;,#&quot;tokenType&quot;: &quot;token&quot;,# &quot;index&quot;: 0#}]from wildgram import wildgramranges = wildgram(&quot;and was beautiful day&quot;)print(ranges)'''[{  &quot;startIndex&quot;: 0,  &quot;endIndex&quot;: 8,  &quot;token&quot;: &quot;and was &quot;,  &quot;tokenType&quot;: &quot;noise&quot;,  &quot;index&quot;: 0},{  &quot;startIndex&quot;: 8,  &quot;endIndex&quot;: 17,  &quot;token&quot;: &quot;beautiful&quot;,  &quot;tokenType&quot;: &quot;token&quot;,  &quot;index&quot;: 1},{  &quot;startIndex&quot;: 8,  &quot;endIndex&quot;: 21,  &quot;token&quot;: &quot;beautiful day&quot;,  &quot;tokenType&quot;: &quot;token&quot;,  &quot;index&quot;: 2},{  &quot;startIndex&quot;: 17,  &quot;endIndex&quot;: 18,  &quot;token&quot;: &quot; &quot;,  &quot;tokenType&quot;: &quot;noise&quot;,  &quot;index&quot;: 3},{  &quot;startIndex&quot;: 18,  &quot;endIndex&quot;: 21,  &quot;token&quot;: &quot;day&quot;,  &quot;tokenType&quot;: &quot;token&quot;,  &quot;index&quot;: 4}]'''```With versions &gt;= 0.2.9, there is also the class WildRules. This applies a set ofrules to the tokenized wildgram, making a basic rule based classifier. This shallbe optimized in future versions for speed, etc. In later versions, it also allows youto specify given phrases nearby.With version &gt;= 0.4.1, there is also the class WildForm. This lets you groupthe output of wildrules into potentially overlapping or incomplete forms. In later versions, we willadd extra validation functionalityexample:```pythonfrom wildgram import WildRules, WildFormtest= WildRules([{&quot;unit&quot;: &quot;TEST&quot;, &quot;value&quot;: &quot;unknown&quot;, &quot;spans&quot;: [&quot;testing&quot;, &quot;test&quot;], &quot;spanType&quot;: &quot;token&quot;, &quot;nearby&quot;: [{&quot;spanType&quot;: &quot;token&quot;, &quot;spans&quot;: [&quot;1234&quot;]}]}, {&quot;unit&quot;: &quot;Dosage&quot;, &quot;value&quot;: {&quot;asType&quot;: &quot;float&quot;, &quot;spanType&quot;: &quot;token&quot;}, &quot;spans&quot;: [&quot;numeric&quot;], &quot;spanType&quot;: &quot;tokenType&quot;}])ret = test.apply(&quot;testing test 123&quot;)# note the unit for testing test is unknown, because it is missing 1234 in the general area# note it can do basic parsing for values, say numbers.[{'unit': 'unknown', 'value': &quot;unknown&quot; 'token': 'testing test', 'startIndex': 0, 'endIndex': 12}, {'unit': 'Dosage', &quot;value&quot;: 123.0, 'token': '123', 'startIndex': 13, 'endIndex': 16}]ret = test.apply(&quot;testing test 1234&quot;)## returns the unit TEST, since 1234 is in the area[{'unit': 'TEST', 'value': &quot;unknown&quot; 'token': 'testing test', 'startIndex': 0, 'endIndex': 12}, {'unit': 'Dosage', &quot;value&quot;: 1234.0, 'token': '1234', 'startIndex': 13, 'endIndex': 17}]forms = WildForm()## lets add a basic form, with one &quot;question&quot; (e.g. a unit-value pair where the value is &quot;&quot;)forms.add_form({&quot;unit&quot;: &quot;test&quot;, &quot;value&quot;: &quot;testing&quot;, &quot;children&quot;: [{&quot;unit&quot;: &quot;test&quot;, &quot;value&quot;: &quot;&quot;, &quot;children&quot;: []}]})## lets add a second form, with two &quot;questions&quot;forms.add_form({&quot;unit&quot;: &quot;test&quot;, &quot;value&quot;: &quot;testing&quot;, &quot;children&quot;: [{&quot;unit&quot;: &quot;test&quot;, &quot;value&quot;: &quot;&quot;, &quot;children&quot;: []}, {&quot;unit&quot;: &quot;Dosage&quot;, &quot;value&quot;: &quot;&quot;, &quot;children&quot;: []}]})## lets apply this to this phrase:rules = WildRules([{&quot;unit&quot;: &quot;test&quot;, &quot;value&quot;: &quot;unknown&quot;, &quot;spans&quot;: [&quot;testing&quot;, &quot;test&quot;], &quot;spanType&quot;: &quot;token&quot;}, {&quot;unit&quot;: &quot;Dosage&quot;, 'value': {&quot;spanType&quot;: &quot;token&quot;, &quot;asType&quot;: &quot;float&quot;}, &quot;spans&quot;: [&quot;numeric&quot;], &quot;spanType&quot;: &quot;tokenType&quot;}])ret = rules.apply(&quot;testing, can anyone hear me? testing 1234&quot;)## output:[{'unit': 'test', 'value': 'unknown', 'token': 'testing', 'startIndex': 0, 'endIndex': 7}, {'unit': 'unknown', 'value': 'unknown', 'token': 'anyone hear me', 'startIndex': 13, 'endIndex': 27}, {'unit': 'test', 'value': 'unknown', 'token': 'testing', 'startIndex': 29, 'endIndex': 36}, {'unit': 'Dosage', 'value': 1234.0, 'token': '1234', 'startIndex': 37, 'endIndex': 41}]forms.apply(ret)## returns## note: returns four forms: 2 filled out copies of the first form (for each instance of &quot;testing&quot;, note start/endIndex)## 2 copies of the second form: note that 1 copy has a missing value for dosage, since in 1 instance of testing there## is no value of dosage that is not nearer to the previous## so inter-form overlap is possible, but not intra-form overlap## tokens are assigned right to left, so if there is a conflict the value belongs to the stuff on the left, and then the## new question gets to start its own form even if the other form is incomplete## it keeps track of the closest token (from rules) and if there are &gt;= 3 tokens between the closest token in the form## and the current one it also creates a new form, since it assumes the information will be close together## this assumption may be modified, or overridden in time. I haven't decided yet, but it holds up pretty well for the things## i want to pull from notes.[{'unit': 'test', 'value': 'testing', 'children': [{'unit': 'test', 'value': 'unknown', 'children': [], 'startIndex': 0, 'endIndex': 7, 'token': 'testing'}]}, {'unit': 'test', 'value': 'testing', 'children': [{'unit': 'test', 'value': 'unknown', 'children': [], 'startIndex': 29, 'endIndex': 36, 'token': 'testing'}]}, {'unit': 'test', 'value': 'testing', 'children': [{'unit': 'test', 'value': 'unknown', 'children': [], 'startIndex': 0, 'endIndex': 7, 'token': 'testing'}, {'unit': 'Dosage', 'value': '', 'children': []}]}, {'unit': 'test', 'value': 'testing', 'children': [{'unit': 'test', 'value': 'unknown', 'children': [], 'startIndex': 29, 'endIndex': 36, 'token': 'testing'}, {'unit': 'Dosage', 'value': 1234.0, 'children': [], 'startIndex': 37, 'endIndex': 41, 'token': '1234'}]}]```## Handling Form meta information:On the data element you want it to apply, add a child with unit &quot;EHR&quot; and value &quot;META-FORM&quot;:```python3{your data element &quot;children&quot;: [{'unit': 'EHR', 'value': 'META-FORM', 'children': []}]}```Meta information can be added in no particular order as a child of the EHR:META-FORM pair.Available Arguments:&quot;EHR&quot;:&quot;INTRA-FORM-SHARABLE&quot; - if added, it will allow the same data element to be added to multiple copies of the same form. Default is that it assumes that elements cannot be shared across copies of the same form. An example would be a sentence like &quot;for 3 weeks had nausea, diarrhea, and vomiting&quot; would associate the element weeks:3 with nausea AND diarrhea AND vomiting. Note that the reverse isn't true -- so &quot;had nausea, diarrhea, and vomiting for 3 weeks&quot;, weeks:3 is only associated with vomiting, since the meaning isn't clear (is it they have nausea/diarrhea/vomiting, and vomiting for 3 weeks or 3 weeks for all three?).That's all folks!</longdescription>
</pkgmetadata>