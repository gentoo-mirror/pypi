<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>greenback: reenter an asyncio or Trio event loop from synchronous code======================================================================.. image:: https://img.shields.io/pypi/v/greenback.svg   :target: https://pypi.org/project/greenback   :alt: Latest PyPI version.. image:: https://img.shields.io/badge/docs-read%20now-blue.svg   :target: https://greenback.readthedocs.io/en/latest/?badge=latest   :alt: Documentation status.. image:: https://travis-ci.org/oremanj/greenback.svg?branch=master   :target: https://travis-ci.org/oremanj/greenback   :alt: Automated test status.. image:: https://codecov.io/gh/oremanj/greenback/branch/master/graph/badge.svg   :target: https://codecov.io/gh/oremanj/greenback   :alt: Test coverage.. image:: https://img.shields.io/badge/code%20style-black-000000.svg   :target: https://github.com/ambv/black   :alt: Code style: black.. image:: http://www.mypy-lang.org/static/mypy_badge.svg   :target: http://www.mypy-lang.org/   :alt: Checked with mypyPython 3.5 introduced ``async``/``await`` syntax for definingfunctions that can run concurrently in a cooperative multitaskingframework such as ``asyncio`` or `Trio&lt;https://trio.readthedocs.io/&gt;`__. Such frameworks have a number of advantagesover previous approaches to concurrency: they scale better than threads and are`clearer about control flow &lt;https://glyph.twistedmatrix.com/2014/02/unyielding.html&gt;`__than the implicit cooperative multitasking provided by ``gevent``. They're also beingactively developed to explore some `exciting new ideas about concurrent programming&lt;https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/&gt;`__.Porting an existing codebase to ``async``/``await`` syntax can bechallenging, though, since it's somewhat &quot;viral&quot;: only an asyncfunction can call another async function. That means you don't just haveto modify the functions that actually perform I/O; you also need to(trivially) modify every function that directly or indirectly calls afunction that performs I/O. While the results are generally an improvement(&quot;explicit is better than implicit&quot;), getting there in one big step is notalways feasible, especially if some of these layers are in libraries thatyou don't control.``greenback`` is a small library that attempts to bridge this gap. Itallows you to **call back into async code from a syntacticallysynchronous function**, as long as the synchronous function wasoriginally called from an async task (running in an asyncio or Trioevent loop) that set up a ``greenback`` &quot;portal&quot; as explainedbelow. This is potentially useful in a number of different situations:* You can interoperate with some existing libraries that are not  ``async``/``await`` aware, without pushing their work off into  another thread.* You can migrate an existing program to ``async``/``await``  syntax one layer at a time, instead of all at once.* You can (cautiously) design async APIs that block in places where  you can't write ``await``, such as on attribute accesses.``greenback`` requires Python 3.6 or later and an implementation thatsupports the ``greenlet`` library. Either CPython or PyPy should work.There are no known OS dependencies.Quickstart----------* Call ``await greenback.ensure_portal()`` at least once in each task that will be  using ``greenback``. (Additional calls in the same task do nothing.) You can think  of this as creating a portal that will be used by future calls to  ``greenback.await_()`` in the same task.* Later, use ``greenback.await_(foo())`` as a replacement for  ``await foo()`` in places where you can't write ``await``.* For more details and additional helper methods, see the  `documentation &lt;https://greenback.readthedocs.io&gt;`__.Example-------Suppose you start with this async-unaware program::    import subprocess    def main():        print_fact(10)    def print_fact(n, mult=1):        &quot;&quot;&quot;Print the value of *n* factorial times *mult*.&quot;&quot;&quot;        if n &lt;= 1:            print_value(mult)        else:            print_fact(n - 1, mult * n)    def print_value(n):        &quot;&quot;&quot;Print the value *n* in an unreasonably convoluted way.&quot;&quot;&quot;        assert isinstance(n, int)        subprocess.run(f&quot;echo {n}&quot;, shell=True)    if __name__ == &quot;__main__&quot;:        main()Using ``greenback``, you can change it to run in a Trio event loop bychanging only the top and bottom layers, with no change to ``print_fact()``. ::    import trio    import greenback    async def main():        await greenback.ensure_portal()        print_fact(10)    def print_fact(n, mult=1):        &quot;&quot;&quot;Print the value of *n* factorial times *mult*.&quot;&quot;&quot;        if n &lt;= 1:            print_value(mult)        else:            print_fact(n - 1, mult * n)    def print_value(n):        &quot;&quot;&quot;Print the value *n* in an unreasonably convoluted way.&quot;&quot;&quot;        assert isinstance(n, int)        greenback.await_(trio.run_process(f&quot;echo {n}&quot;, shell=True))    if __name__ == &quot;__main__&quot;:        trio.run(main)FAQ---**Why is it called &quot;greenback&quot;?** It uses the `greenlet&lt;https://greenlet.readthedocs.io/en/latest/&gt;`__ library to get you*back* to an enclosing async context. Also, maybe it saves you `money&lt;https://www.dictionary.com/browse/greenback&gt;`__ (engineering time) orsomething.**How does it work?** After you run ``await greenback.ensure_portal()``in a certain task, each step of that task will run inside a greenlet.(This is achieved by interposing a &quot;shim&quot; coroutine in between the eventloop and the coroutine for your task; see the source code for details.)Calls to ``greenback.await_()`` are then able to switch from that greenletback to the parent greenlet, which can easily perform the necessary``await`` since it has direct access to the async environment. Theper-task-step greenlet is then resumed with the value or exceptionproduced by the ``await``.**Should I trust this in production?** Maybe; try it and see. Thetechnique is in some ways an awful hack, and has some performanceimplications (any task in which you call ``awaitgreenback.ensure_portal()`` will run somewhat slower), but we're ingood company: SQLAlchemy's async ORM support is implemented in muchthe same way.  ``greenback`` itself is a fairly small amount ofpure-Python code on top of ``greenlet``.  (There is one reasonablysafe ctypes hack that is necessary to work around a knob that's notexposed by the asyncio acceleration extension module on CPython.)``greenlet`` is a C module full of arcane platform-specific hacks, butit's been around for a very long time and popular production-qualityconcurrency systems such as ``gevent`` rely heavily on it.**What won't work?** A few things:* Greenlet switching works by moving parts of the C stack to different  memory addresses, relying on the assumption that Python objects are  fully heap-allocated and don't contain any pointers into the C  stack. Poorly-behaved C extension modules might violate this  assumption and are likely to crash if used with ``greenback``.  Such extension modules are buggy and could be made to crash without  ``greenback`` too, but perhaps only under an obscure or unlikely  series of operations.* Calling ``greenback.await_()`` inside a finalizer (``__del__``  method), signal handler, or weakref callback is unsupported. It  might work most of the time, or even all the time, but the  environment in which such methods run is weird enough that the  author isn't prepared to make any guarantees.  (Not that you have  any guarantees about the rest of it, just some better theoretical  grounding.)License-------``greenback`` is licensed under your choice of the MIT or Apache 2.0 license.See `LICENSE &lt;https://github.com/oremanj/greenback/blob/master/LICENSE&gt;`__for details.</longdescription>
</pkgmetadata>