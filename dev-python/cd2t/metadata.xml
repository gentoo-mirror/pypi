<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># cd2t**repository**: [https://gitlab.com/ko.no/cd2t](https://gitlab.com/ko.no/cd2t)**Table of Content**- [Key Features](#key-features)- [Change Log](#change-log)- [Data Schema](#data-schema)  - [Version 2](#version-2)  - [Version 1](#version-1)- [Built-in Data Types](#built-in-data-types)  - [Generic Data Types](#generic-data-types)    - ['any' Data Type](#any-data-type)    - ['bool' Data Type](#bool-data-type)    - ['enum' Data Type](#enum-data-type)    - ['float' Data Type](#float-data-type)    - ['idlist' Data Type](#idlist-data-type)    - ['integer' Data Type](#integer-data-type)    - ['list' Data Type](#list-data-type)    - ['multitype' Data Type](#multitype-data-type)    - ['none' Data Type](#none-data-type)    - ['object' Data Type](#object-data-type)    - ['schema' Data Type](#schema-data-type)    - ['string' Data Type](#string-data-type)  - [Special Data Types](#special-data-types)    - ['fqdn' Data Type](#fqdn-data-type)    - ['hostname' Data Type](#hostname-data-type)    - ['ip' Data Type](#ip-data-type)  - [General Data Type Options](#general-data-type-options)    - [Reference Options](#reference-options)- [Feature Details](#feature-details)  - [Custom Data Types](#custom-data-types)- [Python Code Example](#python-code-example)## Key Features- **Feature Rich Data Type and Value Validation**- **Unlimited Data Structure**: Recursive linking of data types like lists or  objects can represent any data structure.- **Data Structure Nesting**: Templates allows you to define repeating data  structures only once. Templates can be unlimited nested. Loops are not  allowed.- **Referencing**: Referencing can check the **uniqueness** of values at  different positions in the data structure (i.e. lists of objects with ID  attribute). It also can enforce a **consumer/producer modell**. In example,  strings at some positions can be collected as *producers*. Strings at other  positions must match to one of those *produced* string. Scope of references  can be limited to namespace.- **Multi Data Support**: Multiple data sources can be checked with one schema  or many schemas. You can switch schemas during iterating over data sources.  Referencing or Autogeneration works across schemas and data sources by using  namespaces and reference keys.- **Value Autogeneration**: Some data types support creation of non-existing  values. I.e. unique IDs can be added to a data structure.Uniqueness can be limited to namespaces.- **Schema Validation**: Typos, syntax mistakes or missing required options are  reported as SchemaErrors (Exception) during schema loading. Reason and path  through schema structured are provided.- **Data Validation**: Validation returns a list of findings. Each finding  provides the position within the data structure and the validation finding  reason.## Change Log**Version 2.0.0**:- *Changed*: Templates replaces subschemas.- *New*: Schema version 2 introduced- *New*: IDs in 'idlist' are defined by any other data type  in schema version 2.- *New*: Reference attributes definition changed in 'object'  in schema version 2.- *New*: Custom pre-defined data types can be defined in schema.- *New*: Reference credit support - Producer values and consumer values can  be assignet with credits to detect 'overloaded' producers.- *New*: ruamel.yaml support - If data is loaded with ruamel.yaml module,  autogenerated values have inline comments.- *New*: Data type 'ip' and some specialized IP related data types added.- *New*: Data type 'hostname' and 'fqdn' added.- *New*: All data types description support**Version 1.6.2**:- *Fix*: Reference false positives, if Validator object changes- *Fix*: Sorting of Validation or Autogeneration findings**Version 1.6.1**:- *Fix*: Data Type shortcut mode with classic dictionary schema**Version 1.6.0**:- *Changed*: Python 3.9 or higher required- *New*: Data Type Shortcuts - Specify data type with defaults as string only- *Add*: Validator API - Method to get reference findings- *Changed*: Multitype Data Type - Enhanced data type support**Version 1.5.0**:- *New*: Integer Data Type - Autogenerate random value- *New*: Integer Data Type - Autogenerate default value- *New*: Improved Reference Findings- *Changed*: All Data Types - Schema and data path adjustment**Version 1.4.0**:- *New*: None Data Type added- *Fix*: Consumer namespace space lookup/linking failed,  if producer was processed later.**Version 1.3.1**:- *Fix*: Schema Data Type - Validation failed**Version 1.3**:- *New*: String Data Type - Consumer referencing with namespace lookup for  providers support- *Changed*: Splitting Data Validation (Validator Class) and  Data Autogeneration (Autogenerator Class)- *New*: 2-Phase Autogeneration  - Phase 1: Build references for all data sources  - Phase 2: Autogenerate data based only full reference information- *Fix*: Object Data Type - Attribute dependencies with regex fixed- *Fix*: Object Data Type - Preserve attribute order during autogeneration**Version 1.2**:- *New*: Bool Data Type - Validate allowed value- *New*: Findings - Namespace information added- *Changed/Fix*: Validator method name 'change_namespace'- *Fix*: Schema Data Type - Subschema loop false positives- *Fix*: Referencing - Options for scope definition values- *Fix*: Referencing - Namespace local consumer producer linking- *Fix*: Object Data Type - Dependencies false positives**Version 1.1**: *withdrawn form pypi.org*- *New*: Object Data Type - Allow empty dictionaries in validation- *Changed*: List Data Type - Option 'duplicates' renamed to 'allow_duplicates'**Version 1.0**: *withdrawn form pypi.org*## Data SchemaData schema describes the expected structure and the expected values of the data,which to be validated. It also includes schema meta data and control options.### Version 2```yamlname: &lt; str &gt;description: &lt; str &gt;allow_data_type_shortcuts: &lt; bool | default -&gt; true &gt;# Shortcuts are Data Type strings instead of dictionaries.# Corresponding data type with default options is used.root: { data type schema }custom_data_types:  &lt; data type name &gt;:    type: &lt; built-in data type name &gt; # required; customizable data type    &lt; build-in data type option &gt;: &lt; value &gt;templates:  &lt; template name &gt;: { data schema }template_merge_options:  recursive: &lt; bool | default -&gt; true &gt;  list_merge: &lt; append | append_rp | prepend | prepend_rp | replace                | default -&gt; append_rp &gt;```### Version 1```yamlname: &lt; str &gt;description: &lt; str &gt;allow_data_type_shortcuts: &lt; bool | default -&gt; false &gt;# Shortcuts are Data Type strings instead of dictionaries.# Corresponding data type with default options is used.root: { data type schema }subschemas:  &lt; sub schema name &gt;: { data type schema }```## Built-In Data Types### Generic Data Types#### 'any' Data Type##### 'any' DescriptionThis data type represents any data. The validator stops further data validationor autogeneration.##### 'any' Limitations- *referencing* is not supported- *autogeneration* is not supported##### 'any' Schema```yamltype: 'any' # If type is omitted, validator uses Any Data Typedescription: &lt; str &gt; # Information about data type and value```#### 'bool' Data Type##### 'bool' DescriptionThis data type represents a boolean values (true/false).##### 'bool' Limitations- *referencing* is not supported##### 'bool' Schema```yamltype: 'bool'description: &lt; str &gt; # Information about data type and valueallowed_value: &lt; bool &gt; # true or falseautogenerate: &lt; bool | default -&gt; false &gt;# Autogenerate the default value, if data is not existing.# Requires 'autogenerate_default'autogenerate_default: &lt; bool &gt; # true or false; must match 'allowed_value' (if set)```#### 'enum' Data Type##### 'enum' DescriptionThis data type represents a selection of allowed values.##### 'enum' Limitations- *referencing* is not supported- *autogeneration* is not supported##### 'enum' Schema```yamltype: 'enum'description: &lt; str &gt; # Information about data type and valueallowed_values: # required- &lt; value &gt;```#### 'float' Data Type##### 'float' DescriptionThis data type represents float values.##### 'float' LimitationsNone.##### 'float' Schema Keys```yamltype: 'float'description: &lt; str &gt; # Information about data type and valuereference: { unique options }maximum: &lt; float &gt;# value must be lower or equal to thisminimum: &lt; float &gt;# value must be greater or equal to thismaximum_decimals: &lt; int &gt; # &gt;= 0# Maximum allowed decimal places.allowed_values:- &lt; float &gt; # value must match this value- round: &lt; int &gt; # value rounded to &lt; int &gt; digits must match 'matches'  matches: &lt; float &gt;- range_start: &lt; float &gt; # 'range_start' &lt;= value &lt;= 'range_end'  range_end: &lt; float &gt;# List of directives which values must match.not_allowed_values:- &lt; float &gt; # value mustn't match this value- round: &lt; int &gt; # value rounded to &lt; int &gt; digits mustn't match 'matches'  matches: &lt; float &gt;- range_start: &lt; float &gt; # value &lt; 'range_start' and value &gt; 'range_end'  range_end: &lt; float &gt;# List of directives which values mustn't match.autogenerate: &lt; bool | default -&gt; false &gt;# uses 'autogenerate_default' value.## OR## try for 'autogenerate_random_tries' times:#   1. Create a random float value, which is within the 'autogenerate_ranges'#      or 'minimum' &lt;= random value &lt;= 'maximum'#   2. Check if random value passes the validation process.autogenerate_default: &lt; float &gt;# Autogenerate uses this value.autogenerate_random_tries: &lt; int | default 10 &gt; # 0 &lt; x &lt; 50# Ignored, if 'autogenerate_default' is set.# Maximum amount of tries to find a random float value,# which is not used by any reference.# Integer value must be greater than 0 and lower than 50.autogenerate_ranges:- minimum: &lt; float &gt;  maximum: &lt; float &gt;# Ignored, if 'autogenerate_default' is set.# '[.]minimum' &lt;= '[.]maximum'# Autogenerated float is within the ranges.# If omitted, global 'minimum' and 'maximum' limits the random value.autogenerate_random_decimals: &lt; int | default 2 &gt; # &gt;= 0# Ignored, if 'autogenerate_default' is set.# Limit the decimal places for the random value.```##### 'float' Validation ProcessIf options are missing, corresponding checks are skipped.1. value &gt;= minimum2. value &lt;= maximum3. round of value == value4. value is not in not_allowed_values5. value is in allowed_values#### 'idlist' Data Type##### 'idlist' DescriptionThis data type represents a dictionary, where keys are IDs.IDs can be strings or integer.##### 'idlist' Limitations- *autogeneration* is not supported##### 'idlist' Schema (in Version 2)```yamltype: 'idlist'description: &lt; str &gt; # Information about data type and valuereference: { unique options }# Note: Every ID is referenced as a value with the 'reference.key'.minimum: &lt;int | default -&gt; 0 &gt; # &gt;= 0# Minimum required amount of IDsmaximum: &lt; int &gt; # &gt;= 0# Maximum allowed amount of IDs# If omitted, even an empty idlist is allowed.elements: { data type schema } # required# Data schema defining element data typeid: { data type schema }# Data schema defining IDs# If omitted, ID type defaults to 'string'.```##### 'idlist' Schema (in Version 1)```yamltype: 'idlist'description: &lt; str &gt; # Information about data type and valuereference: { unique options }# Note: Every ID is referenced as a value with the 'reference.key'.minimum: &lt;int | default -&gt; 0 &gt; # &gt;= 0# Minimum required amount of IDsmaximum: &lt; int &gt; # &gt;= 0# Maximum allowed amount of IDs# If omitted, even an empty idlist is allowed.elements: { data type schema } # required# Data schema defining element data typeid_type: &lt; 'integer' | 'string' | default -&gt; 'string' &gt;# Indicates if IDs are integer or stringid_minimum: &lt;int | default -&gt; 0 &gt; # &gt;= 0# Minimum required ID string length or minimum ID integer valueid_maximum: &lt; int &gt; # &gt;= 0# Maximum required ID string length or maximum ID integer value# If omitted, even '' is allowed as ID string.allowed_ids:- &lt; string | integer &gt;# List of regex strings or integers - depending on 'id_type'# If ID matches any of it, the ID is allowed.not_allowed_ids:- &lt; string &gt;# List of regex strings or integers - depending on 'id_type'# If ID matches any of it, the ID is not allowed.# 'not_allowed_ids' are test before 'allowed_ids'.```#### 'integer' Data Type##### 'integer' DescriptionThis data type represents integer values.##### 'integer' LimitationsNone.##### 'integer' Schema```yamltype: 'integer'description: &lt; str &gt; # Information about data type and valuereference: { unique options }maximum: &lt; int &gt;# value must be lower or equal to thisminimum: &lt; int &gt;# value must be greater or equal to thisnot_allowed_values:- &lt; int &gt;# List of integers which values mustn't match.autogenerate: &lt; bool | default -&gt; false &gt;# Requires 'reference.key' to be defined and not ''.# If no unique value could be generated, autogeneration fails.autogenerate_default: &lt; int &gt;# Generate this integer value if value is None.# Ignores all other 'autogen' optionsautogenerate_maximum: &lt; int &gt;# Autogenerated integer must be lower or equals to this.# If omitted, 'maximum' key is upper limitautogenerate_minimum: &lt; int &gt;# Autogenerated integer must be greater or equals to this.# If omitted, 'minimum' key is lower limitautogenerate_find: &lt; 'next_higher' | 'next_lower' |                     'random' | default -&gt; 'next_higher' &gt;# Ignored, if 'autogenerate_default' is set.# Tells autogenerate to try first available integer value# starting at 'minimum' and increasing ('next_higher'),# starting at 'maximum' and decreasing ('next_lower') or# picking a random number within 'minimum' and 'maximum'.```#### 'list' Data Type##### 'list' DescriptionThis data type represents a list of same data types.  If different data types are allowed in the list,use data type 'multitype' as elements.##### 'list' Limitations- Not customizable- *referencing* is not supported - use referencing in the 'elements' data type- *autogeneration* of list elements is not supported - but autogeneration  within existing elements data structure is supported (pass-through).##### 'list' Schema```yamltype: 'list' # requireddescription: &lt; str &gt; # Information about data type and valueelements: { data type schema }  # required# Data schema defining elements data typeminimum: &lt;int | default -&gt; 0 &gt; # &gt;= 0# Minimum required amount of elements in the list.maximum: &lt; int &gt; # &gt;= 0# Maximum allowed amount of elements in the list.allow_duplicates: &lt; bool | default -&gt; true &gt;# Allow same element data multiple times```#### 'multitype' Data Type##### 'multitype' DescriptionThis data type represents a selection of allowed data types.##### 'multitype' Features &amp; Limitations- Not customizable- *referencing* is not supported - use referencing in the 'elements' data type- *autogeneration* of data types is not supported - but autogeneration within  existing data structure is supported (pass-through).- *Multitype* in *Multiype* is not allowed##### 'multitype' Schema```yamltype: 'multitype'description: &lt; str &gt; # Information about data type and valuetypes: # required- { data type schema }# List of data type schemas.```#### 'none' Data Type##### 'none' DescriptionThis data type represents a none or null value.##### 'none' Limitations- *referencing* is not supported- *autogeneration* of data types is not supported - it is already none :wink:##### 'none' Schema Keys```yamltype: 'none'description: &lt; str &gt; # Information about data type and value```#### 'object' Data Type##### 'object' DescriptionThis data type represents an object with attributes.Technically its a dictionary in Python.  Attributes of the object are keys in the dictionary.##### 'object' Limitations- Not customizable- *autogeneration* of missing keys is supported, if value data type supports autogeneration##### 'object' Schema (in Version 2)```yamltype: 'object'description: &lt; str &gt; # Information about data type and valueattributes:  &lt; attribute_name &gt;: { data type schema }# Mapping with key as attribute name and value as data type schema.# If omitted, any data which is an dictionary is accepted.required_attributes:- &lt; attribute_name &gt;# List of attribute names, which must be in the object.ignore_undefined_attributes: &lt; bool | default -&gt; false &gt;# Tell validator to ignore attributes in data object,# which are not defined in 'attributes'.dependencies:  &lt; attribute_name &gt;:    requires:    - &lt; attribute_name &gt;    # List of attribute names, which must be in the object,    # if this attribute is in.    excludes:    - &lt; attribute_name &gt;    # List of attribute names, which must not be in the object,    # if this attribute is in.allow_regex_attributes: &lt; bool | default -&gt; False &gt;# If enabled, regular expressions are allowed in:# 'attributes': If object attribute name matches, schema is verified.# 'required_attributes': Each element must have a at least one matching#                        attribute name.# 'dependencies.&lt;&gt;.requires': Successful if any object attribute name matches#                             each list entry.# 'dependencies.&lt;&gt;.excludes': Error if any object attribute name matches any#                             list entry.# !!! Disables autogeneration of missing keys !!!autogenerate: &lt; bool | default -&gt; True &gt;# Enable/Disable autogeneration of missing attributes,# if 'allow_regex_attributes' == false and# attribute's data type supports autogeneration and is defined within.reference:  { reference options }  # The validator checks, if the same combination of attribute values  # is specified at another data type with the same 'reference.key'.  attributes:    - &lt; attribute_name &gt;    # List of attribute names, which values should be combined uniqueness check.```##### 'object' Schema (in Version 1)```yamltype: 'object'description: &lt; str &gt; # Information about data type and valueattributes:  &lt; attribute_name &gt;: { data type schema }# Mapping with key as attribute name and value as data type schema.# If omitted, any data which is an dictionary is accepted.required_attributes:- &lt; attribute_name &gt;# List of attribute names, which must be in the object.ignore_undefined_attributes: &lt; bool | default -&gt; false &gt;# Tell validator to ignore attributes in data object,# which are not defined in 'attributes'.dependencies:  &lt; attribute_name &gt;:    requires:    - &lt; attribute_name &gt;    # List of attribute names, which must be in the object,    # if this attribute is in.    excludes:    - &lt; attribute_name &gt;    # List of attribute names, which must not be in the object,    # if this attribute is in.allow_regex_attributes: &lt; bool | default -&gt; False &gt;# If enabled, regular expressions are allowed in:# 'attributes': If object attribute name matches, schema is verified.# 'required_attributes': Each element must have a at least one matching#                        attribute name.# 'dependencies.&lt;&gt;.requires': Successful if any object attribute name matches#                             each list entry.# 'dependencies.&lt;&gt;.excludes': Error if any object attribute name matches any#                             list entry.# !!! Disables autogeneration of missing keys !!!autogenerate: &lt; bool | default -&gt; True &gt;# Enable/Disable autogeneration of missing attributes,# if 'allow_regex_attributes' == false and# attribute's data type supports autogeneration and is defined within.reference: { reference options }# The validator checks, if the same combination of attribute values# is specified at another data type with the same 'reference.key'.# Requires 'reference_attributes' to be defined.reference_attributes:- &lt; attribute_name &gt;# List of attribute names, which values should be combined uniqueness check.```#### 'schema' Data Type##### 'schema' DescriptionThis data type does not represents an expected data value.  It uses a subschema's root data type to process the data structure.##### 'schema' Limitations- Supported in Version 1 only (Use *templates* in version 2)- Not customizable##### 'schema' Schema```yamltype: 'schema'description: &lt; str &gt; # Information about data type and valuesubschema: &lt; str &gt;# Name of the subschema, which is defined under 'subschemas' in schema.```#### 'string' Data Type##### 'string' DescriptionThis data type represents a string.##### 'string' Limitations- *autogeneration* is not supported.##### 'string' Schema```yamltype: 'string'description: &lt; str &gt; # Information about data type and valuereference:  # global reference options plus:  allow_namespace_lookups: &lt; bool &gt; # Only valid for 'consumer' mode  namespace_separator_char: &lt; string &gt;# Process:# - Check if *namespace_separator_char* is in string value# - extract namespace from left part of first finding# - extract value from right part of first finding# - lookup for *provider value* == *extracted value* in#   namespace *extracted namespace* for reference.keyminimum: &lt;int | default -&gt; 0 &gt; # &gt;= 0# Minimum required string lengthmaximum: &lt; int &gt; # &gt;= 0# Maximum allowed string lengthallowed_values:- &lt; string &gt;# List of strings# Dependis on 'regex_mode':# == false: String must be equal to any string in the list.# == true: String must match with any regex in the list.not_allowed_values:- &lt; string &gt;# List of strings# Dependis on 'regex_mode':# == false: String mustn't be equal to any string in the list.# == true: String mustn't match with all regex in the list.regex_mode: &lt; bool | default -&gt; false &gt;# Use strings in 'allowed_values' and 'not_allowed_values' for regex matching.regex_multiline: &lt; bool | default -&gt; false &gt;# Use multiline matching for regex tests or notregex_fullmatch: &lt; bool | default -&gt; true &gt;# String must fully match.```### Special Data Types#### 'fqdn' Data Type##### 'fqdn' DescriptionThis data type represents a full-qualified domain name. A FQDN consits ofa hostname (first label; defined by by RFC 953 and RFC 1123) and domain name(remaining labels; defined by RFC 1035 section 2.3.1.).RFCs allows and ignores upper cases in hostnames and domain labels.This is not the default case in cd2t validation.cd2t creates a finding on upper cases. If upper casesshould be ignored by cd2t, set option 'strict_lower' to false.##### 'fqdn' Limitations- Supported in Version 2##### 'fqdn' Schema```yamltype: 'fqdn'minimum: &lt; 4-255 | default -&gt; 4 &gt;# Minimum required length of FQDNsmaximum: &lt; 4-255 | default -&gt; 255 &gt; # &gt;= minimum# Maximum allowed length of FQDNsminimum_labels: &lt; int | default -&gt; 2 &gt; # &gt;= 2# Minimum required amount of labelsmaximum_labels: &lt; int &gt; # &gt;= minimum# Maximum allowed amount of labelsallowed_values:- &lt; string &gt;# FQDN must match with any regex in the list.not_allowed_values:- &lt; string &gt;# FQDN mustn't match with all regex in the list.strict_lower: &lt; bool | default -&gt; true &gt;# Do not allow upper cases in FQDN.```#### 'hostname' Data Type##### 'hostname' DescriptionThis data type represents a internet hostname defined by RFC 953 and RFC 1123.Thus, a hostname contains ASCII character a through z, digits 0 through 9 orhyphen-character '-'. A hostname is 1 to 63 characters long.RFCs allows and ignores upper cases in hostnames. This is not the default casein cd2t validation. cd2t creates a finding on upper cases. If upper casesshould be ignored by cd2t, set option 'strict_lower' to false.##### 'hostname' Limitations- Supported in Version 2##### 'hostname' Schema```yamltype: 'hostname'minimum: &lt; 1-63 | default -&gt; 1 &gt;# Minimum required length of hostnamemaximum: &lt; 1-63 | default -&gt; 63 &gt; # &gt;= minimum# Maximum allowed length of hostnameallowed_values:- &lt; string &gt;# Hostname must match with any regex in the list.not_allowed_values:- &lt; string &gt;# Hostname mustn't match with all regex in the list.strict_lower: &lt; bool | default -&gt; true &gt;# Do not allow upper cases in hostname.```##### 'hostname' Validation Process1. If 'strict_lower' is true: Check for upper cases in hostname2. Check on allowed characters3. Chech minimum and maximum length4. Check on not allowed values5. Check on allowed values#### 'ip' Data Type##### 'ip' DescriptionThis data type represents an IP object. Meaning, IPv4 or IPv6 as well as address,network or interface.##### 'ip' Limitations- Supported in Version 2##### 'ip' Schema```yamltype: ipversion: &lt; 4 | 6 &gt;loopback: &lt; bool &gt; # true: value must be loopback; false: value mustn't be loopbacklink_local: &lt; bool &gt; # true: value must be link-local; false: value mustn't be link-localprivate: &lt; bool &gt; # true: value must be private; false: value mustn't be privatepublic: &lt; bool &gt; # true: value must be public; false: value mustn't be publicmulticast: &lt; bool &gt; # true: value must be multicast; false: value mustn't be multicastallowed_values:  - &lt; IP address string &gt;  # Data must match one of the values.not_allowed_values:  - &lt; IP address string &gt;  # Data mustn't match all values.```#### 'ip_address' Data Type##### 'ip_address' DescriptionThis data type represents an IP address.##### 'ip_address' Limitations- Supported in Version 2##### 'ip_address' Schema```yamltype: ipversion: &lt; 4 | 6 &gt;loopback: &lt; bool &gt; # true: value must be loopback; false: value mustn't be loopbacklink_local: &lt; bool &gt; # true: value must be link-local; false: value mustn't be link-localprivate: &lt; bool &gt; # true: value must be private; false: value mustn't be privatepublic: &lt; bool &gt; # true: value must be public; false: value mustn't be publicmulticast: &lt; bool &gt; # true: value must be multicast; false: value mustn't be multicastallowed_values:  - &lt; IP address string &gt;  # Data must match one of the values.not_allowed_values:  - &lt; IP address string &gt;  # Data mustn't match all values.allowed_subnets:  - &lt; IP network string &gt;  # IP address must be within one of the networksnot_allowed_subnets:  - &lt; IP network string &gt;  # IP address mustn't be within any of the networks```#### 'ip_network' Data Type##### 'ip_network' DescriptionThis data type represents an IP network.##### 'ip_network' Limitations- Supported in Version 2##### 'ip_network' Schema```yamltype: ipversion: &lt; 4 | 6 &gt;loopback: &lt; bool &gt; # true: value must be loopback; false: value mustn't be loopbacklink_local: &lt; bool &gt; # true: value must be link-local; false: value mustn't be link-localprivate: &lt; bool &gt; # true: value must be private; false: value mustn't be privatepublic: &lt; bool &gt; # true: value must be public; false: value mustn't be publicmulticast: &lt; bool &gt; # true: value must be multicast; false: value mustn't be multicastallowed_values:  - &lt; IP address string &gt;  # Data must match one of the values.not_allowed_values:  - &lt; IP address string &gt;  # Data mustn't match all values.allowed_subnets:  - &lt; IP network string &gt;  # IP address must be within one of the networksnot_allowed_subnets:  - &lt; IP network string &gt;  # IP address mustn't be within any of the networksminimum_prefix_length: &lt; int &gt;  # 0 &lt; lenght &lt; 32|128 (v4|v6)maximum_prefix_length: &lt; int &gt;  # 'minimum_prefix_length' &lt; lenght &lt; 32|128 (v4|v6)```#### 'ip_interface' Data Type##### 'ip_interface' DescriptionThis data type represents an IP interface (address with subnet prefix length,i.e. 10.1.1.21/24).##### 'ip_interface' Limitations- Supported in Version 2##### 'ip_interface' Schema```yamltype: ipversion: &lt; 4 | 6 &gt;loopback: &lt; bool &gt; # true: value must be loopback; false: value mustn't be loopbacklink_local: &lt; bool &gt; # true: value must be link-local; false: value mustn't be link-localprivate: &lt; bool &gt; # true: value must be private; false: value mustn't be privatepublic: &lt; bool &gt; # true: value must be public; false: value mustn't be publicmulticast: &lt; bool &gt; # true: value must be multicast; false: value mustn't be multicastallowed_values:  - &lt; IP address string &gt;  # Data must match one of the values.not_allowed_values:  - &lt; IP address string &gt;  # Data mustn't match all values.allowed_subnets:  - &lt; IP network string &gt;  # IP address must be within one of the networksnot_allowed_subnets:  - &lt; IP network string &gt;  # IP address mustn't be within any of the networks```### General Data Type Options#### Reference DescriptionReferencing achieves two validation goals:1. It can makes sure that a value is unique.2. It can makes sure that a value is defined at another place within the data   structure.Basically a reference is defined by a key, so that one or more 'producers' ofvalues can match with one or more 'consumers' of values.In addition, many options are available to implement 1:1, 1:n or n:m relations,scope of 'reachability' of values with namespaces and more ...#### Reference OptionsIf a data type supports referencing, these options are available.```yamlreference:  key: &lt; string &gt; # required  # Identifier to map data at different positions in the data structure  # Define the reference mode.  mode: &lt; 'unique' | 'producer' | 'consumer' | default -&gt; 'unique' &gt;  # - 'producer': collect values as allowed values for 'consumer' positions.  # - 'unique': Inherits 'producer' and checks uniqueness of the value  #   among other values at other positions with the same key.  # - 'consumer': data value must match to a 'producer' value.  credits: &lt; int &gt;  # - 'Producer' and 'unique' mode have infinite credits by default.  # - If 0 with 'producer' or 'unique' mode, no 'consumer' is allowed.  # - If &gt;0 with 'producer' or 'unique':  #   - all producer's credits with same value are summed up,  #   - a consumer is allowed, when enough credits are available,  #   - each consumer's credits are  subtracted from the producers credit sum.  # - In 'consumer' moder the credit value is 1 by default.  # - 'Consumer' credits must be greater than 0.  allow_orphan_producer: &lt; bool | default -&gt; true &gt;  # If disabled, producer value without a consumer are not allowed.  # Select the scope of the reference:  unique_scope: &lt; 'namespace' | 'global' | default -&gt; 'global' &gt;  # Ignored in 'provider' or 'consumer' mode  provider_scope: &lt; 'namespace' | 'global' | default -&gt; 'global' &gt;   # 'ignored in 'consumer' mode  consumer_scope: &lt; 'namespace' | 'global' | default -&gt; 'global' &gt;  # Ignored in 'unique' or 'provider' mode  # 'namespace' scopes to the same namespace data only.  # References across namespaces only works,  # if both 'ends' specify 'global'.```## Feature Details### Custom Data Types*Introduced in version 2*Custom data types provides an efficient way to define data type and options,which used at multiple locations within the data structure.Data type options can be overwritten for each use.&gt; **Note**: Custom data type names mustn't conflict with built-in data types.  &gt; Good practice is to start with a capital letter.#### Example```yamlroot:  type: object  attributes:    name: string    age: NonNegativeInt    rate:      - type: NonNegativeInt        maximum: 100custom_data_types:  NonNegativeInt:    type: integer    minimum: 0```## Python Code Example```pythonimport osimport yamlfrom cd2t import Validatorwith open('my_schema.yml') as f:    schema = yaml.load(f)validator = Validator()validator.load_schema(schema)results = list()for filename in os.listdir('./my_data_folder'):    with open(filename) as f:        test_data = yaml.load(f)    validator.change_namespace(filename)    _results = validator.validate_data(test_data)    results.extend(_results)_results = validator.get_reference_findings()results.extend(_results)print('\n'.join(results))```</longdescription>
</pkgmetadata>