<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># py-tree-sitter[![Build Status](https://github.com/tree-sitter/py-tree-sitter/actions/workflows/ci.yml/badge.svg)](https://github.com/tree-sitter/py-tree-sitter/actions/workflows/ci.yml)[![Build status](https://ci.appveyor.com/api/projects/status/mde790v0v9gux85w/branch/master?svg=true)](https://ci.appveyor.com/project/maxbrunsfeld/py-tree-sitter/branch/master)This module provides Python bindings to the [tree-sitter](https://github.com/tree-sitter/tree-sitter)parsing library.## InstallationThis package currently only works with Python 3. There are no library dependencies,but you do need to have a C compiler installed.```shpip3 install tree_sitter```## Usage### SetupFirst you'll need a Tree-sitter language implementation for each language that youwant to parse. You can clone some of the [existing language repos](https://github.com/tree-sitter)or [create your own](http://tree-sitter.github.io/tree-sitter/creating-parsers):```shgit clone https://github.com/tree-sitter/tree-sitter-gogit clone https://github.com/tree-sitter/tree-sitter-javascriptgit clone https://github.com/tree-sitter/tree-sitter-python```Use the `Language.build_library` method to compile these into a library that'susable from Python. This function will return immediately if the library hasalready been compiled since the last time its source code was modified:```pythonfrom tree_sitter import LanguageLanguage.build_library(    # Store the library in the `build` directory    &quot;build/my-languages.so&quot;,    # Include one or more languages    [&quot;vendor/tree-sitter-go&quot;, &quot;vendor/tree-sitter-javascript&quot;, &quot;vendor/tree-sitter-python&quot;],)```Load the languages into your app as `Language` objects:```pythonGO_LANGUAGE = Language(&quot;build/my-languages.so&quot;, &quot;go&quot;)JS_LANGUAGE = Language(&quot;build/my-languages.so&quot;, &quot;javascript&quot;)PY_LANGUAGE = Language(&quot;build/my-languages.so&quot;, &quot;python&quot;)```#### Basic ParsingCreate a `Parser` and configure it to use one of the languages:```pythonparser = Parser()parser.set_language(PY_LANGUAGE)```Parse some source code:```pythontree = parser.parse(    bytes(        &quot;&quot;&quot;def foo():    if bar:        baz()&quot;&quot;&quot;,        &quot;utf8&quot;,    ))```If you have your source code in some data structure other than a bytes object,you can pass a &quot;read&quot; callable to the parse function.The read callable can use either the byte offset or point tuple to read frombuffer and return source code as bytes object. An empty bytes object or Noneterminates parsing for that line. The bytes must encode the source as UTF-8.For example, to use the byte offset:```pythonsrc = bytes(    &quot;&quot;&quot;def foo():    if bar:        baz()&quot;&quot;&quot;,    &quot;utf8&quot;,)def read_callable(byte_offset, point):    return src[byte_offset : byte_offset + 1]tree = parser.parse(read_callable)```And to use the point:```pythonsrc_lines = [&quot;def foo():\n&quot;, &quot;    if bar:\n&quot;, &quot;        baz()&quot;]def read_callable(byte_offset, point):    row, column = point    if row &gt;= len(src_lines) or column &gt;= len(src_lines[row]):        return None    return src_lines[row][column:].encode(&quot;utf8&quot;)tree = parser.parse(read_callable)```Inspect the resulting `Tree`:```pythonroot_node = tree.root_nodeassert root_node.type == 'module'assert root_node.start_point == (1, 0)assert root_node.end_point == (3, 13)function_node = root_node.children[0]assert function_node.type == 'function_definition'assert function_node.child_by_field_name('name').type == 'identifier'function_name_node = function_node.children[1]assert function_name_node.type == 'identifier'assert function_name_node.start_point == (1, 4)assert function_name_node.end_point == (1, 7)assert root_node.sexp() == &quot;(module &quot;    &quot;(function_definition &quot;        &quot;name: (identifier) &quot;        &quot;parameters: (parameters) &quot;        &quot;body: (block &quot;            &quot;(if_statement &quot;                &quot;condition: (identifier) &quot;                &quot;consequence: (block &quot;                    &quot;(expression_statement (call &quot;                        &quot;function: (identifier) &quot;                        &quot;arguments: (argument_list))))))))&quot;```#### Walking Syntax TreesIf you need to traverse a large number of nodes efficiently, you can usea `TreeCursor`:```pythoncursor = tree.walk()assert cursor.node.type == &quot;module&quot;assert cursor.goto_first_child()assert cursor.node.type == &quot;function_definition&quot;assert cursor.goto_first_child()assert cursor.node.type == &quot;def&quot;# Returns `False` because the `def` node has no childrenassert not cursor.goto_first_child()assert cursor.goto_next_sibling()assert cursor.node.type == &quot;identifier&quot;assert cursor.goto_next_sibling()assert cursor.node.type == &quot;parameters&quot;assert cursor.goto_parent()assert cursor.node.type == &quot;function_definition&quot;```#### EditingWhen a source file is edited, you can edit the syntax tree to keep it in sync withthe source:```pythontree.edit(    start_byte=5,    old_end_byte=5,    new_end_byte=5 + 2,    start_point=(0, 5),    old_end_point=(0, 5),    new_end_point=(0, 5 + 2),)```Then, when you're ready to incorporate the changes into a new syntax tree,you can call `Parser.parse` again, but pass in the old tree:```pythonnew_tree = parser.parse(new_source, tree)```This will run much faster than if you were parsing from scratch.The `Tree.get_changed_ranges` method can be called on the _old_ tree to returnthe list of ranges whose syntactic structure has been changed:```pythonfor changed_range in tree.get_changed_ranges(new_tree):    print(&quot;Changed range:&quot;)    print(f&quot;  Start point {changed_range.start_point}&quot;)    print(f&quot;  Start byte {changed_range.start_byte}&quot;)    print(f&quot;  End point {changed_range.end_point}&quot;)    print(f&quot;  End byte {changed_range.end_byte}&quot;)```#### Pattern-matchingYou can search for patterns in a syntax tree using a _tree query_:```pythonquery = PY_LANGUAGE.query(    &quot;&quot;&quot;(function_definition  name: (identifier) @function.def)(call  function: (identifier) @function.call)&quot;&quot;&quot;)captures = query.captures(tree.root_node)assert len(captures) == 2assert captures[0][0] == function_name_nodeassert captures[0][1] == &quot;function.def&quot;```The `Query.captures()` method takes optional `start_point`, `end_point`,`start_byte` and `end_byte` keyword arguments which can be used to restrict thequery's range. Only one of the `..._byte` or `..._point` pairs need to be givento restrict the range. If all are omitted, the entire range of the passed nodeis used.</longdescription>
</pkgmetadata>