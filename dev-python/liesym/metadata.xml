<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># liesymLie Algebras using Sympy and backend powered by Rust's pyO3 and ndarray## OverviewIn an effort to supply python with the same computer algebra software (CAS)capabilities, [SymPy](https://github.com/sympy/sympy) was written. This pythonlibrary is well written and allows an open source alternative to proprietarychoices like Mathematica/WolframLanguage and Maple. Due to the nature ofhow SymPy was written, certain symbolic calculation can be extremely unoptimizedin python. Even using numpy could offer little speed ups as it is not gearedtowards rational numbers (fractions). Sympy does currently offer a `liealgebras`module, but due to the performance limitations, certain tradeoffs had to bemade such as locking the basis for the classic lie algebras in favor of speed.This is a fair trade off, but would require anyone using a different basisto hand calculate the representations of the algebra all over again.An alternative to solve this problem would be to use a compiledbackend that supports generics (and isn't a pain to build with python).Rust has good python binding support through [py03](https://github.com/PyO3/pyo3)and allows easy communication through numpy using [rust-numpy](https://github.com/PyO3/rust-numpy)as well as numpy like api inside rust using [ndarray](https://github.com/rust-ndarray/ndarray).## Install```bashpip install liesym```## ExamplesSee also example [notebook](notebooks/Example.ipynb)&lt;!--Autogenerated below--&gt;```pythonimport liesym as lsfrom sympy import Matrixfrom IPython.display import display, Markdownfrom sympy.printing.str import StrPrinter```#### Cartan Matrix```pythonA3 = ls.A(3)A3.cartan_matrix```$$\displaystyle \left[\begin{matrix}2 &amp; -1 &amp; 0\\\ -1 &amp; 2 &amp; -1\\\0 &amp; -1 &amp; 2\end{matrix}\right]$$#### Positive Roots```pythonfor i in A3.positive_roots():    display(i)```$$\displaystyle \left[\begin{matrix}1 &amp; 0 &amp; 1\end{matrix}\right]$$$$\displaystyle \left[\begin{matrix}-1 &amp; 1 &amp; 1\end{matrix}\right]$$$$\displaystyle \left[\begin{matrix}1 &amp; 1 &amp; -1\end{matrix}\right]$$$$\displaystyle \left[\begin{matrix}-1 &amp; 2 &amp; -1\end{matrix}\right]$$$$\displaystyle \left[\begin{matrix}0 &amp; -1 &amp; 2\end{matrix}\right]$$$$\displaystyle \left[\begin{matrix}2 &amp; -1 &amp; 0\end{matrix}\right]$$#### Simple Roots```pythonfor i in A3.simple_roots():    display(i)```$$\displaystyle \left[\begin{matrix}1 &amp; -1 &amp; 0 &amp; 0\end{matrix}\right]$$$$\displaystyle \left[\begin{matrix}0 &amp; 1 &amp; -1 &amp; 0\end{matrix}\right]$$$$\displaystyle \left[\begin{matrix}0 &amp; 0 &amp; 1 &amp; -1\end{matrix}\right]$$#### Fundamental Weights```pythonfor i in A3.fundamental_weights(): # defaulted to orthogonal basis    display(i)```$$\displaystyle \left[\begin{matrix}\frac{3}{4} &amp; - \frac{1}{4} &amp; - \frac{1}{4} &amp; - \frac{1}{4}\end{matrix}\right]$$$$\displaystyle \left[\begin{matrix}\frac{1}{2} &amp; \frac{1}{2} &amp; - \frac{1}{2} &amp; - \frac{1}{2}\end{matrix}\right]$$$$\displaystyle \left[\begin{matrix}\frac{1}{4} &amp; \frac{1}{4} &amp; \frac{1}{4} &amp; - \frac{3}{4}\end{matrix}\right]$$#### Dimension of representation  ```pythontable = &quot;&quot;&quot;\| Dim | Irrep Name | Rep (Omega) || :-: | :-: | :-: |&quot;&quot;&quot;for i in A3.fundamental_weights(basis=&quot;omega&quot;):    table += f&quot;&quot;&quot;\| {A3.dim(i)} | $${A3.dim_name(i)}$$  | $${i.table(StrPrinter())}$$|&quot;&quot;&quot;Markdown(table)```| Dim | Irrep Name | Rep (Omega) || :-: | :-: | :-: || 4 | $$4$$  | $$[1, 0, 0]$$|| 6 | $$6$$  | $$[0, 1, 0]$$|| 4 | $$\bar{4}$$  | $$[0, 0, 1]$$|#### Name of repCommonly in literature (especially physics), names of the reps are the dimension rather than the matrix rep.```pythonA3.dim_name(Matrix([[0, 0, 1]]))```$$\displaystyle \bar{4}$$```pythonA3.irrep_lookup(r&quot;\bar{4}&quot;)```$$\displaystyle \left[\begin{matrix}0 &amp; 0 &amp; 1\end{matrix}\right]$$#### Tensor product decompsThe decomp of irreps from a product of irreps```pythonresults = A3.tensor_product_decomposition([    Matrix([[1,0,0]]),    Matrix([[1,0,0]]),])table = &quot;&quot;&quot;\| Rep | Dim name || :-: | :-: |&quot;&quot;&quot;for i in results:    table += f&quot;&quot;&quot;\| $${i.table(StrPrinter())}$$ | $${A3.dim_name(i)}$$ |  &quot;&quot;&quot;Markdown(table)```| Rep | Dim name || :-: | :-: || $$[0, 1, 0]$$ | $$6$$ |  | $$[2, 0, 0]$$ | $$\bar{10}$$ |  #### Lie GroupsCurrently supports SU(N), SO(N), Sp(N)```pythonsu2 = ls.SU(2)su2.generators()```    [Matrix([     [  0, 1/2],     [1/2,   0]]),     Matrix([     [  0, -I/2],     [I/2,    0]]),     Matrix([     [1/2,    0],     [  0, -1/2]])]```python# cartan generatorssu2.generators(cartan_only=True)```    [Matrix([     [1/2,    0],     [  0, -1/2]])]Structure constants. SU(2) structure constants are $e_{ijk}$```pythonsu2.structure_constants()```$$\displaystyle \left[\begin{matrix}\left[\begin{matrix}0 &amp; 0 &amp; 0\\\0 &amp; 0 &amp; 1\\\0 &amp; -1 &amp; 0\end{matrix}\right] &amp; \left[\begin{matrix}0 &amp; 0 &amp; -1\\\0 &amp; 0 &amp; 0\\\1 &amp; 0 &amp; 0\end{matrix}\right] &amp; \left[\begin{matrix}0 &amp; 1 &amp; 0\\\ -1 &amp; 0 &amp; 0\\\0 &amp; 0 &amp; 0\end{matrix}\right]\end{matrix}\right]$$```pythonA1 = ls.A(1)for x in A1.simple_roots(basis=&quot;omega&quot;):    display(x)```$$\displaystyle \left[\begin{matrix}2\end{matrix}\right]$$Quadratic Casimir```pythons = ls.Sp(6)r = s.algebra.fundamental_weights()[0]s.quadratic_casimir(r)```$$\displaystyle \frac{7}{2}$$</longdescription>
</pkgmetadata>