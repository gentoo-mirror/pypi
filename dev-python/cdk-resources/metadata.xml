<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># CDK Resources ### Motivation### ArchitectureRegular **aws-cdk** has a *stack-based* architecture where resources are defined in each stack and then resources areshared between stacks (import from stacks). This project is proposing a *resource-based* architecture as this would enable a more naturalorganization of resources based on AWS services.**Typical CDK Structure** ```└── custom_construct/|    └── constructs1.py|    └── ...|    └── constructs1.py| └── stacks/|    └── stack1.py|    └── stack2.py|    ...|    └── stackN.py└── app.py└── cdk.json```**CDK Resources Approach**```└── custom_construct/|    └── constructs1.py|    └── ...|    └── constructs1.py| └── resources/|    └── apigateway.py|    └── ec2.py|    └── ecs.py|    └── eks.py|    └── elasticsearch.py|    └── ...|    └── vpc.py|└── stacks/|    └── stack1.py|    └── stack2.py|    ...|    └── stackN.py└── app.py└── cdk.json```### Environment ParametersOne of the most broadly used approach to parameterize a cdk stack based on environments also knows as stages (`dev`, ..., `prod`) is to pass them as configurations in the`cdk.json` file. In a big multi stack project, this approach become a issue as `cdk.json` startsgrowing is difficult to manage**Parameterization based on context** ```json{  &quot;app&quot;: &quot;python3 app.py&quot;,  &quot;context&quot;: {    &quot;configurations&quot;: {      &quot;stack1&quot;: {        &quot;dev&quot;: {          &quot;aurora_cluster_instances&quot;: 1,          ...          &quot;ecs_service_desired_container_count&quot;: 1        },        &quot;prod&quot;: {          &quot;aurora_cluster_instances&quot;: 3,          ...          &quot;ecs_service_desired_container_count&quot;: 5        }      },      ...    }  }}```**CDK Resources Parameterization** ```pythonclass PostgreSqlRdsDatabase(Resource[aws_rds.DatabaseCluster]):    construct_class = aws_rds.DatabaseCluster    construct_props = dict(        default=dict(            ...            instances=1,            ...        ),        prod=dict(            instances=2,        )    )```## InstallationTo install use pip```$ pip install cdk-resources```## Components### ResourceResources are the most important component as it contains mostly all the logic of the project. A resource is a natural representation of an AWS element, and in terms of cdk is the equivalent of a **Construct Manager**. Components mustinherit from `cdk_resources.Resource`.There are two types of resources: *resource managed by the stack* and *imported resources*.#### Resource Attributes:* **construct_class** (Required): The **aws_cdk.construct** class this resource represent.* **construct_props**: Required only if it is a managed resource. The cdk construct class properties.* **construct_lookup_method**: Method of the **aws_cdk.construct** construct to be used to import the object.* **construct_lookup_props**: Required if the object is an imported resource. Kwargs used by `construct_lookup_method` to lookup for the object.#### Resource Methods:* **get()**: Class method of the resource that returns the **aws_cdk.construct**. Either by lookup or because was previously created.* **post_create()**: Extra configurations to apply to the construct *after* construct was init.#### Resource Examples:As it can seen in the example below for the `PostgreSqlRdsDatabase` **construct_class** is `aws_rds.DatabaseCluster`, desired configurations for all the environments are being specified in the **construct_props** attr. And otherresources are imported. ```pythonfrom aws_cdk import aws_rds, core, aws_ec2from cdk_resources import Resourcefrom resources.ec2 import PostgreSqlRdsDatabaseSgfrom resources.vpc import (    DefaultVpc,    DefaultPrivateDbASubnet,    DefaultPrivateDbBSubnet,    DefaultPrivateDbCSubnet,)class PostgreSqlRdsDatabase(Resource[aws_rds.DatabaseCluster]):    construct_class = aws_rds.DatabaseCluster    construct_props = dict(        default=dict(            engine=aws_rds.DatabaseClusterEngine.aurora_postgres(                version=aws_rds.AuroraPostgresEngineVersion.VER_13_4            ),            backup=aws_rds.BackupProps(retention=core.Duration.days(3)),            deletion_protection=True,            instance_props=lambda: aws_rds.InstanceProps(                instance_type=aws_ec2.InstanceType.of(                    aws_ec2.InstanceClass.BURSTABLE3,                    aws_ec2.InstanceSize.MEDIUM,                ),                security_groups=[PostgreSqlRdsDatabaseSg.get()],                vpc=DefaultVpc.get(),                vpc_subnets=aws_ec2.SubnetSelection(                    subnets=[                        DefaultPrivateDbASubnet.get(),                        DefaultPrivateDbBSubnet.get(),                        DefaultPrivateDbCSubnet.get(),                    ]                ),                parameter_group=PostgreSqlParameterGroup().construct,            ),            instances=1,            port=5432,            removal_policy=core.RemovalPolicy.RETAIN,            storage_encrypted=True,        ),        prod=dict(            backup=aws_rds.BackupProps(retention=core.Duration.days(30)),            instances=2,            vpc_subnets=lambda: aws_ec2.SubnetSelection(                subnets=[                    DefaultPrivateDbASubnet.get(),                    DefaultPrivateDbCSubnet.get(),                    DefaultPrivateDbCSubnet.get()                ]            ),        ),    )```### StacksA stack is the natural representation of a `CFN Stack`. All stacks must inherit from `cdk_resources.ResourceStack`.#### Resource Attributes:* **EXISTING_RESOURCES** (list): The list of existing resources that must be inited in **aws_cdk.scope**. These are resources that are used by the Stack resources.* **RESOURCES** (list): The resources own for this stack.#### Resource Examples:As it can be seen in the example below for the `SampleStack`. The stack creates a DynamoTable, Security Group, RDS Aurora Parameter Group, and RDS Cluster.Also, some resources must be imported. Those are specified in **EXISTING_RESOURCE** list as the VPC resources.```pythonfrom cdk_resources import ResourceStackfrom resources.dynamodb import DynamoTablefrom resources.ec2 import PostgreSqlRdsDatabaseSgfrom resources.rds import PostgreSqlRdsDatabase, PostgreSqlParameterGroupfrom resources.sns import SnsTopicfrom resources.vpc import (    DefaultVpc,    DefaultPrivateDbASubnet,    DefaultPrivateDbBSubnet,    DefaultPrivateDbCSubnet,)class SampleStack(ResourceStack):    EXISTING_RESOURCES = [        (&quot;vpc&quot;, DefaultVpc),        (&quot;subnet_db_a&quot;, DefaultPrivateDbASubnet),        (&quot;subnet_db_b&quot;, DefaultPrivateDbBSubnet),        (&quot;subnet_db_c&quot;, DefaultPrivateDbCSubnet),    ]    RESOURCES = [        # DynamoDB        (&quot;dynamodb&quot;, DynamoTable),        # RDS        (&quot;postgresql-sg&quot;, PostgreSqlRdsDatabaseSg),        (&quot;postgresql-parameter-group&quot;, PostgreSqlParameterGroup),        (&quot;postgresqlDb&quot;, PostgreSqlRdsDatabase),        # SNS        (&quot;sns-topic&quot;, SnsTopic),    ]```## Parameterizationto do## Examples[Here](https://github.com/sfernandezf/cdk-resources/tree/main/samples) are someavailables examples.</longdescription>
</pkgmetadata>