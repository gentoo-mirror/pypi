<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![SQLGlot logo](sqlglot.svg)SQLGlot is a no-dependency SQL parser, transpiler, optimizer, and engine. It can be used to format SQL or translate between [19 different dialects](https://github.com/tobymao/sqlglot/blob/main/sqlglot/dialects/__init__.py) like [DuckDB](https://duckdb.org/), [Presto](https://prestodb.io/), [Spark](https://spark.apache.org/), [Snowflake](https://www.snowflake.com/en/), and [BigQuery](https://cloud.google.com/bigquery/). It aims to read a wide variety of SQL inputs and output syntactically correct SQL in the targeted dialects.It is a very comprehensive generic SQL parser with a robust [test suite](https://github.com/tobymao/sqlglot/blob/main/tests/). It is also quite [performant](#benchmarks), while being written purely in Python.You can easily [customize](#custom-dialects) the parser, [analyze](#metadata) queries, traverse expression trees, and programmatically [build](#build-and-modify-sql) SQL.Syntax [errors](#parser-errors) are highlighted and dialect incompatibilities can warn or raise depending on configurations. However, it should be noted that SQL validation is not SQLGlotâ€™s goal, so some syntax errors may go unnoticed.Learn more about the SQLGlot API in the [documentation](https://sqlglot.com/).Contributions are very welcome in SQLGlot; read the [contribution guide](https://github.com/tobymao/sqlglot/blob/main/CONTRIBUTING.md) to get started!## Table of Contents* [Install](#install)* [Versioning](#versioning)* [Get in Touch](#get-in-touch)* [Examples](#examples)   * [Formatting and Transpiling](#formatting-and-transpiling)   * [Metadata](#metadata)   * [Parser Errors](#parser-errors)   * [Unsupported Errors](#unsupported-errors)   * [Build and Modify SQL](#build-and-modify-sql)   * [SQL Optimizer](#sql-optimizer)   * [AST Introspection](#ast-introspection)   * [AST Diff](#ast-diff)   * [Custom Dialects](#custom-dialects)   * [SQL Execution](#sql-execution)* [Used By](#used-by)* [Documentation](#documentation)* [Run Tests and Lint](#run-tests-and-lint)* [Benchmarks](#benchmarks)* [Optional Dependencies](#optional-dependencies)## InstallFrom PyPI:```pip3 install sqlglot```Or with a local checkout:```make install```Requirements for development (optional):```make install-dev```## VersioningGiven a version number `MAJOR`.`MINOR`.`PATCH`, SQLGlot uses the following versioning strategy:- The `PATCH` version is incremented when there are backwards-compatible fixes or feature additions.- The `MINOR` version is incremented when there are backwards-incompatible fixes or feature additions.- The `MAJOR` version is incremented when there are significant backwards-incompatible fixes or feature additions.## Get in TouchWe'd love to hear from you. Join our community [Slack channel](https://tobikodata.com/slack)!## Examples### Formatting and TranspilingEasily translate from one dialect to another. For example, date/time functions vary from dialects and can be hard to deal with:```pythonimport sqlglotsqlglot.transpile(&quot;SELECT EPOCH_MS(1618088028295)&quot;, read=&quot;duckdb&quot;, write=&quot;hive&quot;)[0]``````sql'SELECT FROM_UNIXTIME(1618088028295 / 1000)'```SQLGlot can even translate custom time formats:```pythonimport sqlglotsqlglot.transpile(&quot;SELECT STRFTIME(x, '%y-%-m-%S')&quot;, read=&quot;duckdb&quot;, write=&quot;hive&quot;)[0]``````sql&quot;SELECT DATE_FORMAT(x, 'yy-M-ss')&quot;```As another example, let's suppose that we want to read in a SQL query that contains a CTE and a cast to `REAL`, and then transpile it to Spark, which uses backticks for identifiers and `FLOAT` instead of `REAL`:```pythonimport sqlglotsql = &quot;&quot;&quot;WITH baz AS (SELECT a, c FROM foo WHERE a = 1) SELECT f.a, b.b, baz.c, CAST(&quot;b&quot;.&quot;a&quot; AS REAL) d FROM foo f JOIN bar b ON f.a = b.a LEFT JOIN baz ON f.a = baz.a&quot;&quot;&quot;print(sqlglot.transpile(sql, write=&quot;spark&quot;, identify=True, pretty=True)[0])``````sqlWITH `baz` AS (  SELECT    `a`,    `c`  FROM `foo`  WHERE    `a` = 1)SELECT  `f`.`a`,  `b`.`b`,  `baz`.`c`,  CAST(`b`.`a` AS FLOAT) AS `d`FROM `foo` AS `f`JOIN `bar` AS `b`  ON `f`.`a` = `b`.`a`LEFT JOIN `baz`  ON `f`.`a` = `baz`.`a````Comments are also preserved in a best-effort basis when transpiling SQL code:```pythonsql = &quot;&quot;&quot;/* multi   line   comment*/SELECT  tbl.cola /* comment 1 */ + tbl.colb /* comment 2 */,  CAST(x AS INT), # comment 3  y               -- comment 4FROM  bar /* comment 5 */,  tbl #          comment 6&quot;&quot;&quot;print(sqlglot.transpile(sql, read='mysql', pretty=True)[0])``````sql/* multi   line   comment*/SELECT  tbl.cola /* comment 1 */ + tbl.colb /* comment 2 */,  CAST(x AS INT), /* comment 3 */  y /* comment 4 */FROM bar /* comment 5 */, tbl /*          comment 6 */```### MetadataYou can explore SQL with expression helpers to do things like find columns and tables:```pythonfrom sqlglot import parse_one, exp# print all column references (a and b)for column in parse_one(&quot;SELECT a, b + 1 AS c FROM d&quot;).find_all(exp.Column):    print(column.alias_or_name)# find all projections in select statements (a and c)for select in parse_one(&quot;SELECT a, b + 1 AS c FROM d&quot;).find_all(exp.Select):    for projection in select.expressions:        print(projection.alias_or_name)# find all tables (x, y, z)for table in parse_one(&quot;SELECT * FROM x JOIN y JOIN z&quot;).find_all(exp.Table):    print(table.name)```### Parser ErrorsWhen the parser detects an error in the syntax, it raises a ParserError:```pythonimport sqlglotsqlglot.transpile(&quot;SELECT foo( FROM bar&quot;)``````sqlglot.errors.ParseError: Expecting ). Line 1, Col: 13.  select foo( FROM bar              ~~~~```Structured syntax errors are accessible for programmatic use:```pythonimport sqlglottry:    sqlglot.transpile(&quot;SELECT foo( FROM bar&quot;)except sqlglot.errors.ParseError as e:    print(e.errors)``````python[{  'description': 'Expecting )',  'line': 1,  'col': 13,  'start_context': 'SELECT foo( ',  'highlight': 'FROM',  'end_context': ' bar'}]```### Unsupported ErrorsPresto `APPROX_DISTINCT` supports the accuracy argument which is not supported in Hive:```pythonimport sqlglotsqlglot.transpile(&quot;SELECT APPROX_DISTINCT(a, 0.1) FROM foo&quot;, read=&quot;presto&quot;, write=&quot;hive&quot;)``````sqlAPPROX_COUNT_DISTINCT does not support accuracy'SELECT APPROX_COUNT_DISTINCT(a) FROM foo'```### Build and Modify SQLSQLGlot supports incrementally building sql expressions:```pythonfrom sqlglot import select, conditionwhere = condition(&quot;x=1&quot;).and_(&quot;y=1&quot;)select(&quot;*&quot;).from_(&quot;y&quot;).where(where).sql()``````sql'SELECT * FROM y WHERE x = 1 AND y = 1'```You can also modify a parsed tree:```pythonfrom sqlglot import parse_oneparse_one(&quot;SELECT x FROM y&quot;).from_(&quot;z&quot;).sql()``````sql'SELECT x FROM z'```There is also a way to recursively transform the parsed tree by applying a mapping function to each tree node:```pythonfrom sqlglot import exp, parse_oneexpression_tree = parse_one(&quot;SELECT a FROM x&quot;)def transformer(node):    if isinstance(node, exp.Column) and node.name == &quot;a&quot;:        return parse_one(&quot;FUN(a)&quot;)    return nodetransformed_tree = expression_tree.transform(transformer)transformed_tree.sql()``````sql'SELECT FUN(a) FROM x'```### SQL OptimizerSQLGlot can rewrite queries into an &quot;optimized&quot; form. It performs a variety of [techniques](https://github.com/tobymao/sqlglot/blob/main/sqlglot/optimizer/optimizer.py) to create a new canonical AST. This AST can be used to standardize queries or provide the foundations for implementing an actual engine. For example:```pythonimport sqlglotfrom sqlglot.optimizer import optimizeprint(    optimize(        sqlglot.parse_one(&quot;&quot;&quot;            SELECT A OR (B OR (C AND D))            FROM x            WHERE Z = date '2021-01-01' + INTERVAL '1' month OR 1 = 0        &quot;&quot;&quot;),        schema={&quot;x&quot;: {&quot;A&quot;: &quot;INT&quot;, &quot;B&quot;: &quot;INT&quot;, &quot;C&quot;: &quot;INT&quot;, &quot;D&quot;: &quot;INT&quot;, &quot;Z&quot;: &quot;STRING&quot;}}    ).sql(pretty=True))``````sqlSELECT  (    &quot;x&quot;.&quot;a&quot; &lt;&gt; 0 OR &quot;x&quot;.&quot;b&quot; &lt;&gt; 0 OR &quot;x&quot;.&quot;c&quot; &lt;&gt; 0  )  AND (    &quot;x&quot;.&quot;a&quot; &lt;&gt; 0 OR &quot;x&quot;.&quot;b&quot; &lt;&gt; 0 OR &quot;x&quot;.&quot;d&quot; &lt;&gt; 0  ) AS &quot;_col_0&quot;FROM &quot;x&quot; AS &quot;x&quot;WHERE  CAST(&quot;x&quot;.&quot;z&quot; AS DATE) = CAST('2021-02-01' AS DATE)```### AST IntrospectionYou can see the AST version of the sql by calling `repr`:```pythonfrom sqlglot import parse_oneprint(repr(parse_one(&quot;SELECT a + 1 AS z&quot;)))``````python(SELECT expressions:  (ALIAS this:    (ADD this:      (COLUMN this:        (IDENTIFIER this: a, quoted: False)), expression:      (LITERAL this: 1, is_string: False)), alias:    (IDENTIFIER this: z, quoted: False)))```### AST DiffSQLGlot can calculate the difference between two expressions and output changes in a form of a sequence of actions needed to transform a source expression into a target one:```pythonfrom sqlglot import diff, parse_onediff(parse_one(&quot;SELECT a + b, c, d&quot;), parse_one(&quot;SELECT c, a - b, d&quot;))``````python[  Remove(expression=(ADD this:    (COLUMN this:      (IDENTIFIER this: a, quoted: False)), expression:    (COLUMN this:      (IDENTIFIER this: b, quoted: False)))),  Insert(expression=(SUB this:    (COLUMN this:      (IDENTIFIER this: a, quoted: False)), expression:    (COLUMN this:      (IDENTIFIER this: b, quoted: False)))),  Move(expression=(COLUMN this:    (IDENTIFIER this: c, quoted: False))),  Keep(source=(IDENTIFIER this: b, quoted: False), target=(IDENTIFIER this: b, quoted: False)),  ...]```See also: [Semantic Diff for SQL](https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md).### Custom Dialects[Dialects](https://github.com/tobymao/sqlglot/tree/main/sqlglot/dialects) can be added by subclassing `Dialect`:```pythonfrom sqlglot import expfrom sqlglot.dialects.dialect import Dialectfrom sqlglot.generator import Generatorfrom sqlglot.tokens import Tokenizer, TokenTypeclass Custom(Dialect):    class Tokenizer(Tokenizer):        QUOTES = [&quot;'&quot;, '&quot;']        IDENTIFIERS = [&quot;`&quot;]        KEYWORDS = {            **Tokenizer.KEYWORDS,            &quot;INT64&quot;: TokenType.BIGINT,            &quot;FLOAT64&quot;: TokenType.DOUBLE,        }    class Generator(Generator):        TRANSFORMS = {exp.Array: lambda self, e: f&quot;[{self.expressions(e)}]&quot;}        TYPE_MAPPING = {            exp.DataType.Type.TINYINT: &quot;INT64&quot;,            exp.DataType.Type.SMALLINT: &quot;INT64&quot;,            exp.DataType.Type.INT: &quot;INT64&quot;,            exp.DataType.Type.BIGINT: &quot;INT64&quot;,            exp.DataType.Type.DECIMAL: &quot;NUMERIC&quot;,            exp.DataType.Type.FLOAT: &quot;FLOAT64&quot;,            exp.DataType.Type.DOUBLE: &quot;FLOAT64&quot;,            exp.DataType.Type.BOOLEAN: &quot;BOOL&quot;,            exp.DataType.Type.TEXT: &quot;STRING&quot;,        }print(Dialect[&quot;custom&quot;])``````&lt;class '__main__.Custom'&gt;```### SQL ExecutionOne can even interpret SQL queries using SQLGlot, where the tables are represented as Python dictionaries. Although the engine is not very fast (it's not supposed to be) and is in a relatively early stage of development, it can be useful for unit testing and running SQL natively across Python objects. Additionally, the foundation can be easily integrated with fast compute kernels (arrow, pandas). Below is an example showcasing the execution of a SELECT expression that involves aggregations and JOINs:```pythonfrom sqlglot.executor import executetables = {    &quot;sushi&quot;: [        {&quot;id&quot;: 1, &quot;price&quot;: 1.0},        {&quot;id&quot;: 2, &quot;price&quot;: 2.0},        {&quot;id&quot;: 3, &quot;price&quot;: 3.0},    ],    &quot;order_items&quot;: [        {&quot;sushi_id&quot;: 1, &quot;order_id&quot;: 1},        {&quot;sushi_id&quot;: 1, &quot;order_id&quot;: 1},        {&quot;sushi_id&quot;: 2, &quot;order_id&quot;: 1},        {&quot;sushi_id&quot;: 3, &quot;order_id&quot;: 2},    ],    &quot;orders&quot;: [        {&quot;id&quot;: 1, &quot;user_id&quot;: 1},        {&quot;id&quot;: 2, &quot;user_id&quot;: 2},    ],}execute(    &quot;&quot;&quot;    SELECT      o.user_id,      SUM(s.price) AS price    FROM orders o    JOIN order_items i      ON o.id = i.order_id    JOIN sushi s      ON i.sushi_id = s.id    GROUP BY o.user_id    &quot;&quot;&quot;,    tables=tables)``````pythonuser_id price      1   4.0      2   3.0```See also: [Writing a Python SQL engine from scratch](https://github.com/tobymao/sqlglot/blob/main/posts/python_sql_engine.md).## Used By* [SQLMesh](https://github.com/TobikoData/sqlmesh)* [Fugue](https://github.com/fugue-project/fugue)* [ibis](https://github.com/ibis-project/ibis)* [mysql-mimic](https://github.com/kelsin/mysql-mimic)* [Querybook](https://github.com/pinterest/querybook)* [Quokka](https://github.com/marsupialtail/quokka)* [Splink](https://github.com/moj-analytical-services/splink)## DocumentationSQLGlot uses [pdoc](https://pdoc.dev/) to serve its API documentation.A hosted version is on the [SQLGlot website](https://sqlglot.com/), or you can build locally with:```make docs-serve```## Run Tests and Lint```make check  # Set SKIP_INTEGRATION=1 to skip integration tests```## Benchmarks[Benchmarks](https://github.com/tobymao/sqlglot/blob/main/benchmarks/bench.py) run on Python 3.10.5 in seconds.|           Query |         sqlglot |        sqlfluff |         sqltree |        sqlparse |  moz_sql_parser |        sqloxide || --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- ||            tpch |   0.01308 (1.0) | 1.60626 (122.7) | 0.01168 (0.893) | 0.04958 (3.791) | 0.08543 (6.531) | 0.00136 (0.104) ||           short |   0.00109 (1.0) | 0.14134 (129.2) | 0.00099 (0.906) | 0.00342 (3.131) | 0.00652 (5.970) | 8.76E-5 (0.080) ||            long |   0.01399 (1.0) | 2.12632 (151.9) | 0.01126 (0.805) | 0.04410 (3.151) | 0.06671 (4.767) | 0.00107 (0.076) ||           crazy |   0.03969 (1.0) | 24.3777 (614.1) | 0.03917 (0.987) | 11.7043 (294.8) | 1.03280 (26.02) | 0.00625 (0.157) |## Optional DependenciesSQLGlot uses [dateutil](https://github.com/dateutil/dateutil) to simplify literal timedelta expressions. The optimizer will not simplify expressions like the following if the module cannot be found:```sqlx + interval '1' month```</longdescription>
</pkgmetadata>