<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>================================pylibmc cache backend for Django================================.. image:: https://travis-ci.org/django-pylibmc/django-pylibmc.svg    :target: https://travis-ci.org/django-pylibmc/django-pylibmcThis package provides a memcached cache backend for Django using`pylibmc &lt;http://github.com/lericson/pylibmc&gt;`_.  You want to use pylibmc becauseit's fast.Do you need django-pylibmc?---------------------------Django has direct support for pylibmc.  To use it, set you cache backend::    CACHES = {        'default': {            'BACKEND': 'django.core.cache.backends.memcached.PyLibMCCache',            'LOCATION': '127.0.0.1.11211',        }    }See the`Django documentation &lt;https://docs.djangoproject.com/en/1.8/topics/cache/#memcached&gt;`_for details about using this cache backend.Two reasons to use django-pylibmc instead are:- You need to use the binary protocol- You need to use a username and password to access the memcached server (such as  with `Memcachier on Heroku &lt;https://devcenter.heroku.com/articles/memcachier#django&gt;`_).Requirements------------django-pylibmc requires pylibmc 1.4.1 or above.  It supports Django 1.7 through1.9, and Python versions 2.7, 3.4, and 3.5.Installation------------Get it from `pypi &lt;http://pypi.python.org/pypi/django-pylibmc&gt;`_::    pip install django-pylibmcor `github &lt;http://github.com/django-pylibmc/django-pylibmc&gt;`_::    pip install -e git://github.com/django-pylibmc/django-pylibmc.git#egg=django-pylibmcUsage-----Your cache backend should look something like this::    CACHES = {        'default': {            'BACKEND': 'django_pylibmc.memcached.PyLibMCCache',            'LOCATION': 'localhost:11211',            'TIMEOUT': 500,            'BINARY': True,            'OPTIONS': {  # Maps to pylibmc &quot;behaviors&quot;                'tcp_nodelay': True,                'ketama': True            }        }    }To use a `memcached local socket connection&lt;https://code.google.com/p/memcached/wiki/NewConfiguringServer#Unix_Sockets&gt;`_,set ``LOCATION`` to the path to the file, i.e. ``'/var/run/memcached/memcached.sock'``.If you want to use the memcached binary protocol, set the ``BINARY`` key'svalue to ``True`` as shown above.  ``BINARY`` is ``False`` by default.If you want to control `pylibmc behaviors&lt;http://sendapatch.se/projects/pylibmc/behaviors.html&gt;`_, use the``OPTIONS``.  ``OPTIONS`` is an empty dict by default.Pylibmc supports `compression&lt;http://sendapatch.se/projects/pylibmc/misc.html#compression&gt;`_ and theminimum size (in bytes) of values to compress can be set via the Djangosetting ``PYLIBMC_MIN_COMPRESS_LEN``.  The default is ``0``, which is disabled.Pylibmc 1.3.0 and above allows to configure compression level, which canbe set via the Django setting ``PYLIBMC_COMPRESS_LEVEL``. It accepts thesame values as the Python `zlib &lt;https://docs.python.org/2/library/zlib.html&gt;`_module. Please note that pylibmc changed the default from ``1`` (``Z_BEST_SPEED``)to ``-1`` (``Z_DEFAULT_COMPRESSION``) in 1.3.0.Configuration with Environment Variables----------------------------------------Optionally, the memcached connection can be configured with environmentvariables (on platforms like Heroku). To do so, declare the followingvariables:* ``MEMCACHE_SERVERS``* ``MEMCACHE_USERNAME``* ``MEMCACHE_PASSWORD``Caching Timouts---------------When setting a cache value, memcache allows you to set an expiration for thevalue. Commonly, the value is set to a timeout in seconds. However, othervalues are allowed including Unix timestamps and 0 for &quot;never expire&quot;. Thehighest number of seconds is 30 days - more than that, and the value istreated like a timestamp.Django instead tries to work with cache timeouts in seconds after the currenttime. 0 is treated as 0 seconds, meaning the item should expire immediately.A timeout of None signals that the item should not expire. There is somesupport for memcache-style Unix timestamps as well.In the distant past (Django 1.3?), a timeout of 0 was converted to the defaulttimeout.The current django-pylibmc behaviour is to pass 0 to the backend, which shouldbe interpreted as &quot;never expire&quot;. Omiting the timeout will get the Djangodefault.In the future, django-pylibmc will adopt the latest Django behaviour.The safest solution for your own code is to omit the timeout parameter (andget the default timeout), or set it to a timeout in seconds (less than 30days). This way, your code will work when the Django behaviour is adopted.Avoid using a timeout of 0, None, or a negative number.Testing-------Install `tox &lt;http://tox.testrun.org/&gt;`_::    pip install toxRun the tests like this::    toxChangelog=========0.6.1 - 2015-12-28------------------- Supports Django 1.7 through 1.9- Supports Python 2.7, 3.4, and 3.50.6.0 - 2015-04-01------------------- Requires pylibmc 1.4.1 or greater- Supports Django 1.4 through 1.8.- Supports Python 2.5 through 2.7, and Python 3.3 through 3.4- In Django 1.6 and higher, when the timeout is omitted, the default  timeout is used, rather than set to &quot;never expire&quot;.</longdescription>
</pkgmetadata>