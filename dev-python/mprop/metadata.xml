<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Description===========This package intends to offer a mechanism to add properties to your modules.The primary use-case of this functionality is to allow for the deferredexecution of expensive-to-compute module/package level globals without needingto explicitly call a function.Generally speaking, this module has two APIs that offer this functionality.You can use either of them or both of them, and everything will work more orless as you expect it to, as long as you follow the rules.Note that this package supports the use of basically any descriptor at themodule-level, not just properties.Usage=====The first method of using the package supports basically any descriptor beingused as a decorator in the standard way. We show the use of ``property`` for thesake of brevity::    @property    def module_property(mod):        '''mod is the module that this property was defined in'''    import mprop; mprop.init().. warning: If you use properties or any of your own descriptors, you must    call ``mprop.init()`` after defining all of your properties/descriptors.    You *can* call ``mprop.init()`` multiple times if you need to add more    properties/descriptors during runtime.Because remembering to put the import/init call at the bottom of a module canbe annoying, we've got a special decorator that works just like the propertyobject, but handles the ``mprop.init()`` call for you::    from mprop import mproperty    @mproperty    def module_property2(mod):        '''I work exactly the same as the earlier module property, but you        don't need to make a subsequent call to ``mprop.init()``'''Regardless of which method you use, if the name of your module is ``mod`` thosethat import the module can access the properties as normal::    # example.py    from mprop import mproperty    @mproperty    def prop(mod):        return &quot;I was called!&quot;    def fcn():        # I can access the property via:        print _pmodule.prop    # test.py    import example    # the below should print &quot;I was called!&quot;    print example.prop    # this should also print &quot;I was called!&quot;    example.fcn()Referencing properties from within the module=============================================After initialization, your code may want to reference the global properties.If you try to access the properties directly, you will get a NameError unlessyou locally aliased the value, the initialization has not completed, or unlesssomeone else injected a value with that name into the globals.If you would like to directly access properties in the module, from within themodule, you must reference them relative to the newly generated module. This isavailable from within your functions defined in the module via ``_pmodule``,which is the &quot;property-enhanced module&quot; that offers property access.If you find it necessary to require access to the original module object(which doesn't support properties), you can access ``_module`` from the globalnamspace.How it works============The short version: we replace the standard Python module instance in``sys.modules`` during module import, which allows us to ensure that the moduleis replaced everywhere it is used. We perform some magic to ensure thateverything available in the original module is available in the replacementmodule (the replacement module's ``__dict__`` is the module's globals), and wepost-process everything in the module's global namespace to pull outdescriptors as necessary.As of February 1, 2019, in order to offer proper ``@mproperty.setter/deleter``support, we've started initializing the module after import via the systemprofiler. More specifically, any time we get a call for ``@mproperty``, we seeif we've installed a system profiler to clean up after this module. In CPythonvia the ``sys.setprofile()`` handler, we look for return calls from modulecreation. These auto-nest, and auto-remove themselves, so by the time your finalmprop-using module is done initializing, our profilers are removed.We used to inject a special ``__getattribute__`` method that auto-initializes onfirst access, but it was being triggered in cases where I didn't expect.Python magic that goes on-------------------------* Using ``sys.getframe()`` to pull calling frame objects to get module globals  and subsequently the module object itself* Replace ``sys.modules`` entries* Replace an instance ``__dict__``* Assign descriptors during runtime by modifying the base class of the  replacement module* Use the system profiler to discover when a module has finished loading, to  start initialization</longdescription>
</pkgmetadata>