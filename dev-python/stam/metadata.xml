<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;    &lt;img src=&quot;https://github.com/annotation/stam/raw/master/logo.png&quot; alt=&quot;stam logo&quot; width=&quot;320&quot; /&gt;&lt;/p&gt;[![Docs](https://readthedocs.org/projects/stam-python/badge/?version=latest&amp;style=flat)](https://stam-python.readthedocs.io)[![PyPI](https://img.shields.io/pypi/v/stam.svg)](https://pypi.org/project/stam/)[![PyPI](https://img.shields.io/pypi/dm/stam.svg)](https://pypi.org/project/stam/)[![GitHub build](https://github.com/annotation/stam-rust/actions/workflows/stam.yml/badge.svg?branch=master)](https://github.com/annotation/stam-rust/actions/)[![GitHub release](https://img.shields.io/github/release/annotation/stam-rust.svg)](https://GitHub.com/annotation/stam-rust/releases/)[![Project Status: Active â€“ The project has reached a stable, usable state and is being actively developed.](https://www.repostatus.org/badges/latest/active.svg)](https://www.repostatus.org/#active)# STAM Python binding[STAM](https://github.com/annotation/stam) is a data model for stand-off text annotation and described in detail [here](https://github.com/annotation/stam). This is a python library (to be more specific; a python binding written in Rust) to work with the model.This library offers a higher-level interface than the underlying Rust library. Implementation is currently in a preliminary stage. We aim to implement the full model and most extensions.## Installation``$ pip install stam``Or if you feel adventurous and have the necessary build-time dependencies installed (Rust), you can try the latest development release from Github:``$ pip install git+https://github.com/annotation/stam-python``## Documentation* [STAM Specification](https://github.com/annotation/stam) - the STAM specification itself* [API Reference](https://stam-python.readthedocs.io)* [STAM Tutorial: Standoff Text Annotation for Pythonistas](tutorial.ipynb) - An extensive tutorial showing how to work with this Python library, in the form of a Jupyter Notebook. **Recommended!**## Usage Import the library```pythonimport stam```Loading a STAM JSON (or CSV) file containing an annotation store:```pythonstore = stam.AnnotationStore(file=&quot;example.stam.json&quot;)```The annotation store is your workspace, it holds all resources, annotation sets(i.e. keys and annotation data) and of course the actual annotations. It is amemory-based store and you can put as much as you like into it (as long as it fitsin memory).You can optionally pass configuration parameters upon loading a store, as follows:```pythonstore = stam.AnnotationStore(file=&quot;example.stam.json&quot;, config={&quot;debug&quot;: True})```Once loaded, you can retrieving anything by its public ID:```pythonannotation = store.annotation(&quot;my-annotation&quot;)resource = store.resource(&quot;my-resource&quot;)annotationset = store.annotationset(&quot;my-annotationset&quot;)key = annotationset.key(&quot;my-key&quot;)data = annotationset.annotationdata(&quot;my-data&quot;)```You can also iterating through all annotations in the store, and outputting a simple tab separated format:```pythonfor annotation in store.annotations():    # get the text to which this annotation refers (if any)    try:        text = str(annotation)    except stam.StamError:        text = &quot;n/a&quot;    for data in annotation:        print(&quot;\t&quot;.join(( annotation.id(), data.key().id(), str(data.value()), text)))```Adding a resource:```pythonresource = store.add_resource(filename=&quot;my-text.txt&quot;)```Create a store and annotations from scratch:```pythonfrom stam import AnnotationStore, Selector, AnnotationDataBuilderstore = AnnotationStore(id=&quot;test&quot;)resource = store.add_resource(id=&quot;testres&quot;, text=&quot;Hello world&quot;)store.annotate(id=&quot;A1&quot;,                 target=Selector.textselector(resource, Offset.simple(6,11)),                data={ &quot;id&quot;: &quot;D1&quot;, &quot;key&quot;: &quot;pos&quot;, &quot;value&quot;: &quot;noun&quot;, &quot;set&quot;: &quot;testdataset&quot;})```In the above example, the `AnnotationDataSet` , `DataKey` and `AnnotationData`are created on-the-fly. You can also create them explicitly within the set first, as shown in thenext snippet, resulting in the exact same store:```pythonstore = AnnotationStore(id=&quot;test&quot;)resource = store.add_resource(id=&quot;testres&quot;, text=&quot;Hello world&quot;)annotationset = store.add_annotationset(id=&quot;testdataset&quot;)annotationset.add_key(&quot;pos&quot;)data = annotationset.add_data(&quot;pos&quot;,&quot;noun&quot;,&quot;D1&quot;)store.annotate(id=&quot;A1&quot;,     target=Selector.textselector(resource, Offset.simple(6,11)),    data=data)```Providing the full data dictionary as in the earlier example would havealso worked fine, with the same end result, but would be less performant than passing an `AnnotationData` instance directly.The implementation will always ensure any already existing `AnnotationData` will be reused ifpossible, as not duplicating data is one of the core characteristics of theSTAM model.You can serialize the entire annotation store (including all sets and annotations) to a STAM JSON file:```pythonstore.set_filename(&quot;example.stam.json&quot;)store.save()```For more documentation, please read: [STAM Tutorial: Standoff Text Annotation for Pythonistas](tutorial.ipynb).## Differences between the rust library and python library and performance considerationsAlthough this Python binding builds on the Rust library, the API it exposesdiffers in certain aspects to make it more pythonic and easier to work with.This results in a higher-level API that hides some of the lower-level detailsthat are present in the Rust library. This approach does come at the cost of causingsome additional runtime overhead. The Rust methods will often return iterators, references or handles whenever theycan, moreover it will do so safely. The Python API is often forced to make alocal copy. For iterators we often decide to let the entire underlying Rustiterator run its course and then return the result as a whole as a tuple, rather thanreturn a Python generator. Here you gain some speed at the cost of some memory.Probably needless to say, but using Rust directly will always be moreperformant than using this Python binding. However, using this Python bindingshould still be way more performant than if the whole thing were implemented innative Python. The trick is in letting the binding work for you as much aspossible, use higher-level methods whenever they are available rather thanimplementing your logic in Python.## AcknowledgementsThis work is conducted at the [KNAW Humanities Cluster](https://huc.knaw.nl/)'s [Digital Infrastructure department](https://di.huc.knaw.nl/), and funded by the [CLARIAH](https://clariah.nl) project (CLARIAH-PLUS, NWO grant 184.034.023) as part of the FAIR Annotations track.</longdescription>
</pkgmetadata>