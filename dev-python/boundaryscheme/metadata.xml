<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>This is the architecture for the package &quot;boundaryscheme&quot; : https://pypi.org/project/boundaryscheme/# boundaryschemePackage Python to use numerical scheme with boundaries which is described in the PhD manuscript &gt; P. Le Barbenchon, Étude théorique et numérique de la stabilité GKS pour des schémas d'ordre élevé en présence de bords, PhD, 2023.# Package documentationhttps://plebarbenchon.github.io/boundaryscheme# Easy installation for the PyPI version```bashpip install boundaryscheme```# Installation for the GitHub version```bashgit clone https://github.com/PLeBarbenchon/boundaryscheme.gitcd boundaryschemepip3 install -r requirements.txtpip3 install -e .python3 examples/draw_detKLcurve.py```# Example ```pythonimport matplotlib.pyplot as pltfrom boundaryscheme.schemes import BeamWarmingfrom boundaryscheme.boundaries import SILWimport boundaryscheme.pyplot as bspltbsplt.detKLcurve(BeamWarming, SILW(2,3),lambdacursor = True)plt.show()```![mygif](https://github.com/PLeBarbenchon/boundaryscheme/assets/92107096/2ca0d414-77a6-410e-a582-a3950699dcf0)# Creation of a schemeTo compute the scheme $U_{j}^{n+1} = \dfrac{1}{3}U_{j-1}^n + U_j^n -\dfrac{1}{6} U_{j+1}^n - \dfrac{1}{6}U_{j+2}^n$ with a boundary $B$, write ```pythonS = Scheme([1/3,1,-1/6,-1/6],1, B) ```To compute the scheme depending on a parameter $\lambda$, create a Python class using the following formulation:```pythonclass Name(Scheme):    &quot;&quot;&quot;This is a class to represent ...    :param lamb: The Courant number, i.e  a.dt/dx where &quot;a&quot; is the velocity, &quot;dt&quot; the time discretization and &quot;dx&quot; the space discretization    :type lamb: float    :param boundary: Boundary condition, defaults to Dirichlet()    :type boundary: class:`Boundary`, optional    :param sigma: Gap between the mesh and the boundary condition, defaults to 0    :type sigma: float, optional    &quot;&quot;&quot;    def __init__(self, lamb, boundary=Dirichlet(), sigma=0, **kwargs):        &quot;&quot;&quot;Constructor method&quot;&quot;&quot;        self.sigma = sigma        self.lamb = lamb        self.inter = #write the list of the coefficients of the scheme        self.center = #write the index of the center of the scheme        self.CFL = #give the CFL condition        super().__init__(inter=self.inter, center=self.center, boundary=boundary, sigma=sigma, **kwargs)    def shortname(self):        &quot;&quot;&quot;Name method&quot;&quot;&quot;        return &quot;Name&quot;```For example, to compute the scheme $U_{j}^{n+1} = \dfrac{\lambda}{3}U_{j-1}^n + \lambda^2 U_j^n -\dfrac{1}{6} U_{j+1}^n - \dfrac{\lambda}{6}U_{j+2}^n$ with a boundary $B$, write ```pythonclass Name(Scheme):    def __init__(self, lamb, boundary=Dirichlet(), sigma=0, **kwargs):        self.sigma = sigma        self.lamb = lamb        self.inter = [lamb/3, lamb**2, -1/6, -lamb/6]        self.center = 1        self.CFL = #give the CFL condition        super().__init__(inter=self.inter, center=self.center, boundary=boundary, sigma=sigma, **kwargs)    def shortname(self):        &quot;&quot;&quot;Name method&quot;&quot;&quot;        return &quot;Name&quot;```# CitingThe code is citable via Zenodo. Please cite as:P. Le Barbenchon, boundaryscheme: package Python for numerical schemes with boundaries. 2023. [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.7773742.svg)](https://doi.org/10.5281/zenodo.7773742)</longdescription>
</pkgmetadata>