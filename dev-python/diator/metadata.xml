<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Diator - CQRS Library for PythonDiator is a Python library for implementing CQRS pattern in your Python applications. It provides a set of abstractions and utilities to help you separate your read and write concerns, allowing for better scalability, performance, and maintainability of your application.## Features :bulb:- Implements the CQRS pattern- Simple, yet flexible API- Supports multiple message brokers, such as [Redis Pub/Sub](https://redis.io/docs/manual/pubsub/) and [Azure Service Bus](https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-overview)- Easy to integrate with existing codebases## Installation :triangular_ruler:Install the Diator library with [pip](https://pypi.org/project/diator/)```bashpip install diator```There are also several installation options:- To use Redis as Message Broker    ```bash    pip install diator[redis]    ```- Or Azure Service Bus    ```bash    pip install diator[azure]    ```## Documentation :blue_book:To use the Diator library, there are several components to familiarize yourself with. These include Commands and Command Handlers, Queries and Query Handlers, Events and Event Handlers, and Message Brokers. By utilizing these components, you can effectively manage the exchange of information between the read and write models in your application.### **Commands and Command Handlers****Command** represents an intention to perform an action or change the state of an application. Here is an example of the Command:```pythonfrom diator.requests import Requestfrom diator.response import Response@dataclasses.dataclass(frozen=True, kw_only=True)class JoinMeetingCommand(Request)    meeting_id: int = dataclasses.field(default=1)    user_id: int = dataclasses.field(default=1)```**Command Handler** is a component responsible for handling a Command and executing the corresponding action:```pythonfrom diator.requests import RequestHandlerfrom diator.events import EventHandlerclass JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None]):    def __init__(self, meeting_api: MeetingAPI) -&gt; None:        self._meeting_api = meeting_api        self._events: list[Event] = []    @property    def events(self) -&gt; list[Event]:        return self._events    async def handle(self, request: JoinMeetingCommand) -&gt; None:        await self._meeting_api.join(request.meeting_id, request.user_id)        self._events.append(            UserJoinedDomainEvent(user_id=request.user_id, timestamp=datetime.utcnow(), meeting_id=request.meeting_id)        )        self._events.append(            UserJoinedNotificationEvent(user_id=request.user_id)        )```### **Queries and Query Handlers****Query** represents a request for information or data from the application's read model. The process of handling queries **SHOULD NOT** modify the state of the application:```pythonfrom diator.requests import Request@dataclasses.dataclass(frozen=True, kw_only=True)class ReadMeetingQuery(Request)    meeting_id: int = dataclasses.field(default=1)```**Query Result** is an object that contains the data requested by a Query. It is returned by a Query Handler after it processes a Query against the read model:```pythonfrom diator.response import Response@dataclasses.dataclass(frozen=True, kw_only=True)class ReadMeetingQueryResult(Response)    meeting_id: int = dataclasses.field(default=1)    link: str = dataclasses.field()```**Query Handler** is a component responsible for processing a Query against the read model and returning the requested data as a Query Result:```pythonfrom diator.requests import RequestHandlerclass ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult]):    def __init__(self, meeting_api: MeetingAPI) -&gt; None:        self._meeting_api = meeting_api        self._events: list[Event] = []    @property    def events(self) -&gt; list[Event]:        return self._events    async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:        link = await self._meeting_api.get_link(request.meeting_id)        return ReadMeetingQueryResult(            meeting_id=request.meeting_id,            link=link        )```### **Events and Event Handlers****Event** represents a fact that has occurred in the application. It typically represents a significant change in the application's state that is of interest to other parts of the application or external systems.There are several event types:- **Domain Event** - is a message describing a significant event that hasoccurred in the business domain.- **Notification Event** - is a message regarding a change in the business domain that other components will react to.- **Event-carried state transfer (ECST)** - messages notify subscribers about changes in the producer’s internal state.```pythonfrom diator.events import DomainEvent, NotificationEvent, ECSTEvent@dataclasses.dataclass(frozen=True, kw_only=True)class UserJoinedDomainEvent(DomainEvent):  # will be handled by an event handler    user_id: int = dataclasses.field()    meeting_id: int = dataclasses.field()    timestamp: datetime = dataclasses.field()@dataclasses.dataclass(frozen=True, kw_only=True)class UserJoinedNotificationEvent(NotificationEvent):  # will be sent to a message broker    user_id: int = dataclasses.field()@dataclasses.dataclass(frozen=True, kw_only=True)class UserChangedECSTEvent(ECSTEvent):  # will be sent to a message broker    user_id: int = dataclasses.field()    new_username: str = dataclasses.field()```**Event Handler** is a component responsible for processing an Event that has occurred in the application:```pythonfrom diator.events import EventHandlerclass UserJoinedDomainEventHandler(EventHandler[UserJoinedDomainEvent]):    def __init__(self, meeting_api: MeetingAPI) -&gt; None:        self._meeting_api = meeting_api    async def handle(self, event: UserJoinedDomainEvent) -&gt; None:        await self._meeting_api.notify(event.meeting_id, &quot;New user joined!&quot;)```Also the diator library supports different message brokers:- Redis Pub/Sub (`diator.message_brokers.redis.RedisMessageBroker`)- Azure Service Bus (`diator.message_brokers.azure.AzureMessageBroker`)### **Dependency Injection**Currently the library supports only di frameworks like [di](https://github.com/adriangb/di) and [rodi](https://github.com/Neoteroi/rodi)Example of the rodi usage:```pythonfrom rodi import Containerfrom diator.container.rodi import RodiContainerdef setup_di() -&gt; RodiContainer:    external_container = Container()    external_container.register(UserJoinedDomainEventHandler)    external_container.register(JoinMeetingCommandHandler)    external_container.register(ReadMeetingQueryHandler)    container = RodiContainer()    container.attach_external_container(external_container)    return container```Example of the di lib usage:```pythonfrom di import Container, bind_by_type  # using di lib as di-frameworkfrom diator.container.di import DIContainerdef setup_di() -&gt; DIContainer:    external_container = Container()    external_container.bind(        bind_by_type(            Dependent(UserJoinedDomainEventHandler, scope=&quot;request&quot;),             UserJoinedDomainEventHandler        )    )    external_container.bind(        bind_by_type(            Dependent(JoinMeetingCommandHandler, scope=&quot;request&quot;),            JoinMeetingCommandHandler,        )    )    external_container.bind(        bind_by_type(            Dependent(ReadMeetingQueryHandler, scope=&quot;request&quot;),            ReadMeetingQueryHandler,        )    )    container = DIContainer()    container.attach_external_container(external_container)    return container```### **Middlewares**```pythonfrom diator.requests import Requestclass SomeMiddleware:    async def __call__(request: Request, handle):        &quot;&quot;&quot;        Some logic related to request part of the circle.        &quot;&quot;&quot;        response = await handle(request)        &quot;&quot;&quot;        Some logic related to response part of the circle.        &quot;&quot;&quot;        return response```### **Putting it all together** :nut_and_bolt:```pythonfrom diator.requests import RequestMapfrom diator.message_brokers.redis import RedisMessageBrokerfrom diator.events import EventEmitterfrom diator.mediator import Mediatorfrom diator.events import EventMapfrom diator.middlewares import MiddlewareChainasync def main() -&gt; None:    container = setup_di()    event_map = EventMap()    event_map.bind(UserJoinedDomainEvent, UserJoinedDomainEventHandler)  # Mapping event to event handler    request_map = RequestMap()    request_map.bind(JoinMeetingCommand, JoinMeetingCommandHandler)  # Mapping command to command handler    request_map.bind(ReadMeetingQuery, ReadMeetingQueryHandler)  # Mapping query to query handler    redis_client = redis.Redis.from_url(&quot;redis://localhost:6379/0&quot;)  # Creating Async Redis Client    middleware_chain = MiddlewareChain()    middleware_chain.add(SomeMiddleware())  # Adding Middleware to a chain    event_emitter = EventEmitter(        message_broker=RedisMessageBroker(redis_client),        event_map=event_map,        container=container,    )    mediator = Mediator(        request_map=request_map,         event_emitter=event_emitter,         container=container,         middleware_chain=MiddlewareChain    )    &quot;&quot;&quot;     1. JoinMeetingCommand is handled by JoinMeetingCommandHandler    2. JoinMeetingCommandHandler publishes Domain and Notification Events    3. UserJoinedDomainEvent is handled by UserJoinedDomainEventHandler    4. UserJoinedNotificationEvent is sent to the Redis Pub/Sub    &quot;&quot;&quot;    await mediator.send(JoinMeetingCommand(user_id=1))    # Returns ReadMeetingQueryResult    response = await mediator.send(ReadMeetingQuery(meeting_id=1))if __name__ == &quot;__main__&quot;:    asyncio.run(main())```Redis Pub/Sub output:```json{   &quot;message_type&quot;:&quot;notification_event&quot;,   &quot;message_name&quot;:&quot;UserJoinedNotificationEvent&quot;,   &quot;message_id&quot;:&quot;9f62e977-73f7-462b-92cb-8ea658d3bcb5&quot;,   &quot;payload&quot;:{      &quot;event_id&quot;:&quot;9f62e977-73f7-462b-92cb-8ea658d3bcb5&quot;,      &quot;event_timestamp&quot;:&quot;2023-03-07T09:26:02.588855&quot;,      &quot;user_id&quot;:123   }}```## Further reading :scroll:- [Udi Dahan - Clarified CQRS](https://udidahan.com/2009/12/09/clarified-cqrs/)- [Martin Fowler - CQRS](https://martinfowler.com/bliki/CQRS.html)- [Marting Fowler - What do you mean by “Event-Driven”?](https://martinfowler.com/articles/201701-event-driven.html)- [Vlad Khononov - Learning Domain-Driven Design](https://www.oreilly.com/library/view/learning-domain-driven-design/9781098100124/)- [Vaughn Vernon - Really Simple CQRS](https://kalele.io/really-simple-cqrs/)## LicenseThis project is licensed under the terms of the MIT license.</longdescription>
</pkgmetadata>