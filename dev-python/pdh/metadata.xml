<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># PDH - PagerDuty CLI for humans![Build Image](https://github.com/mbovo/pdh/actions/workflows/build-image.yml/badge.svg)`PDH` is a new lightweight CLI for pagerduty interaction: uou can handle your incidents triage without leaving your terminal.It also add some nice tricks to automate the incident triage and easy the on-call burden.See [docs](./docs) (TBD)## Install### With docker```bashdocker run -ti -v ~/.config/pdh.yaml:/root/.config/pdh.yaml --rm pdh:0.3.10 inc ls```### With pip```bashpip install pdh&gt;=0.3.10```### From source```bashgit clone https://github.com/mbovo/pdhcd pdhtask setupsource .venv/bin/activatepdh inc ls```## UsageFirst of all you need to configure `pdh` to talk with PagerDuty's APIs:```bashpdh config```The wizard will prompt you for 3 settings:- `apikey` is the API key, you can generate it from the user's profile page on pagerduty website- `email` the email address of your pagerduty profile- `uid` the userID of your account (you can read it from the browser address bar when clicking on &quot;My Profile&quot;)Settings are persisted to `~/.config/pdh.yaml` in clear.### Listing incidentsAssigned to self:```bashpdh inc ls```Any other incident currently outstanding:```bashpdh inc ls -e```### Auto ACK incoming incidentsWatch for new incidents every 10s and automatically set them to `Acknowledged````bashpdh inc ls --watch --new --ack --timeout 10```### List all HIGH priority incidents periodicallyList incidents asssigned to all users every 5s```bashpdh inc ls --high --everything --watch --timeout 5```### Resolve specific incidents```bashpdh inc resolve INCID0001 INCID0024 INCID0023```### Resolve all incidents related to `Backups````bashpdh inc ls --resolve --regexp &quot;.*Backup.*&quot;```## Rules`PDH` support custom scripting applied to your incidents list. These `rules` are in fact any type of executable you can run on your machine.```bashpdh inc apply INCID001 -s /path/to/my/script.py -s /path/to/binary```The `apply` subcommand will call the listed executable/script passing along a json to stdin with the incident informations. The called script can apply any type of checks/sideffects and output another json to stout to answer the call.Even though rules can be written in any language it's very straightforward using python:### Rules: an exampleAn example rule can be written in python with the following lines```python#!/usr/bin/env python3from pdh import rules, Filter@rules.ruledef main(input):    return {i[&quot;id&quot;]: i[&quot;summary&quot;] for i in input}if __name__ == &quot;__main__&quot;:    main()```This is the simplest rule you can write, reading the input and simply output a new dictionary with the entries. It will output something like:```bash pdh inc apply Q1LNI5LNM7RZ2C Q1C5KG41H0SZAM -s ./a.py┏━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓┃ script ┃ Q1LNI5LNM7RZ2C                                                     ┃ Q1C5KG41H0SZAM                                                                       ┃┡━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩│ ./a.py │  AWS Health Event: us-east-1 EC2 : AWS_EC2_INSTANCE_STOP_SCHEDULED │  AWS Health Event: us-east-1 EC2 : AWS_EC2_INSTANCE_STORE_DRIVE_PERFORMANCE_DEGRADED │└────────┴────────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────────────┘```The default output is `table` with one line for each script runned and with one column per each element in the returned object### Rules: more examples```python#!/usr/bin/env python3# Needed importsfrom pdh import rules, Filter# This annotation make the main() method parse stdin as json into the parameter called input# All returned values are converted to json and printed to stdout@rules.ruledef main(input):    # Initialize PagerDuty's APIs    api = rules.api()    # From the given input extract only incidents with the word cassandra in title    incs = Filter.objects(input, filters=[Filter.regexp(&quot;title&quot;, &quot;.*EC2.*&quot;)])    # ackwnoledge all previously filtered incidents    api.ack(incs)    # resolve all previously filtered incidents    api.resolve(incs)    # snooze all previously filtered incidents for 1h    api.snooze(incs, duration=3600)    # Chain a given rule, i.e call that rule with the output of this one    # chain-loading supports only a single binary, not directories    c = rules.chain(incs, &quot;rules/test_chaining.sh&quot;)    # Execute an external program and get the output/err/return code    p: rules.ShellResponse = rules.exec('kubectl get nodes -o name')    if p.rc &gt; 0:      nodes = p.stdout.split(&quot;\n&quot;)    # if you return a dict will be rendered with each item as a column in a table    # Othrwise will be converted as string    return {i[&quot;id&quot;]: i[&quot;summary&quot;] for i in incs}if __name__ == &quot;__main__&quot;:    main()```## Requirements- [Taskfile](https://taskfile.dev)- Python &gt;=3.10- Docker## ContributingFirst of all you need to setup the dev environment, using Taskfile:```bashtask setup```This will create a python virtualenv and install `pre-commit` and `poetry` in your system if you lack them.## LicenseThis program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.See [](LICENSE) for more details.</longdescription>
</pkgmetadata>