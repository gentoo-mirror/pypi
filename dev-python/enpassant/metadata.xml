<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>| |travisci| |versions| |impls| |wheel| |coverage| |br-coverage|.. |travisci| image:: https://api.travis-ci.org/jonathaneunice/enpassant.svg    :target: http://travis-ci.org/jonathaneunice/enpassant.. |versions| image:: https://img.shields.io/pypi/pyversions/enpassant.svg    :alt: Supported versions    :target: https://pypi.python.org/pypi/enpassant.. |impls| image:: https://img.shields.io/pypi/implementation/enpassant.svg    :alt: Supported implementations    :target: https://pypi.python.org/pypi/enpassant.. |wheel| image:: https://img.shields.io/pypi/wheel/enpassant.svg    :alt: Wheel packaging support    :target: https://pypi.python.org/pypi/enpassant.. |coverage| image:: https://img.shields.io/badge/test_coverage-100%25-blue.svg    :alt: Test line coverage    :target: https://pypi.python.org/pypi/enpassant.. |br-coverage| image:: https://img.shields.io/badge/branch_coverage-99%25-blue.svg    :alt: Test branch coverage    :target: https://pypi.python.org/pypi/enpassantSimple *en passant* assignment, giving Python clearer conditional statementsUsage=====::    from __future__ import print_function # Python 2/3 compat    from enpassant import *    result = Passer()    while result / expensive_request():        print(result.report())        # assuming report() is a method of the object        # expensive_request() would naturally hand backDiscussion==========Many languages support *en passant* (in passing) assignment, like so::    if result = expensive_request():        print(result.report())In Python, that's a syntax error.This leads to more code lines and, in some cases, lessvisual clarity::    result = expensive_request()    if result:        print(result.report())Or worse, in the case of looping structures::    result = expensive_request()    while result:        print(result.report())        result = expensive_request()It doesn't look so bad here, in a highly distilled example. But in realprograms, the called function often has parameters to be managed, and thesurrounding code is invariably longer and more complicated. The more complicatedthe surrounding computations and requests, the simpler the comparison itselfshould be. As the `Zen of Python &lt;http://www.python.org/dev/peps/pep-0020/&gt;`_intones: &quot;Simple is better than complex.&quot; and &quot;Readability counts.&quot;I hope that Python will eventually provide a concise way of handling this, suchas::    while expensive_request() as result:        print(result.report())But in the meanwhile, ``enpassant`` provides a workaround.How it Works============::    from enpassant import *    result = Passer()    while result / expensive_request():        print(result.report())Here ``result / expensive_request()`` is read &quot;the result of theexpensive_request.&quot; ``result`` is merely a proxy object that, when itencounters the division operator, returns the denominator. That is, ``result/ whatever == whatever``. But it also *remembers* the denominator value.Then, whenever you want the result value provided (presumably, later in thebody of your loop or conditional), simply access it through ``result``. Ifyou want the full object returned by ``expensive_request()`` you can get itvia ``result.value``. Or or the result has items or attributes, they areavailable by indexing or naming the attribute directly. *Easy peasy!*NB: If you change the items or attributes of ``result``, those settings arealso forwarded to the underlying object. ``result`` is not a copy, but atrue proxy, and as close to the actual object returned as I can make itgiven current Python strictures.Some Details============``enpassant`` &quot;assignment&quot; is transparent to conditional expressions,because the value of the expression is always the value of the denominator.But ``Passers`` are also guaranteed to have a Boolean value identical tothat of the value they contain, should you wish to use them in subsequenttests.The ``result`` in the example above isn't the pure result of the followingfunction call (or expression), but rather a proxy to it. Item (``[]``)and attribute (``.``) access work directly on ``result`` because``Passer`` objects pass on *getitem* and *get-attribute* requests to theirenclosed value. Usually, this is a convenience, and avoids having toneedlessly state that it's really ``result.value`` that's being indexed ordereferenced. But if you need the specific object returned (say for anobject identity or ``isinstance`` test, use ``result.value`` directly.Alternative Value Access========================It is also possible to retrieve the value of a ``Passer`` by calling it::    if result / expensive_request():        print(result().report())This technique makes clear that the value is being rendered via someprocess, rather than just presented as a normal Python name / variable. Andthe resulting object from ``result()`` is the true and complete result ofthe earlier function call, with no need for implicit / auto-magicalforwarding of items and attributes. Which style makes sense is a matter ofjudgment and taste.Or, if you prefer something terser, the ``+`` (unary positive) operationwill also yield the value::    if result / expensive_request():        print(+result.report())Alternative Invocations=======================.. |larrow| unicode:: 0x2190 .. leftwards arrowIf you prefer the less-than (``&lt;``) or less-than-or-equal (``&lt;=``) operatorsas indicators that ``result`` takes the value of the following value, theyare supported as aliases of the division operation (``/``). Thus, thefollowing are identical::    if result / expensive_request():        print(result.report())    if result &lt; expensive_request():        print(result.report())    if result &lt;= expensive_request():        print(result.report())It's a matter of preference which seems most logical, appropriate, andexpressive. None of them are as good Note, however, that the operation usuallyknown as division (``/``) has a much higher precedence (i.e. tighter binding toits operands) than the typical comparison operations (``&lt;`` and ``&lt;=``). If usedwith a more complex expressions, either know your precedence or use parenthesisto disambiguate!It'd be swell if Python supported arbitrary symbols. Unicode has what wouldbe reasonable alternative assignment markers, such as |larrow| (`LEFTARDSARROW &lt;http://www.fileformat.info/info/unicode/char/2190/index.htm&gt;`_), butalas! Until Python gets more Unicode-savvy, we have to choose some existingASCII operator to repurpose.It is also possible to use a function call idiom if you prefer::    if result(expensive_request()):        print(result.report())This has the virtue of looking like a &quot;wrapping&quot; of the expensiverequest value, rather than reusing / overloading an existing operation.Grabber and Similar===================I've experimented with other forms of collecting and rendering values.This version of ``enpassant`` includes the results of one of those experiments.Objects of the ``Grabber`` class can have their attributes set on their firstaccess. Subsequent uses of that attribute yield the set value.::    info = Grabber()    info.name('Joe')    assert info.name == 'Joe'The challenge with this approach is that once set, attribute values cannot bereset.Notes=====* Se ``CHANGES.yml`` for the change log.* `En passant &lt;http://en.wikipedia.org/wiki/En_passant&gt;`_ is a chess  term.* En passant assignment / naming is discussed in  `Issue1714448 &lt;http://bugs.python.org/issue1714448&gt;`_  and `PEP 379 &lt;http://www.python.org/dev/peps/pep-0379/&gt;`_, which have  been rejected and withdrawn, respectively. But that is years gone  by. I hope the idea will be productively reconsidered in the future.* Automated multi-version testing managed with  `pytest &lt;http://pypi.python.org/pypi/pytest&gt;`_,  `pytest-cov &lt;http://pypi.python.org/pypi/pytest-cov&gt;`_,  `coverage &lt;https://pypi.python.org/pypi/coverage/4.0b1&gt;`_, and  `tox &lt;http://pypi.python.org/pypi/tox&gt;`_.  Packaging linting with `pyroma &lt;https://pypi.python.org/pypi/pyroma&gt;`_.* Successfully packaged for, and  tested against, all early 2017 versions of Python: 2.6, 2.7, 3.2, 3.3,  3.4, 3.5, and 3.6, as well as latest PyPy and PyPy3.* On Python 2.6, uses Raymond Hettinger's `ordereddict &lt;https://pypi.python.org/pypi/ordereddict&gt;`_  module (which is included in the source tree for ease of installation)  to provide ``OrderedDict``. Thank you, Raymond!* The `simplere &lt;http://pypi.python.org/pypi/simplere&gt;`_ package similarly  provides en passant handling (and other helpers) for the important, common  case of regular expression searches.* An alterantive module: `dataholder &lt;https://pypi.python.org/pypi/dataholder/1.0.1&gt;`_.* The author, `Jonathan Eunice &lt;mailto:jonathan.eunice@gmail.com&gt;`_ or  `@jeunice on Twitter &lt;http://twitter.com/jeunice&gt;`_  welcomes your comments and suggestions.Installation============To install or upgrade to the latest version::    pip install -U enpassantYou may need to prefix these with ``sudo`` to authorizeinstallation. In environments without super-user privileges, you may want touse ``pip``'s ``--user`` option, to install only for a single user, ratherthan system-wide. You may also need version-specific versions of ``pip``,such as ``pip2`` and ``pip3``, depending on your system configuration.</longdescription>
</pkgmetadata>