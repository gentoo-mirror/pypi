<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>**DotObject v 1.3.1**Dot Notation ObjectDot lets you define objects in dot notation format.You need to subclass Dot and define your own load and optionally save methods in order to use the dot notation object.**Background**Dot Notation object was originally designed to be the base library for a Redis client for Python. Thus the names 'load' and 'save' come from. The idea was to have python object that simply by writing obj.item=&quot;value&quot;, it sets the redis key &quot;obj.item&quot; with &quot;value&quot; value.And as soon as it detects you are retrieving the value, it gets the latest version from Redis. But in the mean time, it gives you a lazy object till it actually needs the value from Redis.So the Dot notation object is basically a lazy object that once its &quot;load&quot; and &quot;save&quot; methods are defined, it will run those methods when the object is saved or retrieved.**Parameters**root_name : String, Optional.    It is used to overwrite the Dot object root name.int_starts_with: String, Optional. Default: i    It is used to idefntify integer parts since Python does not let integers as attributes.**Returns**A lazy object that will be evaluated when it is actually used.**Examples**Defining your own Dot    &gt;&gt;&gt; from dot import Dot    &gt;&gt;&gt; class This(Dot):    ...     def __init__(self, *args, **kwargs):    ...         super(This, self).__init__(*args, **kwargs)    ...         self.items = {}    ...     def load(self, paths):    ...         return {i: self.items[i] if i in self.items else &quot;value %s&quot; % i for i in paths}    ...     def save(self, path, value):    ...         self.items[path] = value    ... Creating a Dot object    &gt;&gt;&gt; this = This()    &gt;&gt;&gt; aa = this.part1.part2.part3.part4    &gt;&gt;&gt; aa    &lt;Lazy object: this.part1.part2.part3.part4&gt;    &gt;&gt;&gt; print(aa)    value this.part1.part2.part3.part4    &gt;&gt;&gt; aa    value this.part1.part2.part3.part4Dot objects get evaluated in a batch    &gt;&gt;&gt; this = This()    &gt;&gt;&gt; aa = this.part1    &gt;&gt;&gt; aa    &lt;Lazy object: this.part1&gt;    &gt;&gt;&gt; bb = this.part2    &gt;&gt;&gt; bb    &lt;Lazy object: this.part2&gt;    &gt;&gt;&gt; print(aa)    value this.part1    &gt;&gt;&gt; aa    value this.part1    &gt;&gt;&gt; bb    value this.part2Dealing with paths that have integers as a part    &gt;&gt;&gt; bb = this.part1.part2.i120    &gt;&gt;&gt; bb    &lt;Lazy object: this.part1.part2.120&gt;    &gt;&gt;&gt; print bb    value this.part1.part2.120Dealing with Dots like dictionary keys    &gt;&gt;&gt; cc = this['part1.part2.part4']    &gt;&gt;&gt; cc    &lt;Lazy object: this.part1.part2.part4&gt;    &gt;&gt;&gt; dd = this['part1.%s.part4' % 100]    &gt;&gt;&gt; dd    &lt;Lazy object: this.part1.100.part4&gt;    &gt;&gt;&gt; path = 'part1.part2'    &gt;&gt;&gt; this[path] = 'This was set by a dynamic key.'    &gt;&gt;&gt; this.path    This was set by a dynamic key.Saving Dots    &gt;&gt;&gt; this.part1.part2.part3.part4 = &quot;new value&quot;    &gt;&gt;&gt; zz = this.part1.part2.part3.part4    &gt;&gt;&gt; zz    new valueChanging Root name    &gt;&gt;&gt; class That(This):    ...    pass    &gt;&gt;&gt; that = That()    &gt;&gt;&gt; aa = that.something    &gt;&gt;&gt; print(aa)    value that.something    &gt;&gt;&gt; bb = this.something    &gt;&gt;&gt; bb    &lt;Lazy object: this.something&gt;Flushing cache    &gt;&gt;&gt; aa = this.part1    &gt;&gt;&gt; print aa    value this.part1    &gt;&gt;&gt; bb = this.part1 # reads from the cache    &gt;&gt;&gt; this.flush()    &gt;&gt;&gt; bb = this.part1 # Will evaluate this.part1 again</longdescription>
</pkgmetadata>