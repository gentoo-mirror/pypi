<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>======Patchy======.. image:: https://img.shields.io/github/actions/workflow/status/adamchainz/patchy/main.yml?branch=main&amp;style=for-the-badge   :target: https://github.com/adamchainz/patchy/actions?workflow=CI.. image:: https://img.shields.io/badge/Coverage-100%25-success?style=for-the-badge   :target: https://github.com/adamchainz/patchy/actions?workflow=CI.. image:: https://img.shields.io/pypi/v/patchy.svg?style=for-the-badge   :target: https://pypi.org/project/patchy/.. image:: https://img.shields.io/badge/code%20style-black-000000.svg?style=for-the-badge   :target: https://github.com/psf/black.. image:: https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&amp;logoColor=white&amp;style=for-the-badge   :target: https://github.com/pre-commit/pre-commit   :alt: pre-commit.. figure:: https://raw.githubusercontent.com/adamchainz/patchy/main/pirate.png   :alt: A patchy pirate...Patch the inner source of python functions at runtime.A quick example, making a function that returns 1 instead return 9001:.. code-block:: pycon    &gt;&gt;&gt; def sample():    ...     return 1    ...    &gt;&gt;&gt; patchy.patch(    ...     sample,    ...     &quot;&quot;&quot;\    ...     @@ -1,2 +1,2 @@    ...      def sample():    ...     -    return 1    ...     +    return 9001    ...     &quot;&quot;&quot;,    ... )    &gt;&gt;&gt; sample()    9001Patchy works by replacing the code attribute of the function, leaving thefunction object itself the same. It's thus more versatile than monkey patching,since if the function has been imported in multiple places they'll also callthe new behaviour.Installation============Use **pip**:.. code-block:: bash    python -m pip install patchyPython 3.8 to 3.12 supported.----**Hacking on a Django project?**Check out my book `Boost Your Django DX &lt;https://adamchainz.gumroad.com/l/byddx&gt;`__ which covers many ways to improve your development experience.----Why?====If you’re monkey-patching an external library to add or fix some functionality,you will probably forget to check the monkey patch when you upgrade it. Byusing a patch against its source code, you can specify some context that youexpect to remain the same in the function that will be checked before thesource is applied.I found this with some small but important patches to Django for a project.Since it takes a lot of energy to maintain a fork, writing monkey patches wasthe chosen quick solution, but then writing actual patches would be better.The patches are applied with the standard ``patch`` commandline utility.Why not?========There are of course a lot of reasons against:* It’s (relatively) slow (since it writes the source to disk and calls the  ``patch`` command)* If you have a patch file, why not just fork the library and apply it?* At least with monkey-patching you know what end up with, rather than having  the changes being done at runtime to source that may have changed.All are valid arguments. However once in a while this might be the rightsolution.How?====The standard library function ``inspect.getsource()`` is used to retrieve thesource code of the function, the patch is applied with the commandline utility``patch``, the code is recompiled, and the function’s code object is replacedthe new one. Because nothing tends to poke around at code objects apart fromdodgy hacks like this, you don’t need to worry about chasing any referencesthat may exist to the function, unlike ``mock.patch``.A little special treatment is given to ``instancemethod``, ``classmethod``, and``staticmethod`` objects to make sure the underlying function is what getspatched and that you don't have to worry about the details.API===``patch(func, patch_text)``---------------------------Apply the patch ``patch_text`` to the source of function ``func``. ``func`` maybe either a function, or a string providing the dotted path to import afunction.If the patch is invalid, for example the context lines don’t match,``ValueError`` will be raised, with a message that includes all the output fromthe ``patch`` utility.Note that ``patch_text`` will be ``textwrap.dedent()``’ed, but leadingwhitespace will not be removed. Therefore the correct way to include the patchis with a triple-quoted string with a backslash - ``&quot;&quot;&quot;\`` - which starts thestring and avoids including the first newline. A final newline is not requiredand will be automatically added if not present.Example:.. code-block:: python    import patchy    def sample():        return 1    patchy.patch(        sample,        &quot;&quot;&quot;\        @@ -2,2 +2,2 @@        -    return 1        +    return 2&quot;&quot;&quot;,    )    print(sample())  # prints 2``mc_patchface(func, patch_text)``----------------------------------An alias for ``patch``, so you can meme it up by calling``patchy.mc_patchface()``.``unpatch(func, patch_text)``-----------------------------Unapply the patch ``patch_text`` from the source of function ``func``. This isthe reverse of ``patch()``\ing it, and calls ``patch --reverse``.The same error and formatting rules apply as in ``patch()``.Example:.. code-block:: python    import patchy    def sample():        return 2    patchy.unpatch(        sample,        &quot;&quot;&quot;\        @@ -2,2 +2,2 @@        -    return 1        +    return 2&quot;&quot;&quot;,    )    print(sample())  # prints 1``temp_patch(func, patch_text)``--------------------------------Takes the same arguments as ``patch``. Usable as a context manager or functiondecorator to wrap code with a call to ``patch`` before and ``unpatch`` after.Context manager example:.. code-block:: python    def sample():        return 1234    patch_text = &quot;&quot;&quot;\        @@ -1,2 +1,2 @@         def sample():        -    return 1234        +    return 5678        &quot;&quot;&quot;    with patchy.temp_patch(sample, patch_text):        print(sample())  # prints 5678Decorator example, using the same ``sample`` and ``patch_text``:.. code-block:: python    @patchy.temp_patch(sample, patch_text)    def my_func():        return sample() == 5678    print(my_func())  # prints True``replace(func, expected_source, new_source)``----------------------------------------------Check that function or dotted path to function ``func`` has an AST matching``expected_source``, then replace its inner code object with source compiledfrom ``new_source``. If the AST check fails, ``ValueError`` will be raised withcurrent/expected source code in the message. In the author's opinion it'spreferable to call ``patch()`` so your call makes it clear to see what is beingchanged about ``func``, but using ``replace()`` is simpler as you don't have tomake a patch and there is no subprocess call to the ``patch`` utility.Note both ``expected_source`` and ``new_source`` will be``textwrap.dedent()``’ed, so the best way to include their source is with atriple quoted string with a backslash escape on the first line, as per theexample below.If you want, you can pass ``expected_source=None`` to avoid the guard againstyour target changing, but this is highly unrecommended as it means if theoriginal function changes, the call to ``replace()`` will continue to silentlysucceed.Example:.. code-block:: python    import patchy    def sample():        return 1    patchy.replace(        sample,        &quot;&quot;&quot;\        def sample():            return 1        &quot;&quot;&quot;,        &quot;&quot;&quot;\        def sample():            return 42        &quot;&quot;&quot;,    )    print(sample())  # prints 42How to Create a Patch=====================1. Save the source of the function of interest (and nothing else) in a ``.py``   file, e.g. ``before.py``:   .. code-block:: python       def foo():           print(&quot;Change me&quot;)   Make sure you dedent it so there is no whitespace before the ``def``, i.e.   ``d`` is the first character in the file. For example if you wanted to patch   the ``bar()`` method below:   .. code-block:: python       class Foo:           def bar(self, x):               return x * 2   ...you would put just the method in a file like so:   .. code-block:: python       def bar(self, x):           return x * 2   However we'll continue with the first example ``before.py`` since it's   simpler.2. Copy that ``.py`` file, to e.g. ``after.py``, and make the changes you   want, such as:   .. code-block:: python       def foo():           print(&quot;Changed&quot;)3. Run ``diff``, e.g. ``diff -u before.py after.py``. You will get output like:   .. code-block:: diff      diff --git a/Users/chainz/tmp/before.py b/Users/chainz/tmp/after.py      index e6b32c6..31fe8d9 100644      --- a/Users/chainz/tmp/before.py      +++ b/Users/chainz/tmp/after.py      @@ -1,2 +1,2 @@       def foo():      -    print(&quot;Change me&quot;)      +    print(&quot;Changed&quot;)4. The filenames are not necessary for ``patchy`` to work. Take only from the   first ``@@`` line onwards into the multiline string you pass to   ``patchy.patch()``:   .. code-block:: python      patchy.patch(          foo,          &quot;&quot;&quot;\          @@ -1,2 +1,2 @@           def foo():          -    print(&quot;Change me&quot;)          +    print(&quot;Changed&quot;)          &quot;&quot;&quot;,      )</longdescription>
</pkgmetadata>