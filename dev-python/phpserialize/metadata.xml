<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>phpserialize~~~~~~~~~~~~a port of the ``serialize`` and ``unserialize`` functions ofphp to python.  This module implements the python serializationinterface (eg: provides `dumps`, `loads` and similar functions).Usage=====&gt;&gt;&gt; from phpserialize import *&gt;&gt;&gt; obj = dumps(&quot;Hello World&quot;)&gt;&gt;&gt; loads(obj)'Hello World'Due to the fact that PHP doesn't know the concept of lists, listsare serialized like hash-maps in PHP.  As a matter of fact thereverse value of a serialized list is a dict:&gt;&gt;&gt; loads(dumps(range(2))){0: 0, 1: 1}If you want to have a list again, you can use the `dict_to_list`helper function:&gt;&gt;&gt; dict_to_list(loads(dumps(range(2))))[0, 1]It's also possible to convert into a tuple by using the `dict_to_tuple`function:&gt;&gt;&gt; dict_to_tuple(loads(dumps((1, 2, 3))))(1, 2, 3)Another problem are unicode strings.  By default unicode strings areencoded to 'utf-8' but not decoded on `unserialize`.  The reason forthis is that phpserialize can't guess if you have binary or text datain the strings:&gt;&gt;&gt; loads(dumps(u'Hello W\xf6rld'))'Hello W\xc3\xb6rld'If you know that you have only text data of a known charset in the resultyou can decode strings by setting `decode_strings` to True when callingloads:&gt;&gt;&gt; loads(dumps(u'Hello W\xf6rld'), decode_strings=True)u'Hello W\xf6rld'Dictionary keys are limited to strings and integers.  `None` is convertedinto an empty string and floats and booleans into integers for PHPcompatibility:&gt;&gt;&gt; loads(dumps({None: 14, 42.23: 'foo', True: [1, 2, 3]})){'': 14, 1: {0: 1, 1: 2, 2: 3}, 42: 'foo'}It also provides functions to read from file-like objects:&gt;&gt;&gt; from StringIO import StringIO&gt;&gt;&gt; stream = StringIO('a:2:{i:0;i:1;i:1;i:2;}')&gt;&gt;&gt; dict_to_list(load(stream))[1, 2]And to write to those:&gt;&gt;&gt; stream = StringIO()&gt;&gt;&gt; dump([1, 2], stream)&gt;&gt;&gt; stream.getvalue()'a:2:{i:0;i:1;i:1;i:2;}'Like `pickle` chaining of objects is supported:&gt;&gt;&gt; stream = StringIO()&gt;&gt;&gt; dump([1, 2], stream)&gt;&gt;&gt; dump(&quot;foo&quot;, stream)&gt;&gt;&gt; stream.seek(0)&gt;&gt;&gt; load(stream){0: 1, 1: 2}&gt;&gt;&gt; load(stream)'foo'This feature however is not supported in PHP.  PHP will only unserializethe first object.Array Serialization===================Starting with 1.2 you can provide an array hook to the unserializationfunctions that are invoked with a list of pairs to return a real arrayobject.  By default `dict` is used as array object which however meansthat the information about the order is lost for associative arrays.For example you can pass the ordered dictionary to the unserilizationfunctions:&gt;&gt;&gt; from collections import OrderedDict&gt;&gt;&gt; loads('a:2:{s:3:&quot;foo&quot;;i:1;s:3:&quot;bar&quot;;i:2;}',...       array_hook=OrderedDict)collections.OrderedDict([('foo', 1), ('bar', 2)])Object Serialization====================PHP supports serialization of objects.  Starting with 1.2 of phpserializeit is possible to both serialize and unserialize objects.  Because classnames in PHP and Python usually do not map, there is a separate`object_hook` parameter that is responsible for creating these classes.For a simple test example the `phpserialize.phpobject` class can be used:&gt;&gt;&gt; data = 'O:7:&quot;WP_User&quot;:1:{s:8:&quot;username&quot;;s:5:&quot;admin&quot;;}'&gt;&gt;&gt; user = loads(data, object_hook=phpobject)&gt;&gt;&gt; user.username'admin'&gt;&gt;&gt; user.__name__'WP_User'An object hook is a function that takes the name of the class and a dictwith the instance data as arguments.  The instance data keys are in PHPformat which usually is not what you want.  To convert it into Pythonidentifiers you can use the `convert_member_dict` function.  For moreinformation about that, have a look at the next section.  Here anexample for a simple object hook:&gt;&gt;&gt; class User(object):...     def __init__(self, username):...         self.username = username...&gt;&gt;&gt; def object_hook(name, d):...     cls = {'WP_User': User}[name]...     return cls(**d)...&gt;&gt;&gt; user = loads(data, object_hook=object_hook)&gt;&gt;&gt; user.username'admin'To serialize objects you can use the `object_hook` of the dump functionsand return instances of `phpobject`:&gt;&gt;&gt; def object_hook(obj):...     if isinstance(obj, User):...         return phpobject('WP_User', {'username': obj.username})...     raise LookupError('unknown object')...&gt;&gt;&gt; dumps(user, object_hook=object_hook)'O:7:&quot;WP_User&quot;:1:{s:8:&quot;username&quot;;s:5:&quot;admin&quot;;}'PHP's Object System===================The PHP object system is derived from compiled languages such as Javaand C#.  Attributes can be protected from external access by settingthem to `protected` or `private`.  This does not only serve the purposeto encapsulate internals but also to avoid name clashes.In PHP each class in the inheritance chain can have a private variablewith the same name, without causing clashes.  (This is similar to thePython `__var` name mangling system).This PHP class::    class WP_UserBase {        protected $username;        public function __construct($username) {            $this-&gt;username = $username;        }    }    class WP_User extends WP_UserBase {        private $password;        public $flag;        public function __construct($username, $password) {            parent::__construct($username);            $this-&gt;password = $password;            $this-&gt;flag = 0;        }    }Is serialized with a member data dict that looks like this:&gt;&gt;&gt; data = {...     ' * username':          'the username',...     ' WP_User password':    'the password',...     'flag':                 'the flag'... }Because this access system does not exist in Python, the`convert_member_dict` can convert this dict:&gt;&gt;&gt; d = convert_member_dict(data)&gt;&gt;&gt; d['username']'the username'&gt;&gt;&gt; d['password']'the password'The `phpobject` class does this conversion on the fly.  What isserialized is the special `__php_vars__` dict of the class:&gt;&gt;&gt; user = phpobject('WP_User', data)&gt;&gt;&gt; user.username'the username'&gt;&gt;&gt; user.username = 'admin'&gt;&gt;&gt; user.__php_vars__[' * username']'admin'As you can see, reassigning attributes on a php object will tryto change a private or protected attribute with the same name.Setting an unknown one will create a new public attribute:&gt;&gt;&gt; user.is_admin = True&gt;&gt;&gt; user.__php_vars__['is_admin']TrueTo convert the phpobject into a dict, you can use the `_asdict`method:&gt;&gt;&gt; d = user._asdict()&gt;&gt;&gt; d['username']'admin'Python 3 Notes==============Because the unicode support in Python 3 no longer transparentlyhandles bytes and unicode objects we had to change the way thedecoding works.  On Python 3 you most likely want to alwaysdecode strings.  Because this would totally fail on binary dataphpserialize uses the &quot;surrogateescape&quot; method to not fail oninvalid data.  See the documentation in Python 3 for moreinformation.Changelog=========1.3    -   added support for Python 31.2    -   added support for object serialization    -   added support for array hooks1.1    -   added `dict_to_list` and `dict_to_tuple`    -   added support for unicode    -   allowed chaining of objects like pickle does</longdescription>
</pkgmetadata>