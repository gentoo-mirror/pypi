<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![Logo](https://github.com/mkrd/PathDict/blob/main/assets/logo.png?raw=true)[![Total Downloads](https://pepy.tech/badge/path-dict)](https://pepy.tech/project/path-dict)![Tests](https://github.com/mkrd/PathDict/actions/workflows/test.yml/badge.svg)![Coverage](https://github.com/mkrd/PathDict/blob/main/assets/coverage.svg?raw=1)Why do I need this?================================================================================Do you work with dicts a lot, but you also whish that they could do more?Then PathDict is for you!Lets look at this dict:```pythonusers = {    &quot;u1&quot;: {        &quot;name&quot;: &quot;Julia&quot;,        &quot;age&quot;: 32,        &quot;interests&quot;: [&quot;soccer&quot;, &quot;basketball&quot;],    },    &quot;u2&quot;: {        &quot;name&quot;: &quot;Ben&quot;,        &quot;age&quot;: 26,        &quot;interests&quot;: [&quot;airplanes&quot;, &quot;alternative music&quot;],    }}```With PathDict, you can do things like:```pythonusers = PathDict(users)# Get all user namesusers[&quot;*&quot;, &quot;name&quot;]  # -&gt; [&quot;Julia&quot;, &quot;Ben&quot;]# Add new post to the current_user's postsnew_post = {&quot;title&quot;: ...}users[current_user.id, &quot;posts&quot;] = lambda x: (x or []) + [new_post]  # Key &quot;posts&quot; is automatically created!# Increase age of Juliausers[&quot;u1&quot;, &quot;age&quot;] = 33# Append interest &quot;cooking&quot; to all usersusers[&quot;*&quot;, &quot;interests&quot;] = lambda interests: interests + [&quot;cooking&quot;]# Remove all interests of Ben which do not start with &quot;a&quot; (&quot;cooking is removed&quot;)users.filter(&quot;u2&quot;, &quot;interests&quot;, f=lambda interest: not interest.startswith(&quot;a&quot;))# Remove users that are younger than 30users.filter(f=lambda id, user: user[&quot;age&quot;] &gt;= 30)```**Pretty neat, right?**Second Example--------------------------------------------------------------------------------Consider the following dict filled with users. Notice how Bob hasprovided sports interests only, and Julia has provided music interests only.```pythondb = {    &quot;bob&quot;: {        &quot;interests&quot;: {            &quot;sports&quot;: [&quot;soccer&quot;, &quot;basketball&quot;]        }    },    &quot;julia&quot;: {        &quot;interests&quot;: {            &quot;music&quot;: [&quot;pop&quot;, &quot;alternative&quot;]        }    }}```Lets print the music interests of each user using normal dicts:```pythonfor user_name in db:    user_music = None    if user_name in db:        if &quot;interests&quot; in db[user_name]:            if &quot;music&quot; in db[user_name][&quot;interests&quot;]:                user_music = db[user_name][&quot;interests&quot;][&quot;music&quot;]    print(user_music)# ---&gt; None# ---&gt; [&quot;pop&quot;, &quot;alternative&quot;]```**Annoying, right?** This is how we do it with a PathDict:```pythondb = PathDict(db)for user_name in db:    print(db[user_name, &quot;interests&quot;, &quot;music&quot;])# ---&gt; None# ---&gt; [&quot;pop&quot;, &quot;alternative&quot;]```**Much better!** If any of the keys do not exist, it will not throw and error,but return `None`.If we tried this with a normal dict, we would have gotten a `KeyError`.The same also works for setting values, if the path does not exist, it will becreated.Installation================================================================================`pip3 install path-dict````pythonfrom path_dict import PathDict```Usage================================================================================PathDict subclasses [collections.UserDict](https://docs.python.org/3/library/collections.html#collections.UserDict),so it behaves almist like a normal python dict, but comes with some handy extras.## Initialize```python# Empty PathDictpd = PathDict()&gt; pd---&gt; PathDict({})```A PathDict keeps a reference to the original initializing dict:```pythonuser = {    &quot;name&quot;: &quot;Joe&quot;,    &quot;age&quot;: 22,    &quot;hobbies&quot;: [&quot;Playing football&quot;, &quot;Podcasts&quot;]    &quot;friends&quot;: {        &quot;Sue&quot;: {&quot;age&quot;: 30},        &quot;Ben&quot;: {&quot;age&quot;: 35},    }}joe = PathDict(user)&gt; joe == user---&gt; True&gt; joe.dict is user---&gt; True```You can also get a deep copy:```pythonjoe = PathDict(user, copy=True)&gt; joe == user---&gt; True&gt; joe.dict is user---&gt; False```## Getting and setting values with pathsYou can use paths of keys to access values:```pythonjoe = PathDict(user, copy=True)# Get existing path&gt; joe[&quot;friends&quot;, &quot;Sue&quot;, &quot;age&quot;]---&gt; 30# Get non-existent, but valid path&gt; joe[&quot;friends&quot;, &quot;Josef&quot;, &quot;age&quot;]---&gt; None# Set non-existent, but valid path, creates keysjoe[&quot;authentification&quot;, &quot;password&quot;] = &quot;abc123&quot;&gt; joe[&quot;authentification&quot;]---&gt; PathDict({&quot;password&quot;: &quot;abc123&quot;})```Using invalid paths to get or set a value will result in an error. An invalid path is a path that tries to access a key of an int or list, for example. So, only use paths to access hierarchies of PathDicts.```pythonjoe = PathDict(user, copy=True)# Get invalid path (joe[&quot;hobbies&quot;] is a list)&gt; joe[&quot;hobbies&quot;, &quot;not_existent&quot;]---&gt; Error!```## Most dict methods are supportedMany of the usual dict methods work with PathDict:```pythonpathdict = ...for key, value in pathdict.items():    ...for key in pathdict:    ...for key in pathdict.keys():    ...for value in pathdict.values():    ...```## Apply a function at a pathWhen setting a value, you can use a lambda function to modify the value at a given path.The function should take one argument and return the modified value.```pythonstats_dict = {}stats_pd = PathDict({})# Using a standard dict:if &quot;views&quot; not in stats_dict:    stats_dict[&quot;views&quot;] = {}if &quot;total&quot; not in stats_dict[&quot;views&quot;]:     stats_dict[&quot;views&quot;][&quot;total&quot;] = 0stats_dict[&quot;views&quot;][&quot;total&quot;] += 1# Using a PathDict:stats_pd[&quot;views&quot;, &quot;total&quot;] = lambda x: (x or 0) + 1```## FilteringPathDicts offer a filter function, which can filter a list or a PathDict at a given path in-place.To filter a list, pass a function that takes one argument (eg. `lambda ele: return ele &gt; 10`) and returns True if the value should be kept, else False.To filter a PathDict, pass a function that takes two arguments (eg. `lambda key, value: key != &quot;1&quot;`) and returns True if the key-value pair should be kept, else False.You can filter the PathDict filter is called on, or you can also pass a path into the filter to apply the filter at a given path.A filtered function is also offered, which does the same, but returns a filtered copy instead of filtering in-place.```pythonjoe = PathDict(user, copy=True)# Remove all friends that are older than 33.joe.filter(&quot;friends&quot;, f=lambda k, v: v[&quot;age&quot;] &lt;= 33)&gt; joe[&quot;friends&quot;]---&gt; PathDict({    &quot;Sue&quot;: {&quot;age&quot;: 30}})```## AggregatingThe aggregate function can combine a PathDict to a single aggregated value.It takes an init parameter, and a function with takes three arguments (eg. `lambda key, val, agg`)```pythonjoe = PathDict(user, copy=True)# Sum of ages of all friends of joefriend_ages = joe.aggregate(&quot;friends&quot;, init=0, f=lambda k, v, a: a + v[&quot;age&quot;])&gt; friend_ages---&gt; 65```## Serialize to JSONTo serialize a PathDict to JSON, call `json.dumps(&lt;PathDict&gt;.dict)`.If you try to serialize a PathDict object itself, the operation will fail.# Reference### pd(data: dict | list, raw=False) -&gt; PathDictCreates and returns a handle on the given data. Args:- `data` - Must be a list or dict.- `raw` - If `True`, do not interpret paths. So wildcards (`*`) are interpreted as a usual key, and tuples will be interpreted as keys  as well.Returns:- A handle that references the root of the given data dict or list.## PathDict### copy(self, from_root=False) -&gt; PathDictReturn a deep copy of the data at the current path or from the root.Args:- `from_root` - If `True`, the copy will not be made at the root data, and not where the current path is. The path handle will be at the same location as it was in the original. If `False`, only the part of the data where the current path handle is at will be copied.Returns:- A handle on the newly created copyThe current path handle will stay the same.</longdescription>
</pkgmetadata>