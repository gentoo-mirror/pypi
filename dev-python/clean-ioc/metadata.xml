<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Clean IoCA simple dependency injection library for python that requires nothing of your application code (except that you use typing).## Basic Registering and resolvingThere are 4 basic modes of registering a new set of classes### Implementation```pythonclass UserRepository(abc.ABC)    @abc.abstractmethod    def add(self, user):        passclass InMemoryUserRepository(UserRepository)    def __init__(self):        self.users = []    def add(self, user):        # This is obviously terrible, but it's for demo purposes        self.users.append(user)class SqlAlchemyUserRepository(UserRepository)    def __init__(self):        # Do some db stuff here        pass    def add(self, user):        # Do some db stuff here        passcontainer = Container()container.register(UserRepository, InMemoryUserRepository)repository = container.resolve(UserRepository) # This will return an InMemoryUserRepository```### Concrete Class```pythonclass ClientDependency    def get_int(self):        return 10class Client    def __init__(self, dep: ClientDependency)        self.dep = dep    def get_number(self):        return self.dep.get_int()container = Container()container.register(ClientDependency)container.register(Client)client = container.resolve(Client)client.get_number() # returns 10```### Factory```pythonclass ClientDependency    def get_int(self):        return 10class Client    def __init__(self, dep: ClientDependency)        self.dep = dep    def get_number(self):        return self.dep.get_int()def client_factory(dep: ClientDependency):    return Client(dep=dep)container = Container()container.register(ClientDependency)container.register(Client, factory=client_factory)client = container.resolve(Client)client.get_number() # returns 10```### Instance```pythonclass ClientDependency    def __init__(self, num):        self.num = num    def get_int(self):        return self.numclass Client    def __init__(self, dep: ClientDependency)        self.dep = dep    def get_number(self):        return self.dep.get_int()client_dependency = ClientDependency(num=10)container = Container()container.register(ClientDependency, instance=client_dependency)container.register(Client)client = container.resolve(Client)client.get_number() # returns 10```## List resolvingIf you have multiple dependencues you can simply define a dependency as a list[T] and you can return all of the instances.```pythonclass ClientDependency    def __init__(self, numbers: list[int]):        self.numbers = numbers    def get_numbers(self):        return self.numbersclass Client    def __init__(self, dep: ClientDependency)        self.dep = dep    def get_numbers(self):        return self.dep.get_numbers()container = Container()container.register(ClientDependency)container.register(Client)container.register(int, instance=1)container.register(int, instance=2)container.register(int, instance=3)client = container.resolve(Client)client.get_numbers() # returns [3, 2, 1]```## DecoratorsFollows a object orientated decoration pattern, rather than a decoration annotation.The main reason for this was to allow decotation of registered instances```pythonclass Client    def __init__(self, number: int)        self.number = number    def get_number(self):        return self.numberclass DoubleClientDecorator(Client):    def __init__(self, client: Client):        self.client = client    def get_number(self):        return self.client.get_number() * 2container = Container()container.register(Client)container.register_decorator(Client, DoubleClientDecorator)container.register(int, instance=10)client = container.resolve(Client)client.get_number() # returns 20```Decorators are resolved in order of when first registered. So the first registered decorator is the highest in the class tree```python    class Concrete:        pass    class DecoratorOne(Concrete):        def __init__(self, child: Concrete):            self.child = child    class DecoratorTwo(Concrete):        def __init__(self, child: Concrete):            self.child = child    container = Container()    container.register(Concrete)    container.register_decorator(Concrete, DecoratorOne)    container.register_decorator(Concrete, DecoratorTwo)    root = container.resolve(Concrete)    type(root) # returns DecoratorOne    type(root.child) # returns DecoratorTwo    type(root.child.child) # returns Concrete```## Subclasses registrationThis feature allows registration of all subclasses of a giveb type```pythonclass Client(abc.ABC)    @abc.abstractmethod    def get_number(self):        passclass TenClient(Client)    def get_number(self):        return 10class TwentyClient(Client)    def get_number(self):        return 20container = Container()container.register_subclasses(Client)ten_client = container.resolve(TenClient)ten_client.get_number() # returns 10twenty_client = container.resolve(TwentyClient)twenty_client.get_number() # returns 20# Resolve all subsclasses of Clientclient = container.resolve(list[Client]) ## [TwentyClient(), TenClient()]```## LifespansLifespans configure how long and resolved object says alive forThere are 4 lifespan types### transientAlways create a new instance```pythoncontainer.register(Client, lifespan=Lifespan.transient)```### once_per_graph (Default behaviour)Only create one instance throughout the resolve call```pythoncontainer.register(Client, lifespan=Lifespan.once_per_graph)```### scopedOnly create a new instance through the life a scope. When not in a scope the behaviour is the same as **once_per_graph**```pythoncontainer.register(Client, lifespan=Lifespan.scoped)```### singletonOnly one instance of the object is created throughout the lifespan of the container```pythoncontainer.register(Client, lifespan=Lifespan.singleton)```*Note:*When registering an instance, then the behaviour is always singleton```pythoncontainer.register(int, instance=10)```## Open GenericsRegisters all generic subclasses of the service type and allows you to resolve with the generic alias```pythonT = TypeVar(&quot;T&quot;)class HelloCommand:    passclass GoodbyeCommand:    passclass CommandHandler(Generic[T]):    def handle(self, command: T):        passclass HelloCommandHandler(CommandHandler[HelloCommand]):    def handle(self, command: HelloCommand):        print('HELLO')class GoodbyeCommandHandler(CommandHandler[GoodbyeCommand]):    def handle(self, command: GoodbyeCommand):        print('GOODBYE')container = Container()container.register_open_generic(CommandHandler)h1 = container.resolve(CommandHandler[HelloCommand])h2 = container.resolve(CommandHandler[GoodbyeCommand])h1.handle(HelloCommand()) # prints 'HELLO'h2.handle(GoodbyeCommand()) # prints 'GOODBYE'```## Open Generic DecoratorsAllows you to add decorators to your open generic registrations```pythonT = TypeVar(&quot;T&quot;)class HelloCommand:    passclass GoodbyeCommand:    passclass CommandHandler(Generic[T]):    def handle(self, command: T):        passclass HelloCommandHandler(CommandHandler[HelloCommand]):    def handle(self, command: HelloCommand):        print('HELLO')class GoodbyeCommandHandler(CommandHandler[GoodbyeCommand]):    def handle(self, command: GoodbyeCommand):        print('GOODBYE')class AVeryBigCommandHandlerDecorator(Generic[T]):    def __init__(self, handler: CommandHandler[T]):        self.handler = handler    def handle(self, command: T):        print('A VERY BIG')        self.handler.handle(command=command)container = Container()container.register_open_generic(CommandHandler)container.register_open_generic_decorator(CommandHandler, AVeryBigCommandHandlerDecorator)h1 = container.resolve(CommandHandler[HelloCommand])h2 = container.resolve(CommandHandler[GoodbyeCommand])h1.handle(HelloCommand()) # prints 'A VERY BIG\nHELLO'h2.handle(GoodbyeCommand()) # prints 'A VERY BIG\nGOODBYE'```## ScopesScopes are a way to create a sub container that will live for a certain lifespan.Some good use cases for scope would be for the lifespan of handling a http request with a web server or a message/event if working on a message based system```pythonclass Client    def __init__(self, number: int)        return number    def get_number(self):        return self.resolver.resolve(int)container.register(int, instance=2)container.register(Client)client = container.resolve(Client)client.get_number() # returns 2with container.get_scope() as scope:    scope.register(int, instance=10)    scoped_client = scope.resolve(Client)    scoped_client.get_number() # returns 10```## Named registrations &amp; Registration filtersBy default the last unnamed registration is what the container will return when resolve is called as below.```pythoncontainer = Container()container.register(int, instance=1)container.register(int, instance=2)container.register(int, instance=3)number = container.resolve(int) # returns 3```To be more selective of what we return we can add a name to the registration and apply a registration filter when we resolve.A registration filter is simply function that receives a **Registration** and returns a **bool**For example if we wanted to get the int named **&quot;One&quot;** we do the following```pythoncontainer = Container()container.register(int, instance=1, name=&quot;One&quot;)container.register(int, instance=2, name=&quot;Two&quot;)container.register(int, instance=3, name=&quot;Three&quot;)number = container.resolve(int, filter=lambda r: r.name == &quot;One&quot;) # returns 1```Clean IOC comes with a set of in built registration filters that can be found [here](./clean_ioc/registration_filters.py)We can get the desired behaviour as above```pythonfrom clean_ioc.registration_filters import with_namecontainer = Container()container.register(int, instance=1, name=&quot;One&quot;)container.register(int, instance=2, name=&quot;Two&quot;)container.register(int, instance=3, name=&quot;Three&quot;)number = container.resolve(int, filter=with_name(&quot;One&quot;)) # returns 1```## Dependency SettingsDependency settings are defined at registration and allow you to define the selection or setting dependencies```pythonclass Client    def __init__(self, number=10)        self.number = number    def get_number(self):        return self.numbercontainer = Container()container.register(int, instance=1, name=&quot;One&quot;)container.register(int, instance=2)container.register(    Client,    name=&quot;SetsValue&quot;,    dependency_config={&quot;number&quot;: DependencySettings(value=50)})container.register(    Client,    name=&quot;UsesDefaultValue&quot;)container.register(    Client,    name=&quot;IgnoresDefaultParameterValue&quot;,    dependency_config={&quot;number&quot;: DependencySettings(use_default_paramater=False)})container.register(    Client,    name=&quot;UsesRegistrationFilter&quot;,    dependency_config={&quot;number&quot;: DependencySettings(use_default_paramater=False, filter=with_name(&quot;One&quot;))})client1 = container.resolve(Client, filter=with_name(&quot;SetsValue&quot;))client2 = container.resolve(Client, filter=with_name(&quot;UsesDefaultValue&quot;))client3 = container.resolve(Client, filter=with_name(&quot;IgnoresDefaultParameterValue&quot;))client4 = container.resolve(Client, filter=with_name(&quot;UsesRegistrationFilter&quot;))client1.get_number() # returns 50client2.get_number() # returns 10client3.get_number() # returns 2client4.get_number() # returns 1```The order of a dependant value is as follows1. Setting the dependency value explicitly    ```python    DependencySettings(value=50)    ```2. Using the default parameter value if it exisis the dependency value explicitly    ```python    class Client    def __init__(self, number=10)        self.number = number    ```    If you don't want to use the default parameter value you can set it to false in the dependency setting    ```python    DependencySettings(use_default_paramater=False)    ```3. Going to the container registry to find a registration using the registration filter if, if there is a default value on the dependant paramater you must explicity set.## TagsTags can be added to registrations in order to support filtering. This can be useful as a means to filter registrations when resolving lists of a particular type```pythonclass A:    passa1 = A()a2 = A()a3 = A()container = Container()container.register(A, instance=a1, tags=[Tag(&quot;a&quot;, &quot;a1&quot;)])container.register(A, instance=a2, tags=[Tag(&quot;a&quot;)])container.register(A, instance=a3)ar1 = container.resolve(A, filter=has_tag(&quot;a&quot;, &quot;a1&quot;)) # returns a1al1 = container.resolve(list[A], filter=has_tag(&quot;a&quot;))  # returns [a2, a1]al2 = container.resolve(list[A], filter=has_tag(&quot;a&quot;, &quot;a1&quot;)) # returns [a1]al3 = container.resolve(list[A], filter=fn_not(has_tag(&quot;a&quot;, &quot;a1&quot;)))  # returns [a3, a2]al4 = container.resolve(list[A], filter=fn_not(has_tag(&quot;a&quot;))) # returns [a3]al5 = container.resolve(list[A]) # returns [a3, a2, a1]```## Parent Context FiltersRegistrations can also specify that should only apply to certain parents objects by setting the parent_context_filter```pythondef test_parent_context_filter():    class A:        pass    class B(A):        pass    class C(A):        pass    class D:        def __init__(self, a: A):            self.a = a    class E:        def __init__(self, a: A):            self.a = a    container = Container()    container.register(A, B, parent_context_filter=parent_implementation_is(E))    container.register(A, C, parent_context_filter=parent_implementation_is(D))    container.register(D)    container.register(E)    e = container.resolve(E)    d = container.resolve(D)    type(e.a) # returns B    type(d.a) # returns C```## Accessing the Container, Scope and Resolver within dependenciesAccessing container directly```pythonclass Client    def __init__(self, container: Container)        self.container = container    def get_number(self):        return self.container.resolve(int)container.register(int, instance=2)container.register(Client)client = container.resolve(Client)client.get_number() # returns 2```Accessing Resolver also returns the container```pythonclass Client    def __init__(self, resolver: Resolver)        self.resolver = resolver    def get_number(self):        return self.resolver.resolve(int)container.register(int, instance=2)container.register(Client)client = container.resolve(Client)client.get_number() # returns 2```When within a scope, Resolver returns the current scope rather than the container```pythonclass Client    def __init__(self, resolver: Resolver)        self.resolver = resolver    def get_number(self):        return self.resolver.resolve(int)container.register(int, instance=2)container.register(Client)client = container.resolve(Client)client.get_number() # returns 2with container.get_scope() as scope:    scope.register(int, instance=10)    scoped_client = scope.resolve(Client)    scoped_client.get_number() # returns 10```Scopes can also be used as an async context manager```pythonclass Client    async def get_number(self):        return 10container.register(Client)async with container.get_scope() as scope:    scoped_client = scope.resolve(Client)    await scoped_client.get_number() # returns 10```## ModulesA module is a just a function that accepts a container, it can be used to set up common elements on the container```pythonclass ClientDependency    def get_int(self):        return 10class Client    def __init__(self, dep: ClientDependency)        self.dep = dep    def get_number(self):        return self.dep.get_int()def client_module(c: Container):    c.register(ClientDependency)    c.register(Client)container.apply_module(client_module)client = container.resolve(Client)client.get_number() # returns 10```### Helper for modulesThere is now a ```BaseModule``` class that gives you a bit more safety around running a module twice etc. Also you might want to pass in instances into the module.You can find the ```BaseModule``` in ```clean_ioc.modules``` module```python@dataclassclass ClientConfig    url: strclass Client    def __init__(self, config: ClientConfig)        self.base_url = config.url    def get_thing(self):        # Do some requests stuff here        passclass ClientModule(BaseModule):    def __init__(self, config: ClientConfig):        self.config = config    def run(self, c: Container):        c.register(ClientConfig, instance=self.config)        c.register(Client)client_config = ClientConfig(    url = &quot;https://example.com&quot;)container.apply_module(client_module)client = container.resolve(ClientModule(config=client_config))client.get_thing()```## DependencyContext (BETA feature)You can inject a special type into your dependants that allows you to inspect the current dependency tree. For instances you can check the parent of the current class you are constructingOne example of where this becomes useful is if injecting a logger, you can get information about the loggers parent to add extra context```pythonclass Logger    def __init__(self, module):        self.module = moduleclass Client    def __init__(self, logger: Logger)        self.logger = loggerdef logger_fac(context: DependencyContext):    module = context.parent.implementation.__module__    return Logger(module)container = Container()container.register(Client)container.register(Logger, factory=logger_fac)client = container.resolve(Client)```## Pre-configurationsPre configurations run a side-effect for a type before the type gets resolved.This is useful if some python modules have some sort of module level functions that need to be called before the object get created```pythonimport loggingclass Client    def __init__(self, logger: logging.Logger)        self.logger = logger    def do_a_thing(self):        self.logger.info('Doing a thing')def logger_fac(context: DependencyContext):    module = context.parent.implementation.__module__    return logging.getLogger(module)def configuring_logging():    logging.basicConfig()container = Container()container.register(Client)container.register(logging.Logger, factory=logger_fac)container.pre_configure(logging.Logger, configuring_logging)client = container.resolve(Client)```</longdescription>
</pkgmetadata>