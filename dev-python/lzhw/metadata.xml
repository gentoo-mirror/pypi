<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># lzhw##### Compression library for data frames and tabular data files, csv, excel etc.![lzhw logo](./img/lzhw_logo.jpg)[![](https://img.shields.io/badge/docs-latest-blue.svg)](https://mnoorfawi.github.io/lzhw/) [![Build Status](https://travis-ci.com/MNoorFawi/lzhw.svg?branch=master)](https://travis-ci.com/MNoorFawi/lzhw)**Compression** library to compress big lists and/or pandas dataframes using an **optimized algorithm (lzhw)** developed from Lempel-Ziv, Huffman and LZ-Welch techniques.**lzhw** has a command line tool that can be downloaded from [here](https://github.com/MNoorFawi/lzhw/releases/download/v0.0.10/lzhw.exe) and can work from command line with no prior python installation.**Manual on how to use it available [here](https://mnoorfawi.github.io/lzhw/5%20Using%20the%20lzhw%20command%20line%20tool/)**.It works on Windows and soon a Mac version will be available.## Full documentation can be found [here](https://mnoorfawi.github.io/lzhw/)**Data Frames compression and decompression can work in parallel**. ## Quick Start```bashpip install lzhw``````pythonimport lzhwsample_data = [&quot;Sunny&quot;, &quot;Sunny&quot;, &quot;Overcast&quot;, &quot;Rain&quot;, &quot;Rain&quot;, &quot;Rain&quot;, &quot;Overcast&quot;,                &quot;Sunny&quot;, &quot;Sunny&quot;, &quot;Rain&quot;, &quot;Sunny&quot;, &quot;Overcast&quot;, &quot;Overcast&quot;, &quot;Rain&quot;,                &quot;Rain&quot;, &quot;Rain&quot;, &quot;Sunny&quot;, &quot;Sunny&quot;, &quot;Overcaste&quot;]compressed = lzhw.LZHW(sample_data)## let's see how the compressed object looks like:print(compressed.compressed)# (506460, 128794, 112504)## its sizeprint(compressed.size())# 72## size of originalfrom sys import getsizeofprint(getsizeof(sample_data))# 216print(compressed.space_saving())# space saving from original to compressed is 67%## Let's decompress and check whether there is any information lossdecomp = compressed.decompress()print(decomp == sample_data)# True```As we saw, the LZHW class has saved 67% of the space used to store the original list without any loss. This percentage can get better with bigger data that may have repeated sequences.The class has also some useful helper methods as **space_saving**, **size**, and **decompress()** to revert back to original.Another example with numeric data.```pythonfrom random import sample, choicesnumbers = choices(sample(range(0, 5), 5), k = 20)comp_num = lzhw.LZHW(numbers)print(getsizeof(numbers) &gt; comp_num.size())# Trueprint(numbers == list(map(int, comp_num.decompress()))) ## make it int again# Trueprint(comp_num.space_saving())# space saving from original to compressed is 73%```Let's look at how the compressed object is stored and how it looks like when printed:LZHW class has an attribute called **compressed** which is a tuple of integers representing the encoded triplets.```pythonprint(comp_num.compressed) # how the compressed is saved (as tuple of 3 integers)# (8198555, 620206, 3059308)```We can also write the compressed data to files using **save_to_file** method, and read it back and decompress it using **decompress_from_file** function.```pythonstatus = [&quot;Good&quot;, &quot;Bad&quot;, &quot;Bad&quot;, &quot;Bad&quot;, &quot;Good&quot;, &quot;Good&quot;, &quot;Average&quot;, &quot;Average&quot;, &quot;Good&quot;,          &quot;Average&quot;, &quot;Average&quot;, &quot;Bad&quot;, &quot;Average&quot;, &quot;Good&quot;, &quot;Bad&quot;, &quot;Bad&quot;, &quot;Good&quot;]comp_status = lzhw.LZHW(status)comp_status.save_to_file(&quot;status.txt&quot;)decomp_status = lzhw.decompress_from_file(&quot;status.txt&quot;)print(status == decomp_status)# True```## Compressing DataFrames (in Parallel)lzhw doesn't work only on lists, it also compress pandas dataframes and save it into compressed files to decompress them later.```pythonimport pandas as pddf = pd.DataFrame({&quot;a&quot;: [1, 1, 2, 2, 1, 3, 4, 4],                   &quot;b&quot;: [&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;D&quot;, &quot;D&quot;]})comp_df = lzhw.CompressedDF(df)# 100%|██████████████████████████████████████████████████████████████████████████████████| 2/2 [00:00&lt;00:00, 2003.97it/s]```Let's check space saved by compression```pythoncomp_space = 0for i in range(len(comp_df.compressed)):comp_space += comp_df.compressed[i].size()print(comp_space, getsizeof(df))# 296 712## Test information lossprint(list(map(int, comp_df.compressed[0].decompress())) == list(df.a))# True```#### Saving and Loading Compressed DataFramesWith lzhw we can save a data frame into a compressed file and then read it again using **save_to_file** method and **decompress_df_from_file** function.```python## Save to filecomp_df.save_to_file(&quot;comp_df.txt&quot;)## Load the fileoriginal = lzhw.decompress_df_from_file(&quot;comp_df.txt&quot;)# 100%|██████████████████████████████████████████████████████████████████████████████████| 2/2 [00:00&lt;00:00, 2004.93it/s]print(original)#   a  b#0  1  A#1  1  A#2  2  B#3  2  B#4  1  A#5  3  C#6  4  D#7  4  D```#### Compressing Bigger DataFramesLet's try to compress a real-world dataframe **german_credit.xlsx** file from [UCI Machine Learning Repository](https://archive.ics.uci.edu/ml/datasets/statlog+(german+credit+data)) [1].Original txt file is **219 KB** on desk.Let's have a look at how to use parallelism in this example:```pythongc_original = pd.read_excel(&quot;examples/german_credit.xlsx&quot;)comp_gc = lzhw.CompressedDF(gc_original, parallel = True, n_jobs = 2) # two CPUs# 100%|█████████████████████████████████████████████████████████████████████████████████| 62/62 [00:00&lt;00:00, 257.95it/s]## Compare sizes in Python:comp_space = 0for i in range(len(comp_gc.compressed)):comp_space += comp_gc.compressed[i].size()print(comp_space, getsizeof(gc_original))# 4488 548852print(list(map(int, comp_gc.compressed[0].decompress())) == list(gc_original.iloc[:, 0]))# True```**Huge space saving, 99%, with no information loss!**Let's now write the compressed dataframe into a file and compare the sizes of the files.```pythoncomp_gc.save_to_file(&quot;gc_compressed.txt&quot;)``` Checking the size of the compressed file, it is **44 KB**. Meaning that in total we saved around **79%**.Future versions will be optimized to save more space.Let's now check when we reload the file, will we lose any information or not.```python## Load the filegc_original2 = lzhw.decompress_df_from_file(&quot;gc_compressed.txt&quot;)# 100%|█████████████████████████████████████████████████████████████████████████████████| 62/62 [00:00&lt;00:00, 259.46it/s]print(list(map(int, gc_original2.iloc[:, 13])) == list(gc_original.iloc[:, 13]))# Trueprint(gc_original.shape == gc_original2.shape)# True```**Perfect! There is no information loss at all.**## More FunctionalitiesWith **lzhw** also you can choose what columns you are interested in compressing from a data frame.**CompressedDF** class has an argument **selected_cols**. And how many rows you want to decompress with **n_rows** argument.**You can also determine **sliding_window** argument to control more compression speed or compressing to a smaller size.**Default value is 256, meaning that the algorithm will search in previous 256 values for similar sequences. Increasing this number can give smaller compressed size but can slow down a little bit the algorithm but not so much as **lz77_compress is able to scale up reasonably.**Also one can compress large csv files in chunks while reading them in chunks without opening the whole file in memory using **CompressedFromCSV** class which reads a file in chunks using *pandas chunksize* and compress each chunk separately.**Please see [documentation](https://mnoorfawi.github.io/lzhw/) for deeper look**## LZHW Comparison with joblib algorithmsI love [joblib](https://joblib.readthedocs.io/en/latest/index.html). I usually use it for **parallelism** for its great performance coming with a smooth simplicity.I once saw this [article](https://joblib.readthedocs.io/en/latest/auto_examples/compressors_comparison.html#sphx-glr-auto-examples-compressors-comparison-py) in its documentation and it is about measuring the performance between different compressors available in it.Because I am developing a compression library, I wanted to extend the code available in this article adding **lzhw** to the comparison, just to know where my library stands.joblib uses three main techniques in this article **Zlib, LZMA and LZ4**.I will use [1500000 Sales Records Data](http://eforexcel.com/wp/wp-content/uploads/2017/07/1500000%20Sales%20Records.zip).**We will look at Compression and Decompression Duration and The compressed file sizes.***The downloaded compressed file is 53MB on the websites*I will reproduce the code in joblib documentation```pythondata = pd.read_csv(&quot;1500000 Sales Records.csv&quot;)print(data.shape)pickle_file = './pickle_data.joblib'start = time.time()with open(pickle_file, 'wb') as f:    dump(data, f)raw_dump_duration = time.time() - startprint(&quot;Raw dump duration: %0.3fs&quot; % raw_dump_duration)raw_file_size = os.stat(pickle_file).st_size / 1e6print(&quot;Raw dump file size: %0.3fMB&quot; % raw_file_size)start = time.time()with open(pickle_file, 'rb') as f:    load(f)raw_load_duration = time.time() - startprint(&quot;Raw load duration: %0.3fs&quot; % raw_load_duration)## ZLIBstart = time.time()with open(pickle_file, 'wb') as f:    dump(data, f, compress='zlib')zlib_dump_duration = time.time() - startprint(&quot;Zlib dump duration: %0.3fs&quot; % zlib_dump_duration)zlib_file_size = os.stat(pickle_file).st_size / 1e6print(&quot;Zlib file size: %0.3fMB&quot; % zlib_file_size)start = time.time()with open(pickle_file, 'rb') as f:    load(f)zlib_load_duration = time.time() - startprint(&quot;Zlib load duration: %0.3fs&quot; % zlib_load_duration)## LZMAstart = time.time()with open(pickle_file, 'wb') as f:    dump(data, f, compress=('lzma', 3))lzma_dump_duration = time.time() - startprint(&quot;LZMA dump duration: %0.3fs&quot; % lzma_dump_duration)lzma_file_size = os.stat(pickle_file).st_size / 1e6print(&quot;LZMA file size: %0.3fMB&quot; % lzma_file_size)start = time.time()with open(pickle_file, 'rb') as f:    load(f)lzma_load_duration = time.time() - startprint(&quot;LZMA load duration: %0.3fs&quot; % lzma_load_duration)## LZ4start = time.time()with open(pickle_file, 'wb') as f:    dump(data, f, compress='lz4')lz4_dump_duration = time.time() - startprint(&quot;LZ4 dump duration: %0.3fs&quot; % lz4_dump_duration)lz4_file_size = os.stat(pickle_file).st_size / 1e6print(&quot;LZ4 file size: %0.3fMB&quot; % lz4_file_size)start = time.time()with open(pickle_file, 'rb') as f:    load(f)lz4_load_duration = time.time() - startprint(&quot;LZ4 load duration: %0.3fs&quot; % lz4_load_duration)## LZHWstart = time.time()lzhw_data = lzhw.CompressedDF(data)lzhw_data.save_to_file(&quot;lzhw_data.txt&quot;)lzhw_compression_duration = time.time() - startprint(&quot;LZHW compression duration: %0.3fs&quot; % lzhw_compression_duration)lzhw_file_size = os.stat(&quot;lzhw_data.txt&quot;).st_size / 1e6print(&quot;LZHW file size: %0.3fMB&quot; % lzhw_file_size)start = time.time()lzhw_d = lzhw.decompress_df_from_file(&quot;lzhw_data.txt&quot;, parallel = True, n_jobs = -3)  # decompression is slower than compressionlzhw_d_duration = time.time() - startprint(&quot;LZHW decompression duration: %0.3fs&quot; % lzhw_d_duration)# (1500000, 14)# Raw dump duration: 1.294s# Raw dump file size: 267.591MB# Raw load duration: 1.413s# Zlib dump duration: 6.583s# Zlib file size: 96.229MB# Zlib load duration: 2.430s# LZMA dump duration: 76.526s# LZMA file size: 72.476MB# LZMA load duration: 9.240s# LZ4 dump duration: 1.984s# LZ4 file size: 152.374MB# LZ4 load duration: 2.135s# LZHW compression duration: 53.958s# LZHW file size: 41.816MB# LZHW decompression duration: 56.687s```Now let's visualize the new results:```pythonimport numpy as npimport matplotlib.pyplot as pltN = 5load_durations = (raw_load_duration, zlib_load_duration,                  lzma_load_duration, lz4_load_duration, lzhw_d_duration)dump_durations = (raw_dump_duration, zlib_dump_duration,                  lzma_dump_duration, lz4_dump_duration, lzhw_compression_duration)file_sizes = (raw_file_size, zlib_file_size, lzma_file_size, lz4_file_size, lzhw_file_size)ind = np.arange(N)width = 0.5plt.figure(1, figsize=(5, 4))p1 = plt.bar(ind, dump_durations, width)p2 = plt.bar(ind, load_durations, width, bottom=dump_durations)plt.ylabel('Time in seconds')plt.title('Compression &amp; Decompression durations\nof different algorithms')plt.xticks(ind, ('Raw', 'Zlib', 'LZMA', &quot;LZ4&quot;, &quot;LZHW&quot;))plt.legend((p1[0], p2[0]), ('Compression duration', 'Decompression duration'))```![](./img/lzhw_duration2.jpg)```pythonplt.figure(2, figsize=(5, 4))plt.bar(ind, file_sizes, width, log=True)plt.ylabel('File size in MB')plt.xticks(ind, ('Raw', 'Zlib', 'LZMA', &quot;LZ4&quot;, &quot;LZHW&quot;))plt.title('Compressed data size\nof different algorithms')for index, value in enumerate(file_sizes):    plt.text(index, value, str(round(value)) + &quot;MB&quot;)```![](./img/lzhw_size2.jpg)**By far LZHW outperforms others with acceptable time difference**, especially with all other functionalities it enables to deal with compressed data.##### Reference [1] Dua, D. and Graff, C. (2019). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School of Information and Computer Science.</longdescription>
</pkgmetadata>