<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;!-- PROJECT BADGES --&gt;[![Python Version][python-shield]][python-url][![MIT License][license-shield]][license-url][![Coverage][coverage-shield]][coverage-url]&lt;!-- What is PRegEx? --&gt;## What is PRegEx?Let's face it, although RegEx is without a doubt an extremely useful tool, its syntax has been repeatedly proven to be quite hard for people to read and to memorize. This is mainly due to RegEx's declarative nature, which many programmers are not familiar with, as well as its extensive use of symbols that do not inherently relate to their functionality within a RegEx pattern, thus rendering them easy to forget. To make matters even worse, RegEx patterns are more often than not tightly packed with large amounts of information, which our brains just seem to be struggling to break down in order to analyze effectively. For these reasons, building even a simple RegEx pattern for matching URLs can prove to be quite a painful task.This is where PRegEx comes in! PRegEx, which stands for Programmable Regular Expressions, is a Python package that can be used in order to construct Regular Expression patterns in a more human-friendly way. Through the use of PRegEx, one is able to fully utilize the powerful tool that is RegEx without having to deal with any of its nuisances that seem to drive people crazy! PRegEx achieves that by offering the following:1. An easy-to-remember syntax that resembles the good ol' imperative way of programming!2. No longer having to group patterns or escape meta characters, as both are handled internally by PRegEx!3. Modularity to building RegEx patterns, as one can easily break down a complex pattern into multiple simpler ones which can then be combined together.4. A higher-level API on top of Python's built-in &quot;re&quot; module, providing access to its core functionality and more, while saving you the trouble of having to deal with &quot;re.Match&quot; instances.And remember, no matter how complex the abstraction, it's always just a pure RegEx pattern that sits underneath which you can fetch and use any way you like!&lt;!-- Installation --&gt;## InstallationYou can start using PRegEx by installing it via pip. Note that &quot;pregex&quot; requires Python &gt;= 3.9.```shpip install pregex```&lt;!-- Usage example --&gt;## Usage ExampleIn PRegEx, everything is a Programmable Regular Expression, or &quot;Pregex&quot; for short. This makes it easy for simple Pregex instances to be combined into more complex ones! Within the code snippet below, we construct a Pregex instance that will match any URL that ends with either &quot;.com&quot; or &quot;.org&quot; as well as any IP address for which a 4-digit port number is specified. Furthermore, in the case of a URL, we would like for its domain name to be separately captured as well.```pythonfrom pregex.core.classes import AnyLetter, AnyDigit, AnyFromfrom pregex.core.quantifiers import Optional, AtLeastAtMostfrom pregex.core.operators import Eitherfrom pregex.core.groups import Capturefrom pregex.core.pre import Pregex# Define main sub-patterns.http_protocol = Optional('http' + Optional('s') + '://')www = Optional('www.')alphanum = AnyLetter() | AnyDigit()domain_name = \    alphanum + \    AtLeastAtMost(alphanum | AnyFrom('-', '.'), n=1, m=61) + \    alphanumtld = '.' + Either('com', 'org')ip_octet = AnyDigit().at_least_at_most(n=1, m=3)port_number = (AnyDigit() - '0') + 3 * AnyDigit()# Combine sub-patterns together.pre: Pregex = \    http_protocol + \    Either(        www + Capture(domain_name) + tld,        3 * (ip_octet + '.') + ip_octet + ':' + port_number    )```We can then easily fetch the resulting Pregex instance's underlying RegEx pattern.```pythonregex = pre.get_pattern()```This is the pattern that we just built. Yikes!```(?:https?:\/\/)?(?:(?:www\.)?([A-Za-z\d][A-Za-z\d\-.]{1,61}[A-Za-z\d])\.(?:com|org)|(?:\d{1,3}\.){3}\d{1,3}:[1-9]\d{3})```Besides from having access to its underlying pattern, we can use a Pregex instance to find matches within a piece of text. Consider for example the following string:```pythontext = &quot;text--192.168.1.1:8000--text--http://www.wikipedia.org--text--https://youtube.com--text&quot;```By invoking the instance's &quot;get_matches&quot; method, we are able to scan the above string for any possible matches:```pythonmatches = pre.get_matches(text)```Looks like there were three matches:```python['192.168.1.1:8000', 'http://www.wikipedia.org', 'https://youtube.com']```Likewise, we can invoke the instance's &quot;get_captures&quot; method to get any captured groups.```pythongroups = pre.get_captures(text)```As expected, there were only two captured groups since the first match is not a URL and therefore it does not contain a domain name to be captured.```python[(None,), ('wikipedia',), ('youtube',)]```Finally, you might have noticed that we built our pattern by utilizingvarious classes that were imported from modules under *pregex.core*. Thesemodules contain classes through which the RegEx syntax is essentially replaced.However, PRegEx also includes another set of modules, namely those undersubpackage *pregex.meta*, whose classes build upon those in *pregex.core* soas to provide numerous pre-built patterns that you can just import and useright away!```pythonfrom pregex.core.pre import Pregexfrom pregex.core.classes import AnyDigitfrom pregex.core.operators import Eitherfrom pregex.meta.essentials import HttpUrl, IPv4port_number = (AnyDigit() - '0') + 3 * AnyDigit()pre: Pregex = Either(    HttpUrl(capture_domain=True, is_extensible=True),    IPv4(is_extensible=True) + ':' + port_number)```By using classes found within the *pregex.meta* subpackage, we were able toconstruct more or less the same pattern as before only much more easily!## Solving Wordle with PRegExWe are now going to see another example that better exhibits the *programmable* nature of PRegEx.More specifically, we will be creating a Wordle solver function that, given all currently knowninformation as well as access to a 5-letter word dictionary, utilizes PRegEx in order to returna list of candidate words to choose from as a possible solution to the problem.### Formulating what is knownFirst things first, we must think of a way to represent what is known so far regarding theword that we're trying to guess. This information can be encapsulated into three distinctsets of letters:1. **Green letters**: Letters that are included in the word, whose position within it is known.2. **Yellow letters**: Letters that are included in the word, and while their exact position is   unknown, there is one or more positions which we can rule out. 3. **Gray letters**: Letters that are not included in the word.Green letters can be represented by using a dictionary that maps integers (positions) to strings (letters).For example, ``{4 : 'T'}`` indicates that the word we are looking for contains the letter ``T`` in itsfourth position. Yellow letters can also be represented as a dictionary with integer keys, whose valueshowever are going to be lists of strings instead of regular strings, as a position might have been ruledout for more than a single letter. For example, ``{1 : ['A', 'R'], 3 : ['P']}`` indicates that even thoughthe word contains letters ``A``, ``R`` and ``P``, it cannot start with either an ``A`` or an ``R`` aswell as it cannot have the letter ``P`` occupying its third position. Finally, gray letters can be simplystored in a list.In order to have a concrete example to work with, we will be assuming that our currentinformation about the problem is expressed by the following three data structures:```pythongreen: dict[int, str] = {4 : 'T'}yellow: dict[int, list[str]] = {1 : ['A', 'R'], 3 : ['P']}gray: list[str] = ['C', 'D', 'L', 'M', 'N', 'Q', 'U']```### Initializing a Pregex class instanceHaving come up with a way of programmatically formulating the problem, the first step towardsactually solving it would be to create a ``Pregex`` class instance:```pythonwordle = Pregex()```Since we aren't providing a ``pattern`` parameter to the class's constructor, it automaticallydefaults to the empty string ``''``. Thus, through this instance we now have access to all methodsof the ``Pregex`` class, though we are not really able to match anything with it yet.### Yellow letter assertionsBefore we go on to dictate what the valid letters for each position within the wordare, we are first going to deal with yellow letters, that is, letters which we know areincluded in the word that we are looking for, though their position is still uncertain.Since we know for a fact that the sought out word contains these letters, we have tosomehow make sure that any candidate word includes them as well. This can easily bedone by using what is known in RegEx lingo as a *positive lookahead assertion*,represented in PRegEx by the less intimidating *FollowedBy*! Assertions are used inorder to *assert* something about a pattern without really having to *match* any additionalcharacters. A positive lookahead assertion, in particular, dictates that the pattern to whichit is applied must be followed by some other pattern in order for the former to constitutea valid match.In PRegEx, one is able to create a ``Pregex`` instance out of applying a positivelookahead assertion to some pattern ``p1`` by doing the following:```pythonfrom pregex.core.assertions import FollowedBypre = FollowedBy(p1, p2)```where both ``p1`` and ``p2`` are either strings or ``Pregex`` instances. Futhermore, in thecase that ``p1`` already is a ``Pregex`` class instance, one can achieve the same result with:```pythonpre = p1.followed_by(p2)```Having initialized ``wordle`` as a ``Pregex`` instance, we can simply simply do``wordle.followed_by(some_pattern)`` so as to indicate that any potential matchwith ``wordle`` must be followed by ``some_pattern``. Recall that ``wordle`` merelyrepresents the empty string, so we are not really matching anything at this point.Applying an assertion to the empty string pattern is just a neat little trick onecan use in order to validate something about their pattern before they even beginto build it.Now it's just a matter of figuring out what the value of ``some_pattern`` is.Surely we can't just do ``wordle = wordle.followed_by(letter)``, as this resultsin ``letter`` always having to be at the beginning of the word. Here's however whatwe can do: It follows from the rules of Wordle that all words must be comprised of fiveletters, any of which is potentially a yellow letter. Thus, every yellow letter is certainto be preceded by up to four other letters, but no more than that. Therefore, we need apattern that represents just that, namely *four letters at most*. By applying quantifier``at_most(n=4)`` to an instance of ``AnyUppercaseLetter()``, we are able to create sucha pattern. Add a yellow letter to its right and we have our ``some_pattern``. Since theremay be more than one yellow letters, we make sure that we iterate them all one by one soas to enforce a separate assertion for each:```pythonfrom pregex.core.classes import AnyUppercaseLetteryellow_letters_list: list[str] = [l for letter_list in yellow.values() for l in letter_list]at_most_four_letters = AnyUppercaseLetter().at_most(n=4)for letter in yellow_letters_list:    wordle = wordle.followed_by(at_most_four_letters + letter)```By executing the above code snippet we get a ``Pregex`` instance whichrepresents the following RegEx pattern:```(?=[A-Z]{,4}A)(?=[A-Z]{,4}R)(?=[A-Z]{,4}P)```### Building valid character classesAfter we have made sure that our pattern will reject any words that do not containall the yellow letters, we can finally start building the part of the pattern thatwill handle the actual matching. This can easily be achived by performing fiveiterations, one for each letter of the word, where at each iteration ``i`` weconstruct a new character class, which is then appended to our pattern basedon the following logic:* If the letter that corresponds to the word's i-th position is known, then  make it so that the pattern only matches that letter at that position.* If the letter that corresponds to the word's i-th position is not known,  then make it so that the pattern matches any letter except for gray letters,  green letters, as well as any yellow letters that may have been ruled out for  that exact position.The following code snippet does just that:```pythonfrom pregex.core.classes import AnyFromfor i in range(1, 6):    if i in green:        wordle += green[i]    else:        invalid_chars_at_pos_i = gray + list(green.values())        if i in yellow:            invalid_chars_at_pos_i += yellow[i]        wordle += AnyUppercaseLetter() - AnyFrom(*invalid_chars_at_pos_i)```After executing the above code, ``wordle`` will contain the followingRegEx pattern:```(?=[A-Z]{,4}A)(?=[A-Z]{,4}R)(?=[A-Z]{,4}P)[BE-KOPSV-Z][ABE-KOPRSV-Z][ABE-KORSV-Z]T[ABE-KOPRSV-Z]```### Matching from a dictionaryHaving built our pattern, the only thing left to do is to actually use it tomatch candidate words. Provided that we have access to a text file containingall possible Wordle words, we are able to invoke our ``Pregex`` instance's``get_matches`` method in order to scan said text file for any potential matches. ```pythonwords = wordle.get_matches('word_dictionary.txt', is_path=True)```### Putting it all togetherFinally, we combine together everything we discussed into a single function thatspews out a list of words which satisfy all necessary conditions so that theyconstitute possible solutions to the problem.```pythondef wordle_solver(green: dict[int, str], yellow: dict[int, list[str]], gray: list[str]) -&gt; list[str]:    from pregex.core.pre import Pregex    from pregex.core.classes import AnyUpperCaseLetter, AnyFrom    # Initialize pattern as the empty string pattern.    wordle = Pregex()    # This part ensures that yellow letters    # will appear at least once within the word.    yellow_letters_list = [l for letter_list in yellow.values() for l in letter_list]    at_most_four_letters = AnyUppercaseLetter().at_most(n=4)    for letter in yellow_letters_list:        wordle = wordle.followed_by(at_most_four_letters + letter)    # This part actually dictates the set of valid letters    # for each position within the word.    for i in range(1, 6):        if i in green:            wordle += green[i]        else:            invalid_chars_at_pos_i = gray + list(green.values())            if i in yellow:                invalid_chars_at_pos_i += yellow[i]            wordle += AnyUppercaseLetter() - AnyFrom(*invalid_chars_at_pos_i)    # Match candidate words from dictionary and return them in a list.    return wordle.get_matches('word_dictionary.txt', is_path=True)```By invoking the above function we get the following list of words:```pythonword_candidates = wordle_solver(green, yellow, gray)print(word_candidates) # This prints ['PARTY']```Looks like there is only one candidate word, which means that wecan consider our problem solved!You can learn more about PRegEx by visiting the [PRegEx Documentation Page][docs-url].&lt;!-- MARKDOWN LINKS &amp; IMAGES --&gt;[python-shield]: https://img.shields.io/badge/python-3.9+-blue[python-url]: https://www.python.org/downloads/release/python-390/[license-shield]: https://img.shields.io/badge/license-MIT-red[license-url]: https://github.com/manoss96/pregex/blob/main/LICENSE.txt[coverage-shield]: https://coveralls.io/repos/github/manoss96/pregex/badge.svg?branch=main&amp;service=github[coverage-url]: https://coveralls.io/github/manoss96/pregex?branch=main[docs-url]: https://pregex.readthedocs.io/en/latest/</longdescription>
</pkgmetadata>