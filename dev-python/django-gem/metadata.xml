<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Django GemDjango-gem is a reusable Django package that allows user to offload on-the-fly calculationsfor Django models by putting them into database and providing and easy to use architecture to define,how and when those database fields need to be refreshed.### Installation---Using `pip`&lt;pre&gt;pip install django-gem&lt;/pre&gt;Using `poetry`&lt;pre&gt;poetry add django-gem&lt;/pre&gt;---Then add 'django_gem' to your INSTALLED_APPS.&lt;pre&gt;INSTALLED_APPS = [    ...    'django_gem',]&lt;/pre&gt;---UsageFirst you will need to create a class that knows how to re-calculate your database fields.In this package those classes are called &quot;Cutters&quot;.Each of the methods on the cutter need to be defined as `property`,and the names of those methods should mirror re-calculated fields on the Gem model in the format of `cut_&lt;field_name&gt;`.Side effects on the properties define what related models should trigger recalculations on those fields.```pythonfrom django_gems_example.gems.callbacks.author import AuthorCutterCallbacksfrom django_gems_example.models import Author, Bookfrom django_gem.cutters.base import BaseCutterfrom django_gem.decorators.cutters import side_effectsclass AuthorCutter(BaseCutter):    instance: Author    @property    @side_effects(        (Author, [], AuthorCutterCallbacks.author),        (Book, [&quot;author&quot;], AuthorCutterCallbacks.book_author),    )    def cut_book_count(self):        return self.instance.books.count()```Django-gem allows you to create a &quot;satellite&quot; model for you main one,and define the `CutterEngineMeta` with the created `cutter`.```pythonfrom django.db import modelsfrom django_gems_example.gems.cutters.author import AuthorCutterfrom django_gems_example.models import Authorfrom django_gem.models.base import CutterEngineBaseModel, CutterEngineMetaBaseclass AuthorGem(CutterEngineBaseModel):    book_count = models.IntegerField(default=0)    class CutterEngineMeta(CutterEngineMetaBase):        model = Author        cutter = AuthorCutter```To access these fields from the main model, you need to define a property on the model with the same name asthe Gem field name, and wrap it with a `gem_property` decorator.```pythonfrom django.db import modelsfrom django_gem.decorators import gem_propertyclass Author(models.Model):    name = models.CharField(max_length=100)    @gem_property    def book_count(self):        return self.gem.book_count```---All the calculations happen implicitly, as `cutter_registry` that is populated on Django app startuploads all the related models and attaches hooks for calculation. But, if needed, there are methods that you caninvoke directly from the `Saw` class. It allows refreshing a model, a queryset or an entire content type.</longdescription>
</pkgmetadata>