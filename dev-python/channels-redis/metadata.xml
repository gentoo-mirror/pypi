<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>channels_redis==============.. image:: https://github.com/django/channels_redis/workflows/Tests/badge.svg    :target: https://github.com/django/channels_redis/actions?query=workflow%3ATests.. image:: https://img.shields.io/pypi/v/channels_redis.svg    :target: https://pypi.python.org/pypi/channels_redisProvides Django Channels channel layers that use Redis as a backing store.There are two available implementations:* ``RedisChannelLayer`` is the original layer, and implements channel and group  handling itself.* ``RedisPubSubChannelLayer`` is newer and leverages Redis Pub/Sub for message  dispatch. This layer is currently at *Beta* status, meaning it may be subject  to breaking changes whilst it matures.Both layers support a single-server and sharded configurations.Installation------------.. code-block::    pip install channels-redis**Note:** Prior versions of this package were called ``asgi_redis`` and arestill available under PyPI as that name if you need them for Channels 1.x projects.This package is for Channels 2 projects only.Usage-----Set up the channel layer in your Django settings file like so:.. code-block:: python    CHANNEL_LAYERS = {        &quot;default&quot;: {            &quot;BACKEND&quot;: &quot;channels_redis.core.RedisChannelLayer&quot;,            &quot;CONFIG&quot;: {                &quot;hosts&quot;: [(&quot;localhost&quot;, 6379)],            },        },    }Or, you can use the alternate implementation which uses Redis Pub/Sub:.. code-block:: python    CHANNEL_LAYERS = {        &quot;default&quot;: {            &quot;BACKEND&quot;: &quot;channels_redis.pubsub.RedisPubSubChannelLayer&quot;,            &quot;CONFIG&quot;: {                &quot;hosts&quot;: [(&quot;localhost&quot;, 6379)],            },        },    }Possible options for ``CONFIG`` are listed below.``hosts``~~~~~~~~~The server(s) to connect to, as either URIs, ``(host, port)`` tuples, or dicts conforming to `redis Connection &lt;https://redis-py.readthedocs.io/en/v4.3.3/connections.html#redis.connection.Connection&gt;`_.Defaults to ``redis://localhost:6379``. Pass multiple hosts to enable sharding,but note that changing the host list will lose some sharded data.Sentinel connections require dicts conforming to:.. code-block::    {        &quot;sentinels&quot;: [            (&quot;localhost&quot;, 26379),        ],        &quot;master_name&quot;: SENTINEL_MASTER_SET,        **kwargs    }note the additional ``master_name`` key specifying the Sentinel master set and any additional connection kwargs can also be passed. Plain Redis and Sentinel connections can be mixed and matched ifsharding.If your server is listening on a UNIX domain socket, you can also use that to connect: ``[&quot;unix:///path/to/redis.sock&quot;]``.This should be slightly faster than a loopback TCP connection.``prefix``~~~~~~~~~~Prefix to add to all Redis keys. Defaults to ``asgi``. If you're runningtwo or more entirely separate channel layers through the same Redis instance,make sure they have different prefixes. All servers talking to the same layershould have the same prefix, though.``expiry``~~~~~~~~~~Message expiry in seconds. Defaults to ``60``. You generally shouldn't needto change this, but you may want to turn it down if you have peaky traffic youwish to drop, or up if you have peaky traffic you want to backlog until youget to it.``group_expiry``~~~~~~~~~~~~~~~~Group expiry in seconds. Defaults to ``86400``. Channels will be removedfrom the group after this amount of time; it's recommended you reduce itfor a healthier system that encourages disconnections. This value shouldnot be lower than the relevant timeouts in the interface server (e.g.the ``--websocket_timeout`` to `daphne&lt;https://github.com/django/daphne&gt;`_).``capacity``~~~~~~~~~~~~Default channel capacity. Defaults to ``100``. Once a channel is at capacity,it will refuse more messages. How this affects different parts of the systemvaries; a HTTP server will refuse connections, for example, while Djangosending a response will just wait until there's space.``channel_capacity``~~~~~~~~~~~~~~~~~~~~Per-channel capacity configuration. This lets you tweak the channel capacitybased on the channel name, and supports both globbing and regular expressions.It should be a dict mapping channel name pattern to desired capacity; if thedict key is a string, it's intepreted as a glob, while if it's a compiled``re`` object, it's treated as a regular expression.This example sets ``http.request`` to 200, all ``http.response!`` channelsto 10, and all ``websocket.send!`` channels to 20:.. code-block:: python    CHANNEL_LAYERS = {        &quot;default&quot;: {            &quot;BACKEND&quot;: &quot;channels_redis.core.RedisChannelLayer&quot;,            &quot;CONFIG&quot;: {                &quot;hosts&quot;: [(&quot;localhost&quot;, 6379)],                &quot;channel_capacity&quot;: {                    &quot;http.request&quot;: 200,                    &quot;http.response!*&quot;: 10,                    re.compile(r&quot;^websocket.send\!.+&quot;): 20,                },            },        },    }If you want to enforce a matching order, use an ``OrderedDict`` as theargument; channels will then be matched in the order the dict provides them.``symmetric_encryption_keys``~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Pass this to enable the optional symmetric encryption mode of the backend. Touse it, make sure you have the ``cryptography`` package installed, or specifythe ``cryptography`` extra when you install ``channels_redis``::    pip install channels_redis[cryptography]``symmetric_encryption_keys`` should be a list of strings, with each stringbeing an encryption key. The first key is always used for encryption; all areconsidered for decryption, so you can rotate keys without downtime - just adda new key at the start and move the old one down, then remove the old oneafter the message expiry time has passed.Data is encrypted both on the wire and at rest in Redis, though we adviseyou also route your Redis connections over TLS for higher security; the Redisprotocol is still unencrypted, and the channel and group key names couldpotentially contain metadata patterns of use to attackers.Keys **should have at least 32 bytes of entropy** - they are passed throughthe SHA256 hash function before being used as an encryption key. Any stringwill work, but the shorter the string, the easier the encryption is to break.If you're using Django, you may also wish to set this to your site's``SECRET_KEY`` setting via the ``CHANNEL_LAYERS`` setting:.. code-block:: python    CHANNEL_LAYERS = {        &quot;default&quot;: {            &quot;BACKEND&quot;: &quot;channels_redis.core.RedisChannelLayer&quot;,            &quot;CONFIG&quot;: {                &quot;hosts&quot;: [&quot;redis://:password@127.0.0.1:6379/0&quot;],                &quot;symmetric_encryption_keys&quot;: [SECRET_KEY],            },        },    }``on_disconnect`` / ``on_reconnect``~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~The PubSub layer, which maintains long-running connections to Redis, can drop messages in the event of a network partition.To handle such situations the PubSub layer accepts optional arguments which will notify consumers of Redis disconnect/reconnect events.A common use-case is for consumers to ensure that they perform a full state re-sync to ensure that no messages have been missed... code-block:: python    CHANNEL_LAYERS = {        &quot;default&quot;: {            &quot;BACKEND&quot;: &quot;channels_redis.pubsub.RedisPubSubChannelLayer&quot;,            &quot;CONFIG&quot;: {                &quot;hosts&quot;: [...],                &quot;on_disconnect&quot;: &quot;redis.disconnect&quot;,            },        },    }And then in your channels consumer, you can implement the handler:.. code-block:: python    async def redis_disconnect(self, *args):        # Handle disconnectDependencies------------Redis server &gt;= 5.0 is required for `channels_redis`. Python 3.7 or higher is required.Used commands~~~~~~~~~~~~~Your Redis server must support the following commands:* ``RedisChannelLayer`` uses ``BZPOPMIN``, ``DEL``, ``EVAL``, ``EXPIRE``,  ``KEYS``, ``PIPELINE``, ``ZADD``, ``ZCOUNT``, ``ZPOPMIN``, ``ZRANGE``,  ``ZREM``, ``ZREMRANGEBYSCORE``* ``RedisPubSubChannelLayer`` uses ``PUBLISH``, ``SUBSCRIBE``, ``UNSUBSCRIBE``Local Development-----------------You can run the necessary Redis instances in Docker with the following commands:.. code-block:: shell    $ docker network create redis-network    $ docker run --rm \        --network=redis-network \        --name=redis-server \        -p 6379:6379 \        redis    $ docker run --rm \        --network redis-network \        --name redis-sentinel \        -e REDIS_MASTER_HOST=redis-server \        -e REDIS_MASTER_SET=sentinel \        -e REDIS_SENTINEL_QUORUM=1 \        -p 26379:26379 \        bitnami/redis-sentinelContributing------------Please refer to the`main Channels contributing docs &lt;https://github.com/django/channels/blob/master/CONTRIBUTING.rst&gt;`_.That also contains advice on how to set up the development environment and run the tests.Maintenance and Security------------------------To report security issues, please contact security@djangoproject.com. For GPGsignatures and more security process information, seehttps://docs.djangoproject.com/en/dev/internals/security/.To report bugs or request new features, please open a new GitHub issue.This repository is part of the Channels project. For the shepherd and maintenance team, please see the`main Channels readme &lt;https://github.com/django/channels/blob/master/README.rst&gt;`_.</longdescription>
</pkgmetadata>