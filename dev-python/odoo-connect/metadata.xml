<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Odoo ConnectA simple library to use Odoo RPC.[![PyPI version](https://badge.fury.io/py/odoo-connect.svg)](https://pypi.org/project/odoo-connect/)## Usageimport odoo_connectodoo = env = odoo_connect.connect(url='http://localhost', username='admin', password='admin')so = env['sale.order']so.search_read([('create_uid', '=', 1)], [])## Rationale[OdooRPC](https://pypi.org/project/OdooRPC/)or [Odoo RPC Client](https://pypi.org/project/odoo-rpc-client/)are both more complete and mimic internal Odoo API.Then [aio-odoorpc](https://pypi.org/project/aio-odoorpc/) providesan asynchronous API.This library provides only a simple API for connecting to the serverand call methods, so the maintenance should be minimal.Note that each RPC call is executed in a transaction.So the following code on the server, will add one to every line orderedquantity or fail and do nothing.However, ORM client libraries will perform multiple steps, on a failure,already executed code was committed. You can end with race conditionswhere some other code sets product_uom_qty to 0 before you increment it.lines = env['sale.order.line'].search([('order_id.name', '=', 'S00001')])for line in lines:if line.product_uom_qty &gt; 1:line.product_uom_qty += 1A better way of doing something like this is to implement a function on Odooside and call it. `lines.increment_qty([('product_uom_qty', '&gt;', 1)])`.## Export and import dataA separate package provides utilities to more easily extract data from Odoo.It also contains utility to get binary data (attachments) and reports.Since Odoo doesn't accept all kind of values, the *format* package will helpwith converting between user-expected values and values returned by Odoo.The following function will return a table-like (list of lists) structurewith the requested data.You can also pass filter names or export names instead of, respectively,domains and fields. Note that this doesn't support groupping.# Read data as usualenv['sale.order'].search_read_dict([('state', '=', 'sale')], ['name', 'partner_id.name'])env['sale.order'].read_group([], ['amount_untaxed'], ['partner_id', 'create_date:month'])# Export dataimport odoo_connect.data as odoo_dataso = env['sale.order']data = odoo_data.export_data(so, [('state', '=', 'sale')], ['name', 'partner_id.name'])odoo_data.add_url(so, data)# Import data using Odoo's load() functionodoo_data.load_data(so, data)# Import data using writes and creates (or another custom method)for batch in odoo_data.make_batches(data):# add ids by querying the model using the 'name' fieldodoo_data.add_fields(so, batch, 'name', ['id'])# if you just plan to create(), you can skip adding idsodoo_data.load_data(partner, batch, method='write')## Data typesA small module provides functions to translate from JSON values to binaryor date values.## ExploreProvides a simple abstraction for querying data with a local cache.It may be easier than executing and parsing a `read()`.Also, auto-completion for fields is provided in jupyter.from odoo_connect.explore import exploresale_order = explore(env['sale.order'])sale_order = sale_order.search([], limit=1)sale_order.read()## DevelopmentYou can use a vscode container and open this repository inside it.Alternatively, clone and setup the repository manually.git clone $urlcd odoo-connect# Install dev librariespip install -r requirements.txt./pre-commit install# Run some testspytest</longdescription>
</pkgmetadata>