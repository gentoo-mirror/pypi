<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://badge.fury.io/py/htmlement.svg   :target: https://pypi.python.org/pypi/htmlement.. image:: https://readthedocs.org/projects/python-htmlement/badge/?version=stable   :target: http://python-htmlement.readthedocs.io/en/stable/?badge=stable.. image:: https://github.com/willforde/python-htmlement/actions/workflows/tests.yml/badge.svg?branch=master&amp;event=push   :target: https://github.com/willforde/python-htmlement/actions.. image:: https://codecov.io/gh/willforde/python-htmlement/branch/master/graph/badge.svg?token=D5EKKLIVBP   :target: https://codecov.io/gh/willforde/python-htmlement.. image:: https://api.codeclimate.com/v1/badges/7d593426acc83cba5ef7/maintainability   :target: https://codeclimate.com/github/willforde/python-htmlement/maintainability   :alt: MaintainabilityHTMLement---------HTMLement is a pure Python HTML Parser.The object of this project is to be a &quot;pure-python HTML parser&quot; which is also &quot;faster&quot; than &quot;beautifulsoup&quot;.And like &quot;beautifulsoup&quot;, will also parse invalid html.The most simple way to do this is to use ElementTree `XPath expressions`__.Python does support a simple (read limited) XPath engine inside its &quot;ElementTree&quot; module.A benefit of using &quot;ElementTree&quot; is that it can use a &quot;C implementation&quot; whenever available.This &quot;HTML Parser&quot; extends `html.parser.HTMLParser`_ to build a tree of `ElementTree.Element`_ instances.Install-------Run ::    pip install htmlement-or- ::    pip install git+https://github.com/willforde/python-htmlement.gitParsing HTML------------Here I’ll be using a sample &quot;HTML document&quot; that will be &quot;parsed&quot; using &quot;htmlement&quot;: ::    html = &quot;&quot;&quot;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;GitHub&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;        &lt;a href=&quot;https://github.com/marmelo&quot;&gt;GitHub&lt;/a&gt;        &lt;a href=&quot;https://github.com/marmelo/python-htmlparser&quot;&gt;GitHub Project&lt;/a&gt;      &lt;/body&gt;    &lt;/html&gt;    &quot;&quot;&quot;    # Parse the document    import htmlement    root = htmlement.fromstring(html)Root is an ElementTree.Element_ and supports the ElementTree APIwith XPath expressions. With this I'm easily able to get both the title and all anchors in the document. ::    # Get title    title = root.find(&quot;head/title&quot;).text    print(&quot;Parsing: %s&quot; % title)    # Get all anchors    for a in root.iterfind(&quot;.//a&quot;):        print(a.get(&quot;href&quot;))And the output is as follows: ::    Parsing: GitHub    https://github.com/willforde    https://github.com/willforde/python-htmlementParsing HTML with a filter--------------------------Here I’ll be using a slightly more complex &quot;HTML document&quot; that will be &quot;parsed&quot; using &quot;htmlement with a filter&quot; to fetchonly the menu items. This can be very useful when dealing with large &quot;HTML documents&quot; since it can be a lot faster toonly &quot;parse the required section&quot; and to ignore everything else. ::    html = &quot;&quot;&quot;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;Coffee shop&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;        &lt;ul class=&quot;menu&quot;&gt;          &lt;li&gt;Coffee&lt;/li&gt;          &lt;li&gt;Tea&lt;/li&gt;          &lt;li&gt;Milk&lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;extras&quot;&gt;          &lt;li&gt;Sugar&lt;/li&gt;          &lt;li&gt;Cream&lt;/li&gt;        &lt;/ul&gt;      &lt;/body&gt;    &lt;/html&gt;    &quot;&quot;&quot;    # Parse the document    import htmlement    root = htmlement.fromstring(html, &quot;ul&quot;, attrs={&quot;class&quot;: &quot;menu&quot;})In this case I'm not unable to get the title, since all elements outside the filter were ignored.But this allows me to be able to extract all &quot;list_item elements&quot; within the menu list and nothing else. ::    # Get all listitems    for item in root.iterfind(&quot;.//li&quot;):        # Get text from listitem        print(item.text)And the output is as follows: ::    Coffee    Tea    Milk.. _html.parser.HTMLParser: https://docs.python.org/3.6/library/html.parser.html#html.parser.HTMLParser.. _ElementTree.Element: https://docs.python.org/3.6/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element.. _Xpath: https://docs.python.org/3.6/library/xml.etree.elementtree.html#xpath-support__ XPath_</longdescription>
</pkgmetadata>