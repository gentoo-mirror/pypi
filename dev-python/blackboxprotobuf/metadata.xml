<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># BlackBox Protobuf Library### _Note: This is a fork of the library found [here](https://github.com/nccgroup/blackboxprotobuf). This original was written for adding protobuf reading to burp, this version strips out all burp related code and dependencies, and works with python3._## DescriptionBlackbox protobuf library is a Python module for decoding and re-encoding protobufmessages without access to the source protobuf descriptor file. This libraryprovides a simple Python interface to encode/decode messages that can beintegrated into other tools.This library is targeted towards use in DFIR investigations where being able toread the content messages is critical and a protocol buffer definition may not be readilyavailable.## BackgroundProtocol Buffers (protobufs)  are a standard published by Google withaccompanying libraries for binary serialization of data. Protocol buffers aredefined by a `.proto` file known to both the sender and the receiver. The actualbinary message does not contain information such as field names or most typeinformation.For each field, the serialized protocol buffer includes two pieces of metadata,a field number and the wire type. The wire type tells a parser how to parse thelength of the field, so that it can be skipped if it is not known (one protocolbuffer design goal is being able to handle messages with unknown fields). Asingle wire-type generally encompasses multiple protocol buffer types, forexample the length delimited wire-type can be used for string, bytestring,inner message or packed repeated fields. See&lt;https://developers.google.com/protocol-buffers/docs/encoding#structure&gt; forthe breakdown of wire types.The protocol buffer compiler (`protoc`) does support a similar method ofdecoding protocol buffers without the definition with the `--decode_raw`option. However, it does not provide any functionality to re-encode the decodedmessage.## How it worksThe library makes a best effort guess of the type based on the provided wire type (andoccasionally field content) and builds a type definition that can be used tore-encode the data. In general, most fields of interest are likely to be parsedinto a usable form. Users can optionally pass in custom type definitions thatoverride the guessed type. Custom type definitions also allow naming of fields toimprove user friendliness.## Future Work- Allow import and export of type definitions to protobuf definition files.# Usage## Installation    ```pip install blackboxprotobuf```## InterfaceThe main `blackboxprotobuf` module defines five functions, the coreencoding/decoding functions, two convenience functions that encode/decode JSONstrings and a function to validate type definition changes.### Decode Decoding functions takes a protobuf bytestring, and optionallyeither a type definition or a known message name mapped to a type definition(in `blackboxprotobuf.known_messages`). If a type definition isn't provided, anempty message type is assumed and all types are derived from the protobufbinary.The decoder returns a tuple containing a dictionary with the decoded data and adictionary containing the generated type definition. If the input typedefinition does not include types for all fields in the message, the outputtype definitions will include type guesses for those fields.Example use:```pythonimport blackboxprotobufimport base64data = base64.b64decode('KglNb2RpZnkgTWU=')message,typedef = blackboxprotobuf.protobuf_to_json(data)print(message)print(typedef)```### EncodeThe encoding functions takes a Python dictionary containing the data and a typedefinition. Unlike decoding, the type definition is required and will fail ifany fields are not defined. Generally, the type definition should be the outputfrom the decoding function or a modified version thereof.Example use:```pythonimport blackboxprotobufimport base64data = base64.b64decode('KglNb2RpZnkgTWU=')message,typedef = blackboxprotobuf.decode_message(data)message['5'] = 'Modified Me'new_data = bytes(blackboxprotobuf.encode_message(message,typedef))print(data)print(new_data)```### Type definition structureThe type definition object is a Python dictionary representing the typestructure of a message, it includes a type for each field and optionally aname. Each entry in the dictionary represents a field in the message. The keyshould be the field number and the value is a dictionary containing attributes.At the minimum the dictionary should contain the 'type' entry which contains astring identifier for the type. Valid type identifiers can be found in`blackboxprotobuf/lib/types/type_maps.py`.Message fields will also contain one of two entries, 'message_typedef' or'message_type_name'. 'message_typedef' should contain a second type definitionstructure for the inner message. 'message_type_name' should contain the stringidentifier for a message type previously stored in`blackboxprotobuf.known_messages`. If both are specified, the 'message_type_name'will be ignored.## Type BreakdownThe following is a quick breakdown of wire types and default values. See&lt;https://developers.google.com/protocol-buffers/docs/encoding&gt; for more detailedinformation from Google.### Variable Length Integers (varint)The `varint` wire type represents integers with multiple bytes where one bit ofeach is dedicated to indicating if it is the last byte. This can be used torepresent integers (signed/unsigned), boolean values or enums. Integers can beencoded using three variations:- `uint`: Varint encoding with no representation of negative numbers.- `int`: Standard encoding but inefficient for negative numbers (always 10 bytes).- `sint`: Uses ZigZag encoding to efficiently represent negative numbers by  mapping negative numbers into the integer space. For example -1 is converted  to 1, 1 to 2, -2 to 3, and so on. This can result in drastically different  numbers if a type is misinterpreted and either the original or incorrect type  is `sint`.The default is currently `int` with no ZigZag encoding.### Fixed32/64The fixed length wire types have an implicit size based on the wire type. Thesesupport either fixed size integers (signed/unsigned) or fixed size floatingpoint numbers (float/double). The default type for these is the floating pointtype as most integers are more likely to be represented by a varint.### Length DelimitedLength delimited wire types are prefixed with a `varint` indicating the length.This is used for strings, bytestrings, inner messages and packed repeatedfields. Messages can generally be identified by validating if it is a validprotobuf binary. If it is not a message, the default type is a string/bytewhich are relatively interchangeable in Python.Packed repeated fields are arrays of either `varints` or a fixed length wiretype. Non-packed repeated fields use a separate tag (wire type + field number)for each element, allowing them to be easily identified and parsed. However,packed repeated fields only have the initial length delimited wire type tag.The parser is assumed to know the full type already for parsing out theindividual elements. This makes this field type difficult to differentiate froman arbitrary byte string and will require user intervention to identify. Inprotobuf version 2, repeated fields had to be explicitly declared packed in thedefinition. In protobuf version 3, repeated fields are packed by default andare likely to become more common.</longdescription>
</pkgmetadata>