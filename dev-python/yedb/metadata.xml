<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># yedb - rugged embedded and client/server key-value database (Python implementation)&lt;img src=&quot;https://img.shields.io/pypi/v/yedb.svg&quot; /&gt; &lt;img src=&quot;https://img.shields.io/badge/license-Apache%202.0-green&quot; /&gt; &lt;img src=&quot;https://img.shields.io/badge/python-3.6%20%7C%203.7%20%7C%203.8%20%7C%203.9-blue.svg&quot; /&gt;## Why YEDB?- Is it fast?- Fast to read, slow to write- Is it smart?- No- So what is YEDB for?- YEDB is ultra-reliable, thread-safe and very easy to use.- I don't like Python- There are other [implementations](https://yedb.bma.ai)[![Power loss data survivedemo](https://img.youtube.com/vi/i3hSWjrNqLo/0.jpg)](https://www.youtube.com/watch?v=i3hSWjrNqLo)https://www.youtube.com/watch?v=i3hSWjrNqLoYEDB is absolutely reliable rugged key-value database, which can survive in anypower loss, unless the OS file system die. Keys data is saved in the veryreliable way and immediately flushed to disk (this can be disabled to speed        up the engine but is not recommended - why then YEDB is used for).* YEDB database objects are absolutely thread-safe.* YEDB has built-in tools to automatically repair itself if any keys are broken.* If the tools failed to help, YEDB can be easily repaired by a systemadministrator, using standard Linux tools.* YEDB can automatically validate keys with JSON Schema(https://json-schema.org/)* YEDB has a cool CLIPractical usage:* Create a database and start writing continuously* Turn the power switch off* Boot the machine again. The typical result: the latest saved key isn'tsurvived, but the database is still valid and working. In 99% of cases, thelatest key can be automatically restored with built-in repair tools.We created YEDB to use in our embedded products as config registry trees andrugged key-value data storage. We use it a lot and hope you'll like it too.Note: YEDB is good on SSDs and SD cards. As it immediately syncs all the datawritten, it can work on classic HDDs really slowly.## PerformanceModern SSDs give about 200-300 keys/sec written with auto-flush enabled. Thewrite speed can be 10-15 times faster without it, but we would not recommendturning auto-flush off, as it is the key feature of YEDB.Reading speed varies:* for embedded: 30-40k keys/second (70-100k keys/second when cached).* for UNIX/TCP socket: 7-15k keys/second* for HTTP: 700-800 keys/second. Transport via HTTP is mostly slow because YEDB  client uses synchronous &quot;requests&quot; library (while the default server is  async). To get better results, consider tuning the server manually and use  a custom async client.## Quick start```shell# install YEDBpip3 install yedb# to use as embedded or client/server - go on. to use CLI - install additional# required librariespip3 install &quot;yedb[cli]&quot;# create a new database and go interactiveyedb /path/to/my/database# set a keyyedb set key1 value1# get the key valueyedb get key1```## Quick client-server setup```# Install required system packages# Debian/Ubuntu: apt-get install -y --no-install-recommends python3 python3-dev gcc# RedHat/Fedora/CenOS: yum install -y python3 python3-devel gccsudo mkdir /opt/yedbdcd /opt/yedbd &amp;&amp; curl https://raw.githubusercontent.com/alttch/yedb-py/main/setup-server.sh | sudo sh```Use env to specify extra options:* YEDBD\_BIND - override bind to (tcp://host:port, http://host:port or path to  UNIX socket)* YEDBD\_SERVICE - system service name* YEDB\_PS - CLI prompt* PIP\_EXTRA\_OPTIONS - specify pip extra options* PYTHON - override Python path* PIP - override pip path## Embedding```pythonfrom yedb import YEDBwith YEDB('/path/to/db', auto_repair=True) as db:    # do some stuff# ORdb = YEDB('/path/to/db')db.open()try:    # do some stufffinally:    db.close()```## Client/server* If socket transport requested, the built-in in server requires &quot;msgpack&quot;  Python module* If HTTP transport requested, the built-in server requires &quot;aiohttp&quot; Python  module```shell# listen to tcp://localhost:8870 (default), to bind UNIX socket, specify the# full socket path, to use http transport, specify http://host:port to bind topython3 -m yedb.server /path/to/db```### Connect a client* If socket transport requested, the built-in in client requires &quot;msgpack&quot;  Python module* If HTTP transport requested, the built-in client requires &quot;requests&quot; Python  module```pythonfrom yedb import YEDBwith YEDB('tcp://localhost:8870') as db:    # do some stuff, remember to send all parameters as kwargs```YEDB creates thread-local objects. If the software is using permanent threadsor a thread pool, it is recommended to use sessions to correctly drop theseobjects at the end of the statement:```pythonfrom yedb import YEDBwith YEDB('tcp://localhost:8870') as db:    with db.session() as session:        # do some stuff, remember to send all parameters as kwargs        session.key_set(key='key1', value='val1')        print(session.key_get(key='key1'))```### Building own clientYEDB uses JSON RPC (https://www.jsonrpc.org/) as the API protocol. Any method,listed in yedb.server.METHODS can be called. Payloads can be packed either withJSON or with MessagePack.If working via UNIX or TCP socket:* only MessagePack payload encoding is supported* Request/response format: PROTO\_VER + DATA\_FMT + FRAME\_LEN(32-bit  little-endian) + frameWhere PROTO\_VER = protocol version (0x01) and DATA\_FMT = data encoding format(0x02 for MessagePack, which is the only protocol supported by thebuilt-in server).### Working with complicated data structures (embedded only)```pythonfrom yedb import YEDBwith YEDB('/path/to/db') as db:    with db.key_as_dict('path/to/keydict) as key:        key.set('field', 'value')    # If modified, the key is automatically saved at the end of the statement.```## Data formatsThe default engine data format is JSON(https://github.com/python-rapidjson/python-rapidjson is detected and imported automatically if present)Other possible formats and their benefits:* YAML - (requires manually installing &quot;pyyaml&quot; Python module) slow, but keyfiles are more human-readable and editable* msgpack - (requires manually installing &quot;msgpack&quot; Python module). Fast,reliable binary serialization format. If used, keys can hold binary values aswell.* cbor - similar to msgpack (requires manually installing &quot;cbor&quot; Python module)* pickle - native Python pickle binary data serialization format. Is slowerthan msgpack/cbor, but keys can hold Python objects and functions as-is.Databases can be easily converted between formats using &quot;yedb&quot; CLI tool or&quot;convert\_fmt&quot; method, unless format-specific features are used (e.g. if keys        have binary data, they can't be converted to JSON properly).## YEDB Specifications and Data formatsSee https://github.com/alttch/yedb## Schema validationAs all keys are serialized values, they can be automatically schema-validatedwith JSON Schema (https://json-schema.org/).To create the validation schema for the chosen key, or key group, create aspecial key &quot;.schema/path/to&quot;, which has to contain the valid JSON Schema.E.g. the schema, stored in the key &quot;.schema/groups/group1&quot; will be used forvalidating all keys in &quot;groups/group1&quot;, including the group primary key. Andthe schema, stored in &quot;.schema/groups/group1/key1&quot; will be used for validating&quot;groups/group1/key1&quot; only (if key or subgroup schema is present, the parent        schemas are omitted).YEDB also supports a non-standard scheme:```json{ &quot;type&quot; : &quot;code.python&quot; }```which requires the key to have valid Python code, without syntax errors.If schema validation fails on set or structure &quot;with&quot; statement exit, anexception yedb.SchemaValidationError is raised.## Backup/restoreFull backup: simply backup the database directory with any preferred method.Partial/server backup:Use &quot;dump\_keys&quot; / &quot;load\_keys&quot; methods. If dump is created with CLI (requires&quot;msgpack&quot; Python module for that), it has the format:    DUMP\_VER + DUMP\_FMT    KEY_LEN(32-bit little-endian) + KEY    KEY_LEN(32-bit little-endian) + KEY    KEY_LEN(32-bit little-endian) + KEY    KEY_LEN(32-bit little-endian) + KEY    ....    KEY_LEN(32-bit little-endian) + KEY## DebuggingStart client/server with DEBUG=1 env variable:```shellDEBUG=1 yedb /path/to/db```to debug when embedded, enable debug logging```pythonimport yedbyedb.debug = True```After, lower the default logging level.## Module documentationhttps://yedb-py.readthedocs.io/</longdescription>
</pkgmetadata>