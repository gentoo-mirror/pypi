<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Table of Contents* [Scope](#scope)* [Setup](#setup)  * [Versions](#versions)  * [Virtualenv](#virtualenv)  * [Installation](#installation)  * [Tests](#tests)* [APIs](#apis)  * [Labeller](#labeller)  * [Normalizer](#normalizer)  * [Augmenter](#augmenter)  * [Persister](#persister)  * [Zipper](#zipper)## ScopeThe scope of this library is to augment the dataset for an image classification ML system.## Setup### VersionsThe library is compatible with python `3.6` on.### VirtualenvWe suggest to isolate your installation via python virtualenv:```shellpython3 -m venv .imgaug...source .imgaug/bin/activate```### InstallationUpdate `pip` package manager:```shellpip install pip --upgrade...pip install -r requirements.txt```### TestsThe library is covered, by fast, isolated unit and doc testing (the latter to grant reliable documentation):```shellpython -m unittest discover -s imgaug -p '*'```## APIsThe library is composed by different collaborators, each with its specific responsibility.Each class tries to expose a minimal public APIs in the form of `__call__` or `__iter__` methods (when generators are used).  The classes are aimed to work with one image at time, in case you need to transform and augment multiple images, avoid creating multiple instances of the classes, just change the argument of the `__call__` function (but for `Persister`, which need a new instance and/or instance attribute modification).### LabellerThe target label is extracted directly by inspecting the image name and trying to extract meaningful information (customisable).```pythonlbl = Labeller(digits=10)lbl('resources/bag.png')'bag'lbl('resources/109-602-3906-001-c-suit-veletta-albino.jpg')'1096023906'```### NormalizerThe images are normalized by:- resizing them to the specified max size (default to 256 pixels)- optionally applying a squared, transparent/backgound canvas and centering the image on it, thus avoiding any deformation```pythonnorm = Normalizer(size=128, canvas=True)img = norm('resources/bag.png')img.shape(128, 128, 4)```### AugmenterThe number of images is augmented by two orders of magnitude (depending on the cutoff float attribute) by applying different transformations to the original one.  Transformations are applied by using generators, thus saving memory consumption.```pythonaug = Augmenter(cutoff=.5)aug('resources/bag.png')&lt;generator object Augmenter.__call__ at 0x125354480&gt;```### PersisterImages are persisted upon normalization and augmentation, by specifying an action function that accepts the name of the file (original basename suffixed by an index) and a `BytesIO` object containing the image data stream.  The persister supports both a filename path and, optionally, a stream-like object (in case the file is not yet persisted to disk).  The persister supports iteration by yielding the image label and the function return value (typically the saved path), allowing to generate CSV files specific to cloud platforms (i.e. [Google Vision APIs](https://cloud.google.com/vision/automl/docs/prepare)).```pythondef persist(name, stream):    filename = f'temp/{name}'    with open(filename, 'wb') as f:        f.write(stream.getvalue())    return filenamepers = Persister('resources/skirt.jpg', action=perist)for label, filename in pers:    print(label, filename)```### ZipperIn case you need an archive with each normalised augmentations within the recognised label subfolder, you can rely on the `Zipper` interface: it creates a ZIP file on current path, by scanning the specified folder for `PNG` or `JPG` images.```pythonzipper = Zipper('.resources/', normalizer=image.Normalizer(16), augmenter=image.Augmenter(.05))zipper()```</longdescription>
</pkgmetadata>