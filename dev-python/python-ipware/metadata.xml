<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Python IPware (A Python Package)**A python package for server applications to retrieve client's IP address**[![status-image]][status-link][![version-image]][version-link][![coverage-image]][coverage-link]# Overview**Best attempt** to get client's IP address while keeping it **DRY**.# NoticeThere is no perfect `out-of-the-box` solution against fake IP addresses, aka `IP Address Spoofing`.You are encouraged to read the ([Advanced users](README.md#advanced-users)) section of this page anduse `proxy_list` and/or `proxy_count` features to match your needs, especially `if` you areplanning to include `ipware` in any authentication, security or `anti-fraud` related architecture.This is an open source project, with the source code visible to all. Therefore, it may be exploited through unimplemented, or improperly implemented features.Please use ipware `ONLY` as a complement to your `firewall` security measures!# How to install    1. easy_install python-ipware    2. pip install python-ipware    3. git clone http:#github.com/un33k/python-ipware        a. cd python-ipware        b. run python setup.py install    4. wget https:#github.com/un33k/python-ipware/zipball/master        a. unzip the downloaded file        b. cd into python-ipware-* directory        c. run python setup.py install# How to use```python# In a view or a middleware where the `request` object is availableimport ipwareipware = Ipware() # default valuesmeta = request.META # Django (meta = request.META), Flask (meta = request.environ), etcip, trusted_route = ipware.get_client_ip(meta)if ip: # IPv4Address() or IPv6Address() object    # ip object has the following properties    # ip.is_global (is globally routable)    # ip.is_private (is private ip address)    # is_loopback (is loopback address)# trusted_route tells if request came through our proxies (count / trusted)# do something with the ip address (e.g. pass it down through the request)# note: ip address doesn't change often, so better cache it for performance,# try to have distinct session ID for public and anonymous users to cache the ip address```# Advanced users:|        Params ⇩ | ⇩ Description                                                                                                                                                                                                                                                                                                                                                     || --------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- || `proxy_count` ⇨ | : Total number of expected proxies (pattern: `client, proxy1, ..., proxy2`)&lt;br&gt;: if `proxy_count = 0` then `client`&lt;br&gt;: if `proxy_count = 1` then `client, proxy1`&lt;br&gt;: if `proxy_count = 2` then `client, proxy1, proxy2` &lt;br&gt;: if `proxy_count = 3` then `client, proxy1, proxy2 proxy3`                                                                       ||  `proxy_list` ⇨ | : List of trusted proxies (ip header pattern: `client, proxy1, ,..., proxyN`)&lt;br&gt;: if `proxy_list = ['10.1.']` then `client, proxy1`&lt;br&gt;: if `proxy_list = ['10.1', '10.2.3']` then `client, proxy1 proxy2`&lt;br&gt;: if `proxy_list = ['10.1', '10.2.', '10.3.4.4']` then `client, proxy1, proxy2, proxy3` ||    `leftmost` ⇨ | : `leftmost = True` is default for de-facto standard.&lt;br&gt;: `leftmost = False` for rare legacy networks that are configured with the `rightmost` pattern.&lt;br&gt;: It converts `client, proxy1 proxy2` to `proxy2, proxy1, client`                                                                                                                                     ||          Output ⇩ | ⇩ Description                                                                                || ----------------: | :------------------------------------------------------------------------------------------- ||            `ip` ⇨ | : Client IP address object of type IPv4Address() or IPv6Address()                            || `trusted_route` ⇨ | : If proxy `proxy_count` and/or `proxy_list` were provided and matched, `True`, else `False` |### Precedence OrderThe client IP address can be found in one or more request headers attributes. The lookup order is top to bottom and the default attributes are as follow.```python# The default meta precedence order - you can be more specific as per your configuration# It will start looking through the request headers from top to bottom to find the best match# It will return the first qualified global (public) ip address it finds, else# It will return the first qualified private ip address it finds, else# It will return the first qualified loopback up address it finds, else it returns None# Update as per your network topology, reduce the numbers and/or reorder the listrequest_headers_precedence_order = (    &quot;X_FORWARDED_FOR&quot;,  # Load balancers or proxies such as AWS ELB (default client is `left-most` [`&lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;`])    &quot;HTTP_X_FORWARDED_FOR&quot;,  # Similar to X_FORWARDED_TO    &quot;HTTP_CLIENT_IP&quot;,  # Standard headers used by providers such as Amazon EC2, Heroku etc.    &quot;HTTP_X_REAL_IP&quot;,  # Standard headers used by providers such as Amazon EC2, Heroku etc.    &quot;HTTP_X_FORWARDED&quot;,  # Squid and others    &quot;HTTP_X_CLUSTER_CLIENT_IP&quot;,  # Rackspace LB and Riverbed Stingray    &quot;HTTP_FORWARDED_FOR&quot;,  # RFC 7239    &quot;HTTP_FORWARDED&quot;,  # RFC 7239    &quot;HTTP_VIA&quot;,  # Squid and others    &quot;X-CLIENT-IP&quot;,  # Microsoft Azure    &quot;X-REAL-IP&quot;,  # NGINX    &quot;X-CLUSTER-CLIENT-IP&quot;,  # Rackspace Cloud Load Balancers    &quot;X_FORWARDED&quot;,  # Squid    &quot;FORWARDED_FOR&quot;,  # RFC 7239    &quot;CF-CONNECTING-IP&quot;,  # CloudFlare    &quot;TRUE-CLIENT-IP&quot;,  # CloudFlare Enterprise,    &quot;FASTLY-CLIENT-IP&quot;,  # Firebase, Fastly    &quot;FORWARDED&quot;,  # RFC 7239    &quot;CLIENT-IP&quot;,  # Akamai and Cloudflare: True-Client-IP and Fastly: Fastly-Client-IP    &quot;REMOTE_ADDR&quot;,  # Default)```You can customize the order by providing your own list during initialization when calling `IpWare()`.```python# specific meta keyipware = IpWare(precedence=(&quot;X_FORWARDED_FOR&quot;))# multiple meta keysipware = IpWare(precedence=(&quot;X_FORWARDED_FOR&quot;, &quot;HTTP_X_FORWARDED_FOR&quot;))# usage is just to pass in the http request headers# Django (request.META)ip, proxy_verified = ipware.get_client_ip(meta=request.META)# Flask (request.environ)ip, proxy_verified = ipware.get_client_ip(meta=request.environ)# ... etc.```### Trusted ProxiesIf your node server is behind one or more known proxy server(s), you can filter out unwanted requestsby providing a `trusted proxy list`, or a known proxy `count`.You can customize the proxy IP prefixes by providing your own list during initialization when calling `IpWare(proxy_list)`.You can pass your custom list on every call, when calling the proxy-aware api to fetch the ip.```python# In the above scenario, use your load balancer IP address as a way to filter out unwanted requests.ipware = IpWare(proxy_list=[&quot;198.84.193.157&quot;])# If you have multiple proxies, simply add them to the listipware = IpWare(proxy_list=[&quot;198.84.193.157&quot;, &quot;198.84.193.158&quot;])# For proxy servers with fixed sub-domain and dynamic IP, use the following pattern.ipware = IpWare(proxy_list=[&quot;177.139.&quot;, &quot;177.140&quot;])# usage: non-strict mode (X-Forwarded-For: &lt;fake&gt;, &lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;)# The request went through our &lt;proxy1&gt; and &lt;proxy2&gt;, then our server# We choose the &lt;client&gt; ip address to the left our &lt;proxy1&gt; and ignore other ipsip, trusted_route = self.ipware.get_client_ip(meta=request.META)# usage: strict mode (X-Forwarded-For: &lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;)# The request went through our &lt;proxy1&gt; and &lt;proxy2&gt;, then our server# Total ip address are total trusted proxies + client ip# We don't allow far-end proxies, or fake addresses (exact or None)ip, trusted_route = self.ipware.get_client_ip(meta=request.META, strict=True)```In the following `example`, your public load balancer (LB) can be seen as a `trusted` proxy.````Real` Client &lt;public&gt; &lt;-&gt; &lt;public&gt; LB (Server) &lt;private&gt; &lt;-----&gt; &lt;private&gt; Django Server                                                             ^                                                             |`Fake` Client &lt;private&gt; &lt;-&gt; &lt;private&gt; LB (Server) &lt;private&gt; -+```### Proxy CountIf your python server is behind a `known` number of proxies, but you deploy on multiple providers and don't want to track proxy IPs, you still can filter out unwanted requests by providing proxy `count`.You can customize the proxy count by providing your `proxy_count` during initialization when calling `IpWare(proxy_count=2)`.```python# In the above scenario, the total number of proxies can be used as a way to filter out unwanted requests.import ipware# enforce proxy countipware = IpWare(proxy_count=1)# enforce proxy count and trusted proxiesipware = IpWare(proxy_count=1, proxy_list=[&quot;198.84.193.157&quot;])# usage: non-strict mode (X-Forwarded-For: &lt;fake&gt;, &lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;)# total number of ip addresses are greater than the total countip, trusted_route = self.ipware.get_client_ip(meta=request.META)# usage: strict mode (X-Forwarded-For: &lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;)# total number of ip addresses are exactly equal to client ip + proxy_countip, trusted_route = self.ipware.get_client_ip(meta=request.META, strict=True)```In the following `example`, your public load balancer (LB) can be seen as the `only` proxy.````Real` Client &lt;public&gt; &lt;-&gt; &lt;public&gt; LB (Server) &lt;private&gt; &lt;---&gt; &lt;private&gt; Node Server                                                            ^                                                            |                                `Fake` Client  &lt;private&gt; ---+```### Support for Public IP Address (routable on the internet), Private and Loopback```python# We make best attempt to return the first public IP address based on header precedence# Then we fall back on private, followed by loopbackimport ipware# no proxy enforce in this exampleipware = IpWare()ip, _ = self.ipware.get_client_ip(meta=request.META)if ip.is_global:    print('Public IP')else if ip.is_private:    print('Private IP')else if ip.loopback:    print('Loopback IP')```### Support for IPv4, Ipv6, and IP:Port patterns```text- Ports will be automatically stripped off, and the IP addresses will be processed and returned.- IPv4s that are wrapped in IPv6 containers will be also unwrapped, processed and returned```### Originating Request```testPlease note that the [de-facto](https:#developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For) standardfor the originating client IP address is the `leftmost`as per`client, proxy1, proxy2`, and the `rightmost` proxy is the mosttrusted proxy.However, in rare cases your network has a `custom` configuration where the `rightmost` IP address is that of the originating client. If that is the case, then indicate it when creating `IpWare(leftmost=False)`.```# Running the testsTo run the tests against the current environment:    ./test.sh# LicenseReleased under a ([MIT](https:#raw.githubusercontent.com/un33k/python-ipware/main/LICENSE)) license.# VersionX.Y.Z Version    `MAJOR` version -- making incompatible API changes    `MINOR` version -- adding functionality in a backwards-compatible manner    `PATCH` version -- making backwards-compatible bug fixes[status-image]: https://github.com/un33k/python-ipware/actions/workflows/ci.yml/badge.svg[status-link]: https://github.com/un33k/python-ipware/actions/workflows/ci.yml[version-image]: https://img.shields.io/pypi/v/python-ipware.svg[version-link]: https://pypi.python.org/pypi/python-ipware?branch=main[coverage-image]: https://coveralls.io/repos/github/un33k/python-ipware/badge.svg?branch=main[coverage-link]: https://coveralls.io/github/un33k/python-ipware?branch=main[download-image]: https://img.shields.io/pypi/dm/python-ipware.svg[download-link]: https://pypi.python.org/pypi/python-ipware# Sponsors[Neekware Inc.](http://neekware.com)# Need Support?[Neekware Inc.](http://neekware.com) (reach out at info@neekware.com)</longdescription>
</pkgmetadata>