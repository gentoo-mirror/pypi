<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>objclick========[![pypi](https://img.shields.io/pypi/v/objclick.svg)](https://pypi.org/project/objclick) [![python versions](https://img.shields.io/badge/python-3.7+-blue.svg)](https://www.python.org/downloads/) [![documentation](https://img.shields.io/badge/documentation-latest-success)](https://embray.gitlab.io/objclick) [![pipeline status](https://gitlab.com/embray/objclick/badges/master/pipeline.svg)](https://gitlab.com/embray/objclick/badges/master/pipeline.svg)`objclick` provides a drop-in replacement for[click](https://click.palletsprojects.com/en/7.x/), extending it to work invarious OOP contexts.`click` is a very nice package for quickly and easily defining composablecommand-line interfaces in a declarative manner by stacking decorators ontop of functions that implement the &quot;main&quot; functions of a commands.However, by design, it does not play well in OOP contexts.  In particular,it is not so easy to promote an instance method of a class to a `click`command.  This package attempts to rectify that by providing wrappers around`click` that also play well with classes in some cases.To give a motivating example, say you have a base class that implements aCLI:```python&gt;&gt;&gt; import objclick as click&gt;&gt;&gt; import abc&gt;&gt;&gt; class BaseService(metaclass=abc.ABCMeta):...     def explain(self):...         &quot;&quot;&quot;Explain this service; must be implemented by subclasses.&quot;&quot;&quot;......     @click.command()...     def main(self):...         print('Hello, let me tell you about myself.')...         self.explain()...```This class must now be subclassed with an implementation of `explain`, butthe subclass need not re-implement the rest of the CLI:```python&gt;&gt;&gt; class MyService(BaseService):...     def explain(self):...         print(f'I am an instance of {self.__class__.__name__}.')...```Since `MyService.main` is an instance method, we cannot simply call`MyService.main()` to run the &quot;main&quot; function of CLI.  Just like with anormal instance method of a class, we must instantiate the class first andcall the method on the instance:```python&gt;&gt;&gt; service = MyService()&gt;&gt;&gt; service.main([], standalone_mode=False)Hello, let me tell you about myself.I am an instance of MyService.```(note:[standalone_mode](https://click.palletsprojects.com/en/7.x/api/?highlight=standalone_mode#click.BaseCommand.main)is a standard argument to `click` main functions that is useful for testingcommands.)The inititial version of this package is still experimental, but itimplements a number of other useful cases.One such case is given by the `classgroup` decorator.  This allows defininga command group on a classmethod-like method that is bound to the classrather than an instance of the class.  In the common case where aclassmethod implements an alternative constructor for a class, if theclassgroup returns an *instance* of the class it's define on, this instancewill be passed as the `self` argument to any instance methods that are addedas subcommands of the group.For example, here is command group that takes a `--config` option, as aconfiguration is needed to instantiate the `Service` class.  All subcommandsof `Service.main` can then access the configuration:```python&gt;&gt;&gt; import objclick as click&gt;&gt;&gt; import json, pprint&gt;&gt;&gt; class Service:...     def __init__(self, config):...         &quot;&quot;&quot;Instantiate `Service` with a configuration dict.&quot;&quot;&quot;......         self.config = config......     @click.classgroup()...     @click.option('--config', type=click.File())...     def main(cls, config=None):...         if config is not None:...             with config as f:...                 config = json.load(f)...         else:...             config = {}......         print(f'Starting up {cls.__name__}...')...         return cls(config)......     @main.command()...     def show_config(self):...         print('Config:', end=' ')...         pprint.pprint(self.config)...```Now the CLI defined by `Service` can be invoked like:```python&gt;&gt;&gt; import tempfile&gt;&gt;&gt; config = {'option1': 'a', 'option2': 'b'}&gt;&gt;&gt; with tempfile.NamedTemporaryFile(mode='w') as f:...     json.dump(config, f)...     f.flush()...     # like `service.py --config &lt;config-file&gt; show-config`...     args = ['--config', f.name, 'show-config']...     Service.main(args, standalone_mode=False)...Starting up Service...Config: {'option1': 'a', 'option2': 'b'}```objclick Changelog==================v0.1.1 (2020-10-02)-------------------### Bug fixes* Fixed a bug with calling the callback of a `classcommand` or a  `classgroup` via `super()` in a subclass.v0.1.0 (2020-10-01)-------------------* Initial release.</longdescription>
</pkgmetadata>