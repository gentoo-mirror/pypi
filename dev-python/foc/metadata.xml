<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># foc![foc](https://img.shields.io/pypi/v/foc)`fun oriented code` or `francis' odd collection`.Functions from the `Python` standard library are great. But some notations are a bit painful and confusing for personal use, so I created this _odd collection of functions_.## Tl;dr- `foc` provides a collection of _higher-order functions_ and some (_pure_) helpful functions- `foc` respects the `Python` standard library. _Never reinvented the wheel_.## How to use```bash# install$ pip install -U foc# import&gt;&gt;&gt; from foc import *# Take a look at the examples below```&gt; To list all available functions, call `catalog()`.## Ground rules- Followed `Haskell`-like function names and arguments order- Considered using generators first if possible. (_lazy-evaluation_)&gt; `map`, `filter`, `zip`, `range`, `flat` ...- Provide the functions that unpack generators in `list` as well. (annoying to unpack with `[*]` or `list` every time)- Function names that end in `l` indicate the result will be unpacked in a list.&gt; `mapl`, `filterl`, `zipl`, `rangel`, `flatl`, `takewhilel`, `dropwhilel`, ...- Function names that end in `_` indicate that the function is a **partial application** (_not-fully-evaluated function_) builder.&gt; `f_`, `ff_`, `c_`, `cc_`, `m_`, `v_`, `u_`, ...- Most function implementations _should be less than 5-lines_.- No dependencies except for the `Python` standard library- No unnessary wrapping objects.## Examples__Note__: `foc`'s functions are valid for any _iterable_ such as `list`, `tuple`, `deque`, `set`, `str`, ...```python&gt;&gt;&gt; id(&quot;francis&quot;)'francis'&gt;&gt;&gt; fst([&quot;sofia&quot;, &quot;maria&quot;, &quot;claire&quot;])'sofia'&gt;&gt;&gt; snd((&quot;sofia&quot;, &quot;maria&quot;, &quot;claire&quot;))'maria'&gt;&gt;&gt; nth(3, [&quot;sofia&quot;, &quot;maria&quot;, &quot;claire&quot;])    # not list index, but literally n-th'claire'&gt;&gt;&gt; take(3, range(5, 10))[5, 6, 7]&gt;&gt;&gt; list(drop(3, &quot;github&quot;))   # `drop` returns a generator['h', 'u', 'b']&gt;&gt;&gt; head(range(1,5))          # range(1, 5) = [1, 2, 3, 4]1&gt;&gt;&gt; last(range(1,5))4&gt;&gt;&gt; list(init(range(1,5)))    # `init` returns a generator[1, 2, 3]&gt;&gt;&gt; list(tail(range(1,5)))    # `tail` returns a generator[2, 3, 4]&gt;&gt;&gt; pred(3)2&gt;&gt;&gt; succ(3)4&gt;&gt;&gt; odd(3)True&gt;&gt;&gt; even(3)False&gt;&gt;&gt; null([]) == null(()) == null({}) == null(&quot;&quot;)True&gt;&gt;&gt; elem(5, range(10))True&gt;&gt;&gt; words(&quot;fun on functions&quot;)['fun', 'on', 'functions']&gt;&gt;&gt; unwords(['fun', 'on', 'functions'])'fun on functions'&gt;&gt;&gt; lines(&quot;fun\non\nfunctions&quot;)['fun', 'on', 'functions']&gt;&gt;&gt; unlines(['fun', 'on', 'functions'])&quot;fun\non\nfunctions&quot;&gt;&gt;&gt; take(3, repeat(5))        # repeat(5) = [5, 5, ...][5, 5, 5]&gt;&gt;&gt; take(5, cycle(&quot;fun&quot;))     # cycle(&quot;fun&quot;) = ['f', 'u', 'n', 'f', 'u', 'n', ...]['f', 'u', 'n', 'f', 'u']&gt;&gt;&gt; replicate(3, 5)           # the same as 'take(3, repeat(5))'[5, 5, 5]&gt;&gt;&gt; take(3, count(2))         # count(2) = [2, 3, 4, 5, ...][2, 3, 4]&gt;&gt;&gt; take(3, count(2, 3))      # count(2, 3) = [2, 5, 8, 11, ...][2, 5, 8]```### Get binary functions from `python` operators: `sym``sym(OP)` converts `python`'s _symbolic operators_ into _binary functions_.  The string forms of operators like `+`, `-`, `/`, `*`, `**`, `==`, `!=`, .. represent the corresponding binary functions.&gt; To list all available symbols, call `sym()`.```python&gt;&gt;&gt; sym(&quot;+&quot;)(5, 2)                 # 5 + 27&gt;&gt;&gt; sym(&quot;==&quot;)(&quot;sofia&quot;, &quot;maria&quot;)    # &quot;sofia&quot; == &quot;maria&quot;False&gt;&gt;&gt; sym(&quot;%&quot;)(123456, 83)           # 123456 % 8335```### Build partial application: `f_` and `ff_`- `f_` build left-associative partial application,  where the given function's arguments partially evaluation _from the left_.- `ff_` build right-associative partial application,  where the given function's arguments partially evaluation _from the right_.&gt; `f_(fn, *args, **kwargs)`  &gt;&gt; `ff_(fn, *args, **kwargs) == f_(flip(fn), *args, **kwargs)`  &gt;```python&gt;&gt;&gt; f_(&quot;+&quot;, 5)(2)    # the same as `(5+) 2` in Haskell7                    # 5 + 2&gt;&gt;&gt; ff_(&quot;+&quot;, 5)(2)   # the same as `(+5) 2 in Haskell`7                    # 2 + 5&gt;&gt;&gt; f_(&quot;-&quot;, 5)(2)    # the same as `(5-) 2`3                    # 5 - 2&gt;&gt;&gt; ff_(&quot;-&quot;, 5)(2)   # the same as `(subtract 5) 2`-3                   # 2 - 5# with N-ary function&gt;&gt;&gt; def print_args(a, b, c, d): print(f&quot;{a}-{b}-{c}-{d}&quot;)&gt;&gt;&gt; f_(print_args, 1, 2)(3, 4)                # partial-eval from the left1-2-3-4                                       # print_args(1, 2, 3, 4)&gt;&gt;&gt; f_(print_args, 1, 2, 3)(4)                # patial-eval with different args number1-2-3-4                                       # print_args(1, 2, 3, 4)&gt;&gt;&gt; ff_(print_args, 1, 2)(3, 4)               # partial-eval from the right4-3-2-1                                       # print_args(4, 3, 2, 1)```### Build curried functions: `c_` and `cc_`When currying a given function, - `c_` takes the function's arguments _from the left_ - while `cc_` takes them _from the right_.&gt; `c_(fn) == curry(fn)`&gt;&gt; `cc_(fn) == c_(flip(fn))`See also `uncurry````python# currying from the left args&gt;&gt;&gt; c_(&quot;+&quot;)(5)(2)    # 5 + 27&gt;&gt;&gt; c_(&quot;-&quot;)(5)(2)    # 5 - 23# currying from the right args&gt;&gt;&gt; cc_(&quot;+&quot;)(5)(2)   # 2 + 57&gt;&gt;&gt; cc_(&quot;-&quot;)(5)(2)   # 2 - 5-3# with N-ary function&gt;&gt;&gt; c_(print_args)(1)(2)(3)(4)    # print_args(1, 2, 3, 4)1-2-3-4&gt;&gt;&gt; cc_(print_args)(1)(2)(3)(4)   # print_args(4, 3, 2, 1)4-3-2-1```### Build composition of functions: `cf_` and `cfd`- `cf_` (_composition of function_) composes functions using the given list of functions. - `cfd` (_composing-function decorator_) decorates a function with the given list of functions.&gt; `cf_(*fn, rep=None)`&gt;&gt; `cfd(*fn, rep=None)````python&gt;&gt;&gt; square = ff_(&quot;**&quot;, 2)        # the same as (^2) in Haskell&gt;&gt;&gt; add5 = ff_(&quot;+&quot;, 5)           # the same as (+5) in Haskell&gt;&gt;&gt; mul7 = ff_(&quot;*&quot;, 7)           # the same as (*7) in Haskell&gt;&gt;&gt; cf_(mul7, add5, square)(3)   # (*7) . (+5) . (^2) $ 398                               # mul7(add5(square(3))) = ((3 ^ 2) + 5) * 7&gt;&gt;&gt; cf_(square, rep=3)(2)        # cf_(square, square, square)(2) == ((2 ^ 2) ^ 2) ^ 2 = 256256&gt;&gt;&gt; @cfd(mul7, add5, square)... def even_num_less_than(x):...     return len(list(filter(even, range(x))))&gt;&gt;&gt; even_num_less_than(7)        # 'even numbers less than 7' = len({0, 2, 4, 6}) = 4147                              # mul7(add5(square(4))) = ((4 ^ 2) + 5) * 7 = 147# the meaning of decorating a function with a composition of functionsg = cfd(a, b, c, d)(f)           # g = (a . b . c . d)(f)# the samecfd(a, b, c, d)(f)(x)            # g(x) = a(b(c(d(f(x)))))cf_(a, b, c, d, f)(x)            # (a . b . c . d . f)(x) = a(b(c(d(f(x))))) = g(x)````cfd` is very handy and useful to recreate previously defined functions by composing functions. All you need is to write a basic functions to do fundamental things.### Partial application of `map`: `m_` and `mm_`- `m_` builds partial application of `map` (_left-associative_) - `mm_` builds partial application from right to left (_right-associative_).&gt; Compared to `Haskell`,&gt; - `f &lt;$&gt; xs == map(f, xs)`&gt; - `(f &lt;$&gt;) == f_(map, f) == m_(f)`&gt; - `(&lt;$&gt; xs) == f_(flip(map), xs) == mm_(xs)`Unpacking with `list(..)` or `[* .. ]` is sometimes very annoying. Use `mapl` for low memory consuming tasks instead.```python# mapl(f, xs) == [* map(f, xs)] == list(map(f, xs))&gt;&gt;&gt; mapl = cfd(list)(map)# so 'm_' and 'mm_' do&gt;&gt;&gt; ml_ = cfd(list)(m_)&gt;&gt;&gt; mml_ = cfd(list)(mm_)``````python# The same as [ (lambda x: 8*x)(x) for x in range(1, 6) ]&gt;&gt;&gt; list(map(f_(&quot;*&quot;, 8), range(1, 6)))   # (8*) &lt;$&gt; [1..5][8, 16, 24, 32, 40]# tha same: shorter using 'mapl'&gt;&gt;&gt; mapl(f_(&quot;*&quot;, 8), range(1, 6))        # (8*) &lt;$&gt; [1..5][8, 16, 24, 32, 40]# the same: partial application (from left)&gt;&gt;&gt; ml_(f_(&quot;*&quot;, 8))(range(1, 6))         # ((8*) &lt;$&gt;) [1..5][8, 16, 24, 32, 40]# the same: partial application (from right)&gt;&gt;&gt; mml_(range(1, 6))(f_(&quot;*&quot;, 8))        # (&lt;$&gt; [1..5]) (8*)[8, 16, 24, 32, 40]```### Partial application of `filter`: `v_` and `vv_`- `v_` builds partial application of `filter` (_left-associative_) - `vv_` builds partial application from right to left (_right-associative_).The same as `map` (mapping functions over iterables) except for filtering iterables using predicate function.&gt; The name of `v_` comes from the shape of 'funnel'.```python# filterl(f, xs) == [* filter(f, xs)] == list(filter(f, xs))&gt;&gt;&gt; filterl = cfd(list)(filter)&gt;&gt;&gt; vl_ = cfd(list)(v_)      # v_ = f_(filter, f)&gt;&gt;&gt; vvl_ = cfd(list)(vv_)    # vv_ = ff_(filter, xs)``````python# generate a filter to select only even numbers&gt;&gt;&gt; even_nums = vl_(even)&gt;&gt;&gt; even_nums(range(10))[0, 2, 4, 6, 8]&gt;&gt;&gt; even_nums({2, 3, 5, 7, 11, 13, 17})[2]# partailly evaluated 'filter' using 'prime numbers less than 20'&gt;&gt;&gt; primes_lt_20 = vvl_([2, 3, 5, 7, 11, 13, 17, 19])# filter out numbers LE 10&gt;&gt;&gt; primes_lt_20(ff_(&quot;&gt;&quot;, 10))    # (&gt; 10)[11, 13, 17, 19]# used a lambda function&gt;&gt;&gt; primes_lt_20(lambda x: x % 3 == 2)[2, 5, 11, 17, 23, 29, 41, 47]# used the composition of functions&gt;&gt;&gt; primes_lt_20(cf_(ff_(&quot;==&quot;, 2), ff_(&quot;%&quot;, 3)))    # ((== 2) . (% 3))[2, 5, 11, 17, 23, 29, 41, 47]```### Other higher-order functions```python&gt;&gt;&gt; flip(pow)(7, 3)                             # the same as `pow(3, 7) = 3 ** 7`2187&gt;&gt;&gt; bimap(f_(&quot;+&quot;, 3), f_(&quot;*&quot;, 7), (5, 7))       # bimap (3+) (7*) (5, 7)(8, 49)                                         # (3+5, 7*7)&gt;&gt;&gt; first(f_(&quot;+&quot;, 3), (5, 7))                   # first (3+) (5, 7)(8, 7)                                          # (3+5, 7)&gt;&gt;&gt; second(f_(&quot;*&quot;, 7), (5, 7))                  # second (7*) (5, 7)(5, 49)                                         # (5, 7*7)&gt;&gt;&gt; take(5, iterate(lambda x: x**2, 2))         # [2, 2**2, (2**2)**2, ((2**2)**2)**2, ...][2, 4, 16, 256, 65536]&gt;&gt;&gt; [* takewhile(even, [2, 4, 6, 1, 3, 5]) ]    # `takewhile` returns a generator[2, 4, 6]&gt;&gt;&gt; takewhilel(even, [2, 4, 6, 1, 3, 5])[2, 4, 6]&gt;&gt;&gt; [* dropwhile(even, [2, 4, 6, 1, 3, 5]) ]    # `dropwhile` returns a generator[1, 3, 5]&gt;&gt;&gt; dropwhilel(even, [2, 4, 6, 1, 3, 5])[1, 3, 5]# fold with a given initial value from the left&gt;&gt;&gt; foldl(&quot;-&quot;, 10, range(1, 5))                 # foldl (-) 10 [1..4]0# fold with a given initial value from the right&gt;&gt;&gt; foldr(&quot;-&quot;, 10, range(1, 5))                 # foldr (-) 10 [1..4]8# `foldl` without an initial value (used first item instead)&gt;&gt;&gt; foldl1(&quot;-&quot;, range(1, 5))                    # foldl1 (-) [1..4]-8# `foldr` without an initial value (used first item instead)&gt;&gt;&gt; foldr1(&quot;-&quot;, range(1, 5))                    # foldr1 (-) [1..4]-2# accumulate reduced values from the left&gt;&gt;&gt; scanl(&quot;-&quot;, 10, range(1, 5))                 # scanl (-) 10 [1..4][10, 9, 7, 4, 0]# accumulate reduced values from the right&gt;&gt;&gt; scanr(&quot;-&quot;, 10, range(1, 5))                 # scanr (-) 10 [1..4][8, -7, 9, -6, 10]# `scanl` but no starting value&gt;&gt;&gt; scanl1(&quot;-&quot;, range(1, 5))                    # scanl1 (-) [1..4][1, -1, -4, -8]# `scanr` but no starting value&gt;&gt;&gt; scanr1(&quot;-&quot;, range(1, 5))                    # scanr1 (-) [1..4][-2, 3, -1, 4]# See also 'concat' that returns a generator&gt;&gt;&gt; concatl([&quot;sofia&quot;, &quot;maria&quot;])['s', 'o', 'f', 'i', 'a', 'm', 'a', 'r', 'i', 'a']# Note that [&quot;sofia&quot;, &quot;maria&quot;] = [['s','o','f','i','a'], ['m','a','r','i','a']]# See also 'concatmap' that returns a generator&gt;&gt;&gt; concatmapl(str.upper, [&quot;sofia&quot;, &quot;maria&quot;])   # concatmapl = cfd(list, concat)(map)['S', 'O', 'F', 'I', 'A', 'M', 'A', 'R', 'I', 'A']```### Lazy Evaluation: `lazy` and `force`- `lazy` defers the evaluation of a function(or expression) and returns the _deferred expression_.- `force` forces the deferred-expression to be fully evaluated when needed.it reminds `Haskell`'s `force x = deepseq x x`.&gt; `lazy(function-name, *args, **kwargs)`&gt;&gt; `force(expr)`&gt;&gt; `mforce([expr])````python# strictly generate a random integer between [1, 10)&gt;&gt;&gt; randint(1, 10)# generate a lazy expression for the above&gt;&gt;&gt; deferred = lazy(randint, 1, 10)# evaluate it when it need&gt;&gt;&gt; force(deferred)# the same as above&gt;&gt;&gt; deferred()```Are those evaluations with `lazy` really deferred?```python&gt;&gt;&gt; long_list = randint(1, 100000, 100000)    # a list of one million random integers&gt;&gt;&gt; %timeit sort(long_list)142 ms ± 245 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)# See the evaluation was deferred&gt;&gt;&gt; %timeit lazy(sort, long_list)1.03 µs ± 2.68 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each```#### ExampleFor given a function `randint(low, high)`, how can we generate a list of random integers?```python[ randint(1, 10) for _ in range(5) ]    # exactly the same as 'randint(1, 10, 5)'```It's the simplest way but what about using `replicate`?```python# generate a list of random integers using 'replicate'&gt;&gt;&gt; replicate(5, randint(1, 10))[7, 7, 7, 7, 7]        # ouch, duplication of the first evaluated item.```Wrong! This result is definitely not what we want. We need to defer the function evaluation till it is _replicated_.Just use `lazy(randint, 1, 10)` instead of `randint(1, 10)````python# replicate 'deferred expression'&gt;&gt;&gt; randos = replicate(5, lazy(randint, 1, 10))# evaluate when needed&gt;&gt;&gt; mforce(randos)      # mforce = ml_(force), map 'force' over deferred expressions[6, 2, 5, 1, 9]         # exactly what we wanted```Here is the simple secret: if you complete `f_` or `ff_` with a function name and its arguments, and leave it unevaluated (not called), they will act as a _deferred expression_.Not related to `lazy` operation, but you do the same thing with `uncurry````python# replicate the tuple of arguments (1, 10) and then apply to uncurried function&gt;&gt;&gt; ml_(u_(randint))(replicate(5, (1,10)))    # u_ == uncurry[7, 6, 1, 7, 2]```### Normalize containers: `flat``flat` flattens all kinds of iterables except for _string-like object_ (`str`, `bytes`).&gt; `flat(*args)````python# Assume that we regenerate 'data' every time in the examples below&gt;&gt;&gt; data = [1,2,[3,4,[[[5],6],7,{8},((9),10)],range(11,13)], (x for x in [13,14,15])]# 'flat' returns a generator. flatl = cfd(list)(flat)&gt;&gt;&gt; flatl(data)    # list[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]# regardless of the number of arguments&gt;&gt;&gt; flatl(1,[2,{3}],[[[[[4]],5]]], &quot;sofia&quot;, &quot;maria&quot;)[1, 2, 3, 4, 5, 'sofia', 'maria']```### Handy File Tools: `ls` and `grep`Use `ls` and `grep` in the same way you use in your terminal every day.&gt; _This is just a more intuitive alternative to_ `os.listdir` and `os.walk`.  &gt; When applicable, try using the _more flexible_ `shell(&quot;ls -a1 &lt;path&gt;&quot;)` or `shell(&quot;find &lt;path&gt;&quot;)` instead.   See also: `shell`#### Background`Path` from `pathlib` and `glob` are great and useful. But,- _Not intuitive_: `os.path.expanduser(&quot;~&quot;)` every time?- _Non-automated filepath normalization_- _No flexible understanding_: not tolerable for `foc//__init__.py` (`/` typo)- _Not integrated_: listing (`os.listdir`), globbing (`glob.glob`) and selecting files (`filter`)#### Usage&gt; `ls(*paths, grep=REGEX, i=BOOL, r=BOOL, f=BOOL, d=BOOL, g=BOOL)`- support glob patterns `(*,?,[)` in `*paths`- if given `grep=REGEX`, it behaves like `ls -a1 *paths | grep REGEX`- if `i` is set, it makes `grep` case-insensitive (`-i` flag in `grep`)- if `r` is set, it behaves like `find -s *paths` (`-R` flag in `ls`)- if `f` is set, it lists only files like `find -s *paths -type f`- if `d` is set, it lists only directories like `find -s *paths -type d`- if `g` is set, it returns a _generator_ instead of a sorted list```python# couldn't be simpler!&gt;&gt;&gt; ls()       # the same as ls(&quot;.&quot;): get contents of the curruent dir# expands &quot;~&quot; automatically&gt;&gt;&gt; ls(&quot;~&quot;)    # the same as `ls -a1 ~`: returns a list of $HOME# support glob patterns (*, ?, [)&gt;&gt;&gt; ls(&quot;./*/*.py&quot;)# with multiple filepaths&gt;&gt;&gt; ls(FILE, DIR, ...)``````python# list up recursively and filter hidden files out&gt;&gt;&gt; ls(&quot;.git&quot;, r=True, grep=&quot;^[^\.]&quot;)``````python# only files in '.git' directory&gt;&gt;&gt; ls(&quot;.git&quot;, r=True, f=True)# only directories in '.git' directory&gt;&gt;&gt; ls(&quot;.git&quot;, r=True, d=True)``````python# search recursivley and matching a pattern with `grep`&gt;&gt;&gt; ls(&quot;.&quot;, r=True, i=True, grep=&quot;.Py&quot;)    # 'i=True' for case-insensitive grep pattern``````[ .. '.pytest_cache/v/cache/stepwise', 'foc/__init__.py', 'foc/__pycache__/__init__.cpython-310.pyc', 'tests/__init__.py',.. ]``````python# regex patterns come in&gt;&gt;&gt; ls(&quot;.&quot;, r=True, grep=&quot;.py$&quot;)``````['foc/__init__.py', 'setup.py', 'tests/__init__.py', 'tests/test_foc.py']``````python# that's it!&gt;&gt;&gt; ls(&quot;.&quot;, r=True, grep=&quot;^(foc).*py$&quot;)# the same as above&gt;&gt;&gt; ls(&quot;foc/*.py&quot;)``````['foc/__init__.py']````grep` build a filter to select items matching `REGEX` pattern from _iterables_.&gt; `grep(REGEX, i=BOOL)````python# 'grep' builds filter with regex patterns&gt;&gt;&gt; grep(r&quot;^(foc).*py$&quot;)(ls(&quot;.&quot;, r=True))``````['foc/__init__.py']```See also: `HOME`, `cd`, `pwd`, `mkdir`, `rmdir`, `exists`, `dirname`, and `basename`.### Neatify data structures: `neatly` and `nprint``neatly` generates neatly formatted string of the complex data structures of `dict` and `list`.`nprint` (_neatly-print_) prints data structures to `stdout` using `neatly` formatter.&quot;&quot;&quot;`nprint(...) = print(neatly(...))``nprint(DICT, _cols=INDENT, _width=WRAP, **kwargs)````python&gt;&gt;&gt; o = {...   &quot;$id&quot;: &quot;https://example.com/enumerated-values.schema.json&quot;,...   &quot;$schema&quot;: &quot;https://json-schema.org/draft/2020-12/schema&quot;,...   &quot;title&quot;: &quot;Enumerated Values&quot;,...   &quot;type&quot;: &quot;object&quot;,...   &quot;properties&quot;: {...     &quot;data&quot;: {...       &quot;enum&quot;: [42, True, &quot;hello&quot;, None, [1, 2, 3]]...     }...   }... }&gt;&gt;&gt; nprint(o)``````       $id  |  'https://example.com/enumerated-values.schema.json'   $schema  |  'https://json-schema.org/draft/2020-12/schema'properties  |  data  |  enum  -  42            :        :        -  True            :        :        -  'hello'            :        :        -  None            :        :        -  -  1            :        :        -  -  2            :        :        -  -  3     title  |  'Enumerated Values'      type  |  'object'```### Dot-accessible dictionary: `dmap``dmap` is a _yet another_ `dict`. It's exactly the same as `dict` but it enables to access its nested structure with '_dot notations_'.`dmap(DICT, **kwargs)````python&gt;&gt;&gt; d = dmap()    # empty dict&gt;&gt;&gt; d = dmap(dict(...))&gt;&gt;&gt; d = dmap(name=&quot;yunchan lim&quot;, age=19, profession=&quot;pianist&quot;)    # or dmap({&quot;name&quot;:.., &quot;age&quot;:..,})# just put the value in the desired keypath&gt;&gt;&gt; d.cliburn.semifinal.mozart = &quot;piano concerto no.22&quot;&gt;&gt;&gt; d.cliburn.semifinal.liszt = &quot;12 transcendental etudes&quot;&gt;&gt;&gt; d.cliburn.final.beethoven = &quot;piano concerto no.3&quot;&gt;&gt;&gt; d.cliburn.final.rachmaninoff = &quot;piano concerto no.3&quot;&gt;&gt;&gt; nprint(d)``````      name  |  'yunchan lim'       age  |  19profession  |  'pianist'   cliburn  |  semifinal  |  mozart  |  'piano concerto no.22'            :             :   liszt  |  '12 transcendental etudes'            :      final  |     beethoven  |  'piano concerto no.3'            :             :  rachmaninoff  |  'piano concerto no.3'``````python&gt;&gt;&gt; del d.cliburn.semifinal&gt;&gt;&gt; d.profession = &quot;one-in-a-million talent&quot;&gt;&gt;&gt; nprint(d)``````      name  |  'yunchan lim'       age  |  19profession  |  'one-in-a-million talent'   cliburn  |  final  |     beethoven  |  'piano concerto no.3'            :         :  rachmaninoff  |  'piano concerto no.3'``````python# No such keypath&gt;&gt;&gt; d.bach.chopin.beethoven{}```### raise and assert with _expressions_: `error` and `guard`Raise any kinds of exception in `lambda` expression as well.```python&gt;&gt;&gt; error(MESSAGE, e=EXCEPTION_TO_RAISE)    # by default, e=SystemExit&gt;&gt;&gt; error(&quot;Error, used wrong type&quot;, e=TypeError)&gt;&gt;&gt; error(&quot;out of range&quot;, e=IndexError)&gt;&gt;&gt; (lambda x: x if x is not None else error(&quot;Error, got None&quot;, e=ValueError))(None)```Likewise, use `guard` if there need _assertion_ not as a statement, but as an _expression_.```python&gt;&gt;&gt; guard(PREDICATE, MESSAGE, e=EXCEPTION_TO_RAISE)    # by default, e=SystemExit&gt;&gt;&gt; guard(&quot;Almost&quot; == &quot;enough&quot;, &quot;'Almost' is never 'enough'&quot;)&gt;&gt;&gt; guard(rand() &gt; 0.5, &quot;Assertion error occurs with a 0.5 probability&quot;)&gt;&gt;&gt; guard(len(x := range(11)) == 10, f&quot;length is not 10: {len(x)}&quot;)```### Real-World ExampleA causal self-attention of the `transformer` model based on `pytorch` can be described as follows._Somebody_ insists that this helps to follow the process flow without distraction.```python    def forward(self, x):        B, S, E = x.size()  # size_batch, size_block (sequence length), size_embed        N, H = self.config.num_heads, E // self.config.num_heads  # E == (N * H)        q, k, v = self.c_attn(x).split(self.config.size_embed, dim=2)        q = q.view(B, S, N, H).transpose(1, 2)  # (B, N, S, H)        k = k.view(B, S, N, H).transpose(1, 2)  # (B, N, S, H)        v = v.view(B, S, N, H).transpose(1, 2)  # (B, N, S, H)        # Attention(Q, K, V)        #   = softmax( Q*K^T / sqrt(d_k) ) * V        #         // q*k^T: (B, N, S, H) x (B, N, H, S) -&gt; (B, N, S, S)        #   = attention-prob-matrix * V        #         // prob @ v: (B, N, S, S) x (B, N, S, H) -&gt; (B, N, S, H)        #   = attention-weighted value (attention score)        return cf_(            self.dropout,  # dropout of layer's output            self.c_proj,  # linear projection            ff_(torch.Tensor.view, *rev(B, S, E)),  # (B, S, N, H) -&gt; (B, S, E)            torch.Tensor.contiguous,  # contiguos in-memory tensor            ff_(torch.transpose, *rev(1, 2)),  # (B, S, N, H)            ff_(torch.matmul, v),  # (B, N, S, S) x (B, N, S, H) -&gt; (B, N, S, H)            self.dropout_attn,  # attention dropout            ff_(torch.masked_fill, *rev(mask == 0, 0.0)),  # double-check masking            f_(F.softmax, dim=-1),  # softmax            ff_(torch.masked_fill, *rev(mask == 0, float(&quot;-inf&quot;))),  # no-look-ahead            ff_(&quot;/&quot;, math.sqrt(k.size(-1))),  # / sqrt(d_k)            ff_(torch.matmul, k.transpose(-2, -1)),  # Q @ K^T -&gt; (B, N, S, S)        )(q)```</longdescription>
</pkgmetadata>