<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://github.com/5j9/wikitextparser/actions/workflows/tests.yml/badge.svg    :target: https://github.com/5j9/wikitextparser/actions/workflows/tests.yml.. image:: https://codecov.io/github/5j9/wikitextparser/coverage.svg?branch=master    :target: https://codecov.io/github/5j9/wikitextparser.. image:: https://readthedocs.org/projects/wikitextparser/badge/?version=latest    :target: http://wikitextparser.readthedocs.io/en/latest/?badge=latest==============WikiTextParser==============.. Quick Start GuidA simple to use WikiText parsing library for `MediaWiki &lt;https://www.mediawiki.org/wiki/MediaWiki&gt;`_.The purpose is to allow users easily extract and/or manipulate templates, template parameters, parser functions, tables, external links, wikilinks, lists, etc. found in wikitexts... contents:: Table of ContentsInstallation============- Python 3.6+ is required- ``pip install wikitextparser``Usage=====.. code:: python    &gt;&gt;&gt; import wikitextparser as wtpWikiTextParser can detect sections, parser functions, templates, wiki links, external links, arguments, tables, wiki lists, and comments in your wikitext. The following sections are a quick overview of some of these functionalities.You may also want to have a look at the test modules for more examples and probable pitfalls (expected failures).Templates---------.. code:: python    &gt;&gt;&gt; parsed = wtp.parse(&quot;{{text|value1{{text|value2}}}}&quot;)    &gt;&gt;&gt; parsed.templates    [Template('{{text|value1{{text|value2}}}}'), Template('{{text|value2}}')]    &gt;&gt;&gt; parsed.templates[0].arguments    [Argument(&quot;|value1{{text|value2}}&quot;)]    &gt;&gt;&gt; parsed.templates[0].arguments[0].value = 'value3'    &gt;&gt;&gt; print(parsed)    {{text|value3}}The ``pformat`` method returns a pretty-print formatted string for templates:.. code:: python    &gt;&gt;&gt; parsed = wtp.parse('{{t1 |b=b|c=c| d={{t2|e=e|f=f}} }}')    &gt;&gt;&gt; t1, t2 = parsed.templates    &gt;&gt;&gt; print(t2.pformat())    {{t2        | e = e        | f = f    }}    &gt;&gt;&gt; print(t1.pformat())    {{t1        | b = b        | c = c        | d = {{t2            | e = e            | f = f        }}    }}``Template.rm_dup_args_safe`` and ``Template.rm_first_of_dup_args`` methods can be used to clean-up `pages using duplicate arguments in template calls &lt;https://en.wikipedia.org/wiki/Category:Pages_using_duplicate_arguments_in_template_calls&gt;`_:.. code:: python    &gt;&gt;&gt; t = wtp.Template('{{t|a=a|a=b|a=a}}')    &gt;&gt;&gt; t.rm_dup_args_safe()    &gt;&gt;&gt; t    Template('{{t|a=b|a=a}}')    &gt;&gt;&gt; t = wtp.Template('{{t|a=a|a=b|a=a}}')    &gt;&gt;&gt; t.rm_first_of_dup_args()    &gt;&gt;&gt; t    Template('{{t|a=a}}')Template parameters:.. code:: python    &gt;&gt;&gt; param = wtp.parse('{{{a|b}}}').parameters[0]    &gt;&gt;&gt; param.name    'a'    &gt;&gt;&gt; param.default    'b'    &gt;&gt;&gt; param.default = 'c'    &gt;&gt;&gt; param    Parameter('{{{a|c}}}')    &gt;&gt;&gt; param.append_default('d')    &gt;&gt;&gt; param    Parameter('{{{a|{{{d|c}}}}}}')WikiLinks---------.. code:: python    &gt;&gt;&gt; wl = wtp.parse('... [[title#fragmet|text]] ...').wikilinks[0]    &gt;&gt;&gt; wl.title = 'new_title'    &gt;&gt;&gt; wl.fragment = 'new_fragmet'    &gt;&gt;&gt; wl.text = 'X'    &gt;&gt;&gt; wl    WikiLink('[[new_title#new_fragmet|X]]')    &gt;&gt;&gt; del wl.text    &gt;&gt;&gt; wl    WikiLink('[[new_title#new_fragmet]]')All WikiLink properties support get, set, and delete operations.Sections--------.. code:: python    &gt;&gt;&gt; parsed = wtp.parse(&quot;&quot;&quot;    ... == h2 ==    ... t2    ... === h3 ===    ... t3    ... === h3 ===    ... t3    ... == h22 ==    ... t22    ... {{text|value3}}    ... [[Z|X]]    ... &quot;&quot;&quot;)    &gt;&gt;&gt; parsed.sections    [Section('\n'),     Section('== h2 ==\nt2\n=== h3 ===\nt3\n=== h3 ===\nt3\n'),     Section('=== h3 ===\nt3\n'),     Section('=== h3 ===\nt3\n'),     Section('== h22 ==\nt22\n{{text|value3}}\n[[Z|X]]\n')]    &gt;&gt;&gt; parsed.sections[1].title = 'newtitle'    &gt;&gt;&gt; print(parsed)    ==newtitle==    t2    === h3 ===    t3    === h3 ===    t3    == h22 ==    t22    {{text|value3}}    [[Z|X]]    &gt;&gt;&gt; del parsed.sections[1].title    &gt;&gt;&gt;&gt; print(parsed)    t2    === h3 ===    t3    === h3 ===    t3    == h22 ==    t22    {{text|value3}}    [[Z|X]]Tables------Extracting cell values of a table:.. code:: python    &gt;&gt;&gt; p = wtp.parse(&quot;&quot;&quot;{|    ... |  Orange    ||   Apple   ||   more    ... |-    ... |   Bread    ||   Pie     ||   more    ... |-    ... |   Butter   || Ice cream ||  and more    ... |}&quot;&quot;&quot;)    &gt;&gt;&gt; p.tables[0].data()    [['Orange', 'Apple', 'more'],     ['Bread', 'Pie', 'more'],     ['Butter', 'Ice cream', 'and more']]By default, values are arranged according to ``colspan`` and ``rowspan`` attributes:.. code:: python    &gt;&gt;&gt; t = wtp.Table(&quot;&quot;&quot;{| class=&quot;wikitable sortable&quot;    ... |-    ... ! a !! b !! c    ... |-    ... !colspan = &quot;2&quot; | d || e    ... |-    ... |}&quot;&quot;&quot;)    &gt;&gt;&gt; t.data()    [['a', 'b', 'c'], ['d', 'd', 'e']]    &gt;&gt;&gt; t.data(span=False)    [['a', 'b', 'c'], ['d', 'e']]Calling the ``cells`` method of a ``Table`` returns table cells as ``Cell`` objects. Cell objects provide methods for getting or setting each cell's attributes or values individually:.. code:: python    &gt;&gt;&gt; cell = t.cells(row=1, column=1)    &gt;&gt;&gt; cell.attrs    {'colspan': '2'}    &gt;&gt;&gt; cell.set('colspan', '3')    &gt;&gt;&gt; print(t)    {| class=&quot;wikitable sortable&quot;    |-    ! a !! b !! c    |-    !colspan = &quot;3&quot; | d || e    |-    |}HTML attributes of Table, Cell, and Tag objects are accessible via``get_attr``, ``set_attr``, ``has_attr``, and  ``del_attr`` methods.Lists-----The ``get_lists`` method provides access to lists within the wikitext... code:: python    &gt;&gt;&gt; parsed = wtp.parse(    ...     'text\n'    ...     '* list item a\n'    ...     '* list item b\n'    ...     '** sub-list of b\n'    ...     '* list item c\n'    ...     '** sub-list of b\n'    ...     'text'    ... )    &gt;&gt;&gt; wikilist = parsed.get_lists()[0]    &gt;&gt;&gt; wikilist.items    [' list item a', ' list item b', ' list item c']The ``sublists`` method can be used to get all sub-lists of the current list or just sub-lists of specific items:.. code:: python    &gt;&gt;&gt; wikilist.sublists()    [WikiList('** sub-list of b\n'), WikiList('** sub-list of b\n')]    &gt;&gt;&gt; wikilist.sublists(1)[0].items    [' sub-list of b']It also has an optional ``pattern`` argument that works similar to ``lists``, except that the current list pattern will be automatically added to it as a prefix:.. code:: python    &gt;&gt;&gt; wikilist = wtp.WikiList('#a\n#b\n##ba\n#*bb\n#:bc\n#c', '\#')    &gt;&gt;&gt; wikilist.sublists()    [WikiList('##ba\n'), WikiList('#*bb\n'), WikiList('#:bc\n')]    &gt;&gt;&gt; wikilist.sublists(pattern='\*')    [WikiList('#*bb\n')]Convert one type of list to another using the convert method. Specifying the starting pattern of the desired lists can facilitate finding them and improves the performance:.. code:: python        &gt;&gt;&gt; wl = wtp.WikiList(        ...     ':*A1\n:*#B1\n:*#B2\n:*:continuing A1\n:*A2',        ...     pattern=':\*'        ... )        &gt;&gt;&gt; print(wl)        :*A1        :*#B1        :*#B2        :*:continuing A1        :*A2        &gt;&gt;&gt; wl.convert('#')        &gt;&gt;&gt; print(wl)        #A1        ##B1        ##B2        #:continuing A1        #A2Tags----Accessing HTML tags:.. code:: python        &gt;&gt;&gt; p = wtp.parse('text&lt;ref name=&quot;c&quot;&gt;citation&lt;/ref&gt;\n&lt;references/&gt;')        &gt;&gt;&gt; ref, references = p.get_tags()        &gt;&gt;&gt; ref.name = 'X'        &gt;&gt;&gt; ref        Tag('&lt;X name=&quot;c&quot;&gt;citation&lt;/X&gt;')        &gt;&gt;&gt; references        Tag('&lt;references/&gt;')WikiTextParser is able to handle common usages of HTML and extension tags. However it is not a fully-fledged HTML parser and may fail on edge cases or malformed HTML input. Please open an issue on github if you encounter bugs.Miscellaneous-------------``parent`` and ``ancestors`` methods can be used to access a node's parent or ancestors respectively:.. code:: python    &gt;&gt;&gt; template_d = parse(&quot;{{a|{{b|{{c|{{d}}}}}}}}&quot;).templates[3]    &gt;&gt;&gt; template_d.ancestors()    [Template('{{c|{{d}}}}'),     Template('{{b|{{c|{{d}}}}}}'),     Template('{{a|{{b|{{c|{{d}}}}}}}}')]    &gt;&gt;&gt; template_d.parent()    Template('{{c|{{d}}}}')    &gt;&gt;&gt; _.parent()    Template('{{b|{{c|{{d}}}}}}')    &gt;&gt;&gt; _.parent()    Template('{{a|{{b|{{c|{{d}}}}}}}}')    &gt;&gt;&gt; _.parent()  # Returns NoneUse the optional ``type_`` argument if looking for ancestors of a specific type:.. code:: python    &gt;&gt;&gt; parsed = parse('{{a|{{#if:{{b{{c&lt;!----&gt;}}}}}}}}')    &gt;&gt;&gt; comment = parsed.comments[0]    &gt;&gt;&gt; comment.ancestors(type_='ParserFunction')    [ParserFunction('{{#if:{{b{{c&lt;!----&gt;}}}}}}')]To delete/remove any object from its parents use ``del object[:]`` or ``del object.string``.The ``remove_markup`` function or ``plain_text`` method can be used to remove wiki markup:.. code:: python    &gt;&gt;&gt; from wikitextparser import remove_markup, parse    &gt;&gt;&gt; s = &quot;'''a'''&lt;!--comment--&gt; [[b|c]] [[d]]&quot;    &gt;&gt;&gt; remove_markup(s)    'a c d'    &gt;&gt;&gt; parse(s).plain_text()    'a c d'Compared with mwparserfromhell==============================`mwparserfromhell &lt;https://github.com/earwig/mwparserfromhell&gt;`_ is a mature and widely used library with nearly the same purposes as ``wikitextparser``. The main reason leading me to create ``wikitextparser`` was that ``mwparserfromhell`` could not parse wikitext in certain situations that I needed it for. See mwparserfromhell's issues `40 &lt;https://github.com/earwig/mwparserfromhell/issues/40&gt;`_, `42 &lt;https://github.com/earwig/mwparserfromhell/issues/42&gt;`_, `88 &lt;https://github.com/earwig/mwparserfromhell/issues/88&gt;`_, and other related issues. In many of those situation ``wikitextparser`` may be able to give you more acceptable results.Also note that ``wikitextparser`` is still using 0.x.y version `meaning &lt;https://semver.org/&gt;`_ that the API is not stable and may change in the future versions.The tokenizer in ``mwparserfromhell`` is written in C. Tokenization in ``wikitextparser`` is mostly done using the ``regex`` library which is also in C.I have not rigorously compared the two libraries in terms of performance, i.e. execution time and memory usage. In my limited experience, ``wikitextparser`` has a decent performance in realistic cases and should be able to compete and may even have little performance benefits in some situations.If you have had a chance to compare these libraries in terms of performance or capabilities please share your experience by opening an issue on github.Some of the unique features of ``wikitextparser`` are: Providing access to individual cells of each table, pretty-printing templates, a WikiList class with rudimentary methods to work with `lists &lt;https://www.mediawiki.org/wiki/Help:Lists&gt;`_, and a few other functions.Known issues and limitations============================* The contents of templates/parameters are not known to offline parsers. For example an offline parser cannot know if the markup ``[[{{z|a}}]]`` should be treated as wikilink or not, it depends on the inner-workings of the ``{{z}}`` template. In these situations ``wikitextparser`` tries to use a best guess. ``[[{{z|a}}]]`` is treated as a wikilink (why else would anyone call a template inside wikilink markup, and even if it is not a wikilink, usually no harm is done).* Localized namespace names are unknown, so for example ``[[File:...]]`` links are treated as normal wikilinks. ``mwparserfromhell`` has similar issue, see `#87 &lt;https://github.com/earwig/mwparserfromhell/issues/87&gt;`_ and `#136 &lt;https://github.com/earwig/mwparserfromhell/issues/136&gt;`_. As a workaround, `Pywikibot &lt;https://www.mediawiki.org/wiki/Manual:Pywikibot&gt;`_ can be used for determining the namespace.* `Linktrails &lt;https://www.mediawiki.org/wiki/Help:Links&gt;`_ are language dependant and are not supported. `Also not supported by mwparserfromhell &lt;https://github.com/earwig/mwparserfromhell/issues/82&gt;`_. However given the trail pattern and knowing that ``wikilink.span[1]`` is the ending position of a wikilink, it is possible to compute a WikiLink's linktrail.* Templates adjacent to external links are never considered part of the link. In reality, this depends on the contents of the template. Example: ``parse('http://example.com{{dead link}}').external_links[0].url == 'http://example.com'``* List of valid `extension tags &lt;https://www.mediawiki.org/wiki/Parser_extension_tags&gt;`_ depends on the extensions intalled on the wiki. The ``tags`` method currently only supports the ones on English Wikipedia. A configuration option might be added in the future to address this issue.* ``wikitextparser`` currently does not provide an `ast.walk &lt;https://docs.python.org/3/library/ast.html#ast.walk&gt;`_-like method yielding all descendant nodes.* `Parser functions &lt;https://www.mediawiki.org/wiki/Help:Extension:ParserFunctions&gt;`_ and `magic words &lt;https://www.mediawiki.org/wiki/Help:Magic_words&gt;`_ are not evaluated.Credits=======* `python &lt;https://www.python.org/&gt;`_* `regex &lt;https://github.com/mrabarnett/mrab-regex&gt;`_* `wcwidth &lt;https://github.com/jquast/wcwidth&gt;`_</longdescription>
</pkgmetadata>