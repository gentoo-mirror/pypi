<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Matching========.. image:: https://github.com/daffidwilde/matching/workflows/CI/CD/badge.svg    :target: https://github.com/daffidwilde/matching/actions?query=workflow%3ACI%2FCD+branch%3Amain.. image:: https://img.shields.io/badge/code%20style-black-000000.svg    :target: https://github.com/ambv/black.. image:: https://zenodo.org/badge/119597240.svg    :target: https://zenodo.org/badge/latestdoi/119597240.. image:: https://joss.theoj.org/papers/10.21105/joss.02169/status.svg    :target: https://doi.org/10.21105/joss.02169A package for solving matching games.-------------------------------------Matching games allow for the allocation of resources and partnerships in a fairway. Typically, a matching game is defined by two sets of players that each havepreferences over at least some of the elements of the other set. The objectiveof the game is then to find a mapping between the sets of players in whicheveryone is happy enough with their match.In Matching, we deal with four types of matching game:- the stable marriage problem (SM);- the hospital-resident assignment problem (HR);- the student-allocation problem (SA);- the stable roommates problem (SR).Installation------------Matching requires Python 3.5 or above, and relies only on `NumPy&lt;http://www.numpy.org/&gt;`_ for general use.The library is most easily installed using :code:`pip`::    $ python -m pip install matchingHowever, if you would like to install it from source then go ahead and clone theGitHub repo::    $ git clone https://github.com/daffidwilde/matching.git    $ cd matching    $ python setup.py installDocumentation-------------Full documentation (including tutorials and discussion material) is availablehere: `&lt;https://matching.readthedocs.io&gt;`_An academic paper on this library has been included in the Journal of OpenSource Software (JOSS) and is available here:`&lt;https://joss.theoj.org/papers/10.21105/joss.02169&gt;`_Playing a simple game---------------------With all games, Matching uses a ``Player`` class to represent the members of the&quot;applying&quot; party, i.e. residents and students. For HR and SA, there are specificclasses to represent the roles of ``Hospital``, ``Project`` and ``Supervisor``.Consider the following instance of SM which is represented on a bipartite graphwhere the suitors and reviewers are along the left and right respectively... image:: ./tex/stable_marriage.png   :align: center   :width: 10cmWe can construct these preferences using dictionaries:&gt;&gt;&gt; suitor_preferences = {...     &quot;A&quot;: [&quot;D&quot;, &quot;E&quot;, &quot;F&quot;], &quot;B&quot;: [&quot;D&quot;, &quot;F&quot;, &quot;E&quot;], &quot;C&quot;: [&quot;F&quot;, &quot;D&quot;, &quot;E&quot;]... }&gt;&gt;&gt; reviewer_preferences = {...     &quot;D&quot;: [&quot;B&quot;, &quot;C&quot;, &quot;A&quot;], &quot;E&quot;: [&quot;A&quot;, &quot;C&quot;, &quot;B&quot;], &quot;F&quot;: [&quot;C&quot;, &quot;B&quot;, &quot;A&quot;]... }Then to solve this matching game, we make use of the ``StableMarriage`` class,like so:&gt;&gt;&gt; from matching.games import StableMarriage&gt;&gt;&gt; game = StableMarriage.create_from_dictionaries(...     suitor_preferences, reviewer_preferences... )&gt;&gt;&gt; game.solve(){A: E, B: D, C: F}The ``Matching`` object+++++++++++++++++++++++This matching is not a standard Python dictionary, though it does largely lookand behave like one. It is in fact an instance of the ``SingleMatching`` class:&gt;&gt;&gt; matching = game.matching&gt;&gt;&gt; type(matching)&lt;class 'matching.matchings.SingleMatching'&gt;This dictionary-like object is primarily useful as a teaching device that easesthe process of manipulating a matching after a solution has been found. ``Player`` classes++++++++++++++++++Despite passing dictionaries of strings here, the matching displays instances of``matching.player.Player``:&gt;&gt;&gt; matching = game.matching&gt;&gt;&gt; for suitor in matching:...     print(type(suitor))&lt;class 'matching.players.player.Player'&gt;&lt;class 'matching.players.player.Player'&gt;&lt;class 'matching.players.player.Player'&gt;This is because ``create_from_dictionaries`` creates instances of theappropriate player classes first and passes them to the game class. Usingdictionaries like this can be an efficient way of creating large games but itdoes require the names of the players in each party to be unique.With all games, Matching uses a ``Player`` class to represent the members of the&quot;applying&quot; party, i.e. residents and students. For HR and SA, there are specificclasses to represent the roles of ``Hospital``, ``Project`` and ``Supervisor``.A note on performance---------------------One of the limitations of this library is the time complexities of the algorithmimplementations. In practical terms, the running time of any of the algorithmsin Matching is negligible but the theoretic complexity of each has not yet beenattained. For example, an instance of HR with 400 applicants and 20 hospitals issolved in less than one tenth of a second:&gt;&gt;&gt; from matching.games import HospitalResident&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.random.seed(0)&gt;&gt;&gt; num_residents, num_hospitals = 400, 20&gt;&gt;&gt; resident_prefs = {...     r: np.argsort(np.random.random(size=num_hospitals))...     for r in range(num_residents)... }&gt;&gt;&gt; hospital_prefs = {...     h: np.argsort(np.random.random(size=num_residents))...     for h in range(num_hospitals)... }&gt;&gt;&gt; capacities = {h: num_hospitals for h in hospital_prefs}&gt;&gt;&gt; game = HospitalResident.create_from_dictionaries(...     resident_prefs, hospital_prefs, capacities... )&gt;&gt;&gt; _ = game.solve() # 48.6 ms ± 963 µs per loopGet in contact!---------------I hope this package is useful, and feel free to contact me here (or on Twitter:`@daffidwilde &lt;https://twitter.com/daffidwilde&gt;`_) with any issues orrecommendations. Pull requests are always welcome!</longdescription>
</pkgmetadata>