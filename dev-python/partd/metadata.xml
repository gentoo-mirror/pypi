<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>PartD=====|Build Status| |Version Status|Key-value byte store with appendable values    Partd stores key-value pairs.    Values are raw bytes.    We append on old values.Partd excels at shuffling operations.Operations----------PartD has two main operations, ``append`` and ``get``.Example-------1.  Create a Partd backed by a directory::        &gt;&gt;&gt; import partd        &gt;&gt;&gt; p = partd.File('/path/to/new/dataset/')2.  Append key-byte pairs to dataset::        &gt;&gt;&gt; p.append({'x': b'Hello ', 'y': b'123'})        &gt;&gt;&gt; p.append({'x': b'world!', 'y': b'456'})3.  Get bytes associated to keys::        &gt;&gt;&gt; p.get('x')         # One key        b'Hello world!'        &gt;&gt;&gt; p.get(['y', 'x'])  # List of keys        [b'123456', b'Hello world!']4.  Destroy partd dataset::        &gt;&gt;&gt; p.drop()That's it.Implementations---------------We can back a partd by an in-memory dictionary::    &gt;&gt;&gt; p = Dict()For larger amounts of data or to share data between processes we back a partdby a directory of files.  This uses file-based locks for consistency.::    &gt;&gt;&gt; p = File('/path/to/dataset/')However this can fail for many small writes.  In these cases you may wish to buffer one partd with another, keeping a fixed maximum of data in the buffering partd.  This writes the larger elements of the first partd to the second partd when space runs low::    &gt;&gt;&gt; p = Buffer(Dict(), File(), available_memory=2e9)  # 2GB memory bufferYou might also want to have many distributed process write to a single partdconsistently.  This can be done with a server*   Server Process::        &gt;&gt;&gt; p = Buffer(Dict(), File(), available_memory=2e9)  # 2GB memory buffer        &gt;&gt;&gt; s = Server(p, address='ipc://server')*   Worker processes::        &gt;&gt;&gt; p = Client('ipc://server')  # Client machine talks to remote serverEncodings and Compression-------------------------Once we can robustly and efficiently append bytes to a partd we considercompression and encodings.  This is generally available with the ``Encode``partd, which accepts three functions, one to apply on bytes as they arewritten, one to apply to bytes as they are read, and one to join bytestreams.Common configurations already exist for common data and compression formats.We may wish to compress and decompress data transparently as we interact with apartd.  Objects like ``BZ2``, ``Blosc``, ``ZLib`` and ``Snappy`` exist and takeanother partd as an argument.::    &gt;&gt;&gt; p = File(...)    &gt;&gt;&gt; p = ZLib(p)These work exactly as before, the (de)compression happens automatically.Common data formats like Python lists, numpy arrays, and pandasdataframes are also supported out of the box.::    &gt;&gt;&gt; p = File(...)    &gt;&gt;&gt; p = NumPy(p)    &gt;&gt;&gt; p.append({'x': np.array([...])})This lets us forget about bytes and think instead in our normal data types.Composition-----------In principle we want to compose all of these choices together1.  Write policy:  ``Dict``, ``File``, ``Buffer``, ``Client``2.  Encoding:  ``Pickle``, ``Numpy``, ``Pandas``, ...3.  Compression:  ``Blosc``, ``Snappy``, ...Partd objects compose by nesting.  Here we make a partd that writes pickleencoded BZ2 compressed bytes directly to disk::    &gt;&gt;&gt; p = Pickle(BZ2(File('foo')))We could construct more complex systems that include compression,serialization, buffering, and remote access.::    &gt;&gt;&gt; server = Server(Buffer(Dict(), File(), available_memory=2e0))    &gt;&gt;&gt; client = Pickle(Snappy(Client(server.address)))    &gt;&gt;&gt; client.append({'x': [1, 2, 3]}).. |Build Status| image:: https://github.com/dask/partd/workflows/CI/badge.svg   :target: https://github.com/dask/partd/actions?query=workflow%3ACI.. |Version Status| image:: https://img.shields.io/pypi/v/partd.svg   :target: https://pypi.python.org/pypi/partd/</longdescription>
</pkgmetadata>