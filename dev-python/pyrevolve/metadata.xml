<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># CheckpointingThe adjoint computation of an unsteady nonlinear primal function requires thefull primal trajectory in reverse temporal order. Storing this can exceed theavailable memory. In that case, Checkpointing can be used to store the stateonly at carefully selected points in time. From there, the forward computationcan be restarted to recompute lost sections of the trajectory when they areneeded during the adjoint computation. This is always a tradeoff between memoryand runtime. The classic and provably optimal way to do this for a known numberof time steps is [Revolve](https://doi.org/10.1145/347837.347846), and there are other algorithms for optimal onlinecheckpointing if the number of steps is unknown a priori, or for multistagecheckpointing if there are multiple layers of storage, e.g. memory and harddrive.![Visual demo of checkpointing](https://raw.githubusercontent.com/opesci/pyrevolve/master/examples/checkpointing_demo.gif)# PyRevolveThe pyrevolve library contains two parts: crevolve, which is a thin Pythonwrapper around a previously published [C++ implementation](https://www.mathematik.hu-berlin.de/de/forschung/forschungsgebiete/mathematische-optimierung/andrea-walther/walther-software), and pyrevolveitself, which sits on top of crevolve and manages data and computationmanagement for the user.The C++ files in this package are slightly modified to play more nicely withPython, but the original is available from the link below. In addition, thereis a C wrapper around the C++ library, to simplify the interface with Python.This C wrapper is taken from [libadjoint](https://bitbucket.org/dolfin-adjoint/libadjoint).# InstallationSince PyRevolve is distributed as source, you must have a functional C/C++compiler in your environment before trying to install PyRevolve. Theinstallation procedure respects the standard environment variableslike CC/CXX.The simplest installation is through pip by simply doing:    pip install pyrevolveIf you would like to have a local development copy that you can edit,clone the repo and call the following command in the home directory:    pip install -e .If you face any installation issues, first check that you really dohave a functional C++ compiler, either available as `g++` in the pathor pointed to by the environment variable `CXX`. If this is not thereason, please raise a issue here or on[this](https://opesci-slackin.now.sh) Slack channel. # UsageThere are two wrappers: a _classic_ wrapper that follows the behaviour of Revolveas described in the papers, and leaves the data mangement, the actual copyingof data, and the calling of operators to the user. An example of how to use itcan be executed by calling    python examples/use_classic.py    The other, _modernised_ wrapper, takes care of all this. The user creates aRevolver object, and passes a forward operator, reverse operator, andcheckpoint operator to it. The Revolver provides two important methods:`apply_forward`, and `apply_reverse`. A call to `apply_forward` executes theforward computation, while creating the necessary checkpoints for the reversecomputation. After this, a user may also call the `apply_reverse` method tocompute the adjoints.For this to work, the user is responsible that the operators have an `apply()`method that takes arguments `t_start` and `t_end`, and that the checkpointobject has a property `size` to report the size of one checkpoint, and methods`load(ptr)` and `save(ptr)` that deep-copy all time-dependent live data intoa location given in `ptr`.An example of this can be found here:    python examples/use_modernised.py    </longdescription>
</pkgmetadata>