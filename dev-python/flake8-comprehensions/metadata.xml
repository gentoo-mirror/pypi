<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=====================flake8-comprehensions=====================.. image:: https://img.shields.io/github/actions/workflow/status/adamchainz/flake8-comprehensions/main.yml?branch=main&amp;style=for-the-badge   :target: https://github.com/adamchainz/flake8-comprehensions/actions?workflow=CI.. image:: https://img.shields.io/pypi/v/flake8-comprehensions.svg?style=for-the-badge   :target: https://pypi.org/project/flake8-comprehensions/.. image:: https://img.shields.io/badge/code%20style-black-000000.svg?style=for-the-badge   :target: https://github.com/psf/black.. image:: https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&amp;logoColor=white&amp;style=for-the-badge   :target: https://github.com/pre-commit/pre-commit   :alt: pre-commitA `flake8 &lt;https://flake8.readthedocs.io/en/latest/index.html&gt;`_ plugin that helps you write better list/set/dict comprehensions.Requirements============Python 3.7 to 3.11 supported.Installation============First, install with ``pip``:.. code-block:: sh     python -m pip install flake8-comprehensionsSecond, if you define Flake8’s ``select`` setting, add the ``C4`` prefix to it.Otherwise, the plugin should be active by default.----**Linting a Django project?**Check out my book `Boost Your Django DX &lt;https://adamchainz.gumroad.com/l/byddx&gt;`__ which covers Flake8 and many other code quality tools.----Rules=====C400-402: Unnecessary generator - rewrite as a ``&lt;list/set/dict&gt;`` comprehension.---------------------------------------------------------------------------------Rules:* C400 Unnecessary generator - rewrite as a list comprehension.* C401 Unnecessary generator - rewrite as a set comprehension.* C402 Unnecessary generator - rewrite as a dict comprehension.It's unnecessary to use ``list``, ``set``, or ``dict`` around a generator expression, since there are equivalent comprehensions for these types.For example:* Rewrite ``list(f(x) for x in foo)`` as ``[f(x) for x in foo]``* Rewrite ``set(f(x) for x in foo)`` as ``{f(x) for x in foo}``* Rewrite ``dict((x, f(x)) for x in foo)`` as ``{x: f(x) for x in foo}``C403-404: Unnecessary list comprehension - rewrite as a ``&lt;set/dict&gt;`` comprehension.-------------------------------------------------------------------------------------Rules:* C403 Unnecessary list comprehension - rewrite as a set comprehension.* C404 Unnecessary list comprehension - rewrite as a dict comprehension.It's unnecessary to use a list comprehension inside a call to ``set`` or ``dict``, since there are equivalent comprehensions for these types.For example:* Rewrite ``set([f(x) for x in foo])`` as ``{f(x) for x in foo}``* Rewrite ``dict([(x, f(x)) for x in foo])`` as ``{x: f(x) for x in foo}``C405-406: Unnecessary ``&lt;list/tuple&gt;`` literal - rewrite as a ``&lt;set/dict&gt;`` literal.-------------------------------------------------------------------------------------* C405 Unnecessary ``&lt;list/tuple&gt;`` literal - rewrite as a set literal.* C406 Unnecessary ``&lt;list/tuple&gt;`` literal - rewrite as a dict literal.It's unnecessary to use a list or tuple literal within a call to ``set`` or ``dict``.For example:* Rewrite ``set([1, 2])`` as ``{1, 2}``* Rewrite  ``set((1, 2))`` as ``{1, 2}``* Rewrite ``set([])`` as ``set()``* Rewrite ``dict([(1, 2)])`` as ``{1: 2}``* Rewrite ``dict(((1, 2),))`` as ``{1: 2}``* Rewrite ``dict([])`` as ``{}``C407: Unnecessary ``&lt;dict/list&gt;`` comprehension - ``&lt;builtin&gt;`` can take a generator------------------------------------------------------------------------------------This rule was dropped in version 3.4.0, because it promoted an increase in laziness which could lead to bugs.C408: Unnecessary ``&lt;dict/list/tuple&gt;`` call - rewrite as a literal.--------------------------------------------------------------------It's slower to call e.g. ``dict()`` than using the empty literal, because the name ``dict`` must be looked up in the global scope in case it has been rebound.Same for the other two basic types here.For example:* Rewrite ``dict()`` as ``{}``* Rewrite ``dict(a=1, b=2)`` as ``{&quot;a&quot;: 1, &quot;b&quot;: 2}``* Rewrite ``list()`` as ``[]``* Rewrite ``tuple()`` as ``()``C409-410: Unnecessary ``&lt;list/tuple&gt;`` passed to ``&lt;list/tuple&gt;``\() - ``&lt;advice&gt;``.------------------------------------------------------------------------------------Rules:* C409 Unnecessary ``&lt;list/tuple&gt;`` passed to tuple() - ``&lt;advice&gt;``.* C410 Unnecessary list passed to list() - ``&lt;advice&gt;``.Where ``&lt;advice&gt;`` is either:* remove the outer call to ``&lt;list/tuple&gt;``\()* rewrite as a ``&lt;list/tuple&gt;`` literalIt's unnecessary to use a list or tuple literal within a call to ``list`` or ``tuple``, since there is literal syntax for these types.For example:* Rewrite ``tuple([1, 2])`` as ``(1, 2)``* Rewrite ``tuple((1, 2))`` as ``(1, 2)``* Rewrite ``tuple([])`` as ``()``* Rewrite ``list([1, 2])`` as ``[1, 2]``* Rewrite ``list((1, 2))`` as ``[1, 2]``* Rewrite ``list([])`` as ``[]``C411: Unnecessary list call - remove the outer call to list().--------------------------------------------------------------It's unnecessary to use a ``list`` around a list comprehension, since it is equivalent without it.For example:* Rewrite ``list([f(x) for x in foo])`` as ``[f(x) for x in foo]``C412: Unnecessary ``&lt;dict/list/set&gt;`` comprehension - 'in' can take a generator.--------------------------------------------------------------------------------This rule was dropped in version 3.4.0, because it promoted an increase in laziness which could lead to bugs.C413: Unnecessary ``&lt;list/reversed&gt;`` call around sorted().-----------------------------------------------------------It's unnecessary to use ``list()`` around ``sorted()`` as it already returns a list.It is also unnecessary to use ``reversed()`` around ``sorted()`` as the latter has a ``reverse`` argument.For example:* Rewrite ``list(sorted([2, 3, 1]))`` as ``sorted([2, 3, 1])``* Rewrite ``reversed(sorted([2, 3, 1]))`` as ``sorted([2, 3, 1], reverse=True)``* Rewrite ``reversed(sorted([2, 3, 1], reverse=True))`` as ``sorted([2, 3, 1])``C414: Unnecessary ``&lt;list/reversed/set/sorted/tuple&gt;`` call within ``&lt;list/set/sorted/tuple&gt;``\().--------------------------------------------------------------------------------------------------It's unnecessary to double-cast or double-process iterables by wrapping the listed functions within ``list``/``set``/``sorted``/``tuple``.For example:* Rewrite ``list(list(iterable))`` as ``list(iterable)``* Rewrite ``list(tuple(iterable))`` as ``list(iterable)``* Rewrite ``tuple(list(iterable))`` as ``tuple(iterable)``* Rewrite ``tuple(tuple(iterable))`` as ``tuple(iterable)``* Rewrite ``set(set(iterable))`` as ``set(iterable)``* Rewrite ``set(list(iterable))`` as ``set(iterable)``* Rewrite ``set(tuple(iterable))`` as ``set(iterable)``* Rewrite ``set(sorted(iterable))`` as ``set(iterable)``* Rewrite ``set(reversed(iterable))`` as ``set(iterable)``* Rewrite ``sorted(list(iterable))`` as ``sorted(iterable)``* Rewrite ``sorted(tuple(iterable))`` as ``sorted(iterable)``* Rewrite ``sorted(sorted(iterable))`` as ``sorted(iterable)``* Rewrite ``sorted(reversed(iterable))`` as ``sorted(iterable)``C415: Unnecessary subscript reversal of iterable within ``&lt;reversed/set/sorted&gt;``\().-------------------------------------------------------------------------------------It's unnecessary to reverse the order of an iterable when passing it into one of the listed functions will change the order again.For example:* Rewrite ``set(iterable[::-1])`` as ``set(iterable)``* Rewrite ``sorted(iterable)[::-1]`` as ``sorted(iterable, reverse=True)``* Rewrite ``reversed(iterable[::-1])`` as ``iterable``C416: Unnecessary ``&lt;dict/list/set&gt;`` comprehension - rewrite using ``&lt;dict/list/set&gt;``\().-------------------------------------------------------------------------------------------It's unnecessary to use a dict/list/set comprehension to build a data structure if the elements are unchanged.Wrap the iterable with ``dict()``, ``list()``, or ``set()`` instead.For example:* Rewrite ``{a: b for a, b in iterable}`` as ``dict(iterable)``* Rewrite ``[x for x in iterable]`` as ``list(iterable)``* Rewrite ``{x for x in iterable}`` as ``set(iterable)``C417: Unnecessary ``map`` usage - rewrite using a generator expression/``&lt;list/set/dict&gt;`` comprehension.---------------------------------------------------------------------------------------------------------``map(func, iterable)`` has great performance when ``func`` is a built-in function, and it makes sense if your function already has a name.But if your func is a ``lambda``, it’s faster to use a generator expression or a comprehension, as it avoids the function call overhead.For example:* Rewrite ``map(lambda x: x + 1, iterable)`` to ``(x + 1 for x in iterable)``* Rewrite ``map(lambda item: get_id(item), items)`` to ``(get_id(item) for item in items)``* Rewrite ``list(map(lambda num: num * 2, nums))`` to ``[num * 2 for num in nums]``* Rewrite ``set(map(lambda num: num % 2 == 0, nums))`` to ``{num % 2 == 0 for num in nums}``* Rewrite ``dict(map(lambda v: (v, v ** 2), values))`` to ``{v : v ** 2 for v in values}``C418: Unnecessary ``&lt;dict/dict comprehension&gt;`` passed to dict() - remove the outer call to dict()--------------------------------------------------------------------------------------------------It's unnecessary to use a ``dict`` around a dict literal or dict comprehension, since either syntax already constructs a dict.For example:* Rewrite ``dict({})`` as ``{}``* Rewrite ``dict({&quot;a&quot;: 1})`` as ``{&quot;a&quot;: 1}``C419 Unnecessary list comprehension in ``&lt;any/all&gt;``\() prevents short-circuiting - rewrite as a generator.-----------------------------------------------------------------------------------------------------------Using a list comprehension inside a call to ``any()``/``all()`` prevents short-circuiting when a ``True`` / ``False`` value is found.The whole list will be constructed before calling ``any()``/``all()``, potentially wasting work.part-way.Rewrite to use a generator expression, which can stop part way.For example:* Rewrite ``all([condition(x) for x in iterable])`` as ``all(condition(x) for x in iterable)``* Rewrite ``any([condition(x) for x in iterable])`` as ``any(condition(x) for x in iterable)``</longdescription>
</pkgmetadata>