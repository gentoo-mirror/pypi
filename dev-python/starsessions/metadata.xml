<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>## StarsessionsAdvanced sessions for Starlette and FastAPI frameworks![PyPI](https://img.shields.io/pypi/v/starsessions)![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/alex-oleshkevich/starsessions/lint_and_test.yml?branch=master)![GitHub](https://img.shields.io/github/license/alex-oleshkevich/starsessions)![Libraries.io dependency status for latest release](https://img.shields.io/librariesio/release/pypi/starsessions)![PyPI - Downloads](https://img.shields.io/pypi/dm/starsessions)![GitHub Release Date](https://img.shields.io/github/release-date/alex-oleshkevich/starsessions)## InstallationInstall `starsessions` using PIP or poetry:```bashpip install starsessions# orpoetry add starsessions```Use `redis` extra for [Redis support](#redis).## Quick startSee example application in [`examples/`](examples) directory of this repository.## Usage1. Add `starsessions.SessionMiddleware` to your application to enable session support,2. Configure session store and pass it to the middleware,3. Load session in your view/middleware by calling `load_session(connection)` utility.```pythonfrom starlette.applications import Starlettefrom starlette.middleware import Middlewarefrom starlette.responses import JSONResponsefrom starlette.routing import Routefrom starsessions import CookieStore, load_session, SessionMiddlewareasync def index_view(request):    await load_session(request)    session_data = request.session    return JSONResponse(session_data)session_store = CookieStore(secret_key='TOP SECRET')app = Starlette(    middleware=[        Middleware(SessionMiddleware, store=session_store, lifetime=3600 * 24 * 14),    ],    routes=[        Route('/', index_view),    ])```### Cookie securityBy default, the middleware uses strict defaults.The cookie lifetime is limited to the browser session and sent via HTTPS protocol only.You can change these defaults by changing `cookie_https_only` and `lifetime` arguments:```pythonfrom starlette.middleware import Middlewarefrom starsessions import CookieStore, SessionMiddlewaresession_store = CookieStore(secret_key='TOP SECRET')middleware = [    Middleware(SessionMiddleware, store=session_store, cookie_https_only=False, lifetime=3600 * 24 * 14),]```The example above will let session usage over insecure HTTP transport and the session lifetime will be set to 14 days.### Loading sessionThe session data is not loaded by default. Call `load_session` to load data from the store.```pythonasync def index_view(request):    await load_session(request)    request.session['key'] = 'value'```However, if you try to access uninitialized session, `SessionNotLoaded` exception will be raised.```pythonasync def index_view(request):    request.session['key'] = 'value'  # raises SessionNotLoaded```You can automatically load session by using `SessionAutoloadMiddleware` middleware.### Session autoloadFor performance reasons session is not autoloaded by default. Sometimes it is annoying to call `load_session` too often.We provide `SessionAutoloadMiddleware` to reduce amount of boilerplate code by autoloading session for you.There are two options: always autoload or autoload for specific paths only.Here are examples:```pythonfrom starlette.middleware import Middlewarefrom starsessions import CookieStore, SessionAutoloadMiddleware, SessionMiddlewaresession_store = CookieStore(secret_key='TOP SECRET')# Always autoloadmiddleware = [    Middleware(SessionMiddleware, store=session_store),    Middleware(SessionAutoloadMiddleware),]# Autoload session for selected pathsmiddleware = [    Middleware(SessionMiddleware, store=session_store),    Middleware(SessionAutoloadMiddleware, paths=['/admin', '/app']),]# regex patterns also supportedimport readmin_rx = re.compile('/admin*')middleware = [    Middleware(SessionMiddleware, store=session_store),    Middleware(SessionAutoloadMiddleware, paths=[admin_rx]),]```### Rolling sessionsThe default behavior of `SessionMiddleware` is to expire cookie after `lifetime` seconds after it was set.For example, if you create a session with `lifetime=3600` then the session will be terminated exactly in 3600 seconds.Sometimes this may not be what you need, so we provide alternate expiration strategy - rolling sessions.When rolling sessions in use, the cookie expiration time will be extended by `lifetime` value on every response.Let's see how it works on example. First, on the first response you create a new session with `lifetime=3600`,then user does another request and session gets extended by another 3600 seconds and so on.This approach is useful when you want to have short-timed sessions but don't want them to interrupt in the middle ofuser's operation. With rolling strategy, session cookie will be expired only after some period of user's inactivity.To enable rolling strategy set `rolling=True`.```pythonfrom starlette.middleware import Middlewarefrom starsessions import SessionMiddlewaremiddleware = [    Middleware(SessionMiddleware, lifetime=300, rolling=True),]```The snippet above demonstrates an example setup where session will be dropped after 300 seconds (5 minutes) ofinactivity, but will be automatically extended by another 5 minutes while the user is online.### Cookie pathYou can pass `cookie_path` argument to bind session cookie to specific URLs. For example, to activate session cookieonly for admin area, use `cookie_path=&quot;/admin&quot;` middleware argument.```pythonfrom starlette.middleware import Middlewarefrom starsessions import SessionMiddlewaremiddleware = [    Middleware(SessionMiddleware, cookie_path='/admin'),]```All other URLs not matching value of `cookie_path` will not receive cookie thus session will be unavailable.### Cookie domainYou can also specify which hosts can receive a cookie by passing `cookie_domain` argument to the middleware.```pythonfrom starlette.middleware import Middlewarefrom starsessions import SessionMiddlewaremiddleware = [    Middleware(SessionMiddleware, cookie_domain='example.com'),]```&gt; Note, this makes session cookie available for subdomains too.&gt; For example, when you set `cookie_domain=example.com` then session cookie will be available on subdomains&gt; like `app.example.com`.### Session-only cookiesIf you want session cookie to automatically remove from tbe browser when tab closes then set `lifetime` to `0`.&gt; Note, this depends on browser implementation!```pythonfrom starlette.middleware import Middlewarefrom starsessions import SessionMiddlewaremiddleware = [    Middleware(SessionMiddleware, lifetime=0),]```## Built-in stores### MemoryClass: `starsessions.InMemoryStore`Simply stores data in memory. The data is cleared after server restart. Mostly for use with unit tests.### CookieStoreClass: `starsessions.CookieStore`Stores session data in a signed cookie on the client.### RedisClass: `starsessions.stores.redis.RedisStore`Stores session data in a Redis server. The store accepts either connection URL or an instance of `Redis`.&gt; Requires [redis-py](https://github.com/redis/redis-py),&gt; use `pip install starsessions[redis]` or `poetry add starsessions[redis]````pythonfrom redis.asyncio.utils import from_urlfrom starsessions.stores.redis import RedisStorestore = RedisStore('redis://localhost')# orredis = from_url('redis://localhost')store = RedisStore(connection=redis)```#### Redis key prefixBy default, all keys in Redis prefixed with `starsessions.`. If you want to change this use `prefix` argument.```pythonfrom starsessions.stores.redis import RedisStorestore = RedisStore(url='redis://localhost', prefix='my_sessions')```Prefix can be a callable:```pythonfrom starsessions.stores.redis import RedisStoredef make_prefix(key: str) -&gt; str:    return 'my_sessions_' + keystore = RedisStore(url='redis://localhost', prefix=make_prefix)```#### Key expirationThe library automatically manages key expiration, usually you have nothing to do with it.But for cases when `lifetime=0` we don't know when the session will over, and we have to heuristically calculate TTLotherwise the data will remain in Redis forever. At this moment, we just set 30 days TTL. You can change it bysetting `gc_ttl` value on the store.```pythonfrom starsessions.stores.redis import RedisStorestore = RedisStore(url='redis://localhost', gc_ttl=3600)  # max 1 hour```## Custom storeCreating new stores is quite simple. All you need is to extend `starsessions.SessionStore`class and implement abstract methods.Here is an example of how we can create a memory-based session store. Note, it is important that `write` methodreturns session ID as a string value.```pythonfrom typing import Dictfrom starsessions import SessionStore# instance of class which manages session persistenceclass InMemoryStore(SessionStore):    def __init__(self):        self._storage = {}    async def read(self, session_id: str, lifetime: int) -&gt; Dict:        &quot;&quot;&quot; Read session data from a data source using session_id. &quot;&quot;&quot;        return self._storage.get(session_id, {})    async def write(self, session_id: str, data: Dict, lifetime: int, ttl: int) -&gt; str:        &quot;&quot;&quot; Write session data into data source and return session id. &quot;&quot;&quot;        self._storage[session_id] = data        return session_id    async def remove(self, session_id: str):        &quot;&quot;&quot; Remove session data. &quot;&quot;&quot;        del self._storage[session_id]    async def exists(self, session_id: str) -&gt; bool:        return session_id in self._storage```### lifetime and ttlThe `write` accepts two special arguments: `lifetime` and `ttl`.The difference is that `lifetime` is a total session duration (set by the middleware)and `ttl` is a remaining session time. After `ttl` seconds the data can be safely deleted from the storage.&gt; Your custom backend has to correctly handle setups when `lifetime = 0`.In such cases you don't have exact expiration value, and you have to find a way how to extend session TTL at the storageside, if any.## SerializersThe library automatically serializes session data to string using JSON.By default, we use `starsessions.JsonSerializer` but you can implement your own by extending `starsessions.Serializer`class.```pythonimport jsonimport typingfrom starlette.middleware import Middlewarefrom starsessions import Serializer, SessionMiddlewareclass MySerializer(Serializer):    def serialize(self, data: typing.Any) -&gt; bytes:        return json.dumps(data).encode('utf-8')    def deserialize(self, data: bytes) -&gt; typing.Dict[str, typing.Any]:        return json.loads(data)middleware = [    Middleware(SessionMiddleware, serializer=MySerializer()),]```## Session terminationThe middleware will remove session data and cookie if session has no data. Use `request.session.clear` to empty data.## Regenerating session IDSometimes you need a new session ID to avoid session fixation attacks (for example, after successful signs in).For that, use `starsessions.session.regenerate_session_id(connection)` utility.```pythonfrom starsessions.session import regenerate_session_idfrom starlette.responses import Responsedef login(request):    regenerate_session_id(request)    return Response('successfully signed in')```</longdescription>
</pkgmetadata>