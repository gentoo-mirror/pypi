<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Cipher - trading strategy backtesting framework![Tests](https://github.com/nanvel/cipher-bt/actions/workflows/tests.yaml/badge.svg)- [Usage](#usage)  - [Development](#development)- [Disclaimer](#disclaimer)Documentation: https://cipher.nanvel.comFeatures:- well-structured, simple to use, extensible- multiple trading sessions at the same time- complex exit strategies can be implemented (trailing take profit, etc.)- multiple data sources support (multiple exchanges, symbols, timeframes, etc.)- signal generation and signal handlers are splitted- simple to run, just `python my_strategy.py`- works in [Google Colab](https://colab.research.google.com/)- [finplot](https://github.com/highfestiva/finplot) and [mplfinance](https://github.com/matplotlib/mplfinance) plotters- TA: [pandas-ta](https://github.com/twopirllc/pandas-ta) is included, you can still use your libraries of choice## UsageInitialize a new strategies folder and create a strategy:```shellpip install 'cipher-bt[finplot]'mkdir my_strategiescd my_strategiescipher initcipher new my_strategypython my_strategy.py```EMA crossover strategy example:```pythonimport numpy as npfrom cipher import Cipher, Session, Strategyclass EmaCrossoverStrategy(Strategy):    def __init__(self, fast_ema_length=9, slow_ema_length=21, trend_ema_length=200):        self.fast_ema_length = fast_ema_length        self.slow_ema_length = slow_ema_length        self.trend_ema_length = trend_ema_length    def compose(self):        df = self.datas.df        df[&quot;fast_ema&quot;] = df.ta.ema(length=self.fast_ema_length)        df[&quot;slow_ema&quot;] = df.ta.ema(length=self.slow_ema_length)        df[&quot;trend_ema&quot;] = df.ta.ema(length=self.trend_ema_length)        df[&quot;difference&quot;] = df[&quot;fast_ema&quot;] - df[&quot;slow_ema&quot;]        # signal columns have to be boolean type        df[&quot;entry&quot;] = np.sign(df[&quot;difference&quot;].shift(1)) != np.sign(df[&quot;difference&quot;])        df[&quot;max_6&quot;] = df[&quot;high&quot;].rolling(window=6).max()        df[&quot;min_6&quot;] = df[&quot;low&quot;].rolling(window=6).min()        return df    def on_entry(self, row: dict, session: Session):        if row[&quot;difference&quot;] &gt; 0 and row[&quot;close&quot;] &gt; row[&quot;trend_ema&quot;]:            # start a new long session            session.position += &quot;0.01&quot;            session.stop_loss = row[&quot;min_6&quot;]            session.take_profit = row[&quot;close&quot;] + 1.5 * (row[&quot;close&quot;] - row[&quot;min_6&quot;])        elif row[&quot;difference&quot;] &lt; 0 and row[&quot;close&quot;] &lt; row[&quot;trend_ema&quot;]:            # start a new short session            session.position -= &quot;0.01&quot;            session.stop_loss = row[&quot;max_6&quot;]            session.take_profit = row[&quot;close&quot;] - 1.5 * (row[&quot;max_6&quot;] - row[&quot;close&quot;])    # def on_&lt;signal&gt;(self, row: dict, session: Session) -&gt; None:    #     &quot;&quot;&quot;Custom signal handler, called for each open session.    #     We can adjust or close position or adjust brackets here.&quot;&quot;&quot;    #     # session.position = 1    #     # session.position = base(1)  # same as the one above    #     # session.position = '1'  # int, str, float are being converted to Decimal    #     # session.position = quote(100)  # sets position worth 100 quote asset    #     # session.position += 1  # adds to the position    #     # session.position -= Decimal('1.25')  # reduces position by 1.25    #     # session.position += percent(50)  # adds 50% more position    #     # session.position *= 1.5  # has the same effect as the one above    #     pass    #    # def on_take_profit(self, row: dict, session: Session) -&gt; None:    #     &quot;&quot;&quot;Called once take profit hit, default action - close position.    #     We can adjust the position and brackets here and let the session continue.&quot;&quot;&quot;    #     session.position = 0    #    # def on_stop_loss(self, row: dict, session: Session) -&gt; None:    #     &quot;&quot;&quot;Called once stop loss hit, default action - close position.    #     We can adjust the position and brackets here and let the session continue.&quot;&quot;&quot;    #     session.position = 0    #    # def on_stop(self, row: dict, session: Session) -&gt; None:    #     &quot;&quot;&quot;Called for each open session when the dataframe end reached.    #     We have an opportunity to close open sessions, otherwise - they will be ignored.&quot;&quot;&quot;    #     session.position = 0def main():    cipher = Cipher()    cipher.add_source(&quot;binance_spot_ohlc&quot;, symbol=&quot;BTCUSDT&quot;, interval=&quot;1h&quot;)    cipher.set_strategy(EmaCrossoverStrategy())    cipher.run(start_ts=&quot;2020-01-01&quot;, stop_ts=&quot;2020-04-01&quot;)    cipher.set_commission(&quot;0.0025&quot;)    print(cipher.sessions)    print(cipher.stats)    cipher.plot()if __name__ == &quot;__main__&quot;:    main()```![ema_crossover_plot](https://github.com/nanvel/cipher-bt/raw/master/docs/plotter.png)## Development```shellbrew install poetrypoetry installpoetry shellpytest testscipher --help```## DisclaimerThis software is for educational purposes only. Do not risk money which you are afraid to lose.USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS AND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS.</longdescription>
</pkgmetadata>