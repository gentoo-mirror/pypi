<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Storey[![CI](https://github.com/mlrun/storey/workflows/CI/badge.svg)](https://github.com/mlrun/storey/actions?query=workflow%3ACI)Storey is an asynchronous streaming library, for real time event processing and feature extraction.#### In This Document- [API Walkthrough](#api-walkthrough)- [Usage Examples](#examples)&amp;#x25B6; For more information, see the [Storey Python package documentation](https://storey.readthedocs.io).&lt;a id=&quot;api-walkthrough&quot;&gt;&lt;/a&gt;## API WalkthroughA Storey flow consist of steps linked together by the `build_flow` function, each doing it's designated work.### Supported Steps#### Input Steps* `SyncEmitSource` * `AsyncEmitSource` * `CSVSource`  * `ParquetSource` * `DataframeSource`  #### Processing Steps* `Filter` * `Map` * `FlatMap`* `MapWithState`* `Batch(max_events, timeout)` - Batches events. This step emits a batch every max_events events, or when timeout seconds have passed since the first event in the batch was received.* `Choice`  * `JoinWithV3IOTable` * `SendToHttp` * `AggregateByKey(aggregations,cache, key=None, emit_policy=EmitEveryEvent(), augmentation_fn=None)` - This step aggregates the data into the cache object provided for later persistence, and outputs an event enriched with the requested aggregation features.* `QueryByKey(features, cache, key=None, augmentation_fn=None, aliases=None)` - Similar to to `AggregateByKey`, but this step is for serving only and does not aggregate the event.* `NoSqlTarget(table)` - Persists the data in `table` to its associated storage by key.* `Extend`* `JoinWithTable`  #### Output Steps* `Complete`  * `Reduce` * `StreamTarget` * `CSVTarget`* `ReduceToDataFrame`* `TSDBTarget`* `ParquetTarget`     &lt;a id=&quot;examples&quot;&gt;&lt;/a&gt;## Usage Examples### Using AggregatesThe following example reads user data, creates features using Storey's aggregates, persists the data to V3IO and emits events containing the features to a V3IO Stream for further processing.```pythonfrom storey import build_flow, SyncEmitSource, Table, V3ioDriver, AggregateByKey, FieldAggregator, NoSqlTargetfrom storey.dtypes import SlidingWindowsv3io_web_api = &quot;https://webapi.change-me.com&quot;v3io_acceess_key = &quot;1284ne83-i262-46m6-9a23-810n41f169ea&quot;table_object = Table(&quot;/projects/my_features&quot;, V3ioDriver(v3io_web_api, v3io_acceess_key))def enrich(event, state):    if &quot;first_activity&quot; not in state:        state[&quot;first_activity&quot;] = event.time    event.body[&quot;time_since_activity&quot;] = (event.body[&quot;time&quot;] - state[&quot;first_activity&quot;]).seconds    state[&quot;last_event&quot;] = event.time    event.body[&quot;total_activities&quot;] = state[&quot;total_activities&quot;] = state.get(&quot;total_activities&quot;, 0) + 1    return event, statecontroller = build_flow([    SyncEmitSource(),    MapWithState(table_object, enrich, group_by_key=True, full_event=True),    AggregateByKey([FieldAggregator(&quot;number_of_clicks&quot;, &quot;click&quot;, [&quot;count&quot;],                                    SlidingWindows([&quot;1h&quot;,&quot;2h&quot;, &quot;24h&quot;], &quot;10m&quot;)),                    FieldAggregator(&quot;purchases&quot;, &quot;purchase_amount&quot;, [&quot;avg&quot;, &quot;min&quot;, &quot;max&quot;],                                    SlidingWindows([&quot;1h&quot;,&quot;2h&quot;, &quot;24h&quot;], &quot;10m&quot;)),                    FieldAggregator(&quot;failed_activities&quot;, &quot;activity&quot;, [&quot;count&quot;],                                    SlidingWindows([&quot;1h&quot;], &quot;10m&quot;),                                    aggr_filter=lambda element: element[&quot;activity_status&quot;] == &quot;fail&quot;))],                   table_object,                   time_field=&quot;time&quot;),    NoSqlTarget(table_object),    StreamTarget(V3ioDriver(v3io_web_api, v3io_acceess_key), &quot;features_stream&quot;)]).run()```We can also create a serving function, which sole purpose is to read data from the feature store and emit it further```pythoncontroller = build_flow([    SyncEmitSource(),    QueryAggregationByKey([FieldAggregator(&quot;number_of_clicks&quot;, &quot;click&quot;, [&quot;count&quot;],                                           SlidingWindows([&quot;1h&quot;,&quot;2h&quot;, &quot;24h&quot;], &quot;10m&quot;)),                           FieldAggregator(&quot;purchases&quot;, &quot;purchase_amount&quot;, [&quot;avg&quot;, &quot;min&quot;, &quot;max&quot;],                                           SlidingWindows([&quot;1h&quot;,&quot;2h&quot;, &quot;24h&quot;], &quot;10m&quot;)),                           FieldAggregator(&quot;failed_activities&quot;, &quot;activity&quot;, [&quot;count&quot;],                                           SlidingWindows([&quot;1h&quot;], &quot;10m&quot;),                                           aggr_filter=lambda element: element[&quot;activity_status&quot;] == &quot;fail&quot;))],                           table_object,                           time_field=&quot;time&quot;)]).run()```</longdescription>
</pkgmetadata>