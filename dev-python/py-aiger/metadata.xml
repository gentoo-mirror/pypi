<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;figure&gt;  &lt;img src=&quot;assets/logo_text.svg&quot; alt=&quot;py-aiger logo&quot; width=300px&gt;  &lt;figcaption&gt;      pyAiger: A python library for manipulating sequential and      combinatorial circuits.  &lt;/figcaption&gt;&lt;/figure&gt;[![Build Status](https://cloud.drone.io/api/badges/mvcisback/py-aiger/status.svg)](https://cloud.drone.io/mvcisback/py-aiger)[![codecov](https://codecov.io/gh/mvcisback/py-aiger/branch/master/graph/badge.svg)](https://codecov.io/gh/mvcisback/py-aiger)[![PyPI version](https://badge.fury.io/py/py-aiger.svg)](https://badge.fury.io/py/py-aiger)[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1405781.svg)](https://doi.org/10.5281/zenodo.1405781)&lt;!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again --&gt;**Table of Contents**- [About PyAiger](#about-pyaiger)- [Installation](#installation)- [Boolean Expression DSL](#boolean-expression-dsl)- [Sequential Circuit DSL](#sequential-circuit-dsl)    - [Sequential composition](#sequential-composition)    - [Parallel composition](#parallel-composition)    - [Circuits with Latches/Feedback/Delay](#circuits-with-latchesfeedbackdelay)    - [Relabeling](#relabeling)    - [Evaluation](#evaluation)    - [Useful circuits](#useful-circuits)- [Extra](#extra)- [Ecosystem](#ecosystem)- [Related Projects](#related-projects)- [Citing](#citing)&lt;!-- markdown-toc end --&gt;# About PyAiger1. Q: How is Py-Aiger pronounced? A: Like &quot;pie&quot; + &quot;grrr&quot;.2. Q: Why python? Aren't you worried about performance?! A: No. The goals of this library are ease of use and hackability. 3. Q: No, I'm really concerned about performance! A: This library is not suited to implement logic solvers. For everything else, such as the creation and manipulation of circuits with many thousands of gates in between solver calls, the library is really fast enough.4. Q: Where does the name come from? A: &lt;a href=&quot;http://fmv.jku.at/aiger/&quot;&gt;Aiger&lt;/a&gt; is a popular circuit format. The format is used in &lt;a href=&quot;http://fmv.jku.at/hwmcc17/&quot;&gt;hardware model checking&lt;/a&gt;, &lt;a href=&quot;http://www.syntcomp.org/&quot;&gt;synthesis&lt;/a&gt;, and is supported by &lt;a href=&quot;https://github.com/berkeley-abc/abc&quot;&gt;ABC&lt;/a&gt;. The name is a combination of AIG (standing for &lt;a href=&quot;https://en.wikipedia.org/wiki/And-inverter_graph&quot;&gt;And-Inverter-Graph&lt;/a&gt;) and the mountain &lt;a href=&quot;https://en.wikipedia.org/wiki/Eiger&quot;&gt;Eiger&lt;/a&gt;.# InstallationIf you just need to use `aiger`, you can just run:`$ pip install py-aiger`For developers, note that this project uses the[poetry](https://poetry.eustace.io/) python package/dependencymanagement tool. Please familarize yourself with it and thenrun:`$ poetry install`# Usage```import aigerx, y, z, w = aiger.atoms('x', 'y', 'z', 'w')expr1 = z.implies(x &amp; y)expr2 = z &amp; wcirc1 = expr1.with_output('z') \      # Get AIG for expr1 with output 'z'.             .aigcirc2 = circ1 &gt;&gt; circ2                # Feed outputs of circ1 into circ2.```# Boolean Expression DSLWhile powerful, when writing combinatorial circuits, the SequentialCircuit DSL can be somewhat clumsy. For this common usecase, we havedeveloped the Boolean Expression DSL. All circuits generated this wayhave a single output.```pythonimport aigerx, y, z = aiger.atoms('x', 'y', 'z')expr1 = x &amp; y  # circuit with inputs 'x', 'y' and 1 output computing x AND y.expr2 = x | y  # logical or.expr3 = x ^ y  # logical xor.expr4 = x == y  # logical ==, xnor.expr5 = x.implies(y)expr6 = ~x  # logical negation.expr7 = aiger.ite(x, y, z)  # if x then y else z.# Atoms can be constants.expr8 = x &amp; True  # Equivalent to just x.expr9 = x &amp; False # Equivalent to const False.# Specifying output name of boolean expression.# - Output is a long uuid otherwise.expr10 = expr5.with_output('x_implies_y')assert expr10.output == 'x_implies_y'# And you can inspect the AIG if needed.circ = x.aig# And of course, you can get a BoolExpr from a single output aig.expr10 = aiger.BoolExpr(circ)```# Sequential Circuit DSL```pythonimport aigerfrom aiger import utils# Parser for ascii AIGER format.aig1 = aiger.load(path_to_aig1_file.aag)aig2 = aiger.load(path_to_aig2_file.aag)```## Sequential composition```pythonaig3 = aig1 &gt;&gt; aig2```## Parallel composition```pythonaig4 = aig1 | aig2```## Circuits with Latches and Delayed FeedbackSometimes one requires some outputs to be feed back into the circuitsas time delayed inputs. This can be accomplished using the `loopback`method. This method takes in a variable number of dictionariesencoding how to wire an input to an output. The wiring dictionarieswith the following keys and default values:| Key         | Default | Meaning                          || ----------- | ------- | -------------------------------- || input       |         | Input port                       || output      |         | Output port                      || latch       | input   | Latch name                       || init        | True    | Initial latch value              || keep_output | True    | Keep loopbacked output as output |```python# Connect output y to input x with delay, initialized to True.# (Default initialization is False.)aig5 = aig1.loopback({  &quot;input&quot;: &quot;x&quot;, &quot;output&quot;: &quot;y&quot;,})aig6 = aig1.loopback({  &quot;input&quot;: &quot;x&quot;, &quot;output&quot;: &quot;y&quot;,}, {  &quot;input&quot;: &quot;z&quot;, &quot;output&quot;: &quot;z&quot;, &quot;latch&quot;: &quot;z_latch&quot;,  &quot;init&quot;: False, &quot;keep_outputs&quot;: False})```## RelabelingThere are two syntaxes for relabeling. The first uses indexingsyntax in a nod to [notation often used variable substition in math](https://mathoverflow.net/questions/243084/history-of-the-notation-for-substitution).The syntax is the relabel method, which is preferable when one wantsto be explicit, even for those not familar with `py-aiger`.```python# Relabel input 'x' to 'z'.aig1['i', {'x': 'z'}]aig1.relabel('input', {'x': 'z'})# Relabel output 'y' to 'w'.aig1['o', {'y': 'w'}]aig1.relabel('output', {'y': 'w'})# Relabel latches 'l1' to 'l2'.aig1['l', {'l1': 'l2'}]aig1.relabel('latch', {'l1': 'l2'})```## Evaluation```python# Combinatoric evaluation.aig3(inputs={'x':True, 'y':False})# Sequential evaluation.sim = aig3.simulate([{'x': 0, 'y': 0},                     {'x': 1, 'y': 2},                    {'x': 3, 'y': 4}])# Simulation Coroutinesim = aig3.simulator()  # Coroutinenext(sim)  # Initializeprint(sim.send({'x': 0, 'y': 0}))print(sim.send({'x': 1, 'y': 2}))print(sim.send({'x': 3, 'y': 4}))# Unrollaig4 = aig3.unroll(steps=10, init=True)```## Useful circuits```python# Fix input x to be False.aig4 = aiger.source({'x': False}) &gt;&gt; aig3# Remove output y. aig4 = aig3 &gt;&gt; aiger.sink(['y'])# Create duplicate w of output y.aig4 = aig3 &gt;&gt; aiger.tee({'y': ['y', 'w']})```# Extra```pythonaiger.common.eval_order(aig1)  # Returns topological ordering of circuit gates.# Convert object into an AIG from multiple formats including BoolExpr, AIG, str, and filepaths.aiger.to_aig(aig1)```# Ecosystem### Stable- [py-aiger-bv](https://github.com/mvcisback/py-aiger-bv): Extension of pyAiger for manipulating sequential bitvector circuits.- [py-aiger-cnf](https://github.com/mvcisback/py-aiger-cnf): BoolExpr to Object representing CNF. Mostly used for interfacing with py-aiger-sat.- [py-aiger-past-ltl](https://github.com/mvcisback/py-aiger-past-ltl): Converts Past Linear Temporal Logic to aiger circuits.- [py-aiger-coins](https://github.com/mvcisback/py-aiger-coins): Library for creating circuits that encode discrete distributions.- [py-aiger-sat](https://github.com/mvcisback/py-aiger-sat): Bridge between py-aiger and py-sat.- [py-aiger-bdd](https://github.com/mvcisback/py-aiger-bdd): Aiger &lt;-&gt; BDD bridge.- [py-aiger-gridworld](https://github.com/mvcisback/py-aiger-gridworld): Create aiger circuits representing gridworlds.- [py-aiger-dfa](https://pypi.org/project/py-aiger-dfa/): Convert between finite automata and sequential circuits.### Underdevelopment- [py-aiger-spectral](https://github.com/mvcisback/py-aiger-spectral): A tool for performing (Fourier) Analysis of Boolean Functions.- [py-aiger-abc](https://pypi.org/project/py-aiger-abc/): Aiger and abc bridge.# Related Projects- [pyAig](https://github.com/sterin/pyaig): Another python library  for working with AIGER circuits.</longdescription>
</pkgmetadata>