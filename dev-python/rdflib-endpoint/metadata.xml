<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;div align=&quot;center&quot;&gt;# üí´ SPARQL endpoint for RDFLib[![PyPI - Version](https://img.shields.io/pypi/v/rdflib-endpoint.svg?logo=pypi&amp;label=PyPI&amp;logoColor=silver)](https://pypi.org/project/rdflib-endpoint/)[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/rdflib-endpoint.svg?logo=python&amp;label=Python&amp;logoColor=silver)](https://pypi.org/project/rdflib-endpoint/)[![Test package](https://github.com/vemonet/rdflib-endpoint/actions/workflows/test.yml/badge.svg)](https://github.com/vemonet/rdflib-endpoint/actions/workflows/test.yml)[![Publish package](https://github.com/vemonet/rdflib-endpoint/actions/workflows/publish.yml/badge.svg)](https://github.com/vemonet/rdflib-endpoint/actions/workflows/publish.yml)[![Coverage Status](https://coveralls.io/repos/github/vemonet/rdflib-endpoint/badge.svg?branch=main)](https://coveralls.io/github/vemonet/rdflib-endpoint?branch=main)[![license](https://img.shields.io/pypi/l/rdflib-endpoint.svg?color=%2334D058)](https://github.com/vemonet/rdflib-endpoint/blob/main/LICENSE.txt)[![code style - black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![types - Mypy](https://img.shields.io/badge/types-mypy-blue.svg)](https://github.com/python/mypy)&lt;/div&gt;`rdflib-endpoint` is a SPARQL endpoint based on RDFLib to **easily serve RDF files locally**, machine learning models, or any other logic implemented in Python via **custom SPARQL functions**.It aims to enable python developers to easily deploy functions that can be queried in a federated fashion using SPARQL. For example: using a python function to resolve labels for specific identifiers, or run a classifier given entities retrieved using a `SERVICE` query to another SPARQL endpoint.&gt; Feel free to create an [issue](/issues), or send a pull request if you are facing issues or would like to see a feature implemented.## ‚ÑπÔ∏è How it works`rdflib-endpoint` can be used directly from the terminal to quickly serve RDF files through a SPARQL endpoint automatically deployed locally.It can also be used to define custom SPARQL functions: the user defines and registers custom SPARQL functions, and/or populate the RDFLib Graph using Python, then the endpoint is started using `uvicorn`/`gunicorn`.The deployed SPARQL endpoint can be used as a `SERVICE` in a federated SPARQL query from regular triplestores SPARQL endpoints. Tested on OpenLink Virtuoso (Jena based) and Ontotext GraphDB (RDF4J based). The endpoint is CORS enabled by default to enable querying it from client JavaScript (can be turned off).Built with [RDFLib](https://github.com/RDFLib/rdflib) and [FastAPI](https://fastapi.tiangolo.com/).## üì¶Ô∏è InstallationThis package requires Python &gt;=3.7, install it  from [PyPI](https://pypi.org/project/rdflib-endpoint/) with:```shellpip install rdflib-endpoint```The `uvicorn` and `gunicorn` dependencies are not included by default, if you want to install them use the optional dependency `web`:```bashpip install &quot;rdflib-endpoint[web]&quot;```If you want to use `rdlib-endpoint` as a CLI you can install with the optional dependency `cli`:```bashpip install &quot;rdflib-endpoint[cli]&quot;```If you want to use [oxigraph](https://github.com/oxigraph/oxigraph) as backend triplestore you can install with the optional dependency `oxigraph`:```bashpip install &quot;rdflib-endpoint[oxigraph,cli]&quot;```&gt; ‚ö†Ô∏è Oxigraph and `oxrdflib` do not support custom functions, so it can be only used to deploy graphs without custom functions.## ‚å®Ô∏è Use the CLI`rdflib-endpoint` can be used from the command line interface to perform basic utility tasks, such as serving or converting RDF files locally.Make sure you installed `rdflib-endpoint` with the `cli` optional dependencies:```bashpip install &quot;rdflib-endpoint[cli]&quot;```### ‚ö°Ô∏è Quickly serve RDF files through a SPARQL endpointUse `rdflib-endpoint` as a command line interface (CLI) in your terminal to quickly serve one or multiple RDF files as a SPARQL endpoint.You can use wildcard and provide multiple files, for example to serve all turtle, JSON-LD and nquads files in the current folder you could run:```bashrdflib-endpoint serve *.ttl *.jsonld *.nq```&gt; Then access the YASGUI SPARQL editor on http://localhost:8000If you installed with the Oxigraph optional dependency you can use it as backend triplestore, it is faster and supports some functions that are not supported by the RDFLib query engine (such as `COALESCE()`):```bashrdflib-endpoint serve --store Oxigraph &quot;*.ttl&quot; &quot;*.jsonld&quot; &quot;*.nq&quot;```### üîÑ Convert RDF files to another format`rdflib-endpoint` can also be used to quickly merge and convert files from multiple formats to a specific format:```bashrdflib-endpoint convert &quot;*.ttl&quot; &quot;*.jsonld&quot; &quot;*.nq&quot; --output &quot;merged.trig&quot;```## ‚ú® Deploy your SPARQL endpoint`rdflib-endpoint` enables you to easily define and deploy SPARQL endpoints based on RDFLib Graph, ConjunctiveGraph, and Dataset. Additionally it provides helpers to defines custom functions in the endpoint.Checkout the [`example`](https://github.com/vemonet/rdflib-endpoint/tree/main/example) folder for a complete working app example to get started, including a docker deployment. A good way to create a new SPARQL endpoint is to copy this `example` folder, and start from it.### üö® Deploy as a standalone APIDeploy your SPARQL endpoint as a standalone API:```pythonfrom rdflib import ConjunctiveGraphfrom rdflib_endpoint import SparqlEndpoint# Start the SPARQL endpoint based on a RDFLib Graph and register your custom functionsg = ConjunctiveGraph()# TODO: Add triples in your graph# Then use either SparqlEndpoint or SparqlRouter, they take the same argumentsapp = SparqlEndpoint(    graph=g,    path=&quot;/&quot;,    cors_enabled=True,    # Metadata used for the SPARQL service description and Swagger UI:    title=&quot;SPARQL endpoint for RDFLib graph&quot;,    description=&quot;A SPARQL endpoint to serve machine learning models, or any other logic implemented in Python. \n[Source code](https://github.com/vemonet/rdflib-endpoint)&quot;,    version=&quot;0.1.0&quot;,    public_url='https://your-endpoint-url/',    # Example query displayed in YASGUI default tab    example_query=&quot;&quot;&quot;PREFIX myfunctions: &lt;https://w3id.org/um/sparql-functions/&gt;SELECT ?concat ?concatLength WHERE {    BIND(&quot;First&quot; AS ?first)    BIND(myfunctions:custom_concat(?first, &quot;last&quot;) AS ?concat)}&quot;&quot;&quot;,    # Additional example queries displayed in additional YASGUI tabs    example_queries = {    &quot;Bio2RDF query&quot;: {        &quot;endpoint&quot;: &quot;https://bio2rdf.org/sparql&quot;,        &quot;query&quot;: &quot;&quot;&quot;SELECT DISTINCT * WHERE {    ?s a ?o .} LIMIT 10&quot;&quot;&quot;,    },    &quot;Custom function&quot;: {        &quot;query&quot;: &quot;&quot;&quot;PREFIX myfunctions: &lt;https://w3id.org/um/sparql-functions/&gt;SELECT ?concat ?concatLength WHERE {    BIND(&quot;First&quot; AS ?first)    BIND(myfunctions:custom_concat(?first, &quot;last&quot;) AS ?concat)}&quot;&quot;&quot;,    }})```Finally deploy this app using `uvicorn` (see below)### üõ£Ô∏è Deploy as a router to include in an existing APIDeploy your SPARQL endpoint as an `APIRouter` to include in an existing `FastAPI` API. The `SparqlRouter` constructor takes the same arguments as the `SparqlEndpoint`, apart from `enable_cors` which needs be enabled at the API level.```pythonfrom fastapi import FastAPIfrom rdflib import ConjunctiveGraphfrom rdflib_endpoint import SparqlRouterg = ConjunctiveGraph()sparql_router = SparqlRouter(    graph=g,    path=&quot;/&quot;,    # Metadata used for the SPARQL service description and Swagger UI:    title=&quot;SPARQL endpoint for RDFLib graph&quot;,    description=&quot;A SPARQL endpoint to serve machine learning models, or any other logic implemented in Python. \n[Source code](https://github.com/vemonet/rdflib-endpoint)&quot;,    version=&quot;0.1.0&quot;,    public_url='https://your-endpoint-url/',)app = FastAPI()app.include_router(sparql_router)```### üìù Define custom SPARQL functionsThis option makes it easier to define functions in your SPARQL endpoint, e.g. `BIND(myfunction:custom_concat(&quot;start&quot;, &quot;end&quot;) AS ?concat)`. It can be used with the `SparqlEndpoint` and `SparqlRouter` classes.Create a `app/main.py` file in your project folder with your custom SPARQL functions, and endpoint parameters:````pythonimport rdflibfrom rdflib import ConjunctiveGraphfrom rdflib.plugins.sparql.evalutils import _evalfrom rdflib_endpoint import SparqlEndpointdef custom_concat(query_results, ctx, part, eval_part):    &quot;&quot;&quot;Concat 2 strings in the 2 senses and return the length as additional Length variable    &quot;&quot;&quot;    # Retrieve the 2 input arguments    argument1 = str(_eval(part.expr.expr[0], eval_part.forget(ctx, _except=part.expr._vars)))    argument2 = str(_eval(part.expr.expr[1], eval_part.forget(ctx, _except=part.expr._vars)))    evaluation = []    scores = []    # Prepare the 2 result string, 1 for eval, 1 for scores    evaluation.append(argument1 + argument2)    evaluation.append(argument2 + argument1)    scores.append(len(argument1 + argument2))    scores.append(len(argument2 + argument1))    # Append the results for our custom function    for i, result in enumerate(evaluation):        query_results.append(eval_part.merge({            part.var: rdflib.Literal(result),            # With an additional custom var for the length            rdflib.term.Variable(part.var + 'Length'): rdflib.Literal(scores[i])        }))    return query_results, ctx, part, eval_part# Start the SPARQL endpoint based on a RDFLib Graph and register your custom functionsg = ConjunctiveGraph()# Use either SparqlEndpoint or SparqlRouter, they take the same argumentsapp = SparqlEndpoint(    graph=g,    path=&quot;/&quot;,    # Register the functions:    functions={        'https://w3id.org/um/sparql-functions/custom_concat': custom_concat    },    cors_enabled=True,    # Metadata used for the SPARQL service description and Swagger UI:    title=&quot;SPARQL endpoint for RDFLib graph&quot;,    description=&quot;A SPARQL endpoint to serve machine learning models, or any other logic implemented in Python. \n[Source code](https://github.com/vemonet/rdflib-endpoint)&quot;,    version=&quot;0.1.0&quot;,    public_url='https://your-endpoint-url/',    # Example queries displayed in the Swagger UI to help users try your function    example_query=&quot;&quot;&quot;PREFIX myfunctions: &lt;https://w3id.org/um/sparql-functions/&gt;SELECT ?concat ?concatLength WHERE {    BIND(&quot;First&quot; AS ?first)    BIND(myfunctions:custom_concat(?first, &quot;last&quot;) AS ?concat)}&quot;&quot;&quot;)````### ‚úíÔ∏è Or directly define the custom evaluationYou can also directly provide the custom evaluation function, this will override the `functions`.Refer to the [RDFLib documentation](https://rdflib.readthedocs.io/en/stable/_modules/examples/custom_eval.html) to define the custom evaluation function. Then provide it when instantiating the SPARQL endpoint:```pythonimport rdflibfrom rdflib.plugins.sparql.evaluate import evalBGPfrom rdflib.namespace import FOAF, RDF, RDFSdef custom_eval(ctx, part):    &quot;&quot;&quot;Rewrite triple patterns to get super-classes&quot;&quot;&quot;    if part.name == &quot;BGP&quot;:        # rewrite triples        triples = []        for t in part.triples:            if t[1] == RDF.type:                bnode = rdflib.BNode()                triples.append((t[0], t[1], bnode))                triples.append((bnode, RDFS.subClassOf, t[2]))            else:                triples.append(t)        # delegate to normal evalBGP        return evalBGP(ctx, triples)    raise NotImplementedError()app = SparqlEndpoint(    graph=g,    custom_eval=custom_eval)```### ü¶Ñ Run the SPARQL endpointYou can then run the SPARQL endpoint server from the folder where your script is defined with `uvicorn` on http://localhost:8000 (it is installed automatically when you install the `rdflib-endpoint` package)```bashuvicorn main:app --app-dir example/app --reload```&gt; Checkout in the `example/README.md` for more details, such as deploying it with docker.## üßëüíª DevelopmentThis section is for if you want to run the package in development, and get involved by making a code contribution.### üì•Ô∏è CloneClone the repository:```bashgit clone https://github.com/vemonet/rdflib-endpointcd rdflib-endpoint```### üê£ Install dependenciesInstall [Hatch](https://hatch.pypa.io), this will automatically handle virtual environments and make sure all dependencies are installed when you run a script in the project:```bashpipx install hatch```Install the dependencies in a local virtual environment (running this command is optional as `hatch` will automatically install and synchronize dependencies each time you run a script with `hatch run`):```bashhatch -v env create```### üöÄ Run example APIThe API will be automatically reloaded when the code is changed:```bashhatch run dev```Access the YASGUI interface at http://localhost:8000### ‚òëÔ∏è Run testsMake sure the existing tests still work by running the test suite and linting checks. Note that any pull requests to the fairworkflows repository on github will automatically trigger running of the test suite:```bashhatch run test```To display all `print()`:```bashhatch run test -s```You can also run the tests on multiple python versions:```bashhatch run all:test```### üßπ Code formattingThe code will be automatically formatted when you commit your changes using `pre-commit`. But you can also run the script to format the code yourself:```hatch run fmt```### ‚ôªÔ∏è Reset the environmentIn case you are facing issues with dependencies not updating properly you can easily reset the virtual environment with:```bashhatch env prune```### üè∑Ô∏è New release processThe deployment of new releases is done automatically by a GitHub Action workflow when a new release is created on GitHub. To release a new version:1. Make sure the `PYPI_TOKEN` secret has been defined in the GitHub repository (in Settings &gt; Secrets &gt; Actions). You can get an API token from PyPI at [pypi.org/manage/account](https://pypi.org/manage/account).2. Increment the `version` number following semantic versioning, select between `fix`, `minor`, or `major`:   ```bash   hatch version fix   ```3. Commit the new version, and create a new release on GitHub, which will automatically trigger the workflow to publish the new release to [PyPI](https://pypi.org/project/rdflib-endpoint/).You can also manually trigger the workflow from the Actions tab in your GitHub repository webpage if needed.## üìÇ Projects using rdflib-endpointHere are some projects using `rdflib-endpoint` to deploy custom SPARQL endpoints with python:* [The Bioregistry](https://bioregistry.io/), an open source, community curated registry, meta-registry, and compact identifier resolver.* [proycon/codemeta-server](https://github.com/proycon/codemeta-server), server for codemeta, in memory triple store, SPARQL endpoint and simple web-based visualisation for end-user</longdescription>
</pkgmetadata>