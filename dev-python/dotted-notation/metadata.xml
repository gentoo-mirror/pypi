<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># DottedSometimes you want to fetch data from a deeply nested data structure. Dotted notationhelps you do that.Let's say you have a dictionary containing a dictionary containing a list and you wishto fetch the ith value from that nested list.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; d = {'hi': {'there': [1, 2, 3]}}    &gt;&gt;&gt; dotted.get(d, 'hi.there[1]')    2## APIProbably the easiest thing to do is pydoc the api layer.    $ pydoc dotted.api### GetSee grammar discussion below about things you can do get data via dotted.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; dotted.get({'a': {'b': {'c': {'d': 'nested'}}}}, 'a.b.c.d')    'nested'### UpdateUpdate will mutate the object if it can.  It always returns the changed object though. Ifit's not mutable, then get via the return.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; l = []    &gt;&gt;&gt; t = ()    &gt;&gt;&gt; dotted.update(l, '[0]', 'hello')    ['hello']    &gt;&gt;&gt; l    ['hello']    &gt;&gt;&gt; dotted.update(t, '[0]', 'hello')    ('hello',)    &gt;&gt;&gt; t    ()    ```#### Update via patternYou can update all fields that match pattern given by either a wildcard OR regex.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; d = {'a': 'hello', 'b': {'bye'}}    &gt;&gt;&gt; dotted.update(d, '*', 'me')    {'a': 'me', 'b': 'me'}### RemoveYou can remove a field or do so only if it matches value.  For example,    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; d = {'a': 'hello', 'b': 'bye'}    &gt;&gt;&gt; dotted.remove(d, 'b')    {'a': 'hello'}    &gt;&gt;&gt; dotted.remove(d, 'a', 'bye')    {'a': 'hello'}#### Remove via patternSimilar to update, all patterns that match will be removed.  If you provide a value aswell, only the matched patterns that also match the value will be removed.### MatchUse to match a dotted-style pattern to a field.  Partial matching is on by default.  Youcan match via wildcard OR via regex.  Here's a regex example:    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; dotted.match('/a.+/', 'abced.b')    'abced.b'    &gt;&gt;&gt; dotted.match('/a.+/', 'abced.b', partial=False)With the `groups=True` parameter, you'll see how it was matched:    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; match('hello.*', 'hello.there.bye', groups=True)    ('hello.there.bye', ('hello', 'there.bye'))In the above example, `hello` matched to `hello` and `*` matched to `there.bye` (partialmatching is enabled by default).### ExpandYou may wish to _expand_ all fields that match a pattern in an object.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; d = {'hello': {'there': [1, 2, 3]}, 'bye': 7}    &gt;&gt;&gt; dotted.expand(d, '*')    ('hello', 'bye')    &gt;&gt;&gt; dotted.expand(d, '*.*')    ('hello.there',)    &gt;&gt;&gt; dptted.expand(d, '*.*[*]')    ('hello.there[0]', 'hello.there[1]', 'hello.there[2]')    &gt;&gt;&gt; dotted.expand(d, '*.*[1:]')    ('hello.there[1:]',)## GrammarDotted notation looks similar to python. Both _dot_ fields and _bracketed_ fieldsuse `keys()` and `__getitem__()` internally.  A _dot_ field expects to see adictionary-like object. A _slot_ field is biased towards sequences (like lists, tuples,and strs) but can act on dicts as well. Dotted also supports slicing notation as well astransforms discussed below.### Key fieldsA key field is expressed as `a` or part of a dotted expression, such as `a.b`.  Thegrammar parser is permissive for what can be in a key field.  Pretty much any non-reservedchar will match.  Note that key fields will only work on objects that have a `keys()`method.  Basically, they work with dictionary or dictionary-like objects.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; dotted.get({'a': {'b': 'hello'}}, 'a.b')    'hello'If the key field starts with a space or `-`, you should either quote it OR you may usea `\` as the first char.### Bracketed fieldsYou may also use bracket notation, such as `a[0]` which does a `__getitem__` at key 0.The parser prefers numeric types over string types (if you wish to look up a non-numericfield using brackets be sure to quote it).  Bracketed fields will work with pretty muchany object that can be looked up via `__getitem__`.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; dotted.get({'a': ['first', 'second', 'third']}, 'a[0]')    'first'    &gt;&gt;&gt; dotted.get({'a': {'b': 'hello'}}, 'a[&quot;b&quot;]')    'first'### Numeric typesThe parser will attempt to interpret a field numerically if it can, such as `field.1`will interpret the `1` part numerically.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; dotted.get({'7': 'me', 7: 'you'}, '7')    'you'### QuotingSometimes you need to quote a field which you can do by just putting the field in quotes.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; dotted.get({'has . in it': 7}, '&quot;has . in it&quot;')    7### The numericize `#` operatorNon-integer numeric fields may be interpreted incorrectly if they have decimal point. Tosolve, use the numerize operator `#` at the front of a quoted field, such as `#'123.45'`.This will coerce to a numeric type (e.g. float).    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; d = {'a': {1.2: 'hello', 1: {2: 'fooled you'}}}    &gt;&gt;&gt; dotted.get(d, 'a.1.2')    'fooled you'    &gt;&gt;&gt; dotted.get(d, 'a.#&quot;1.2&quot;')    'hello'### SlicingDotted slicing works like python slicing and all that entails.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; d = {'hi': {'there': [1, 2, 3]}, 'bye': {'there': [4, 5, 6]}}    &gt;&gt;&gt; dotted.get(d, 'hi.there[::2]')    [1, 3]    &gt;&gt;&gt; dotted.get(d, '*.there[1:]')    ([2, 3], [5, 6])### The append `+` operatorBoth bracketed fileds and slices support the '+' operator which refers to the end ofsequence. You may append an item or slice to the end a sequence.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; d = {'hi': {'there': [1, 2, 3]}, 'bye': {'there': [4, 5, 6]}}    &gt;&gt;&gt; dotted.update(d, '*.there[+]', 8)    {'hi': {'there': [1, 2, 3, 8]}, 'bye': {'there': [4, 5, 6, 8]}}    &gt;&gt;&gt; dotted.update(d, '*.there[+:]', [999])    {'hi': {'there': [1, 2, 3, 8, 999]}, 'bye': {'there': [4, 5, 6, 8, 999]}}### The append-unique `+?` operatorIf you want to update only _unique_ items to a list, you can use the `?`postfix.  This will ensure that it's only added once (see match-first below).    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; items = [1, 2]    &gt;&gt;&gt; dotted.update(items, '[+?]', 3)    [1, 2, 3]    &gt;&gt;&gt; dotted.update(items, '[+?]', 3)    [1, 2, 3]### The invert `-` operatorYou can invert the meaning of the notation by prefixing a `-`.  For example,to remove an item using `update`:    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; d = {'a': 'hello', 'b': 'bye'}    &gt;&gt;&gt; dotted.update(d, '-b', dotted.ANY)    {'a': 'hello'}    &gt;&gt;&gt; dotted.remove(d, '-b', 'bye again')    {'a': 'hello', 'b': 'bye again'}## PatternsYou may use dotted for pattern matching. You can match to wildcards or regularexpressions.  You'll note that patterns always return a tuple of matches.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; d = {'hi': {'there': [1, 2, 3]}, 'bye': {'there': [4, 5, 6]}}    &gt;&gt;&gt; dotted.get(d, '*.there[2]')    (3, 6)    &gt;&gt;&gt; dotted.get(d, '/h.*/.*')    ([1, 2, 3],)Dotted will return all values that match the pattern(s).### WildcardsThe wildcard pattern is `*`.  It will match anything.### Regular expressionsThe regex pattern is enclosed in slashes: `/regex/`. Note that if the field is a non-str,the regex pattern will internally match to its str representation.### The match-first operatoerYou can also postfix any pattern with a `?`.  This will return onlythe first match.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; d = {'hi': {'there': [1, 2, 3]}, 'bye': {'there': [4, 5, 6]}}    &gt;&gt;&gt; dotted.get(d, '*?.there[2]')    (3,)## TransformsYou can optionally add transforms to the end of dotted notation. These willbe applied on `get` and `update`. Transforms are separated by the `|` operatorand multiple may be chained together. Transforms may be parameterized usingthe `:` operator.    &gt;&gt;&gt; import dotted    &gt;&gt;&gt; d = [1, '2', 3]    &gt;&gt;&gt; dotted.get(d, '[1]')    '2'    &gt;&gt;&gt; dotted.get(d, '[1]|int')    2    &gt;&gt;&gt; dotted.get(d, '[0]|str:number=%d')    'number=1'You may register new transforms via either `register` or the `@transform`decorator. Look at transforms.py for preregistered.## Filters### The key-value filterYou may filter by key-value to narrow your result set.  You may use with __key__ or__bracketed__ fields.  Key-value fields may be disjunctively (OR) specified via the `,`delimiter.A key-value field on __key__ field looks like: `keyfield.key1=value1,key2=value2...`.This will return all key-value matches on a subordinate dict-like object.  For example,    &gt;&gt;&gt; d = {    ...    'a': {    ...         'id': 1,    ...         'hello': 'there',    ...     },    ...     'b': {    ...         'id': 2,    ...         'hello': 'there',    ...     },    ... }    &gt;&gt;&gt; dotted.get(d, '*.id=1')    ({'id': 1, 'hello': 'there'},)    &gt;&gt;&gt; dotted.get(d, '*.id=*')    ({'id': 1, 'hello': 'there'}, {'id': 2, 'hello': 'there'})A key-value field on a __bracketed__ field looks like: `[key1=value1,key2=value2...]`.This will return all items in a list that match key-value filter.  For example,    &gt;&gt;&gt; d = {    ...     'a': [{'id': 1, 'hello': 'there'}, {'id': 2, 'hello': 'there'}],    ...     'b': [{'id': 3, 'hello': 'there'}, {'id': 4, 'hello': 'bye'}],    ... }    &gt;&gt;&gt; dotted.get(d, 'a[hello=&quot;there&quot;][*].id')    (1, 2)    &gt;&gt;&gt; dotted.get(d, '*[hello=&quot;there&quot;][*].id')    r == (1, 2, 3)### The key-value first filterYou can have it match first by appending a `?` to the end of the filter.    &gt;&gt;&gt; d = {    ...     'a': [{'id': 1, 'hello': 'there'}, {'id': 2, 'hello': 'there'}],    ...     'b': [{'id': 3, 'hello': 'there'}, {'id': 4, 'hello': 'bye'}],    ... }    &gt;&gt;&gt; dotted.get(d, 'a[hello=&quot;there&quot;?]')    return [{'id': 1, 'hello': 'there'}]### Conjunction vs disjunctionTo _conjunctively_ connect filters use the `.` operator. Filters offer the ability to act_disjunctively_ as well by using the `,` operator.For example, given`*.key1=value1,key2=value2.key3=value3`. This will filter(`key1=value1` OR `key2=value2`) AND `key3=value3`.Note that this gives you the abilty to have a key filter multiple values, such as:`*.key1=value1,key2=value2`.</longdescription>
</pkgmetadata>