<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>PyAutoLens: Open-Source Strong Lensing======================================.. |nbsp| unicode:: 0xA0    :trim:.. |binder| image:: https://mybinder.org/badge_logo.svg   :target: https://mybinder.org/v2/gh/Jammy2211/autolens_workspace/HEAD.. |RTD| image:: https://readthedocs.org/projects/pyautolens/badge/?version=latest    :target: https://pyautolens.readthedocs.io/en/latest/?badge=latest    :alt: Documentation Status.. |Tests| image:: https://github.com/Jammy2211/PyAutoLens/actions/workflows/main.yml/badge.svg   :target: https://github.com/Jammy2211/PyAutoLens/actions.. |Build| image:: https://github.com/Jammy2211/PyAutoBuild/actions/workflows/release.yml/badge.svg   :target: https://github.com/Jammy2211/PyAutoBuild/actions.. |code-style| image:: https://img.shields.io/badge/code%20style-black-000000.svg    :target: https://github.com/psf/black.. |JOSS| image:: https://joss.theoj.org/papers/10.21105/joss.02825/status.svg   :target: https://doi.org/10.21105/joss.02825.. |arXiv| image:: https://img.shields.io/badge/arXiv-1708.07377-blue    :target: https://arxiv.org/abs/1708.07377|binder| |RTD| |Tests| |Build| |code-style| |JOSS| |arXiv|`Installation Guide &lt;https://pyautolens.readthedocs.io/en/latest/installation/overview.html&gt;`_ |`readthedocs &lt;https://pyautolens.readthedocs.io/en/latest/index.html&gt;`_ |`Introduction on Binder &lt;https://mybinder.org/v2/gh/Jammy2211/autolens_workspace/release?filepath=introduction.ipynb&gt;`_ |`HowToLens &lt;https://pyautolens.readthedocs.io/en/latest/howtolens/howtolens.html&gt;`_.. image:: https://github.com/Jammy2211/PyAutoLogo/blob/main/gifs/pyautolens.gif?raw=true  :width: 900When two or more galaxies are aligned perfectly down our line-of-sight, the background galaxy appears multiple times.This is called strong gravitational lensing and **PyAutoLens** makes it simple to model strong gravitational lenses.Getting Started---------------The following links are useful for new starters:- `The PyAutoLens readthedocs &lt;https://pyautolens.readthedocs.io/en/latest&gt;`_: including `an installation guide &lt;https://pyautolens.readthedocs.io/en/latest/installation/overview.html&gt;`_ and `overview of lens analysis features &lt;https://pyautolens.readthedocs.io/en/latest/overview/overview_1_lensing.html&gt;`_.- `The introduction Jupyter Notebook on Binder &lt;https://mybinder.org/v2/gh/Jammy2211/autolens_workspace/release?filepath=introduction.ipynb&gt;`_: try **PyAutoLens** in a web browser (without installation).- `The autolens_workspace GitHub repository &lt;https://github.com/Jammy2211/autolens_workspace&gt;`_: example scripts and the HowToLens Jupyter notebook lectures.Support-------Support for installation issues, help with lens modeling and using **PyAutoLens** is available by`raising an issue on the GitHub issues page &lt;https://github.com/Jammy2211/PyAutoLens/issues&gt;`_.We also offer support on the **PyAutoLens** `Slack channel &lt;https://pyautolens.slack.com/&gt;`_, where we also provide thelatest updates on **PyAutoLens**. Slack is invitation-only, so if you'd like to join sendan `email &lt;https://github.com/Jammy2211&gt;`_ requesting an invite.HowToLens---------For users less familiar with gravitational lensing, Bayesian inference and scientific analysisyou may wish to read through the **HowToLens** lectures. These teach you the basic principles of gravitational lensingand Bayesian inference, with the content pitched at undergraduate level and above.A complete overview of the lectures `is provided on the HowToLens readthedocs page &lt;https://pyautolens.readthedocs.io/en/latest/howtolens/howtolens.html&gt;`_API Overview------------Lensing calculations are performed in **PyAutoLens** by building a ``Tracer`` object from ``LightProfile``,``MassProfile`` and ``Galaxy`` objects. Below, we create a simple strong lens system where a redshift 0.5lens ``Galaxy`` with an ``Isothermal`` ``MassProfile`` lenses a background source at redshift 1.0 with an``Exponential`` ``LightProfile`` representing a disk... code-block:: python    import autolens as al    import autolens.plot as aplt    from astropy import cosmology as cosmo    &quot;&quot;&quot;    To describe the deflection of light by mass, two-dimensional grids of (y,x) Cartesian    coordinates are used.    &quot;&quot;&quot;    grid = al.Grid2D.uniform(        shape_native=(50, 50),        pixel_scales=0.05,  # &lt;- Conversion from pixel units to arc-seconds.    )    &quot;&quot;&quot;    The lens galaxy has an elliptical isothermal mass profile and is at redshift 0.5.    &quot;&quot;&quot;    mass = al.mp.Isothermal(        centre=(0.0, 0.0), ell_comps=(0.1, 0.05), einstein_radius=1.6    )    lens_galaxy = al.Galaxy(redshift=0.5, mass=mass)    &quot;&quot;&quot;    The source galaxy has an elliptical exponential light profile and is at redshift 1.0.    &quot;&quot;&quot;    disk = al.lp.Exponential(        centre=(0.3, 0.2),        ell_comps=(0.05, 0.25),        intensity=0.05,        effective_radius=0.5,    )    source_galaxy = al.Galaxy(redshift=1.0, disk=disk)    &quot;&quot;&quot;    We create the strong lens using a Tracer, which uses the galaxies, their redshifts    and an input cosmology to determine how light is deflected on its path to Earth.    &quot;&quot;&quot;    tracer = al.Tracer.from_galaxies(        galaxies=[lens_galaxy, source_galaxy],         cosmology = al.cosmo.Planck15()    )    &quot;&quot;&quot;    We can use the Grid2D and Tracer to perform many lensing calculations, for example    plotting the image of the lensed source.    &quot;&quot;&quot;    tracer_plotter = aplt.TracerPlotter(tracer=tracer, grid=grid)    tracer_plotter.figures_2d(image=True)With **PyAutoLens**, you can begin modeling a lens in minutes. The example below demonstrates a simple analysis whichfits the lens galaxy's mass with an ``Isothermal`` and the source galaxy's light with a ``Sersic``... code-block:: python    import autofit as af    import autolens as al    import autolens.plot as aplt    &quot;&quot;&quot;    Load Imaging data of the strong lens from the dataset folder of the workspace.    &quot;&quot;&quot;    dataset = al.Imaging.from_fits(        data_path=&quot;/path/to/dataset/image.fits&quot;,        noise_map_path=&quot;/path/to/dataset/noise_map.fits&quot;,        psf_path=&quot;/path/to/dataset/psf.fits&quot;,        pixel_scales=0.1,    )    &quot;&quot;&quot;    Create a mask for the imaging data, which we setup as a 3.0&quot; circle, and apply it.    &quot;&quot;&quot;    mask = al.Mask2D.circular(        shape_native=dataset.shape_native,        pixel_scales=dataset.pixel_scales,        radius=3.0    )    dataset = dataset.apply_mask(mask=mask)    &quot;&quot;&quot;    We model the lens galaxy using an elliptical isothermal mass profile and    the source galaxy using an elliptical sersic light profile.    To setup these profiles as model components whose parameters are free &amp; fitted for    we set up each Galaxy as a `Model` and define the model as a `Collection` of all galaxies.    &quot;&quot;&quot;    # Lens:    mass = af.Model(al.mp.Isothermal)    lens = af.Model(al.Galaxy, redshift=0.5, mass=lens_mass_profile)    # Source:    disk = af.Model(al.lp.Sersic)    source = af.Model(al.Galaxy, redshift=1.0, disk=disk)    # Overall Lens Model:    model = af.Collection(galaxies=af.Collection(lens=lens, source=source))    &quot;&quot;&quot;    We define the non-linear search used to fit the model to the data (in this case, Dynesty).    &quot;&quot;&quot;    search = af.DynestyStatic(name=&quot;search[example]&quot;, nlive=50)    &quot;&quot;&quot;    We next set up the `Analysis`, which contains the `log likelihood function` that the    non-linear search calls to fit the lens model to the data.    &quot;&quot;&quot;    analysis = al.AnalysisImaging(dataset=dataset)    &quot;&quot;&quot;    To perform the model-fit we pass the model and analysis to the search's fit method. This will    output results (e.g., dynesty samples, model parameters, visualization) to hard-disk.    &quot;&quot;&quot;    result = search.fit(model=model, analysis=analysis)    &quot;&quot;&quot;    The results contain information on the fit, for example the maximum likelihood    model from the Dynesty parameter space search.    &quot;&quot;&quot;    print(result.samples.max_log_likelihood())</longdescription>
</pkgmetadata>