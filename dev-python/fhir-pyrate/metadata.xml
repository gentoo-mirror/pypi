<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)[![Supported Python version](https://img.shields.io/badge/python-3.8+-blue.svg)](https://www.python.org/downloads/release/python-380/)[![Stable Version](https://img.shields.io/pypi/v/fhir-pyrate?label=stable)](https://pypi.org/project/fhir-pyrate/)[![Pre-release Version](https://img.shields.io/github/v/release/UMEssen/fhir-pyrate?label=pre-release&amp;include_prereleases&amp;sort=semver)](https://pypi.org/project/fhir-pyrate/#history)[![DOI](https://zenodo.org/badge/456893108.svg)](https://zenodo.org/badge/latestdoi/456893108)&lt;!-- PROJECT LOGO --&gt;&lt;br /&gt;&lt;div align=&quot;center&quot;&gt;  &lt;a href=&quot;https://github.com/UMEssen/FHIR-PYrate&quot;&gt;    &lt;img src=&quot;https://raw.githubusercontent.com/UMEssen/FHIR-PYrate/main/images/logo.svg&quot; alt=&quot;Logo&quot; width=&quot;440&quot; height=&quot;338&quot;&gt;  &lt;/a&gt;&lt;/div&gt;This package is meant to provide a simple abstraction to query and structure FHIR resources aspandas DataFrames. Want to use R instead? Try out [fhircrackr](https://github.com/POLAR-fhiR/fhircrackr)!There are four main classes:* [Ahoy](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/ahoy.py): Authenticate on the FHIR API([Example 1](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/1-simple-json-to-df.ipynb),[2](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/2-condition-to-imaging-study.ipynb)),at the moment only BasicAuth and token authentication are supported.* [Pirate](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/pirate.py): Extract and search for data via FHIR  API  ([Example 1](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/1-simple-json-to-df.ipynb),[2](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/2-condition-to-imaging-study.ipynb),[3](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/3-observation-for-condition.ipynb) &amp;[4](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/4-patients-for-diagnostic-report.ipynb)).* [Miner](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/miner.py): Search for keywords or phrases  within Diagnostic Report ([Example 4](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/4-patients-for-diagnostic-report.ipynb)).* [DicomDownloader](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/dicom_downloader.py): Download complete studies or  series ([Example 2](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/2-condition-to-imaging-study.ipynb)).**DISCLAIMER**:We have tried to add tests for some public FHIR servers. However, because of the quality andquantity of resources we could not test as much as we have tested with the local FHIR server atour institute. If there is anything in the code that only applies to our server, or you haveproblems with the authentication (or anything else really), please just create an issue or[email us](mailto:giulia.baldini@uk-essen.de).&lt;br /&gt;&lt;div align=&quot;center&quot;&gt;  &lt;img src=&quot;https://raw.githubusercontent.com/UMEssen/FHIR-PYrate/main/images/resources.svg&quot; alt=&quot;Resources&quot; width=&quot;630&quot; height=&quot;385&quot;&gt;&lt;/div&gt;&lt;!-- TABLE OF CONTENTS --&gt;Table of Contents:* [Install](https://github.com/UMEssen/FHIR-PYrate/#install)   * [Either Pip](https://github.com/UMEssen/FHIR-PYrate/#either-pip)   * [Or Within Poetry](https://github.com/UMEssen/FHIR-PYrate/#or-within-poetry)* [Run Tests](https://github.com/UMEssen/FHIR-PYrate/#run-tests)* [Explanations &amp;amp; Examples](https://github.com/UMEssen/FHIR-PYrate/#explanations--examples)   * [Ahoy](https://github.com/UMEssen/FHIR-PYrate/#ahoy)   * [Pirate](https://github.com/UMEssen/FHIR-PYrate/#pirate)      * [sail_through_search_space](https://github.com/UMEssen/FHIR-PYrate/#sail_through_search_space)      * [trade_rows_for_bundles](https://github.com/UMEssen/FHIR-PYrate/#trade_rows_for_bundles)      * [bundles_to_dataframe](https://github.com/UMEssen/FHIR-PYrate/#bundles_to_dataframe)      * [***_dataframe](https://github.com/UMEssen/FHIR-PYrate/#_dataframe)   * [Miner](https://github.com/UMEssen/FHIR-PYrate/#miner)   * [DicomDownloader](https://github.com/UMEssen/FHIR-PYrate/#dicomdownloader)* [Contributing](https://github.com/UMEssen/FHIR-PYrate/#contributing)* [Authors and acknowledgment](https://github.com/UMEssen/FHIR-PYrate/#authors-and-acknowledgment)* [License](https://github.com/UMEssen/FHIR-PYrate/#license)* [Project status](https://github.com/UMEssen/FHIR-PYrate/#project-status)## Install### Either PipThe package can be installed using PyPi```bashpip install fhir-pyrate```or using GitHub (always the newest version).```bashpip install git+https://github.com/UMEssen/FHIR-PYrate.git```These two commands only install the packages needed for **Pirate**. If you also want to use the **Miner** or the **DicomDownloader**, then you need to install them as extra dependencies with```bashpip install &quot;fhir-pyrate[miner]&quot; # only for minerpip install &quot;fhir-pyrate[downloader]&quot; # only for downloaderpip install &quot;fhir-pyrate[all]&quot; # for both```### Or Within PoetryWe can also use poetry for this same purpose. Using PyPi we need to run the following commands.```bashpoetry add fhir-pyratepoetry install```Whereas to add it from GitHub, we have different options, because until recently[poetry used to exclusively install from the master branch](https://github.com/python-poetry/poetry/issues/3366).Poetry 1.2.0a2+:```bashpoetry add git+https://github.com/UMEssen/FHIR-PYrate.gitpoetry install```For the previous versions you need to add the following line to your `pyproject.toml` file:```bashfhir-pyrate = {git = &quot;https://github.com/UMEssen/FHIR-PYrate.git&quot;, branch = &quot;main&quot;}```and then run```bashpoetry lock```Also in poetry, the above only installs the packages for **Pirate**. If you also want to use the **Miner** or the **DicomDownloader**, then you need to install them as extra dependencies with```bashpoetry add &quot;fhir-pyrate[miner]&quot; # only for minerpoetry add &quot;fhir-pyrate[downloader]&quot; # only for downloaderpoetry add &quot;fhir-pyrate[all]&quot; # for both```or by adding the following to your `pyproject.toml` file:```bashfhir-pyrate = {git = &quot;https://github.com/UMEssen/FHIR-PYrate.git&quot;, branch = &quot;main&quot;, extras = [&quot;all&quot;]}```## Run TestsWhen implementing new features, make sure that the existing ones have not been broken by using ourunit tests. First set the `FHIR_USER` and `FHIR_PASSWORD` environment variables with yourusername and password for the FHIR server and then run the tests.```bashpoetry run python -m unittest discover tests```If you implement a new feature, please add a small test for it in[tests](https://github.com/UMEssen/FHIR-PYrate/blob/main/tests). You canalso use the tests as examples.## Explanations &amp; ExamplesPlease look at the [examples](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples) folder for complete examples.### [Ahoy](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/ahoy.py)The **Ahoy** class is used to authenticate and is needed for the **Pirate** and**DicomDownloader** classes.```pythonfrom fhir_pyrate import Ahoy# Authorize via passwordauth = Ahoy(  username=&quot;your_username&quot;,  auth_method=&quot;password&quot;,  auth_url=&quot;auth-url&quot;, # Your URL for authentication  refresh_url=&quot;refresh-url&quot;, # Your URL to refresh the authentication token (if available))```We accept the following authentication methods:* **token**: Pass your already generated token as a constructor argument.* **password**: Enter your password via prompt.* **env**: Use the `FHIR_USER` and `FHIR_PASSWORD` environment variables (mostly used for  the unit tests). You can also change their names with the `change_environment_variable_name`  function.* **keyring**: To Be Implemented.### [Pirate](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/pirate.py)The **Pirate** can query any resource implemented within the FHIR API and is initialized asfollows:```pythonfrom fhir_pyrate import Pirateauth = ...# Init Piratesearch = Pirate(    auth=auth,    base_url=&quot;fhir-url&quot;, # e.g. &quot;http://hapi.fhir.org/baseDstu2&quot;    print_request_url=False, # If set to true, you will see all requests)```The Pirate functions do one of three things:1. They run the query and collect the resources and store them in a generator of bundles.   * `steal_bundles`: single process, no timespan to specify   * `sail_through_search_space`: multiprocess, divide&amp;conquer with many smaller timespans   * `trade_rows_for_bundles`: multiprocess, takes DataFrame as input and runs one query per row2. They take a generator of bundles and build a DataFrame.   * `bundles_to_dataframe`: multiprocess, builds the DataFrame from the bundles.3. They are wrapper that combine the functionalities of 1&amp;2, or that set some particular parameters.   * `steal_bundles_to_dataframe`: single process, executes `steal_bundles` and then runs `bundles_to_dataframe` on the result.   * `sail_through_search_space_to_dataframe`: multiprocess, executes `sail_through_search_space` and then runs `bundles_to_dataframe` on the result.   * `trade_rows_for_dataframe`: multiprocess, executes `trade_rows_for_bundles` and then runs `bundles_to_dataframe` on the result, it is also possible to add columns from the original DataFrame to the result| Name                                    | Type | Multiprocessing | DF Input? |        Output        ||:----------------------------------------|:----:|:---------------:|:---------:|:--------------------:|| steal_bundles                           |  1   |       No        |    No     | Generator of FHIRObj || sail_through_search_space               |  1   |       Yes       |    No     | Generator of FHIRObj || trade_rows_for_bundles                  |  1   |       Yes       |    Yes    | Generator of FHIRObj || bundles_to_dataframe                    |  2   |       Yes       |     /     |      DataFrame       || steal_bundles_to_dataframe              |  3   |       No        |    No     |      DataFrame       || sail_through_search_space_to_dataframe  |  3   |       Yes       |    No     |      DataFrame       || trade_rows_for_dataframe                |  3   |       Yes       |    Yes    |      DataFrame       |**CACHING**: It is also possible to cache the bundles using the `cache_folder` parameter.This unfortunately does not currently work with multiprocessing, but saves a lot of time if youneed to download a lot of data and you are always doing the same requests.You can also specify how long the cache should be valid with the `cache_expiry_time` parameter.Additionally, you can also specify whether the requests should be retried using the `retry_requests`parameter. There is an example of this in the docstrings of the Pirate class.A toy request for ImagingStudy:```pythonsearch = ...# Make the FHIR callbundles = search.sail_through_search_space_to_dataframe(    resource_type=&quot;ImagingStudy&quot;,    date_init=&quot;2021-04-01&quot;,    time_attribute_name=&quot;started&quot;,    request_params={      &quot;modality&quot;: &quot;CT&quot;,      &quot;_count&quot;: 5000,    })```The argument `request_params` is a dictionary that takes a string as key (the FHIR identifier) and anything as value.If the value is a list or tuple, then all values will be used to build the request to the FHIR API.`sail_through_search_space_to_dataframe` is a wrapper function that directly converts the result of`sail_through_search_space` into a DataFrame.#### [`sail_through_search_space`](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/pirate.py)The `sail_through_search_space` function uses the multiprocessing module to speed up some queries.The multiprocessing is done as follows:The time frame is divided into multiple time spans (as many as there are processes) and each smallertime frame is investigated simultaneously. This is why it is necessary to give a `date_init`and `date_end` param to the `sail_through_search_space` function.**Note** that if the `date_init` or `date_end` parameters are given as strings, they will be convertedto `datetime.datetime` objects, so any non specified parameters (month, day or time) will be assumedaccording to the `datetime` workflow, and then converted to string according to the `time_format`specified in the **Pirate** constructor.A problematic aspect of the resources is that the date in which the resource was acquired is definedusing different attributes. Also, some resources use a fixed date, other use a time period.You can specify the date attribute that you want to use with `time_attribute_name`.The resources where the date is based on a period (such as `Encounter` or `Procedure`) may causeduplicates in the multiprocessing because one entry may belong to multiple time spans that aregenerated. You can drop the ID duplicates once you have built a DataFrame with your data.#### [`trade_rows_for_bundles`](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/pirate.py)In case we already have an Excel sheet or CSV file with `fhir_patient_id`s or any otheridentifier), and we want to request resources based on thoseidentifiers we can use the function `trade_rows_for_bundles`:```pythonsearch = ...# DataFrame containing FHIR patient IDspatient_df = ...# Collect all imaging studies defined within df_reportsdr_bundles = search.trade_rows_for_bundles(  patient_df,  resource_type=&quot;DiagnosticReport&quot;,  request_params={&quot;_count&quot;: &quot;100&quot;, &quot;status&quot;: &quot;final&quot;},  df_constraints={&quot;subject&quot;: &quot;fhir_patient_id&quot;},)```We only have to define the `resource_type` and the constraints that we want to enforce from theDataFrame in `df_constraints`. This dictionary should contain pairs of (`fhir_identifier`,`identifier_column`) where `fhir_identifier` is the API search parameter and `identifier_column`is the column where the values that we want to search for are stored.Additionally, a system can be used to better identify the constraints of the DataFrame.For example, let us assume that we have a column of the DataFrame (called `loinc_code` thatcontains a bunch of different LOINC codes. Our `df_constraints` could look as follows:```df_constraints={&quot;code&quot;: (&quot;http://loinc.org&quot;, &quot;loinc_code&quot;)}```This function also uses multiprocessing, but differently from before, it will process the rowsof the DataFrame in parallel.#### [`bundles_to_dataframe`](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/pirate.py)The two functions described above return a generator of `FHIRObj` bundles which can then beconverted to a `DataFrame` using this function.The `bundles_to_dataframe` has three options on how to handle and extract the relevant informationfrom the bundles:1. Extract everything, in this case you can use the[`flatten_data`](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/util/bundle_processing_templates.py)function, which is already the default for `process_function`, so you do not actually need tospecify anything.```python# Create bundles with Piratesearch = ...bundles = ...# Convert the returned bundles to a dataframedf = search.bundles_to_dataframe(    bundles=bundles,)```2. Use a processing function where you define exactly which attributes are needed by iterating   through the entries and selecting the elements. The values that will be added to the   dictionary represent the columns of the DataFrame. For an example of when it might make sense   to do this, check [Example 3](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/3-patients-for-condition.ipynb).```pythonfrom typing import List, Dictfrom fhir_pyrate.util.fhirobj import FHIRObj# Create bundles with Piratesearch = ...bundles = ...def get_diagnostic_text(bundle: FHIRObj) -&gt; List[Dict]:    records = []    for entry in bundle.entry or []:        resource = entry.resource        records.append(            {                &quot;fhir_diagnostic_report_id&quot;: resource.id,                &quot;report_status&quot;: resource.text.status,                &quot;report_text&quot;: resource.text.div,            }        )    return records# Convert the returned bundles to a dataframedf = search.bundles_to_dataframe(    bundles=bundles,    process_function=get_diagnostic_text,)```3. Extract only part of the information using the `fhir_paths` argument. Here you can put a list   of string that follow the [FHIRPath](https://hl7.org/fhirpath/) standard. For this purpose, we   use the [fhirpath-py](https://github.com/beda-software/fhirpath-py) package, which uses the   [antr4](https://github.com/antlr/antlr4) parser. Additionally, you can use tuples like `(key,   fhir_path)`, where `key` will be the name of the column the information derived from that   FHIRPath will be stored.```python# Create bundles with Piratesearch = ...bundles = ...# Convert the returned bundles to a dataframedf = search.bundles_to_dataframe(    bundles=bundles,    fhir_paths=[&quot;id&quot;, (&quot;code&quot;, &quot;code.coding&quot;), (&quot;identifier&quot;, &quot;identifier[0].code&quot;)],)```**NOTE 1 on FHIR paths**: The standard also allows some primitive math operations such as modulus(`mod`) or integer division (`div`), and this may be problematic if there are fields of theresource that use these terms as attributes.It is actually the case in many generated [public FHIR resources](https://hapi.fhir.org/baseDstu2/DiagnosticReport/133015).In this case the term `text.div` cannot be used, and you should use a processing functioninstead (as in 2.).**NOTE 2 on FHIR paths**: Since it is possible to specify the column name with a tuple`(key, fhir_path)`, it is important to know that if a key is used multiple times for differentpieces of information but for the same resource, the field will be only filled with the firstoccurence that is not None.```pythondf = search.steal_bundles_to_dataframe(    resource_type=&quot;DiagnosticReport&quot;,    request_params={        &quot;_count&quot;: 1,        &quot;_include&quot;: &quot;DiagnosticReport:subject&quot;,    },    # CORRECT EXAMPLE    # In this case subject.reference is None for patient, so all patients will have their Patient.id    fhir_paths=[(&quot;patient&quot;, &quot;subject.reference&quot;), (&quot;patient&quot;, &quot;Patient.id&quot;)],    # And Patient.id is None for DiagnosticReport, so they will have their subject.reference    fhir_paths=[(&quot;patient&quot;, &quot;Patient.id&quot;), (&quot;patient&quot;, &quot;subject.reference&quot;)],    # WRONG EXAMPLE    # In this case, only the first code will be stored    fhir_paths=[(&quot;code&quot;, &quot;code.coding[0].code&quot;), (&quot;code&quot;, &quot;code.coding[1].code&quot;)],    # CORRECT EXAMPLE    # Whenever we are working with codes, it is usually better to use the `where` argument and    # to store the values using a meaningful name    fhir_paths=[        (&quot;code_abc&quot;, &quot;code.coding.where(system = 'ABC').code&quot;),        (&quot;code_def&quot;, &quot;code.coding.where(system = 'DEF').code&quot;),    ],    num_pages=1,)```#### [`***_dataframe`](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/pirate.py)The `steal_bundles_to_dataframe`, `sail_through_search_space_to_dataframe` and `trade_rows_for_dataframe`are facade functions which retrieve the bundles and then run `bundles_to_dataframe`.In `trade_rows_for_dataframe` you can also specify the `with_ref` parameter to also add theparameters specified in `df_constraints` as columns of the final DataFrame.You can find an example in [Example 3](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/3-patients-for-condition.ipynb).Additionally, you can specify the `with_columns` parameter, which can add any columns from the originalDataFrame. The columns can be either specified as a list of columns `[col1, col2, ...]` or as alist of tuples `[(new_name_for_col1, col1), (new_name_for_col2, col2), ...]`.Currently, whenever a column is completely empty (i.e., no resourceshave a corresponding value for that column), it is just removed from the DataFrame.This is to ensure that we output clean DataFrames when we are handling multiple resources.More on that in the following section.#### Note on Querying Multiple ResourcesNot all FHIR servers allow this (at least not the public ones that we have tried),but it is also possible to obtain multiple resources with just one query:```pythonsearch = ...result_dfs = search.steal_bundles_to_dataframe(    resource_type=&quot;ImagingStudy&quot;,    request_params={        &quot;_lastUpdated&quot;: &quot;ge2022-12&quot;,        &quot;_count&quot;: &quot;3&quot;,        &quot;_include&quot;: &quot;ImagingStudy:subject&quot;,    },    fhir_paths=[        &quot;id&quot;,        &quot;started&quot;,        (&quot;modality&quot;, &quot;modality.code&quot;),        (&quot;procedureCode&quot;, &quot;procedureCode.coding.code&quot;),        (            &quot;study_instance_uid&quot;,            &quot;identifier.where(system = 'urn:dicom:uid').value.replace('urn:oid:', '')&quot;,        ),        (&quot;series_instance_uid&quot;, &quot;series.uid&quot;),        (&quot;series_code&quot;, &quot;series.modality.code&quot;),        (&quot;numberOfInstances&quot;, &quot;series.numberOfInstances&quot;),        (&quot;family_first&quot;, &quot;name[0].family&quot;),        (&quot;given_first&quot;, &quot;name[0].given&quot;),    ],    num_pages=1,)```In this case, a dictionary of DataFrames is returned, where the keys are the resource types.You can then select the single dictionary by doing `result_dfs[&quot;ImagingStudy&quot;]`or `result_dfs[&quot;Patient&quot;]`.You can find an example of this in [Example 2](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/2-condition-to-imaging-study.ipynb)where the `ImagingStudy` resource is queried.In theory, it would be smarter to specify the resource name in front of the FHIRPaths,e.g. `ImagingStudy.series.uid` instead of `series.uid`, and for each DataFrame only return thecorresponding attributes.However, we do not want to force the user to always specify the resource type, and in the currentversion the DataFramescoming from multiple resources have the same columns, becausewe cannot filter which resource was actually intended.Currently, we solved this by just removing all columns that do not have any results.Which means however, that if you are actually requesting an attribute for a specific resource and itis not found, that that column will not appear.In the future, [we plan to do a smarter filtering of the FHIRPaths](https://github.com/UMEssen/FHIR-PYrate/issues/120),such that only the ones containingthe actual resource name are kept if the resource name is specified in the path,and that a column full of `None`s is obtained in case no resource type is specified.### [Miner](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/miner.py)&lt;br /&gt;&lt;div align=&quot;center&quot;&gt;  &lt;img src=&quot;https://raw.githubusercontent.com/UMEssen/FHIR-PYrate/main/images/miner.svg&quot; alt=&quot;Logo&quot; width=&quot;718&quot; height=&quot;230&quot;&gt;&lt;/div&gt;&lt;br /&gt;The **Miner** takes a DataFrame and searches it for a particular regular expressionwith the help of [SpaCy](https://spacy.io/).It is also possible to add a regular expression for the text that should be excluded.Please use a RegEx checker (e.g. [https://regex101.com/](https://regex101.com/)) to build yourregular expressions.```pythonfrom fhir_pyrate import Minerdf_diagnostic_reports = ...  # Get a DataFrame# Search for text where the word &quot;Tumor&quot; is presentminer = Miner(    target_regex=&quot;Tumor*&quot;,    decode_text=...# Here you can write a function that processes each single text (e.g. stripping, decoding))df_filtered = miner.nlp_on_dataframe(  df_diagnostic_reports,  text_column_name=&quot;report_text&quot;,  new_column_name=&quot;text_found&quot;)```### [DicomDownloader](https://github.com/UMEssen/FHIR-PYrate/blob/main/fhir_pyrate/dicom_downloader.py)At our institute we have a DicomWebAdapter app that can be used to download studies and seriesfrom the PACS system of our hospital. The DicomDownloader uses the[DicomWebClient](https://dicomweb-client.readthedocs.io/en/latest/usage.html) with a specificinternal URL for each PACS to connect and download the images.We could not find a public system that was offering anything similar, so this class has onlybeen tested on our internal FHIR server.In case you have questions or you would like some particular features to be able to use this atyour institute, please do not hesitate and contact us, or write a pull request!The **DicomDownloader** downloads a complete Study (StudyInstanceUID) or a specific series (StudyInstanceUID + SeriesInstanceUID).The relevant data can be downloaded either es DICOM (`.dcm`) or NIfTI (`.nii.gz`).In the NIfTI case there will be an  additional `.dcm` file to store some metadata.Using the function `download_data_from_dataframe` it is possible to download studies and seriesdirectly from the data of a given dataframe. The column that contain the study/seriesinformation can be specified. To have an example of how the DataFrame should look like, pleaserefer to [Example 2](https://github.com/UMEssen/FHIR-PYrate/blob/main/examples/2-condition-to-imaging-study.ipynb).A DataFrame will be returned which specifies the successfully downloaded Study/Series ID, thedeidentified IDs and the download folder name. Additionally, a DataFrame containing the failedstudies will also be returned, together with the kind of error and the traceback.```pythonfrom fhir_pyrate import DicomDownloaderauth = ...# Initialize the Study Downloader# Decide to download the data as NIfTis, set it to &quot;dicom&quot; for DICOMsdownloader = DicomDownloader(  auth=auth,  output_format=&quot;nifti&quot;,  dicom_web_url=DICOM_WEB_URL, # Specify a URL of your DICOM Web Adapter)# Get some studiesdf_studies = ...# Download the seriessuccessful_df, error_df = downloader.download_data_from_dataframe(  df_studies,  output_dir=&quot;out&quot;,  study_uid_col=&quot;study_instance_uid&quot;,  series_uid_col=&quot;series_instance_uid&quot;,  download_full_study=False, # If we download the entire study, series_instance_uid will not be used)```Additionally, it is also possible to use the `download_data` function to download a single study orseries given as parameter.In this case, the mapping information will be returned as a list of dictionaries that can be usedto build a mapping file.```python# Download only one series and get some download informationdownload_info = downloader.download_data(  study_uid=&quot;1.2.826.0.1.3680043.8.498.24222694654806877939684038520520717689&quot;,  series_uid=&quot;1.2.826.0.1.3680043.8.498.33463995182843850024561469634734635961&quot;,  output_dir=&quot;out&quot;,  save_metadata=True,)# Download only one full studydownload_info_study = downloader.download_data(  study_uid=&quot;1.2.826.0.1.3680043.8.498.24222694654806877939684038520520717689&quot;,  series_uid=None,  output_dir=&quot;out&quot;,  save_metadata=True,)```## Contributing&lt;!-- Thank you https://github.com/othneildrew/Best-README-Template --&gt;Contributions are what make the open source community such an amazing place to learn, inspire, and create.Any contributions you make are greatly appreciated.If you have a suggestion that would make this better, please fork the repo and create a pullrequest. You can also simply open an issue with the tag &quot;enhancement&quot;.1. Fork the Project2. Create your Feature Branch (git checkout -b feature/AmazingFeature)3. Commit your Changes (git commit -m 'Add some AmazingFeature')4. Push to the Branch (git push origin feature/AmazingFeature)5. Open a Pull Request## Authors and acknowledgmentThis package was developed by the [SHIP-AI group at the Institute for Artificial Intelligence in Medicine](https://ship-ai.ikim.nrw/).- [goku1110](https://github.com/goku1110): initial idea, development, logo &amp; figures- [giuliabaldini](https://github.com/giuliabaldini): development, tests, new featuresWe would like to thank [razorx89](https://github.com/razorx89), [butterpear](https://github.com/butterpear), [vkyprmr](https://github.com/vkyprmr), [Wizzzard93](https://github.com/Wizzzard93), [karzideh](https://github.com/karzideh) and [luckfamousa](https://github.com/luckfamousa) for their input, time and effort.## LicenseThis project is licenced under the [MIT Licence](LICENSE).## Project statusThe project is in active development.</longdescription>
</pkgmetadata>