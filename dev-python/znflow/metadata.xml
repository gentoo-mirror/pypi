<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![zincware](https://img.shields.io/badge/Powered%20by-zincware-darkcyan)](https://github.com/zincware)[![Coverage Status](https://coveralls.io/repos/github/zincware/ZnFlow/badge.svg?branch=main)](https://coveralls.io/github/zincware/ZnFlow?branch=main)[![PyPI version](https://badge.fury.io/py/znflow.svg)](https://badge.fury.io/py/znflow)[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/zincware/ZnFlow/HEAD)# ZnFlowThe `ZnFlow` package provides a basic structure for building computationalgraphs based on functions or classes. It is designed as a lightweightabstraction layer to- learn graph computing.- build your own packages on top of it.## Installation```shellpip install znflow```## Usage### Connecting FunctionsWith ZnFlow you can connect functions to each other by using the `@nodify`decorator. Inside the `znflow.DiGraph` the decorator will return a`FunctionFuture` object that can be used to connect the function to other nodes.The `FunctionFuture` object will also be used to retrieve the result of thefunction. Outside the `znflow.DiGraph` the function behaves as a normalfunction.```pythonimport znflow@znflow.nodifydef compute_mean(x, y):    return (x + y) / 2print(compute_mean(2, 8))# &gt;&gt;&gt; 5with znflow.DiGraph() as graph:    mean = compute_mean(2, 8)graph.run()print(mean.result)# &gt;&gt;&gt; 5with znflow.DiGraph() as graph:    n1 = compute_mean(2, 8)    n2 = compute_mean(13, 7)    n3 = compute_mean(n1, n2)graph.run()print(n3.result)# &gt;&gt;&gt; 7.5```### Connecting ClassesIt is also possible to connect classes. They can be connected either directly orvia class attributes. This is possible by returning `znflow.Connections` insidethe `znflow.DiGraph` context manager. Outside the `znflow.DiGraph` the classbehaves as a normal class.In the following example we use a dataclass, but it works with all Pythonclasses that inherit from `znflow.Node`.```pythonimport znflowimport dataclasses@znflow.nodifydef compute_mean(x, y):    return (x + y) / 2@dataclasses.dataclassclass ComputeMean(znflow.Node):    x: float    y: float    results: float = None    def run(self):        self.results = (self.x + self.y) / 2with znflow.DiGraph() as graph:    n1 = ComputeMean(2, 8)    n2 = compute_mean(13, 7)    # connecting classes and functions to a Node    n3 = ComputeMean(n1.results, n2)graph.run()print(n3.results)# &gt;&gt;&gt; 7.5```## Dask SupportZnFlow comes with support for [Dask](https://www.dask.org/) to run your graph:- in parallel.- through e.g. SLURM (see https://jobqueue.dask.org/en/latest/api.html).- with a nice GUI to track progress.All you need to do is install ZnFlow with Dask `pip install znflow[dask]`. Wecan then extend the example from above. This will run `n1` and `n2` in parallel.You can investigate the graph on the Dask dashboard (typicallyhttp://127.0.0.1:8787/graph or via the client object in Jupyter.)```pythonimport znflowimport dataclassesfrom dask.distributed import Client@znflow.nodifydef compute_mean(x, y):    return (x + y) / 2@dataclasses.dataclassclass ComputeMean(znflow.Node):    x: float    y: float    results: float = None    def run(self):        self.results = (self.x + self.y) / 2with znflow.DiGraph() as graph:    n1 = ComputeMean(2, 8)    n2 = compute_mean(13, 7)    # connecting classes and functions to a Node    n3 = ComputeMean(n1.results, n2)client = Client()deployment = znflow.deployment.Deployment(graph=graph, client=client)deployment.submit_graph()n3 = deployment.get_results(n3)print(n3)# &gt;&gt;&gt; ComputeMean(x=5.0, y=10.0, results=7.5)```We need to get the updated instance from the Dask worker via`Deployment.get_results`. Due to the way Dask works, an inplace update is notpossible. To retrieve the full graph, you can use`Deployment.get_results(graph.nodes)` instead.### Working with listsZnFlow supports some special features for working with lists. In the followingexample we want to `combine` two lists.```pythonimport znflow@znflow.nodifydef arange(size: int) -&gt; list:    return list(range(size))print(arange(2) + arange(3))&gt;&gt;&gt; [0, 1, 0, 1, 2]with znflow.DiGraph() as graph:    lst = arange(2) + arange(3)graph.run()print(lst.result)&gt;&gt;&gt; [0, 1, 0, 1, 2]```This functionality is restricted to lists. There are some further features thatallow combining `data: list[list]` by either using`data: list = znflow.combine(data)` which has an optional `attribute=None`argument to be used in the case of classes or you can simply use`data: list = sum(data, [])`.### Attributes AccessInside the `with znflow.DiGraph()` context manager, accessing class attributesyields `znflow.Connector` objects. Sometimes, it may be required to obtain theactual attribute value instead of a `znflow.Connector` object. It is notrecommended to run class methods inside the `with znflow.DiGraph()` contextmanager since it should be exclusively used for building the graph and not foractual computation.In the case of properties or other descriptor-based attributes, it might benecessary to access the actual attribute value. This can be achieved using the`znflow.get_attribute` method, which supports all features from `getattr` andcan be imported as such:```pythonfrom znflow import get_attribute as getattr```Here's an example of how to use `znflow.get_attribute`:```pythonimport znflowclass POW2(znflow.Node):    &quot;&quot;&quot;Compute the square of x.&quot;&quot;&quot;    x_factor: float = 0.5    results: float = None    _x: float = None    @property    def x(self):        return self._x    @x.setter    def x(self, value):        # using &quot;self._x = value * self.x_factor&quot; inside &quot;znflow.DiGraph()&quot; would run        # &quot;value * Connector(self, &quot;x_factor&quot;)&quot; which is not possible (TypeError)        # therefore we use znflow.get_attribute.        self._x = value * znflow.get_attribute(self, &quot;x_factor&quot;)    def run(self):        self.results = self.x**2with znflow.DiGraph() as graph:    n1 = POW2()    n1.x = 4.0graph.run()assert n1.results == 4.0```Instead, you can also use the `znflow.disable_graph` decorator / context managerto disable the graph for a specific block of code or the `znflow.Property` as adrop-in replacement for `property`.# Supported FrameworksZnFlow includes tests to ensure compatibility with:- &quot;Plain classes&quot;- `dataclasses`- `ZnInit`- `attrs`It is currently **not** compatible with pydantic. I don't know what pydanticdoes internally and wasn't able to find a workaround.</longdescription>
</pkgmetadata>