<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>============dictionaries============Python dictionary implementations&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;.. image:: https://img.shields.io/travis/pasztorpisti/py-dictionaries.svg?style=flat    :target: https://travis-ci.org/pasztorpisti/py-dictionaries    :alt: build.. image:: https://img.shields.io/codacy/grade/9920e31609734de8815aa995b70b96e7/master.svg?style=flat    :target: https://www.codacy.com/app/pasztorpisti/py-dictionaries    :alt: code quality.. image:: https://img.shields.io/coveralls/pasztorpisti/py-dictionaries/master.svg?style=flat    :target: https://coveralls.io/r/pasztorpisti/py-dictionaries?branch=master    :alt: coverage.. image:: https://img.shields.io/pypi/v/dictionaries.svg?style=flat    :target: https://pypi.python.org/pypi/dictionaries    :alt: pypi.. image:: https://img.shields.io/github/tag/pasztorpisti/py-dictionaries.svg?style=flat    :target: https://github.com/pasztorpisti/py-dictionaries    :alt: github.. image:: https://img.shields.io/github/license/pasztorpisti/py-dictionaries.svg?style=flat    :target: https://github.com/pasztorpisti/py-dictionaries/blob/master/LICENSE.txt    :alt: license: MIT.. contents::Quick overview==============- Attribute-style item access is provided by all dictionary classes of this library.- 5 dictionary implementations:  - Standard dictionaries with attribute-style item access and a smarter ``copy()`` method with update parameters:    - ``Dict``    - ``OrderedDict``  - Immutable/hashable versions of the previous two dictionaries:    - ``FrozenDict``    - ``FrozenOrderedDict``  - A wrapper that can be used to create a readonly view of another dictionary instance:    - ``ReadonlyDictProxy``Installation============.. code-block:: sh    pip install dictionariesAlternatively you can download the distribution from the following places:- https://pypi.python.org/pypi/dictionaries#downloads- https://github.com/pasztorpisti/py-dictionaries/releasesUsage=====Quick-starter-------------After installing the library you can import the dictionary classes the following way:.. code-block:: python    from dictionaries import Dict, OrderedDict, FrozenDict, FrozenOrderedDict, ReadonlyDictProxyTheir interface is as standard as possible so I assume you know how to deal with them.Attribute-style item access---------------------------The attribute-style dictionary item access can be really convenient in many cases but it has issues. The mostobvious issue is that the attributes of the dictionary are in conflict with your item keys.For this reason attribute-style access is a little bit &quot;stinky&quot; (especially when you try to implement it) andto aid this problem I've recently come up with a different kind of attribute-style access implementation. Thislibrary provides both the usual way (discussed here and there) and also my method. (Yes, I know that providing 2 ormore ways isn't pythonic but you have to experiment to find out what works and what doesn't...) Later I mightdrop one of them.&quot;Classic&quot; attribute-style dict item access (as people know it)..............................................................As mentioned previously the attributes of the dictionary instance (like ``copy``) conflict with the keys ofyour items. In order to be able to access dictionary methods we have to provide priority for the dictionaryattributes over the item keys... code-block:: python    &gt;&gt;&gt; from dictionaries import Dict    &gt;&gt;&gt; d = Dict(copy=True, name='example')    &gt;&gt;&gt; d.my_item = 5   # this is equivalent to d['my_item'] = 5    &gt;&gt;&gt; d    {'my_item': 5, 'name': 'example', 'copy': True}    &gt;&gt;&gt; d.my_item    5    &gt;&gt;&gt; d.name    'example'    &gt;&gt;&gt; d.copy          # the 'copy' item conflicts with the copy method!!!    &lt;bound method ExtendedCopyMixin.copy of {'my_item': 5, 'name': 'example', 'copy': True}&gt;Attribute-style item access through the ``items`` attribute of the dictionary.............................................................................My recent invention aids the previous conflict between dictionary attributes and item keys. By typinga little bit more you can use attribute-style access without worrying about conflicts:.. code-block:: python    &gt;&gt;&gt; from dictionaries import Dict    &gt;&gt;&gt; d = Dict(copy=True, name='example')    &gt;&gt;&gt; d.items.my_item = 5    &gt;&gt;&gt; d    {'my_item': 5, 'name': 'example', 'copy': True}    &gt;&gt;&gt; d.items.my_item    5    &gt;&gt;&gt; d.items.name    'example'    &gt;&gt;&gt; d.items.copy    True    &gt;&gt;&gt; d.items()       # using items() the good old way still works    dict_items([('my_item', 5), ('name', 'example'), ('copy', True)])You can use the ``items`` &quot;method&quot; of your dictionary the old way by calling it but you can also use it as anobject that provides attribute style access to your items. There are no conflicts because the only attributesof ``items`` are the keys of your dictionary items.Besides attribute-style item access the ``items`` attribute provides a limited set of the typical dictionary interface:- ``__contains__``, ``__iter__``, ``__len__``- Item assignment/retrieval/deletion with both attribute-style access and subscript notation.This can be useful if you have to pass around the ``items`` object to be accessed elsewhere... code-block:: python    &gt;&gt;&gt; from dictionaries import Dict    &gt;&gt;&gt; d = Dict(copy=True, name='example', my_item=5)    &gt;&gt;&gt; 'name' in d    True    &gt;&gt;&gt; iter(d.items)    &lt;dict_keyiterator object at 0x104254e08&gt;    &gt;&gt;&gt; list(d.items)    ['my_item', 'name', 'copy']    &gt;&gt;&gt; len(d.items)    3    &gt;&gt;&gt; del d.items['name']    &gt;&gt;&gt; del d.items.copy            # no conflict with Dict.copy :-)    &gt;&gt;&gt; d    {'my_item': 5}Dictionary classes==================``FrozenDict`` and ``FrozenOrderedDict``----------------------------------------These are &quot;frozen&quot;/immutable like the ``frozenset`` provided by the standard library. After creationtheir value doesn't change during their lifetime. Like other immutable objects, instances ofthese dictionaries are hashable given that all objects inside them are also hashable... code-block:: python    &gt;&gt;&gt; from dictionaries import FrozenDict    &gt;&gt;&gt; d = FrozenDict(item1=1, item2=2)    &gt;&gt;&gt; d['item3'] = 3      # we shouldn't be able to modify an immutable object    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;    TypeError: 'FrozenDict' object does not support item assignment    &gt;&gt;&gt; del d['item2']      # we shouldn't be able to modify an immutable object    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;    TypeError: 'FrozenDict' object does not support item deletion    &gt;&gt;&gt; d    &lt;FrozenDict {'item1': 1, 'item2': 2}&gt;    &gt;&gt;&gt; hash(d)    8310388587437647073``ReadonlyDictProxy``---------------------Sometimes you have to pass around some of your dictionaries but you want to make sure that no one modifies them. In thiscase what you should do is creating a ``ReadonlyDictProxy`` wrapper around your dictionary and passing around thewrapper instead of your original wrapped one. The ``ReadonlyDictProxy`` instance will delegate all requests to youroriginal dictionary except those requests that involve data modification (like item assignment/deletion, ``update()``,etc...). Of course if you  modify the wrapped dictionary then the users of the readonly proxy will notice the changes.The proxy keeps most of the behavior provided by the wrapped dict, for example if the wrapped dict is an ordered onethen the readonly proxy also behaves as ordered... code-block:: python    &gt;&gt;&gt; from dictionaries import ReadonlyDictProxy, OrderedDict    &gt;&gt;&gt; wrapped = OrderedDict.fromkeys(['item1', 'item2', 'item3'])    &gt;&gt;&gt; proxy = ReadonlyDictProxy(wrapped)    &gt;&gt;&gt; wrapped    OrderedDict([('item1', None), ('item2', None), ('item3', None)])    &gt;&gt;&gt; proxy    &lt;ReadonlyDictProxy OrderedDict([('item1', None), ('item2', None), ('item3', None)])&gt;Changes to the wrapped dict instance are reflected by the readonly proxy:.. code-block:: python    &gt;&gt;&gt; del wrapped['item3']    &gt;&gt;&gt; wrapped['new_item'] = 'brand new'    &gt;&gt;&gt; wrapped    OrderedDict([('item1', None), ('item2', None), ('new_item', 'brand new')])    &gt;&gt;&gt; proxy    &lt;ReadonlyDictProxy OrderedDict([('item1', None), ('item2', None), ('new_item', 'brand new')])&gt;Trying to modify the proxy object will fail:.. code-block:: python    &gt;&gt;&gt; proxy['trying hard'] = 'to assign'      # the proxy is readonly, assignment fails    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;    TypeError: 'ReadonlyDictProxy' object does not support item assignment    &gt;&gt;&gt; del proxy['item1']                      # the proxy is readonly, deletion fails    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;    TypeError: 'ReadonlyDictProxy' object does not support item deletionCopying a ``ReadonlyDictProxy`` instance with its ``copy`` method creates another``ReadonlyDictProxy`` instance that wraps the exact same object:.. code-block:: python    &gt;&gt;&gt; # Both of these statements create another wrapper/proxy around wrapped:    &gt;&gt;&gt; proxy_copy = proxy.copy()    &gt;&gt;&gt; proxy_copy2 = ReadonlyDictProxy(wrapped)    &gt;&gt;&gt;    &gt;&gt;&gt; # Now we have 3 proxy objects wrapping the same dictionary (wrapped):    &gt;&gt;&gt; wrapped.clear()    &gt;&gt;&gt; wrapped.items.woof = 'woof'    &gt;&gt;&gt; proxy    &lt;ReadonlyDictProxy OrderedDict([('woof', 'woof')])&gt;    &gt;&gt;&gt; proxy_copy    &lt;ReadonlyDictProxy OrderedDict([('woof', 'woof')])&gt;    &gt;&gt;&gt; proxy_copy2    &lt;ReadonlyDictProxy OrderedDict([('woof', 'woof')])&gt;Extended ``copy`` method------------------------All dictionary classes except ``ReadonlyDictProxy`` have a ``copy`` method that receives ``**kwargs``. Thesekeyword arguments are treated as dictionary items and used to create a copy that is updated with them... code-block:: python    &gt;&gt;&gt; from dictionaries import Dict    &gt;&gt;&gt; d = Dict(a=0, b=1)    &gt;&gt;&gt; d2 = d.copy(b=2, c=3)    &gt;&gt;&gt; d    {'a': 0, 'b': 1}    &gt;&gt;&gt; d2    {'a': 0, 'b': 2, 'c': 3}</longdescription>
</pkgmetadata>