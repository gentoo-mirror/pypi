<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pybotx-smart-logger_Shows logs when you need it_## Проблема/решениеВ основном наши боты работают в закрытых контурах. Там невозможно использовать Sentry,поэтому наш главный помощник в диагностике неполадок - логи контейнера.Однако, если сделать логи слишком подробными, то действительно важную информацию будеточень сложно найти. Также мы получим проблемы избыточного использования постояннойпамяти или слишком быструю ротацию логов. Но сделав логи слишком сжатыми, мы рискуемстолкнуться с ситуацией, когда их недостаточно для диагностики ошибки.То есть хочется видеть как можно больше информации во время возникновения ошибок, и какможно меньше - когда всё хорошо.## ИспользованиеИспользуя функцию `smart_log(log_message: str, *args: Any, **kwargs: Any)` логируете всюинформацию, которая поможет в диагностике ошибки. Если во время обработки сообщениябудет выброшено исключение, в логи попадёт:1. Текущее сообщение от пользователя,2. Вся залогированная с помощью `smart_log` информация,3. Выброшенное исключение.Если обработка сообщения завершится успешно, накопленные логи будут &quot;выброшены&quot;.## Настройка1. Устанавливаем библиотеку:  ```bashpoetry add pybotx-smart-logger```2. Подключим мидлварь для логирования входящих сообщений:**middlewares/smart_logger.py**```python #logger_init_middlewareasync def smart_logger_middleware(    message: IncomingMessage,    bot: Bot,    call_next: IncomingMessageHandlerFunc,) -&gt; None:    async with wrap_smart_logger(        log_source=&quot;Incoming message&quot;,        context_func=lambda: format_raw_command(message.raw_command),        debug=True,    ):        await call_next(message, bot)```**bot.py**```python #logger_init_botBot(    collectors=[collector],    bot_accounts=[BOT_CREDENTIALS],    middlewares=[        smart_logger_middleware,    ],)```3. Для того чтобы логировать какие-то другие части приложения, необходимо обернуть в контекстный менеджер:```python #logger_common_useasync def handler() -&gt; None:    async with wrap_smart_logger(        log_source=&quot;Request to Server&quot;,        context_func=lambda: str(kwargs),        debug=False,    ):        await make_request(**kwargs)```4.  Также можно использовать smart_logger для логирования запросов к FastAPI приложению:```python #logger_fastapi_useapp = FastAPI()@app.middleware(&quot;http&quot;)async def smart_logger_middleware(request: Request, call_next: Callable) -&gt; None:    async with wrap_smart_logger(        log_source=&quot;Incoming request&quot;,        context_func=lambda: pformat_str_request(request),        debug=DEBUG,    ):        return await call_next(request)````log_source` определяет источник логов. `context_func` - пользовательская функция для форматирования логов.## Пример команд для включения отладки```python #logger_debug_enable@collector.command(&quot;/_debug:enable-for-huids&quot;, visible=False)async def enable_debug_for_users(message: IncomingMessage, bot: Bot) -&gt; None:    try:        huids = [UUID(huid) for huid in message.arguments]    except ValueError:        await bot.answer_message(&quot;Получен невалидный user_huid&quot;)        return    # TODO: Обновите список user_huid    await bot.answer_message(f&quot;Список user_huid для отладки обновлён {huids}&quot;)``````python #logger_debug_enable_command@collector.command(&quot;/_debug:enable-for-tasks&quot;, visible=False)async def enable_debug_for_tasks(message: IncomingMessage, bot: Bot) -&gt; None:    # TODO: Обновите список имён задач    await bot.answer_message(&quot;Список задач для отладки обновлён&quot;)```## Группировка сообщений логераДля того, чтобы логи из разных хендлеров не перемешивались между собой и можно было удобно отследить весь порядок действия пользователя, можно включить группировку логов.```python #logger_groupasync def smart_logger_middleware(    message: IncomingMessage,    bot: Bot,    call_next: IncomingMessageHandlerFunc,) -&gt; None:    async with wrap_smart_logger(        log_source=&quot;Incoming message&quot;,        context_func=lambda: format_raw_command(message.raw_command),        debug=True,        group=True,  # Enable grouping    ):        await call_next(message, bot)```Теперь всё, что было залогировано через функцию `smart_log` будет &quot;выброшено&quot; толькопосле обработки сообщения и не будет перемешано с логами других сообщений.**Работает только с включенным `DEBUG`**## Где применять1. Проверка роли:```python #logger_check_role# TODO: Мидлварь для заполнения message.state.userasync def subscribed_users_only_middleware(    message: IncomingMessage,    bot: Bot,    call_next: IncomingMessageHandlerFunc,) -&gt; None:    if not message.state.user.is_subscribed:        await bot.send(message=only_subscribed_users_allowed_message(message))        return    smart_log(&quot;This user is subscribed&quot;)    await call_next(message, bot)```2. Обращение в API:```python #logger_api_callasync def _perform_request(    method: Literal[&quot;GET&quot;, &quot;POST&quot;],    url: str,    query_params: Optional[Dict[str, Any]] = None,    body_dict: Optional[Dict[str, Any]] = None,) -&gt; str:    smart_log(&quot;Performing request to YourAwesomeAPI&quot;)    smart_log(&quot;Method:&quot;, method)    smart_log(&quot;URL:&quot;, url)    smart_log(&quot;Query parameters:&quot;, query_params)    smart_log(&quot;Body dict:&quot;, body_dict)    try:        async with AsyncClient(base_url=base_url) as client:            response = await client.request(                method,                url,                params=query_params,                json=body_dict,            )    except HTTPError as exc:        raise RequestToAwesomeAPIError from exc    smart_log(&quot;Response text:&quot;, response.text)    try:        response.raise_for_status()    except HTTPStatusError as exc:  # noqa: WPS440        raise InvalidStatusCodeFromAwesomeAPIError from exc    return response.text```А также любые моменты, где что-то может пойти не так. Логируйте - не стестяйтесь.</longdescription>
</pkgmetadata>