<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>python-pulse-control (pulsectl module)======================================Python (3.x and 2.x) blocking high-level interface and ctypes-based bindingsfor PulseAudio_ (libpulse), to use in a simple synchronous code.Wrappers are mostly for mixer-like controls and introspection-related operations,as opposed to e.g. submitting sound samples to play and player-like client.For async version to use with asyncio_, see `pulsectl-asyncio`_ project instead.Originally forked from pulsemixer_ project, which had this code bundled... _PulseAudio: https://wiki.freedesktop.org/www/Software/PulseAudio/.. _asyncio: https://docs.python.org/3/library/asyncio.html.. _pulsectl-asyncio: https://pypi.org/project/pulsectl-asyncio/.. _pulsemixer: https://github.com/GeorgeFilipkin/pulsemixer/|.. contents::  :backlinks: noneUsage-----Simple example::  import pulsectl  with pulsectl.Pulse('volume-increaser') as pulse:    for sink in pulse.sink_list():      # Volume is usually in 0-1.0 range, with &gt;1.0 being soft-boosted      pulse.volume_change_all_chans(sink, 0.1)Listening for server state change events::  import pulsectl  with pulsectl.Pulse('event-printer') as pulse:    # print('Event types:', pulsectl.PulseEventTypeEnum)    # print('Event facilities:', pulsectl.PulseEventFacilityEnum)    # print('Event masks:', pulsectl.PulseEventMaskEnum)    def print_events(ev):      print('Pulse event:', ev)      ### Raise PulseLoopStop for event_listen() to return before timeout (if any)      # raise pulsectl.PulseLoopStop    pulse.event_mask_set('all')    pulse.event_callback_set(print_events)    pulse.event_listen(timeout=10)Misc other tinkering::  &gt;&gt;&gt; import pulsectl  &gt;&gt;&gt; pulse = pulsectl.Pulse('my-client-name')  &gt;&gt;&gt; pulse.sink_list()  [&lt;PulseSinkInfo at 7f85cfd053d0 - desc='Built-in Audio', index=0L, mute=0, name='alsa-speakers', channels=2, volumes='44.0%, 44.0%'&gt;]  &gt;&gt;&gt; pulse.sink_input_list()  [&lt;PulseSinkInputInfo at 7fa06562d3d0 - index=181L, mute=0, name='mpv Media Player', channels=2, volumes='25.0%, 25.0%'&gt;]  &gt;&gt;&gt; pulse.sink_input_list()[0].proplist  {'application.icon_name': 'mpv',   'application.language': 'C',   'application.name': 'mpv Media Player',   ...   'native-protocol.version': '30',   'window.x11.display': ':1.0'}  &gt;&gt;&gt; pulse.source_list()  [&lt;PulseSourceInfo at 7fcb0615d8d0 - desc='Monitor of Built-in Audio', index=0L, mute=0, name='alsa-speakers.monitor', channels=2, volumes='100.0%, 100.0%'&gt;,   &lt;PulseSourceInfo at 7fcb0615da10 - desc='Built-in Audio', index=1L, mute=0, name='alsa-mic', channels=2, volumes='100.0%, 100.0%'&gt;]  &gt;&gt;&gt; sink = pulse.sink_list()[0]  &gt;&gt;&gt; pulse.volume_change_all_chans(sink, -0.1)  &gt;&gt;&gt; pulse.volume_set_all_chans(sink, 0.5)  &gt;&gt;&gt; pulse.server_info().default_sink_name  'alsa_output.pci-0000_00_14.2.analog-stereo'  &gt;&gt;&gt; pulse.default_set(sink)  &gt;&gt;&gt; card = pulse.card_list()[0]  &gt;&gt;&gt; card.profile_list  [&lt;PulseCardProfileInfo at 7f02e7e88ac8 - description='Analog Stereo Input', n_sinks=0, n_sources=1, name='input:analog-stereo', priority=60&gt;,   &lt;PulseCardProfileInfo at 7f02e7e88b70 - description='Analog Stereo Output', n_sinks=1, n_sources=0, name='output:analog-stereo', priority=6000&gt;,   ...   &lt;PulseCardProfileInfo at 7f02e7e9a4e0 - description='Off', n_sinks=0, n_sources=0, name='off', priority=0&gt;]  &gt;&gt;&gt; pulse.card_profile_set(card, 'output:hdmi-stereo')  &gt;&gt;&gt; help(pulse)  ...  &gt;&gt;&gt; pulse.close()Current code logic is that all methods are invoked through the Pulse instance,and everything returned from these are &quot;Pulse-Something-Info&quot; objects - thinwrappers around C structs that describe the thing, without any methods attached.Aside from a few added convenience methods, most of them should have similarsignature and do same thing as their C libpulse API counterparts, so see`pulseaudio doxygen documentation`_ for more information on them.Pulse client can be integrated into existing eventloop (e.g. asyncio, twisted,etc) using ``Pulse.set_poll_func()`` or ``Pulse.event_listen()`` in a separatethread.Somewhat extended usage example can be found in `pulseaudio-mixer-cli`_ projectcode, as well as tests here... _pulseaudio doxygen documentation: https://freedesktop.org/software/pulseaudio/doxygen/introspect_8h.html.. _pulseaudio-mixer-cli: https://github.com/mk-fg/pulseaudio-mixer-cli/blob/master/pa-mixer-mk3.pyNotes-----Some less obvious things are described in this section.Things not yet wrapped/exposed in python````````````````````````````````````````There are plenty of information, methods and other things in libpulse not yetwrapped/exposed by this module, as they weren't needed (yet) for author/devsuse-case(s).Making them accessible from python code can be as simple as adding an attributename to the &quot;c_struct_fields&quot; value in PulseSomethingInfo objects.See `github #3 &lt;https://github.com/mk-fg/python-pulse-control/issues/3&gt;`_for a more concrete example of finding/adding such stuff.For info and commands that are not available through libpulse introspection API,it is possible to use ``pulsectl.connect_to_cli()`` fallback function, whichwill open unix socket to server's &quot;module-cli&quot; (signaling to load it, ifnecessary), which can be used in exactly same way as &quot;pacmd&quot; tool (not to beconfused with &quot;pactl&quot;, which uses native protocol instead of module-cli) orpulseaudio startup files (e.g. &quot;default.pa&quot;).Probably a bad idea to parse string output from commands there though, as theseare not only subject to change, but can also vary depending on system locale.Volume``````In PulseAudio, &quot;volume&quot; for anything is not a flat number, but essentially alist of numbers, one per channel (as in &quot;left&quot;, &quot;right&quot;, &quot;front&quot;, &quot;rear&quot;, etc),which should correspond to channel map of the object it relates/is-applied to.In this module, such lists are represented by PulseVolumeInfo objects.I.e. ``sink.volume`` is a PulseVolumeInfo instance, and all thin/simple wrappersthat accept index of the object, expect such instance to be passed, e.g.``pulse.sink_input_volume_set(sink.index, sink.volume)``.There are convenience ``volume_get_all_chans``, ``volume_set_all_chans`` and``volume_change_all_chans`` methods to get/set/adjust volume as/by a singlenumeric value, which is also accessible on PulseVolumeInfo objects as a``value_flat`` property.PulseVolumeInfo can be constructed from a numeric volume value plus number ofchannels, or a python list of per-channel numbers.All per-channel volume values in PulseVolumeInfo (and flat values in the wrapperfuncs above), are float objects in 0-65536 range, with following meanings:* 0.0 volume is &quot;no sound&quot; (corresponds to PA_VOLUME_MUTED).* 1.0 value is &quot;current sink volume level&quot;, 100% or PA_VOLUME_NORM.* &gt;1.0 and up to 65536.0 (PA_VOLUME_MAX / PA_VOLUME_NORM) - software-boosted  sound volume (higher values will negatively affect sound quality).Probably a good idea to set volume only in 0-1.0 range and boost volume inhardware without quality loss, e.g. by tweaking sink volume (which correspondsto ALSA/hardware volume), if that option is available.Note that ``flat-volumes=yes`` option (&quot;yes&quot; by default on some distros, &quot;no&quot; ine.g. Arch Linux) in pulseaudio daemon.conf already scales device-volume with thevolume of the &quot;loudest&quot; application, so already does what's suggested above.Fractional volume values used in the module get translated (in a linear fashion)to/from pa_volume_t integers for libpulse. See ``src/pulse/volume.h`` inpulseaudio sources for all the gory details on the latter (e.g. how it relatesto sound level in dB).Code example::  from pulsectl import Pulse, PulseVolumeInfo  with Pulse('volume-example') as pulse:    sink_input = pulse.sink_input_list()[0] # first random sink-input stream    volume = sink_input.volume    print(volume.values) # list of per-channel values (floats)    print(volume.value_flat) # average level across channels (float)    time.sleep(1)    volume.value_flat = 0.3 # sets all volume.values to 0.3    pulse.volume_set(sink_input, volume) # applies the change    time.sleep(1)    n_channels = len(volume.values)    new_volume = PulseVolumeInfo(0.5, n_channels) # 0.5 across all n_channels    # new_volume = PulseVolumeInfo([0.15, 0.25]) # from a list of channel levels (stereo)    pulse.volume_set(sink_input, new_volume)    # pulse.sink_input_volume_set(sink_input.index, new_volume) # same as aboveIn most common cases, doing something like``pulse.volume_set_all_chans(sink_input, 0.2)`` should do the trick though -no need to bother with specific channels in PulseVolumeInfo there.String values`````````````libpulse explicitly returns utf-8-encoded string values, which are alwaysdecoded to &quot;abstract string&quot; type in both python-2 (where it's called &quot;unicode&quot;)and python-3 (&quot;str&quot;), for consistency.It might be wise to avoid mixing these with encoded strings (&quot;bytes&quot;) in the code,especially in python-2, where &quot;bytes&quot; is often used as a default string type.Enumerated/named values (enums)```````````````````````````````In place of C integers that correspond to some enum or constant (e.g. -1 forPA_SINK_INVALID_STATE), module returns EnumValue objects, which are comparableto strings (&quot;str&quot; type in py2/py3).For example::  &gt;&gt;&gt; pulsectl.PulseEventTypeEnum.change == 'change'  True  &gt;&gt;&gt; pulsectl.PulseEventTypeEnum.change  &lt;EnumValue event-type=change&gt;  &gt;&gt;&gt; pulsectl.PulseEventTypeEnum  &lt;Enum event-type [change new remove]&gt;It might be preferrable to use enums instead of strings in the code so thatinterpreter can signal error on any typos or unknown values specified, asopposed to always silently failing checks with bogus strings.Event-handling code, threads````````````````````````````libpulse clients always work as an event loop, though this module kinda hidesit, presenting a more old-style blocking interface.So what happens on any call (e.g. ``pulse.mute(...)``) is:* Make a call to libpulse, specifying callback for when operation will be completed.* Run libpulse event loop until that callback gets called.* Return result passed to that callback call, if any (for various &quot;get&quot; methods).``event_callback_set()`` and ``event_listen()`` calls essentally do raw firstand second step here.Which means that any pulse calls from callback function can't be used when``event_listen()`` (or any other pulse call through this module, for that matter)waits for return value and runs libpulse loop already.One can raise PulseLoopStop exception there to make ``event_listen()`` return,run whatever pulse calls after that, then re-start the ``event_listen()`` thing.This will not miss any events, as all blocking calls do same thing as``event_listen()`` does (second step above), and can cause callable passed to``event_callback_set()`` to be called (when loop is running).Also, same instance of libpulse eventloop can't be run from different threads,naturally, so if threads are used, client can be initialized with``threading_lock=True`` option (can also accept lock instance instead of True)to create a mutex around step-2 (run event loop) from the list above, somultiple threads won't do it at the same time.For proper python eventloop integration (think twisted or asyncio),use `pulsectl-asyncio`_ module instead.There are also some tricks mentioned in `github #11&lt;https://github.com/mk-fg/python-pulse-control/issues/11&gt;`_ to shoehorn thismodule into async apps, but even with non-asyncio eventloop, starting frompulsectl-asyncio would probably be much easier.Tests`````Test code is packaged/installed with the module and can be useful to run whenchanging module code, or to check if current python, module and pulseudioversions all work fine together.Commands to run tests from either checkout directory or installed module::  % python2 -m unittest discover  % python3 -m unittest discoverNote that if &quot;pulsectl&quot; module is available both in current directory(e.g. checkout dir) and user/system python module path, former should alwaystake priority for commands above.Add e.g. ``-k test_stream_move`` for commands above to match and run specifictest(s), and when isolating specific failure, it might also be useful to runwith PA_DEBUG=1 env-var to get full verbose pulseaudio log, for example::  % PA_DEBUG=1 python -m unittest discover -k test_module_funcsTest suite runs ad-hoc isolated pulseaudio instance with null-sinks (nottouching hardware), custom (non-default) startup script and environment,and interacts only with that instance, terminating it afterwards.Still uses system/user daemon.conf files though, so these can affect the tests.Any test failures can indicate incompatibilities, bugs in the module code,issues with pulseaudio (or its daemon.conf) and underlying dependencies.There are no &quot;expected&quot; test case failures.All tests can run for up to 10 seconds currently (v19.9.6), due to someinvolving playback (using paplay from /dev/urandom) being time-sensitive.Changelog and versioning scheme```````````````````````````````This package uses one-version-per-commit scheme (updated by pre-commit hook)and pretty much one release per git commit, unless more immediate follow-upcommits are planned or too lazy to run ``py setup.py sdist bdist_wheel upload``for some trivial README typo fix.| Version scheme: ``{year}.{month}.{git-commit-count-this-month}``| I.e. &quot;16.9.10&quot; is &quot;11th commit on Sep 2016&quot;.|There is a `CHANGES.rst &lt;CHANGES.rst&gt;`_ file with the list of any intentionalbreaking changes (should be exceptionally rare, if any) and new/addednon-trivial functionality.| It can be a bit out of date though, as one has to remember to update it manually.| &quot;Last synced/updated:&quot; line there might give a hint as to by how much.Installation------------It's a regular package for Python (3.x or 2.x).`If a package is available for your distribution`_,using your package manager is the recommended way to install it.Otherwise, using pip_ is the best way::  % pip install pulsectl(add --user option to install into $HOME for current user only)Be sure to use python3/python2, pip3/pip2, easy_install-... commandsbased on which python version you want to install the module for,if you are still using python2 (and likely have python3 on the system as well).If you don't have &quot;pip&quot; command::  % python -m ensurepip  % python -m pip install --upgrade pip  % python -m pip install pulsectl(same suggestion wrt &quot;install --user&quot; as above)On a very old systems, one of these might work::  % curl https://bootstrap.pypa.io/get-pip.py | python  % pip install pulsectl  % easy_install pulsectl  % git clone --depth=1 https://github.com/mk-fg/python-pulse-control  % cd python-pulse-control  % python setup.py install(all of install-commands here also have --user option)Current-git version can be installed like this::  % pip install 'git+https://github.com/mk-fg/python-pulse-control#egg=pulsectl'Note that to install stuff to system-wide PATH and site-packages(without --user), elevated privileges (i.e. root and su/sudo) are often required.Use &quot;...install --user&quot;, `~/.pydistutils.cfg`_ or virtualenv_to do unprivileged installs into custom paths.More info on python packaging can be found at `packaging.python.org`_... _If a package is available for your distribution: https://repology.org/project/python:pulsectl/versions.. _pip: http://pip-installer.org/.. _~/.pydistutils.cfg: http://docs.python.org/install/index.html#distutils-configuration-files.. _virtualenv: http://pypi.python.org/pypi/virtualenv.. _packaging.python.org: https://packaging.python.org/installing/Links-----* pulsemixer_ - initial source for this project (embedded in the tool).* `pulsectl-asyncio`_ - similar libpulse wrapper to this one, but for async python code.* `libpulseaudio &lt;https://github.com/thelinuxdude/python-pulseaudio/&gt;`_ -  different libpulse bindings module, more low-level, auto-generated from  pulseaudio header files.  Branches there have bindings for different (newer) pulseaudio versions.* `pypulseaudio &lt;https://github.com/liamw9534/pypulseaudio/&gt;`_ -  high-level bindings module, rather similar to this one.* `pulseaudio-mixer-cli`_ - alsamixer-like script built on top of this module.</longdescription>
</pkgmetadata>