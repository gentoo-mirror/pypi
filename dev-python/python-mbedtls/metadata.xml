<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. vim:tw=72=======================================================Cryptographic library for Python with Mbed TLS back end=======================================================.. image:: https://results.pre-commit.ci/badge/github/Synss/python-mbedtls/master.svg   :target: https://results.pre-commit.ci/latest/github/Synss/python-mbedtls/master   :alt: pre-commit.ci status.. image::   https://github.com/Synss/python-mbedtls/actions/workflows/main.yml/badge.svg?branch=master   :target: https://github.com/Synss/python-mbedtls/actions/.. image::   https://coveralls.io/repos/github/Synss/python-mbedtls/badge.svg?branch=master   :target: https://coveralls.io/github/Synss/python-mbedtls?branch=master`python-mbedtls`_ is a free cryptographic library for Python that uses`mbed TLS`_ for back end.   mbed TLS (formerly known as PolarSSL) makes it trivially easy for   developers to include cryptographic and SSL/TLS capabilities in their   (embedded) products, facilitating this functionality with a minimal   coding footprint.*python-mbedtls* API follows the recommendations from:* `PEP 272`_ -- API for Block Encryption Algorithms v1.0* `PEP 452`_ -- API for Cryptographic Hash Functions v2.0* `PEP 506`_ -- Adding a Secret Module to the Standard Library* `PEP 543`_ -- A Unified TLS API for Python (`completed and modernized`_)and therefore plays well with the `cryptographic services`_ from thePython standard library and many other cryptography libraries as well... _python-mbedtls: https://synss.github.io/python-mbedtls.. _mbed TLS: https://tls.mbed.org.. _PEP 272: https://www.python.org/dev/peps/pep-0272/.. _PEP 452: https://www.python.org/dev/peps/pep-0452/.. _PEP 506: https://www.python.org/dev/peps/pep-0506/.. _PEP 543: https://www.python.org/dev/peps/pep-0543/.. _cryptographic services: https://docs.python.org/3/library/crypto.html.. _PyCrypto: https://www.dlitz.net/software/pycrypto/.. _hashlib: https://docs.python.org/3.6/library/hashlib.html.. _hmac: https://docs.python.org/3.6/library/hmac.html.. _completed and modernized: https://github.com/Synss/python-mbedtls/blob/master/src/mbedtls/_tlsi.pyLicense=======*python-mbedtls* is licensed under the MIT License (see LICENSE.txt).This enables the use of *python-mbedtls* in both open source and closedsource projects.  The MIT License is compatible with both GPL and Apache2.0 license under which mbed TLS is distributed.API documentation=================https://synss.github.io/python-mbedtls/Installation============The bindings are tested with mbedTLS 2.28.3 for Python 3.8,3.9, 3.10, and 3.11 on Linux, macOS, and Windows.`manylinux`_ wheels are available for 64-bit Linux systems.  Installwith ``pip install python-mbedtls``... _manylinux: https://www.python.org/dev/peps/pep-0513/Usage and examples==================Now, let us see examples using the various parts of the library.Check which version of mbed TLS is being used by python-mbedtls---------------------------------------------------------------The *mbedtls.version* module shows the run-time versioninformation to mbed TLS.&gt;&gt;&gt; from mbedtls import version&gt;&gt;&gt; _ = version.version  # &quot;mbed TLS 2.28.3&quot;&gt;&gt;&gt; _ = version.version_info  # (2, 28, 3)Message digest--------------The *mbedtls.hashlib* module supports MD2, MD4, MD5, SHA-1, SHA-2(in 224, 256, 384, and 512-bits), and RIPEMD-160 secure hashesand message digests.  Note that MD2 and MD4 are not includedby default and are only present if they are compiled in mbedtls.Here are the examples from (standard) *hashlib* portedto *python-mbedtls*:&gt;&gt;&gt; from mbedtls import hashlib&gt;&gt;&gt; m = hashlib.md5()&gt;&gt;&gt; m.update(b&quot;Nobody inspects&quot;)&gt;&gt;&gt; m.update(b&quot; the spammish repetition&quot;)&gt;&gt;&gt; m.digest()b'\xbbd\x9c\x83\xdd\x1e\xa5\xc9\xd9\xde\xc9\xa1\x8d\xf0\xff\xe9'&gt;&gt;&gt; m.digest_size16&gt;&gt;&gt; m.block_size64More condensed:&gt;&gt;&gt; hashlib.sha224(b&quot;Nobody inspects the spammish repetition&quot;).hexdigest()'a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2'Using ``new()``:&gt;&gt;&gt; h = hashlib.new('ripemd160')&gt;&gt;&gt; h.update(b&quot;Nobody inspects the spammish repetition&quot;)&gt;&gt;&gt; h.hexdigest()'cc4a5ce1b3df48aec5d22d1f16b894a0b894eccc'HMAC algorithm--------------The *mbedtls.hmac* module computes HMAC.Example:&gt;&gt;&gt; from mbedtls import hmac&gt;&gt;&gt; m = hmac.new(b&quot;This is my secret key&quot;, digestmod=&quot;md5&quot;)&gt;&gt;&gt; m.update(b&quot;Nobody inspects&quot;)&gt;&gt;&gt; m.update(b&quot; the spammish repetition&quot;)&gt;&gt;&gt; m.digest()b'\x9d-/rj\\\x98\x80\xb1rG\x87\x0f\xe9\xe4\xeb'Warning:The message is cleared after calculation of the digest.  Only call``mbedtls.hmac.Hmac.digest()`` or ``mbedtls.hmac.Hmac.hexdigest()``once per message.HMAC-based key derivation function (HKDF)-----------------------------------------The *mbedtls.hkdf* module exposes extract-and-expand key derivationfunctions.  The main function is ``hkdf()`` but ``extract()`` and``expand()`` may be used as well.Example:&gt;&gt;&gt; from mbedtls import hkdf&gt;&gt;&gt; hkdf.hkdf(...     b&quot;my secret key&quot;,...     length=42,...     info=b&quot;my cool app&quot;,...     salt=b&quot;and pepper&quot;,...     digestmod=hmac.sha256... )b'v,\xef\x90\xccU\x1d\x1b\xd7\\a\xaf\x92\xac\n\x90\xf9q\xf4)\xcd&quot;\xf7\x1a\x94p\x03.\xa8e\x1e\xfb\x92\xe8l\x0cc\xf8e\rvj'where *info*, *salt*, and *digestmod* are optional, although providing(at least) *info* is highly recommended.Symmetric cipher----------------The *mbedtls.cipher* module provides symmetric encryption.  The APIfollows the recommendations from PEP 272 so that it can be used as adrop-in replacement to other libraries.*python-mbedtls* provides the following algorithms:- AES encryption/decryption (128, 192, and 256 bits) in ECB, CBC, CFB128,  CTR, OFB, or XTS mode;- AES AEAD (128, 192, and 256 bits) in GCM or CCM mode;- ARC4 encryption/decryption;- ARIA encryption/decryption (128, 192, and 256 bits) in ECB, CBC,  CTR, or GCM modes;- Blowfish encryption/decryption in ECB, CBC, CFB64, or CTR mode;- Camellia encryption/decryption (128, 192, and 256 bits) in ECB, CBC,  CFB128, CTR, or GCM mode;- DES, DES3, and double DES3 encryption/decryption in ECB or CBC mode;- CHACHA20 and CHACHA20/POLY1305 encryption/decryption.Example:&gt;&gt;&gt; from mbedtls import cipher&gt;&gt;&gt; c = cipher.AES.new(b&quot;My 16-bytes key.&quot;, cipher.MODE_CBC, b&quot;CBC needs an IV.&quot;)&gt;&gt;&gt; enc = c.encrypt(b&quot;This is a super-secret message!!&quot;)&gt;&gt;&gt; encb&quot;*`k6\x98\x97=[\xdf\x7f\x88\x96\xf5\t\x19J\xf62h\xf4n\xca\xe8\xfe\xf5\xd7X'\xb1\x8c\xc9\x85&quot;&gt;&gt;&gt; c.decrypt(enc)b'This is a super-secret message!!'RSA public key--------------The *mbedtls.pk* module provides the RSA cryptosystem.  This includes:- Public-private key generation and key import/export in PEM and DER  formats;- asymmetric encryption and decryption;- message signature and verification.Key generation, the default size is 2048 bits:&gt;&gt;&gt; from mbedtls import pk&gt;&gt;&gt; rsa = pk.RSA()&gt;&gt;&gt; prv = rsa.generate()&gt;&gt;&gt; rsa.key_size256Message encryption and decryption:&gt;&gt;&gt; enc = rsa.encrypt(b&quot;secret message&quot;)&gt;&gt;&gt; rsa.decrypt(enc)b'secret message'Message signature and verification:&gt;&gt;&gt; sig = rsa.sign(b&quot;Please sign here.&quot;)&gt;&gt;&gt; rsa.verify(b&quot;Please sign here.&quot;, sig)True&gt;&gt;&gt; rsa.verify(b&quot;Sorry, wrong message.&quot;, sig)False&gt;&gt;&gt; pub = rsa.export_public_key(format=&quot;DER&quot;)&gt;&gt;&gt; other = pk.RSA.from_buffer(pub)&gt;&gt;&gt; other.verify(b&quot;Please sign here.&quot;, sig)TrueStatic and ephemeral elliptic curve Diffie-Hellman--------------------------------------------------The *mbedtls.pk* module provides the ECC cryptosystem.  This includes:- Public-private key generation and key import/export in the PEM and DER  formats;- asymmetric encrypt and decryption;- message signature and verification;- ephemeral ECDH key exchange.``get_supported_curves()`` returns the list of supported curves.The API of the ECC class is the same as the API of the RSA classbut ciphering (``encrypt()`` and ``decrypt()`` is not supported byMbed TLS).Message signature and verification using elliptic a curve digitalsignature algorithm (ECDSA):&gt;&gt;&gt; from mbedtls import pk&gt;&gt;&gt; ecdsa = pk.ECC()&gt;&gt;&gt; prv = ecdsa.generate()&gt;&gt;&gt; sig = ecdsa.sign(b&quot;Please sign here.&quot;)&gt;&gt;&gt; ecdsa.verify(b&quot;Please sign here.&quot;, sig)True&gt;&gt;&gt; ecdsa.verify(b&quot;Sorry, wrong message.&quot;, sig)False&gt;&gt;&gt; pub = ecdsa.export_public_key(format=&quot;DER&quot;)&gt;&gt;&gt; other = pk.ECC.from_buffer(pub)&gt;&gt;&gt; other.verify(b&quot;Please sign here.&quot;, sig)TrueThe classes ``ECDHServer`` and ``ECDHClient`` may be used for ephemeralECDH.  The key exchange is as follows:&gt;&gt;&gt; ecdh_key = pk.ECC()&gt;&gt;&gt; ecdh_key.generate()&gt;&gt;&gt; ecdh_srv = pk.ECDHServer(ecdh_key)&gt;&gt;&gt; ecdh_cli = pk.ECDHClient(ecdh_key)The server generates the ServerKeyExchange encrypted payload andpasses it to the client:&gt;&gt;&gt; ske = ecdh_srv.generate()&gt;&gt;&gt; ecdh_cli.import_SKE(ske)then the client generates the ClientKeyExchange encrypted payload andpasses it back to the server:&gt;&gt;&gt; cke = ecdh_cli.generate()&gt;&gt;&gt; ecdh_srv.import_CKE(cke)Now, client and server may generate their shared secret:&gt;&gt;&gt; secret = ecdh_srv.generate_secret()&gt;&gt;&gt; ecdh_cli.generate_secret() == secretTrue&gt;&gt;&gt; ecdh_srv.shared_secret == ecdh_cli.shared_secretTrueDiffie-Hellman-Merkle key exchange----------------------------------The classes ``DHServer`` and ``DHClient`` may be used for DH Keyexchange.  The classes have the same API as ``ECDHServer``and ``ECDHClient``, respectively.The key exchange is as follow:&gt;&gt;&gt; from mbedtls.mpi import MPI&gt;&gt;&gt; from mbedtls import pk&gt;&gt;&gt; dh_srv = pk.DHServer(MPI.prime(128), MPI.prime(96))&gt;&gt;&gt; dh_cli = pk.DHClient(MPI.prime(128), MPI.prime(96))The 128-bytes prime and the 96-bytes prime are the modulus ``P``and the generator ``G``.The server generates the ServerKeyExchange payload:&gt;&gt;&gt; ske = dh_srv.generate()&gt;&gt;&gt; dh_cli.import_SKE(ske)The payload ends with ``G^X mod P`` where ``X`` is the secret value ofthe server.&gt;&gt;&gt; cke = dh_cli.generate()&gt;&gt;&gt; dh_srv.import_CKE(cke)``cke`` is ``G^Y mod P`` (with ``Y`` the secret value from the client)returned as its representation in bytes so that it can be readilytransported over the network.As in ECDH, client and server may now generate their shared secret:&gt;&gt;&gt; secret = dh_srv.generate_secret()&gt;&gt;&gt; dh_cli.generate_secret() == secretTrue&gt;&gt;&gt; dh_srv.shared_secret == dh_cli.shared_secretTrueX.509 certificate writing and parsing-------------------------------------The *mbedtls.x509* module can be used to parse X.509 certificatesor create and verify a certificate chain.Here, the trusted root is a self-signed CA certificate``ca0_crt`` signed by ``ca0_key``.&gt;&gt;&gt; import datetime as dt&gt;&gt;&gt;&gt;&gt;&gt; from mbedtls import hashlib&gt;&gt;&gt; from mbedtls import pk&gt;&gt;&gt; from mbedtls import x509&gt;&gt;&gt;&gt;&gt;&gt; now = dt.datetime.utcnow()&gt;&gt;&gt; ca0_key = pk.RSA()&gt;&gt;&gt; _ = ca0_key.generate()&gt;&gt;&gt; ca0_csr = x509.CSR.new(ca0_key, &quot;CN=Trusted CA&quot;, hashlib.sha256())&gt;&gt;&gt; ca0_crt = x509.CRT.selfsign(...     ca0_csr, ca0_key,...     not_before=now, not_after=now + dt.timedelta(days=90),...     serial_number=0x123456,...     basic_constraints=x509.BasicConstraints(True, 1))...An intermediate then issues a Certificate Singing Request (CSR) that theroot CA signs:&gt;&gt;&gt; ca1_key = pk.ECC()&gt;&gt;&gt; _ = ca1_key.generate()&gt;&gt;&gt; ca1_csr = x509.CSR.new(ca1_key, &quot;CN=Intermediate CA&quot;, hashlib.sha256())&gt;&gt;&gt;&gt;&gt;&gt; ca1_crt = ca0_crt.sign(...     ca1_csr, ca0_key, now, now + dt.timedelta(days=90), 0x123456,...     basic_constraints=x509.BasicConstraints(ca=True, max_path_length=3))...And finally, the intermediate CA signs a certificate for theEnd Entity on the basis of a new CSR:&gt;&gt;&gt; ee0_key = pk.ECC()&gt;&gt;&gt; _ = ee0_key.generate()&gt;&gt;&gt; ee0_csr = x509.CSR.new(ee0_key, &quot;CN=End Entity&quot;, hashlib.sha256())&gt;&gt;&gt;&gt;&gt;&gt; ee0_crt = ca1_crt.sign(...     ee0_csr, ca1_key, now, now + dt.timedelta(days=90), 0x987654)...The emitting certificate can be used to verify the next certificate inthe chain:&gt;&gt;&gt; ca1_crt.verify(ee0_crt)True&gt;&gt;&gt; ca0_crt.verify(ca1_crt)TrueNote, however, that this verification is only one step in a private keyinfrastructure and does not take CRLs, path length, etc. into account.TLS and DTLS client and server------------------------------The *mbedtls.tls* module provides TLS clients and servers.  The APIfollows the recommendations of `PEP 543`_.  Note, however, that thePython standard SSL library does not follow the PEP so that thislibrary may not be a drop-in replacement... _PEP 543: https://www.python.org/dev/peps/pep-0543/Connectionless DTLS is supported as well.See examples in the `programs/`_ directory of the repositoryand `tests/test_tls.py`_... _programs/: https://github.com/Synss/python-mbedtls/tree/master/programs.. _tests/test_tls.py: https://github.com/Synss/python-mbedtls/blob/master/tests/test_tls.py</longdescription>
</pkgmetadata>