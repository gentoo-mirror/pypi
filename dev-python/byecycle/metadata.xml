<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># byecycle ðŸš²[![python](https://img.shields.io/pypi/pyversions/byecycle)](https://pdm.fming.dev)[![pyPI](https://img.shields.io/pypi/v/byecycle)](https://pypi.org/project/byecycle)[![docs](https://img.shields.io/badge/doc-pages-blue)](https://a-recknagel.github.io/byecycle/)[![pdm-managed](https://img.shields.io/badge/packaging-pdm-blueviolet)](https://pdm.fming.dev)[![license](https://img.shields.io/pypi/l/byecycle)](https://github.com/a-recknagel/byecycle/blob/main/LICENSE)[![chat](https://img.shields.io/badge/chat-gitter-mediumturquoise)](https://matrix.to/#/#chextra:gitter.im)Find and expose cyclic imports in python projects.## Installation`byecycle` uses the built-in [ast module](https://docs.python.org/3/library/ast.html#ast.parse)to parse code files. As a consequence, it can only handle python code within the samemajor version (read: no support for python 1 and 2), and the same or lower minor versionof the python interpreter it was installed with. If `byecycle` raises `SyntaxError`s incode that you know to be working, try using a `byecycle` that is installed with the samepython version that can run the code in question.### From PyPI#### Requirements: - python 3.11 or higher - [pipx](https://pypa.github.io/pipx/installation/)```shellpipx install byecycle```---### Development Setup#### Requirements: - python 3.11 or higher - [pdm](https://pdm.fming.dev/) - git```shellgit clone https://github.com/a-recknagel/byecycle.gitcd byecyclepdm install -G:all```## Usage### As a Command Line Tool```shell# with a pathbyecycle /home/me/dev/byecycle/src/byecycle/# or the name of an installed packagebyecycle byecycle```The result will be a json string:```json{  &quot;byecycle.misc&quot;: {},  &quot;byecycle.graph&quot;: {    &quot;byecycle&quot;: {      &quot;tags&quot;: [        &quot;vanilla&quot;,        &quot;parent&quot;      ],      &quot;cycle&quot;: &quot;complicated&quot;    },    &quot;byecycle.misc&quot;: {      &quot;tags&quot;: [        &quot;vanilla&quot;      ],      &quot;cycle&quot;: null    }  },  [...]  &quot;byecycle&quot;: {    &quot;byecycle.graph&quot;: {      &quot;tags&quot;: [        &quot;vanilla&quot;,        &quot;parent&quot;      ],      &quot;cycle&quot;: &quot;complicated&quot;    }  }}```By default, the result is printed with some rich formatting to highlight types and such.If you need the output to be plain ascii, pass the `--no-rich` flag.---For bigger projects, you might get much more complex output. The intent of returning`json` is to have something that can be easily piped into e.g. `jq` for furtherprocessing:```shell# filter out imports that don't have a cyclebyecycle byecycle | jq '.[] |= (.[] |= select(.cycle != null) | select(. != {}))'``````json{  &quot;byecycle.graph&quot;: {    &quot;byecycle&quot;: {      &quot;tags&quot;: [        &quot;parent&quot;,        &quot;vanilla&quot;      ],      &quot;cycle&quot;: &quot;complicated&quot;    }  },  &quot;byecycle.cli&quot;: {    &quot;byecycle&quot;: {      &quot;tags&quot;: [        &quot;parent&quot;,        &quot;vanilla&quot;      ],      &quot;cycle&quot;: &quot;complicated&quot;    }  },  &quot;byecycle&quot;: {    &quot;byecycle.graph&quot;: {      &quot;tags&quot;: [        &quot;parent&quot;,        &quot;vanilla&quot;      ],      &quot;cycle&quot;: &quot;complicated&quot;    },    &quot;byecycle.cli&quot;: {      &quot;tags&quot;: [        &quot;parent&quot;,        &quot;vanilla&quot;      ],      &quot;cycle&quot;: &quot;complicated&quot;    }  }}```Alternatively, you can also call the main entrypoint's core functionality as a regularpython function. Among other things, it returns a dictionary equivalent to the CLI's jsonthat you can work with:```pythonfrom byecycle import runcycles, *_ = run(&quot;byecycle&quot;)# filter out imports that don't have a cyclefor outer_k, outer_v in cycles.items():    for inner_k, inner_v in outer_v.items():        if inner_v[&quot;cycle&quot;]:            print(f&quot;{outer_k} -&gt; {inner_k}: {inner_v['cycle']}&quot;)``````textbyecycle.graph -&gt; byecycle -&gt; complicatedbyecycle.cli -&gt; byecycle -&gt; complicatedbyecycle -&gt; byecycle.graph -&gt; complicatedbyecycle -&gt; byecycle.cli -&gt; complicated```---See the help text of `byecycle` for an explanation of tags/`ImportKind`s andcycle/`EdgeKind`s.In short, if there is a cycle, the tags of all involved imports informthe cycle-severity, with the highest severity winning out if multiple apply. The defaultscan be overriden in order to isolate, filter, or highlight cycles with specific severities.### To Visualize the Import GraphIf you pass the `--draw` flag&lt;sup&gt;1&lt;/sup&gt; on your command-line-call, `byecycle` will create an image ofthe import graph instead:```shellbyecycle byecycle --draw```&lt;img src=&quot;https://github.com/a-recknagel/byecycle/assets/2063412/e5e8427c-8554-4ce5-9f9f-e2e9eca40742&quot; alt=&quot;Plot of imports in the byecycle project&quot; width=&quot;320&quot; height=&quot;240&quot;&gt;&lt;img src=&quot;https://github.com/a-recknagel/byecycle/assets/2063412/a00586db-e71e-4e74-94ed-0709129920b0&quot; alt=&quot;Legend for nodes in the plot&quot; width=&quot;320&quot; height=&quot;240&quot;&gt;---&lt;sup&gt;[1]&lt;/sup&gt;&lt;sub&gt; Requires installation of the `draw`-extra, i.e. `pipx install &quot;byecycle[draw]&quot;`.&lt;/sub&gt;</longdescription>
</pkgmetadata>