<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># dyntastic[![CI](https://github.com/nayaverdier/dyntastic/actions/workflows/ci.yml/badge.svg)](https://github.com/nayaverdier/dyntastic/actions/workflows/ci.yml)[![codecov](https://codecov.io/gh/nayaverdier/dyntastic/branch/main/graph/badge.svg)](https://codecov.io/gh/nayaverdier/dyntastic)[![pypi](https://img.shields.io/pypi/v/dyntastic)](https://pypi.org/project/dyntastic)[![license](https://img.shields.io/github/license/nayaverdier/dyntastic.svg)](https://github.com/nayaverdier/dyntastic/blob/main/LICENSE)A DynamoDB library on top of Pydantic and boto3.## Installation```bashpip3 install dyntastic```If the Pydantic binaries are too large for you (they can exceed 90MB),use the following:```bashpip3 uninstall pydantic  # if pydantic is already installedpip3 install dyntastic --no-binary pydantic```## UsageThe core functionality of this library is provided by the `Dyntastic` class.`Dyntastic` is a subclass of Pydantic's `BaseModel`, so can be used in all thesame places a Pydantic model can be used (FastAPI, etc).```pythonimport uuidfrom datetime import datetimefrom typing import Optionalfrom dyntastic import Dyntasticfrom pydantic import Fieldclass Product(Dyntastic):    __table_name__ = &quot;products&quot;    __hash_key__ = &quot;product_id&quot;    product_id: str = Field(default_factory=lambda: str(uuid.uuid4()))    name: str    description: Optional[str] = None    price: float    tax: Optional[float] = Noneclass Event(Dyntastic):    __table_name__ = &quot;events&quot;    __hash_key__ = &quot;event_id&quot;    __range_key__ = &quot;timestamp&quot;    event_id: str    timestamp: datetime    data: dict# All your favorite pydantic functionality still works:p = Product(name=&quot;bread&quot;, price=3.49)# Product(product_id='d2e91c30-e701-422f-b71b-465b02749f18', name='bread', description=None, price=3.49, tax=None)p.dict()# {'product_id': 'd2e91c30-e701-422f-b71b-465b02749f18', 'name': 'bread', 'description': None, 'price': 3.49, 'tax': None}p.json()# '{&quot;product_id&quot;: &quot;d2e91c30-e701-422f-b71b-465b02749f18&quot;, &quot;name&quot;: &quot;bread&quot;, &quot;description&quot;: null, &quot;price&quot;: 3.49, &quot;tax&quot;: null}'```To explicitly define an AWS region or DynamoDB endpoint url (for using a localdynamodb docker instance, for example), set `__table_region__` or`__table_host__`### Inserting into DynamoDBUsing the `Product` example from above, simply:```pythonproduct = Product(name=&quot;bread&quot;, description=&quot;Sourdough Bread&quot;, price=3.99)product.product_id# d2e91c30-e701-422f-b71b-465b02749f18# Nothing is written to DynamoDB until .save() is called:product.save()```### Getting Items from DynamoDB```pythonProduct.get(&quot;d2e91c30-e701-422f-b71b-465b02749f18&quot;)# Product(product_id='d2e91c30-e701-422f-b71b-465b02749f18', name='bread', description=&quot;Sourdough Bread&quot;, price=3.99, tax=None)```The range key must be provided if one is defined:```pythonEvent.get(&quot;d2e91c30-e701-422f-b71b-465b02749f18&quot;, &quot;2022-02-12T18:27:55.837Z&quot;)```Consistent reads are supported:```pythonEvent.get(..., consistent_read=True)```A `DoesNotExist` error is raised by `get` if a key is not found:```pythonProduct.get(&quot;nonexistent&quot;)# Traceback (most recent call last):#   ...# dyntastic.exceptions.DoesNotExist```Use `safe_get` instead to return `None` if the key is not found:```pythonProduct.safe_get(&quot;nonexistent&quot;)# None```### Querying Items in DynamoDB```python# A is shorthand for the Attr class (i.e. attribute)from dyntastic import A# auto paging iterablefor event in Event.query(&quot;some_event_id&quot;):    print(event)Event.query(&quot;some_event_id&quot;, per_page=10)Event.query(&quot;some_event_id&quot;)Event.query(&quot;some_event_id&quot;, range_key_condition=A.timestamp &lt; datetime(2022, 2, 13))Event.query(&quot;some_event_id&quot;, filter_condition=A.some_field == &quot;foo&quot;)# query an indexEvent.query(A.my_other_field == 12345, index=&quot;my_other_field-index&quot;)# note: Must provide a condition expression rather than just the valueEvent.query(123545, index=&quot;my_other_field-index&quot;)  # errors!# query an index with an optional filter expressionfilter_expression = Noneif filter_value:    filter_expression = A('filter_field').eq(filter_value)Event.query(    A.my_other_field == 12345,     index=&quot;my_other_field-index&quot;,    filter_expression=filter_expression)# consistent readEvent.query(&quot;some_event_id&quot;, consistent_read=True)```If you need to manually handle pagination, use `query_page`:```pythonpage = Event.query_page(...)page.items# [...]page.has_more# Truepage.last_evaluated_key# {&quot;event_id&quot;: &quot;some_event_id&quot;, &quot;timestamp&quot;: &quot;...&quot;}Event.query_page(..., last_evaluated_key=page.last_evaluated_key)```### Scanning Items in DynamoDBScanning is done identically to querying, except there are no hash keyor range key conditions.```python# auto paging iterablefor event in Event.scan():    passEvent.scan((A.my_field &lt; 5) &amp; (A.some_other_field.is_in([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])))Event.scan(..., consistent_read=True)```### Updating Items in DynamoDBExamples:```pythonmy_item.update(A.my_field.set(&quot;new_value&quot;))my_item.update(A.my_field.set(A.another_field))my_item.update(A.my_int.set(A.another_int - 10))my_item.update(A.my_int.plus(1))my_item.update(A.my_list.append(&quot;new_element&quot;))my_item.update(A.some_attribute.set_default(&quot;value_if_not_already_present&quot;))my_item.update(A.my_field.remove())my_item.update(A.my_list.remove(2))  # remove by indexmy_item.update(A.my_string_set.add(&quot;new_element&quot;))my_item.update(A.my_string_set.add({&quot;new_1&quot;, &quot;new_2&quot;}))my_item.update(A.my_string_set.delete(&quot;element_to_remove&quot;))my_item.update(A.my_string_set.delete({&quot;remove_1&quot;, &quot;remove_2&quot;}))```The data is automatically refreshed after the update request. To disable thisbehavior, pass `refresh=False`:```pythonmy_item.update(..., refresh=False)```Supports conditions:```pythonmy_item.update(..., condition=A.my_field == &quot;something&quot;)```By default, if the condition is not met, the update call will be a noop.To instead error in this situation, pass `require_condition=True`:```pythonmy_item.update(..., require_condition=True)```### Batch ReadsMultiple items can be read from a table at the same time using the `batch_get` function.Note that DynamoDB limits the number of items that can be read at one time to100 items or 16MB, whichever comes first.Note that if any of the provided keys are missing from dynamo, they will simplybe excluded in the result set.```pythonMyModel.batch_get([&quot;hash_key_1&quot;, &quot;hash_key_2&quot;, &quot;hash_key_3&quot;])# =&gt; [MyModel(...), MyModel(...)]```For models with a range key defined:```pythonMyModel.batch_get([(&quot;hash_key_1&quot;, &quot;range_key_1&quot;), (&quot;hash_key_2&quot;, &quot;range_key_2&quot;)])# =&gt; [MyModel(...), MyModel(...)]```### Batch WritesSave and delete operations may also be performed in batches.Note that DynamoDB limits the number of items that can be written in a singlebatch to 25 items or 16MB, whichever comes first. Dyntastic will automaticallybatch in chunks of 25, or less if desired.```pythonwith MyModel.batch_writer():    MyModel(id=&quot;0&quot;).delete()    MyModel(id=&quot;1&quot;).save()    MyModel(id=&quot;2&quot;).save()# all operations are performed once the `with` context is exited```To configure a smaller batch size, for example when each item is relatively large:```pythonwith MyModel.batch_writer(batch_size=2):    MyModel(id=&quot;1&quot;).save()    MyModel(id=&quot;2&quot;).save()    # the previous two models are written immediately, since the batch size was reached    MyModel(id=&quot;3).save()# The final operation is performed here now that the `with` context has exited```### Create a DynamoDB TableThis functionality is currently meant only for use in unit tests as it does notsupport configuring throughput.To create a table with no secondary indexes:```pythonMyModel.create_table()# Do not wait until the table creation is complete (subsequent operations# may error if they are performed before the table creation is finished)MyModel.create_table(wait=False)```To define global secondary indexes (creating local secondary indexes is notcurrently supported):```python# All of the following are equivalentindex1 = &quot;my_field&quot;index1 = Index(&quot;my_field&quot;)index1 = Index(&quot;my_field&quot;, index_name=&quot;my_field-index&quot;)# Range keys are also supportedindex2 = Index(&quot;my_field&quot;, &quot;my_second_field&quot;)index2 = Index(&quot;my_field&quot;, &quot;my_second_field&quot;, index_name=&quot;my_field_my_second_field-index&quot;)MyModel.create_table(index1, index2)```# Changelog## 0.9.0 2023-04-15- Add support for `__table_host__` for local testing## 0.8.2 2022-11-12- Make mypy linting more strict## 0.8.1 2022-11-08- Fixed `batch_read` to support non-string hash keys## 0.8.0 2022-10-12- Add `py.typed` marker to indicate this library ships with type hints## 0.7.0 2022-10-11- No changes since 0.7.0a1## 0.7.0a1 2022-10-08- Change dependency version pinning to be more flexible- Only require `importlib_metadata` for python3.7 and earlier## 0.6.0 2022-09-17- Added support for `__table_name__` being a `Callable[[], str]` to allow dynamic table name- Added support for batch reads and writes- Fixed `consistent_read` behavior for `safe_get` (previously was always set to `True`)## 0.5.0 2022-05-09- Added support for multiple subclasses within one table (`get_model` function)## 0.4.1 2022-04-26- Fixed serialization of dynamo types when using Pydantic aliases## 0.4.0 2022-04-26- Fixed compatibility with Pydantic aliases## 0.3.0 2022-04-25- Added support for nested attribute conditions and update expressions- Fixed bug where `refresh()` would cause nested Pydantic models to be  converted to dictionaries instead of loaded into their models- Added Pydantic aliases (models will all be dumped using pydantic's  `by_alias=True` flag).## 0.2.0 2022-04-23**BREAKING**: Accessing attributes after calling `update(..., refresh=False)`will trigger a ValueError. Read below for more information.- Added built in safety for unrefreshed instances after an update. Any  attribute accesses on an instance that was updated with `refresh=False`  will raise a ValueError. This can be fixed by calling `refresh()` to get  the most up-to-date data of the item, or by calling `ignore_unrefreshed()`  to explicitly opt-in to using stale data.## 0.1.0 2022-02-13- Initial release</longdescription>
</pkgmetadata>