<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># IODictiodict is a thread safe object store which is writting in pure python.The dictionary implementation follows the `Dict` API, but storesitems using their **birthtime** allowing users to treat this datastore as afile system backed `OrderedDict`.&gt; Items in the object store use file system attributes, when available to  store key and birthtime information. File system attributes enhance the  capability of the object store; however, they're not required. In the  event xattrs are not available, file stat is used for file creation time.  While stat works, in many cases, item ordering is not guarenteed.## Dictionary Usage``` pythonimport iodictdata = iodict.IODict(path='/tmp/iodict')  # Could be any path on the file systemdata[&quot;key&quot;] = &quot;value&quot;data{'key': &quot;value&quot;}dir(data)['__class__', '__delattr__', '__delitem__', '__dict__', '__dir__', '__doc__', '__enter__', '__eq__', '__exit__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_db_path', '_encoder', '_lock', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']```When running in a multiprocessing / threading application, a lock is requiredto be passed into the iodict class.``` pythonimport threadingimport iodictdata = iodict.IODict(path='/tmp/iodict', lock=threading.Lock)```&gt; By default, if no lock is provided, a multiprocessing lock will be created.The lock object allows the `iodict` to respect the locking paradigm of theexecuting application.## Durable Queue UsageThe DurableQueue class is used to create a disk-backed queue which implementsthe standarad `queue.Queue` API.``` pythonimport iodictq = iodict.DurableQueue(path='/tmp/iodict')  # Could be any path on the file systemq.put(&quot;test&quot;)data = q.get()data'test'```## Flushing Capable Queue UsageThe FlushQueue class is used to extend the capabilities of a standard queueobject by providing an extension which can be used to flush the objects withinqueue to a disk. This is useful in situation when the application needs to haltor otherwise stop working, but the inflight processes need to be saved andresumed at a later time.``` pythonimport queueimport iodictclass NewQueue(queue.Queue, iodict.FlushQueue):    def __init__(self, path, lock=None, semaphore=None):        super().__init__()        self.path = path        self.lock = lock        self.semaphore = semaphoreq = NewQueue(path='/tmp/iodict')  # Could be any path on the file systemq.put(&quot;test&quot;)q.qsize()1q.flush()q.qsize()0q.ingest()q.qsize()1q.get()'test'```</longdescription>
</pkgmetadata>