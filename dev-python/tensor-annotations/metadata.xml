<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># TensorAnnotationsTensorAnnotations is an experimental library enabling annotation of data-typeand semantic shape information using type annotations - for example:```pythondef calculate_loss(frames: Array4[uint8, Time, Batch, Height, Width]):  ...```This annotation states that the data-type of `frames` is `uint8`, and that thedimensions are time-like, batch-like, etc. (while saying nothing about theactual _values_ - e.g. the actual batch size).Why? Two reasons:*   Shape annotations can be checked _statically_. This can catch a range of    bugs caused by e.g. wrong selection or reduction of axes before you run your    code - even when the errors would not necessarily throw a runtime exception!*   Interface documentation (also enabling shape autocompletion in IDEs).To do this, the library provides three things:*   A set of custom tensor types for TensorFlow and JAX, supporting the above    kinds of annotations*   A collection of common semantic labels (e.g. `Time`, `Batch`, etc.)*   Type stubs for common library functions that preserve semantic shape    information (e.g. `reduce_sum(Tensor[Time, Batch], axis=0) -&gt;    Tensor[Batch]`)TensorAnnotations is being developed for JAX and TensorFlow.## ExampleHere is some code that takes advantage of static shape checking:```pythonimport tensorflow as tffrom tensor_annotations import axesimport tensor_annotations.tensorflow as ttfuint8 = ttf.uint8Batch, Time = axes.Batch, axes.Timedef sample_batch() -&gt; ttf.Tensor2[uint8, Time, Batch]:  return tf.zeros((3, 5))def train_batch(batch: ttf.Tensor2[uint8, Batch, Time]):  m: ttf.Tensor1[uint8, Batch] = tf.reduce_max(batch, axis=1)  # Do something usefuldef main():  batch1 = sample_batch()  batch2 = tf.transpose(batch1)  train_batch(batch2)```This code contains shape annotations in the signatures of `sample_batch` and`train_batch`, and in the line calling `reduce_max`. It is otherwise thesame code you would have written in an unchecked program.You can check these annotations for inconsistencies by running a static typechecker on your code (see 'General usage' below). For example, running`train_batch` directly on `batch1` will result in the following error frompytype:```File &quot;example.py&quot;, line 10: Function train_batch was called with the wrong arguments [wrong-arg-types]         Expected: (batch: Tensor2[uint8, Batch, Time])  Actually passed: (batch: Tensor2[uint8, Time, Batch])```Similarly, changing the the call to `reduce_max` from `axis=1` to `axis=0`results in:```File &quot;example.py&quot;, line 15: Type annotation for m does not match type of assignment [annotation-type-mismatch]  Annotation: Tensor1[uint8, Batch]  Assignment: Tensor1[uint8, Time]```(These messages were shortened for readability. The actual errors will be moreverbose because fully qualified type names will be displayed. We are lookinginto improving this.)See `examples/tf_time_batch.py` for a complete example.## RequirementsTensorAnnotatations requires Python 3.8 or above, due to the use of`typing.Literal`.## InstallationTo install custom tensor types:```bashpip install tensor_annotations```Then, depending on whether you use JAX or TensorFlow:```bashpip install tensor_annotations_jax_stubs# and/orpip install tensor_annotations_tensorflow_stubs```If you use pytype, you'll also need to take a few extra steps to letit take advantage of JAX/TensorFlow stubs (since it doesn't yet supportPEP 561 stub packages). First, make a copy of typeshed in e.g. your homedirectory:```bashgit clone https://github.com/python/typeshed &quot;$HOME/typeshed&quot;```Next, symlink the stubs into your copy of typeshed:```bashsite_packages=$(python3 -m site --user-site)# Custom tensor classesmkdir -p &quot;$HOME&quot;/typeshed/stubs/{tensor_annotations/tensor_annotations,tensorflow,jax}ln -s &quot;$site_packages/tensor_annotations/__init__.py&quot; &quot;$HOME/typeshed/stubs/tensor_annotations/tensor_annotations/__init__.pyi&quot;ln -s &quot;$site_packages/tensor_annotations/jax.pyi&quot; &quot;$HOME/typeshed/stubs/tensor_annotations/tensor_annotations/jax.pyi&quot;ln -s &quot;$site_packages/tensor_annotations/tensorflow.pyi&quot; &quot;$HOME/typeshed/stubs/tensor_annotations/tensor_annotations/tensorflow.pyi&quot;ln -s &quot;$site_packages/tensor_annotations/axes.py&quot; &quot;$HOME/typeshed/stubs/tensor_annotations/tensor_annotations/axes.pyi&quot;# TensorFlowln -s &quot;$site_packages/tensorflow-stubs&quot; &quot;$HOME/typeshed/stubs/tensorflow/tensorflow&quot;# JAXln -s &quot;$site_packages/jax-stubs&quot; &quot;$HOME/typeshed/stubs/jax/jax&quot;```## General usageFirst, import `tensor_annotations` and start annotating function signaturesand variable assignments. This can be done gradually.Next, run a static type checker on your code. If you use Mypy, it should justwork. If you use pytype, you need to invoke it in a special way in order to letit know about the custom typeshed installation:```TYPESHED_HOME=&quot;$HOME/typeshed&quot; pytype your_code.py```We recommend you deliberately introduce a shape error and then confirm thatyour type checker gives you an error to be sure you're set up correctly.### Annotated tensor classesTensorAnnotations provides tensor classes for JAX and TensorFlow:```python# JAXimport tensor_annotations.jax as tjaxtjax.arrayN  # Where N is the rank of the tensor# TensorFlowimport tensor_annotations.tensorflow as ttfttf.TensorN  # Where N is the rank of the tensor```These classes can be parameterized by semantic axis labels (below) usinggenerics, similar to `List[int]`. (Different classes are needed for each rankbecause Python currently does not support variadic generics, but we're workingon it.)### Data typesTensorAnnotations also provides its own data-type types:```python# JAXfrom tensor_annotations.jax import uint8, float32  # Etc# TensorFlowfrom tensor_annotations.tensorflow import uint8, float32  # Etc```This is because, for various reasons, the native data-type types like`tf.uint8` and `jnp.uint8` are unsuitable for use in type annotations. See`tensorflow.py` and `jax.py` for more information.### Axis labelsAxis labels are used to indicate the semantic meaning of each dimension in atensor - whether the dimension is batch-like, features-like, etc. Note that noconnection is made between the symbol, e.g. `Batch`, and the actual _value_ ofthat dimension (e.g. the batch size) - the symbol really does only describe thesemantic meaning of the dimension.See `axes.py` for the list of axis labels we provide out of the box. To define acustom axis label, simply subclass `tensor_annotations.axes.Axis`. You can alsouse `typing.NewType` to do this using a single line:```pythonCustomAxis = typing.NewType('CustomAxis', axes.Axis)```In the future we intend to support axis types that are tied to the actual sizeof that axis. Currently, however, we don't have a good way of doing this. If younonetheless want to annotate certain dimensions with a literal size, e.g. fordocumentation of interfaces which are hardcoded for specific sizes, we recommendyou just use a custom axis for this purpose. (Just to be clear, though: thesesizes will _not_ be checked - neither statically, nor at runtime!)```pythonL64 = typing.NewType('L64', axes.Axis)```### StubsBy default, TensorFlow and JAX are not aware of our annotations. For example, ifyou have a tensor `x: Array2[uint8, Time, Batch]` and you call`jnp.sum(x, axis=0)`, you won't get a `Array1[uint8, Batch]`, you'll just get an`Any`. We therefore provide a set of custom type annotations for TensorFlow andJAX packaged in 'stub' (`.pyi`) files.Our stubs currently cover the following parts of the API. All operations aresupported for rank 1, 2, 3 and 4 tensors, unless otherwise noted. Unaryoperators are also supported for rank 0 (scalar) tensors.#### TensorFlowSee [Coverage](docs/coverage.md).**Tensor unary operators**: For tensor `x`: `abs(x)`, `-x`, `+x`**Tensor binary operators**: For tensors `a` and `b`: `a + b`, `a / b`, `a //b`, `a ** b`, `a &lt; b`, `a &gt; b`, `a &lt;= b`, `a &gt;= b`, `a * b`. Yet to be typed:`a ? float`, `a ? int` for `Tensor0`, broadcasting where one axis is 1#### JAXSee [Coverage](docs/coverage.md).**Tensor unary operators**: For tensor `x`, `abs(x)`, `-x`, `+x`**Tensor binary operators**: For tensors `a` and `b`, `a + b`, `a / b`, `a //b`, `a ** b`, `a &lt; b`, `a &gt; b`, `a &lt;= b`, `a &gt;= b`, `a * b`. Yet to be typed:`a ? float`, `a ? int` for `Tensor0`, broadcasting where one axis is 1### CastingSome of your code might be already typed with existing library tensor types:```pythondef sample_batch() -&gt; jnp.array: ...```If this is the case, and you don't want to change these types globally in yourcode, you can cast to TensorAnnotations classes with `typing.cast`:```pythonfrom typing import castx = cast(tjax.Array2[uint8, Batch, Time], x)```Note that this is only a hint to the type checker - at runtime, it's a no-op. Analternative syntax emphasising this fact is:```pythonx: tjax.Array2[uint8, Batch, Time] = x  # type: ignore```## Gotchas**Use tuples for shape/axis specifications**For type inference with TensorFlow and JAX API functions we often have to matchadditional arguments. I.e., the rank of a `tf.zeros(...)` tensor depends on thelength of the shape argument. This only works with tuples, and not with lists:```pythona = tf.zeros((10, 10))  # Correctly infers type Tensor2[Any, Any]b: ttf.Tensor2[uint8, Time, Batch] = get_batch()c = tf.transpose(b, perm=(0, 1))  # Tracks and infers the axes-types of b```while```pythona = tf.zeros([10, 10])  # Returns Anyb: ttf.Tensor2[uint8, Time, Batch] = get_batch()c = tf.transpose(b, perm=[0, 1]))  # Does not track permutations and returns Any```**Runtime vs static checks**Note that we do not verify that the rank of a tensor at runtime matches the onespecified in the annotations. If you were in an evil mood, you could create anuntyped (Any) tensor, and statically type it as something completely wrong. Thisis in line with the rest of the python type-checking approach, which does not*enforce* consistency with the annotated types at runtime.**Value consistency**. Not only do we not verify the rank, we don't verifyanything about the actual shape value either. The following will _not_ raise anerror:```pythonx: tjax.Array1[uint8, Batch] = jnp.zeros((3,))y: tjax.Array1[uint8, Batch] = jnp.zeros((5,))```Note that _this is by design_! Shape symbols such as `Batch` are _not_placeholders for actual values like 3 or 5. Symbols only refer to the _semanticmeaning_ of a dimension. In the above example, say, `x` might be a train batch,and `y` might be a test batch, and therefore they have different sizes, eventhough both of their dimensions are batch-like. This means that evenelement-wise operations like `z = x + y` would in this case not raise atype-check error.## FAQs**Why doesn't e.g. `tjax.ArrayN` subclass `jnp.DeviceArray`?**We'd *like* this to be the case, but haven't figured out how to yet becauseof circular dependencies:* `ArrayN` is defined in `tensor_annotations.jax`, which would need to import  `jax.numpy` in order to subclass `jnp.DeviceArray`.* However, our `jax.numpy` stubs make use of `ArrayN`, so `jax.numpy` itself  needs to import `tensor_annotations.jax`.We ultimate solution to this will hopefully be to upstream our `ArrayN` classessuch that they can be defined in `jax.numpy` too. Until then, we'll just betrying to make e.g. `tjax.ArrayN` look as close to `jnp.DeviceArray` as possiblethrough dummy methods and dummy attributes so that autocomplete still works.If there are particular methods/attributes you'd like added, please do let usknow.**Why are so many methods annotated as `Any` in the JAX stubs?**We don't yet have a good way of automatically generating stubs in general.For the methods where we *do* generate stubs automatically (all the onesnot annotated as `Any`), we've checked their signature manually and writtenstub generators for each method individually.Ideally we'd start from stubs generated by e.g. pytype and then customisethem to include shape information, but we haven't got around to settingthis up yet.**Why not use [PEP 646](https://peps.python.org/pep-0646)?**Compatibility. There are two factors: a) concise syntax for PEP 646 isonly available in Python 3.11 onwards, which not everyone can migrate to yet;and b) PEP 646 is (as of January 2022) only supported by Pyre and Pyright -not by Mypy or pytype, which are both popular.Type checker support is the biggest thing - so once there _is_ better supportfor PEP 646 in Mypy and pytype, we may revisit this question.## See alsoThis library is one approach of many to checking tensor shapes. We don't expectit to be the final solution; we create it to explore one point in the space ofpossibilities.Other tools for checking tensor shapes include:* [Pythia](https://yanniss.github.io/tensor-ecoop20.pdf), a static analyzer  designed specifically for detecting TensorFlow shape errors* [tsanley](https://github.com/ofnote/tsanley), which uses string annotations  combined with runtime verification* [PyContracts](https://github.com/AndreaCensi/contracts), a general-purpose  library for specifying constraints on function arguments that has special  support for NumPy* [Shape Guard](https://github.com/Qwlouse/shapeguard), another runtime  verification tool using concise helper methods* [swift-tfp](https://github.com/google-research/swift-tfp), a static analyzer  for tensor shapes in Swift  To learn more about tensor shape checking in general, see:* Stephan Hoyer's  [Ideas for array shape typing in Python](https://docs.google.com/document/d/1vpMse4c6DrWH5rq2tQSx3qwP_m_0lyn-Ij4WHqQqRHY/edit)  document* The  [Typing for multi-dimensional arrays](https://github.com/python/typing/issues/513)  GitHub issue in `python/typing`* Our  [Shape annotation feature scoping](https://docs.google.com/document/d/1t-j1MJ9M0f0KMAnM22J97tCHSfVoFjAy9k4Lexi75c4/edit)  and our [Shape annotation syntax proposal](https://docs.google.com/document/d/1But-hjet8-djv519HEKvBN6Ik2lW3yu0ojZo6pG9osY/edit) documents (a synthesis of the most promising ideas  from the full doc)* The Python  [typing-sig](https://mail.python.org/archives/list/typing-sig@python.org/)  mailing list (in particular,  [this thread](https://mail.python.org/archives/list/typing-sig@python.org/thread/IOBJGI5SJCUHJAUE4BOULGFBBEO5DCVG/)  )* [Notes and recordings](https://docs.google.com/document/d/1oaG0V2ZE5BRDjd9N-Tr1N0IKGwZQcraIlZ0N8ayqVg8/edit)  from the Tensor Typing Open Design Meetings## Repository structureThe `tensor_annotations` package contains four types of things:* **Custom tensor classes**. We provide our own versions of e.g. TensorFlow's  `Tensor` class and JAX's `Array` class in order to support shape  parameterisation. These are stored in **`tensorflow.py`** and **`jax.py`**.  (Note that these are only used in the context of type annotations - they are  never instantiated - hence no implementation being present.)* **Type stubs for custom tensor classes**. We also need to provide type  annotations specifying what the shape of, say, `x: Tensor[A, B] + y:  Tensor[B]` is. These are **`tensorflow.pyi`** and **`jax.pyi`**.  * These are generated from `templates/tensors.pyi` using    `tools/render_tensor_template.py`.* **Type stubs for library functions**. Finally, we need to specify what the  shape of, say, `tf.reduce_sum(x: Tensor[A, B], axis=0)` is. This information  is stored in type stubs in **`library_stubs`**. (The `third_party/py`  directory structure is necessary to indicate to pytype exactly which packages  these stubs are for.) Ideally, these will eventually live in the libraries  themselves.  * JAX stubs are auto-generated from `templates/jax.pyi` using    `tools/render_jax_library_template.pyi`. Note that we currently specify the    signature of the library members we don't generate automatically as `Any`.    Ideally, we'd like to automatically generate complete type stubs and then    tweak them to include shape information, but we haven't gotten around to    this yet.  * For TensorFlow stubs, we start from stubs generated by a Google-internal    TensorFlow stub generator    and then hand-edit those stubs to include shape stubs. The edits we've made    are demarcated by `BEGIN/END tensor_annotations annotations for ...` blocks.    Again, we'll make this more automated in the future.* **Common axis types**. Finally, we also provide a canonical set of common axis  labels such as 'time' and 'batch'. These are stored in **`axes.py`**.</longdescription>
</pkgmetadata>