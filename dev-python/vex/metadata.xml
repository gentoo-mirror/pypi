<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Vex###Run a command in the named virtualenv.vex is an alternative to virtualenv's ``source wherever/bin/activate``and ``deactivate``, and virtualenvwrapper's ``workon``, and alsovirtualenv-burrito if you use that.It works in a more elegant way, though it does less.You might find it nicer to use.And it works with non-bash shells.How it works============``vex`` just runs any command in a virtualenv, without modifying the currentshell environment.To know why this is different, you have to understand a little about howvirtualenv normally works.The normal way people use a virtualenv (other than virtualenvwrapper,which does this for them) is to open a shell and sourcea file called ``whatever/bin/activate``.Sourcing this shell script modifies the environment in the current shell.It saves the old values and sets up a shell function named ``deactivate``which restores those old values. When you run ``deactivate`` it restoresits saved values.This is also the way virtualenvwrapper's ``workon`` functions - after all, itis a wrapper for virtualenv.If you want to use a virtualenv inside a script you probably don't useactivate, though, you just run the python that is inside the virtualenv'sbin/ directory.The way virtualenv's activate works isn't elegant, but it usually works fine.It's just specific to the shell, and sometimes gets a little fiddly, because ofthat decision to modify the current shell environment.The principle of ``vex`` is much simpler, and it doesn't care what shell youuse, because it does not modify the current environment. It only sets up theenvironment of the new process, and those environment settings just go awaywhen the process does. So no ``deactivate`` or restoration of environment isnecessary.For example, if you run ``vex foo bash`` then that bash shell has the rightenvironment setup, but specifically &quot;deactivating the virtualenv&quot; isunnecessary; the virtualenv &quot;deactivates&quot; when the process ends,e.g. if you use ``exit`` or Ctrl-D as normal to leave bash. That's justan example with bash, it works the same with anything.(More examples in the Examples section.)Examples========vex should work with most commands you can think of.Try it out.``vex foo bash``    Launch a bash shell with virtualenv foo activated in it.    To deactivate, just exit the shell (using &quot;exit&quot; or Ctrl-D).``vex foo python``    Launch a Python interpreter inside virtualenv foo.``vex foo which python``    Verify the path to python from inside virtualenv foo.``vex foo pip freeze``    See what's installed in virtualenv foo.``vex foo pip install ipython``    Install ipython inside virtualenv foo.``vex foo ipython``    Launch the ipython interpreter you have installed inside virtualenv foo.``vex foo``    Launch your shell (as specified in SHELL or ~/.vexrc) in virtualenv foo    (this is like a direct replacement for 'workon').``vex foo cmd``    On Windows, this launches a &quot;DOS&quot; shell using virtualenv foo.    (Try that with virtualenvwrapper!)``vex foo powershell``    On Windows, this launches a PowerShell instance using virtualenv foo.``vex -mr ephemeral``    In one command, this creates a virtualenv named ephemeral, then runs    a shell (since there was no argument), then after that shell exits, vex    removes the virtualenv named ephemeral.If you break things by doing weird fun things with vex, you get to keep all thepieces left over.How to install vex==================You can just 'pip install vex,' but for convenience it's recommended to installvex with the user scheme as follows::    pip install --user vexThough --user requires a little initial setup, this setup occurs once for alltools (see the next section), experienced Python developers have already doneit, and there are two reasons for using it despite the small extra trouble.First, it is not that convenient to use vex only from a virtualenv (though youcan) because then you need to use some other technique to activate thevirtualenv in which you have vex installed, in order to get access to it.That would usually be an unnecessary waste of time.Second, it does not require root privileges and does not make any system-widemesses. Installing Python libraries system-wide is something you shouldnormally leave to your OS package manager; you are probably doing yourselfa favor if you learn never to use ``sudo pip`` or ``sudo easy_install``.``pip install --user`` mostly substitutes for the purposes which wouldotherwise use ``sudo``.As an added benefit, you can use ``pip install --user`` on systems where youare not allowed to make global modifications, or voluntarily refrain in orderto protect the global configuration.You shouldn't normally have to separately install virtualenv; pip should dragthat in if you don't already have it.If you don't have pip, `learn to install pip &lt;http://pip.readthedocs.org/en/latest/installing.html&gt;`_.To uninstall, just use ``pip uninstall vex -y``.First-time setup for Python beginners=====================================The PATH problem----------------Though ``pip install --user`` is the way I recommend to install command-linePython tools like vex, it won't necessarily give you immediate results if yourmachine is not fully set up for Python development. The reason is that``pip install --user`` puts the script in a directory which isn't on thedefault ``$PATH`` (Windows: ``%PATH%``; PowerShell: ``$env:path``).For example, a Linux user named sam might see the script installed at::    /home/sam/.local/bin/vex(the exact path may vary); typing 'vex' will result in a 'command notfound', though inconveniently typing the absolute path will work.Similarly, a Windows user named sam might see the script installed at::    c:\users\sam\appdata\roaming\python\scripts\vexand typing 'vex' will result in 'is not recognized' ... but again, givingan absolute path will work, it's just inconvenient.This is not that hard to solve, if you have it then PLEASE take a few minutesto walk through the next section.The PATH solution-----------------**The solution is to adjust your PATH to include the appropriate directory.**For example, on Linux, sam might edit his shell config (e.g., ~/.profile) atthe end, to read::    PATH=$PATH:/home/sam/.local/binwhile on Windows, sam might go into the 'Environment Variables' control panel(Control Panel &gt; System &gt; Advanced System Settings &gt; Environment Variables)and in the upper box under 'User variables for sam', double-click 'PATH',and append the following to its current value (semicolon and all)::    ;c:\users\sam\appdata\roaming\python\scriptsThis will allow Windows to know what you mean when you type 'vex' (or the nameof any Python command-line tool which supports Windows and which you havewisely installed with ``pip install --user``).Another PATH problem--------------------Unless you already know better, if you need to adjust PATH for the benefitof your shell or installing some utility, you probably want to do thatwith changes in ~/.profile or equivalent (e.g. ~/.bash_profile, ~/.zprofile),which will take effect the next time you start a login shell.Otherwise, you might break a whole class of things that includes vex,in a way that cannot be reasonably automatically corrected. If you understood that, then you don't have to read the rest of this sectionwhich is just for explanation. Here's the longer story:Apparently some command-line tools have recommended in their docs that youstick things on the front of $PATH from ~/.bashrc (equivalently .zshrc, etc.)But this can cause problems for other utilities and scripts, if you do notunderstand the meaning of doing it this way instead of another way.The meaning of making these changes in files like ~/.bashrc instead ofother files is this: &quot;I want this directory to be searched for executablesbefore ANY other directory, EVERY time. This is VERY important to me. It's my favorite directory to find executables in.&quot;This might not normally be a problem for you. But it means that any other script or utility which puts another directory atthe front of PATH is going to be overruled. For example, vex helpfully puts thebin/ directory of the relevant virtualenv at the head of PATH. It's the onlyreasonable way to achieve this effect. But if your ~/.bashrc says &quot;SMASH PATH&quot;then when you run bash under vex, vex will hand off a perfectly goodvirtualenv-activated environment for bash to use, and then after vex hands offbash will smash PATH as you instructed, and something else will have prioritybefore your virtualenv stuff. There's nothing bash or vex can do about this because, first, it's impossibleto determine whether this was a mistake or something you literally intended,and not okay to squash the people who might literally intend this; and second,the only way that vex could override what you told bash to do would be for meto give you more shell-specific crap for you to source in ~/.bashrc thatmutates the current environment, which is exactly what vex is getting awayfrom. There is literally no way for vex to stop processes from messing up theirown environments, the best it can do is hand off the right thing.So instead of telling bash to do something that breaks vex, then wanting vex todo something which breaks everything else to override what you told bash to do,just don't make this change in ~/.bashrc unless you WANT other things to takeprecedence over your virtualenvs whenever you start bash. A good solution is to use ~/.profile (or similar files your shell uses like~/.bash_profile, ~/.zprofile) to make changes in PATH. Because this only runsat the creation of a login shell, e.g. when you log in to X, it is possiblefor vex and other utilities to make the right adjustment without somethingin ~/.bashrc squishing it immediately afterward. And when the subprocess goesaway, there is no environmental residue, and vex doesn't have to couple tospecific shells or depend on shell at all, and you don't have to put any morecrap in ~/.bashrc unless it's specifically what you mean to have there.A detail pertaining to shell environment variables like WORKON_HOME-------------------------------------------------------------------In shell, putting a tilde in quotes like '~' or &quot;~&quot; means you wantto suppress expansion of that into the path of your home directory.Therefore, if you set WORKON_HOME to some quoted value, it won't beexpanded, and vex will have no way to know whether you mean a pathwith a tilde in it, but will have to assume that you do.So when you set a variable like WORKON_HOME, use one of these styles::    export WORKON_HOME=~/.virtualenvs    export WORKON_HOME=$HOME/.virtualenvs    export WORKON_HOME=&quot;$HOME/.virtualenvs&quot;Options=======vex is simple so there aren't a lot of options.Since everyone seems to like workon more than specifying absolutevirtualenv paths, vex defaults to that kind of behavior.But it may still be necessary to use an absolute path now and then.So you can point vex at the absolute path of a virtualenv with ``--path``.For example, if you made a virtualenv under the current directorycalled env and don't want to type out ``source env/bin/activate``::    vex --path env pip freezeYou can also set which directory the subprocess starts in,like this shell which starts in ``/tmp``::    vex --cwd /tmp foo bashYou can also have vex create the named virtualenv before running the command::    vex --make foo bashOr you can have vex remove the already-existing virtualenv after running thecommand::    vex --remove foo bashOr you can create a previously nonexistent virtualenv, run the commandin it, then remove it once the command exits::    vex --make --remove foo bashThis can also be abbreviated as ``'vex -mr foo bash'``.For the benefit of people who do not use the shell completions,you can also list available virtualenvs::    vex --listThis should list the virtualenvs you have in the directoryspecified by 'virtualenvs=' in .vexrc or by setting $WORKON_HOME. ``--list`` does not combine with any other options.Since you might have many virtualenvs or you might be lookingfor something specific (or building your own completion),you can also list virtualenvs beginning with a certain prefix::    vex --list aIf you need more detailed filtering, pipe to grep or something.Config======Like many user-oriented command line utilities, vex has an optional configfile to specify defaults. Its default location ``~/.vexrc``. Example::    shell=bash    virtualenvs=~/.my_virtualenvs    env:        ANSWER=42This specifies that the result of running ``vex foo`` (no command)is to run bash, as in ``vex foo bash``;that the place to look for named virtualenvsis ``~/.my_virtualenvs``; and that processes you launched with vex should allget certain environment variables (in this case, ``ANSWER`` set to ``42``).Thanks to `Nick Coghlan &lt;https://github.com/ncoghlan&gt;`_, there is also anoption to specify the default python you want to use, if you haven't specifiedit. Here's an example line you could put in vexrc::    python=python3(Equivalent to always specifying ``--python python3`` when using ``vex -m``.)If you want to use a config someplace other than ``~/.vexrc``::    vex --config ~/.tempvexrc foo bashShell Prompts=============This section gives some simple examples of how you could customize your shellto reflect the current virtualenv, since vex intentionally does not mess withyour shell's prompt (in order to stay shell-agnostic).Beginner's note: don't put these in ``~/.vexrc``, that won't do anything!If you don't know what you're doing, use the suggested filenames.bash----Here is an example of what you could put in ``~/.bashrc``:.. code-block:: bash    function virtualenv_prompt() {        if [ -n &quot;$VIRTUAL_ENV&quot; ]; then            echo &quot;(${VIRTUAL_ENV##*/}) &quot;        fi    }    export PS1='$(virtualenv_prompt)\u@\H&gt; 'zsh---Here is an example of what you could put in ``~/.zshrc``:.. code-block:: bash    # zsh needs this option set to use $(virtualenv_prompt)    setopt prompt_subst    function virtualenv_prompt() {        if [ -n &quot;$VIRTUAL_ENV&quot; ]; then            echo &quot;(${VIRTUAL_ENV##*/}) &quot;        fi    }    export PROMPT='$(virtualenv_prompt)%n@%m&gt; 'ksh---Here is something you can start from in ``~/.kshrc``:.. code-block:: ksh    PS1='${VIRTUAL_ENV:+($( basename $VIRTUAL_ENV )) }${USER}@${HOSTNAME:=$(hostname)}:$PWD&gt; 'This should also work for mksh in ``~/.mkshrc``.fish----Here is some code you could put into ``~/.config/fish/functions/fish_prompt.fish``... code-block:: text    function fish_prompt        if test -n &quot;$VIRTUAL_ENV&quot;            set -l ve_tag (basename &quot;$VIRTUAL_ENV&quot;)            echo -n (set_color green)&quot;($ve_tag) &quot;(set_color normal)        end        printf '%s@%s %s%s%s&gt; ' (whoami) (hostname|cut -d . -f 1) (set_color $fish_color_cwd) (prompt_pwd) (set_color normal)    endtcsh----If you're among the proud few who use tcsh, this kind of works(and you may ridicule my terrible csh skills and propose a better solution!)However, it relies on ``$VIRTUAL_ENV`` never changing, so in other words it'sreally only usable if you stick to vex when using tcsh, and don't mess with``$VIRTUAL_ENV`` yourself. There has to be a better solution..... code-block:: tcsh    if ($?VIRTUAL_ENV == 0) then        set VIRTUAL_ENV=&quot;&quot;    endif    set prompt=&quot;`if ( &quot;$VIRTUAL_ENV&quot; != &quot;&quot; ) basename $VIRTUAL_ENV`|%N@%m:%~%# &quot;Shell Completion================vex provides a completely optional mechanism to set upcompletion of the 'vex' command for several popular shells.This allows you to do things like hitting the 'TAB' keyafter 'vex mye' and getting it expanded to 'vex myenv'.(Specific features depend on the shell.)It's completely optional. vex will work without it. So if vex doesn't havea completion configuration for your shell, don't worry, you can still use vex.And if you want a completion config, please suggest or contribute oneon `Github &lt;https://github.com/sashahart/vex&gt;`_.Since completion requires a modification of the current shellstate, and vex refuses to do this, it can be done by having the shellevaluate some lines emitted by vex.If you use these, use them EXACTLY as described here.For example, omitting quotes may have confusing results.And don't put these in ``~/.vexrc``, that won't do anything!bash----This could be put in, e.g., ``~/.bashrc``... code-block:: bash   eval &quot;$(vex --shell-config bash)&quot;OS X users may need to enable bash completion before this will work.zsh---This could be put in, e.g., ``~/.zshrc``... code-block:: bash   eval &quot;$(vex --shell-config zsh)&quot;If you did not already enable zsh completion, your .zshrc file should do thatbefore this will work, using e.g. 'autoload compinit; compinit'. The symptom ofthis problem will be something like 'command not found: compdef'.fish----This could be put in, e.g., ``~/.config/fish/config.fish``... code-block:: text    . (vex --shell-config fish|psub)Caveats=======Put optional flags for vex right after ``vex``. If you put them in thecommand, vex will naturally think they are meant for the command.For example, ``vex foo mope -h`` cannot be understood as providingan -h flag to vex; vex has to interpret it as part of the command.Even ``vex foo -h mope`` must interpret '-h mope' as a command, because it ispossible that an executable name on ``$PATH`` begins with a dash.vex won't use virtualenvs with names that start with a dash, because this isthe character which prefixes a command-line flag (option).Don't be surprised if 'vex foo sudo bash' results in a shell that doesn't useyour virtualenv. Safe sudo policy often controls the environment, notably asa default on Debian and Ubuntu. It's better not to mess with this policy,especially if you knew little enough that you wondered why it didn't work.As a workaround, you can use this:.. code-block:: bash    sudo env PATH=&quot;$PATH&quot; vex foo bashvex should not be particularly slow to mere mortals, but if you run ita million times in a script then the effects of python startup might becomenoticeable. If you have this problem, consider running your virtualenv's pythondirectly. (It works at least as well, it's just usually less convenient.)If you run e.g. ``bash -c ls`` you may see that ls does not generate color,because it decides whether to do that after detecting whether it is talking toa terminal. Similarly, commands run through vex are liable to suppress theircolor. Things like grep can be given options like --color=always, but then piped or redirected output will contain color codes. If you want to run Pythonunit tests in virtualenvs, just use `tox &lt;http://tox.readthedocs.org/en/latest/&gt;`_, it's great.As with other tools, if you want to use a virtualenv with spaces in the name,your shell is probably going to force you to quote its name in order to makethe tool understand you are not providing more than one actual argument.For example, ``vex foo bar baz`` will be interpreted by bash/zsh as running'bar baz' in virtualenv foo, NOT as running baz in 'foo bar' or anything else.Again, this isn't down to vex, it is just how these shells work.Mind the results of asking to run commands with shell variables in them.For example, you might expect this to print 'foo':.. code-block:: bash    vex foo echo $VIRTUAL_ENVThe reason it doesn't is that your current shell is interpreting $VIRTUAL_ENVeven before vex gets it or can pass it to the subprocess. You could quote it:.. code-block:: bash    vex foo echo '$VIRTUAL_ENV'but then it literally prints $VIRTUAL_ENV, not the shell evaluation of thevariable, because that isn't the job of vex. That's a job for bash to do... code-block:: bash    vex foo bash -c 'echo $VIRTUAL_ENV'</longdescription>
</pkgmetadata>