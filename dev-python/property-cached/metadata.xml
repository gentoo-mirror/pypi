<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>===============================property-cached===============================.. image:: https://img.shields.io/travis/althonos/property-cached/master.svg?style=flat-square   :target: https://travis-ci.org/althonos/property-cached.. image:: https://img.shields.io/codecov/c/gh/althonos/property-cached.svg?style=flat-square   :target: https://codecov.io/gh/althonos/property-cached.. image:: https://img.shields.io/pypi/v/property-cached.svg?style=flat-square   :target: https://pypi.python.org/pypi/property-cached.. image:: https://img.shields.io/badge/code%20style-black-000000.svg?style=flat-square   :target: https://github.com/ambv/blackA decorator for caching properties in classes (forked from ``cached-property``).This library was forked from the upstream library ``cached-property`` since itsdeveloper does not seem to be maintaining it anymore. It works as a drop-inreplacement with fully compatible API (import ``property_cached`` instead of``cached_property`` in your code and *voil√†*). In case development resumes onthe original library, this one is likely to be deprecated.*Slightly modified README included below:*Why?-----* Makes caching of time or computational expensive properties quick and easy.* Because I got tired of copy/pasting this code from non-web project to non-web project.How to use it--------------Let's define a class with an expensive property. Every time you stay there theprice goes up by $50!.. code-block:: python    class Monopoly(object):        def __init__(self):            self.boardwalk_price = 500        @property        def boardwalk(self):            # In reality, this might represent a database call or time            # intensive task like calling a third-party API.            self.boardwalk_price += 50            return self.boardwalk_priceNow run it:.. code-block:: python    &gt;&gt;&gt; monopoly = Monopoly()    &gt;&gt;&gt; monopoly.boardwalk    550    &gt;&gt;&gt; monopoly.boardwalk    600Let's convert the boardwalk property into a ``cached_property``... code-block:: python    from cached_property import cached_property    class Monopoly(object):        def __init__(self):            self.boardwalk_price = 500        @cached_property        def boardwalk(self):            # Again, this is a silly example. Don't worry about it, this is            #   just an example for clarity.            self.boardwalk_price += 50            return self.boardwalk_priceNow when we run it the price stays at $550... code-block:: python    &gt;&gt;&gt; monopoly = Monopoly()    &gt;&gt;&gt; monopoly.boardwalk    550    &gt;&gt;&gt; monopoly.boardwalk    550    &gt;&gt;&gt; monopoly.boardwalk    550Why doesn't the value of ``monopoly.boardwalk`` change? Because it's a **cached property**!Invalidating the Cache----------------------Results of cached functions can be invalidated by outside forces. Let's demonstrate how to force the cache to invalidate:.. code-block:: python    &gt;&gt;&gt; monopoly = Monopoly()    &gt;&gt;&gt; monopoly.boardwalk    550    &gt;&gt;&gt; monopoly.boardwalk    550    &gt;&gt;&gt; # invalidate the cache    &gt;&gt;&gt; del monopoly.__dict__['boardwalk']    &gt;&gt;&gt; # request the boardwalk property again    &gt;&gt;&gt; monopoly.boardwalk    600    &gt;&gt;&gt; monopoly.boardwalk    600Working with Threads---------------------What if a whole bunch of people want to stay at Boardwalk all at once? This means using threads, whichunfortunately causes problems with the standard ``cached_property``. In this case, switch to using the``threaded_cached_property``:.. code-block:: python    from cached_property import threaded_cached_property    class Monopoly(object):        def __init__(self):            self.boardwalk_price = 500        @threaded_cached_property        def boardwalk(self):            &quot;&quot;&quot;threaded_cached_property is really nice for when no one waits                for other people to finish their turn and rudely start rolling                dice and moving their pieces.&quot;&quot;&quot;            sleep(1)            self.boardwalk_price += 50            return self.boardwalk_priceNow use it:.. code-block:: python    &gt;&gt;&gt; from threading import Thread    &gt;&gt;&gt; from monopoly import Monopoly    &gt;&gt;&gt; monopoly = Monopoly()    &gt;&gt;&gt; threads = []    &gt;&gt;&gt; for x in range(10):    &gt;&gt;&gt;     thread = Thread(target=lambda: monopoly.boardwalk)    &gt;&gt;&gt;     thread.start()    &gt;&gt;&gt;     threads.append(thread)    &gt;&gt;&gt; for thread in threads:    &gt;&gt;&gt;     thread.join()    &gt;&gt;&gt; self.assertEqual(m.boardwalk, 550)Working with async/await (Python 3.5+)--------------------------------------The cached property can be async, in which case you have to use awaitas usual to get the value. Because of the caching, the value is onlycomputed once and then cached:.. code-block:: python    from cached_property import cached_property    class Monopoly(object):        def __init__(self):            self.boardwalk_price = 500        @cached_property        async def boardwalk(self):            self.boardwalk_price += 50            return self.boardwalk_priceNow use it:.. code-block:: python    &gt;&gt;&gt; async def print_boardwalk():    ...     monopoly = Monopoly()    ...     print(await monopoly.boardwalk)    ...     print(await monopoly.boardwalk)    ...     print(await monopoly.boardwalk)    &gt;&gt;&gt; import asyncio    &gt;&gt;&gt; asyncio.get_event_loop().run_until_complete(print_boardwalk())    550    550    550Note that this does not work with threading either, most asyncioobjects are not thread-safe. And if you run separate event loops ineach thread, the cached version will most likely have the wrong eventloop. To summarize, either use cooperative multitasking (event loop)or threading, but not both at the same time.Timing out the cache--------------------Sometimes you want the price of things to reset after a time. Use the ``ttl``versions of ``cached_property`` and ``threaded_cached_property``... code-block:: python    import random    from cached_property import cached_property_with_ttl    class Monopoly(object):        @cached_property_with_ttl(ttl=5) # cache invalidates after 5 seconds        def dice(self):            # I dare the reader to implement a game using this method of 'rolling dice'.            return random.randint(2,12)Now use it:.. code-block:: python    &gt;&gt;&gt; monopoly = Monopoly()    &gt;&gt;&gt; monopoly.dice    10    &gt;&gt;&gt; monopoly.dice    10    &gt;&gt;&gt; from time import sleep    &gt;&gt;&gt; sleep(6) # Sleeps long enough to expire the cache    &gt;&gt;&gt; monopoly.dice    3    &gt;&gt;&gt; monopoly.dice    3**Note:** The ``ttl`` tools do not reliably allow the clearing of the cache. Thisis why they are broken out into seperate tools. See https://github.com/pydanny/cached-property/issues/16.Credits--------* ``@pydanny`` for the original ``cached-property`` implementation.* Pip, Django, Werkzueg, Bottle, Pyramid, and Zope for having their own implementations. This package originally used an implementation that matched the Bottle version.* Reinout Van Rees for pointing out the `cached_property` decorator to me.* ``@audreyr``_ who created ``cookiecutter``_, which meant rolling this out took ``@pydanny`` just 15 minutes.* ``@tinche`` for pointing out the threading issue and providing a solution.* ``@bcho`` for providing the time-to-expire feature.. _`@audreyr`: https://github.com/audreyr.. _`cookiecutter`: https://github.com/audreyr/cookiecutter.. :changelog:History-------1.6.4 (2020-03-06)++++++++++++++++++* Fix some remaining Python 2 support code (`#25 &lt;https://github.com/althonos/property-cached/pull/25&gt;`_)1.6.3 (2019-09-07)++++++++++++++++++* Resolve `cached_property` docstring not showing (`#171 &lt;https://github.com/pydanny/cached-property/pull/171&gt;`_).1.6.2 (2019-07-22)++++++++++++++++++* Fix metadata to keep original author and add @althonos as maintainer1.6.1 (2019-07-22)++++++++++++++++++* Fix unneeded dependencies being present in ``setup.cfg``1.6.0 (2019-07-22)++++++++++++++++++* Fixed class hierarchy, ``cached_property`` now inherits from ``property``* Add support for slotted classes and stop using the object ``__dict__``* Improve function wrapping using ``functools.update_wrapper``* Implement the ``__set_name__`` magic method available since Python 3.61.5.1 (2018-08-05)++++++++++++++++++* Added formal support for Python 3.7* Removed formal support for Python 3.31.4.3  (2018-06-14)+++++++++++++++++++* Catch SyntaxError from asyncio import on older versions of Python, thanks to @asottile1.4.2 (2018-04-08)++++++++++++++++++* Really fixed tests, thanks to @pydanny1.4.1 (2018-04-08)++++++++++++++++++* Added conftest.py to manifest so tests work properly off the tarball, thanks to @dotlambda* Ensured new asyncio tests didn't break Python 2.7 builds on Debian, thanks to @pydanny* Code formatting via black, thanks to @pydanny and @ambv1.4.0 (2018-02-25)++++++++++++++++++* Added asyncio support, thanks to @vbraun* Remove Python 2.6 support, whose end of life was 5 years ago, thanks to @pydanny1.3.1 (2017-09-21)++++++++++++++++++* Validate for Python 3.61.3.0 (2015-11-24)++++++++++++++++++* Drop some non-ASCII characters from HISTORY.rst, thanks to @AdamWill* Added official support for Python 3.5, thanks to @pydanny and @audreyr* Removed confusingly placed lock from example, thanks to @ionelmc* Corrected invalidation cache documentation, thanks to @proofit404* Updated to latest Travis-CI environment, thanks to @audreyr1.2.0 (2015-04-28)++++++++++++++++++* Overall code and test refactoring, thanks to @gsakkis* Allow the del statement for resetting cached properties with ttl instead of del obj._cache[attr], thanks to @gsakkis.* Uncovered a bug in PyPy, https://bitbucket.org/pypy/pypy/issue/2033/attributeerror-object-attribute-is-read, thanks to @gsakkis* Fixed threaded_cached_property_with_ttl to actually be thread-safe, thanks to @gsakkis1.1.0 (2015-04-04)++++++++++++++++++* Regression: As the cache was not always clearing, we've broken out the time to expire feature to its own set of specific tools, thanks to @pydanny* Fixed typo in README, thanks to @zoidbergwill1.0.0 (2015-02-13)++++++++++++++++++* Added timed to expire feature to ``cached_property`` decorator.* **Backwards incompatiblity**: Changed ``del monopoly.boardwalk`` to ``del monopoly['boardwalk']`` in order to support the new TTL feature.0.1.5 (2014-05-20)++++++++++++++++++* Added threading support with new ``threaded_cached_property`` decorator* Documented cache invalidation* Updated credits* Sourced the bottle implementation0.1.4 (2014-05-17)++++++++++++++++++* Fix the dang-blarged py_modules argument.0.1.3 (2014-05-17)++++++++++++++++++* Removed import of package into ``setup.py``0.1.2 (2014-05-17)++++++++++++++++++* Documentation fixes. Not opening up a RTFD instance for this because it's so simple to use.0.1.1 (2014-05-17)++++++++++++++++++* setup.py fix. Whoops!0.1.0 (2014-05-17)++++++++++++++++++* First release on PyPI.</longdescription>
</pkgmetadata>