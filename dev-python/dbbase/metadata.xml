<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>## Introduction**dbbase** implements a light-weight wrapper around SQLAlchemy in the style of Flask-SQLAlchemy, but without the requirements of Flask. So the same models and classes used in a Flask project can be used in other contexts than web applications.The package focuses on three areas of interest.* Convenience functions as part of the Model class with easy access to the session and query object, as well as simple functions for saving, etc. within the Model class.* Serialization functions enable expressing model data as both JSON and dictionary objects. This feature facilitates easy access to views. The views can be scaled up to include objects created by relationships with explicit control over the content, or show only the bare minimum. These functions can be used as part of an API.* Document dictionaries introspect the model classes you have built and present the data objects in a format similar to Swagger / OpenAPI. This enables a method for communicating the details of the models. In addition, the functions could be wrapped into parsing functions that evaluate query strings and form data, directly from the table characteristics. This avoids the extra work of defining tables, and then coding a separate schema just to evaluate incoming and outgoing data. Finally, the doc functions could be used as a basis for unit/integration tests to ensure that all the requirements for the data have been met.## Characteristics### Engine BehaviorIntegration of session / query with table classes.Just as with Flask-SQLAlchemy, the `db` object carries a lot of the SQLAlchemy functionality. The `db` object has session as well as the other standard SQLAlchemy features.### Model Behavior#### Model CreationBelow is typical example of a table class with `dbbase`. Like Flask-SQLAlchemy, the models are created with db.Model that is an enhanced version of SQLAlchemy's declarative base.```python    class Job(db.Model):        __tablename__ = 'jobs'        id = db.Column(db.Integer, primary_key=True)        name = db.Column(db.String, nullable=False)        another_id = db.Column(db.SmallInteger)        start_date = db.Column(db.Date, default=date.today)        update_at = db.Column(db.DateTime, onupdate=datetime.now)        completed_at = db.Column(db.DateTime)        completion_status = db.Column(db.SmallInteger, default=0)```#### Record CreationRecord creation uses the standard methods.```python    job = Job(        name='model build process',        another_id=4        # letting defaults through    )    db.session.add(job)    db.session.commit()    # alternatively    job.save()```#### QueriesThe Model class also holds the query object.Using SQLAlchemy, you would have a session object and do something along the lines of:```python    session.query(Job).filter(Job.start_date &gt; '2020-04-01').all()```With Flask-SQLAlchemy and dbbase you would do:```python    Job.query.filter(Job.start_date &gt; '2020-04-01').all()```#### SerializationTo accommodate differing formatting standards between JavaScript and Python when outputting JSON formatted data, the following conversion is available.Start with a record:```pythonjob = Job(    id=123303,    name='model build process',    another_id=4,    start_date='2020-04-15',    update_at=datetime.datetime(2020, 4, 20, 3, 2, 1)    completed_at = datetime.date(2020, 4, 30)    completion_status = 0).save()job.serialize(){    &quot;id&quot;: 123303,    &quot;name&quot;: &quot;model build process&quot;,    &quot;anotherId&quot;: 4,    &quot;startDate&quot;: &quot;2020-04-15&quot;,    &quot;updateAt&quot;: &quot;2020-04-20 03:02:01&quot;    &quot;endDate&quot; = &quot;2020-4-30&quot;    &quot;completionStatus&quot; = 0}```Or, `job.serialize(to_camel_case=False)` would output it without any camel case conversion.Incoming data could also be formatted as serialized above, and deserialiedvia```python    Job.deserialize(data, from_camel_case=True)```Note that this does not update the record directly (the job in this example). Rather, the output is in the form of a dict. This gives an opportunity to evaluate the data prior to updating the record and database.For example, suppose you also use `parser = reqparse.RequestParser()` fromFlask-Restful on the Flask side of things:```python    data = Job.deserialize(        JobResource.parser.parse_args())    job = Job(id, **data)```Finally, the serialize / deserialize functions can always be subclassed for special requirements of that particular model.### Document DictionariesThe same model, Job, can be expressed with details similarly to the OpenAPI specification for objects. It is a little different because SQLAlchemy has a more nuanced approach to defaults and onupdate functions, and foreign keys. Just as serialization mentioned above of objects can control what columns to include, the documentation function, `db.doc_table` enables control of what fields to include and what column properties to include.The following command```python    db.doc_table(Job, to_camel_case=True, serial_fields=None, column_props=None)```produces this output.```json{    &quot;Job&quot;: {        &quot;type&quot;: &quot;object&quot;,        &quot;properties&quot;: {            &quot;id&quot;: {                &quot;type&quot;: &quot;integer&quot;,                &quot;format&quot;: &quot;int32&quot;,                &quot;primary_key&quot;: true,                &quot;nullable&quot;: false,                &quot;info&quot;: {}            },            &quot;name&quot;: {                &quot;type&quot;: &quot;string&quot;,                &quot;nullable&quot;: false,                &quot;info&quot;: {}            },            &quot;anotherId&quot;: {                &quot;type&quot;: &quot;integer&quot;,                &quot;format&quot;: &quot;int8&quot;,                &quot;nullable&quot;: true,                &quot;info&quot;: {}            },            &quot;startDate&quot;: {                &quot;type&quot;: &quot;date&quot;,                &quot;nullable&quot;: true,                &quot;default&quot;: {                    &quot;for_update&quot;: false,                    &quot;arg&quot;: &quot;date.today&quot;                },                &quot;info&quot;: {}            },            &quot;updateAt&quot;: {                &quot;type&quot;: &quot;date-time&quot;,                &quot;nullable&quot;: true,                &quot;onupdate&quot;: {                    &quot;for_update&quot;: true,                    &quot;arg&quot;: &quot;datetime.now&quot;                },                &quot;info&quot;: {}            },            &quot;completedAt&quot;: {                &quot;type&quot;: &quot;date-time&quot;,                &quot;nullable&quot;: true,                &quot;info&quot;: {}            },            &quot;completionStatus&quot;: {                &quot;type&quot;: &quot;integer&quot;,                &quot;format&quot;: &quot;int8&quot;,                &quot;nullable&quot;: true,                &quot;default&quot;: {                    &quot;for_update&quot;: false,                    &quot;arg&quot;: 0                },                &quot;info&quot;: {}            }        },        &quot;xml&quot;: &quot;Job&quot;    }}```## MoreAdditional documentation can be found at https://sidorof.github.io/dbbase/</longdescription>
</pkgmetadata>