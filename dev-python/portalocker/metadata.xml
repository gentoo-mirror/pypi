<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>############################################portalocker - Cross-platform locking library############################################.. image:: https://github.com/WoLpH/portalocker/actions/workflows/python-package.yml/badge.svg?branch=master    :alt: Linux Test Status    :target: https://github.com/WoLpH/portalocker/actions/.. image:: https://ci.appveyor.com/api/projects/status/mgqry98hgpy4prhh?svg=true    :alt: Windows Tests Status    :target: https://ci.appveyor.com/project/WoLpH/portalocker.. image:: https://coveralls.io/repos/WoLpH/portalocker/badge.svg?branch=master    :alt: Coverage Status    :target: https://coveralls.io/r/WoLpH/portalocker?branch=masterOverview--------Portalocker is a library to provide an easy API to file locking.An important detail to note is that on Linux and Unix systems the locks areadvisory by default. By specifying the `-o mand` option to the mount command itis possible to enable mandatory file locking on Linux. This is generally notrecommended however. For more information about the subject: - https://en.wikipedia.org/wiki/File_locking - http://stackoverflow.com/questions/39292051/portalocker-does-not-seem-to-lock - https://stackoverflow.com/questions/12062466/mandatory-file-lock-on-linuxThe module is currently maintained by Rick van Hattem &lt;Wolph@wol.ph&gt;.The project resides at https://github.com/WoLpH/portalocker . Bugs and featurerequests can be submitted there. Patches are also very welcome.Security contact information------------------------------------------------------------------------------To report a security vulnerability, please use the`Tidelift security contact &lt;https://tidelift.com/security&gt;`_.Tidelift will coordinate the fix and disclosure.Redis Locks-----------This library now features a lock based on Redis which allows for locks acrossmultiple threads, processes and even distributed locks across multiplecomputers.It is an extremely reliable Redis lock that is based on pubsub.As opposed to most Redis locking systems based on key/value pairs,this locking method is based on the pubsub system. The big advantage isthat if the connection gets killed due to network issues, crashingprocesses or otherwise, it will still immediately unlock instead ofwaiting for a lock timeout.First make sure you have everything installed correctly:::    pip install &quot;portalocker[redis]&quot;Usage is really easy:::    import portalocker    lock = portalocker.RedisLock('some_lock_channel_name')    with lock:        print('do something here')The API is essentially identical to the other ``Lock`` classes so in additionto the ``with`` statement you can also use ``lock.acquire(...)``.Python 2--------Python 2 was supported in versions before Portalocker 2.0. If you are stillusingPython 2,you can run this to install:::    pip install &quot;portalocker&lt;2&quot;Tips----On some networked filesystems it might be needed to force a `os.fsync()` beforeclosing the file so it's actually written before another client reads the file.Effectively this comes down to:::   with portalocker.Lock('some_file', 'rb+', timeout=60) as fh:       # do what you need to do       ...       # flush and sync to filesystem       fh.flush()       os.fsync(fh.fileno())Links-----* Documentation    - http://portalocker.readthedocs.org/en/latest/* Source    - https://github.com/WoLpH/portalocker* Bug reports    - https://github.com/WoLpH/portalocker/issues* Package homepage    - https://pypi.python.org/pypi/portalocker* My blog    - http://w.wol.ph/Examples--------To make sure your cache generation scripts don't race, use the `Lock` class:&gt;&gt;&gt; import portalocker&gt;&gt;&gt; with portalocker.Lock('somefile', timeout=1) as fh:...     print('writing some stuff to my cache...', file=fh)To customize the opening and locking a manual approach is also possible:&gt;&gt;&gt; import portalocker&gt;&gt;&gt; file = open('somefile', 'r+')&gt;&gt;&gt; portalocker.lock(file, portalocker.LockFlags.EXCLUSIVE)&gt;&gt;&gt; file.seek(12)&gt;&gt;&gt; file.write('foo')&gt;&gt;&gt; file.close()Explicitly unlocking is not needed in most cases but omitting it has been knownto cause issues:https://github.com/AzureAD/microsoft-authentication-extensions-for-python/issues/42#issuecomment-601108266If needed, it can be done through:&gt;&gt;&gt; portalocker.unlock(file)Do note that your data might still be in a buffer so it is possible that yourdata is not available until you `flush()` or `close()`.To create a cross platform bounded semaphore across multiple processes you canuse the `BoundedSemaphore` class which functions somewhat similar to`threading.BoundedSemaphore`:&gt;&gt;&gt; import portalocker&gt;&gt;&gt; n = 2&gt;&gt;&gt; timeout = 0.1&gt;&gt;&gt; semaphore_a = portalocker.BoundedSemaphore(n, timeout=timeout)&gt;&gt;&gt; semaphore_b = portalocker.BoundedSemaphore(n, timeout=timeout)&gt;&gt;&gt; semaphore_c = portalocker.BoundedSemaphore(n, timeout=timeout)&gt;&gt;&gt; semaphore_a.acquire()&lt;portalocker.utils.Lock object at ...&gt;&gt;&gt;&gt; semaphore_b.acquire()&lt;portalocker.utils.Lock object at ...&gt;&gt;&gt;&gt; semaphore_c.acquire()Traceback (most recent call last):  ...portalocker.exceptions.AlreadyLockedMore examples can be found in the`tests &lt;http://portalocker.readthedocs.io/en/latest/_modules/tests/tests.html&gt;`_.Versioning----------This library follows `Semantic Versioning &lt;http://semver.org/&gt;`_.Changelog---------Every release has a ``git tag`` with a commit message for the tagexplaining what was added and/or changed. The list of tags/releasesincluding the commit messages can be found here:https://github.com/WoLpH/portalocker/releasesLicense-------See the `LICENSE &lt;https://github.com/WoLpH/portalocker/blob/develop/LICENSE&gt;`_ file.</longdescription>
</pkgmetadata>