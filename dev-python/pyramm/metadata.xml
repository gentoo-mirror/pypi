<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pyramm&lt;img align=&quot;right&quot; src=&quot;https://github.com/captif-nz/pyramm/actions/workflows/push.yml/badge.svg&quot;&gt;Python wrapper for the [RAMM API](https://api.ramm.com/v1/documentation/index).**Users must have their own login for the RAMM database.**## Installation```bashpip install pyramm```## IssuesPlease submit an issue if you find a bug or have an idea for an improvement.## InitialiseYou must first initialise the connection to the RAMM API as follows. Note that the`database` argument defaults to `&quot;SH New Zealand&quot;` if it is not provided.```pythonfrom pyramm.api import Connectionconn = Connection(username, password, database=&quot;SH New Zealand&quot;)```Alternatively the username and password can be stored in file called `.pyramm.ini`. Thisfile must be saved in the users home directory (`&quot;~&quot;` on linux) and contain the following:```ini[RAMM]USERNAME = usernamePASSWORD = password```You are then able to initialise the RAMM API connection without providing your logincredentials each time.```pythonfrom pyramm.api import Connectionconn = Connection()```## Table and column namesA list of available tables can be accessed using:```pythontable_names = conn.table_names()```A list of columns for a given table can be accessed using:```pythoncolumn_names = conn.column_names(table_name)```## Table dataSome methods are attached to the `Connection` object to provide convenient access toselected RAMM tables. These helper methods implement some additional filtering (exposedas method arguments) and automatically set the DataFrame index to the correct tablecolumn(s).Tables not listed in the sections below can be accessed using the general `get_data()`method:```pythondf = conn.get_data(table_name)```### General tables:```pythonroadnames = conn.roadnames()``````pythoncarrway = conn.carr_way(road_id=None)``````pythonc_surface = conn.c_surface(road_id=None)``````pythontop_surface = conn.top_surface()``````pythonsurf_material = conn.surf_material()``````pythonsurf_category = conn.surf_category()``````pythonminor_structure = conn.minor_structure()```### HSD tables:```pythonhsd_roughness = conn.hsd_roughness(road_id, latest=True, survey_year=None)``````pythonhsd_roughness_hdr = conn.hsd_roughness_hdr()``````pythonhsd_rutting = conn.hsd_rutting(road_id, latest=True, survey_year=None)``````pythonhsd_rutting_hdr = conn.hsd_rutting_hdr()``````pythonhsd_texture = conn.hsd_texture(road_id, latest=True, survey_year=None)``````pythonhsd_texture_hdr = conn.hsd_texture_hdr()```## CentrelineThe `Centreline` object is provided to: - assist with generating geometry for table entries (based on `road_id`, `start_m` and`end_m` values), &lt;!-- - find the nearest geometry element to give a point (`latitude`, `longitude`), --&gt; - find the displacement (in metres) along the nearest geometry element given a point(`latitude`, `longitude`).The base geometry used by the `Centreline` object is derived from the `carr_way` table.### Create a Centreline instance:```pythoncentreline = conn.centreline()```### Append geometry to table:For a table containing `road_id`, `start_m` and `end_m` columns, the geometry can beappended using the `append_geometry()` method:```pythondf = centreline.append_geometry(df, geometry_type=&quot;wkt&quot;)```The `geometry_type` argument defaults to `&quot;wkt&quot;`. This will provide a[WKT](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry)LineString for each row.Alternatively, `geometry_type` can be set to `&quot;coord&quot;` to appenda `northing` and `easting` column to the DataFrame.### Find carriageway and position from point coordinates:The carriageway and position information (e.g. Rs/Rp) can be determined for a point coordinateusing the `position()` method:```pythonpoint = Point((172.618567, -43.441594))  # Shapely Point objectposition = centreline.position(point, point_crs=4326, road_id=None)```The point coordinate reference system defaults to WGS84 but can be adjusted using the`point_crs` argument. The value must be an integer corresponing to the[EPSG code](https://epsg.io/) (e.g. `4326` for WGS84).If the `road_id` argument is provided then the position will be determined only for thespecified road. Otherwise the position will be determined for the nearest road.#### Partial centrelineSometimes it is necessary to match only to selected parts of the RAMM centreline. In thiscase a partial centreline can be generated and used for the matching:```python# Generate a partial centreline containing only road_id 3656 between route position 10m# and 100m:partial_centreline = conn.centreline(lengths={3656: [10, 100]})point = Point((172.608406, -43.451023))position = partial_centreline.position(point)```The `lengths` argument is a Python dictionary containing `road_id` keys and start/endposition pair values. Some examples include:- `{3656: None}` includes the entire centreline for road_id 3656.- `{3656: [10, 100]}` includes only the section of centreline for road_id 3656 between route position 10m and 100m.- `{3656: [500, None]}` includes only the section of centreline for road_id 3656 from route position 500m.</longdescription>
</pkgmetadata>