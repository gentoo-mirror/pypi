<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>===============================================================================parse_type===============================================================================.. image:: https://github.com/jenisys/parse_type/actions/workflows/test.yml/badge.svg    :target: https://github.com/jenisys/parse_type/actions/workflows/test.yml    :alt: CI Build Status.. image:: https://img.shields.io/pypi/v/parse_type.svg    :target: https://pypi.python.org/pypi/parse_type    :alt: Latest Version.. image:: https://img.shields.io/pypi/dm/parse_type.svg    :target: https://pypi.python.org/pypi/parse_type    :alt: Downloads.. image:: https://img.shields.io/pypi/l/parse_type.svg    :target: https://pypi.python.org/pypi/parse_type/    :alt: License`parse_type`_ extends the `parse`_ module (opposite of `string.format()`_)with the following features:* build type converters for common use cases (enum/mapping, choice)* build a type converter with a cardinality constraint (0..1, 0..*, 1..*)    from the type converter with cardinality=1.* compose a type converter from other type converters* an extended parser that supports the CardinalityField naming schema    and creates missing type variants (0..1, 0..*, 1..*) from the    primary type converter.. _parse_type: http://pypi.python.org/pypi/parse_type.. _parse:      http://pypi.python.org/pypi/parse.. _`string.format()`: http://docs.python.org/library/string.html#format-string-syntaxDefinitions-------------------------------------------------------------------------------*type converter*    A type converter function that converts a textual representation    of a value type into instance of this value type.    In addition, a type converter function is often annotated with attributes    that allows the `parse`_ module to use it in a generic way.    A type converter is also called a *parse_type* (a definition used here).*cardinality field*    A naming convention for related types that differ in cardinality.    A cardinality field is a type name suffix in the format of a field.    It allows parse format expression, ala::        &quot;{person:Person}&quot;     #&lt; Cardinality: 1    (one; the normal case)        &quot;{person:Person?}&quot;    #&lt; Cardinality: 0..1 (zero or one  = optional)        &quot;{persons:Person*}&quot;   #&lt; Cardinality: 0..* (zero or more = many0)        &quot;{persons:Person+}&quot;   #&lt; Cardinality: 1..* (one  or more = many)    This naming convention mimics the relationship descriptions in UML diagrams.Basic Example-------------------------------------------------------------------------------Define an own type converter for numbers (integers):.. code-block:: python    # -- USE CASE:    def parse_number(text):        return int(text)    parse_number.pattern = r&quot;\d+&quot;  # -- REGULAR EXPRESSION pattern for type.This is equivalent to:.. code-block:: python    import parse    @parse.with_pattern(r&quot;\d+&quot;)    def parse_number(text):         return int(text)    assert hasattr(parse_number, &quot;pattern&quot;)    assert parse_number.pattern == r&quot;\d+&quot;.. code-block:: python    # -- USE CASE: Use the type converter with the parse module.    schema = &quot;Hello {number:Number}&quot;    parser = parse.Parser(schema, dict(Number=parse_number))    result = parser.parse(&quot;Hello 42&quot;)    assert result is not None, &quot;REQUIRE: text matches the schema.&quot;    assert result[&quot;number&quot;] == 42    result = parser.parse(&quot;Hello XXX&quot;)    assert result is None, &quot;MISMATCH: text does not match the schema.&quot;.. hint::    The described functionality above is standard functionality    of the `parse`_ module. It serves as introduction for the remaining cases.Cardinality-------------------------------------------------------------------------------Create an type converter for &quot;ManyNumbers&quot; (List, separated with commas)with cardinality &quot;1..* = 1+&quot; (many) from the type converter for a &quot;Number&quot;... code-block:: python    # -- USE CASE: Create new type converter with a cardinality constraint.    # CARDINALITY: many := one or more (1..*)    from parse import Parser    from parse_type import TypeBuilder    parse_numbers = TypeBuilder.with_many(parse_number, listsep=&quot;,&quot;)    schema = &quot;List: {numbers:ManyNumbers}&quot;    parser = Parser(schema, dict(ManyNumbers=parse_numbers))    result = parser.parse(&quot;List: 1, 2, 3&quot;)    assert result[&quot;numbers&quot;] == [1, 2, 3]Create an type converter for an &quot;OptionalNumbers&quot; with cardinality &quot;0..1 = ?&quot;(optional) from the type converter for a &quot;Number&quot;... code-block:: python    # -- USE CASE: Create new type converter with cardinality constraint.    # CARDINALITY: optional := zero or one (0..1)    from parse import Parser    from parse_type import TypeBuilder    parse_optional_number = TypeBuilder.with_optional(parse_number)    schema = &quot;Optional: {number:OptionalNumber}&quot;    parser = Parser(schema, dict(OptionalNumber=parse_optional_number))    result = parser.parse(&quot;Optional: 42&quot;)    assert result[&quot;number&quot;] == 42    result = parser.parse(&quot;Optional: &quot;)    assert result[&quot;number&quot;] == NoneEnumeration (Name-to-Value Mapping)-------------------------------------------------------------------------------Create an type converter for an &quot;Enumeration&quot; from the description ofthe mapping as dictionary... code-block:: python    # -- USE CASE: Create a type converter for an enumeration.    from parse import Parser    from parse_type import TypeBuilder    parse_enum_yesno = TypeBuilder.make_enum({&quot;yes&quot;: True, &quot;no&quot;: False})    parser = Parser(&quot;Answer: {answer:YesNo}&quot;, dict(YesNo=parse_enum_yesno))    result = parser.parse(&quot;Answer: yes&quot;)    assert result[&quot;answer&quot;] == TrueCreate an type converter for an &quot;Enumeration&quot; from the description ofthe mapping as an enumeration class (`Python 3.4 enum`_ or the `enum34`_backport; see also: `PEP-0435`_)... code-block:: python    # -- USE CASE: Create a type converter for enum34 enumeration class.    # NOTE: Use Python 3.4 or enum34 backport.    from parse import Parser    from parse_type import TypeBuilder    from enum import Enum    class Color(Enum):        red   = 1        green = 2        blue  = 3    parse_enum_color = TypeBuilder.make_enum(Color)    parser = Parser(&quot;Select: {color:Color}&quot;, dict(Color=parse_enum_color))    result = parser.parse(&quot;Select: red&quot;)    assert result[&quot;color&quot;] is Color.red.. _`Python 3.4 enum`: http://docs.python.org/3.4/library/enum.html#module-enum.. _enum34:   http://pypi.python.org/pypi/enum34.. _PEP-0435: http://www.python.org/dev/peps/pep-0435Choice (Name Enumeration)-------------------------------------------------------------------------------A Choice data type allows to select one of several strings.Create an type converter for an &quot;Choice&quot; list, a list of unique names(as string)... code-block:: python    from parse import Parser    from parse_type import TypeBuilder    parse_choice_yesno = TypeBuilder.make_choice([&quot;yes&quot;, &quot;no&quot;])    schema = &quot;Answer: {answer:ChoiceYesNo}&quot;    parser = Parser(schema, dict(ChoiceYesNo=parse_choice_yesno))    result = parser.parse(&quot;Answer: yes&quot;)    assert result[&quot;answer&quot;] == &quot;yes&quot;Variant (Type Alternatives)-------------------------------------------------------------------------------Sometimes you need a type converter that can accept text for multipletype converter alternatives. This is normally called a &quot;variant&quot; (or: union).Create an type converter for an &quot;Variant&quot; type that accepts:* Numbers (positive numbers, as integer)* Color enum values (by name).. code-block:: python    from parse import Parser, with_pattern    from parse_type import TypeBuilder    from enum import Enum    class Color(Enum):        red   = 1        green = 2        blue  = 3    @with_pattern(r&quot;\d+&quot;)    def parse_number(text):        return int(text)    # -- MAKE VARIANT: Alternatives of different type converters.    parse_color = TypeBuilder.make_enum(Color)    parse_variant = TypeBuilder.make_variant([parse_number, parse_color])    schema = &quot;Variant: {variant:Number_or_Color}&quot;    parser = Parser(schema, dict(Number_or_Color=parse_variant))    # -- TEST VARIANT: With number, color and mismatch.    result = parser.parse(&quot;Variant: 42&quot;)    assert result[&quot;variant&quot;] == 42    result = parser.parse(&quot;Variant: blue&quot;)    assert result[&quot;variant&quot;] is Color.blue    result = parser.parse(&quot;Variant: __MISMATCH__&quot;)    assert not resultExtended Parser with CardinalityField support-------------------------------------------------------------------------------The parser extends the ``parse.Parser`` and adds the following functionality:* supports the CardinalityField naming scheme* automatically creates missing type variants for types with  a CardinalityField by using the primary type converter for cardinality=1* extends the provide type converter dictionary with new type variants.Example:.. code-block:: python    # -- USE CASE: Parser with CardinalityField support.    # NOTE: Automatically adds missing type variants with CardinalityField part.    # USE:  parse_number() type converter from above.    from parse_type.cfparse import Parser    # -- PREPARE: parser, adds missing type variant for cardinality 1..* (many)    type_dict = dict(Number=parse_number)    schema = &quot;List: {numbers:Number+}&quot;    parser = Parser(schema, type_dict)    assert &quot;Number+&quot; in type_dict, &quot;Created missing type variant based on: Number&quot;    # -- USE: parser.    result = parser.parse(&quot;List: 1, 2, 3&quot;)    assert result[&quot;numbers&quot;] == [1, 2, 3]</longdescription>
</pkgmetadata>