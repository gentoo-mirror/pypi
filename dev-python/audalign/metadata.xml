<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># AudalignPackage for processing and aligning audio files using audio fingerprinting, cross-correlation, cross-correlation with spectrograms, or visual alignment techniques.![gif of audalign aligning](audalign.gif)This package offers tools to align many recordings of the same event. It has two main purposes: to accurately align recordings, and to process the audio files prior to alignments. All main functions are accessed through functions in the audalign.\_\_init\_\_ file. The recognizers themselves are objects in the recognizer directory which in turn have configurations in the config directories. Alignments are primarily accomplished with fingerprinting, though where fingerprinting fails, correlation, correlation with spectrograms, and visual alignment techniques can be used to get a closer result. After an initial alignment is found, that alignment can be passed to &quot;fine_align,&quot; which will find smaller, relative alignments to the main one.---Each alignment technique has different degrees of adjustment for accuracy settings. Fingerprinting parameters can be generally set to get consistent results using it's config's `set_accuracy` method. Visual alignment has many parameters that can be adjusted and requires case by case adjustment. Parameters for correlation are focused on sample rate or scipy's find_peaks.[Noisereduce](https://timsainburg.com/noise-reduction-python.html) is very useful for this application and a wrapper is implemented for ease of use. Uniformly leveling prior to noise reduction using uniform_level_file boosts quiet but important sound features.Alignment and recognition results consist of a dictionary. If an output directory is given, silence is placed before all target files so that they will automatically be aligned and writen to the output directory along with an audio file containing the combined sum. A `rankings` key is included in each alignment and recognition result. This helps determine the strength of the alignment, but is not definitive proof. Values range from 1-10.---All formats that ffmpeg or libav support are supported here.All fingerprints are stored in memory in the `FingerprintRecognzier` and must be saved to disk with the `save_fingerprinted_files` method in order to persist them.Regular file recogniton can also be done with Audalign similar to [dejavu](https://github.com/worldveil/dejavu).For more details on implementation and results, see the [wiki!!](https://github.com/benfmiller/audalign/wiki)## InstallationInstall from PyPI:Don't forget to install ffmpeg/avlib (Below in the Readme)!```bashpip install audalign```OR```bashgit clone https://github.com/benfmiller/audalign.gitcd audalign/pip install audalign```ORDownload and extract audalign then```bashpip install audalign```in the directory## RecognizersThere are currently four included recognizers, each with their own config objects.```pythonimport audalign as adfingerprint_rec = ad.FingerprintRecognizer()correlation_rec = ad.CorrelationRecognizer()cor_spec_rec = ad.CorrelationSpectrogramRecognizer()visual_rec = ad.VisualRecognizer()fingerprint_rec.config.set_accuracy(3)# recognizer.config.some_item```For more info about the configuration objects, check out the [wiki](https://github.com/benfmiller/audalign/wiki) or the config objects themselves. They are relatively nicely commented.Recognizers are then passed to recognize and align functions.```pythonresults = ad.align(&quot;target/folder/&quot;, recognizer=fingerprint_rec)results = ad.align(&quot;target/folder/&quot;, recognizer=correlation_rec)results = ad.align(&quot;target/folder/&quot;, recognizer=cor_spec_rec)results = ad.align(&quot;target/folder/&quot;, recognizer=visual_rec)results = ad.recognize(&quot;target/file1&quot;, &quot;target/file2&quot;, recognizer=fingerprint_rec)results = ad.recognize(&quot;target/file1&quot;, &quot;target/folder&quot;, recognizer=fingerprint_rec)# orresults = ad.target_align(    &quot;target/files&quot;,    &quot;target/folder/&quot;,    destination_path=&quot;write/alignments/to/folder&quot;,    recognizer=fingerprint_rec)# orresults = ad.align_files(    &quot;target/file1&quot;,    &quot;target/file2&quot;,    destination_path=&quot;write/alignments/to/folder&quot;,    recognizer=correlation_rec)# results can then be sent to fine_alignfine_results = ad.fine_align(    results,    recognizer=cor_spec_rec,)```Correlation is more precise than fingerprints and will always give a best alignment unlike fingerprinting, which can return no alignment. `max_lags` is very important for fine aligning. `locality` can be very useful for all alignments and recognitions.## Other Functions```python# wrapper for timsainb/noisereducead.remove_noise_file(    &quot;target/file&quot;,    &quot;5&quot;, # noise start in seconds    &quot;20&quot;, # noise end in seconds    &quot;destination/file&quot;,    alt_noise_filepath=&quot;different/sound/file&quot;,    prop_decrease=&quot;0.5&quot;, # If you want noise half reduced)ad.remove_noise_directory(    &quot;target/directory/&quot;,    &quot;noise/file&quot;,    &quot;5&quot;, # noise start in seconds    &quot;20&quot;, # noise end in seconds    &quot;destination/directory&quot;,    prop_decrease=&quot;0.5&quot;, # If you want noise half reduced)ad.uniform_level_file(    &quot;target/file&quot;,    &quot;destination&quot;,    mode=&quot;normalize&quot;,    width=5,)ad.plot(&quot;file.wav&quot;) # Plots spectrogram with peaks overlaidad.convert_audio_file(&quot;audio.wav&quot;, &quot;audio.mp3&quot;) # Also convert video file to audio filead.get_metadata(&quot;file.wav&quot;) # Returns metadata from ffmpeg/ avlib```You can easily recalcute the alignment shifts from previous results using recalc_shifts.You can then write those shifts using write_shifts_from_results. write_shifts_from_results alsolets you use different source files for alignments too.```pythonrecalculated_results = ad.recalc_shifts(older_results)ad.write_shifts_from_results(recalculated_results, &quot;destination&quot;, &quot;source_files_folder_or_file_list&quot;)```## FingerprintingFingerprinting is only used in the FingerprintRecognizer object. Alignments are not independent, so fingerprints created before alignments will be used for the alignment. The exception of this is in fine_aligning, where new fingerprints are always created.Running recognitions will fingerprint all files in the recognitions not already fingerprinted.```pythonfingerprint_rec = ad.FingerprintRecognizer()fingerprint_rec.fingerprint_file(&quot;test_file.wav&quot;)# orfingerprint_rec.fingerprint_directory(&quot;audio/directory&quot;)```fingerprints are stored in fingerprint_rec and can be saved by```pythonfingerprint_rec.save_fingerprinted_files(&quot;save_file.json&quot;) # or .pickle# or loaded withfingerprint_rec.load_fingerprinted_files(&quot;save_file.json&quot;) # or .pickle```## Getting ffmpeg set upYou can use **ffmpeg or libav**.Mac (using [homebrew](http://brew.sh)):```bash# ffmpegbrew install ffmpeg --with-libvorbis --with-sdl2 --with-theora####    OR    ###### libavbrew install libav --with-libvorbis --with-sdl --with-theora```Linux (using apt):```bash# ffmpegapt-get install ffmpeg libavcodec-extra####    OR    ###### libavapt-get install libav-tools libavcodec-extra```Windows:1. Download and extract ffmpeg from [Windows binaries provided here](https://ffmpeg.org/download.html).2. Add the ffmpeg `/bin` folder to your PATH environment variableOR1. Download and extract libav from [Windows binaries provided here](http://builds.libav.org/windows/).2. Add the libav `/bin` folder to your PATH environment variable</longdescription>
</pkgmetadata>