<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=====mkenv=====|PyPI| |Pythons| |Travis| |AppVeyor|mkenv is a tool for configuring, in a single file, a set of virtualenvs,which packages to install into each, and any binaries to make globallyavailable from within.Installation------------The usual::    $ pip install mkenvUsage-----The best way to use ``mkenv`` is by creating a file named``~/.local/share/virtualenvs/virtualenvs.toml``. Here's an example of what goesin it:.. code-block:: toml    [virtualenv.development]    install = [        &quot;pudb&quot;,        &quot;twisted&quot;,    ]    link = [&quot;trial&quot;]    [virtualenv.app]    install = [&quot;$DEVELOPMENT/myapp&quot;]After creating the above, running ``convergeenvs`` will create 2 virtualenvs,one called &quot;development&quot; with pudb and twisted installed into it and triallinked from within it onto your ``PATH``, and a second called &quot;app&quot; installingthe corresponding directory.That's about all you need to know. If you insist on reading further though,mkenv has an older, not-very-recommended mutable interface which allows you tocreate virtualenvs in a central location without tracking them in a config file(or converging them). For that, usage is similar to ``mkvirtualenv``,although ``mkenv`` passes arguments directly through to ``virtualenv``:.. code-block:: sh    $ mkenv nameofvenv -- -p pypywill create a virtual environment in an appropriate platform-specificdata directory, or in the directory specified by ``WORKON_HOME`` forcompatibility with virtualenvwrapper.Single-Purpose Virtualenvs--------------------------A common use case for virtualenvs is for single-purpose installations, e.g.:&quot;I want to install fabric and give it its own virtualenv so that itsdependencies can be independently upgraded, all while still being able to usethe ``fab`` binary globally&quot;.``mkenv`` supports a ``--link`` option for this use case:.. code-block:: sh    $ mkenv -i fabric --link fabwill create a virtualenv for fabric (in the same normal location), but willsymlink the ``fab`` binary from within the virtualenv into your``~/.local/bin`` directory.(You may have heard of `pipsi &lt;https://github.com/mitsuhiko/pipsi&gt;`_ which is asimilar tool for this use case, but with less customization than I would haveliked.)Temporary Virtualenvs---------------------I also find ``mktmpenv`` useful for quick testing. To support its use case,``mkenv`` currently supports a different but similar style of temporaryvirtualenv.Invoking::    $ venv=$(mkenv -t)in your shell will create (or re-create) a global temporary virtualenv,and print its ``bin/`` subdirectory (which in this case will be thenstored in the ``venv`` variable). It can subsequently be used by, e.g.::    $ $venv/pythonor::    $ $venv/pip ...et cetera.You may prefer using::    $ cd $(mkenv -t)as your temporary venv workflow if you're into that sort of thing instead.The global virtualenv is cleared each time you invoke ``mkenv -t``.Unless you care, unlike virtualenvwrapper's ``mktmpenv``, there's noneed to care about cleaning it up, whenever it matters for the nexttime, it will be cleared and overwritten.``mkenv`` may support the more similar &quot;traditional&quot; one-use virtualenv in thefuture, but given that it does not activate virtualenvs by default (see below),the current recommendation for this use case would be to simply use the``virtualenv`` binary directly.The 5 Minute Tutorial---------------------Besides the ``mkenv`` for named-virtualenv creation and ``mkenv -t`` fortemporary-virtualenv creation described above::    $ findenv name foowill output (to standard output) the path to a virtualenv with the given name(see also ``--existing-only``), and::    $ rmenv foowill remove it.There are a number of other slight variants, see the ``--help`` information foreach of the three binaries.*Real documentation to come (I hope)*Why don't I use virtualenvwrapper?----------------------------------``virtualenvwrapper`` is great! I've used it for a few years. But I'veslowly settled on a much smaller subset of its functionality that I liketo use. Specifically:    * I don't like activating virtualenvs.            virtualenvs are magical and hacky enough on their own, and piling      activation on top just makes things even more messy for me, especially      when moving around between different projects in a shell.  Some people      use ``cd`` tricks to solve this, but I just want simplicity.    * I don't need project support.      I've never attached a project to a virtualenv. I just use a naming      convention, naming the virtualenv with the name of the repo (with simple      coersion), and then using `dynamic directory expansion in my shell      &lt;https://github.com/Julian/dotfiles/blob/4376b05de0f7af9e7ecb2e3596b8830c806c5d71/.config/zsh/.zshrc#L59-L92&gt;`_      to handle association.Basically, I just want a thing that is managing a central repository ofvirtualenvs for me. So that's what ``mkenv`` does... |PyPI| image:: https://img.shields.io/pypi/v/mkenv.svg   :alt: PyPI version   :target: https://pypi.python.org/pypi/mkenv.. |Pythons| image:: https://img.shields.io/pypi/pyversions/mkenv.svg   :alt: Supported Python versions   :target: https://pypi.python.org/pypi/mkenv.. |Travis| image:: https://travis-ci.org/Julian/mkenv.svg?branch=master   :alt: Travis build status   :target: https://travis-ci.org/Julian/mkenv.. |AppVeyor| image:: https://ci.appveyor.com/api/projects/status/9ybhc3jvygurtl90/branch/master?svg=true   :alt: AppVeyor build status   :target: https://ci.appveyor.com/project/Julian/mkenv</longdescription>
</pkgmetadata>