<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pyicumessageformatAn unopinionated library for parsing ICU MessageFormat messages into bothASTs and, optionally, token lists.This library is mainly a re-implementation of the JavaScript library[format-message-parse](https://www.npmjs.com/package/format-message-parse)with a few extra configuration flags.[format-message-parse](https://www.npmjs.com/package/format-message-parse)and `pyicumessageformat` are both licensed MIT.## Parser Options```pythonfrom pyicumessageformat import Parser# The following are the default values for the various available# settings for the Parser.parser = Parser({    # Whether or not to include indices on placeholder objects.    'include_indices': False,    # Maximum depth limits the nesting depth of sub-messages. This is    # done to avoid throwing a RecursionError.    'maximum_depth': 50,    # Known types that include sub-messages.    'submessage_types': ['plural', 'selectordinal', 'select'],    # Sub-message types that are numeric and support &quot;#&quot; in sub-messages.    'subnumeric_types': ['plural', 'selectordinal'],    # Whether or not to parse simple XML-style tags. When this is False,    # XML-style tags will be treated as plain text.    'allow_tags': False,    # The type that should be set for tags. This should be set to a    # unique value that will not overlap with any placeholder types.    'tag_type': 'tag',    # When enabled, strict tags makes the system far less forgiving    # about dangling '&lt;' characters in input strings.    'strict_tags': False,    # If this is set, tag names must start with the provided string,    # otherwise the tag will be ignored and treated as plain text.    # This is overridden by strict_tags, which will always require a    # tag opening character to be treated as a tag.    'tag_prefix': None,    # Whether or not to parse sub-messages for unknown types. When this    # is set to False and an unknown type has sub-messages, a syntax    # error will be raised.    'loose_submessages': False,    # Whether or not spaces should be allowed in format strings.    'allow_format_spaces': True,    # Whether or not the parser should require known types with    # sub-messages to have an &quot;other&quot; selector.    # See &quot;Require Other&quot; below in README for more details.    'require_other': True})```### Require OtherThe `require_other` setting has a few valid possible values.* `True`: All known sub-message types are required to have an &quot;other&quot;    selector.* `False`: No types are required to have an &quot;other&quot; selector.* `&quot;subnumeric&quot;`: All known numeric sub-message types are required to have an    &quot;other&quot; selector.* `&quot;all&quot;`: All types, including unknown types, with sub-messages are required    to have an &quot;other&quot; selector.Additionally, `require_other` can be a list of types. In that event, only thosetypes will be required to have an &quot;other&quot; selector.## TagsBy default, tags are not handled in any way. By setting `allow_tags` to True,rudimentary support for simple XML-style tags is enabled. In this mode, theparser will look for tag opening (`&lt;`) characters and attempt to read a tag.If the tag opening is not followed by either a forward slash (`/`) or aletter A-Z, the tag will be ignored. If the tag is followed by a forwardslash, but not then followed by a valid string, then it will not be matched.Matches: `&lt;b&gt;`, `&lt;strong&gt;`, `&lt;x:link&gt;`, `&lt;/b&gt;`Matches, but errors: `&lt;hi`, `&lt;unending`Does Not Match: `i &lt;3 programming`, `3 &lt; 4`, `&lt;/`By setting a string to `tag_prefix`, you can only match tags that start witha specific string. For example, if you set the tag prefix to `x:` then onlytags starting with `x:` will be matched.Matches with `x:`: `&lt;x:link&gt;`, `&lt;x:strong&gt;`, `&lt;/x:link&gt;`Matches, but errors: `&lt;x:link`,Does Not Match: `Usage: /ban &lt;user&gt;`Finally, you can enable `strict_tags` to require all tag opening (`&lt;`) charactersto be treated as part of a tag. In strict tags mode, all `&lt;` characters *must*be escaped if they are not part of a tag. `tag_prefix` is ignored when stricttags are enabled.Matches: `&lt;b&gt;`, `&lt;strong&gt;`, `&lt;x:link&gt;`, `&lt;/b&gt;`,Matches, but errors: `&lt;hi`, `&lt;unending`, `&lt;/`, `i &lt;3 programming`, `3 &lt; 4`Does Not Match: `i '&lt;'3 programming`## ParsingThe Parser has a single method that is intended to be called externally:### `parse(input: str, tokens?: list) -&gt; AST`Simply pass in a string, and get an AST back:```python&gt;&gt;&gt; ast = parser.parse('''Hello, &lt;b&gt;{firstName}&lt;/b&gt;! You have {messages, plural,    =0 {no messages}    =1 {one message}    other {# messages}} and you're {completion, number, percentage} done.''')&gt;&gt;&gt; ast[    'Hello, ',    {        'name': 'b',        'type': 'tag',        'contents': [            {                'name': 'firstName'            }        ]    },    '! You have ',    {        'name': 'messages',        'type': 'plural',        'options': {            '=0': ['no messages'],            '=1': ['one message'],            'other': [                {                    'name': 'messages',                    'type': 'number'                },                ' messages'            ]        }    },    &quot; and you're &quot;,    {        'name': 'completion',        'type': 'number',        'format': 'percentage'    },    ' done.']```If there is an error in the message, `parse(...)` will raise a`SyntaxError`:```python&gt;&gt;&gt; parser.parse('Hello, {name{!')SyntaxError: Expected , or } at position 12 but found {```If you include an empty list for `tokens`, you can also get back yourinput in a tokenized format. Please note that tokenization stopswhen an error is encountered:```python&gt;&gt;&gt; tokens = []&gt;&gt;&gt; parse('Hello, {firstName}! You are {age, number} years old.', tokens)&gt;&gt;&gt; tokens[    {'type': 'text', 'text': 'Hello, '},    {'type': 'syntax', 'text': '{'},    {'type': 'name', 'text': 'firstName'},    {'type': 'syntax', 'text': '}'},    {'type': 'text', 'text': '! You are '},    {'type': 'syntax', 'text': '{'},    {'type': 'name', 'text': 'age'},    {'type': 'syntax', 'text': ','},    {'type': 'space', 'text': ' '},    {'type': 'type', 'text': 'number'},    {'type': 'syntax', 'text': '}'},    {'type': 'text', ' years old.'}]&gt;&gt;&gt; tokens = []&gt;&gt;&gt; parser.parse('Hello, {name{!', tokens)SyntaxError: Expected , or } at position 12 but found {&gt;&gt;&gt; tokens[    {'type': 'text', 'text': 'Hello, '},    {'type': 'syntax', 'text': '{'},    {'type': 'name', 'text': 'name'}]```## AST Format```typescripttype AST = Node[];type Node = string | Placeholder;type Placeholder = Tag | Variable;type Tag = {    name: string;    type: 'tag';    contents?: AST;    // start and end only included with include_indices    start?: number;    end?: number;};type Variable = {    name: string;    type?: string;    offset?: number;    format?: string;    options?: Submessages;    // If hash is present, it should be true and indicate    // that the variable was a hash (#).    hash?: true;    // start and end only included with include_indices    start?: number;    end?: number;}type Submessages = {    [selector: string]: AST;};```</longdescription>
</pkgmetadata>