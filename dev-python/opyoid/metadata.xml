<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Opyoid======![CI](https://github.com/illuin-tech/opyoid/workflows/CI/badge.svg)[![codecov](https://codecov.io/gh/illuin-tech/opyoid/branch/master/graph/badge.svg)](https://codecov.io/gh/illuin-tech/opyoid)Dependency injection library using typings, to easily manage large applications.This project is inspired from [Guice](https://github.com/google/guice).# InstallationRun `pip install opyoid` to install from PyPI.Run `pip install .` to install from sources.This project follows the [Semantic Versioning Specification](https://semver.org/).All breaking changes are described in the [Changelog](CHANGELOG.md).# Usage### Simple Injection```pythonfrom opyoid import Module, Injectorclass MyClass:    passclass MyParentClass:    def __init__(self, my_param: MyClass):        self.my_param = my_paramclass MyModule(Module):    def configure(self) -&gt; None:        self.bind(MyClass)        self.bind(MyParentClass)injector = Injector([MyModule])my_instance = injector.inject(MyParentClass)assert isinstance(my_instance, MyParentClass)assert isinstance(my_instance.my_param, MyClass)```If they are multiple bindings for the same class, the latest will be used.### ModuleThe module is used to group bindings related to a feature.You can include a module in another with `install`:```pythonfrom opyoid import Module, Injectorclass MyClass:    passclass MyModule(Module):    def configure(self) -&gt; None:        self.bind(MyClass)class MyParentClass:    def __init__(self, my_param: MyClass):        self.my_param = my_paramclass MyParentModule(Module):    def configure(self) -&gt; None:        self.install(MyModule)        self.bind(MyParentClass)injector = Injector([MyParentModule])my_instance = injector.inject(MyParentClass)assert isinstance(my_instance, MyParentClass)assert isinstance(my_instance.my_param, MyClass)```### Binding Subclasses```pythonfrom opyoid import Module, Injectorclass MyClass:    passclass MySubClass(MyClass):    passclass MyModule(Module):    def configure(self) -&gt; None:        self.bind(MyClass, to_class=MySubClass)injector = Injector([MyModule])my_instance = injector.inject(MyClass)assert isinstance(my_instance, MySubClass)```### Binding Instances```pythonfrom opyoid import Module, Injectorclass MyClass:    def __init__(self, my_param: str):        self.my_param = my_parammy_instance = MyClass(&quot;hello&quot;)class MyModule(Module):    def configure(self) -&gt; None:        self.bind(MyClass, to_instance=my_instance)injector = Injector([MyModule])injected_instance = injector.inject(MyClass)assert my_instance is injected_instance```### Binding scopesWhen binding a class, you can choose the scope in which it will be instantiated.This will only have an effect when binding classes, not instances.#### Singleton ScopeBy default, all classes are instantiated in a Singleton scope.This means that only one instance of each class will be created, and it will be shared between all classes requiring it.```pythonfrom opyoid import Module, Injector, SingletonScopeclass MyClass:    passclass MyParentClass:    def __init__(self, my_param: MyClass):        self.my_param = my_paramclass MyModule(Module):    def configure(self) -&gt; None:        self.bind(MyClass, scope=SingletonScope)        self.bind(MyParentClass, scope=SingletonScope)injector = Injector([MyModule])instance_1 = injector.inject(MyClass)instance_2 = injector.inject(MyClass)parent_instance = injector.inject(MyParentClass)assert instance_1 is instance_2assert instance_1 is parent_instance.my_param```#### PerLookup ScopeIf you use the per lookup scope, a new instance will be created every time each class is injected.```pythonfrom opyoid import Module, Injector, PerLookupScopeclass MyClass:    passclass MyParentClass:    def __init__(self, my_param: MyClass):        self.my_param = my_paramclass MyModule(Module):    def configure(self) -&gt; None:        self.bind(MyClass, scope=PerLookupScope)        self.bind(MyParentClass)injector = Injector([MyModule])instance_1 = injector.inject(MyClass)instance_2 = injector.inject(MyClass)parent_instance = injector.inject(MyParentClass)assert instance_1 is not instance_2assert instance_1 is not parent_instance.my_param```#### Thread ScopeThis scope only creates a new instance the first time that the class is injected in the current thread.There will only be one instance of each class in each thread, and two instances injected from different threads will bedifferent objects.```pythonfrom threading import Threadfrom opyoid import Module, Injector, ThreadScopeclass MyClass:    passclass MyModule(Module):    def configure(self) -&gt; None:        self.bind(MyClass, scope=ThreadScope)injector = Injector([MyModule])instance_1 = injector.inject(MyClass)instance_2 = injector.inject(MyClass)def thread_target():    instance_3 = injector.inject(MyClass)    assert instance_1 is not instance_3Thread(target=thread_target).start()assert instance_1 is instance_2```### Bindings without ModuleIf you prefer, you can add bindings to your injector without creating a Module class (or using both).```pythonfrom opyoid import Module, Injector, SelfBindingclass MyClass:    passclass MyParentClass:    def __init__(self, my_param: MyClass):        self.my_param = my_paramclass MyModule(Module):    def configure(self) -&gt; None:        self.bind(MyClass)injector = Injector([MyModule], [SelfBinding(MyParentClass)])my_instance = injector.inject(MyParentClass)assert isinstance(my_instance, MyParentClass)assert isinstance(my_instance.my_param, MyClass)```The same options of Module.bind are available when using bindings:```pythonfrom opyoid import ClassBinding, InstanceBinding, PerLookupScope, SelfBindingclass MyClass:    passclass MySubClass(MyClass):    passmy_instance = MyClass()SelfBinding(MyClass)  # binding a class to itselfClassBinding(MyClass, MySubClass)  # binding a class to a subclassSelfBinding(MyClass, scope=PerLookupScope)  # specifying scopeInstanceBinding(MyClass, my_instance)  # binding an instanceSelfBinding(MyClass, named=&quot;my_name&quot;)  # binding a class to itself with a specific nameInstanceBinding(MyClass, my_instance, named=&quot;my_name&quot;)  # binding an instance with a specific name```### Injecting TypeIf no explicit binding is defined, the last class binding will be used to inject a type:```pythonfrom typing import Typefrom opyoid import Module, Injectorclass MyClass:    passclass SubClass(MyClass):    passclass MyParentClass:    def __init__(self, my_param: Type[MyClass]):        self.my_param = my_parammy_instance = MyClass()class MyModule(Module):    def configure(self) -&gt; None:        self.bind(MyClass)        self.bind(MyClass, to_instance=my_instance)        self.bind(MyClass, to_class=SubClass)        self.bind(MyParentClass)injector = Injector([MyModule])parent_instance = injector.inject(MyParentClass)assert isinstance(parent_instance, MyParentClass)assert parent_instance.my_param is SubClass```## Dataclasses`opyoid` can inject classes and parameters defined with the `attrs` library and python data classes.##  Notes about Generics- The supported generic types are `List`, `Set`, `Tuple`, `Optional`, `Union` and `Type` (and any combination of them).Other generics must be bound explicitly (e.g. you must bind a dict to `Dict[str, MyClass]` if you want to inject it).- Be careful when using generics, the bindings will only be used if the type matches exactly. For example, you cannotimplicitly bind `MyClass[T]` to inject `MyClass`, or `MyClass[str]` to inject `MyClass[T]`. You need to bind somethingto `MyClass[str]` to be able to inject it.# Advanced usageMore advanced features and examples are available in the [./docs](docs) folder.</longdescription>
</pkgmetadata>