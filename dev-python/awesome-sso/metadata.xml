<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Stable Version](https://badge.fury.io/py/awesome-sso.svg)](https://pypi.org/project/awesome-sso/)[![tests](https://github.com/MoBagel/awesome-sso/workflows/develop/badge.svg)](https://github.com/MoBagel/awesome-sso)[![Coverage Status](https://coveralls.io/repos/github/MoBagel/awesome-sso/badge.svg?branch=develop)](https://coveralls.io/github/MoBagel/awesome-sso)# Awesome SSOA library designed to host common components for a cluster of microservices sharing a single sign on.## Feature- [x] A common exception class, supporting both status code and custom error code to map to more detailed error message  or serve as i18n key.- [x] A common FastAPI app for interaction with service, like login ,registration and unregistration.- [x] a connector for minio object store.- [x] a connector for beanie, a mongo odm compatible with pydantic.## Usage### Installation1. `pip install awesome-sso`### ExceptionsUsing fast API as example, we may simply throw exception with a proper status code, and an optional error code. We mayalso supply arbitrary key value in args dict, to help frontend render better error message.```pythonfrom awesome_sso.exceptions import NotFoundfrom fastapi import APIRouterrouter = APIRouter()@router.get('/transactions')def get(id: str):    try:        obj = find_by_id(id)    except Exception as e:        raise NotFound(message='transaction not found' % id, error_code='A0001', args={id: id})    ...```And we may implement a common error handler to convert all these errors to proper response schema```pythonfrom awesome_sso.exceptions import HTTPExceptionfrom fastapi.requests import Requestfrom fastapi.responses import JSONResponse@app.exception_handler(HTTPException)async def http_exception_handler(request: Request, exc: HTTPException):    return JSONResponse(        status_code=exc.status_code,        content={            'detail': exc.detail,            'error_code': exc.error_code,        }    )```This would result in a response with status code 404, and body```json{  &quot;status_code&quot;: 404,  &quot;detail&quot;: {    &quot;message&quot;: &quot;transaction not found&quot;,    &quot;id&quot;: &quot;some_id&quot;  },  &quot;error_code&quot;: &quot;A0001&quot;}```With this response, frontend can decide to simply render detail, or map it to detailed message. If error_code &quot;A0001&quot;correspond to the following i18 n entry```json&quot;error.A0001&quot;: {&quot;en-US&quot;: &quot;transaction can not be found with supplied {id}: {message}&quot;}```we may format message accordingly with```typescripterrorMessage = formatMessage({ id: `error.${error.data.error_code}` }, error.data.detail);```Note that error code is not supplied, is default to status code. So it is always safe to simply use error_code infrontend to decide what to render.### Data Store#### Miniorefer to `tests/test_minio.py`#### Mongorefer to `tests/service/test_user.py````pythonfrom beanie import init_beaniefrom motor.motor_asyncio import AsyncIOMotorClientfrom awesome_sso.service.user.schema import AwesomeUserdef init_mongo():    settings = YOUR_SETTINGS()    models = [AwesomeUser]    cli = AsyncIOMotorClient(settings.mongodb_dsn)    await init_beanie(        database=cli[settings.mongodb_db_name],        document_models=models,    )    for model in models:        await model.get_motor_collection().drop()        await model.get_motor_collection().drop_indexes()```### Service#### configure service settings```pythonfrom awesome_sso.service.settings import Settingssettings = Settings()settings.init_app(    symmetric_key='YOUR_SYMMETRIC_KEY',  # to encode and decode service token    public_key='YOUR_PUBLIC_KEY',  # to decode the token signed by sso    user_model=USER_MODEL,  # user orm needs to inherit AwesomeUser from `awesome_sso.user.schema`    service_name='YOUR_SERVICE_NAME',  # for service discovery, to recognize service    sso_domain='YOUR_SSO_DOMAIN',  # for service registration and sync user)```#### initial service and mount to your application```pythonfrom awesome_sso.service import Servicefrom fastapi import FastAPIapp = FastAPI()service = Service()service.init_app(YOUR_FASTAPI_APP)app.mount('/YOUR/PATH', YOUR_FASTAPI_APP)```then open the api doc, you will see the apis in `awesome_sso.service.user.route`## Development### Installing Poetry1. create your own environment for poetry, and simply run: `pip install poetry`2. alternatively, you can refer to [poetry's official page](https://github.com/python-poetry/poetry)3. to be able to use `poe` directly, `pip install poethepoet`### Contributing1. project setup: `poetry install`2. create your own branch to start developing new feature.3. before creating pr, make sure you pass `poe lint` and `./run_test.sh`.    - what happened inside `./run_test.sh` is that a minio server is setup for you temporarily, and teardown and unit      test is finished.    - notice that `poe test` would also work if you already have a minio up and running. You need the following env      variable: `MINIO_ACCESS_KEY`, `MINIO_SECRET_KEY`, `MINIO_ADDRESS` upon running `poe test`.4. for a list of available poe command, `poe`5. after you submit a pr, you should check if pipeline is successful.### Releasing1. `poetry version [new_version]`2. `git commit -m&quot;Bump version&quot;`3. `git push origin develop`4. [create new release](https://github.com/MoBagel/awesome-sso/releases/new) on github.5. Create release off develop branch, auto generate notes, and review release note. 6. Publish release</longdescription>
</pkgmetadata>