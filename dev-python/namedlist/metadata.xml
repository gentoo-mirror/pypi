<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>===========namedlist===========WARNING=======This package is no longer maintained, except for exceptional cases.Please use the built-in dataclasses module instead.Overview========namedlist provides 2 factory functions, namedlist.namedlist andnamedlist.namedtuple. namedlist.namedtuple is similar tocollections.namedtuple, with the following differences:* namedlist.namedtuple supports per-field default values.* namedlist.namedtuple supports an optional default value, to be used  by all fields that do not have an explicit default value.namedlist.namedlist is similar, with this additional difference:* namedlist.namedlist instances are mutable.Typical usage=============You can use namedlist like a mutable namedtuple::    &gt;&gt;&gt; from namedlist import namedlist    &gt;&gt;&gt; Point = namedlist('Point', 'x y')    &gt;&gt;&gt; p = Point(1, 3)    &gt;&gt;&gt; p.x = 2    &gt;&gt;&gt; assert p.x == 2    &gt;&gt;&gt; assert p.y == 3Or, you can specify a default value for all fields::    &gt;&gt;&gt; Point = namedlist('Point', 'x y', default=3)    &gt;&gt;&gt; p = Point(y=2)    &gt;&gt;&gt; assert p.x == 3    &gt;&gt;&gt; assert p.y == 2Or, you can specify per-field default values::    &gt;&gt;&gt; Point = namedlist('Point', [('x', 0), ('y', 100)])    &gt;&gt;&gt; p = Point()    &gt;&gt;&gt; assert p.x == 0    &gt;&gt;&gt; assert p.y == 100You can also specify the per-field defaults with a mapping, insteadof an iterable. Note that this is only useful with an orderedmapping, such as an OrderedDict::    &gt;&gt;&gt; from collections import OrderedDict    &gt;&gt;&gt; Point = namedlist('Point', OrderedDict((('y', 0),    ...                                         ('x', 100))))    &gt;&gt;&gt; p = Point()    &gt;&gt;&gt; p    Point(y=0, x=100)The default value will only be used if it is provided and a per-fielddefault is not used::    &gt;&gt;&gt; Point = namedlist('Point', ['x', ('y', 100)], default=10)    &gt;&gt;&gt; p = Point()    &gt;&gt;&gt; assert p.x == 10    &gt;&gt;&gt; assert p.y == 100If you use a mapping, the value NO_DEFAULT is convenient to specifythat a field uses the default value::    &gt;&gt;&gt; from namedlist import NO_DEFAULT    &gt;&gt;&gt; Point = namedlist('Point', OrderedDict((('y', NO_DEFAULT),    ...                                         ('x', 100))),    ...                            default=5)    &gt;&gt;&gt; p = Point()    &gt;&gt;&gt; assert p.x == 100    &gt;&gt;&gt; assert p.y == 5namedtuple is similar, except the instances are immutable::    &gt;&gt;&gt; from namedlist import namedtuple    &gt;&gt;&gt; Point = namedtuple('Point', 'x y', default=3)    &gt;&gt;&gt; p = Point(y=2)    &gt;&gt;&gt; assert p.x == 3    &gt;&gt;&gt; assert p.y == 2    &gt;&gt;&gt; p.x = 10    Traceback (most recent call last):    ...    AttributeError: can't set attributeAll of the documentation below in the Specifying Fields and SpecifyingDefaults sections applies to namedlist.namedlist andnamedlist.namedtuple.Creating types==============Specifying Fields-----------------Fields in namedlist.namedlist or namedlist.namedtuple can be specifiedas in collections.namedtuple: as either a string specifing the fieldnames, or as a iterable of field names. These two uses areequivalent::    &gt;&gt;&gt; Point = namedlist('Point', 'x y')    &gt;&gt;&gt; Point = namedlist('Point', ['x', 'y'])As are these::    &gt;&gt;&gt; Point = namedtuple('Point', 'x y')    &gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])If using a string, commas are first converted to spaces. So these areequivalent::    &gt;&gt;&gt; Point = namedlist('Point', 'x y')    &gt;&gt;&gt; Point = namedlist('Point', 'x,y')Specifying Defaults-------------------Per-field defaults can be specified by supplying a 2-tuple (name,default_value) instead of just a string for the field name. This isonly supported when you specify a list of field names::    &gt;&gt;&gt; Point = namedlist('Point', [('x', 0), ('y', 0)])    &gt;&gt;&gt; p = Point(3)    &gt;&gt;&gt; assert p.x == 3    &gt;&gt;&gt; assert p.y == 0Or, using namedtuple::    &gt;&gt;&gt; Point = namedtuple('Point', [('x', 0), ('y', 0)])    &gt;&gt;&gt; p = Point(3)    &gt;&gt;&gt; assert p.x == 3    &gt;&gt;&gt; assert p.y == 0In addition to, or instead of, these per-field defaults, you can alsospecify a default value which is used when no per-field default valueis specified::    &gt;&gt;&gt; Point = namedlist('Point', 'x y z', default=0)    &gt;&gt;&gt; p = Point(y=3)    &gt;&gt;&gt; assert p.x == 0    &gt;&gt;&gt; assert p.y == 3    &gt;&gt;&gt; assert p.z == 0    &gt;&gt;&gt; Point = namedlist('Point', [('x', 0), 'y', ('z', 0)], default=4)    &gt;&gt;&gt; p = Point(z=2)    &gt;&gt;&gt; assert p.x == 0    &gt;&gt;&gt; assert p.y == 4    &gt;&gt;&gt; assert p.z == 2In addition to supplying the field names as an iterable of 2-tuples,you can also specify a mapping. The keys will be the field names, andthe values will be the per-field default values. This is most usefulwith an OrderedDict, as the order of the fields will then bedeterministic.  The module variable NO_DEFAULT can be specified if youwant a field to use the per-type default value instead of specifyingit with a field::    &gt;&gt;&gt; Point = namedlist('Point', OrderedDict((('x', 0),    ...                                         ('y', NO_DEFAULT),    ...                                         ('z', 0),    ...                                         )),    ...                            default=4)    &gt;&gt;&gt; p = Point(z=2)    &gt;&gt;&gt; assert p.x == 0    &gt;&gt;&gt; assert p.y == 4    &gt;&gt;&gt; assert p.z == 2Writing to values-----------------Instances of the classes generated by namedlist.namedlist are fullywritable, unlike the tuple-derived classes returned bycollections.namedtuple or namedlist.namedtuple::    &gt;&gt;&gt; Point = namedlist('Point', 'x y')    &gt;&gt;&gt; p = Point(1, 2)    &gt;&gt;&gt; p.y = 4    &gt;&gt;&gt; assert p.x == 1    &gt;&gt;&gt; assert p.y == 4Specifying __slots__--------------------For namedlist.namedlist, by default, the returned class sets __slots__which is initialized to the field names. While this decreases memoryusage by eliminating the instance dict, it also means that you cannotcreate new instance members.To change this behavior, specify use_slots=False when creating thenamedlist::    &gt;&gt;&gt; Point = namedlist('Point', 'x y', use_slots=False)    &gt;&gt;&gt; p = Point(0, 1)    &gt;&gt;&gt; p.z = 2    &gt;&gt;&gt; assert p.x == 0    &gt;&gt;&gt; assert p.y == 1    &gt;&gt;&gt; assert p.z == 2However, note that this method does not add the new variable to_fields, so it is not recognized when iterating over the instance::    &gt;&gt;&gt; list(p)    [0, 1]    &gt;&gt;&gt; sorted(p._asdict().items())    [('x', 0), ('y', 1)]Additional class members------------------------namedlist.namedlist and namedlist.namedtuple classes contain these members:* _asdict(): Returns a dict which maps field names to their  corresponding values.* _fields: Tuple of strings listing the field names. Useful for introspection.Renaming invalid field names----------------------------This functionality is identical to collections.namedtuple. If youspecify rename=True, then any invalid field names are changed to _0,_1, etc. Reasons for a field name to be invalid are:* Zero length strings.* Containing characters other than alphanumerics and underscores.* A conflict with a Python reserved identifier.* Beginning with a digit.* Beginning with an underscore.* Using the same field name more than once.For example::    &gt;&gt;&gt; Point = namedlist('Point', 'x x for', rename=True)    &gt;&gt;&gt; assert Point._fields == ('x', '_1', '_2')Mutable default values----------------------For namedlist.namelist, be aware of specifying mutable defaultvalues. Due to the way Python handles default values, each instance ofa namedlist will share the default. This is especially problematicwith default values that are lists. For example::    &gt;&gt;&gt; A = namedlist('A', [('x', [])])    &gt;&gt;&gt; a = A()    &gt;&gt;&gt; a.x.append(4)    &gt;&gt;&gt; b = A()    &gt;&gt;&gt; assert b.x == [4]This is probably not the desired behavior, so see the next section.Specifying a factory function for default values------------------------------------------------For namedlist.namedlist, you can supply a zero-argument callable for adefault, by wrapping it in a FACTORY call. The only change in thisexample is to change the default from `[]` to `FACTORY(list)`. Butnote that `b.x` is a new list object, not shared with `a.x`::    &gt;&gt;&gt; from namedlist import FACTORY    &gt;&gt;&gt; A = namedlist('A', [('x', FACTORY(list))])    &gt;&gt;&gt; a = A()    &gt;&gt;&gt; a.x.append(4)    &gt;&gt;&gt; b = A()    &gt;&gt;&gt; assert b.x == []Every time a new instance is created, your callable (in this case,`list`), will be called to produce a new instance for the defaultvalue.Iterating over instances------------------------Because instances are iterable (like lists or tuples), iteration worksthe same way. Values are returned in definition order::    &gt;&gt;&gt; Point = namedlist('Point', 'x y z t')    &gt;&gt;&gt; p = Point(1.0, 42.0, 3.14, 2.71828)    &gt;&gt;&gt; for value in p:    ...    print(value)    1.0    42.0    3.14    2.71828namedlist specific functions============================_update-------`namedlist._update()` is similar to `dict.update()`. It is used tomutate a namedlist.namedlist instance with new values::    &gt;&gt;&gt; Point = namedlist('Point', 'x y z')    &gt;&gt;&gt; p = Point(1, 2, 3)    &gt;&gt;&gt; p.z = 4    &gt;&gt;&gt; p._update(y=5, x=6)    &gt;&gt;&gt; p    Point(x=6, y=5, z=4)    &gt;&gt;&gt; p._update({'x': 7, 'z': 8})    &gt;&gt;&gt; p    Point(x=7, y=5, z=8)    &gt;&gt;&gt; p._update([('z', 9), ('y', 10)])    &gt;&gt;&gt; p    Point(x=7, y=10, z=9)Creating and using instances============================Because the type returned by namedlist or namedtuple is a normalPython class, you create instances as you would with any Python class.Bitbucket vs. GitLab====================The repository used to be on Bitbucket in Mercurial format.  ButBitbucket dropped Mercurial support and did not provide any way tomigrate issues to a git repository, even one hosted on Bitbucket.  So,I abandoned Bitbucket and moved the code to GitLab.  Thus, all of theissue were lost, and new issues started again with #1.  I'm naming theGitLab issues as #GH-xx, and the old Bitbucket issues as #BB-xx.  I'mstill angry at Bitbucket for forcing this change.Change log==========1.8 2020-08-29 Eric V. Smith----------------------------* Add python 3.8 compatibility (#GL-1).* Moved to gitlab.* Require setuptools, and specify universal wheels (issue #BB-30).* Drop code for bdist_rpm that tried to change the RPM name to  python-namedlist (issue #BB-31).1.7 2015-05-15 Eric V. Smith----------------------------* Changed RPM name to python3-namedlist if running with python 3.* No code changes.1.6 2014-12-23 Eric V. Smith----------------------------* Add namedlist._update(), similar to dict.update(). Thanks to Arthur  Skowronek (issue #BB-23).* Add namedlist._replace(), similar to namedtuple._replace (issue  #BB-24).1.5 2014-05-20 Eric V. Smith----------------------------* Support slices in namedlist.__getattr__ (issue #BB-22).1.4 2014-03-14 Eric V. Smith----------------------------* Add MANIFEST.in to MANIFEST.in, so it will be included in sdists  (issue #BB-21).1.3 2014-03-12 Eric V. Smith----------------------------* Support unicode type and field names in Python 2.x (issue #BB-19). The  identifiers still must be ASCII only, but you can pass them as  unicode. This is useful for code that needs to run under both Python  2 and Python 3.1.2 2014-02-13 Eric V. Smith----------------------------* Produce an RPM named python-namedlist (issue #BB-17).* Add namedtuple (issue #BB-10). Passes all of the collections.namedtuple  tests, except those related to _source. Those tests don't apply  given our different approach to dynamic class creation. All other  collections.namedtuple tests have been copied to our test suite.1.1 2014-02-07 Eric V. Smith----------------------------* Added __dict__ so vars() will be supported.* Fixed pickling from another module (issue #BB-14).* Moved tests to a separate file (issue #BB-15).1.0 2014-02-04 Eric V. Smith----------------------------* Declare the API stable and release version 1.0.* Support python 2.6 (issue #BB-8). The doctests don't pass because  OrderedDict isn't available until 2.7.0.4 2014-02-04 Eric V. Smith----------------------------* Add docstring (issue #BB-7).* Fixed README.txt typos (thanks pombredanne on bitbucket).0.3 2014-01-29 Eric V. Smith----------------------------* Removed documentation left over from recordtype.* Make instances unhashable (issue #BB-2).* For python3, use str.isidentifier (issue #BB-1).* Reorganize code for name checking. No functional changes.* Make instances iterable (issue #BB-3).* Add collections.Sequence ABC (issue #BB-4).* Have &quot;python setup.py test&quot; also run doctests (issue #BB-5).0.2 2014-01-28 Eric V. Smith----------------------------* Added MANIFEST.in.* Hopefully fixed a problem with .rst formatting in CHANGES.txt.0.1 2014-01-28 Eric V. Smith----------------------------* Initial release.* Based off my recordtype project, but uses ast generation instead of  building up a string and exec-ing it. This has a number of advantages:  - Supporting both python2 and python3 is easier. exec has the    anti-feature of having different syntax in the two languages.  - Adding additional features is easier, because I can write in real    Python instead of having to write the string version, and deal    with all of the escaping and syntax errors.* Added FACTORY, to allow namedlist to work even with mutable defaults.</longdescription>
</pkgmetadata>