<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>RotPy=====RotPy provides python bindings for the Spinnaker SDKto enable Pythonic control of Teledyne/FLIR/Point Grey USB and GigE cameras.See `the website &lt;https://matham.github.io/rotpy/index.html&gt;`_ for the complete **documentation**... image:: https://github.com/matham/rotpy/workflows/Python%20application/badge.svg    :target: https://github.com/matham/rotpy/actions    :alt: Github CI statusInstallation============You can install RotPy using pre-compiled wheels on Windows, Linux, or Mac or by installingthe Spinnaker SDK and then installing RotPy from source.Either way, you'll likely need to install the **Spinnaker drivers** so that the camerasare recognized. Please download it from `their website &lt;https://www.flir.com/products/spinnaker-sdk/&gt;`_and follow the instructions to install the drivers if the cameras are not found.Pre-compiled wheels-------------------To install from the pre-compiled wheels (assuming it's available on your platform), simply do::    python -m pip install rotpy.. note::    For Windows, if rotpy errors out saying dll not found, you probably need    to install the    `Microsoft Visual C++ Redistributable &lt;https://docs.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist&gt;`_    (`64-bit &lt;https://aka.ms/vs/17/release/vc_redist.x64.exe&gt;`_,    `32-bit &lt;https://aka.ms/vs/17/release/vc_redist.x86.exe&gt;`_)... warning::    RotPy is licensed under MIT. However, the pre-compiled wheels contain some of the    Spinnaker SDK runtime libraries which have their own license. Please see the    license file packaged along with the binaries in the wheel.From source-----------To install RotPy from source, you need to:#. Install the   `Spinnaker SDK &lt;https://www.flir.com/products/spinnaker-sdk/&gt;`_ development   libraries.#. Install a C++ compiler that supports C++11. E.g. on Windows Visual Studio etc.   On Mac you may have to export the following environment variables::       export CXX=&quot;/usr/bin/clang&quot;       export CXXFLAGS=&quot;-std=c++11&quot;       export CPPFLAGS=&quot;-std=c++11&quot;#. Set the environment variables so Python can locate the Spinnaker SDK.   #. You need to set ``ROTPY_INCLUDE`` to the include directory, e.g. on Windows it may be something like      ``set ROTPY_INCLUDE=&quot;C:\Program Files\FLIR\Spinnaker\include&quot;``. On Linux and Mac it should typically      be automatically found.   #. You need to set ``ROTPY_LIB`` to the paths that contain the libraries and binaries. E.g. on Windows it may      be ``set ROTPY_LIB=&quot;C:\Program Files\FLIR\Spinnaker\bin64\vs2015;C:\Program Files\FLIR\Spinnaker\lib64\vs2015&quot;``.      On Linux and Mac, again, it should typically be automatically found.#. Then install RotPy with::       python -m pip install rotpy --no-binary rotpy#. At runtime, you'll need to ensure the Spinnaker runtime binaries are on the   system ``PATH`` using e.g.   `os.add_dll_directory &lt;https://docs.python.org/3/library/os.html#os.add_dll_directory&gt;`_.   You may also have to set the environmental variable (depending on the OS bitness)   ``GENICAM_GENTL32_PATH``/``GENICAM_GENTL64_PATH``   to the directory containing the ``FLIR_GenTL*.cti`` file as well as any or all variables   ``FLIR_GENTL32_CTI_VS140``/``FLIR_GENTL64_CTI_VS140``/``FLIR_GENTL32_CTI``/``FLIR_GENTL64_CTI``   to the **full path** to the ``FLIR_GenTL*.cti`` file.   Additionally, the ``FLIR_GenTL*.cti`` file containing directory may also need to be added   to the system ``PATH``. Spinnaker will raise an error if the cti file cannot be loaded.Examples========Getting an image from a GigE camera-----------------------------------.. code-block:: python    &gt;&gt;&gt; from rotpy.system import SpinSystem    &gt;&gt;&gt; from rotpy.camera import CameraList    &gt;&gt;&gt; # get a system ref and a list of all attached cameras    &gt;&gt;&gt; system = SpinSystem()    &gt;&gt;&gt; cameras = CameraList.create_from_system(system, update_cams=True, update_interfaces=True)    &gt;&gt;&gt; cameras.get_size()        1    &gt;&gt;&gt; # get the camera attached from the list    &gt;&gt;&gt; camera = cameras.create_camera_by_index(0)    &gt;&gt;&gt; camera.get_unique_id()        '77T45WD4A84C_86TA1684_GGGGGG14_64CW3987'    &gt;&gt;&gt; # init the camera and get one image    &gt;&gt;&gt; camera.init_cam()    &gt;&gt;&gt; # get its serial number    &gt;&gt;&gt; camera.camera_nodes.DeviceSerialNumber.get_node_value()    '36548975'    &gt;&gt;&gt; camera.begin_acquisition()    &gt;&gt;&gt; image_cam = camera.get_next_image(timeout=5)    &gt;&gt;&gt; # we copy the image so that we can release its camera buffer    &gt;&gt;&gt; image = image_cam.deep_copy_image(image_cam)    &gt;&gt;&gt; image_cam.release()    &gt;&gt;&gt; camera.end_acquisition()    &gt;&gt;&gt; # save the image    &gt;&gt;&gt; image.save_png('image.png')    &gt;&gt;&gt; # get image metadata    &gt;&gt;&gt; image.get_bits_per_pixel()        8    &gt;&gt;&gt; image.get_height()        512    &gt;&gt;&gt; image.get_width()        612    &gt;&gt;&gt; image.get_frame_id()        1    &gt;&gt;&gt; image.get_frame_timestamp()        67557050882    &gt;&gt;&gt; image.get_pix_fmt()        'Mono8'    &gt;&gt;&gt; image.get_image_data_size()        313344    &gt;&gt;&gt; data = image.get_image_data()    &gt;&gt;&gt; type(data)        bytearray    &gt;&gt;&gt; len(data)        313344    &gt;&gt;&gt; 512 * 612        313344    &gt;&gt;&gt; camera.deinit_cam()    &gt;&gt;&gt; camera.release()Configuring and getting an image from a USB3 camera---------------------------------------------------.. code-block:: python    &gt;&gt;&gt; from rotpy.system import SpinSystem    &gt;&gt;&gt; from rotpy.camera import CameraList    &gt;&gt;&gt; # create system/camera list instance and create the camera by serial number    &gt;&gt;&gt; system = SpinSystem()    &gt;&gt;&gt; cameras = CameraList.create_from_system(system, True, True)    &gt;&gt;&gt; cameras.get_size()    1    &gt;&gt;&gt; camera = cameras.create_camera_by_serial('87785435')    &gt;&gt;&gt; # init so we can read the pixel format node    &gt;&gt;&gt; camera.init_cam()    &gt;&gt;&gt; # the names of the pixel formats available for the camera    &gt;&gt;&gt; camera.camera_nodes.PixelFormat.get_entries_names()    ['Mono8',     'Mono12Packed',     'Mono12p',     'Mono16',     'BayerGR8',     ...,     'BayerBG16',     'YCbCr411_8_CbYYCrYY',     'YCbCr422_8_CbYCrY',     'YCbCr8_CbYCr',     'RGB8']    &gt;&gt;&gt; # the current one is BayerRG8    &gt;&gt;&gt; node = camera.camera_nodes.PixelFormat.get_node_value()    &gt;&gt;&gt; node    &lt;rotpy.node.SpinEnumItemNode at 0x236edec43c8&gt;    &gt;&gt;&gt; node.get_enum_name()    'BayerRG8'    &gt;&gt;&gt; # instead set it to RGB8    &gt;&gt;&gt; camera.camera_nodes.PixelFormat.set_node_value_from_str('RGB8')    &gt;&gt;&gt; camera.camera_nodes.PixelFormat.get_node_value().get_enum_name()    'RGB8'    &gt;&gt;&gt; # set acquired image height to 800 pixels    &gt;&gt;&gt; camera.camera_nodes.Height.get_node_value()    1200    &gt;&gt;&gt; camera.camera_nodes.Height.set_node_value(800)    &gt;&gt;&gt; camera.camera_nodes.Height.get_node_value()    800    &gt;&gt;&gt; camera.camera_nodes.Height.get_max_value()    1200    &gt;&gt;&gt; # get the current framerate    &gt;&gt;&gt; camera.camera_nodes.AcquisitionFrameRate.is_readable()    True    &gt;&gt;&gt; camera.camera_nodes.AcquisitionFrameRate.get_node_value()    42.7807502746582    &gt;&gt;&gt; # get one image and copy and release it so we don't tie up the buffers    &gt;&gt;&gt; camera.begin_acquisition()    &gt;&gt;&gt; image_cam = camera.get_next_image()    &gt;&gt;&gt; image = image_cam.deep_copy_image(image_cam)    &gt;&gt;&gt; image_cam.release()    &gt;&gt;&gt; camera.end_acquisition()    &gt;&gt;&gt; # get some image metadat    &gt;&gt;&gt; image.get_frame_timestamp() / 1e9    512.51940629    &gt;&gt;&gt; image.get_height()    800    &gt;&gt;&gt; image.get_buffer_size()    4608000    &gt;&gt;&gt; 1920*800*3    4608000    &gt;&gt;&gt; image.get_pix_fmt()    'RGB8'    &gt;&gt;&gt; # cleanup    &gt;&gt;&gt; camera.deinit_cam()    &gt;&gt;&gt; camera.release()System and camera properties----------------------------The system and camera properties can be read and set using`node &lt;https://matham.github.io/rotpy/node.html&gt;`_objects. These nodes, each represent a camera or system property, and theycan be integer nodes, float nodes, boolean nodes, string nodes, commandnodes etc.These nodes derive from Spinnaker's `GenICam &lt;https://en.wikipedia.org/wiki/GenICam&gt;`_implementation for their cameras. RotPy provides access to a generic node access APIas well as to some pre-listed nodes available on many cameras.The generic API is accessed through the `NodeMap &lt;https://matham.github.io/rotpy/node.html#rotpy.node.NodeMap&gt;`_ usinge.g. `SpinSystem.get_tl_node_map &lt;https://matham.github.io/rotpy/system.html#rotpy.system.SpinSystem.get_tl_node_map&gt;`_,`InterfaceDevice.get_tl_node_map &lt;https://matham.github.io/rotpy/system.html#rotpy.system.InterfaceDevice.get_tl_node_map&gt;`_,`Camera.get_node_map &lt;https://matham.github.io/rotpy/camera.html#rotpy.camera.Camera.get_node_map&gt;`_,`Camera.get_tl_dev_node_map &lt;https://matham.github.io/rotpy/camera.html#rotpy.camera.Camera.get_tl_dev_node_map&gt;`_, or`Camera.get_tl_stream_node_map &lt;https://matham.github.io/rotpy/camera.html#rotpy.camera.Camera.get_tl_stream_node_map&gt;`_.The pre-listed nodes can be accessed through e.g.`SpinSystem.system_nodes &lt;https://matham.github.io/rotpy/system.html#rotpy.system.SpinSystem.system_nodes&gt;`_,`InterfaceDevice.interface_nodes &lt;https://matham.github.io/rotpy/system.html#rotpy.system.InterfaceDevice.interface_nodes&gt;`_,`Camera.camera_nodes &lt;https://matham.github.io/rotpy/camera.html#rotpy.camera.Camera.camera_nodes&gt;`_,`Camera.tl_dev_nodes &lt;https://matham.github.io/rotpy/camera.html#rotpy.camera.Camera.tl_dev_nodes&gt;`_, or`Camera.tl_stream_nodes &lt;https://matham.github.io/rotpy/camera.html#rotpy.camera.Camera.tl_stream_nodes&gt;`_.These link to the following respectiveobjects: `SystemNodes &lt;https://matham.github.io/rotpy/system_nodes.html#rotpy.system_nodes.SystemNodes&gt;`_,`InterfaceNodes &lt;https://matham.github.io/rotpy/system_nodes.html#rotpy.system_nodes.InterfaceNodes&gt;`_,`CameraNodes &lt;https://matham.github.io/rotpy/camera_nodes.html#rotpy.camera_nodes.CameraNodes&gt;`_,`TLDevNodes &lt;https://matham.github.io/rotpy/camera_nodes.html#rotpy.camera_nodes.TLDevNodes&gt;`_, and`TLStreamNodes &lt;https://matham.github.io/rotpy/camera_nodes.html#rotpy.camera_nodes.TLStreamNodes&gt;`_.E.g. to access some of the system nodes using`system_nodes &lt;https://matham.github.io/rotpy/system.html#rotpy.system.SpinSystem.system_nodes&gt;`_:.. code-block:: python    &gt;&gt;&gt; from rotpy.system import SpinSystem    &gt;&gt;&gt; system = SpinSystem()    &gt;&gt;&gt; # get a list of all boolean nodes    &gt;&gt;&gt; system.system_nodes.bool_nodes    ['EnumerateGEVInterfaces', 'EnumerateUSBInterfaces', 'EnumerateGen2Cameras']    &gt;&gt;&gt; # let's inspect the USB node    &gt;&gt;&gt; system.system_nodes.EnumerateUSBInterfaces    &lt;rotpy.node.SpinBoolNode at 0x26822c20d68&gt;    &gt;&gt;&gt; # first make sure this node is actually available for this system    &gt;&gt;&gt; system.system_nodes.EnumerateUSBInterfaces.is_available()    True    &gt;&gt;&gt; system.system_nodes.EnumerateUSBInterfaces.get_node_value()    True    &gt;&gt;&gt; system.system_nodes.EnumerateUSBInterfaces.get_description()    'Enables or disables enumeration of USB Interfaces.'    &gt;&gt;&gt; system.system_nodes.EnumerateUSBInterfaces.get_name()    'EnumerateUSBInterfaces'    &gt;&gt;&gt; system.system_nodes.EnumerateUSBInterfaces.get_node_value_as_str()    '1'    &gt;&gt;&gt; system.system_nodes.EnumerateUSBInterfaces.get_short_description()    'Enables or disables enumeration of USB Interfaces.'We can similarly use the node map to get the same node if it's available:.. code-block:: python    &gt;&gt;&gt; from rotpy.system import SpinSystem    &gt;&gt;&gt; system = SpinSystem()    &gt;&gt;&gt; node_map = system.get_tl_node_map()    &gt;&gt;&gt; node = node_map.get_node_by_name('EnumerateUSBInterfaces')    &gt;&gt;&gt; node is not None and node.is_available()    True    &gt;&gt;&gt; node.get_node_value()    True    &gt;&gt;&gt; node.get_description()    'Enables or disables enumeration of USB Interfaces.'Similarly, for the camera, we can use the pre-listed nodes:.. code-block:: python    &gt;&gt;&gt; # make sure to init the camera, otherwise many nodes won't be available    &gt;&gt;&gt; camera.init_cam()    &gt;&gt;&gt; # check that the auto-exposure setting is available    &gt;&gt;&gt; camera.camera_nodes.ExposureAuto.is_available()    True    &gt;&gt;&gt; camera.camera_nodes.ExposureAuto.get_description()    'Sets the automatic exposure mode when Exposure Mode is Timed.'    &gt;&gt;&gt; # the auto-exposure is a enum node with children items    &gt;&gt;&gt; camera.camera_nodes.ExposureAuto.get_node_value()    &lt;rotpy.node.SpinEnumItemNode at 0x26822c2bc18&gt;    &gt;&gt;&gt; camera.camera_nodes.ExposureAuto.get_node_value().get_enum_name()    'Continuous'    &gt;&gt;&gt; # but we can just get the symbolic string name directly    &gt;&gt;&gt; camera.camera_nodes.ExposureAuto.get_node_value_as_str()    'Continuous'    &gt;&gt;&gt; # to see what options are available for this enum node, look in the names module    &gt;&gt;&gt; from rotpy.names.camera import ExposureAuto_names    &gt;&gt;&gt; ExposureAuto_names    {'Off': 0, 'Once': 1, 'Continuous': 2}    &gt;&gt;&gt; # or for pre-listed enum nodes, we can get it as an attribute    &gt;&gt;&gt; camera.camera_nodes.ExposureAuto.enum_names    {'Off': 0, 'Once': 1, 'Continuous': 2}    &gt;&gt;&gt; # try setting it to an incorrect value    &gt;&gt;&gt; camera.camera_nodes.ExposureAuto.set_node_value_from_str('off', verify=True)    Traceback (most recent call last):      File &quot;&lt;ipython-input-48-d16a67f0044c&gt;&quot;, line 1, in &lt;module&gt;        camera.camera_nodes.ExposureAuto.set_node_value_from_str('off', verify=True)      File &quot;rotpy\node.pyx&quot;, line 650, in rotpy.node.SpinValueNode.set_node_value_from_str        cpdef set_node_value_from_str(self, str value, cbool verify=True):      File &quot;rotpy\node.pyx&quot;, line 664, in rotpy.node.SpinValueNode.set_node_value_from_str        self._value_handle.FromString(s, verify)    RuntimeError: Spinnaker: GenICam::InvalidArgumentException= Feature 'ExposureAuto' : cannot convert value 'off', the value is invalid. : InvalidArgumentException thrown in node 'ExposureAuto' while calling 'ExposureAuto.FromString()' (file 'Enumeration.cpp', line 132) [-2001]    &gt;&gt;&gt; # now set it correctly    &gt;&gt;&gt; camera.camera_nodes.ExposureAuto.set_node_value_from_str('Off', verify=True)    &gt;&gt;&gt; camera.camera_nodes.ExposureAuto.get_node_value_as_str()    'Off'Similarly, we can use the node map to set the exposure back to ``&quot;Continuous&quot;``:.. code-block:: python    &gt;&gt;&gt; node_map = camera.get_node_map()    &gt;&gt;&gt; node = node_map.get_node_by_name('ExposureAuto')    &gt;&gt;&gt; node is not None and node.is_available()    True    &gt;&gt;&gt; node.get_node_value_as_str()    'Off'    &gt;&gt;&gt; node.set_node_value_from_str('Continuous', verify=True)    &gt;&gt;&gt; node.get_node_value_as_str()    'Continuous'    &gt;&gt;&gt; # now de-init the camera and the node won't be available    &gt;&gt;&gt; camera.deinit_cam()    &gt;&gt;&gt; node.is_available()    False    &gt;&gt;&gt; camera.camera_nodes.ExposureAuto.is_available()    FalseAttaching event handlers------------------------Camera detection events^^^^^^^^^^^^^^^^^^^^^^^We can register callbacks to be called when the system detects a camera arrival orremoval on any interface, or on specific interfaces. E.g. to be notified on any interface:.. code-block:: python    &gt;&gt;&gt; from rotpy.system import SpinSystem    &gt;&gt;&gt; system = SpinSystem()    &gt;&gt;&gt; # register a callback for both arrival and removal    &gt;&gt;&gt; def arrival(handler, system, serial):    ...     print('Arrived:', serial)    &gt;&gt;&gt; def removal(handler, system, serial):    ...     print('Removed:', serial)    &gt;&gt;&gt; # register and then plug and unplug a camera twice    &gt;&gt;&gt; handler = system.attach_interface_event_handler(arrival, removal, update=True)    Arrived: 36548975    Removed: 36548975    Arrived: 36548975    Removed: 36548975    &gt;&gt;&gt; system.detach_interface_event_handler(handler)Logging handler^^^^^^^^^^^^^^^We can also register logging event handlers to get any logging events on the system or devices:.. code-block:: python    &gt;&gt;&gt; from rotpy.system import SpinSystem    &gt;&gt;&gt; from rotpy.camera import CameraList    &gt;&gt;&gt; # create system and set logging level to debug    &gt;&gt;&gt; system = SpinSystem()    &gt;&gt;&gt; system.set_logging_level('debug')    &gt;&gt;&gt; # create a callback that prints the message    &gt;&gt;&gt; def log_handler(handler, system, item):    ...     print('Log:', item['category'], item['priority'], item['message'])    &gt;&gt;&gt; # attach the callback and do something that causes logs    &gt;&gt;&gt; handler = system.attach_log_event_handler(log_handler)    &gt;&gt;&gt; cameras = CameraList.create_from_system(system, update_cams=True, update_interfaces=True)    Log: SpinnakerCallback DEBUG Spinnaker: GetCameras()    Log: GenTLCallback DEBUG Entering InterfaceGev::InterfaceGev()    Log: GenTLCallback DEBUG Leaving InterfaceGev::InterfaceGev()    Log: GenTLCallback DEBUG GenTL Trace: system.cpp, line 125, GenTL::EnumerateGigEInterfaces    Log: GenTLCallback DEBUG Entering HAL_UsbGetInterfaces()    Log: GenTLCallback DEBUG Enumerating host Controller PCI\VEN_8086&amp;DEV_A12F&amp;SUBSYS_06E41028&amp;REV_31\3&amp;11458735&amp;0&amp;A0    Log: GenTLCallback DEBUG Host Controller's child instance ID: USB\VID_8087&amp;PID_0029\5&amp;587A6F87&amp;0&amp;4    Log: GenTLCallback DEBUG Entering InterfaceUsb::InterfaceUsb()    Log: GenTLCallback DEBUG Leaving InterfaceUsb::InterfaceUsb()    Log: GenTLCallback DEBUG GenTL Trace: system.cpp, line 162, GenTL::EnumerateUsbInterfaces    Log: GenTLCallback DEBUG GenTL Trace: system.cpp, line 191, GenTL::InitializeInterfaces    Log: GenTLCallback DEBUG GenTL Trace: system.cpp, line 225, GenTL::System::RefreshInterfaces    Log: GenTLCallback DEBUG GenTL Trace: system.cpp, line 535, GenTL::System::UpdateInterfaceList    &gt;&gt;&gt; # now detach the handler    &gt;&gt;&gt; system.detach_log_event_handler(handler)Camera image handler^^^^^^^^^^^^^^^^^^^^We can also register a callback that is called on every new image that is received from thedevice, as opposed to polling for new images:.. code-block:: python    &gt;&gt;&gt; from rotpy.camera import CameraList    &gt;&gt;&gt; from rotpy.system import SpinSystem    &gt;&gt;&gt; # create system and get a camera    &gt;&gt;&gt; system = SpinSystem()    &gt;&gt;&gt; cameras = CameraList.create_from_system(system, update_cams=True, update_interfaces=True)    &gt;&gt;&gt; camera = cameras.create_camera_by_index(0)    &gt;&gt;&gt; camera.init_cam()    &gt;&gt;&gt; # create an image handler that prints the frame ID and time    &gt;&gt;&gt; def image_callback(handler, camera, image):    ...     print('Image:', image.get_frame_id(), image.get_frame_timestamp())    &gt;&gt;&gt; # attach callback and start getting frames    &gt;&gt;&gt; handler = camera.attach_image_event_handler(image_callback)    &gt;&gt;&gt; camera.begin_acquisition()    Image: 1 388361262364    Image: 2 388366605529     ...    Image: 135 389077033335    &gt;&gt;&gt; # stop frames and printing    &gt;&gt;&gt; camera.end_acquisition()    &gt;&gt;&gt; camera.detach_image_event_handler(handler)    &gt;&gt;&gt; camera.deinit_cam()    &gt;&gt;&gt; camera.release()Camera events^^^^^^^^^^^^^We can also register a callback that is called on camera events. E.g.:.. code-block:: python    &gt;&gt;&gt; from rotpy.camera import CameraList    &gt;&gt;&gt; from rotpy.system import SpinSystem    &gt;&gt;&gt; # create system and get a camera    &gt;&gt;&gt; system = SpinSystem()    &gt;&gt;&gt; cameras = CameraList.create_from_system(system, update_cams=True, update_interfaces=True)    &gt;&gt;&gt; camera = cameras.create_camera_by_index(0)    &gt;&gt;&gt; camera.init_cam()    &gt;&gt;&gt; # define the callback and attach it    &gt;&gt;&gt; def event_callback(handler, camera, event):    ...     print('Event:', event, handler.get_event_data(event), handler.get_event_metadata())    &gt;&gt;&gt; handler = camera.attach_device_event_handler(event_callback)    &gt;&gt;&gt; # now use the EventSelector enum to get the enum items which    &gt;&gt;&gt; correspond to the event names that are available.    &gt;&gt;&gt; nodes = camera.camera_nodes.EventSelector.get_entries()    &gt;&gt;&gt; # not all are actually available, so only activate the ones available    &gt;&gt;&gt; nodes = [node for node in nodes if node.is_available()]    &gt;&gt;&gt; for node in nodes:    ...     print(node.get_enum_name())    ...     camera.camera_nodes.EventSelector.set_node_value_from_str(node.get_enum_name())    ...     camera.camera_nodes.EventNotification.set_node_value_from_str('On')    ExposureEnd    &gt;&gt;&gt; # this printed just ExposureEnd, indicating only this event was available    &gt;&gt;&gt; # start acquisition so that the events occur    &gt;&gt;&gt; camera.begin_acquisition()    Event: EventExposureEnd {'frame_id': 62629213124996} ('device', 'EventExposureEnd', 40003)    Event: EventExposureEnd {'frame_id': 62633508092293} ('device', 'EventExposureEnd', 40003)    ...    Event: EventExposureEnd {'frame_id': 62676457765304} ('device', 'EventExposureEnd', 40003)    &gt;&gt;&gt; camera.end_acquisition()    &gt;&gt;&gt; camera.detach_device_event_handler(handler)    &gt;&gt;&gt; camera.deinit_cam()    &gt;&gt;&gt; camera.release()</longdescription>
</pkgmetadata>