<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># AladdinA feature store simplifying feature managment, serving and quality control.Describe your features, and the feature store grants your wishes so you become the feature king.## Feature ViewsWrite features as the should be, as data models.Then get code completion and typesafety by referencing them in other features.This makes the features light weight, data source indipendent, and flexible.```pythonclass Match(FeatureView):    metadata = FeatureViewMetadata(        name=&quot;match&quot;,        description=&quot;Features about football matches&quot;,        batch_source=...    )    # Raw data    home_team = Entity(dtype=String())    away_team = Entity(dtype=String())    date = EventTimestamp(max_join_with=timedelta(days=365))    half_time_score = String()    full_time_score = String().description(&quot;the scores at full time, in the format 'home-away'. E.g: '2-1'&quot;)    # Transformed features    is_liverpool = (home_team == &quot;Liverpool&quot;).description(&quot;If the home team is Liverpool&quot;)    score_as_array = full_time_score.split(&quot;-&quot;)    # Custom pandas df method, which get first and second index in `score_as_array`    home_team_score = score_as_array.transformed(lambda df: df[&quot;score_as_array&quot;].str[0].replace({np.nan: 0}).astype(int))    away_team_score = score_as_array.transformed(...)    score_differance = home_team_score - away_team_score    total_score = home_team_score + away_team_score```## Data sourcesAladdin makes handling data sources easy, as you do not have to think about how it is done.Only define where the data is, and we handle the dirty work.```pythonmy_db = PostgreSQLConfig(env_var=&quot;DATABASE_URL&quot;)class Match(FeatureView):    metadata = FeatureViewMetadata(        name=&quot;match&quot;,        description=&quot;...&quot;,        batch_source=my_db.table(            &quot;matches&quot;,            mapping_keys={                &quot;Team 1&quot;: &quot;home_team&quot;,                &quot;Team 2&quot;: &quot;away_team&quot;,            }        )    )    home_team = Entity(dtype=String())    away_team = Entity(dtype=String())```### Fast developmentMaking iterativ and fast exploration in ML is important. This is why Aladdin also makes it super easy to combine, and test multiple sources.```pythonmy_db = PostgreSQLConfig.localhost()aws_bucket = AwsS3Config(...)class SomeFeatures(FeatureView):    metadata = FeatureViewMetadata(        name=&quot;some_features&quot;,        description=&quot;...&quot;,        batch_source=my_db.table(&quot;local_features&quot;)    )    # Some features    ...class AwsFeatures(FeatureView):    metadata = FeatureViewMetadata(        name=&quot;aws&quot;,        description=&quot;...&quot;,        batch_source=aws_bucket.file_at(&quot;path/to/file.parquet&quot;)    )    # Some features    ...```## Model ServiceUsually will you need to combine multiple features for each model.This is where a `ModelService` comes in.Here can you define which features should be exposed.```python# Uses the variable name, as the model service name.# Can also define a custom name, if wanted.match_model = ModelService(    features=[        Match.select_all(),        # Select features with code completion        LocationFeatures.select(lambda view: [            view.distance_to_match,            view.duration_to_match        ]),    ])```## Data EnrichersIn manny cases will extra data be needed in order to generate some features.We therefore need some way of enriching the data.This can easily be done with Aladdin's `DataEnricher`s.```pythonmy_db = PostgreSQLConfig.localhost()redis = RedisConfig.localhost()user_location = my_db.data_enricher( # Fetch all user locations    sql=&quot;SELECT * FROM user_location&quot;).cache( # Cache them for one day    ttl=timedelta(days=1),    cache_key=&quot;user_location_cache&quot;).lock( # Make sure only one processer fetches the data at a time    lock_name=&quot;user_location_lock&quot;,    redis_config=redis)async def distance_to_users(df: DataFrame) -&gt; Series:    user_location_df = await user_location.load()    ...    return distancesclass SomeFeatures(FeatureView):    metadata = FeatureViewMetadata(...)    latitude = Float()    longitude = Float()    distance_to_users = Float().transformed(distance_to_users, using_features=[latitude, longitude])```## Access DataYou can easily create a feature store that contains all your feature definitions.This can then be used to genreate data sets, setup an instce to serve features, DAG's etc.```pythonstore = FeatureStore.from_dir(&quot;.&quot;)# Select all features from a single feature viewdf = await store.all_for(&quot;match&quot;, limit=2000).to_df()```### Centraliced Feature Store DefinitionYou would often share the features with other coworkers, or split them into different stages, like `staging`, `shadow`, or `production`.One option is therefore to reference the storage you use, and load the `FeatureStore` from there.```pythonaws_bucket = AwsS3Config(...)store = await aws_bucket.file_at(&quot;production.json&quot;).feature_store()# This switches from the production online store to the offline store# Aka. the batch sources defined on the feature viewsexperimental_store = store.offline_store()```This json file can be generated by running `aladdin apply`.### Select multiple feature views```pythondf = await store.features_for({    &quot;home_team&quot;: [&quot;Man City&quot;, &quot;Leeds&quot;],    &quot;away_team&quot;: [&quot;Liverpool&quot;, &quot;Arsenal&quot;],}, features=[    &quot;match:home_team_score&quot;,    &quot;match:is_liverpool&quot;,    &quot;other_features:distance_traveled&quot;,]).to_df()```### Model ServiceSelecting features for a model is super simple.```pythondf = await store.model(&quot;test_model&quot;).features_for({    &quot;home_team&quot;: [&quot;Man City&quot;, &quot;Leeds&quot;],    &quot;away_team&quot;: [&quot;Liverpool&quot;, &quot;Arsenal&quot;],}).to_df()```### Feature ViewIf you want to only select features for a specific feature view, then this is also possible.```pythonprev_30_days = await store.feature_view(&quot;match&quot;).previous(days=30).to_df()sample_of_20 = await store.feature_view(&quot;match&quot;).all(limit=20).to_df()```## Data qualityAladdin will make sure all the different features gets formatted as the correct datatype.In this way will there be no incorrect format, value type errors.## Feature ServerThis expectes that you either run the command in your feature store repo, or have a file with a `RepoReference` instance.You can also setup an online source like Redis, for faster storage.```pythonredis = RedisConfig.localhost()aws_bucket = AwsS3Config(...)repo_files = RepoReference(    env_var_name=&quot;ENVIRONMENT&quot;,    repo_paths={        &quot;production&quot;: aws_bucket.file_at(&quot;feature-store/production.json&quot;),        &quot;shadow&quot;: aws_bucket.file_at(&quot;feature-store/shadow.json&quot;),        &quot;staging&quot;: aws_bucket.file_at(&quot;feature-store/staging.json&quot;)        # else generate the feature store from the current dir    })# Use redis as the online source, if not running localyif repo_files.selected != &quot;local&quot;:    online_source = redis.online_source()```Then run `aladdin serve`, and a FastAPI server will start. Here can you push new features, which then transforms and stores the features, or just fetch them.</longdescription>
</pkgmetadata>