<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>dkpro-cassis============.. image:: https://travis-ci.org/dkpro/dkpro-cassis.svg?branch=master  :target: https://travis-ci.org/dkpro/dkpro-cassis.. image:: https://readthedocs.org/projects/cassis/badge/?version=latest  :target: https://cassis.readthedocs.io/en/latest/?badge=latest  :alt: Documentation Status.. image:: https://codecov.io/gh/dkpro/dkpro-cassis/branch/master/graph/badge.svg  :target: https://codecov.io/gh/dkpro/dkpro-cassis.. image:: https://img.shields.io/pypi/l/dkpro-cassis.svg  :alt: PyPI - License  :target: https://pypi.org/project/dkpro-cassis/.. image:: https://img.shields.io/pypi/pyversions/dkpro-cassis.svg  :alt: PyPI - Python Version  :target: https://pypi.org/project/dkpro-cassis/.. image:: https://img.shields.io/pypi/v/dkpro-cassis.svg  :alt: PyPI  :target: https://pypi.org/project/dkpro-cassis/.. image:: https://img.shields.io/badge/code%20style-black-000000.svg  :target: https://github.com/ambv/black  DKPro **cassis** (pronunciation: [ka.sis]) provides a pure-Python implementation of the *Common Analysis System* (CAS)as defined by the `UIMA &lt;https://uima.apache.org&gt;`_ framework. The CAS is a data structure representing an object tobe enriched with annotations (the co-called *Subject of Analysis*, short *SofA*).This library enables the creation and manipulation of CAS objects and their associated type systems as well as loadingand saving CAS objects in the `CAS XMI XML representation &lt;https://uima.apache.org/d/uimaj-current/references.html#ugr.ref.xmi&gt;`_in Python programs. This can ease in particular the integration of Python-based Natural Language Processing (e.g.`spacy &lt;https://spacy.io&gt;`_ or `NLTK &lt;https://www.nltk.org&gt;`_) and Machine Learning librarys (e.g.`scikit-learn &lt;https://scikit-learn.org/stable/&gt;`_ or `Keras &lt;https://keras.io&gt;`_) in UIMA-based text analysis workflows.An example of cassis in action is the `spacy recommender for INCEpTION &lt;https://github.com/inception-project/external-recommender-spacy&gt;`_,which wraps the spacy NLP library as a web service which can be used in conjunction with the `INCEpTION &lt;https://inception-project.github.io&gt;`_text annotation platform to automatically generate annotation suggestions.Features--------Currently supported features are:- Text SofAs- Deserializing/serializing UIMA CAS from/to XMI- Deserializing/serializing type systems from/to XML- Selecting annotations, selecting covered annotations, adding  annotations- Type inheritance- Multiple SofA support- Type system can be changed after loading- Primitive and reference features and arrays of primitives and referencesSome features are still under development, e.g.- Proper type checking- XML/XMI schema validation- `UIMA JSON CAS support &lt;https://github.com/apache/uima-uimaj-io-jsoncas#readme&gt;`_ (the format is not yet finalized)Installation------------To install the package with :code:`pip`, just run    pip install dkpro-cassisUsage-----Example CAS XMI and types system files can be found under :code:`tests\test_files`.Loading a CAS~~~~~~~~~~~~~A CAS can be deserialized from XMI either by reading from a file orstring using :code:`load_cas_from_xmi`... code:: python    from cassis import *    with open('typesystem.xml', 'rb') as f:        typesystem = load_typesystem(f)            with open('cas.xmi', 'rb') as f:       cas = load_cas_from_xmi(f, typesystem=typesystem)Saving a CAS as XMI~~~~~~~~~~~~~~~~~~~A CAS can be serialized to XMI either by writing to a file or bereturned as a string using :code:`cas.to_xmi()`... code:: python    from cassis import *    with open('cas.xmi', 'rb') as f:       cas = load_cas_from_xmi(f)    # Returned as a string    xmi = cas.to_xmi()    # Written to file    cas.to_xmi(&quot;my_cas.xmi&quot;)Adding annotations~~~~~~~~~~~~~~~~~~Given a type system with a type :code:`cassis.Token` that has an :code:`id` and:code:`pos` feature, annotations can be added in the following:.. code:: python    from cassis import *    with open('typesystem.xml', 'rb') as f:        typesystem = load_typesystem(f)            with open('cas.xmi', 'rb') as f:        cas = load_cas_from_xmi(f, typesystem=typesystem)           Token = typesystem.get_type('cassis.Token')    tokens = [        Token(begin=0, end=3, id='0', pos='NNP'),        Token(begin=4, end=10, id='1', pos='VBD'),        Token(begin=11, end=14, id='2', pos='IN'),        Token(begin=15, end=18, id='3', pos='DT'),        Token(begin=19, end=24, id='4', pos='NN'),        Token(begin=25, end=26, id='5', pos='.'),    ]    for token in tokens:        cas.add(token)Selecting annotations~~~~~~~~~~~~~~~~~~~~~.. code:: python    from cassis import *    with open('typesystem.xml', 'rb') as f:        typesystem = load_typesystem(f)            with open('cas.xmi', 'rb') as f:        cas = load_cas_from_xmi(f, typesystem=typesystem)    for sentence in cas.select('cassis.Sentence'):        for token in cas.select_covered('cassis.Token', sentence):            print(token.get_covered_text())                        # Annotation values can be accessed as properties            print('Token: begin={0}, end={1}, id={2}, pos={3}'.format(token.begin, token.end, token.id, token.pos)) Getting and setting (nested) features~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~If you want to access a variable but only have its name as a string or have nested feature structures,e.g. a feature structure  with feature :code:`a` that has afeature :code:`b` that has a feature :code:`c`, some of which can be :code:`None`, then you can use thefollowing:.. code:: python    fs.get(&quot;var_name&quot;) # Or    fs[&quot;var_name&quot;]Or in the nested case,.. code:: python    fs.get(&quot;a.b.c&quot;)    fs[&quot;a.b.c&quot;]If :code:`a` or  :code:`b` or  :code:`c` are :code:`None`, then this returns instead ofthrowing an error.Another example would be a StringList containing :code:`[&quot;Foo&quot;, &quot;Bar&quot;, &quot;Baz&quot;]`:.. code:: python    assert lst.get(&quot;head&quot;) == &quot;foo&quot;    assert lst.get(&quot;tail.head&quot;) == &quot;bar&quot;    assert lst.get(&quot;tail.tail.head&quot;) == &quot;baz&quot;    assert lst.get(&quot;tail.tail.tail.head&quot;) == None    assert lst.get(&quot;tail.tail.tail.tail.head&quot;) == NoneThe same goes for setting:.. code:: python    # Functional    lst.set(&quot;head&quot;, &quot;new_foo&quot;)    lst.set(&quot;tail.head&quot;, &quot;new_bar&quot;)    lst.set(&quot;tail.tail.head&quot;, &quot;new_baz&quot;)    assert lst.get(&quot;head&quot;) == &quot;new_foo&quot;    assert lst.get(&quot;tail.head&quot;) == &quot;new_bar&quot;    assert lst.get(&quot;tail.tail.head&quot;) == &quot;new_baz&quot;    # Bracket access    lst[&quot;head&quot;] = &quot;newer_foo&quot;    lst[&quot;tail.head&quot;] = &quot;newer_bar&quot;    lst[&quot;tail.tail.head&quot;] = &quot;newer_baz&quot;    assert lst[&quot;head&quot;] == &quot;newer_foo&quot;    assert lst[&quot;tail.head&quot;] == &quot;newer_bar&quot;    assert lst[&quot;tail.tail.head&quot;] == &quot;newer_baz&quot;Creating types and adding features~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.. code:: python    from cassis import *    typesystem = TypeSystem()    parent_type = typesystem.create_type(name='example.ParentType')    typesystem.create_feature(domainType=parent_type, name='parentFeature', rangeType=TYPE_NAME_STRING)    child_type = typesystem.create_type(name='example.ChildType', supertypeName=parent_type.name)    typesystem.create_feature(domainType=child_type, name='childFeature', rangeType=TYPE_NAME_INTEGER)    annotation = child_type(parentFeature='parent', childFeature='child')When adding new features, these changes are propagated. For example,adding a feature to a parent type makes it available to a child type.Therefore, the type system does not need to be frozen for consistency.The type system can be changed even after loading, it is not frozenlike in UIMAj.Sofa support~~~~~~~~~~~~A Sofa represents some form of an unstructured artifact that is processed in a UIMA pipeline. It contains for instancethe document text. Currently, new Sofas can be created. This is automatically done when creating a new view. Basicproperties of the Sofa can be read and written:.. code:: python    cas = Cas()    cas.sofa_string = &quot;Joe waited for the train . The train was late .&quot;    cas.sofa_mime = &quot;text/plain&quot;    print(cas.sofa_string)    print(cas.sofa_mime)Array support~~~~~~~~~~~~~Array feature values are not simply Python arrays, but they are wrapped in a feature structure ofa UIMA array type such as :code:`uima.cas.FSArray`... code:: python    from cassis import *    from cassis.typesystem import TYPE_NAME_FS_ARRAY, TYPE_NAME_ANNOTATION    typesystem = TypeSystem()    ArrayHolder = typesystem.create_type(name='example.ArrayHolder')    typesystem.create_feature(domainType=ArrayHolder, name='array', rangeType=TYPE_NAME_FS_ARRAY)    cas = Cas(typesystem=typesystem)    Annotation = cas.typesystem.get_type(TYPE_NAME_ANNOTATION)    FSArray = cas.typesystem.get_type(TYPE_NAME_FS_ARRAY)    ann = Annotation(begin=0, end=1)    cas.add(ann1)    holder = ArrayHolder(array=FSArray(elements=[ann, ann, ann]))    cas.add(holder)Managing views~~~~~~~~~~~~~~A view into a CAS contains a subset of feature structures and annotations. One view corresponds to exactly one Sofa. Itcan also be used to query and alter information about the Sofa, e.g. the document text. Annotations added to one vieware not visible in another view.  A view Views can be created and changed. A view has the same methods and attributesas a :code:`Cas` ... code:: python    from cassis import *    with open('typesystem.xml', 'rb') as f:        typesystem = load_typesystem(f)    Token = typesystem.get_type('cassis.Token')    # This creates automatically the view `_InitialView`    cas = Cas()    cas.sofa_string = &quot;I like cheese .&quot;    cas.add_all([        Token(begin=0, end=1),        Token(begin=2, end=6),        Token(begin=7, end=13),        Token(begin=14, end=15)    ])    print([x.get_covered_text() for x in cas.select_all()])    # Create a new view and work on it.    view = cas.create_view('testView')    view.sofa_string = &quot;I like blackcurrant .&quot;    view.add_all([        Token(begin=0, end=1),        Token(begin=2, end=6),        Token(begin=7, end=19),        Token(begin=20, end=21)    ])    print([x.get_covered_text() for x in view.select_all()])Merging type systems~~~~~~~~~~~~~~~~~~~~Sometimes, it is desirable to merge two type systems. With **cassis**, this can beachieved via the :code:`merge_typesystems` function. The detailed rules of merging can be found`here &lt;https://uima.apache.org/d/uimaj-2.10.4/references.html#ugr.ref.cas.typemerging&gt;`_... code:: python    from cassis import *    with open('typesystem.xml', 'rb') as f:        typesystem = load_typesystem(f)    ts = merge_typesystems([typesystem, load_dkpro_core_typesystem()])Type checking~~~~~~~~~~~~~When adding annotations, no type checking is performed for simplicity reasons.In order to check types, call the :code:`cas.typecheck()` method. Currently, it onlychecks whether elements in `uima.cas.FSArray` areadhere to the specified :code:`elementType`.DKPro Core Integration----------------------A CAS using the DKPro Core Type System can be created via.. code:: python    from cassis import *    cas = Cas(typesystem=load_dkpro_core_typesystem())    for t in cas.typesystem.get_types():        print(t)Miscellaneous-------------If feature names clash with Python magic variables~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~If your type system defines a type called :code:`self` or :code:`type`, then it will be madeavailable as a member variable :code:`self_` or :code:`type_` on the respective type:.. code:: python    from cassis import *    from cassis.typesystem import *    typesystem = TypeSystem()    ExampleType = typesystem.create_type(name='example.Type')    typesystem.create_feature(domainType=ExampleType, name='self', rangeType=TYPE_NAME_STRING)    typesystem.create_feature(domainType=ExampleType, name='type', rangeType=TYPE_NAME_STRING)    annotation = ExampleType(self_=&quot;Test string1&quot;, type_=&quot;Test string2&quot;)    print(annotation.self_)    print(annotation.type_)Leniency~~~~~~~~If the type for a feature structure is not found in the typesystem, it will raise an exception by default.If you want to ignore these kind of errors, you can pass :code:`lenient=True` to the :code:`Cas` constructor orto :code:`load_cas_from_xmi`.Large XMI files~~~~~~~~~~~~~~~If you try to parse large XMI files and get an error message like :code:`XMLSyntaxError: internal error: Huge input lookup`,then you can disable this security check by passing :code:`trusted=True` to your calls to :code:`load_cas_from_xmi`.Citing &amp; Authors----------------If you find this repository helpful, feel free to cite.. code:: bibtex    @software{klie2020_cassis,      author       = {Jan-Christoph Klie and                      Richard Eckart de Castilho},      title        = {DKPro Cassis - Reading and Writing UIMA CAS Files in Python},      publisher    = {Zenodo},      doi          = {10.5281/zenodo.3994108},      url          = {https://github.com/dkpro/dkpro-cassis}    }Development-----------The required dependencies are managed by **pip**. A virtual environmentcontaining all needed packages for development and production can becreated and activated by::    virtualenv venv --python=python3 --no-site-packages    source venv/bin/activate    pip install -e &quot;.[test, dev, doc]&quot;The tests can be run in the current environment by invoking::    make testor in a clean environment via::    toxRelease-------- Make sure all issues for the milestone are completed, otherwise move them to the next- Checkout the ``main`` branch- Bump the version in ``cassis/__version__.py`` to a stable one, e.g. ``__version__ = &quot;0.6.0&quot;``, commit and push, wait until the build completed. An example commit message would be ``No issue. Release 0.6.0``- Create a tag for that version via e.g. ``git tag v0.6.0`` and push the tags via ``git push --tags``. Pushing a tag triggers the release to pypi- Bump the version in ``cassis/__version__.py`` to the next development version, e.g. ``0.7.0-dev``, commit and push that. An example commit message would be ``No issue. Bump version after release``- Once the build has completed and pypi accepted the new version, go to the Github release and write the changelog based on the issues in the respective milestone- Create a new milestone for the next version</longdescription>
</pkgmetadata>