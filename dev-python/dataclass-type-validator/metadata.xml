<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># dataclass-type-validatorThe `dataclass-type-validator` is a type validation library for the properties of `dataclasses.dataclass` using Python type hint information.## Installation`pip install dataclass-type-validator` or add `dataclass-type-validator` line to `requirements.txt`## A Simple Example### Explicitly calling dataclass_type_validator from within your dataclass```pythonfrom dataclasses import dataclassfrom typing import Listfrom dataclass_type_validator import dataclass_type_validatorfrom dataclass_type_validator import TypeValidationError@dataclass()class User:    id: int    name: str    friend_ids: List[int]    def __post_init__(self):        dataclass_type_validator(self)# Valid UserUser(id=10, name='John Smith', friend_ids=[1, 2])# =&gt; User(id=10, name='John Smith', friend_ids=[1, 2])# Invalid Usertry:    User(id='a', name=['John', 'Smith'], friend_ids=['a'])except TypeValidationError as e:    print(e)# =&gt; TypeValidationError: Dataclass Type Validation (errors = {#   'id': &quot;must be an instance of &lt;class 'int'&gt;, but received &lt;class 'str'&gt;&quot;,#   'name': &quot;must be an instance of &lt;class 'str'&gt;, but received &lt;class 'list'&gt;&quot;,#   'friend_ids': 'must be an instance of typing.List[int], but there are some errors:#       [&quot;must be an instance of &lt;class \'int\'&gt;, but received &lt;class \'str\'&gt;&quot;]'})```### The same, but using the class decorator instead```pythonfrom dataclasses import dataclassfrom typing import Listfrom dataclass_type_validator import dataclass_validatefrom dataclass_type_validator import TypeValidationError@dataclass_validate@dataclass()class User:    id: int    name: str    friend_ids: List[int]# Valid UserUser(id=10, name='John Smith', friend_ids=[1, 2])# =&gt; User(id=10, name='John Smith', friend_ids=[1, 2])# Invalid Usertry:    User(id='a', name=['John', 'Smith'], friend_ids=['a'])except TypeValidationError as e:    print(e)# =&gt; TypeValidationError: Dataclass Type Validation (errors = {#   'id': &quot;must be an instance of &lt;class 'int'&gt;, but received &lt;class 'str'&gt;&quot;,#   'name': &quot;must be an instance of &lt;class 'str'&gt;, but received &lt;class 'list'&gt;&quot;,#   'friend_ids': 'must be an instance of typing.List[int], but there are some errors:#       [&quot;must be an instance of &lt;class \'int\'&gt;, but received &lt;class \'str\'&gt;&quot;]'})```You can also pass the `strict` param (which defaults to False) to the decorator:```python@dataclass_validate(strict=True)@dataclass(frozen=True)class SomeList:    values: List[str]# Invalid item contained in typed Listtry:    SomeList(values=[&quot;one&quot;, &quot;two&quot;, 3])except TypeValidationError as e:    print(e)# =&gt; TypeValidationError: Dataclass Type Validation Error (errors = {#   'x': 'must be an instance of typing.List[str], but there are some errors: #       [&quot;must be an instance of &lt;class \'str\'&gt;, but received &lt;class \'int\'&gt;&quot;]'})```You can also pass the `before_post_init` param (which defaults to False) to the decorator,to force the type validation to occur before `__post_init__()` is called.  This can be usedto ensure the types of the field values have been validated before your higher-level semanticvalidation is performed in `__post_init__()`.```python@dataclass_validate(before_post_init=True)@dataclassclass User:    id: int    name: str    def __post_init__(self):        # types of id and name have already been checked before this is called.        # Otherwise, the following check will throw a TypeError if user passed         # `id` as a string or other type that cannot be compared to int.        if id &lt; 1:            raise ValueError(&quot;superuser not allowed&quot;)```</longdescription>
</pkgmetadata>