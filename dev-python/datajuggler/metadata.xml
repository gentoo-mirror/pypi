<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![](https://img.shields.io/pypi/pyversions/datajuggler.svg?color=blue&amp;logo=python&amp;logoColor=white)](https://www.python.org/)[![](https://img.shields.io/pypi/v/datajuggler.svg?color=blue&amp;logo=pypi&amp;logoColor=white)](https://pypi.org/project/datajuggler/)[![](https://pepy.tech/badge/datajuggler/month)](https://pepy.tech/project/datajuggler)[![](https://img.shields.io/github/stars/iisaka51/datajuggler?logo=github)](https://github.com/iisaka51/datajuggler/)[![](https://img.shields.io/pypi/l/datajuggler.svg?color=blue)](https://github.com/iisaka51/datajuggler/blob/master/LICENSE.txt)&lt;p align=&quot;center&quot; style=&quot;margin-bottom: 0px !important;&quot;&gt;  &lt;img width=&quot;400&quot; src=&quot;https://user-images.githubusercontent.com/9247573/198170177-cbfb7cd3-a0c5-4d66-a944-27888e153351.png&quot; align=&quot;center&quot;&gt;  &lt;!--  https://github.com/iisaka51/datajuggler/blob/main/datajuggler_logo.png&quot; alt=&quot;Datajuggler logo&quot; align=&quot;center&quot;&gt;  --&gt;&lt;/p&gt;&lt;p align=&quot;center&quot; style=&quot;margin-bottom: 0px !important;&quot;&gt;&lt;sub&gt;&lt;sub&gt;source: www.irasutoya.com&lt;/sub&gt;&lt;/sub&gt;&lt;/p&gt;# DataJugglerThis library provides utility classes and helper functions for data processing.This is spin-off project from [scrapinghelper](https://github.com/iisaka51/scrapinghelper).This project is inspired by follow great projects. - [python-benedict](https://github.com/fabiocaccamo/python-benedict) - [munch](https://github.com/Infinidat/munch) - [adict](https://github.com/mewwts/addict). - [serialize](https://github.com/hgrecco/serialize)## Features - 100% backward-compatible, you can safely wrap existing dictionaries and list. - Keypath list-index support (also negative) using the standard [n] suffix. - aDict support dot-notation access to value of dictionaries. - aDict support immutable and hashable of dictiinary. - uDict support Keylist and Keypath which are pointing to valaues of dictionaries. - uDict and many helper functions parse methods to retrieve data as needed. - iList support immutable and hashable of list. - iList support hold attributes using aDict. - serializer support 17 different formats:   - bson, dill, json, msgpack, phpserialize, pickle, serpent, yaml   - json:cusom, yaml:cusom, msgpack:custom, toml, xml   - querystring, ini, csv, cloudpickle,   - base64(support encrypt/decrypt)## classes - class BaseDict   Factory class for custom dictionary. - class IODict   Factory class for IO serializable dictionary. - class aDict   Allow to access using dot notation for dictionary. - class Keypath and Keylist   type and manage for keypath and Keylist - class uDict   Allow to access using keypath and keylist. - class iList   Allow hashable and immutable list. when call freeze(). - class StrCase   Convert case for object(s). - class TypeValidator   drop in replace for isinstance() for convinient. - class ValueValidator   validator for value. - class AbstractSerializer   factory class for custom serializer - class AbstractClassSerializer   factory class for custom class serializerutilities for string manupulate helper functions. -  `replace_values()` - Replace objects for object(s). -  `omit_values()` - Omit values for object(s). -  `rename_duplicates()` - Rename duplicated strings to append a number at the end. -  `split_chunks()` - Split iterable object into chunks. -  `urange()` - Return an object that produces a sequence of integes. -  `copy_docstring` - Copying the docstring of function onto another function by nameif pandas installed, follows functions are enabled.otherwise raise NotImplementedError when function call it. -  `add_df()` - Add data into DataFrame. -  `df_compare()` - Check DataFrame is equals.## Installation - Run `pip install datajuggler` or set required modules. - `pip install &quot;datajuggler[database]&quot;` - `pip install &quot;datajuggler[requests]&quot;` - `pip install &quot;datajuggler[yaml]&quot;` and/or if you want to enable all serialzier. - `pip install &quot;datajuggler[serializer]&quot;`...etc.## Getting Started### aDictaDict allow to access using dot notation for values of dictionary.and support freeze/unfreeze object.  validator for value.```pythonIn [1]: from datajuggler import aDict, uDict, iListIn [2]: data = { 'one': { 'two': { 'three': { 'four': 4 }}}}In [3]: a = aDict(data)In [4]: a.one.two.three.fourOut[4]: 4In [5]: a.one.two.three.four = 3In [6]: a.one.two.three.fourOut[6]: 3In [7]: a.freeze()In [8]: hash(a)Out[8]: 2318099281826460897In [9]: try:   ...:     a.one.two.three.four=10   ...: except AttributeError as e:   ...:     print(e)   ...:aDict frozen object cannot be modified.In [10]: a.unfreeze()In [11]: a.one.two.three.four = 10In [12]: try:    ...:     hash(a)    ...: except AttributeError as e:    ...:     print(e)    ...:unhashable not frozen object.In [13]:```### uDictuDict is utilized class support keylist and keypath accessing to values.```pythonIn [1]: from datajuggler import uDict, Keylist, KeypathIn [2]: data = { &quot;a&quot;: 1,   ...:          &quot;b&quot;: { &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, },   ...:                 &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, },   ...:                 &quot;e&quot;: [ { &quot;x&quot;: 1, &quot;y&quot;: -1, &quot;z&quot;: [101, 102, 103], },   ...:                        { &quot;x&quot;: 2, &quot;y&quot;: -2, &quot;z&quot;: [201, 202, 203], },   ...:                        { &quot;x&quot;: 3, &quot;y&quot;: -3, &quot;z&quot;: [301, 302, 303], },   ...:                      ],   ...:               },   ...:       }In [3]: d = uDict(data)In [4]: d['a']Out[4]: 1In [5]: d[Keylist(['b', 'e[1]', 'z[2]'])]Out[5]: 203In [6]: d[Keypath('b.e[1].z[2]')]Out[6]: 203In [7]:```### iListiList is universal object with list and aDict.```pythonIn [1]: from datajuggler import iListIn [2]: l = iList()   ...: assert l == []In [3]: l = iList([1,2,3])   ...: assert l == [1,2,3]In [4]: l = iList()   ...: try:   ...:     l[0] = 1   ...: except IndexError as e:   ...:     print(e)   ...:list assignment index out of rangeIn [5]: l = iList([1])   ...: l[0] = 10In [6]: l1 = iList([1,2,3,4,5])   ...: l2 = iList([1,2,3,4,5])In [7]: assert l1 == l2In [8]: l1 = iList([1,2,3,4,5])   ...: l2 = list([1,2,3,4,5])In [9]: assert l1 == l2In [10]: l1 = iList([5,4,3,2,1])    ...: l2 = list([1,2,3,4,5])    ...: assert l1 != l2In [11]: l1 = iList([1, 2, 3])In [12]: try:    ...:     hash(l1)    ...: except AttributeError as e:    ...:     print(e)    ...:unhashable not frozen object.In [13]: l1.freeze()In [14]: hash(l1)Out[14]: 7029740037309777799In [15]: try:    ...:     l1[0] = 10    ...: except AttributeError as e:    ...:     print(e)    ...:iList frozen object cannot be modified.In [16]: l1.unfreeze()In [17]: l1[0] = 10In [18]: l = iList([1,2,3])In [19]: l.Hello='Python'In [20]: l.HelloOut[20]: 'Python'In [21]: l == [1,2,3]Out[21]: TrueIn [22]: l.get_attrs()Out[22]: {'Hello': 'Python'}In [23]:```## class BaseDictBaseDict is internal base class for custom dictionary.this class has follows methods. - `update(*args, **kwargs)` - `get(key: Hashable, default=None))` - `setdefault(key: Hashable, default=None)` - `fromkeys(sequence, values, inplace=False)` - `fromvalues(sequence, base=1, prefix=None, format=&quot;{:02}&quot;,inplace=False)` - `fromlists(keys: Sequence, values: Sequence, inplace=False)` - `to_dict(obj)` - `from_dict(obj, factory=None, inplace=False)`### fromkeys()Create a new dictionary with keys from iterable and values set to value.If set `True` to `inplace`, perform operation in-place.```pythonIn [1]: from datajuggler.core import BaseDictIn [2]: data = [ 'January', 'February', 'March', 'April' ]In [3]: BaseDict().fromkeys(data,2)Out[3]: BaseDict({'January': 2, 'February': 2, 'March': 2, 'April': 2})In [4]: d = BaseDict()In [5]: d.fromkeys(data, 2, inplace=True)In [6]: dOut[6]: BaseDict({'January': 2, 'February': 2, 'March': 2, 'April': 2})In [7]:```### fromvalues()Create a new dictionary from list of values.keys automaticaly generate as interger or str.`base` is the starting number.if set 'name' to `prefix`, keys will be use 'name01'...and if set &quot;{:03}&quot; to `format`, keys will &quot;name_001&quot;.So, set '' to `prefix`, key as str from interger.If set `True` to `inplace`, perform operation in-place.```pythonIn [7]: BaseDict().fromvalues(data)Out[7]: BaseDict({1: 'January', 2: 'February', 3: 'March', 4: 'April'})In [8]: BaseDict().fromvalues(data, base=0)Out[8]: BaseDict({0: 'January', 1: 'February', 2: 'March', 3: 'April'})In [9]: BaseDict().fromvalues(data, base=100)Out[9]: BaseDict({100: 'January', 101: 'February', 102: 'March', 103: 'April'})In [10]: BaseDict().fromvalues(data, prefix='key_')Out[10]: BaseDict({'key_1': 'January', 'key_2': 'February', 'key_3': 'March', 'key_4': 'April'})In [11]: d = BaseDict()In [12]: d.fromvalues(data, inplace=True)In [13]: dOut[13]: BaseDict({1: 'January', 2: 'February', 3: 'March', 4: 'April'})In [14]:```### fromlists()Create a new dictionary from two list as keys and values.Only the number of elements in the shorter of the two lists is processed.If set `True` to `inplace`, perform operation in-place.```pythonIn [14]: keys = [ 'January', 'February', 'March', 'April' ]In [15]: values = [ 1, 2, 3, 4 ]In [16]: BaseDict().fromlists(keys, values)Out[16]: BaseDict({'January': 1, 'February': 2, 'March': 3, 'April': 4})In [17]: d = BaseDict()In [18]: d.fromlists(keys, values, inplace=True)In [19]: dOut[19]: BaseDict({'January': 1, 'February': 2, 'March': 3, 'April': 4})In [20]:```## class IODictthis class support serialize method.  - Base64, CSV, INI, JSON, YAML, TOML, XML, query_strings, plistif not installed PyYAML and/or toml and call from_yaml(), from_tomo(),will raise NotImpelementedError.IODict is subclass of BaseDict. - `from_base64(cls, s, subformat=&quot;json&quot;, encoding=&quot;utf-8&quot;, **kwargs)` - `from_csv(cls, s, columns=None, columns_row=True, **kwargs)` - `from_ini(cls, s, **kwargs)` - `from_json(self, s, **kwargs)` - `from_pickle(cls, s, **kwargs)` - `from_plist(cls, s, **kwargs)` - `from_query_string(cls, s, **kwargs)` - `from_toml(cls, s, **kwargs)` - `from_xml(cls, s, **kwargs)` - `from_yaml(cls, s, **kwargs)` - `from_serializer(cls, s, format, **kwargs)` - `to_base64(cls, s, subformat=&quot;json&quot;, encoding=&quot;utf-8&quot;, **kwargs)` - `to_csv(cls, s, columns=None, columns_row=True, **kwargs)` - `to_ini(cls, s, **kwargs)` - `to_json(self, s, **kwargs)` - `to_pickle(cls, s, **kwargs)` - `to_plist(cls, s, **kwargs)` - `to_query_string(cls, s, **kwargs)` - `to_toml(cls, s, **kwargs)` - `to_xml(cls, s, **kwargs)` - `to_yaml(cls, s, **kwargs)` - `to_serializer(cls, s, format, **kwargs)`## Serializationdatajuggler keep compatibitily for [Serialize](https://github.com/hgrecco/serialize).and more easy add customaize serializer and class serializer.datajuggler detect following serialization library, and it is automaticaly enable. - cloudpickle - bson - dill - msgpack - serpent - phpserialize - PyYAML - xmllibtodict```pythonIn [1]: from datajuggler import serializer as ioIn [2]: import decimalIn [3]: import datetimeIn [4]: data = {   ...:   'a': 1,   ...:   'b': decimal.Decimal('2'),   ...:   'c': datetime.datetime(2020, 5, 24, 8, 20),   ...:   'd': datetime.date(1962, 1, 13),   ...:   'e': datetime.time(11, 12, 13),   ...:   'f': [1, 2, 3, decimal.Decimal('4')]   ...:   }In [5]: io.dumps(data, format='json')Out[5]: b'{&quot;a&quot;: 1, &quot;b&quot;: {&quot;__class_name__&quot;: &quot;&lt;class \'decimal.Decimal\'&gt;&quot;, &quot;__dumped_obj__&quot;: {&quot;__type__&quot;: &quot;Decimal&quot;, &quot;value&quot;: &quot;2&quot;}}, &quot;c&quot;: {&quot;__class_name__&quot;: &quot;&lt;class \'datetime.datetime\'&gt;&quot;, &quot;__dumped_obj__&quot;: {&quot;__type__&quot;: &quot;datetime&quot;, &quot;value&quot;: [2020, 5, 24, 8, 20, 0]}}, &quot;d&quot;: {&quot;__class_name__&quot;: &quot;&lt;class \'datetime.date\'&gt;&quot;, &quot;__dumped_obj__&quot;: {&quot;__type__&quot;: &quot;date&quot;, &quot;value&quot;: [1962, 1, 13]}}, &quot;e&quot;: {&quot;__class_name__&quot;: &quot;&lt;class \'datetime.time\'&gt;&quot;, &quot;__dumped_obj__&quot;: {&quot;__type__&quot;: &quot;time&quot;, &quot;value&quot;: [11, 12, 13]}}, &quot;f&quot;: [1, 2, 3, {&quot;__class_name__&quot;: &quot;&lt;class \'decimal.Decimal\'&gt;&quot;, &quot;__dumped_obj__&quot;: {&quot;__type__&quot;: &quot;Decimal&quot;, &quot;value&quot;: &quot;4&quot;}}]}'In [6]: io.dumps(data, format='msgpack')Out[6]: b&quot;\x86\xa1a\x01\xa1b\x82\xae__class_name__\xb9&lt;class 'decimal.Decimal'&gt;\xae__dumped_obj__\x82\xa8__type__\xa7Decimal\xa5value\xa12\xa1c\x82\xae__class_name__\xbb&lt;class 'datetime.datetime'&gt;\xae__dumped_obj__\x82\xa8__type__\xa8datetime\xa5value\x96\xcd\x07\xe4\x05\x18\x08\x14\x00\xa1d\x82\xae__class_name__\xb7&lt;class 'datetime.date'&gt;\xae__dumped_obj__\x82\xa8__type__\xa4date\xa5value\x93\xcd\x07\xaa\x01\r\xa1e\x82\xae__class_name__\xb7&lt;class 'datetime.time'&gt;\xae__dumped_obj__\x82\xa8__type__\xa4time\xa5value\x93\x0b\x0c\r\xa1f\x94\x01\x02\x03\x82\xae__class_name__\xb9&lt;class 'decimal.Decimal'&gt;\xae__dumped_obj__\x82\xa8__type__\xa7Decimal\xa5value\xa14&quot;In [7]: io.dumps(data, format='pickle')Out[7]: b&quot;\x80\x04\x95\xa8\x01\x00\x00\x00\x00\x00\x00}\x94(\x8c\x01a\x94K\x01\x8c\x01b\x94\x8c\x08builtins\x94\x8c\x07getattr\x94\x93\x94\x8c'datajuggler.serializer.class_serializer\x94\x8c\x16DecimalClassSerializer\x94\x93\x94)\x81\x94\x8c\x06decode\x94\x86\x94R\x94}\x94(\x8c\x08__type__\x94\x8c\x07Decimal\x94\x8c\x05value\x94\x8c\x012\x94u\x85\x94R\x94\x8c\x01c\x94h\x05h\x06\x8c\x17DatetimeClassSerializer\x94\x93\x94)\x81\x94h\n\x86\x94R\x94}\x94(h\x0e\x8c\x08datetime\x94h\x10]\x94(M\xe4\x07K\x05K\x18K\x08K\x14K\x00eu\x85\x94R\x94\x8c\x01d\x94h\x05h\x06\x8c\x13DateClassSerializer\x94\x93\x94)\x81\x94h\n\x86\x94R\x94}\x94(h\x0e\x8c\x04date\x94h\x10]\x94(M\xaa\x07K\x01K\reu\x85\x94R\x94\x8c\x01e\x94h\x05h\x06\x8c\x13TimeClassSerializer\x94\x93\x94)\x81\x94h\n\x86\x94R\x94}\x94(h\x0e\x8c\x04time\x94h\x10]\x94(K\x0bK\x0cK\reu\x85\x94R\x94\x8c\x01f\x94]\x94(K\x01K\x02K\x03h\x0c}\x94(h\x0eh\x0fh\x10\x8c\x014\x94u\x85\x94R\x94eu.&quot;In [8]: io.dumps(data, format='yaml')Out[8]: b&quot;a: 1\nb: !!python/object/apply:decimal.Decimal\n- '2'\nc: 2020-05-24 08:20:00\nd: 1962-01-13\ne: !!python/object/apply:datetime.time\n- !!binary |\n  CwwNAAAA\nf:\n- 1\n- 2\n- 3\n- !!python/object/apply:decimal.Decimal\n  - '4'\n&quot;In [9]: s = io.dumps(data, format='yaml')In [10]: io.loads(s, format='yaml')Out[10]:{'a': 1, 'b': Decimal('2'), 'c': datetime.datetime(2020, 5, 24, 8, 20), 'd': datetime.date(1962, 1, 13), 'e': datetime.time(11, 12, 13), 'f': [1, 2, 3, Decimal('4')]}In [11]:```### Custom Serializerfollowing exmaple is cloudpickle of datajuggler.```pythonfrom datajuggler.serializer.abstract import (    AbstractSerializer, register_serializer)try:    import cloudpickle    cloudpickle_enable = Trueexcept ImportError:  # pragma: no cover    cloudpickle_enable = False    cloudpickle = AbstractSerializer()class CloudpickleSerializer(AbstractSerializer):    def __init__(self):        super().__init__(format='cloudpickle',                         extension=['pickle', 'cpickle'],                         package='cloudpickle',                         enable=cloudpickle_enable,                         overwrite=True)    def loads(self, s, **kwargs):        data = cloudpickle.loads(s, **kwargs)        return data    def dumps(self, d, **kwargs):        data = cloudpickle.dumps(d, **kwargs)        return dataregister_serializer(CloudpickleSerializer)```### class Seriailizerin case of datetime.dateitime, see follows code.```pythonimport datetimefrom datajuggler.serializer.abstract import (    AbstractClassSerializer, register_serializer)from datajuggler.validator import TypeValidator as _typeclass DatetimeClassSerializer(io.AbstractClassSerializer):    def __init__(self, cls=datetime.datetime):        super().__init__(cls)    def encode(self, obj):        if _type.is_datetime(obj):            return {                &quot;__type__&quot;: &quot;datetime&quot;,                &quot;value&quot;: [                     obj.year,                     obj.month,                     obj.day,                     obj.hour,                     obj.minute,                     obj.second,                    ],                }        else:            super().encode(obj)    def decode(self, obj):        v = obj.get(&quot;__type__&quot;)        if v == &quot;datetime&quot;:            return datetime.datetime(*obj[&quot;value&quot;])        self.raise_error(obj)register_serializer(DatetimeClassSerializer)```and provide helper functions. - `get_format_by_path(path)` - `get_serializer_by_format(format)` - `get_serializers_extensions()` - `autodetect_format(s)` - `validate_file(s)` - `is_url(s)` - `is_dsn(s)` - `read_contents(s)` - `read_database(s)` - `read_url(url, **options)` - `read_file(filepath, encording=&quot;utf-8&quot;, **options)` - `write_file(filepath, content, encording=&quot;utf-8&quot;, **options)`### read_contents()read contets from filepath.if [requests](https://github.com/psf/requests) installed and filepath is starts with 'http://' or 'https://', read contents from URL.if [dataset](https://dataset.readthedocs.io/en/latest/) installed and filepath is starts with'sqlite://' or 'mysql://', 'postgresql://' read contents form DATABASE.```pythonIn [1]:  from datajuggler import serializer as ioIn [2]: io.read_contents('sqlite:///users.sqlite#users')Out[2]:[{'id': 1, 'name': 'David Coverdale', 'age': 71, 'belongs': 'Whitesnake'}, {'id': 2, 'name': 'Neal Schon ', 'age': 68, 'belongs': 'Journey'}, {'id': 3, 'name': 'Tom Scholz', 'age': 75, 'belongs': 'Boston'}, {'id': 4, 'name': 'David Gilmour', 'age': 75, 'belongs': 'Pink Floyd'}, {'id': 5, 'name': 'Ann Wilson', 'age': 71, 'belongs': 'Heart'}, {'id': 6, 'name': 'Nacy Wilson', 'age': 67, 'belongs': 'Heart'}]In [3]: from datajuggler import aDictIn [4]: class User(aDict):   ...:     pass   ...:In [5]: users = io.read_contents('sqlite:///users.sqlite#users',row_type=User)In [6]: users[0].nameOut[6]: 'David Coverdale'In [7]: del usersIn [8]: users = aDict('sqlite:///users.sqlite#users')._valuesIn [9]: usersOut[9]:[aDict({'id': 1, 'name': 'David Coverdale', 'age': 71, 'belongs': 'Whitesnake'}), aDict({'id': 2, 'name': 'Neal Schon ', 'age': 68, 'belongs': 'Journey'}), aDict({'id': 3, 'name': 'Tom Scholz', 'age': 75, 'belongs': 'Boston'}), aDict({'id': 4, 'name': 'David Gilmour', 'age': 75, 'belongs': 'Pink Floyd'}), aDict({'id': 5, 'name': 'Ann Wilson', 'age': 71, 'belongs': 'Heart'}), aDict({'id': 6, 'name': 'Nacy Wilson', 'age': 67, 'belongs': 'Heart'})]In [10]:```if you want filtering data, pass to kwargs as follows.```pythonIn [1]: from datajuggler import serializer as ioIn [2]: io.read_contents('sqlite:///users.sqlite#users')Out[2]:[{'id': 1, 'name': 'David Coverdale', 'age': 71, 'belongs': 'Whitesnake'}, {'id': 2, 'name': 'Neal Schon ', 'age': 68, 'belongs': 'Journey'}, {'id': 3, 'name': 'Tom Scholz', 'age': 75, 'belongs': 'Boston'}, {'id': 4, 'name': 'David Gilmour', 'age': 75, 'belongs': 'Pink Floyd'}, {'id': 5, 'name': 'Ann Wilson', 'age': 71, 'belongs': 'Heart'}, {'id': 6, 'name': 'Nacy Wilson', 'age': 67, 'belongs': 'Heart'}]In [3]: io.read_contents('sqlite:///users.sqlite#users', id={'==': 2})Out[3]: [{'id': 2, 'name': 'Neal Schon ', 'age': 68, 'belongs': 'Journey'}]In [4]: io.read_contents('sqlite:///users.sqlite#users', id={'&gt;=': 3})Out[4]:[{'id': 3, 'name': 'Tom Scholz', 'age': 75, 'belongs': 'Boston'}, {'id': 4, 'name': 'David Gilmour', 'age': 75, 'belongs': 'Pink Floyd'}, {'id': 5, 'name': 'Ann Wilson', 'age': 71, 'belongs': 'Heart'}, {'id': 6, 'name': 'Nacy Wilson', 'age': 67, 'belongs': 'Heart'}]In [5]: io.read_contents('sqlite:///users.sqlite#users', id={'between': [2,4]})Out[5]:[{'id': 2, 'name': 'Neal Schon ', 'age': 68, 'belongs': 'Journey'}, {'id': 3, 'name': 'Tom Scholz', 'age': 75, 'belongs': 'Boston'}, {'id': 4, 'name': 'David Gilmour', 'age': 75, 'belongs': 'Pink Floyd'}]In [6]: io.read_contents('sqlite:///users.sqlite#users', name={'like': '%WILSON'   ...: })Out[6]:[{'id': 5, 'name': 'Ann Wilson', 'age': 71, 'belongs': 'Heart'}, {'id': 6, 'name': 'Nacy Wilson', 'age': 67, 'belongs': 'Heart'}]In [7]:```and pass to `row_type` parameter as followings.```pythonIn [17]: d = io.read_contents('sqlite:///users.sqlite#users', row_type=aDict)In [18]: users = list(d)In [19]: users[0]Out[19]: aDict({'id': 1, 'name': 'David Coverdale', 'age': 71, 'belongs': 'Whitesnake'})In [20]: users[0].nameOut[20]: 'David Coverdale'In [21]:```See also: [dataset document](https://dataset.readthedocs.io/en/latest/)currently, not support write_database().### base64 and subformat.base64 serializer accept subformat.if pass 'base64,json' to `format`,  recognaized as 'format, subformat'. - dumps: if set 'subformat', first encoding subformat then encoding base64 - loads: if set 'subformat', first decoding base64 then decoding subformat```pythoIn [2]: from datajuggler import serializer as ioIn [3]: import datetimeIn [4]: import decimalIn [5]: data = {'a': 1,   ...:   'b': decimal.Decimal('2'),   ...:   'c': datetime.datetime(2020, 5, 24, 8, 20),   ...:   'd': datetime.date(1962, 1, 13),   ...:   'e': datetime.time(11, 12, 13),   ...:   'f': [1, 2, 3, decimal.Decimal('4')]}In [6]: io.dumps(data, format='base64,yaml:custom')Out[6]: b'YTogMQpiOiAhPHRhZzpnaXRodWIuY29tL2lpc2FrYTUxL2RhdGFqdWdnbGVyLDIwMjI6cHl0aG9uL2RhdGFqdWdnbGVyPgogIF9fY2xhc3NfbmFtZV9fOiA8Y2xhc3MgJ2RlY2ltYWwuRGVjaW1hbCc+CiAgX19kdW1wZWRfb2JqX186CiAgICBfX3R5cGVfXzogRGVjaW1hbAogICAgdmFsdWU6ICcyJwpjOiAhPHRhZzpnaXRodWIuY29tL2lpc2FrYTUxL2RhdGFqdWdnbGVyLDIwMjI6cHl0aG9uL2RhdGFqdWdnbGVyPgogIF9fY2xhc3NfbmFtZV9fOiA8Y2xhc3MgJ2RhdGV0aW1lLmRhdGV0aW1lJz4KICBfX2R1bXBlZF9vYmpfXzoKICAgIF9fdHlwZV9fOiBkYXRldGltZQogICAgdmFsdWU6CiAgICAtIDIwMjAKICAgIC0gNQogICAgLSAyNAogICAgLSA4CiAgICAtIDIwCiAgICAtIDAKZDogITx0YWc6Z2l0aHViLmNvbS9paXNha2E1MS9kYXRhanVnZ2xlciwyMDIyOnB5dGhvbi9kYXRhanVnZ2xlcj4KICBfX2NsYXNzX25hbWVfXzogPGNsYXNzICdkYXRldGltZS5kYXRlJz4KICBfX2R1bXBlZF9vYmpfXzoKICAgIF9fdHlwZV9fOiBkYXRlCiAgICB2YWx1ZToKICAgIC0gMTk2MgogICAgLSAxCiAgICAtIDEzCmU6ICE8dGFnOmdpdGh1Yi5jb20vaWlzYWthNTEvZGF0YWp1Z2dsZXIsMjAyMjpweXRob24vZGF0YWp1Z2dsZXI+CiAgX19jbGFzc19uYW1lX186IDxjbGFzcyAnZGF0ZXRpbWUudGltZSc+CiAgX19kdW1wZWRfb2JqX186CiAgICBfX3R5cGVfXzogdGltZQogICAgdmFsdWU6CiAgICAtIDExCiAgICAtIDEyCiAgICAtIDEzCmY6Ci0gMQotIDIKLSAzCi0gITx0YWc6Z2l0aHViLmNvbS9paXNha2E1MS9kYXRhanVnZ2xlciwyMDIyOnB5dGhvbi9kYXRhanVnZ2xlcj4KICBfX2NsYXNzX25hbWVfXzogPGNsYXNzICdkZWNpbWFsLkRlY2ltYWwnPgogIF9fZHVtcGVkX29ial9fOgogICAgX190eXBlX186IERlY2ltYWwKICAgIHZhbHVlOiAnNCcK'In [7]: s = io.dumps(data, format='base64,yaml:custom')In [8]: io.loads(s, format='base64,yaml:custom')Out[8]:{'a': 1, 'b': Decimal('2'), 'c': datetime.datetime(2020, 5, 24, 8, 20), 'd': datetime.date(1962, 1, 13), 'e': datetime.time(11, 12, 13), 'f': [1, 2, 3, Decimal('4')]}In [9]: io.loads(s, format='base64')Out[9]: b&quot;a: 1\nb: !&lt;tag:github.com/iisaka51/datajuggler,2022:python/datajuggler&gt;\n  __class_name__: &lt;class 'decimal.Decimal'&gt;\n  __dumped_obj__:\n    __type__: Decimal\n    value: '2'\nc: !&lt;tag:github.com/iisaka51/datajuggler,2022:python/datajuggler&gt;\n  __class_name__: &lt;class 'datetime.datetime'&gt;\n  __dumped_obj__:\n    __type__: datetime\n    value:\n    - 2020\n    - 5\n    - 24\n    - 8\n    - 20\n    - 0\nd: !&lt;tag:github.com/iisaka51/datajuggler,2022:python/datajuggler&gt;\n  __class_name__: &lt;class 'datetime.date'&gt;\n  __dumped_obj__:\n    __type__: date\n    value:\n    - 1962\n    - 1\n    - 13\ne: !&lt;tag:github.com/iisaka51/datajuggler,2022:python/datajuggler&gt;\n  __class_name__: &lt;class 'datetime.time'&gt;\n  __dumped_obj__:\n    __type__: time\n    value:\n    - 11\n    - 12\n    - 13\nf:\n- 1\n- 2\n- 3\n- !&lt;tag:github.com/iisaka51/datajuggler,2022:python/datajuggler&gt;\n  __class_name__: &lt;class 'decimal.Decimal'&gt;\n  __dumped_obj__:\n    __type__: Decimal\n    value: '4'\n&quot;In [10]:```### base64 and encrypt/decrypt.base64 serializer accept password.If set 'password', perform operation encrypt/decrypt for dumps()/loads(). - dumps()   - raw_data -&gt; subformat encode -&gt; encrypt -&gt; base64 encode - loads()   - base64 decode -&gt; decrypt -&gt; subformat decode -&gt; raw_data```pythonIn [5]: from datajuggler import serializer as ioIn [6]: data = { 'January': 1, 'February': 2, 'March': 3, 'April': 4 }In [7]: s = io.dumps(data, format='base64, json')In [8]: io.loads(s, format='base64, json')Out[8]: {'January': 1, 'February': 2, 'March': 3, 'April': 4}In [9]: s = io.dumps(data, format='base64, json', password='python123')In [10]: io.loads(s, format='base64, json', password='python123')Out[10]: {'January': 1, 'February': 2, 'March': 3, 'April': 4}In [11]: sOut[11]: b'ra3xLVfJAfeEH3MTZ0FBQUFBQmpXZTl1WU1VU1Q2bDhWTG5iWF9oMEgtMjB2d1BNWUFhX2Y2cTZkcmgwZkFPQzhjV3Q2amY2QjlVbGFHODYzbUtYaHZPNjQ0N0J5OUY4R1oxSFBaVjV0VVFqY0tfbzgzVXBzQ2lCdWVORGpyMkhqVEhLRVMwNkxvbm5LbU5VZmlCWDR3QUlxekN6dGVYX2VwcUdWUHpvLVFwcXhBPT0='In [12]: import base64In [13]: base64.b64decode(s)Out[13]: b'\xad\xad\xf1-W\xc9\x01\xf7\x84\x1fs\x13gAAAAABjWe9uYMUST6l8VLnbX_h0H-20vwPMYAa_f6q6drh0fAOC8cWt6jf6B9UlaG863mKXhvO6447By9F8GZ1HPZV5tUQjcK_o83UpsCiBueNDjr2HjTHKES06LonnKmNUfiBX4wAIqzCzteX_epqGVPzo-QpqxA=='In [14]: io.loads(s, format='base64')Out[14]: b'\xad\xad\xf1-W\xc9\x01\xf7\x84\x1fs\x13gAAAAABjWe9uYMUST6l8VLnbX_h0H-20vwPMYAa_f6q6drh0fAOC8cWt6jf6B9UlaG863mKXhvO6447By9F8GZ1HPZV5tUQjcK_o83UpsCiBueNDjr2HjTHKES06LonnKmNUfiBX4wAIqzCzteX_epqGVPzo-QpqxA=='In [15]: io.loads(s, format='base64', password='python123')Out[15]: b'{&quot;January&quot;: 1, &quot;February&quot;: 2, &quot;March&quot;: 3, &quot;April&quot;: 4}'In [16]:```## class aDictAllow to access using dot notation for dictionary.This class is inspired by [munch](https://github.com/Infinidat/munch).aDict is subclass of BaseDict.This class is inspired by [munch](https://github.com/Infinidat/munch) and [adict](https://github.com/mewwts/addict).```pythonIn [1]: from datajuggler import aDictIn [2]: d = aDict()In [3]: d.python = 'great'In [4]: dOut[4]: aDict({'python': 'great'})In [5]: d['python']Out[5]: 'great'In [6]: data = {'one': {'two': {'three': {'four': 4 }}}}In [7]: d = aDict(data)In [8]: dOut[8]: aDict({'one': aDict({'two': aDict({'three': aDict({'four': 4})})})})In [9]: d.one.two.three.fourOut[9]: 4In [10]:```aDict support hashable and immutable dictionary. - `freeze()` - freeze object for immutable. - `unfreeze()` - unfreeze objectbuilt-in function `hash()` acceptfrozen object.So, frozen aDict object is able to set as key to dictionary.```pythonIn [1]: from datajuggler import aDictIn [2]: d = aDict({'one': {'two': {'three': {'four': 4 }}}})In [3]: dOut[3]: aDict({'one': aDict({'two': aDict({'three': aDict({'four': 4})})})})In [4]: d.one.two.three.four = 1In [5]: d.freeze()In [6]: try:   ...:     d.one.two.three.four = 2   ...: except AttributeError as e:   ...:     print(e)   ...:aDict frozen object cannot be modified.In [7]: d.unfreeze()In [8]: d.one.two.three.four = 2In [9]:```## class Keypath and KeylistThis is utility class for uDict and manage for keypath and Keylist```pythondata = { &quot;a&quot;: 1,         &quot;b&quot;: { &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, },                &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, },                &quot;e&quot;: [ { &quot;x&quot;: 1, &quot;y&quot;: -1, &quot;z&quot;: [101, 201, 301], },                       { &quot;x&quot;: 2, &quot;y&quot;: -2, &quot;z&quot;: [102, 202, 302], },                       { &quot;x&quot;: 3, &quot;y&quot;: -3, &quot;z&quot;: [103, 203, 303], },                     ],              },      }```Keylist(['b','e[1]', 'z[0]']) point to value `102`.Keypath(['b.e[1].z[0]']) point to value `102`.indexes of list should be integer or str([index]).```pythonIn [7]: Keylist(['b', 'e[1]', 'z[0]'])Out[7]: Keylist(['b', 'e', 1, 'z', 0])```### methods for Keylist class - `keylistss(d: dict)` - `to_keypath(d: dict)` - `list2path(keylist)` - `value()` - `validate(keylist)`### methods for Keypath class - `keypaths(d: dict)` - `to_keylist(keypath)` - `path2list(keypath)` - `value()` - `validate(keypath)`### keylists()keylists() suppport list of key as keys. - `keylists(obj, indexes=False)````pythonIn [1]: from datajuggler import keylists   ...:   ...: data = { &quot;a&quot;: 1,   ...:          &quot;b&quot;: { &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, },   ...:                 &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, },   ...:               },   ...:         }   ...:   ...: expect = [ [&quot;a&quot;],   ...:            [&quot;b&quot;],   ...:            [&quot;b&quot;, &quot;c&quot;],   ...:            [&quot;b&quot;, &quot;c&quot;, &quot;x&quot;],   ...:            [&quot;b&quot;, &quot;c&quot;, &quot;y&quot;],   ...:            [&quot;b&quot;, &quot;d&quot;],   ...:            [&quot;b&quot;, &quot;d&quot;, &quot;x&quot;],   ...:            [&quot;b&quot;, &quot;d&quot;, &quot;y&quot;],   ...:        ]   ...: result = keylists(data)   ...: assert result == expectIn [2]: data = { 1: { 1: 1, },   ...:          2: { 2: 1, },   ...:          3: { None: 1, },   ...:        }   ...: expect = [[1], [1, 1], [2], [2, 2], [3], [3, None]]   ...: result = keylists(data)   ...: assert result == expect   ...:                        { &quot;x&quot;: 2, &quot;y&quot;: -2, &quot;z&quot;: [2, 3, 4], },   ...:                        { &quot;x&quot;: 3, &quot;y&quot;: -3, &quot;z&quot;: [3, 4, 5], },   ...:                      ],   ...:               },   ...:        }   ...: expect = [   ...:     [&quot;a&quot;],   ...:     [&quot;b&quot;],   ...:     [&quot;b&quot;, &quot;c&quot;],   ...:     [&quot;b&quot;, &quot;c&quot;, &quot;x&quot;],   ...:     [&quot;b&quot;, &quot;c&quot;, &quot;y&quot;],   ...:     [&quot;b&quot;, &quot;d&quot;],   ...:     [&quot;b&quot;, &quot;d&quot;, &quot;x&quot;],   ...:     [&quot;b&quot;, &quot;d&quot;, &quot;y&quot;],   ...:     [&quot;b&quot;, &quot;e&quot;],   ...:     [&quot;b&quot;, &quot;e[0]&quot;],   ...:     [&quot;b&quot;, &quot;e[0]&quot;, &quot;x&quot;],   ...:     [&quot;b&quot;, &quot;e[0]&quot;, &quot;y&quot;],   ...:     [&quot;b&quot;, &quot;e[0]&quot;, &quot;z&quot;],   ...:     [&quot;b&quot;, &quot;e[0]&quot;, &quot;z[0]&quot;],   ...:     [&quot;b&quot;, &quot;e[0]&quot;, &quot;z[1]&quot;],   ...:     [&quot;b&quot;, &quot;e[0]&quot;, &quot;z[2]&quot;],   ...:     [&quot;b&quot;, &quot;e[1]&quot;],   ...:     [&quot;b&quot;, &quot;e[1]&quot;, &quot;x&quot;],   ...:     [&quot;b&quot;, &quot;e[1]&quot;, &quot;y&quot;],   ...:     [&quot;b&quot;, &quot;e[1]&quot;, &quot;z&quot;],   ...:     [&quot;b&quot;, &quot;e[1]&quot;, &quot;z[0]&quot;],   ...:     [&quot;b&quot;, &quot;e[1]&quot;, &quot;z[1]&quot;],   ...:     [&quot;b&quot;, &quot;e[1]&quot;, &quot;z[2]&quot;],   ...:     [&quot;b&quot;, &quot;e[2]&quot;],   ...:     [&quot;b&quot;, &quot;e[2]&quot;, &quot;x&quot;],   ...:     [&quot;b&quot;, &quot;e[2]&quot;, &quot;y&quot;],   ...:     [&quot;b&quot;, &quot;e[2]&quot;, &quot;z&quot;],   ...:     [&quot;b&quot;, &quot;e[2]&quot;, &quot;z[0]&quot;],   ...:     [&quot;b&quot;, &quot;e[2]&quot;, &quot;z[1]&quot;],   ...:     [&quot;b&quot;, &quot;e[2]&quot;, &quot;z[2]&quot;],   ...: ]   ...: result  = keylists(data, indexes=True)   ...: result.sort()   ...: assert result == expectIn [4]: data = { &quot;a&quot;: { &quot;b&quot;: [   ...:                    [1, 2],   ...:                    [3, 4, 5],   ...:                    [ { &quot;x&quot;: 1, &quot;y&quot;: -1, }, ],   ...:                  ],   ...:               },   ...:        }   ...: expect = [ [&quot;a&quot;],   ...:            [&quot;a&quot;, &quot;b&quot;],   ...:            [&quot;a&quot;, &quot;b[0]&quot;],   ...:            [&quot;a&quot;, &quot;b[0][0]&quot;],   ...:            [&quot;a&quot;, &quot;b[0][1]&quot;],   ...:            [&quot;a&quot;, &quot;b[1]&quot;],   ...:            [&quot;a&quot;, &quot;b[1][0]&quot;],   ...:            [&quot;a&quot;, &quot;b[1][1]&quot;],   ...:            [&quot;a&quot;, &quot;b[1][2]&quot;],   ...:            [&quot;a&quot;, &quot;b[2]&quot;],   ...:            [&quot;a&quot;, &quot;b[2][0]&quot;],   ...:            [&quot;a&quot;, &quot;b[2][0]&quot;, &quot;x&quot;],   ...:            [&quot;a&quot;, &quot;b[2][0]&quot;, &quot;y&quot;],   ...:         ]   ...: result = keylists(data, indexes=True)   ...: result.sort()   ...: assert result == expectIn [5]: data = { &quot;a&quot;: 1,   ...:          &quot;b&quot;: { &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, },   ...:                 &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, },   ...:                 &quot;e&quot;: [ { &quot;x&quot;: 1, &quot;y&quot;: -1, &quot;z&quot;: [1, 2, 3], },   ...:                        { &quot;x&quot;: 2, &quot;y&quot;: -2, &quot;z&quot;: [2, 3, 4], },   ...:                        { &quot;x&quot;: 3, &quot;y&quot;: -3, &quot;z&quot;: [3, 4, 5], },   ...:                      ],   ...:               },   ...:       }   ...: expect = [ [&quot;a&quot;],   ...:            [&quot;b&quot;],   ...:            [&quot;b&quot;, &quot;c&quot;],   ...:            [&quot;b&quot;, &quot;c&quot;, &quot;x&quot;],   ...:            [&quot;b&quot;, &quot;c&quot;, &quot;y&quot;],   ...:            [&quot;b&quot;, &quot;d&quot;],   ...:            [&quot;b&quot;, &quot;d&quot;, &quot;x&quot;],   ...:            [&quot;b&quot;, &quot;d&quot;, &quot;y&quot;],   ...:            [&quot;b&quot;, &quot;e&quot;],   ...:        ]   ...: result = keylists(data, indexes=False)   ...: result.sort()   ...: assert result == expectIn [6]:```### keypaths()Keypath support attribute-styple access to value (dot-notation by default). - `keypaths(obj, separator, indexes=False)````pythonIn [1]: from datajuggler import keypaths   ...:   ...: data = { &quot;a&quot;: 1,   ...:          &quot;b&quot;: { &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3 },   ...:                 &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5 },   ...:          },   ...: }   ...: expect = [ &quot;a&quot;,   ...:            &quot;b&quot;,   ...:            &quot;b.c&quot;,   ...:            &quot;b.c.x&quot;,   ...:            &quot;b.c.y&quot;,   ...:            &quot;b.d&quot;,   ...:            &quot;b.d.x&quot;,   ...:            &quot;b.d.y&quot;,   ...:       ]   ...:   ...: result = keypaths(data)   ...: assert result == expectIn [2]: data = { &quot;a&quot;: 1,   ...:          &quot;b&quot;: { &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3 },   ...:          &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5 },   ...:     },   ...: }   ...: expect = [ &quot;a&quot;,   ...:            &quot;b&quot;,   ...:            &quot;b c&quot;,   ...:            &quot;b c x&quot;,   ...:            &quot;b c y&quot;,   ...:            &quot;b d&quot;,   ...:            &quot;b d x&quot;,   ...:            &quot;b d y&quot;,   ...:       ]   ...: result = keypaths(data, separator=&quot; &quot;)   ...: assert result == expectIn [3]: data = { 1: { 1: 1 }, 2: { 2: 1 }, 3: { 3: 1 } }   ...: expect = ['1', '1.1', '2', '2.2', '3', '3.3']   ...: result = keypaths(data)   ...: assert result == expectIn [4]: data = { &quot;a&quot;: 1,   ...:          &quot;b&quot;: { &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, },   ...:                 &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, },   ...:                 &quot;e&quot;: [ { &quot;x&quot;: 1, &quot;y&quot;: -1, &quot;z&quot;: [1, 2, 3], },   ...:                        { &quot;x&quot;: 2, &quot;y&quot;: -2, &quot;z&quot;: [2, 3, 4], },   ...:                        { &quot;x&quot;: 3, &quot;y&quot;: -3, &quot;z&quot;: [3, 4, 5], },   ...:                 ],   ...:             },   ...:         }   ...: expect = [ &quot;a&quot;,   ...:            &quot;b&quot;,   ...:            &quot;b.c&quot;, &quot;b.c.x&quot;, &quot;b.c.y&quot;, &quot;b.d&quot;, &quot;b.d.x&quot;, &quot;b.d.y&quot;, &quot;b.e&quot;,   ...:            &quot;b.e[0]&quot;, &quot;b.e[0].x&quot;, &quot;b.e[0].y&quot;, &quot;b.e[0].z&quot;,   ...:            &quot;b.e[0].z[0]&quot;, &quot;b.e[0].z[1]&quot;, &quot;b.e[0].z[2]&quot;,   ...:            &quot;b.e[1]&quot;, &quot;b.e[1].x&quot;, &quot;b.e[1].y&quot;, &quot;b.e[1].z&quot;,   ...:            &quot;b.e[1].z[0]&quot;, &quot;b.e[1].z[1]&quot;, &quot;b.e[1].z[2]&quot;,   ...:            &quot;b.e[2]&quot;, &quot;b.e[2].x&quot;, &quot;b.e[2].y&quot;, &quot;b.e[2].z&quot;,   ...:            &quot;b.e[2].z[0]&quot;, &quot;b.e[2].z[1]&quot;, &quot;b.e[2].z[2]&quot;,   ...:     ]   ...:   ...: result = keypaths(data, indexes=True)   ...: assert result == expectIn [5]: data = { &quot;a&quot;: 1,   ...:          &quot;b&quot;: {   ...:             &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, },   ...:             &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, },   ...:             &quot;e&quot;: [ { &quot;x&quot;: 1, &quot;y&quot;: -1, &quot;z&quot;: [1, 2, 3], },   ...:                    { &quot;x&quot;: 2, &quot;y&quot;: -2, &quot;z&quot;: [2, 3, 4], },   ...:                    { &quot;x&quot;: 3, &quot;y&quot;: -3, &quot;z&quot;: [3, 4, 5], },   ...:                  ],   ...:             },   ...:         }   ...: expect = [ &quot;a&quot;,   ...:            &quot;b&quot;,   ...:            &quot;b.c&quot;,   ...:            &quot;b.c.x&quot;,   ...:            &quot;b.c.y&quot;,   ...:            &quot;b.d&quot;,   ...:            &quot;b.d.x&quot;,   ...:            &quot;b.d.y&quot;,   ...:            &quot;b.e&quot;,   ...:        ]   ...: result = keypaths(data, indexes=False)   ...: assert result == expectIn [6]: data  = { &quot;a&quot;: { &quot;b&quot;: [ [1, 2],   ...:                         [3, 4, 5],   ...:                         [ { &quot;x&quot;: 1, &quot;y&quot;: -1, }, ],   ...:                   ],   ...:             },   ...:      }   ...: expect = [ &quot;a&quot;,   ...:            &quot;a.b&quot;,   ...:            &quot;a.b[0]&quot;,   ...:            &quot;a.b[0][0]&quot;,   ...:            &quot;a.b[0][1]&quot;,   ...:            &quot;a.b[1]&quot;,   ...:            &quot;a.b[1][0]&quot;,   ...:            &quot;a.b[1][1]&quot;,   ...:            &quot;a.b[1][2]&quot;,   ...:            &quot;a.b[2]&quot;,   ...:            &quot;a.b[2][0]&quot;,   ...:            &quot;a.b[2][0].x&quot;,   ...:            &quot;a.b[2][0].y&quot;,   ...: ]   ...: result = keypaths(data, indexes=True)   ...: assert result == expectIn [7]:```### list2path() and path2list()Convert from/to keylists and keypaths.```pythonIn [1]: from datajuggler import Keylist, Keypath   ...:   ...: data = ['x', 'y', 'z']   ...: expect = ['x.y.z']   ...:   ...: result = Keylist.list2path(data)   ...: assert result == expectIn [2]: expect = ['x_y_z']   ...: result = Keylist.list2path(data, separator='_')   ...: assert result == expectIn [3]: data = [['x', 'y', 'z'], ['a', 'b', 'c']]   ...: expect = ['x.y.z', 'a.b.c']   ...: result = Keylist.list2path(data)   ...: assert result == expectIn [4]: data = 'x.y.z'   ...: expect = ['x', 'y', 'z']   ...: result = Keypath.path2list(data)   ...: assert result == expectIn [5]: data = 'x_y_z'   ...: expect = ['x', 'y', 'z']   ...: result = Keypath.path2list(data, separator='_')   ...: assert result == expectIn [6]: data = ['x.y.z', 'a.b.c']   ...: expect = [['x', 'y', 'z'], ['a', 'b', 'c']]   ...: result = Keypath.path2list(data)   ...: assert result == expectIn [7]:```## class uDictuDict is utilized dictionary which is subclass of IODict.This class is inspired by [python-benedict](https://github.com/fabiocaccamo/python-benedict).uDict support keypath and keylist.uDict has following  methods. - `clean(d1: dict, strings=True, collections=True,          inplace=False, factory=dict)` - `clone(d1: dict, empty=False, memo=None)` - `compare(d1: dict, d2: dict, keys=None, thrown_error=False)` - `counts(pattern, d=None, count_for&quot;key&quot;, wild=False, verbatim=False)` - `filter(predicate, d=None, factory=dict)` - `get_keys(d=None, output_as=None)` - `get_values(keys, d=None)` - `groupby(seq, key, factory=dict)` - `invert(d=None, flat=False, inplace=False, factory=dict)` - `keylists(d=None, indexes=False)` - `keypaths(d=None, indexes=False, separator=&quot;.&quot;)` - `map(func, d=None, map_for=None, inplace=False, factory=dict)` - `merge(other, d=None, overwrite=False, inplace=False, factory=dict)` - `move(key_src, key_dest, d=None, overwrite=False, inplace=False, factory=dict)` - `nest(items, key, patrent_key, children_key)` - `rename(key, key_new, d=None, case_name=None, overwrite=False,           inplace=False, factory=dict)` - `remove(keys, d=None, inplace=False, factory=dict)` - `subset(keys, d=None, default=None, use_keypath=False,           separator=&quot;.&quot;, inplace=False, factory=dict)` - `find(keys, d=None, default=None, first_one=True, factory=dict)` - `search(query, d=None, search_for=&quot;key&quot;, exact=False, ignore_case=False)` - `sort(d=None, sort_by=&quot;key&quot;, reverse=False, inplace=False, factory=dict)` - `swap(key1, key2, d=None, inplace=False, factory=dict)` - `flatten(d=None, separator=&quot;.&quot;, inplace=False, factory=dict)` - `unflatten(d=None, default=None, separator=&quot;.&quot;, inplace=False, factory=dict)` - `traverse(callback, d=None, parents=[], *args, **kwargs)` - `unique(d=None)` - `get_items(loc, value, d=None, func=None,                   separator='.',inplace=False,  factory=dict)` - `pop_items(loc, value, d=None, func=None,                   separator='.',inplace=False,  factory=dict)` - `del_items(loc, value, d=None, func=None,                   separator='.',inplace=False,  factory=dict)` - `set_items(loc, value, d=None, func=None,                   separator='.',inplace=False,  factory=dict)`helper functions are defined in datajuggler.dicthelper for normal dict objects. - `d_clean()` - `d_clone()` - `d_compare()` - `d_counts()` - `d_filter()` - `d_groupby()` - `d_invert()` - `d_map()` - `d_merge()` - `d_move()` - `d_rename()` - `d_remove()` - `d_nest()` - `d_subset()` - `d_find()` - `d_sort()` - `d_search()` - `d_swap()` - `d_flatten()` - `d_unflatten()` - `d_traverse()` - `d_unique()` - `get_keys()` - `get_values()` - `get_items()` - `pop_items()` - `del_items()` - `set_items()`### clean() and d_clean()```pythondef clean(self,        obj: Optional[dict]=None,        strings=True,        collections=True,        inplace: bool=False,        factory: Optional[Type[dict]]=None,    ):``````pythondef d_clean(        obj: dict,        strings=True,        collections=True,        inplace: bool=False,        factory: Type[dict]=dict,    ):```Clean the current dict instance removing all empty values:    None, '', {}, [], ().If strings or collections (dict, list, set, tuple) flags are False,related empty values will not be deleted.```pythonIn [1]: from datajuggler import aDict   ...: from datajuggler.dicthelper import d_clean   ...:   ...: data = {   ...:     &quot;a&quot;: {},   ...:     &quot;b&quot;: {&quot;x&quot;: 1},   ...:     &quot;c&quot;: [],   ...:     &quot;d&quot;: [0, 1],   ...:     &quot;e&quot;: 0.0,   ...:     &quot;f&quot;: &quot;&quot;,   ...:     &quot;g&quot;: None,   ...:     &quot;h&quot;: &quot;0&quot;,   ...: }   ...:   ...: expect = {   ...:     &quot;b&quot;: {&quot;x&quot;: 1},   ...:     &quot;d&quot;: [0, 1],   ...:     &quot;e&quot;: 0.0,   ...:     &quot;h&quot;: &quot;0&quot;,   ...: }   ...:   ...: result = d_clean(data)   ...: assert result == expectIn [2]: expect = {   ...:     &quot;a&quot;: {},   ...:     &quot;b&quot;: {&quot;x&quot;: 1},   ...:     &quot;c&quot;: [],   ...:     &quot;d&quot;: [0, 1],   ...:     &quot;e&quot;: 0.0,   ...:     &quot;h&quot;: &quot;0&quot;,   ...: }   ...:   ...: result = d_clean(data, collections=False)   ...: assert result == expectIn [3]: expect = {   ...:     &quot;b&quot;: {&quot;x&quot;: 1},   ...:     &quot;d&quot;: [0, 1],   ...:     &quot;e&quot;: 0.0,   ...:     &quot;f&quot;: &quot;&quot;,   ...:     &quot;h&quot;: &quot;0&quot;,   ...: }   ...:   ...: result = d_clean(data, strings=False)   ...: assert result == expectIn [4]: expect = aDict({   ...:             &quot;b&quot;: {&quot;x&quot;: 1},   ...:             &quot;d&quot;: [0, 1],   ...:             &quot;e&quot;: 0.0,   ...:             &quot;h&quot;: &quot;0&quot;,   ...:          })   ...:   ...: result = d_clean(data, factory=aDict)   ...: assert result == expectIn [5]: expect = {   ...:     &quot;b&quot;: {&quot;x&quot;: 1},   ...:     &quot;d&quot;: [0, 1],   ...:     &quot;e&quot;: 0.0,   ...:     &quot;h&quot;: &quot;0&quot;,   ...: }   ...:   ...: d_clean(data, inplace=True)   ...: assert data == expectIn [6]:```### clone() and d_clone()```pythondef clone(self,        obj: Optional[dict]=None,        empty: bool=False,        memo: Optional[dict]=None,        factory: Optional[Type[dict]]=None,    ):``````pythondef d_clone(        obj: dict,        empty: bool=False,        memo: Optional[dict]=None,    ):```Return a clone (deepcopy) of the dict.```pythonIn [1]: from datajuggler.dicthelper import d_clone   ...:   ...: data = { &quot;a&quot;: { &quot;b&quot;: { &quot;c&quot;: 1, }, }, }   ...:   ...: result = d_clone(data)   ...: assert isinstance(result, dict) == True   ...: assert result == dataIn [2]: result[&quot;a&quot;][&quot;b&quot;][&quot;c&quot;] = 2   ...:   ...: assert result[&quot;a&quot;][&quot;b&quot;][&quot;c&quot;] == 2   ...: assert data[&quot;a&quot;][&quot;b&quot;][&quot;c&quot;] == 1In [3]: data = { &quot;a&quot;: { &quot;b&quot;: { &quot;c&quot;: 1, }, }, }   ...: result = d_clone(data, empty=True)   ...: assert isinstance(result, dict) == True   ...: assert result == {}In [4]:```### compare() and d_compare()```pythondef compare(self,    d1: dict,    d2: Optional[dict]=None,    *,    keys: Optional[Union[Hashable,list]]=None,    keylist: bool=False,    keypath: bool=False,    thrown_error: bool=False,    ):``````pythobdef d_compare(        d1: dict,        d2: dict,        *,        keys: Optional[Union[Hashable,list, Keylist, Keypath]]=None,        keylist: bool=False,        keypath: bool=False,        thrown_error: bool=False,    ):```Compare tow dictionary with keys and return `True` when equal found values.otherwise return `False`.if not set second dictionary, use self object.if not set keys, just compare two dictionaries,if pass `thrown_error=True`, raise ValueError when not equal found values.if passs `keylist=True`, keylist accept for key.if passs `keypath=True`, keypath accept for key.```pythonIn [1]: from datajuggler import aDict, Keylist, Keypath   ...: from datajuggler.dicthelper import d_compare   ...:   ...: d1 = {}   ...: d2 = {}   ...: result = d_compare(d1, d2)   ...: assert result == TrueIn [2]: d1 = {1: 1}   ...: d2 = {1: 1}   ...: result = d_compare(d1, d2)   ...: assert result == TrueIn [3]: d1 = {'1': 'one'}   ...: d2 = {'1': 'one'}   ...: result = d_compare(d1, d2)   ...: assert result == TrueIn [4]: d1 = {'1': 'one'}   ...: d2 = {'1':  2}   ...: result = d_compare(d1, d2)   ...: assert result == FalseIn [5]: d1 = { &quot;a&quot;: 1, &quot;b&quot;: [1,2,3] }   ...: d2 = { &quot;a&quot;: 1, &quot;b&quot;: [1,2,3] }   ...: result = d_compare(d1, d2)   ...: assert result == TrueIn [6]: d1 = { &quot;a&quot;: 1,   ...:        &quot;b&quot;: 2,   ...:        &quot;c&quot;: {   ...:             &quot;d&quot;: {   ...:                 &quot;e&quot;: 3,   ...:                 &quot;f&quot;: 4,   ...:                 &quot;g&quot;: { &quot;h&quot;: 5, },   ...:             }   ...:          },   ...:       }   ...: d2 = { &quot;a&quot;: 1,   ...:        &quot;b&quot;: 2,   ...:        &quot;c&quot;: {   ...:             &quot;d&quot;: {   ...:                 &quot;e&quot;: 3,   ...:                 &quot;f&quot;: 4,   ...:                 &quot;g&quot;: { &quot;h&quot;: 5, },   ...:             }   ...:          },   ...:       }   ...: result = d_compare(d1, d2)   ...: assert result == TrueIn [7]: d1 = { &quot;a&quot;: 1,   ...:        &quot;b&quot;: 2,   ...:        &quot;c&quot;: {   ...:             &quot;d&quot;: {   ...:                 &quot;e&quot;: 3,   ...:                 &quot;f&quot;: 4,   ...:                 &quot;g&quot;: { &quot;h&quot;: 5, },   ...:             }   ...:          },   ...:       }   ...: d2 = { &quot;a&quot;: 1,   ...:        &quot;b&quot;: 2,   ...:        &quot;c&quot;: {   ...:             &quot;d&quot;: {   ...:                 &quot;e&quot;: 13,   ...:                 &quot;f&quot;: 14,   ...:                 &quot;g&quot;: { &quot;h&quot;: 5, },   ...:             }   ...:          },   ...:       }   ...: result = d_compare(d1, d2, keys='b')   ...: assert result == TrueIn [8]: d1 = { &quot;a&quot;: 1,   ...:        &quot;b&quot;: 2,   ...:        &quot;c&quot;: {   ...:             &quot;d&quot;: {   ...:                 &quot;e&quot;: 3,   ...:                 &quot;f&quot;: 4,   ...:                 &quot;g&quot;: { &quot;h&quot;: 5, },   ...:             }   ...:          },   ...:       }   ...: d2 = { &quot;a&quot;: 1,   ...:        &quot;b&quot;: 2,   ...:        &quot;c&quot;: {   ...:             &quot;d&quot;: {   ...:                 &quot;e&quot;: 13,   ...:                 &quot;f&quot;: 14,   ...:                 &quot;g&quot;: { &quot;h&quot;: 5, },   ...:             }   ...:          },   ...:       }   ...: result = d_compare(d1, d2, keys='d')   ...: assert result == FalseIn [9]: d1 = { &quot;a&quot;: 1,   ...:        &quot;b&quot;: 2,   ...:        &quot;c&quot;: {   ...:             &quot;d&quot;: {   ...:                 &quot;e&quot;: 3,   ...:                 &quot;f&quot;: 4,   ...:                 &quot;g&quot;: { &quot;h&quot;: 5, },   ...:             }   ...:          },   ...:       }   ...: d2 = { &quot;a&quot;: 1,   ...:        &quot;b&quot;: 2,   ...:        &quot;c&quot;: {   ...:             &quot;d&quot;: {   ...:                 &quot;e&quot;: 13,   ...:                 &quot;f&quot;: 14,   ...:                 &quot;g&quot;: { &quot;h&quot;: 5, },   ...:             }   ...:          },   ...:       }   ...: result = d_compare(d1, d2, keys=Keylist(['c', 'd', 'g']))   ...: assert result == TrueIn [10]: d1 = { &quot;a&quot;: 1,    ...:        &quot;b&quot;: 2,    ...:        &quot;c&quot;: {    ...:             &quot;d&quot;: {    ...:                 &quot;e&quot;: 3,    ...:                 &quot;f&quot;: 4,    ...:                 &quot;g&quot;: { &quot;h&quot;: 5, },    ...:             }    ...:          },    ...:       }    ...: d2 = { &quot;a&quot;: 1,    ...:        &quot;b&quot;: 2,    ...:        &quot;c&quot;: {    ...:             &quot;d&quot;: {    ...:                 &quot;e&quot;: 13,    ...:                 &quot;f&quot;: 14,    ...:                 &quot;g&quot;: { &quot;h&quot;: 5, },    ...:             }    ...:          },    ...:       }    ...: result = d_compare(d1, d2, keys=Keypath('c.d.g'))    ...: assert result == TrueIn [11]:```### counts() and d_counts()```pythondef counts(self,        pattern: Union[Pattern, Hashable, Sequence],        obj: Optional[dict]=None,        count_for: DictItemType=DictItem.KEY,        wild: bool=False,        verbatim: bool=False,    ) -&gt;Union[int, dict]:``````pythondef d_counts(        obj: dict,        pattern: Union[Hashable, Pattern, Sequence],        count_for: DictItemType=DictItem.KEY,        wild: bool=False,        verbatim: bool=False,    ) -&gt;Union[int, dict]:```Counts of keys or values.`count_for` accept &quot;key&quot; and &quot;value&quot;.if pass `wild=True`, match substr and ignore_case.if pass `verbatim=True`, counts as it is.```pythonIn [1]: from datajuggler.dicthelper import d_counts   ...:   ...: data = {'x': {'y': {'z': [{'aA': 'v11', 'b': 'v12', 'c': 'v13'},   ...:                           {'aA': 'v21', 'b': 'v22', 'c': 'v23'}]} }}   ...: d_counts(data, 'aA')Out[1]: 2In [2]: d_counts(data, 'aA', count_for='key')Out[2]: 2In [3]: d_counts(data, 'aa', count_for='key')Out[3]: 0In [4]: d_counts(data, 'aa', count_for='key', wild=True)Out[4]: 2In [5]: d_counts(data, ['aA', 'b'])Out[5]: defaultdict(int, {'aA': 2, 'b': 2})In [6]: d_counts(data, ['aA', 'b'], wild=True)Out[6]: defaultdict(int, {'aA': 2, 'b': 2})In [7]: d_counts(data, ['a', 'b'], wild=True, verbatim=True)Out[7]: defaultdict(int, {'aA': 2, 'b': 2})In [8]: d_counts(data, 'v11', count_for='value')Out[8]: {'v11': 1}In [9]: d_counts(data, 'v1', count_for='value', wild=True)Out[9]: {'v1': 3}In [10]: d_counts(data, 'v1', count_for='value', wild=True, verbatim=True)Out[10]: {'v11': 1, 'v12': 1, 'v13': 1}In [11]: data = {'x': {'y': {'z': [{'aA': 100, 'b': 101, 'c': 103},    ...:                           {'aA': 100, 'b': 101, 'c': 103}]} }}    ...: d_counts(data, 100, count_for='value')Out[11]: {100: 2}In [12]:```### filter() and d_filter()```pythondef filter(self,        predicate: Callable,        obj: Optional[dict]=None,        factory: Optional[Type[dict]]=None,    ):``````pythondef d_filter(        predicate: Callable,        obj: dict,        factory: Type[dict]=dict,    ):```Create a new dictionary with filter items in dictionary by item.Predicate function receives key, value argumentsand should return a bool value.If set `factory`, create instance of factory class.If set `True` to `inplace`, perform operation in-place.```pythonIn [1]: from datajuggler import uDict,  aDict   ...: from datajuggler.dicthelper import d_filter   ...:   ...:   ...: is_janfeb = lambda x, y: x.endswith('ary')   ...: data = { 'January': 1, 'February': 2, 'March': 3, 'April': 4 }   ...:   ...: d_filter(is_janfeb, data)Out[1]: {'January': 1, 'February': 2}In [2]: d_filter(is_janfeb, data, factory=uDict)Out[2]: uDict({'January': 1, 'February': 2})In [3]: is_even = lambda x, y: y % 2 == 0   ...: d_filter(is_even, data)Out[3]: {'February': 2, 'April': 4}In [4]:```### groupby() and d_groupby()```pythondef groupby( self,        seq: list,        key: Hashable,        factory: Optional[Type[dict]]=None,    ) -&gt; dict:``````pythondef d_groupby(        seq: list,        key: Hashable,        factory: Type[dict]=dict,    ) -&gt; dict:```A groupby operation involves some combination of splitting the object, applying a function, and combining the results. This can be used to group large amounts of data and compute operations on these groups.```pythonIn [1]: from datajuggler import uDict,  aDict   ...: from datajuggler.dicthelper import d_groupby   ...:   ...: data = [   ...:     {&quot;id&quot;: 1, &quot;name&quot;: &quot;John&quot;},   ...:     {&quot;id&quot;: 2, &quot;name&quot;: &quot;Paul&quot;},   ...:     {&quot;id&quot;: 3, &quot;name&quot;: &quot;David&quot;},   ...:     {&quot;id&quot;: 4, &quot;name&quot;: &quot;Freddie&quot;},   ...:     {&quot;id&quot;: 3, &quot;name&quot;: &quot;Jack&quot;},   ...:     {&quot;id&quot;: 1, &quot;name&quot;: &quot;Eddie&quot;},   ...:     {&quot;id&quot;: 3, &quot;name&quot;: &quot;Bob&quot;},   ...:     {&quot;id&quot;: 4, &quot;name&quot;: &quot;Maichael&quot;},   ...:     {&quot;id&quot;: 1, &quot;name&quot;: &quot;Edward&quot;},   ...: ]   ...: expect = ( &quot;{1: [{'id': 1, 'name': 'John'}, &quot;   ...:                 &quot;{'id': 1, 'name': 'Eddie'}, &quot;   ...:                 &quot;{'id': 1, 'name': 'Edward'}], &quot;   ...:             &quot;2: [{'id': 2, 'name': 'Paul'}], &quot;   ...:             &quot;3: [{'id': 3, 'name': 'David'}, &quot;   ...:                 &quot;{'id': 3, 'name': 'Jack'}, &quot;   ...:                 &quot;{'id': 3, 'name': 'Bob'}], &quot;   ...:             &quot;4: [{'id': 4, 'name': 'Freddie'}, &quot;   ...:                 &quot;{'id': 4, 'name': 'Maichael'}]}&quot; )   ...: result = d_groupby(data, &quot;id&quot;)   ...: assert result.__repr__() == expect```### invert() and d_invert()```pythondef invert( self,        obj: Optional[dict]=None,        flat: bool=False,        inplace: bool=False,        factory: Optional[Type[dict]]=None,    ) -&gt;dict:``````pythondef d_invert(        obj: dict,        flat: bool=False,        inplace: bool=False,        factory: Type[dict]=dict,    ) -&gt;dict:```Return an inverted dict where values become keys and keys become values.Since multiple keys could have the same value, each value will be a list of keys.If pass `flat=True` each value will be a single value.(use this only if values are unique).```pythonIn [1]: from datajuggler import aDict   ...: from datajuggler.dicthelper import d_invert   ...:   ...:   ...: data = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4, &quot;e&quot;: 5}   ...: expect = {1: ['a'], 2: ['b'], 3: ['c'], 4: ['d'], 5: ['e']}   ...: result = d_invert(data)   ...: assert result == expectIn [2]: data = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4, &quot;e&quot;: 5}   ...: expect = {1: ['a'], 2: ['b'], 3: ['c'], 4: ['d'], 5: ['e']}   ...: d_invert(data, inplace=True)   ...: assert data == expectIn [3]: data = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4, &quot;e&quot;: 5}   ...: expect = aDict({1: ['a'], 2: ['b'], 3: ['c'], 4: ['d'], 5: ['e']})   ...: result = d_invert(data, factory=aDict)   ...: assert result == expectIn [4]: data = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4, &quot;e&quot;: 5}   ...: expect = { 1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;, 4: &quot;d&quot;, 5: &quot;e&quot;}   ...: result = d_invert(data, flat=True)   ...: assert result == expectIn [5]: data = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4, &quot;e&quot;: 5}   ...: expect = { 1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;, 4: &quot;d&quot;, 5: &quot;e&quot;}   ...: d_invert(data, flat=True, inplace=True)   ...: assert data == expectIn [6]: data = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4, &quot;e&quot;: 5}   ...: expect = aDict({ 1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;, 4: &quot;d&quot;, 5: &quot;e&quot;})   ...: result = d_invert(data, flat=True, factory=aDict)   ...: assert result == expectIn [7]:```### map() and d_map()```pythondef map(self,        func: Callable,        obj: Optional[dict]=None,        map_for: Optional[DictItemType]=None,        inplace: bool=False,        factory: Optional[Type[dict]]=None,    ) -&gt;dict:``````pythondef d_map(        func: Callable,        obj: dict,        map_for: Optional[DictItemType]=None,        inplace: bool=False,        factory: Type[dict]=dict,    ) -&gt;dict:```Create a new dictionary with apply function to keys/value of dictionary.if pass `map_for=None`  apply function to key and value. (default)if pass `map_for=&quot;key&quot;`  apply function to key.if pass `map_for=&quot;value&quot;`  apply function to value.If set `factory`, create instance of factory class.If set `True` to `inplace`, perform operation in-place.```pythonIn [1]: from datajuggler import uDict,  aDict   ...: from datajuggler.dicthelper import d_map   ...:   ...:   ...: data = { 'January': 1, 'February': 2, 'March': 3, 'April': 4 }   ...: expect = { 1: 'January', 2: 'February', 3: 'March', 4: 'April' }   ...: result = d_map(reversed, data)   ...: assert result == expectIn [2]: expect = uDict({ 1: 'January', 2: 'February', 3: 'March', 4: 'April' })   ...: result = d_map(reversed, data, factory=uDict)   ...: assert result == expect   ...:In [3]: expect = { 1: 'January', 2: 'February', 3: 'March', 4: 'April' }   ...: result = d_map(reversed, data, inplace=True)   ...: assert data == expectIn [4]: data = { 'January': 1, 'February': 2, 'March': 3, 'April': 4 }   ...: expect = uDict({ 'JANUARY': 1, 'FEBRUARY': 2, 'MARCH': 3, 'APRIL': 4 })   ...: result = d_map(str.upper, data, map_for=&quot;key&quot;)   ...: assert result == expectIn [5]: data = { 'Jack': [10, 11, 12], 'John': [8, 15, 3] }   ...: expect = { 'Jack': 33, 'John': 26 }   ...: result = d_map(sum, data, map_for=&quot;value&quot;)   ...: assert result == expectIn [6]:```### merge() and d_merger()```pythondef merge(self,        others: list,        obj: Optional[dict]=None,        overwrite: bool=True,        concat: bool=False,        inplace: bool=False,        factory: Optional[Type[dict]]=None,    ) -&gt;dict:``````pythondef d_merge(        obj: dict,        others: Union[dict, list, tuple],        overwrite: bool=True,        concat: bool=False,        inplace: bool=False,        factory: Type[dict]=dict,    ) -&gt;dict:```Merge one or more dictionary objects into obj.Sub-dictionaries keys will be merged toghether.If pass `overwrite=False`, existing values will not be overwritten.If pass `concat=True`, list values will be concatenated toghether.If set `factory`, create instance of factory class.If set `True` to `inplace`, perform operation in-place.```pythonIn [1]: from datajuggler import aDict   ...: from datajuggler.dicthelper import d_merge   ...:   ...:   ...: d1 = { &quot;a&quot;: 1, &quot;b&quot;: 1, }   ...: d2 = { &quot;b&quot;: 2, &quot;c&quot;: 3, }   ...: expect = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, }   ...: d_merge(d1, d2)Out[1]: {'a': 1, 'b': 2, 'c': 3}In [2]: d_merge(d1, d2, factory=aDict)Out[2]: aDict({'a': 1, 'b': 2, 'c': 3})In [3]: d_merge(d1, d2, inplace=True)In [4]: d1Out[4]: {'a': 1, 'b': 2, 'c': 3}In [5]: d1 = {   ...:     &quot;a&quot;: [0, 1, 2],   ...:     &quot;b&quot;: [5, 6, 7],   ...:     &quot;c&quot;: [],   ...:     &quot;d&quot;: [],   ...: }   ...: d2 = {   ...:     &quot;a&quot;: [3, 4, 5],   ...:     &quot;b&quot;: [8, 9, 0],   ...:     &quot;c&quot;: [-1],   ...: }   ...: expect = {   ...:     &quot;a&quot;: [3, 4, 5],   ...:     &quot;b&quot;: [8, 9, 0],   ...:     &quot;c&quot;: [-1],   ...:     &quot;d&quot;: [],   ...: }In [6]: d_merge(d1, d2)Out[6]: {'a': [3, 4, 5], 'b': [8, 9, 0], 'c': [-1], 'd': []}In [7]: d_merge(d1, d2, concat=True)Out[7]: {'a': [0, 1, 2, 3, 4, 5], 'b': [5, 6, 7, 8, 9, 0], 'c': [-1], 'd': []}In [8]: d1 = { &quot;a&quot;: 1, &quot;b&quot;: 1, }   ...: d2 = { &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 3, }   ...: d3 = { &quot;d&quot;: 5, &quot;e&quot;: 5, }   ...: d4 = { &quot;d&quot;: 4, &quot;f&quot;: 6, }In [9]: d_merge(d1, [d2, d3, d4])Out[9]: {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}In [10]: d_merge(d1, (d2, d3, d4))Out[10]: {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}In [11]: d1 = {    ...:     &quot;a&quot;: 1,    ...:     &quot;b&quot;: {    ...:         &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, },    ...:         &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, },    ...:         &quot;e&quot;: { &quot;x&quot;: 6, &quot;y&quot;: 7, },    ...:     },    ...: }    ...: d2 = {    ...:     &quot;a&quot;: 0,    ...:     &quot;b&quot;: {    ...:         &quot;c&quot;: 1,    ...:         &quot;d&quot;: { &quot;y&quot;: 1, &quot;z&quot;: 2, },    ...:         &quot;e&quot;: {    ...:             &quot;f&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, },    ...:             &quot;g&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, },    ...:         },    ...:     },    ...: }In [12]: d_merge(d1, d2)Out[12]:{'a': 0, 'b': {'c': 1,  'd': {'x': 4, 'y': 1, 'z': 2},  'e': {'x': 6, 'y': 7, 'f': {'x': 2, 'y': 3}, 'g': {'x': 4, 'y': 5}}}}In [13]:  d_merge(d1, d2, overwrite=False)Out[13]:{'a': 1, 'b': {'c': 1,  'd': {'x': 4, 'y': 1, 'z': 2},  'e': {'x': 6, 'y': 7, 'f': {'x': 2, 'y': 3}, 'g': {'x': 4, 'y': 5}}}}In [14]:```### move() and d_move()```pythondef move(self,        key_src: Union[str, list],        key_dest: Union[str, list],        obj: Optional[dict]=None,        *,        keep_order: bool=False,        overwrite: bool=True,        inplace: bool=False,        factory: Optional[Type[dict]]=None,    ) -&gt;dict:``````pythondef d_move(        obj: dict,        key_src: Union[str, list, dict],        key_dest: Optional[Union[str, list]]=None,        *,        overwrite: bool=True,        keep_order: bool=False,        inplace: bool=False,        factory: Type[dict]=dict,    ) -&gt;dict:```Create new dictionary which Move an item from key_src to key_dst.It can be used to rename a key.If key_dst exists and pass `overwrite=True`, its value will be overwritten.if pass `keep_order=True`, keep ordered of dictionary. (may be slow).If set `factory`, create instance of factory class.If set `True` to `inplace`, perform operation in-place.```pythonIn [1]: from datajuggler import aDict   ...: from datajuggler.dicthelper import d_move   ...:   ...: data = {   ...:     &quot;a&quot;: { &quot;x&quot;: 1, &quot;y&quot;: 1, },   ...:     &quot;b&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 2, },   ...:     &quot;c&quot;: { &quot;x&quot;: 3, &quot;y&quot;: 3, },   ...: }In [2]: d_move(data, &quot;a&quot;, &quot;a&quot;)Out[2]: {'a': {'x': 1, 'y': 1}, 'b': {'x': 2, 'y': 2}, 'c': {'x': 3, 'y': 3}}In [3]: d_move(data, &quot;a&quot;, &quot;d&quot;)Out[3]: {'b': {'x': 2, 'y': 2}, 'c': {'x': 3, 'y': 3}, 'd': {'x': 1, 'y': 1}}In [4]: d_move(data, &quot;a&quot;, &quot;d&quot;, overwrite=False)Out[4]: {'b': {'x': 2, 'y': 2}, 'c': {'x': 3, 'y': 3}, 'd': {'x': 1, 'y': 1}}In [5]: d_move(data, &quot;a&quot;, &quot;d&quot;, keep_order=True)Out[5]: {'d': {'x': 1, 'y': 1}, 'b': {'x': 2, 'y': 2}, 'c': {'x': 3, 'y': 3}}In [6]: d_move(data, &quot;a&quot;, &quot;d&quot;, factory=aDict)Out[6]: aDict({'b': {'x': 2, 'y': 2}, 'c': {'x': 3, 'y': 3}, 'd': {'x': 1, 'y': 1}})In [7]: d_move(data, &quot;a&quot;, &quot;d&quot;, inplace=True)In [8]: dataOut[8]: {'b': {'x': 2, 'y': 2}, 'c': {'x': 3, 'y': 3}, 'd': {'x': 1, 'y': 1}}In [9]:```### rename() and d_rename()```pythondef rename(self,        key: Union[Hashable,dict],        key_new: Optional[Hashable]=None,        obj: Optional[dict]=None,        case_name: Optional[str]=None,        *,        overwrite: bool=False,        keep_order: bool=False,        inplace: bool=False,        factory: Optional[Type[dict]]=None,    ) -&gt;dict:``````pythondef d_rename(        obj: dict,        key: Union[Hashable,dict, list],        key_new: Optional[Hashable]=None,        case_name: Optional[str]=None,        *,        overwrite: bool=False,        keep_order: bool=False,        inplace: bool=False,        factory: Type[dict]=dict,    ) -&gt;dict:```Create the new dictionary which is chnaged the key to key_new.if key as dictionary {key: key_new}, change key using mapping dictionary.If key_dst exists and pass `overwrite=True`, its value will be overwritten.if pass `keep_order=True`, keep ordered of dictionary. (may be slow).If set `factory`, create instance of factory class.If set `True` to `inplace`, perform operation in-place.```pythonIn [1]: from datajuggler import  aDict   ...: from datajuggler.dicthelper import d_rename   ...:   ...: data = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: None, }In [2]: d_rename(data, &quot;a&quot;, &quot;a&quot;)Out[2]: {'a': 1, 'b': 2, 'c': 3, 'd': None}In [3]: d_rename(data, &quot;a&quot;, &quot;A&quot;)Out[3]: {'b': 2, 'c': 3, 'd': None, 'A': 1}In [4]: d_rename(data, &quot;a&quot;, &quot;A&quot;, keep_order=True)Out[4]: {'A': 1, 'b': 2, 'c': 3, 'd': None}In [5]: try:   ...:     result = d_rename(data, &quot;a&quot;, &quot;b&quot;)   ...: except KeyError as e:   ...:     print(e)   ...:&quot;Invalid key: 'b', key already in dict and 'overwrite' is disabled.&quot;In [6]: d_rename(data, &quot;a&quot;, &quot;b&quot;, overwrite=True)Out[6]: {'b': 1, 'c': 3, 'd': None}In [7]: d_rename(data, {'a': 'A', 'b': 'B'})Out[7]: {'c': 3, 'd': None, 'A': 1, 'B': 2}In [8]: d_rename(data, &quot;b&quot;, &quot;B&quot;, inplace=True)In [9]: dataOut[9]: {'a': 1, 'c': 3, 'd': None, 'B': 2}In [10]: data = { &quot;First Name&quot;: 'jack', 'Last Name': 'bauwer' }In [11]: d_rename(data, &quot;First Name&quot;, case_name='snake')Out[11]: {'Last Name': 'bauwer', 'first_name': 'jack'}In [12]: keys = list(data.keys())    ...: d_rename(data, keys, case_name='snake')Out[12]: {'first_name': 'jack', 'last_name': 'bauwer'}In [13]: d_rename(data, keys, case_name='camel')Out[13]: {'firstName': 'jack', 'lastName': 'bauwer'}In [14]:```### remove() and d_remove()```pythondef remove(self,        keys: Union[list, Hashable],        obj: Optional[dict]=None,        *,        inplace: bool=False,        factory: Optional[Type[dict]]=None,    ):``````pythondef d_remove(        obj: dict,        keys: Union[list, tuple, Hashable],        *,        inplace: bool=False,        factory: Type[dict]=dict,    ):```Create new dictionary which Remove multiple keys from the dict.It is possible to pass a single key or more keys (as list or *args).```pythonIn [1]: from datajuggler import aDict   ...: from datajuggler.dicthelper import d_remove   ...:   ...: data = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4, &quot;e&quot;: 5, }In [2]: d_remove(data, &quot;c&quot;)Out[2]: {'a': 1, 'b': 2, 'd': 4, 'e': 5}In [3]: d_remove(data, [&quot;c&quot;, &quot;d&quot;, &quot;e&quot;])Out[3]: {'a': 1, 'b': 2}In [4]: d_remove(data, (&quot;c&quot;, &quot;d&quot;, &quot;e&quot;))Out[4]: {'a': 1, 'b': 2}In [5]: d_remove(data, &quot;c&quot;, factory=aDict)Out[5]: aDict({'a': 1, 'b': 2, 'd': 4, 'e': 5})In [6]: d_remove(data, &quot;c&quot;, inplace=True)In [7]: dataOut[7]: {'a': 1, 'b': 2, 'd': 4, 'e': 5}In [8]:```### nest() and d_nest()```pythondef d_nest(    items: tuple,    id_key: Union[str, list],    parent_id_key: Union[str, list],    children_key: Union[str, list],    ) -&gt; list:```Nest a list of dicts at the given key and return a new nested listusing the specified keys to establish the correct items hierarchy.```pythonIn [1]: from datajuggler.dicthelper import d_nest   ...:   ...: data = [   ...:     {&quot;id&quot;: 1, &quot;parent_id&quot;: None, &quot;name&quot;: &quot;John&quot;},   ...:     {&quot;id&quot;: 2, &quot;parent_id&quot;: 1, &quot;name&quot;: &quot;Frank&quot;},   ...:     {&quot;id&quot;: 3, &quot;parent_id&quot;: 2, &quot;name&quot;: &quot;Tony&quot;},   ...:     {&quot;id&quot;: 4, &quot;parent_id&quot;: 3, &quot;name&quot;: &quot;Jimmy&quot;},   ...:     {&quot;id&quot;: 5, &quot;parent_id&quot;: 1, &quot;name&quot;: &quot;Sam&quot;},   ...:     {&quot;id&quot;: 6, &quot;parent_id&quot;: 3, &quot;name&quot;: &quot;Charles&quot;},   ...:     {&quot;id&quot;: 7, &quot;parent_id&quot;: 2, &quot;name&quot;: &quot;Bob&quot;},   ...:     {&quot;id&quot;: 8, &quot;parent_id&quot;: 3, &quot;name&quot;: &quot;Paul&quot;},   ...:     {&quot;id&quot;: 9, &quot;parent_id&quot;: None, &quot;name&quot;: &quot;Michael&quot;},   ...: ]In [2]: d_nest(data, &quot;id&quot;, &quot;parent_id&quot;, &quot;children&quot;)Out[2]:[{'id': 1,  'parent_id': None,  'name': 'John',  'children': [{'id': 2,    'parent_id': 1,    'name': 'Frank',    'children': [{'id': 3,      'parent_id': 2,      'name': 'Tony',      'children': [{'id': 4, 'parent_id': 3, 'name': 'Jimmy', 'children': []},       {'id': 6, 'parent_id': 3, 'name': 'Charles', 'children': []},       {'id': 8, 'parent_id': 3, 'name': 'Paul', 'children': []}]},     {'id': 7, 'parent_id': 2, 'name': 'Bob', 'children': []}]},   {'id': 5, 'parent_id': 1, 'name': 'Sam', 'children': []}]}, {'id': 9, 'parent_id': None, 'name': 'Michael', 'children': []}]In [3]: try:   ...:     result = d_nest(data, &quot;id&quot;, &quot;id&quot;, &quot;children&quot;)   ...: except ValueError as e:   ...:     print(e)   ...:keys should be different.In [4]: try:   ...:     result = d_nest(data, &quot;id&quot;, &quot;parent_id&quot;, &quot;id&quot;)   ...: except ValueError as e:   ...:     print(e)   ...:keys should be different.In [5]: try:   ...:     d_nest(data, &quot;id&quot;, &quot;parent_id&quot;, &quot;parent_id&quot;)   ...: except ValueError as e:   ...:     print(e)   ...:keys should be different.In [6]: data = [   ...:     [{&quot;id&quot;: 1, &quot;parent_id&quot;: None, &quot;name&quot;: &quot;John&quot;}],   ...:     [{&quot;id&quot;: 2, &quot;parent_id&quot;: 1, &quot;name&quot;: &quot;Frank&quot;}],   ...: ]In [7]: try:   ...:     d_nest(data, &quot;id&quot;, &quot;parent_id&quot;, &quot;children&quot;)   ...: except ValueError as e:   ...:     print(e)   ...:element should be a dict.In [8]:```### subset() and d_subset()```pythondef d_subset(        obj: dict,        keys: Union[str, list, tuple, Hashable],        *,        default: Optional[Any]=None,        use_keypath: bool=False,        separator: str=Default_Keypath_Separator,        inplace: bool=False,        factory: Type[dict]=dict,    ):```Return a dict subset for the given keys.It is possible to pass a single key or more keys (as list or *args).```pythonIn [1]: from datajuggler import aDict   ...: from datajuggler.dicthelper import d_subset   ...:   ...:   ...: data = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4, &quot;e&quot;: 5}In [2]: d_subset(data, 'b')Out[2]: {'b': 2}In [3]: d_subset(data, ['b', 'd'])Out[3]: {'b': 2, 'd': 4}In [4]: d_subset(data, ('b', 'd'))Out[4]: {'b': 2, 'd': 4}In [5]: d_subset(data, ('b', 'd'), factory=aDict)Out[5]: aDict({'b': 2, 'd': 4})In [6]: d_subset(data, ('b', 'd'), inplace=True)In [7]: dataOut[7]: {'b': 2, 'd': 4}In [8]: data = { &quot;a&quot;: 1,   ...:          &quot;b&quot;: { &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3 },   ...:                 &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5 },   ...:          },   ...: }In [9]: d_subset(data, keys='z', default={})Out[9]: {'z': {}}In [10]: try:    ...:     d_subset(data, keys='x', default={})    ...: except KeyError as e:    ...:     print(e)    ...:&quot;Multiple keys founded.'x'&quot;In [11]: d_subset(data, keys='x', default={}, use_keypath=True)Out[11]: {'b.c.x': 2, 'b.d.x': 4}In [12]: d_subset(data, keys='c')Out[12]: {'c': {'x': 2, 'y': 3}}In [13]: d_subset(data, keys=['c', 'd'])Out[13]: {'c': {'x': 2, 'y': 3}, 'd': {'x': 4, 'y': 5}}In [14]: d_subset(data, keys=['c', 'd'], use_keypath=True)Out[14]: {'b.c': {'x': 2, 'y': 3}, 'b.d': {'x': 4, 'y': 5}}In [15]: d_subset(data, keys=['c', 'd'],use_keypath=True, separator=' ')Out[15]: {'b c': {'x': 2, 'y': 3}, 'b d': {'x': 4, 'y': 5}}In [16]:```### find() and d_find()```pythondef d_find(        obj: dict,        keys: Union[list,Hashable],        default: Optional[Any]=None,        first_one: bool=True,        factory: Type[dict]=dict,    ) -&gt; Union[Any, dict]:```Return the match searching for the given keys.if pass `first_one=True`, return first matches.If no result found, default value is returned.```pythonIn [1]: from datajuggler.dicthelper import d_find   ...:   ...: data = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: None, }In [2]: d_find(data, &quot;b&quot;, 0)Out[2]: 2In [3]: d_find(data, &quot;e&quot;, 0)Out[3]: 0In [4]: d_find(data, [&quot;x&quot;, &quot;y&quot;, &quot;b&quot;, &quot;z&quot;], 5)Out[4]: 2In [5]: d_find(data, [&quot;a&quot;, &quot;x&quot;, &quot;b&quot;, &quot;y&quot;], 5)Out[5]: 1In [6]: d_find(data, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], 5)Out[6]: 5In [7]: d_find(data, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], &quot;missing&quot;)Out[7]: 'missing'In [8]: d_find(data, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])In [9]: d_find(data, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], first_one=True)Out[9]: 1In [10]: d_find(data, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], first_one=False)Out[10]: {'a': 1, 'b': 2, 'c': 3}In [11]:```### sort() and d_sort()```pythondef d_sort(        obj: dict,        sort_by: DictItemType=DictItem.KEY,        reverse: bool=False,        inplace: bool=False,        factory: Type[dict]=dict,    ):```Create new dictiionary which is sorted by keys/values.`sort_by` accept &quot;key&quot; and &quot;value&quot;. default is  &quot;key&quot;.If pass `reverse=True`,  the list will be reversed.If set `factory`, create instance of factory class.If set `True` to `inplace`, perform operation in-place.```pythonIn [1]: from datajuggler import aDict   ...: from datajuggler.dicthelper import d_sort   ...:   ...: data = {   ...:     &quot;a&quot;: 8,   ...:     &quot;c&quot;: 6,   ...:     &quot;e&quot;: 4,   ...:     &quot;g&quot;: 2,   ...:     &quot;b&quot;: 7,   ...:     &quot;d&quot;: 5,   ...:     &quot;f&quot;: 3,   ...:     &quot;h&quot;: 1,   ...: }In [2]: d_sort(data)Out[2]: {'h': 1, 'g': 2, 'f': 3, 'e': 4, 'd': 5, 'c': 6, 'b': 7, 'a': 8}In [3]: d_sort(data, reverse=True)Out[3]: {'a': 8, 'b': 7, 'c': 6, 'd': 5, 'e': 4, 'f': 3, 'g': 2, 'h': 1}In [4]: d_sort(data, sort_by=&quot;value&quot;)Out[4]: {'a': 8, 'b': 7, 'c': 6, 'd': 5, 'e': 4, 'f': 3, 'g': 2, 'h': 1}In [5]: d_sort(data, factory=aDict)Out[5]: aDict({'h': 1, 'g': 2, 'f': 3, 'e': 4, 'd': 5, 'c': 6, 'b': 7, 'a': 8})In [6]: d_sort(data, inplace=True)In [7]: dataOut[7]: {'h': 1, 'g': 2, 'f': 3, 'e': 4, 'd': 5, 'c': 6, 'b': 7, 'a': 8}In [8]:```### search() and d_search()```pythondef d_search(        obj: dict,        query: Pattern,        search_for: DictItemType=DictItem.KEY,        exact: bool=False,        ignore_case: bool=False,        use_keypath: bool=True,    ):```Search and return a list of items matching the given query.```pythonIn [1]: from datajuggler.dicthelper import d_search   ...:   ...: data =  {   ...:     &quot;a&quot;: &quot;January&quot;,   ...:     &quot;b&quot;: &quot;january!&quot;,   ...:     &quot;c&quot;: {   ...:         &quot;d&quot;: True,   ...:         &quot;e&quot;: &quot; january february &quot;,   ...:         &quot;f&quot;: {   ...:             &quot;g&quot;: ['January', 'February', 'March', 'April' ],   ...:             &quot;january&quot;: 12345,   ...:             &quot;February&quot;: True,   ...:         },   ...:     },   ...:     &quot;x&quot;: &quot;Peter Piper picked a peck of pickled peppers.&quot;,   ...:     &quot;y&quot;: { &quot;x&quot;: { &quot;y&quot;: 5, &quot;z&quot;: 6, }, },   ...:     &quot;January February&quot;: &quot;march&quot;,   ...: }In [2]: d_search(data, &quot;jarnuary&quot;, search_for=&quot;value&quot;)Out[2]: {}In [3]: d_search(data, &quot;january&quot;, search_for=&quot;value&quot;, ignore_case=True)Out[3]: {'a': 'January', 'b': 'january!', 'c.f.g.0': 'January'}In [4]: d_search(data, &quot;january&quot;, search_for=&quot;value&quot;, exact=True)Out[4]: {}In [5]: d_search(data, &quot;january&quot;, search_for=&quot;value&quot;, ignore_case=True)Out[5]:{Keypath(&quot;a&quot;): 'January', Keypath(&quot;b&quot;): 'january!', Keypath(&quot;c.f.g[0]&quot;): 'January'}In [6]: d_search(data, &quot;january&quot;, search_for=&quot;value&quot;,   ...:          ignore_case=True, use_keypath=False)Out[6]: {'a': 'January', 'b': 'january!', 'c.f.g[0]': 'January'}In [7]:```### swap() and d_swap()```pythondef d_swap(        obj: dict,        key1: Hashable,        key2: Hashable,        inplace: bool=False,        factory: Type[dict]=dict,    ) -&gt;Optional[dict]:```Swap items values at the given keys.```pythonIn [1]: from datajuggler import aDict   ...: from datajuggler.dicthelper import d_swap   ...:   ...: data = { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: None, }In [2]: d_swap(data, &quot;a&quot;, &quot;b&quot;)Out[2]: {'a': 2, 'b': 1, 'c': 3, 'd': None}In [3]: d_swap(data, &quot;a&quot;, &quot;a&quot;)Out[3]: {'a': 1, 'b': 2, 'c': 3, 'd': None}In [4]: d_swap(data, &quot;a&quot;, &quot;b&quot;, factory=aDict)Out[4]: aDict({'a': 2, 'b': 1, 'c': 3, 'd': None})In [5]: d_swap(data, &quot;a&quot;, &quot;b&quot;, inplace=True)In [6]: dataOut[6]: {'a': 2, 'b': 1, 'c': 3, 'd': None}In [7]:```### flatten() and d_flatten()```pythondef d_flatten(        obj: dict,        separator: str=Default_Keypath_Separator,        inplace: bool=False,        factory: Type[dict]=dict,    ) -&gt; dict:```Return a new flattened dict using the given separator to join nested```pythonIn [1]: from datajuggler import aDict   ...: from datajuggler.dicthelper import d_flatten, d_unflatten   ...:   ...: data = { &quot;a&quot;: 1,   ...:          &quot;b&quot;: 2,   ...:          &quot;c&quot;: {   ...:             &quot;d&quot;: {   ...:                 &quot;e&quot;: 3,   ...:                 &quot;f&quot;: 4,   ...:                  &quot;g&quot;: { &quot;h&quot;: 5, },   ...:             }   ...:          },   ...:       }In [2]: d_flatten(data)Out[2]: {'a': 1, 'b': 2, 'c.d.e': 3, 'c.d.f': 4, 'c.d.g.h': 5}In [3]: d_flatten(data, separator=&quot;_&quot;)Out[3]: {'a': 1, 'b': 2, 'c_d_e': 3, 'c_d_f': 4, 'c_d_g_h': 5}In [4]: d_flatten(data, factory=aDict)Out[4]: aDict({'a': 1, 'b': 2, 'c.d.e': 3, 'c.d.f': 4, 'c.d.g.h': 5})In [5]: d_flatten(data, inplace=True)In [6]: dataOut[6]: {'a': 1, 'b': 2, 'c.d.e': 3, 'c.d.f': 4, 'c.d.g.h': 5}In [7]:```### unflatten() and d_unflatten()```pythondef d_unflatten(        obj: dict,        default: Optional[Any]=None,        separator: str=Default_Keypath_Separator,        inplace: bool=False,        factory: Type[dict]=dict,    ) -&gt; dict:```Return a new unflattened dict using the given separator to join nested dict keys to flatten keypaths.```pythonIn [1]: from datajuggler import aDict   ...: from datajuggler.dicthelper import d_flatten, d_unflatten   ...:   ...: data = {   ...:     &quot;a&quot;: 1,   ...:     &quot;b&quot;: 2,   ...:     &quot;c.d.e&quot;: 3,   ...:     &quot;c.d.f&quot;: 4,   ...:     &quot;c.d.g.h&quot;: 5,   ...: }In [2]: d_unflatten(data)Out[2]: {'a': 1, 'b': 2, 'c': {'d': {'e': 3, 'f': 4, 'g': {'h': 5}}}}In [3]: data = {   ...:     &quot;a&quot;: 1,   ...:     &quot;b&quot;: 2,   ...:     &quot;c_d_e&quot;: 3,   ...:     &quot;c_d_f&quot;: 4,   ...:     &quot;c_d_g_h&quot;: 5,   ...: }In [4]: d_unflatten(data, separator=&quot;_&quot;)Out[4]: {'a': 1, 'b': 2, 'c': {'d': {'e': 3, 'f': 4, 'g': {'h': 5}}}}In [5]: d_unflatten(data, separator=&quot;_&quot;, inplace=True)In [6]: dataOut[6]: {'a': 1, 'b': 2, 'c': {'d': {'e': 3, 'f': 4, 'g': {'h': 5}}}}In [7]:```### traverse() and d_traverse()```pythonef d_traverse(        obj: Union[dict, list, tuple],        callback: Callable,        parents: list=[],        *args: Any,        **kwargs: Any,    ):```Traverse dict or list and apply callback function.callback function will be called as follows.  - `callback(obj, key, value, *args, parents=parents, **kwargs)`  - `callback(obj, index, value, *args, parents=parents, **kwargs)``parantes` can pass to Keylist().  - Keylist(parents)````pythonIn [1]: from datajuggler.dicthelper import d_traverse   ...:   ...:   ...: data = { &quot;a&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, &quot;z&quot;: { &quot;ok&quot;: 5, }, },   ...:          &quot;b&quot;: { &quot;x&quot;: 7, &quot;y&quot;: 11, &quot;z&quot;: { &quot;ok&quot;: 13, }, },   ...:          &quot;c&quot;: { &quot;x&quot;: 17, &quot;y&quot;: 19, &quot;z&quot;: { &quot;ok&quot;: 23, }, },   ...:        }In [2]: def func(obj, key, val, *args, **kwargs):   ...:     if not isinstance(val, dict):   ...:         obj[key] = val + 1   ...:   ...: d_traverse(data, func)In [3]: dataOut[3]:{'a': {'x': 3, 'y': 4, 'z': {'ok': 6}}, 'b': {'x': 8, 'y': 12, 'z': {'ok': 14}}, 'c': {'x': 18, 'y': 20, 'z': {'ok': 24}}}In [4]: from datajuggler import Keylists   ...: paths=[]   ...: def func(obj, key, val, *args, parents, **kwargs):   ...:     global paths   ...:     if not isinstance(val, dict):   ...:         obj[key] = val + 1   ...:         paths.append(Keylist(parents).to_keypath())   ...:   ...: d_traverse(data, func)In [5]: dataOut[5]:{'a': {'x': 4, 'y': 5, 'z': {'ok': 7}}, 'b': {'x': 9, 'y': 13, 'z': {'ok': 15}}, 'c': {'x': 19, 'y': 21, 'z': {'ok': 25}}}In [6]: data = [ 100, [200, [300, 310], 210], 110]   ...:   ...: def func(obj, index, val, *args, parents, **kwargs):   ...:     if not isinstance(val, list):   ...:         obj[index] = val + 1000   ...:   ...: d_traverse(data, func)In [7]: dataOut[7]: [1100, [1200, [1300, 1310], 1210], 1110]In [8]: paths = []   ...: def func(obj, index, val, parents, *args, **kwargs):   ...:     global paths   ...:     index_paths = [ str(x) for x in parents ]   ...:     paths.append( ' '.join(index_paths))   ...:   ...: d_traverse(data, func)In [9]: dataOut[9]: [1100, [1200, [1300, 1310], 1210], 1110]In [10]: data = [ 100, [200, [300, 310], 210], 110]In [11]: paths = []    ...: def func(obj, index, val, parents, *args, **kwargs):    ...:     global paths    ...:     index_paths = [ str(x) for x in parents ]    ...:     paths.append( ' '.join(index_paths))    ...:    ...: d_traverse(data, func)In [12]: dataOut[12]: [100, [200, [300, 310], 210], 110]In [13]: data = { &quot;a&quot;: { &quot;x&quot;: [ 100, 200], &quot;y&quot;: 3, &quot;z&quot;: { &quot;ok&quot;: 5, }, },    ...:          &quot;b&quot;: { &quot;x&quot;: [ 110, 210], &quot;y&quot;: 11, &quot;z&quot;: { &quot;ok&quot;: 13, }, },    ...:          &quot;c&quot;: { &quot;x&quot;: [ 120, 220], &quot;y&quot;: 19, &quot;z&quot;: { &quot;ok&quot;: 13, }, },    ...:        }    ...:    ...: paths = []    ...: def func(obj, key, val, parents, *args, **kwargs):    ...:     global paths    ...:     if not isinstance(val, dict) and not isinstance(val, list):    ...:         obj[key] = val + 1    ...:    ...: d_traverse(data, func)In [14]: dataOut[14]:{'a': {'x': [101, 201], 'y': 4, 'z': {'ok': 6}}, 'b': {'x': [111, 211], 'y': 12, 'z': {'ok': 14}}, 'c': {'x': [121, 221], 'y': 20, 'z': {'ok': 14}}}In [15]: aths = []    ...: def func(obj, key, val, parents, *args, **kwargs):    ...:     global paths    ...:     if not isinstance(val, dict) and  not isinstance(val, list):    ...:         obj[key] = val + 1    ...:         index_paths = [ str(x) for x in parents ]    ...:         paths.append( ' '.join(index_paths))    ...:    ...: d_traverse(data, func)In [16]: dataOut[16]:{'a': {'x': [102, 202], 'y': 5, 'z': {'ok': 7}}, 'b': {'x': [112, 212], 'y': 13, 'z': {'ok': 15}}, 'c': {'x': [122, 222], 'y': 21, 'z': {'ok': 15}}}In [17]:```### unique() and d_unique()```pythondef d_unique(        obj: dict,    ) -&gt; list:```Return unique values from dict.```pythonIn [1]: from datajuggler.dicthelper import  d_unique   ...:   ...: data = { &quot;a&quot;: { &quot;x&quot;: 1, &quot;y&quot;: 1, },   ...:          &quot;b&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 2, },   ...:          &quot;c&quot;: { &quot;x&quot;: 1, &quot;y&quot;: 1, },   ...:          &quot;d&quot;: { &quot;x&quot;: 1, },   ...:          &quot;e&quot;: { &quot;x&quot;: 1, &quot;y&quot;: 1, &quot;z&quot;: 1, },   ...:          &quot;f&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 2, },   ...: }In [2]: d_unique(data)Out[2]: [{'x': 1, 'y': 1}, {'x': 2, 'y': 2}, {'x': 1}, {'x': 1, 'y': 1, 'z': 1}]In [3]:```### get_keys()```pythondef get_keys(        obj: Optional[dict]=None,        indexes: bool=False,        *,        output_as: Optional[DictKey]=None,        separator: str=Default_Keypath_Separator,    ) -&gt; list:```Get all keys from dictionary as a ListThis function is able to process on nested dictionary.`output_as` accept &quot;keylist&quot; and &quot;keypath&quot;.```pythonIn [1]: from datajuggler.dicthelper import get_keysIn [2]: data = { &quot;a&quot;: 1,   ...:                  &quot;b&quot;: { &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, },   ...:                         &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, },   ...:                       },   ...:                 }In [3]: get_keys(data)Out[3]: ['a', 'b', 'c', 'x', 'y', 'd', 'x', 'y']In [4]: get_keys(data, output_as=&quot;keylist&quot;)Out[4]:[['a'], ['b'], ['b', 'c'], ['b', 'c', 'x'], ['b', 'c', 'y'], ['b', 'd'], ['b', 'd', 'x'], ['b', 'd', 'y']]In [5]: get_keys(data, output_as=&quot;keypath&quot;)Out[5]: ['a', 'b', 'b.c', 'b.c.x', 'b.c.y', 'b.d', 'b.d.x', 'b.d.y']In [6]: get_keys(data, output_as=&quot;keypath&quot;, separator='_')Out[6]: ['a', 'b', 'b_c', 'b_c_x', 'b_c_y', 'b_d', 'b_d_x', 'b_d_y']In [7]:```### get_values()```pythondef get_values(        obj: Union[dict, Sequence],        keys: Union[Hashable, Keylist, Keypath],    ) -&gt; Any:```Get the value of key in the objet(s).`obj` : dict, dict[dict], dict[list], list[dict]return value, list, dict.```pythonIn [1]: from datajuggler import uDict, Keypath, Keylist   ...: from datajuggler.dicthelper import get_valuesIn [2]: data = { &quot;a&quot;: 1,   ...:          &quot;b&quot;: { &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, },   ...:                 &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, },   ...:                 &quot;e&quot;: [ { &quot;x&quot;: 1, &quot;y&quot;: -1, &quot;z&quot;: [1, 2, 3], },   ...:                        { &quot;x&quot;: 2, &quot;y&quot;: -2, &quot;z&quot;: [2, 3, 4], },   ...:                        { &quot;x&quot;: 3, &quot;y&quot;: -3, &quot;z&quot;: [3, 4, 5], },   ...:                      ],   ...:               },   ...:       }   ...:In [3]: get_values(data, 'a')Out[3]: 1In [4]: get_values(data, ('b', 'c'))Out[4]: {'x': 2, 'y': 3}In [5]: get_values(data, Keylist(['b', 'c']))Out[5]: {'x': 2, 'y': 3}In [6]: get_values(data, Keylist(['b', 'e[1]', 'z[2]']))Out[6]: 4In [7]: get_values(data, Keypath('b.c'))Out[7]: {'x': 2, 'y': 3}In [8]: get_values(data, Keypath('b.e[1].z[2]'))Out[8]: 4In [9]: d = uDict(data)In [10]: d['a']Out[10]: 1In [11]: d[('b', 'c')]Out[11]: uDict({'x': 2, 'y': 3})In [12]: d[Keylist(['b', 'c'])]Out[12]: uDict({'x': 2, 'y': 3})In [13]: d[Keylist(['b', 'e[1]', 'z[2]'])]Out[13]: 4In [14]: d[Keypath('b.c')]Out[14]: uDict({'x': 2, 'y': 3})In [15]: d[Keypath('b.e[1].z[2]')]Out[15]: 4In [16]:```### keylists()```pythondef keylists(        obj: Any,        indexes: bool=False,    ) -&gt; list:```keylist is the list of key as keys from dict/list.this function is just calling Keylist.keylists()### keypaths()```pythondef keypaths(        obj: dict,        indexes: bool=False,        separator: str=Default_Keypath_Separator,    ) -&gt; str:```Keypath is the string for  attribute-sytle access to value.(dot-notation by default).this function is just calling Keypath.keypaths()### get_items()```pythondef get_items(        obj: dict,        loc: Hashable,        value: Any,        func: Optional[Callable]=None,        *,        separator: str=Default_Keypath_Separator,        factory: Type[dict]=dict,    ):```Create new dictionary with new key value pair as d[key]=val.If set `True` to `inplace`, perform operation in-place.otherwise, not modify the initial dictionary.```pythonIn [1]: from datajuggler import uDict, Keypath, Keylist   ...: from datajuggler.dicthelper import get_itemsIn [2]: get_items({}, 'a', 1)Out[2]: {'a': 1}In [3]: data = { 'a': 1, 'b': 2}   ...: get_items(data, 'a', 3)Out[3]: {'a': 3, 'b': 2}In [4]: data = { 'a': 1, 'b': [{'c': 11, 'd': 12 },   ...:                        {'c': 22, 'd': 22 }] }   ...:   ...: get_items(data, 'b', 2)Out[4]: {'a': 1, 'b': 2}In [5]: data = { 'a': 1, 'b': [{'c': 11, 'd': 12 },   ...:                        {'c': 22, 'd': 22 }] }   ...:   ...: get_items(data, 'c', 4)Out[5]: {'a': 1, 'b': [{'c': 11, 'd': 12}, {'c': 22, 'd': 22}], 'c': 4}In [6]: data = { 'a': 1, 'b': [{'c': 11, 'd': 12 },   ...:                        {'c': 22, 'd': 22 }] }   ...:   ...: get_items(data, ('b','c'), 4)Out[6]: {'a': 1, 'b': {'c': 4}}In [7]: data = { 'a': 1, 'b': [{'c': 11, 'd': 12 },   ...:                        {'c': 22, 'd': 22 }] }   ...:   ...: get_items(data, Keylist('b','c'), 4)Out[7]: {'a': 1, 'b': 4}In [8]: data = { 'a': 1, 'b': [{'c': 11, 'd': 12 },   ...:                        {'c': 22, 'd': 22 }] }   ...:   ...: get_items(data, Keypath('b.c'), 4)Out[8]: {'a': 1, 'b': {'c': 4}}In [9]: d = uDict(data)In [10]: dOut[10]: uDict({'a': 1, 'b': [{'c': 11, 'd': 12}, {'c': 22, 'd': 22}]})In [11]: d.get_items('a', 3)Out[11]: uDict({'a': 3, 'b': [{'c': 11, 'd': 12}, {'c': 22, 'd': 22}]})In [12]: d.get_items('c', 4)Out[12]: uDict({'a': 1, 'b': [{'c': 11, 'd': 12}, {'c': 22, 'd': 22}], 'c': 4})In [13]: d.get_items('b', 2)Out[13]: uDict({'a': 1, 'b': 2})In [14]: d.get_items(('b','c'), 4)Out[14]: uDict({'a': 1, 'b': uDict({'c': 4})})In [15]: d.get_items(Keylist('b','c'), 4)Out[15]: uDict({'a': 1, 'b': 4})In [16]: d.get_items(Keypath('b.c'), 4)Out[16]: uDict({'a': 1, 'b': uDict({'c': 4})})In [17]:```###  pop_items()```pythonef pop_items(        obj: dict,        loc: Hashable,        value: Optional[Any]=None,        func: Optional[Callable]=None,        *,        separator: str=Default_Keypath_Separator,        factory: Type[dict]=dict,    ):```Create new dictionary with new key value pair as d[key]=val.If set `True` to `inplace`, perform operation in-place.otherwise, not modify the initial dictionary.### del_items()```pythondef del_items(        obj: dict,        loc: Union[Hashable, list, tuple],        *.        separator: str=Default_Keypath_Separator,        inplace: bool=False,        factory: Type[dict]=dict,    ):```Create new dicttionary with the given key(s) removed.New dictionary has d[key] deleted for each supplied key.If set `True` to `inplace`, perform operation in-place.otherwise, not modify the initial dictionary.### set_items()```pythondef set_items(        obj: Union[dict, Sequence],        loc: Union[str, Sequence],        value: Any,        func: Optional[Callable]=None,        separator: str=Default_Keypath_Separator,        factory: Type[dict]=dict,    ):```Create new dict with new, potentially nested, key value pair.## class iList`iList` class support immutable and hashable for list. - `freeze()` change status of object in frozen. - `unfreeze()` unfreeze for object.if call `freeze()`, following method will raise AttiributeError. - `__hash__()` - `__radd__()` - `__rand__()` - `__ior__()` - `__isub__()` - `__setitem__()` - `__reversed__()` - `append()` - `reverse()` - `clear()` - `expand()` - `pop()` - `remove()` - `sort()`and add new helper mehtods. - `copy(freeze: bool=False)` - `clone(empty: bool=False)` - `find(val)` - `without(items)` - `replace(old, new)`### copy()```python    def copy(self, freeze: bool=False):```Creaate the new list that is copied this list.this method could not copy self.attrs..if pass `freeze=True`, return frozen list object.```pythonIn [1]: from datajuggler import iListIn [2]: l1 = iList([1,2,3])   ...: l1.Hello = 'Python'   ...: l2 = l1.copy()   ...: assert l2 == l1In [3]: l2.get_attrs()Out[3]: {}In [4]: l1 = iList([1])   ...: l2 = l1.copy(freeze=True)   ...: hash(l2)Out[4]: -4714387948668998104In [5]:```### clone()```python    def clone(self, empty: bool=False):```Creaate the new list that is cloned this list.this method copy self.attrs.if pass `empty=True`, keep self.attrs but list will be cleared.```pythonIn [5]: l1 = iList([1,2,3])   ...: l1.Hello = 'Python'   ...: l2 = l1.clone()   ...: assert l2 == l1In [6]: l2.get_attrs()Out[6]: {'Hello': 'Python'}In [7]: l3 = l1.clone(empty=True)In [8]: l3Out[8]: iList([])In [9]: l3.get_attrs()Out[9]: {'Hello': 'Python'}In [10]:```### without()```python   def without(self, *items):```Create new list without items and return iterable.```pythonIn [13]: l1 = iList([1,2,3,4,5,6,7,8,9])In [14]: l1.without([2,4,6,8])Out[14]: [1, 3, 5, 7, 9]In [15]: l1Out[15]: iList([1, 2, 3, 4, 5, 6, 7, 8, 9])In [16]:```### find()```python    def find(self,            val: Union[Any, list, tuple],        ) -&gt; list:```Return the list of index that found val in list.otherwise return None```pythonIn [2]: l1 = iList([1,2,3,4,5,6,7,8,9])In [3]: l1.find(2)Out[3]: [1]In [4]: l1.find([2,4,6,8])Out[4]: [1, 3, 5, 7]In [5]:```### replace()```python    def replace(self,            old: Any,            new: Any,            func: Optional[Callable]=None,        ) -&gt;list:```Return a new list that has new instead of old.if old is not found, it will raise an ItemNotFountError.callback function will be called as follows. - `func(index, old, new)````pythonIn [1]: from datajuggler import iListIn [2]: l1 = iList([1,2,3,1,2,3])In [3]: l1.replace(3, 5)Out[3]: [1, 2, 5, 1, 2, 5]In [4]: def func(index, old, new):   ...:     if index &gt; 3:   ...:         return new   ...:     else:   ...:         return old   ...:In [5]: l1 = iList([1,2,3,1,2,3])In [6]: l1.replace(3, 5, func)Out[6]: [1, 2, 3, 1, 2, 5]In [7]:```## class TypeValidatorTypeValidator class has following classmethods.using TypeValidator not necessary including typing module. - `is_bool(cls, obj: Any)` - `is_collection(cls, obj: Any)` - `is_callable(cls, obj: Any)` - `is_datetime(cls, obj: Any)` - `is_decimal(cls, obj: Any)` - `is_dict(cls, obj: Any)` - `is_dict_or_other(cls, obj: Any, other: Any)` - `is_dict_and_not_other(cls, obj: Any, other: Any)` - `is_dict_keys(cls, obj: Any)` - `is_dict_values(cls, obj: Any)` - `is_dict_items(cls, obj: Any)` - `is_dict_or_list(cls, obj: Any)` - `is_dict_or_list_or_tuple(cls, obj: Any)` - `is_float(cls, obj: Any)` - `is_function(cls, obj: Any)` - `is_hashable(cls, obj: Any)` - `is_integer(cls, obj: Any)` - `is_integer_or_float(cls, obj: Any)` - `is_iterable(cls, obj: Any)` - `is_json_serializable(cls, obj: Any)` - `is_keylist(cls, obj: Any)` - `is_keypath(cls, obj: Any)` - `is_keylist_or_keypath(cls, obj: Any)` - `is_list(cls, obj: Any)` - `is_list_not_empty(cls, obj: Any)` - `is_list_or_tuple(cls, obj: Any)` - `is_list_of_keylists(cls, obj: Any)` - `is_list_of_keypaths(cls, obj: Any)` - `is_mapping(cls, obj: Any)` - `is_match(cls, obj: Any)` - `is_none(cls, obj: Any)` - `is_not_none(cls, obj: Any)` - `is_pattern(cls, obj: Any)` - `is_regex(cls, obj: Any)` - `is_same_as(cls, obj: Any, other: Any)` - `is_sequence(cls, obj: Any)` - `is_set(cls, obj: Any)` - `is_set_not_empty(cls, obj: Any)` - `is_str(cls, obj: Any)` - `is_str_not_empty(cls, obj: Any)` - `is_tuple(cls, obj: Any)` - `is_tuple_not_empty(cls, obj: Any)` - `is_uuid(cls, obj: Any)` - `is_str_alnum(cls, obj: Any)` - `is_str_alpha(cls, obj: Any)` - `is_str_financial_number(cls, obj: Any)` - `is_str_emoji(cls, obj: Any)` - `is_truthy(cls, value: Any) - `is_bytes(cls, obj: Any)` - `is_bytes_not_empty(cls, obj: Any)` - `is_made_by_pydantic(cls, obj: Any)` - `is_made_by_dataclass(cls, obj: Any)` - `is_made_by_namedtuple(cls, obj: Any)` - `is_made_by_typing_namedtuple(cls, obj: Any)` - `is_made_by_collections_namedtuple(cls, obj: Any)`Using TypeValidator class no need to include typing module compare with objects.i.e.:```pythonIn [1]: from datajuggler.validator import TypeValidator as _typeIn [2]: data = { &quot;a&quot;: 1,   ...:                  &quot;b&quot;: { &quot;c&quot;: { &quot;x&quot;: 2, &quot;y&quot;: 3, },   ...:                         &quot;d&quot;: { &quot;x&quot;: 4, &quot;y&quot;: 5, },   ...:                       },   ...:                 }In [3]: keys = data.keys()In [4]: keysOut[4]: dict_keys(['a', 'b'])In [5]: _type.is_dict_keys(keys)Out[5]: TrueIn [6]:```## class ValueValidator - `is_md5(cls, value: Any): - `is_sha1(cls, value: Any): - `is_sha224(cls, value: Any): - `is_sha256(cls, value: Any): - `is_sha512(cls, value: Any): - `is_financial_number(cls, value: Any): - `is_valid_checkdigit(cls, value: Any, num_digits=None, weights=None): - `is_uuid(cls, value: Any): - `is_truthy(cls, value: Any) - `is_length(cls, value: Any, min=None, max=None, thrown_error=False) - `is_between(cls, value: Any, min=None, max=None, thrown_error=False)```pythonIn [1]: from datajuggler.validator import ValueValidator as _valueIn [2]: import hashlibIn [3]: data = 'datajuggler'In [4]: hash_str = hashlib.md5(data.encode()).hexdigest()   ...: assert _value.is_md5(hash_str) == True   ...: assert _value.is_md5(data) == FalseIn [5]: hash_str = hashlib.sha1(data.encode()).hexdigest()   ...: assert _value.is_sha1(hash_str) == True   ...: assert _value.is_sha1(data) == FalseIn [6]: hash_str = hashlib.sha224(data.encode()).hexdigest()   ...: assert _value.is_sha224(hash_str) == True   ...: assert _value.is_sha224(data) == FalseIn [7]: hash_str = hashlib.sha256(data.encode()).hexdigest()   ...: assert _value.is_sha256(hash_str) == True   ...: assert _value.is_sha256(data) == FalseIn [8]: hash_str = hashlib.sha512(data.encode()).hexdigest()   ...: assert _value.is_sha512(hash_str) == True   ...: assert _value.is_sha512(data) == FalseIn [9]: assert _value.is_between(10, 2, 10) == True   ...: assert _value.is_between(10, 2, 20) == True   ...: assert _value.is_between(10, None, 20) == True   ...: assert _value.is_between(10, None, None) == False   ...: assert _value.is_between(10, 1, None) == True   ...: assert _value.is_between(10, -1, None) == True   ...: assert _value.is_between(10, 10, None) == TrueIn [10]: data = 'datajuggler'    ...: assert _value.is_length(data, 2, 10) == False    ...: assert _value.is_length(data, 2, 11) == True    ...: assert _value.is_length(data, None, 11) == True    ...: assert _value.is_length(data, None, None) == False    ...: assert _value.is_length(data, 1, None) == True    ...: assert _value.is_length(data, -1, None) == False    ...: assert _value.is_length(data, 11, None) == True    ...:In [11]: data = list([1,2,3,4,5,6,7,8,9,10,11])    ...: assert _value.is_length(data, 2, 10) == False    ...: assert _value.is_length(data, 2, 11) == True    ...: assert _value.is_length(data, None, 11) == True    ...: assert _value.is_length(data, None, None) == False    ...: assert _value.is_length(data, 1, None) == True    ...: assert _value.is_length(data, -1, None) == False    ...: assert _value.is_length(data, 11, None) == TrueIn [12]: data = range(11)    ...: assert _value.is_length(data, 2, 10) == False    ...: assert _value.is_length(data, 2, 11) == True    ...: assert _value.is_length(data, None, 11) == True    ...: assert _value.is_length(data, None, None) == False    ...: assert _value.is_length(data, 1, None) == True    ...: assert _value.is_length(data, -1, None) == False    ...: assert _value.is_length(data, 11, None) == TrueIn [13]: import uuis    ...: data = uuid.uuid4()    ...: assert _value.is_uuid(data) == True    ...: assert _value.is_uuid('datajuggler') == FalseIn [14]: assert _value.is_financial_number('1') == True    ...: assert _value.is_financial_number('12') == True    ...: assert _value.is_financial_number('123') == True    ...: assert _value.is_financial_number('1,234') == True    ...: assert _value.is_financial_number('-1,234') == True    ...: assert _value.is_financial_number('-1234') == True    ...: assert _value.is_financial_number('0.12') == True    ...: assert _value.is_financial_number('.12') == True    ...: assert _value.is_financial_number('12.') == TrueIn [15]: assert _value.is_valid_checkdigit(261009) == True   ...: assert _value.is_valid_checkdigit(261008) == False   ...: assert _value.is_valid_checkdigit(26100, 5) == True   ...: assert _value.is_valid_checkdigit(1100, 5) == TrueIn [16]: assert _value.is_valid_checkdigit('261009') == True   ...: assert _value.is_valid_checkdigit('261008') == False   ...: assert _value.is_valid_checkdigit('26100', 5) == True   ...: assert _value.is_valid_checkdigit('1100', 5) == TrueIn [17]: assert _value.is_valid_checkdigit(261009,   ...:                           weights=[6,5,4,3,2]) == True   ...: assert _value.is_valid_checkdigit('261009',   ...:                           weights=[6,5,4,3,2]) == TrueIn [18]:```## class StrCase`strCase` class support convert case. - `convert_case(case)` - `show_supported_case()````pythonIn [1]: from datajuggler import StrCaseIn [2]: c = StrCase('The sky is the limits')In [3]: c.show_supported_case()Out[4]:{'case': 'sample', 'snake': 'convert_case', 'kebab': 'convert-case', 'camel': 'convertCase', 'pascal': 'ConvertCase', 'const': 'CONVERT_CASE', 'sentence': 'Convert case', 'title': 'Convert Case', 'lower': 'convert case', 'upper': 'CONVERT CASE'}In [4]: c.convert_case('snake')Out[4]: 'the_sky_is_the_limits'In [5]: c.convert_case('camel')Out[5]: 'theSkyIsTheLimits'````StrCase` class accept str, list, dict objects for inputs.```pythonIn [8]: data = &quot;The sky is the limit&quot;   ...: expect = 'the-sky-is-the-limit'   ...: s = StrCase(data)   ...: assert s.convert_case('kebab') == expectIn [9]: data = &quot;The sky is the limit&quot;   ...: expect = 'theSkyIsTheLimit'   ...: s = StrCase(data)   ...: assert s.convert_case(case='camel') == expectIn [10]: data = [&quot;Good luck&quot;, &quot;The sky is the limit&quot; ]    ...: expect = [&quot;good_luck&quot;, &quot;the_sky_is_the_limit&quot;]    ...: s = StrCase(data)    ...: assert s.convert_case() == expectIn [11]: data = {1: &quot;Good luck&quot;, 2: &quot;The sky is the limit&quot; }    ...: expect = {1: &quot;good_luck&quot;, 2: &quot;the_sky_is_the_limit&quot; }    ...: s = StrCase(data)    ...: assert s.convert_case() == expectIn [12]: data = {&quot;Good luck&quot;: 1, &quot;The sky is the limit&quot;: 2 }    ...: expect = {&quot;good_luck&quot;: 1, &quot;the_sky_is_the_limit&quot;: 2 }    ...: s = StrCase(data)    ...: assert s.convert_case(replace_for='key') == expectIn [13]:````StrCase` class support nested objects.```pythonIn [13]: data = [&quot;Good luck&quot;, &quot;The sky is the limit&quot;,    ...:         {1: &quot;Good luck&quot;, 2: &quot;The sky is the limit&quot; } ]    ...: expect = [&quot;good_luck&quot;, &quot;the_sky_is_the_limit&quot;,    ...:         {1: &quot;good_luck&quot;, 2: &quot;the_sky_is_the_limit&quot; } ]    ...: s = StrCase(data)    ...: assert s.convert_case() == expectIn [14]:```### split_chunks()Return split into even chunk_size elements.```pythonIn [1]: from datajuggler import split_chunks   ...:   ...: data = [11,12,13,14, 21,22,23, 31,32,33]   ...: expect = [[11,12,13, 14], [21,22,23,31], [32,33, None, None ]]   ...: result = list(split_chunks(data,4))   ...: assert result == expectIn [2]: data = [11,12,13,14, 21,22,23, 31,32,33]   ...: expect = [[11,12,13, 14], [21,22,23,31], [32,33] ]   ...: result = list(split_chunks(data,4, fill_na=False))   ...: assert result == expectIn [3]: data = [11,12,13,14, 21,22,23,31,32,33]   ...: expect = [[11,12,13, 14], [21,22,23,31], [32,33, -1, -1] ]   ...: result = list(split_chunks(data,4, na_value=-1))   ...: assert result == expectIn [4]:```if pass tuple as input. return list of tuple for chunk data.```pythonIn [4]: data = (11,12,13,21,22,23,31,32,33)   ...: expect = [(11,12,13), (21,22,23), (31,32,33)]   ...: result = list(split_chunks(data,3))   ...: assert result == expectIn [5]:```if pass dict objects as input. return list of dict for chunk data.`fill_na` and `na_value` is always ignored.```pythonIn [5]: data = { 'January': 1, 'February': 2, 'March': 3, 'April': 4 }   ...: expect = [{ 'January': 1, 'February': 2, 'March': 3},   ...:           { 'April': 4 } ]   ...: result = list(split_chunks(data,3))   ...: assert result == expectIn [6]: data = { 'January': 1, 'February': 2, 'March': 3, 'April': 4 }   ...: expect = [{ 'January': 1, 'February': 2, 'March': 3},   ...:           { 'April': 4 } ]   ...: result = list(split_chunks(data,3, fill_na=True))   ...: assert result == expectIn [7]: data = { 'January': 1, 'February': 2, 'March': 3, 'April': 4 }   ...: expect = [{ 'January': 1, 'February': 2, 'March': 3},   ...:           { 'April': 4 } ]   ...: result = list(split_chunks(data,3, na_value=None))In [8]:```if pass str objects as input. return list of str for chunk data.`fill_na` and `na_value` is always ignored.```pythonIn [8]: data = &quot;Peter Piper picked a peck of pickled peppers.&quot;   ...: expect = [ &quot;Peter Piper picked a&quot;,   ...:            &quot; peck of pickled pep&quot;,   ...:            &quot;pers.&quot; ]   ...: result = list(split_chunks(data,20))   ...: assert result == expectIn [9]: data = &quot;Peter Piper picked a peck of pickled peppers.&quot;   ...: expect = [ &quot;Peter Piper picked a&quot;,   ...:            &quot; peck of pickled pep&quot;,   ...:            &quot;pers.&quot; ]   ...: result = list(split_chunks(data,20, fill_na=True, na_value=None))   ...: assert result == expectIn [10]:```### urange()`urange()` is almost same as `range()````In [1]: from datajuggler import urange   ...:   ...: expect = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]   ...: result = list(urange(10))   ...: assert result == expectIn [2]: expect = [1, 2, 3, 4, 5, 6, 7, 8, 9]   ...: result = list(urange(1, 10))   ...: assert result == expectIn [3]: expect = [1, 3, 5, 7, 9]   ...: result = list(urange(1, 10, 2))   ...: assert result == expectIn [4]: expect = [10, 8, 6, 4, 2]   ...: result = list(urange(10, 1, -2))   ...: assert result == expectIn [5]: expect = [10, 9, 8, 7, 6, 5, 4, 3, 2]   ...: result = list(urange(10, 1))   ...: assert result == expectIn [6]:````urange()` support callable as step.```pythonIn [6]: def  gen_step(val):   ...:     return (val * 3)   ...:   ...: expect = [1, 4, 16]   ...: result = list(urange(1, 20, gen_step))   ...: assert result == expectIn [7]:```### rename_duplicate()Rename duplicate string for list or values of dict.```pythonIn [1]: from datajuggler import rename_duplicates   ...:   ...: data = [&quot;Apple&quot;, &quot;Apple&quot;, &quot;Banana&quot;, &quot;Maple&quot; ]   ...: expect = [&quot;Apple&quot;, &quot;Apple_01&quot;, &quot;Banana&quot;, &quot;Maple&quot; ]   ...: result = rename_duplicates(data)   ...: assert result == expectIn [2]: data = [&quot;Apple&quot;, &quot;Apple&quot;, &quot;Banana&quot;, &quot;Maple&quot; ]   ...: expect = [&quot;Apple&quot;, &quot;Apple__01&quot;, &quot;Banana&quot;, &quot;Maple&quot; ]   ...: result = rename_duplicates(data, separator='__')   ...: assert result == expectIn [3]: data = [&quot;Apple&quot;, &quot;Apple&quot;, &quot;Banana&quot;, &quot;Maple&quot; ]   ...: expect = [&quot;Apple&quot;, &quot;Apple_001&quot;, &quot;Banana&quot;, &quot;Maple&quot; ]   ...: result = rename_duplicates(data, format=&quot;{:03}&quot;)   ...: assert result == expectIn [4]: data = [&quot;Apple&quot;, [&quot;Apple&quot;, &quot;Apple&quot;, &quot;Banana&quot;, &quot;Maple&quot; ]]   ...: expect = [&quot;Apple&quot;, [&quot;Apple&quot;, &quot;Apple_01&quot;, &quot;Banana&quot;, &quot;Maple&quot; ]]   ...: result = rename_duplicates(data)   ...: assert result == expectIn [5]:```### df_compare()```pythonIn [1]: from datajuggler import df_compare   ...:   ...: d1 = pd.DataFrame([ ['Kyoto', 35.0117,135.452],   ...:                     ['Osaka', 34.4138,135.3808]],   ...:                   columns=['cityName', 'latitude', 'longitude'])   ...: d2 = pd.DataFrame([ ['Kyoto', 35.0117,135.452],   ...:                     ['Osaka', 34.4138,135.3808]],   ...:                   columns=['cityName', 'latitude', 'longitude'])   ...: assert ( df_compare(d1, d2) == 0 )In [2]: d1 = pd.DataFrame([ ['26100', 35.0117,135.452],   ...:                     ['27100', 34.4138,135.3808]],   ...:                   columns=['cityCode', 'latitude', 'longitude'])   ...: d2 = pd.DataFrame([ ['Kyoto', 35.0117,135.452],   ...:                     ['Osaka', 34.4138,135.3808]],   ...:                   columns=['cityName', 'latitude', 'longitude'])   ...: assert ( df_compare(d1, d2) != 0 )In [3]:```### omit_values()Omit values from objects.```pythonIn [1]: from datajuggler import omit_values   ...:   ...: data = ['January', 'February', 'March', 'April' ]   ...: omits = ['February', 'April']   ...: expect = ['January', '', 'March', '' ]   ...: result = omit_values(data, omits)   ...: assert result == expectIn [2]: data = ['January', 'February', 'March', 'April' ]   ...: omits = ['february', 'april']   ...: expect = ['January', '', 'March', '' ]   ...: result = omit_values(data, omits, ignore_case=True)   ...: assert result == expectIn [3]: data = ['January', 'February', 'March', 'April' ]   ...: omits = ['February', 'April']   ...: expect = ['January', 'March' ]   ...: result = omit_values(data, omits, drop=True)   ...: assert result == expectIn [4]: data = &quot;JanuaryFebruaryMarchApril&quot;   ...: omits = ['February', 'April']   ...: expect = &quot;JanuaryMarch&quot;   ...: result = omit_values(data, omits)   ...: assert result == expectIn [5]:```### replace_values()Replace values for objects.mutltidispatch functions as follows. - replace_values( data: str, old, new, ignore_case) - replace_values( values: list, replace: dict, *,        ignore_case: bool=False, inplace: bool=False, **kwargs: Any ) - replace_values( values: dict, replace: dict, *,        ignore_case: bool=False, inplace: bool=False,        replace_for: ReplaceForType = ReplaceFor.VALUE )    ReplaceFor.KEY and ReplaceFor.VALUE are defined 'key' and 'value'. - replace_values( values: list, replace_from: list, replace_to: str, *,        ignore_case: bool=False, inplace: bool=False, **kwargs: Any) - replace_values( values: str, replace_from: list, replace_to: Hashable, *,        ignore_case: bool=False, **kwargs: Any) - replace_values( values: str, replace: dict, *,        ignore_case: bool=False, **kwargs: Any)```pythonIn [1]: from datajuggler import replace_values   ...:   ...: data = &quot;JanuaryFebruaryMarchApril&quot;   ...: old = [ 'March', 'April' ]   ...: replace_to = &quot;&quot;   ...: expect = &quot;JanuaryFebruary&quot;   ...: result = replace_values( data, old, replace_to )   ...: assert result == expectIn [2]: data = &quot;JanuaryFebruaryMarchApril&quot;   ...: replace = { 'March': '3', 'April': '4' }   ...: expect = &quot;JanuaryFebruary34&quot;   ...: result = replace_values( data, replace )   ...: assert result == expect   ...:In [3]: data = &quot;JanuaryFebruaryMarchApril&quot;   ...: replace = { 'March': 3, 'April': 4 }   ...: expect = &quot;JanuaryFebruary34&quot;   ...: result = replace_values( data, replace )   ...: assert result == expectIn [4]: data = ['January', 'February', 'March', 'April' ]   ...: replace = { 'March': '3', 'April': '4' }   ...: expect = ['January', 'February', '3', '4' ]   ...: result = replace_values( data, replace )   ...: assert result == expectIn [5]: def convert_func(matchobj):   ...:     map = {'January': '1',   ...:            'February': '2' }   ...:     return map[matchobj.group(0)]   ...:   ...: data = ['January', 'February', 'March', 'April',   ...:         'May', 'June', 'July', 'August',   ...:         'September', 'October', 'November', 'December']   ...:   ...: replace = { '.*ary': convert_func, '.*ber': 'BER' }   ...:   ...: expect = ['1', '2', 'March', 'April',   ...:         'May', 'June', 'July', 'August',   ...:         'BER', 'BER', 'BER', 'BER']   ...: result = replace_values( data, replace)   ...: assert result == expectIn [6]: data = ['January', 'February', 'March', 'April']   ...: replace = {'march': '3', 'april': '4' }   ...:   ...: expect = ['January', 'February', '3', '4' ]   ...: result = replace_values( data, replace, ignore_case=True)   ...: assert result == expectIn [7]: data = ['January', 'February', 'March', 'April']   ...: replace = {'march': '3', 'april': '4' }   ...: expect = ['January', 'February', '3', '4' ]   ...: replace_values( data, replace, ignore_case=True, inplace=True)   ...: assert data == expectIn [8]: data = { 1: 'January', 2: 'February', 3: 'March', 4: 'April' }   ...: replace = { 'March': 3, 'April': 4 }   ...: expect = { 1: 'January', 2: 'February', 3: 3, 4: 4 }   ...: result = replace_values( data, replace )   ...: assert result == expectIn [9]: data = { 1: 'January', 2: 'February', 3: 'March', 4: 'April' }   ...: replace = { 'March': 3, 'April': 4 }   ...: expect = { 1: 'January', 2: 'February', 3: 3, 4: 4 }   ...: result = replace_values( data, replace, replace_for='value' )   ...: assert result == expectIn [10]: data = { 1: 'January', 2: 'February', 3: 'March', 4: 'April' }    ...: replace = { 'march': 3, 'april': 4 }    ...: expect = { 1: 'January', 2: 'February', 3: 3, 4: 4 }    ...: result = replace_values( data, replace, ignore_case=True )    ...: assert result == expectIn [11]: data = { 1: 'January', 2: 'February', 3: 'March', 4: 'April' }    ...: replace = { 'march': 3, 'april': 4 }    ...: expect = { 1: 'January', 2: 'February', 3: 3, 4: 4 }    ...: replace_values( data, replace, ignore_case=True, inplace=True )    ...: assert data == expectIn [12]: data = { 1: 'one', 2: 'two', 3: 'three', 4: 'four' }    ...: replace = {1: 'one',  2: 'two', 3: 'three'}    ...: expect = { 'one': 'one', 'two': 'two', 'three': 'three', 4: 'four' }    ...: result = replace_values( data, replace, replace_for='key')    ...: assert result == expectIn [13]: data = { 1: 'one', 2: 'two', 3: 'three', 4: 'four' }    ...: replace = {'one': 1, 'two': [2, 'two'], 'three': { 3: 'three'}}    ...: expect = { 1: 1, 2: [2, 'two'] , 3: {3: 'three'}, 4: 'four' }    ...: result = replace_values( data, replace )    ...: assert result == expectIn [14]:```## copy_docstring()Copying the docstring of function onto another function by nameThe following is an example of a method definition in uDict.```pythonfrom datajuggler.strings import copy_docstringfrom datajuggler import dicthelper as d# ...class uDic(IODict):    # ...    @copy_docstring(d.d_counts)    def counts(self,            pattern: Union[Pattern, Hashable, Sequence],            obj: Optional[dict]=None,            *,            count_for: DictItemType=DictItem.KEY,            wild: bool=False,            verbatim: bool=False,        ) -&gt;Union[int, dict]:        &quot;&quot;&quot;If obj is omitted, self is used.  &quot;&quot;&quot;        obj = obj if obj or obj == {} else self        return d.d_counts(obj, pattern, count_for=count_for,                        wild=wild, verbatim=verbatim)``````pythonIn [3]: from datajuggler import dicthelper as dIn [4]: print(d.d_counts.__doc__)Counts of keys or values       if pass `wild=True`, match substr and ignore_case.       if pass `verbatim=True`, counts as it is.In [5]: from datajuggler import uDictIn [6]: print(uDict.counts.__doc__)Counts of keys or values       if pass `wild=True`, match substr and ignore_case.       if pass `verbatim=True`, counts as it is.    If obj is omitted, self is used.In [7]```## KNOWN PROBLEMSdatajuggler is not support followings issues. - out-of-core processing. - multi-threaded data processing.If you are working with huge datasets, try using [datatable](https://github.com/h2oai/datatable).</longdescription>
</pkgmetadata>