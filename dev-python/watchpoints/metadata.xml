<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># watchpoints[![build](https://github.com/gaogaotiantian/watchpoints/workflows/build/badge.svg)](https://github.com/gaogaotiantian/watchpoints/actions?query=workflow%3Abuild)  [![coverage](https://img.shields.io/codecov/c/github/gaogaotiantian/watchpoints)](https://codecov.io/gh/gaogaotiantian/watchpoints)  [![pypi](https://img.shields.io/pypi/v/watchpoints.svg)](https://pypi.org/project/watchpoints/)  [![support-version](https://img.shields.io/pypi/pyversions/watchpoints)](https://img.shields.io/pypi/pyversions/watchpoints)  [![license](https://img.shields.io/github/license/gaogaotiantian/watchpoints)](https://github.com/gaogaotiantian/watchpoints/blob/master/LICENSE)  [![commit](https://img.shields.io/github/last-commit/gaogaotiantian/watchpoints)](https://github.com/gaogaotiantian/watchpoints/commits/master)watchpoints is an easy-to-use, intuitive variable/object monitor tool for python that behaves similar to watchpoints in gdb.## Install```pip install watchpoints```## Usage### watchSimply ```watch``` the variables you need to monitor!```pythonfrom watchpoints import watcha = 0watch(a)a = 1```will generate```====== Watchpoints Triggered ======Call Stack (most recent call last):  &lt;module&gt; (my_script.py:5):&gt;   a = 1a:0-&gt;1```It works on both variable change and object change```pythonfrom watchpoints import watcha = []watch(a)a.append(1)  # Triggera = {}  # Trigger```Even better, it can track the changes of the object after the changes of the variable```pythonfrom watchpoints import watcha = []watch(a)a = {}  # Triggera[&quot;a&quot;] = 2  # Trigger```Without doubts, it works whenever the object is changed, even if it's not in the same scope```pythonfrom watchpoints import watchdef func(var):    var[&quot;a&quot;] = 1a = {}watch(a)func(a)``````====== Watchpoints Triggered ======Call Stack (most recent call last):  &lt;module&gt; (my_script.py:8):&gt;   func(a)  func (my_script.py:4):&gt;   var[&quot;a&quot;] = 1a:{}-&gt;{'a': 1}```As you can imagine, you can monitor attributes of an object, or a specific element of a list or a dict```pythonfrom watchpoints import watchclass MyObj:    def __init__(self):        self.a = 0obj = MyObj()d = {&quot;a&quot;: 0}watch(obj.a, d[&quot;a&quot;])  # Yes you can do thisobj.a = 1  # Triggerd[&quot;a&quot;] = 1  # Trigger```Also, watchpoints supports native ```threading``` library for multi-threading. It will tell you which thread is changing thevalue as well.```====== Watchpoints Triggered ======---- Thread-1 ----Call Stack (most recent call last):  _bootstrap (/usr/lib/python3.8/threading.py:890):&gt;   self._bootstrap_inner()  _bootstrap_inner (/usr/lib/python3.8/threading.py:932):&gt;   self.run()  run (my_script.py:15):&gt;   a[0] = ia:[0]-&gt;[1]```**watchpoints will try to guess what you want to monitor, and monitor it as you expect**(well most of the time)### unwatchWhen you are done with the variable, you can unwatch it.```pythonfrom watchpoints import watch, unwatcha = 0watch(a)a = 1unwatch(a)a = 2  # nothing will happen```Or you can unwatch everything by passing no argument to it```pythonunwatch()  # unwatch everything```### print to different streamLike the ``print`` function, you can choose the output stream for watch print using ``file`` argument. The defaultvalue is ``sys.stderr``.```pythonf = open(&quot;watch.log&quot;, &quot;w&quot;)a = 0watch(a, file=f)a = 1f.close()```Be aware that **the stream needs to be available when the variable is changed**! So the following code **WON'T WORK**:```pythona = 0with open(&quot;watch.log&quot;, &quot;w&quot;) as f:    watch(a, file=f)a = 1```Or you could just give a filename to ``watch``. It will append to the file.```pythonwatch(a, file=&quot;watch.log&quot;)```Use config if you want to make it global```pythonwatch.config(file=&quot;watch.log&quot;)```### customize printerYou can use your own printer function to print the object, instead of the default ``objprint`` with ``custom_printer`````python# This will use built-in print function for the objectswatch(a, custom_printer=print)```Use config if you want to make it global```pythonwatch.config(custom_printer=print)```### aliasYou can give an alias to a monitored variable, so you can unwatch it anywhere. And the alias will be printed instead of the variable name```pythonfrom watchpoints import watch, unwatchwatch(a, alias=&quot;james&quot;)# Many other stuff, scope changesunwatch(&quot;james&quot;)```### conditional callbackYou can give an extra condition filter to do &quot;conditional watchpoints&quot;. Pass a function ```func(obj)``` which returns ```True```if you want to trigger the callback to ```when``` of ```watch``````pythona = 0watch(a, when=lambda x: x &gt; 0)a = -1  # Won't triggera = 1  # Trigger```### variable vs objectWhen you do ```watch()``` on an object, you are actually tracking both the object and the variable holding it. In most cases, that's whatyou want anyways. However, you can configure precisely which you want to track.```pythona = []watch(a, track=&quot;object&quot;)a.append(1)  # Triggera = {}  # Won't trigger because the list object does not changea = []watch(a, track=&quot;variable&quot;)a.append(1)  #  Won't trigger, because &quot;a&quot; still holds the same objecta = {}  # Trigger```### object compare and deepcopyNested object comparison is tricky. It's hard to find a solid standard to compare complicated customized objects.By default, watchpoints will do a shallow copy of the object. You can override this behavior by passing ```deepcopy=True``` to ```watch()``````pythonwatch(a, deepcopy=True)```watchpoints will honor ```__eq__``` method for user-defined classes first. If ```__eq__``` is not implemented, watchpoints will compare```__dict__```(basically attibures) of the object if using shallow copy, and raise an ```NotImplementedError``` if using deepcopy.The reason behind this is, if you deepcopied a complicated structure, there's no way for watchpoints to figure out if it's the same objectwithout user defined ```__eq__``` function.#### customize copy and compareFor your own data structures, you can provide a customized copy and/or customized compare function for watchpoints to better suit your need.watchpoints will use the copy function you provide to copy the object for reference, and use your compare function to check if thatobject is changed. If copy function or compare function is not provided, it falls to default as mentioned above.```cmp``` argument takes a function that will take two objects as arguments and return a ```boolean``` representing whether the objectsare **different**```pythondef my_cmp(obj1, obj2):    return obj1.id != obj2.idwatch(a, cmp=my_cmp)``````copy``` argument takes a function that will take a object and return a copy of it```pythondef my_copy(obj):    return MyObj(id=obj.id)watch(a, copy=my_copy)```### stack limitYou can specify the call stack limit printed using ```watch.config()```. The default value is ```5```, any positive integer is accepted.You can use ```None``` for unlimited call stack, which means it will prints out all the frames.```pythonwatch.config(stack_limit=10)```You can also set different stack limits for each monitored variable by passing ``stack_limit`` argument to ``watch`````python# This will only change stack_limit for awatch(a, stack_limit=10)```### customize callbackOf course sometimes you want to print in your own format, or even do something more than print. You can use your own callback for monitored variables```pythonwatch(a, callback=my_callback)```The callback function takes three arguments```pythondef my_callback(frame, elem, exec_info)```* ```frame``` is the current frame when a change is detected.* ```elem``` is a ```WatchElement``` object that I'm too lazy to describe for now.* ```exec_info``` is a tuple of ```(funcname, filename, lineno)``` of the line that changed the variableYou can also set change the callback function globally by```pythonwatch.config(callback=my_callback)```Use ```restore()``` to restore the default callback```pythonwatch.restore()```### Integrating with pdbwatchpoints can be used with pdb with ease. You can trigger pdb just like using ```breakpoint()``` whenyour monitored variable is changed. Simply do```pythonwatch.config(pdb=True)```When you are in pdb, use ```q(uit)``` command to exit pdb, and the next change on the variable will trigger the pdb again.### Avoid importSometimes it's a hassle having to import the function in every single file. You can install the watch function to builtinsand be able to call it in any files:```pythonwatch.install()  # or watch.install(&quot;func_name&quot;) and use it as func_name()# Remove it from the builtinswatch.uninstall()  # if installed with a name, pass it to uninstall() as well```## Limitations* watchpoints uses ```sys.settrace()``` so it is not compatible with other libraries that use the same function.* watchpoints will slow down your program significantly, like other debuggers, so use it for debugging purpose only* ```watch()``` needs to be used by itself, not nested in other functions, to be correctly parsed* at this point, there might be other issues because it's still in development phase## Bugs/RequestsPlease send bug reports and feature requests through [github issue tracker](https://github.com/gaogaotiantian/watchpoints/issues).## LicenseCopyright Tian Gao, 2020.Distributed under the terms of the  [Apache 2.0 license](https://github.com/gaogaotiantian/watchpoints/blob/master/LICENSE).</longdescription>
</pkgmetadata>