<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># objsize[![Coverage Status](https://coveralls.io/repos/github/liran-funaro/objsize/badge.svg?branch=master)](https://coveralls.io/github/liran-funaro/objsize?branch=master) [![Downloads](https://static.pepy.tech/badge/objsize)](https://pepy.tech/project/objsize)The `objsize` Python package allows for the exploration andmeasurement of an object’s complete memory usage in bytes, including itschild objects. This process, often referred to as deep size calculation,is achieved through Python’s internal Garbage Collection (GC) mechanism.The `objsize` package is designed to ignore shared objects, such as`None`, types, modules, classes, functions, and lambdas, because theyare shared across many instances. One of the key performance features of`objsize` is that it avoids recursive calls, ensuring a faster andsafer execution.## Key Features* Traverse objects’ subtree* Calculates the size of objects, including nested objects (deep size), in bytes* Exclude non-exclusive objects* Exclude specified objects subtree* Provides flexibility by allowing users to define custom handlers for:  - Object’s size calculation  - Object’s referents (i.e., its children)  - Object filter (skip specific objects)## Documentation| [`objsize`](https://liran-funaro.github.io/objsize/library/objsize.html#module-objsize)   | Traversal over Python's objects subtree and calculating the total size of the subtree (deep size).   ||-------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|# Install```bashpip install objsize==0.7.0```# Basic UsageCalculate the size of the object including all its members in bytes.```pycon&gt;&gt;&gt; import objsize&gt;&gt;&gt; objsize.get_deep_size(dict(arg1='hello', arg2='world'))340```It is possible to calculate the deep size of multiple objects by passingmultiple arguments:```pycon&gt;&gt;&gt; objsize.get_deep_size(['hello', 'world'], dict(arg1='hello', arg2='world'), {'hello', 'world'})628```# Complex Data`objsize` can calculate the size of an object’s entire subtree inbytes regardless of the type of objects in it, and its depth.Here is a complex data structure, for example, that include a selfreference:```pythonmy_data = list(range(3)), list(range(3, 6))class MyClass:    def __init__(self, x, y):        self.x = x        self.y = y        self.d = {'x': x, 'y': y, 'self': self}    def __repr__(self):        return f&quot;{self.__class__.__name__}()&quot;my_obj = MyClass(*my_data)```We can calculate `my_obj` deep size, including its stored data.```pycon&gt;&gt;&gt; objsize.get_deep_size(my_obj)724```We might want to ignore non-exclusive objects such as the ones stored in`my_data`.```pycon&gt;&gt;&gt; objsize.get_deep_size(my_obj, exclude=[my_data])384```Or simply let `objsize` detect that automatically:```pycon&gt;&gt;&gt; objsize.get_exclusive_deep_size(my_obj)384```# Non Shared Functions or Classes`objsize` filters functions, lambdas, and classes by default sincethey are usually shared among many objects. For example:```pycon&gt;&gt;&gt; method_dict = {&quot;identity&quot;: lambda x: x, &quot;double&quot;: lambda x: x*2}&gt;&gt;&gt; objsize.get_deep_size(method_dict)232```Some objects, however, as illustrated in the above example, have uniquefunctions not shared by other objects. Due to this, it may be useful tocount their sizes. You can achieve this by providing an alternativefilter function.```pycon&gt;&gt;&gt; objsize.get_deep_size(method_dict, filter_func=objsize.shared_object_filter)986```Notes:* The default filter function is  [`objsize.traverse.shared_object_or_function_filter()`](https://liran-funaro.github.io/objsize/library/objsize.traverse.html#objsize.traverse.shared_object_or_function_filter).* When using [`objsize.traverse.shared_object_filter()`](https://liran-funaro.github.io/objsize/library/objsize.traverse.html#objsize.traverse.shared_object_filter), shared functions and  lambdas are also counted, but builtin functions are still excluded.# Special CasesSome objects handle their data in a way that prevents Python’s GC fromdetecting it. The user can supply a special way to calculate the actualsize of these objects.## Case 1: [`torch`](https://pytorch.org/docs/stable/torch.html#module-torch)Using a simple calculation of the object size won’t work for[`torch.Tensor`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor).```pycon&gt;&gt;&gt; import torch&gt;&gt;&gt; objsize.get_deep_size(torch.rand(200))72```So the user can define its own size calculation handler for such cases:```pythonimport objsizeimport sysimport torchdef get_size_of_torch(o):    # `objsize.safe_is_instance` catches `ReferenceError` caused by `weakref` objects    if objsize.safe_is_instance(o, torch.Tensor):        return sys.getsizeof(o) + (o.element_size() * o.nelement())    else:        return sys.getsizeof(o)```Then use it as follows:```pycon&gt;&gt;&gt; objsize.get_deep_size(...   torch.rand(200),...   get_size_func=get_size_of_torch... )872```The above approach may neglect the object’s internal structure. The usercan help `objsize` to find the object’s hidden storage by supplying itwith its own referent and filter functions:```pythonimport objsizeimport gcimport torchdef get_referents_torch(*objs):    # Yield all native referents    yield from gc.get_referents(*objs)    for o in objs:        # If the object is a torch tensor, then also yield its storage        if type(o) == torch.Tensor:            yield o.untyped_storage()# `torch.dtype` is a common object like Python's types.MySharedObjects = (*objsize.SharedObjectOrFunctionType, torch.dtype)def filter_func(o):    return not objsize.safe_is_instance(o, MySharedObjects)```Then use these as follows:```pycon&gt;&gt;&gt; objsize.get_deep_size(...   torch.rand(200),...   get_referents_func=get_referents_torch,...   filter_func=filter_func... )928```## Case 2: [`weakref`](https://docs.python.org/3/library/weakref.html#module-weakref)Using a simple calculation of the object size won’t work for`weakref.proxy`.```pycon&gt;&gt;&gt; from collections import UserList&gt;&gt;&gt; o = UserList([0]*100)&gt;&gt;&gt; objsize.get_deep_size(o)1032&gt;&gt;&gt; import weakref&gt;&gt;&gt; o_ref = weakref.proxy(o)&gt;&gt;&gt; objsize.get_deep_size(o_ref)72```To mitigate this, you can provide a method that attempts to fetch theproxy’s referents:```pythonimport weakrefimport gcdef get_weakref_referents(*objs):    yield from gc.get_referents(*objs)    for o in objs:        if type(o) in weakref.ProxyTypes:            try:                yield o.__repr__.__self__            except ReferenceError:                pass```Then use it as follows:```pycon&gt;&gt;&gt; objsize.get_deep_size(o_ref, get_referents_func=get_weakref_referents)1104```After the referenced object will be collected, then the size of theproxy object will be reduced.```pycon&gt;&gt;&gt; del o&gt;&gt;&gt; gc.collect()&gt;&gt;&gt; # Wait for the object to be collected&gt;&gt;&gt; objsize.get_deep_size(o_ref, get_referents_func=get_weakref_referents)72```# Object Size SettingsTo avoid repeating the input settings when handling the special casesabove, you can use the [`ObjSizeSettings`](https://liran-funaro.github.io/objsize/library/objsize.traverse.html#objsize.traverse.ObjSizeSettings) class.```pycon&gt;&gt;&gt; torch_objsize = objsize.ObjSizeSettings(...   get_referents_func=get_referents_torch,...   filter_func=filter_func,... )&gt;&gt;&gt; torch_objsize.get_deep_size(torch.rand(200))928&gt;&gt;&gt; torch_objsize.get_deep_size(torch.rand(300))1328```See [`ObjSizeSettings`](https://liran-funaro.github.io/objsize/library/objsize.traverse.html#objsize.traverse.ObjSizeSettings) for thelist of configurable parameters.# TraversalA user can implement its own function over the entire subtree using thetraversal method, which traverses all the objects in the subtree.```pycon&gt;&gt;&gt; for o in objsize.traverse_bfs(my_obj):...     print(o)...MyClass(){'x': [0, 1, 2], 'y': [3, 4, 5], 'd': {'x': [0, 1, 2], 'y': [3, 4, 5], 'self': MyClass()}}[0, 1, 2][3, 4, 5]{'x': [0, 1, 2], 'y': [3, 4, 5], 'self': MyClass()}210543```Similar to before, non-exclusive objects can be ignored.```pycon&gt;&gt;&gt; for o in objsize.traverse_exclusive_bfs(my_obj):...     print(o)...MyClass(){'x': [0, 1, 2], 'y': [3, 4, 5], 'd': {'x': [0, 1, 2], 'y': [3, 4, 5], 'self': MyClass()}}{'x': [0, 1, 2], 'y': [3, 4, 5], 'self': MyClass()}```# Alternative[Pympler](https://pythonhosted.org/Pympler/) also supportsdetermining an object deep size via `pympler.asizeof()`. There are twomain differences between `objsize` and `pympler`.1. `objsize` has additional features:   * Traversing the object subtree: iterating all the object’s     descendants one by one.   * Excluding non-exclusive objects. That is, objects that are also     referenced from somewhere else in the program. This is true for     calculating the object’s deep size and for traversing its     descendants.2. `objsize` has a simple and robust implementation with significantly   fewer lines of code, compared to `pympler`. The Pympler   implementation uses recursion, and thus have to use a maximal depth   argument to avoid reaching Python’s max depth. `objsize`, however,   uses BFS which is more efficient and simple to follow. Moreover, the   Pympler implementation carefully takes care of any object type.   `objsize` archives the same goal with a simple and generic   implementation, which has fewer lines of code.# License: BSD-3Copyright (c) 2006-2023, Liran Funaro.All rights reserved.Redistribution and use in source and binary forms, with or withoutmodification, are permitted provided that the following conditions are met:1. Redistributions of source code must retain the above copyright   notice, this list of conditions and the following disclaimer.2. Redistributions in binary form must reproduce the above copyright   notice, this list of conditions and the following disclaimer in the   documentation and/or other materials provided with the distribution.3. Neither the name of the copyright holder nor the   names of its contributors may be used to endorse or promote products   derived from this software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THEIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSEARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BELIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, ORCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OFSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESSINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER INCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THEPOSSIBILITY OF SUCH DAMAGE.</longdescription>
</pkgmetadata>