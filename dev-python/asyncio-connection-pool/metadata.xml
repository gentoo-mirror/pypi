<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># asyncio-connection-pool[![GitHub Workflow Status (main)](https://img.shields.io/github/workflow/status/fellowinsights/asyncio-connection-pool/CI/main?style=plastic)][main CI][![PyPI](https://img.shields.io/pypi/v/asyncio-connection-pool?style=plastic)][package][![PyPI - Python Version](https://img.shields.io/pypi/pyversions/asyncio-connection-pool?style=plastic)][package][main CI]: https://github.com/fellowinsights/asyncio-connection-pool/actions?query=workflow%3ACI+branch%3Amain[package]: https://pypi.org/project/asyncio-connection-pool/This is a generic, high-throughput, optionally-burstable pool for asyncio.Some cool features:- No locking[^1]; no `asyncio.Lock` or `asyncio.Condition` needs to be taken in  order to get a connection.- Available connections are retrieved without yielding to the event loop.- When `burst_limit` is specified, `max_size` acts as a &quot;soft&quot; limit; the pool  can go beyond this limit to handle increased load, and shrinks back down  after.- The contents of the pool can be anything; just implement a  `ConnectionStrategy`.[^1]: Theoretically, there is an implicit &quot;lock&quot; that is held while an asyncio      task is executing. No other task can execute until the current task      yields (since it's cooperative multitasking), so any operations during      that time are atomic.## Why?We were using a different pool for handling our Redis connections, and noticedthat, under heavy load, we would spend a lot of time waiting for the lock, evenwhen there were available connections in the pool.We also thought it would be nice if we didn't need to keep many connectionsopen when they weren't needed, but still have the ability to make more whenthey are required.## API### `asyncio_connection_pool.ConnectionPool`This is the implementation of the pool. It is generic over a type ofconnection, and all implementation-specific logic is contained within a[`ConnectionStrategy`](#asyncio_connection_poolconnectionstrategy).A pool is created as follows:```pythonfrom asyncio_connection_pool import ConnectionPoolpool = ConnectionPool(strategy=my_strategy, max_size=15)```The constructor can optionally be passed an integer as `burst_limit`. Thisallows the pool to open more connections than `max_size` temporarily.#### `@asynccontextmanager async def get_connection(self) -&gt; AsyncIterator[Conn]`This method is the only way to get a connection from the pool. It is expectedto be used as follows:```pythonpool = ConnectionPool(...)async with pool.get_connection() as conn:    # Use the connection    pass```When the `async with` block is entered, a connection is retrieved. If aconnection needs to be opened or if the pool is at capacity and no connectionsare available, the caller will yield to the event loop.When the block is exited, the connection will be returned to the pool.### `asyncio_connection_pool.ConnectionStrategy`This is an abstract class that defines the interface of the object passed as`strategy`. A subclass _must_ implement the following methods:#### `async def create_connection(self) -&gt; Awaitable[Conn]`This method is called to create a new connection to the resource. This happenswhen a connection is requested and all connections are in use, as long as thepool is not at capacity.The result of a call to this method is what will be provided to a consumer ofthe pool, and in most cases will be stored in the pool to be re-used later.If this method raises an exception, it will bubble up to the frame where`ConnectionPool.get_connection()` was called.#### `def connection_is_closed(self, conn: Conn) -&gt; bool`This method is called to check if a connection is no longer able to be used.When the pool is retrieving a connection to give to a client, this method iscalled to make sure it is valid.The return value should be `True` if the connection is _not_ valid.If this method raises an exception, it is assumed that the connection isinvalid. The passed-in connection is dropped and a new one is retrieved. Theexception is suppressed unless it is not a `BaseException`, like`asyncio.CancelledError`. It is the responsibility of the `ConnectionStrategy`implementation to avoid leaking a connection in this case.#### `async def close_connection(self, conn: Conn)`This method is called to close a connection. This occurs when the pool hasexceeded `max_size` (i.e. it is bursting) and a connection is returned that isno longer needed (i.e. there are no more consumers waiting for a connection).If this method raises an exception, the connection is assumed to be closed andthe exception bubbles to the caller of `ConnectionPool.get_connection().__aexit__`(usually an `async with` block).## Integrations  with 3rd-party librariesThis package includes support for [`ddtrace`][ddtrace]/[`datadog`][datadog] andfor [`aioredis`][aioredis] (&lt;2.0.0).[ddtrace]: https://github.com/datadog/dd-trace-py[datadog]: https://github.com/datadog/datadogpy[aioredis]: https://github.com/aio-libs/aioredis### `asyncio_connection_pool.contrib.datadog.ConnectionPool`This class subclasses the `ConnectionPool` in the root of the package, and addsa bunch of tracing, gauges, and events. The constructor, in addition to thearguments of the base class, supports:- Required `service_name` argument: A prefix to all of the metrics- Optional `extra_tags` argument: Additional tags to provide to all metrics  (strings in a `&quot;key:value&quot;` format)### `asyncio_connection_pool.contrib.aioredis.RedisConnectionStrategy`This class implements the `ConnectionStrategy` abstract methods, using`aioredis.Redis` objects as connections. The constructor takes arbitraryarguments and forwards them to `aioredis.create_redis`.## How is this safe without locks?I encourage you to read the [source](https://github.com/fellowinsights/asyncio-connection-pool/blob/master/asyncio_connection_pool/__init__.py)to find out (it is quite well-commented). If you notice any faults in thelogic, please feel free to file an issue.</longdescription>
</pkgmetadata>