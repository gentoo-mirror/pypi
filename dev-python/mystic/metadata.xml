<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>--------------------------------------------------------------------------------------mystic: constrained nonlinear optimization for scientific machine learning, UQ, and AI--------------------------------------------------------------------------------------About Mystic============The ``mystic`` framework provides a collection of optimization algorithmsand tools that allows the user to more robustly (and easily) solve hardoptimization problems. All optimization algorithms included in ``mystic``provide workflow at the fitting layer, not just access to the algorithmsas function calls. ``mystic`` gives the user fine-grained power to bothmonitor and steer optimizations as the fit processes are running.Optimizers can advance one iteration with ``Step``, or run to completionwith ``Solve``.  Users can customize optimizer stop conditions, where bothcompound and user-provided conditions may be used. Optimizers can savestate, can be reconfigured dynamically, and can be restarted from asaved solver or from a results file.  All solvers can also leverageparallel computing, either within each iteration or as an ensemble ofsolvers.Where possible, ``mystic`` optimizers share a common interface, and thus canbe easily swapped without the user having to write any new code. ``mystic``solvers all conform to a solver API, thus also have common method callsto configure and launch an optimization job. For more details, see``mystic.abstract_solver``. The API also makes it easy to bind a favorite3rd party solver into the ``mystic`` framework.Optimization algorithms in ``mystic`` can accept parameter constraints,as &quot;soft constraints&quot; (i.e. ``penalties``, which &quot;penalize&quot; regions ofsolution space that violate the constraints), or as &quot;hard constraints&quot;(i.e. ``constraints``, which constrain the solver to only search in regionsof space where the constraints are respected), or both. ``mystic`` providesa large selection of constraints, including probabistic and dimensionallyreducing constraints. By providing a robust interface designed toenable the user to easily configure and control solvers, ``mystic``greatly reduces the barrier to solving hard optimization problems.Sampling, interpolation, and statistics in ``mystic`` are all designedto seamlessly couple with constrained optimization to facilitatescientific machine learning, uncertainty quantification, adaptivesampling, nonlinear interpolation, and artificial intelligence.``mystic`` can convert systems of equalities and inequalities tohard or soft constraints using methods in ``mystic.symbolic``.With ``mystic.constraints.vectorize``, constraints can be convertedto kernel transforms for use in machine learning. Similarly, ``mystic``provides tools for accurately producing emulators on an irregular gridusing ``mystic.math.interpolate``, which includes methods for solvingfor gradients and Hessians. ``mystic.samplers`` use optimizers todrive adaptive sampling toward the first and second order critical pointsof the response surface, yielding highly-informative training data setsand ensuring emulator accuracy. ``mystic.math.discrete`` definesconstrained discrete probability measures, which can be used inconstrained statistical optimization and learning.``mystic`` is in active development, so any user feedback, bug reports, comments,or suggestions are highly appreciated.  A list of issues is located at https://github.com/uqfoundation/mystic/issues, with a legacy list maintained at https://uqfoundation.github.io/project/mystic/query.Major Features==============``mystic`` provides a stock set of configurable, controllable solvers with:    - a common interface    - a control handler with: pause, continue, exit, and callback    - ease in selecting initial population conditions: guess, random, etc    - ease in checkpointing and restarting from a log or saved state    - the ability to leverage parallel &amp; distributed computing    - the ability to apply a selection of logging and/or verbose monitors    - the ability to configure solver-independent termination conditions    - the ability to impose custom and user-defined penalties and constraintsTo get up and running quickly, ``mystic`` also provides infrastructure to:    - easily generate a model (several standard test models are included)    - configure and auto-generate a cost function from a model    - configure an ensemble of solvers to perform a specific taskCurrent Release===============The latest released version of ``mystic`` is available from:    https://pypi.org/project/mystic``mystic`` is distributed under a 3-clause BSD license.Development Version===================You can get the latest development version with all the shiny new features at:    https://github.com/uqfoundationIf you have a new contribution, please submit a pull request.Installation============``mystic`` can be installed with ``pip``::    $ pip install mysticTo include optional scientific Python support, with ``scipy``, install::    $ pip install mystic[math]To include optional plotting support with ``matplotlib``, install::    $ pip install mystic[plotting]To include optional parallel computing support, with ``pathos``, install::    $ pip install mystic[parallel]Requirements============``mystic`` requires:    - ``python`` (or ``pypy``), **&gt;=3.7**    - ``setuptools``, **&gt;=42**    - ``cython``, **&gt;=0.29.30**    - ``numpy``, **&gt;=1.0**    - ``sympy``, **&gt;=0.6.7**    - ``mpmath``, **&gt;=0.19**    - ``dill``, **&gt;=0.3.7**    - ``klepto``, **&gt;=0.2.4**Optional requirements:    - ``matplotlib``, **&gt;=0.91**    - ``scipy``, **&gt;=0.6.0**    - ``pathos``, **&gt;=0.3.1**    - ``pyina``, **&gt;=0.2.8**More Information================Probably the best way to get started is to look at the documentation athttp://mystic.rtfd.io. Also see ``mystic.tests`` for a set of scripts thatdemonstrate several of the many features of the ``mystic`` framework.You can run the test suite with ``python -m mystic.tests``. There areseveral plotting scripts that are installed with ``mystic``, primary of whichare ``mystic_log_reader`` (also available with ``python -m mystic``) and the``mystic_model_plotter`` (also available with ``python -m mystic.models``).There are several other plotting scripts that come with ``mystic``, and theyare detailed elsewhere in the documentation.  See https://github.com/uqfoundation/mystic/tree/master/examples for examples that demonstrate the basic usecases for configuration and launching of optimization jobs using one of thesample models provided in ``mystic.models``. Many of the included examplesare standard optimization test problems. The use of constraints and penaltiesare detailed in https://github.com/uqfoundation/mystic/tree/master/examples2 while more advanced features leveraging ensemble solvers, machine learning,uncertainty quantification, and dimensional collapse are found in https://github.com/uqfoundation/mystic/tree/master/examples3. The scripts in https://github.com/uqfoundation/mystic/tree/master/examples4 demonstrate leveraging ``pathos``for parallel computing, as well as demonstrate some auto-partitioning schemes.``mystic`` has the ability to work in product measure space, and the scripts inhttps://github.com/uqfoundation/mystic/tree/master/examples5 show how to workwith product measures at a low level. The source code is generally welldocumented, so further questions may be resolved by inspecting the code itself.Please feel free to submit a ticket on github, or ask a question onstackoverflow (**@Mike McKerns**). If you would like to share how you use``mystic`` in your work, please send an email (to **mmckerns at uqfoundationdot org**).Instructions on building a new model are in ``mystic.models.abstract_model``.``mystic`` provides base classes for two types of models:    - ``AbstractFunction``   [evaluates ``f(x)`` for given evaluation points ``x``]    - ``AbstractModel``      [generates ``f(x,p)`` for given coefficients ``p``]``mystic`` also provides some convienence functions to help you build amodel instance and a cost function instance on-the-fly. For moreinformation, see ``mystic.forward_model``.  It is, however, not necessaryto use base classes or the model builder in building your own model orcost function, as any standard Python function can be used as long as itmeets the basic ``AbstractFunction`` interface of ``cost = f(x)``.All ``mystic`` solvers are highly configurable, and provide a robust set ofmethods to help customize the solver for your particular optimizationproblem. For each solver, a minimal (``scipy.optimize``) interface is alsoprovided for users who prefer to configure and launch their solvers as asingle function call. For more information, see ``mystic.abstract_solver``for the solver API, and each of the individual solvers for their minimalfunctional interface.``mystic`` enables solvers to use parallel computing whenever the user providesa replacement for the (serial) Python ``map`` function.  ``mystic`` includes asample ``map`` in ``mystic.python_map`` that mirrors the behavior of thebuilt-in Python ``map``, and a ``pool`` in ``mystic.pools`` that provides ``map``functions using the ``pathos`` (i.e. ``multiprocessing``) interface. ``mystic``solvers are designed to utilize distributed and parallel tools provided bythe ``pathos`` package. For more information, see ``mystic.abstract_map_solver``,``mystic.abstract_ensemble_solver``, and the ``pathos`` documentation athttp://pathos.rtfd.io.Important classes and functions are found here:    - ``mystic.solvers``                  [solver optimization algorithms]    - ``mystic.termination``              [solver termination conditions]    - ``mystic.strategy``                 [solver population mutation strategies]    - ``mystic.monitors``                 [optimization monitors]    - ``mystic.symbolic``                 [symbolic math in constraints]    - ``mystic.constraints``              [constraints functions]    - ``mystic.penalty``                  [penalty functions]    - ``mystic.collapse``                 [checks for dimensional collapse]    - ``mystic.coupler``                  [decorators for function coupling]    - ``mystic.pools``                    [parallel worker pool interface]    - ``mystic.munge``                    [file readers and writers]    - ``mystic.scripts``                  [model and convergence plotting]    - ``mystic.samplers``                 [optimizer-guided sampling]    - ``mystic.support``                  [hypercube measure support plotting]    - ``mystic.forward_model``            [cost function generator]    - ``mystic.tools``                    [constraints, wrappers, and other tools]    - ``mystic.cache``                    [results caching and archiving]    - ``mystic.models``                   [models and test functions]    - ``mystic.math``                     [mathematical functions and tools]Important functions within ``mystic.math`` are found here:    - ``mystic.math.Distribution``        [a sampling distribution object]    - ``mystic.math.legacydata``          [classes for legacy data observations]    - ``mystic.math.discrete``            [classes for discrete measures]    - ``mystic.math.measures``            [tools to support discrete measures]    - ``mystic.math.approx``              [tools for measuring equality]    - ``mystic.math.grid``                [tools for generating points on a grid]    - ``mystic.math.distance``            [tools for measuring distance and norms]    - ``mystic.math.poly``                [tools for polynomial functions]    - ``mystic.math.samples``             [tools related to sampling]    - ``mystic.math.integrate``           [tools related to integration]    - ``mystic.math.interpolate``         [tools related to interpolation]    - ``mystic.math.stats``               [tools related to distributions]Solver, Sampler, and model API definitions are found here:    - ``mystic.abstract_sampler``         [the sampler API definition]    - ``mystic.abstract_solver``          [the solver API definition]    - ``mystic.abstract_map_solver``      [the parallel solver API]    - ``mystic.abstract_ensemble_solver`` [the ensemble solver API]    - ``mystic.models.abstract_model``    [the model API definition]``mystic`` also provides several convience scripts that are used to visualizemodels, convergence, and support on the hypercube. These scripts are installedto a directory on the user's ``$PATH``, and thus can be run from anywhere:    - ``mystic_log_reader``               [parameter and cost convergence]    - ``mystic_log_converter``            [logfile format converter]    - ``mystic_collapse_plotter``         [convergence and dimensional collapse]    - ``mystic_model_plotter``            [model surfaces and solver trajectory]    - ``support_convergence``             [convergence plots for measures]    - ``support_hypercube``               [parameter support on the hypercube]    - ``support_hypercube_measures``      [measure support on the hypercube]    - ``support_hypercube_scenario``      [scenario support on the hypercube]Typing ``--help`` as an argument to any of the above scripts will print out aninstructive help message.Citation========If you use ``mystic`` to do research that leads to publication, we ask that youacknowledge use of ``mystic`` by citing the following in your publication::    M.M. McKerns, L. Strand, T. Sullivan, A. Fang, M.A.G. Aivazis,    &quot;Building a framework for predictive science&quot;, Proceedings of    the 10th Python in Science Conference, 2011;    http://arxiv.org/pdf/1202.1056    Michael McKerns, Patrick Hung, and Michael Aivazis,    &quot;mystic: highly-constrained non-convex optimization and UQ&quot;, 2009- ;    https://uqfoundation.github.io/project/mysticPlease see https://uqfoundation.github.io/project/mystic orhttp://arxiv.org/pdf/1202.1056 for further information.</longdescription>
</pkgmetadata>