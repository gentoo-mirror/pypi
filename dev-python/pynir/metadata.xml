<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Commom Calibration methods for multivariate calibrationThis is a Python library for dealing with multivariate calibration, e.g., Near infrared spectra regression and classification tasks.## InstallationUse the package manager [pip](https://pip.pypa.io/en/stable/) to install [pynir](https://pypi.org/project/pynir/). ```bashpip install pynir```In addition, we have also provide an online version at [link](https://nir.chemoinfolab.com)## Usage### Simulata NIR spectra (spc) and reference values (conc)```pythonfrom pynir.utils import simulateNIRspc, conc = simulateNIR()```### Regression```pythonfrom pynir.utils import simulateNIRfrom pynir.Calibration import pls# estabilish PLS modeln_components = 10plsModel = pls(n_components = n_components)plsModel.fit(X,y)yhat = plsModel.predict(X)```### Classification```python# simulate NIR datafrom pynir.utils import simulateNIRfrom pynir.Calibration import plsdanclass = 4X,y,wv = simulateNIR(nSample=200,n_components=10,refType=nclass, noise=1e-5)# estabilish PLS modeln_components = 10plsdaModel = plsda(n_components = n_components)plsdaModel.fit(X,y)yhat = plsdaModel.predict(X)```### Feature selection```python# Feature selectionfrom pynir.utils import simulateNIRfrom pynir.Calibration import plsfrom pynir.FeatureSelection import MCUVE# simulate NIR dataX,y,wv = simulateNIR(nSample=200,n_components=10,noise=1e-5)mcModel = MCUVE(X, y, n_components, nrep=nrep).fit()featureSelected_MC_UVE = mcModel.featureRank[:nSel]```### Outlier dection```pythonimport numpy as npimport matplotlib.pyplot as pltfrom pynir.utils import simulateNIRfrom pynir.OutlierDection import outlierDection_PLS# simulate NIR dataX,y,wv = simulateNIR(nSample=200,n_components=10,noise=1e-5)ODModel = outlierDection_PLS(ncomp=3)Q, Tsq, Q_conf, Tsq_conf, idxOutlier = ODModel.fit(X, y).detect(X,y)ODModel.plot_HotellingT2_Q(Q, Tsq, Q_conf, Tsq_conf)```### Calibration Transfer```pythonfrom pynir.utils import simulateNIR_calibrationTransferfrom pynir.Calibration import pls, regresssionReportfrom pynir.CalibrationTransfer import PDS,SST, BSimport matplotlib.pyplot as pltimport numpy as np# Simulate NIR spectra for calibration transfernSample = 100X1, X2, y, wv = simulateNIR_calibrationTransfer(nSample=nSample,n_components=10,shifts=5e1)idxTrain,idxTest = train_test_split(np.arange(nSample),test_size=0.6)idxTransfer,idxTest = train_test_split(idxTest,test_size=0.5)# Multivariate calibrationn_components = 7plsModel1 = pls(n_components=n_components).fit(X1[idxTrain,:], y[idxTrain])yhat1 = plsModel1.predict(X1[idxTest,:],n_components=n_components)yhat2= plsModel1.predict(X2[idxTest,:],n_components=n_components)fig, ax = plt.subplots(2,sharex=True,figsize=(8,16))plsModel1.plot_prediction(y[idxTest], yhat1,title = &quot;First&quot;, ax = ax[0])plsModel1.plot_prediction(y[idxTest], yhat2, title= &quot;Second&quot;, ax = ax[1])# Calibration transfer on spectra## PDSX2_PDS = PDS(halfWindowSize=3).fit(X1[idxTransfer,:], X2[idxTransfer,:]).transform(X2[idxTest,:])yhat2_PDS= plsModel1.predict(X2_PDS,n_components=n_components)plsModel1.plot_prediction(y[idxTest], yhat2_PDS, title= &quot;PDS&quot;)fig, ax = plt.subplots()ax.plot(wv, np.transpose(X2_PDS))## SSTX2_SST = SST(n_components=n_components).fit(X1[idxTransfer,:], X2[idxTransfer,:]).transform(X2[idxTest,:])yhat2_SST= plsModel1.predict(X2_SST,n_components=n_components)plsModel1.plot_prediction(y[idxTest], yhat2_SST, title= &quot;SST&quot;)fig, ax = plt.subplots()ax.plot(wv, np.transpose(X2_SST))# Calibration transfer on prediction## BSyhat2_BS = BS().fit(yhat1, yhat2).transform(yhat2)plsModel1.plot_prediction(y[idxTest], yhat2_BS, title= &quot;BS&quot;)```### Calibration Enhancement```pythonfrom pynir.utils import simulateNIR_calibrationTransferfrom pynir.Calibration import pls, regresssionReportfrom pynir.CalibrationTransfer import NS_PFCE,SS_PFCE,FS_PFCE,MT_PFCEimport matplotlib.pyplot as pltimport numpy as npfrom sklearn.model_selection import train_test_splitimport timenSample = 100X1, X2, y, wv = simulateNIR_calibrationTransfer(nSample=nSample,n_components=10,shifts=5e1)idxTrain,idxTest = train_test_split(np.arange(nSample),test_size=0.6)idxTransfer,idxTest = train_test_split(idxTest,test_size=0.5)n_components = 7plsModel1 = pls(n_components=n_components).fit(X1[idxTrain,:], y[idxTrain])## PFCEthres = 0.98constrType = 1tic = time.time()b1 = plsModel1.model['B'][:,-1]NS_PFCE_model = NS_PFCE(thres=thres, constrType=constrType).fit(X1[idxTransfer,:],X2[idxTransfer,:],b1)yhat2_NS_PFCE = NS_PFCE_model.transform(X2[idxTest,:])plsModel1.plot_prediction(y[idxTest], yhat2_NS_PFCE, title= &quot;NS-PFCE&quot;)fig, ax = plt.subplots()ax.plot(wv, NS_PFCE_model.b2.x[1:])ax.set_xlabel(&quot;wavelength (nm)&quot;)ax.set_ylabel(&quot;Regression Coefficients&quot;)ax.set_title(&quot;NS-PFCE&quot;)print(&quot;cost {:.2f} seconds for NS-PFCE&quot;.format(time.time()-tic))tic = time.time()b1 = plsModel1.model['B'][:,-1]SS_PFCE_model = SS_PFCE(thres=thres, constrType=constrType).fit(X2[idxTransfer,:],y[idxTransfer],b1)yhat2_SS_PFCE = SS_PFCE_model.transform(X2[idxTest,:])plsModel1.plot_prediction(y[idxTest], yhat2_SS_PFCE, title= &quot;SS-PFCE&quot;)fig, ax = plt.subplots()ax.plot(wv, SS_PFCE_model.b2.x[1:])ax.set_xlabel(&quot;wavelength (nm)&quot;)ax.set_ylabel(&quot;Regression Coefficients&quot;)ax.set_title(&quot;SS-PFCE&quot;)print(&quot;cost {:.2f} seconds for SS-PFCE&quot;.format(time.time()-tic))tic = time.time()b1 = plsModel1.model['B'][:,-1]FS_PFCE_model = FS_PFCE(thres=thres, constrType=constrType).fit(X1[idxTransfer,:],X2[idxTransfer,:],y[idxTransfer],b1)yhat2_FS_PFCE = FS_PFCE_model.transform(X2[idxTest,:])plsModel1.plot_prediction(y[idxTest], yhat2_FS_PFCE, title= &quot;FS-PFCE&quot;)fig, ax = plt.subplots()ax.plot(wv, FS_PFCE_model.b2.x[1:])ax.set_xlabel(&quot;wavelength (nm)&quot;)ax.set_ylabel(&quot;Regression Coefficients&quot;)ax.set_title(&quot;FS-PFCE&quot;)print(&quot;cost {:.2f} seconds for FS-PFCE&quot;.format(time.time()-tic))tic = time.time()b1 = plsModel1.model['B'][:,-1]MT_PFCE_model = MT_PFCE(thres=thres, constrType=constrType)MT_PFCE_model.fit([X1[idxTrain,:],X2[idxTransfer,:]],(y[idxTrain],y[idxTransfer]),b1)yhat1_MT_PFCE = MT_PFCE_model.transform(X1[idxTest,:],0) # task 1yhat2_MT_PFCE = MT_PFCE_model.transform(X2[idxTest,:],1) # task 2fig, ax = plt.subplots(2,sharex=True,figsize=(8,16))plsModel1.plot_prediction(y[idxTest], yhat1_MT_PFCE, title= &quot;MT-PFCE_First&quot;, ax= ax[0])plsModel1.plot_prediction(y[idxTest], yhat2_MT_PFCE, title= &quot;MT-PFCE_Second&quot;, ax= ax[1])fig, ax = plt.subplots()ax.plot(wv, MT_PFCE_model.B.x.reshape(2,-1)[:,1:].transpose())ax.set_xlabel(&quot;wavelength (nm)&quot;)ax.set_ylabel(&quot;Regression Coefficients&quot;)ax.set_title(&quot;MT-PFCE&quot;)print(&quot;cost {:.2f} seconds for MT-PFCE&quot;.format(time.time()-tic))```## DemonFirst, execute```bashgit clone https://github.com/JinZhangLab/pynir.gitcd ./pynir/examples```Then, execute code in your python coding environment or just in terminal as follows:```bashpython Demo1_SimulateNIR.pypython Demo2_Regression.pypython Demo3_Binary_Classification.pypython Demo4_Multiclass_Classification.pypython Demo5_dataPreprocessing.pypython Demo6_outierDection.pypython Demo7_FeatureSelection_oneSteppython Demo8_FeatureSelection_multiSteps.pypython Demo9_calibrationTransfer.pypython Demo10_calibrationTransfer_PFCE_simulateNIR.pypython Demo11_calibrationTransfer_PFCE_Tablet.pypython Demo12_calibrationTransfer_PFCE_Corn.py```## Ref- Zhang, J.; Cui, X. Y.; Cai, W. S.; Shao, X. G., A variable importance criterion for variable selection in near-infrared spectral analysis. Sci. China Chem. 2018, 62, 271-79.[link](https://link.springer.com/article/10.1007%2Fs11426-018-9368-9)- Zhang J., Li B. Y., Hu Y., Zhou L. X., Wang G. Z., Guo G., Zhang Q. H., Lei S. C., Zhang A. H. A parameter-free framework for calibration enhancement of near-infrared spectroscopy based on correlation constraint [J]. Analytica Chimica Acta, 2021, 1142: 169-178.  [link](&lt;https://linkinghub.elsevier.com/retrieve/pii/S0003-2670(20)31110-7&gt;)## ContributingPull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.Please make sure to update tests as appropriate.## License[MIT](https://choosealicense.com/licenses/mit/)</longdescription>
</pkgmetadata>