<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># [cvxcovariance](http://www.cvxgrp.org/cov_pred_finance/book)[![Coverage Status](https://coveralls.io/repos/github/cvxgrp/cov_pred_finance/badge.svg)](https://coveralls.io/github/cvxgrp/cov_pred_finance)[![PyPI version](https://badge.fury.io/py/cvxcovariance.svg)](https://badge.fury.io/py/cvxcovariance)![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)[![Downloads](https://static.pepy.tech/personalized-badge/cvxcovariance?period=month&amp;units=international_system&amp;left_color=black&amp;right_color=orange&amp;left_text=PyPI%20downloads%20per%20month)](https://pepy.tech/project/cvxcovariance)[![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/cvxgrp/cov_pred_finance)The `cvxcovariance` packageprovides simple tools for creating an estimate $\hat\Sigma_t$ of the covariance$\Sigma_t$ of the $n$-dimensional return vectors $r_t$, $t=1,2,\ldots$, based onthe observed returns $r_1, \ldots, r_{t-1}$. (Here $r_t$ is the return from$t-1$ to $t$.) The covariance predictor $\hat\Sigma_t$ is generated by blending$K$ different &quot;expert&quot; predictors $\hat\Sigma_t^{(1)},\ldots,\hat\Sigma_t^{(K)}$,by solving a convex optimization problem at each time step.For a detailed description of the methodology, see our manuscript[A Simple Method for Predicting Covariance Matrices of Financial Returns](https://web.stanford.edu/~boyd/papers/cov_pred_finance.html)(in particular Section 3).In the simplest case the user provides a $T\times n$ pandas DataFrameof returns $r_1,\ldots,r_T$ and $K$ half-life pairs, and gets back covariancepredictors for each time step. (The $K$ experts are computed as iteratedexponentially weighted moving average (IEWMA) predictors as described inSection 2.6 of the [paper](https://web.stanford.edu/~boyd/papers/cov_pred_finance.html).)In the more general case, the user provides the $K$ expert predictors$\hat\Sigma_t^{(1)},\ldots,\hat\Sigma_t^{(K)}$, $t=1,\ldots,T$, and these areblended together by solving the convex optimization problems. In either casethe result is returned as an iterator object over namedtuples:`Result = namedtuple(&quot;Result&quot;, [&quot;time&quot;, &quot;mean&quot;, &quot;covariance&quot;, &quot;weights&quot;])`.Note: at time $t$ the user is provided with $\Sigma_{t+1}$,$\textit{i.e.}$, the covariance matrix for the next time step.So `Result.covariance` returns the covariance prediction for `time+1`.## InstallationTo install the package, run the following command in the terminal:```bashpip install cvxcovariance```## UsageThere are two alternative ways to use the package. The first is to use the`from_ewmas` function to create a combined multiple IEWMA (CM-IEWMA) predictor.The second is to provide your own covariance experts, via dictionaries,and pass them to the `from_sigmas` function. Both functions return an objectof the `_CovarianceCombination` class, which can be used to solve the covariancecombination problem.### CM-IEWMAThe `from_ewmas` function takes as input a pandas DataFrame ofreturns and the IEWMA half-life pairs (each pair consists of one half-life forvolatility estimation and one for correlation estimation), and returns aniterator object that iterates over the CM-IEWMA covariance predictors definedvia namedtuples. Through the namedtuple you can access the`time`, `mean`, `covariance`, and `weights` attributes. `time` is the timestamp.`mean` is the estimated mean of the return at the $\textit{next}$ timestamp,$\textit{i.e.}$ `time+1`, if the user wants to estimate the mean; per defaultthe mean is set to zero, which is a reasonable assumption for many financialreturns. `covariance` is the estimated covariance matrix for the $\textit{next}$timestamp, $\textit{i.e.}$ `time+1`. `weights` are the $K$ weights attributedto the experts. Here is an example:```pythonimport pandas as pdfrom cvx.covariance.combination import from_ewmas# Load return datareturns = pd.read_csv(&quot;data/ff5.csv&quot;, index_col=0, header=0, parse_dates=True).iloc[:1000]n = returns.shape[1]# Define half-life pairs for K=3 experts, (halflife_vola, halflife_cov)halflife_pairs = [(10, 21), (21, 63), (63, 125)]# Define the covariance combinatorcombinator = from_ewmas(returns,                        halflife_pairs,                        min_periods_vola=n,  # min periods for volatility estimation                        min_periods_cov=3 * n)  # min periods for correlation estimation# Solve combination problem and loop through combination results to get predictorscovariance_predictors = {}for predictor in combinator.solve(window=10):  # lookback window for optimization    # From predictor we can access predictor.time, predictor.mean (=0 here),    # predictor.covariance, and predictor.weights    covariance_predictors[predictor.time] = predictor.covariance```Here `covariance_predictors[t]` is the covariance prediction for time $t+1$,$\textit{i.e.}$, it is uses knowledge of $r_1,\ldots,r_t$.### General covariance combinationThe `from_sigmas` function takes as input a pandas DataFrame ofreturns and a dictionary of covariance predictors `{key: {time:sigma}`, where `key` is the key of an expert predictor and `{time:sigma}` is the expert predictions. For example, here we combine twoEWMA covariance predictors from pandas:```pythonimport pandas as pdfrom cvx.covariance.combination import from_sigmas# Load return datareturns = pd.read_csv(&quot;data/ff5.csv&quot;, index_col=0,                      header=0, parse_dates=True).iloc[:1000]n = returns.shape[1]# Define 21 and 63 day EWMAs as dictionaries (K=2 experts)ewma21 = returns.ewm(halflife=21, min_periods=5 * n).cov().dropna()expert1 = {time: ewma21.loc[time] for time in ewma21.index.get_level_values(0).unique()}ewma63 = returns.ewm(halflife=63, min_periods=5 * n).cov().dropna()expert2 = {time: ewma63.loc[time] for time in ewma63.index.get_level_values(0).unique()}# Create expert dictionaryexperts = {1: expert1, 2: expert2}# Define the covariance combinatorcombinator = from_sigmas(sigmas=experts, returns=returns)# Solve combination problem and loop through combination results to get predictorscovariance_predictors = {}for predictor in combinator.solve(window=10):    # From predictor we can access predictor.time, predictor.mean (=0 here),    # predictor.covariance, and predictor.weights    covariance_predictors[predictor.time] = predictor.covariance```Here `covariance_predictors[t]` is the covariance prediction for time$t+1$, $\textit{i.e.}$, it is uses knowledge of $r_1,\ldots,r_t$.## PoetryWe assume you share already the love for [Poetry](https://python-poetry.org).Once you have installed poetry you can perform```bashmake install```to replicate the virtual environment we have defined in [pyproject.toml](pyproject.toml)and locked in [poetry.lock](poetry.lock).## JupyterWe install [JupyterLab](https://jupyter.org) on fly within the aforementionedvirtual environment. Executing```bashmake jupyter```will install and start the jupyter lab.## CitingIf you want to reference our paper in your research,please consider citing us by using the following BibTeX:```BibTeX@misc{johansson2023covariance,      title={A Simple Method for Predicting Covariance Matrices of Financial Returns},      author={Kasper Johansson and Mehmet Giray Ogut and Markus Pelger      and Thomas Schmelzer and Stephen Boyd},      year={2023},      eprint={2305.19484},      archivePrefix={arXiv},}```</longdescription>
</pkgmetadata>