<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Lovely Pytest Docker[![PyPI](https://img.shields.io/pypi/v/lovely-pytest-docker)](https://pypi.org/project/lovely-pytest-docker/)[![PyPI](https://img.shields.io/pypi/pyversions/lovely-pytest-docker)](https://pypi.org/project/lovely-pytest-docker/)[![Build Status](https://app.travis-ci.com/lovelysystems/lovely-pytest-docker.svg?branch=master)](https://app.travis-ci.com/lovelysystems/lovely-pytest-docker)Create simple Pytest_ fixtures for writing integration tests based on Dockercontainers. The framework provides a service class to start and stop containersbased Docker Compose. Each single container can be started individually.Some parts of this package are taken fromhttps://github.com/AndreLouisCaron/pytest-docker## Usage with PytestThe docker compose file should contain all desired containers and the portsshould be exposed. In the following example we want to start the app to testand a SQL database (Crate). Let's assume there is a ``Dockerfile`` for the appin the same folder as the docker compose file.```yamlversion: &quot;3&quot;services:  app:    build: .    ports:      - &quot;8080&quot;    depends_on:      - &quot;crate&quot;  crate:    image: crate:latest    ports:      - &quot;4200&quot;```In the ``conftest.py`` file we can declare the docker fixtures for each servicewe want to be able to start in the tests.```python    import pytest    @pytest.fixture(scope='session')    def docker_app(docker_services):        docker_services.start('app')        public_port = docker_services.wait_for_service(&quot;app&quot;, 8080)        url = &quot;http://{docker_services.docker_ip}:{public_port}&quot;.format(**locals())        return url    @pytest.fixture(scope='session')    def docker_crate(docker_services):        docker_services.start('crate')        public_port = docker_services.wait_for_service(&quot;crate&quot;, 4200)        dsn = &quot;{docker_services.docker_ip}:{public_port}&quot;.format(**locals())        return dsn```By default the fixture will look for the ``docker-compose.yml`` file in the``tests`` subfolder of the path where ``pytest.ini`` resides (or the project'sroot directory if no ini file is given - as in the tests example). In manycases you will want to override the location for the docker compose files. Justoverwrite the ``docker_compose_files`` fixture in your ``conftest.py`` file.```python    @pytest.fixture(scope='session')    def docker_compose_files(pytestconfig):        &quot;&quot;&quot;Get the docker-compose.yml absolute path.        Override this fixture in your tests if you need a custom location.        &quot;&quot;&quot;        return [            project_path('docker', 'docker-compose.yml'),        ]```In your test file declare the fixtures you want to use:```python    def test_something(docker_app, docker_crate):        # e.g. initialize database        ...        # test something (e.g. request to docker_app)        ...```A working configuration and test example can be found in the ``tests`` folderof this package.## Execution in Docker ContainerIt's possible to execute a command inside one of the Docker containers. Usethe ``exec`` method of the ``docker_services`` fixture::```python    def test_execute(docker_services):        # the first argument is the service name of the compose file,        # the following arguments build the command to run        res = docker_services.execute('crate', 'ls', '-a')```## Stopping a Docker ContainerIt's possible to stop single Docker containers. Usethe ``stop`` method of the ``docker_services`` fixture::    def test_stop(docker_services):        # the first argument is the service name of the compose file,        # the following arguments build the command to run        res = docker_services.stop('crate')## Wait for ServiceThe ``wait_for_service`` method of the service module checks whether thedocker service is really started. By default it makes a HTTP GET request to theserver's ``/`` endpoint. The service will retry to check until a timeout of30 seconds has passed.### Custom Service CheckerSome services may work differently and require a custom checker.Create a custom service checker function which receives the IP address and theport as parameters::```python    def custom_service_checker(ip_address, port):        # if service is ready        return True        # otherwise return False```In the fixture provide the custom service checker function as ``check_service``parameter to the ``wait_for_service`` method::```python    @pytest.fixture(scope='session')    def docker_custom_service(docker_services):        docker_services.start('custom_service')        public_port = docker_services.wait_for_service(            &quot;app&quot;,            8080,            check_server=custom_service_checker        )        url = &quot;http://{docker_services.docker_ip}:{public_port}&quot;.format(**locals())        return url```To use another request path with the default checker the `url_checker` methodcan be used to create a `check_url` method for another path::```python    docker_services.wait_for_service(        &quot;app&quot;,        8080,        check_server=url_checker('/probe_status'),    )```## Run TestsTests are held in the ``tests`` directory. Running tests is done via thepytest package with::```shell    ./gradlew pytest```.. _Pytest: http://doc.pytest.org</longdescription>
</pkgmetadata>