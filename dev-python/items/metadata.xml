<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>| |travisci| |version| |versions| |impls| |wheel| |coverage|.. |travisci| image:: https://travis-ci.org/jonathaneunice/items.svg?branch=master    :alt: Travis CI build status    :target: https://travis-ci.org/jonathaneunice/items.. |version| image:: http://img.shields.io/pypi/v/items.svg?style=flat    :alt: PyPI Package latest release    :target: https://pypi.python.org/pypi/items.. |versions| image:: https://img.shields.io/pypi/pyversions/items.svg    :alt: Supported versions    :target: https://pypi.python.org/pypi/items.. |impls| image:: https://img.shields.io/pypi/implementation/items.svg    :alt: Supported implementations    :target: https://pypi.python.org/pypi/items.. |wheel| image:: https://img.shields.io/pypi/wheel/items.svg    :alt: Wheel packaging support    :target: https://pypi.python.org/pypi/items.. |coverage| image:: https://img.shields.io/badge/test_coverage-100%25-6600CC.svg    :alt: Test line coverage    :target: https://pypi.python.org/pypi/itemsAttributes are the most straightforward and convenient to access composite datain many situations. ``item.name`` is neater, more readable, and more concisethan the indexing style ``item['name']`` typical of dictionaries. Havingattribute access often is the difference between being able to easilyde-reference a component of ``item`` directly and deciding to store thatattribute in a completely separate variable for clarity (``item_name =item['name']``).In traversing data structures from XML, JSON, and other typically-nested datasources, concise direct access can clean up code considerably.Items-----``items`` therefore provides ``Item``, a convenient attribute-accessible ``dict`` subclass,plus helper functions.``itemize``, for example, helps iterate through a sequence of dictionaries, as often foundin JSON processing: Each record is handed back as an ``Item`` rather than a Python``dict``.A typical progression would be from:.. code-block:: python    for item in data:        item_name = item['name']        # ...        print(item_name)to.. code-block:: python    from items import itemize    for item in itemize(data):        # ...        print(item.name)To process a sequence wholesale, returning a ``list``:.. code-block:: python    from items import itemize_all    itemize_all(data)If you're iterating over a sequence of tuples (or lists) rather thandictionaries, you can still use ``itemize`` by providing the field namesyou wnat assigned... code-block:: python    parser = ...    for item in itemize(parser, fields='prefix token value'):        if item.prefix is None and item.token == 'start_array':            ...Here each result returned by ``parser`` (typically a Python generator)is converted from a tuple (or list) into an ``Item``.  Now you have several valuesconveniently packaged in a name-accessible way without having to createa separate ``namedtuple`` for this result type, and without any need fortuple positional indexing.You can even do this for a scalar sequence:    for item in itemize('aeiou', fields='vowel'):        item.value = 20 if item.vowel == 'e' else 15Beyond graceful handling of single-valued sequences, this example demonstratesthe mutability of each ``Item``. ``namedtuples`` are grand as return types,but they cannot be easily extended or annotated by subsequent processing...acommon requirement for many algorithms.Diving Deeper-------------``Item`` subclasses ``collections.OrderedDict``, so keys are ordered the sameas when your program first encountered them. The performance overhead ofordered mappings is minimal in most development contexts, especially inexploratory and data-cleanup tasks. Whatever overhead there is is more thanmade up for by the programming and debugging clarity of not having keys occurin seemingly randomized order.``Item`` s are also permissive, in a way that ``dict`` and its variants usuallyare not: If you access ``item.some_attribute`` where the attribute doesnot exist, you do **not** raise a ``KeyError``, unlike typicalPython dictionaries. Instead you get ``Empty``, a designated, false-yvalue similar to, but distinct from, ``None``. This is convenient forprocessing data which is irregular or not uniformly filled-in, because you donot need the constant &quot;guard conditions&quot;--``if`` statements or``try``/``except KeyError`` blocks--to protect against cases where this datavalue or that is missing. Using ``Empty`` instead of ``None`` preserves yourability to use ``None`` in cases where it's semantically important. Forexample, in parsing JSON, ``None`` is returned from JSON's ``null`` value.``Empty`` objects are infinitely dereferenceable. No matter how many levels ofindirection, they always just hand back themselves--the same gentle &quot;nothinghere, no exceptions raised&quot; behavior. You can also iterate over an``Empty``--it will simply iterate zero times. This neatly avoids the common``TypeError: 'NoneType' object is not iterable`` error messages in instanceswhere a value can be a list--or ``None`` if the list is not present... code-block:: python    from items import Empty    e = Empty    assert e[1].method().there[33][0].no.attributes[99].here is Empty    for x in Empty:        print('hey!')     # never prints, because no such iterations occurFor more on the background of ``Empty``, see the `nulltype &lt;https://pypi.org/project/nulltype/&gt;`_module. A typical use would be:.. code-block:: python    for item in itemize(data):        if item.name:            process(item)Items that lack names are simply not processed.The more nested, complex, and irregular your data structures, themore valuable this becomes.Serialization and Deserialization=================================Be careful importing data. Popular Python modules for reading JSON, YAML, andother formats do not believe mappings are (or should be) ordered. Historicallyand officially, they're not, no matter how ordered they look, no matter thatother languages such as JavaScript take a different approach, and no matter howmany Stack Overflow questions demonstrate that ordered input and output isstrongly and broadly desired. Therefore stock input/output modules can causedislocation as data is parsed. Take steps to return ordered mappings from them... code-block:: python    # YAML module that will load into OrderedDict instances, which can then    # be easily converted to Item instances; based on default PyYAML    import oyaml as yaml    data = itemize_all(yaml.load(rawyaml))    # modified call to json.load or json.loads to preserve order by instantiating    # Item instances rather than dict    import json    data = json.loads(rawjson, object_pairs_hook=Item)Cycles======Not currently organized for handling cyclic data structures. Those do notappear in processing JSON, XML, and other common data formats, but mightbe a nice future extension.Installation============To install or upgrade to the latest version::    pip install -U itemsSometimes Python installations have different names for ``pip`` (e.g. ``pip``,``pip2``, and ``pip3``), and on systems with multiple versions of Python, which``pip`` goes with which Python interpreter can become confusing. In thosecases, try running ``pip`` as a module of the Python version you want toinstall under. This can reduce conflicts and confusion::    python3.6 -m pip install -U itemsOn Unix, Linux, and macOS you may need to prefix these with ``sudo`` to authorizeinstallation. In environments without super-user privileges, you may want touse ``pip``'s ``--user`` option, to install only for a single user, ratherthan system-wide.Testing=======If you wish to run the module tests locally, you'll need to install``pytest`` and ``tox``.  For full testing, you will also need ``pytest-cov``and ``coverage``. Then run one of these commands::    tox                # normal run - speed optimized    tox -e py37        # run for a specific version only    tox -c toxcov.ini  # run full coverage testsNotes=====* Does not work on Python 2. Should work on Python 3 prior to 3.6, but not guaranteed.  Testing more difficult given different dictionary ordering rules prior to 3.6.  Since items intended as forward-looking module, not currently worth energy to retrofit  to archaic dialects.</longdescription>
</pkgmetadata>