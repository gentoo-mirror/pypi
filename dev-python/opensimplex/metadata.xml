<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># OpenSimplex Noise[![build-status](https://github.com/lmas/opensimplex/workflows/Tests/badge.svg?branch=master)](https://github.com/lmas/opensimplex/actions)[![pypi-version](https://img.shields.io/pypi/v/opensimplex?label=Version)](https://pypi.org/project/opensimplex/)[![pypi-downloads](https://img.shields.io/pypi/dm/opensimplex?label=Downloads)](https://pypistats.org/packages/opensimplex)[OpenSimplex] is a noise generation function like [Perlin] or [Simplex] noise, but better.    OpenSimplex noise is an n-dimensional gradient noise function that was    developed in order to overcome the patent-related issues surrounding    Simplex noise, while continuing to also avoid the visually-significant    directional artifacts characteristic of Perlin noise.    - Kurt SpencerThis is merely a python port of Kurt Spencer's [original code] (released to the public domain)and neatly wrapped up in a package.[OpenSimplex]: https://en.wikipedia.org/wiki/OpenSimplex_noise[Perlin]: https://en.wikipedia.org/wiki/Perlin_noise[Simplex]: https://en.wikipedia.org/wiki/Simplex_noise[original code]: https://gist.github.com/KdotJPG/b1270127455a94ac5d19## StatusThe `master` branch contains the latest code (possibly unstable),with automatic tests running for **Python 3.8, 3.9, 3.10 on Linux, MacOS and Windows**.Please refer to the [version tags] for the latest stable version.[version tags]: https://github.com/lmas/opensimplex/tagsUpdates for **v0.4+**:- Adds a hard dependency on 'Numpy', for array optimizations aimed at heavier workloads.- Adds optional dependency on 'Numba', for further speed optimizations using caching  (currently untested due to issues with llvmlite).- Adds typing support.- General refactor and cleanup of the library, tests and docs.- **Breaking changes: API functions uses new names.**## ContributionsBug reports, bug fixes and other issues with existing features of the library are welcomed and will be handled duringthe maintainer's free time. New stand-alone examples are also accepted.However, pull requests with new features for the core internals will not be accepted as it eats up too much weekendtime, which I would rather spend on library stability instead.## Usage**Installation**    pip install opensimplex**Basic usage**    &gt;&gt;&gt; import opensimplex    &gt;&gt;&gt; opensimplex.seed(1234)    &gt;&gt;&gt; n = opensimplex.noise2(x=10, y=10)    &gt;&gt;&gt; print(n)    0.580279369186297**Running tests and benchmarks**Setup a development environment:    make dev    source devenv/bin/activate    make depsAnd then run the tests:    make testOr the benchmarks:    make benchmarkFor more advanced examples, see the files in the [tests](./tests/) and [examples](./examples/) directories.## API**opensimplex.seed(seed)**    Seeds the underlying permutation array (which produces different outputs),    using a 64-bit integer number.    If no value is provided, a static default will be used instead.    seed(13)**random_seed()**    Works just like seed(), except it uses the system time (in ns) as a seed value.    Not guaranteed to be random so use at your own risk.    random_seed()**opensimplex.noise2(x, y)**    Generate 2D OpenSimplex noise from X,Y coordinates.    :param x: x coordinate as float    :param y: y coordinate as float    :return:  generated 2D noise as float, between -1.0 and 1.0    &gt;&gt;&gt; noise2(0.5, 0.5)    -0.43906247097569345**opensimplex.noise2array(x, y)**    Generates 2D OpenSimplex noise using Numpy arrays for increased performance.    :param x: numpy array of x-coords    :param y: numpy array of y-coords    :return:  2D numpy array of shape (y.size, x.size) with the generated noise              for the supplied coordinates    &gt;&gt;&gt; rng = numpy.random.default_rng(seed=0)    &gt;&gt;&gt; ix, iy = rng.random(2), rng.random(2)    &gt;&gt;&gt; noise2array(ix, iy)    array([[ 0.00449931, -0.01807883],           [-0.00203524, -0.02358477]])**opensimplex.noise3(x, y, z)**    Generate 3D OpenSimplex noise from X,Y,Z coordinates.    :param x: x coordinate as float    :param y: y coordinate as float    :param z: z coordinate as float    :return:  generated 3D noise as float, between -1.0 and 1.0    &gt;&gt;&gt; noise3(0.5, 0.5, 0.5)    0.39504955501618155**opensimplex.noise3array(x, y, z)**    Generates 3D OpenSimplex noise using Numpy arrays for increased performance.    :param x: numpy array of x-coords    :param y: numpy array of y-coords    :param z: numpy array of z-coords    :return:  3D numpy array of shape (z.size, y.size, x.size) with the generated              noise for the supplied coordinates    &gt;&gt;&gt; rng = numpy.random.default_rng(seed=0)    &gt;&gt;&gt; ix, iy, iz = rng.random(2), rng.random(2), rng.random(2)    &gt;&gt;&gt; noise3array(ix, iy, iz)    array([[[0.54942818, 0.54382411],            [0.54285204, 0.53698967]],           [[0.48107672, 0.4881196 ],            [0.45971748, 0.46684901]]])**opensimplex.noise4(x, y, z, w)**    Generate 4D OpenSimplex noise from X,Y,Z,W coordinates.    :param x: x coordinate as float    :param y: y coordinate as float    :param z: z coordinate as float    :param w: w coordinate as float    :return:  generated 4D noise as float, between -1.0 and 1.0    &gt;&gt;&gt; noise4(0.5, 0.5, 0.5, 0.5)    0.04520359600370195**opensimplex.noise4array(x, y, z, w)**    Generates 4D OpenSimplex noise using Numpy arrays for increased performance.    :param x: numpy array of x-coords    :param y: numpy array of y-coords    :param z: numpy array of z-coords    :param w: numpy array of w-coords    :return:  4D numpy array of shape (w.size, z.size, y.size, x.size) with the              generated noise for the supplied coordinates    &gt;&gt;&gt; rng = numpy.random.default_rng(seed=0)    &gt;&gt;&gt; ix, iy, iz, iw = rng.random(2), rng.random(2), rng.random(2), rng.random(2)    &gt;&gt;&gt; noise4array(ix, iy, iz, iw)    array([[[[0.30334626, 0.29860705],             [0.28271858, 0.27805178]],            [[0.26601215, 0.25305428],             [0.23387872, 0.22151356]]],           [[[0.3392759 , 0.33585534],             [0.3343468 , 0.33118285]],            [[0.36930335, 0.36046537],             [0.36360679, 0.35500328]]]])## FAQ- What does the distribution of the noise values look like?![Noise Distribution](https://github.com/lmas/opensimplex/raw/master/images/distribution.png)- Is this relevantly different enough to avoid any real trouble with theoriginal patent?    &gt; If you read the [patent    &gt; claims](http://www.google.com/patents/US6867776):    &gt;    &gt; Claim #1 talks about the hardware-implementation-optimized    &gt; gradient generator. Most software implementations of Simplex Noise    &gt; don't use this anyway, and OpenSimplex Noise certainly doesn't.    &gt;    &gt; Claim #2(&amp;3&amp;4) talk about using (x',y',z')=(x+s,y+s,z+s) where    &gt; s=(x+y+z)/3 to transform the input (render space) coordinate onto    &gt; a simplical grid, with the intention to make all of the    &gt; &quot;scissor-simplices&quot; approximately regular. OpenSimplex Noise (in    &gt; 3D) uses s=-(x+y+z)/6 to transform the input point to a point on    &gt; the Simplectic honeycomb lattice so that the simplices bounding    &gt; the (hyper)cubes at (0,0,..,0) and (1,1,...,1) work out to be    &gt; regular. It then mathematically works out that s=(x+y+z)/3 is    &gt; needed for the inverse transform, but that's performing a    &gt; different (and opposite) function.    &gt;    &gt; Claim #5(&amp;6) are specific to the scissor-simplex lattice. Simplex    &gt; Noise divides the (squashed) n-dimensional (hyper)cube into n!    &gt; simplices based on ordered edge traversals, whereas OpenSimplex    &gt; Noise divides the (stretched) n-dimensional (hyper)cube into n    &gt; polytopes (simplices, rectified simplices, birectified simplices,    &gt; etc.) based on the separation (hyper)planes at integer values of    &gt; (x'+y'+z'+...).    &gt;    &gt; Another interesting point is that, if you read all of the claims,    &gt; none of them appear to apply to the 2D analogue of Simplex noise    &gt; so long as it uses a gradient generator separate from the one    &gt; described in claim #1. The skew function in Claim #2 only    &gt; applies to 3D, and #5 explicitly refers to n&gt;=3.    &gt;    &gt; And none of the patent claims speak about using surflets /    &gt; &quot;spherically symmetric kernels&quot; to generate the &quot;images with    &gt; texture that do not have visible grid artifacts,&quot; which is    &gt; probably the biggest similarity between the two algorithms.    &gt;    &gt; - **Kurt**, on [Reddit].[Reddit]: https://www.reddit.com/r/proceduralgeneration/comments/2gu3e7/like_perlins_simplex_noise_but_dont_like_the/ckmqz2y## Credits- Kurt Spencer - Original work- Owen Raccuglia - Test cases, [Go Module]- /u/redblobgames - Fixed conversion for Java's long type, see [Reddit]And all the other Github [Contributors] and [Bug Hunters]. Thanks![Go Module]: https://github.com/ojrac/opensimplex-go[Reddit]: https://old.reddit.com/r/proceduralgeneration/comments/327zkm/repeated_patterns_in_opensimplex_python_port/cq8tth7/[Contributors]: https://github.com/lmas/opensimplex/graphs/contributors[Bug Hunters]: https://github.com/lmas/opensimplex/issues?q=is%3Aclosed## LicenseWhile the original work was released to the public domain by Kurt, this package is using the MIT license.Please see the file LICENSE for details.## Example OutputMore example code and trinkets can be found in the [examples] directory.[examples]: https://github.com/lmas/opensimplex/tree/master/examplesExample images visualising 2D, 3D and 4D noise on a 2D plane, using the default seed:**2D noise**![Noise 2D](https://github.com/lmas/opensimplex/raw/master/images/noise2d.png)**3D noise**![Noise 3D](https://github.com/lmas/opensimplex/raw/master/images/noise3d.png)**4D noise**![Noise 4D](https://github.com/lmas/opensimplex/raw/master/images/noise4d.png)</longdescription>
</pkgmetadata>