<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![image](https://img.shields.io/badge/pypi-v2.9.0-blue.svg)](https://pypi.org/project/moler/)[![image](https://img.shields.io/badge/python-2.7%20%7C%203.6%20%7C%203.7%20%7C%203.8%20%7C%203.9%20%7C%203.10-blue.svg)](https://pypi.org/project/moler/)[![Build Status](https://travis-ci.org/nokia/moler.svg?branch=master)](https://travis-ci.org/nokia/moler)[![Coverage Status](https://coveralls.io/repos/github/nokia/moler/badge.svg?branch=master)](https://coveralls.io/github/nokia/moler?branch=master)[![BCH compliance](https://bettercodehub.com/edge/badge/nokia/moler?branch=master)](https://bettercodehub.com/)[![Codacy Badge](https://api.codacy.com/project/badge/Grade/355afc9110f34d549b7c08c33961827c)](https://www.codacy.com/app/mplichta/moler?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=nokia/moler&amp;amp;utm_campaign=Badge_Grade)[![License](https://img.shields.io/badge/License-BSD%203--Clause-blue.svg)](./LICENSE)# Table of Contents1. [Changelog](#changelog)2. [Moler info](#moler)3. [Moler usage examples](#moler-usage-examples)4. [API design reasoning](#api-design-reasoning)5. [Designed API](#designed-api)# ChangelogView our [chronological list](./CHANGELOG.md) of user-facing changes, large and small, made to the Moler project.![moler logo](https://i.imgur.com/mkPutdC.png)# MolerMoler ([name origin](https://github.com/nokia/moler/wiki#moler-name-origin)) is Python librarythat provides &quot;bricks&quot; for building  automated tests.All these &quot;bricks&quot; have clearly defined responsibilities, have similar API,follow same construction pattern (so new ones are easy to create).Here they are:* Commands as self-reliant object  * to allow for command triggering and parsing encapsulated in single object (lower maintenance cost)* Event observers &amp; callbacks (alarms are events example)  * to allow for online reaction (not offline postprocessing)* Run observers/commands in the background  * to allow for test logic decomposition into multiple commands running in parallel  * to allow for handling unexpected system behavior (reboots, alarms)* State machines -&gt; automatic auto-connecting after dropped connection  * to increase framework auto-recovery and help in troubleshooting &quot;what went wrong&quot;* Automatic logging of all connections towards devices used by tests  * to decrease investigation time by having logs focused on different parts of system under test# Moler usage examplesLet's see Moler in action. Here is hypothetical use case: &quot;find PIDs of all python processes&quot;:```python    from moler.config import load_config    from moler.device.device import DeviceFactory    load_config(config='my_devices.yml')                    # description of available devices    my_unix = DeviceFactory.get_device(name='MyMachine')    # take specific device out of available ones    ps_cmd = my_unix.get_cmd(cmd_name=&quot;ps&quot;,                 # take command of that device                             cmd_params={&quot;options&quot;: &quot;-ef&quot;})    processes_info = ps_cmd()                               # run the command, it returns result    for proc_info in processes_info:        if 'python' in proc_info['CMD']:            print(&quot;PID: {info[PID]} CMD: {info[CMD]}&quot;.format(info=proc_info))```* To have command we ask device &quot;give me such command&quot;.* To run command we just call it as function (command object is callable)* What command returns is usually dict or list of dicts - easy to processAbove code displays:```bash    PID: 1817 CMD: /usr/bin/python /usr/share/system-config-printer/applet.py    PID: 21825 CMD: /usr/bin/python /home/gl/moler/examples/command/unix_ps.py```How does it know what `'MyMachine'` means? Code loads definition from `my_devices.yml` configuration file:```yaml    DEVICES:      MyMachine:        DEVICE_CLASS: moler.device.unixlocal.UnixLocal      RebexTestMachine:        DEVICE_CLASS: moler.device.unixremote.UnixRemote        CONNECTION_HOPS:          UNIX_LOCAL:                # from state            UNIX_REMOTE:             # to state              execute_command: ssh   # via command              command_params:        # with params                expected_prompt: demo@                host: test.rebex.net                login: demo                password: password                set_timeout: False   # remote doesn't support: export TMOUT```We have remote machine in our config. Let's check if there is 'readme.txt' fileon that machine (and some info about the file):```python    remote_unix = DeviceFactory.get_device(name='RebexTestMachine')  # it starts in local shell    remote_unix.goto_state(state=&quot;UNIX_REMOTE&quot;)                      # make it go to remote shell    ls_cmd = remote_unix.get_cmd(cmd_name=&quot;ls&quot;, cmd_params={&quot;options&quot;: &quot;-l&quot;})    remote_files = ls_cmd()    if 'readme.txt' in remote_files['files']:        print(&quot;readme.txt file:&quot;)        readme_file_info = remote_files['files']['readme.txt']        for attr in readme_file_info:            print(&quot;  {:&lt;18}: {}&quot;.format(attr, readme_file_info[attr]))```As you may noticed device is state machine. State transitions are defined insideconfiguration file under `CONNECTION_HOPS`. Please note, that it is only config file whoknows &quot;I need to use ssh to be on remote&quot; - client code just says &quot;go to remote&quot;.Thanks to that you can exchange &quot;how to reach remote&quot; without any change in main code.Above code displays:```bash    readme.txt file:      permissions       : -rw-------      hard_links_count  : 1      owner             : demo      group             : users      size_raw          : 403      size_bytes        : 403      date              : Apr 08  2014      name              : readme.txt```How about doing multiple things in parallel. Let's ping googlewhile asking test.rebex.net about readme.txt file:```pythonmy_unix = DeviceFactory.get_device(name='MyMachine')host = 'www.google.com'ping_cmd = my_unix.get_cmd(cmd_name=&quot;ping&quot;, cmd_params={&quot;destination&quot;: host, &quot;options&quot;: &quot;-w 6&quot;})remote_unix = DeviceFactory.get_device(name='RebexTestMachine')remote_unix.goto_state(state=&quot;UNIX_REMOTE&quot;)ls_cmd = remote_unix.get_cmd(cmd_name=&quot;ls&quot;, cmd_params={&quot;options&quot;: &quot;-l&quot;})print(&quot;Start pinging {} ...&quot;.format(host))ping_cmd.start()                                # run command in backgroundprint(&quot;Let's check readme.txt at {} while pinging {} ...&quot;.format(remote_unix.name, host))remote_files = ls_cmd()                         # foreground &quot;run in the meantime&quot;file_info = remote_files['files']['readme.txt']print(&quot;readme.txt file: owner={fi[owner]}, size={fi[size_bytes]}&quot;.format(fi=file_info))ping_stats = ping_cmd.await_done(timeout=6)     # await background commandprint(&quot;ping {}: {}={}, {}={} [{}]&quot;.format(host,'packet_loss',                                          ping_stats['packet_loss'],                                          'time_avg',                                          ping_stats['time_avg'],                                          ping_stats['time_unit']))``````logStart pinging www.google.com ...Let's check readme.txt at RebexTestMachine while pinging www.google.com ...readme.txt file: owner=demo, size=403ping www.google.com: packet_loss=0, time_avg=35.251 [ms]```Besides being callable command-object works as &quot;Future&quot; (result promise).You can start it in background and later await till it is done to grab result.If we enhance our configuration with logging related info:```yaml    LOGGER:      PATH: ./logs      DATE_FORMAT: &quot;%H:%M:%S&quot;```then above code will automatically create Molers' main log (`moler.log`)which shows activity on all devices:```log22:30:19.723 INFO       moler               |More logs in: ./logs22:30:19.747 INFO       MyMachine           |Connection to: 'MyMachine' has been opened.22:30:19.748 INFO       MyMachine           |Changed state from 'NOT_CONNECTED' into 'UNIX_LOCAL'22:30:19.866 INFO       MyMachine           |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('^moler_bash#')]' started.22:30:19.901 INFO       RebexTestMachine    |Connection to: 'RebexTestMachine' has been opened.22:30:19.901 INFO       RebexTestMachine    |Changed state from 'NOT_CONNECTED' into 'UNIX_LOCAL'22:30:19.919 INFO       RebexTestMachine    |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('demo@')]' started.22:30:19.920 INFO       RebexTestMachine    |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('^moler_bash#')]' started.22:30:19.921 INFO       RebexTestMachine    |Command 'moler.cmd.unix.ssh.Ssh':'TERM=xterm-mono ssh -l demo test.rebex.net' started.22:30:19.921 INFO       RebexTestMachine    |TERM=xterm-mono ssh -l demo test.rebex.net22:30:20.763 INFO       RebexTestMachine    |*********22:30:20.909 INFO       RebexTestMachine    |Changed state from 'UNIX_LOCAL' into 'UNIX_REMOTE'22:30:20.917 INFO       RebexTestMachine    |Command 'moler.cmd.unix.ssh.Ssh' finished.22:30:20.919 INFO       MyMachine           |Command 'moler.cmd.unix.ping.Ping':'ping www.google.com -w 6' started.22:30:20.920 INFO       MyMachine           |ping www.google.com -w 622:30:20.920 INFO       RebexTestMachine    |Command 'moler.cmd.unix.ls.Ls':'ls -l' started.22:30:20.922 INFO       RebexTestMachine    |ls -l22:30:20.985 INFO       RebexTestMachine    |Command 'moler.cmd.unix.ls.Ls' finished.22:30:26.968 INFO       MyMachine           |Command 'moler.cmd.unix.ping.Ping' finished.22:30:26.992 INFO       RebexTestMachine    |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('^moler_bash#')]' finished.22:30:27.011 INFO       RebexTestMachine    |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('demo@')]' finished.22:30:27.032 INFO       MyMachine           |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('^moler_bash#')]' finished.```As you may noticed main log shows code progress from high-level view - dataon connections are not visible, just activity of commands running on devices.If you want to see in details what has happened on each device - you have it in device logs.Moler creates log per each device`moler.RebexTestMachine.log`:```log22:30:19.901  |Changed state from 'NOT_CONNECTED' into 'UNIX_LOCAL'22:30:19.902 &lt;|22:30:19.919  |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('demo@')]' started.22:30:19.920  |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('^moler_bash#')]' started.22:30:19.921  |Command 'moler.cmd.unix.ssh.Ssh':'TERM=xterm-mono ssh -l demo test.rebex.net' started.22:30:19.921 &gt;|TERM=xterm-mono ssh -l demo test.rebex.net22:30:19.924 &lt;|TERM=xterm-mono ssh -l demo test.rebex.net22:30:20.762 &lt;|Password:22:30:20.763 &gt;|*********22:30:20.763 &lt;|22:30:20.908 &lt;|Welcome to Rebex Virtual Shell!              |For a list of supported commands, type 'help'.              |demo@ETNA:/$22:30:20.909  |Changed state from 'UNIX_LOCAL' into 'UNIX_REMOTE'22:30:20.917  |Command 'moler.cmd.unix.ssh.Ssh' finished.22:30:20.920  |Command 'moler.cmd.unix.ls.Ls':'ls -l' started.22:30:20.922 &gt;|ls -l22:30:20.974 &lt;|ls -l22:30:20.978 &lt;|drwx------ 2 demo users          0 Jul 26  2017 .22:30:20.979 &lt;|drwx------ 2 demo users          0 Jul 26  2017 ..              |drwx------ 2 demo users          0 Dec 03  2015 aspnet_client              |drwx------ 2 demo users          0 Oct 27  2015 pub              |-rw------- 1 demo users        403 Apr 08  2014 readme.txt              |demo@ETNA:/$22:30:20.985  |Command 'moler.cmd.unix.ls.Ls' finished.22:30:26.992  |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('^moler_bash#')]' finished.22:30:27.011  |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('demo@')]' finished.```and `moler.MyMachine.log`:```log22:30:19.748  |Changed state from 'NOT_CONNECTED' into 'UNIX_LOCAL'22:30:19.748 &lt;|22:30:19.866  |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('^moler_bash#')]' started.22:30:20.919  |Command 'moler.cmd.unix.ping.Ping':'ping www.google.com -w 6' started.22:30:20.920 &gt;|ping www.google.com -w 622:30:20.921 &lt;|ping www.google.com -w 622:30:20.959 &lt;|PING www.google.com (216.58.215.68) 56(84) bytes of data.22:30:20.960 &lt;|22:30:21.000 &lt;|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=1 ttl=51 time=40.1 ms22:30:21.001 &lt;|22:30:21.992 &lt;|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=2 ttl=51 time=31.0 ms22:30:22.999 &lt;|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=3 ttl=51 time=36.5 ms22:30:23.996 &lt;|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=4 ttl=51 time=31.4 ms22:30:24.996 &lt;|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=5 ttl=51 time=29.8 ms22:30:26.010 &lt;|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=6 ttl=51 time=42.4 ms22:30:26.960 &lt;|              |--- www.google.com ping statistics ---              |6 packets transmitted, 6 received, 0% packet loss, time 5007ms              |rtt min/avg/max/mdev = 29.888/35.251/42.405/4.786 ms              |moler_bash#22:30:26.968  |Command 'moler.cmd.unix.ping.Ping' finished.22:30:27.032  |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('^moler_bash#')]' finished.```If the log files are too large you can split files.The log files can be split by size. For example let's assume we want split log files by 5 MB (5242880 bytes) and we wantto keep maximum 999 files:```yaml    LOGGER:      PATH: ./logs      DATE_FORMAT: &quot;%H:%M:%S&quot;      LOG_ROTATION:        KIND: size        INTERVAL: 5242880        BACKUP_COUNT: 999  # Default value      ```The log files can be split by time. For example let's assume we want split log files every 30 minutes (1800 seconds) and we want to keep maximum 999 files (default value): ```yaml    LOGGER:      PATH: ./logs      DATE_FORMAT: &quot;%H:%M:%S&quot;      LOG_ROTATION:        KIND: time        INTERVAL: 1800        BACKUP_COUNT: 999  # Default value```For space saving Moler can compress the logs after rotation. The external tool is used. Let's use the above examplesto show how to compress logs:```yaml    LOGGER:      PATH: ./logs      DATE_FORMAT: &quot;%H:%M:%S&quot;      LOG_ROTATION:        KIND: size        INTERVAL: 5242880        BACKUP_COUNT: 999  # Default value        COMPRESS_AFTER_ROTATION: True  # Default is False        COMPRESS_COMMAND: &quot;zip -9mq {compressed} {log_input}&quot;  # Default value        COMPRESSED_FILE_EXTENSION: &quot;.zip&quot;  # Default value``````yaml    LOGGER:      PATH: ./logs      DATE_FORMAT: &quot;%H:%M:%S&quot;      LOG_ROTATION:        KIND: time        INTERVAL: 1800        BACKUP_COUNT: 999  # Default value        COMPRESS_COMMAND: &quot;zip -9mq {compressed} {log_input}&quot;  # Default value              COMPRESSED_FILE_EXTENSION: &quot;.zip&quot;  # Default value```In a script we can also disable logging from device. Please use it very carefully. Investigation any issue may be impossible if we don't have full logs. ```pythonmy_unix = DeviceFactory.get_device(name='MyMachine')my_unix.disbale_logging()  # to disable logging on devicemy_unix.enable_logging()  # to enable logging on device```In a script you can add suffix to all log files or only to files for specific devices. with disable logging from device.  ```pythonfrom moler.config.loggers import change_logging_suffixchange_logging_suffix(&quot;.suffix1&quot;)  # all log files with suffixchange_logging_suffix(None)  # all log files without suffxmy_unix = DeviceFactory.get_device(name='MyMachine')my_unix.set_logging_suffix(&quot;device_suffix&quot;)  # to add suffix to filename with logsmy_unix.set_suffix(None)  # to remove suffix from filename with logs```Previous examples ask device to create command. We can also create command ourselvesgiving it connection to operate on:```python    import time    from moler.cmd.unix.ping import Ping    from moler.connection_factory import get_connection    host = 'www.google.com'    terminal = get_connection(io_type='terminal', variant='threaded')  # take connection    with terminal.open():        ping_cmd = Ping(connection=terminal.moler_connection,                        destination=host, options=&quot;-w 6&quot;)        print(&quot;Start pinging {} ...&quot;.format(host))        ping_cmd.start()        print(&quot;Doing other stuff while pinging {} ...&quot;.format(host))        time.sleep(3)        ping_stats = ping_cmd.await_done(timeout=4)        print(&quot;ping {}: {}={}, {}={} [{}]&quot;.format(host,'packet_loss',                                                  ping_stats['packet_loss'],                                                  'time_avg',                                                  ping_stats['time_avg'],                                                  ping_stats['time_unit']))```Please note also that connection is context manager doing open/close actions.```bash    Start pinging www.google.com ...    Doing other stuff while pinging www.google.com ...    ping www.google.com: packet_loss=0, time_avg=50.000 [ms]```## Reuse freedomLibrary gives you freedom which part you want to reuse. We are fan's of &quot;take what you need only&quot;.* You may use configuration files or configure things by Python calls.   ```python   load_config(config={'DEVICES': {'MyMachine': {'DEVICE_CLASS': 'moler.device.unixlocal.UnixLocal'}}})   ```* You may use devices or create commands manually* You can take connection or build it yourself:   ```python   from moler.threaded_moler_connection import ThreadedMolerConnection   from moler.io.raw.terminal import ThreadedTerminal   terminal_connection = ThreadedTerminal(moler_connection=ThreadedMolerConnection())   ```* You can even install your own implementation in place of default implementation per connection type# API design reasoningThe main goal of command is its usage simplicity: just run it and give me back its result.Command hides from its caller:* a way how it realizes &quot;runs&quot;* how it gets data of output to be parsed* how it parses that dataCommand shows to its caller:* API to start/stop it or await for its completion* API to query for its result or result readinessCommand works as [Futures and promises](https://en.wikipedia.org/wiki/Futures_and_promises)After starting, we await for its result which is parsed out command output provided usually as dict.Running that command and parsing its output may take some time, so till that point result computation is yet incomplete.## Command as future* it starts some command on device/shell over connection  (as future-function starts it's execution)* it parses data incoming over such connection  (as future-function does it's processing)* it stores result of that parsing  (as future-function concludes in calculation result)* it provides means to return that result  (as future-function does via 'return' or 'yield' statement)* it's result is not ready &quot;just-after&quot; calling command  (as it is with future in contrast to function)So command should have future API.Quote from **_&quot;Professional Python&quot;_** by **Luke Sneeringer**:&gt; The Future is a standalone object. It is independent of the actual function that is running.&gt; It does nothing but store the state and result information.Command differs in that it is both:* function-like object performing computation* future-like object storing result of that computation.## Command vs. Connection-observerCommand is just &quot;active version&quot; of connection observer.Connection observer is passive since it just observes connection for some data;data that may just asynchronously appear (alarms, reboots or anything you want).Intention here is split of responsibility: one observer is looking for alarms,another one for reboots.Command is active since it actively triggers some output on connectionby sending command-string over that connection. So, it activates some actionon device-behind-connection. That action is &quot;command&quot; in device terminology.Like `ping` on bash console/device. And it produces that &quot;command&quot; output.That output is what Moler's Command as connection-observer is looking for.## Most well known Python's futures* [concurrent.futures.Future](https://docs.python.org/3/library/concurrent.futures.html)* [asyncio.Future](https://docs.python.org/3/library/asyncio-task.html#future)| API                     | concurrent.futures.Future                   | asyncio.Future                                      || :---------------------- | :------------------------------------------ | :-------------------------------------------------- || storing result          | :white_check_mark: `set_result()`           | :white_check_mark: `set_result()`                   || result retrieval        | :white_check_mark: `result()`               | :white_check_mark: `result()`                       || storing failure cause   | :white_check_mark: `set_exception()`        | :white_check_mark: `set_exception()`                || failure cause retrieval | :white_check_mark: `exception()`            | :white_check_mark: `exception()`                    || stopping                | :white_check_mark: `cancel()`               | :white_check_mark: `cancel()`                       || check if stopped        | :white_check_mark: `cancelled()`            | :white_check_mark: `cancelled()`                    || check if running        | :white_check_mark: `running()`              | :no_entry_sign: `(but AbstractEventLoop.running())` || check if completed      | :white_check_mark: `done()`                 | :white_check_mark: `done()`                         || subscribe completion    | :white_check_mark: `add_done_callback()`    | :white_check_mark: `add_done_callback()`            || unsubscribe completion  | :no_entry_sign:                             | :white_check_mark: `remove_done_callback()`         |Starting callable to be run &quot;as future&quot; is done by entities external to future-object| API              | concurrent.futures&lt;br&gt;start via Executor objects (thread/proc) | asyncio&lt;br&gt;start via module-lvl functions or ev-loop || ---------------- | ---------------------------------------- | ---------------------------------------------- || start callable   | submit(fn, *args, **kwargs)&lt;br&gt;Schedules callable to be executed as&lt;br&gt;fn(*args **kwargs) -&gt; Future | ensure_future(coro_or_future) -&gt; Task&lt;br&gt;future = run_coroutine_threadsafe(coro, loop) || start same callable&lt;br&gt;on data iterator | map(fn, *iterables, timeout) -&gt; iterator | join_future = asyncio.gather(*map(f, iterable))&lt;br&gt;loop.run_until_complete(join_future)|Awaiting completion of future is done by entities external to future-object| API               | concurrent.futures&lt;br&gt;awaiting by module level functions | asyncio&lt;br&gt;awaiting by module-lvl functions or ev-loop || ----------------- | ------------------------------------------ | -------------------------------------------- || await completion  |  done, not_done = wait(futures, timeout) -&gt; futures | done, not_done = await wait(futures)&lt;br&gt;results = await gather(futures)&lt;br&gt;result = await future&lt;br&gt;result = yield from future&lt;br&gt;result = await coroutine&lt;br&gt;result = yield from coroutine&lt;br&gt;result = yield from wait_for(future, timeout)&lt;br&gt;loop.run_until_complete(future) -&gt; blocking run || process as they&lt;br&gt;complete | for done in as_completed(futures, timeout) -&gt; futures | for done in as_completed(futures, timeout) -&gt; futures |## Fundamental difference of commandContrary to **concurrent.futures** and **asyncio** we don't want command to be run by some external entity.We want it to be self-executable for usage simplicity.We want to take command and just say to it:* **&quot;run&quot;** or **&quot;run in background&quot;*** and not **&quot;Hi, external runner, would you run/run-background that command for me&quot;**# Designed API1. create command object``` pythoncommand = Command()```2. run it synchronously/blocking and get result in one shot behaves like function call since Command is callable.Run-as-callable gives big advantage since it fits well in python ecosystem.``` pythonresult = command()```function example:``` pythonmap(ping_cmd, all_machines_to_validate_reachability)```3. run it asynchronously/nonblocking``` pythoncommand_as_future = command.start()```4. shift from background to foreground**asyncio:** variant looks like:``` pythonresult = await futuredone_futures, pending = yield from asyncio.wait(futures)result = yield from asyncio.wait_for(future, 60.0)```and **concurrent.futures** variant looks like:``` pythondone_futures, pending = wait(futures)```Moler's API maps to above well-known API``` pythonresult = command.await_done(timeout)```* it is &quot;internal&quot; to command &quot;Hi command, that is what I want from you&quot; (above APIs say &quot;Hi you there, that is what I want you to do with command&quot;)* it directly (Zen of Python) shows what we are awaiting for* timeout is required parameter (not as in concurrent.futures) since we don't expect endless execution of command (user must know what is worst case timeout to await command completion)# Video introductionYou can [watch videos how to use Moler on YouTube](https://www.youtube.com/channel/UCgToo2qq8kLMyEgzd4btM9g). </longdescription>
</pkgmetadata>