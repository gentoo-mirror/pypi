<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>======Result======.. image:: https://img.shields.io/github/actions/workflow/status/rustedpy/result/ci.yml?branch=master    :alt: GitHub Workflow Status (branch)    :target: https://github.com/rustedpy/result/actions/workflows/ci.yml?query=branch%3Amaster.. image:: https://codecov.io/gh/rustedpy/result/branch/master/graph/badge.svg    :alt: Coverage    :target: https://codecov.io/gh/rustedpy/resultA simple Result type for Python 3 `inspired by Rust&lt;https://doc.rust-lang.org/std/result/&gt;`__, fully type annotated.Installation============Latest release:.. sourcecode:: sh   $ pip install resultLatest GitHub ``master`` branch version:.. sourcecode:: sh   $ pip install git+https://github.com/rustedpy/resultSummary=======The idea is that a result value can be either ``Ok(value)`` or ``Err(error)``,with a way to differentiate between the two. ``Ok`` and ``Err`` are both classesencapsulating an arbitrary value. ``Result[T, E]`` is a generic type alias for``typing.Union[Ok[T], Err[E]]``. It will change code like this:.. sourcecode:: python    def get_user_by_email(email: str) -&gt; Tuple[Optional[User], Optional[str]]:        &quot;&quot;&quot;        Return the user instance or an error message.        &quot;&quot;&quot;        if not user_exists(email):            return None, 'User does not exist'        if not user_active(email):            return None, 'User is inactive'        user = get_user(email)        return user, None    user, reason = get_user_by_email('ueli@example.com')    if user is None:        raise RuntimeError('Could not fetch user: %s' % reason)    else:        do_something(user)To something like this:.. sourcecode:: python    from result import Ok, Err, Result, is_ok, is_err    def get_user_by_email(email: str) -&gt; Result[User, str]:        &quot;&quot;&quot;        Return the user instance or an error message.        &quot;&quot;&quot;        if not user_exists(email):            return Err('User does not exist')        if not user_active(email):            return Err('User is inactive')        user = get_user(email)        return Ok(user)    user_result = get_user_by_email(email)    if isinstance(user_result, Ok): # or `is_ok(user_result)`        # type(user_result.value) == User        do_something(user_result.value)    else: # or `elif is_err(user_result)`        # type(user_result.value) == str        raise RuntimeError('Could not fetch user: %s' % user_result.value)And if you're using python version ``3.10`` or later, you can use the elegant ``match`` statement as well:.. sourcecode:: python    from result import Result, Ok, Err    def divide(a: int, b: int) -&gt; Result[int, str]:        if b == 0:            return Err(&quot;Cannot divide by zero&quot;)        return Ok(a // b)    values = [(10, 0), (10, 5)]    for a, b in values:        divide_result = divide(a, b)        match divide_result:            case Ok(value):                print(f&quot;{a} // {b} == {value}&quot;)            case Err(e):                print(e)Not all methods (https://doc.rust-lang.org/std/result/enum.Result.html) havebeen implemented, only the ones that make sense in the Python context. By using``isinstance`` to check for ``Ok`` or ``Err`` you get type safe access to thecontained value when using `MyPy &lt;https://mypy.readthedocs.io/&gt;`__ to typecheckyour code. All of this in a package allowing easier handling of values that canbe OK or not, without resorting to custom exceptions.API===Creating an instance:.. sourcecode:: python    &gt;&gt;&gt; from result import Ok, Err    &gt;&gt;&gt; res1 = Ok('yay')    &gt;&gt;&gt; res2 = Err('nay')Checking whether a result is ``Ok`` or ``Err``. You can either use ``is_ok``and ``is_err`` type guard **functions** or ``isinstance``. This way you gettype safe access that can be checked with MyPy. The ``is_ok()`` or ``is_err()``**methods** can be used if you don't need the type safety with MyPy:.. sourcecode:: python    &gt;&gt;&gt; res = Ok('yay')    &gt;&gt;&gt; isinstance(res, Ok)    True    &gt;&gt;&gt; is_ok(res)    True    &gt;&gt;&gt; isinstance(res, Err)    False    &gt;&gt;&gt; is_err(res)    False    &gt;&gt;&gt; res.is_ok()    True    &gt;&gt;&gt; res.is_err()    FalseYou can also check if an object is ``Ok`` or ``Err`` by using the ``OkErr`` type.Please note that this type is designed purely for convenience, and should not be usedfor anything else. Using ``(Ok, Err)`` also works fine:.. sourcecode:: python    &gt;&gt;&gt; res1 = Ok('yay')    &gt;&gt;&gt; res2 = Err('nay')    &gt;&gt;&gt; isinstance(res1, OkErr)    True    &gt;&gt;&gt; isinstance(res2, OkErr)    True    &gt;&gt;&gt; isinstance(1, OkErr)    False    &gt;&gt;&gt; isinstance(res1, (Ok, Err))    TrueConvert a ``Result`` to the value or ``None``:.. sourcecode:: python    &gt;&gt;&gt; res1 = Ok('yay')    &gt;&gt;&gt; res2 = Err('nay')    &gt;&gt;&gt; res1.ok()    'yay'    &gt;&gt;&gt; res2.ok()    NoneConvert a ``Result`` to the error or ``None``:.. sourcecode:: python    &gt;&gt;&gt; res1 = Ok('yay')    &gt;&gt;&gt; res2 = Err('nay')    &gt;&gt;&gt; res1.err()    None    &gt;&gt;&gt; res2.err()    'nay'Access the value directly, without any other checks:.. sourcecode:: python    &gt;&gt;&gt; res1 = Ok('yay')    &gt;&gt;&gt; res2 = Err('nay')    &gt;&gt;&gt; res1.value    'yay'    &gt;&gt;&gt; res2.value    'nay'Note that this is a property, you cannot assign to it. Results are immutable.For your convenience, simply creating an ``Ok`` result without value is the same as using ``True``:.. sourcecode:: python    &gt;&gt;&gt; res1 = Ok()    &gt;&gt;&gt; res1.value    TrueThe ``unwrap`` method returns the value if ``Ok`` and ``unwrap_err`` methodreturns the error value if ``Err``, otherwise it raises an ``UnwrapError``:.. sourcecode:: python    &gt;&gt;&gt; res1 = Ok('yay')    &gt;&gt;&gt; res2 = Err('nay')    &gt;&gt;&gt; res1.unwrap()    'yay'    &gt;&gt;&gt; res2.unwrap()    Traceback (most recent call last):    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;    File &quot;C:\project\result\result.py&quot;, line 107, in unwrap        return self.expect(&quot;Called `Result.unwrap()` on an `Err` value&quot;)    File &quot;C:\project\result\result.py&quot;, line 101, in expect        raise UnwrapError(message)    result.result.UnwrapError: Called `Result.unwrap()` on an `Err` value    &gt;&gt;&gt; res1.unwrap_err()    Traceback (most recent call last):    ...    &gt;&gt;&gt;res2.unwrap_err()    'nay'A custom error message can be displayed instead by using ``expect`` and ``expect_err``:.. sourcecode:: python    &gt;&gt;&gt; res1 = Ok('yay')    &gt;&gt;&gt; res2 = Err('nay')    &gt;&gt;&gt; res1.expect('not ok')    'yay'    &gt;&gt;&gt; res2.expect('not ok')    Traceback (most recent call last):    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;    File &quot;C:\project\result\result.py&quot;, line 101, in expect        raise UnwrapError(message)    result.result.UnwrapError: not ok    &gt;&gt;&gt; res1.expect_err('not err')    Traceback (most recent call last):    ...    &gt;&gt;&gt; res2.expect_err('not err')    'nay'A default value can be returned instead by using ``unwrap_or`` or ``unwrap_or_else``:.. sourcecode:: python    &gt;&gt;&gt; res1 = Ok('yay')    &gt;&gt;&gt; res2 = Err('nay')    &gt;&gt;&gt; res1.unwrap_or('default')    'yay'    &gt;&gt;&gt; res2.unwrap_or('default')    'default'    &gt;&gt;&gt; res1.unwrap_or_else(str.upper)    'yay'    &gt;&gt;&gt; res2.unwrap_or_else(str.upper)    'NAY'The ``unwrap`` method will raised an ``UnwrapError``. A custom exception can beraised by using the ``unwrap_or_raise`` method instead:.. sourcecode:: python    &gt;&gt;&gt; res1 = Ok('yay')    &gt;&gt;&gt; res2 = Err('nay')    &gt;&gt;&gt; res1.unwrap_or_raise(ValueError)    'yay'    &gt;&gt;&gt; res2.unwrap_or_raise(ValueError)    ValueError: nayValues and errors can be mapped using ``map``, ``map_or``, ``map_or_else`` and``map_err``:.. sourcecode:: python   &gt;&gt;&gt; Ok(1).map(lambda x: x + 1)   Ok(2)   &gt;&gt;&gt; Err('nay').map(lambda x: x + 1)   Err('nay')   &gt;&gt;&gt; Ok(1).map_or(-1, lambda x: x + 1)   2   &gt;&gt;&gt; Err(1).map_or(-1, lambda x: x + 1)   -1   &gt;&gt;&gt; Ok(1).map_or_else(lambda: 3, lambda x: x + 1)   2   &gt;&gt;&gt; Err('nay').map_or_else(lambda: 3, lambda x: x + 1)   3   &gt;&gt;&gt; Ok(1).map_err(lambda x: x + 1)   Ok(1)   &gt;&gt;&gt; Err(1).map_err(lambda x: x + 1)   Err(2)To save memory, both the ``Ok`` and ``Err`` classes are ‘slotted’,i.e. they define ``__slots__``. This means assigning arbitraryattributes to instances will raise ``AttributeError``.The ``as_result()`` decorator can be used to quickly turn ‘normal’functions into ``Result`` returning ones by specifying one or moreexception types:.. sourcecode:: python    @as_result(ValueError, IndexError)    def f(value: int) -&gt; int:        if value == 0:            raise ValueError  # becomes Err        elif value == 1:            raise IndexError  # becomes Err        elif value == 2:            raise KeyError  # raises Exception        else:            return value  # becomes Ok    res = f(0)  # Err[ValueError()]    res = f(1)  # Err[IndexError()]    res = f(2)  # raises KeyError    res = f(3)  # Ok[3]``Exception`` (or even ``BaseException``) can be specified to create a‘catch all’ ``Result`` return type. This is effectively the same as``try`` followed by ``except Exception``, which is not considered goodpractice in most scenarios, and hence this requires explicit opt-in.Since ``as_result`` is a regular decorator, it can be used to wrapexisting functions (also from other libraries), albeit with a slightlyunconventional syntax (without the usual ``@``):.. sourcecode:: python    import third_party    x = third_party.do_something(...)  # could raise; who knows?    safe_do_something = as_result(Exception)(third_party.do_something)    res = safe_do_something(...)  # Ok(...) or Err(...)    if isinstance(res, Ok):        print(res.value)FAQ===- **Why do I get the &quot;Cannot infer type argument&quot; error with MyPy?**There is `a bug in MyPy&lt;https://github.com/python/mypy/issues/230&gt;`_ which can be triggered in some scenarios.Using ``if isinstance(res, Ok)`` instead of ``if res.is_ok()`` will help in some cases.Otherwise using `one of these workarounds&lt;https://github.com/python/mypy/issues/3889#issuecomment-325997911&gt;`_ can help.License=======MIT License</longdescription>
</pkgmetadata>