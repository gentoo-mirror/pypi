<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># WSRPC aiohttp[![Github Actions](https://github.com/wsrpc/wsrpc-aiohttp/workflows/tests/badge.svg)](https://github.com/wsrpc/wsrpc-aiohttp/actions?query=branch%3Amaster)[![Coveralls](https://coveralls.io/repos/github/wsrpc/wsrpc-aiohttp/badge.svg?branch=master)](https://coveralls.io/github/wsrpc/wsrpc-aiohttp?branch=master)[![Latest Version](https://img.shields.io/pypi/v/wsrpc-aiohttp.svg)](https://pypi.python.org/pypi/wsrpc-aiohttp/)[![python wheel](https://img.shields.io/pypi/wheel/wsrpc-aiohttp.svg)](https://pypi.python.org/pypi/wsrpc-aiohttp/)[![Python Versions](https://img.shields.io/pypi/pyversions/wsrpc-aiohttp.svg)](https://pypi.python.org/pypi/wsrpc-aiohttp/)[![license](https://img.shields.io/pypi/l/wsrpc-aiohttp.svg)](https://pypi.python.org/pypi/wsrpc-aiohttp/)Easy to use minimal WebSocket Remote Procedure Call library for aiohttpservers.See [online demo](https://demo.wsrpc.info/) and[documentation](https://docs.wsrpc.info/) with examples.## Features-   Call server functions from the client side;-   Call client functions from the server (for example to notify clients    about events);-   Async connection protocol: both server or client are able to call    several functions and get responses as soon as each response would    be ready in any order.-   Fully async server-side functions;-   Transfer any exceptions from a client side to the server side and    vise versa;-   Ready-to-use frontend-library without dependencies;-   Thread-based websocket handler for writing fully-synchronous backend    code (for synchronous database drivers etc.)-   Protected server-side methods (cliens are not able to call methods,    starting with underline directly);-   Signals for introspection## InstallationInstall via pip:    pip install wsrpc-aiohttpYou may want to install *optional*[ujson](https://pypi.python.org/pypi/ujson) library to speedup messageserialization/deserialization:    pip install ujsonPython module provides client js library out of the box. But for purejavascript applications you can install [standalone js clientlibrary](https://www.npmjs.com/package/@wsrpc/client) using npm:    npm install @wsrpc/client## UsageBackend code:``` pythonimport loggingfrom time import timeimport aiohttp.webfrom wsrpc_aiohttp import Route, STATIC_DIR, WebSocketRoute, decoratorslog = logging.getLogger(__name__)# This class can be called by client.# Connection object will have this class instance after calling route-alias.class TestRoute(Route):    # This method will be executed when client calls route-alias    # for the first time.    def init(self, **kwargs):        # Python __init__ must be return &quot;self&quot;.        # This method might return anything.        return kwargs    # This method named by camelCase because the client can call it.    @decorators.proxy    async def getEpoch(self):        # You can execute functions on the client side        await self.do_notify()        return time()    # This method calls function on the client side    @decorators.proxy    async def do_notify(self):        awesome = 'Somebody executed test1.getEpoch method!'        await self.socket.call('notify', result=awesome)app = aiohttp.web.Application()app.router.add_route(&quot;*&quot;, &quot;/ws/&quot;, WebSocketAsync)  # Websocket routeapp.router.add_static('/js', STATIC_DIR)  # WSRPC js libraryapp.router.add_static('/', &quot;.&quot;)  # Your static files# Stateful request# This is the route alias TestRoute as &quot;test1&quot;WebSocketAsync.add_route('test1', TestRoute)# Stateless requestWebSocketAsync.add_route('test2', lambda *a, **kw: True)if __name__ == '__main__':    logging.basicConfig(level=logging.DEBUG)    aiohttp.web.run_app(app, port=8000)```Frontend code:``` HTML&lt;script type=&quot;text/javascript&quot; src=&quot;/js/wsrpc.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var url = (window.location.protocol===&quot;https):&quot;?&quot;wss://&quot;:&quot;ws://&quot;) + window.location.host + '/ws/';    RPC = new WSRPC(url, 8000);    // Configure client API, that can be called from server    RPC.addRoute('notify', function (data) {        console.log('Server called client route &quot;notify&quot;:', data);        return data.result;    });    RPC.connect();    // Call stateful route    // After you call that route, server would execute 'notify' route on the    // client, that is registered above.    RPC.call('test1.getEpoch').then(function (data) {        console.log('Result for calling server route &quot;test1.getEpoch&quot;: ', data);    }, function (error) {        alert(error);    });    // Call stateless method    RPC.call('test2').then(function (data) {        console.log('Result for calling server route &quot;test2&quot;', data);    });&lt;/script&gt;```## VersioningThis software follows [Semantic Versioning](http://semver.org/)</longdescription>
</pkgmetadata>