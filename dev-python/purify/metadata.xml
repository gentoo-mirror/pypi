<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># purifyPythonic object-mutator transforms as pure functions.## RationaleThis solves a longstanding complaint that I have about Python -there's no Pythonic way to write a pure function that is supposed toreturn a transformed version of an input instance of a class.Specifically, Python heavily incentivizes (via its syntax and viautilities such as `mypy`) doing the following:```def rename_tree(name: str, tree: Tree) -&gt; Tree:    tree.name = name    return tree```because the pure alternatives are either expensive:```def pure_rename_tree(name: str, tree: Tree) -&gt; Tree:    tree = deepcopy(tree)    tree.name = name    return tree```or not Pythonic and not type checkable:```def pure_rename_treedict(name: str, tree: dict) -&gt; dict:    return dict(tree, name=name)```This library is a result of noticing that the first option above isextremely common in our codebases at XOi and enough of a convention tobe a best practice.  While this usually works as long as we composethese &quot;object transforms&quot; as a linear pipeline where no function everneeds to read the pre-transformed object, it is nevertheless aconvention which trades off actual purity for efficiency andreadability.A new decorator, `@purify`, can be applied to any function where asingle one of the arguments will be modified, and by performing abehind-the-scenes shallow copy of that object, allows the objecttransform to become pure without further ado.```@purifydef rename_tree(name: str, tree: Tree) -&gt; Tree:    tree.name = tree    return treetree = Tree('Felicity')dtree = rename_tree('Daniella', tree)print(tree.name) # 'Felicity'print(dtree.name) # 'Daniella'```### Shallow copy vs deepcopyIn rudimentary tests with objects of size &lt; 400 KB, `deepcopy` wasfound to be, not surprisingly, 3 orders or magnitude slower than ashallow copy. Additionally, equality tests on deep-copied and _not_modified objects are 1-2 orders of magnitude slower than shallowcopies, presumably because the shallow copy allows the comparison todo far more `id` equality checks.So, `deepcopy` is expensive. But it's the only way to be sure thatyour function is actually pure. `purify` defaults to shallowcopy. Why?Because, as it turns out, it's frequently pretty simple to splitmutating functions into 'levels' based on the actual object that theymodify, and then decorate each level independently. In most cases,this will mean far fewer Python objects need actual copying, and italso gives you more reusable functions than you would have had if allthe levels were present together.Given:```class Nest:    num_eggs: intclass Tree:    # ... (lots of other attributes)    nests: List[Nest]```This expensive deepcopy approach:```@purify(deep=True)def lay_in_all_nests(add: int, tree: Tree) -&gt; Tree:    for nest in tree.nests:        nest.num_eggs += add    return tree```Could be replaced with the equally pure, and less copy-expensive:```@purifydef lay_in_nest(lay: int, nest: Nest) -&gt; Nest:    nest.num_eggs += add    return nest@purifydef lay_in_all_nests(lay: int, tree: Tree) -&gt; Tree:    tree.nests = [lay_in_nest(lay, nest) for nest in tree.nests]    return tree```#### How to visually parse shallowly pure functionsSome effort is required to use shallow-copy functions properly,whereas `deepcopy` makes your function trivially pure. How to focusthat effort?A good rule of thumb is that the object being purified must only everbe referenced with a single dot (`.`), e.g. `tree.nests`, and usage ofthat dotted name must either be read-only or direct assignment to thatname.  E.g., `tree.nests[i] = foo` is a no-no, because theleft-hand-side of the statement is not the bare name `nests`, butsomething that directs its activity into the list itself.## Advanced Usage:### Argument nameIt's highly recommended to follow a convention where the object thatyou're mutating is the last positional argument to your function. Thisis generally better for the composition of many partially-appliedfunctions transforming the same object.That said, if you have a desire to specify which argument is to beshallow-copied, you may do so by calling the decorator with the firstpositional argument being the name of the function argument you wantpurified.### DeepcopyAs above, if you have a need for deepcopying, you need only to pass`deep=True` to the decorator.</longdescription>
</pkgmetadata>