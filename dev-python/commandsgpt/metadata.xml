<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># CommandsGPTAn implementation of GPT-4 to recognize instructions. It recognizes which commands it must run to fulfill the user's instruction, using a graph where each node is a command and the data generated by each command can be passed to other commands.Create new commands easily by describing them using natural language and coding the functions corresponding to the commands.# Installation* Install the `commandsgpt` module.```pip install commandsgpt```If you're using a virtual environment:```pipenv install commandsgpt```* You also have to install the OpenAI package:```pip install openai```or```pipenv install openai```* Set an environment variable OPENAI_API_KEY to store your OpenAI key.# UsageCreate a `commands` dictionary that will store the commands described in natural language. ```pythoncommands = {    &quot;REQUEST_USER_INPUT&quot;: {        &quot;description&quot;: &quot;Asks the user to input data through the interface.&quot;,        &quot;arguments&quot;: {            &quot;message&quot;: {&quot;description&quot;: &quot;Message displayed to the user related to the data that will be requested (example: 'Enter your age').&quot;, &quot;type&quot;: &quot;string&quot;},        },        &quot;generates_data&quot;: {            &quot;input&quot;: {&quot;description&quot;: &quot;Data entered by the user&quot;, &quot;type&quot;: &quot;string&quot;},        },    },    ...}```Now, create the functions that will be called when the commands are executed.* The name of the function is irrelevant.* The first parameter must be the Config object; the second one must be the Graph object. Normally, you won't work directly with these objects, so you don't have to worry about them. Just use them as the first two parameters.* The following parameters must match those described in the commands dictionary (name and data type).* The return value must be a dictionary. Its keys, values and data types must match the return values described in the commands dictionary.*Example of a command function*```pythonfrom commands_gpt.config import Configfrom commands_gpt.commands.graphs import Graphdef request_user_input_command(config: Config, graph: Graph, message: str) -&gt; dict[str, Any]:    input_ = input(f&quot;{message}\n*: &quot;)    results = {        &quot;input&quot;: input_,    }    return results```Create a `command_name_to_func` dictionary that will take the name of a command and return the corresponding function.*Example of command_name_to_func dictionary*```pythoncommand_name_to_func = {    &quot;REQUEST_USER_INPUT&quot;: request_user_input_command,    ...}```Add the ***essential commands*** to your commands dictionaries.* These are the default commands that implement core logic to the model's thinking, like an IF command.* If you already defined your own core logic commands (IF command, THINK command, CALCULATE command, etc.), then you are free not to use them.```pythonfrom commands_gpt.commands.commands_funcs import add_essential_commandsadd_essential_commands(commands, command_name_to_func)```Your `config` object:```python# keyword arguments are optionalconfig = Config(&quot;gpt-4-0314&quot;, verbosity=1, explain_graph=True, save_graph_as_file=False)```Create an instruction:```pythoninstruction = input(&quot;Enter your instruction: &quot;)```Create a recognizer:```pythonrecognizer = ComplexRecognizer(config, commands, command_name_to_func)```Pass your instruction to the recognizer model:```pythoncommands_data_str = recognizer.recognize(instruction)```Create the graph of commands and execute it:```pythongraph = Graph(recognizer, commands_data_str)graph.execute_commands(config)```# ExampleCreate two files: `custom_commands.py` and `main.py`.## custom_commands.py```pythonfrom typing import Anyfrom pathlib import Pathfrom commands_gpt.config import Configfrom commands_gpt.commands.graphs import Graphcommands = {    &quot;WRITE_TO_USER&quot;: {        &quot;description&quot;: &quot;Writes something to the interface to communicate with the user.&quot;,        &quot;arguments&quot;: {            &quot;content&quot;: {&quot;description&quot;: &quot;Content to write.&quot;, &quot;type&quot;: &quot;string&quot;},        },        &quot;generates_data&quot;: {},    },    &quot;REQUEST_USER_INPUT&quot;: {        &quot;description&quot;: &quot;Asks the user to input data through the interface.&quot;,        &quot;arguments&quot;: {            &quot;message&quot;: {&quot;description&quot;: &quot;Message displayed to the user related to the data that will be requested (example: 'Enter your age').&quot;, &quot;type&quot;: &quot;string&quot;},        },        &quot;generates_data&quot;: {            &quot;input&quot;: {&quot;description&quot;: &quot;Data entered by the user&quot;, &quot;type&quot;: &quot;string&quot;},        },    },    &quot;WRITE_FILE&quot;: {        &quot;description&quot;: &quot;Write a file.&quot;,        &quot;arguments&quot;: {            &quot;content&quot;: {&quot;description&quot;: &quot;Content that will be written.&quot;, &quot;type&quot;: &quot;string&quot;},            &quot;file_path&quot;: {&quot;description&quot;: &quot;Complete path of the file that will be written.&quot;, &quot;type&quot;: &quot;string&quot;},        },        &quot;generates_data&quot;: {},    },}# Commands functions# The name of the function is irrelevant# The first argument must be the Config object, followed by the Graph object# The arguments must match the arguments from the commands dictionary# The return value must be a dictionary which keys must match the &quot;generates_data&quot; keys# The data types must match the ones declared in the commands dictionarydef write_to_user_command(config: Config, graph: Graph, content: str) -&gt; dict[str, Any]:    print(f&quot;&gt;&gt;&gt; {content}&quot;)    return {}def request_user_input_command(config: Config, graph: Graph, message: str) -&gt; dict[str, Any]:    input_ = input(f&quot;{message}\n*: &quot;)    results = {        &quot;input&quot;: input_,    }    return resultsdef write_file_command(config: Config, graph: Graph, content: str, file_path: str) -&gt; dict[str, Any]:    file_dir = Path(file_path).parent    assert file_dir.exists(), f&quot;Container directory '{file_dir}' does not exist.&quot;    with open(file_path, &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f:        f.write(content)        f.close()    return {}# add your functions herecommand_name_to_func = {    &quot;WRITE_TO_USER&quot;: write_to_user_command,    &quot;REQUEST_USER_INPUT&quot;: request_user_input_command,    &quot;WRITE_FILE&quot;: write_file_command,}```## main.py```pythonfrom commands_gpt.recognizers import ComplexRecognizerfrom commands_gpt.commands.graphs import Graphfrom commands_gpt.config import Configfrom custom_commands import commands, command_name_to_funcfrom commands_gpt.commands.commands_funcs import add_essential_commandsadd_essential_commands(commands, command_name_to_func)chat_model = &quot;gpt-4-0314&quot;config = Config(chat_model, verbosity=2, explain_graph=False, save_graph_as_file=False)instruction = input(&quot;Enter your prompt: &quot;)recognizer = ComplexRecognizer(config, commands, command_name_to_func)commands_data_str = recognizer.recognize(instruction)graph = Graph(recognizer, commands_data_str)graph.execute_commands(config)```Copyright (c) 2023, Martín Alexis Martínez Andrade.All rights reserved.Redistribution and use in source and binary forms, with or withoutmodification, are permitted provided that the following conditions aremet:    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.    * Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOTLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FORA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHTOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOTLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANYTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USEOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</longdescription>
</pkgmetadata>