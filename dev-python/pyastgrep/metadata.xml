<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>pyastgrep=========.. image:: https://badge.fury.io/py/pyastgrep.svg     :target: https://badge.fury.io/py/pyastgrep.. image:: https://github.com/spookylukey/pyastgrep/actions/workflows/tests.yml/badge.svg     :target: https://github.com/spookylukey/pyastgrep/actions/workflows/tests.ymlA command-line utility for grepping Python files using XPath syntax (or CSSselectors) against the Python AST (Abstract Syntax Tree).In other words, this allows you to search Python code against specific syntaxelements (function definitions, arguments, assignments, variables etc), insteadof grepping for string matches.The interface and behaviour is designed to match grep and ripgrep as far as itmakes sense to do so... contents:: ContentsInstallation------------Python 3.8+ required.We recommend `pipx &lt;https://pipxproject.github.io/pipx/&gt;`_ to install itconveniently in an isolated environment:::   pipx install pyastgrepYou can also use pip:::   pip install pyastgrepUnderstanding the XML structure-------------------------------To get started, you’ll need some understanding of how Python AST is structured,and how that is mapped to XML. Some methods for doing that are below:1. Use `Python AST Explorer &lt;https://python-ast-explorer.com/&gt;`_ to play around   with what AST looks like.2. Dump out the AST and/or XML structure of the top-level statements in a Python   file. The easiest way to do this is to use the provided ``pyastdump``   command, passing in either a Python filename, ``pyastdump yourfile.py``, or   piping in Python fragments as below:   .. code:: bash      $ echo 'x = 1' | pyastdump -      &lt;Module&gt;        &lt;body&gt;          &lt;Assign lineno=&quot;1&quot; col_offset=&quot;0&quot;&gt;            &lt;targets&gt;              &lt;Name lineno=&quot;1&quot; col_offset=&quot;0&quot; type=&quot;str&quot; id=&quot;x&quot;&gt;                &lt;ctx&gt;                  &lt;Store/&gt;                &lt;/ctx&gt;              &lt;/Name&gt;            &lt;/targets&gt;            &lt;value&gt;              &lt;Constant lineno=&quot;1&quot; col_offset=&quot;4&quot; type=&quot;int&quot; value=&quot;1&quot;/&gt;            &lt;/value&gt;          &lt;/Assign&gt;        &lt;/body&gt;        &lt;type_ignores/&gt;      &lt;/Module&gt;   (When piping input in this way, code will be automatically dedented, making   this easier to do from partial Python snippets.)   You can also use the ``pyastgrep`` command, but since the top-level XML   elements are ``&lt;Module&gt;&lt;body&gt;``, and don’t correspond to actual source lines,   you’ll need to use an XPath expression ``./*/*`` to get a match for each   statement within the body, and pass ``--xml`` and/or ``--ast`` to dump the   XML/AST structure:   .. code:: bash      $ pyastgrep --xml --ast './*/*' myfile.py      myfile.py:1:1:import os      Import(          lineno=1,          col_offset=0,          end_lineno=1,          end_col_offset=9,          names=[alias(lineno=1, col_offset=7, end_lineno=1, end_col_offset=9, name='os', asname=None)],      )      &lt;Import lineno=&quot;1&quot; col_offset=&quot;0&quot;&gt;        &lt;names&gt;          &lt;alias lineno=&quot;1&quot; col_offset=&quot;7&quot; type=&quot;str&quot; name=&quot;os&quot;/&gt;        &lt;/names&gt;      &lt;/Import&gt;      ...Note that the XML format is a very direct translation of the Python AST asproduced by the `ast module &lt;https://docs.python.org/3/library/ast.html&gt;`_ (withsome small additions made to improve usability for a few cases). This AST is notstable across Python versions, so the XML is not stable either. Normally changesin the AST correspond to new syntax that is added to Python, but in some cases anew Python version will make significant changes made to the AST generated forthe same code.You’ll also need some understanding of how to write XPath expressions (see linksat the bottom), but the examples below should get you started.Examples--------Usages of a function called ``open``:.. code:: bash   $ pyastgrep './/Call/func/Name[@id=&quot;open&quot;]'   src/pyastgrep/search.py:88:18:            with open(path) as f:Literal numbers:.. code:: bash   $ pyastgrep './/Constant[@type=&quot;int&quot; or @type=&quot;float&quot;]'   tests/examples/test_xml/everything.py:5:20:    assigned_int = 123   tests/examples/test_xml/everything.py:6:22:    assigned_float = 3.14Function calls where:* the function is named ``open``:* the second positional argument is a string literal containing the character ``b``:.. code:: bash   pyastgrep './/Call[./func/Name[@id=&quot;open&quot;]][./args/Constant[position()=1][contains(@value, &quot;b&quot;)]]'Usages of ``open`` that are **not** in a ``with`` item expression:.. code:: bash   pyastgrep './/Call[not(ancestor::withitem)]/func/Name[@id=&quot;open&quot;]'Names longer than 42 characters:.. code:: bash   $ pyastgrep './/Name[string-length(@id) &gt; 42]'``except`` clauses that raise a different exception class than they catch:.. code:: bash   $ pyastgrep &quot;//ExceptHandler[body//Raise/exc//Name and not(contains(body//Raise/exc//Name/@id, type/Name/@id))]&quot;Functions whose name contain a certain substring:.. code:: bash   $ pyastgrep './/FunctionDef[contains(@name, &quot;something&quot;)]'Classes whose name matches a regular expression:.. code:: bash   $ pyastgrep &quot;.//ClassDef[re:match('M.*', @name)]&quot;The above uses the Python `re.match&lt;https://docs.python.org/3/library/re.html#re.match&gt;`_ method. You can also use``re:search`` to use the Python `re.search&lt;https://docs.python.org/3/library/re.html#re.search&gt;`_ method.Case-insensitive match of names on the left hand side of an assignmentcontaining a certain string. This can be achieved using the ``lower-case``function from XPath2:.. code:: bash   $ pyastgrep './/Assign/targets//Name[contains(lower-case(@id), &quot;something&quot;)]' --xpath2You can also use regexes, passing the ``i`` (case-insensitive flag) as below, asdescribed in the Python `Regular Expression Syntax docs&lt;https://docs.python.org/3/library/re.html#regular-expression-syntax&gt;`_.. code:: bash   $ pyastgrep './/Assign/targets//Name[re:search(&quot;(?i)something&quot;, @id)]'Assignments to the name ``foo``, including type annotated assignments, whichuse ``AnnAssign``, and tuple unpacking assignments (while avoiding things like``foo.bar = ...``). Note the use of the ``|`` operator to do a union... code:: bash   $ pyastgrep '(.//AnnAssign/target|.//Assign/targets|.//Assign/targets/Tuple/elts)/Name[@id=&quot;foo&quot;]'Docstrings of functions/methods whose value contains “hello”:.. code:: bash   $ pyastgrep './/FunctionDef/body/Expr[1]/value/Constant[@type=&quot;str&quot;][contains(@value, &quot;hello&quot;)]'For-loop variables called ``i`` or ``j`` (including those created by tuple unpacking):.. code:: bash   $ pyastgrep './/For/target//Name[@id=&quot;i&quot; or @id=&quot;j&quot;]'Method calls: These are actually “calls” on objects that are attributes of otherobjects. This will match the top-level object:.. code:: bash   $ pyastgrep './/Call/func/Attribute'Individual positional arguments to a method call named ``encode``, where thearguments are literal strings or numbers. Note the use of ``Call[…]`` to match“Call nodes that have descendants that match …”, rather than matching thosedescendant nodes themselves... code:: bash   $ pyastgrep './/Call[./func/Attribute[@attr=&quot;encode&quot;]]/args/Constant'For a Django code base, find all ``.filter`` and ``.exclude`` method calls, andall ``Q`` object calls, which have a keyword argument where the name containsthe string ``&quot;user&quot;``, for finding ORM calls like``.filter(user__id__in=...)`` or ``Q(thing__user=...)``:.. code:: bash   pyastgrep '(.//Call[./func/Attribute[@attr=&quot;filter&quot; or @attr=&quot;exclude&quot;]] | .//Call[./func/Name[@id=&quot;Q&quot;]]) [./keywords/keyword[contains(@arg, &quot;user&quot;)]]'Ignoring files--------------Files/directories matching ``.gitignore`` entries (global and local) areautomatically ignored, unless specified as paths on the command line.Currently there are no other methods to add or remove this ignoring logic.Please open a ticket if you want this feature. Most likely we should try to makeit work like `ripgrep filtering&lt;https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#manual-filtering-globs&gt;`_if that makes sense.CSS selectors-------------In general, XPath expressions are more powerful than CSS selectors, and CSSselectors have some things that are specific to HTML (such as specific selectorsfor ``id`` and ``class``). However, it may be easier to get started using CSSselectors, and for some things CSS selectors are easier. In that case, just pass``--css`` and the expression will be interpreted as a CSS selector instead.For example, to get the first statement in each ``for`` statement body:.. code:: bash   $ pyastgrep --css 'For &gt; body &gt; *:first-child'The CSS selector will converted to an XPath expression with a prefix of ``.//``— that is, it will be interpreted as a query over all the document.Note that unlike CSS selectors in HTML, the expression will be interpretedcase-sensitively.You can also use the online tool `css2xpath &lt;https://css2xpath.github.io/&gt;`_ todo translations before passing to ``pyastgrep``. This tool also supports somethings that our `cssselect (our dependency) does not yet support&lt;https://github.com/scrapy/cssselect/issues&gt;`_.Tips----Command line flags~~~~~~~~~~~~~~~~~~There are a growing number of command line flags – see ``pyastgrep --help``Extracting code snippets~~~~~~~~~~~~~~~~~~~~~~~~If you want to extract standalone snippets of code, try ``--context=statement--heading`` which does automatic dedenting. e.g. to extract all functions andmethods, with leading whitespace removed, do:.. code-block:: bash   $ pyastgrep --heading -C statement './/FunctionDef'Absolute paths~~~~~~~~~~~~~~To get pyastgrep to print absolute paths in results, pass the current absolutepath as the directory to search::  pyastgrep &quot;...&quot; $(pwd)Debugging XPath expressions~~~~~~~~~~~~~~~~~~~~~~~~~~~Use the ``--xml`` option to see the XML for matches. If you need to see morecontext, you can use things like the ``parent`` or ``ancestor`` selector. Forexample, you might do the following but get back more results than you want:.. code:: bash   $ pyastgrep './/Assign/targets//Name[@id=&quot;foo&quot;]   example.py:1:1:foo = 1   example.py:2:2:(foo, bar) = (3, 4)   example.py:3:1:foo.bar = 2Here you might be interested in the first two results, which both assign tothe name ``foo``, but not the last one since it does not. You can get the XML for thewhole matching assignment expressions like this:.. code:: bash   $ pyastgrep './/Assign/targets//Name[@id=&quot;foo&quot;]/ancestor::Assign' --xml   example.py:1:1:foo = 1   &lt;Assign lineno=&quot;1&quot; col_offset=&quot;0&quot;&gt;     &lt;targets&gt;       &lt;Name lineno=&quot;1&quot; col_offset=&quot;0&quot; type=&quot;str&quot; id=&quot;foo&quot;&gt;         &lt;ctx&gt;           &lt;Store/&gt;         &lt;/ctx&gt;       &lt;/Name&gt;     &lt;/targets&gt;     &lt;value&gt;       &lt;Constant lineno=&quot;1&quot; col_offset=&quot;6&quot; type=&quot;int&quot; value=&quot;1&quot;/&gt;     &lt;/value&gt;   &lt;/Assign&gt;   ...You could also go the other way and change the XPath expression to match on theparent ``Assign`` node — this matches “all ``Assign`` nodes that are parents ofa ``target`` node that is a parent of a ``Name`` node with attribute ``id``equal to ``&quot;foo&quot;``:.. code:: bash   $ pyastgrep './/Assign[./targets//Name[@id=&quot;foo&quot;]]' --xmlLimitations and other tools---------------------------pyastgrep is useful for grepping Python code at a fairly low level. It can beused for various refactoring or linting tasks. Some linting tasks require higherlevel understanding of a code base. For example, to detect use of a certainfunction, you need to cope with various ways that the function may be importedand used, and avoid detecting a function with the same name but from a differentmodule. For these kinds of tasks, you might be interested in:* `Semgrep &lt;https://semgrep.dev/&gt;`_* `Fixit &lt;https://github.com/Instagram/Fixit&gt;`_If you are looking for something simpler, try:* Simon Willison’s `symbex &lt;https://github.com/simonw/symbex/&gt;`_ which can  extract functions/methods/classes.If you are using this as a library, you should note that while AST works wellfor linting, it’s not as good for rewriting code, because AST does not containor preserve things like formatting and comments. For a better approach, have alook at `libCST &lt;https://github.com/Instagram/LibCST&gt;`_.Use as a library----------------pyastgrep is structured internally to make it easy to use as a library as wellas a CLI, with a clear separation of the different layers. However, while wewill try not to break things without good reason, at this point we are notdocumenting or guaranteeing API stability for these functions. Please contributeto `the discussion &lt;https://github.com/spookylukey/pyastgrep/discussions/18&gt;`_if you have needs here.Editor integration------------------Emacs~~~~~pyastgrep works very well with ``compilation-mode`` and wrappers like``projectile-compile-project`` from `Projectile&lt;https://docs.projectile.mx/projectile/usage.html#basic-usage&gt;`_. We recommendsetting up a keyboard shortcut for ``next-error`` to enable you to step throughresults easily.Visual Studio Code~~~~~~~~~~~~~~~~~~Run pyastgrep from a terminal and results will be hyperlinked automatically.PyCharm~~~~~~~Run pyastgrep from a terminal and results will be hyperlinked automatically.Others~~~~~~Contributions to this section gladly accepted!Contributing------------Get test suite running::  pip install -r requirements-test.txt  pytestRun tests against all versions::  pip install tox  toxPlease install `pre-commit &lt;https://pre-commit.com/&gt;`_ in the repo::  pre-commit installThis will add Git hooks to run linters when committing, which ensures our style(black) and other things.You can manually run these linters using::  pre-commit run --all --all-filesRun mypy (we only expect it to pass on Python 3.10)::  mypy .Bug fixes and other changes can be submitted using pull requests on GitHub. Forlarge changes, it’s worth opening an issue first to discuss the approach.Links------ `Green tree snakes &lt;https://greentreesnakes.readthedocs.io/en/latest/&gt;`__ - a very readable overview of Python ASTs.- `ast module documentation &lt;https://docs.python.org/3/library/ast.html&gt;`__.- `Python AST Explorer &lt;https://python-ast-explorer.com/&gt;`__ for worked  examples of ASTs.- A `brief guide to XPath &lt;http://www.w3schools.com/xml/xpath_syntax.asp&gt;`__.  See also the `XPath Axes &lt;https://www.w3schools.com/xml/xpath_axes.asp&gt;`_ guide  which can be very helpful for matching related AST nodes.- `Online XPath Tester &lt;https://extendsclass.com/xpath-tester.html&gt;`_History-------This project was forked from https://github.com/hchasestevens/astpath by `H.Chase Stevens &lt;http://www.chasestevens.com&gt;`__. Main changes:* Added a test suite* Many bugs fixed* Significant rewrite of parts of code* Changes to match grep/ripgrep, including formatting and automatic filtering.</longdescription>
</pkgmetadata>