<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;a href=&quot;https://jgltechnologies.com/discord&quot;&gt;&lt;img src=&quot;https://discord.com/api/guilds/844418702430175272/embed.png&quot;&gt;&lt;/a&gt;# aiohttp-ratelimiteraiohttp-ratelimiter is a rate limiter for the aiohttp.web framework.This is a new library, and we are always looking for people to contribute. If you see something wrong with the code or want to add a feature, please create a pull request on &lt;a href=&quot;https://jgltechnologies.com/aiohttplimiter&quot;&gt;our github&lt;/a&gt;.Install from git```python -m pip install git+https://github.com/JGLTechnologies/aiohttp-ratelimiter```Install from pypi```python -m pip install aiohttp-ratelimiter// if redis is being usedpython -m pip install aiohttp-ratelimiter[redis]// if memcached is being usedpython -m pip install aiohttp-ratelimiter[memcached]```&lt;br&gt;Example```pythonfrom aiohttp import webfrom aiohttplimiter import default_keyfunc, Limiterfrom aiohttplimiter.redis_limiter import RedisLimiterfrom aiohttplimiter.memcached_limiter import MemcachedLimiterapp = web.Application()routes = web.RouteTableDef()# In Memorylimiter = Limiter(keyfunc=default_keyfunc)# Redislimiter = RedisLimiter(keyfunc=default_keyfunc, uri=&quot;redis://localhost:6379&quot;)# Memcachedlimiter = MemcachedLimiter(keyfunc=default_keyfunc, uri=&quot;memcached://localhost:11211&quot;)@routes.get(&quot;/&quot;)# This endpoint can only be requested 1 time per second per IP address@limiter.limit(&quot;1/second&quot;)async def home(request):    return web.Response(text=&quot;test&quot;)app.add_routes(routes)web.run_app(app)```&lt;br&gt;You can exempt an IP from rate limiting using the exempt_ips kwarg.```pythonfrom aiohttplimiter import Limiter, default_keyfuncfrom aiohttp import webapp = web.Application()routes = web.RouteTableDef()# 192.168.1.245 is exempt from rate limiting.# Keep in mind that exempt_ips takes a set not a list.limiter = Limiter(keyfunc=default_keyfunc, exempt_ips={&quot;192.168.1.245&quot;})@routes.get(&quot;/&quot;)@limiter.limit(&quot;3/5minutes&quot;)async def test(request):    return web.Response(text=&quot;test&quot;)app.add_routes(routes)web.run_app(app)```&lt;br&gt;You can create your own error handler by using the error_handler kwarg.```pythonfrom aiohttplimiter import Allow, RateLimitExceeded, Limiter, default_keyfuncfrom aiohttp import webdef handler(request: web.Request, exc: RateLimitExceeded):    # If for some reason you want to allow the request, return aiohttplimitertest.Allow().    if some_condition:        return Allow()    return web.Response(text=f&quot;Too many requests&quot;, status=429)limiter = Limiter(keyfunc=default_keyfunc, error_handler=handler)```&lt;br&gt;If multiple paths use one handler like this:```python@routes.get(&quot;/&quot;)@routes.get(&quot;/home&quot;)@limiter.limit(&quot;5/hour&quot;)def home(request):    return web.Response(text=&quot;Hello&quot;)```&lt;br&gt;Then they will have separate rate limits. To prevent this use the path_id kwarg.```python@routes.get(&quot;/&quot;)@routes.get(&quot;/home&quot;)@limiter.limit(&quot;2/3days&quot;, path_id=&quot;home&quot;)def home(request):    return web.Response(text=&quot;Hello&quot;)```&lt;br&gt;Views Example ```python@routes.view(&quot;/&quot;)class Home(View):    @limiter.limit(&quot;1/second&quot;)    def get(self):        return web.Response(text=&quot;hello&quot;)```</longdescription>
</pkgmetadata>