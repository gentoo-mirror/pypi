<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Overview--------*waiting* is a small library for waiting for stuff to happen. It basically waits for a function to return **True**, in various modes.*Waiting* is compatible with `flux &lt;http://flux.readthedocs.org&gt;`_ for simulated timelines.Usage-----The most basic usage is when you have a function you want to wait for:: &gt;&gt;&gt; predicate = lambda : TrueWaiting forever is very simple:: &gt;&gt;&gt; from waiting import wait, TimeoutExpired &gt;&gt;&gt; wait(predicate) TrueIf your predicate returns a value, it will be returned as the result of wait():: &gt;&gt;&gt; result = object() &gt;&gt;&gt; wait(lambda: result) is result TrueA *timeout* parameter can also be specified:: &gt;&gt;&gt; wait(predicate, timeout_seconds=10.5) TrueWhen a timeout expires without the predicate being fullfilled, an exception is thrown:: &gt;&gt;&gt; try: ...     wait(lambda : False, timeout_seconds=0) ... except TimeoutExpired: ...     # expired! ...     pass ... else: ...     assert FalseSleeping polls the predicate at a certain interval (by default 1 second). The interval can be changed with the *sleep_seconds* argument:: &gt;&gt;&gt; wait(predicate, sleep_seconds=20) TrueWhen waiting for multiple predicates, *waiting* provides two simple facilities to help aggregate them: **ANY** and **ALL**. They resemble Python's built-in *any()* and *all()*, except that they don't call a predicate once it has been satisfied (this is useful when the predicates are inefficient and take time to complete):: &gt;&gt;&gt; from waiting import wait, ANY, ALL &gt;&gt;&gt; wait(ANY([predicate, predicate])) True &gt;&gt;&gt; wait(ALL([predicate, predicate])) TrueTimeoutExpired exceptions, by default, don't tell you much about what didn't happen that you were expecting. To fix that, use the *waiting_for* argument:: &gt;&gt;&gt; try: ...     wait(lambda : False, timeout_seconds=0, waiting_for=&quot;something that will never happen&quot;) #doctest: +ELLIPSIS ... except TimeoutExpired as e: ...     print(e) Timeout of 0 seconds expired waiting for something that will never happenExponential backoff is supported for the sleep interval:: &gt;&gt;&gt; from waiting import wait &gt;&gt;&gt; wait(predicate, sleep_seconds=(1, 100)) # sleep 1, 2, 4, 8, 16, 32, 64, 100, 100, .... True &gt;&gt;&gt; wait(predicate, sleep_seconds=(1, 100, 3)) # sleep 1, 3, 9, 27, 81, 100, 100, 100 .... True &gt;&gt;&gt; wait(predicate, sleep_seconds=(1, None)) # sleep 1, 2, 4, 6, .... (infinity) True &gt;&gt;&gt; wait(predicate, sleep_seconds=(1, None, 4)) # sleep 1, 4, 16, 64, ... (infinity) TrueIf your predicate might raise certain exceptions you wish to ignore, you may use ``expected_exceptions`` to ignore them:: &gt;&gt;&gt; from waiting import wait &gt;&gt;&gt; wait(predicate, expected_exceptions=ValueError) True &gt;&gt;&gt; wait(predicate, expected_exceptions=(ValueError, AttributeError)) TrueIf you'd like to maintain updates while waiting for a predicate to complete, you may use ``on_poll`` to pass a function to perform some behavior after every sleep. By default, this is a no-op. &gt;&gt;&gt; import logging &gt;&gt;&gt; from waiting import wait &gt;&gt;&gt; try: ...    wait(lambda: False, timeout_seconds=5,               # Timeout after 5 seconds ...          on_poll=lambda: logging.warn(&quot;Waiting...&quot;)) # Log &quot;Waiting...&quot; six times. ... except TimeoutExpired: ...    pass ... else: ...    assert False</longdescription>
</pkgmetadata>