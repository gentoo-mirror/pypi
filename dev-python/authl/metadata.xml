<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># AuthlA Python library for managing federated identity[![Documentation Status](https://readthedocs.org/projects/authl/badge/?version=latest)](https://authl.readthedocs.io/en/latest/?badge=latest)## AboutAuthl is intended to make it easy to add federated identity to Python-based webapps without requiring the creation of site-specific user accounts, but alsowithout requiring the user to choose from a myriad of buttons or links to selectany specific login provider.All it should take is a single login form that asks for how the user wants to beidentified.## Current stateThe basic API works, and provides an easy drop-in set of endpoints for[Flask](http://flask.pocoo.org).Currently supported authentication mechanisms:* Directly authenticating against email using a magic link* Federated authentication against Fediverse providers    ([Mastodon](https://joinmastodon.org/), [Pleroma](https://pleroma.social))* Federated authentication against [IndieAuth](https://indieauth.net/)* Silo authentication against [Twitter](https://twitter.com/)* Test/loopback authentication for development purposesPlanned functionality:* Pluggable OAuth mechanism to easily support additional identity providers such as:    * OpenID Connect (Google et al)    * Facebook    * GitHub* OpenID 1.x (Wordpress, LiveJournal, Dreamwidth, etc.)* A more flexible configuration system## RationaleIdentity is hard, and there are so many competing standards which try to be thebe-all end-all Single Solution. OAuth and OpenID Connect want lock-in to silos,IndieAuth wants every user to self-host their own identity site, and OpenID 1.xhas fallen by the wayside. Meanwhile, users just want to be able to log in withthe social media they're already using (siloed or not).Any solution which requires all users to have a certain minimum level oftechnical ability is not a workable solution.All of these solutions are prone to the so-called &quot;[NASCARproblem](https://indieweb.org/NASCAR_problem)&quot; where every supported loginprovider needs its own UI. But being able to experiment with a more unified UXmight help to fix some of that.## DocumentationFull API documentation is hosted on [readthedocs](https://authl.readthedocs.io).## UsageBasic usage is as follows:1. Create an Authl object with your configured handlers    This can be done by instancing individual handlers yourself, or you can use    `authl.from_config`2. Make endpoints for initiation and progress callbacks    The initiation callback receives an identity string (email address/URL/etc.)    from the user, queries Authl for the handler and its ID, and builds a    callback URL for that handler to use. Typically you'll have a single    callback endpoint that includes the handler's ID as part of the URL scheme.    The callback endpoint needs to be able to receive a `GET` or `POST` request    and use that to validate the returned data from the authorization handler.    Your callback endpoint (and generated URL thereof) should also include    whatever intended forwarding destination.3. Handle the `authl.disposition` object types accordingly    A `disposition` is what should be done with the agent that initiated the    endpoint call. Currently there are the following:    * `Redirect`: return an HTTP redirection to forward it along to another URL    * `Notify`: return a notification to the user that they must take another      action (e.g. check their email)    * `Verified`: indicates that the user has been verified; set a session      cookie (or whatever) and forward them along to their intended destination    * `Error`: An error occurred; return it to the user as appropriate## Flask usageTo make life easier with Flask, Authl provides an `authl.flask.AuthlFlask`wrapper. You can use it from a Flask app with something like the below:```pythonimport uuidimport loggingimport flaskimport authl.flasklogging.basicConfig(level=logging.INFO)LOGGER = logging.getLogger(__name__)app = flask.Flask('authl-test')app.secret_key = str(uuid.uuid4())authl = authl.flask.AuthlFlask(    app,    {        'SMTP_HOST': 'localhost',        'SMTP_PORT': 25,        'EMAIL_FROM': 'authl@example.com',        'EMAIL_SUBJECT': 'Login attempt for Authl test',        'INDIELOGIN_CLIENT_ID': authl.flask.client_id,        'TEST_ENABLED': True,        'MASTODON_NAME': 'authl testing',        'MASTODON_HOMEPAGE': 'https://github.com/PlaidWeb/Authl'    },    tester_path='/check_url')@app.route('/')@app.route('/some-page')def index():    &quot;&quot;&quot; Just displays a very basic login form &quot;&quot;&quot;    LOGGER.info(&quot;Session: %s&quot;, flask.session)    LOGGER.info(&quot;Request path: %s&quot;, flask.request.path)    if 'me' in flask.session:        return 'Hello {me}. Want to &lt;a href=&quot;{logout}&quot;&gt;log out&lt;/a&gt;?'.format(            me=flask.session['me'], logout=flask.url_for(                'logout', redir=flask.request.path[1:])        )    return 'You are not logged in. Want to &lt;a href=&quot;{login}&quot;&gt;log in&lt;/a&gt;?'.format(        login=flask.url_for('authl.login', redir=flask.request.path[1:]))@app.route('/logout/')@app.route('/logout/&lt;path:redir&gt;')def logout(redir=''):    &quot;&quot;&quot; Log out from the thing &quot;&quot;&quot;    LOGGER.info(&quot;Logging out&quot;)    LOGGER.info(&quot;Redir: %s&quot;, redir)    LOGGER.info(&quot;Request path: %s&quot;, flask.request.path)    flask.session.clear()    return flask.redirect('/' + redir)```This will configure the Flask app to allow IndieLogin, Mastodon, and email-basedauthentication (using the server's local sendmail), and use the default loginendpoint of `/login/`. The `index()` endpoint handler always redirects loginsand logouts back to the same page when you log in or log out (the `[1:]` is totrim off the initial `/` from the path). The logout handler simply clears thesession and redirects back to the redirection path.The above configuration uses Flask's default session lifetime of one month (thiscan be configured by setting `app.permanent_session_lifetime` to a `timedelta`object, e.g. `app.permanent_session_lifetime = datetime.timedelta(hours=20)`).Sessions will also implicitly expire whenever the application server isrestarted, as `app.secret_key` is generated randomly at every startup.### Accessing the default stylesheetIf you would like to access `authl.flask`'s default stylesheet, you can do it bypassing the argument `asset='css'` to the login endpoint. For example, if youare using the default endpoint name of `authl.login`, you can use:```pythonflask.url_for('authl.login', asset='css')```from Python, or e.g.```html&lt;link rel=&quot;stylesheet&quot; href=&quot;{{url_for('authl.login', asset='css')}}&quot;&gt;```from a Jinja template.</longdescription>
</pkgmetadata>