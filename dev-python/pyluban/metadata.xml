<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># luban## Why Need?The feature-processing module is used in different scenarios, such as: model training and model inference. Usually, we use Python to train models, and feature-processing is also done in Python. However, in model inference, the shorter the inference run time, the better. So we usually use C++/java/golang or other languages to do model inference. If feature-process module is written in many different languages, they may be inconsistencies. So, we decide to develop such a module in C++, which can be used by other different languages. In addition, we use a json configuration for feature processing, so that it will be easier to use.## Supported libraries and tools1. c/c++ lib: libluban2. python lib: pyluban## Configuration```json{    &quot;user_features&quot;: [        {            &quot;name&quot;: &quot;U1&quot;,            &quot;expr&quot;: &quot;A*B&quot;,            &quot;type&quot;: 1,            &quot;hash&quot;: false,            &quot;padding&quot;: 0,            &quot;dim&quot;: 1        },        {            &quot;name&quot;: &quot;U2&quot;,            &quot;expr&quot;: &quot;C[int64]+D[int64]&quot;,            &quot;type&quot;: 0,            &quot;hash&quot;: false,            &quot;padding&quot;: 0,            &quot;dim&quot;: 1        }    ],    &quot;item_features&quot;: [        {            &quot;name&quot;: &quot;I1&quot;,            &quot;expr&quot;: &quot;F[int64]+G[int64]&quot;,            &quot;type&quot;: 0,            &quot;hash&quot;: false,            &quot;padding&quot;: 0,            &quot;dim&quot;: 1        },        {            &quot;name&quot;: &quot;I2&quot;,            &quot;expr&quot;: &quot;concat(H[string],\&quot;TEST\&quot;)&quot;,            &quot;type&quot;: 0,            &quot;hash&quot;: true,            &quot;padding&quot;: 0,            &quot;dim&quot;: 1        }    ],    &quot;groups&quot;: [        [            &quot;U1&quot;        ],        [            &quot;U2&quot;        ],        [            &quot;I1&quot;,            &quot;I2&quot;        ]    ]}```### featuresConfigure the relevant properties for each feature.| Properties | Type          | Empty | Default | Description                                                                                            || ---------- | ------------- | ----- | ------- | ------------------------------------------------------------------------------------------------------ || name       | string        | N     | -       | name of feature                                                                                        || expr       | string        | Y     | &quot;&quot;      | how to process feature                                                                                 || type       | int           | N     | -       | 0: int64,&lt;br/&gt;1: float3,&lt;br/&gt;2: string&lt;br/&gt;3: vector\&lt;int64\&gt;&lt;br/&gt;4: vector\&lt;float\&gt;&lt;br/&gt;5: vector\&lt;string\&gt; || hash       | bool          | Y     | false   | hash or not                                                                                            || padding    | int64/float32 | Y     | 0/0.0   | fill value                                                                                             || dim        | int           | Y     | 1       | dim of result                                                                                          |### groupsAfter processing, different features may be placed in different groups. Because the downstream user is pytorch, different types of data are inconvenient to put in a tensor. The final output order of the features is the same as the order configured in the group. **All features configured in groups need to be configured in the features above**.## Parse ExpressionAfter installing the Python tool, the `luban_parser` tool is installed by default in /usr/local/bin. This tool is used to parse the above JSON configuration and generate the configuration using the JSON format used by C++. The expressions here are similar to Python's syntax. Originally, we wanted to use antlr to customize the DSL, but after thinking about it, we thought that it could be as simple as possible. As a result, it was finally decided to parse expressions using Python's built-in ast.### Operators1. opr: +, -, *, /, %, **2. math function: round, floor, ceil, log, exp, log10, log2, sqrt, abs, sin, sinh, asin,asinh, cos, cosh, acos, acosh, tan, tanh, atan, atanh, sigmoid3. aggravate function: min, max, variance, stddev, average, norm4. time function: year, month, day, hour, minute, second, date, now, date_diff, date_add, date_sub, from_unixtime, unix_timestamp5. string function: concat, substr, lower, upper, cross, reverse6. topk function: topki, topkf, topks7. other function: min_max, z_score, binarize, bucketize, box_cox, normalize```c// The following is a list of supported operations// If it is a template type, you can add the type feature when configuring the function name// e.g.: _add&lt;int64_t&gt;, _add&lt;float&gt;// If you do not add type information, the float type is defaulted// In practice, the tool does some built-in implicit data type conversionsT _add(T &amp;a, T &amp;b);T _sub(T &amp;a, T &amp;b);T _mul(T &amp;a, T &amp;b);T _div(T &amp;a, T &amp;b);int64_t _mod(int64_t &amp;a, int64_t &amp;b);float _pow(float &amp;a, float &amp;b);int64_t _round(float &amp;x);int64_t _floor(float &amp;x);int64_t _ceil(float &amp;x);float _log(float &amp;x);float _exp(float &amp;x);float _log10(float &amp;x);float _log2(float &amp;x);float _sqrt(float &amp;x);float _abs(float &amp;x);float _sin(float &amp;x);float _asin(float &amp;x);float _sinh(float &amp;x);float _asinh(float &amp;x);float _cos(float &amp;x);float _acos(float &amp;x);float _cosh(float &amp;x);float _acosh(float &amp;x);float _tan(float &amp;x);float _atan(float &amp;x);float _tanh(float &amp;x);float _atanh(float &amp;x);float _sigmoid(float &amp;x);T min(std::vector&lt;float&gt; &amp;src);T max(std::vector&lt;T&gt; &amp;src);float average(std::vector&lt;T&gt; &amp;src);float variance(std::vector&lt;T&gt; &amp;src);float stddev(std::vector&lt;T&gt; &amp;src);float norm(std::vector&lt;T&gt; &amp;src, float &amp;n);std::string year();std::string month();std::string day();std::string date();std::string hour();std::string minute();std::string second();int64_t now();std::string from_unixtime(int64_t &amp;ts, std::string &amp;format);int64_t unix_timestamp(std::string &amp;t, std::string &amp;format);std::string date_add(std::string &amp;s, int64_t &amp;n);std::string date_sub(std::string &amp;s, int64_t &amp;n);int64_t date_diff(std::string &amp;d1, std::string &amp;d2);std::string reverse(std::string &amp;s);std::string upper(std::string &amp;s);std::string lower(std::string &amp;s);std::string substr(std::string &amp;s, int64_t &amp;start, int64_t &amp;len);std::string concat(std::string &amp;a, std::string &amp;b);float min_max(T &amp;v, T &amp;min, T &amp;max);float z_score(float &amp;v, float &amp;mean, float &amp;stdv);int64_t binarize(T &amp;v, T &amp;threshold);int64_t bucketize(T &amp;v, std::vector&lt;T&gt; &amp;boundaries);float box_cox(float &amp;v, float &amp;lambda);std::vector&lt;float&gt; normalize(std::vector&lt;T&gt; &amp;src, float &amp;norm);std::vector&lt;T&gt; topk(std::vector&lt;T&gt; &amp;src, int64_t &amp;k);std::vector&lt;std::string&gt; cross(std::vector&lt;std::string&gt; &amp;srcA,                               std::vector&lt;std::string&gt; &amp;srcB);```## Usage1. Follow the installation prompts in the next section to compile and install the tool2. Include header files and add libluban to dynamic link paths3. Steps:      1. step1: Configure the JSON file   2. use `luban_parser` to process JSON configuration files and generate configuration files in JSON format   3. Use the configuration file in JSON format as a configuration input for C/C++/Golang/Python## Install### install On MacOS ARM```shellpip install pyluban```### Unix Like```shellpython setup.py install --install-scripts=/usr/local/binpip install pyluban```## Examples### Features &amp; FeaturesListThe structure of the features is as follows:```json// json format{    &quot;A&quot;: {                        // key is the name of feature        &quot;type&quot;: 0,                // type listed above        &quot;value&quot;: 10               // certain value    },    &quot;B&quot;: {        &quot;type&quot;: 1,                        &quot;value&quot;: 10.9                    },    ...}```how to parse features in python```pythonimport jsonimport pylubanfeas = {&quot;A&quot;: {&quot;type&quot;: 0,&quot;value&quot;: 10},...}feas_str = json.dumps(feas)# arg is strfeatures = pyluban.Features(feas_str)# arg is str listfeatures = pyluban.Features([feas_str1, feas_str2, feas_str3])# arg is nilfeatures = pyluban.Features()# create a featureslistl = pyluban.FeatuersList()# add a valuel.append(features)print(l[0])print(l)l[0] = features```## FunctionThis is the configuration of function processing, usually, **users generally do not use**, will be used when doing unit tests, and are also explained here.```json{    &quot;func&quot;:&quot;_add&lt;int64_t&gt;&quot;,    &quot;name&quot;:&quot;X&quot;,    &quot;flag&quot;:3,    &quot;args&quot;: [],    &quot;vars&quot;: [&quot;A&quot;,&quot;B&quot;]}```| Properties | Type         | Description                                                                                                                                   || ---------- | ------------ | --------------------------------------------------------------------------------------------------------------------------------------------- || func       | string       | function name                                                                                                                                 || name       | string       | name of generated feature                                                                                                                     || flag       | int64        | Flag bits for each parameter: In the binary bit of flag, the ith bit is 1 to indicate that the input is a variable; Otherwise, it is constant || args       | list of dict | same structure of features                                                                                                                    || vars       | list of str  | variable name list                                                                                                                            |## ToolkitBy configuring the class for feature processing entry, the consumer mainly uses this class to process features.```pythonimport pylubanimport luban_parser# this is the original config file&quot;&quot;&quot;{    &quot;features&quot;: [        {            &quot;name&quot;: &quot;A&quot;,            &quot;expr&quot;: &quot;(B+C)*F&quot;,            &quot;type&quot;: 0,            &quot;hash&quot;: false,            &quot;padding&quot;: 0,            &quot;dim&quot;: 1        },        {            &quot;name&quot;: &quot;B&quot;,            &quot;type&quot;: 0,            &quot;padding&quot;: 0,            &quot;dim&quot;: 1        },        {            &quot;name&quot;: &quot;C&quot;,            &quot;type&quot;: 0,            &quot;padding&quot;: 0,            &quot;dim&quot;: 1        },        {            &quot;name&quot;: &quot;D&quot;,            &quot;expr&quot;: &quot;concat(\&quot;prefix-\&quot;, E)&quot;,            &quot;type&quot;: 0,            &quot;hash&quot;: true,            &quot;padding&quot;: 0,            &quot;dim&quot;: 3        }    ],    &quot;groups&quot;: [        [            &quot;A&quot;,            &quot;B&quot;        ],        [            &quot;D&quot;        ]    ]}&quot;&quot;&quot;luban_parser.parser(input_file: str, output_file: str)# this is the output file of luban_parser&quot;&quot;&quot;{    &quot;transforms&quot;: [        {            &quot;func&quot;: &quot;_add&lt;int64_t&gt;&quot;,            &quot;name&quot;: &quot;anonymous_0&quot;,            &quot;flag&quot;: 3,            &quot;args&quot;: [],            &quot;vars&quot;: [                &quot;B&quot;,                &quot;C&quot;            ]        },        {            &quot;func&quot;: &quot;_mul&lt;int64_t&gt;&quot;,            &quot;name&quot;: &quot;A&quot;,            &quot;flag&quot;: 3,            &quot;args&quot;: [],            &quot;vars&quot;: [                &quot;anonymous_0&quot;,                &quot;F&quot;            ]        },        {            &quot;func&quot;: &quot;concat&quot;,            &quot;name&quot;: &quot;D&quot;,            &quot;flag&quot;: 2,            &quot;args&quot;: [                {                    &quot;type&quot;: 2,                    &quot;value&quot;: &quot;prefix-&quot;                }            ],            &quot;vars&quot;: [                &quot;E&quot;            ]        }    ],    &quot;groups&quot;: [        {            &quot;id&quot;: 0,            &quot;width&quot;: 2,            &quot;type&quot;: 0        },        {            &quot;id&quot;: 1,            &quot;width&quot;: 3,            &quot;type&quot;: 0        }    ],    &quot;features&quot;: [        {            &quot;name&quot;: &quot;A&quot;,            &quot;type&quot;: 0,            &quot;padding&quot;: 0,            &quot;group&quot;: 0,            &quot;offset&quot;: 0,            &quot;hash&quot;: false,            &quot;dim&quot;: 1        },        {            &quot;name&quot;: &quot;B&quot;,            &quot;type&quot;: 0,            &quot;padding&quot;: 0,            &quot;group&quot;: 0,            &quot;offset&quot;: 1,            &quot;hash&quot;: false,            &quot;dim&quot;: 1        },        {            &quot;name&quot;: &quot;D&quot;,            &quot;type&quot;: 0,            &quot;padding&quot;: 0,            &quot;group&quot;: 1,            &quot;offset&quot;: 0,            &quot;hash&quot;: true,            &quot;dim&quot;: 3        }    ]}&quot;&quot;&quot;# config.json is the file after configuration processing, # and the above is an example of the file content of the configurationtoolkit = pyluban.Toolkit(&quot;config.json&quot;)```#### RowsIn the case of only one feature, Rows is a list object with a length of the number of groups configured above, which can be accessed via subscripts and then converted into numpy structures.```python# r pyluban:Rows typer = toolkit.process(features: pyluban.Features)for i in range(len(r)):    print(np.asarray(r[i]))```#### MatricesMatrices is a list object with a length of the number of groups configured above, which can be accessed by subscripts and then converted into a numpy structure.```pythonl = pyluban.FeaturesList()l.append(features: pyluban.Features)m = self.toolkit.process(l)for i in range(len(m)):    print(np.asarray(m[i]))```</longdescription>
</pkgmetadata>