<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>django-syzygy=============.. image:: https://github.com/charettes/django-syzygy/workflows/Test/badge.svg    :target: https://github.com/charettes/django-syzygy/actions    :alt: Build Status.. image:: https://coveralls.io/repos/github/charettes/django-syzygy/badge.svg?branch=master    :target: https://coveralls.io/github/charettes/django-syzygy?branch=master    :alt: Coverage statusDjango application providing database migration tooling to automate their deployment.Inspired by a `2015 post from Ludwig Hähne`_ and experience dealing with migration at Zapier_... _`2015 post from Ludwig Hähne`: https://pankrat.github.io/2015/django-migrations-without-downtimes/#django-wishlist.. _Zapier: https://zapier.comInstallation------------.. code:: sh    pip install django-syzygyUsage-----Add ``'syzygy'`` to your ``INSTALLED_APPS``.. code:: python    # settings.py    INSTALLED_APPS = [        ...        'syzygy',        ...    ]Setup you deployment pipeline to run ``migrate --pre-deploy`` before rollingout your code changes and ``migrate`` afterwards to apply the postponedmigrations.Concept-------Syzygy introduces a notion of *prerequisite* and *postponed* migrations withregards to deployment.A migration is assumed to be a *prerequisite* to deployment unless it containsa destructive operation or the migration has its ``stage`` class attribute setto ``Stage.POST_DEPLOY``. When this attribute is defined it will bypass``operations`` based heuristics.e.g. this migration would be considered a *prerequisite*.. code:: python    class Migration(migrations.Migration):        operations = [            AddField('model', 'field', models.IntegerField(null=True))        ]while the following migrations would be *postponed*.. code:: python    class Migration(migrations.Migration):        operations = [            RemoveField('model', 'field'),        ].. code:: python    from syzygy import Stage    class Migration(migrations.Migration):        stage = Stage.POST_DEPLOY        operations = [            RunSQL(...),        ]In order to prevent the creation of migrations mixing operations of different*stages* this package registers system checks. These checks will generate an errorfor every migration with an ambiguous ``stage``.e.g. this migration would result in a check error.. code:: python    class Migration(migrations.Migration):        operations = [            AddField('model', 'other_field', models.IntegerField(null=True)),            RemoveField('model', 'field'),        ]Migration revert are also supported and result in inverting the nature ofmigrations. A migration that is normally considered a *prerequisite* would thenbe *postponed* when reverted.With this new notion of migration stage it's possible for the `migrate` commandto target only migrations meant to be run before a deployment using the`--pre-deploy` flag or error out in the case on an ambiguous plan.Third-party migrations----------------------As long as the adoption of migration stages concept  not generalized yourproject might depend on third-party apps containing migrations with anambiguous sequence of operations.Since an explicit `stage` cannot be explicitly assigned by editing thesemigrations a fallback or an override stage can be specified through therespective ``MIGRATION_STAGES_FALLBACK`` and ``MIGRATION_STAGES_OVERRIDE``settings.By default third-party app migrations with an ambiguous sequence of operationswill fallback to ``Stage.PRE_DEPLOY`` but this behavior can be changed bysetting ``MIGRATION_THIRD_PARTY_STAGES_FALLBACK`` to ``Stage.POST_DEPLOY`` ordisabled by setting it to ``None``... note::  The third-party app detection logic relies on the ``site`` `Python module`_  and is known to not properly detect all kind of third-party Django  applications. You should rely on ``MIGRATION_STAGES_FALLBACK`` and  ``MIGRATION_STAGES_OVERRIDE`` to configure stages if it doesn't work for your  setup... _`Python module`: https://docs.python.org/3/library/site.htmlMigration quorum----------------When deploying migrations to multiple clusters sharing the same database it'simportant that:1. Migrations are applied only once2. Pre-deployment migrations are applied before deployment in any clusters is   takes place3. Post-deployment migrations are only applied once all clusters are done   deployingThe built-in ``migrate`` command doesn't offer any guarantees with regards toserializability of invocations, in other words naively calling ``migrate`` frommultiple clusters before or after a deployment could cause some migrations tobe attempted to be applied twice.To circumvent this limitation Syzygy introduces a ``--quorum &lt;N:int&gt;`` flag to the``migrate`` command that allow clusters coordination to take place.When specified the ``migrate --quorum &lt;N:int&gt;`` command will wait for at least``N`` number invocations of ``migrate`` for the planned migrations before proceedingwith applying them once and blocking on all callers until the operation completes.In order to use the ``--quorum`` feature you must configure the ``MIGRATION_QUORUM_BACKEND``setting to point to a quorum backend such as cache based one provided by Sygyzy.. code:: python    MIGRATION_QUORUM_BACKEND = 'syzygy.quorum.backends.cache.CacheQuorum'or.. code:: python    CACHES = {        ...,        'quorum': {            ...        },    }    MIGRATION_QUORUM_BACKEND = {        'backend': 'syzygy.quorum.backends.cache.CacheQuorum',        'alias': 'quorum',    }.. note::  In order for ``CacheQuorum`` to work properly in a distributed environment it  must be pointed at a backend that supports atomic ``incr`` operations such as  Memcached or Redis.Development-----------Make your changes, and then run tests via tox:.. code:: sh    tox</longdescription>
</pkgmetadata>