<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Myst Python LibraryThis is the official Python client library for the Myst Platform.## Requirements- Python 3.7+## InstallationTo install the package from PyPI:    $ pip install --upgrade myst-alpha## AuthenticationThe Myst API uses JSON Web Tokens (JWTs) to authenticate requests.The Myst Python library handles the sending of JWTs to the API automatically and currently supports two ways toauthenticate to obtain a JWT: through your Google user account or a Myst service account.### Authenticating using your user accountIf you don't yet have a Google account, you can create one on the[Google Account Signup](https://accounts.google.com/signup) page.Once you have access to a Google account, send an email to `support@myst.ai` with your email so we can authorize you touse the Myst Platform.Use the following code snippet to authenticate using your user account:```pythonimport mystmyst.authenticate()```The first time you run this, you'll be presented with a web browser and asked to authorize the Myst Python library tomake requests on behalf of your Google user account. If you'd like to re-authorize (for example with a differentaccount), pass `use_cache=False` to be presented with the web browser authorization once again.### Authenticating using a service accountYou can also authenticate using a Myst service account. To request a service account, email `support@myst.ai`.To authenticate using a service account, set the `MYST_APPLICATION_CREDENTIALS` environment variable to the path to yourservice account key file:```sh$ export MYST_APPLICATION_CREDENTIALS=&lt;/path/to/key/file.json&gt;```Then, go through the service account authentication flow:```pythonimport mystmyst.authenticate_with_service_account()```Alternatively, you can explicitly pass the path to your service account key:```pythonfrom pathlib import Pathimport mystmyst.authenticate_with_service_account(key_file_path=Path(&quot;/path/to/key/file.json&quot;))```## Connecting to a different environmentContributors may want to connect to a non-production environment that they are authorized to develop in. In that case,you can set the client with the API host you'd like to connect to.```pythonimport mystmyst.set_client(myst.Client(api_host=&quot;https://petstore.api&quot;))myst.authenticate()```## Working with projects and graphsA project is a workspace for setting up a graph of sources, models, operations, and time series to achieve a particularobjective. The sources, model, operations, and time series therein are _nodes_ of the graph, and they are connected bydifferent types of _edges_.For more of a conceptual overview, see [the platform documentation](https://docs.myst.ai/docs). The following assumessome familiarity with those concepts and focuses instead on demonstrating how to use the Myst client library tointeract with the platform.### Projects#### Create a project```pythonimport mystproject = myst.Project.create(title=&quot;SF Electricity Load&quot;)```#### List projects```pythonimport mystprojects = myst.Project.list()```#### Retrieve a project```pythonimport mystproject = myst.Project.get(uuid=&quot;f89d7fbe-a051-4d0c-aa60-d6838b7e64a0&quot;)```#### Update a project```pythonimport mystproject = myst.Project.get(uuid=&quot;f89d7fbe-a051-4d0c-aa60-d6838b7e64a0&quot;)project = project.update(title=&quot;My Project&quot;)```#### Delete a project```pythonimport mystproject = myst.Project.get(uuid=&quot;f89d7fbe-a051-4d0c-aa60-d6838b7e64a0&quot;)project.delete()```#### Filter a project by title```pythonimport mystprojects = myst.Project.filter(title=&quot;My title&quot;)```### Nodes (Sources, Models, Operations, Time Series)A node (source, model, operation, or time series) is always associated with a project, and there are multiple patternsin the client library API by which you can list or create them.#### Create a nodeFor example, suppose you want to create a temperature time series to be used as a feature in your model. Assuming thatyou have the variable `project: Project` in scope, you can write the following to create a new time series:```pythonksfo_temperature_time_series = project.create_time_series(    title=&quot;Temperature (KSFO)&quot;,    sample_period=myst.TimeDelta(&quot;PT1H&quot;),  # Sample period of one hour. &quot;PT1H&quot; is an ISO 8601 duration string.)```Or, to exactly the same effect:```pythonimport mystksfo_temperature_time_series = myst.TimeSeries.create(    project=project,  # Notice that project must be specified in this formulation.    title=&quot;Temperature (KSFO)&quot;,    sample_period=myst.TimeDelta(&quot;PT1H&quot;),)```This is true for the other types of nodes, too. In all, the client library offers the following equivalent ways tocreate the different types of nodes:- `project.create_source(...)` &lt;=&gt; `Source.create(project=project, ...)`- `project.create_operation(...)` &lt;=&gt; `Operation.create(project=project, ...)`- `project.create_model(...)` &lt;=&gt; `Model.create(project=project, ...)`- `project.create_time_series(...)` &lt;=&gt; `TimeSeries.create(project=project, ...)`#### Create a node with connectorFor nodes that are powered by connectors, you must specify the parameters of that connector during construction. Forexample, suppose you wanted to create a source node based on The Weather Company's Cleaned Observations API, to be usedas the source of temperature data in the time series we created above. To do so, you would write:```pythonfrom myst.connectors.source_connectors import cleaned_observationsksfo_cleaned_observations = project.create_source(    title=&quot;Cleaned Weather (KSFO)&quot;,    connector=cleaned_observations.CleanedObservations(        latitude=37.619,        longitude=-122.374,        fields=[            cleaned_observations.Field.SURFACE_TEMPERATURE_CELSIUS,        ],    ),)````Model` and `Operation` nodes are constructed similarly. As another example, if we wanted to take the 3-hour rollingmean of the temperature, we could create an operation as follows:```pythonimport mystfrom myst.connectors.operation_connectors import time_transformationsrolling_mean_ksfo_temperature = project.create_operation(    title=&quot;Temperature (KSFO) - 3H Rolling Mean&quot;,    connector=time_transformations.TimeTransformations(        rolling_window_parameters=time_transformations.RollingWindowParameters(            window_period=myst.TimeDelta(&quot;PT3H&quot;),            min_periods=1,            centered=False,            aggregation_function=time_transformations.AggregationFunction.MEAN,        )    ),)```We will see how to connect an input to this operation [in a following step](#create-an-input).#### List nodes in a project```pythonnodes = project.list_nodes()```#### Retrieve a node```pythonimport mystmodel = myst.Model.get(    project=&quot;05703aea-7319-4623-810d-b92b58692906&quot;,    uuid=&quot;a5ba722c-6750-4796-8b43-230b5e0f4c4a&quot;,)```Similar for `myst.Source.get`, `myst.Operation.get`, and `myst.TimeSeries.get`.#### Update a node```pythonimport mystmodel = myst.Model.get(    project=&quot;05703aea-7319-4623-810d-b92b58692906&quot;,    uuid=&quot;a5ba722c-6750-4796-8b43-230b5e0f4c4a&quot;,)model = model.update(title=&quot;My Model&quot;)```Similar for updating `Source`, `Operation`, and `TimeSeries` instances.### Edges (Inputs, Layers)#### Create a layerA layer is an edge that feeds into a time series. You can create a layer into a time series with either:```pythonimport mystfrom myst.connectors.source_connectors import cleaned_observationslayer = ksfo_temperature_time_series.create_layer(    node=ksfo_cleaned_observations,    order=0,    end_timing=myst.TimeDelta(&quot;-PT23H&quot;),    label_indexer=cleaned_observations.Field.SURFACE_TEMPERATURE_CELSIUS.value,)```or:```pythonimport mystfrom myst.connectors.source_connectors import cleaned_observationslayer = myst.Layer.create(    time_series=ksfo_temperature_time_series,    node=ksfo_cleaned_observations,    order=0,    end_timing=myst.TimeDelta(&quot;-PT23H&quot;),    label_indexer=cleaned_observations.Field.SURFACE_TEMPERATURE_CELSIUS.value,)```#### Update a layer```pythonimport mystlayer = myst.Layer.get(    project=&quot;05703aea-7319-4623-810d-b92b58692906&quot;,    uuid=&quot;a5ba722c-6750-4796-8b43-230b5e0f4c4a&quot;,)layer = layer.update(order=2)```#### Create an inputAn input is an edge that feeds into a model or an operation. To connect the temperature time series into the operationwe constructed before, we would write:```pythonfrom myst.connectors.operation_connectors import time_transformationsoperation_input = rolling_mean_ksfo_temperature.create_input(    time_series=ksfo_temperature_time_series,    group_name=time_transformations.GroupName.OPERANDS,)```As always, this creation method is also available as:```pythonimport mystfrom myst.connectors.operation_connectors import time_transformationsoperation_input = myst.Input.create(    time_series=rolling_mean_ksfo_temperature,    node=ksfo_temperature_time_series,    group_name=time_transformations.GroupName.OPERANDS,)```#### Update an input```pythonimport mystinput_ = myst.Input.get(    project=&quot;05703aea-7319-4623-810d-b92b58692906&quot;,    uuid=&quot;a5ba722c-6750-4796-8b43-230b5e0f4c4a&quot;,)input_ = input_.update(group_name=&quot;My Group Name&quot;)```#### List time series layers```pythonlayers = ksfo_temperature_time_series.list_layers()```#### List model/operation inputs```pythoninputs = rolling_mean_ksfo_temperature.list_inputs()```## Working with time seriesTime series are at the core of Myst's API. In addition to the functionality offered by a generic node, time series alsosupport querying and inserting data.First, retrieve a time series:```pythonimport mysttime_series = myst.TimeSeries.get(    project=&quot;40bcb171-1c51-4497-9524-914630818aeb&quot;,    uuid=&quot;ca2a63d1-3515-47b4-afc7-13c6656dd744&quot;,)```To insert a `TimeArray` of random scalar data into the time series:```pythonimport mystimport numpy as nptime_array = myst.TimeArray(    sample_period=&quot;PT1H&quot;,    start_time=&quot;2021-07-01T00:00:00Z&quot;,    end_time=&quot;2021-07-08T00:00:00Z&quot;,    as_of_time=&quot;2021-07-01T00:00:00Z&quot;,    values=np.random.randn(168),)time_series.insert_time_array(time_array=time_array)```You can also query a time series for a given as of time and natural time range. In this example, the query will returnthe data we just inserted:```pythonimport mystreturned_time_array = time_series.query_time_array(    start_time=myst.Time(&quot;2021-07-01T00:00:00Z&quot;),    end_time=myst.Time(&quot;2021-07-08T00:00:00Z&quot;),    as_of_time=myst.Time(&quot;2021-07-01T00:00:00Z&quot;),)assert returned_time_array == time_array```You are also able to update a time series.```pythonimport mysttime_series = myst.TimeSeries.get(    project=&quot;40bcb171-1c51-4497-9524-914630818aeb&quot;,    uuid=&quot;ca2a63d1-3515-47b4-afc7-13c6656dd744&quot;,)time_series = time_series.update(title=&quot;My Time Series&quot;)```You are also able to create an ad-hoc time series run job.```pythonimport mysttime_series = myst.TimeSeries.get(    project=&quot;40bcb171-1c51-4497-9524-914630818aeb&quot;,    uuid=&quot;ca2a63d1-3515-47b4-afc7-13c6656dd744&quot;,)time_series_run_job = time_series.run(    start_timing=myst.Time(&quot;2022-07-28T00:00:00Z&quot;),    end_timing=myst.Time(&quot;2022-08-10T00:00:00Z&quot;))time_series_run_job = time_series_run_job.wait_until_completed()result = time_series.get_run_result(uuid=time_series_run_job.result)```## Working with modelsModels are at the core of Myst's API. In addition to the functionality offered by a generic node, models alsosupport creating an ad-hoc fit job.You are able to create an ad-hoc model fit job.```pythonimport mystmodel = myst.Model.get(    project=&quot;40bcb171-1c51-4497-9524-914630818aeb&quot;,    uuid=&quot;ca2a63d1-3515-47b4-afc7-13c6656dd744&quot;,)model_fit_job = model.fit(    start_timing=myst.Time(&quot;2022-07-28T00:00:00Z&quot;),    end_timing=myst.Time(&quot;2022-08-10T00:00:00Z&quot;))model_fit_job = model_fit_job.wait_until_completed()result = model.get_fit_result(uuid=model_fit_job.result)```## Working with policiesA policy is the way to specify the schedule on which a particular target will be fit or run, as well as the parametersaround the target time range.At the time of this writing, the Myst Platform supports two types of policies: _time series run policies_ and _model fitpolicies_.### Time series run policies#### Create a time series run policy```pythonimport mystksfo_temp_run_policy = ksfo_temperature_time_series.create_run_policy(    schedule_timing=myst.TimeDelta(&quot;PT1H&quot;),  # Run every hour.    start_timing=myst.TimeDelta(&quot;PT1H&quot;),  # Run on data starting from an hour from now (inclusive)...    end_timing=myst.TimeDelta(&quot;P7D&quot;),  # ...up to 7 days from now (exclusive).)```#### Update a time series run policy```pythonimport mysttime_series_run_policy = myst.TimeSeriesRunPolicy.get(    project=&quot;05703aea-7319-4623-810d-b92b58692906&quot;,    uuid=&quot;a5ba722c-6750-4796-8b43-230b5e0f4c4a&quot;,)time_series_run_policy = time_series_run_policy.update(active=False)```### Model fit policiesSuppose we have a variable `xgboost_model` that contains a value of type `Model`.#### Create a model fit policy```pythonimport mystxgboost_model_fit_policy = xgboost_model.create_fit_policy(    schedule_timing=myst.TimeDelta(&quot;PT24H&quot;),  # Run every 24 hours.    start_timing=myst.Time(&quot;2021-01-01T00:00:00Z&quot;),  # Fit on data from the beginning of 2021 (UTC)...    end_timing=myst.TimeDelta(&quot;-PT1H&quot;),  # ...up to an hour ago (exclusive).)```#### Update a model fit policy```pythonimport mystmodel_fit_policy = myst.ModelFitPolicy.get(    project=&quot;05703aea-7319-4623-810d-b92b58692906&quot;,    uuid=&quot;a5ba722c-6750-4796-8b43-230b5e0f4c4a&quot;,)model_fit_policy = model_fit_policy.update(active=False)```## DeployingIn order for the graph to be executed, it must first be _deployed_. The Python client library does not currently supportthis functionality; we recommend using the Myst Platform UI to deploy a project.## BacktestingIn order to run a backtest, make sure that you have created and deployed a project and graph with a model you want to backtest.### Listing backtests```pythonimport myst# Use an existing project.project = myst.Project.get(uuid=&quot;&lt;uuid&gt;&quot;)# List all backtests associated with the project.backtests = myst.Backtest.list(project=project)```### Creating and running backtest```pythonimport myst# Use an existing project.project = myst.Project.get(uuid=&quot;&lt;uuid&gt;&quot;)# Use an existing deployed model within the project.model = myst.Model.get(project=project, uuid=&quot;&lt;uuid&gt;&quot;)# Create a backtest.backtest = myst.Backtest.create(    project=project,    title=&quot;My Backtest&quot;,    model=model,    test_start_time=myst.Time(&quot;2021-07-01T00:00:00Z&quot;),    test_end_time=myst.Time(&quot;2022-01-01T00:00:00Z&quot;),    fit_start_timing=myst.TimeDelta(&quot;-P1M&quot;),    fit_end_timing=myst.TimeDelta(&quot;-PT24H&quot;),    fit_reference_timing=myst.CronTiming(cron_expression=&quot;0 0 * * 1&quot;),    predict_start_timing=myst.TimeDelta(&quot;PT1H&quot;),    predict_end_timing=myst.TimeDelta(&quot;PT24H&quot;),    predict_reference_timing=myst.CronTiming(cron_expression=&quot;0 0 * * *&quot;),)# Run the backtest.backtest.run()```### Analyze backtest resultsTo extract the result of a backtest in the client library, you can use the following code:```pythonimport myst# Use an existing project.project = myst.Project.get(uuid=&quot;&lt;uuid&gt;&quot;)# Use an existing backtest within the project.backtest = myst.Backtest.get(project=project, uuid=&quot;&lt;uuid&gt;&quot;)# Wait until the backtest is complete.backtest.wait_until_completed()# Get the result of the completed backtest.backtest_result = backtest.get_result()```Once you have extracted your backtest result, you can use the following code to generate metrics:```python# Get `mape`, `mae`, and `rmse` from the result object.metrics_dictionary = backtest_result.metrics# To calculate custom metrics, map the backtest result to a pandas data frame.result_data_frame = backtest_result.to_pandas_data_frame()# Compute some metrics for the backtest result.absolute_error_series = (result_data_frame[&quot;targets&quot;] - result_data_frame[&quot;predictions&quot;]).abs()absolute_percentage_error_series = absolute_error_series / result_data_frame[&quot;targets&quot;].abs()# Create an index with the prediction horizons.horizon_index = (    result_data_frame.index.get_level_values(&quot;time&quot;) -    result_data_frame.index.get_level_values(&quot;reference_time&quot;))# Print the MAE and MAPE for each prediction horizon.print(absolute_error_series.groupby(horizon_index).mean())print(absolute_percentage_error_series.groupby(horizon_index).mean())```### update a backtest```pythonimport mystbacktest = myst.Backtest.get(    project=&quot;05703aea-7319-4623-810d-b92b58692906&quot;,    uuid=&quot;a5ba722c-6750-4796-8b43-230b5e0f4c4a&quot;,)backtest = backtest.update(title=&quot;My backtest&quot;)```## HPOIn order to run an HPO, make sure that you have created a project and graph with a model you want to optimize.### Listing HPOs```pythonimport myst# Use an existing project.project = myst.Project.get(uuid=&quot;&lt;uuid&gt;&quot;)# List all HPOs associated with the project.hpos = myst.HPO.list(project=project)```### Creating and running HPO```pythonimport myst# Use an existing project.project = myst.Project.get(uuid=&quot;&lt;uuid&gt;&quot;)# Use an existing deployed model within the project.model = myst.Model.get(project=project, uuid=&quot;&lt;uuid&gt;&quot;)# Create an hpo.hpo = myst.HPO.create(    project=project,    title=&quot;My HPO&quot;,    model=model,    search_space={        &quot;num_boost_round&quot;: myst.hpo.LogUniform(lower=100, upper=1000),        &quot;max_depth&quot;: myst.hpo.QUniform(lower=1, upper=12, q=1),        &quot;learning_rate&quot;: myst.hpo.LogUniform(lower=0.005, upper=0.2),        &quot;min_child_weight&quot;: myst.hpo.QUniform(lower=0, upper=100, q=5),    },    search_algorithm=myst.hpo.Hyperopt(num_trials=10, max_concurrent_trials=5),    test_start_time=myst.Time(&quot;2021-07-01T00:00:00Z&quot;),    test_end_time=myst.Time(&quot;2022-01-01T00:00:00Z&quot;),    fit_start_timing=myst.TimeDelta(&quot;-P1M&quot;),    fit_end_timing=myst.TimeDelta(&quot;-PT24H&quot;),    fit_reference_timing=myst.CronTiming(cron_expression=&quot;0 0 * * 1&quot;),    predict_start_timing=myst.TimeDelta(&quot;PT1H&quot;),    predict_end_timing=myst.TimeDelta(&quot;PT24H&quot;),    predict_reference_timing=myst.CronTiming(cron_expression=&quot;0 0 * * *&quot;),)# Run the HPO.hpo.run()```### Analyze HPO resultsTo extract the result of an HPO in the client library, you can use the following code:```pythonimport myst# Use an existing project.project = myst.Project.get(uuid=&quot;&lt;uuid&gt;&quot;)# Use an existing HPO within the project.hpo = myst.HPO.get(project=project, uuid=&quot;&lt;uuid&gt;&quot;)# Wait until the HPO is complete.hpo.wait_until_completed()# Get the result of the completed HPO.hpo_result = hpo.get_result()```Once you have extracted your HPO result, you can use the following code to get the optimize parametersand the metrics from the best_trial:```python# Get the optimized parameters for the best trial.parameters = hpo_result.best_trial.parameters# Get the pre-computed metrics for the best trial.metrics = hpo_result.best_trial.metrics```### update an HPO```pythonimport mysthpo = myst.HPO.get(    project=&quot;05703aea-7319-4623-810d-b92b58692906&quot;,    uuid=&quot;a5ba722c-6750-4796-8b43-230b5e0f4c4a&quot;,)hpo = hpo.update(title=&quot;My HPO&quot;)```## Further ExamplesFor more full-featured usage examples of the Myst Platform Python client library, see the`/examples` folder.## SupportFor questions or just to say hi, reach out to `support@myst.ai`.</longdescription>
</pkgmetadata>