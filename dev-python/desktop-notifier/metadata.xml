<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![PyPi Release](https://img.shields.io/pypi/v/desktop-notifier.svg)](https://pypi.org/project/desktop-notifier/)[![Pyversions](https://img.shields.io/pypi/pyversions/desktop-notifier.svg)](https://pypi.org/pypi/desktop-notifier/)[![Documentation Status](https://readthedocs.org/projects/desktop-notifier/badge/?version=latest)](https://desktop-notifier.readthedocs.io/en/latest/?badge=latest)# Desktop Notifier`desktop-notifier`  is a Python library for cross-platform desktop notifications.Currently supported platforms are:* Linux via the dbus service org.freedesktop.Notifications* macOS and iOS via the Notification Center framework* [**exprimental**] Windows via the WinRT / Python bridge.![gif](screenshots/macOS.gif)## FeaturesWhere supported by the native platform APIs:* Clickable notifications* Multiple action buttons* A single reply field (e.g., for chat notifications)* Asyncio integration: the main API consists of async methods and a running event loop  is required to respond to user interactions with a notification* Notification sounds* Notification threads (e.g., for different conversations)* Limit maximum number of notifications shown in the notification center* Pure Python dependencies only, no extension modules## InstallationFrom PyPI:```pip3 install -U desktop-notifier```## UsageThe main API consists of asynchronous methods which need to be awaited. Basic usage onlyrequires the user to specify a notification title and message. For instance:```Pythonimport asynciofrom desktop_notifier import DesktopNotifiernotifier = DesktopNotifier()async def main():    n = await notifier.send(title=&quot;Hello world!&quot;, message=&quot;Sent from Python&quot;)        await asyncio.sleep(5)  # wait a bit before clearing notification    await notifier.clear(n)  # removes the notification    await notifier.clear_all()  # removes all notifications for this appasyncio.run(main())```For convenience, the is also a synchronous method ``send_sync()`` to send notificationswhich does not require a running asyncio loop:```Pythonnotifier.send_sync(title=&quot;Hello world!&quot;, message=&quot;Sent from Python&quot;)```By default, &quot;Python&quot; will be used as the app name for all notifications, but you canmanually specify an app name and icon in the ``DesktopNotifier`` constructor. Advancedusage also allows setting different notification options such as urgency, buttons,callbacks, etc. The following code will generate the notification shown in the gif atthe top of the page:```Pythonimport asynciofrom desktop_notifier import DesktopNotifier, Urgency, Button, ReplyFieldnotifier = DesktopNotifier()async def main():  await notifier.send(      title=&quot;Julius Caesar&quot;,      message=&quot;Et tu, Brute?&quot;,      urgency=Urgency.Critical,      buttons=[        Button(          title=&quot;Mark as read&quot;,          on_pressed=lambda: print(&quot;Marked as read&quot;)),      ],      reply_field=ReplyField(        title=&quot;Reply&quot;,        button_title=&quot;Send&quot;,        on_replied=lambda text: print(&quot;Brutus replied:&quot;, text),      ),      on_clicked=lambda: print(&quot;Notification clicked&quot;),      on_dismissed=lambda: print(&quot;Notification dismissed&quot;),      sound=True,  )  loop = asyncio.get_event_loop()loop.create_task(main())loop.run_forever()```Note that some platforms may not support all options. For instance, some Linux desktopenvironments may not support notifications with buttons. macOS does not supportmanually setting the app icon or name. Instead, both are always determined by theapplication which uses the Library. This can be Python itself, when used interactively,or a frozen app bundle when packaged with PyInstaller or similar solutions. Please referto the [Platform Support](https://desktop-notifier.readthedocs.io/en/latest/background/platform_support.html)chapter of the documentation for more information on limitations for certain platforms.Any options or configurations which are not supported by the platform will be silentlyignored. Please refer to the documentation on [Read the Docs](https://desktop-notifier.readthedocs.io)for more information on platform support.## Event loop integrationUsing the asynchronous API is highly recommended to prevent multiple milliseconds ofblocking IO from DBus or Cocoa APIs. In addition, execution of callbacks requires arunning event loop. On Linux, an asyncio event loop will be sufficient but macOSrequires a running [CFRunLoop](https://developer.apple.com/documentation/corefoundation/cfrunloop-rht).You can use [rubicon-objc](https://github.com/beeware/rubicon-objc) to integrate a CoreFoundation CFRunLoop with asyncio:```Pythonimport asynciofrom rubicon.objc.eventloop import EventLoopPolicy# Install the event loop policyasyncio.set_event_loop_policy(EventLoopPolicy())# Get an event loop, and run it!loop = asyncio.get_event_loop()loop.run_forever()```Desktop-notifier itself uses Rubicon Objective-C to interface with Cocoa APIs so youwill not be adding a new dependency. A full example integrating with the CFRunLoop isgiven in [examples/eventloop.py](examples/eventloop.py). Please refer to the[Rubicon Objective-C docs](https://rubicon-objc.readthedocs.io/en/latest/how-to/async.html)for more information.Likewise, you can integrate the asyncio event loop with a Gtk main loop on Gnome using[gbulb](https://pypi.org/project/gbulb). This is not required for full functionalitybut may be convenient when developing a Gtk app.## Notes on macOSOn macOS 10.14 and higher, the implementation uses the `UNUserNotificationCenter`instead of the deprecated `NSUserNotificationCenter`. `UNUserNotificationCenter`only allows signed executables to send desktop notifications. This means thatnotifications will only work if the Python executable or bundled app has been signed.Note that the installer from [python.org](https://python.org) provides a properly signedPython framework but **homebrew does not** (manually signing the executable installedby homebrew _should_ work as well).If you freeze your code with PyInstaller or a similar packaging solution, you must sign the resulting app bundle for notifications to work. An ad-hoc signature will besufficient but signing with an Apple developer certificate is recommended fordistribution and may be required on future releases of macOS.## Requirements* macOS 10.13 or higher* Linux desktop environment providing a dbus desktop notifications service## Dependencies* [dbus-next](https://github.com/altdesktop/python-dbus-next) on Linux* [rubicon-objc](https://github.com/beeware/rubicon-objc) on macOS</longdescription>
</pkgmetadata>