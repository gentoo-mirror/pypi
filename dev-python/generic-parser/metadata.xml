<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Generic Parser[![Cron Testing](https://github.com/pylhc/generic_parser/workflows/Cron%20Testing/badge.svg)](https://github.com/pylhc/generic_parser/actions?query=workflow%3A%22Cron+Testing%22)[![Code Climate coverage](https://img.shields.io/codeclimate/coverage/pylhc/generic_parser.svg?style=popout)](https://codeclimate.com/github/pylhc/generic_parser)[![Code Climate maintainability (percentage)](https://img.shields.io/codeclimate/maintainability-percentage/pylhc/generic_parser.svg?style=popout)](https://codeclimate.com/github/pylhc/generic_parser)&lt;!-- [![GitHub last commit](https://img.shields.io/github/last-commit/pylhc/generic_parser.svg?style=popout)](https://github.com/pylhc/generic_parser/) --&gt;[![PyPI Version](https://img.shields.io/pypi/v/generic_parser?label=PyPI&amp;logo=pypi)](https://pypi.org/project/generic_parser/)[![GitHub release](https://img.shields.io/github/v/release/pylhc/generic_parser?logo=github)](https://github.com/pylhc/generic_parser/)[![Conda-forge Version](https://img.shields.io/conda/vn/conda-forge/generic_parser?color=orange&amp;logo=anaconda)](https://anaconda.org/conda-forge/generic_parser)[![DOI](https://zenodo.org/badge/201085116.svg)](https://zenodo.org/badge/latestdoi/201085116)The package provides an all-around parser for arguments and config-files.The creation of the arguments is similar to the ones from argparse, but the input can then be either from command line, a config file or directly from python.See the [API documentation](https://pylhc.github.io/generic_parser/) for details.## InstallingInstallation is easily done via `pip`. The package is then used as `generic_parser`.```bashpython -m pip install generic-parser```One can also install in a `conda` environment via the `conda-forge` channel with:```bashconda install -c conda-forge generic_parser```## Example Usage:Content of `myscript.py````pythonfrom generic_parser import entrypoint, EntryPointParametersdef get_arguments():    args = EntryPointParameters()    args.add_parameter(name=&quot;first&quot;,                       flags=[&quot;-f&quot;, &quot;--first&quot;],                       help=&quot;First Parameter, an int&quot;,                       choices=[1, 2, 3],                       type=int,                       required=True,                       )    args.add_parameter(name=&quot;second&quot;,                       flags=[&quot;-s&quot;, &quot;--second&quot;],                       help=&quot;Second Parameter, a string&quot;,                       type=str,                       default=&quot;default&quot;,                       required=False,                       )    return args@entrypoint(get_arguments())def main(opt, unknown):    print(opt.first == 1)    print(opt.second == &quot;default&quot;)if __name__ == '__main__':    main()```### CommandlineCalling that script with ``python myscript.py -f 1 -s &quot;test&quot;`` will result in:```TrueFalse```It is assumed, that this is the standard mode of operation for your functions.#### Config FileFurther, one can also use a config file `config.ini` containing:```[Section]first = 2second = &quot;Hello&quot;```and run the script with `python myscript.py --entry_cfg config.ini` leading to```FalseFalse```Config files are very useful if you want to rerun your code with the same or similar parameters.Especially the declaration of a `[DEFAULT]` section can be helpful.For further information about config files, check the python [Config Parser](https://docs.python.org/3/library/configparser.html).### PythonOr call the function directly from python code:```pythonif __name__ == '__main__':    main(first=1, second=&quot;World&quot;)``````TrueFalse```This is incredibly helpful if one wants to write python-wrappers around entrypoint-functions,and does not want to resort to commandline calls from python.Note that also in this case all variables are validated, courtesy of the `dict_parser`.`dict_parser` provides even multi-level dictionary checking functionality,which is not used in the `Entrypoint`, but can be handy in other use-cases.## LicenseThis project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details</longdescription>
</pkgmetadata>