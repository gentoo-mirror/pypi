<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Prometheus FastAPI Instrumentator &lt;!-- omit in toc --&gt;[![pypi-version](https://badge.fury.io/py/prometheus-fastapi-instrumentator.svg)](https://pypi.python.org/pypi/prometheus-fastapi-instrumentator)[![python-versions](https://img.shields.io/pypi/pyversions/prometheus-fastapi-instrumentator.svg)](https://pypi.python.org/pypi/prometheus-fastapi-instrumentator)[![downloads](https://pepy.tech/badge/prometheus-fastapi-instrumentator/month)](https://pepy.tech/project/prometheus-fastapi-instrumentator/month)[![build](https://img.shields.io/github/actions/workflow/status/trallnag/kubestatus2cloudwatch/ci.yaml?branch=master)](https://github.com/trallnag/kubestatus2cloudwatch/actions)[![codecov](https://codecov.io/gh/trallnag/prometheus-fastapi-instrumentator/branch/master/graph/badge.svg)](https://codecov.io/gh/trallnag/prometheus-fastapi-instrumentator)A configurable and modular Prometheus Instrumentator for your FastAPI. Install`prometheus-fastapi-instrumentator` from[PyPI](https://pypi.python.org/pypi/prometheus-fastapi-instrumentator/). Here isthe fast track to get started with a pre-configured instrumentator. Import theinstrumentator class:```pythonfrom prometheus_fastapi_instrumentator import Instrumentator```Instrument your app with default metrics and expose the metrics:```pythonInstrumentator().instrument(app).expose(app)```Depending on your code you might have to use the following instead:```pythoninstrumentator = Instrumentator().instrument(app)@app.on_event(&quot;startup&quot;)async def _startup():    instrumentator.expose(app)```With this, your FastAPI is instrumented and metrics are ready to be scraped. Thedefaults give you:- Counter `http_requests_total` with `handler`, `status` and `method`. Total  number of requests.- Summary `http_request_size_bytes` with `handler`. Added up total of the  content lengths of all incoming requests.- Summary `http_response_size_bytes` with `handler`. Added up total of the  content lengths of all outgoing responses.- Histogram `http_request_duration_seconds` with `handler` and `method`. Only a  few buckets to keep cardinality low.- Histogram `http_request_duration_highr_seconds` without any labels. Large  number of buckets (&gt;20).In addition, following behavior is active:- Status codes are grouped into `2xx`, `3xx` and so on.- Requests without a matching template are grouped into the handler `none`.If one of these presets does not suit your needs you can do one of multiplethings:- Pick one of the already existing closures from  [`metrics`](./src/prometheus_fastapi_instrumentator/metrics.py) and pass it to  the instrumentator instance. See [here](#adding-metrics) how to do that.- Create your own instrumentation function that you can pass to an  instrumentator instance. See [here](#creating-new-metrics) to learn how more.- Don't use this package at all and just use the source code as inspiration on  how to instrument your FastAPI.## Table of Contents &lt;!-- omit in toc --&gt;&lt;!--TOC--&gt;- [Disclaimer](#disclaimer)- [Features](#features)- [Advanced Usage](#advanced-usage)  - [Creating the Instrumentator](#creating-the-instrumentator)  - [Adding metrics](#adding-metrics)  - [Creating new metrics](#creating-new-metrics)  - [Perform instrumentation](#perform-instrumentation)  - [Specify namespace and subsystem](#specify-namespace-and-subsystem)  - [Exposing endpoint](#exposing-endpoint)- [Contributing](#contributing)- [Licensing](#licensing)&lt;!--TOC--&gt;## DisclaimerNot made for generic Prometheus instrumentation in Python. Use the Prometheusclient library for that. This packages uses it as well.All the generic middleware and instrumentation code comes with a cost inperformance that can become noticeable.## FeaturesBeyond the fast track, this instrumentator is **highly configurable** and it isvery easy to customize and adapt to your specific use case. Here is a list ofsome of these options you may opt-in to:- Regex patterns to ignore certain routes.- Completely ignore untemplated routes.- Control instrumentation and exposition with an env var.- Rounding of latencies to a certain decimal number.- Renaming of labels and the metric.- Metrics endpoint can compress data with gzip.- Opt-in metric to monitor the number of requests in progress.It also features a **modular approach to metrics** that should instrument allFastAPI endpoints. You can either choose from a set of already existing metricsor create your own. And every metric function by itself can be configured aswell. You can see ready to use metrics[here](https://trallnag.github.io/prometheus-fastapi-instrumentator/metrics.html).## Advanced UsageThis chapter contains an example on the advanced usage of the Prometheus FastAPIInstrumentator to showcase most of it's features. Fore more concrete info checkout the[automatically generated documentation](https://trallnag.github.io/prometheus-fastapi-instrumentator/).### Creating the InstrumentatorWe start by creating an instance of the Instrumentator. Notice the additional`metrics` import. This will come in handy later.```pythonfrom prometheus_fastapi_instrumentator import Instrumentator, metricsinstrumentator = Instrumentator(    should_group_status_codes=False,    should_ignore_untemplated=True,    should_respect_env_var=True,    should_instrument_requests_inprogress=True,    excluded_handlers=[&quot;.*admin.*&quot;, &quot;/metrics&quot;],    env_var_name=&quot;ENABLE_METRICS&quot;,    inprogress_name=&quot;inprogress&quot;,    inprogress_labels=True,)```Unlike in the fast track example, now the instrumentation and exposition willonly take place if the environment variable `ENABLE_METRICS` is `true` atrun-time. This can be helpful in larger deployments with multiple servicesdepending on the same base FastAPI.### Adding metricsLet's say we also want to instrument the size of requests and responses. Forthis we use the `add()` method. This method does nothing more than taking afunction and adding it to a list. Then during run-time every time FastAPIhandles a request all functions in this list will be called while giving them asingle argument that stores useful information like the request and responseobjects. If no `add()` at all is used, the default metric gets added in thebackground. This is what happens in the fast track example.All instrumentation functions are stored as closures in the `metrics` module.Fore more concrete info check out the[automatically generated documentation](https://trallnag.github.io/prometheus-fastapi-instrumentator/).Closures come in handy here because it allows us to configure the functionswithin.```pythoninstrumentator.add(metrics.latency(buckets=(1, 2, 3,)))```This simply adds the metric you also get in the fast track example with amodified buckets argument. But we would also like to record the size of allrequests and responses.```pythoninstrumentator.add(    metrics.request_size(        should_include_handler=True,        should_include_method=False,        should_include_status=True,        metric_namespace=&quot;a&quot;,        metric_subsystem=&quot;b&quot;,    )).add(    metrics.response_size(        should_include_handler=True,        should_include_method=False,        should_include_status=True,        metric_namespace=&quot;namespace&quot;,        metric_subsystem=&quot;subsystem&quot;,    ))```You can add as many metrics you like to the instrumentator.### Creating new metricsAs already mentioned, it is possible to create custom functions to pass on to`add()`. This is also how the default metrics are implemented. The documentationand code[here](https://trallnag.github.io/prometheus-fastapi-instrumentator/metrics.html)is helpful to get an overview.The basic idea is that the instrumentator creates an `info` object that containseverything necessary for instrumentation based on the configuration of theinstrumentator. This includes the raw request and response objects but also themodified handler, grouped status code and duration. Next, all registeredinstrumentation functions are called. They get `info` as their single argument.Let's say we want to count the number of times a certain language has beenrequested.```pythonfrom typing import Callablefrom prometheus_fastapi_instrumentator.metrics import Infofrom prometheus_client import Counterdef http_requested_languages_total() -&gt; Callable[[Info], None]:    METRIC = Counter(        &quot;http_requested_languages_total&quot;,        &quot;Number of times a certain language has been requested.&quot;,        labelnames=(&quot;langs&quot;,)    )    def instrumentation(info: Info) -&gt; None:        langs = set()        lang_str = info.request.headers[&quot;Accept-Language&quot;]        for element in lang_str.split(&quot;,&quot;):            element = element.split(&quot;;&quot;)[0].strip().lower()            langs.add(element)        for language in langs:            METRIC.labels(language).inc()    return instrumentation```The function `http_requested_languages_total` is used for persistent elementsthat are stored between all instrumentation executions (for example the metricinstance itself). Next comes the closure. This function must adhere to the showninterface. It will always get an `Info` object that contains the request,response and a few other modified informations. For example the (grouped) statuscode or the handler. Finally, the closure is returned.**Important:** The response object inside `info` can either be the responseobject or `None`. In addition, errors thrown in the handler are not caught bythe instrumentator. I recommend to check the documentation and/or the sourcecode before creating your own metrics.To use it, we hand over the closure to the instrumentator object.```pythoninstrumentator.add(http_requested_languages_total())```### Perform instrumentationUp to this point, the FastAPI has not been touched at all. Everything has beenstored in the `instrumentator` only. To actually register the instrumentationwith FastAPI, the `instrument()` method has to be called.```pythoninstrumentator.instrument(app)```Notice that this will do nothing if `should_respect_env_var` has been set duringconstruction of the instrumentator object and the respective env var is notfound.### Specify namespace and subsystemYou can specify the namespace and subsystem of the metrics by passing them inthe instrument method.```pythonfrom prometheus_fastapi_instrumentator import Instrumentator@app.on_event(&quot;startup&quot;)async def startup():    Instrumentator().instrument(app, metric_namespace='myproject', metric_subsystem='myservice').expose(app)```Then your metrics will contain the namespace and subsystem in the metric name.```sh# TYPE myproject_myservice_http_request_duration_highr_seconds histogrammyproject_myservice_http_request_duration_highr_seconds_bucket{le=&quot;0.01&quot;} 0.0```### Exposing endpointTo expose an endpoint for the metrics either follow[Prometheus Python Client](https://github.com/prometheus/client_python) and addthe endpoint manually to the FastAPI or serve it on a separate server. You canalso use the included `expose` method. It will add an endpoint to the givenFastAPI. With `should_gzip` you can instruct the endpoint to compress the dataas long as the client accepts gzip encoding. Prometheus for example does bydefault. Beware that network bandwith is often cheaper than CPU cycles.```pythoninstrumentator.expose(app, include_in_schema=False, should_gzip=True)```Notice that this will to nothing if `should_respect_env_var` has been set duringconstruction of the instrumentator object and the respective env var is notfound.## ContributingPlease refer to [`CONTRIBUTING.md`](CONTRIBUTING).Consult [`DEVELOPMENT.md`](DEVELOPMENT.md) for guidance regarding development.Read [`RELEASE.md`](RELEASE.md) for details about the release process.## LicensingThe default license for this project is the[ISC License](https://choosealicense.com/licenses/isc). A permissive licensefunctionally equivalent to the BSD 2-Clause and MIT licenses, removing somelanguage that is no longer necessary. See [`LICENSE`](LICENSE) for the licensetext.The [BSD 3-Clause License](https://choosealicense.com/licenses/bsd-3-clause) isused as the license for the[`routing`](src/prometheus_fastapi_instrumentator/routing.py) module. This isdue to it containing code from[elastic/apm-agent-python](https://github.com/elastic/apm-agent-python). BSD3-Clause is a permissive license similar to the BSD 2-Clause License, but with a3rd clause that prohibits others from using the name of the copyright holder orits contributors to promote derived products without written consent. Thelicense text is included in the module itself.</longdescription>
</pkgmetadata>