<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pydantic-partial## InstallationJust use `pip install pydantic-partial` to install the library.**Note:** `pydantic-partial` is compatible with `pydantic` versions `1.9`, `1.10` and even `2.x` (ðŸ¥³) onPython `3.9`, `3.10` and `3.11`. This is also ensured running all tests on all those versionsusing `tox`.## AboutCreate partial models from your normal pydantic models. Partial models will allowsome or all fields to be optional and thus not be required when creating the modelinstance.Partial models can be used to support PATCH HTTP requests where the user only wantsto update some fields of the model and normal validation for required fields is notrequired. It may also be used to have partial response DTOs where you want to skipcertain fields, this can be useful in combination with `exclude_none`. It is - likeshown in these examples - intended to be used with API use cases, so when usingpydantic with for example FastAPI.**Disclaimer:** This is still an early release of `pydantic-partial`. Things mightchange in the future. PR welcome. ;-)### Usage example`pydantic-partial` provides a mixin to generate partial model classes. The mixin canbe used like this:```pythonimport pydanticfrom pydantic_partial import PartialModelMixin# Something model, then can be used as a partial, too:class Something(PartialModelMixin, pydantic.BaseModel):    name: str    age: int# Create a full partial modelFullSomethingPartial = Something.model_as_partial()FullSomethingPartial()  # Same as FullSomethingPartial(name=None, age=None)```### Without using the mixinYou also may create partial models without using the mixin:```pythonimport pydanticfrom pydantic_partial import create_partial_model# Something model, without the mixin:class Something(pydantic.BaseModel):    name: str    age: int# Create a full partial modelFullSomethingPartial = create_partial_model(Something)FullSomethingPartial()  # Same as FullSomethingPartial(name=None, age=None)```### Only changing some fields to being optional`pydantic-partial` can be used to create partial models that only change someof the fields to being optional. Just pass the list of fields to be optional tothe `as_partial()` or `create_partial_model()` function.```pythonimport pydanticfrom pydantic_partial import create_partial_modelclass Something(pydantic.BaseModel):    name: str    age: int# Create a partial model only for the name attributeFullSomethingPartial = create_partial_model(Something, 'name')FullSomethingPartial(age=40)  # Same as FullSomethingPartial(name=None, age=40)# This would still raise an error: FullSomethingPartial(age=None, ...)```### Recursive partialsPartial models can be created changing the field of all nested models to beingoptional, too.```pythonfrom typing import Listimport pydanticfrom pydantic_partial import PartialModelMixin, create_partial_modelclass InnerSomething(PartialModelMixin, pydantic.BaseModel):    name: strclass OuterSomething(pydantic.BaseModel):    name: str    things: List[InnerSomething]# Create a full partial modelRecursiveOuterSomethingPartial = create_partial_model(OuterSomething, recursive=True)RecursiveOuterSomethingPartial(things=[    {},])```**Note:** The inner model MUST extend the `PartialModelMixin` mixin. Otherwise`pydantic-partial` will not be able to detect which fields may allow to beingconverted to partial models.**Also note:** My recommendation would be to always create such recursivepartials by creating partials for all the required models and then overridethe fields on you outer partial model class. This is way more explicit.## Known limitations`pydantic-partial` cannot generate new class types that actually are supported by thePython typing system rules. This means that the partial models will only be recognizedas the same as their original model classes - type checkers will not know about the partialmodel changes and thus will think all those partial fields are still required.This is due to the fact that Python itself has no concept of partials. `pydantic-partial`could (in theory) provide plugins for `mypy` for example to &quot;patch&quot; this in, but this wouldbe a massive amount of work while being kind of a bad hack. The real solution would be tohave a partial type in Python itself, but this is not planned for the near future as faras I know.My recommendation is to use `pydantic-partial` only for API use cases where you do notneed to work with the partial aspects of the models - they are just the DTOs (data transferobjects) you are using. If you need to use partial models in other cases you might geterrors by your type checker - if you use one. Please be aware of this.**Note:** Not having a good solution in Python itself for this is the reason `pydantic` doesnot support partial models in the first place. `pydantic-partial` is just a really goodworkaround for this issue.  See [issue 2](https://github.com/team23/pydantic-partial/issues/2) in this project and[issue 1673](https://github.com/pydantic/pydantic/issues/1673#issuecomment-1557267229)in the `pydantic` project for reference.Having that all said: If anyone wants to get a working plugin for `mypy` or others ready,I'm going to very much support this.# ContributingIf you want to contribute to this project, feel free to just fork the project,create a dev branch in your fork and then create a pull request (PR). If youare unsure about whether your changes really suit the project please create anissue first, to talk about this.</longdescription>
</pkgmetadata>