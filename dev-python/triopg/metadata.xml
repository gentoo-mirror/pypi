<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://travis-ci.org/python-trio/triopg.svg?branch=master   :target: https://travis-ci.org/python-trio/triopg   :alt: Automated test status (Linux and MacOS).. image:: https://ci.appveyor.com/api/projects/status/4t8ydnax9p6ehauj/branch/master?svg=true   :target: https://ci.appveyor.com/project/touilleMan/triopg/history   :alt: Automated test status (Windows).. image:: https://codecov.io/gh/python-trio/triopg/branch/master/graph/badge.svg   :target: https://codecov.io/gh/python-trio/triopg   :alt: Test coveragetriopg======Welcome to `triopg &lt;https://github.com/python-trio/triopg&gt;`__!PostgreSQL client for `Trio &lt;https://trio.readthedocs.io/&gt;`__ based on`asyncpg &lt;https://magicstack.github.io/asyncpg/&gt;`__.License: Your choice of MIT or Apache License 2.0Quick example:.. code-block:: python    import trio_asyncio    import triopg    async def main():        async with triopg.connect() as conn:            await conn.execute(                &quot;&quot;&quot;                DROP TABLE IF EXISTS users;                CREATE TABLE IF NOT EXISTS users (                    _id SERIAL PRIMARY KEY,                    user_id VARCHAR(32) UNIQUE                )&quot;&quot;&quot;            )            async with conn.transaction():                await conn.execute(&quot;INSERT INTO users (user_id) VALUES (1)&quot;)                await conn.execute(&quot;INSERT INTO users (user_id) VALUES (2)&quot;)                await conn.execute(&quot;INSERT INTO users (user_id) VALUES (3)&quot;)            print(await conn.fetch(&quot;SELECT * FROM users&quot;))    trio_asyncio.run(main)API basics----------``triopg`` is a thin Trio-compatible wrapper around ``asyncpg``. The API is the same,with one exception - ``triopg`` does not support manual resource management.In ``asyncpg`` you can manage pools, connections and transactions manually:.. code-block:: python    conn = await asyncpg.connect()    tr = conn.transaction()    # ..    tr.commit()    conn.close()While in ``triopg`` you can *only* use ``async with`` blocks:.. code-block:: python    async with triopg.connect() as conn:        async with conn.transaction():            # ...Otherwise you can follow ``asyncpg```tutorial &lt;https://magicstack.github.io/asyncpg/current/usage.html&gt;`__ and`reference &lt;https://magicstack.github.io/asyncpg/current/api/&gt;`__.Everything should work the same way. Please`file an issue &lt;https://github.com/python-trio/triopg/issues/new&gt;`__ if it doesn't.Helpers-------In addition to ``asyncpg``-compatible API, ``triopg`` provides Trio-style``.listen()`` helper for the eponymous`Postgres statement &lt;https://www.postgresql.org/docs/current/sql-listen.html&gt;`__:.. code-block:: python    async with conn.listen('some.channel', max_buffer_size=1) as notifications:        async for notification in notifications:            if notification != triopg.NOTIFY_OVERFLOW:                print('Notification received:', notification)``max_buffer_size`` is the amount of notifications you are willing to queue in memory.If you **don't** want to think about buffering, set the buffer size to ``math.inf``and everything will just work in regular non-pathological situations.Otherwise, you can set a finite buffer. In this case you should handle``triopg.NOTIFY_OVERFLOW`` marker and react according to your use case.For example, you could re-scan the tables, like you would do at startup.Or could you simply ignore the marker if you are only interested in thenewest notifications.For detailed discussion on buffering, see Trio manual,`&quot;Buffering in channels&quot; &lt;https://trio.readthedocs.io/en/stable/reference-core.html#buffering-in-channels&gt;`__section.**Note:** we can't politely ask Postgres to slow down: ``LISTEN`` backpressure is`not supported by asyncpg &lt;https://github.com/MagicStack/asyncpg/issues/463&gt;`__.There's also an inherent challenge with Postgres. Postgres (like mostbroadcast systems) doesn't really have a good way to communicate backpressurefurther upstream to the clients that are calling ``NOTIFY``.</longdescription>
</pkgmetadata>