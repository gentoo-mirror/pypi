<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Healthcheck-----------.. image:: https://github.com/ateliedocodigo/py-healthcheck/raw/develop/py-healthcheck.jpg    :target: https://pypi.python.org/pypi/py-healthcheck.. image:: https://badge.fury.io/py/py-healthcheck.svg    :target: https://badge.fury.io/py/py-healthcheck.. image:: https://requires.io/github/ateliedocodigo/py-healthcheck/requirements.svg?branch=develop     :target: https://requires.io/github/ateliedocodigo/py-healthcheck/requirements/?branch=develop     :alt: Requirements Status.. image:: https://travis-ci.org/ateliedocodigo/py-healthcheck.svg?branch=develop    :target: https://travis-ci.org/ateliedocodigo/py-healthcheckHealthcheck is a library to write simple healthcheck functions that canbe used to monitor your application. It is possible to use in a ``Flask``app or ``Tornado`` app. It's useful for asserting that your dependenciesare up and running and your application can respond to HTTP requests.The Healthcheck functions can be exposed via a user defined ``Flask``route so you can use an external monitoring application (``monit``,``nagios``, ``Runscope``, etc.) to check the status and uptime of yourapplication.New in version 1.1: Healthcheck also gives you a simple Flask route toview information about your application's environment. By default, thisincludes data about the operating system, the Python environment, thecurrent process, and the application config. You can customize whichsections are included, or add your own sections to the output.Installing----------::    pip install py-healthcheckUsage-----Here's an example of basic usage with ``Flask``:.. code:: python    from flask import Flask    from healthcheck import HealthCheck, EnvironmentDump    app = Flask(__name__)    health = HealthCheck()    envdump = EnvironmentDump()    # add your own check function to the healthcheck    def redis_available():        client = _redis_client()        info = client.info()        return True, &quot;redis ok&quot;    health.add_check(redis_available)    # add your own data to the environment dump    def application_data():        return {&quot;maintainer&quot;: &quot;Luis Fernando Gomes&quot;,                &quot;git_repo&quot;: &quot;https://github.com/ateliedocodigo/py-healthcheck&quot;}    envdump.add_section(&quot;application&quot;, application_data)    # Add a flask route to expose information    app.add_url_rule(&quot;/healthcheck&quot;, &quot;healthcheck&quot;, view_func=lambda: health.run())    app.add_url_rule(&quot;/environment&quot;, &quot;environment&quot;, view_func=lambda: envdump.run())To use with ``Tornado`` you can import the ``TornadoHandler``:.. code:: python    import tornado.web    from healthcheck import TornadoHandler, HealthCheck, EnvironmentDump    app = tornado.web.Application()    health = HealthCheck()    envdump = EnvironmentDump()    # add your own check function to the healthcheck    def redis_available():        client = _redis_client()        info = client.info()        return True, &quot;redis ok&quot;    health.add_check(redis_available)    # add your own data to the environment dump or healthcheck    def application_data():        return {&quot;maintainer&quot;: &quot;Luis Fernando Gomes&quot;,                &quot;git_repo&quot;: &quot;https://github.com/ateliedocodigo/py-healthcheck&quot;}    # ou choose where you want to output this information    health.add_section(&quot;application&quot;, application_data)    health.add_section(&quot;version&quot;, __version__)    envdump.add_section(&quot;application&quot;, application_data)    # Add a tornado handler to expose information    app.add_handlers(        r&quot;.*&quot;,        [            (                &quot;/healthcheck&quot;,                TornadoHandler, dict(checker=health)            ),            (                &quot;/environment&quot;,                TornadoHandler, dict(checker=envdump)            ),        ]    )Alternatively you can set all together:.. code:: python    import tornado.web    from healthcheck import TornadoHandler, HealthCheck, EnvironmentDump    # add your own check function to the healthcheck    def redis_available():        client = _redis_client()        info = client.info()        return True, &quot;redis ok&quot;    health = HealthCheck(checkers=[redis_available])    # add your own data to the environment dump    def application_data():        return {&quot;maintainer&quot;: &quot;Luis Fernando Gomes&quot;,                &quot;git_repo&quot;: &quot;https://github.com/ateliedocodigo/py-healthcheck&quot;}    envdump = EnvironmentDump(application=application_data)    app = tornado.web.Application([        (&quot;/healthcheck&quot;, TornadoHandler, dict(checker=health)),        (&quot;/environment&quot;, TornadoHandler, dict(checker=envdump)),    ])To run all of your check functions, make a request to the healthcheckURL you specified, like this:::    curl &quot;http://localhost:5000/healthcheck&quot;And to view the environment data, make a check to the URL you specifiedfor EnvironmentDump:::    curl &quot;http://localhost:5000/environment&quot;The HealthCheck class---------------------Check Functions~~~~~~~~~~~~~~~Check functions take no arguments and should return a tuple of (bool,str). The boolean is whether or not the check passed. The message is anystring or output that should be rendered for this check. Useful forerror messages/debugging... code:: python    # add check functions    def addition_works():        if 1 + 1 == 2:            return True, &quot;addition works&quot;        else:            return False, &quot;the universe is broken&quot;Any exceptions that get thrown by your code will be caught and handledas errors in the healthcheck:.. code:: python    # add check functions    def throws_exception():        bad_var = None        bad_var['explode']Will output:.. code:: json    {        &quot;status&quot;: &quot;failure&quot;,        &quot;results&quot;: [            {                &quot;output&quot;: &quot;'NoneType' object has no attribute '__getitem__'&quot;,                &quot;checker&quot;: &quot;throws_exception&quot;,                &quot;passed&quot;: false            }        ]    }Note, all checkers will get run and all failures will be reported. It'sintended that they are all separate checks and if any one fails thehealthcheck overall is failed.Caching~~~~~~~In Runscope's infrastructure, the /healthcheck endpoint is hitsurprisingly often. haproxy runs on every server, and each haproxy hitsevery healthcheck twice a minute. (So if we have 30 servers in ourinfrastructure, that's 60 healthchecks per minute to every Flaskservice.) Plus, monit hits every healthcheck 6 times a minute.To avoid putting too much strain on backend services, health checkresults can be cached in process memory. By default, health checks thatsucceed are cached for 27 seconds, and failures are cached for 9seconds. These can be overridden with the ``success_ttl`` and``failed_ttl`` parameters. If you don't want to use the cache at all,initialize the Healthcheck object with``success_ttl=None, failed_ttl=None``.Customizing~~~~~~~~~~~You can customize the status codes, headers, and output format forsuccess and failure responses.The EnvironmentDump class-------------------------Built-in data sections~~~~~~~~~~~~~~~~~~~~~~By default, EnvironmentDump data includes these 4 sections:-  ``os``: information about your operating system.-  ``python``: information about your Python executable, Python path,   and installed packages.-  ``process``: information about the currently running Python process,   including the PID, command line arguments, and all environment   variables.Some of the data is scrubbed to avoid accidentally exposing passwords oraccess keys/tokens. Config keys and environment variable names arescanned for ``key``, ``token``, or ``pass``. If those strings arepresent in the name of the variable, the value is not included.Disabling built-in data sections~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~For security reasons, you may want to disable an entire section. You candisable sections when you instantiate the ``EnvironmentDump`` object,like this:.. code:: python    envdump = EnvironmentDump(include_python=False,                               include_os=False,                              include_process=False)Adding custom data sections~~~~~~~~~~~~~~~~~~~~~~~~~~~You can add a new section to the output by registering a function ofyour own. Here's an example of how this would be used:.. code:: python    def application_data():        return {&quot;maintainer&quot;: &quot;Luis Fernando Gomes&quot;,                &quot;git_repo&quot;: &quot;https://github.com/ateliedocodigo/py-healthcheck&quot;                &quot;config&quot;: app.config}    envdump = EnvironmentDump()    envdump.add_section(&quot;application&quot;, application_data)Credits-------This project was forked from `Runscope/healthcheck &lt;https://github.com/Runscope/healthcheck&gt;`_. since ``1.3.1``</longdescription>
</pkgmetadata>