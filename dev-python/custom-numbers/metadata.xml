<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># custom_numbers 1.2.0## DESCRIPTIONA Swiss-army knife for numbers of custom numeral systems.## AUTHOREvgueni Antonov 2023.## NOTEThis module was created and tested on Python 3.10.6, pip 23.1.2.First time published in May 2023.## INSTALLATION```pip3 install custom-numbers# orpython3 -m pip install custom-numbers```## QUICKSTARTFor details on how to use it, see the USAGE section below.```from custom_numbers import custom_numbers as cnmy_custom_numeral_system = cn.CustomNumeralSystem(&quot;paf&quot;)my_number = cn.CustomNumber(my_custom_numeral_system, &quot;a&quot;)# Now if you type in REPL:# help(cn)# You will get the help for the module and the classes.```## USAGEThis package contains one module with few classes made to help you declarea custom numeral system, made of custom symbols with a custom base. Asthis may sound strange, in reality this is how it looks:&gt; NOTE: Subsystems are not supported and I do not plan to implement this&gt; feature.&gt; NOTE: This module supports only custom integer numbers. Custom&gt; floating point numbers are not supported and will never be.### QUICK RECAP ON EXISTING AND WELL-KNOWN NUMERAL SYSTEMSLet's start with something you already know - a binary number. Theseare made of only **zeroes and ones** and therefore the Base is 2.&gt; Example: 1100101and this actually is the title of a really cool song from the 90s.Also **1100101** binary, converted to decimal is **101** (a hundred and one),just like (binary) **10&lt;sub&gt;2&lt;/sub&gt;** == **2&lt;sub&gt;10&lt;/sub&gt;** (decimal).Now - a hexadecimal number - these are made of the digits**0, 1, 2, 3, 4, 5, 6, 7, 8, 9** and the letters**A, B, C, D, E, F** and have a Base of 16.So a hexadecimal number looks like this:&gt; F&lt;sub&gt;16&lt;/sub&gt; == 15&lt;sub&gt;10&lt;/sub&gt;, &gt; 10&lt;sub&gt;16&lt;/sub&gt; == 16&lt;sub&gt;10&lt;/sub&gt;, &gt; F0&lt;sub&gt;16&lt;/sub&gt; == 240&lt;sub&gt;10&lt;/sub&gt;The other well-known numeral system is the octal system, consisting ofonly digits from zero to seven and Base 8, but we will skip this one now.And finally the decimal system which we all know since childhood have aBase of 10 and is made of the digits from zero to nine.### TUTORIAL: DECLARING A CUSTOM NUMERAL SYSTEMOkay, so far you are familiar with the most widely used numeral systems -the binary, the octal, the decimal and the hexadecimal.Let's start by re-defining the binary system. So it does have a Base of 2and we won't change that. However how about instead of using **0 and 1**to use **P and A** instead? So **P** would be our new zero and **A** wouldbe our new one. Therefore as we normally would write **1100101** this nowwould be written as **AAPPAPA**. Confusing, right? But so what - it isstill a binary system, we just changed the symbols.But now how about something crazier - a numeral system with a Base of 3,using the symbols **P, A, F** as digits, so **F** would be **2** decimal,**P** would be **0** decimal. Therefore:&gt; AA&lt;sub&gt;3&lt;/sub&gt; == 4&lt;sub&gt;10&lt;/sub&gt;, &gt; AF&lt;sub&gt;3&lt;/sub&gt; == 5&lt;sub&gt;10&lt;/sub&gt;, &gt; FP&lt;sub&gt;3&lt;/sub&gt; == 6&lt;sub&gt;10&lt;/sub&gt;Now let's see this in action:```from custom_numbers import custom_numbers as cnsys3 = cn.CustomNumeralSystem(&quot;paf&quot;)num3 = cn.CustomNumber(sys3, &quot;aa&quot;)num10 = num3.to_decimal()print(num10) # Prints &quot;4&quot;```Best way to test if the classes work as expected is to declare numeralsystems with the symbols we all know:```from custom_numbers import custom_numbers as cnsys2 = cn.CustomNumeralSystem(&quot;01&quot;)num2 = cn.CustomNumber(sys2, &quot;1100101&quot;)num10 = num2.to_decimal()print(num10) # Prints &quot;101&quot;sys16 = cn.CustomNumeralSystem(&quot;0123456789abcdef&quot;)num16 = cn.CustomNumber(sys16, &quot;f0&quot;)num10 = num16.to_decimal()print(num10) # Prints &quot;240&quot;```So far so good. Now let's go totally nuts and declare a system with aBase greather than 16 and a totally weird set of symbols for digits.And we can actually do that and even more totally crazy stuff:```sysN = cn.CustomNumeralSystem(&quot;kje5nCs21Q9vW0KMqc&quot;)```&gt; NOTE: The custom numbers are CASE SENSITIVE!!&gt; So **N != n** !!&gt; NOTE: There are forbidden characters, which can't be used in a numeral&gt; system and can't be used in a number. You could always get them as a&gt; string by using the **forbidden_characters** property of the &gt; **CustomNumeralSystem** class.### TUTORIAL: BASIC OPERATIONSIn **CustomNumeralSystem** class for the needs of basic validation, the equality and iequality Python operators were implemented, so you could compare two objects.However the comparisson would be by the list (basically the string)of the characters representing the digits, rather than standardPython object (reference) comparisson.```sys1 = cn.CustomNumeralSystem(&quot;paf&quot;)sys2 = cn.CustomNumeralSystem(&quot;paf&quot;)# The two objects are different, despite being initialized with# the same valueid(sys1) == id(sys2) # False# However the set of characters (the digits) is the same, the # base is the same, so I accept they are the same numeral systemssys1 == sys2 # True# And you could also test for inequalitysys1 = cn.CustomNumeralSystem(&quot;paf&quot;)sys2 = cn.CustomNumeralSystem(&quot;paz&quot;)sys1 != sys2 # True```Signed custom numbers are supported as well.```sysN = cn.CustomNumeralSystem(&quot;paf&quot;)numN1 = cn.CustomNumber(sysN, &quot;-a&quot;) # A negative numbernumN2 = cn.CustomNumber(sysN, &quot;a&quot;)  # A positive numbernumN3 = cn.CustomNumber(sysN, &quot;+a&quot;) # A positive number```Basic math operations are supported trough standard Python operators.```sysN = cn.CustomNumeralSystem(&quot;paf&quot;)numN1 = cn.CustomNumber(sysN, &quot;-a&quot;)numN2 = cn.CustomNumber(sysN, &quot;a&quot;)numN3 = cn.CustomNumber(sysN, &quot;+a&quot;)# ComparissonnumN1 == numN2numN1 != numN2numN1 &gt; numN2numN1 &lt; numN2numN1 &gt;= numN2numN1 &lt;= numN2# Basic mathematical operationsnumN1 + numN2   # AdditionnumN1 += numN2  # Augmented additionnumN1 - numN2   # SubtractionnumN1 -= numN2  # Augmented subtractionnumN1 // numN2  # Floor divisionnumN1 / numN2   # NOTE: This will perform floor division as well!# as floating point numbers are not supported by this class and will# never be.numN1 * numN2   # MultiplicationnumN1 ** numN2  # PowernumN1 % numN2   # Modulo divisionabs(numN)       # Absolute value```Using the iterator:```sysN = cn.CustomNumeralSystem(&quot;paf&quot;)it = cn.GearIterator(sysN, 0, 2)next(it)    # &quot;p&quot; # &quot;p&quot; assumes to be the analog of the zeronext(it)    # &quot;a&quot;next(it)    # &quot;f&quot;next(it)    # &quot;ap&quot;next(it)    # &quot;aa&quot;# and so on. You get the idea.# The iterator could also be initialized with an init_value which is# de-facto a custom number from the chosen CustomNumeralSystem,# but for convenience I left the number to be a string, as you may# wish or not to initialize at all:it = cn.GearIterator(sysN, 0, 2, &quot;af&quot;)```&gt; NOTE: If initialized, the iterator will strip any leading &quot;zeroes&quot;&gt; (so to speak) from the given init_value.### class CustomNumeralSystemDefines and declares a custom numeral system.```CustomNumeralSystem(digits: str)Args:    digits: The symbols to be used as digits. The string length defines        the numeral system base.```PROPERTIES:```forbidden_characters -&gt; strbase -&gt; int```METHODS:```valid_number(number: str) -&gt; bool    Tests if the given &quot;number&quot; is valid for the current numeral system.    Should not contain forbidden characters.    Should contain only characters defined in the numeral system.```### class CustomNumberDefines and declares a number from a custom numeral system.```CustomNumber(numeral_system: CustomNumeralSystem, value: str)Args:    numeral_system: A previously defined custom numeral system.    value: The value (the number itself).```PROPERTIES:```init_value -&gt; str    Returns the initial value the class was initialized with.```METHODS:```digit_to_int(digit: str) -&gt; int    Converts the given digit from the custom numeral system to a    decimal integer.to_decimal() -&gt; int    Converts the current number value to a decimal integer.```### class GearIteratorIterates over the numbers of a custom numeral system eiter starting atthe very first number (the zero-equivalent) or starting from a giveninit_value.Briefly simulates old gear counters, like the old cars odometer.```GearIterator(numeral_system: CustomNumeralSystem, min_length: int = 0, max_length: int = 0, init_value: str = &quot;&quot;)Args:    numeral_system: Custom numeral system. Mind the order of symbols!    min_length: Minimum length, default is zero.    max_length: Maximum length, default is zero - means no limit.    init_value: Value to initialize with.```PROPERTIES:```combinations -&gt; int    Returns the number of possible combinations (iterations).```&gt; The class implements the Python context management protocol.</longdescription>
</pkgmetadata>