<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># citizenshell [![Build Status](https://travis-ci.org/meuter/citizenshell.svg?branch=master)](https://travis-ci.org/meuter/citizenshell)__citizenshell__ is a python library allowing to execute shell commands either locally or remotely over several protocols (telnet, ssh, serial or adb) using a simple and consistent API. This library is compatible with both python 2 (2.7) and 3 (&gt;=3.4) as well as with [PyPy](https://pypy.org/). For now, it focuses on POSIX platforms like Linux and MacOS, but may be extended to work to Windows based platform in the future. It is distributed under[MIT](https://opensource.org/licenses/MIT) license.## Installation__citizenshell__ can simply installed using `pip install citizenshell`## Obtaining a shellFirst you need a shell. For that you have several options:1. use the built-in `LocalShell` for quick access:    ```python    from citizenshell import sh    ```2. you can instanciate your own `LocalShell`:    ```python    from citizenshell import LocalShell    shell = LocalShell()    ```3. you can instanciate the `TelnetShell` for shell over telnet:    ```python    from citizenshell import TelnetShell    shell = TelnetShell(hostname=&quot;acme.org&quot;, username=&quot;john&quot;,                        password=&quot;secretpassword&quot;)    ```4. you can instanciate the `SecureShell` for shell over SSH:    ```python    from citizenshell import SecureShell    shell = SecureShell(hostname=&quot;acme.org&quot;, username=&quot;john&quot;,                        password=&quot;secretpassword&quot;)    ```5. you can instanciate the `AdbShell` for shell over ADB:    - if ADB devices is reachable over TCP/IP:      ```python      from citizenshell import AdbShell        shell = AdbShell(hostname=&quot;acme.org&quot;, port=5555)      ```    - if ADB device is connected via USB:      ```python      from citizenshell import AdbShell        shell = AdbShell(device=&quot;1c123a09dab45cbf&quot;)      ```    - if there is only one ADB device connected via USB:      ```python      from citizenshell import AdbShell        shell = AdbShell()      ```6. you can instanciate the `SerialShell` for shell over serial line:    ```python    from serial import EIGHTBITS, PARITY_NONE    from citizenshell import SerialShell    shell = SerialShell(port=&quot;/dev/ttyUSB3&quot;, username=&quot;john&quot;,                        password=&quot;secretpassword&quot;,                        baudrate=115200, parity=PARITY_NONE, bytesize=EIGHTBITS)    ```7. you can also obtain shell objects by URI using the `Shell` function:    ```python    from citizenshell import Shell    localshell  = Shell()    telnetshell = Shell(&quot;telnet://john:secretpassword@acme.org:1234&quot;)    secureshell = Shell(&quot;ssh://john:secretpassword@acme.org:1234&quot;)    adbshell    = Shell(&quot;adb://myandroiddevice:5555&quot;)    adbtcpshell = Shell(&quot;adb+tcp://myandroiddevice:5555&quot;)    adbtcpshell = Shell(&quot;adb+usb://1c123a09dab45cbf&quot;)    serialshell = Shell(&quot;serial://jogn:secretpassword@/dev/ttyUSB3?baudrate=115200&quot;)    ```    you can also mix and match betweens providing arguments in the URI or via kwargs:    ```python    telnetshell = Shell(&quot;telnet://john@acme.org&quot;, password=&quot;secretpassword&quot;, port=1234)    serialshell = Shell(&quot;serial://john:secretpassword@/dev/ttyUSB3&quot;, baudrate=115200)    ```## Using a shellOnce you have shell, any shell, you can call it directly and get the standart output:```pythonassert shell(&quot;echo Hello World&quot;) == &quot;Hello World&quot;```You can also iterate over the standard output:```pythonresult = [int(x) for x in shell(&quot;&quot;&quot;    for i in 1 2 3 4; do        echo $i;    done&quot;&quot;&quot;)]assert result == [1, 2, 3, 4]```You don't have to wait for the command to finish to receive the output.This loop```pythonfor line in shell(&quot;for i in 1 2 3 4; do echo -n 'It is '; date +%H:%M:%S; sleep 1; done&quot;, wait=False):    print &quot;&gt;&gt;&gt;&quot;, line + &quot;!&quot;```would produce something like:```text&gt;&gt;&gt; It is 14:24:52!&gt;&gt;&gt; It is 14:24:53!&gt;&gt;&gt; It is 14:24:54!&gt;&gt;&gt; It is 14:24:55!```You can extract stdout, stderr and exit code seperately:```pythonresult = shell(&quot;&gt;&amp;2 echo error &amp;&amp; echo output &amp;&amp; exit 13&quot;)assert result.stdout() == [&quot;output&quot;]assert result.stderr() == [&quot;error&quot;]assert result.exit_code() == 13```You can inject environment variable to the shell```pythonassert shell(&quot;echo $VAR&quot;, VAR=&quot;bar&quot;) == &quot;bar&quot;```By default, shell inherits &quot;$CWD&quot; from the environment (aka $PWD).Still, if ever a command needs to be run from a custom path, oneway to achieve this is:```python    shell = LocalShell()    os.chdir(first_custom_path)    shell('first_command')    os.chdir(second_custom_path)    shell('second_command')```This works ... but it is ugly! Two levels of abstraction are mixed.This is better:```python    shell = LocalShell()    shell('first_command', cwd=first_custom_path)    shell('second_command', cwd=second_custom_path)```The shell can raise an exception if the exit code is non-zero:```pythonassert shell(&quot;exit 13&quot;).exit_code() == 13 # will not raise any exceptiontry:    shell(&quot;exit 13&quot;, check_xc=True) # will raise an exception    assert False, &quot;will not be reached&quot;except ShellError as e:    assert True, &quot;will be reached&quot;```The shell can also raise an exception if something is printed on the standard error:```pythonshell(&quot;echo DANGER &gt;&amp;2&quot;).stderr() == [&quot;DANGER&quot;] # will not raise any exceptiontry:    shell(&quot;echo DANGER &gt;&amp;2&quot;, check_err=True) # will raise an exception    assert False, &quot;will not be reached&quot;except ShellError as e:    assert True, &quot;will be reached&quot;```You can pull file from the remote host (for `LocalShell` it's just doing a copy):```pythonshell(&quot;echo -n test &gt; remote_file.txt&quot;)shell.pull(&quot;local_file.txt&quot;, &quot;remote_file.txt&quot;)assert open(&quot;local_file.txt&quot;, &quot;r&quot;).read() == &quot;test&quot;```or push file to the remote host (again, for `LocalShell` it's just doing a copy):```pythonopen(&quot;local_file.txt&quot;, &quot;w&quot;).write(&quot;test&quot;)shell.push(&quot;local_file.txt&quot;, &quot;remote_file.txt&quot;)assert str(shell(&quot;cat remote_file.txt&quot;)) == &quot;test&quot;```## LogsEvery shell object has a set of loggers: stdin, stderr and stdout, as well as for out of band logging message. By default they are all set to `logging.CRITICAL` which does not log anything. However, this log levelcan be configured either using the `log_level=` keyword argument in the shell constructor:```pythonfrom citizenshell import LocalShellfrom logging import INFOshell = LocalShell(log_level=INFO)```or by calling the `set_log_level()` method:```pythonfrom citizenshell import shfrom logging import INFOsh.set_log_level(INFO)```When configured with `logging.INFO`:- all commands are logged on stdout prefixed by a `$` and colored in cyan with `termcolor`- all characters produced on stdout are logged to stdout- all characters produced on stderr are logged to stderr and colored in red with `termcolor`- all out of band messages are logged to stdout prefixed with `&gt;` and colored in yello with `termcolor`For example:```pythonfrom citizenshell import LocalShellfrom logging import INFOshell = LocalShell(log_level=INFO)shell(&quot;&gt;&amp;2 echo error &amp;&amp; echo output &amp;&amp; exit 13&quot;)shell(&quot;echo Hello &gt; /tmp/from.txt&quot;)shell.push(&quot;/tmp/from.txt&quot;, &quot;/tmp/to.txt&quot;)```will produce the following logs (colors are omitted):```$ &gt;&amp;2 echo error &amp;&amp; echo output &amp;&amp; exit 13outputerror$ echo Hello &gt; /tmp/from.txt&gt; '/tmp/from.txt' -&gt; '/tmp/to.txt'$ command -v chmod/bin/chmod$ chmod 664 '/tmp/to.txt'```For more even more logs messages, `logging.DEBUG` can be used.</longdescription>
</pkgmetadata>