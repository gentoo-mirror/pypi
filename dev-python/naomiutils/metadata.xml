<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># naomiCollection of routines written in Python for manipulating Naomi ROM and EEPROMfiles. This is geared towards enthusiasts building their own netboot servers orRPI setups and provides libraries for examining ROM and manipulating ROM headersas well as attaching EEPROM settings to ROM files and manipulating their contents.It is fully typed and requires a minimum of Python 3.6 to operate.## NaomiEEPRomThe NaomiEEPRom class provides high-level accessors to a 128-byte Naomi EEPROMdump as obtained through a ROM dumper or from an emulator's saved state. It handlescorrecting various CRCs as well as allowing high-level access to the duplicatedgame and system settings sections. Use this to create or manipulate a raw EEPROMdata file.### Default ConstructorTakes a single byte argument &quot;data&quot; and verifies that it is a valid 128-byte EEPROMbefore returning an instance of the `NaomiEEPRom` class used to manipulate thatdata. If any of the CRCs do not match this will raise a `NaomiEEPRomException`.### NaomiEEPRom.defaultAn alternate constructor that takes a single byte argument &quot;serial&quot; and an optionalbyte argument &quot;game_defaults&quot; and creates a valid EEPROM based on this data, returningan instance of the `NaomiEEPRom` class that can be used to manipulate this newlycreated EEPROM. The serial argument should be exactly bytes and begin with a &quot;B&quot;,followed by two characters and finally a digit, as represented by a bytestring. Thisis a Naomi system restriction. Optionally, a string of bytes can be given in the&quot;game_defaults&quot; section which will be used to determine the length and defaultvalues of the game section of the EEPROM.### NaomiEEPRom.validateA static method that takes a byte argument &quot;data&quot; and checks it for validity. Thisincludes making sure the length is 128 bytes and that all CRCs are correct. Optionallyyou can pass in the boolean keyword argument &quot;only_system&quot; set to True to only checkthat the system section is valid. This is useful for validating EEPROMs where the BIOShas written system settings but the game has not yet booted and created its owndefaults yet. You can use this function to ensure that passing data to the defaultconstructor will not result in an exception.### data propertyAn instance of NaomiEEPRom has the &quot;data&quot; property, which returns a bytes objectrepresenting the current 128-byte EEPROM. This will have all CRC sections fixed.Use the &quot;data&quot; property to retrieve the EEPROM for writing to a file or sending toa Naomi system after manipulating data using the NaomiEEPRom class. Note that thisis read-only, you should not attempt to manipulate the raw data using this property.## serial propertyReturns the 4 byte serial that is found in the system section of the EEPROM. Thiswill match a serial given in the `NaomiEEPRom.default` constructor when it is used.Use this to help determine what game an EEPROM goes with. Note that this is read-only.To modify the serial, create a new EEPROM with that serial. Game settings and systemsettings are not compatible across games on the Naomi platform.## length propertyThe length in bytes as an integer of the game section of the EEPROM. If the game sectionis not valid this return 0 bytes. Otherwise it returns the length of the game sectionitself. This property is writeable. If you provide it a new value, the game sectionwill be resized to that length. Use this to determine the bounds of the `game` sectionas documented below, as well as to resize the `game` section.## system propertyReturns a bytes-like wrapper object representing the system section of the EEPROM.This operates like a bytearray object in Python. That means you can access or mutateany byte or section in the system area using this property. Note that this wrapperobject takes care of reading from and writing to both mirrors of the system section inthe EEPROM file as well as ensuring that the CRC is correct. Note also that the systemsection is hard-coded to 16 bytes in length which cannot be modified. This is a systemrestriction on the Naomi platform. Much like bytes objects in python, accessing a singlebyte returns an integer in the range of 0-255, but accessing a range returns a bytesobject.A simple example of reading bytes 6-8 of the system section:```eeprom = NaomiEEPRom(somedata)print(eeprom.system[6:8])  # Will print a bytes object of length 2.```A simple example of writing bytes 10-12 of the system section:```eeprom = NaomiEEPRom(somedata)eeprom.system[10:12] = b&quot;\x12\x34&quot;```## game propertyReturns a bytes-like wrapper object representing the game section of the EEPROM. Thisoperates identically to the `system` property as documented above, only it accesses thegame section of the EEPROM. Note that for this to work properly, the game section needsto be initialized by setting the `length` property on the instance of `NaomiEEPRom`. Ifyou are manipulating an existing EEPROM file, this property will already be set for you.Note that this wrapper object includes a `valid` property which returns if the currentsection is valid in the EEPROM you are manipulating. This will always be `True` forthe system section. However, if you access the game section on a newly-created EEPROMwithout setting defaults or a length, the game property's `valid` property will return`False`.An example of verifying that the game section is valid:```eeprom = NaomiEEPRom.default(serial=b&quot;BBG0&quot;)print(eeprom.game.valid)  # Will print &quot;False&quot; as the EEPROM was created without a game section default.eeprom.length = 20print(eeprom.game.valid)  # Will print &quot;True&quot; as the EEPROM game section was initialized to be 20 bytes long.```## NaomiRomThe NaomiRom class provides high-level accessors to a Naomi ROM header as foundat the beginning of a ROM file suitable for netbooting. It handles decoding allsections of the ROM header as well as allowing modification and even creation ofnew ROM header sections given valid data. Use this if you wish to manipulate orcreate your own Naomi ROM files form scratch.### Default ConstructorTakes a single byte argument &quot;data&quot; and uses it as the ROM image where the headerwill be extracted. Note that there is no CRC over the ROM header so any data thatis 1280 bytes or longer will appear valid.### NaomiRom.defaultAn alternate constructor that creates an entirely blank Naomi ROM containing noloaded executable or test sections and no ROM name. Use this when you want toprogramatically construct a ROM image, such as when you are building a final ROMin a homebrew program you are building for the Naomi platform.### valid propertyAn instance of NaomiRom has the &quot;valid&quot; property which will be &quot;True&quot; when the ROMpassed into the constructor is a valid Naomi ROM and &quot;False&quot; otherwise. This is aread-only property as the vailidity of a ROM is entirely dictated by the datapassed into the constructor.### data propertyThe ROM data, as passed into the constructor for the instance of NaomiRom, or ascreated when using `NaomiRom.default` alternate constructor. Note that when anyof the following properties are written, the `data` property will be changed toreflect those settings. Use this to retrieve the updated ROM after you've madeadjustments to the values you wish to change.### publisher propertyThe publisher of this ROM, as a string. When read, grabs the current publisherof the ROM image. When written, updates the publisher to the new string provided.### names propertyA dictionary of names indexed by region. Given the current system region, the namesthat show up here will also be the names that show up in the test menu for a givengame. Note that there are the following constants that can be used to index into thenames list: `NaomiRomRegionEnum.REGION_JAPAN`, `NaomiRomRegionEnum.REGION_USA`,`NaomiRomRegionEnum.REGION_EXPORT`, `NaomiRomRegionEnum.REGION_KOREA`, and finally`NaomiRomRegionEnum.REGION_AUSTRALIA`. Note that the last region, Australia, existsin many ROM files but is not accessible as there is no Australia BIOS for the Naomiplatform. When read, grabs a dictionary of names of the ROM given the region. Whenwritten, updates the ROM names by region using the dictionary provided.### sequencetexts propertyA list of 8 sequence texts that are used by the game for coin insertion messages.Many ROMs only have the first sequence set. When read, grabs all 8 sequence textsand returns a list of them. When written, updates the sequence texts to the newlist of strings provided.### defaults propertyA dictionary of NaomiEEPROMDefaults instance representing what defaults the BIOS willset in the system EEPROM section when initializing the EEPROM on first boot. Notethat this is indexed by the same enumeration as the &quot;names&quot; property. When read, grabsthe defaults and returns them. When written, extracts values from the providedNaomiEEPROMDefaults instances and updates the per-region defaults in the ROM accordingly.### date propertyA `datetime.date` instance representing what date the ROM was build and released.When read, returns the current date in the ROM header. When written, updates thedate of the ROM with the new `datetime.date` provided.### serial propertyA 4-byte bytestring representing the serial number of the ROM. This is used to tieEEPROM data to the ROM itself and lets the Naomi know when to reset certain defaults.When read, returns the current serial from the ROM header. When written, updates theserial in the ROM header.### regions propertyA list of NaomiRomRegionEnum values representing valid regions this ROM will run under.Uses the same region constants as the `names` property. When read, returns a list ofthe valid regions this ROM executes under. When written, updates the list of regionsthe ROM is allowed to execute under. When booting, the Naomi BIOS will check thecurrent region against this list and show an error if the current region is notincluded in the list.### players propertyA list of integers representing the valid number of player configurations that thisROM will boot under. Valid player numbers include 1, 2, 3 and 4. When read, returnsa list of all valid number of player configurations that this game will boot with.When written, updates the list of player configurations. When booting, the NaomiBIOS will check the &quot;Number of Players&quot; setting in the system assignments and seeif that setting appears in this list.### frequencies propertyA list of frequencies that the monitor is allowed to run at for this ROM. Thisincludes the values 15 and 31. On read, returns the list of allowed frequencies.On write, updates the list of allowed frequencies. On boot, the Naomi BIOS willcheck the current horizontal refresh rate of the system as controlled by a DIPswitch and show an error if it isn't in the list of allowed frequencies.### orientations propertyA list of strings representing the allowed orientations for the monitor for thisROM. The includes the values &quot;horizontal&quot; and &quot;vertical&quot;. On read, returns thelist of all acceptable orientations. On write, updates that list based on theprovided list of strings. On boot, the Naomi BIOS will check the current &quot;MonitorOrientation&quot; setting in the system assignments and see if that orientation ison this list.### servicetype propertyA string value of either &quot;individual&quot; or &quot;common&quot; for the expected service buttontype for the ROM. On read, returns either &quot;individual&quot; or &quot;common&quot; to representthe current service type selected. On write, updates the service type to matchthe string provided.### main_executable propertyAn instance of a NaomiExecutable including sections of the ROM that the NaomiBIOS will copy before executing the ROM, as well as the entrypoint in main RAMthat the BIOS will jump to after copying sections. On read, returns the currentlist of sections to copy as well as the main entrypoint, as encapsulated as aninstance of NaomiExecutable. On write, it updates the ROM to the new executableconfiguration by unpacking the NaomiExecutable instance given.### test_executable propertyThis property is identical to the `main_executable` property, except for itrepresents the code and entrypoint that the Naomi BIOS will use when executingthe &quot;Game Test Mode&quot; section of the test menu. It can be similarly read and written.## NaomiSettingsPatcherThe NaomiSettingsPatcher class provides logic for attaching an EEPROM or SRAM configurationfile to a Naomi ROM so that it can be written to the EEPROM/SRAM when netbooting thatROM. Note that this is not a supported feature of the Naomi platform, so it usesan executable stub that it attaches to the ROM in order to make this work. If youdo not care what executable stub is attached and only want to patch settings intoa ROM file, use the `get_default_trojan` function which will return a bytesobject suitable for passing into a `NaomiSettingsPatcher` constructor.### Default ConstructorTakes a bytes &quot;rom&quot; argument and a bytes &quot;trojan&quot; argument creates an instance ofNaomiSettingsPatcher which can attach or retrieve previously-attached EEPROM or SRAM settingsin a Naomi ROM file suitable for netbooting. An example of how to initialize thisis as follows:```from naomi import NaomiSettingsPatcher, get_default_trojanpatcher = NaomiSettingsPatcher(somedata, get_default_trojan())```### data propertyThe same bytes as passed to the `NaomiSettingsPatcher` constructor. After calling`put_settings()` as documented below, this will be updated to the new ROM contentswith the settings applied. A recommended workflow is to patch ROMs on-the-fly whennetbooting by creating an instance of `NaomiSettingsPatcher` with the ROM data youwere about to send, calling `put_settings()` with the settings you wish to attach,and then getting the data using this property and sending it down the wire to theNaomi system. Note that you can attach either an EEPROM file (128 bytes) or an SRAMfile (32kb) but not both.### serial propertyAn instance of NaomiSettingsPatcher has the `serial` property. When read, thiswill examine the serial of the Naomi ROM passed into the constructor and return the4 byte serial number, suitable for matching against an EEPROM's system serial. Notethat this property is read-only.### rom propertyReturns a `NaomiRom` instance that encapsulates the ROM passed into the patcher. Thisinstance should not be edited, as it will not be read again when performing the patches.Note that this property is read-only.### has_eeprom propertyReturns `True` if the ROM passed into the patcher has an attached EEPROM file. Returns`False` otherwise.### eeprom_info propertyReturns an optional instance of NaomiSettingsInfo if the ROM has a configured EEPROMsection. If the ROM does not have a configured EEPROM section, this returns `None`.The NaomiSettingsInfo instance represents the configuration passed to `put_eeprom()`on a previous invocation. Note that this property is read-only.### get_eeprom() methodReturns a 128-byte EEPROM bytestring that was previously attached to the Naomi ROM,or `None` if this ROM does not include any EEPROM settings.### put_eeprom() methodgiven a bytes &quot;eeprom&quot; argument which is a valid 128-byte EEPROM, ensures that itis attached to the Naomi ROM such that the settings are written when netbooting theROM image. If there are already EEPROM settings attached to the ROM, this overwritesthose with new settings. If there are not already settings attached, this does thework necessary to attach the settings file as well as the writing trojan supplied tothe `NaomiSettingsPatcher` constructor.Valid EEPROM files can be obtained form a number of places. If you use an emulatorto set up system and game settings, then the EEPROM file that emulator writes canusually be supplied here to make your game boot to the same settings. If you usethe `NaomiEEPRom` class to manipulate an EEPROM, the data it produces can also besupplied here to force the Naomi to use the same settings.Optionally, pass in the boolean keyword argument &quot;enable_sentinel&quot; set to True andthe Naomi ROM will re-initialize the settings when netbooting even if the last gamenetbooted was this game. Use this when iterating over settings that you want to chooseso that you can ensure the settings are written. If you do not provide this argument,the default behavior is that settings will not be overwritten when we netboot a gamethat is already running on the system.Optionally, pass in the boolean keyword argument &quot;enable_debugging&quot; set to Truewhich forces the Naomi to display debugging information on the screen before bootingthe game. Use this to see what is actually going on under the hood when using thesettings patching feature.Optionally, pass in the boolean keyword argument &quot;verbose&quot; set to True which forcesthe `put_eeprom()` function to output progress text to stdout. Use this if you aremaking a command-line tool and wish to display information about the patch processto the user.### has_sram propertyReturns `True` if the ROM passed into the patcher has an attached SRAM file. Returns`False` otherwise.### get_sram() methodReturns a 32k-byte SRAM bytestring that was previously attached to the Naomi ROM, or`None` if this ROM does not include any SRAM settings.### put_sram() methodgiven a bytes &quot;settings&quot; argument which is a valid 32k-byte SRAM, ensures that it isattached to the Naomi ROM such that the settings are written when netbooting the ROMimage. If there are already SRAM settings attached to the ROM, this overwrites thosewith new settings. If there are not already settings attached, this does the worknecessary to attach the settings file.Valid SRAM files can be obtained from an emulator that is capable of writing an SRAMfile. This only makes sense to use in the context of atomiswave conversions and ina select few Naomi games that store their settings in SRAM such as Ikaruga.Optionally, pass in the boolean keyword argument &quot;verbose&quot; set to True which forcesthe `put_settings()` function to output progress text to stdout. Use this if you aremaking a command-line tool and wish to display information about the patch processto the user.# naomi.settingsCollection of routines written in Python for safe manipulation of 128-byteNaomi EEPROM files using supplied system definition files. Essentially, givena valid 128-byte EEPROM or a valid 4-byte Naomi ROM serial and a set of systemand game definition files, `naomi.settings` will provide you a high-levelrepresentation of valid settings including their defaults, valid values andrelationships to each other. Settings editors can be built using this modulewhich work together with `naomi.NaomiEEPRom` and `naomi.NaomiSettingsPatcher`to make the settings available when netbooting a game on a Naomi system.## SettingA single setting, with its name, default, current value, possible allowed values,and any possible relationship to other settings. Note that any relationship,if it exists, will only be to other Setting objects inside a `Settings` class.Note that you should not attempt to construct an instance of this yourself.You should only work with previously-constructed instances of it as found insidean instance of `Settings`.### name propertyThe name of this setting, as a string. This is what you should display to a userif you are developing a settings editor.### order propertyThe order that this setting showed up in the definition file that created it.Note that if you are implementing an editor, you can safely ignore this as thesettings will already be placed in the correct display order.### size propertyThe size of this setting, as an instance of SettingSizeEnum. The valid valuesfor this are `SettingSizeEnum.NIBBLE` and `SettingSizeEnum.BYTE`. Note that ifyou are developing an editor, you can safely ignore this as the `values` propertywill include all valid values that this setting can be set to. You do not have tounderstand or manipulate this in any way and it is only present so that otherparts of the `naomi.settings` module can do their job properly.### length propertyThe length in bytes this setting takes up, if the `size` property is `SettingSizeEnum.BYTE`.If the `size` property is instead `SettingSizeEnum.NIBBLE` then this will alwaysbe set to 1. Note that much like the `size` property if you are implementing aneditor you can safely ignore this property for the same rationale as above.### read_only propertyWhether this property is read-only or not. Some settings are not modifiable, suchas the system serial number. Other settings are only modifiable if other settingsare set to some value, such as the &quot;Continue&quot; setting on Marvel vs. Capcom 2 whichis dependent on &quot;Event&quot; mode being off. If this property is &quot;False&quot; then this settingis user-editable under all circumstances. If this property is &quot;True&quot; then this settingis never user-editable. If this property is an instance of `ReadOnlyCondition` thenit depends on some other settings for whether it is read-only. You can call the`evaluate()` method on the instance of `ReadOnlyCondition` which takes a list of`Setting` objects (this setting's siblings as found in a `Settings` object) and returnsa boolean. If that boolean is &quot;True&quot;, then this setting is currently read-only becauseof some other setting's value. If the boolean is &quot;False&quot;, then the setting is currentlyeditable because of some other setting's value.In the Naomi Test Mode, settings that are always read-only are hidden completely fromthe user. Settings which are never read-only are displayed to the user. And settingswhich are conditionally read-only will be conditionally hidden based on whether theyare read-only. It is recommended that your editor perform a similar thing when youdisplay settings. Settings whose `read_only` property is &quot;False&quot; should always bedisplayed. Settings whose `read_only` property is &quot;True&quot; should be completely hiddenfrom the user. Settings whose `read_only` property is a `ReadOnlyCondition` should beevaluated and then the setting either grayed out when it is &quot;True&quot; or conditionallyhidden from the user.### values propertyA dictionary whose keys are integers which the `current` property could be setto, and whose values are the strings which should be displayed to the user forthose value selections. Note that if a setting is always read-only this may insteadbe None. It is guaranteed to be a dictionary with at least one value whenever asetting is user-editable.### current propertyThe current integer value that the setting is set to. In order to display the correctthing to a user, you should use this as a key into the `values` property to look upthe correct string to display.### default propertyThe default value for this setting. Note that under some circumstances, this maynot be available and will return None. You can safely ignore this property if you aredeveloping an editor. If you wish to provide a &quot;defaults&quot; button in your editor, itis recommended to instead use the `from_serial()` or `from_rom()` method on an instance of`SettingsManager` which will return you a new `SettingsWrapper` with default values.This will correctly handle system and game defaults as well as dependendent defaultsettings.## SettingsA class which represents a collection of settings that can be used to manipulatea section of an EEPROM file. Note that you should not attempt to constructthis yourself. You should only work with previously-constructed instances ofit as found inside an instance of `SettingsWrapper`.### filename propertyThe name of the settings definition file that was used to create this collection.Note that this is not a fully qualified path, but instead just the name ofthe file, like &quot;system.settings&quot; or &quot;BBG0.settings&quot;. If you wish to look upthe actual file location given this property, use the `files` property on aninstance of `SettingsManager`.### type propertyAn instance of SettingType which specifies whether this collection of settingsis a system settings section or a game settings section in an EEPROM. Validvalues are `SettingType.SYSTEM` and `SettingType.GAME`.### settings propertyA python list of `Setting` objects, representing the list of settings thatcan be mofidied or displayed. You should not assign to this property directlywhen modifying settings in a settings editor you are implementing. However,you are welcome to modify the properties of each setting in this list directly.### length propertyAn integer representing how many bytes long the section of EEPROM representedby this collection is. For system settings, this will always be 16 since thesystem section is hardcoded at 16 bytes. For game settings, this will bedetermined by the settings definition file that was looked up for the gamein question.## SettingsWrapperA class whose sole purpose is to encapsulate a group of system settings,game settings and the serial number of the game that the system and gamesettings go with. This is returned by many methods in `SettingsManager`and taken as a parameter of several more methods in `SettingsManager.Note that you should not attempt to construct this yourself. You shouldonly work with previously-constructed instances of it as returned bymethods in `SettingsManager`.### serial propertyThe 4-byte serial of the game this `SettingsWrapper` instance has beencreated for.### systemA collection of settings that manipulate the system section of the EEPROMfor the game this instance has been created for. This is inside of a`Settings` wrapper object.### gameA collection of settings that manipulate the game section of the EEPROMfor the game this instance has been created for. This is inside of a`Settings` wrapper object.### to_json() methodConverts the current instance of `SettingsWrapper` to a dictionary suitablefor passing to `json.dumps`. This is provided as a convenience wrapper sothat if you are implementing a web interface you don't have to serializeanything yourself. To unserialize a dictionary that you get from this method,call the `from_json` method on an instance of `SettingsManager`.## SettingsManagerThe `SettingsManager` class manages the ability to parse a 128-byte EEPROMfile given a directory of settings definitions. It is responsible foridentifying the correct files for patching given an EEPROM or ROM serial.It is also responsible for taking a modified list of settings and writinga new EEPROM file.Note that default definitions are included with this module. To grab thedefault definitions directory, use the `get_default_settings_directory` functionwhich will return a fully qualified path to the settings directory of thismodule.Note that since this is parsing user-supplied settings definitions files,there can be errors in processing those files. In any function that returnsa `SettingsWrapper` instance, a `SettingsParseException` can be thrown.This is a subclass of `Exception` so you can get the error message todisplay to a user by calling `str()` on the exception instance. The instancewill also have a `filename` property which is the filename of the settingsdefinition file that caused the problem.There can also be problems in saving EEPROM settings given the same definitionsfiles. In this case, a `SettingsSaveException` can be thrown. This is identicalto `SettingsParseException` save for the source, so all of the above documentationapplies.There can also be problems in deserializing JSON data when calling the`from_json()` method. In this case, a `JSONParseException` can be thrown. Similarto the above two exceptions, calling `str()` on the instance will give you backan error message that can be displayed to a user. The instance will also havea `context` property which is the exact location in the JSON where the failureoccured as represented by a list of attributes that were dereferenced in theJSON to get to the section that had an error.### Default ConstructorTakes a single string argument &quot;directory&quot; which points at the directorywhich contains settings definition files and returns an instance of the`SettingsManager` class. In this repository, that directory is`naomi/settings/definitions/`. Note that the settings definitions in thisrepository can be found by using the `get_default_settings_directory` function.An example of how to initialize this is as follows:```from naomi.settings import get_default_settings_directory, SettingsManagerdir = get_default_settings_directory()man =  SettingsManager(dir)```### files propertyAn instance of `SettingsManager` has the &quot;files&quot; property, which returnsa dictionary of recognized settings definitions in the directory supplied tothe default constructor. The returned dictionary has keys representing thesettings definition file, such as &quot;system.settings&quot; or &quot;BBG0.settings&quot;. Thevalues of the dictionary are fully qualified system paths to the file inquestion.### from_serial() methodTakes a single bytes argument &quot;serial&quot; as retrieved from Naomi ROM headerand uses that to construct a `SettingsWrapper` class representing theavailable settings for a game that has the serial number provided. Thiscan be used when you want to edit settings for a game but do not have anEEPROM already created. This will read the definitions files and createa `SettingsWrapper` with default settings. This can be then passed to the`to_eeprom()` function to return a valid 128-byte EEPROM representing thedefault settings.### from_rom() methodTakes a NaomiRom instance argument &quot;rom&quot; and a NaomiRomReginEnum argument&quot;region&quot; and retrieves any requested system defaults from the Naomi ROMheader. It uses that as well as the game's settings definition file to createa default EEPROM that is then used to construct a `SettingsWrapper` classrepressenting the default settings as a Naomi would create them on firstboot. This can then be edited or passed to the `to_eeprom()` function toreturn a valid 128-byte EEPROM representing the edited settings.### from_eeprom() methodTakes a single bytes argument &quot;data&quot; as loaded from a valid 128-byteEEPROM file or as grabbed from the `data` property of an instance of`NaomiEEPRom` and constructs a `SettingsWrapper` class representing theavailable settings for a game that matches the serial number provided inthe EEPROM file. This can be used when you want to edit the settings fora game and you already have the EEPROM file created. This will read thedefinitions file and parse out the current settings in the EEPROM andreturn a `SettingsWrapper` with those settings. This can then be modifiedand passed to the `to_eeprom()` function to return a valid 128-byte EEPROMrepresenting the current settings.### from_json() methodTakes a single dictionary argument &quot;jsondict&quot; and deserializes it toa `SettingsWrapper` instance. The dictionary argument can be retrievedby calling the `to_json()` method on an existing `SettingsWrapper` instance.This is provided specifically as a convenience method for code wishing toprovide web editor interfaces. A recommended workflow is to create aninstance of `SettingsManager`, request a `SettingsWrapper` by callingeither `from_eeprom()` or `from_serial()` as appropriate, calling `to_json()`on the resulting `SettingsWrapper` class and then passing that to`json.dumps` to get valid JSON that can be sent to a JS frontend app. Afterthe frontend app has manipulated the settings by modifying the currentvalue of each setting, you can use `json.loads` to get back a dictionarythat can be passed to this function to get a deserialized `SettingsWrapper`class. The deserialized `SettingsWrapper` instance can then be passed tothe `to_eeprom()` function to return a valid 128-byte EEPROM representingthe settings chosen by the JS frontend.### to_eeprom() methodGiven an instance of `SettingsWrapper` returned by either `from_serial()`,`from_eeprom()` or `from_json()`, calculates and returns a valid 128-byteEEPROM file that represents the settings. Use this when you are finishedmodifying system and game settings using code and wish to generate a validEEPROM file that can be modified with `NaomiEEPRom`, placed in an emulator'sdata directory to load those settings or attached to a Naomi ROM using the`naomi.NaomiSettingsPatcher` class so that the settings are written whennetbooting the rom on a Naomi system.# Settings Definitions FormatSettings definition files are meant to be simple, human readable documentationfor a game's EEPROM settings. They are written in such a way that on top ofbeing human-readable documentation, they can also be parsed by`naomi.settings.SettingsManager` to help with making settings editors for anygame on the Naomi platform. Each setting in a settings definition file representshow to parse some number of bytes in a game's EEPROM. You'll notice that whilethere is a size specifier for each setting there is no location specifier. That'sbecause each setting is assumed to come directly after the previous setting inthe section.All settings sections in an game's EEPROM are assumed to be little-endian, muchlike the Naomi system itself. Defaults and valid values are specified as hexdigits as copied directly out of a hex editor. When specifying half-byte settings,the first setting is assumed to be the top half of the byte (the first hex digitthat appears when reading the EEPROM in a hex editor) and the second setting isassumed to be the bottom half of the byte. All half-byte settings are expectedto come in pairs.Aside from the &quot;system.settings&quot; file, all settings files are named after theserial number of the game they are associated with. The serial number for thegame can be found by looking at the ROM header using a tool such as `rominfo`,or by looking at bytes 3-7 of an EEPROM that you got out of an emulator andloaded into a hex editor.The only necessary parts of a setting are the name and the size. If the settingis user-editable, there should be at least one valid value that the setting isallowed to be. Optionally, you can specify the default value for any settingand whether the setting is read-only. Additionally, read-only and default valuescan depend on the value of another setting.Settings are defined by writing any valid string name followed by a colon. Settingparts come after the colon and are either comma-separated or are placed one perline after the setting name. You can mix and match any number of comma-separatedparts and parts on their own lines. Whatever makes the most sense and is the mostreadable is allowed.  Settings parts can show up in any order after the settingname. You can define size, read-only, defaults and valid options in any order youwish. The only restriction is that the size part MUST appear before any default parts.Any line in a settings definition file that starts with a hashtag (`#`) is treatedas a comment. You can write anything you want in comments so feel free to writedown any useful information about settings you think somebody else might care toknow.## A Simple SettingThe most basic setting is one that has a name, a size and some allowed values.An example of such a setting is like so:```Sample Setting: byte, values are 1 to 10```This defines a setting named &quot;Sample Setting&quot; which is a single byte and canhave the hex values 01, 02, 03, 04, 05, 06, 07, 08, 09 and 0a. Editors thatdisplay this setting will display a drop-down or selection box that includesthe decimal values &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, and &quot;10&quot;.The decimal values for each valid setting is automatically inferred based onthe range given in the setting.If you want to specify some alternate text for each valid setting, you maydo so like so:```Sample Setting: byte, 1 - On, 0 - Off```This defines a setting named &quot;Sample Setting&quot; which is a single byte and canhave the hex values 01 and 00 applied to it. Editors that display this settingwill display a drop-down or selection box that includes the value &quot;On&quot; and&quot;Off&quot; and will select the correct one based on the value in the EEPROM when itis parsed.You can mix and match how you define settings values if it is most convenient.For example, the following setting mixes the two ways of specifying validvalues:```Sample Setting: byte, 0 - Off, 1 to 9, 10 - MAX```This defines a setting named &quot;Sample Setting&quot; which is a single byte andcan have the hex values 00, 01, 02, 03, 04, 05, 06, 07, 08, 09 and 0a. Editorsthat display this setting will display a drop-down or selection box that includesthe options &quot;Off&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;MAX&quot;. Thecorrect one will be selected based on the value in the EEPROM when it is parsed.## Changing the Setting DisplayNormally, if you have some number of values that a setting can be and youwant to control what an editor displays when selecting each value, you wouldlist each value out individually along with the text it should be displayed as.However, if you have a large range of values and you want to display them inhex instead of decimal, you can instead do the following:```Sample Setting: byte, values are 1 to 10 in hex```This defines a setting named &quot;Sample Setting&quot; which is a single byte and canhave the hex values 01, 02, 03, 04, 05, 06, 07, 08, 09 and 0a. This is identicalto the simple setting in the previous section. However, editors that display thissetting will display a drop-down or selection box that includes the options&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot; and &quot;0a&quot;. You could havewritten the settings out individually, but for large ranges that you want todisplay in hex this is faster.## Changing the Setting SizeIf your setting spans more than 1 byte, or it is only the top half or bottomhalf of a byte, you can specify that in the size part. For settings that occupymore than 1 byte, you can simply write the number of bytes in the part section.If a setting only occupies the top or bottom half of a byte, you can specifya half-byte for the size.An example of a setting that takes up 4 bytes is as follows:```Big Setting: 2 bytes, 12 34 - On, 56 78 - Off```This defines a setting named &quot;Big Setting&quot; that takes up two bytes and hasthe two hex values 12 34 and 56 78 as read in a hex editor as its options.Editors will display either &quot;On&quot; or &quot;Off&quot; as they would for 1 byte settings.An example of a pair of settings that take up half a byte each is as follows:```Small Setting 1: half-byte, values are 1 to 2Small Setting 2: half-byte, values are 3 to 4```This defines two settings named &quot;Small Setting 1&quot; and &quot;Small Setting 2&quot;. Eachsetting takes up half a byte. The first setting, &quot;Small Setting 1&quot;, will takethe top half of the byte, and the second, &quot;Small Setting 2&quot;, will take thebottom half of the byte. The hex values for each are the same as they wouldbe for all other documented settings. Note that the settings came in a pairbecause you have to specify both halves of the byte!## Specifying Read-Only SettingsSometimes there is a setting that you can't figure out, or there's a settingthat the game writes when it initializes the EEPROM but never changes. In thiscase you can mark the setting read-only and editors will not let people seeor change the setting. However, the setting will still be created when somebodyneeds to make a default EEPROM based on the settings definition file.An example of how to mark a setting as read-only:```Hidden Setting: byte, read-only```In this case, there is a setting named &quot;Hidden Setting&quot; which is a singlebyte. We specified that it was read-only, so editors will not display thesetting to the user. Also, since it was read-only, we didn't need to specifyany allowed values. You can use this when there are parts of the EEPROM youdon't want people to mess with, or that you don't understand so you just needto skip it.Sometimes there are settings that only display in some scenarios, such as whenanother setting is set to a certain value. If you run into a setting such asthis, you can specify that relationship like so:```Sometimes Hidden Setting: byte, read-only if Other Setting is 1, values are 0 to 2```This defines a setting called &quot;Sometimes Hidden Setting&quot; which is a single byteand can have the hex values 00, 01 and 02. When another setting named &quot;OtherSetting&quot; is set to 1, this setting becomes read-only and cannot be modifiedby the user. When that other setting named &quot;Other Setting&quot; is set to any othervalue, this setting becomes user-changeable.If you want to specify that a setting is read-only unless another setting isa certain value, you can do so like the following:```Sometimes Hidden Setting: byte, read-only unless Other Setting is 1, values are 0 to 2```This defines the same setting as the first example, but the read-only logicis reversed. This setting will be read-only when &quot;Other Setting&quot; is any valuebut 1, and will be user-changeable when &quot;Other Setting&quot; is 1.If you need to specify multiple values for the other setting, you can do solike so:```Sometimes Hidden Setting: byte, read-only if Other Setting is 1 or 2, values are 0 to 2```This defines the same setting as the first example, but the read-only logicis changed. The setting will be read only when &quot;Other Setting&quot; is 1 or 2, andwill be user-changeable when &quot;Other Setting&quot; is any other value.## Specifying DefaultsIts nice to specify what the default for each setting is. This way, editorscan make a new EEPROM from scratch for the game you are defining without needingan EEPROM to exist first. If you don't specify a default, the default for thesetting is assumed to be 0. If that isn't a valid value for a setting, you'llrun into problems so it is best to define defaults for settings when you can.To specify a default, you can do the following:```Default Setting: byte, default is 1, values are 1, 2```This defines a setting named &quot;Defaut Setting&quot; which is a single byte and whosevalid values are 01 and 02. The default value when creating an EEPROM fromscratch is 01.If a setting is read-only, then when we an EEPROM is edited and saved, thedefault value will take precidence over the current value. If a setting isuser-editable, then the current value will take precidence over the defaultvalue. This is so that you can have settings which are optionally read-onlybased on other settings and specify what value the setting should be whenit is read-only. This isn't often necessary but it can come in handy in somespecific scenarios.For example, in Marvel Vs. Capcom 2, the &quot;Continue&quot; setting is defaulted to&quot;On&quot;. However, if event mode is turned on, then the &quot;Continue&quot; setting isforced to &quot;Off&quot; and becomes no longer user-editable. To represent sucha case as this, you can do something like the following:```Event: byte, default is 0  0 - Off  1 - OnContinue: byte, read-only if Event is 1, default is 1 if Event is 0, default is 0 if Event is 1  0 - Off  1 - On```This can be a bit daunting to read at first, so let's break it down. First,it defines a setting named &quot;Event&quot; which is a byte and can have values 00 and 01.Those values are labelled &quot;Off&quot; and &quot;On&quot; respectively. Event mode is off by default.Then, it defines a setting named &quot;Continue&quot; which is a byte as well. It has values00 and 01 labelled &quot;Off&quot; and &quot;On&quot; respectively. It is user-editable when event modeis off, and it is read-only when event mode is on. When event mode is off, the defaultis 01, which corresponds to &quot;On&quot;. When event mode is on, the default is &quot;00&quot; whichcorresponds to &quot;Off&quot;. Remember how settings that are read-only try to save thedefault first, and settings that are user-changeable try to save the current valuefirst? That's where the magic happens. When the &quot;Event&quot; setting is set to &quot;On&quot;then the &quot;Continue&quot; setting is read-only, so we will save the default hex value of 00!When the &quot;Event&quot; setting is set to &quot;Off&quot;, the &quot;Continue&quot; setting is user-changeable sowe will save whatever value the user selected! When we create a new EEPROM from scratch,we set &quot;Event&quot; to 00 which tells the &quot;Continue&quot; setting to default to 01. It all worksperfectly!### Specifying Entirely-Dependent DefaultsSometimes you might run into a setting that seems to be identical to another setting,or a setting that seems to be the same as another setting plus or minus some adjustmentvalue. If you encounter such a relationship, you can represent it by doing somethinglike the following:```Setting: byte, default is 0, values are 1 to 10Dependent Setting: byte, read-only, default is value of Setting```This defines a setting named &quot;Setting&quot; which is a single byte that can have hex values01, 02, 03, 04, 05, 06, 07, 08, 09 and 0a. It defines a second setting named &quot;DependentSetting&quot; which defaults to whatever &quot;Setting&quot; is set to. Since it is read-only, thedefault will take precidence over the current value, so when somebody edits &quot;Setting&quot;in an editor, both &quot;Setting&quot; and &quot;Dependent Setting&quot; will be saved with the same value!In some cases, a setting will be dependent on another setting, but won't have theexact same value. If you wanted to, you could list out a whole bunch of default conditionalsto represent all of the possibilities, like so:```Setting: byte, default is 0, values are 1 to 3Dependent Setting: byte, read-only  default is 0 if Setting is 1  default is 1 if Setting is 2  default is 2 if Setting is 3```This would work, and sets up &quot;Dependent Setting&quot; to be 00 when Setting is 01, 01 whenSetting is 02, and 02 when Setting is 03. However, if there are a lot of possible valuesfor &quot;Setting&quot;, this can get tedious. Instead, you can represent the relationship like so:```Setting: byte, default is 0, values are 1 to 3Dependent Setting: byte, read-only, default is value of Setting - 1```This defines the exact same pair of settings, with the exact same defaults!## Specifying an Alternate Display OrderNormally settings are displayed in exactly the order the show up in thefile. Sometimes settings show up in a different order in a game's testmenu than they appear in the EEPROM file itself. You can't just rearrangethe order that the settings appear in the definition file since thatdictates the order that the settings themselves are processed. So, insteadyou can specify that a setting should be displayed before or after anothersetting. Here is an example:```Simple Setting: byte, values are 1 to 10Other Setting: byte, values are 2 to 5, display before Simple Setting```This defines two settings named &quot;Simple Setting&quot; and &quot;Other Setting&quot;. While&quot;Simple Setting&quot; comes first when parsing the EEPROM itself, when it comestime to display the settings in an editor, &quot;Other Setting&quot; will be displayedfirst and then &quot;Simple Setting&quot;.Similarly, you can specify that a setting come after another setting like so:```Simple Setting: byte, values are 1 to 10, display after Other SettingOther Setting: byte, values are 2 to 5```Both the above examples produce the exact same list of settings in an editor.## Using &quot;:&quot; or &quot;,&quot; in Setting Names or ValuesSince these are special characters used to figure out where a setting name endsas well as separate sections, using one of these characters in a setting name orvalue description will result in an error. In order to have a setting thatincludes one of these symbols, you can escale it like so:```Setting With A Colon\: The Revengence: byte, 1 - Good\, Very Good, 2 - Bad\, Very Bad```This defines a setting named &quot;Setting With a Colon: The Revengence&quot; that has twolabelled values consisting of &quot;Good, Very Good&quot; and &quot;Bad, Very Bad&quot;. Whenever youneed to use a character that is special, prefix it with a &quot;\\&quot;. This includes the&quot;\\&quot; character as it denotes that the next character should be escaped. So if youwant a &quot;\\&quot; character in your setting name or value, you should use two &quot;\\&quot; charactersin a row.</longdescription>
</pkgmetadata>