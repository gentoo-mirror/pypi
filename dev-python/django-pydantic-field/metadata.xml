<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![PyPI Version](https://img.shields.io/pypi/v/django-pydantic-field)](https://pypi.org/project/django-pydantic-field/)[![Lint and Test Package](https://github.com/surenkov/django-pydantic-field/actions/workflows/python-test.yml/badge.svg)](https://github.com/surenkov/django-pydantic-field/actions/workflows/python-test.yml)[![Downloads](https://pepy.tech/badge/django-pydantic-field/month)](https://pepy.tech/project/django-pydantic-field)[![Supported Python Versions](https://img.shields.io/pypi/pyversions/django-pydantic-field)](https://pypi.org/project/django-pydantic-field/)[![Supported Django Versions](https://img.shields.io/pypi/frameworkversions/django/django-pydantic-field)](https://pypi.org/project/django-pydantic-field/)# Django + Pydantic = ðŸ–¤Django JSONField with Pydantic models as a Schema## UsageInstall the package with `pip install django-pydantic-field`.``` pythonimport pydanticfrom datetime import datefrom uuid import UUIDfrom django.db import modelsfrom django_pydantic_field import SchemaFieldclass Foo(pydantic.BaseModel):    count: int    size: float = 1.0class Bar(pydantic.BaseModel):    slug: str = &quot;foo_bar&quot;class MyModel(models.Model):    # Infer schema from field annotation    foo_field: Foo = SchemaField()    # or explicitly pass schema to the field    bar_list: typing.Sequence[Bar] = SchemaField(schema=list[Bar])    # Pydantic exportable types are supported    raw_date_map: dict[int, date] = SchemaField()    raw_uids: set[UUID] = SchemaField()...    model = MyModel(    foo_field={&quot;count&quot;: &quot;5&quot;},    bar_list=[{}],    raw_date_map={1: &quot;1970-01-01&quot;},    raw_uids={&quot;17a25db0-27a4-11ed-904a-5ffb17f92734&quot;})model.save()assert model.foo_field == Foo(count=5, size=1.0)assert model.bar_list == [Bar(slug=&quot;foo_bar&quot;)]assert model.raw_date_map == {1: date(1970, 1, 1)}assert model.raw_uids == {UUID(&quot;17a25db0-27a4-11ed-904a-5ffb17f92734&quot;)}```Practically, schema could be of any type supported by Pydantic.In addition, an external `config` class can be passed for such schemes.### Forward referencing annotationsIt is also possible to use `SchemaField` with forward references and string literals, e.g the code below is also valid:``` pythonclass MyModel(models.Model):    foo_field: &quot;Foo&quot; = SchemaField()    bar_list: typing.Sequence[&quot;Bar&quot;] = SchemaField(schema=typing.ForwardRef(&quot;list[Bar]&quot;))class Foo(pydantic.BaseModel):    count: int    size: float = 1.0class Bar(pydantic.BaseModel):    slug: str = &quot;foo_bar&quot;```In this case, exact type resolution will be postponed until initial access to the field.Usually this happens on the first instantiation of the model.## Django Forms supportIt is possible to create Django forms, which would validate against the given schema:``` pythonfrom django import formsfrom django_pydantic_field.forms import SchemaFieldclass Foo(pydantic.BaseModel):    slug: str = &quot;foo_bar&quot;class FooForm(forms.Form):    field = SchemaField(Foo)  # `typing.ForwardRef(&quot;Foo&quot;)` is fine too, but only in Django 4+form = FooForm(data={&quot;field&quot;: '{&quot;slug&quot;: &quot;asdf&quot;}'})assert form.is_valid()assert form.cleaned_data[&quot;field&quot;] == Foo(slug=&quot;asdf&quot;)````django_pydantic_field` also supports auto-generated fields for `ModelForm` and `modelform_factory`:``` pythonclass FooModelForm(forms.ModelForm):    class Meta:        model = Foo        fields = [&quot;field&quot;]form = FooModelForm(data={&quot;field&quot;: '{&quot;slug&quot;: &quot;asdf&quot;}'})assert form.is_valid()assert form.cleaned_data[&quot;field&quot;] == Foo(slug=&quot;asdf&quot;)...# ModelForm factory supportAnotherFooModelForm = modelform_factory(Foo, fields=[&quot;field&quot;])form = AnotherFooModelForm(data={&quot;field&quot;: '{&quot;slug&quot;: &quot;bar_baz&quot;}'})assert form.is_valid()assert form.cleaned_data[&quot;field&quot;] == Foo(slug=&quot;bar_baz&quot;)```Note, that forward references would be resolved until field is being bound to the form instance.## Django REST Framework support``` pythonfrom rest_framework import generics, serializersfrom django_pydantic_field.rest_framework import SchemaField, AutoSchemaclass MyModelSerializer(serializers.ModelSerializer):    foo_field = SchemaField(schema=Foo)    class Meta:        model = MyModel        fields = '__all__'class SampleView(generics.RetrieveAPIView):    serializer_class = MyModelSerializer    # optional support of OpenAPI schema generation for Pydantic fields    schema = AutoSchema()```Global approach with typed `parser` and `renderer` classes``` pythonfrom rest_framework import viewsfrom rest_framework.decorators import api_view, parser_classes, renderer_classesfrom django_pydantic_field.rest_framework import SchemaRenderer, SchemaParser, AutoSchema@api_view([&quot;POST&quot;])@parser_classes([SchemaParser[Foo]]):@renderer_classes([SchemaRenderer[list[Foo]]])def foo_view(request):    assert isinstance(request.data, Foo)    count = request.data.count + 1    return Response([Foo(count=count)])class FooClassBasedView(views.APIView):    parser_classes = [SchemaParser[Foo]]    renderer_classes = [SchemaRenderer[list[Foo]]]    # optional support of OpenAPI schema generation for Pydantic parsers/renderers    schema = AutoSchema()    def get(self, request, *args, **kwargs):        assert isinstance(request.data, Foo)        return Response([request.data])    def put(self, request, *args, **kwargs):        assert isinstance(request.data, Foo)        count = request.data.count + 1        return Response([request.data])```## Acknowledgement* [Churkin Oleg](https://gist.github.com/Bahus/98a9848b1f8e2dcd986bf9f05dbf9c65) for his Gist as a source of inspiration;* Boutique Air Flight Operations platform as a test ground;</longdescription>
</pkgmetadata>