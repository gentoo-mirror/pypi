<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Python Filterparams #Filterparams is a library for parsing URL paramters for filterpurposes in a backend. It provides a syntax to map SQL-like queries on top of the query parameters and parses it into apython object.This is a helper library for providing filter collection APIs. The primary use case for developing the library is touse it with a REST-API which uses the [JSONAPI](http://jsonapi.org/) standard. Because of this the syntax is completely compatible with the standard and encapsulates everything in the `filter` query parameter.## Example ##Given the URL (non URL escaped for better readability):```/users?filter[param][name][like][no_default_name]=doe&amp;filter[param][first_name]=doe%&amp;filter[binding]=(!no_brand_name&amp;first_name)&amp;filter[order]=name&amp;filter[order]=desc(first_name)```It can be parsed by the given function:```pythonfrom urllib.parse import urlsplit, parse_qsfrom filterparams import build_parserurl = urlsplit(    '/users?filter[param][name][like][no_default_name]=doe'    '&amp;filter[param][first_name]=doe%&amp;filter[binding]='    '(!no_brand_name&amp;first_name)&amp;filter[order]=name'    '&amp;filter[order]=desc(first_name)')params = parse_qs(url)valid_filters = ['eq', 'like']default_filter = 'eq'parser = build_parser(    valid_filters=valid_filters,    default_filter=default_filter,)query = parser(params)```Would parse the data. You can access the parsed filters through`.param_order` and the orders through `.orders`. The param orderin this specific case would be resolved to:```pythonAnd(    left=Parameter(        name='name',        alias='no_default_name',        filter='like',        value='doe%',    ),    right=Parameter(        name='first_name',        alias='first_name',        filter='eq',        value='doe',    ))```The orders would be:```python[Order(name='name', direction='asc'),  Order(name='first_name', direction='desc')]```## Syntax ##All arguments must be prefixed by &quot;filter&quot;. It is possible to query for specific data with filters, apply orders to the result and to combine filters through AND, NOT and OR bindings.The syntax builds under the filter parameter a virtual object. The keys of the object are simulated through specifying `[{key}]` in the passed query parameter. Thus `filter[param]` would point to the param key in the filter object.### Filter specification ###The solution supports to query data through the `param` subkey.```filter[param][{parameter_name}][{operation}][{alias}] = {to_query_value}```The `operation` and `alias` parameters may be omitted. If no `alias` is provided the given parameter name is used for it.If no `operation` is given, the default one is used (in the example this would be equal).Example:```filter[param][phone_number][like]=001%```This would add a filter to all phone numbers which start with &quot;001&quot;.### Filter binding ###Per default all filters are combined through AND clauses. You can change that by specifying the `filter[binding]` argument.This is where the aliases which you can define come into place. The binding provides means to combine filters with AND and OR. Also you are able to negate filters here.The filters are addressed by their alias or name, if no alias is provided.If you have a filter `search_for_name`, `search_for_phone_number` and `search_for_account_number` defined you can say `search_for_name OR NOT search_for_number AND search_for_account_number` by specifying the following filter:```filter[binding]=search_for_name|(!search_for_phone_number&amp;search_for_account_number)```Even though the brackets are useless here, you can use them in more complex filters.The following table summarizes the possible configuration options:&lt;table&gt;  &lt;thead&gt;    &lt;tr&gt;      &lt;th&gt;Type&lt;/th&gt;      &lt;th&gt;Symbol&lt;/th&gt;      &lt;th&gt;Example&lt;/th&gt;    &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr&gt;      &lt;td&gt;AND&lt;/td&gt;      &lt;td&gt;&amp;&lt;/td&gt;      &lt;td&gt;a&amp;b&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;OR&lt;/td&gt;      &lt;td&gt;|&lt;/td&gt;      &lt;td&gt;a|b&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;NOT&lt;/td&gt;      &lt;td&gt;!&lt;/td&gt;      &lt;td&gt;!a&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;Bracket&lt;/td&gt;      &lt;td&gt;()&lt;/td&gt;      &lt;td&gt;(a|b)&amp;c&lt;/td&gt;    &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;### Ordering ###To specify a sort order of the results the `filter[order]` parameter may be used. The value can be specified multiple times. To add ordering you have to provide the name of the parameter which should be ordered, not its alias!If you want to order by `name`, `first_name` and in reverse order `balance` you can do so by specifying the following query url parameters:```filter[order]=name&amp;filter[order]=first_name&amp;filter[order]=desc(balance)```As you can see the `desc()` definition can be used to indicate reverse ordering.### Filter definition ###Not every backend does or should support all possible filter mechanisms. This is why the filters which should be accepted by the backend have to be added before processing the query parameters.You can limit the allowed filters by building a parse through the`filterparams.build_parser` function. You can configure the allowedfilters through the `valid_filters` definition. Additionally youhave to add the default filter by using the second `default_filter`parameter.```pythonfrom filterparams import build_parservalid_filters = ['eq', 'like']default_filter = 'eq'parser = build_parser(    valid_filters=valid_filters,    default_filter=default_filter,)query = parser({})```If you don't want any validation you can use the `parse` function.```pythonfrom filterparams import parsequery = parse({})```## Notes ##- There do no yet exist any public projects which use this library to provide transparent mapping to an underlying backend. I plan long-term to add another library which does use this package and provide a way to map it on sqlalchemy models. If you are planning to do this or use it for other data mapping please contact me and I'll add a reference to it inthe README.- The same as mentioned above is valid for client libraries, which generate the filter query structure in any language. Again, as soon as the API is stable I'll probably add a JavaScript library.- Depending on your backend it might not make sense to support all features (ordering, parameter binding) of thelanguage. You might still want to use it to parse your basic parameters though and ignore the rest.## Used Libraries ##For evaluating the filter params ordering the [funcparserlib](https://github.com/vlasovskikh/funcparserlib) ([MIT license](https://github.com/vlasovskikh/funcparserlib/blob/master/LICENSE))module is used. Additionally the [Werkzeug](https://github.com/mitsuhiko/werkzeug/blob/master/LICENSE) package is used for supporting dicts with multiple values in the same key.## Other Languages ##This is a list of projects implementing the same API for other languages.Currently this list only has one entry. - Go - [go-filterparams](https://github.com/cbrand/go-filterparams)</longdescription>
</pkgmetadata>