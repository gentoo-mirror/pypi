<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pytest-stepfunctions![GitHub Actions/CI](https://github.com/chehsunliu/pytest-stepfunctions/workflows/CI/badge.svg)[![codecov](https://codecov.io/gh/chehsunliu/pytest-stepfunctions/branch/master/graph/badge.svg)](https://codecov.io/gh/chehsunliu/pytest-stepfunctions)[![pypi-version](https://img.shields.io/pypi/v/pytest-stepfunctions)](https://pypi.python.org/pypi/pytest-stepfunctions)[![pypi-downloads](https://img.shields.io/pypi/dm/pytest-stepfunctions.svg)](https://pypistats.org/packages/pytest-stepfunctions)[![pypi-pyversions](https://img.shields.io/pypi/pyversions/pytest-stepfunctions)](https://pypi.python.org/pypi/pytest-stepfunctions)A pytest fixture that makes you able to mock Lambda code during AWS StepFunctions local testing.## Table of Contents- [Overview](#overview)- [Installing](#installing)- [Getting Started](#getting-started)  * [Creating a State Machine](#creating-a-state-machine)  * [Mocking the EMR Client in the Lambda Code](#mocking-the-emr-client-in-the-lambda-code)  * [Starting Execution and Validating Results](#starting-execution-and-validating-results)  * [Running the Test with the Step Functions JAR](#running-the-test-with-the-step-functions-jar)  * [Running the Test with the Step Functions Docker Image](#running-the-test-with-the-step-functions-docker-image)- [Contributing](#contributing)- [Known Issues](#known-issues)## OverviewAWS provides local Step Functions as a JAR and a Docker image for the quick testing without deployment. They described how to perform such task in [this article](https://docs.aws.amazon.com/step-functions/latest/dg/sfn-local-lambda.html) as well. I got excited at the very beginning, but soon ended up frustrated for still being unable to mock Lambda functions' external dependencies. Then I thought: what if initiate a Python thread with a fake Lambda service and use this fake service to execute Lambda functions? Fortunately, It works!## InstallingUse pip to install:```bash$ pip install pytest-stepfunctions```## Getting StartedSuppose there is a state machine that simply collects all the EMR cluster unique identifiers. Here is the state machine definition:```json{  &quot;StartAt&quot;: &quot;ListIds&quot;,  &quot;States&quot;: {    &quot;ListIds&quot;: {      &quot;Type&quot;: &quot;Task&quot;,      &quot;Resource&quot;: &quot;${ListIdsLambdaArn}&quot;,      &quot;ResultPath&quot;: &quot;$.cluster_ids&quot;,      &quot;End&quot;: true    }  }}```and the Lambda code `my/pkg/emr.py`:```pythonimport boto3def list_ids(*args, **kwargs):    emr_client = boto3.client(&quot;emr&quot;)    response = emr_client.list_clusters()    return [item[&quot;Id&quot;] for item in response[&quot;Clusters&quot;]]```### Creating a State MachineIn the test file `tests/test_foo.py`, create a Step Functions client with endpoint URL pointed to our Step Functions service, and use this client to create a state machine resource by using the definition above```pythonfrom string import Templateimport boto3def test_bar(aws_stepfunctions_endpoint_url):    definition_template = Template(&quot;&quot;&quot;    {      &quot;StartAt&quot;: &quot;ListIds&quot;,      &quot;States&quot;: {        &quot;ListIds&quot;: {          &quot;Type&quot;: &quot;Task&quot;,          &quot;Resource&quot;: &quot;${ListIdsLambdaArn}&quot;,          &quot;ResultPath&quot;: &quot;$.cluster_ids&quot;,          &quot;End&quot;: true        }      }    }    &quot;&quot;&quot;)    list_ids_lambda_arn = &quot;arn:aws:lambda:us-east-1:123456789012:function:my.pkg.emr.list_ids&quot;    definition = definition_template.safe_substitute(ListIdsLambdaArn=list_ids_lambda_arn)    sfn_client = boto3.client(&quot;stepfunctions&quot;, endpoint_url=aws_stepfunctions_endpoint_url)    state_machine_arn = sfn_client.create_state_machine(        name=&quot;list-ids&quot;, definition=definition, roleArn=&quot;arn:aws:iam::012345678901:role/DummyRole&quot;    )[&quot;stateMachineArn&quot;]```Note the internal fake Lambda service in pytest-stepfunctions will parse Lambda ARNs to recognize what to call.### Mocking the EMR Client in the Lambda CodeHere uses the [pytest-mock](https://github.com/pytest-dev/pytest-mock/) fixture to temporarily patch the `boto3` module inside the Lambda code. `botocore.stub.Stubber` is also applied to make sure the mock request parameters and response content are all valid:```pythonfrom botocore.stub import Stubberdef test_bar(aws_stepfunctions_endpoint_url, mocker):    ...    emr_client = boto3.client(&quot;emr&quot;)    mocker.patch(&quot;my.pkg.emr.boto3&quot;, autospec=True).client.return_value = emr_client    stubber = Stubber(emr_client)    stubber.add_response(        &quot;list_clusters&quot;, service_response={&quot;Clusters&quot;: [{&quot;Id&quot;: &quot;j-00001&quot;}, {&quot;Id&quot;: &quot;j-00002&quot;}]}    )```### Starting Execution and Validating ResultsStart and wait until the execution status is not `RUNNING`:```pythonimport jsonimport timedef test_bar(aws_stepfunctions_endpoint_url, mocker):    ...    execution_arn = sfn_client.start_execution(        stateMachineArn=state_machine_arn, name=&quot;list-ids-exec&quot;, input=&quot;{}&quot;    )[&quot;executionArn&quot;]    with stubber:        while True:            response = sfn_client.describe_execution(executionArn=execution_arn)            if response[&quot;status&quot;] != &quot;RUNNING&quot;:                break            time.sleep(0.5)    stubber.assert_no_pending_responses()    assert &quot;SUCCEEDED&quot; == response[&quot;status&quot;]    assert [&quot;j-00001&quot;, &quot;j-00002&quot;] == json.loads(response[&quot;output&quot;])[&quot;cluster_ids&quot;]```### Running the Test with the Step Functions JARThe JAR is available [here](https://docs.aws.amazon.com/step-functions/latest/dg/sfn-local.html). Download and execute it first:```bash$ java -jar /path/to/StepFunctionsLocal.jar \    --lambda-endpoint http://localhost:13000 \    --step-functions-endpoint http://localhost:8083 \    --wait-time-scale 0Step Functions LocalVersion: 1.4.0Build: 2019-09-182020-07-06 18:40:28.284: Configure [Lambda Endpoint] to [http://localhost:13000]2020-07-06 18:40:28.285: Configure [Step Functions Endpoint] to [http://localhost:8083]2020-07-06 18:40:28.323: Loaded credentials from profile: default2020-07-06 18:40:28.324: Starting server on port 8083 with account 123456789012, region us-east-1```Then run the test with the following command:```bash$ python -m pytest -v \    --pytest-stepfunctions-endpoint-url=http://0.0.0.0:8083 \    --pytest-stepfunctions-lambda-address=0.0.0.0 \    --pytest-stepfunctions-lambda-port=13000 \    ./tests=============================== test session starts ================================platform linux -- Python 3.7.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1 -- /tmp/gg/venv/bin/pythoncachedir: .pytest_cacherootdir: /tmp/ggplugins: mock-3.1.1, stepfunctions-0.1a2collected 1 itemtests/test_foo.py::test_bar PASSED                                           [100%]================================ 1 passed in 1.01s =================================```### Running the Test with the Step Functions Docker ImageI personally recommend this way as it is much easier to reproduce the testing environment.This is the `Dockerfile````dockerfileFROM python:3.7WORKDIR /appCOPY ./my ./myCOPY ./tests ./testsRUN pip install pytest pytest-stepfunctions pytest-mock boto3```and the `docker-compose.yml` for Docker Compose:```yamlversion: &quot;3.2&quot;services:  tester:    build:      context: .      dockerfile: ./Dockerfile    environment:      AWS_DEFAULT_REGION: us-east-1      AWS_ACCESS_KEY_ID: xxx      AWS_SECRET_ACCESS_KEY: xxx    command: &gt;      bash -c &quot;python -m pytest -v      --pytest-stepfunctions-endpoint-url=http://sfn-endpoint:8083      --pytest-stepfunctions-lambda-address=0.0.0.0      --pytest-stepfunctions-lambda-port=13000      ./tests&quot;  sfn-endpoint:    image: amazon/aws-stepfunctions-local:1.5.1    environment:      AWS_DEFAULT_REGION: us-east-1      AWS_ACCESS_KEY_ID: xxx      AWS_SECRET_ACCESS_KEY: xxx      WAIT_TIME_SCALE: 0      STEP_FUNCTIONS_ENDPOINT: http://sfn-endpoint:8083      LAMBDA_ENDPOINT: http://tester:13000```Then run the following command to run the test:```bash$ docker-compose up --build --exit-code-from tester```## ContributingHere are the tools required:- Docker and Docker Compose- GNU Make- [pip-tools](https://github.com/jazzband/pip-tools)Set up a virtual environment for your IDE:```bash$ python -m venv venv$ source ./venv/bin/activate(venv) $ pip-sync ./dev-requirements.txt ./requirements.txt```Run the tests and linters:```bash$ make lint test```## Known Issues1. Nested workflows are very slow: if a state machine contains lots of nested state machines, the execution will be extremely slow even `WAIT_TIME_SCALE` is set to 0. This is a known performance issue in the official JAR.2. AWS Service integrations other than Lambda are not supported yet. Services like EMR even have no endpoint option in the official JAR. A possible workaround for some cases is calling them by invoking Lambda functions.   </longdescription>
</pkgmetadata>