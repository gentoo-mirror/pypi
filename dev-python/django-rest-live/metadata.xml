<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>## Django REST Live[![Documentation](https://readthedocs.org/projects/django-rest-live/badge/?version=latest)](https://django-rest-live.readthedocs.io/en/latest/?badge=latest)[![CircleCI](https://circleci.com/gh/pennlabs/django-rest-live.svg?style=shield)](https://circleci.com/gh/pennlabs/django-rest-live)[![Coverage Status](https://codecov.io/gh/pennlabs/django-rest-live/branch/master/graph/badge.svg)](https://codecov.io/gh/pennlabs/django-rest-live)[![PyPi Package](https://img.shields.io/pypi/v/django-rest-live.svg)](https://pypi.org/project/django-rest-live/)Django REST Live enables clients which use an API built with [Django REST Framework](https://github.com/encode/django-rest-framework) to receive a stream of updates for querysets and model instances over a websocket connection managed by [Django Channels](https://github.com/django/channels). There had been plans for real-time websocket support in REST Framework on a few occasions ([2016](https://www.django-rest-framework.org/community/mozilla-grant/#realtime-apis), [2018](https://groups.google.com/g/django-rest-framework/c/3-QNn3SYlZI/m/Gwx6rFr4BQAJ?pli=1)), but at the time, async support in Django was in the early planning stages and Channels was being [rewritten with breaking API changes](https://channels.readthedocs.io/en/2.x/one-to-two.html).This plugin aims to bridge that gap between Channels and REST Framework while being as generic and boilerplate-free as possible. Clients are be able to subscribe to real-time updates for any queryset that's exposed through a [Generic API View](https://www.django-rest-framework.org/api-guide/generic-views/#genericapiview) or any of its subclasses, including [Model ViewSet](https://www.django-rest-framework.org/api-guide/viewsets/#modelviewset), with just one mixin!Check out [the full tutorial and reference documentation](https://django-rest-live.readthedocs.io) for specifics.### Dependencies- [Django](https://github.com/django/django/) (3.1 and up)- [Django Channels](https://github.com/django/channels) (2.x and 3.x both supported)- [Django REST Framework](https://github.com/encode/django-rest-framework/) (3.11 and up)- [`channels_redis`](https://github.com/django/channels_redis) for  [channel layer](https://channels.readthedocs.io/en/latest/topics/channel_layers.html) support in production. Channel layers is what allows a Django signal to broadcast an update to all websocket clients.### Installation and SetupMake sure to [install and properly set up Django Channels](https://channels.readthedocs.io/en/latest/installation.html) before installing `django-rest-live`.```pip install django-rest-live```Add `rest_live` to your `INSTALLED_APPS`:```pythonINSTALLED_APPS = [    ...    &quot;rest_framework&quot;,    &quot;channels&quot;,    &quot;rest_live&quot;,]```Create a `RealtimeRouter` in your ASGI routing file (generally `asgi.py`) and add the router's consumer to the websocket routing you set up with Django Channels. Feel free to choose any URL endpoint for the websocket, here we've chosen `/ws/subscribe/`.```pythonfrom channels.auth import AuthMiddlewareStackfrom channels.routing import ProtocolTypeRouter, URLRouterfrom django.urls import pathfrom django.core.asgi import get_asgi_applicationfrom rest_live.routers import RealtimeRouterrouter = RealtimeRouter()application = ProtocolTypeRouter({    &quot;http&quot;: get_asgi_application(),    &quot;websocket&quot;: AuthMiddlewareStack(    URLRouter([        path(&quot;ws/subscribe/&quot;, router.as_consumer().as_asgi(), name=&quot;subscriptions&quot;),    ])),})```### Configuration&gt; Check out the [Tutorial](https://django-rest-live.readthedocs.io/en/latest/usage/) for an in-depth example.To allow subscriptions to a queryset, add the `RealtimeMixin` to a GenericAPIView or ModelViewSet that exposes that queryset. Then, register the view with the `RealtimeRouter` instance you created during setup.```python...router = RealtimeRouter()router.register(MyViewSet)  # Register all ViewSets here...```### Client-SideSubscribing to a updates equires opening a [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)on the client connection to the URL you specified during setup. Feel free to use any frontend web framework you'd like. Below is a simple example in vanilla JavaScript which logs updates to the console.```javascriptconst socket = new WebSocket(&quot;ws://&lt;django_domain_here&gt;/ws/subscribe&quot;);socket.addEventListener(&quot;message&quot;, function (event) {  console.log(&quot;Update received:&quot;, JSON.parse(event.data));});// Subscribe to updates for the model instance with the ID of 1.socket.send(  JSON.stringify({    id: 1337,    type: &quot;subscribe&quot;,    model: &quot;appname.ModelName&quot;,    action: &quot;retrieve&quot;,    lookup_by: 1,  }));// Subscribe to updates for every model in the queryset.socket.send(  JSON.stringify({    id: 1338,    type: &quot;subscribe&quot;,    model: &quot;appname.ModelName&quot;,    action: &quot;list&quot;,  }));// After 5 seconds, unsubscribe from updates for the single model instance with ID 1.setTimeout(5 * 1000, () =&gt;  socket.sent(    JSON.stringify({      type: &quot;unsubscribe&quot;,      id: 1337,    })  ));```Broadcast updates will be sent from the server in this format:```json{  &quot;type&quot;: &quot;broadcast&quot;,  &quot;id&quot;: 1337,  &quot;model&quot;: &quot;appname.ModelName&quot;,  &quot;action&quot;: &quot;UPDATED&quot;,  &quot;instance&quot;: { &quot;id&quot;: 1, &quot;field1&quot;: &quot;value1&quot;, &quot;field2&quot;: &quot;value2&quot; }}```This is only a basic example. For more details, including how to send arguments and parameters along with subscriptions, read the [Tutorial](https://django-rest-live.readthedocs.io/en/latest/usage/) and the [Websocket API Reference](https://django-rest-live.readthedocs.io/en/latest/api/).### Closing Notes`django-rest-live` took initial inspiration from [this article by Kit La Touche](https://www.oddbird.net/2018/12/12/channels-and-drf/).Differently from projects like [`djangochannelsrestframework`](https://github.com/hishnash/djangochannelsrestframework),`django-rest-live` does not aim to supplant REST Framework for performing CRUD actions through a REST API. Instead,it is designed to be used in conjunction with HTTP REST endpoints. Clients should still use normal REST frameworkendpoints generated by ViewSets and other API views to get initial data to populate a page, as well as any write-drivenbehavior (`POST`, `PATCH`, `PUT`, `DELETE`). `django-rest-live` gets rid of the need for periodic polling GETrequests to for resource updates after page load.</longdescription>
</pkgmetadata>