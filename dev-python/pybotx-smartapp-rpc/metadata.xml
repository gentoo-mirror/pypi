<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># BotX-SmartApp-RPCБиблиотека, позволяющая писать смартаппы, используя [наш JSONRPC-like протокол](https://ccsteam.atlassian.net/wiki/spaces/EI/pages/193167368/SmartApp+RPC)## УстановкаИспользуя `poetry`:```bashpoetry add pybotx-smartapp-rpc```## Добавление RPC методов1. Создайте класс для входящих аргументов:``` pythonfrom pybotx_smartap_rpc import RPCArgsBaseModel...class SumArgs(RPCArgsBaseModel):    a: int    b: int```2. Создайте RPC метод:``` pythonfrom pybotx_smartapp_rpc import SmartApp, RPCRouter, RPCResultResponse...rpc = RPCRouter()...@rpc.method(&quot;sum&quot;)async def sum(    smartapp: SmartApp, rpc_arguments: SumArgs) -&gt; RPCResultResponse[int]:    return RPCResultResponse(result=rpc_arguments.a + rpc_arguments.b)# Так же у метода может не быть аргументов:@rpc.method(&quot;answer&quot;)async def answer(smartapp: SmartApp) -&gt; RPCResultResponse[int]:    return RPCResultResponse(result=42)```3. Создайте экземпляр `SmartAppRPC` и подключите роутер из прошлого пункта:``` pythonfrom pybotx_smartapp_rpc import SmartAppRPCfrom anywhere import methods ...smartapp = SmartAppRPC(routers=[methods.rpc])```4. Сделайте хендлер для `smartapp_event` и вызывайте в нем хендлер библиотеки``` python@collector.smartapp_eventasync def handle_smartapp_event(event: SmartAppEvent, bot: Bot) -&gt; None:    await smartapp.handle_smartapp_event(event, bot)```## Продвинутая работа с библиотекой* В `RPCResultResponse` можно передавать `botx.File` файлы.``` python@rpc.method(&quot;get-pdf&quot;)async def get_pdf(    smartapp: SmartApp, rpc_arguments: GetPDFArgs) -&gt; RPCResultResponse[None]:    ...    return RPCResultResponse(result=None, files=[...])```* В `SmartAppRPC`, `RPCRouter` и `RPCRouter.method` можно передать мидлвари, сначала будут вызваны мидлвари приложения, затем мидлвари роутера и в конце мидлвари метода.``` pythonsmartapp = SmartAppRPC(..., middlewares=[...])...rpc = RPCRouter(middlewares=[...])...@rpc.method(&quot;sum&quot;, middlewares=[...])```* `RPCArgsBaseModel` это алиас для `pydantic.BaseModel`, вы можете использовать все возможности исходного класса.``` pythonfrom uuid import UUID...class DelUserArgs(RPCArgsBaseModel):    # pydantic сериализует входящую строку в UUID    user_huid: UUID```* Через объект `smartapp`, передаваемый в хендлер можно получить доступ к `event` и `bot`.``` python...@rpc.method(&quot;del-user&quot;)async def del_user(    smartapp: SmartApp, rpc_arguments: DelUserArgs) -&gt; RPCResultResponse[None]:    await smartapp.bot.send_message(        body=&quot;Done&quot;,        bot_id=smartapp.event.bot.id,        chat_id=smartapp.event.chat.id,    )    ...```* Используя метод `smartapp.send_event` можно отправлять RPC ивенты с `ref: null`.  Это может пригодиться при необходимости отправки уведомления не в ответ на RPC запрос.``` python@rpc.method(&quot;notify-me&quot;)async def notify_me(    smartapp: SmartApp, rpc_arguments: NotifyMeArgs) -&gt; RPCResultResponse[None]:    ...    await smartapp.send_event(&quot;notified&quot;, files=[notify_file])    ...```* Используя метод `smartapp.send_push` можно отправлять пуш уведомлений на клиент.И обновлять счетчик уведомлений на икноке смартапа.``` python@rpc.method(&quot;notify-me&quot;)async def notify_me(    smartapp: SmartApp, rpc_arguments: NotifyMeArgs) -&gt; RPCResultResponse[None]:    await smartapp.send_push(42, &quot;You have 42 new emails!&quot;)    ...```* В мидлварях можно создавать новые объекты в `smartapp.state`, чтобы потом использовать их в хендлерах.``` pythonasync def user_middleware(smartapp: SmartApp, rpc_arguments: RPCArgsBaseModel, call_next: Callable) -&gt; RPCResponse[User]:    smartapp.state.user = await User.get(smartapp.message.user_huid)    return await call_next(smartapp, rpc_arguments)@rpc.method(&quot;get-user-fullname&quot;)async def get_user_fullname(smartapp: SmartApp) -&gt; RPCResultResponse[str]:    return RPCResultResponse(result=smartapp.state.user.fullname)```* Можно выбрасывать пользовательские RPC ошибки, которые будут отправлены как ответ на RPC запрос.``` pythonfrom pybotx_smartapp_rpc import RPCErrorExc, RPCError...@rpc.method(&quot;return-error&quot;)async def return_error(smartapp: SmartApp, rpc_arguments: RaiseOneErrorArgs) -&gt; None:    # one error    raise RPCErrorExc(        RPCError(            reason=&quot;It's error reason&quot;,            id=&quot;CUSTOM_ERROR&quot;,            meta={&quot;args&quot;: rpc_arguments.dict()},        )    )    # or list of errors    raise RPCErrorExc(        [            RPCError(                reason=&quot;It's error reason&quot;,                id=&quot;CUSTOM_ERROR&quot;,                meta={&quot;args&quot;: rpc_arguments.dict()},            ),            RPCError(                reason=&quot;It's one more error reason&quot;,                id=&quot;CUSTOM_ERROR_NUMBER_TWO&quot;,                meta={&quot;args&quot;: rpc_arguments.dict()},            )        ]    )```* Можно добавить хендлер на определенный тип исключений. В него будут отправлять исключения того же и дочерних классов.Хендлер **обязан** возвращать `RPCErrorResponse`, ошибки из которого будут отправлены источнику запроса.``` pythonfrom pybotx_smartapp_rpc import SmartAppRPC, RPCErrorResponse...async def key_error_handler(exc: KeyError, smartapp: SmartApp) -&gt; RPCErrorResponse:    key = exc.args[0]    return RPCErrorResponse(        errors=[            RPCError(                reason=f&quot;Key {key} not found.&quot;,                id=&quot;KEY_ERROR&quot;,                meta={&quot;key&quot;: key},            ),        ]    )smartapp = SmartAppRPC(..., exception_handlers={KeyError: key_error_handler})```### Swagger documentationМожно подключить rpc роутеры к авто генерируемой документации FastAPI и использоватьдокументацию в Swagger. Для этого необходимо переопределить функцию для генерации OpenAPI схемы:```pythonfrom fastapi import FastAPIapplication = FastAPI()def get_custom_openapi():    return custom_openapi(        title=&quot;Smartapp API&quot;,        version=&quot;0.1.0&quot;,        fastapi_routes=application.routes,        rpc_router=smartapp.router,    )application.openapi = get_custom_openapi```Пример функции `custom_openapi`:```pythonfrom fastapi import routingfrom fastapi.encoders import jsonable_encoderfrom fastapi.openapi.models import OpenAPIfrom fastapi.openapi.utils import get_flat_models_from_routes, get_openapi_pathfrom fastapi.utils import get_model_definitionsdef custom_openapi(    *,    title: str,    version: str,    openapi_version: str = &quot;3.0.2&quot;,    description: Optional[str] = None,    fastapi_routes: Sequence[BaseRoute],    rpc_router: RPCRouter,    tags: Optional[List[Dict[str, Any]]] = None,    servers: Optional[List[Dict[str, Union[str, Any]]]] = None,    terms_of_service: Optional[str] = None,    contact: Optional[Dict[str, Union[str, Any]]] = None,    license_info: Optional[Dict[str, Union[str, Any]]] = None,) -&gt; Dict[str, Any]:    info: Dict[str, Any] = {&quot;title&quot;: title, &quot;version&quot;: version}    if description:        info[&quot;description&quot;] = description    if terms_of_service:        info[&quot;termsOfService&quot;] = terms_of_service    if contact:        info[&quot;contact&quot;] = contact    if license_info:        info[&quot;license&quot;] = license_info            output: Dict[str, Any] = {&quot;openapi&quot;: openapi_version, &quot;info&quot;: info}    if servers:        output[&quot;servers&quot;] = servers            components: Dict[str, Dict[str, Any]] = {}    paths: Dict[str, Dict[str, Any]] = {}    # FastAPI    flat_fastapi_models = get_flat_models_from_routes(fastapi_routes)    fastapi_model_name_map = get_model_name_map(flat_fastapi_models)    fast_api_definitions = get_model_definitions(        flat_models=flat_fastapi_models, model_name_map=fastapi_model_name_map    )    # pybotx RPC    flat_rpc_models = get_rpc_flat_models_from_routes(rpc_router)    rpc_model_name_map = get_model_name_map(flat_rpc_models)    rpc_definitions = get_model_definitions(        flat_models=flat_rpc_models, model_name_map=rpc_model_name_map    )    for route in fastapi_routes:        if isinstance(route, routing.APIRoute):            result = get_openapi_path(                route=route, model_name_map=fastapi_model_name_map            )            if result:                path, security_schemes, path_definitions = result                if path:                    paths.setdefault(route.path_format, {}).update(path)                if security_schemes:                    components.setdefault(&quot;securitySchemes&quot;, {}).update(                        security_schemes                    )                if path_definitions:                    fast_api_definitions.update(path_definitions)    for method_name in rpc_router.rpc_methods.keys():        if not rpc_router.rpc_methods[method_name].include_in_schema:            continue        result = get_rpc_openapi_path(            method_name=method_name,            route=rpc_router.rpc_methods[method_name],            model_name_map=rpc_model_name_map,        )        if result:            path, path_definitions = result            if path:                paths.setdefault(method_name, {}).update(path)            if path_definitions:                rpc_definitions.update(path_definitions)    if fast_api_definitions:        components[&quot;schemas&quot;] = {            k: fast_api_definitions[k] for k in sorted(fast_api_definitions)        }    if rpc_definitions:        components.setdefault(&quot;schemas&quot;, {}).update(            {k: rpc_definitions[k] for k in sorted(rpc_definitions)}        )    if components:        output[&quot;components&quot;] = components        output[&quot;paths&quot;] = paths    if tags:        output[&quot;tags&quot;] = tags    return jsonable_encoder(OpenAPI(**output), by_alias=True, exclude_none=True)  # type: ignore```### Возможности RPC Swagger* Можно добавлять теги к запросам, анaлогично FastAPI.``` pythonrpc = RPCRouter(tags=[&quot;RPC&quot;])@rpc.method(&quot;documented-method&quot;, tags=[&quot;docs&quot;])async def docs(    smartapp: SmartApp, rpc_arguments: DocumentedArgs) -&gt; RPCResultResponse[DocumentedResponse]:    &quot;&quot;&quot;Desctiption of this method.&quot;&quot;&quot;    ...```* Можно переопределять pydantic модель успешного ответа.``` python@rpc.method(&quot;method&quot;, return_type=Response)async def method(    smartapp: SmartApp, rpc_arguments: MethodArgs) -&gt; RPCResultResponse[int]:    ...```* Можно исключать некоторые методы из документации.``` pythonrpc = RPCRouter(include_in_schema=False)@rpc.method(&quot;_hidden_method&quot;, include_in_schema=False)async def hidden_method(smartapp: SmartApp) -&gt; RPCResultResponse[int]:    ...```* Можно определять пользовательские ошибки.``` pythonfrom pybotx_smartapp_rpc import RPCError, RPCErrorExcclass Meta(BaseModel):    user_id: int    username: strclass UsernotFoundError(RPCError):    id = &quot;UserNotFound&quot;    reason = &quot;User not found in db&quot;    meta: Meta@rpc.method(&quot;method-with_error&quot;, errors=[UsernotFoundError])async def get_user(    smartapp: SmartApp, rpc_arguments: UserArgs) -&gt; RPCResultResponse[User]:    ...    raise RPCErrorExc(UsernotFoundError(meta={&quot;user_id&quot;: 1, &quot;username&quot;: &quot;test&quot;}))```</longdescription>
</pkgmetadata>