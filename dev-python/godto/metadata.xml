<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># godtoData Transfer Object (DTO) codegen from JSON schemas following the OpenAPI spec ## Usage### Full OpenAPI schema modelTo work with an OpenAPI schema, load it with the `Model` class,which is a Pydantic model (however note that the class name 'Model' comes from the OpenAPI spec).```pyfrom godto.openapi.v3 import Modelmodel = Model.parse_raw(schema_json)```For example the Transport for London `StopPoint` API schemais [shipped as package data][StopPoint_schema] in `tubeulator`.[StopPoint_schema]: https://github.com/lmmx/tubeulator/blob/master/src/tubeulator/data/openapi/StopPoint/StopPoint.json```pyfrom pathlib import Pathpath_to_schema = Path(&quot;data/openapi/StopPoint/StopPoint.json&quot;)schema_json = path_to_schema.read_text()```### Model helper functionsYou can also work with partial views on the model, such as the paths and their parameters.The examples in the following code block show `model_paths` which loads the schema for a given spec(by default OpenAPI v3) and returns its parameters for a specific method (by default GET):- `required`: whether the parameter is required or optional- `schema_`: the schema for parsing the parameter- `description`: the human-readable parameter docstring```py&gt;&gt;&gt; from godto.api.model import model_paths&gt;&gt;&gt; param_requirements = model_paths(schema_json, extract=&quot;required&quot;)&gt;&gt;&gt; pprint(param_requirements)                                                      {'/': {'categories': False,                                                                'lat': True,                                                                        'lon': True,                                                                        'modes': False,                                                                     'radius': False,                                                                    'returnLines': False,                                                               'stopTypes': True,                                                                  'useStopPointHierarchy': False},                                              '/*': {}, '/Meta/Categories': {}, '/Meta/Modes': {},...&gt;&gt;&gt; param_schemas = model_paths(schema_json, extract=&quot;schema_&quot;)&gt;&gt;&gt; param_descs = model_paths(schema_json, extract=&quot;description&quot;)            &gt;&gt;&gt; pprint(param_descs)                                                        &gt;&gt;&gt; pprint(param_descs)                                                             {'/': {'categories': 'an optional list of comma separated property categories '                          &quot;to return in the StopPoint's property bag. If null or &quot;                        'empty, all categories of property are returned. Pass the '                         'keyword &quot;none&quot; to return no properties (a valid list of '                          'categories can be obtained from the '                                              '/StopPoint/Meta/categories endpoint)',                          'lat': 'Format - double. the latitude of the centre of the bounding '                  'circle',                                                                    'lon': 'Format - double. the longitude of the centre of the bounding '                'circle',                                                                    'modes': 'the list of modes to search (comma separated mode names e.g. '                'tube,dlr)',                                                               'radius': 'Format - int32. the radius of the bounding circle in metres '                      '(default : 200)',...                  ```## RequirementsPython 3.9+</longdescription>
</pkgmetadata>