<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Flask Toolkits[![Downloads](https://static.pepy.tech/personalized-badge/flask-toolkits?period=total&amp;units=international_system&amp;left_color=black&amp;right_color=blue&amp;left_text=Downloads)](https://pepy.tech/project/flask-toolkits)## Installation```pip install flask-toolkits```## DescriptionFlask toolkits implements and provides several features from `FastAPI` like:- Automatic API documentation (define the function and we'll generate the `swagger`/`openapi` spec for you)- Passing parameters through `view`/`router` function which is unable in `Flask` before- Easy Middleware setup- Parameters and schema validation using `Pydantic`- Response classes that could return any type of data without worried to get error- much more..## Changelogs- v0.0    - First Upload- v0.1    - Integration with [flask-http-middleware](https://pypi.org/project/flask-http-middleware)    - [pydantic](https://pypi.org/project/pydantic) support for JSON arguments and validation    - Multiple response type generator    - Added `JSONResponse` class to replace `jsonify` roles in send dictionary data with encoding improvements.- v0.2    - Supported enumeration API documentation    - Added support for type hint from `typing`'s generic (ex: `Optional`, `Union`, `List`)    - Fixed input parameter validations- v0.3    - Support `File` and `Form` input parameters validation and automatic swagger.    - Added constraint feature for parameters (ex: limit, max/min length, greater/less than, equals than etc)- v0.4    - Support `Authorization` header in openapi spec.    - Added `Authorization` processing function for security and can be used as `login` or `auth`.- v0.5    - Support `add_url_rule` and `route` for endpoint definition    - Support auto swagger for multiple methods in a single endpoints- v0.6    - Support `alias` on endpoint parameters (path, query, header, etc) to enable        non-pythonic terms of parameter names- v0.7    - support response structure generator function to helps creating the response schema and examples## Key Tools inside this `toolkit`- Automatic API documentation (`swagger`/`openapi`)- Request-Response direct HTTP middleware (`flask-http-middleware`)- Automatic parameters validation (`pydantic`)- Response generator (JSON, Plain Text, HTML)## Automatic Parameters ValidationThe original `Blueprints` class from `flask` can't insert most of arguments inside endpoint.Here our `APIRouter` allows you to have arguments inside your endpoint```from typing import Optionalfrom flask_toolkits import APIRouter, Body, Header, Queryfrom flask_toolkits.responses import JSONResponserouter = APIRouter(&quot;email&quot;, import_name=__name__, static_folder=&quot;/routers/email&quot;, url_prefix=&quot;/email&quot;)@router.post(&quot;/read&quot;, tags=[&quot;Email Router&quot;])def get_email(    id: int,    name: Optional[str],):    return JSONResponse({&quot;id&quot;: id, &quot;name&quot;: name})```## Automatic API DocumentationHere our `APIRouter` allows you to auto-documenting your endpoint through `AutoSwagger`.Define the new router using `APIRouter` class, lets put it in another pyfile`email_view.py````from typing import Optionalfrom flask_toolkits import APIRouter, Body, Header, Queryfrom flask_toolkits.responses import JSONResponserouter = APIRouter(&quot;email&quot;, import_name=__name__, static_folder=&quot;/routers/email&quot;, url_prefix=&quot;/email&quot;)@router.post(&quot;/read&quot;, tags=[&quot;Email Router&quot;])def get_email(    id: int = Body(),    name: Optional[str] = Body(None),    token: int = Header(),    race: Optional[str] = Query(None)):    return JSONResponse({&quot;id&quot;:id, &quot;name&quot;: name})````main.py````from flask import Flaskfrom flask_toolkits import AutoSwaggerfrom email_view import router as email_routerapp = Flask(__name__)auto_swagger = AutoSwagger()app.register_blueprint(email_router)app.register_blueprint(auto_swagger)if __name__ == &quot;__main__&quot;:    app.run()```then you can go to `http://localhost:5000/docs` and you will found you router is already documented![alt text](https://github.com/Danangjoyoo/flask-toolkits/blob/main/docs/auto1.png?raw=true)---## Supported Field Parameters`flask-toolkits` provide multiple field parameters such as `Header`, `Query`, `Body`, `Path`, `File`, `Form`---## Easy Security Scheme Setup and Documentation`flask-toolkits` helps you to define your security scheme for authorization easier than before. In advance this also give you automated documentation.### Basic Usagelets assume you have your own bearer security schema. You just have to create a new instance of `HTTPBearerSecurity()` to enable automatic documentation on it.```from flask import requestfrom flask_toolkits import APIRouterfrom flask_toolkits.security import HTTPBearerSecurityrouter = APIRouter(&quot;api&quot;, __name__)@router.get(&quot;/home&quot;, security=HTTPBearerSecurity())def home(message: str):    if my_security_scheme(request):        return JSONResponse({&quot;message&quot;: message})    return JSONResponse({&quot;message&quot;: &quot;invalid authorization&quot;})```this is how it looks like![alt text](https://github.com/Danangjoyoo/flask-toolkits/blob/main/docs/auth0.png?raw=true)on you clicked it![alt text](https://github.com/Danangjoyoo/flask-toolkits/blob/main/docs/auth1.png?raw=true)### Define your own security schemeIf you want to define your own security scheme you can follow below guidance```from flask import requestfrom flask_toolkits import APIRouterfrom flask_toolkits.security import HTTPBearerSecurityclass JWTBearer(HTTPBearerSecurity):    def __init__(self):        super().__init__()    def __call__(self, req):        data = self.get_authorization_data(req)        if data != &quot;abcdefghij&quot;:            raise Exception(&quot;This is not good&quot;)        return reqrouter = APIRouter(&quot;api&quot;, __name__)@router.get(&quot;/home&quot;, security=JWTBearer())def home(message: str):    if my_security_scheme(request):        return JSONResponse({&quot;message&quot;: message})    return JSONResponse({&quot;message&quot;: &quot;invalid authorization&quot;})```Overriding `__call__` method inside the subclass would define your security schema for the routers that are using your security scheme---## Define to all endpoints in a routerJust pass it to `APIRouter` and all its endpoint will use that security scheme!```router_with_bearer = APIRouter(&quot;api&quot;, __name__, security=JWTBearer())```but don't worries! You can also override it by just defining in the router decorator!```@router_with_bearer.get(&quot;/home&quot;, security=AnotherBearerSecurity())def home():    return {&quot;message&quot;: &quot;hello&quot;}```---## Parameter AliasIn case you have non-pythonic terms with unicode character (-, +, _, =) for your paramter names, you can apply the `alias` into the parameters easily```@app.get(&quot;/test-alias&quot;)def test_alias(    apikey: str = Header(alias=&quot;x-api-key&quot;)):    return JSONResponse({&quot;apikey&quot;: apikey})```here you will also have your swagger is defined with that `alias`![alt text](https://github.com/Danangjoyoo/flask-toolkits/blob/main/docs/alias1.png?raw=true)---## Response StructureCreating the response example and schema easily by just defining the class and pass it to `create_response_example` or accessing `as_response()` from `BaseSchema` objects```from flask_toolkits.responses import response_json_exampleclass PersonResponse(BaseSchema):    name: str    age: intclass FailedResponse(BaseSchema):    message: str    error_code: int@router.route(    '/hello_world/&lt;first&gt;/&lt;int:number&gt;', tags=[&quot;My Hello&quot;],    responses={        200: response_json_example(PersonResponse(name=&quot;Alex&quot;, age=20)),        400: FailedResponse(message=&quot;Data not found&quot;, error_code=101).as_response()    },)def hello_world(    name: str = Query(),    age: int = Query()):    resp = {        &quot;name&quot;: name,        &quot;age&quot;: age    }    return JSONResponse(resp)```![alt text](https://github.com/Danangjoyoo/flask-toolkits/blob/main/docs/response_example1.png?raw=true)![alt text](https://github.com/Danangjoyoo/flask-toolkits/blob/main/docs/response_schema1.png?raw=true)---## Multiple HTTP Methods in a single endpoint`add_url_rule` and `route` method for `Flask`'s App or `Blueprints` object are now supported. This also allows you to have multiple HTTP methods in a single endpoint function```@app.route(&quot;/test-multiple-method&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;PATCH&quot;])def go_multi_method(    name: str = Body()):    return JSONResponse({&quot;result&quot;: name})```Here you will get `null` if you hit it using `GET` but you'll get the value on you hit with other methods that support `Body`. You won't loose your validation since it only applied for methods that support that kind of params.---## Request-Response direct HTTP middleware```import timefrom flask import Flaskfrom flask_toolkits.middleware import MiddlewareManager, BaseHTTPMiddlewareapp = Flask(__name__)class MetricsMiddleware(BaseHTTPMiddleware):    def __init__(self):        super().__init__()    def dispatch(self, request, call_next):        t0 = time.time()        response = call_next(request)        response_time = time.time()-t0        response.headers.add(&quot;response_time&quot;, response_time)        return responseapp.wsgi_app = MiddlewareManager(app)app.wsgi_app.add_middleware(MetricsMiddleware)@app.get(&quot;/health&quot;)def health():    return {&quot;message&quot;:&quot;I'm healthy&quot;}```</longdescription>
</pkgmetadata>