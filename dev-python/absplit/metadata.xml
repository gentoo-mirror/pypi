<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;a name=&quot;readme-top&quot;&gt;&lt;/a&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cormac-rynne/absplit/main/images/logo.jpeg&quot; width=&quot;460&quot; height=&quot;140&quot;&gt;&lt;h3&gt;&lt;strong&gt;ABSplit&lt;/strong&gt;&lt;/h3&gt;Split your data into matching A/B/n groups![license](https://img.shields.io/badge/License-MIT-blue.svg)![version](https://img.shields.io/badge/version-1.4.2-blue.svg)![version](https://img.shields.io/badge/python-3-orange.svg)&lt;/div&gt;&lt;details open&gt;  &lt;summary&gt;Table of Contents&lt;/summary&gt;  &lt;ol&gt;    &lt;li&gt;      &lt;a href=&quot;#about-the-project&quot;&gt;About The Project&lt;/a&gt;    &lt;/li&gt;    &lt;li&gt;      &lt;a href=&quot;#getting-started&quot;&gt;Getting Started&lt;/a&gt;      &lt;ul&gt;        &lt;li&gt;&lt;a href=&quot;#installation&quot;&gt;Installation&lt;/a&gt;&lt;/li&gt;      &lt;/ul&gt;    &lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#tutorial&quot;&gt;Tutorials&lt;/a&gt;&lt;/li&gt;    &lt;ul&gt;        &lt;li&gt;&lt;a href=&quot;#do-it-yourself&quot;&gt;Do it yourself&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;li&gt;&lt;a href=&quot;#usage&quot;&gt;Usage&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#api-reference&quot;&gt;API Reference&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#contributing&quot;&gt;Contributing&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#license&quot;&gt;License&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt;  &lt;/ol&gt;&lt;/details&gt;## About the projectABSplit is a python package that uses a genetic algorithm to generate as equal as possible A/B, A/B/C, or A/B/n test splits.The project aims to provide a convenient and efficient way for splitting population data into distinct groups (ABSplit), as well as and finding matching samples that closely resemble a given original sample (Match).Whether you have static population data or time series data, this Python package simplifies the process and allows you to analyze and manipulate your population data.This covers the following use cases:1. **ABSplit class**: Splitting an entire population into n groups by given proportions2. **Match class**: Finding a matching group in a population for a given sample&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#readme-top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;## Getting StartedUse the package manager [pip](https://pip.pypa.io/en/stable/) to install ABSplit and it's prerequisites.ABSplit requires `pygad==3.0.1`### Installation```bashpip install absplit```&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#readme-top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;## TutorialsPlease see [this colab](https://colab.research.google.com/drive/1gL7dxDJrtVoO5m1mSUWutdr7yas7sZwI?usp=sharing) for a range of examples on how to use ABSplit and Match### Do it yourselfSee [this colab](https://colab.research.google.com/drive/1SlCNnOtN4WCDTSJHsFrZtI7gKcXEl8-C?usp=sharing) to learn how ABSplit works under the hood, and how to build your own group splitting tool using [PyGAD](https://pypi.org/project/pygad/),&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#readme-top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;## Usage```pythonfrom absplit import ABSplitimport pandas as pdimport datetimeimport numpy as np# Synthetic datadata_dct = {    'date': [datetime.date(2030,4,1) + datetime.timedelta(days=x) for x in range(3)]*5,    'country': ['UK'] * 15,    'region': [item for sublist in [[x]*6 for x in ['z', 'y']] for item in sublist] + ['x']*3,    'city': [item for sublist in [[x]*3 for x in ['a', 'b', 'c', 'd', 'e']] for item in sublist],    'metric1': np.arange(0, 15, 1),    'metric2': np.arange(0, 150, 10)}df = pd.DataFrame(data_dct)# Identify which columns are metrics, which is the time period, and what to split onkwargs = {    'metrics': ['metric1', 'metric2'],    'date_col': 'date',    'splitting': 'city'}# Initialiseab = ABSplit(    df=df,    split=[.5, .5],  # Split into 2 groups of equal size    **kwargs,)# Generate splitab.run()# Visualise generation fitnessab.fitness()# Visualise dataab.visualise()# Extract bin splitsdf = ab.results# Extract data aggregated by binsdf_agg = ab.aggregations# Extract summary statisticsdf_dist = ab.distributions    # Population counts between groupsdf_rmse = ab.rmse             # RMSE between groups for each metricdf_mape = ab.mape             # MAPE between groups for each metricdf_totals = ab.totals         # Total sum of each metric for each group```&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#readme-top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;## API Reference### Absplit `ABSplit(df, metrics, splitting, date_col=None, ga_params={}, metric_weights={}, splits=[0.5, 0.5], size_penalty=0)`Splits population into n groups. Mutually exclusive, completely exhaustiveArguments:* `df` (pd.DataFrame): Dataframe of population to be split* `metrics` (str, list): Name of, or list of names of, metric columns in DataFrame to be considered in split* `splitting` (str): Name of column that represents individuals in the population that is getting split. For example, if you wanted to split a dataframe of US counties, this would be the county name column* `date_col` (str, optional): Name of column that represents time periods, if applicable. If left empty, it willperform a static split, i.e. not across timeseries, (default `None`)* `ga_params` (dict, optional): Parameters for the genetic algorithm `pygad.GA` module parameters, see [here](https://pygad.readthedocs.io/en/latest/README_pygad_ReadTheDocs.html#pygad-ga-class) for arguments you can pass(default: `{}`)* `splits` (list, optional): How many groups to split into, and relative size of the groups (default: `[0.5, 0.5]`,2 groups of equal size)* `size_penalty` (float, optional): Penalty weighting for differences in the population count between groups (default: `0`)* `sum_penalty` (float, optional): Penalty weighting for the sum of metrics over time. If this is greater than zero,it will add a penalty to the cost function that will try and make the sum of each metric the same for each group (default: `0`)* `cutoff_date` (str, optional): Cutoff date between fitting and validation data. For example, if you have data between 2023-01-01 and 2023-03-01, and the cutoff date is 2023-02-01, the algorithm will only perform the fit on data between 2023-01-01 and 2023-02-01. If `None`, it will fit on all available data. If cutoff date is provided, RMSE scores  (gotten by using the `ab.rmse` attribute) will only be for validation period (i.e., from 2023-02-01 to end of timeseries)* `missing_dates` (str, optional): How to deal with missing dates in time series data, options: `['drop_dates','drop_population', '0', 'median']` (default: `median`)* `metric_weights` (dict, optional): Weights for each metric in the data. If you want the splitting to focus on one metrics more than the other, you can prioritise this here (default: `{}`)### Match `Match(population, sample, metrics, splitting, date_col=None, ga_params={}, metric_weights={})`Takes DataFrame `sample` and finds a comparable group in `population`.Arguments:* `population` (pd.DataFrame): Population to search  for comparable group (**Must exclude sample data**)* `sample` (pd.DataFrame): Sample we are looking to find a match for.* `metrics` (str, list): Name of, or list of names of, metric columns in DataFrame* `splitting` (str): Name of column that represents individuals in the population that is getting split* `date_col` (str, optional): Name of column that represents time periods, if applicable. If left empty, it willperform a static split, i.e. not across timeseries, (default `None`)* `ga_params` (dict, optional): Parameters for the genetic algorithm `pygad.GA` module parameters, see [here](https://pygad.readthedocs.io/en/latest/README_pygad_ReadTheDocs.html#pygad-ga-class) for arguments you can pass(default: `{}`)* `splits` (list, optional): How many groups to split into, and relative size of the groups (default: `[0.5, 0.5]`,2 groups of equal size)* `metric_weights` (dict, optional): Weights for each metric in the data. If you want the splitting to focus on one metrics more than the other, you can prioritise this here (default: `{}`)&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#readme-top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;## ContributingI welcome contributions to ABSplit! For major changes, please open an issue firstto discuss what you would like to change.Please make sure to update tests as appropriate.&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#readme-top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;## License[MIT](https://choosealicense.com/licenses/mit/)&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#readme-top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;</longdescription>
</pkgmetadata>