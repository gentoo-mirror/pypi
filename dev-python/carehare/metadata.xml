<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>carehare========Asyncio RabbitMQ client that handles all the edge cases.Installation------------``pip install carehare``Usage-----Consumer (``async for``)::    try:        async with carehare.connect(&quot;amqps://guest:guest@localhost&quot;) as connection:            try:                await connection.queue_declare(&quot;my-queue&quot;, exclusive=True)                async with connection.acking_consumer(&quot;my-queue&quot;) as consumer:                    async for message in consumer:                        print(repr(message))                        # ... if we raise an exception here, we won't ack.                        #                        # ... if we `break` from this loop, we won't ack.                        #                        # Call `consumer.close()` before (or instead of) `break`                        # to abort iteration.            except carehare.ChannelClosedByServer:                logger.info(&quot;RabbitMQ told this one consumer to go away&quot;)            except carehare.ConnectionClosed:                # Either RabbitMQ is telling us an error (and the outer context                # manager will throw it), or we called connection.close()                # ourselves (so we want to close).                pass    except carehare.ConnectionClosedByServer:        # str(error) will give the RabbitMQ error message        logger.error(&quot;RabbitMQ closed our connection&quot;)    except carehare.ConnectionClosedByHeartbeatMonitor:        logger.error(&quot;RabbitMQ went away&quot;)Consumer (``next_delivery``)::    try:        async with carehare.connect(&quot;amqps://guest:guest@localhost&quot;) as connection:            try:                await connection.queue_declare(&quot;my-queue&quot;, exclusive=True)                async with connection.acking_consumer(&quot;my-queue&quot;) as consumer:                    while True:                        message, delivery_tag = await consumer.next_delivery()                        # You must ack() (with no await). If RabbitMQ doesn't                        # receive this ack, it may deliver the same message to                        # another client.                        consumer.ack(delivery_tag)                        if message.startswith(b&quot;okay, go away now&quot;):                            break            except carehare.ChannelClosedByServer:                logger.info(&quot;RabbitMQ told this one consumer to go away&quot;)            except carehare.ConnectionClosed:                # Either RabbitMQ is telling us an error (and the outer context                # manager will throw it), or we called connection.close()                # ourselves (so we want to close).                pass    except carehare.ConnectionClosedByServer:        # str(error) will give the RabbitMQ error message        logger.error(&quot;RabbitMQ closed our connection&quot;)    except carehare.ConnectionClosedByHeartbeatMonitor:        logger.error(&quot;RabbitMQ went away&quot;)Publisher::    try:        async with carehare.connect(&quot;amqps://guest:guest@localhost&quot;) as connection:            try:                await connection.publish(b&quot;Hello, world!&quot;, routing_key=&quot;my-queue&quot;)            except carehare.ServerSentNack:                logger.warn(&quot;Failed to publish message&quot;)            except carehare.ChannelClosedByServer:                # str(err) will give the RabbitMQ error message -- for instance,                # &quot;404 NOT_FOUND&quot; if the exchange does not exist                logger.error(&quot;Problem with the exchange&quot;)    except carehare.ConnectionClosedByServer:        # str(error) will give the RabbitMQ error message        logger.error(&quot;RabbitMQ closed our connection&quot;)    except carehare.ConnectionClosedByHeartbeatMonitor:        logger.error(&quot;RabbitMQ went away&quot;)Design decisions----------------``carehare`` is designed to turn RabbitMQ's asynchronous error system into_understandable_ Python exceptions.Channels~~~~~~~~Carehare doesn't let you control RabbitMQ Channels. They aren't Pythonic. (InRabbitMQ, an exception on a channel closes the channel -- and cancels all itspending operations.)Instead, carehare uses channels to handle errors. For instance, Queue.Declarecosts three operations: Channel.Open, Queue.Declare, Channel.Close. Since theoperation has its own channel, it won't interfere with other operations if itcauses an exception.There's a speed-up for publishing: we lazily open a Channel per *exchange*.Error codes like &quot;not found&quot;, &quot;access refused&quot; and &quot;not implemented&quot; will makecarehare raise an exception on all pending publishes on the same exchange. Don'tworry: a normal &quot;Nack&quot; (&quot;message wasn't delivered&quot;) will only make your singlemessage fail.Exceptions~~~~~~~~~~&quot;Exceptions&quot; are hardly exceptional: as a programmer, they are your job. Theseones are designed to help you solve them.Connection methods return ``asyncio.Future`` objects. You must await each oneand handle its errors.Even though you're using Python async context managers, exceptions can'thappen *everywhere*. Carehare will only raise when you ``await`` a responsefrom RabbitMQ. In particular, ``consumer.ack()`` will never raise! You must call it from themain event loop, but you won't await it.To code safely, catch these exceptions religiously:* ``carehare.ChannelClosedByServer``: RabbitMQ did not like the command you  just ran. Read the exception message for details. After you receive this  message, you may continue using the RabbitMQ connection.* ``carehare.ConnectionClosed``: When the connection shuts down, every pending  ``Future`` will raise this. Only the actual ``Connection`` context manager  will raise the underlying exception: a ``carehare.ConnectionClosedByServer``  with a descriptive error message.Carehare won't raise ``asyncio.Cancelled``.Back-pressure~~~~~~~~~~~~~The core logic is synchronous. It's simpler to reason about. The downside:neither RabbitMQ nor users will wait for buffers to empty before sending moredata.Use application-level logic to make sure you don't run out of memory:* Consuming? Don't worry. Use ``prefetch_count`` to limit the number of messages  RabbitMQ sends. Always ack: carehare won't permit ``no-ack``.* Publishing? Carehare forces &quot;publisher confirms&quot;, so each publish returns a  ``Future``. Your application is responsible for not calling publish() too many  times simultaneously. Use an ``asyncio.Semaphore`` or reason about your  specific use (for instance, &quot;my server will host max 100 clients, and each  client can only publish one message at a time&quot;).Comparison to other async RabbitMQ clients~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Other clients tend to try and achieve &quot;RabbitMQ in Python&quot;. They fail when itcomes to exceptions:* ``aiormq``: If your code generates an error during consume, aiormq (4.1.1)  will catch it and ignore it -- stalling your program.* ``aioamqp``: If your connection produces an unexpected error, aioamqp will  catch it and ignore it -- stalling your program. Also, the latest release was  in 2019.This author believes it's too confusing to model RabbitMQ's API in Python.Instead, carehare models your *intent* in Python.Dependencies------------You'll need Python 3.8+ and a RabbitMQ server.If you have Docker, here's how to start a development server::    test-server/prepare-certs.sh  # Create SSL certificates used in tests    docker run --rm -it \         -p 5671:5671 \         -p 5672:5672 \         -p 15672:15672 \         -v &quot;/$(pwd)&quot;/test-server:/test-server \         -e RABBITMQ_SSL_CACERTFILE=/test-server/ca.cert \         -e RABBITMQ_SSL_CERTFILE=/test-server/server.cert \         -e RABBITMQ_SSL_KEYFILE=/test-server/server.key \         -e RABBITMQ_SSL_VERIFY=verify_peer \         -e RABBITMQ_SSL_FAIL_IF_NO_PEER_CERT=true \         -e RABBITMQ_CONFIG_FILE=/test-server/rabbitmq \         rabbitmq:3.8.11-management-alpineDuring testing, see the RabbitMQ management interface at http://localhost:15672.Contributing------------To add features and fix bugs~~~~~~~~~~~~~~~~~~~~~~~~~~~~First, start a development RabbitMQ server (see above).Now take on the development cycle:#. ``tox`` # to ensure tests pass.#. Write new tests in ``tests/`` and make sure they fail.#. Write new code in ``carehare/`` to make the tests pass.#. Submit a pull request.To deploy~~~~~~~~~Use `semver &lt;https://semver.org/&gt;`_.#. ``git push`` and make sure Travis tests all pass.#. ``git tag vX.X.X``#. ``git push --tags``TravisCI will push to PyPi.</longdescription>
</pkgmetadata>