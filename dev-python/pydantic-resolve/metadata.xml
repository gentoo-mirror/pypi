<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![img](doc/imgs/resolver.png)&gt; A small yet powerful package which can run resolvers to generate deep nested datasets.[![pypi](https://img.shields.io/pypi/v/pydantic-resolve.svg)](https://pypi.python.org/pypi/pydantic-resolve)[![Downloads](https://static.pepy.tech/personalized-badge/pydantic-resolve?period=month&amp;units=abbreviation&amp;left_color=grey&amp;right_color=orange&amp;left_text=Downloads)](https://pepy.tech/project/pydantic-resolve)![Python Versions](https://img.shields.io/pypi/pyversions/pydantic-resolve)![Test Coverage](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/allmonday/6f1661c6310e1b31c9a10b0d09d52d11/raw/covbadge.json)[![CI](https://github.com/allmonday/pydantic_resolve/actions/workflows/ci.yml/badge.svg)](https://github.com/allmonday/pydantic_resolve/actions/workflows/ci.yml)[Change log](./changelog.md)## TR;DR`pydantic-resolve` helps you resolve all `resolve_field` methods inside a pydantic object.It attempts to convert the data returned from `resolve_field` methods to the type target field announced.for example: ```pythonclass Team(BaseModel):    id: int    name: str    members: List[Member] = []    def resolve_members(self, loader=LoaderDepend(members_batch_load_fn)):  # 3        return loader.load(self.id)````resolve_members` method returns list of dict:```python[  {'id': 1, 'name': 'kikodo'},  {'id': 2, 'name': 'kimi'},]``` and will be transformed to `Member` instances ```python[  Member(id=1, name='kikodo'),  Member(id=2, name='kimi')]```and then assigned it to team.members:```python&quot;&quot;&quot;expected schema:{  departments[] {    id    name    teams[] {      id      name      members[] {        id        name      }    }  }}&quot;&quot;&quot;class Member(BaseModel):    id: int    name: str# 1. define schema fields# 2. define resolvable fields# 3. declare depend loaderclass Team(BaseModel):    # 1     id: int    name: str    # 2    members: List[Member] = []    def resolve_members(self, loader=LoaderDepend(members_batch_load_fn)):  # 3        return loader.load(self.id)class Department(BaseModel):    id: int    name: str    teams: List[Team] = []    def resolve_teams(self, loader=LoaderDepend(teams_batch_load_fn)):        return loader.load(self.id)class Result(BaseModel):    departments: List[Department] = []    def resolve_departments(self):        return departments# 3. user Resolver to resolve all fields.async def main():    result = Result()    await Resolver().resolve(result)    return result```## Install```shellpip install pydantic-resolve```## Quick startAssume we have 3 tables: `departments`, `teams` and `members`, which have `1:N relationship` from left to right. ```python# 1. prepare table recordsdepartments = [    dict(id=1, name='INFRA'),    dict(id=2, name='DevOps'),    dict(id=3, name='Sales'),]teams = [    dict(id=1, department_id=1, name=&quot;K8S&quot;),    dict(id=2, department_id=1, name=&quot;MONITORING&quot;),    # ...    dict(id=10, department_id=2, name=&quot;Operation&quot;),]members = [    dict(id=1, team_id=1, name=&quot;Sophia&quot;),    # ...    dict(id=19, team_id=10, name=&quot;Emily&quot;),    dict(id=20, team_id=10, name=&quot;Ella&quot;)]```and we want to generate nested json base on these 3 tables. the output should be looks like: &gt; and we hope to query each table for only once, N+1 query is forbidden.```json{  &quot;departments&quot;: [    {      &quot;id&quot;: 1,      &quot;name&quot;: &quot;INFRA&quot;,      &quot;teams&quot;: [        {          &quot;id&quot;: 1,          &quot;name&quot;: &quot;K8S&quot;,          &quot;members&quot;: [            {              &quot;id&quot;: 1,              &quot;name&quot;: &quot;Sophia&quot;            }          ]        }      ]    }  ]}```We will shows how to make it with `pydantic-resolve` which has 4 steps:1. get data2. group children with parent_id in dataloader function3. define pydantic schema, bind with dataloader4. resolve```pythonimport jsonimport asynciofrom typing import Listfrom pydantic import BaseModelfrom pydantic_resolve import Resolver, LoaderDepend, build_list# 1. prepare table recordsdepartments = [    dict(id=1, name='INFRA'),    dict(id=2, name='DevOps'),    dict(id=3, name='Sales'),]teams = [    dict(id=1, department_id=1, name=&quot;K8S&quot;),    dict(id=2, department_id=1, name=&quot;MONITORING&quot;),    dict(id=3, department_id=1, name=&quot;Jenkins&quot;),     dict(id=5, department_id=2, name=&quot;Frontend&quot;),    dict(id=6, department_id=2, name=&quot;Bff&quot;),    dict(id=7, department_id=2, name=&quot;Backend&quot;),     dict(id=8, department_id=3, name=&quot;CAT&quot;),    dict(id=9, department_id=3, name=&quot;Account&quot;),    dict(id=10, department_id=3, name=&quot;Operation&quot;),]members = [  dict(id=1, team_id=1, name=&quot;Sophia&quot;),  dict(id=2, team_id=1, name=&quot;Jackson&quot;),  dict(id=3, team_id=2, name=&quot;Olivia&quot;),  dict(id=4, team_id=2, name=&quot;Liam&quot;),  dict(id=5, team_id=3, name=&quot;Emma&quot;),  dict(id=6, team_id=4, name=&quot;Noah&quot;),  dict(id=7, team_id=5, name=&quot;Ava&quot;),  dict(id=8, team_id=6, name=&quot;Lucas&quot;),  dict(id=9, team_id=6, name=&quot;Isabella&quot;),  dict(id=10, team_id=6, name=&quot;Mason&quot;),  dict(id=11, team_id=7, name=&quot;Mia&quot;),  dict(id=12, team_id=8, name=&quot;Ethan&quot;),  dict(id=13, team_id=8, name=&quot;Amelia&quot;),  dict(id=14, team_id=9, name=&quot;Oliver&quot;),  dict(id=15, team_id=9, name=&quot;Charlotte&quot;),  dict(id=16, team_id=10, name=&quot;Jacob&quot;),  dict(id=17, team_id=10, name=&quot;Abigail&quot;),  dict(id=18, team_id=10, name=&quot;Daniel&quot;),  dict(id=19, team_id=10, name=&quot;Emily&quot;),  dict(id=20, team_id=10, name=&quot;Ella&quot;)]# 2. define dataloaderasync def teams_batch_load_fn(department_ids):    &quot;&quot;&quot; return teams grouped by department_id &quot;&quot;&quot;    return build_list(teams, department_ids, lambda t: t['department_id'])async def members_batch_load_fn(team_ids):    &quot;&quot;&quot; return members grouped by team_id &quot;&quot;&quot;    return build_list(members, team_ids, lambda t: t['team_id'])# 3. define pydantic typesclass Member(BaseModel):    id: int    name: strclass Team(BaseModel):    id: int    name: str    members: List[Member] = []    def resolve_members(self, loader=LoaderDepend(members_batch_load_fn)):        return loader.load(self.id)class Department(BaseModel):    id: int    name: str    teams: List[Team] = []    def resolve_teams(self, loader=LoaderDepend(teams_batch_load_fn)):        return loader.load(self.id)class Result(BaseModel):    departments: List[Department] = []    def resolve_departments(self):        return departmentsasync def main():    result = Result()    # 4. resolve    data = await Resolver().resolve(result)    print(json.dumps(data.dict(), indent=4))asyncio.run(main())```then we got:```json{  &quot;departments&quot;: [    {      &quot;id&quot;: 1,      &quot;name&quot;: &quot;INFRA&quot;,      &quot;teams&quot;: [        {          &quot;id&quot;: 1,          &quot;name&quot;: &quot;K8S&quot;,          &quot;members&quot;: [            {              &quot;id&quot;: 1,              &quot;name&quot;: &quot;Sophia&quot;            },            {              &quot;id&quot;: 2,              &quot;name&quot;: &quot;Jackson&quot;            }          ]        },        {          &quot;id&quot;: 2,          &quot;name&quot;: &quot;MONITORING&quot;,          &quot;members&quot;: [            {              &quot;id&quot;: 3,              &quot;name&quot;: &quot;Olivia&quot;            },            {              &quot;id&quot;: 4,              &quot;name&quot;: &quot;Liam&quot;            }          ]        },        {          &quot;id&quot;: 3,          &quot;name&quot;: &quot;Jenkins&quot;,          &quot;members&quot;: [            {              &quot;id&quot;: 5,              &quot;name&quot;: &quot;Emma&quot;            }          ]        }      ]    },    {      &quot;id&quot;: 2,      &quot;name&quot;: &quot;DevOps&quot;,      &quot;teams&quot;: [        {          &quot;id&quot;: 5,          &quot;name&quot;: &quot;Frontend&quot;,          &quot;members&quot;: [            {              &quot;id&quot;: 7,              &quot;name&quot;: &quot;Ava&quot;            }          ]        },        {          &quot;id&quot;: 6,          &quot;name&quot;: &quot;Bff&quot;,          &quot;members&quot;: [            {              &quot;id&quot;: 8,              &quot;name&quot;: &quot;Lucas&quot;            },            {              &quot;id&quot;: 9,              &quot;name&quot;: &quot;Isabella&quot;            },            {              &quot;id&quot;: 10,              &quot;name&quot;: &quot;Mason&quot;            }          ]        },        {          &quot;id&quot;: 7,          &quot;name&quot;: &quot;Backend&quot;,          &quot;members&quot;: [            {              &quot;id&quot;: 11,              &quot;name&quot;: &quot;Mia&quot;            }          ]        }      ]    },    {      &quot;id&quot;: 3,      &quot;name&quot;: &quot;Sales&quot;,      &quot;teams&quot;: [        {          &quot;id&quot;: 8,          &quot;name&quot;: &quot;CAT&quot;,          &quot;members&quot;: [            {              &quot;id&quot;: 12,              &quot;name&quot;: &quot;Ethan&quot;            },            {              &quot;id&quot;: 13,              &quot;name&quot;: &quot;Amelia&quot;            }          ]        },        {          &quot;id&quot;: 9,          &quot;name&quot;: &quot;Account&quot;,          &quot;members&quot;: [            {              &quot;id&quot;: 14,              &quot;name&quot;: &quot;Oliver&quot;            },            {              &quot;id&quot;: 15,              &quot;name&quot;: &quot;Charlotte&quot;            }          ]        },        {          &quot;id&quot;: 10,          &quot;name&quot;: &quot;Operation&quot;,          &quot;members&quot;: [            {              &quot;id&quot;: 16,              &quot;name&quot;: &quot;Jacob&quot;            },            {              &quot;id&quot;: 17,              &quot;name&quot;: &quot;Abigail&quot;            },            {              &quot;id&quot;: 18,              &quot;name&quot;: &quot;Daniel&quot;            },            {              &quot;id&quot;: 19,              &quot;name&quot;: &quot;Emily&quot;            },            {              &quot;id&quot;: 20,              &quot;name&quot;: &quot;Ella&quot;            }          ]        }      ]    }  ]}```## More cases:for more cases like: - how to filter members- how to make post calculation after resolved?- and so on..please read the following demos.```shellcd examplespython -m readme_demo.0_basicpython -m readme_demo.1_filterpython -m readme_demo.2_post_methodspython -m readme_demo.3_contextpython -m readme_demo.4_loader_instancepython -m readme_demo.5_subsetpython -m readme_demo.6_mapperpython -m readme_demo.7_single```## API### Resolver(loader_filters, loader_instances, ensure_type, annotation_class, context)- loader_filters: `dict`  provide extra query filters along with loader key.  reference: [6_sqlalchemy_loaderdepend_global_filter.py](examples/6_sqlalchemy_loaderdepend_global_filter.py) L55, L59- loader_instances: `dict`  provide pre-created loader instance, with can `prime` data into loader cache.  reference: [test_20_loader_instance.py](tests/resolver/test_20_loader_instance.py), L62, L63- ensure_type: `bool`  if `True`, resolve method is restricted to be annotated.  reference: [test_13_check_wrong_type.py](tests/resolver/test_13_check_wrong_type.py)- annotation_class: `class`  if you have `from __future__ import annotation`, and pydantic raises error, use this config to update forward refs  reference: [test_25_parse_to_obj_for_pydantic_with_annotation.py](tests/resolver/test_25_parse_to_obj_for_pydantic_with_annotation.py), L39- context: `dict`  context can carry setting into each single resolver methods.  ```python  class Earth(BaseModel):      humans: List[Human] = []      def resolve_humans(self, context):          return [dict(name=f'man-{i}') for i in range(context['count'])]  earth = await Resolver(context={'count': 10}).resolve(earth)  ```### LoaderDepend(loader_fn)- loader_fn: `subclass of DataLoader or batch_load_fn`. [detail](https://github.com/syrusakbary/aiodataloader#dataloaderbatch_load_fn-options)  declare dataloader dependency, `pydantic-resolve` will take the care of lifecycle of dataloader.### build_list(rows, keys, fn), build_object(rows, keys, fn)- rows: `list`, query result- keys: `list`, batch_load_fn:keys- fn: `lambda`, define the way to get primary key  helper function to generate return value required by `batch_load_fn`. read the code for details.  reference: [test_utils.py](tests/utils/test_utils.py), L32### mapper(param)- param: `class of pydantic or dataclass, or a lambda`  `pydantic-resolve` will trigger the fn in `mapper` after inner future is resolved. it exposes an interface to change return schema even from the same dataloader.  if param is a class, it will try to automatically transform it.  reference: [test_16_mapper.py](tests/resolver/test_16_mapper.py)### ensure_subset(base_class)- base_class: `class`  it will raise exception if fields of decorated class has field not existed in `base_class`.  reference: [test_2_ensure_subset.py](tests/utils/test_2_ensure_subset.py)## Run FastAPI example```shellpoetry shellcd examplesuvicorn fastapi_demo.main:app# http://localhost:8000/docs#/default/get_tasks_tasks_get```## Unittest```shellpoetry run python -m unittest  # orpoetry run pytest  # orpoetry run tox```## Coverage```shellpoetry run coverage run -m pytestpoetry run coverage report -m```</longdescription>
</pkgmetadata>