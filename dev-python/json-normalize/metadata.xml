<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># JSON Normalize![PyPI](https://img.shields.io/pypi/v/json_normalize)![PyPI - License](https://img.shields.io/pypi/l/json_normalize)![PyPI - Python Version](https://img.shields.io/pypi/pyversions/json_normalize)![PyPI - Status](https://img.shields.io/pypi/status/json_normalize)This package contains a function, json_normalize. It will take a json-like structure and convert it to a map object which returns dicts. Output dicts will have their path joined by &quot;.&quot;, this can of course be customized.Data association will flows up and down inside dicts although in iterables, e.g. lists, data## json_normalize.json_normalize```pythonjson_normalize.json_normalize(    tree: Union[dict, Iterable],    combine_lists: Literal[&quot;chain&quot;, &quot;product&quot;] = None,    drop_nodes: Iterable[str] = (),    freeze_nodes: Iterable[str] = (),    key_joiner: Union[str, Callable] = &quot;.&quot;,)```- *`tree`* - A json like structure. Any iterable inside the object that is not a dict or a string will be treated as a list.- *`combine_lists`*`=None` - If there are two different branches in the json like object the function will have to know how to combine these. If the default `None` is used the function does not know how to handle them and will raise an error. However if `combine_lists=&quot;chain&quot;` simply put them after eachother similar to `itertool.chain`. The other option would be `combine_lists=&quot;product&quot;` this will use the `itertool.product` to combine the different branches.- *`drop_nodes`*`=()` - This makes it possible to ignore nodes with certain names- *`freeze_nodes`*`=()` - This makes it possible to preserve nodes with certain names, the function will not recursivly keep normalizing anything below this node. If this node contains a dict it will be a dict in the end as well.- *`key_joiner`*`=&quot;.&quot;` - If you want to customize the path. `key_joiner` takes either a function or a string as input. If it is a function, it will recieve the path to a certain node in to form of a tuple. If `key_joiner` is a string it will be converted to a function as this: `lambda p: key_joiner.join(p)`## ExamplesA General use case:```python&gt;&gt;&gt; from json_normalize import json_normalize&gt;&gt;&gt; json_like = {...     &quot;city&quot;: &quot;Stockholm&quot;,...     &quot;coords&quot;: {...         &quot;lat&quot;: 59.331924,...         &quot;long&quot;: 18.062297...     },...     &quot;measurements&quot;: [...         {...             &quot;time&quot;: 1624363200,...             &quot;temp&quot;: {&quot;val&quot;: 28, &quot;unit&quot;: &quot;C&quot;},...             &quot;wind&quot;: {&quot;val&quot;: 2.8, &quot;dir&quot;: 290, &quot;unit&quot;: &quot;m/s&quot;},...         },...         {...             &quot;time&quot;: 1624366800,...             &quot;temp&quot;: {&quot;val&quot;: 26, &quot;unit&quot;: &quot;C&quot;},...         }...     ]... }&gt;&gt;&gt; normal_json = json_normalize(json_like)&gt;&gt;&gt; normal_json&lt;map object at ...&gt;&gt;&gt;&gt; list(normal_json)[    {        'city': 'Stockholm',        'coords.lat': 59.331924,        'coords.long': 18.062297,        'measurements.time': 1624363200,        'measurements.temp.val': 28,        'measurements.temp.unit': 'C',        'measurements.wind.val': 2.8,        'measurements.wind.dir': 290,        'measurements.wind.unit': 'm/s'    },    {        'city': 'Stockholm',        'coords.lat': 59.331924,        'coords.long': 18.062297,        'measurements.time': 1624366800,        'measurements.temp.val': 26,        'measurements.temp.unit': 'C'    }]```Information always flow both in and out of each container, here data in both `a` and `c` node are associated as their closest common node (the root) is a dict. linked via `b`.```python&gt;&gt;&gt; json_like = {...     &quot;a&quot;: 1,...     &quot;b&quot;: {...         &quot;c&quot;: &quot;x&quot;,...         &quot;d&quot;: 2...     }... }&gt;&gt;&gt; list(json_normalize(json_like))[    {        &quot;a&quot;: 1,        &quot;b.c&quot;: &quot;x&quot;,        &quot;b.d&quot;: 2    }]```However id the closest common node is a list like object the information is not associated with each other, e.g. the nodes `g=2` and `h=3` closest common node is a list and therefor, in the output, that data ends up in different objects.```python&gt;&gt;&gt; tree = {...     &quot;a&quot;: 1,...     &quot;b&quot;: [...         {...             &quot;c&quot;: &quot;x&quot;,...             &quot;g&quot;: 2...         },...         {...             &quot;c&quot;: &quot;y&quot;,...             &quot;h&quot;: 3...         }...     ]... }&gt;&gt;&gt; list(json_normalize(tree))[    {        &quot;a&quot;: 1,        &quot;b.c&quot;: &quot;x&quot;,        &quot;b.h&quot; 2    },    {        &quot;a&quot;: 1,        &quot;b.c&quot;: &quot;y&quot;,        &quot;b.g&quot;: 3    }]```Even if a branch contains more data in a deeper layer as long as that data is contained inside a `dict` that data will be associated with the data in other branches.```python&gt;&gt;&gt; tree = {...     &quot;a&quot;: {...         &quot;j&quot;: 1.1,...         &quot;k&quot;: 1.2...     },...     &quot;b&quot;: [...         {...             &quot;c&quot;: &quot;x&quot;,...             &quot;d&quot;: 2...         },...         {...             &quot;c&quot;: &quot;y&quot;,...             &quot;d&quot;: 3...         }...     ]... }&gt;&gt;&gt; list(json_normalize(tree))[    {        &quot;j&quot;: 1.1,        &quot;k&quot;: 1.2,        &quot;c&quot;: &quot;x&quot;,        &quot;d&quot;: 2    },    {        &quot;j&quot;: 1.1,        &quot;k&quot;: 1.2,        &quot;c&quot;: &quot;y&quot;,        &quot;d&quot;: 3    }]```When there are multiple lists in different branches the fucntion will have to know how to combine this. Default is `None` which will raise an error incase this happens. `&quot;chain&quot;` will put the information after eachother and `&quot;product&quot;` will combine the information as shown below.```python&gt;&gt;&gt; tree = {...     &quot;a&quot;: 1,...     &quot;b&quot;: [...         {&quot;x&quot;: &quot;1&quot;},...         {&quot;x&quot;: &quot;2&quot;}...     ],...     &quot;c&quot;: [...         {&quot;y&quot;: &quot;3&quot;},...         {&quot;y&quot;: &quot;4&quot;}...     ]... }&gt;&gt;&gt; list(json_normalize(tree))ValueError()&gt;&gt;&gt; list(json_normalize(tree, combine_lists=&quot;chain&quot;))[    {&quot;a&quot;: 1, &quot;b.x&quot;: &quot;1&quot;},    {&quot;a&quot;: 1, &quot;b.x&quot;: &quot;1&quot;},    {&quot;a&quot;: 1, &quot;c.y&quot;: &quot;3&quot;},    {&quot;a&quot;: 1, &quot;c.y&quot;: &quot;4&quot;},]&gt;&gt;&gt; list(json_normalize(tree, combine_lists=&quot;product&quot;))[    {&quot;a&quot;: 1, &quot;b.x&quot;: &quot;1&quot;, &quot;c.y&quot;: &quot;3&quot;},    {&quot;a&quot;: 1, &quot;b.x&quot;: &quot;1&quot;, &quot;c.y&quot;: &quot;4&quot;},    {&quot;a&quot;: 1, &quot;b.x&quot;: &quot;2&quot;, &quot;c.y&quot;: &quot;3&quot;},    {&quot;a&quot;: 1, &quot;b.x&quot;: &quot;2&quot;, &quot;c.y&quot;: &quot;4&quot;},]```If you want to make sure you do not copy information into to many branches you can leave the `combine_lists=None` and instead drop problematic nodes with the argument `drop_nodes=(&quot;b&quot;,)`.```python&gt;&gt;&gt; tree = {...     &quot;a&quot;: 1,...     &quot;b&quot;: [...         {&quot;x&quot;: &quot;1&quot;},...         {&quot;x&quot;: &quot;2&quot;}...     ],...     &quot;c&quot;: [...         {&quot;y&quot;: &quot;1&quot;},...         {&quot;y&quot;: &quot;2&quot;}...     ]... }&gt;&gt;&gt; list(json_normalize(tree, drop_nodes=(&quot;b&quot;,)))[    {&quot;a&quot;: 1, &quot;c.y&quot;: &quot;1&quot;},    {&quot;a&quot;: 1, &quot;c.y&quot;: &quot;2&quot;},]```If you wish to customize the path generated you can to that by giving the key_joiner argument.```python&gt;&gt;&gt; tree = {...     &quot;a&quot;: 1,...     &quot;b&quot;: [...         {&quot;x&quot;: &quot;1&quot;},...         {&quot;x&quot;: &quot;2&quot;}...     ],... }&gt;&gt;&gt; def key_joiner(path: tuple) -&gt; string:...     return path[-1]&gt;&gt;&gt; list(json_normalize(tree, key_joiner=key_joiner))[    {&quot;a&quot;: 1, &quot;x&quot;: &quot;1&quot;},    {&quot;a&quot;: 1, &quot;x&quot;: &quot;2&quot;},]&gt;&gt;&gt; list(json_normalize(tree, key_joiner=&quot; -&gt; &quot;))[    {&quot;a&quot;: 1, &quot;b -&gt; x&quot;: &quot;1&quot;},    {&quot;a&quot;: 1, &quot;b -&gt; x&quot;: &quot;2&quot;},]```The function will also accept generators and simlar objects.```python&gt;&gt;&gt; from itertools import chain&gt;&gt;&gt; def meta_generator():...     yield {&quot;who&quot;: &quot;generator&quot;, &quot;val&quot;: a_generator(1)}...     yield {&quot;who&quot;: &quot;range&quot;, &quot;val&quot;: range(10, 12)}...     yield {&quot;who&quot;: &quot;map&quot;, &quot;val&quot;: map(lambda x: x**2, range(20, 22))}...     yield {&quot;who&quot;: &quot;chain&quot;, &quot;val&quot;: chain([30], [31])}&gt;&gt;&gt; def a_generator(n):...     yield n...     yield 2 * n&gt;&gt;&gt; list(json_normalize(meta_generator())):[    {'who': 'generator', 'val': 1},    {'who': 'generator', 'val': 2},    {'who': 'range', 'val': 10},    {'who': 'range', 'val': 11},    {'who': 'map', 'val': 400},    {'who': 'map', 'val': 441},    {'who': 'chain', 'val': 30},    {'who': 'chain', 'val': 31},]```</longdescription>
</pkgmetadata>