<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)# commlib-pyBroker-based communication framework written in python 3.Implements the most common communication patterns (RPC/ReqResp, PubSub) over a message broker.A message broker is a communication middleware responsible for routing messages to theproper endpoints. Some examples of message brokers are: AMQP brokers (e.g. RabbitMQ),Apache Kafka, MQTT brokers (e.g. Mosquito and EMQX) and Redis.Yes, Redis can also be used as a message broker for RPC and PubSub communication!!Currently, AMQP, Redis and MQTT brokers are supported.The goal of this project is to implement a standard communication middlewarebased on message brokers, for building systems. A system can be a device, an IoT environment or a software platformm. Performance is also consideredas it is often used on low-cost devices, so messaging has to be fast and withlow footprint.# Installation```bashpython setup.py install```, or via pip```bashpip install .```, or by giving the git repo url to pip```bashpip install git+https://github.com/robotics-4-all/commlib-py.git@master```In order to keep minimal footprint of the implementation, the backendcommunication transports (AMQP, MQTT, Redis etc) are not installed by default.## Redis SupportIn order to have access to the Redis transport you will have to install the`redis` python package```bashpip install redis```However, there’s also a C library, Hiredis, that contains a fast parser that can offer significant speedups for some Redis commands such as LRANGE. You can think of Hiredis as an optional accelerator for Redis commands.It is highly recommended to also install hiredis.```pip install hiredis```## AMQP SupportIn order to have access to the AMQP transport you will have to installed the following dependencies:```bashpip install &quot;pika&quot;```## MQTT SupportIn order to have access to the MQTT transport you will have to installed the following dependencies:```bashpip install paho-mqtt```## JSON SerializationIt is recommended to use a fast json library, such as [orjson](https://github.com/ijl/orjson) or [ujson](https://github.com/ultrajson/ultrajson).The framework will load and use the most performance optimal library basedon installations.# Guide## NodeA **Node** is a software component that follows the Component-Port-Connector model.It has input and output ports for communicating with the world. Eachport defines an endpoint and can be of the following types.```         +-----------------+         |                 |InPort  +-+     Node      +-+ OutPort        +-+               +-+         |                 |         +-----------------+``````                        +--------+                         +----------+ OutPort    |        |      InPort +----------+|         +-+ --------&gt; |        | ---------&gt; +-+         ||         +-+           |        |            +-+         || Node A   |            | Broker |             |   Node B ||         +-+ &lt;-------- |        | &lt;--------- +-+         ||         +-+           |        |            +-+         |+----------+ InPort     |        |     OutPort +----------+                        +--------+```**Input Port**:  - Subscriber  - RPC Service  - Action Service**Output Port**:  - Publisher  - RPC Client  - Action Client**InOut Port**:  - RPCBridge: Bridge RPC Communication between two brokers. Directional.  - TopicBridge: Bridge PubSub Communication between two brokers. Directional.  - PTopicBridge: Bridge PubSub Communication between two brokers, based on a topic pattern. Directional.Furthermore, it implements several features:- Publish Heartbeat messages in the background for as long as the node is active- Provide control interfaces, to `start` and `stop` the execution of the Node- Provides methods to create endpoints and bind to Node ports.```pythonfrom commlib.node import Node, TransportTypefrom commlib.msg import RPCMessage## Import the Redis transports## Imports are lazy handled internallyfrom commlib.transports.redis import ConnectionParametersclass AddTwoIntMessage(RPCMessage):    class Request(RPCMessage.Request):        a: int = 0        b: int = 0    class Response(RPCMessage.Response):        c: int = 0def on_request(msg):    print(f'On-Request: {msg}')    resp = AddTwoIntMessage.Response(c = msg.a + msg.b)    return respif __name__ == '__main__':    conn_params = ConnectionParameters()    node = Node(node_name='add_two_ints_node',                connection_params=conn_params,                # heartbeat_uri='nodes.add_two_ints.heartbeat',                debug=True)    rpc = node.create_rpc(msg_type=AddTwoIntMessage,                          # rpc_name='add_two_ints_node.add_two_ints',                          on_request=add_two_int_handler)    node.run_forever(sleep_rate=1)```A Node always binds to a specific broker for implementing the input andoutput ports. Of course you can instantiate and run several Nodes in a single-process application.**Node class:**```pythonclass Node:    def __init__(self,                 node_name: Optional[str] = '',                 connection_params: Optional[Any] = None,                 transport_connection_params: Optional[Any] = None,                 debug: Optional[bool] = False,                 heartbeats: Optional[bool] = True,                 heartbeat_uri: Optional[str] = None,                 compression: CompressionType = CompressionType.NO_COMPRESSION,                 ctrl_services: Optional[bool] = False):```Node methods to create and run Endpoints::```▾+Node : class   +create_action(self, *args, **kwargs) : member   +create_action_client(self, *args, **kwargs) : member   +create_event_emitter(self, *args, **kwargs) : member   +create_heartbeat_thread(self) : member   +create_mpublisher(self, *args, **kwargs) : member   +create_psubscriber(self, *args, **kwargs) : member   +create_publisher(self, *args, **kwargs) : member   +create_rpc(self, *args, **kwargs) : member   +create_rpc_client(self, *args, **kwargs) : member   +create_start_service(self, uri: str = None) : member   +create_stop_service(self, uri: str = None) : member   +create_subscriber(self, *args, **kwargs) : member   +run(self) : member   +run_forever(self, sleep_rate: float = 0.001) : member   +stop(self) : member```## Endpoint (Low-level API)It is possible to construct endpoints without binding them to a specificNode. This is a feature to support a wider range of applications, where theconcept Node might not be usable.One can create endpoint instances by using the following classes of eachsupported transport- RPCClient- RPCServer- Publisher- Subscriber- MPublisher (Multi-topic Publisher)- PSubscriber (Pattern-based Subscriber)- ActionService (Preemptable Services with feedback)- ActionClient```pythonfrom commlib.transports.redis import RPCServicefrom commlib.transports.amqp import Subscriberfrom commlib.transports.mqtt import Publisher, RPCClient...```Or use the `endpoint_factory` to construct endpoints.```pythonimport timefrom commlib.endpoints import endpoint_factory, EndpointType, TransportTypedef callback(data):    print(data)if __name__ == '__main__':    topic = 'factory_test_topic'    mqtt_sub = endpoint_factory(EndpointType.Subscriber, TransportType.MQTT)(        topic=topic,        on_message=callback    )    mqtt_sub.run()    mqtt_pub = endpoint_factory(EndpointType.Publisher, TransportType.MQTT)(        topic=topic,        debug=True    )    data = {'a': 1, 'b': 2}    while True:        mqtt_pub.publish(data)        time.sleep(1)```## Req/Resp (RPC) Communication```                             +---------------+                   +--------&gt;+   RPC Topic   +------++--------------+   |         |               |      |        +---------------+|              +---+         +---------------+      +-------&gt;+               ||  RPC Client  |                                             |  RPC Service  ||              +&lt;--+         +---------------+      +--------+               |+--------------+   |         |Temporaty Topic|      |        +---------------+                   +---------+               +&lt;-----+                             +---------------+```### Server Side Example```pythonfrom commlib.msg import RPCMessagefrom commlib.node import Nodefrom commlib.transports.mqtt import ConnectionParametersclass AddTwoIntMessage(RPCMessage):    class Request(RPCMessage.Request):        a: int = 0        b: int = 0    class Response(RPCMessage.Response):        c: int = 0def add_two_int_handler(msg):    print(f'Request Message: {msg.__dict__}')    resp = AddTwoIntMessage.Response(c = msg.a + msg.b)    return respif __name__ == '__main__':    conn_params = ConnectionParameters()    node = Node(node_name='add_two_ints_node',                connection_params=conn_params,                # heartbeat_uri='nodes.add_two_ints.heartbeat',                debug=True)    rpc = node.create_rpc(msg_type=AddTwoIntMessage,                          rpc_name='add_two_ints_node.add_two_ints',                          on_request=add_two_int_handler)    node.run_forever(sleep_rate=1)```### Client Side Example```pythonimport timefrom commlib.msg import RPCMessagefrom commlib.node import Nodefrom commlib.transports.mqtt import ConnectionParametersclass AddTwoIntMessage(RPCMessage):    class Request(RPCMessage.Request):        a: int = 0        b: int = 0    class Response(RPCMessage.Response):        c: int = 0if __name__ == '__main__':    conn_params = ConnectionParameters()    node = Node(node_name='myclient',                connection_params=conn_params,                # heartbeat_uri='nodes.add_two_ints.heartbeat',                debug=True)    rpc = node.create_rpc_client(msg_type=AddTwoIntMessage,                                 rpc_name='add_two_ints_node.add_two_ints')    node.run()    # Create an instance of the request object    msg = AddTwoIntMessage.Request()    while True:        # returns AddTwoIntMessage.Response instance        resp = rpc.call(msg)        print(resp)        msg.a += 1        msg.b += 1        time.sleep(1)```## PubSub CommunicatonTraditional Topic-based Publish-Subscribe pattern for asynchronous communication as depicted below.```                                                    +------------+                                                    |            |                                            +------&gt;+ Subscriber |                                            |       |            |                                            |       +------------+                                            |+-----------+             +------------+    |       +------------+|           |             |            |    |       |            || Publisher +------------&gt;+   Topic    +-----------&gt;+ Subscriber ||           |             |            |    |       |            |+-----------+             +------------+    |       +------------+                                            |                                            |       +------------+                                            |       |            |                                            +------&gt;+ Subscriber |                                                    |            |                                                    +------------+```An example of using PubSub communication is located at [examples/simple_pubsub](https://github.com/robotics-4-all/commlib-py/tree/docs/examples/simple_pubsub).### Write a Simple Topic Publisher```pythonfrom commlib.msg import MessageHeader, PubSubMessagefrom commlib.node import Nodefrom commlib.transports.mqtt import ConnectionParametersclass SonarMessage(PubSubMessage):    header: MessageHeader = MessageHeader()    range: float = -1    hfov: float = 30.6    vfov: float = 14.2class SonarMessage(PubSubMessage):    distance: float = 0.001    horizontal_fov: float = 30.0    vertical_fov: float = 14.0if __name__ == &quot;__main__&quot;:    conn_params = ConnectionParameters(host='localhost', port=1883)    node = Node(node_name='sensors.sonar.front',                connection_params=conn_params,                # heartbeat_uri='nodes.add_two_ints.heartbeat',                debug=True)    pub = node.create_publisher(msg_type=SonarMessage,                                topic='sensors.sonar.front')    node.run()    msg = SonarMessage()    while True:        pub.publish(msg)        msg.range += 1        time.sleep(1)```### Write a Simple Topic Subscriber```python#!/usr/bin/env pythonimport timefrom commlib.msg import MessageHeader, PubSubMessagefrom commlib.node import Nodefrom commlib.transports.mqtt import ConnectionParametersclass SonarMessage(PubSubMessage):    header: MessageHeader = MessageHeader()    range: float = -1    hfov: float = 30.6    vfov: float = 14.2def on_message(msg):    print(f'Received front sonar data: {msg}')if __name__ == '__main__':    conn_params = ConnectionParameters()    node = Node(node_name='obstacle_avoidance_node',                connection_params=conn_params,                # heartbeat_uri='nodes.add_two_ints.heartbeat',                debug=True)    node.create_subscriber(msg_type=SonarMessage,                           topic='sensors.sonar.front',                           on_message=on_message)    node.run_forever(sleep_rate=1)```## Pattern-based Topic SubscriptionFor pattern-based topic subscription one can also use the `PSubscriber` class directly.For multi-topic publisher one can also use the `MPublisher` class directly.```                                +---------+        +---------------------&gt; | Topic A |        |                       +---------+        |                                          |                                  +---------------+                          |               |               +---------+|  MPublisher   |--------------&gt;| Topic B ||               |               +---------++---------------+                                  |                                          |                                          |                       +---------+        +---------------------&gt; | Topic C |                                +---------+``````python#!/usr/bin/env python### Pattern-based Subscriber##from commlib.node import Nodefrom commlib.transports.mqtt import ConnectionParametersdef on_message(msg, topic):    print(f'Message at topic &lt;{topic}&gt;: {msg}')if __name__ == '__main__':    conn_params = ConnectionParameters()    node = Node(node_name='example5_listener',                connection_params=conn_params,                debug=True)    node.create_psubscriber(topic='topic.*', on_message=on_message)    node.run_forever()``````python#!/usr/bin/env python### Multi-Topic Puiblisher##from commlib.node import Nodefrom commlib.transports.mqtt import ConnectionParametersdef on_message(msg, topic):    print(f'Message at topic &lt;{topic}&gt;: {msg}')if __name__ == '__main__':    conn_params = ConnectionParameters()    node = Node(node_name='example5_publisher',                connection_params=conn_params,                debug=True)    pub = node.create_mpublisher()    node.run()    topicA = 'topic.a'    topicB = 'topic.b'    while True:        pub.publish({'a': 1}, topicA)        pub.publish({'b': 1}, topicB)        time.sleep(1)```## Pythonic implementation of Subscribers and RPCs using decorators```pythonfrom commlib.msg import MessageHeader, PubSubMessage, RPCMessagefrom commlib.node import Node, TransportTypefrom commlib.transports.redis import ConnectionParametersclass SonarMessage(PubSubMessage):    header: MessageHeader = MessageHeader()    range: float = -1    hfov: float = 30.6    vfov: float = 14.2class AddTwoIntMessage(RPCMessage):    class Request(RPCMessage.Request):        a: int = 0        b: int = 0    class Response(RPCMessage.Response):        c: int = 0conn_params = ConnectionParameters()node = Node(node_name='obstacle_avoidance_node',            connection_params=conn_params,            debug=True)@node.subscribe('sensors.sonar.front', SonarMessage)def on_message(msg):    print(f'Received front sonar data: {msg}')@node.rpc('add_two_ints_node.add_two_ints', AddTwoIntMessage)def add_two_int_handler(msg):    print(f'Request Message: {msg.__dict__}')    resp = AddTwoIntMessage.Response(c = msg.a + msg.b)    return respnode.run_forever(sleep_rate=0.01)```## Preemptable Services with Feedback (Actions)Actions are [pre-emptable services](https://en.wikipedia.org/wiki/Preemption_(computing)) with support for asynchronous feedback publishing. This communication patternis used to implement services which can be stopped and can provide feedback data, such as the move command service of a robot.### Write an Action Service```pythonimport timefrom commlib.action import GoalStatusfrom commlib.msg import ActionMessagefrom commlib.transports.redis import ConnectionParameters)class ExampleAction(ActionMessage):    class Goal(ActionMessage.Goal):        target_cm: int = 0    class Result(ActionMessage.Result):        dest_cm: int = 0    class Feedback(ActionMessage.Feedback):        current_cm: int = 0def on_goal(goal_h):    c = 0    res = ExampleAction.Result()    while c &lt; goal_h.data.target_cm:        if goal_h.cancel_event.is_set():            break        goal_h.send_feedback(ExampleAction.Feedback(current_cm=c))        c += 1        time.sleep(1)    res.dest_cm = c    return resif __name__ == '__main__':    action_name = 'testaction'    conn_params = ConnectionParameters()    node = Node(node_name='action_service_example_node',                connection_params=conn_params,                # heartbeat_uri='nodes.add_two_ints.heartbeat',                debug=True)    node.create_action(msg_type=ExampleAction,                       action_name=action_name,                       on_goal=on_goal)    node.run_forever()```### Write an Action Client```pythonimport timefrom commlib.action import GoalStatusfrom commlib.msg import ActionMessagefrom commlib.transports.redis import ActionClient, ConnectionParametersclass ExampleAction(ActionMessage):    class Goal(ActionMessage.Goal):        target_cm: int = 0    class Result(ActionMessage.Result):        dest_cm: int = 0    class Feedback(ActionMessage.Feedback):        current_cm: int = 0def on_feedback(feedback):    print(f'ActionClient &lt;on-feedback&gt; callback: {feedback}')def on_result(result):    print(f'ActionClient &lt;on-result&gt; callback: {result}')def on_goal_reached(result):    print(f'ActionClient &lt;on-goal-reached&gt; callback: {result}')if __name__ == '__main__':    action_name = 'testaction'    conn_params = ConnectionParameters()    node = Node(node_name='action_client_example_node',                connection_params=conn_params,                # heartbeat_uri='nodes.add_two_ints.heartbeat',                debug=True)    action_client = node.create_action_client(msg_type=ExampleAction,                                              action_name=action_name,                                              on_goal_reached=on_goal_reached,                                              on_feedback=on_feedback,                                              on_result=on_result)    node.run()    goal_msg = ExampleAction.Goal(target_cm=5)    action_client.send_goal(goal_msg)    resp = action_client.get_result(wait=True)    print(f'Action Result: {resp}')    node.stop()```## Broker-to-broker (B2B) bridgesIn the context of IoT and CPS, it is a common requirement to bridge messagesbetween message brokers, based on application-specific rules. An example is to bridge analytics (preprocessed) data from the Edge to the Cloud. And what happensif the brokers use different communication protocols?```                                  {Bridge}[Producer] -------&gt; [Broker A] -------------&gt; [Broker B] ------&gt; [Consumer]                                  {Bridge}```In the context of the current work, communication bridges are implemented forPubSub and RPC communication between various message brokers. Currently, MQTT, AMQP and Redis are supported.![bridges_1](./assets/BrokerMessaging-Bridges.png)Below are examples of an MQTT Redis-to-MQTT Bridge and a Redis-to-MQTTTopic Bridge.```python#!/usr/bin/env pythonimport timeimport commlib.transports.amqp as acommimport commlib.transports.redis as rcommimport commlib.transports.mqtt as mcommfrom commlib.bridges import (    RPCBridge, RPCBridgeType, TopicBridge, TopicBridgeType)def redis_to_mqtt_rpc_bridge():    &quot;&quot;&quot;    [RPC Client] ----&gt; [Broker A] ------&gt; [Broker B] ---&gt; [RPC Service]    &quot;&quot;&quot;    bA_params = rcomm.ConnectionParameters()    bB_params = mcomm.ConnectionParameters()    bA_uri = 'ops.start_navigation'    bB_uri = 'thing.robotA.ops.start_navigation'    br = RPCBridge(RPCBridgeType.REDIS_TO_MQTT,                   from_uri=bA_uri, to_uri=bB_uri,                   from_broker_params=bA_params,                   to_broker_params=bB_params,                   debug=False)    br.run()def redis_to_mqtt_topic_bridge():    &quot;&quot;&quot;    [Producer Endpoint] ---&gt; [Broker A] ---&gt; [Broker B] ---&gt; [Consumer Endpoint]    &quot;&quot;&quot;    bA_params = rcomm.ConnectionParameters()    bB_params = mcomm.ConnectionParameters()    bA_uri = 'sonar.front'    bB_uri = 'thing.robotA.sensors.sonar.font'    br = TopicBridge(TopicBridgeType.REDIS_TO_MQTT,                     from_uri=bA_uri, to_uri=bB_uri,                     from_broker_params=bA_params,                     to_broker_params=bB_params,                     debug=False)    br.run()if __name__ == '__main__':    redis_to_mqtt_rpc_bridge()    redis_to_mqtt_topic_bridge()```A Pattern-based Topic Bridge (PTopicBridge) example is also shown below.In this example, we use static definition of messages (`SonarMessage`), alsoreferred as `typed communication`.```python#!/usr/bin/env pythonimport timefrom commlib.msg import PubSubMessagefrom commlib.bridges import PTopicBridgeimport commlib.transports.amqp as acommimport commlib.transports.redis as rcommclass SonarMessage(PubSubMessage):    distance: float = 0.001    horizontal_fov: float = 30.0    vertical_fov: float = 14.0if __name__ == '__main__':    &quot;&quot;&quot;    [Broker A] ------------&gt; [Broker B] ---&gt; [Consumer Endpoint]    &quot;&quot;&quot;    bA_uri = 'sensors.*'    bB_namespace = 'myrobot'    bA_params = rcomm.ConnectionParameters()    bB_params = mcomm.ConnectionParameters()    br = PTopicBridge(TopicBridgeType.REDIS_TO_MQTT,                      bA_uri,                      bB_namespace,                      bA_params,                      bB_params,                      msg_type=SonarMessage,                      debug=False)    br.run()```## Action bridges### TODO## TCP BridgeTCP bridge forwards tcp packages between two endpoints:```[Client] -------&gt; [TCPBridge, port=xxxx] ---------&gt; [TCP endpoint, port=xxxx]```A one-to-one connection is performed between the bridge and the endpoint. ## REST ProxyImplements a REST proxy, that enables invocation of REST services viabroker communication. The proxy uses an RPCService to run the broker endpoint andan http client for calling REST services. An RPC call is transformed into proper,REST-compliant, http request, based on the input parameters.```pythonclass RESTProxyMessage(RPCMessage):    class Request(RPCMessage.Request):        base_url: str        path: str = '/'        verb: str = 'GET'        query_params: Dict = {}        path_params: Dict = {}        body_params: Dict = {}        headers: Dict = {}    class Response(RPCMessage.Response):        data: Union[str, Dict, int]        headers: Dict[str, Any]        status_code: int = 200```Responses from the REST services are returned to clients in the form of a `RPCMessage.Response` message.## Transports### AMQP / RabbitMQRPC (request/reply) and PubSub Endpoints are supported by the protocol itself (AMQP), using dedicated exchanges.For RPC enpoints a `Direct Exchange` is used to route requests and responses,optionally using the [Direct Reply-to](https://www.rabbitmq.com/direct-reply-to.html).If the `Direct Reply-to` feature is used, then RPC endpoints must publishto the default exchange `&quot;&quot;`.To use `Direct Reply-to`, an RPC client should:- Consume from the pseudo-queue `amq.rabbitmq.reply-to` in no-ack mode.- Set the `reply-to` property in their request message to `amq.rabbitmq.reply-to`.Meta-information such as the serialization method used, is passed through the[message properties](https://www.rabbitmq.com/consumers.html#message-properties)metadata, as specified my AMQP.### RedisReq/Resp communication (RPC) is not supported out-of-the-box. To supportRPC communication over Redis, a custom layer implements the pattern for both endpoints using Redis Lists to represent queues. RPC server listens for requests froma list (LPOP / BLPOP), while an RPC client sends request messages to that list (RPUSH).In order for the client to be able to receive responses, he must listen to a temporary queue.To achieve this, the request message must include a `reply_to` property that is used by the RPCServer implementation to send the response message. Furthermore,`serialization` and `encoding` properties are defined. Finally, the headerincludes a `timestamp`, that indicates the time that the message was sent to to wire.Below is the  data model of the request message.```{  'data': {},  'header': {    'timestamp': &lt;int&gt;,    'reply_to': &lt;str&gt;,    'content_type': 'application/json',    'content_encoding': 'utf8',    'agent': 'commlib'  }}```**Note**: The **RPC Client** implementation is responsible to remove any created temporary queues!### MQTTReq/Resp communication (RPC) is not supported out-of-the-box. To supportRPC communication over MQTT, a custom layer implements the pattern for both endpoints using MQTT topics. RPC server listens for requests at a specific topic,while an RPC client listens to a temporary topic for response messages.For the server to know where to send the response, the request message must include a `reply_to` property that is used by the RPCServer implementation to send the response message. Furthermore,`serialization` and `encoding` properties are defined. Finally, the headerincludes a `timestamp`, that indicates the time that the message was sent to to wire.Below is the data model of the Request message.```json{  'data': {},  'header': {    'timestamp': &lt;int&gt;,    'reply_to': &lt;str&gt;,    'content_type': 'application/json',    'content_encoding': 'utf8',    'agent': 'commlib',  }}```# ExamplesExamples can be found at the [examples/](./examples) directory of this repository.# TestsRun tests by executing `tox` command under this repo directory:```bashmake tests```**TODO - Currently working on!!**# DocsMake docs by running:```bashmake docs```**TODO - Currently working on!!**# Contributions- [klpanagi](https://github.com/klpanagi)</longdescription>
</pkgmetadata>