<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>### asyncwhois[![PyPI version](https://badge.fury.io/py/asyncwhois.svg)](https://badge.fury.io/py/asyncwhois)![build-workflow](https://github.com/pogzyb/asyncwhois/actions/workflows/build-and-test.yml/badge.svg)[![codecov](https://codecov.io/gh/pogzyb/asyncwhois/branch/main/graph/badge.svg?token=Q4xtgezXGX)](https://codecov.io/gh/pogzyb/asyncwhois)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)`asyncwhois` | Python utility for querying and parsing WHOIS information for Domains, IPv4s, IPv6s, and AS numbers.#### Quickstart```pythonimport asynciofrom pprint import pprintimport asyncwhois# pick a domaindomain = 'bitcoin.org'# domain could also be a URL; asyncwhois uses tldextract to parse the URLdomain = 'https://www.google.com?q=asyncwhois'# standard callresult = asyncwhois.whois_domain(domain)# result.query_output       # The semi-free text output from the whois server# result.parser_output      # A dictionary of key:values extracted from query_output# result.tld_extract_result # tldextract result (`tldextract.tldextract.ExtractResult`)# asyncio callloop = asyncio.get_event_loop()result = loop.run_until_complete(asyncwhois.aio_whois_domain(domain))pprint(result.parser_output)&quot;&quot;&quot;{created: datetime.datetime(2008, 8, 18, 13, 19, 55), dnssec: 'unsigned', domain_name: 'bitcoin.org', expires: datetime.datetime(2029, 8, 18, 13, 19, 55), name_servers: ['dns1.registrar-servers.com', 'dns2.registrar-servers.com'], registrant_address: 'P.O. Box 0823-03411', registrant_city: 'Panama', registrant_country: 'PA', registrant_name: 'WhoisGuard Protected', registrant_organization: 'WhoisGuard, Inc.', registrant_state: 'Panama', registrant_zipcode: '', registrar: 'NAMECHEAP INC', status: ['clientTransferProhibited '          'https://icann.org/epp#clientTransferProhibited'], updated: datetime.datetime(2019, 11, 24, 13, 58, 35, 940000)} ... &quot;&quot;&quot;```#### RDAPThe `whodap` (https://github.com/pogzyb/whodap) project is used behind the scenes to perform RDAP queries.```python# RDAP domain queryresult = asyncwhois.rdap_domain('https://google.com')# Async RDAP domain queryresult = loop.run_until_complete(asyncwhois.aio_rdap_domain('https://google.com'))pprint(result.query_output)         # Raw RDAP query output as a dictionarypprint(result.parser_output)        # RDAP query output parsed/flattened into a WHOIS-like dictionaryprint(result.tld_extract_result)    # tldextract result (`tldextract.tldextract.ExtractResult`)```#### Using ProxiesSOCKS4 and SOCKS5 proxies are supported for WHOIS and RDAP queries.```pythontor_host = 'localhost'tor_port = 9050# WHOIS Queries with Proxyresult = asyncwhois.whois_domain(    'bitcoin.org', proxy_url=f&quot;socks5://{tor_host}:{tor_port}&quot;)# or with auth...tor_user = 'torpedo'tor_pw = 'torpw'result = asyncwhois.whois_ipv4(    '8.8.8.8', proxy_url=f&quot;socks5://{tor_user}:{tor_pw}@{tor_host}:{tor_port}&quot;)# RDAP Queries with Proxyimport httpx# EXTERNAL DEPENDENCY for SOCKS Proxies.from httpx_socks import SyncProxyTransport, AsyncProxyTransport transport = SyncProxyTransport.from_url(f&quot;socks5://{tor_host}:{tor_port}&quot;)client = httpx.Client(transport=transport)result = asyncwhois.rdap_ipv6('2001:4860:4860::8888', httpx_client=client)transport = AsyncProxyTransport.from_url(f&quot;socks5://{tor_user}:{tor_pw}@{tor_host}:{tor_port}&quot;)async with httpx.AsyncClient(transport=transport) as client:    result = await asyncwhois.aio_rdap_domain('bitcoin.org', httpx_client=client)```#### Exported Functions| Function      | Description || ----------- | ----------- ||  `whois_domain`          | WHOIS lookup for domain names     ||  `whois_ipv4`            | WHOIS lookup for ipv4 addresses   ||  `whois_ipv6`            | WHOIS lookup for ipv6 addresses   ||  `rdap_domain`     | RDAP lookup for domain names      ||  `rdap_ipv4`       | RDAP lookup for ipv4 addresses    ||  `rdap_ipv6`       | RDAP lookup for ipv6 addresses    ||  `rdap_asn`        | RDAP lookup for Autonomous System Numbers    ||  `aio_whois_domain`      | async counterpart to `whois_domain`      ||  `aio_whois_ipv4`        | async counterpart to `whois_ipv4`      ||  `aio_whois_ipv6`        | async counterpart to `whois_ipv6`      ||  `aio_rdap_domain` | async counterpart to `rdap_domain`      ||  `aio_rdap_ipv4`   | async counterpart to `rdap_ipv4`      ||  `aio_rdap_ipv6`   | async counterpart to `rdap_ipv6`      ||  `aio_rdap_asn`    | async counterpart to `rdap_asn`      |#### ContributionsParsed output not what you expected? Unfortunately, &quot;the format of responses [from a WHOIS server] follow a semi-free text format&quot;. Therefore,situations will arise where this module does not support parsing the output from a specific server, and you may findyourself needing more control over how parsing happens. Fortunately, you can create customized parsers to suit your needs.Example: This is a snippet of the output from running the &quot;whois google.be&quot; command.```pythonDomain:google.beStatus:NOT AVAILABLERegistered:Tue Dec 12 2000Registrant:    Not shown, please visit www.dnsbelgium.be for webbased whois.Registrar Technical Contacts:    Organisation:MarkMonitor Inc.    Language:en    Phone:+1.2083895740    Fax:+1.2083895771Registrar:    Name: MarkMonitor Inc.    Website: http://www.markmonitor.comNameservers:    ns2.google.com    ns1.google.com    ns4.google.com    ns3.google.comKeys:Flags:    clientTransferProhibited...```In this case, the &quot;name servers&quot; are listed on separate lines. The default BaseParser regexeswon't find all of these server names. In order to accommodate this extra step, the &quot;parse&quot; method wasoverwritten within the parser subclass as seen below:```pythonclass RegexBE(BaseParser):    _be_expressions = {  # the base class (BaseParser) will handle these regexes        BaseKeys.CREATED: r'Registered: *(.+)',        BaseKeys.REGISTRAR: r'Registrar:\n.+Name: *(.+)',        BaseKeys.REGISTRANT_NAME: r'Registrant:\n *(.+)'    }        def __init__(self):        super().__init__()        self.update_reg_expressions(self._be_expressions)        def parse(self, blob: str) -&gt; Dict[str, Any]:        # run base class parsing for other keys        parsed_output = super().parse(blob)        # custom parsing is needed to extract all the name servers        ns_match = re.search(r&quot;Name servers: *(.+)Keys: &quot;, blob, re.DOTALL)        if ns_match:            parsed_output[BaseKeys.NAME_SERVERS] = [m.strip() for m in ns_match.group(1).split('\n') if m.strip()]        return parsed_output```</longdescription>
</pkgmetadata>