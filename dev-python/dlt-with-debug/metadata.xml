<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;div id=&quot;top&quot;&gt;&lt;/div&gt;&lt;br /&gt;&lt;div align=&quot;center&quot;&gt;  &lt;img src=&quot;https://raw.githubusercontent.com/souvik-databricks/random_snaps/main/dlt_logo.png&quot; alt=&quot;Delta Live Table&quot; width=&quot;450&quot; height=&quot;250&quot;&gt;  &lt;h3 align=&quot;center&quot;&gt;DLT with Debug&lt;/h3&gt;  &lt;p align=&quot;center&quot;&gt;    Running DLT workflows from interactive notebooks.    &lt;br /&gt;    &lt;br /&gt;  &lt;/p&gt;&lt;/div&gt;## About The ProjectDelta Live Tables (DLTs) are a great way to design data pipelines with only focusing on the core business logic.It makes the life of data engineers easy but while the development workflows are streamlined in DLT, when it comes to __*debugging and seeing how the data looks after each transformation step*__ in a typical DLT pipeline it becomes very painful and cumbersome as we dont have the DLT package available in our interactive environment.Enter **dlt-with-debug** a lightweight decorator utility which allows developers to do interactivepipeline development by having a unified source code for both DLT run and Non-DLT interactive notebook run. &lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;### Built With- Python's builtins  - [globals()](https://docs.python.org/3/library/functions.html#globals)  - [exec()](https://docs.python.org/3/library/functions.html#exec)  - [decorator()](https://docs.python.org/3/glossary.html#term-decorator)&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;### Installationpip install in your Databricks Notebook_**PyPI**_```python%pip install dlt-with-debug```&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;### Prerequisites- [Databricks](https://databricks.com/) - [Delta Live Tables](https://databricks.com/product/delta-live-tables)&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;### Usage- *In our notebooks containing DLT Jobs the imports changes slightly as below*    ```    from dlt_with_debug import dltwithdebug, pipeline_id, showoutput        if pipeline_id:      import dlt    else:      from dlt_with_debug import dlt    ```&gt; **Note**: &gt; 1. Use the `dlt.create_table()` API instead of `dlt.table()` as `dlt.table()` sometimes gets mixed with `spark.table()` in the global namespace.&gt; 2. Always pass the `globals()` namespace to `dltwithdebug` decorator like this `@dltwithdebug(globals())`&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;---### Sample `DLT with debug` DLT pipeline example&gt; **Code**:Cmd 1```python%pip install -e git+https://github.com/souvik-databricks/dlt-with-debug.git#&quot;egg=dlt_with_debug&quot;```Cmd 2```pythonfrom pyspark.sql.functions import *from pyspark.sql.types import *# We are importing # dltwithdebug as that's the entry point to interactive DLT workflows# pipeline_id to ensure we import the dlt package based on environment# showoutput is a helper function for seeing the output result along with expectation metrics if any is specifiedfrom dlt_with_debug import dltwithdebug, pipeline_id, showoutputif pipeline_id:  import dltelse:  from dlt_with_debug import dlt```Cmd 3```pythonjson_path = &quot;/databricks-datasets/wikipedia-datasets/data-001/clickstream/raw-uncompressed-json/2015_2_clickstream.json&quot;```Cmd 4```python# Notice we are using dlt.create_table instead of dlt.table@dlt.create_table(  comment=&quot;The raw wikipedia click stream dataset, ingested from /databricks-datasets.&quot;,  table_properties={    &quot;quality&quot;: &quot;bronze&quot;  })@dltwithdebug(globals())def clickstream_raw():  return (    spark.read.option(&quot;inferSchema&quot;, &quot;true&quot;).json(json_path)  )```Cmd 5```python# for displaying the result of the transformation # use showoutput(func_name)# for example here we are using showoutput(clickstream_raw) showoutput(clickstream_raw)```![Alt Text](https://raw.githubusercontent.com/souvik-databricks/random_snaps/main/clck_raw.png)Cmd 6```python@dlt.create_table(  comment=&quot;Wikipedia clickstream dataset with cleaned-up datatypes / column names and quality expectations.&quot;,  table_properties={    &quot;quality&quot;: &quot;silver&quot;  })@dlt.expect(&quot;valid_current_page&quot;, &quot;current_page_id IS NOT NULL AND current_page_title IS NOT NULL&quot;)@dlt.expect_or_fail(&quot;valid_count&quot;, &quot;click_count &gt; 0&quot;)@dlt.expect_all({'valid_prev_page_id': &quot;previous_page_id IS NOT NULL&quot;})@dltwithdebug(globals())def clickstream_clean():  return (    dlt.read(&quot;clickstream_raw&quot;)      .withColumn(&quot;current_page_id&quot;, expr(&quot;CAST(curr_id AS INT)&quot;))      .withColumn(&quot;click_count&quot;, expr(&quot;CAST(n AS INT)&quot;))      .withColumn(&quot;previous_page_id&quot;, expr(&quot;CAST(prev_id AS INT)&quot;))      .withColumnRenamed(&quot;curr_title&quot;, &quot;current_page_title&quot;)      .withColumnRenamed(&quot;prev_title&quot;, &quot;previous_page_title&quot;)      .select(&quot;current_page_id&quot;, &quot;current_page_title&quot;, &quot;click_count&quot;, &quot;previous_page_id&quot;, &quot;previous_page_title&quot;)  )```Cmd 7```pythonshowoutput(clickstream_clean)```![Alt Text](https://raw.githubusercontent.com/souvik-databricks/random_snaps/main/clck_clean.png)---&gt; _Important to note that here you can see we are also **seeing how many records will the expectations affect**._---&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;## Same sample `DLT with debug` DLT pipeline executed as part of a delta live table![Alt Text](https://i.ibb.co/VQzZsZR/Screenshot-2022-10-18-at-5-34-14-AM.png)&gt; Below we can the expectation results also match up with the expectation metrics that we got from dltwithdebug earlier &gt; with `showoutput(clickstream_clean)`&gt; ![Expectation Results](https://raw.githubusercontent.com/souvik-databricks/random_snaps/main/expectations.png)&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;## Quick API guide#### Table syntax```python@dlt.create_table(   # &lt;-- Notice we are using the dlt.create_table() instead of dlt.table()  name=&quot;&lt;name&gt;&quot;,  comment=&quot;&lt;comment&gt;&quot;,  spark_conf={&quot;&lt;key&gt;&quot; : &quot;&lt;value&quot;, &quot;&lt;key&quot; : &quot;&lt;value&gt;&quot;},  table_properties={&quot;&lt;key&gt;&quot; : &quot;&lt;value&gt;&quot;, &quot;&lt;key&gt;&quot; : &quot;&lt;value&gt;&quot;},  path=&quot;&lt;storage-location-path&gt;&quot;,  partition_cols=[&quot;&lt;partition-column&gt;&quot;, &quot;&lt;partition-column&gt;&quot;],  schema=&quot;schema-definition&quot;,  temporary=False)@dlt.expect@dlt.expect_or_fail@dlt.expect_or_drop@dlt.expect_all@dlt.expect_all_or_drop@dlt.expect_all_or_fail@dltwithdebug(globals())    # &lt;-- This dltwithdebug(globals()) needs to be addeddef &lt;function-name&gt;():    return (&lt;query&gt;)```#### View syntax```python@dlt.create_view(    # &lt;-- Notice we are using the dlt.create_view() instead of dlt.view()  name=&quot;&lt;name&gt;&quot;,  comment=&quot;&lt;comment&gt;&quot;)@dlt.expect@dlt.expect_or_fail@dlt.expect_or_drop@dlt.expect_all@dlt.expect_all_or_drop@dlt.expect_all_or_fail@dltwithdebug(globals())    # &lt;-- This dltwithdebug(globals()) needs to be addeddef &lt;function-name&gt;():    return (&lt;query&gt;)```#### Getting results syntax```pythonshowoutput(function_name)  # &lt;-- showoutput(function_name)                            # Notice we are only passing the function name                           # The name of the function which is wrapped by the dltdecorators                                                      # For example:                           # @dlt.create_table()                           # @dltwithdebug(globals())                           # def step_one():                           #    return spark.read.csv()                           # showoutput(step_one)```#### Import syntax```python# We are importing # dltwithdebug as that's the entry point to interactive DLT workflows# pipeline_id to ensure we import the dlt package based on environment# showoutput is a helper function for seeing the output result along with expectation metrics if any is specifiedfrom dlt_with_debug import dltwithdebug, pipeline_id, showoutputif pipeline_id:  import dltelse:  from dlt_with_debug import dlt```&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;## Upcoming functionalityAs of now the following DLT APIs are covered for interactive use:1. **Currently Available:**   - `dlt.read`   - `dlt.read_stream`   - `dlt.create_table`   - `dlt.create_view`   - `dlt.table` &lt;-- This one sometimes gets overridden with `spark.table`   - `dlt.view`    - `dlt.expect`   - `dlt.expect_or_fail`   - `dlt.expect_or_drop`   - `dlt.expect_all`   - `dlt.expect_all_or_drop`   - `dlt.expect_all_or_fail`2. **Will be covered in the upcoming release:**   - `dlt.create_target_table`   - `dlt.create_streaming_live_table`   - `dlt.apply_changes`## Limitation`DLT with Debug` is a fully python based utility and as such it doesn't supports `spark.table(&quot;LIVE.func_name&quot;)` syntax. So instead of `spark.table(&quot;LIVE.func_name&quot;)` use `dlt.read(&quot;func_name&quot;)` or `dlt.read_stream(&quot;func_name&quot;)`## LicenseDistributed under the MIT License.&lt;p align=&quot;right&quot;&gt;(&lt;a href=&quot;#top&quot;&gt;back to top&lt;/a&gt;)&lt;/p&gt;</longdescription>
</pkgmetadata>