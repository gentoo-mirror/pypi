<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Devicetree Schema ToolsThe dtschema module contains tools and schema data for Devicetreeschema validation using the[json-schema](http://json-schema.org/documentation.html) vocabulary.The tools validate Devicetree files using DT binding schema files. Thetools also validate the DT binding schema files. Schema files arewritten in a JSON compatible subset of YAML to be both human and machinereadable.## Data ModelTo understand how validation works, it is important to understand howschema data is organized and used. If you're reading this, I assumeyou're already familiar with Devicetree and the .dts file format.In this repository you will find 2 kinds of data files; *Schemas* and*Meta-Schemas*.### *Devicetree Schemas*Found under `./dtschema/schemas`*Devicetree Schemas* describe the format of devicetree data.The raw Devicetree file format is very open ended and doesn't restrict howdata is encoded.Hence, it is easy to make mistakes when writing aDevicetree. Schema files impose the constraints on what data can be putinto a Devicetree.This repository contains the 'core' schemas which consists of DTproperties defined within the DT Specification and common bindings suchas the GPIO, clock, and PHY bindings.This repository does not contain device specific bindings. Those arecurrently maintained within the Linux kernel tree alongside Devicetreefiles (.dts).When validating, the tool will load all the schema files it can find and theniterate over all the nodes of the Devicetree.For each node, the tool will determine which schema(s) are applicable and make surethe node data matches the schema constraints.Nodes failing a schema test will emit an error.Nodes that don't match any schema can emit a warning.As a developer, you would write a Devicetree schema file for each newdevice binding that you create and add it to the `./schemas` directory.Schema files also have the dual purpose of documenting a binding.When you define a new binding, you only have to create one file that containsboth the machine-verifiable data format and the documentation.Devicetree Schema files are normal YAML files using the jsonschema vocabulary.The Devicetree Schema files are simplified to make them more compact.The default for arrays in json-schema is they are variable sized. This can berestricted by defining 'minItems', 'maxItems', and 'additionalItems'. ForDeviceTree Schemas, a fixed size is desired in most cases, so these propertiesare added based on the size of 'items' list.### *Devicetree Meta-Schemas*Found in `./dtschema/meta-schemas`*Devicetree Meta-Schemas* describe the data format of Devicetree Schema files.The Meta-schemas make sure all the binding schemas are in the correct formatand the tool will emit an error if the format is incorrect. json-schemaby default is very relaxed in terms of what is allowed in schemas. Unknownkeywords are silently ignored as an example. The DT Meta-schemas are designedto limit what is allowed and catch common errors in writing schemas.As a developer you normally will not need to write metaschema files.Devicetree Meta-Schema files are normal YAML files using the jsonschema vocabulary.## UsageThere are several tools available in the *tools/* directory.`tools/dt-doc-validate`This tool takes a schema file(s) or directory of schema files and validatesthem against the DT meta-schema.Example:```dt-doc-validate -u test/schemas test/schemas/good-example.yaml````tools/dt-mk-schema`This tool takes user-provided schema file(s) plus the core schema files in thisrepo, removes everything not needed for validation, applies fix-ups to theschemas, and outputs a single file with the processed schema. This stepis optional and can be done separately to speed up subsequent validationof Devicetrees.Example:```dt-mk-schema -j test/schemas/ &gt; processed-schema.json````tools/dt-validate`This tool takes user-provided Devicetree(s) and either a schema directoryor a pre-processed schema file from `dt-mk-schema`, and then validates theDevicetree against the schema.Example:```dtc -O dtb -o device.dtb test/device.dtsdt-validate -s processed-schema.json device.dtb````tools/dt-check-compatible`This tool tests whether a list of compatible strings are found or not inthe schemas. By default, a compatible string is printed when it matchesone (or a pattern) in the schemas.Example:```dt-check-compatible -s processed-schema.json vendor,a-compatible```## InstallingThe project and its dependencies can be installed with pip:```pip3 install dtschema```or directly from git:```pip3 install git+https://github.com/devicetree-org/dt-schema.git@main```All executables will be installed. Ensure ~/.local/bin is in the PATH.For development, clone the git repository manually and run pip on local tree::```git clone https://github.com/devicetree-org/dt-schema.gitcd dt-schemapip3 install -e .```## DependenciesNote: The above installation instructions handle all of the dependenciesautomatically.This code depends on Python 3 with the pylibfdt, ruamel.yaml, rfc3987, and jsonschemalibraries. Installing pylibfdt depends on the 'swig' program.On Debian/Ubuntu, the dependencies can be installed with apt and/or pip. Therfc3987 module is not packaged, so pip must be used:```sudo apt install swigsudo apt install python3 python3-ruamel.yamlpip3 install rfc3987```### jsonschemaThis code depends on at least version 4.1.2 of the[Python jsonschema](https://github.com/Julian/jsonschema/tree/master)library for Draft 2019-09 support.The module can be installed directly from github with pip:```pip3 install git+https://github.com/Julian/jsonschema.git```</longdescription>
</pkgmetadata>