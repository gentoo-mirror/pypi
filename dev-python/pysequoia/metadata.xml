<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># PySequoia[![PyPI version](https://badge.fury.io/py/pysequoia.svg)](https://pypi.org/project/pysequoia/)[![PyPI Downloads](https://img.shields.io/pypi/dm/pysequoia.svg?label=PyPI%20downloads)](https://pypi.org/project/pysequoia/)[![status-badge](https://ci.codeberg.org/api/badges/wiktor/pysequoia/status.svg)](https://ci.codeberg.org/wiktor/pysequoia)Provides [OpenPGP][] facilities in Python through [Sequoia PGP][SQ] library. Ifyou need to work with encryption and digital signatures using IETFstandard this package is for you![OpenPGP]: https://en.wikipedia.org/wiki/Pretty_Good_Privacy#OpenPGP[SQ]: https://sequoia-pgp.org/Note: This is a work in progress. The API is **not** stable!## Building```bashset -euxo pipefailpython3 -m venv .envsource .env/bin/activatepip install maturinmaturin develop```## InstallingPySequoia can be installed through `pip`:```shpip install pysequoia```## TestingThis entire document is used for end-to-end, integration tests thatexercise package's API surface.Tests assume these keys and cards exist:```bash# generate a key with passwordgpg --batch --pinentry-mode loopback --passphrase hunter22 --quick-gen-key passwd@example.comgpg --batch --pinentry-mode loopback --passphrase hunter22 --export-secret-key passwd@example.com &gt; passwd.pgp# generate a key without passwordgpg --batch --pinentry-mode loopback --passphrase '' --quick-gen-key no-passwd@example.com future-defaultgpg --batch --pinentry-mode loopback --passphrase '' --export-secret-key no-passwd@example.com &gt; no-passwd.pgp# initialize dummy OpenPGP Cardsh /start.shecho 12345678 &gt; pin/root/.cargo/bin/opgpcard admin --card 0000:00000000 --admin-pin pin import no-passwd.pgp```## Available functionsAll examples assume these basic classes have been imported:```pythonfrom pysequoia import Cert```### encryptSigns and encrypts a string to one or more recipients:```pythonfrom pysequoia import encrypts = Cert.from_file(&quot;passwd.pgp&quot;)r = Cert.from_bytes(open(&quot;wiktor.asc&quot;, &quot;rb&quot;).read())encrypted = encrypt(signer = s.signer(&quot;hunter22&quot;), recipients = [r], content = &quot;content to encrypt&quot;)print(f&quot;Encrypted data: {encrypted}&quot;)```### decryptDecrypts data:```pythonfrom pysequoia import decryptsender = Cert.from_file(&quot;no-passwd.pgp&quot;)receiver = Cert.from_file(&quot;passwd.pgp&quot;)content = &quot;Red Green Blue&quot;encrypted = encrypt(signer = sender.signer(), recipients = [receiver], content = content)print(f&quot;Encrypted data: {encrypted}&quot;)decrypted = decrypt(decryptor = receiver.decryptor(&quot;hunter22&quot;), data = encrypted)assert content == decrypted.content;```### signSigns the data and returns armored output:```pythonfrom pysequoia import signs = Cert.from_file(&quot;signing-key.asc&quot;)signed = sign(s.signer(), &quot;data to be signed&quot;)print(f&quot;Signed data: {signed}&quot;)```### Certificates APIThe `Cert` class represents one OpenPGP certificate (commonly called a&quot;public key&quot;).This package additionally verifies the certificate using Sequoia PGP's[`StandardPolicy`][SP]. This means that certificates using weakcryptography can fail to load or present different view than the onein other OpenPGP software (e.g. if the User ID uses SHA-1 inback-signatures it may be missing from the list returned by thispackage).[SP]: https://docs.rs/sequoia-openpgp/latest/sequoia_openpgp/policy/struct.StandardPolicy.html#### generateCreates new general purpose key with given User ID:```pythonalice = Cert.generate(&quot;Alice &lt;alice@example.com&gt;&quot;)fpr = alice.fingerprintprint(f&quot;Generated cert with fingerprint {fpr}:\n{alice}&quot;)```Newly generated certificates are usable in both encryption and signingcontexts:```pythonalice = Cert.generate(&quot;Alice &lt;alice@example.com&gt;&quot;)bob = Cert.generate(&quot;Bob &lt;bob@example.com&gt;&quot;)encrypted = encrypt(signer = alice.signer(), recipients = [bob], content = &quot;content to encrypt&quot;)print(f&quot;Encrypted data: {encrypted}&quot;)```#### mergeMerges data from old certificate with new packets:```pythonold = Cert.from_file(&quot;wiktor.asc&quot;)new = Cert.from_file(&quot;wiktor-fresh.asc&quot;)merged = old.merge(new)print(f&quot;Merged, updated cert: {merged}&quot;)```#### User IDsListing existing User IDs:```pythoncert = Cert.from_file(&quot;wiktor.asc&quot;)user_id = cert.user_ids[0]assert str(user_id).startswith(&quot;Wiktor Kwapisiewicz&quot;)```Adding new User IDs:```pythoncert = Cert.generate(&quot;Alice &lt;alice@example.com&gt;&quot;)assert len(cert.user_ids) == 1;cert = cert.add_user_id(value = &quot;Alice &lt;alice@company.invalid&gt;&quot;, certifier = cert.certifier())assert len(cert.user_ids) == 2;```Revoking User IDs:```pythoncert = Cert.generate(&quot;Bob &lt;bob@example.com&gt;&quot;)cert = cert.add_user_id(value = &quot;Bob &lt;bob@company.invalid&gt;&quot;, certifier = cert.certifier())assert len(cert.user_ids) == 2;cert = cert.revoke_user_id(user_id = cert.user_ids[1], certifier = cert.certifier())print(str(cert.user_ids))assert len(cert.user_ids) == 1;```#### NotationsNotations are small pieces of data that can be attached to signatures (and, indirectly, to User IDs).The following example reads and displays [Keyoxide][KX] proof URI:[KX]: https://keyoxide.org/```pythoncert = Cert.from_file(&quot;wiktor.asc&quot;)user_id = cert.user_ids[0]notation = user_id.notations[0]assert notation.key == &quot;proof@metacode.biz&quot;;assert notation.value == &quot;dns:metacode.biz?type=TXT&quot;;```Notations can also be added:```pythonfrom pysequoia import Notationcert = Cert.from_file(&quot;signing-key.asc&quot;)# No notations initiallyassert len(cert.user_ids[0].notations) == 0;cert = cert.set_notations(cert.certifier(), [Notation(&quot;proof@metacode.biz&quot;, &quot;dns:metacode.biz&quot;)])# Has one notation nowprint(str(cert.user_ids[0].notations))assert len(cert.user_ids[0].notations) == 1;# Check the notation datanotation = cert.user_ids[0].notations[0]assert notation.key == &quot;proof@metacode.biz&quot;;assert notation.value == &quot;dns:metacode.biz&quot;;```## Certificate management### WKDFetching certificates via Web Key Directory:```pythonfrom pysequoia import WKDimport asyncioasync def fetch_and_display():    cert = await WKD.search(email = &quot;test-wkd@metacode.biz&quot;)    print(f&quot;Cert found via WKD: {cert}&quot;)    assert cert.fingerprint == &quot;5b7abe660d5c62a607fe2448716b17764e3fcaca&quot;asyncio.run(fetch_and_display())```### Key serverKey servers let people search and store OpenPGP certificates.#### HKPS[HKPS][HKP] is a popular protocol implemented by most key servers.[HKP]: https://datatracker.ietf.org/doc/html/draft-shaw-openpgp-hkp-00Fetching certificates via HKPS protocol:```pythonfrom pysequoia import KeyServerimport asyncioasync def fetch_and_display():    ks = KeyServer(&quot;hkps://keyserver.ubuntu.com&quot;)    cert = await ks.get(&quot;653909a2f0e37c106f5faf546c8857e0d8e8f074&quot;)    print(f&quot;Cert found via HKPS: {cert}&quot;)    assert cert.fingerprint == &quot;653909a2f0e37c106f5faf546c8857e0d8e8f074&quot;asyncio.run(fetch_and_display())```Keys can also be uploaded:```pythonfrom pysequoia import KeyServerimport asyncioasync def upload_key(cert):    ks = KeyServer(&quot;hkps://keyserver.ubuntu.com&quot;)    await ks.put(cert)    print(&quot;Cert uploaded successfully&quot;)asyncio.run(upload_key(Cert.from_file(&quot;wiktor.asc&quot;)))```#### VKS[Verifying Key Server protocol][VKS] is a custom protocol usedcurrently by keys.openpgp.org key server. Keys retrieved via thisprotocol will contain only User IDs that have been verified (viae-mail) by the server operator.[VKS]: https://keys.openpgp.org/about/api```pythonfrom pysequoia import KeyServerimport asyncioasync def fetch_and_display():    ks = KeyServer(&quot;vks://keys.openpgp.org&quot;)    cert = await ks.get(&quot;653909a2f0e37c106f5faf546c8857e0d8e8f074&quot;)    print(f&quot;Cert found via HKPS: {cert}&quot;)    assert cert.fingerprint == &quot;653909a2f0e37c106f5faf546c8857e0d8e8f074&quot;asyncio.run(fetch_and_display())```Keys can also be uploaded:```pythonfrom pysequoia import KeyServerimport asyncioasync def upload_key(cert):    ks = KeyServer(&quot;vks://keys.openpgp.org&quot;)    await ks.put(cert)    print(&quot;Cert uploaded successfully&quot;)asyncio.run(upload_key(Cert.from_file(&quot;wiktor.asc&quot;)))```### CertD integrationThe library exposes [OpenPGP Certificate Directory][CERT-D]integration which allows storing and retrieving OpenPGP certificatesin a persistent way directly in the file system.Note that this will *not* allow you to read GnuPG-specific keydirectories. Cert-D [does not allow certificate removal][NO-REMOV].[CERT-D]: https://sequoia-pgp.gitlab.io/pgp-cert-d/[NO-REMOV]: https://gitlab.com/sequoia-pgp/pgp-cert-d/-/issues/33```pythonfrom pysequoia import Storecert = Cert.from_file(&quot;wiktor.asc&quot;)s = Store(&quot;/tmp/store&quot;)s.put(cert)assert s.get(cert.fingerprint) != None```The certificate is now stored in the given directory and can beretrieved later by its fingerprint:```pythons = Store(&quot;/tmp/store&quot;)assert s.get(&quot;653909a2f0e37c106f5faf546c8857e0d8e8f074&quot;) != None```## OpenPGP CardsThere's an experimental feature allowing communication with OpenPGPCards (like Yubikey or Nitrokey).```pythonfrom pysequoia import Card# enumerate all cardsall = Card.all()# open card by card identcard = Card.open(&quot;0000:00000000&quot;)print(f&quot;Card ident: {card.ident}&quot;)print(f&quot;Cardholder: {card.cardholder}&quot;)```Cards can be used for signing data:```pythonsigner = card.signer(&quot;123456&quot;)signed = sign(signer, &quot;data to be signed&quot;)print(f&quot;Signed data: {signed}&quot;)```As well as for decryption:```pythondecryptor = card.decryptor(&quot;123456&quot;)sender = Cert.from_file(&quot;passwd.pgp&quot;)receiver = Cert.from_file(&quot;no-passwd.pgp&quot;)content = &quot;Red Green Blue&quot;encrypted = encrypt(signer = sender.signer(&quot;hunter22&quot;), recipients = [receiver], content = content)print(f&quot;Encrypted data: {encrypted}&quot;)decrypted = decrypt(decryptor = decryptor, data = encrypted)assert content == decrypted.content;```Note that while this package allows using cards for signing anddecryption the provisioning process is not supported.[OpenPGP card tools][] can be used to initialize the card.[OpenPGP card tools]: https://crates.io/crates/openpgp-card-tools## LicenseThis project is licensed under [Apache License, Version 2.0][APL].[APL]: https://www.apache.org/licenses/LICENSE-2.0.html## ContributionUnless you explicitly state otherwise, any contribution intentionallysubmitted for inclusion in the package by you shall be under the termsand conditions of this license, without any additional terms orconditions.## SponsorsMy work is being supported by these generous organizations(alphabetical order):  - [nlnet.nl](https://nlnet.nl/)  - [pep.foundation](https://pep.foundation/)  - [sovereigntechfund.de](https://sovereigntechfund.de/en.html)</longdescription>
</pkgmetadata>