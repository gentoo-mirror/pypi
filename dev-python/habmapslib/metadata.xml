<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># habmapslibLibrería para el uso de [habmaps](https://github.com/alpeza/habmaps)* [GitHub](https://github.com/alpeza/habmapsgateway)* [Pypi](https://pypi.org/project/habmapslib/#description)## Quick Start__1.- Instalamos el cliente de habmaps con__Opción 1```bashpip3 install habmapslib# para el upgrade pip3 install --upgrade habmapslib```Opción 2, instalación manual```bashgit clone https://github.com/alpeza/habmapsgateway.gitcd habmapsgateway/habmapslibsudo python3 setup.py install```__2.- Envíamos información a la plataforma__```pythonfrom habmapslib import MapTracker, HabMapsMessageimport timemt = MapTracker.MapTracker(id=&quot;default-station-id&quot;, #Nombre de la estación base                           mqtt_url=&quot;localhost&quot;,    #DNS o IP del servidor MQTT                           mqtt_port=1883,          #Puerto del servidor MQTT                           user='habmaps',          #Credenciales de acceso al broker MQTT                           password='root')mt.startAlive() #Iniciamos la señal de alive que se enviará cada n minutos while True:    mt.sendHabMessage(HabMapsMessage.HabMapsMessage(        TimeStamp='2021-04-02 15:33:43', #El timestamp del hab en formato string datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)        HabId='Mi-Hab', #Nombre del hab que se esta monitorizando, vendrá de la traza q transmita el hab        HabPosition=[5, 3], #Array de [ latitud, longitud]        Signals={ #Payload de sensores clave: Nombre del sensor, valor: valor del sensor            &quot;miSensorUno&quot;: 122.4,            &quot;miSensorDos&quot;: 400.5        },        BasestationPosition=[5, 3])) #Array opcional de [ latitud, longitud] de posición de la estacion base    time.sleep(5)```## LoggingLa configuración de los logs se realiza a través de variables de entorno```bashexport HABLIB_LOGLEVEL=DEBUG #INFO,ERRORexport HABLIB_FORMAT=&quot;[%(asctime)s] p%(process)s {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s&quot;export HABLIB_LOGFILE=&quot;/tmp/hablibclient.log&quot;```## Error Handling```python    rc = mt.sendHabMessage(HabMapsMessage.HabMapsMessage(    TimeStamp='2021-04-02 15:33:43',    HabId='Mi-Hab',    HabPosition=[5, 3],    Signals={        &quot;miSensorUno&quot;: 122.4,        &quot;miSensorDos&quot;: 400.5    },    BasestationPosition=[5, 3]))if rc['isOK']:    print(&quot;El mensaje se ha enviado correctamente ... &quot;)else:    print(&quot;Ha existido algun error en la transmision ...&quot;)    print(rc['reason'])```## CLI FileParserLa librería también se puede emplear a modo de _daemon_ que va leyendode un fichero y transmitiéndolo a habmaps.```bashpython3 -m habmapslib.cli --help```1.- Configuramos el programa:```bashpython3 -m habmapslib.cli --genconffile &gt; miConfig.yaml#Editamos la configuraciónnano miConfig.yaml```2.- Lanzamos el programa```bashpython3 -m habmapslib.cli --conffile miConfig.yaml```### Configuración del CLI FileParserLa configuración se define a través de un fichero YAML.```yamlbasestation:  id: &quot;id-de-mi-estacion&quot;  appenders:    gpsappender:      file: '/Users/tests/ArchLab/habmapsgateway/demotraces/gps.appender'      regexselect: '\[.*\]\|(.*)\|(.*),(.*)\|.*\|'      mapping:        - &quot;height&quot;        - &quot;lat&quot;        - &quot;lon&quot;mqtt:  url: &quot;localhost&quot;  topic: &quot;hablistener&quot;  port: 1883  user: &quot;habmaps&quot;  password: &quot;root&quot;  alive: 60frame:  # Definición de la trama donde  # $time : Es la hora expresada en HHMMSS  # $pos : Es la posición gps del hab expresada en lat,lon  # $id  : Es el identificador del hab  format: &quot;$time|AlturaGPS|$pos|VelocidadHorizontalGPS|Temperatura|Presion|AlturaBarometrica|$id|&quot;  # Fichero donde se van insertando las trazas de LoRa  file: &quot;/Users/tests/ArchLab/habmapsgateway/demotraces/out.log&quot;  # Cada cuantos segundos se mira el fichero de envio  refresh: 1``` Nos resultarán de mayor interés las siguientes secciones:#### Appender GPSSe trata de un fichero donde el programa espera encontrar la posición GPS de laantena.```yaml  ...  appenders:    gpsappender:      file: '/Users/tests/ArchLab/habmapsgateway/demotraces/gps.appender'      regexselect: '\[.*\]\|(.*)\|(.*),(.*)\|.*\|'      mapping:        - &quot;height&quot;        - &quot;lat&quot;        - &quot;lon&quot;```En caso de no disponer de un módulo gps. Se puede dejar a blancos el campo `gpsappender.file`:```yaml  ...  gpsappender:    file: ''    regexselect: '\[.*\]\|(.*)\|(.*),(.*)\|.*\|'    mapping:      - &quot;height&quot;      - &quot;lat&quot;      - &quot;lon&quot;```El GPS appender funciona del siguiente modo:- 1.- Filtra la última línea del fichero indicado en el campo `gpsappender.file`.- 2.- Sobre esta última línea aplicará el filtro que se le haya indicado mediante la expresión  regular definida en `gpsappender.regexselect`.- 3.- Los __grupos__ que salgan de esta expresión regular los mapeará según defina el orden de la lista `gpsappender.mapping`.  En este caso el grupo 1 se corresponderá con el campo `height` mientras que el grupo 3 con `lon`.&gt; Podemos validar la expresión regular en [regex101](https://regex101.com/). La expresión regular&gt; del ejemplo se corresponde con la trama `[2021-03-28 18:49:02][INFO]|1129|42.3074,2.2111|0.1187|`&gt;&gt; Podemos emplear otras expresiones regulares, por ejemplo, esta esperaría encontrar `(.*),(.*),(.*)`&gt; la información del siguiente modo `1129,42.3074,2.2111`, `&lt;altura&gt;,&lt;latitud&gt;,&lt;longitud&gt;`#### Trama de la sondaEl programa tratará de realizar un envío a mqtt por cada línea nueva que detecte en el fichero `frame.file`.Este interpretará y mapeará  la línea a json según se le especifique en `frame.format`. Cada campo vendrá separado por el caracter `|`.Existen campos de mapeo reservados:* `$time`: Se interpreta como el _timestamp_ de la sonda especificado en forma `HHMMSS`.* `$pos` : Se interpreta como la posición gps de la sonda expresada como `lat,lon`.* `$id`: Se interpreta como el `id` de la sonda.```yaml...frame:  format: &quot;$time|AlturaGPS|$pos|VelocidadHorizontalGPS|Temperatura|Presion|AlturaBarometrica|$id|&quot;  file: &quot;/Users/tests/ArchLab/habmapsgateway/demotraces/out.log&quot;```El resto de campos se interpretarán como valores de sensor.Un ejemplo de trama de sonda para este formato es el siguiente:```185359|1127|4.3074,2.2111|0.1717|22.64|900.5943|983|HABCAT2|```### Ejecución del del CLI FileParserCLI FileParser controla y actúa del siguiente modo frente a los errores.#### Errores de ficheros1.- Si __no existen los ficheros especificados__ en la configuración en el arranque    el programa se esperará hasta que existan. Si se ha especificado un fichero de     parseo gps pero este no existe _CLI File Parser_ creará uno en blanco    y continuará seteando la posición GPS del gateway a 0. 2.- Si durante la ejecución se borrase el fichero de trazas especificado en    `frame.file` _CLI File Parser_ lanzaría una excepción y el programa fallaría    por lo que si queremos que se relance automáticamente y se quede esperando    hasta que exista el fichero debemos de lanzar el programa mediante un _script_    similar al siguiente:```bashexport HABLIB_LOGLEVEL=INFO #INFO,ERRORexport HABLIB_FORMAT=&quot;[%(asctime)s] p%(process)s {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s&quot;export HABLIB_FORMAT=&quot;%(levelname)s - %(message)s&quot; # &lt;-- Para local, con menos verboseexport HABLIB_LOGFILE=&quot;/tmp/hablibclient.log&quot;# Trap para salir del bucle mediante cntrl+c en local.trap ctrl_c INTfunction ctrl_c() {  echo &quot;Manual exited PID: &quot;$$  exit 0}while [ true ]; do    python3 -m habmapslib.cli --conffile config.yamldone```3.- Si no es capaz de parsear el fichero de trazas GPS notificará el errory seteará la posición del gateway a `lat:0, lon:0` continuando con la transmisiónde trazas.#### Errores de conexión.Si el cliente _mqtt_ no es capaz de establecer la conexión con el servidorel mensaje __se descartará__ y volverá a intentarlo con la siguiente traza que le llegue.</longdescription>
</pkgmetadata>