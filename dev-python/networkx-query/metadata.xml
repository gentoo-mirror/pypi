<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># networkx-query[![Coverage Status](https://img.shields.io/coveralls/geronimo-iia/networkx-query/master.svg)](https://coveralls.io/r/geronimo-iia/networkx-query)[![Codacy Badge](https://api.codacy.com/project/badge/Grade/fe669a02b4aa46b5b1faf619ba2bf382)](https://www.codacy.com/app/geronimo-iia/networkx-query?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=geronimo-iia/networkx-query&amp;amp;utm_campaign=Badge_Grade)[![Scrutinizer Code Quality](https://img.shields.io/scrutinizer/g/geronimo-iia/networkx-query.svg)](https://scrutinizer-ci.com/g/geronimo-iia/networkx-query/?branch=master)[![PyPI Version](https://img.shields.io/pypi/v/networkx-query.svg)](https://pypi.org/project/networkx-query)[![PyPI License](https://img.shields.io/pypi/l/networkx-query.svg)](https://pypi.org/project/networkx-query)Versions following [Semantic Versioning](https://semver.org/)## OverviewNetworkX Query ToolSee [documentation](https://geronimo-iia.github.io/networkx-query).## InstallationInstall this library directly into an activated virtual environment:```text$ pip install networkx-query```or add it to your [Poetry](https://poetry.eustace.io/) project:```text$ poetry add networkx-query```## Usage### Searching nodes```pythonimport networkx as nxfrom networkx_query import search_nodes, search_edgesg = nx.DiGraph()g.add_node(1, product=&quot;chocolate&quot;)g.add_node(2, product=&quot;milk&quot;)g.add_node(3, product=&quot;coat&quot;)g.add_edge(1, 2, action=&quot;shake&quot;)g.add_edge(3, 2, action=&quot;produce&quot;)for node_id in search_nodes(g, {&quot;==&quot;: [(&quot;product&quot;,), &quot;chocolate&quot;]}):    print(node_id)&gt;&gt; 1```### Searching edges```pythonfor edge_id in search_edges(g, {&quot;eq&quot;: [(&quot;action&quot;,), &quot;produce&quot;]}):    print(edge_id)&gt;&gt; (3, 2)```### Searching direct relation shipWith ```search_direct_relationships``` you can made a query which filter edges on their : - source node attributes - edge attributes - target node attributesWith this graph:```pythonimport networkx as nxfrom networkx_query import search_direct_relationshipsg = nx.DiGraph()for i in range(30):    g.add_node(i, data=i)for i in range(10, 30):    g.add_edge(i - 10, i, data=i)```We can filtering all edges with source node with data &lt; 3:```pythonlist(search_direct_relationships(graph=g, source={&quot;lt&quot;: [&quot;data&quot;, 3]}))[(0, 10), (1, 11), (2, 12)]```We can filtering all edges with: - source node with data &lt; 8 - edge with data &gt; 15```pythonlist(search_direct_relationships(graph=g, source={&quot;lt&quot;: [&quot;data&quot;, 8]}, edge={&quot;gt&quot;: [&quot;data&quot;, 15]}))&gt;&gt; [(6, 16), (7, 17)]```We can filtering all edges with: - source node with data &gt; 9 - edge with data &gt; 15 - target node with data &lt; 22```pythonsearch_direct_relationships(            graph=g, source={&quot;gt&quot;: [&quot;data&quot;, 9]}, edge={&quot;gt&quot;: [&quot;data&quot;, 15]}, target={'lt': [&quot;data&quot;, 22]}        )    )&gt;&gt; [(10, 20), (11, 21)]```### search_relationshipsWith :```python    g = nx.DiGraph()    g.add_node(1, product=&quot;a&quot;)    g.add_node(2, product=&quot;b&quot;)    g.add_node(3, product=&quot;c&quot;)    g.add_node(4, product=&quot;d&quot;)    g.add_edge(1, 2)    g.add_edge(1, 3, weight=2)    g.add_edge(1, 4)    g.add_edge(2, 4)    g.add_edge(3, 4)```You could find all path with multiple constraints:```python    list(search_relationships(            g,            {&quot;eq&quot;: [(&quot;product&quot;,), &quot;a&quot;]},            PathCriteria(target={&quot;eq&quot;: [(&quot;product&quot;,), &quot;b&quot;]}),            PathCriteria(target={&quot;eq&quot;: [(&quot;product&quot;,), &quot;d&quot;]}),        ))     # output: [[1, 2, 4]]     list(search_relationships(g, {&quot;eq&quot;: [(&quot;product&quot;,), &quot;a&quot;]}, PathCriteria(target={&quot;eq&quot;: [(&quot;product&quot;,), &quot;c&quot;]})))     # outptu: [[1, 3]]```or something more complex:```python    g.add_node(5, product=&quot;d&quot;)    g.add_node(6, product=&quot;d&quot;)    g.add_node(7, product=&quot;a&quot;)    g.add_node(8, product=&quot;a&quot;)    g.add_edge(7, 5, weight=2)    g.add_edge(7, 6, weight=2)    g.add_edge(8, 5, weight=2)    list(        search_relationships(            g,            {&quot;eq&quot;: [(&quot;product&quot;,), &quot;a&quot;]},  # node 1, 7, 8            PathCriteria(                target={&quot;eq&quot;: [(&quot;product&quot;,), &quot;d&quot;]}, edge={&quot;eq&quot;: [(&quot;weight&quot;,), 2]}            ),  # edge 1-3, 7-5, 7-6, 8-5  node 4, 5, 6 -&gt; no 1, 3, 4        )    )    # output: [[7, 5], [7, 6], [8, 5]]    list(        search_relationships(            g,            {&quot;eq&quot;: [(&quot;product&quot;,), &quot;a&quot;]},  # node 1, 7, 8            PathCriteria(target={}, edge={&quot;eq&quot;: [(&quot;weight&quot;,), 2]}),  # edge 1-3, 7-5, 7-6, 8-5            PathCriteria(target={&quot;eq&quot;: [(&quot;product&quot;,), &quot;d&quot;]}),  # node 4, 5, 6 -&gt; no 1, 3, 4        )    )    # output: [[1, 3, 4]]```Note the usage of `PathCriteria(target={}, ..` to define a constraint based only on edge. `{}` act as a wildcard.## APIActually, we have:- [search_edges](https://geronimo-iia.github.io/networkx-query/reference/#networkx_query.search_edges)- [search_nodes](https://geronimo-iia.github.io/networkx-query/reference/#networkx_query.search_nodes) - [search_direct_relationships](https://geronimo-iia.github.io/networkx-query/reference/#networkx_query.search_direct_relationships) - [search_relationships](https://geronimo-iia.github.io/networkx-query/reference/#networkx_query.search_relationships) All this function are based on [prepare_query](https://geronimo-iia.github.io/networkx-query/reference/#networkx_query.prepare_query) which return an Evaluator.Quickly, ```Evaluator``` are function with this signature: (context) -&gt; bool, and ```Context``` is a dictionary like structure (with in and [] methods, and support __contains__ or  (__iter__ and __getitem__))With networkX, node and edge attributes are dictionary like, so implementation of this three methods are very simple.## Query languageWe define a little json query language like [json-query-language](https://github.com/clue/json-query-language/blob/master/SYNTAX.md) against nodes or edges attributes.### ExpressionsMain expression syntax turn around this:```{    operator_name : parameters}```### Basic matching expressionTest if a node/edge has an attribute named &quot;my_property&quot;:```{    &quot;has&quot; : &quot;my_property&quot;}```Test if a node/edge has an attribute product : { &quot;definition&quot;: { &quot;name&quot;: xxx }} with xxx equals to &quot;chocolate&quot;.```{    &quot;eq&quot; : [ (&quot;product&quot;, &quot;definition&quot;, &quot;name&quot;), &quot;chocolate&quot;]}```The tuple ```(&quot;product&quot;, &quot;definition&quot;, &quot;name&quot;)``` is a path in attribut dictionnary.A Path is a single string or a tuple of string which represente a path in a tree (here a dictionary).We support this operators:| Name     | Alias | Parameters      | Description                                                                   || -------- | :---: | --------------- | ----------------------------------------------------------------------------- || has      |       | Path            | Check if path exists in context.                                              || contains |       | Path, str       | Check if an attribut path exists and contains specified value.                || eq       | `==`  | Path, Any       | Check if an attribut path exists and equals specified value.                  || neq      | `!=`  | Path, Any       | Check if an attribut path did not exists or not equals specified value.       || gt       |  `&gt;`  | Path, Any       | Check if an attribut path exists and greather that specified value.           || lt       |  `&lt;`  | Path, Any       | Check if an attribut path exists and lower that specified value.              || gte      | `&gt;=`  | Path, Any       | Check if an attribut path exists and greather or equals that specified value. || lte      | `&lt;=`  | Path, Any       | Check if an attribut path exists and lower or equals that specified value.    || in       | `:=`  | Path, List[Any] | Check if an attribut path exists and attribut value in specified values.      |### Boolean composition of matching expressionWe support this operators:| Name | Alias | Parameters    | Description    || ---- | :---: | ------------- | -------------- || and  | `&amp;&amp;`  | list of query | And operator.  || or   | \|\|  | list of query | Or operator.   || xor  |       | list of query | xor operator.  || nxor |       | list of query | nxor operator. || not  |  `!`  | query         | Not operator.  |By default, a list of expressions is equivalent of an &quot;AND&quot; of this expressions.Example:```{    'not': {        'has': ['group']    },    'has': 'application',    'eq': [('_link', 'other', 'weight'), 2]}```is equivalent to:```{    'and': [        {            'not': [                {                    'has': ['group']                }            ]        },        {            'has': ['application']        },        {            'eq': [('_link', 'other', 'weight'), 2]        }    ]}```## Wished Features- add projection expression (a return like statement)- add join relation ship </longdescription>
</pkgmetadata>