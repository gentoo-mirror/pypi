<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Responses=========.. image:: https://img.shields.io/pypi/v/responses.svg    :target: https://pypi.python.org/pypi/responses/.. image:: https://img.shields.io/pypi/pyversions/responses.svg    :target: https://pypi.org/project/responses/.. image:: https://img.shields.io/pypi/dm/responses   :target: https://pypi.python.org/pypi/responses/.. image:: https://codecov.io/gh/getsentry/responses/branch/master/graph/badge.svg    :target: https://codecov.io/gh/getsentry/responses/A utility library for mocking out the ``requests`` Python library...  note::    Responses requires Python 3.8 or newer, and requests &gt;= 2.30.0Table of Contents-----------------.. contents::Installing----------``pip install responses``Deprecations and Migration Path-------------------------------Here you will find a list of deprecated functionality and a migration path for each.Please ensure to update your code according to the guidance... list-table:: Deprecation and Migration   :widths: 50 25 50   :header-rows: 1   * - Deprecated Functionality     - Deprecated in Version     - Migration Path   * - ``responses.json_params_matcher``     - 0.14.0     - ``responses.matchers.json_params_matcher``   * - ``responses.urlencoded_params_matcher``     - 0.14.0     - ``responses.matchers.urlencoded_params_matcher``   * - ``stream`` argument in ``Response`` and ``CallbackResponse``     - 0.15.0     - Use ``stream`` argument in request directly.   * - ``match_querystring`` argument in ``Response`` and ``CallbackResponse``.     - 0.17.0     - Use ``responses.matchers.query_param_matcher`` or ``responses.matchers.query_string_matcher``   * - ``responses.assert_all_requests_are_fired``, ``responses.passthru_prefixes``, ``responses.target``     - 0.20.0     - Use ``responses.mock.assert_all_requests_are_fired``,       ``responses.mock.passthru_prefixes``, ``responses.mock.target`` instead.BETA Features-------------Below you can find a list of BETA features. Although we will try to keep the API backwards compatiblewith released version, we reserve the right to change these APIs before they are considered stable. Please share your feedback via`GitHub Issues &lt;https://github.com/getsentry/responses/issues&gt;`_.Record Responses to files^^^^^^^^^^^^^^^^^^^^^^^^^You can perform real requests to the server and ``responses`` will automatically record the output to thefile. Recorded data is stored in `YAML &lt;https://yaml.org&gt;`_ format.Apply ``@responses._recorder.record(file_path=&quot;out.yaml&quot;)`` decorator to any function where you performrequests to record responses to ``out.yaml`` file.Following code.. code-block:: python    import requests    from responses import _recorder    def another():        rsp = requests.get(&quot;https://httpstat.us/500&quot;)        rsp = requests.get(&quot;https://httpstat.us/202&quot;)    @_recorder.record(file_path=&quot;out.yaml&quot;)    def test_recorder():        rsp = requests.get(&quot;https://httpstat.us/404&quot;)        rsp = requests.get(&quot;https://httpbin.org/status/wrong&quot;)        another()will produce next output:.. code-block:: yaml    responses:    - response:        auto_calculate_content_length: false        body: 404 Not Found        content_type: text/plain        method: GET        status: 404        url: https://httpstat.us/404    - response:        auto_calculate_content_length: false        body: Invalid status code        content_type: text/plain        method: GET        status: 400        url: https://httpbin.org/status/wrong    - response:        auto_calculate_content_length: false        body: 500 Internal Server Error        content_type: text/plain        method: GET        status: 500        url: https://httpstat.us/500    - response:        auto_calculate_content_length: false        body: 202 Accepted        content_type: text/plain        method: GET        status: 202        url: https://httpstat.us/202Replay responses (populate registry) from files^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^You can populate your active registry from a ``yaml`` file with recorded responses.(See `Record Responses to files`_ to understand how to obtain a file).To do that you need to execute ``responses._add_from_file(file_path=&quot;out.yaml&quot;)`` withinan activated decorator or a context manager.The following code example registers a ``patch`` response, then all responses present in``out.yaml`` file and a ``post`` response at the end... code-block:: python    import responses    @responses.activate    def run():        responses.patch(&quot;http://httpbin.org&quot;)        responses._add_from_file(file_path=&quot;out.yaml&quot;)        responses.post(&quot;http://httpbin.org/form&quot;)    run()Basics------The core of ``responses`` comes from registering mock responses and covering test functionwith ``responses.activate`` decorator. ``responses`` provides similar interface as ``requests``.Main Interface^^^^^^^^^^^^^^* responses.add(``Response`` or ``Response args``) - allows either to register ``Response`` object or directly  provide arguments of ``Response`` object. See `Response Parameters`_.. code-block:: python    import responses    import requests    @responses.activate    def test_simple():        # Register via 'Response' object        rsp1 = responses.Response(            method=&quot;PUT&quot;,            url=&quot;http://example.com&quot;,        )        responses.add(rsp1)        # register via direct arguments        responses.add(            responses.GET,            &quot;http://twitter.com/api/1/foobar&quot;,            json={&quot;error&quot;: &quot;not found&quot;},            status=404,        )        resp = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)        resp2 = requests.put(&quot;http://example.com&quot;)        assert resp.json() == {&quot;error&quot;: &quot;not found&quot;}        assert resp.status_code == 404        assert resp2.status_code == 200        assert resp2.request.method == &quot;PUT&quot;If you attempt to fetch a url which doesn't hit a match, ``responses`` will raisea ``ConnectionError``:.. code-block:: python    import responses    import requests    from requests.exceptions import ConnectionError    @responses.activate    def test_simple():        with pytest.raises(ConnectionError):            requests.get(&quot;http://twitter.com/api/1/foobar&quot;)Shortcuts^^^^^^^^^Shortcuts provide a shorten version of ``responses.add()`` where method argument is prefilled* responses.delete(``Response args``) - register DELETE response* responses.get(``Response args``) - register GET response* responses.head(``Response args``) - register HEAD response* responses.options(``Response args``) - register OPTIONS response* responses.patch(``Response args``) - register PATCH response* responses.post(``Response args``) - register POST response* responses.put(``Response args``) - register PUT response.. code-block:: python    import responses    import requests    @responses.activate    def test_simple():        responses.get(            &quot;http://twitter.com/api/1/foobar&quot;,            json={&quot;type&quot;: &quot;get&quot;},        )        responses.post(            &quot;http://twitter.com/api/1/foobar&quot;,            json={&quot;type&quot;: &quot;post&quot;},        )        responses.patch(            &quot;http://twitter.com/api/1/foobar&quot;,            json={&quot;type&quot;: &quot;patch&quot;},        )        resp_get = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)        resp_post = requests.post(&quot;http://twitter.com/api/1/foobar&quot;)        resp_patch = requests.patch(&quot;http://twitter.com/api/1/foobar&quot;)        assert resp_get.json() == {&quot;type&quot;: &quot;get&quot;}        assert resp_post.json() == {&quot;type&quot;: &quot;post&quot;}        assert resp_patch.json() == {&quot;type&quot;: &quot;patch&quot;}Responses as a context manager^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Instead of wrapping the whole function with decorator you can use a context manager... code-block:: python    import responses    import requests    def test_my_api():        with responses.RequestsMock() as rsps:            rsps.add(                responses.GET,                &quot;http://twitter.com/api/1/foobar&quot;,                body=&quot;{}&quot;,                status=200,                content_type=&quot;application/json&quot;,            )            resp = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)            assert resp.status_code == 200        # outside the context manager requests will hit the remote server        resp = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)        resp.status_code == 404Response Parameters-------------------The following attributes can be passed to a Response mock:method (``str``)    The HTTP method (GET, POST, etc).url (``str`` or ``compiled regular expression``)    The full resource URL.match_querystring (``bool``)    DEPRECATED: Use ``responses.matchers.query_param_matcher`` or    ``responses.matchers.query_string_matcher``    Include the query string when matching requests.    Enabled by default if the response URL contains a query string,    disabled if it doesn't or the URL is a regular expression.body (``str`` or ``BufferedReader`` or ``Exception``)    The response body. Read more `Exception as Response body`_json    A Python object representing the JSON response body. Automatically configures    the appropriate Content-Type.status (``int``)    The HTTP status code.content_type (``content_type``)    Defaults to ``text/plain``.headers (``dict``)    Response headers.stream (``bool``)    DEPRECATED: use ``stream`` argument in request directlyauto_calculate_content_length (``bool``)    Disabled by default. Automatically calculates the length of a supplied string or JSON body.match (``tuple``)    An iterable (``tuple`` is recommended) of callbacks to match requests    based on request attributes.    Current module provides multiple matchers that you can use to match:    * body contents in JSON format    * body contents in URL encoded data format    * request query parameters    * request query string (similar to query parameters but takes string as input)    * kwargs provided to request e.g. ``stream``, ``verify``    * 'multipart/form-data' content and headers in request    * request headers    * request fragment identifier    Alternatively user can create custom matcher.    Read more `Matching Requests`_Exception as Response body--------------------------You can pass an ``Exception`` as the body to trigger an error on the request:.. code-block:: python    import responses    import requests    @responses.activate    def test_simple():        responses.get(&quot;http://twitter.com/api/1/foobar&quot;, body=Exception(&quot;...&quot;))        with pytest.raises(Exception):            requests.get(&quot;http://twitter.com/api/1/foobar&quot;)Matching Requests-----------------Matching Request Body Contents^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^When adding responses for endpoints that are sent request data you can addmatchers to ensure your code is sending the right parameters and providedifferent responses based on the request body contents. ``responses`` providesmatchers for JSON and URL-encoded request bodies.URL-encoded data&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;.. code-block:: python    import responses    import requests    from responses import matchers    @responses.activate    def test_calc_api():        responses.post(            url=&quot;http://calc.com/sum&quot;,            body=&quot;4&quot;,            match=[matchers.urlencoded_params_matcher({&quot;left&quot;: &quot;1&quot;, &quot;right&quot;: &quot;3&quot;})],        )        requests.post(&quot;http://calc.com/sum&quot;, data={&quot;left&quot;: 1, &quot;right&quot;: 3})JSON encoded data&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;Matching JSON encoded data can be done with ``matchers.json_params_matcher()``... code-block:: python    import responses    import requests    from responses import matchers    @responses.activate    def test_calc_api():        responses.post(            url=&quot;http://example.com/&quot;,            body=&quot;one&quot;,            match=[                matchers.json_params_matcher({&quot;page&quot;: {&quot;name&quot;: &quot;first&quot;, &quot;type&quot;: &quot;json&quot;}})            ],        )        resp = requests.request(            &quot;POST&quot;,            &quot;http://example.com/&quot;,            headers={&quot;Content-Type&quot;: &quot;application/json&quot;},            json={&quot;page&quot;: {&quot;name&quot;: &quot;first&quot;, &quot;type&quot;: &quot;json&quot;}},        )Query Parameters Matcher^^^^^^^^^^^^^^^^^^^^^^^^Query Parameters as a Dictionary&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;You can use the ``matchers.query_param_matcher`` function to matchagainst the ``params`` request parameter. Just use the same dictionary as youwill use in ``params`` argument in ``request``.Note, do not use query parameters as part of the URL. Avoid using ``match_querystring``deprecated argument... code-block:: python    import responses    import requests    from responses import matchers    @responses.activate    def test_calc_api():        url = &quot;http://example.com/test&quot;        params = {&quot;hello&quot;: &quot;world&quot;, &quot;I am&quot;: &quot;a big test&quot;}        responses.get(            url=url,            body=&quot;test&quot;,            match=[matchers.query_param_matcher(params)],        )        resp = requests.get(url, params=params)        constructed_url = r&quot;http://example.com/test?I+am=a+big+test&amp;hello=world&quot;        assert resp.url == constructed_url        assert resp.request.url == constructed_url        assert resp.request.params == paramsBy default, matcher will validate that all parameters match strictly.To validate that only parameters specified in the matcher are present in original requestuse ``strict_match=False``.Query Parameters as a String&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;As alternative, you can use query string value in ``matchers.query_string_matcher`` to matchquery parameters in your request.. code-block:: python    import requests    import responses    from responses import matchers    @responses.activate    def my_func():        responses.get(            &quot;https://httpbin.org/get&quot;,            match=[matchers.query_string_matcher(&quot;didi=pro&amp;test=1&quot;)],        )        resp = requests.get(&quot;https://httpbin.org/get&quot;, params={&quot;test&quot;: 1, &quot;didi&quot;: &quot;pro&quot;})    my_func()Request Keyword Arguments Matcher^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^To validate request arguments use the ``matchers.request_kwargs_matcher`` function to matchagainst the request kwargs.Only following arguments are supported: ``timeout``, ``verify``, ``proxies``, ``stream``, ``cert``.Note, only arguments provided to ``matchers.request_kwargs_matcher`` will be validated... code-block:: python    import responses    import requests    from responses import matchers    with responses.RequestsMock(assert_all_requests_are_fired=False) as rsps:        req_kwargs = {            &quot;stream&quot;: True,            &quot;verify&quot;: False,        }        rsps.add(            &quot;GET&quot;,            &quot;http://111.com&quot;,            match=[matchers.request_kwargs_matcher(req_kwargs)],        )        requests.get(&quot;http://111.com&quot;, stream=True)        # &gt;&gt;&gt;  Arguments don't match: {stream: True, verify: True} doesn't match {stream: True, verify: False}Request multipart/form-data Data Validation^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^To validate request body and headers for ``multipart/form-data`` data you can use``matchers.multipart_matcher``. The ``data``, and ``files`` parameters provided will be comparedto the request:.. code-block:: python    import requests    import responses    from responses.matchers import multipart_matcher    @responses.activate    def my_func():        req_data = {&quot;some&quot;: &quot;other&quot;, &quot;data&quot;: &quot;fields&quot;}        req_files = {&quot;file_name&quot;: b&quot;Old World!&quot;}        responses.post(            url=&quot;http://httpbin.org/post&quot;,            match=[multipart_matcher(req_files, data=req_data)],        )        resp = requests.post(&quot;http://httpbin.org/post&quot;, files={&quot;file_name&quot;: b&quot;New World!&quot;})    my_func()    # &gt;&gt;&gt; raises ConnectionError: multipart/form-data doesn't match. Request body differs.Request Fragment Identifier Validation^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^To validate request URL fragment identifier you can use ``matchers.fragment_identifier_matcher``.The matcher takes fragment string (everything after ``#`` sign) as input for comparison:.. code-block:: python    import requests    import responses    from responses.matchers import fragment_identifier_matcher    @responses.activate    def run():        url = &quot;http://example.com?ab=xy&amp;zed=qwe#test=1&amp;foo=bar&quot;        responses.get(            url,            match=[fragment_identifier_matcher(&quot;test=1&amp;foo=bar&quot;)],            body=b&quot;test&quot;,        )        # two requests to check reversed order of fragment identifier        resp = requests.get(&quot;http://example.com?ab=xy&amp;zed=qwe#test=1&amp;foo=bar&quot;)        resp = requests.get(&quot;http://example.com?zed=qwe&amp;ab=xy#foo=bar&amp;test=1&quot;)    run()Request Headers Validation^^^^^^^^^^^^^^^^^^^^^^^^^^When adding responses you can specify matchers to ensure that your code issending the right headers and provide different responses based on the requestheaders... code-block:: python    import responses    import requests    from responses import matchers    @responses.activate    def test_content_type():        responses.get(            url=&quot;http://example.com/&quot;,            body=&quot;hello world&quot;,            match=[matchers.header_matcher({&quot;Accept&quot;: &quot;text/plain&quot;})],        )        responses.get(            url=&quot;http://example.com/&quot;,            json={&quot;content&quot;: &quot;hello world&quot;},            match=[matchers.header_matcher({&quot;Accept&quot;: &quot;application/json&quot;})],        )        # request in reverse order to how they were added!        resp = requests.get(&quot;http://example.com/&quot;, headers={&quot;Accept&quot;: &quot;application/json&quot;})        assert resp.json() == {&quot;content&quot;: &quot;hello world&quot;}        resp = requests.get(&quot;http://example.com/&quot;, headers={&quot;Accept&quot;: &quot;text/plain&quot;})        assert resp.text == &quot;hello world&quot;Because ``requests`` will send several standard headers in addition to what wasspecified by your code, request headers that are additional to the onespassed to the matcher are ignored by default. You can change this behaviour bypassing ``strict_match=True`` to the matcher to ensure that only the headersthat you're expecting are sent and no others. Note that you will probably haveto use a ``PreparedRequest`` in your code to ensure that ``requests`` doesn'tinclude any additional headers... code-block:: python    import responses    import requests    from responses import matchers    @responses.activate    def test_content_type():        responses.get(            url=&quot;http://example.com/&quot;,            body=&quot;hello world&quot;,            match=[matchers.header_matcher({&quot;Accept&quot;: &quot;text/plain&quot;}, strict_match=True)],        )        # this will fail because requests adds its own headers        with pytest.raises(ConnectionError):            requests.get(&quot;http://example.com/&quot;, headers={&quot;Accept&quot;: &quot;text/plain&quot;})        # a prepared request where you overwrite the headers before sending will work        session = requests.Session()        prepped = session.prepare_request(            requests.Request(                method=&quot;GET&quot;,                url=&quot;http://example.com/&quot;,            )        )        prepped.headers = {&quot;Accept&quot;: &quot;text/plain&quot;}        resp = session.send(prepped)        assert resp.text == &quot;hello world&quot;Creating Custom Matcher^^^^^^^^^^^^^^^^^^^^^^^If your application requires other encodings or different data validation you can buildyour own matcher that returns ``Tuple[matches: bool, reason: str]``.Where boolean represents ``True`` or ``False`` if the request parameters match andthe string is a reason in case of match failure. Your matcher canexpect a ``PreparedRequest`` parameter to be provided by ``responses``.Note, ``PreparedRequest`` is customized and has additional attributes ``params`` and ``req_kwargs``.Response Registry---------------------------Default Registry^^^^^^^^^^^^^^^^By default, ``responses`` will search all registered ``Response`` objects andreturn a match. If only one ``Response`` is registered, the registry is kept unchanged.However, if multiple matches are found for the same request, then first match is returned andremoved from registry.Ordered Registry^^^^^^^^^^^^^^^^In some scenarios it is important to preserve the order of the requests and responses.You can use ``registries.OrderedRegistry`` to force all ``Response`` objects to be dependenton the insertion order and invocation index.In following example we add multiple ``Response`` objects that target the same URL. However,you can see, that status code will depend on the invocation order... code-block:: python    import requests    import responses    from responses.registries import OrderedRegistry    @responses.activate(registry=OrderedRegistry)    def test_invocation_index():        responses.get(            &quot;http://twitter.com/api/1/foobar&quot;,            json={&quot;msg&quot;: &quot;not found&quot;},            status=404,        )        responses.get(            &quot;http://twitter.com/api/1/foobar&quot;,            json={&quot;msg&quot;: &quot;OK&quot;},            status=200,        )        responses.get(            &quot;http://twitter.com/api/1/foobar&quot;,            json={&quot;msg&quot;: &quot;OK&quot;},            status=200,        )        responses.get(            &quot;http://twitter.com/api/1/foobar&quot;,            json={&quot;msg&quot;: &quot;not found&quot;},            status=404,        )        resp = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)        assert resp.status_code == 404        resp = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)        assert resp.status_code == 200        resp = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)        assert resp.status_code == 200        resp = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)        assert resp.status_code == 404Custom Registry^^^^^^^^^^^^^^^Built-in ``registries`` are suitable for most of use cases, but to handle special conditions, you canimplement custom registry which must follow interface of ``registries.FirstMatchRegistry``.Redefining the ``find`` method will allow you to create custom search logic and returnappropriate ``Response``Example that shows how to set custom registry.. code-block:: python    import responses    from responses import registries    class CustomRegistry(registries.FirstMatchRegistry):        pass    print(&quot;Before tests:&quot;, responses.mock.get_registry())    &quot;&quot;&quot; Before tests: &lt;responses.registries.FirstMatchRegistry object&gt; &quot;&quot;&quot;    # using function decorator    @responses.activate(registry=CustomRegistry)    def run():        print(&quot;Within test:&quot;, responses.mock.get_registry())        &quot;&quot;&quot; Within test: &lt;__main__.CustomRegistry object&gt; &quot;&quot;&quot;    run()    print(&quot;After test:&quot;, responses.mock.get_registry())    &quot;&quot;&quot; After test: &lt;responses.registries.FirstMatchRegistry object&gt; &quot;&quot;&quot;    # using context manager    with responses.RequestsMock(registry=CustomRegistry) as rsps:        print(&quot;In context manager:&quot;, rsps.get_registry())        &quot;&quot;&quot; In context manager: &lt;__main__.CustomRegistry object&gt; &quot;&quot;&quot;    print(&quot;After exit from context manager:&quot;, responses.mock.get_registry())    &quot;&quot;&quot;    After exit from context manager: &lt;responses.registries.FirstMatchRegistry object&gt;    &quot;&quot;&quot;Dynamic Responses-----------------You can utilize callbacks to provide dynamic responses. The callback must returna tuple of (``status``, ``headers``, ``body``)... code-block:: python    import json    import responses    import requests    @responses.activate    def test_calc_api():        def request_callback(request):            payload = json.loads(request.body)            resp_body = {&quot;value&quot;: sum(payload[&quot;numbers&quot;])}            headers = {&quot;request-id&quot;: &quot;728d329e-0e86-11e4-a748-0c84dc037c13&quot;}            return (200, headers, json.dumps(resp_body))        responses.add_callback(            responses.POST,            &quot;http://calc.com/sum&quot;,            callback=request_callback,            content_type=&quot;application/json&quot;,        )        resp = requests.post(            &quot;http://calc.com/sum&quot;,            json.dumps({&quot;numbers&quot;: [1, 2, 3]}),            headers={&quot;content-type&quot;: &quot;application/json&quot;},        )        assert resp.json() == {&quot;value&quot;: 6}        assert len(responses.calls) == 1        assert responses.calls[0].request.url == &quot;http://calc.com/sum&quot;        assert responses.calls[0].response.text == '{&quot;value&quot;: 6}'        assert (            responses.calls[0].response.headers[&quot;request-id&quot;]            == &quot;728d329e-0e86-11e4-a748-0c84dc037c13&quot;        )You can also pass a compiled regex to ``add_callback`` to match multiple urls:.. code-block:: python    import re, json    from functools import reduce    import responses    import requests    operators = {        &quot;sum&quot;: lambda x, y: x + y,        &quot;prod&quot;: lambda x, y: x * y,        &quot;pow&quot;: lambda x, y: x**y,    }    @responses.activate    def test_regex_url():        def request_callback(request):            payload = json.loads(request.body)            operator_name = request.path_url[1:]            operator = operators[operator_name]            resp_body = {&quot;value&quot;: reduce(operator, payload[&quot;numbers&quot;])}            headers = {&quot;request-id&quot;: &quot;728d329e-0e86-11e4-a748-0c84dc037c13&quot;}            return (200, headers, json.dumps(resp_body))        responses.add_callback(            responses.POST,            re.compile(&quot;http://calc.com/(sum|prod|pow|unsupported)&quot;),            callback=request_callback,            content_type=&quot;application/json&quot;,        )        resp = requests.post(            &quot;http://calc.com/prod&quot;,            json.dumps({&quot;numbers&quot;: [2, 3, 4]}),            headers={&quot;content-type&quot;: &quot;application/json&quot;},        )        assert resp.json() == {&quot;value&quot;: 24}    test_regex_url()If you want to pass extra keyword arguments to the callback function, for example when reusinga callback function to give a slightly different result, you can use ``functools.partial``:.. code-block:: python    from functools import partial    def request_callback(request, id=None):        payload = json.loads(request.body)        resp_body = {&quot;value&quot;: sum(payload[&quot;numbers&quot;])}        headers = {&quot;request-id&quot;: id}        return (200, headers, json.dumps(resp_body))    responses.add_callback(        responses.POST,        &quot;http://calc.com/sum&quot;,        callback=partial(request_callback, id=&quot;728d329e-0e86-11e4-a748-0c84dc037c13&quot;),        content_type=&quot;application/json&quot;,    )Integration with unit test frameworks-------------------------------------Responses as a ``pytest`` fixture^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.. code-block:: python    @pytest.fixture    def mocked_responses():        with responses.RequestsMock() as rsps:            yield rsps    def test_api(mocked_responses):        mocked_responses.get(            &quot;http://twitter.com/api/1/foobar&quot;,            body=&quot;{}&quot;,            status=200,            content_type=&quot;application/json&quot;,        )        resp = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)        assert resp.status_code == 200Add default responses for each test^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^When run with ``unittest`` tests, this can be used to set up somegeneric class-level responses, that may be complemented by each test.Similar interface could be applied in ``pytest`` framework... code-block:: python    class TestMyApi(unittest.TestCase):        def setUp(self):            responses.get(&quot;https://example.com&quot;, body=&quot;within setup&quot;)            # here go other self.responses.add(...)        @responses.activate        def test_my_func(self):            responses.get(                &quot;https://httpbin.org/get&quot;,                match=[matchers.query_param_matcher({&quot;test&quot;: &quot;1&quot;, &quot;didi&quot;: &quot;pro&quot;})],                body=&quot;within test&quot;,            )            resp = requests.get(&quot;https://example.com&quot;)            resp2 = requests.get(                &quot;https://httpbin.org/get&quot;, params={&quot;test&quot;: &quot;1&quot;, &quot;didi&quot;: &quot;pro&quot;}            )            print(resp.text)            # &gt;&gt;&gt; within setup            print(resp2.text)            # &gt;&gt;&gt; within testRequestMock methods: start, stop, reset^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^``responses`` has ``start``, ``stop``, ``reset`` methods very analogous to`unittest.mock.patch &lt;https://docs.python.org/3/library/unittest.mock.html#patch-methods-start-and-stop&gt;`_.These make it simpler to do requests mocking in ``setup`` methods or whereyou want to do multiple patches without nesting decorators or with statements... code-block:: python    class TestUnitTestPatchSetup:        def setup(self):            &quot;&quot;&quot;Creates ``RequestsMock`` instance and starts it.&quot;&quot;&quot;            self.r_mock = responses.RequestsMock(assert_all_requests_are_fired=True)            self.r_mock.start()            # optionally some default responses could be registered            self.r_mock.get(&quot;https://example.com&quot;, status=505)            self.r_mock.put(&quot;https://example.com&quot;, status=506)        def teardown(self):            &quot;&quot;&quot;Stops and resets RequestsMock instance.            If ``assert_all_requests_are_fired`` is set to ``True``, will raise an error            if some requests were not processed.            &quot;&quot;&quot;            self.r_mock.stop()            self.r_mock.reset()        def test_function(self):            resp = requests.get(&quot;https://example.com&quot;)            assert resp.status_code == 505            resp = requests.put(&quot;https://example.com&quot;)            assert resp.status_code == 506Assertions on declared responses--------------------------------When used as a context manager, Responses will, by default, raise an assertionerror if a url was registered but not accessed. This can be disabled by passingthe ``assert_all_requests_are_fired`` value:.. code-block:: python    import responses    import requests    def test_my_api():        with responses.RequestsMock(assert_all_requests_are_fired=False) as rsps:            rsps.add(                responses.GET,                &quot;http://twitter.com/api/1/foobar&quot;,                body=&quot;{}&quot;,                status=200,                content_type=&quot;application/json&quot;,            )Assert Request Call Count-------------------------Assert based on ``Response`` object^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Each ``Response`` object has ``call_count`` attribute that could be inspectedto check how many times each request was matched... code-block:: python    @responses.activate    def test_call_count_with_matcher():        rsp = responses.get(            &quot;http://www.example.com&quot;,            match=(matchers.query_param_matcher({}),),        )        rsp2 = responses.get(            &quot;http://www.example.com&quot;,            match=(matchers.query_param_matcher({&quot;hello&quot;: &quot;world&quot;}),),            status=777,        )        requests.get(&quot;http://www.example.com&quot;)        resp1 = requests.get(&quot;http://www.example.com&quot;)        requests.get(&quot;http://www.example.com?hello=world&quot;)        resp2 = requests.get(&quot;http://www.example.com?hello=world&quot;)        assert resp1.status_code == 200        assert resp2.status_code == 777        assert rsp.call_count == 2        assert rsp2.call_count == 2Assert based on the exact URL^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Assert that the request was called exactly n times... code-block:: python    import responses    import requests    @responses.activate    def test_assert_call_count():        responses.get(&quot;http://example.com&quot;)        requests.get(&quot;http://example.com&quot;)        assert responses.assert_call_count(&quot;http://example.com&quot;, 1) is True        requests.get(&quot;http://example.com&quot;)        with pytest.raises(AssertionError) as excinfo:            responses.assert_call_count(&quot;http://example.com&quot;, 1)        assert (            &quot;Expected URL 'http://example.com' to be called 1 times. Called 2 times.&quot;            in str(excinfo.value)        )    @responses.activate    def test_assert_call_count_always_match_qs():        responses.get(&quot;http://www.example.com&quot;)        requests.get(&quot;http://www.example.com&quot;)        requests.get(&quot;http://www.example.com?hello=world&quot;)        # One call on each url, querystring is matched by default        responses.assert_call_count(&quot;http://www.example.com&quot;, 1) is True        responses.assert_call_count(&quot;http://www.example.com?hello=world&quot;, 1) is TrueAssert Request Calls data-------------------------``Request`` object has ``calls`` list which elements correspond to ``Call`` objectsin the global list of ``Registry``. This can be useful when the order of requests is notguaranteed, but you need to check their correctness, for example in multithreadedapplications... code-block:: python    import concurrent.futures    import responses    import requests    @responses.activate    def test_assert_calls_on_resp():        rsp1 = responses.patch(&quot;http://www.foo.bar/1/&quot;, status=200)        rsp2 = responses.patch(&quot;http://www.foo.bar/2/&quot;, status=400)        rsp3 = responses.patch(&quot;http://www.foo.bar/3/&quot;, status=200)        def update_user(uid, is_active):            url = f&quot;http://www.foo.bar/{uid}/&quot;            response = requests.patch(url, json={&quot;is_active&quot;: is_active})            return response        with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:            future_to_uid = {                executor.submit(update_user, uid, is_active): uid                for (uid, is_active) in [(&quot;3&quot;, True), (&quot;2&quot;, True), (&quot;1&quot;, False)]            }            for future in concurrent.futures.as_completed(future_to_uid):                uid = future_to_uid[future]                response = future.result()                print(f&quot;{uid} updated with {response.status_code} status code&quot;)        assert len(responses.calls) == 3  # total calls count        assert rsp1.call_count == 1        assert rsp1.calls[0] in responses.calls        assert rsp1.calls[0].response.status_code == 200        assert json.loads(rsp1.calls[0].request.body) == {&quot;is_active&quot;: False}        assert rsp2.call_count == 1        assert rsp2.calls[0] in responses.calls        assert rsp2.calls[0].response.status_code == 400        assert json.loads(rsp2.calls[0].request.body) == {&quot;is_active&quot;: True}        assert rsp3.call_count == 1        assert rsp3.calls[0] in responses.calls        assert rsp3.calls[0].response.status_code == 200        assert json.loads(rsp3.calls[0].request.body) == {&quot;is_active&quot;: True}Multiple Responses------------------You can also add multiple responses for the same url:.. code-block:: python    import responses    import requests    @responses.activate    def test_my_api():        responses.get(&quot;http://twitter.com/api/1/foobar&quot;, status=500)        responses.get(            &quot;http://twitter.com/api/1/foobar&quot;,            body=&quot;{}&quot;,            status=200,            content_type=&quot;application/json&quot;,        )        resp = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)        assert resp.status_code == 500        resp = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)        assert resp.status_code == 200URL Redirection---------------In the following example you can see how to create a redirection chain and add custom exception that will be raisedin the execution chain and contain the history of redirects...  code-block::    A -&gt; 301 redirect -&gt; B    B -&gt; 301 redirect -&gt; C    C -&gt; connection issue.. code-block:: python    import pytest    import requests    import responses    @responses.activate    def test_redirect():        # create multiple Response objects where first two contain redirect headers        rsp1 = responses.Response(            responses.GET,            &quot;http://example.com/1&quot;,            status=301,            headers={&quot;Location&quot;: &quot;http://example.com/2&quot;},        )        rsp2 = responses.Response(            responses.GET,            &quot;http://example.com/2&quot;,            status=301,            headers={&quot;Location&quot;: &quot;http://example.com/3&quot;},        )        rsp3 = responses.Response(responses.GET, &quot;http://example.com/3&quot;, status=200)        # register above generated Responses in ``response`` module        responses.add(rsp1)        responses.add(rsp2)        responses.add(rsp3)        # do the first request in order to generate genuine ``requests`` response        # this object will contain genuine attributes of the response, like ``history``        rsp = requests.get(&quot;http://example.com/1&quot;)        responses.calls.reset()        # customize exception with ``response`` attribute        my_error = requests.ConnectionError(&quot;custom error&quot;)        my_error.response = rsp        # update body of the 3rd response with Exception, this will be raised during execution        rsp3.body = my_error        with pytest.raises(requests.ConnectionError) as exc_info:            requests.get(&quot;http://example.com/1&quot;)        assert exc_info.value.args[0] == &quot;custom error&quot;        assert rsp1.url in exc_info.value.response.history[0].url        assert rsp2.url in exc_info.value.response.history[1].urlValidate ``Retry`` mechanism----------------------------If you are using the ``Retry`` features of ``urllib3`` and want to cover scenarios that test your retry limits, you can test those scenarios with ``responses`` as well. The best approach will be to use an `Ordered Registry`_.. code-block:: python    import requests    import responses    from responses import registries    @responses.activate(registry=registries.OrderedRegistry)    def test_max_retries():        url = &quot;https://example.com&quot;        rsp1 = responses.get(url, body=&quot;Error&quot;, status=500)        rsp2 = responses.get(url, body=&quot;Error&quot;, status=500)        rsp3 = responses.get(url, body=&quot;Error&quot;, status=500)        rsp4 = responses.get(url, body=&quot;OK&quot;, status=200)        session = requests.Session()        adapter = requests.adapters.HTTPAdapter(            max_retries=Retry(                total=4,                backoff_factor=0.1,                status_forcelist=[500],                method_whitelist=[&quot;GET&quot;, &quot;POST&quot;, &quot;PATCH&quot;],            )        )        session.mount(&quot;https://&quot;, adapter)        resp = session.get(url)        assert resp.status_code == 200        assert rsp1.call_count == 1        assert rsp2.call_count == 1        assert rsp3.call_count == 1        assert rsp4.call_count == 1Using a callback to modify the response---------------------------------------If you use customized processing in ``requests`` via subclassing/mixins, or if youhave library tools that interact with ``requests`` at a low level, you may needto add extended processing to the mocked Response object to fully simulate theenvironment for your tests.  A ``response_callback`` can be used, which will bewrapped by the library before being returned to the caller.  The callbackaccepts a ``response`` as it's single argument, and is expected to return asingle ``response`` object... code-block:: python    import responses    import requests    def response_callback(resp):        resp.callback_processed = True        return resp    with responses.RequestsMock(response_callback=response_callback) as m:        m.add(responses.GET, &quot;http://example.com&quot;, body=b&quot;test&quot;)        resp = requests.get(&quot;http://example.com&quot;)        assert resp.text == &quot;test&quot;        assert hasattr(resp, &quot;callback_processed&quot;)        assert resp.callback_processed is TruePassing through real requests-----------------------------In some cases you may wish to allow for certain requests to pass through responsesand hit a real server. This can be done with the ``add_passthru`` methods:.. code-block:: python    import responses    @responses.activate    def test_my_api():        responses.add_passthru(&quot;https://percy.io&quot;)This will allow any requests matching that prefix, that is otherwise notregistered as a mock response, to passthru using the standard behavior.Pass through endpoints can be configured with regex patterns if youneed to allow an entire domain or path subtree to send requests:.. code-block:: python    responses.add_passthru(re.compile(&quot;https://percy.io/\\w+&quot;))Lastly, you can use the ``passthrough`` argument of the ``Response`` objectto force a response to behave as a pass through... code-block:: python    # Enable passthrough for a single response    response = Response(        responses.GET,        &quot;http://example.com&quot;,        body=&quot;not used&quot;,        passthrough=True,    )    responses.add(response)    # Use PassthroughResponse    response = PassthroughResponse(responses.GET, &quot;http://example.com&quot;)    responses.add(response)Viewing/Modifying registered responses--------------------------------------Registered responses are available as a public method of the RequestMockinstance. It is sometimes useful for debugging purposes to view the stack ofregistered responses which can be accessed via ``responses.registered()``.The ``replace`` function allows a previously registered ``response`` to bechanged. The method signature is identical to ``add``. ``response`` s areidentified using ``method`` and ``url``. Only the first matched ``response`` isreplaced... code-block:: python    import responses    import requests    @responses.activate    def test_replace():        responses.get(&quot;http://example.org&quot;, json={&quot;data&quot;: 1})        responses.replace(responses.GET, &quot;http://example.org&quot;, json={&quot;data&quot;: 2})        resp = requests.get(&quot;http://example.org&quot;)        assert resp.json() == {&quot;data&quot;: 2}The ``upsert`` function allows a previously registered ``response`` to bechanged like ``replace``. If the response is registered, the ``upsert`` functionwill registered it like ``add``.``remove`` takes a ``method`` and ``url`` argument and will remove **all**matched responses from the registered list.Finally, ``reset`` will reset all registered responses.Coroutines and Multithreading-----------------------------``responses`` supports both Coroutines and Multithreading out of the box.Note, ``responses`` locks threading on ``RequestMock`` object allowing onlysingle thread to access it... code-block:: python    async def test_async_calls():        @responses.activate        async def run():            responses.get(                &quot;http://twitter.com/api/1/foobar&quot;,                json={&quot;error&quot;: &quot;not found&quot;},                status=404,            )            resp = requests.get(&quot;http://twitter.com/api/1/foobar&quot;)            assert resp.json() == {&quot;error&quot;: &quot;not found&quot;}            assert responses.calls[0].request.url == &quot;http://twitter.com/api/1/foobar&quot;        await run()Contributing------------Environment Configuration^^^^^^^^^^^^^^^^^^^^^^^^^Responses uses several linting and autoformatting utilities, so it's important that whensubmitting patches you use the appropriate toolchain:Clone the repository:.. code-block:: shell    git clone https://github.com/getsentry/responses.gitCreate an environment (e.g. with ``virtualenv``):.. code-block:: shell    virtualenv .env &amp;&amp; source .env/bin/activateConfigure development requirements:.. code-block:: shell    make developTests and Code Quality Validation^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^The easiest way to validate your code is to run tests via ``tox``.Current ``tox`` configuration runs the same checks that are used inGitHub Actions CI/CD pipeline.Please execute the following command line from the project root to validateyour code against:* Unit tests in all Python versions that are supported by this project* Type validation via ``mypy``* All ``pre-commit`` hooks.. code-block:: shell    toxAlternatively, you can always run a single test. See documentation below.Unit tests&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;Responses uses `Pytest &lt;https://docs.pytest.org/en/latest/&gt;`_ fortesting. You can run all tests by:.. code-block:: shell    tox -e py37    tox -e py310OR manually activate required version of Python and run.. code-block:: shell    pytestAnd run a single test by:.. code-block:: shell    pytest -k '&lt;test_function_name&gt;'Type Validation&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;To verify ``type`` compliance, run `mypy &lt;https://github.com/python/mypy&gt;`_ linter:.. code-block:: shell    tox -e mypyOR.. code-block:: shell    mypy --config-file=./mypy.ini -p responsesCode Quality and Style&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;To check code style and reformat it run:.. code-block:: shell    tox -e precomOR.. code-block:: shell    pre-commit run --all-files</longdescription>
</pkgmetadata>