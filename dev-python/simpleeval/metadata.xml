<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>simpleeval (Simple Eval)========================.. image:: https://github.com/danthedeckie/simpleeval/actions/workflows/ci.yml/badge.svg?branch=gh-actions-build   :target: https://github.com/danthedeckie/simpleeval/actions/   :alt: Build Status.. image:: https://codecov.io/gh/danthedeckie/simpleeval/branch/master/graph/badge.svg?token=isRnN1yrca   :target: https://codecov.io/gh/danthedeckie/simpleeval   :alt: Code Coverage.. image:: https://badge.fury.io/py/simpleeval.svg   :target: https://badge.fury.io/py/simpleeval   :alt: PyPI Version.. image:: https://img.shields.io/badge/code%20style-black-000000.svg   :target: https://github.com/psf/black.. image:: https://img.shields.io/badge/linting-pylint-yellowgreen   :target: https://github.com/PyCQA/pylintA single file library for easily adding evaluatable expressions intopython projects.  Say you want to allow a user to set an alarm volume, whichcould depend on the time of day, alarm level, how many previous alarms had goneoff, and if there is music playing at the time.Or if you want to allow simple formulae in a web application, but don't want togive full eval() access, or don't want to run in javascript on the client side.It's deliberately trying to stay simple to use and not have millions of features,pull it in from PyPI (pip or easy_install), or even just a single file you can dumpinto a project.Internally, it's using the amazing python ``ast`` module to parse theexpression, which allows very fine control of what is and isn't allowed.  Itshould be completely safe in terms of what operations can be performed by theexpression.The only issue I know to be aware of is that you can create an expression whichtakes a long time to evaluate, or which evaluating requires an awful lot ofmemory, which leaves the potential for DOS attacks.  There is basic protectionagainst this, and you can lock it down further if you desire. (see theOperators_ section below)You should be aware of this when deploying in a public setting.The defaults are pretty locked down and basic, and it's easy to addwhatever extra specific functionality you need (your own functions,variable/name lookup, etc).Basic Usage-----------To get very simple evaluating:.. code-block:: python    from simpleeval import simple_eval    simple_eval(&quot;21 + 21&quot;)returns ``42``.Expressions can be as complex and convoluted as you want:.. code-block:: python    simple_eval(&quot;21 + 19 / 7 + (8 % 3) ** 9&quot;)returns ``535.714285714``.You can add your own functions in as well... code-block:: python    simple_eval(&quot;square(11)&quot;, functions={&quot;square&quot;: lambda x: x*x})returns ``121``.For more details of working with functions, read further down.Note:~~~~~all further examples use ``&gt;&gt;&gt;`` to designate python code, as if you are usingthe python interactive prompt... _Operators:Operators---------You can add operators yourself, using the ``operators`` argument, but these arethe defaults:+--------+------------------------------------+|  ``+`` | add two things. ``x + y``          ||        | ``1 + 1`` -&gt; ``2``                 |+--------+------------------------------------+|  ``-`` | subtract two things ``x - y``      ||        | ``100 - 1`` -&gt; ``99``              |+--------+------------------------------------+|  ``/`` | divide one thing by another        ||        | ``x / y``                          ||        | ``100/10`` -&gt; ``10``               |+--------+------------------------------------+|  ``*`` | multiple one thing by another      ||        | ``x * y``                          ||        | ``10 * 10`` -&gt; ``100``             |+--------+------------------------------------+| ``**`` | 'to the power of' ``x**y``         ||        | ``2 ** 10`` -&gt; ``1024``            |+--------+------------------------------------+| ``%``  | modulus. (remainder)  ``x % y``    ||        | ``15 % 4`` -&gt; ``3``                |+--------+------------------------------------+| ``==`` | equals  ``x == y``                 ||        | ``15 == 4`` -&gt; ``False``           |+--------+------------------------------------+| ``&lt;``  | Less than. ``x &lt; y``               ||        | ``1 &lt; 4`` -&gt; ``True``              |+--------+------------------------------------+| ``&gt;``  | Greater than. ``x &gt; y``            ||        | ``1 &gt; 4`` -&gt; ``False``             |+--------+------------------------------------+| ``&lt;=`` | Less than or Equal to. ``x &lt;= y``  ||        | ``1 &lt; 4`` -&gt; ``True``              |+--------+------------------------------------+| ``&gt;=`` | Greater or Equal to ``x &gt;= 21``    ||        | ``1 &gt;= 4`` -&gt; ``False``            |+--------+------------------------------------+| ``&gt;&gt;`` | &quot;Right shift&quot; the number.          ||        | ``100 &gt;&gt; 2`` -&gt; ``25``             |+--------+------------------------------------+| ``&lt;&lt;`` | &quot;Left shift&quot; the number.           ||        | ``100 &lt;&lt; 2`` -&gt; ``400``            |+--------+------------------------------------+| ``in`` | is something contained within      ||        | something else.                    ||        | ``&quot;spam&quot; in &quot;my breakfast&quot;``       ||        | -&gt; ``False``                       |+--------+------------------------------------+| ``^``  | &quot;bitwise exclusive OR&quot; (xor)       ||        | ``62 ^ 20`` -&gt; ``42``              |+--------+------------------------------------+| ``|``  | &quot;bitwise OR&quot;                       ||        | ``8 | 34`` -&gt; ``42``               |+--------+------------------------------------+| ``&amp;``  | &quot;bitwise AND&quot;                      ||        | ``100 &amp; 63`` -&gt; ``36``             |+--------+------------------------------------+| ``~``  | &quot;bitwise invert&quot;                   ||        | ``~ -43`` -&gt; ``42``                |+--------+------------------------------------+The ``^`` operator is often mistaken for a exponent operator, not the bitwise operation that it is in python, so if you want ``3 ^ 2`` to equal ``9``, you canreplace the operator like this:.. code-block:: python    &gt;&gt;&gt; import ast    &gt;&gt;&gt; from simpleeval import safe_power    &gt;&gt;&gt; s = SimpleEval()    &gt;&gt;&gt; s.operators[ast.BitXor] = safe_power    &gt;&gt;&gt; s.eval(&quot;3 ^ 2&quot;)    9for example.Limited Power~~~~~~~~~~~~~Also note, the ``**`` operator has been locked down by default to have amaximum input value of ``4000000``, which makes it somewhat harder to makeexpressions which go on for ever.  You can change this limit by changing the``simpleeval.POWER_MAX`` module level value to whatever is an appropriate valuefor you (and the hardware that you're running on) or if you want to completelyremove all limitations, you can set the ``s.operators[ast.Pow] = operator.pow``or make your own function.On my computer, ``9**9**5`` evaluates almost instantly, but ``9**9**6`` takesover 30 seconds.  Since ``9**7`` is ``4782969``, and so over the ``POWER_MAX``limit, it throws a ``NumberTooHigh`` exception for you. (Otherwise it would goon for hours, or until the computer runs out of memory)Strings (and other Iterables) Safety~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~There are also limits on string length (100000 characters,``MAX_STRING_LENGTH``).  This can be changed if you wish.Related to this, if you try to create a silly long string/bytes/list, by doing``'i want to break free'.split() * 9999999999`` for instance, it will block you.If Expressions--------------You can use python style ``if x then y else z`` type expressions:.. code-block:: python    &gt;&gt;&gt; simple_eval(&quot;'equal' if x == y else 'not equal'&quot;,                    names={&quot;x&quot;: 1, &quot;y&quot;: 2})    'not equal'which, of course, can be nested:.. code-block:: python    &gt;&gt;&gt; simple_eval(&quot;'a' if 1 == 2 else 'b' if 2 == 3 else 'c'&quot;)    'c'Functions---------You can define functions which you'd like the expresssions to have access to:.. code-block:: python    &gt;&gt;&gt; simple_eval(&quot;double(21)&quot;, functions={&quot;double&quot;: lambda x:x*2})    42You can define &quot;real&quot; functions to pass in rather than lambdas, of course too,and even re-name them so that expressions can be shorter.. code-block:: python    &gt;&gt;&gt; def double(x):            return x * 2    &gt;&gt;&gt; simple_eval(&quot;d(100) + double(1)&quot;, functions={&quot;d&quot;: double, &quot;double&quot;:double})    202If you don't provide your own ``functions`` dict, then the the following defaultsare provided in the ``DEFAULT_FUNCTIONS`` dict:+----------------+--------------------------------------------------+| ``randint(x)`` | Return a random ``int`` below ``x``              |+----------------+--------------------------------------------------+| ``rand()``     | Return a random ``float`` between 0 and 1        |+----------------+--------------------------------------------------+| ``int(x)``     | Convert ``x`` to an ``int``.                     |+----------------+--------------------------------------------------+| ``float(x)``   | Convert ``x`` to a ``float``.                    |+----------------+--------------------------------------------------+| ``str(x)``     | Convert ``x`` to a ``str`` (``unicode`` in py2)  |+----------------+--------------------------------------------------+If you want to provide a list of functions, but want to keep these as well,then you can do a normal python ``.copy()`` &amp; ``.update``:.. code-block:: python    &gt;&gt;&gt; my_functions = simpleeval.DEFAULT_FUNCTIONS.copy()    &gt;&gt;&gt; my_functions.update(            square=(lambda x:x*x),            double=(lambda x:x+x),        )    &gt;&gt;&gt; simple_eval('square(randint(100))', functions=my_functions)Names-----Sometimes it's useful to have variables available, which in python terminologyare called 'names'... code-block:: python    &gt;&gt;&gt; simple_eval(&quot;a + b&quot;, names={&quot;a&quot;: 11, &quot;b&quot;: 100})    111You can also hand the handling of names over to a function, if you prefer:.. code-block:: python    &gt;&gt;&gt; def name_handler(node):            return ord(node.id[0].lower(a))-96    &gt;&gt;&gt; simple_eval('a + b', names=name_handler)    3That was a bit of a silly example, but you could use this for pulling valuesfrom a database or file, say, or doing some kind of caching system.The two default names that are provided are ``True`` and ``False``.  So if you want to provide your own names, but want ``True`` and ``False`` to keep working, either provide them yourself, or ``.copy()`` and ``.update`` the ``DEFAULT_NAMES``. (See functions example above).Creating an Evaluator Class---------------------------Rather than creating a new evaluator each time, if you are doing a lot ofevaluations, you can create a SimpleEval object, and pass it expressions eachtime (which should be a bit quicker, and certainly more convenient for some usecases):.. code-block:: python    &gt;&gt;&gt; s = SimpleEval()    &gt;&gt;&gt; s.eval(&quot;1 + 1&quot;)    2    &gt;&gt;&gt; s.eval('100 * 10')    1000    # and so on...One useful feature of using the ``SimpleEval`` object is that you can parse an expressiononce, and then evaluate it mulitple times using different ``names``:.. code-block:: python    # Set up &amp; Cache the parse tree:    expression = &quot;foo + bar&quot;    parsed = s.parse(expression)    # evaluate the expression multiple times:    for names in [{&quot;foo&quot;: 1, &quot;bar&quot;: 10}, {&quot;foo&quot;: 100, &quot;bar&quot;: 42}]:        s.names = names        print(s.eval(expression, previously_parsed=parsed))for instance.  This may help with performance.You can assign / edit the various options of the ``SimpleEval`` object if youwant to.  Either assign them during creation (like the ``simple_eval``function).. code-block:: python    def boo():        return 'Boo!'    s = SimpleEval(functions={&quot;boo&quot;: boo})or edit them after creation:.. code-block:: python    s.names['fortytwo'] = 42this actually means you can modify names (or functions) with functions, if youreally feel so inclined:.. code-block:: python    s = SimpleEval()    def set_val(name, value):        s.names[name.value] = value.value        return value.value    s.functions = {'set': set_val}    s.eval(&quot;set('age', 111)&quot;)Say.  This would allow a certain level of 'scriptyness' if you had theseevaluations happening as callbacks in a program.  Although you really arereaching the end of what this library is intended for at this stage.Compound Types--------------Compound types (``dict``, ``tuple``, ``list``, ``set``) in general just work ifyou pass them in as named objects.  If you want to allow creation of these, the``EvalWithCompoundTypes`` class works.  Just replace any use of ``SimpleEval`` withthat.The ``EvalWithCompoundTypes`` class also contains support for simple comprehensions.eg: ``[x + 1 for x in [1,2,3]]``.  There's a safety `MAX_COMPREHENSION_LENGTH` to controlhow many items it'll allow before bailing too.  This also takes into account nestedcomprehensions.Since the primary intention of this library is short expressions - an extra 'sweetener' isenabled by default.  You can access a dict (or similar's) keys using the .attr syntax:.. code-block:: python    &gt;&gt;&gt;  simple_eval(&quot;foo.bar&quot;, names={&quot;foo&quot;: {&quot;bar&quot;: 42}})    42for instance.  You can turn this off either by setting the module global `ATTR_INDEX_FALLBACK`to `False`, or on the ``SimpleEval`` instance itself. e.g. ``evaller.ATTR_INDEX_FALLBACK=False``.Extending---------The ``SimpleEval`` class is pretty easy to extend.  For instance, to create aversion that disallows method invocation on objects:.. code-block:: python    import ast    import simpleeval    class EvalNoMethods(simpleeval.SimpleEval):        def _eval_call(self, node):            if isinstance(node.func, ast.Attribute):                raise simpleeval.FeatureNotAvailable(&quot;No methods please, we're British&quot;)            return super(EvalNoMethods, self)._eval_call(node)and then use ``EvalNoMethods`` instead of the ``SimpleEval`` class.Other...--------The library supports python 3 - but should be mostly compatible (and tested before 0.9.11)with python 2.7 as well.Object attributes that start with ``_`` or ``func_`` are disallowed by default.If you really need that (BE CAREFUL!), then modify the module global``simpleeval.DISALLOW_PREFIXES``.A few builtin functions are listed in ``simpleeval.DISALLOW_FUNCTIONS``.  ``type``, ``open``, etc.If you need to give access to this kind of functionality to your expressions, then be verycareful.  You'd be better wrapping the functions in your own safe wrappers.The initial idea came from J.F. Sebastian on Stack Overflow( http://stackoverflow.com/a/9558001/1973500 ) with modifications and many improvements,see the head of the main file for contributors list.Please read the ``test_simpleeval.py`` file for other potential gotchas ordetails.  I'm very happy to accept pull requests, suggestions, or other issues.Enjoy!Developing----------Run tests::    $ make testOr to set the tests running on every file change:    $ make autotest(requires ``entr``) I'm trying to keep the codebase relatively clean with Black, isort, pylint &amp; mypy.See::    $ make formatand::    $ make lintBEWARE------I've done the best I can with this library - but there's no warranty, no guarantee, nada.  A lot ofvery clever people think the whole idea of trying to sandbox CPython is impossible.  Read the codeyourself, and use it at your own risk.</longdescription>
</pkgmetadata>