<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pypants[![](https://img.shields.io/pypi/v/pypants.svg)](https://pypi.org/pypi/pypants/) [![License](https://img.shields.io/badge/License-BSD%203--Clause-blue.svg)](https://opensource.org/licenses/BSD-3-Clause)CLI for working with Python packages and BUILD files in a [Pants](https://www.pantsbuild.org/) monorepo.Features:- Auto-generate BUILD files based on the package type and import statements- Generate new Python package folders through an interactive CLI- Compute a topologically-sorted list of dependencies for a given Python build targetTable of Contents:- [Installation](#installation)- [Guide](#guide)  - [Commands](#commands)  - [Project Configuration](#project-configuration)  - [Package Configuration](#package-configuration)  - [Package Types](#package-types)  - [Registering Extra Targets](#registering-extra-targets)  - [Package Generators](#package-generators)- [Development](#development)## Installationpypants requires Python 3.6 or above```bashpip install pypants```## Guide### Commands#### `pypants process-requirements`Update `3rdparty/python/import-map.json` using the entries in `3rdparty/python/requirements.txt`. All this does is convert the published package name to an import name. Execute this command when you add a new requirement to `requirements.txt`.#### `pypants process-packages`Auto-generate all relevant BUILD files in the project/repo. You should execute this command in a git pre-commit or pre-push hook so your BUILD files are kept up to date. You can also run it on demand after you add a new dependency to an internal package.#### `pypants generate-package`Starts an interactive CLI that generates a new package folder. This depends on the package generators you registered.### Project ConfigurationTo configure your project, add a file named `.pypants.cfg` to the root of your Git repo and paste the example below. You should define the `top_dirs` option at a minimum.```ini[project]; **************; COMMON OPTIONS; **************; REQUIRED: Top-level directories to search for Python packages. These are relative; to your project/repo root. This is a JSON list of strings.top_dirs = [&quot;.&quot;]; Prefix to use for names of packages generated by pypants. e.g. foobar_; python_package_name_prefix =; Never look for or process files in these directories. This is a JSON list of; strings. e.g. [&quot;node_modules&quot;, &quot;generators&quot;]; ignore_dirs = []; ****************; UNCOMMON OPTIONS; ****************; Set of target package names to ignore when collecting build targets. This is a; JSON list of strings.; ignore_targets = []; Path to the location of the import-map.json file relative to the project root; third_party_import_map_path = 3rdparty/python/import-map.json; Path to the requirements.txt relative to the project root. The default value is; the default that Pants uses.; third_party_requirements_path = 3rdparty/python/requirements.txt```Besides the JSON lists, other options are parsed with Python's built-in [ConfigParser](https://docs.python.org/3/library/configparser.html).### Package Configuration`pypants` currently expects the Python package to be structured like:```txtmypackage/├── setup.py├── .pypants.cfg &lt;---- this is the pypants config file├── src/    ├── BUILD &lt;---- pypants will generate this file    ├── mypackage/        ├── __init__.py        ├── ...source code...├── tests/    ├── unit/        ├── BUILD &lt;---- pypants will generate this file        ├── ...unit tests...    ├── functional/        ├── BUILD &lt;---- pypants will generate this file        ├── ...functional tests...```To configure each package, add a file named `.pypants.cfg` to the package folder and paste the example below. You should define the `type` option at a minimum.```ini[package]; **************; COMMON OPTIONS; **************; REQUIRED: Package type. See Package Types section for available values.type = library; ****************; UNCOMMON OPTIONS; ****************; Extra set of dependencies to include in the python_library target. This is a; JSON list of strings.; extra_dependencies = []; Extra set of tags to include in the Pants build targets. This is a JSON list of; strings.; extra_tags = []; Flag denoting whether to generate a BUILD file.; generate_build_file = true; Flag denoting whether to generate a pex_binary target for local.py. This is; essentially an extra entry point. It's only used for specific package types.; generate_local_binary = false; Flag denoting whether to include a pex_binary target for pytest; generate_pytest_binary = false```### Package TypesEach of the package types will result in a different BUILD file.#### `library`The BUILD file for internal Python libraries has one target defined. For example:```pythonpython_library(    dependencies=[        &quot;3rdparty/python:arrow&quot;,        &quot;3rdparty/python:isoweek&quot;,        &quot;lib/code/src&quot;,        &quot;lib/logger/src&quot;,    ],    sources=[&quot;my_library/**/*&quot;],    tags={&quot;code&quot;, &quot;lib&quot;, &quot;python&quot;},)```There is no name provided so this target can be referenced just by its containing folder path. In this case it would be `&quot;&lt;TOPDIR&gt;/my_library/src&quot;`.#### `binary`A binary target can be used for executable scripts (CLIs and servers) and usually depend on internal libraries. The BUILD has a library and binary target defined:```pythonpython_library(    name=&quot;lib&quot;,    dependencies=[        &quot;3rdparty/python:boto3&quot;,        &quot;3rdparty/python:cfn-flip&quot;,        &quot;3rdparty/python:Click&quot;,        &quot;3rdparty/python:jsonschema&quot;,        &quot;lib/logger/src&quot;,    ],    sources=[&quot;cli_deploy/**/*&quot;],    tags={&quot;apps&quot;, &quot;code&quot;, &quot;python&quot;},)pex_binary(    name=&quot;deploy&quot;,    dependencies=[&quot;:lib&quot;],    source=&quot;cli_deploy/cli.py&quot;,    tags={&quot;apps&quot;, &quot;code&quot;, &quot;python&quot;},)```- The `python_library` target is pretty much the same as an internal Python library package- The `pex_binary` target defines an explicit name. This is because when we go to build the PEX file, we want to define the filename. In this example, running `./pants binary apps/cli_deploy/src:deploy` will result in `dist/deploy.pex`.- The only dependency for the binary should be the library. The library will then include all the dependencies.- `source` points to the entry point of the binary. This module should handle the `if __name__ == &quot;__main__&quot;` condition to kick off the script.#### `test`pypants looks for subfolders named unit, functional, or component within a package's `tests/` folder. The BUILD file for test folders have a few targets defined. For example:```pythonpython_library(    name=&quot;lib/time_utils/tests/unit&quot;,    dependencies=[        &quot;3rdparty/python:arrow&quot;,        &quot;lib/python_core/src&quot;,        &quot;lib/time_utils/src&quot;    ],    sources=[&quot;**/*&quot;],    tags={&quot;lib&quot;, &quot;python&quot;, &quot;tests&quot;, &quot;unit&quot;},)python_tests(    dependencies=[&quot;:lib/time_utils/tests/unit&quot;],    sources=[&quot;**/*.py&quot;],    tags={&quot;lib&quot;, &quot;python&quot;, &quot;tests&quot;, &quot;unit&quot;},)pex_binary(    name=&quot;unittest&quot;,    entry_point=&quot;unittest&quot;,    dependencies=[&quot;:lib/time_utils/tests/unit&quot;])```- The `python_library` target is mostly here to define the unit tests dependencies in a single place so the other two targets can point to it- The `python_tests` target lets us run pytest against the test files that match `**/*.py`- The `pex_binary` target lets us run the unittest module directly. We won't actually package up this target via `./pants binary`. Setting the entry_point to `&quot;unittest&quot;` is essentially the same as running `python -m unittest test_something.py` from the command line.#### `lambda_function`The BUILD file for the Lambda handler contains a special-purpose build target: `python_awslambda`. This target is a wrapper around [lambdex](https://github.com/wickman/lambdex). It creates a PEX like the `pex_binary` target (you can execute it) but it modifies the PEX to work with a Lambda Function. For example:```pythonpython_library(    name=&quot;my-lambda-lib&quot;,    sources=[&quot;lambda_handler/**/*&quot;],    dependencies=[        &quot;3rdparty/python:requests&quot;,        &quot;lib/logger/src&quot;,    ],)pex_binary(    name=&quot;my-lambda-bin&quot;,    source=&quot;lambda_handler/lambda_handler.py&quot;,    dependencies=[&quot;:my-lambda-lib&quot;],)python_awslambda(    name=&quot;my-lambda&quot;,    binary=&quot;:my-lambda-bin&quot;,    handler=&quot;lambda_handler.lambda_handler:lambda_handler&quot;,)```This BUILD file will be placed in the same folder as the `.pypants.cfg` file.#### `migration`The BUILD file for an [Alembic](https://alembic.sqlalchemy.org/) migration uses the `python_app` target to include the loose version files:```pythonpython_library(    name=&quot;lib&quot;,    dependencies=[        &quot;3rdparty/python:alembic&quot;,        &quot;3rdparty/python:SQLAlchemy&quot;,        &quot;lib/core/src&quot;,    ],    sources=[&quot;**/*&quot;],    tags={&quot;code&quot;, &quot;db&quot;, &quot;migration&quot;, &quot;python&quot;},)pex_binary(name=&quot;alembic&quot;, entry_point=&quot;alembic.config&quot;, dependencies=[&quot;:lib&quot;])python_app(    name=&quot;migrations-my-database-name&quot;,    archive=&quot;tar&quot;,    binary=&quot;:alembic&quot;,    bundles=[        bundle(fileset=[&quot;alembic.ini&quot;]),        bundle(fileset=[&quot;env.py&quot;]),        bundle(fileset=[&quot;versions/*.py&quot;]),    ],    tags={&quot;code&quot;, &quot;db&quot;, &quot;migration&quot;, &quot;python&quot;},)```This BUILD file will be placed in the same folder as the `.pypants.cfg` file.#### `behave`The BUILD file for a [behave](https://behave.readthedocs.io/en/latest/) test package includes a library target with test dependencies and a binary target that wraps behave. For example:```pythonpython_library(    name=&quot;lib&quot;,    dependencies=[        &quot;3rdparty/python:requests&quot;,        &quot;lib/application_config/src&quot;,    ],    sources=[&quot;**/*&quot;],    tags={&quot;integration&quot;, &quot;python&quot;, &quot;tests&quot;, &quot;tests-integration&quot;},)pex_binary(    source=&quot;behave_cli.py&quot;,    dependencies=[&quot;:lib&quot;],    tags={&quot;integration&quot;, &quot;python&quot;, &quot;tests&quot;, &quot;tests-integration&quot;},)```This BUILD file will be placed in the same folder as the `.pypants.cfg` file.The `behave_cli.py` source references a wrapper script that you should add to the folder:```python&quot;&quot;&quot;Programmatic entrypoint to running behave from the command line&quot;&quot;&quot;import osimport sysfrom behave.__main__ import main as behave_mainif __name__ == &quot;__main__&quot;:    cwd = os.getcwd()    os.chdir(os.path.dirname(__file__))    try:        exit_code = behave_main(sys.argv[1:])    finally:        os.chdir(cwd)        sys.exit(exit_code)```#### `py2sfn_project`py2sfn is a framework that simplifies the creation and deployment of workflows to [AWS Step Functions](https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html). The BUILD file for a project only includes a generic target with the set of task dependencies:```pythontarget(    dependencies=[        &quot;stepfunctions/projects/example-project/tasks/lambda_fetchjoke/src:lib&quot;,        &quot;stepfunctions/projects/example-project/tasks/lambda_generatelist/src:lib&quot;,        &quot;stepfunctions/projects/example-project/tasks/lambda_rankcharactersbyjoke/src:lib&quot;,    ],    tags={&quot;py2sfn-project&quot;, &quot;python&quot;, &quot;stepfunctions/projects&quot;},)```This BUILD file will be placed in the same folder as the `.pypants.cfg` file.### Registering Extra TargetsIf your project contains internal packages that don't aren't represented cleanly by the `.pypants.cfg` file, you can register extra targets programmatically.1. In your repo, create a new file at `.pypants/targets.py`1. Define a top-level function called `register_extra_targets`. Within that function, instantiate your extra build targets and return a dictionary that maps package name to `BuildTarget`.For example, if you have several Alembic database folders:```python&quot;&quot;&quot;Module that defines extra pypants build targets&quot;&quot;&quot;from typing import Dictfrom pypants.config import PROJECT_CONFIGfrom pypants.build_targets import AlembicMigrationPackagedef register_extra_targets() -&gt; Dict[str, &quot;pypants.build_targets.base.PythonPackage&quot;]:    &quot;&quot;&quot;Register extra targets specific to MyProject&quot;&quot;&quot;    targets = {}    # Register task targets for Alembic database migration targets    #    # * For migrations, this searches db/ looking for eny.py files. If it finds one,    #   it means we've found an Alembic migration folder and can register a build    #   target.    env_py_paths = PROJECT_CONFIG.config_dir_path.joinpath(&quot;db&quot;).glob(&quot;**/env.py&quot;)    for env_py_path in env_py_paths:        alias = env_py_path.parent.name.replace(&quot;_db&quot;, &quot;&quot;).replace(&quot;_&quot;, &quot;-&quot;)        package_name = f&quot;migrations-{alias}&quot;        target = AlembicMigrationPackage(            target_type=&quot;code&quot;,            build_template=&quot;migration&quot;,            top_dir_name=&quot;db&quot;,            package_dir_name=env_py_path.parent.name,            package_path=str(env_py_path.parent),            package_name=package_name,            build_dir=str(env_py_path.parent),            extra_tags={&quot;migration&quot;},        )        targets[package_name] = target    return targets```### Package GeneratorsThe `generate-package` command can be used to create a new package on disk. It sources package &quot;generators&quot; (folders that define the package boilerplate) from the `.pypants/generators` folder in your repo. To create a new package generator, copy one of the folders from [`examples/generators/`](examples/generators/) to `&lt;your repo&gt;/.pypants/generators/&lt;name&gt;` and modify it as needed. The generators use a tool called [cookiecutter](https://github.com/cookiecutter/cookiecutter) to rendere templates.## DevelopmentIf you're working on pypants locally and want to test out how your changes impact your target project:1. Activate the virtualenv for your target project1. Install flit: `pip install flit`1. Keeping your virtualenv activated, install pypants via `cd /path/to/pypants/repo &amp;&amp; flit install -s`</longdescription>
</pkgmetadata>