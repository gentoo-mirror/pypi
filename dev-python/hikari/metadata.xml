<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;div align=&quot;center&quot;&gt;&lt;h1&gt;hikari&lt;/h1&gt;&lt;a href=&quot;https://pypi.org/project/hikari&quot;&gt;&lt;img height=&quot;20&quot; alt=&quot;Supported python versions&quot; src=&quot;https://img.shields.io/pypi/pyversions/hikari&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://pypi.org/project/hikari&quot;&gt;&lt;img height=&quot;20&quot; alt=&quot;PyPI version&quot; src=&quot;https://img.shields.io/pypi/v/hikari&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/hikari-py/hikari/actions&quot;&gt;&lt;img height=&quot;20&quot; alt=&quot;CI status&quot; src=&quot;https://github.com/hikari-py/hikari/actions/workflows/ci.yml/badge.svg?branch=master&amp;event=push&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://pypi.org/project/mypy/&quot;&gt;&lt;img height=&quot;20&quot; alt=&quot;Mypy badge&quot; src=&quot;https://img.shields.io/badge/mypy-checked-blue&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://pypi.org/project/black&quot;&gt;&lt;img height=&quot;20&quot; alt=&quot;Black badge&quot; src=&quot;https://img.shields.io/badge/code%20style-black-000000.svg&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeclimate.com/github/hikari-py/hikari/test_coverage&quot;&gt;&lt;img height=&quot;20&quot; alt=&quot;Test coverage&quot; src=&quot;https://api.codeclimate.com/v1/badges/f95070b25136a69b0589/test_coverage&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://discord.gg/Jx4cNGG&quot;&gt;&lt;img height=&quot;20&quot; alt=&quot;Discord invite&quot; src=&quot;https://discord.com/api/guilds/574921006817476608/widget.png&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.hikari-py.dev/en/stable&quot;&gt;&lt;img height=&quot;20&quot; alt=&quot;Documentation Status&quot; src=&quot;https://readthedocs.org/projects/hikari-py/badge/?version=latest&quot;&gt;&lt;/a&gt;&lt;/div&gt;An opinionated, static typed Discord microframework for Python3 and asyncio that supports Discord's v10 REST andGateway APIs.Built on good intentions and the hope that it will be extendable and reusable, rather than an obstacle for futuredevelopment.Python 3.8, 3.9, 3.10 and 3.11 are currently supported.## InstallationInstall Hikari from PyPI with the following command:```bashpython -m pip install -U hikari# Windows users may need to run this instead...py -3 -m pip install -U hikari```----## BotsHikari provides two different default bot implementations to suit your needs:- [GatewayBot](#gatewaybot)- [RESTBot](#restbot)### GatewayBotA [`GatewayBot`](https://docs.hikari-py.dev/en/stable/reference/hikari/impl/bot/#hikari.impl.bot.GatewayBot)is one which will connect to Discord through the gateway and receiveevents through there. A simple startup example could be the following:```pyimport hikaribot = hikari.GatewayBot(token=&quot;...&quot;)@bot.listen()async def ping(event: hikari.GuildMessageCreateEvent) -&gt; None:    &quot;&quot;&quot;If a non-bot user mentions your bot, respond with 'Pong!'.&quot;&quot;&quot;    # Do not respond to bots nor webhooks pinging us, only user accounts    if not event.is_human:        return    me = bot.get_me()    if me.id in event.message.user_mentions_ids:        await event.message.respond(&quot;Pong!&quot;)bot.run()```This will only respond to messages created in guilds. You can use `DMMessageCreateEvent` instead to only listen onDMs, or `MessageCreateEvent` to listen to both DMs and guild-based messages. A full list of eventscan be found in the [events docs](https://docs.hikari-py.dev/en/stable/reference/hikari/events/).If you wish to customize the intents being used in order to change which events your bot is notified about, then youcan pass the `intents` kwarg to the `GatewayBot` constructor:```pyimport hikari# the default is to enable all unprivileged intents (all events that do not target the# presence, activity of a specific member nor message content).bot = hikari.GatewayBot(intents=hikari.Intents.ALL, token=&quot;...&quot;)```The above example would enable all intents, thus enabling events relating to member presences to be received(you'd need to whitelist your application first to be able to start the bot if you do this).Events are determined by the type annotation on the event parameter, or alternatively as a type passed to the`@bot.listen()` decorator, if you do not want to use type hints.```pyimport hikaribot = hikari.GatewayBot(&quot;...&quot;)@bot.listen()async def ping(event: hikari.MessageCreateEvent):    ...# or@bot.listen(hikari.MessageCreateEvent)async def ping(event):    ...```### RESTBotA [`RESTBot`](https://docs.hikari-py.dev/en/stable/reference/hikari/impl/rest_bot/#hikari.impl.rest_bot.RESTBot)spawns an interaction server to which Discord will **only** send interaction events,which can be handled and responded to.An example of a simple `RESTBot` could be the following:```pyimport asyncioimport hikari# This function will handle the interactions receivedasync def handle_command(interaction: hikari.CommandInteraction):    # Create an initial response to be able to take longer to respond    yield interaction.build_deferred_response()    await asyncio.sleep(5)    # Edit the initial response    await interaction.edit_initial_response(&quot;Edit after 5 seconds!&quot;)# Register the commands on startup.## Note that this is not a nice way to manage this, as it is quite spammy# to do it every time the bot is started. You can either use a command handler# or only run this code in a script using `RESTApp` or add checks to not update# the commands if there were no changesasync def create_commands(bot: hikari.RESTBot):    application = await bot.rest.fetch_application()    await bot.rest.set_application_commands(        application=application.id,        commands=[            bot.rest.slash_command_builder(&quot;test&quot;, &quot;My first test command!&quot;),        ],    )bot = hikari.RESTBot(    token=&quot;...&quot;,    token_type=&quot;...&quot;,    public_key=&quot;...&quot;,)bot.add_startup_callback(create_commands)bot.set_listener(hikari.CommandInteraction, handle_command)bot.run()```Unlike `GatewayBot`, registering listeners is done through `.set_listener`, and it takes in an interaction typethat the handler will take in.Note that a bit of a setup is required to get the above code to work. You will need to host the project tothe World Wide Web (scary!) and then register the URL on the [Discord application portal](https://discord.com/developers/applications)for your application under &quot;Interactions Endpoint URL&quot;.A quick way you can get your bot onto the internet and reachable by Discord (**for development environment only**) isthrough a tool like [ngrok](https://ngrok.com/) or [localhost.run](https://localhost.run/). More information on how touse them can be found in their respective websites.### Common helpful featuresBoth implementations take in helpful arguments such as [customizing timeouts for requests](https://docs.hikari-py.dev/en/stable/reference/hikari/impl/config/#hikari.impl.config.HTTPSettings.timeouts)and [enabling a proxy](https://docs.hikari-py.dev/en/stable/reference/hikari/impl/config/#hikari.impl.config.ProxySettings),which are passed directly into the bot during initialization.Also note that you could pass extra options to `bot.run` during development, for example:```pyimport hikaribot = hikari.GatewayBot(&quot;...&quot;)# orbot = hikari.RESTBot(&quot;...&quot;, &quot;...&quot;)bot.run(    asyncio_debug=True,             # enable asyncio debug to detect blocking and slow code.    coroutine_tracking_depth=20,    # enable tracking of coroutines, makes some asyncio                                    # errors clearer.    propagate_interrupts=True,      # Any OS interrupts get rethrown as errors.)```Many other helpful options exist for you to take advantage of if you wish. Links to the respective docs can be seenbelow:- [GatewayBot.run](https://docs.hikari-py.dev/en/stable/reference/hikari/impl/bot/#hikari.impl.bot.GatewayBot.run)- [RESTBot.run](https://docs.hikari-py.dev/en/stable/reference/hikari/impl/rest_bot/#hikari.impl.rest_bot.RESTBot.run)---## REST-only applicationsYou may only want to integrate with the REST API, for example if writing a web dashboard.This is relatively simple to do:```pyimport hikariimport asynciorest = hikari.RESTApp()async def print_my_user(token):    await rest.start()      # We acquire a client with a given token. This allows one REST app instance    # with one internal connection pool to be reused.    async with rest.acquire(token) as client:        my_user = await client.fetch_my_user()        print(my_user)    await rest.close()        asyncio.run(print_my_user(&quot;user token acquired through OAuth here&quot;))```---## Optional FeaturesOptional features can be specified when installing hikari:* `server` - Install dependencies required to enable Hikari's standard interaction server (RESTBot) functionality.* `speedups` - Detailed in [`hikari[speedups]`](#hikarispeedups).Example:```bash# To install hikari with the speedups feature:python -m pip install -U hikari[speedups]# To install hikari with both the speedups and server features:python -m pip install -U hikari[speedups, server]```## Additional resourcesYou may wish to use a command framework on top of Hikari so that you can start writing a bot quickly withoutimplementing your own command handler.Hikari does not include a command framework by default, so you will want to pick a third party library to do it:- [`lightbulb`](https://github.com/tandemdude/hikari-lightbulb) - a simple and easy to use command framework for Hikari.- [`tanjun`](https://github.com/FasterSpeeding/Tanjun) - a flexible command framework designed to extend Hikari.- [`crescent`](https://github.com/magpie-dev/hikari-crescent) - a command handler for Hikari that keeps your project neat and tidy.---## Making your application more efficientAs your application scales, you may need to adjust some things to keep it performing nicely.### Python optimization flagsCPython provides two optimization flags that remove internal safety checks that are useful for development, and changeother internal settings in the interpreter.- `python bot.py` - no optimization - this is the default.- `python -O bot.py` - first level optimization - features such as internal assertions will be disabled.- `python -OO bot.py` - second level optimization - more features (**including all docstrings**) will be removed from  the loaded code at runtime.**A minimum of first level of optimization** is recommended when running bots in a production environment.### `hikari[speedups]`If you have a C compiler (Microsoft VC++ Redistributable 14.0 or newer, or a modern copy of GCC/G++, Clang, etc), it isrecommended you install Hikari using `pip install -U hikari[speedups]`. This will install `aiohttp` with its availablespeedups, `ciso8601` and `orjson` which will provide you with a substantial performance boost.### `uvloop`**If you use a UNIX-like system**, you will get additional performance benefits from using a library called `uvloop`.This replaces the default `asyncio` event loop with one that uses `libuv` internally. You can run `pip install uvloop`and then amend your script to be something similar to the following example to utilise it in your application:```pyimport osif os.name != &quot;nt&quot;:    import uvloop    uvloop.install()# Your code goes here```### Compiled extensionsEventually, we will start providing the option to use compiled components of this library over pure Python ones if itsuits your use case. This should also enable further scalability of your application, should[_PEP 554 -- Multiple Interpreters in the Stdlib_](https://www.python.org/dev/peps/pep-0554/#abstract) be accepted.Currently, this functionality does not yet exist.---## Developing HikariTo familiarize yourself a bit with the project, we recommend reading our[contributing manual](https://github.com/hikari-py/hikari/blob/master/CONTRIBUTING.md).If you wish to contribute something, you should first start by cloning the repository.In the repository, make a virtual environment (`python -m venv .venv`) and enter it (`source .venv/bin/activate` onLinux, or for Windows use one of `.venv\Scripts\activate.ps1`, `.venv\Scripts\activate.bat`,`source .venv/Scripts/activate`).The first thing you should run is `pip install -r dev-requirements.txt` to install nox.This handles running predefined tasks and pipelines.Once this is complete, you can run `nox` without any arguments to ensure everything builds and is correct.### Where can I start?Check out the issues tab on GitHub. If you are nervous, look for issues marked as &quot;good first issue&quot; for somethingeasy to start with![![good-first-issues](https://img.shields.io/github/issues/hikari-py/hikari/good%20first%20issue)](https://github.com/hikari-py/hikari/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22)Feel free to also join our [Discord](https://discord.gg/Jx4cNGG) to directly ask questions to the maintainers! They willbe glad to help you out and point you in the right direction.</longdescription>
</pkgmetadata>