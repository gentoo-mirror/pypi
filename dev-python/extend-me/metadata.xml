<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://gitlab.com/katyukha/extend-me/badges/master/pipeline.svg    :target: https://gitlab.com/katyukha/extend-me/-/commits/master.. image:: https://coveralls.io/repos/katyukha/extend-me/badge.png    :target: https://coveralls.io/r/katyukha/extend-me.. image:: https://img.shields.io/badge/docs-passing-brightgreen.svg    :target: https://katyukha.gitlab.io/extend-me/    .. image:: https://img.shields.io/pypi/dm/extend-me.svg    :target: https://pypi.org/project/extend_me/    :alt: PyPI - DownloadsExtend Me - Class based extension/plugin library================================================This module provides mechanism of extension of your applicationbased on 'extension via inheritance'. Under this words I meanability to define new extensions of application objects simplyby subclassing of extensible classes of app.For example we have app with class 'Worker' which we would liketo make extensible (allowing third party modules to extend orchange its behavior). Thinking strait, there are a lot of workto be done, to impelement mechanism of loading, registering,end enabling extension, with lot of glue code, which must definesome entry points to connect extension and main app. But why notmake it simpler, supposing that any subclass of 'Worker' willextend it? And this module provides implementation of thisin two ways:- Explicit (by using metaclass *ExtensibleType* directly)    - When using this way You will heve seperatly Base class      to be subclassed by extension classes and class getter      which will construct class based on all defined extensions      using multiple inhertance- Implicit (by using Extensible class which use metaclass magic implicitly)    - *Extensible* class takes care of all metaclass magic        related to generation objects of correct classHow it Works------------Metaclass (*ExtensibleType*) tracks all subclasses of class itis applied to, and provides method to build class based on allsubclasses of base class, thus using all functionality of allsubclasses. Thus generation of correct class is separate processwhich should be used everywhere where extensible class is requred.To simplify this class *Extensible* was implemented. It has redefinedmethod *__new__* which automaticaly creates instances of correct class(class that inherited from base class and all its extensions')Examples--------ExtensibleType~~~~~~~~~~~~~~At the begining we should create a metaclass that will automaticalygether all information about all extensions, and apply this metaclassto class we would like to enable extensions for::    &gt;&gt;&gt; import six  # Used for Python 2/3 compatability    &gt;&gt;&gt; mc = ExtensibleType._(&quot;Object&quot;)    &gt;&gt;&gt; @six.add_metaclass(mc)    ... class Object(object):    ...     passNot method *_* of *ExtensibleType*. This method is used to create metaclassfor specific object. It receives one argument - string that will be used asname of class generated by this metaclassNext we may define extension for this class. It is very simple.Just subclass previously defined class::    &gt;&gt;&gt; class ObjectExtension(Object):    ...     cool_attribute = 1    ...     def method1(self):    ...         return &quot;Test&quot;So... at this momet we have base class and extension. And here is thatcore magic occures. Metaclass that was created at the begining automaticalycollects all subclasses of base class. So it is posible now to create newclass that is subclass of all subclasses of base class using multiple inheritance.And metaclass *mc* will do it for You::    &gt;&gt;&gt; cls = mc.get_class()And now You can use cls for Your needs, instead of base class.It can do all that base class can, and all that extensions can::    &gt;&gt;&gt; obj = cls()    &gt;&gt;&gt; obj.method1()    'Test'    &gt;&gt;&gt; obj.cool_attribute    1ExtensibleByHashType~~~~~~~~~~~~~~~~~~~~Same as *ExtensibleType*, but allows to build tree of classesfor diferent names (types). Just look examples below.First, create metaclass that will specify inheritance rules::    &gt;&gt;&gt; import six  # Used for Python 2/3 compatability    &gt;&gt;&gt; mc = ExtensibleByHashType._(&quot;Connector&quot;, hashattr='name')Here we see aditional parametr in _ method: ``hashattr='name'``which describes what meta attribute will be used as key(hash).Next step - we have to create Base class with this metaclass.As example we will look into connection classes of *openerp_proxy* project::    &gt;&gt;&gt; @six.add_metaclass(mc)    ... class ConnectorBase(object):    ...     # Base class for all connectors    ...    ...     def __init__(self, host, port, verbose=False):    ...         self.host = host    ...         self.port = port    ...         self.verbose = verbose    ...    ...     def _get_service(self, name):    ...         raise NotImplementedError    ...    ...     def get_service(self, name):    ...         # Returns service for specified *name*    ...         return self._get_service(name)Base class describes only interface, and may be some part of abstract logicAnd as next step we will extend it in diferent ways to support differentconnection types::    &gt;&gt;&gt; class ConnectorXMLRPC(ConnectorBase):    ...     # XML-RPC connector    ...     class Meta:    ...         name = 'xml-rpc' # remember definition of metaclass?    ...                          # this attribute is used as hash(key)    ...                          # to unique identify each banch of extensions    ...                          # of base class    ...    ...     def __init__(self, *args, **kwargs):    ...         super(ConnectorXMLRPC, self).__init__(*args, **kwargs)    ...         self.__services = {}    ...    ...     def get_service_url(self, service_name):    ...         return 'http://%s:%s/xmlrpc/%s' % (self.host, self.port, service_name)    ...    ...     def _get_service(self, name):    ...         service = self.__services.get(name, False)    ...         if service is False:    ...             service = XMLRPCProxy(self.get_service_url(name), verbose=self.verbose)    ...             self.__services[name] = service    ...         return service    ...    ...    ... # Pay attention on base class.    &gt;&gt;&gt; class ConnectorXMLRPCS(ConnectorXMLRPC):    ...     # XML-RPCS Connector    ...     class Meta:    ...         name = 'xml-rpcs'    ...    ...     def get_service_url(self, service_name):    ...         return 'https://%s:%s/xmlrpc/%s' % (self.host, self.port, service_name)Code above creates two connectors: one for *XML-RPC* and one for *XML-RPCS*.Each of connectors may be extended by simple inheritance. And if required anyextension may define new branch(key)(hash) as wee see in example above.To use this connector *mc* has method *get_class(name[, default=False])*wich will return class generated for hash=*name*::    &gt;&gt;&gt; cls = mc.get_class('xml-rpc')    &gt;&gt;&gt; [b.__name__ for b in cls.__bases__]    ['ConnectorXMLRPC', 'ConnectorBase']    &gt;&gt;&gt; cls.__name__    'Connector'    &gt;&gt;&gt; cls = mc.get_class('xml-rpcs')    &gt;&gt;&gt; [b.__name__ for b in cls.__bases__]    ['ConnectorXMLRPCS', 'ConnectorBase']    &gt;&gt;&gt; cls.__name__    'Connector'Example above shows what classes will be generated for specified names.By default, if *mc.get_class* called with unregistered name(No extension with ``Meta.name == name`` defined) it will raise *ValueError*If You want to allow creating of classes with not *Meta.name* defined,just pass ``default=True`` to *mc.get_class*::    &gt;&gt;&gt; cls = mc.get_class('unexisting-protocol', default=True)    &gt;&gt;&gt; [b.__name__ for b in cls.__bases__]    ['ConnectorBase']    &gt;&gt;&gt; cls.__name__    'Connector'Extensible~~~~~~~~~~This class provides one more level of abstraction, allowing to hide all metaclass magicbehide the scene. So, using it You don't need to worry about metaclasses and classcreation process. Just inherit extensions form base class, and use in Your programinstances of base class. Let's see it in example::    &gt;&gt;&gt; class MyCoolClass(Extensible):    ...     my_attr_1 = 25    ...     def my_method1(self, arg1):    ...         print('Hello, %s' % arg1)    &gt;&gt;&gt; class MyCoolClassExtension1(MyCoolClass):    ...     def my_method1(self, arg1):    ...         super(MyCoolClassExtension1, self).my_method1(arg1.upper())    ...    ...     def my_method2(self, arg1):    ...         print(&quot;Good by, %s&quot; % arg1)And now using simply instances of base class You have all abilities that provided by extensions::    &gt;&gt;&gt; my_cool_obj = MyCoolClass()    &gt;&gt;&gt; print(my_cool_obj.my_attr_1)    25    &gt;&gt;&gt; my_cool_obj.my_method1('World')    Hello, WORLD    &gt;&gt;&gt; my_cool_obj.my_method2('World')    Good by, World</longdescription>
</pkgmetadata>