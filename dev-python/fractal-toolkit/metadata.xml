<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Fractal&gt; Fractal is a scaffolding toolkit for building SOLID logic for your Python applications.[![PyPI Version][pypi-image]][pypi-url][![Build Status][build-image]][build-url][![Code Coverage][coverage-image]][coverage-url][![Code Quality][quality-image]][quality-url]&lt;!-- Badges --&gt;[pypi-image]: https://img.shields.io/pypi/v/fractal-toolkit[pypi-url]: https://pypi.org/project/fractal-toolkit/[build-image]: https://github.com/douwevandermeij/fractal/actions/workflows/build.yml/badge.svg[build-url]: https://github.com/douwevandermeij/fractal/actions/workflows/build.yml[coverage-image]: https://codecov.io/gh/douwevandermeij/fractal/branch/master/graph/badge.svg[coverage-url]: https://codecov.io/gh/douwevandermeij/fractal[quality-image]: https://api.codeclimate.com/v1/badges/55adbc041d119d371ef7/maintainability[quality-url]: https://codeclimate.com/github/douwevandermeij/fractal## Installation```shpip install fractal-toolkit```## Usage* Fractal can be used inside large Python applications to isolate certain (logical related) behaviour from the rest ofthe application.* Fractal is ideal for refactoring large applications into smaller parts* Fractal applications by design are microservices  * Just wrap the app in an HTTP framework (like FastAPI, see contrib module) and expose with Docker  * Other usages apart from HTTP (and Docker) are also possible    * Like subscribing to a data stream or pub/sub channel## ArchitectureApplications that use Fractal can be built in many ways, including a non-SOLID architecture.The Fractal toolkit tries to make it easier to go for the SOLID approach.To start a Fractal project, the first class to make derives from `fractal.Fractal`.It should provide a `fractal.core.utils.settings.Settings` object and a`fractal.core.utils.application_context.ApplicationContext` object, which should also be derived from.The `Settings` class provides all static configuration for the application; it's the place where environment variablesare loaded. The class creates a singleton object.The `Context` class provides the dynamic configuration of the application, using the `Settings` object.In the `Context` all dependencies will be injected.### Hexagonal Architecture (ports and adapters)In Hexagonal Architecture, together with Domain Driven Design principles, the core of the application, is the boundedcontext containing the domain objects (entities, repositories, services, etc.) but without specific implementationdetails. Just the domain logic. From now on we call the core the domain.This is (loosely) enforced by not allowing dependencies to external packages inside the domain.This, in turn, is the _dependency inversion principle_ of SOLID.The repositories and services inside the domain are interfaces or abstract classes. These are known as ports.Next to the domain there are the adapters. Each interface or port needs an adapter to function at runtime. Adapters areallowed to depend on external packages.At runtime, in the application `Context`, based on `Settings`, the appropriate adapter will be set for each port.### Basic application structureA typical application folder structure using Fractal looks like:    app/    ├── adapters/    │   ├── __init__.py    │   └── products.py    ├── domain/    │   ├── __init__.py    │   └── products.py    ├── context.py    ├── main.py    └── settings.pyWith this, a fully functional Fractal application can be built having a Python interface. That is, the logic of theapplication can only be reached by invoking methods on Python level.Such Fractal applications might be used as part of larger (Python) applications to isolate or encapsulate certainbehaviour. The larger application itself can also be a Fractal application, and so on. Hence the name: Fractal.While using Fractal as a way to have separation of concerns with separate isolated bounded contexts in Pythonapplications, it's also possible to wrap Fractal in a small application and expose as REST API using, for example,FastAPI, Flask or Django. Next that application can be deployed again in a Docker environment. This makes Fractal aperfect fit for microservices as well.As a rule of thumb, continuing on the separation of concerns, the folder/file structure inside a Fractal applicationshould follow the naming of the subject (rather than the naming of the responsibilities of module).In the example app this is denoted by `products.py` in both the `domain` folder as the `adapters` folder.When the file is getting too big to be easily readable or maintainable, it can be converted into a package.Within the package the files can be named by their responsibilities.An example package folder structure:    app/    ├── adapters/    │   └── products/    │       ├── __init__.py    │       ├── django.py    │       └── fastapi.py    ├── domain/    │   └── products/    │       ├── __init__.py    │       ├── commands/    │       │   ├── __init__.py    │       │   └── add.py    │       └── events.py    ├── context.py    ├── main.py    └── settings.pyAs can be seen in the example package folder structure, in the `domain` the package contains files about certainactions or responsibilities andf in the `adapters` folder it's more about the target implementation.Of course the target implementation file can be converted into a package again and contain files for certainresponsibilities again.#### Example file contents##### main.py```pythonfrom fractal import Fractalfrom app.context import ApplicationContextfrom app.settings import Settingsclass ApplicationFractal(Fractal):    settings = Settings()    context = ApplicationContext()```##### settings.py```pythonimport osfrom fractal.core.utils.settings import Settings as BaseSettingsclass Settings(BaseSettings):    BASE_DIR = os.path.dirname(__file__)    ROOT_DIR = os.path.dirname(os.path.dirname(BASE_DIR))    APP_NAME = os.getenv(&quot;APP_NAME&quot;, &quot;product_system&quot;)    def load(self):        self.PRODUCT_REPOSITORY_BACKEND = os.getenv(&quot;PRODUCT_REPOSITORY_BACKEND&quot;, &quot;&quot;)```##### context.py```pythonfrom fractal.core.utils.application_context import ApplicationContext as BaseContextfrom app.settings import Settingsclass ApplicationContext(BaseContext):    def load_repositories(self):        from app.domain.products import ProductRepository        if Settings().PRODUCT_REPOSITORY_BACKEND == &quot;sql&quot;:            '''example: some sql adapter code'''        elif Settings().PRODUCT_REPOSITORY_BACKEND == &quot;file&quot;:            '''example: some file adapter code'''        else:            from app.adapters.products import InMemoryProductRepository            self.product_repository: ProductRepository = self.install_repository(                InMemoryProductRepository(),            )```##### domain/products.py```pythonfrom abc import ABCfrom dataclasses import dataclassfrom fractal.core.models import Modelfrom fractal.core.repositories import Repository@dataclassclass Product(Model):    id: str    name: strclass ProductRepository(Repository[Product], ABC):    pass```##### adapters/products.py```pythonfrom fractal.core.repositories.inmemory_repository_mixin import InMemoryRepositoryMixinfrom app.domain.products import Product, ProductRepositoryclass InMemoryProductRepository(ProductRepository, InMemoryRepositoryMixin[Product]):    pass```## Advanced features### Command bus patternA command is a container to invoke actions in the domain, from inside and outside of the domain.A command has a one-to-one relation with a command handler.The command handler can be seen as a single transaction, e.g., to a database.The code in the command handler should just be doing just the things that are necessary to be inside the transaction.Transactions can fail, so it's important to prevent side effects from happening and include only the code that needs togo in the same transaction and thus will be rolled back as a whole in case the transaction fails.Secondary actions that need to take place _after_ the action has been done, should be outside of scope of the commandhandler.After a command handler has been completed successfully, that is, when the transaction is persisted, an event can bepublished. This event is the trigger for all secondary actions, which in turn can be commands again.#### Example file contentsThe affected files in the folder structure:    app/    └── domain/    │   └── products/    │       └── commands.py    └── context.py##### commands.pyWithout publishing events:```pythonfrom dataclasses import dataclassfrom fractal.core.command_bus.command_handler import CommandHandlerfrom fractal.core.command_bus.commands import AddEntityCommandfrom app.context import ApplicationContextfrom app.domain.products import Product, ProductRepository@dataclassclass AddProductCommand(AddEntityCommand[Product]):    passclass AddProductCommandHandler(CommandHandler):    command = AddProductCommand    def __init__(        self,        product_repository: ProductRepository,    ):        self.product_repository = product_repository    @staticmethod    def install(context: ApplicationContext):        context.command_bus.add_handler(            AddProductCommandHandler(                context.product_repository,            )        )    def handle(self, command: AddProductCommand):        self.product_repository.add(command.entity)```##### context.py```pythonfrom fractal.core.utils.application_context import ApplicationContext as BaseContextclass ApplicationContext(BaseContext):    ...    def load_command_bus(self):        super(ApplicationContext, self).load_command_bus()        from app.domain.products.commands import AddProductCommandHandler        AddProductCommandHandler.install(self)```### Event publishingWhen an event gets published, the `EventPublisher` will iterate over its registered projectors (`EventProjector`).Each projector will be invoked with the event as a parameter.Projectors can do anything:- printing the event to the console- populating a repository  - like an event store  - or a read optimized view- invoking a new command- sending the event to an external service, which may:  - invoke a new command  - send an emailEach projector should only be doing one thing.The relation between an event and a projector is one-to-many.**!! CAVEAT !!**When using events, and especially when sending events to an external service, be aware that these other services mighthave a dependency on the structure of the event.Changing existing events is **dangerous**.The best approach here is to apply the _open-closed principle_ of SOLID, open for extension, closed for modification.Alternatively creating a new event is also possible.#### Example file contentsThe affected files in the folder structure, on top of the command bus pattern code:    app/    └── domain/    │   └── products/    │       ├── commands.py    │       └── events.py    └── context.py##### commands.py```pythonfrom dataclasses import dataclassfrom datetime import datetimefrom fractal.core.command_bus.command_handler import CommandHandlerfrom fractal.core.command_bus.commands import AddEntityCommandfrom fractal.core.event_sourcing.event_publisher import EventPublisherfrom app.context import ApplicationContextfrom app.domain.products import Product, ProductRepositoryfrom app.domain.products.events import ProductAddedEvent@dataclassclass AddProductCommand(AddEntityCommand[Product]):    user_id: strclass AddProductCommandHandler(CommandHandler):    command = AddProductCommand    def __init__(        self,        event_publisher: EventPublisher,        product_repository: ProductRepository,    ):        self.event_publisher = event_publisher        self.product_repository = product_repository    @staticmethod    def install(context: ApplicationContext):        context.command_bus.add_handler(            AddProductCommandHandler(                context.event_publisher,                context.product_repository,            )        )    def handle(self, command: AddProductCommand):        event = ProductAddedEvent(            id=command.entity.id,            name=command.entity.name,            created_by=command.user_id,            created_on=datetime.utcnow(),        )        self.product_repository.add(command.entity)        self.event_publisher.publish_event(event)```##### events.py```pythonfrom dataclasses import dataclassfrom datetime import datetimefrom typing import Callable, Dict, List, Typefrom fractal.core.command_bus.command import Commandfrom fractal.core.event_sourcing.event import (    BasicSendingEvent,    Event,    EventCommandMapper,)@dataclassclass ProductEvent(BasicSendingEvent):    id: str    @property    def object_id(self):        return self.id    @property    def aggregate_root_id(self):        return self.id@dataclassclass ProductAddedEvent(ProductEvent):    name: str    created_by: str    created_on: datetimeclass ProductEventCommandMapper(EventCommandMapper):    def mappers(self) -&gt; Dict[Type[Event], List[Callable[[Event], Command]]]:        return {            # example:            # ProductAddedEvent: [            #     lambda event: SomeCommand(...)            # ],        }```##### context.py```pythonfrom fractal.core.utils.application_context import ApplicationContext as BaseContextclass ApplicationContext(BaseContext):    ...    def load_event_projectors(self):        from fractal.core.event_sourcing.projectors.command_bus_projector import (            CommandBusProjector,        )        from app.domain.products.events import ProductEventCommandMapper        self.command_bus_projector = CommandBusProjector(            lambda: self.command_bus,            [                ProductEventCommandMapper(),            ],        )        from fractal.core.event_sourcing.projectors.print_projector import (            PrintEventProjector,        )        return [            self.command_bus_projector,            PrintEventProjector(),        ]```### Eventual consistencyTODO### Event sourcingTODO### Specification patternTODO### FastAPI + DockerTODORequest contract, together with URI parameters and authentication token payload can be processed by the applicationby using the command bus. The command can ingest the separate variables and/or domain objects (entities).Response contract might be different from the domain object that is affected by the request.### AuthenticationTODO</longdescription>
</pkgmetadata>