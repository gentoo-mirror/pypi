<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Caching results of functions in Python======================================.. image:: https://travis-ci.com/scidam/cachepy.svg?branch=master    :target: https://travis-ci.com/scidam/cachepyA caching toolset for Python. It is tested for bothPython 2.7.x and 3.4+ (&lt;3.10).Features--------    * Memory-based and file-based caches;    * Ability to set the TTL (time-to-live) and NOC (the number of calls) on caches;    * Encryption of the cached data (symmetric encryption algorithm (RSA) is used);    * LFU (least frequently used) and MFU (most frequently used) cache-clearing strategies;    * caches of limited size;Notes-----    - Encryption functionality requires the `PyCryptodome` package to be installed;    - File-based caches save the cached data in a file; files with cached data should be      cleaned up manually, if needed.Examples--------.. code-block:: python    from cachepy import *    mycache = Cache()    # save the cached data to memory without encryption    @mycache    def my_heavy_function(x):        '''Performs heavy computations'''        print('Hi, I was invoked...')        return x**2    my_heavy_function(2)    # &quot;Hi, I was invoked...&quot; will be printed to stdout only once    # return 4    my_heavy_function(2)    # return 4To store data to a file, one needs to initialize a decorator, as follows:.. code-block:: python    # create cache-to-file decorator    filecache = FileCache('mycache')  # mycache.dat file will be created;    # `.dat` extension is appended automatically to the filename    # (depends on the shelve module implementation);Its behavior is the same as a memory-based one, but all cached data is stored inthe specified file.One can set up time-to-live (TTL) and/or maximum number of calls (NOC)for the cached data when the decorator is initialized:.. code-block:: python    import time    from cachepy import *    cache_with_ttl = Cache(ttl=2)  # ttl given in seconds    @cache_with_ttl    def my_heavy_function(x):        '''Performs heavy computations'''        print('Hi, I was invoked...')        return x**2    my_heavy_function(3)    # Hi, I was invoked... will be printed    # return 9    my_heavy_function(3)    # 'Hi, I was invoked ...' will not be printed    # return 9    time.sleep(2)    my_heavy_function(3)    # 'Hi, I was invoked ...' will be printed again    # return 9.. code-block:: python    cache_with_noc = Cache(noc=2)  # the number-of-calls: noc = 2    @cache_with_noc    def my_heavy_function(x):        '''Performs heavy computations'''        print('Hi, I was invoked...')        return x**2    my_heavy_function(3)    my_heavy_function(3) # 'Hi, I was invoked ...' will not be printed    my_heavy_function(3) # 'Hi, I was invoked ...' will be printed againIt is easy to use both `NOC` and `TTL` arguments when defininga caching decorator:.. code-block:: python    cache_with_noc_ttl = Cache(noc=2, ttl=1)    @cache_with_noc_ttl    def my_heavy_function(x):        '''Performs heavy computations'''        print('Hi, I was invoked...')        return x**2    my_heavy_function(3)    my_heavy_function(3)  # 'Hi, I was invoked ...' will not be printed    my_heavy_function(3)  # 'Hi, I was invoked ...' will be printed (noc is    # reached, recompute the func value)    time.sleep(2)  # get ttl expired    my_heavy_function(3) # 'Hi, I was invoked ...' will be printed againOne can encrypt the cached data by providing a non-empty `key` argument asa password (RSA encryption algorithm is used):.. code-block:: python    cache_to_file_ttl_noc = FileCache('mycache',                                      noc=2, ttl = 2,                                      key='mypassword')    @cache_to_file_ttl_noc    def my_heavy_function(x):        '''Performs heavy computations'''        print('Hi, I was invoked...')        return x**2    my_heavy_function(2) # 'Hi, I was invoked...' will be printed    my_heavy_function(2) # 'Hi, I was invoked...' will not be printedWhen `my_heavy_function` is decorated by `cache_to_file_ttl_noc`, as shownin the example above, the value `2**2 = 4` will be computed and the result ofthe computation will be stored in the file named `mycache.dat`. Alongwith the result of the computation,  additional information will be storedin the file `mycache.dat`. The additional information includes:1) the result's expiration time (computed from the TTL),2) NOC and 3) the number of already performed calls of the function beingdecorated (`my_heavy_function`).Encryption is available only if `PyCryptodome` package is installed and the`key` parameter (a non-empty string representing the password) is passed to thecache constructor. It also could work with the old PyCrypto package.If you passed the non-empty `key` parameter to the cache constructorbut `PyCryptodome` was not found, a special warning would be raised in this case(&quot;PyCryptodome not installed. Data will not be encrypted&quot;) andthe cache would work as usual but without encryption functionality.Caching with limitations------------------------Standard cache constructors are used to initialize caches of unlimited capacity.There are also caches of limited capacity.Such caches are initialized by constructors named `LimitedCache` and `LimitedFileCache`.These constructors have additionalparameters `cache_size` (the maximum number of items stored in the cache) and`algorithm` (cache-clearing algorithm). Available `algorithm` values are`lfu` (default, which stands for least frequently used) and `mfu` (most frequently used).When `algorithm='lfu'`, then the least frequently used item is removed from the cache,if it is exhausted. In case of `algorithm='mfu'`, everything behaves the same way,with the only difference being that the most frequently used item is removed.Testing-------.. code-block:: bash         python -m  cachepy.testTODO----    * Writing backend for redis serverLog list--------    * Version 1.2 (testing compatibility with Python 3.8 - 3.9)    * Version 1.1    * Version 1.0 (broken installation via pip/pipenv)    * Version 0.1        - initial releaseAuthor------    Dmitry Kislov &lt;kislov@easydan.com&gt;</longdescription>
</pkgmetadata>