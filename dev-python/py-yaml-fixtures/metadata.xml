<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Py YAML FixturesA (*work-in-progress*) library for loading database fixtures written in [Jinja2](http://jinja.pocoo.org/)-templated YAML files. It comes with support for [faker](http://faker.readthedocs.io/en/master/) and relationships between fixture objects. Currently it works with the following packages:- Django 2+- Flask SQLAlchemy- Flask Unchained- Standalone SQLAlchemyRequires **Python 3.5+**## Useful Links* [Fork it on GitHub](https://github.com/briancappello/py-yaml-fixtures)* [Documentation](https://py-yaml-fixtures.readthedocs.io/en/latest/)* [PyPI](https://pypi.org/project/Py-YAML-Fixtures/)```bashpip install py-yaml-fixtures```## Table of Contents* [Fixture File Syntax](https://github.com/briancappello/py-yaml-fixtures#fixture-file-syntax)   * [Relationships](https://github.com/briancappello/py-yaml-fixtures#relationships)* [Faker and Jinja Templating](https://github.com/briancappello/py-yaml-fixtures#faker-and-jinja-templating)* [Installation](https://github.com/briancappello/py-yaml-fixtures#installation)   * [Configuration and Usage](https://github.com/briancappello/py-yaml-fixtures#configuration-and-usage)      * [With Django](https://github.com/briancappello/py-yaml-fixtures#with-django)      * [With Flask and Flask-SQLAlchemy](https://github.com/briancappello/py-yaml-fixtures#with-flask-and-flask-sqlalchemy)      * [With Flask Unchained](https://github.com/briancappello/py-yaml-fixtures#with-flask-unchained)      * [With Standalone SQLAlchemy](https://github.com/briancappello/py-yaml-fixtures#with-standalone-sqlalchemy)* [Known Limitations](https://github.com/briancappello/py-yaml-fixtures#known-limitations)   * [One to Many Relationships](https://github.com/briancappello/py-yaml-fixtures#one-to-many-relationships)   * [Many to Many Relationships](https://github.com/briancappello/py-yaml-fixtures#many-to-many-relationships)   * [Association Proxies](https://github.com/briancappello/py-yaml-fixtures#association-proxies)* [Contributing](https://github.com/briancappello/py-yaml-fixtures#contributing)   * [Adding support for other ORMs](https://github.com/briancappello/py-yaml-fixtures#adding-support-for-other-orms)* [License](https://github.com/briancappello/py-yaml-fixtures#license)## Fixture File SyntaxFirst, let's define some example models to work with:```pythonclass Parent(BaseModel):    __tablename__ = 'parent'    id = sa.Column(sa.Integer, primary_key=True)    name = sa.Column(sa.String)    children = relationship('Child', back_populates='parent')class Child(BaseModel):    __tablename__ = 'child'    id = sa.Column(sa.Integer, primary_key=True)    name = sa.Column(sa.String)    parent_id = sa.Column(sa.Integer, sa.ForeignKey('parent.id'))    parent = relationship('Parent', back_populates='children')```To populate these models with fixtures data, you can either create a single `fixtures.yaml` file in your fixtures directory where the top-level keys are the model class names:```yaml# db/fixtures/fixtures.yamlChild:    alice:        name: Alice    bob:        name: Bob    grace:        name: Grace    judy:        name: JudyParent:    parent1:        name: Parent 1        children: ['Child(alice)', 'Child(bob)']    parent2:        name: Parent 2        children:          - 'Child(grace)'          - 'Child(judy)'```Or you can create YAML files named after each model's class name (`Parent` and `Child` in our case). For example:```yaml# db/fixtures/Child.yamlalice:    name: Alicebob:    name: Bobgrace:    name: Gracejudy:    name: Judy``````yaml# db/fixtures/Parent.yamlparent1:    name: Parent 1    children: ['Child(alice)', 'Child(bob)']parent2:    name: Parent 2    children:        - 'Child(grace)'        - 'Child(judy)'```### RelationshipsThe top-level YAML keys (`alice`, `bob`, `grace`, `judy`, `parent1`, `parent2`) are unique ids used to reference objects in relationships. They must be unique across *all* model fixtures.To reference them, we use an *identifier string*. An identifier string consists of two parts: the class name, and one or more ids. For singular relationships the notation is `'ModelClassName(id)'`. For the many-side of relationships, the notation is the same, just combined with YAML's list syntax:```yaml# db/fixtures/Parent.yamlparent1:  name: Parent 1  children: ['Child(alice)', 'Child(bob)']parent2:  name: Parent 2  children:    - 'Child(grace)'    - 'Child(judy)'# or in short-hand notationparent3:  name: Parent 3  children: ['Child(alice, bob)']# technically, as long as there are at least 2 ids in the identifier string,# then even the YAML list syntax is optional, and you can write stuff like this:parent4:  name: Parent 4  children: Child(alice, bob)# or spanning multiple lines:parent5:  name: Parent 5  children: &gt;    Child(      grace,      judy,    )```## Faker and Jinja TemplatingAll of the YAML fixtures files are rendered by Jinja before getting loaded. This means you have full access to the Jinja environment, and can use things like `faker`, `range` and `random`:```jinja2# db/fixtures/Child.yaml{% for i in range(0, 20) %}child{{ i }}:  name: {{ faker.name() }}{% endfor %}``````jinja2# db/fixtures/Parent.yaml{% for i in range(0, 10) %}parent{{ i }}:  name: {{ faker.name() }}  children: {{ random_models('Child', 0, range(0, 4)|random) }}{% endfor %}```There are also two included Jinja helper functions:* `random_model(model_name: str)`   - For example, to get one random `Child` model: `{{ random_model('Child') }}`* `random_models(model_name: str, min_count: int = 0, max_count: int = 3)`   - For example, to get a list of 0 to 3 `Child` models: `{{ random_models('Child') }}`   - For example, to get a list of 1 to 4 `Child` models: `{{ random_models('Child', 1, 4) }}`## Installation```bash# to use with djangopip install py-yaml-fixtures[django]# to use with flask-sqlalchemypip install py-yaml-fixtures[flask-sqlalchemy]# to use with flask-unchainedpip install py-yaml-fixtures[flask-unchained]# to use with standalone sqlalchemypip install py-yaml-fixtures[sqlalchemy]```### Configuration and Usage* [With Django](https://github.com/briancappello/py-yaml-fixtures#with-django)* [With Flask and Flask-SQLAlchemy](https://github.com/briancappello/py-yaml-fixtures#with-flask-and-flask-sqlalchemy)* [With Flask Unchained](https://github.com/briancappello/py-yaml-fixtures#with-flask-unchained)* [With Standalone SQLAlchemy](https://github.com/briancappello/py-yaml-fixtures#with-standalone-sqlalchemy)#### With DjangoAdd `py_yaml_fixtures` to your `settings.INSTALLED_APPS`.```python# project-root/app/settings.pyINSTALLED_APPS = [   # ...   'py_yaml_fixtures',   'auth',   'blog',   'app',]```The `py_yaml_fixtures` app adds one command: `manage.py import_fixtures`. It looks for fixture files in every app configured in your `settings.INSTALLED_APPS` that has a `fixtures` folder. So in this example:```bash# appproject-root/app/fixtures/project-root/app/fixtures/ContactSubmission.yaml# blogproject-root/blog/fixtures/project-root/blog/fixtures/Article.yaml# authproject-root/auth/fixtures/project-root/auth/fixtures/User.yamlproject-root/auth/fixtures/Group.yaml```To load the model fixtures into the database, you would run:```bashcd your-django-project-root# to load fixtures from all apps./manage.py import_fixtures# or to load fixtures from specific apps./manage.py import_fixtures app blog```#### With Flask and Flask-SQLAlchemyThis is the minimal setup required to make a Flask cli command available to import fixtures, by default, `flask import-fixtures`:```pythonfrom flask import Flaskfrom flask_sqlalchemy import SQLAlchemyfrom py_yaml_fixtures.flask import PyYAMLFixturesapp = Flask(__name__)db = SQLAlchemy(app)# optional configuration settings (these are all the defaults):app.config['FLASK_MODELS_MODULE'] = 'app.models'  # where all of your model classes are importedapp.config['PY_YAML_FIXTURES_DIR'] = 'db/fixtures'  # where your fixtures file(s) liveapp.config['PY_YAML_FIXTURES_COMMAND_NAME'] = 'import-fixtures'  # the name of the CLI commandfixtures = PyYAMLFixtures(app)  # instantiate the PyYAMLFixtures Flask Extension```After creating fixture files in the configured `PY_YAML_FIXTURES_DIR`, you would then be able to run `flask import-fixtures` to load the fixtures into the database.#### With Flask UnchainedAdd `py_yaml_fixtures` to your `unchained_config.BUNDLES`.The PyYAMLFixtures bundle adds one command to Flask Unchained: `flask db import-fixtures`. It looks for fixture files in each bundle's `fixtures` folder (if it exists). For example:```bash# example folder structure:# appproject-root/app/fixtures/project-root/app/fixtures/ModelOne.yaml# blog_bundleproject-root/bundles/blog/fixtures/project-root/bundles/blog/fixtures/Post.yaml# security_bundleproject-root/bundles/security/fixtures/project-root/bundles/security/fixtures/User.yamlproject-root/bundles/security/fixtures/Role.yaml``````python# project-root/unchained_config.pyBUNDLES = [    # ...    'flask_unchained.bundles.sqlalchemy',    'py_yaml_fixtures',    'bundles.blog',    'bundles.security',    'app',]```To load the model fixtures into the database, you would run:```bashcd your-flask-unchained-project-root# to load fixtures from all bundlesflask db import-fixtures# or to load fixtures from specific bundlesflask db import-fixtures app security_bundle```#### With Standalone SQLAlchemy```pythonimport sqlalchemy as safrom py_yaml_fixtures import FixturesLoaderfrom py_yaml_fixtures.factories.sqlalchemy import SQLAlchemyModelFactoryfrom sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import relationship, sessionmakerPY_YAML_FIXTURES_DIR = 'db/fixtures'BaseModel = declarative_base()class Parent(BaseModel):    __tablename__ = 'parent'    id = sa.Column(sa.Integer, primary_key=True)    name = sa.Column(sa.String)    children = relationship('Child', back_populates='parent')class Child(BaseModel):    __tablename__ = 'child'    id = sa.Column(sa.Integer, primary_key=True)    name = sa.Column(sa.String)    parent_id = sa.Column(sa.Integer, sa.ForeignKey('parent.id'))    parent = relationship('Parent', back_populates='children')# first we need a list of our model classes to provide to the factorymodel_classes = [Parent, Child]# and we need a session connected to the database, also for the factoryengine = create_engine('sqlite:///:memory:')Session = sessionmaker()Session.configure(bind=engine)session = Session()# then we create the factory, and pass it to the fixtures loaderfactory = SQLAlchemyModelFactory(session, model_classes)loader = FixturesLoader(factory, fixture_dirs=[PY_YAML_FIXTURES_DIR])# to create all the fixtures in the database, we have to call loader.create_all()if __name__ == '__main__':    # create the tables in the database    BaseModel.metadata.create_all(bind=engine)    # and use the loader to import the fixtures data into the database    loader.create_all(lambda identifier, model, created: print(        '{action} {identifier}: {model}'.format(            action='Creating' if created else 'Updating',            identifier=identifier.key,            model=repr(model)        )))```## Known Limitations### One to Many RelationshipsIt is not possible to &quot;mix&quot; declarations on both sides of a relationship, eg this doesn't work:```yamlParent:  alice:    name: Alice    children:      - Child(grace)  bob:    name: BobChild:  grace:    name: Grace  judy:    name: Judy    parent: Parent(bob)```The above example will raise a circular dependency exception. You can either declare all children on `Parent` models, *or* declare all parents on `Child` models, **but not both**.### Many to Many RelationshipsLet's say we have a many-to-many relationship between the `Article` and `Tag` models:```pythonclass ArticleTag(db.Model):    &quot;&quot;&quot;Join table between Article and Tag&quot;&quot;&quot;    article_id = db.foreign_key('Article', primary_key=True)    article = db.relationship('Article', back_populates='article_tags')    tag_id = db.foreign_key('Tag', primary_key=True)    tag = db.relationship('Tag', back_populates='tag_articles')class Article(db.Model):    title = db.Column(db.String)    article_tags = db.relationship('ArticleTag', back_populates='article')    tags = db.association_proxy('article_tags', 'tag')class Tag(db.Model):    name = db.Column(db.String)    tag_articles = db.relationship('ArticleTag', back_populates='tag')    articles = db.association_proxy('tag_articles', 'article')```The relationships must be specified on the join table model `ArticleTag`:```yamlArticle:  hello_world:    title: Hello World  metaprogramming:    title: MetaprogrammingTag:  coding:    name: Coding  beginner:    name: Beginner  advanced:    name: AdvancedArticleTag:  at1:    article: Article(hello_world)    tag: Tag(coding)  at2:    article: Article(hello_world)    tag: Tag(beginner)  at3:    article: Article(metaprogramming)    tag: Tag(coding)  at4:    article: Article(metaprogramming)    tag: Tag(advanced)```### Association ProxiesAs of this writing, specifying values directly on association proxy columns is *not* supported.## ContributingContributions are welcome!* Please file bug reports as GitHub issues.* Or even better, open a pull request with the fix!### Adding support for other ORMsYou must implement a concrete factory by extending `py_yaml_fixtures.FactoryInterface`. There are three abstract methods that must be implemented: `create_or_update`, `get_relationships`, and `maybe_convert_values` (see the [DjangoModelFactory](https://github.com/briancappello/py-yaml-fixtures/blob/master/py_yaml_fixtures/factories/django.py) and [SQLAlchemyModelFactory](https://github.com/briancappello/py-yaml-fixtures/blob/master/py_yaml_fixtures/factories/sqlalchemy.py) implementations as examples).## LicenseMIT</longdescription>
</pkgmetadata>