<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># OvldMultiple dispatch in Python, with some extra features.With ovld, you can write a version of the same function for every type signature using annotations instead of writing an awkward sequence of `isinstance` statements. Unlike Python `singledispatch`, it works for multiple arguments.Other features of `ovld`:* Multiple dispatch for methods (with `metaclass=ovld.OvldMC`)* Create variants of functions* Built-in support for extensible, stateful recursion* Function wrappers* Function postprocessors* Nice stack traces## ExampleHere's a function that adds lists, tuples and dictionaries:```pythonfrom ovld import ovld@ovlddef add(x: list, y: list):    return [add(a, b) for a, b in zip(x, y)]@ovlddef add(x: tuple, y: tuple):    return tuple(add(a, b) for a, b in zip(x, y))@ovlddef add(x: dict, y: dict):    return {k: add(v, y[k]) for k, v in x.items()}@ovlddef add(x: object, y: object):    return x + y```## Bootstrapping and variantsNow, there is another way to do this using ovld's *auto-bootstrapping*. Simply list `self` as the first argument to the function, and `self` will be bound to the function itself, so you can call `self(x, y)` for the recursion instead of `add(x, y)`:```python@ovlddef add(self, x: list, y: list):    return [self(a, b) for a, b in zip(x, y)]@ovlddef add(self, x: tuple, y: tuple):    return tuple(self(a, b) for a, b in zip(x, y))@ovlddef add(self, x: dict, y: dict):    return {k: self(v, y[k]) for k, v in x.items()}@ovlddef add(self, x: object, y: object):    return x + y```Why is this useful, though? Observe:```python@add.variantdef mul(self, x: object, y: object):    return x * yassert add([1, 2], [3, 4]) == [4, 6]assert mul([1, 2], [3, 4]) == [3, 8]```A `variant` of a function is a copy which inherits all of the original's implementations but may define new ones. And because `self` is bound to the function that's called at the top level, the implementations for `list`, `tuple` and `dict` will bind `self` to `add` or `mul` depending on which one was called. You may also call `self.super(*args)` to invoke the parent implementation for that type.## StateYou can pass `initial_state` to `@ovld` or `variant`. The initial state must be a function that takes no arguments. Its return value will be available in `self.state`. The state is initialized at the top level call, but recursive calls to `self` will preserve it.In other words, you can do something like this:```python@add.variant(initial_state=lambda: 0)def count(self, x, y):    self.state += 1    return (f&quot;#{self.state}&quot;, x + y)assert count([1, 2, 3], [4, 5, 6]) == [(&quot;#1&quot;, 5), (&quot;#2&quot;, 7), (&quot;#3&quot;, 9)]```The initial_state function can return any object and you can use the state to any purpose (e.g. cache or memoization).## Custom dispatchYou can define your own dispatching function. The dispatcher's first argument is always `self`.* `self.resolve(x, y)` to get the right function for the types of x and y* `self[type(x), type(y)]` will also return the right function for these types, but it works directly with the types.For example, here is how you might define a function such that f(x) &lt;=&gt; f(x, x):```python@ovld.dispatchdef add_default(self, x, y=None):    if y is None:        y = x    return self.resolve(x, y)(x, y)@ovlddef add_default(x: int, y: int):    return x + y@ovlddef add_default(x: str, y: str):    return x + y@ovlddef add_default(xs: list, ys: list):    return [add_default(x, y) for x, y in zip(xs, ys)]assert add_default([1, 2, &quot;alouette&quot;]) == [2, 4, &quot;alouettealouette&quot;]```There are other uses for this feature, e.g. memoization.The normal functions may also have a `self`, which works the same as bootstrapping, and you can give an `initial_state` to `@ovld.dispatch` as well.## Postprocess`@ovld`, `@ovld.dispatch`, etc. take a `postprocess` argument which should be a function of one argument. That function will be called with the result of the call and must return the final result of the call.Note that intermediate, bootstrapped recursive calls (recursive calls using `self()`) will **not** be postprocessed (if you want to wrap these calls, you can do so otherwise, like defining a custom dispatch). Only the result of the top level call is postprocessed.## MethodsUse the `OvldMC` metaclass to use multiple dispatch on methods. In this case there is no bootstrapping as described above and `self` is simply bound to the class instance.```pythonfrom ovld import OvldMCclass Cat(metaclass=OvldMC):    def interact(self, x: Mouse):        return &quot;catch&quot;    def interact(self, x: Food):        return &quot;devour&quot;    def interact(self, x: PricelessVase):        return &quot;destroy&quot;```Subclasses of `Cat` will inherit the overloaded `interact` and it may define additional overloaded methods which will only be valid for the subclass.**Note:** It is possible to use `ovld.dispatch` on methods, but in this case be aware that the first argument for the dispatch method will not be the usual `self` but an `OvldCall` object. The `self` can be retrived as `ovldcall.obj`. Here's an example to make it all clear:```pythonclass Stuff(metaclass=OvldMC):    def __init__(self, mul):        self.mul = mul    @ovld.dispatch    def calc(ovldcall, x):        # Wraps every call to self.calc, but we receive ovldcall instead of self        # ovldcall[type(x)] returns the right method to call        # ovldcall.obj is the self (the actual instance of Stuff)        return ovldcall[type(x)](x) * ovldcall.obj.mul    def calc(self, x: int):        return x + 1    def calc(self, xs: list):        return [self.calc(x) for x in xs]print(Stuff(2).calc([1, 2, 3]))  # [4, 6, 8, 4, 6, 8]```### Mixins in subclassesThe `@extend_super` decorator on a method will combine the method with the definition on the superclass:```pythonfrom ovld import OvldMC, extend_superclass One(metaclass=OvldMC):    def f(self, x: int):        return &quot;an integer&quot;class Two(One):    @extend_super    def f(self, x: str):        return &quot;a string&quot;assert Two().f(1) == &quot;an integer&quot;assert Two().f(&quot;s&quot;) == &quot;a string&quot;```## Ambiguous callsThe following definitions will cause a TypeError at runtime when called with two ints, because it is unclear which function is the right match:```python@ovlddef ambig(x: int, y: object):    print(&quot;io&quot;)@ovlddef ambig(x: object, y: int):    print(&quot;oi&quot;)ambig(8, 8)  # ???```You may define an additional function with signature (int, int) to disambiguate:```python@ovlddef ambig(x: int, y: int):    print(&quot;ii&quot;)```## Other features### metaTo test arbitrary conditions, you can use `meta`:```pythonfrom ovld import ovld, meta@metadef StartsWithT(cls):    return cls.__name__.startswith(&quot;T&quot;)@ovlddef f(x: StartsWithT):    return &quot;T&quot;assert f(TypeError(&quot;xyz&quot;)) == &quot;T&quot;# Or: a useful example, since dataclasses have no common superclass:from dataclasses import dataclass, is_dataclass@dataclassclass Point:    x: int    y: int@ovlddef f(x: meta(is_dataclass)):    return &quot;dataclass&quot;assert f(Point(1, 2)) == &quot;dataclass&quot;```### deferredYou may define overloads for certain classes from external packages withouthaving to import them:```pythonfrom ovld import ovld, deferred@ovlddef f(x: deferred(&quot;numpy.ndarray&quot;)):    return &quot;ndarray&quot;# numpy is not importedassert &quot;numpy&quot; not in sys.modules# But once we import it, the ovld works:import numpyassert f(numpy.arange(10)) == &quot;ndarray&quot;```### Tracebacks`ovld` automagically renames functions so that the stack trace is more informative:```python@add.variantdef bad(self, x: object, y: object):    raise Exception(&quot;Bad.&quot;)bad([1], [2])&quot;&quot;&quot;  File &quot;/Users/breuleuo/code/ovld/ovld/core.py&quot;, line 148, in bad.entry    res = ovc(*args, **kwargs)  File &quot;/Users/breuleuo/code/ovld/ovld/core.py&quot;, line 182, in bad.dispatch    return method(self.bind_to, *args, **kwargs)  File &quot;example.py&quot;, line 6, in bad[list, list]    return [self(a, b) for a, b in zip(x, y)]  File &quot;example.py&quot;, line 6, in &lt;listcomp&gt;    return [self(a, b) for a, b in zip(x, y)]  File &quot;/Users/breuleuo/code/ovld/ovld/core.py&quot;, line 182, in bad.dispatch    return method(self.bind_to, *args, **kwargs)  File &quot;example.py&quot;, line 26, in bad[*, *]    raise Exception(&quot;Bad.&quot;)  Exception: Bad.&quot;&quot;&quot;```The functions on the stack have names like `bad.entry`, `bad.dispatch`, `bad[list, list]` and `bad[*, *]` (`*` stands for `object`), which lets you better understand what happened just from the stack trace.This also means profilers will be able to differentiate between these paths and between variants, even if they share code paths.</longdescription>
</pkgmetadata>