<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>pytz - World Timezone Definitions for Python============================================:Author: Stuart Bishop &lt;stuart@stuartbishop.net&gt;Introduction~~~~~~~~~~~~pytz brings the Olson tz database into Python. This library allowsaccurate and cross platform timezone calculations using Python 2.4or higher. It also solves the issue of ambiguous times at the endof daylight saving time, which you can read more about in the PythonLibrary Reference (``datetime.tzinfo``).Almost all of the Olson timezones are supported... note::    Projects using Python 3.9 or later should be using the support    now included as part of the standard library, and third party    packages work with it such as `tzdata &lt;https://pypi.org/project/tzdata/&gt;`_.    pytz offers no advantages beyond backwards compatibility with    code written for earlier versions of Python... note::    This library differs from the documented Python API for    tzinfo implementations; if you want to create local wallclock    times you need to use the ``localize()`` method documented in this    document. In addition, if you perform date arithmetic on local    times that cross DST boundaries, the result may be in an incorrect    timezone (ie. subtract 1 minute from 2002-10-27 1:00 EST and you get    2002-10-27 0:59 EST instead of the correct 2002-10-27 1:59 EDT). A    ``normalize()`` method is provided to correct this. Unfortunately these    issues cannot be resolved without modifying the Python datetime    implementation (see PEP-431).Installation~~~~~~~~~~~~This package can either be installed using ``pip`` or from a tarball using thestandard Python distutils.If you are installing using ``pip``, you don't need to download anything as thelatest version will be downloaded for you from PyPI::    pip install pytzIf you are installing from a tarball, run the following command as anadministrative user::    python setup.py installpytz for Enterprise~~~~~~~~~~~~~~~~~~~Available as part of the Tidelift Subscription.The maintainers of pytz and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. `Learn more. &lt;https://tidelift.com/subscription/pkg/pypi-pytz?utm_source=pypi-pytz&amp;utm_medium=referral&amp;utm_campaign=enterprise&amp;utm_term=repo&gt;`_.Example &amp; Usage~~~~~~~~~~~~~~~Localized times and date arithmetic-----------------------------------&gt;&gt;&gt; from datetime import datetime, timedelta&gt;&gt;&gt; from pytz import timezone&gt;&gt;&gt; import pytz&gt;&gt;&gt; utc = pytz.utc&gt;&gt;&gt; utc.zone'UTC'&gt;&gt;&gt; eastern = timezone('US/Eastern')&gt;&gt;&gt; eastern.zone'US/Eastern'&gt;&gt;&gt; amsterdam = timezone('Europe/Amsterdam')&gt;&gt;&gt; fmt = '%Y-%m-%d %H:%M:%S %Z%z'This library only supports two ways of building a localized time. Thefirst is to use the ``localize()`` method provided by the pytz library.This is used to localize a naive datetime (datetime with no timezoneinformation):&gt;&gt;&gt; loc_dt = eastern.localize(datetime(2002, 10, 27, 6, 0, 0))&gt;&gt;&gt; print(loc_dt.strftime(fmt))2002-10-27 06:00:00 EST-0500The second way of building a localized time is by converting an existinglocalized time using the standard ``astimezone()`` method:&gt;&gt;&gt; ams_dt = loc_dt.astimezone(amsterdam)&gt;&gt;&gt; ams_dt.strftime(fmt)'2002-10-27 12:00:00 CET+0100'Unfortunately using the tzinfo argument of the standard datetimeconstructors ''does not work'' with pytz for many timezones.&gt;&gt;&gt; datetime(2002, 10, 27, 12, 0, 0, tzinfo=amsterdam).strftime(fmt)  # /!\ Does not work this way!'2002-10-27 12:00:00 LMT+0018'It is safe for timezones without daylight saving transitions though, suchas UTC:&gt;&gt;&gt; datetime(2002, 10, 27, 12, 0, 0, tzinfo=pytz.utc).strftime(fmt)  # /!\ Not recommended except for UTC'2002-10-27 12:00:00 UTC+0000'The preferred way of dealing with times is to always work in UTC,converting to localtime only when generating output to be readby humans.&gt;&gt;&gt; utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)&gt;&gt;&gt; loc_dt = utc_dt.astimezone(eastern)&gt;&gt;&gt; loc_dt.strftime(fmt)'2002-10-27 01:00:00 EST-0500'This library also allows you to do date arithmetic using localtimes, although it is more complicated than working in UTC as youneed to use the ``normalize()`` method to handle daylight saving timeand other timezone transitions. In this example, ``loc_dt`` is setto the instant when daylight saving time ends in the US/Easterntimezone.&gt;&gt;&gt; before = loc_dt - timedelta(minutes=10)&gt;&gt;&gt; before.strftime(fmt)'2002-10-27 00:50:00 EST-0500'&gt;&gt;&gt; eastern.normalize(before).strftime(fmt)'2002-10-27 01:50:00 EDT-0400'&gt;&gt;&gt; after = eastern.normalize(before + timedelta(minutes=20))&gt;&gt;&gt; after.strftime(fmt)'2002-10-27 01:10:00 EST-0500'Creating local times is also tricky, and the reason why working withlocal times is not recommended. Unfortunately, you cannot just passa ``tzinfo`` argument when constructing a datetime (see the nextsection for more details)&gt;&gt;&gt; dt = datetime(2002, 10, 27, 1, 30, 0)&gt;&gt;&gt; dt1 = eastern.localize(dt, is_dst=True)&gt;&gt;&gt; dt1.strftime(fmt)'2002-10-27 01:30:00 EDT-0400'&gt;&gt;&gt; dt2 = eastern.localize(dt, is_dst=False)&gt;&gt;&gt; dt2.strftime(fmt)'2002-10-27 01:30:00 EST-0500'Converting between timezones is more easily done, using thestandard astimezone method.&gt;&gt;&gt; utc_dt = datetime.fromtimestamp(1143408899, tz=utc)&gt;&gt;&gt; utc_dt.strftime(fmt)'2006-03-26 21:34:59 UTC+0000'&gt;&gt;&gt; au_tz = timezone('Australia/Sydney')&gt;&gt;&gt; au_dt = utc_dt.astimezone(au_tz)&gt;&gt;&gt; au_dt.strftime(fmt)'2006-03-27 08:34:59 AEDT+1100'&gt;&gt;&gt; utc_dt2 = au_dt.astimezone(utc)&gt;&gt;&gt; utc_dt2.strftime(fmt)'2006-03-26 21:34:59 UTC+0000'&gt;&gt;&gt; utc_dt == utc_dt2TrueYou can take shortcuts when dealing with the UTC side of timezoneconversions. ``normalize()`` and ``localize()`` are not reallynecessary when there are no daylight saving time transitions todeal with.&gt;&gt;&gt; utc_dt = datetime.fromtimestamp(1143408899, tz=utc)&gt;&gt;&gt; utc_dt.strftime(fmt)'2006-03-26 21:34:59 UTC+0000'&gt;&gt;&gt; au_tz = timezone('Australia/Sydney')&gt;&gt;&gt; au_dt = au_tz.normalize(utc_dt.astimezone(au_tz))&gt;&gt;&gt; au_dt.strftime(fmt)'2006-03-27 08:34:59 AEDT+1100'&gt;&gt;&gt; utc_dt2 = au_dt.astimezone(utc)&gt;&gt;&gt; utc_dt2.strftime(fmt)'2006-03-26 21:34:59 UTC+0000'``tzinfo`` API--------------The ``tzinfo`` instances returned by the ``timezone()`` function havebeen extended to cope with ambiguous times by adding an ``is_dst``parameter to the ``utcoffset()``, ``dst()`` &amp;&amp; ``tzname()`` methods.&gt;&gt;&gt; tz = timezone('America/St_Johns')&gt;&gt;&gt; normal = datetime(2009, 9, 1)&gt;&gt;&gt; ambiguous = datetime(2009, 10, 31, 23, 30)The ``is_dst`` parameter is ignored for most timestamps. It is only usedduring DST transition ambiguous periods to resolve that ambiguity.&gt;&gt;&gt; print(tz.utcoffset(normal, is_dst=True))-1 day, 21:30:00&gt;&gt;&gt; print(tz.dst(normal, is_dst=True))1:00:00&gt;&gt;&gt; tz.tzname(normal, is_dst=True)'NDT'&gt;&gt;&gt; print(tz.utcoffset(ambiguous, is_dst=True))-1 day, 21:30:00&gt;&gt;&gt; print(tz.dst(ambiguous, is_dst=True))1:00:00&gt;&gt;&gt; tz.tzname(ambiguous, is_dst=True)'NDT'&gt;&gt;&gt; print(tz.utcoffset(normal, is_dst=False))-1 day, 21:30:00&gt;&gt;&gt; tz.dst(normal, is_dst=False).seconds3600&gt;&gt;&gt; tz.tzname(normal, is_dst=False)'NDT'&gt;&gt;&gt; print(tz.utcoffset(ambiguous, is_dst=False))-1 day, 20:30:00&gt;&gt;&gt; tz.dst(ambiguous, is_dst=False)datetime.timedelta(0)&gt;&gt;&gt; tz.tzname(ambiguous, is_dst=False)'NST'If ``is_dst`` is not specified, ambiguous timestamps will raisean ``pytz.exceptions.AmbiguousTimeError`` exception.&gt;&gt;&gt; print(tz.utcoffset(normal))-1 day, 21:30:00&gt;&gt;&gt; print(tz.dst(normal))1:00:00&gt;&gt;&gt; tz.tzname(normal)'NDT'&gt;&gt;&gt; import pytz.exceptions&gt;&gt;&gt; try:...     tz.utcoffset(ambiguous)... except pytz.exceptions.AmbiguousTimeError:...     print('pytz.exceptions.AmbiguousTimeError: %s' % ambiguous)pytz.exceptions.AmbiguousTimeError: 2009-10-31 23:30:00&gt;&gt;&gt; try:...     tz.dst(ambiguous)... except pytz.exceptions.AmbiguousTimeError:...     print('pytz.exceptions.AmbiguousTimeError: %s' % ambiguous)pytz.exceptions.AmbiguousTimeError: 2009-10-31 23:30:00&gt;&gt;&gt; try:...     tz.tzname(ambiguous)... except pytz.exceptions.AmbiguousTimeError:...     print('pytz.exceptions.AmbiguousTimeError: %s' % ambiguous)pytz.exceptions.AmbiguousTimeError: 2009-10-31 23:30:00Problems with Localtime~~~~~~~~~~~~~~~~~~~~~~~The major problem we have to deal with is that certain datetimesmay occur twice in a year. For example, in the US/Eastern timezoneon the last Sunday morning in October, the following sequencehappens:    - 01:00 EDT occurs    - 1 hour later, instead of 2:00am the clock is turned back 1 hour      and 01:00 happens again (this time 01:00 EST)In fact, every instant between 01:00 and 02:00 occurs twice. This meansthat if you try and create a time in the 'US/Eastern' timezonethe standard datetime syntax, there is no way to specify if you meantbefore of after the end-of-daylight-saving-time transition. Using thepytz custom syntax, the best you can do is make an educated guess:&gt;&gt;&gt; loc_dt = eastern.localize(datetime(2002, 10, 27, 1, 30, 00))&gt;&gt;&gt; loc_dt.strftime(fmt)'2002-10-27 01:30:00 EST-0500'As you can see, the system has chosen one for you and there is a 50%chance of it being out by one hour. For some applications, this doesnot matter. However, if you are trying to schedule meetings with peoplein different timezones or analyze log files it is not acceptable.The best and simplest solution is to stick with using UTC.  The pytzpackage encourages using UTC for internal timezone representation byincluding a special UTC implementation based on the standard Pythonreference implementation in the Python documentation.The UTC timezone unpickles to be the same instance, and pickles to asmaller size than other pytz tzinfo instances.  The UTC implementationcan be obtained as pytz.utc, pytz.UTC, or pytz.timezone('UTC').&gt;&gt;&gt; import pickle, pytz&gt;&gt;&gt; dt = datetime(2005, 3, 1, 14, 13, 21, tzinfo=utc)&gt;&gt;&gt; naive = dt.replace(tzinfo=None)&gt;&gt;&gt; p = pickle.dumps(dt, 1)&gt;&gt;&gt; naive_p = pickle.dumps(naive, 1)&gt;&gt;&gt; len(p) - len(naive_p)17&gt;&gt;&gt; new = pickle.loads(p)&gt;&gt;&gt; new == dtTrue&gt;&gt;&gt; new is dtFalse&gt;&gt;&gt; new.tzinfo is dt.tzinfoTrue&gt;&gt;&gt; pytz.utc is pytz.UTC is pytz.timezone('UTC')TrueNote that some other timezones are commonly thought of as the same (GMT,Greenwich, Universal, etc.). The definition of UTC is distinct from theseother timezones, and they are not equivalent. For this reason, they willnot compare the same in Python.&gt;&gt;&gt; utc == pytz.timezone('GMT')FalseSee the section `What is UTC`_, below.If you insist on working with local times, this library provides afacility for constructing them unambiguously:&gt;&gt;&gt; loc_dt = datetime(2002, 10, 27, 1, 30, 00)&gt;&gt;&gt; est_dt = eastern.localize(loc_dt, is_dst=True)&gt;&gt;&gt; edt_dt = eastern.localize(loc_dt, is_dst=False)&gt;&gt;&gt; print(est_dt.strftime(fmt) + ' / ' + edt_dt.strftime(fmt))2002-10-27 01:30:00 EDT-0400 / 2002-10-27 01:30:00 EST-0500If you pass None as the is_dst flag to localize(), pytz will refuse toguess and raise exceptions if you try to build ambiguous or non-existenttimes.For example, 1:30am on 27th Oct 2002 happened twice in the US/Easterntimezone when the clocks where put back at the end of Daylight SavingTime:&gt;&gt;&gt; dt = datetime(2002, 10, 27, 1, 30, 00)&gt;&gt;&gt; try:...     eastern.localize(dt, is_dst=None)... except pytz.exceptions.AmbiguousTimeError:...     print('pytz.exceptions.AmbiguousTimeError: %s' % dt)pytz.exceptions.AmbiguousTimeError: 2002-10-27 01:30:00Similarly, 2:30am on 7th April 2002 never happened at all in theUS/Eastern timezone, as the clocks where put forward at 2:00am skippingthe entire hour:&gt;&gt;&gt; dt = datetime(2002, 4, 7, 2, 30, 00)&gt;&gt;&gt; try:...     eastern.localize(dt, is_dst=None)... except pytz.exceptions.NonExistentTimeError:...     print('pytz.exceptions.NonExistentTimeError: %s' % dt)pytz.exceptions.NonExistentTimeError: 2002-04-07 02:30:00Both of these exceptions share a common base class to make error handlingeasier:&gt;&gt;&gt; isinstance(pytz.AmbiguousTimeError(), pytz.InvalidTimeError)True&gt;&gt;&gt; isinstance(pytz.NonExistentTimeError(), pytz.InvalidTimeError)TrueA special case is where countries change their timezone definitionswith no daylight savings time switch. For example, in 1915 Warsawswitched from Warsaw time to Central European time with no daylight savingstransition. So at the stroke of midnight on August 5th 1915 the clockswere wound back 24 minutes creating an ambiguous time period that cannotbe specified without referring to the timezone abbreviation or theactual UTC offset. In this case midnight happened twice, neither timeduring a daylight saving time period. pytz handles this transition bytreating the ambiguous period before the switch as daylight savingstime, and the ambiguous period after as standard time.&gt;&gt;&gt; warsaw = pytz.timezone('Europe/Warsaw')&gt;&gt;&gt; amb_dt1 = warsaw.localize(datetime(1915, 8, 4, 23, 59, 59), is_dst=True)&gt;&gt;&gt; amb_dt1.strftime(fmt)'1915-08-04 23:59:59 WMT+0124'&gt;&gt;&gt; amb_dt2 = warsaw.localize(datetime(1915, 8, 4, 23, 59, 59), is_dst=False)&gt;&gt;&gt; amb_dt2.strftime(fmt)'1915-08-04 23:59:59 CET+0100'&gt;&gt;&gt; switch_dt = warsaw.localize(datetime(1915, 8, 5, 00, 00, 00), is_dst=False)&gt;&gt;&gt; switch_dt.strftime(fmt)'1915-08-05 00:00:00 CET+0100'&gt;&gt;&gt; str(switch_dt - amb_dt1)'0:24:01'&gt;&gt;&gt; str(switch_dt - amb_dt2)'0:00:01'The best way of creating a time during an ambiguous time period isby converting from another timezone such as UTC:&gt;&gt;&gt; utc_dt = datetime(1915, 8, 4, 22, 36, tzinfo=pytz.utc)&gt;&gt;&gt; utc_dt.astimezone(warsaw).strftime(fmt)'1915-08-04 23:36:00 CET+0100'The standard Python way of handling all these ambiguities is not tohandle them, such as demonstrated in this example using the US/Easterntimezone definition from the Python documentation (Note that thisimplementation only works for dates between 1987 and 2006 - it isincluded for tests only!):&gt;&gt;&gt; from pytz.reference import Eastern # pytz.reference only for tests&gt;&gt;&gt; dt = datetime(2002, 10, 27, 0, 30, tzinfo=Eastern)&gt;&gt;&gt; str(dt)'2002-10-27 00:30:00-04:00'&gt;&gt;&gt; str(dt + timedelta(hours=1))'2002-10-27 01:30:00-05:00'&gt;&gt;&gt; str(dt + timedelta(hours=2))'2002-10-27 02:30:00-05:00'&gt;&gt;&gt; str(dt + timedelta(hours=3))'2002-10-27 03:30:00-05:00'Notice the first two results? At first glance you might think they arecorrect, but taking the UTC offset into account you find that they areactually two hours appart instead of the 1 hour we asked for.&gt;&gt;&gt; from pytz.reference import UTC # pytz.reference only for tests&gt;&gt;&gt; str(dt.astimezone(UTC))'2002-10-27 04:30:00+00:00'&gt;&gt;&gt; str((dt + timedelta(hours=1)).astimezone(UTC))'2002-10-27 06:30:00+00:00'Country Information~~~~~~~~~~~~~~~~~~~A mechanism is provided to access the timezones commonly in usefor a particular country, looked up using the ISO 3166 country code.It returns a list of strings that can be used to retrieve the relevanttzinfo instance using ``pytz.timezone()``:&gt;&gt;&gt; print(' '.join(pytz.country_timezones['nz']))Pacific/Auckland Pacific/ChathamThe Olson database comes with a ISO 3166 country code to English countryname mapping that pytz exposes as a dictionary:&gt;&gt;&gt; print(pytz.country_names['nz'])New ZealandWhat is UTC~~~~~~~~~~~'UTC' is `Coordinated Universal Time`_. It is a successor to, but distinctfrom, Greenwich Mean Time (GMT) and the various definitions of UniversalTime. UTC is now the worldwide standard for regulating clocks and timemeasurement.All other timezones are defined relative to UTC, and include offsets likeUTC+0800 - hours to add or subtract from UTC to derive the local time. Nodaylight saving time occurs in UTC, making it a useful timezone to performdate arithmetic without worrying about the confusion and ambiguities causedby daylight saving time transitions, your country changing its timezone, ormobile computers that roam through multiple timezones...  _Coordinated Universal Time: https://en.wikipedia.org/wiki/Coordinated_Universal_TimeHelpers~~~~~~~There are two lists of timezones provided.``all_timezones`` is the exhaustive list of the timezone names that canbe used.&gt;&gt;&gt; from pytz import all_timezones&gt;&gt;&gt; len(all_timezones) &gt;= 500True&gt;&gt;&gt; 'Etc/Greenwich' in all_timezonesTrue``common_timezones`` is a list of useful, current timezones. It doesn'tcontain deprecated zones or historical zones, except for a few I'vedeemed in common usage, such as US/Eastern (open a bug report if youthink other timezones are deserving of being included here). It is alsoa sequence of strings.&gt;&gt;&gt; from pytz import common_timezones&gt;&gt;&gt; len(common_timezones) &lt; len(all_timezones)True&gt;&gt;&gt; 'Etc/Greenwich' in common_timezonesFalse&gt;&gt;&gt; 'Australia/Melbourne' in common_timezonesTrue&gt;&gt;&gt; 'US/Eastern' in common_timezonesTrue&gt;&gt;&gt; 'Canada/Eastern' in common_timezonesTrue&gt;&gt;&gt; 'Australia/Yancowinna' in all_timezonesTrue&gt;&gt;&gt; 'Australia/Yancowinna' in common_timezonesFalseBoth ``common_timezones`` and ``all_timezones`` are alphabeticallysorted:&gt;&gt;&gt; common_timezones_dupe = common_timezones[:]&gt;&gt;&gt; common_timezones_dupe.sort()&gt;&gt;&gt; common_timezones == common_timezones_dupeTrue&gt;&gt;&gt; all_timezones_dupe = all_timezones[:]&gt;&gt;&gt; all_timezones_dupe.sort()&gt;&gt;&gt; all_timezones == all_timezones_dupeTrue``all_timezones`` and ``common_timezones`` are also available as sets.&gt;&gt;&gt; from pytz import all_timezones_set, common_timezones_set&gt;&gt;&gt; 'US/Eastern' in all_timezones_setTrue&gt;&gt;&gt; 'US/Eastern' in common_timezones_setTrue&gt;&gt;&gt; 'Australia/Victoria' in common_timezones_setFalseYou can also retrieve lists of timezones used by particular countriesusing the ``country_timezones()`` function. It requires an ISO-3166two letter country code.&gt;&gt;&gt; from pytz import country_timezones&gt;&gt;&gt; print(' '.join(country_timezones('ch')))Europe/Zurich&gt;&gt;&gt; print(' '.join(country_timezones('CH')))Europe/ZurichInternationalization - i18n/l10n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Pytz is an interface to the IANA database, which uses ASCII names. The `Unicode  Consortium's Unicode Locales (CLDR) &lt;http://cldr.unicode.org&gt;`_project provides translations. Python packages such as`Babel &lt;https://babel.pocoo.org/en/latest/api/dates.html#timezone-functionality&gt;`_and Thomas Khyn's `l18n &lt;https://pypi.org/project/l18n/&gt;`_ package can be usedto access these translations from Python.License~~~~~~~MIT license.This code is also available as part of Zope 3 under the Zope PublicLicense,  Version 2.1 (ZPL).I'm happy to relicense this code if necessary for inclusion in otheropen source projects.Latest Versions~~~~~~~~~~~~~~~This package will be updated after releases of the Olson timezonedatabase.  The latest version can be downloaded from the `Python PackageIndex &lt;https://pypi.org/project/pytz/&gt;`_.  The code that is usedto generate this distribution is hosted on Github and availableusing git::    git clone https://github.com/stub42/pytz.gitAnnouncements of new releases are made on`Launchpad &lt;https://launchpad.net/pytz&gt;`_, and the`Atom feed &lt;http://feeds.launchpad.net/pytz/announcements.atom&gt;`_hosted there.Bugs, Feature Requests &amp; Patches~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Bugs should be reported on `Github &lt;https://github.com/stub42/pytz/issues&gt;`_.Feature requests are unlikely to be considered, and efforts instead directedto timezone support now built into Python or packages that work with it.Security Issues~~~~~~~~~~~~~~~Reports about security issues can be made via `Tidelift &lt;https://tidelift.com/security&gt;`_.Issues &amp; Limitations~~~~~~~~~~~~~~~~~~~~- This project is in maintenance mode. Projects using Python 3.9 or later  are best served by using the timezone functionaly now included in core  Python and packages that work with it such as `tzdata &lt;https://pypi.org/project/tzdata/&gt;`_.- Offsets from UTC are rounded to the nearest whole minute, so timezones  such as Europe/Amsterdam pre 1937 will be up to 30 seconds out. This  was a limitation of the Python datetime library.- If you think a timezone definition is incorrect, I probably can't fix  it. pytz is a direct translation of the Olson timezone database, and  changes to the timezone definitions need to be made to this source.  If you find errors they should be reported to the time zone mailing  list, linked from http://www.iana.org/time-zones.Further Reading~~~~~~~~~~~~~~~More info than you want to know about timezones:https://data.iana.org/time-zones/tz-link.htmlContact~~~~~~~Stuart Bishop &lt;stuart@stuartbishop.net&gt;</longdescription>
</pkgmetadata>