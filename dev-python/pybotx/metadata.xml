<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pybotx*Библиотека для создания чат-ботов и SmartApps для мессенджера eXpress*[![PyPI version](https://badge.fury.io/py/botx.svg)](https://badge.fury.io/py/pybotx)![PyPI - Python Version](https://img.shields.io/pypi/pyversions/pybotx)[![Coverage](https://codecov.io/gh/ExpressApp/pybotx/branch/master/graph/badge.svg)](https://codecov.io/gh/ExpressApp/pybotx/branch/master)[![Code style](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)## Особенности* Простая для использования* Поддерживает коллбэки BotX* Легко интегрируется с асинхронными веб-фреймворками* Полное покрытие тестами* Полное покрытие аннотациями типов## УстановкаИспользуя `poetry`:```bashpoetry add pybotx```**Предупреждение:** Данный проект находится в активной разработке (`0.y.z`) иего API может быть изменён при повышении минорной версии.## Информация о мессенджере eXpress и платформе BotXДокументацию по мессенджеру (включая руководство пользователя и администратора)можно найти на [официальном сайте](https://express.ms/).Перед тем, как продолжать знакомство с библиотекой `pybotx`,советуем прочитать данные статьи: [Что такое чат-боты и SmartApp](https://ccsteam.atlassian.net/wiki/spaces/SMARTAPP/pages/311001089)и [Взаимодействие с Bot API и BotX API](https://ccsteam.atlassian.net/wiki/spaces/SMARTAPP/pages/311001185).В этих статьях находятся исчерпывающие примеры работы с платформой, которыелегко повторить, используя `pybotx`.Также не будет лишним ознакомиться с [документацией по плаформе BotX](https://hackmd.ccsteam.ru/s/botx_platform).## Примеры готовых проектов на базе pybotx* [Next Feature Bot](https://github.com/ExpressApp/next-feature-bot) - бот,  используемый для тестирования функционала платформы BotX.* [ToDo Bot](https://github.com/ExpressApp/todo-bot) - бот для ведения списка  дел.* [Weather SmartApp](https://github.com/ExpressApp/weather-smartapp) -  приложение для просмотра погоды.## Минимальный пример бота (интеграция с FastAPI)```pythonfrom http import HTTPStatusfrom uuid import UUIDfrom fastapi import FastAPI, Requestfrom fastapi.responses import JSONResponse# В этом и последующих примерах импорт из `pybotx` будет производиться# через звёздочку для краткости. Однако, это не является хорошей практикой.from pybotx import *collector = HandlerCollector()@collector.command(&quot;/echo&quot;, description=&quot;Send back the received message body&quot;)async def echo_handler(message: IncomingMessage, bot: Bot) -&gt; None:    await bot.answer_message(message.body)# Сюда можно добавлять свои обработчики команд# или копировать примеры кода, расположенные ниже.bot = Bot(    collectors=[collector],    bot_accounts=[        BotAccountWithSecret(            # Не забудьте заменить эти учётные данные на настоящие,            # когда создадите бота в панели администратора.            id=UUID(&quot;123e4567-e89b-12d3-a456-426655440000&quot;),            host=&quot;cts.example.com&quot;,            secret_key=&quot;e29b417773f2feab9dac143ee3da20c5&quot;,        ),    ],)app = FastAPI()app.add_event_handler(&quot;startup&quot;, bot.startup)app.add_event_handler(&quot;shutdown&quot;, bot.shutdown)# На этот эндпоинт приходят команды BotX# (сообщения и системные события).@app.post(&quot;/command&quot;)async def command_handler(request: Request) -&gt; JSONResponse:    bot.async_execute_raw_bot_command(await request.json())    return JSONResponse(        build_command_accepted_response(),        status_code=HTTPStatus.ACCEPTED,    )# К этому эндпоинту BotX обращается, чтобы узнать# доступность бота и его список команд.@app.get(&quot;/status&quot;)async def status_handler(request: Request) -&gt; JSONResponse:    status = await bot.raw_get_status(dict(request.query_params))    return JSONResponse(status)# На этот эндпоинт приходят коллбэки с результатами# выполнения асинхронных методов в BotX.@app.post(&quot;/notification/callback&quot;)async def callback_handler(request: Request) -&gt; JSONResponse:    await bot.set_raw_botx_method_result(await request.json())    return JSONResponse(        build_command_accepted_response(),        status_code=HTTPStatus.ACCEPTED,    )```## Примеры### Получение сообщений*([подробное описание функции](https://ccsteam.atlassian.net/wiki/spaces/SMARTAPP/pages/311001185/Bot+API+BotX+API#%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D1%85-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9))*```pythonfrom uuid import UUIDfrom pybotx import *ADMIN_HUIDS = (UUID(&quot;123e4567-e89b-12d3-a456-426614174000&quot;),)collector = HandlerCollector()@collector.command(&quot;/visible&quot;, description=&quot;Visible command&quot;)async def visible_handler(_: IncomingMessage, bot: Bot) -&gt; None:    # Обработчик команды бота. Команда видимая, поэтому описание    # является обязательным.    print(&quot;Hello from `/visible` handler&quot;)@collector.command(&quot;/_invisible&quot;, visible=False)async def invisible_handler(_: IncomingMessage, bot: Bot) -&gt; None:    # Невидимая команда - не отображается в списке команд бота    # и не нуждается в описании.    print(&quot;Hello from `/invisible` handler&quot;)async def is_admin(status_recipient: StatusRecipient, bot: Bot) -&gt; bool:    return status_recipient.huid in ADMIN_HUIDS@collector.command(&quot;/admin-command&quot;, visible=is_admin)async def admin_command_handler(_: IncomingMessage, bot: Bot) -&gt; None:    # Команда показывается только если пользователь является админом.    # Список команд запрашивается при открытии чата в приложении.    print(&quot;Hello from `/admin-command` handler&quot;)@collector.default_message_handlerasync def default_handler(_: IncomingMessage, bot: Bot) -&gt; None:    # Если команда не была найдена, вызывается `default_message_handler`,    # если он определён. Такой обработчик может быть только один.    print(&quot;Hello from default handler&quot;)```### Получение системных событий*([подробное описание функции](https://ccsteam.atlassian.net/wiki/spaces/SMARTAPP/pages/311001185/Bot+API+BotX+API#%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D1%85-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9))*```pythonfrom pybotx import *collector = HandlerCollector()@collector.chat_createdasync def chat_created_handler(event: ChatCreatedEvent, bot: Bot) -&gt; None:    # Работа с событиями производится с помощью специальных обработчиков.    # На каждое событие можно объявить только один такой обработчик.    print(f&quot;Got `chat_created` event: {event}&quot;)@collector.smartapp_eventasync def smartapp_event_handler(event: SmartAppEvent, bot: Bot) -&gt; None:    print(f&quot;Got `smartapp_event` event: {event}&quot;)```### Middlewares*(Этот функционал относится исключительно к `pybotx`)*```pythonfrom httpx import AsyncClientfrom pybotx import *collector = HandlerCollector()async def custom_api_client_middleware(    message: IncomingMessage,    bot: Bot,    call_next: IncomingMessageHandlerFunc,) -&gt; None:    # До вызова `call_next` (обязателен в каждой миддлвари) располагается    # код, который выполняется до того, как сообщение дойдёт до    # своего обработчика.    async_client = AsyncClient()    # У сообщения есть объект состояния, в который миддлвари могут добавлять    # необходимые данные.    message.state.async_client = async_client    await call_next(message, bot)    # После вызова `call_next` выполняется код, когда обработчик уже    # завершил свою работу.    await async_client.aclose()@collector.command(    &quot;/fetch-resource&quot;,    description=&quot;Fetch resource from passed URL&quot;,    middlewares=[custom_api_client_middleware],)async def fetch_resource_handler(message: IncomingMessage, bot: Bot) -&gt; None:    async_client = message.state.async_client    response = await async_client.get(message.argument)    print(response.status_code)```### Сборщики обработчиков*(Этот функционал относится исключительно к `pybotx`)*```pythonfrom uuid import UUID, uuid4from pybotx import *ADMIN_HUIDS = (UUID(&quot;123e4567-e89b-12d3-a456-426614174000&quot;),)async def request_id_middleware(    message: IncomingMessage,    bot: Bot,    call_next: IncomingMessageHandlerFunc,) -&gt; None:    message.state.request_id = uuid4()    await call_next(message, bot)async def ensure_admin_middleware(    message: IncomingMessage,    bot: Bot,    call_next: IncomingMessageHandlerFunc,) -&gt; None:    if message.sender.huid not in ADMIN_HUIDS:        await bot.answer_message(&quot;You are not admin&quot;)        return    await call_next(message, bot)# Для того чтобы добавить новый обработчик команды,# необходимо создать экземпляр класса `HandlerCollector`.# Позже этот сборщик будет использован при создании бота.main_collector = HandlerCollector(middlewares=[request_id_middleware])# У сборщиков (как у обработчиков), могут быть собственные миддлвари.# Они автоматически применяются ко всем обработчикам данного сборщика.admin_collector = HandlerCollector(middlewares=[ensure_admin_middleware])# Сборщики можно включать друг в друга. В данном примере у# `admin_collector` будут две миддлвари. Первая - его собственная,# вторая - полученная при включении в `main_collector`.main_collector.include(admin_collector)```### Отправка сообщения*([подробное описание функции](https://ccsteam.atlassian.net/wiki/spaces/SMARTAPP/pages/311001185/Bot+API+BotX+API#%D0%9E%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F))*```pythonfrom uuid import UUIDfrom pybotx import *collector = HandlerCollector()@collector.command(&quot;/answer&quot;, description=&quot;Answer to sender&quot;)async def answer_to_sender_handler(message: IncomingMessage, bot: Bot) -&gt; None:    # Т.к. нам известно, откуда пришло сообщение, у `pybotx` есть необходимый    # контекст для отправки ответа.    await bot.answer_message(&quot;Text&quot;)@collector.command(&quot;/send&quot;, description=&quot;Send message to specified chat&quot;)async def send_message_handler(message: IncomingMessage, bot: Bot) -&gt; None:    try:        chat_id = UUID(message.argument)    except ValueError:        await bot.answer_message(&quot;Invalid chat id&quot;)        return    # В данном случае нас интересует не ответ, а отправка сообщения    # в другой чат. Чат должен существовать и бот должен быть в нём.    try:        await bot.send_message(            bot_id=message.bot.id,            chat_id=chat_id,            body=&quot;Text&quot;,        )    except Exception as exc:        await bot.answer_message(f&quot;Error: {exc}&quot;)        return    await bot.answer_message(&quot;Message was send&quot;)@collector.command(&quot;/prebuild-answer&quot;, description=&quot;Answer with prebuild message&quot;)async def prebuild_answer_handler(message: IncomingMessage, bot: Bot) -&gt; None:    # С помощью OutgoingMessage можно выносить логику    # формирования ответов в другие модули.    answer = OutgoingMessage(        bot_id=message.bot.id,        chat_id=message.chat.id,        body=&quot;Text&quot;,    )    await bot.send(message=answer)```#### Отправка сообщения с кнопками*([подробное описание функции](https://ccsteam.atlassian.net/wiki/spaces/SMARTAPP/pages/311001185/Bot+API+BotX+API#%D0%9E%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81-%D0%BA%D0%BD%D0%BE%D0%BF%D0%BA%D0%B0%D0%BC%D0%B8))*```pythonfrom pybotx import *collector = HandlerCollector()@collector.command(&quot;/bubbles&quot;, description=&quot;Send buttons&quot;)async def bubbles_handler(message: IncomingMessage, bot: Bot) -&gt; None:    # Если вам нужна клавиатура под полем для ввода сообщения,    # используйте `KeyboardMarkup`. Этот класс имеет те же методы,    # что и `BubbleMarkup`.    bubbles = BubbleMarkup()    bubbles.add_button(        command=&quot;/choose&quot;,        label=&quot;Red&quot;,        data={&quot;pill&quot;: &quot;red&quot;},    )    bubbles.add_button(        command=&quot;/choose&quot;,        label=&quot;Blue&quot;,        data={&quot;pill&quot;: &quot;blue&quot;},        new_row=False,    )    await bot.answer_message(        &quot;The time has come to make a choice, Mr. Anderson:&quot;,        bubbles=bubbles,    )```#### Упоминание пользователя*([подробное описание функции](https://ccsteam.atlassian.net/wiki/spaces/SMARTAPP/pages/311001185/Bot+API+BotX+API#%D0%A3%D0%BF%D0%BE%D0%BC%D0%B8%D0%BD%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F))*```pythonfrom pybotx import *collector = HandlerCollector()@collector.command(&quot;/send-contact&quot;, description=&quot;Send author's contact&quot;)async def send_contact_handler(message: IncomingMessage, bot: Bot) -&gt; None:    contact = MentionBuilder.contact(message.sender.huid)    await bot.answer_message(f&quot;Author is {contact}&quot;)@collector.command(&quot;/echo-contacts&quot;, description=&quot;Send back recieved contacts&quot;)async def echo_contact_handler(message: IncomingMessage, bot: Bot) -&gt; None:    if not (contacts := message.mentions.contacts):        await bot.answer_message(&quot;Please send at least one contact&quot;)        return    answer = &quot;, &quot;.join(map(str, contacts))    await bot.answer_message(answer)```#### Отправка файла в сообщении*([подробное описание функции](https://ccsteam.atlassian.net/wiki/spaces/SMARTAPP/pages/311001185/Bot+API+BotX+API#%D0%9E%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0-%D0%B2-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B8))*```pythonfrom aiofiles.tempfile import NamedTemporaryFilefrom pybotx import *collector = HandlerCollector()@collector.command(&quot;/send-file&quot;, description=&quot;Send file&quot;)async def send_file_handler(message: IncomingMessage, bot: Bot) -&gt; None:    # Для создания файла используется file-like object    # с поддержкой асинхронных операций.    async with NamedTemporaryFile(&quot;wb+&quot;) as async_buffer:        await async_buffer.write(b&quot;Hello, world!\n&quot;)        await async_buffer.seek(0)        file = await OutgoingAttachment.from_async_buffer(async_buffer, &quot;test.txt&quot;)    await bot.answer_message(&quot;Attached file&quot;, file=file)@collector.command(&quot;/echo-file&quot;, description=&quot;Echo file&quot;)async def echo_file_handler(message: IncomingMessage, bot: Bot) -&gt; None:    if not (attached_file := message.file):        await bot.answer_message(&quot;Attached file is required&quot;)        return    await bot.answer_message(&quot;&quot;, file=attached_file)```### Редактирование сообщения*([подробное описание функции](https://hackmd.ccsteam.ru/s/E9MPeOxjP#%D0%A0%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F))*```pythonfrom pybotx import *collector = HandlerCollector()@collector.command(&quot;/increment&quot;, description=&quot;Self-updating widget&quot;)async def increment_handler(message: IncomingMessage, bot: Bot) -&gt; None:    if message.source_sync_id:  # ID сообщения, в котором была нажата кнопка.        current_value = message.data[&quot;current_value&quot;]        next_value = current_value + 1    else:        current_value = 0        next_value = 1    answer_text = f&quot;Counter: {current_value}&quot;    bubbles = BubbleMarkup()    bubbles.add_button(        command=&quot;/increment&quot;,        label=&quot;+&quot;,        data={&quot;current_value&quot;: next_value},    )    if message.source_sync_id:        await bot.edit_message(            bot_id=message.bot.id,            sync_id=message.source_sync_id,            body=answer_text,            bubbles=bubbles,        )    else:        await bot.answer_message(answer_text, bubbles=bubbles)```### Обработчики ошибок*(Этот функционал относится исключительно к `pybotx`)*```pythonfrom loguru import loggerfrom pybotx import *async def internal_error_handler(    message: IncomingMessage,    bot: Bot,    exc: Exception,) -&gt; None:    logger.exception(&quot;Internal error:&quot;)    await bot.answer_message(        &quot;**Error:** internal error, please contact your system administrator&quot;,    )# Для перехвата исключений существуют специальные обработчики.# Бот принимает словарь из типов исключений и их обработчиков.bot = Bot(    collectors=[],    bot_accounts=[],    exception_handlers={Exception: internal_error_handler},)```### Создание чата*([подробное описание функции](https://ccsteam.atlassian.net/wiki/spaces/SMARTAPP/pages/311001185/Bot+API+BotX+API#%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D1%87%D0%B0%D1%82%D0%B0))*```pythonfrom pybotx import *collector = HandlerCollector()@collector.command(&quot;/create-group-chat&quot;, description=&quot;Create group chat&quot;)async def create_group_chat_handler(message: IncomingMessage, bot: Bot) -&gt; None:    if not (contacts := message.mentions.contacts):        await bot.answer_message(&quot;Please send at least one contact&quot;)        return    try:        chat_id = await bot.create_chat(            bot_id=message.bot.id,            name=&quot;New group chat&quot;,            chat_type=ChatTypes.GROUP_CHAT,            huids=[contact.entity_id for contact in contacts],        )    except (ChatCreationProhibitedError, ChatCreationError) as exc:        await bot.answer_message(str(exc))        return    chat_mention = MentionBuilder.chat(chat_id)    await bot.answer_message(f&quot;Chat created: {chat_mention}&quot;)```### Получение списка пользователей*([подробное описание функции](https://ccsteam.atlassian.net/wiki/spaces/SMARTAPP/pages/311001185/Bot+API+BotX+API#%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D0%B5%D0%B9-%D0%BD%D0%B0-CTS))*```pythonfrom pybotx import *collector = HandlerCollector()@collector.command(&quot;/get_users_list&quot;, description=&quot;Get a list of users&quot;)async def users_list_handler(message: IncomingMessage, bot: Bot) -&gt; None:    async with bot.users_as_csv(        bot_id=message.bot.id,        cts_user=True,        unregistered=False,        botx=False,    ) as users:        async for user in users:            print(user)```</longdescription>
</pkgmetadata>