<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># JSON TableA little package to convert a JSON into a table! This project was born out of a need to transform many JSONs mined from APIs to something that Pandas or a relational database could understand. The difference between this package and json path packages is that its designed to create __tables__, not just extract single values.&lt;a href=&quot;https://pypi.org/project/jsontable/&quot;&gt;&lt;img src=&quot;https://img.shields.io/pypi/v/jsontable.svg&quot; alt=&quot;latest release&quot; /&gt;&lt;/a&gt;## How to installThe package is available through pypi. So simply go to your command line and:```bashpip install jsontable```You're also welcome to download the code from github and modify to suit your needs. And if you have time let me know what cool functionality you added and we can improve the project!## How it worksIt works in a similar manner to JSON parsers1. Create a converter object2. Give the converter a list of paths you want to explore and how you want to name each column3. Give the converter a __decoded__ JSON object you want to read, and it returns a table## UsageHere is a quick example to get you going```pythonimport jsontable as jsontable#Create a list of paths you want to extractpaths = [{&quot;$.id&quot;:&quot;id&quot;},{&quot;$.name&quot;:&quot;name&quot;}, {&quot;$.address.city&quot;:&quot;city&quot;}]#The JSON object you want to exploresample = {&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;Foo&quot;,&quot;address&quot;:{&quot;city&quot;:&quot;Bar&quot;}}#Create an instance of a converterconverter = jsontable.converter()#Set the paths you want to extractconverter.set_paths(paths)#Input a JSON to be interpretedconverter.convert_json(sample)```In this case, you will get a table with two columns and two rows (header and first row of data) like these:```python[['id', 'name', 'city'], ['1', 'Foo', 'Bar']]```For more examples, refer to the [tests folder](/tests)## How it works#### JSON PathsEach path you specify is a column in your final table. Each path that is setup is expanded according to the [standard JSON Path functionality](https://goessner.net/articles/JsonPath/). This is, for each path, the converter starts at the root of the JSON object and navigates each step (a.k.a node) of the path in order. When it reaches the final step in the path (a.k.a leaf), it outputs the resulting element of the JSON into the cell.The __final cell value__ is converted based on the [standard JSON values](https://www.json.org/) as follows:|JSON Value|Conversion|Sample Output||--|--|--||object|stringified object |`'{&quot;city&quot;:&quot;Bar&quot;}'`||array|stringified array |`'[1,2,3]'`||string|string|'Foo'||number|number|4.7||boolean|stringidied boolean|'False'||null|None|None||_missing value_ (i.e. the path did not find an element)|None|None|The intention behind stringifying the object, array and boolean is to be able to pass the output to other data libraries (e.g [Pandas](https://pandas.pydata.org/))  or to a relational database. #### Array Expansion__With the exception of the final node__, array elements are automatically expanded into rows. So for example a path `'$.a.b'` applied to a JSON `{&quot;a&quot;:[{&quot;b&quot;:1},{&quot;b&quot;:2}]}` would result into two rows `[[1],[2]]`. The array expansion functionality can be applied to the final node by explicitly using the `*` operator as a final step (e.g. `$.a.*`)Example:```pythonpaths = [{&quot;$.name&quot;:&quot;Name&quot;},{&quot;$.telephones.type&quot;:&quot;Telephone Type&quot;},{&quot;$.telephones.number&quot;:&quot;Telephone Number&quot;}]sample = {&quot;name&quot;:&quot;Foo&quot;,&quot;telephones&quot;:[{&quot;type&quot;:&quot;mobile&quot;, &quot;number&quot;:&quot;0000&quot;},{&quot;type&quot;:&quot;home&quot;, &quot;number&quot;:&quot;1111&quot;}]}converter = jsontable.converter()converter.set_paths(paths)converter.convert_json(sample)```Result:```[['Name', 'Telephone Number', 'Telephone Type'], ['Foo', '0000', 'mobile'], ['Foo', '1111', 'home']]```The reverse of this functionality (not expand arrays if they are encountered before the end) is not implemented only due to the lack of need.#### Joining ColumnsSince a path may result in multiple rows, there is the need to be able to combine the result of each column into the same table. The joining mechanism is similar to an SQL join, where each cell (row-cell combination) is &quot;matched&quot; to a row in the result using a &quot;matching value&quot;. The matching value in this case is the last common element of the paths. This is best illustrated with an example, the following table shows the transformations applied to the sample JSON.```pythonsample = {&quot;contacts&quot;:[{&quot;name&quot;:&quot;Foo&quot;,&quot;telephones&quot;:[{&quot;type&quot;:&quot;mobile&quot;, &quot;number&quot;:&quot;0000&quot;},{&quot;type&quot;:&quot;home&quot;, &quot;number&quot;:&quot;1111&quot;}],&quot;emails&quot;:[{&quot;type&quot;:&quot;work&quot;, &quot;email&quot;:&quot;foo@w.com&quot;},{&quot;type&quot;:&quot;personal&quot;, &quot;email&quot;:&quot;foo@p.com&quot;}]},{&quot;name&quot;:&quot;Bar&quot;,&quot;telephones&quot;:[{&quot;type&quot;:&quot;mobile&quot;, &quot;number&quot;:&quot;2222&quot;},{&quot;type&quot;:&quot;home&quot;, &quot;number&quot;:&quot;3333&quot;}],&quot;emails&quot;:[{&quot;type&quot;:&quot;work&quot;, &quot;email&quot;:&quot;bar@w.com&quot;},{&quot;type&quot;:&quot;personal&quot;, &quot;email&quot;:&quot;bar@p.com&quot;}]}]}```&lt;table&gt;&lt;tr&gt;&lt;th&gt;Paths&lt;/th&gt;&lt;th&gt;Result&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre lang=&quot;python&quot;&gt;[{&quot;$.contacts.name&quot;:&quot;Name&quot;},{&quot;$.contacts.telephones.type&quot;:&quot;Type&quot;},{&quot;$.contacts.telephones.number&quot;:&quot;Number&quot;}]&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre lang=&quot;python&quot;&gt;[['Name', 'Type', 'Number'], ['Foo', 'mobile', '0000'], ['Foo', 'home', '1111'], ['Bar', 'mobile', '2222'], ['Bar', 'home', '3333']]&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre lang=&quot;python&quot;&gt;[{&quot;$.contacts.name&quot;:&quot;Name&quot;},{&quot;$.contacts.telephones.number&quot;:&quot;Number&quot;},{&quot;$.contacts.emails.email&quot;:&quot;Email&quot;}]&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre lang=&quot;python&quot;&gt;[['Name', 'Number', 'Email'], ['Foo', '0000', 'foo@w.com'], ['Foo', '1111', 'foo@w.com'],['Foo', '0000', 'foo@p.com'], ['Foo', '1111', 'foo@p.com'],  ['Bar', '0000', 'bar@w.com'], ['Bar', '1111', 'bar@w.com'],['Bar', '0000', 'bar@p.com'], ['Bar', '1111', 'bar@p.com'],  ]&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;In the first case, the `type` and `number` have a common path `telephone` and therefore the columns are combined for the same telephone element. If we then look at the `name` path it has a common path `contacts` with the rest of the columns, and therefore, the value is repeated across the rows.In the second case the `email` and `number` only have a common path `contacts` and since each path results in two rows, the only possible way to match these is to combine all the values, resulting in 4 rows per contact (total 8 rows since there are 2 contacts). ## OperatorsCurrently there are two operators supported: * and ~|Syntax|Description||--|--||`*`| Returns __all values__ of the current element. If its an array, it will return one row per array value. If its an object (dictionary in Python) it will return one row per __value__. If its a value (string, number, boolean, null), it returns the same value||`~`| Return __all indices__ of the current element. If its an array, it returns an ascending numbered sequence starting with 0 (e.g. [1,2] would return [[0],[1]]) . If its an object, it will return the keys (e.g. {&quot;a&quot;:1,&quot;b&quot;:2} would return [['a'],['b']]). If its a value it returns 0|More operators will be implemented in later releases.## New in this version - A bug that was preventing list expansions at different depths (e.g. $.a as well as $.b.c) has been fixed. - Implementation of the * and ~ operatorsBoth these changes were made possible by changing the search method from depth first to breadth first, as well as recursing through a tree rather than iterating through one column at a time. ## Coming upIn the wishlist we have: - Filtering - List indexing - More functions (basic arithmetics, string concatenation and expansion) - Square bracket notation ($[a][b] for $.a.b) - Stringify objects as an option - Option to output pandas style named array - Method to set paths and convert at the same time - CSV Output/Input## ReferencesI want to mention that whilst I inted to expand the functionality of this package, at the moment it can only take a simple sequence of keys to navigate a path. This is, the full functionality proposed by Stefan Gossner in his [jsonpath](https://goessner.net/articles/JsonPath/) is not yet implemented.... but we will get there.If you are looking for a package that simply extracts a single value from a JSON by using more complex paths (and its functions), I recommend you look at [jsonpath-rw](https://github.com/kennknowles/python-jsonpath-rw) by Kenn Knowles [jsonpath-ng](https://pypi.org/project/jsonpath-ng/) by Tomas Aparicio or [jsonpath2](https://pypi.org/project/jsonpath2/) by Mark Borkum. ## Final disclaimerI will continue to look for improvements in the package and hopefully add some useful functionality. Given the current popularity of the package, the maintenance is in a best effort manner. However if you have issues or bugs to report let me know [here](/issues) and I will try my best to help. You can use this package as you wish, but unfortunatelly, I cannot take responsibility of how this code is used, or the results it provides. It is up to you to test this does what you want it to!</longdescription>
</pkgmetadata>