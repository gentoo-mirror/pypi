<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># SQL Views for Postgres[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/mypebble/django-pgviews?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge)[![Circle CI](https://circleci.com/gh/mypebble/django-pgviews.png)](https://circleci.com/gh/mypebble/django-pgviews)Adds first-class support for [PostgreSQL Views][pg-views] in the Django ORM[pg-views]: http://www.postgresql.org/docs/9.1/static/sql-createview.html## InstallationInstall via pip:    pip install django-pgviewsAdd to installed applications in settings.py:```pythonINSTALLED_APPS = (  # ...  'django_pgviews',)```## Examples```pythonfrom django.db import modelsfrom django_pgviews import view as pgclass Customer(models.Model):    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)    is_preferred = models.BooleanField(default=False)    class Meta:        app_label = 'myapp'class PreferredCustomer(pg.View):    projection = ['myapp.Customer.*',]    dependencies = ['myapp.OtherView',]    sql = &quot;&quot;&quot;SELECT * FROM myapp_customer WHERE is_preferred = TRUE;&quot;&quot;&quot;    class Meta:      app_label = 'myapp'      db_table = 'myapp_preferredcustomer'      managed = False```**NOTE** It is important that we include the `managed = False` in the `Meta` soDjango 1.7 migrations don't attempt to create DB tables for this view.The SQL produced by this might look like:```postgresqlCREATE VIEW myapp_preferredcustomer ASSELECT * FROM myapp_customer WHERE is_preferred = TRUE;```To create all your views, run ``python manage.py sync_pgviews``You can also specify field names, which will map onto fields in your View:```pythonfrom django_pgviews import view as pgVIEW_SQL = &quot;&quot;&quot;    SELECT name, post_code FROM myapp_customer WHERE is_preferred = TRUE&quot;&quot;&quot;class PreferredCustomer(pg.View):    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)    sql = VIEW_SQL```## UsageTo map onto a View, simply extend `pg_views.view.View`, assign SQL to the`sql` argument and define a `db_table`. You must _always_ set `managed = False`on the `Meta` class.Views can be created in a number of ways:1. Define fields to map onto the VIEW output2. Define a projection that describes the VIEW fields### Define FieldsDefine the fields as you would with any Django Model:```pythonfrom django_pgviews import view as pgVIEW_SQL = &quot;&quot;&quot;    SELECT name, post_code FROM myapp_customer WHERE is_preferred = TRUE&quot;&quot;&quot;class PreferredCustomer(pg.View):    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)    sql = VIEW_SQL    class Meta:      managed = False      db_table = 'my_sql_view'```### Define Projection`django-pgviews` can take a projection to figure out what fields it needs tomap onto for a view. To use this, set the `projection` attribute:```pythonfrom django_pgviews import view as pgclass PreferredCustomer(pg.View):    projection = ['myapp.Customer.*',]    sql = &quot;&quot;&quot;SELECT * FROM myapp_customer WHERE is_preferred = TRUE;&quot;&quot;&quot;    class Meta:      db_table = 'my_sql_view'      managed = False```This will take all fields on `myapp.Customer` and apply them to`PreferredCustomer`## Features### Updating ViewsSometimes your models change and you need your Database Views to reflect the newdata. Updating the View logic is as simple as modifying the underlying SQL andrunning:```python manage.py sync_pgviews --force```This will forcibly update any views that conflict with your new SQL.### DependenciesYou can specify other views you depend on. This ensures the other views areinstalled beforehand. Using dependencies also ensures that your views getrefreshed correctly when using `sync_pgviews --force`.**Note:** Views are synced after the Django application has migrated and addingmodels to the dependency list will cause syncing to fail.Example:```pythonfrom django_pgviews import view as pgclass PreferredCustomer(pg.View):    dependencies = ['myapp.OtherView',]    sql = &quot;&quot;&quot;SELECT * FROM myapp_customer WHERE is_preferred = TRUE;&quot;&quot;&quot;    class Meta:      app_label = 'myapp'      db_table = 'myapp_preferredcustomer'      managed = False```### Materialized ViewsPostgres 9.3 and up supports [materialized views](http://www.postgresql.org/docs/current/static/sql-creatematerializedview.html)which allow you to cache the results of views, potentially allowing themto load faster.However, you do need to manually refresh the view. To do this automatically,you can attach [signals](https://docs.djangoproject.com/en/1.8/ref/signals/)and call the refresh function.Example:```pythonfrom django_pgviews import view as pgVIEW_SQL = &quot;&quot;&quot;    SELECT name, post_code FROM myapp_customer WHERE is_preferred = TRUE&quot;&quot;&quot;class Customer(models.Model):    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)    is_preferred = models.BooleanField(default=True)class PreferredCustomer(pg.MaterializedView):    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)    sql = VIEW_SQL@receiver(post_save, sender=Customer)def customer_saved(sender, action=None, instance=None, **kwargs):    PreferredCustomer.refresh()```Postgres 9.4 and up allow materialized views to be refreshed concurrently, without blocking reads, as long as aunique index exists on the materialized view. To enable concurrent refresh, specify the name of a column that can beused as a unique index on the materialized view. Unique index can be defined on more than one column of a materializedview. Once enabled, passing `concurrently=True` to the model's refresh method will result in postgres performing therefresh concurrently. (Note that the refresh method itself blocks until the refresh is complete; concurrent refresh ismost useful when materialized views are updated in another process or thread.)Example:```pythonfrom django_pgviews import view as pgVIEW_SQL = &quot;&quot;&quot;    SELECT id, name, post_code FROM myapp_customer WHERE is_preferred = TRUE&quot;&quot;&quot;class PreferredCustomer(pg.MaterializedView):    concurrent_index = 'id, post_code'    sql = VIEW_SQL    name = models.CharField(max_length=100)    post_code = models.CharField(max_length=20)@receiver(post_save, sender=Customer)def customer_saved(sender, action=None, instance=None, **kwargs):    PreferredCustomer.refresh(concurrently=True)```### Custom SchemaYou can define any table name you wish for your views. They can even live inside your own custom[PostgreSQL schema](http://www.postgresql.org/docs/current/static/ddl-schemas.html).```pythonfrom django_pgviews import view as pgclass PreferredCustomer(pg.View):    sql = &quot;&quot;&quot;SELECT * FROM myapp_customer WHERE is_preferred = TRUE;&quot;&quot;&quot;    class Meta:      db_table = 'my_custom_schema.preferredcustomer'      managed = False```### Sync Listenersdjango-pgviews 0.5.0 adds the ability to listen to when a `post_sync` event hasoccurred.#### `view_synced`Fired every time a VIEW is synchronised with the database.Provides args:* `sender` - View Class* `update` - Whether the view to be updated* `force` - Whether `force` was passed* `status` - The result of creating the view e.g. `EXISTS`, `FORCE_REQUIRED`* `has_changed` - Whether the view had to change#### `all_views_synced`Sent after all Postgres VIEWs are synchronised.Provides args:* `sender` - Always `None`## Django Compatibility&lt;table&gt;  &lt;thead&gt;    &lt;tr&gt;      &lt;th&gt;Django Version&lt;/th&gt;      &lt;th&gt;Django-PGView Version&lt;/th&gt;    &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr&gt;      &lt;td&gt;1.4 and down&lt;/td&gt;      &lt;td&gt;Unsupported&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1.5&lt;/td&gt;      &lt;td&gt;0.0.1&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1.6&lt;/td&gt;      &lt;td&gt;0.0.3&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1.7&lt;/td&gt;      &lt;td&gt;0.0.4&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1.9&lt;/td&gt;      &lt;td&gt;0.1.0&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1.10&lt;/td&gt;      &lt;td&gt;0.2.0&lt;/td&gt;    &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;### Django 1.7 NoteDjango 1.7 changed how models are loaded so that it's no longer possible to do`sql = str(User.objects.all().query)` because the dependent models aren'tyet loaded by Django.### Django 1.9 NoteYou now have to use the `.view` module directly.### Django 1.10 NoteWhen updating to Django 1.10, if you see `AttributeError: can't set attribute`when you try to migrate or run tests, you need to check your migrations forwhere `_base_manager` or `_default_manager` get set on the model and replace itwith `objects` inside the migration.This also applies to [Django MPTT](https://django-mptt.github.io/django-mptt/upgrade.html#id1)who have covered this in a bit more detail.## Python 3 SupportDjango PGViews supports Python 3 in versions 0.0.7 and above.## Django 3.0 NoteChanged `from django.utils import six` to `import six` in the `views.py` file, and added `six` as a dependency module due to the module being removed from Django.</longdescription>
</pkgmetadata>