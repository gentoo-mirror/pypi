<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![PyPI](https://github.com/a-nau/yaml2pyclass/actions/workflows/pypi_publish.yml/badge.svg)](https://github.com/a-nau/yaml2pyclass/actions/workflows/pypi_publish.yml)[![test](https://github.com/a-nau/yaml2pyclass/workflows/test/badge.svg)](https://github.com/a-nau/yaml2pyclass/actions)# yaml2pyclass Code GeneratorThis package enables you to easily generate and instantiate dataclasses from an input `YAML` file. For examplethis `YAML` file```yamlimage_size: [ 1280, 960 ]cluster_config:  eps: 0.02  min_num_samples: 10path_output: &quot;./output&quot;```automatically converts to a Python `class````pythonimport dataclassesimport yaml2pyclassclass Config(yaml2pyclass.CodeGenerator):    @dataclasses.dataclass    class ClusterConfigClass:        eps: float        min_num_samples: int    image_size: list    cluster_config: ClusterConfigClass    path_output: str```In addition to code creation, an instance of the generated class that is initialized with the `YAML`s values can becreated automatically.The use case it was primarily developed for is facilitating code completion for arbitrary `YAML` config files.Using `YAML` files as input config allows flexible and general information passing, however, whenusing [`pyyaml`](https://pypi.org/project/PyYAML/) theinformation is saved as a `dict` which does not support any automatic code completion. This means, that you need to knowthe exact variable names for access.Using this package you can enjoy `YAML`s flexibility and generality, while additionally providing the benefit of codecompletion and type specific suggestions from your IDE. Thus, no need to memorize exact variable names or types.## InstallationYou can install the package using `pip````shellpip install yaml2pyclass```## Usage### File UpdateTo update an existing file, as e.g. in the case of a config file, you need to create a base file. The base file (e.g.at `path/to/config.py`) should simply contain a class, that inherits from the `yaml2pyclass` base class `CodeGenerator`:```pythonimport yaml2pyclassclass Config(yaml2pyclass.CodeGenerator):    # content is updated automatically from the specified YAML file    pass```Then, in the function where you want to use this class based on the `YAML` input, import the created class and callthe `from_yaml` function```pythonfrom path.to.config import Config  # import the class Config from the path/to/config.py fileconfig = Config.from_yaml(&quot;config.yaml&quot;)```This will update the file of the `Config` class with dataclass that matches the input `YAML`.## ContributorsThis project is a collaboration with [Felix Hertlein](https://github.com/FelixHertlein).## LicenseThis code is distributed under the 3-Clause BSD License, see [LICENSE](LICENSE).</longdescription>
</pkgmetadata>