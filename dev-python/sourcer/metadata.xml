<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># SourcerA parsing library for Python.## What's it look like?First, define your grammar:```pythonfrom sourcer import Grammarg = Grammar(r'''    class Greeting {        salutation: &quot;Hello&quot; | &quot;Hi&quot;i        audience: Punctuation* &gt;&gt; Word &lt;&lt; Punctuation*    }    Word = /[a-z]+/i    Punctuation = &quot;.&quot; | &quot;!&quot; | &quot;?&quot; | &quot;,&quot;    ignore /\s+/    start = Greeting''')```Sourcer compiles your grammar to a Python module.Then, use your grammar to parse things:```python&gt;&gt;&gt; g.parse('Hello, World!')Greeting(salutation='Hello', audience='World')&gt;&gt;&gt; g.parse('Hello?? Anybody?!')Greeting(salutation='Hello', audience='Anybody')&gt;&gt;&gt; g.parse('hi all')Greeting(salutation='hi', audience='all')```## InstallationUse pip:```console$ python3 -m pip install sourcer```Sourcer requires Python version 3.6 or later.## Examples### Arithmetic Expressions```pythonfrom sourcer import Grammar# The Grammar is compiled to a Python module and assigned to &quot;g&quot;.g = Grammar(r'''    start = Expr    # Define operatator precedence, from highest to lowest. Use &quot;left&quot; for    # left associative operators, and &quot;right&quot; for right associative operators.    Expr = Int between {        mixfix: '(' &gt;&gt; Expr &lt;&lt; ')'        prefix: '+', '-'        right: '^'        postfix: '%'        left: '*', '/'        left: '+', '-'    }    # Turn integers into Python int objects.    Int = /\d+/ |&gt; `int`    # Ignore whitespace.    ignore /\s+/''')# Some examples:assert g.parse('1 + 2 + 3') == g.Infix(g.Infix(1, '+', 2), '+', 3)assert g.parse('4 + -5 / 6') == g.Infix(4, '+', g.Infix(g.Prefix('-', 5), '/', 6))assert g.parse('7 * (8 + 9)') == g.Infix(7, '*', g.Infix(8, '+', 9))```### Something Like JSONMaybe you have to parse something that is a little bit like JSON, but differentenough that you can't use a real JSON parser.Here's a simple example that you can start with and work from, and build it upinto what you need.```pythonfrom sourcer import Grammarg = Grammar(r'''    # Import Python modules by quoting your import statement in backticks.    # (You can also use triple backticks to quote multiple lines at once.)    `from ast import literal_eval`    # This grammar parses one value.    start = Value    # A value is one of these things.    Value = Object | Array | String | Number | Keyword    # An object is zero or more members separated by commas, enclosed in    # curly braces. Convert each into a Python dict.    Object = &quot;{&quot; &gt;&gt; (Member // &quot;,&quot;) &lt;&lt; &quot;}&quot; |&gt; `dict`    # A member is a pair of string literal and value, separated by a colon.    Member = [String, &quot;:&quot; &gt;&gt; Value]    # An array is zero or more values separated by commas, enclosed in    # square braces.    Array = &quot;[&quot; &gt;&gt; (Value // &quot;,&quot;) &lt;&lt; &quot;]&quot;    # Interpret each string as a Python literal string.    String = /&quot;(?:[^\\&quot;]|\\.)*&quot;/ |&gt; `literal_eval`    # Interpret each number as a Python float literal.    Number = /-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/ |&gt; `float`    # Convert boolean literals to Python booleans, and &quot;null&quot; to None.    Keyword = &quot;true&quot; &gt;&gt; `True` | &quot;false&quot; &gt;&gt; `False` | &quot;null&quot; &gt;&gt; `None`    ignore /\s+/''')# Notice that we get back Python dicts, lists, strings, booleans, etc.result = g.parse('{&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: true}')assert result == {'foo': 'bar', 'baz': True}result = g.parse('[12, -34, {&quot;56&quot;: 78, &quot;foo&quot;: null}]')assert result == [12, -34, {'56': 78, 'foo': None}]```### Using ClassesClasses let you define the types of objects in your parse tree.```pythonfrom sourcer import Grammarg = Grammar(r'''    # A list of commands separated by semicolons.    start = Command /? &quot;;&quot;    # A pair of action and range.    class Command {        action: &quot;Copy&quot; | &quot;Delete&quot; | &quot;Print&quot;        range: Range    }    # A range (which can be open or closed on either end).    class Range {        start: &quot;(&quot; | &quot;[&quot;        left: Int &lt;&lt; &quot;,&quot;        right: Int        end: &quot;]&quot; | &quot;)&quot;    }    # Integers.    Int = /\d+/ |&gt; `int`    ignore /\s+/''')result = g.parse('Print [10, 20); Delete (33, 44];')assert result == [    g.Command(action='Print', range=g.Range('[', 10, 20, ')')),    g.Command(action='Delete', range=g.Range('(', 33, 44, ']')),]cmd = result[1]assert cmd.action == 'Delete'# The Command objects have position information:info = cmd._metadata.position_infoassert info.start == g._Position(index=16, line=1, column=17)assert info.end == g._Position(index=30, line=1, column=31)```### Something Like XMLMaybe you have to parse something where you have matching start and end tags.Here's a simple example that you can work from.```pythonfrom sourcer import Grammarg = Grammar(r'''    # A document is a list of one or more items:    Document = Item+    # An item is either an element or some text:    Item = Element | Text    # Text goes until it sees a &quot;&lt;&quot; character:    class Text {        content: /[^&lt;]+/    }    # An element is a pair of matching tags, and zero or more items:    class Element {        open: &quot;&lt;&quot; &gt;&gt; Word &lt;&lt; &quot;&gt;&quot;        items: Item*        close: &quot;&lt;/&quot; &gt;&gt; Word &lt;&lt; &quot;&gt;&quot; where `lambda x: x == open`    }    # A word doesn't have special characters, and doesn't start with a digit:    Word = /[_a-zA-Z][_a-zA-Z0-9]*/''')# We can use the &quot;Document&quot; rule directly:result = g.Document.parse('To: &lt;party&gt;&lt;b&gt;Second&lt;/b&gt; Floor Only&lt;/party&gt;')assert result == [    g.Text('To: '),    g.Element(        open='party',        items=[            g.Element('b', [g.Text('Second')], 'b'),            g.Text(' Floor Only'),        ],        close='party',    ),]# Similarly, we can use any of our other rules directly, too. For example, maybe# we just want to parse a single word:result = g.Word.parse('booyah')assert result == 'booyah' # (But yes, this doesn't really accomplish anything...)```### Significant IndentationIf you ever need to parse something with significant indentation, you can startwith this example and build it up.```pythonfrom sourcer import Grammarg = Grammar(r'''    ignore /[ \t]+/    Indent = /\n[ \t]*/    MatchIndent(i) =&gt;        Indent where `lambda x: x == i`    IncreaseIndent(i) =&gt;        Indent where `lambda x: len(x) &gt; len(i)`    Body(current_indent) =&gt;        let i = IncreaseIndent(current_indent) in        Statement(i) // MatchIndent(i)    Statement(current_indent) =&gt;        If(current_indent) | Print    class If(current_indent) {        test: &quot;if&quot; &gt;&gt; Name        body: Body(current_indent)    }    class Print {        name: &quot;print&quot; &gt;&gt; Name    }    Name = /[a-zA-Z]+/    Newline = /[\r\n]+/    Start = Opt(Newline) &gt;&gt; (Statement('') /? Newline)''')from textwrap import dedentresult = g.parse('print ok\nprint bye')assert result == [g.Print('ok'), g.Print('bye')]result = g.parse('if foo\n  print bar')assert result == [g.If('foo', [g.Print('bar')])]result = g.parse(dedent('''    print ok    if foo        if bar            print baz            print fiz        print buz    print zim'''))assert result == [    g.Print('ok'),    g.If('foo', [        g.If('bar', [            g.Print('baz'),            g.Print('fiz'),        ]),        g.Print('buz'),    ]),    g.Print('zim'),]```### More Examples[Excel formula](https://github.com/jvs/sourcer/tree/master/examples)and some corresponding[test cases](https://github.com/jvs/sourcer/blob/master/tests/test_excel.py)## Background[Parsing expression grammar](http://en.wikipedia.org/wiki/Parsing_expression_grammar&gt;)The main thing to know is that the `|` operator represents an ordered choice.## Parsing ExpressionsThis is work in progress. The goal is to provide examples of each of thedifferent parsing expressions.For now, here's a list of the supported expressions:- Binding:    - `let foo = bar in baz` -- parses bar, binding the result to foo, then      parses baz.- Class:    - `class Foo { bar: Bar; baz: Baz }` -- defines a sequence of named elements.- Expectation (Lookahead):    - `Expect(foo)` -- parses foo without consuming any input.    - `ExpectNot(foo)` -- fails if it can parse foo.- Failure:    - `Fail(message)` -- fails with the provided error message.- Function Application:    - `foo |&gt; bar` -- parses foo then parses bar, then returns `bar(foo)`.    - `foo &lt;| bar` -- parses foo then parses bar, then returns `foo(bar)`.- Operator Precedence:    - `foo between { ... }` -- defines an operator precedence table.- Option:    - `foo?` -- parse foo, if that fails then return `None`.    - `Opt(foo)` -- verbose form of `foo?`.- Ordered Choice:    - `foo | bar` -- parses foo, and if that fails, then tries bar.- Python Expression:    - `` `foo` `` -- returns the Python value `foo`, without consuming any input.- Predicate:    - `foo where bar` -- parses foo, then bar, returning foo only if      `bar(foo)` returns `True` (or some other truthy value).- Projection:    - `foo &gt;&gt; bar` -- parses foo, then parses bar, returning only bar.    - `foo &lt;&lt; bar` -- parses foo, then parses bar, returning only foo.- Regular Expression:    - `/foo/` -- matches the regular expression foo.    - `/foo/i` -- matches the regular expression foo, ignoring case.    - `/(?i)foo/` -- matches the regular expression foo, also ignoring case.- Repetition:    - `foo*` -- parses foo zero or more times, returning the results in a list.    - `foo+` -- parses foo one or more times.    - `List(foo)` -- verbose form of `foo*`.    - `Some(foo)` -- verbose form of `foo+`.- Separated List:    - `foo /? bar` -- parses a list of foo separated by bar, consuming      an optional trailing separator.    - `foo // bar` -- parses a list of foo separated by bar, and does      not consume a trailing separator.    - In both cases, returns the list of foo values and discards the bar      values.- Sequence:    - `[foo, bar, baz]` -- parses foo, then bar, then baz, returning the      results in a list.- String Matching:    - `'foo'` -- matches the string &quot;foo&quot;.    - `'foo'i` -- matches the string &quot;foo&quot;, ignoring case.- Template Instatiation:    - `foo(bar)` -- parses the rule foo using the parsing expression bar.### Generating A Python FileReally quickly, if you want to generate Python source code from your grammar,and perhaps save the source to a file, here's an example:```pythonfrom sourcer import Grammarg = Grammar(    r'''        start = &quot;Hello&quot; &gt;&gt; /[a-zA-Z]+/        ignore /[ \t]+/        ignore &quot;,&quot; | &quot;.&quot; | &quot;!&quot; | &quot;?&quot;    ''',    # Add the optional &quot;include_source&quot; flag:    include_source=True,)# The Python code is in the `_source_code` field:assert 'def parse' in g._source_code```You can then take the `_source_code` field of your grammar and write it to afile as part of your build.## Why does this exist?Sometimes you have to parse things, and sometimes a regex won't cut it.Things you might have to parse someday:- log files- business rules- market data feeds- equations- queries- user input- domain specific languages- obscure data formats- legacy source codeSo that's what this library is for. It's for when you have to take some textand turn it into a tree of Python objects.#### But aren't there a ton of parsing libraries for Python already?Yes, there are. Most of them focus on different problems. Sourcer focuses on theoutput of parsing, rather than the means. The main point of Sourcer is that youcan just define the thing that you really want, and then get on with your life.## Features- Supports Python version 3.6 and later.- Create parsers at runtime, or generate Python source code as part of your build.- Implements [Parsing Expression Grammars](http://en.wikipedia.org/wiki/Parsing_expression_grammar)  (where &quot;|&quot; represents ordered choice).- Built-in support for operator precedence parsing.- Supports inline Python, for defining predicates and transformations directly  within grammars.- Supports class definitions for defining the structure of your parse trees.- Each rule in a grammar becomes a top-level function in the generated Python  module, so you can use a grammar as a parsing library, rather than just a  monolithic &quot;parse&quot; function.- Supports data dependent rules, for things like:    - significant indentation    - matching start and end tags</longdescription>
</pkgmetadata>