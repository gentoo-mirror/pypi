<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Pydantic-resolve[![CI](https://github.com/allmonday/pydantic_resolve/actions/workflows/ci.yml/badge.svg)](https://github.com/allmonday/pydantic_resolve/actions/workflows/ci.yml)![Python Versions](https://img.shields.io/pypi/pyversions/pydantic-resolve)![Test Coverage](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/allmonday/6f1661c6310e1b31c9a10b0d09d52d11/raw/covbadge.json)[![pypi](https://img.shields.io/pypi/v/pydantic-resolve.svg)](https://pypi.python.org/pypi/pydantic-resolve)[![Downloads](https://static.pepy.tech/personalized-badge/pydantic-resolve?period=month&amp;units=abbreviation&amp;left_color=grey&amp;right_color=orange&amp;left_text=Downloads)](https://pepy.tech/project/pydantic-resolve)&gt; A small yet powerful package which can run resolvers to generate deep nested datasets.[Change log](./changelog.md)**example**:```python# prepare dataloaderimport asynciofrom typing import List, Optionalfrom pydantic import BaseModelfrom pydantic_resolve import Resolver, mapper, LoaderDepend# define dataset and loader functionsasync def friends_batch_load_fn(names):    mock_db = {        'tangkikodo': ['tom', 'jerry'],        'john': ['mike', 'wallace'],        'trump': ['sam', 'jim'],        'sally': ['sindy', 'lydia'],    }    return [mock_db.get(name, []) for name in names]async def contact_batch_load_fn(names):    mock_db = {        'tom': 1001, 'jerry': 1002, 'mike': 1003, 'wallace': 1004, 'sam': 1005,        'jim': 1006, 'sindy': 1007, 'lydia': 1008, 'tangkikodo': 1009, 'john': 1010,        'trump': 2011, 'sally': 2012,    }    result = []    for name in names:        n = mock_db.get(name, None)        result.append({'number': n} if n else None)    return result``````python# define data schemasclass Contact(BaseModel):    number: Optional[int]class Friend(BaseModel):    name: str    contact: Optional[Contact] = None    def resolve_contact(self, contact_loader=LoaderDepend(contact_batch_load_fn)):        return contact_loader.load(self.name)    is_contact_10: bool = False    def post_is_contact_10(self):                             # 3. after resolve_contact executed, do extra computation        if self.contact:            if str(self.contact.number).startswith('10'):                self.is_contact_10 = True        else:            self.is_contact_10 = Falseclass User(BaseModel):    name: str    age: int    greeting: str = ''    async def resolve_greeting(self):        await asyncio.sleep(1)        return f&quot;hello, i'm {self.name}, {self.age} years old.&quot;    contact: Optional[Contact] = None    def resolve_contact(self, contact_loader=LoaderDepend(contact_batch_load_fn)):        return contact_loader.load(self.name)    friends: List[Friend] = []    @mapper(lambda names: [Friend(name=name) for name in names])  # manually convert    def resolve_friends(self, friend_loader=LoaderDepend(friends_batch_load_fn)):        return friend_loader.load(self.name)    friend_count: int = 0    def post_friend_count(self):        self.friend_count = len(self.friends)class Root(BaseModel):    users: List[User] = []    def resolve_users(self):        return [            {&quot;name&quot;: &quot;tangkikodo&quot;, &quot;age&quot;: 19},            {&quot;name&quot;: &quot;john&quot;, &quot;age&quot;: 20},            {&quot;name&quot;: &quot;trump&quot;, &quot;age&quot;: 21},            {&quot;name&quot;: &quot;sally&quot;, &quot;age&quot;: 22},            {&quot;name&quot;: &quot;no man&quot;, &quot;age&quot;: 23},        ]``````python# resolve resultsasync def main():    import json    root = Root()    root = await Resolver().resolve(root)                 # 4. run it    dct = root.dict()    print(json.dumps(dct, indent=4))asyncio.run(main())```**output**:```json{  &quot;users&quot;: [    {      &quot;name&quot;: &quot;tangkikodo&quot;,      &quot;age&quot;: 19,      &quot;greeting&quot;: &quot;hello, i'm tangkikodo, 19 years old.&quot;,      &quot;contact&quot;: {        &quot;number&quot;: 1009      },      &quot;friends&quot;: [        {          &quot;name&quot;: &quot;tom&quot;,          &quot;contact&quot;: {            &quot;number&quot;: 1001          },          &quot;is_contact_10&quot;: true        },        {          &quot;name&quot;: &quot;jerry&quot;,          &quot;contact&quot;: {            &quot;number&quot;: 1002          },          &quot;is_contact_10&quot;: true        }      ],      &quot;friend_count&quot;: 2    },    {      &quot;name&quot;: &quot;john&quot;,      &quot;age&quot;: 20,      &quot;greeting&quot;: &quot;hello, i'm john, 20 years old.&quot;,      &quot;contact&quot;: {        &quot;number&quot;: 1010      },      &quot;friends&quot;: [        {          &quot;name&quot;: &quot;mike&quot;,          &quot;contact&quot;: {            &quot;number&quot;: 1003          },          &quot;is_contact_10&quot;: true        },        {          &quot;name&quot;: &quot;wallace&quot;,          &quot;contact&quot;: {            &quot;number&quot;: 1004          },          &quot;is_contact_10&quot;: true        }      ],      &quot;friend_count&quot;: 2    },    ...    ,    {      &quot;name&quot;: &quot;no man&quot;,      &quot;age&quot;: 23,      &quot;greeting&quot;: &quot;hello, i'm no man, 23 years old.&quot;,      &quot;contact&quot;: null,      &quot;friends&quot;: [],      &quot;friend_count&quot;: 0    }  ]}```## Install```shellpip install pydantic-resolve```- use `resolve` for simple scenario,- use `Resolver` and `LoaderDepend` for complicated nested batch query.## API`Resolver(loader_filters, loader_instances, ensure_type)`- `loader_filters`  provide extra query filters along with loader key.  detail: `examples/6_sqlalchemy_loaderdepend_global_filter.py` L55, L59- `loader_instances`  provide pre-created loader instance, with can `prime` data into loader cache.  detail: `tests/resolver/test_20_loader_instance.py`, L62, L63- `ensure_type`  if `True`, resolve method is restricted to be annotated.  detail: `tests/resolver/test_13_check_wrong_type``LoaderDepend(loader_fn)`- `loader_fn`: subclass of DataLoader or batch_load_fn. [detail](https://github.com/syrusakbary/aiodataloader#dataloaderbatch_load_fn-options)  declare dataloader dependency, `pydantic-resolve` will take the care of lifecycle of dataloader.`build_list(rows, keys, fn)` &amp; `build_object(rows, keys, fn)`- `rows`: query result- `keys`: batch_load_fn:keys- `fn`: define the way to get primary key  helper function to generate return value required by `batch_load_fn`. read the code for details.`mapper(param)`- `param`: can be either a class of pydantic or dataclass, or a lambda.  `pydantic-resolve` will trigger the fn in `mapper` after inner future is resolved. it exposes an interface to change return schema even from the same dataloader.  if param is a class, it will try to automatically transform it.`ensure_subset(base_class)`- `base_class`: pydantic class  it can raise exception if fields of decorated class has field not existed in `base_class`.  detail: `tests/utils/test_2_ensure_subset.py`## Run FastAPI example```shellpoetry shellcd examplesuvicorn fastapi_demo.main:app# http://localhost:8000/docs#/default/get_tasks_tasks_get```## Some documentations.- [Reason](./doc/reason-en.md)- [How LoaderDepend works](./doc/loader-en.md)- [Comparsion with common solutions](./doc/compare-en.md)For more examples, please explore [examples](./examples/) folder.## Unittest```shellpoetry run python -m unittest  # orpoetry run pytest  # orpoetry run tox```## Coverage```shellpoetry run coverage run -m pytestpoetry run coverage report -m```</longdescription>
</pkgmetadata>