<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://github.com/docarray/docarray/blob/main/docs/assets/logo-dark.svg?raw=true&quot; alt=&quot;DocArray logo: The data structure for unstructured data&quot; width=&quot;150px&quot;&gt;&lt;br&gt;&lt;b&gt;The data structure for multimodal data&lt;/b&gt;&lt;/p&gt;&lt;p align=center&gt;&lt;a href=&quot;https://pypi.org/project/docarray/&quot;&gt;&lt;img src=&quot;https://img.shields.io/pypi/v/docarray?style=flat-square&amp;amp;label=Release&quot; alt=&quot;PyPI&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://bestpractices.coreinfrastructure.org/projects/6554&quot;&gt;&lt;img src=&quot;https://bestpractices.coreinfrastructure.org/projects/6554/badge&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codecov.io/gh/docarray/docarray&quot;&gt;&lt;img alt=&quot;Codecov branch&quot; src=&quot;https://img.shields.io/codecov/c/github/docarray/docarray/main?&amp;logo=Codecov&amp;logoColor=white&amp;style=flat-square&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://pypistats.org/packages/docarray&quot;&gt;&lt;img alt=&quot;PyPI - Downloads from official pypistats&quot; src=&quot;https://img.shields.io/pypi/dm/docarray?style=flat-square&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://discord.gg/WaMp6PVPgR&quot;&gt;&lt;img src=&quot;https://dcbadge.vercel.app/api/server/WaMp6PVPgR?theme=default-inverted&amp;style=flat-square&quot;&gt;&lt;/a&gt;&lt;/p&gt;&gt; **Note**&gt; The README you're currently viewing is for DocArray&gt;0.30, which introduces some significant changes from DocArray 0.21. If you wish to continue using the older DocArray &lt;=0.21, ensure you install it via `pip install docarray==0.21`. Refer to its [codebase](https://github.com/docarray/docarray/tree/v0.21.0), [documentation](https://docarray.jina.ai), and [its hot-fixes branch](https://github.com/docarray/docarray/tree/docarray-v1-fixes) for more information.DocArray is a Python library expertly crafted for the [representation](#represent), [transmission](#send), [storage](#store), and [retrieval](#retrieve) of multimodal data. Tailored for the development of multimodal AI applications, its design guarantees seamless integration with the extensive Python and machine learning ecosystems. As of January 2022, DocArray is openly distributed under the [Apache License 2.0](https://github.com/docarray/docarray/blob/main/LICENSE) and currently enjoys the status of a sandbox project within the [LF AI &amp; Data Foundation](https://lfaidata.foundation/).- :fire: Offers native support for **[NumPy](https://github.com/numpy/numpy)**, **[PyTorch](https://github.com/pytorch/pytorch)**, **[TensorFlow](https://github.com/tensorflow/tensorflow)**, and **[JAX](https://github.com/google/jax)**, catering specifically to **model training scenarios**.- :zap: Based on **[Pydantic](https://github.com/pydantic/pydantic)**, and instantly compatible with web and microservice frameworks like **[FastAPI](https://github.com/tiangolo/fastapi/)** and **[Jina](https://github.com/jina-ai/jina/)**.- :package: Provides support for vector databases such as **[Weaviate](https://weaviate.io/), [Qdrant](https://qdrant.tech/), [ElasticSearch](https://www.elastic.co/de/elasticsearch/), [Redis](https://redis.io/)**, and **[HNSWLib](https://github.com/nmslib/hnswlib)**.- :chains: Allows data transmission as JSON over **HTTP** or as **[Protobuf](https://protobuf.dev/)** over **[gRPC](https://grpc.io/)**.## InstallationTo install DocArray from the CLI, run the following command:```shellpip install -U docarray```&gt; **Note**&gt; To use DocArray &lt;=0.21, make sure you install via `pip install docarray==0.21` and check out its [codebase](https://github.com/docarray/docarray/tree/v0.21.0) and [docs](https://docarray.jina.ai) and [its hot-fixes branch](https://github.com/docarray/docarray/tree/docarray-v1-fixes).## Get StartedNew to DocArray? Depending on your use case and background, there are multiple ways to learn about DocArray: - [Coming from pure PyTorch or TensorFlow](#coming-from-pytorch)- [Coming from Pydantic](#coming-from-pydantic)- [Coming from FastAPI](#coming-from-fastapi)- [Coming from Jina](#coming-from-jina)- [Coming from a vector database](#coming-from-a-vector-database)- [Coming from Langchain](#coming-from-langchain)## RepresentDocArray empowers you to **represent your data** in a manner that is inherently attuned to machine learning.This is particularly beneficial for various scenarios:- :running: You are **training a model**: You're dealing with tensors of varying shapes and sizes, each signifying different elements. You desire a method to logically organize them.- :cloud: You are **serving a model**: Let's say through FastAPI, and you wish to define your API endpoints precisely.- :card_index_dividers: You are **parsing data**: Perhaps for future deployment in your machine learning or data science projects.&gt; :bulb: **Familiar with Pydantic?** You'll be pleased to learn&gt; that DocArray is not only constructed atop Pydantic but also maintains complete compatibility with it!&gt; Furthermore, we have a [specific section](#coming-from-pydantic) dedicated to your needs!In essence, DocArray facilitates data representation in a way that mirrors Python dataclasses, with machine learning being an integral component:```pythonfrom docarray import BaseDocfrom docarray.typing import TorchTensor, ImageUrlimport torch# Define your data modelclass MyDocument(BaseDoc):    description: str    image_url: ImageUrl  # could also be VideoUrl, AudioUrl, etc.    image_tensor: TorchTensor[1704, 2272, 3]  # you can express tensor shapes!# Stack multiple documents in a Document Vectorfrom docarray import DocVecvec = DocVec[MyDocument](    [        MyDocument(            description=&quot;A cat&quot;,            image_url=&quot;https://example.com/cat.jpg&quot;,            image_tensor=torch.rand(1704, 2272, 3),        ),    ]    * 10)print(vec.image_tensor.shape)  # (10, 1704, 2272, 3)```&lt;details markdown=&quot;1&quot;&gt;  &lt;summary&gt;Click for more details&lt;/summary&gt;Let's take a closer look at how you can represent your data with DocArray:```pythonfrom docarray import BaseDocfrom docarray.typing import TorchTensor, ImageUrlfrom typing import Optionalimport torch# Define your data modelclass MyDocument(BaseDoc):    description: str    image_url: ImageUrl  # could also be VideoUrl, AudioUrl, etc.    image_tensor: Optional[        TorchTensor[1704, 2272, 3]    ] = None  # could also be NdArray or TensorflowTensor    embedding: Optional[TorchTensor] = None```So not only can you define the types of your data, you can even **specify the shape of your tensors!**```python# Create a documentdoc = MyDocument(    description=&quot;This is a photo of a mountain&quot;,    image_url=&quot;https://upload.wikimedia.org/wikipedia/commons/2/2f/Alpamayo.jpg&quot;,)# Load image tensor from URLdoc.image_tensor = doc.image_url.load()# Compute embedding with any model of your choicedef clip_image_encoder(image_tensor: TorchTensor) -&gt; TorchTensor:  # dummy function    return torch.rand(512)doc.embedding = clip_image_encoder(doc.image_tensor)print(doc.embedding.shape)  # torch.Size([512])```### Compose nested DocumentsOf course, you can compose Documents into a nested structure:```pythonfrom docarray import BaseDocfrom docarray.documents import ImageDoc, TextDocimport numpy as npclass MultiModalDocument(BaseDoc):    image_doc: ImageDoc    text_doc: TextDocdoc = MultiModalDocument(    image_doc=ImageDoc(tensor=np.zeros((3, 224, 224))), text_doc=TextDoc(text='hi!'))```You rarely work with a single data point at a time, especially in machine learning applications. That's why you can easily collect multiple `Documents`:### Collect multiple `Documents`When building or interacting with an ML system, usually you want to process multiple Documents (data points) at once.DocArray offers two data structures for this:- **`DocVec`**: A vector of `Documents`. All tensors in the documents are stacked into a single tensor. **Perfect for batch processing and use inside of ML models**.- **`DocList`**: A list of `Documents`. All tensors in the documents are kept as-is. **Perfect for streaming, re-ranking, and shuffling of data**.Let's take a look at them, starting with `DocVec`:```pythonfrom docarray import DocVec, BaseDocfrom docarray.typing import AnyTensor, ImageUrlimport numpy as npclass Image(BaseDoc):    url: ImageUrl    tensor: AnyTensor  # this allows torch, numpy, and tensor flow tensorsvec = DocVec[Image](  # the DocVec is parametrized by your personal schema!    [        Image(            url=&quot;https://upload.wikimedia.org/wikipedia/commons/2/2f/Alpamayo.jpg&quot;,            tensor=np.zeros((3, 224, 224)),        )        for _ in range(100)    ])``` In the code snippet above, `DocVec` is **parametrized by the type of document** you want to use with it: `DocVec[Image]`.This may look weird at first, but we're confident that you'll get used to it quickly!Besides, it lets us do some cool things, like having **bulk access to the fields that you defined** in your document:```pythontensor = vec.tensor  # gets all the tensors in the DocVecprint(tensor.shape)  # which are stacked up into a single tensor!print(vec.url)  # you can bulk access any other field, too```The second data structure, `DocList`, works in a similar way:```pythonfrom docarray import DocListdl = DocList[Image](  # the DocList is parametrized by your personal schema!    [        Image(            url=&quot;https://upload.wikimedia.org/wikipedia/commons/2/2f/Alpamayo.jpg&quot;,            tensor=np.zeros((3, 224, 224)),        )        for _ in range(100)    ])```You can still bulk access the fields of your document:```pythontensors = dl.tensor  # gets all the tensors in the DocListprint(type(tensors))  # as a list of tensorsprint(dl.url)  # you can bulk access any other field, too```And you can insert, remove, and append documents to your `DocList`:```python# appenddl.append(    Image(        url=&quot;https://upload.wikimedia.org/wikipedia/commons/2/2f/Alpamayo.jpg&quot;,        tensor=np.zeros((3, 224, 224)),    ))# deletedel dl[0]# insertdl.insert(    0,    Image(        url=&quot;https://upload.wikimedia.org/wikipedia/commons/2/2f/Alpamayo.jpg&quot;,        tensor=np.zeros((3, 224, 224)),    ),)```And you can seamlessly switch between `DocVec` and `DocList`:```pythonvec_2 = dl.to_doc_vec()assert isinstance(vec_2, DocVec)dl_2 = vec_2.to_doc_list()assert isinstance(dl_2, DocList)```&lt;/details&gt;## SendDocArray facilitates the **transmission of your data** in a manner inherently compatible with machine learning.This includes native support for **Protobuf and gRPC**, along with **HTTP** and serialization to JSON, JSONSchema, Base64, and Bytes.This feature proves beneficial for several scenarios:- :cloud: You are **serving a model**, perhaps through frameworks like **[Jina](https://github.com/jina-ai/jina/)** or **[FastAPI](https://github.com/tiangolo/fastapi/)**- :spider_web: You are **distributing your model** across multiple machines and need an efficient means of transmitting your data between nodes- :gear: You are architecting a **microservice** environment and require a method for data transmission between microservices&gt; :bulb: **Are you familiar with FastAPI?** You'll be delighted to learn&gt; that DocArray maintains full compatibility with FastAPI!&gt; Plus, we have a [dedicated section](#coming-from-fastapi) specifically for you!When it comes to data transmission, serialization is a crucial step. Let's delve into how DocArray streamlines this process:```pythonfrom docarray import BaseDocfrom docarray.typing import ImageTorchTensorimport torch# model your dataclass MyDocument(BaseDoc):    description: str    image: ImageTorchTensor[3, 224, 224]# create a Documentdoc = MyDocument(    description=&quot;This is a description&quot;,    image=torch.zeros((3, 224, 224)),)# serialize it!proto = doc.to_protobuf()bytes_ = doc.to_bytes()json = doc.json()# deserialize it!doc_2 = MyDocument.from_protobuf(proto)doc_4 = MyDocument.from_bytes(bytes_)doc_5 = MyDocument.parse_raw(json)```Of course, serialization is not all you need. So check out how DocArray integrates with **[Jina](https://github.com/jina-ai/jina/)** and **[FastAPI](https://github.com/tiangolo/fastapi/)**.## StoreAfter modeling and possibly distributing your data, you'll typically want to **store it** somewhere. That's where DocArray steps in!**Document Stores** provide a seamless way to, as the name suggests, store your Documents. Be it locally or remotely, you can do it all through the same user interface:- :cd: **On disk**, as a file in your local filesystem- :bucket: On **[AWS S3](https://aws.amazon.com/de/s3/)**- :cloud: On **[Jina AI Cloud](https://cloud.jina.ai/)**The Document Store interface lets you push and pull Documents to and from multiple data sources, all with the same user interface.For example, let's see how that works with on-disk storage:```pythonfrom docarray import BaseDoc, DocListclass SimpleDoc(BaseDoc):    text: strdocs = DocList[SimpleDoc]([SimpleDoc(text=f'doc {i}') for i in range(8)])docs.push('file://simple_docs')docs_pull = DocList[SimpleDoc].pull('file://simple_docs')```## Retrieve**Document Indexes** let you index your Documents in a **vector database** for efficient similarity-based retrieval.This is useful for:- :left_speech_bubble: Augmenting **LLMs and Chatbots** with domain knowledge ([Retrieval Augmented Generation](https://arxiv.org/abs/2005.11401))- :mag: **Neural search** applications- :bulb: **Recommender systems**Currently, Document Indexes support **[Weaviate](https://weaviate.io/)**, **[Qdrant](https://qdrant.tech/)**, **[ElasticSearch](https://www.elastic.co/)**,  **[Redis](https://redis.io/)**, and **[HNSWLib](https://github.com/nmslib/hnswlib)**, with more to come!The Document Index interface lets you index and retrieve Documents from multiple vector databases, all with the same user interface.It supports ANN vector search, text search, filtering, and hybrid search.```pythonfrom docarray import DocList, BaseDocfrom docarray.index import HnswDocumentIndeximport numpy as npfrom docarray.typing import ImageUrl, ImageTensor, NdArrayclass ImageDoc(BaseDoc):    url: ImageUrl    tensor: ImageTensor    embedding: NdArray[128]# create some datadl = DocList[ImageDoc](    [        ImageDoc(            url=&quot;https://upload.wikimedia.org/wikipedia/commons/2/2f/Alpamayo.jpg&quot;,            tensor=np.zeros((3, 224, 224)),            embedding=np.random.random((128,)),        )        for _ in range(100)    ])# create a Document Indexindex = HnswDocumentIndex[ImageDoc](work_dir='/tmp/test_index')# index your dataindex.index(dl)# find similar Documentsquery = dl[0]results, scores = index.find(query, limit=10, search_field='embedding')```---## Learn DocArrayDepending on your background and use case, there are different ways for you to understand DocArray.### Coming from DocArray &lt;=0.21&lt;details markdown=&quot;1&quot;&gt;  &lt;summary&gt;Click to expand&lt;/summary&gt;If you are using DocArray version 0.30.0 or lower, you will be familiar with its [dataclass API](https://docarray.jina.ai/fundamentals/dataclass/)._DocArray &gt;=0.30 is that idea, taken seriously._ Every document is created through a dataclass-like interface,courtesy of [Pydantic](https://pydantic-docs.helpmanual.io/usage/models/).This gives the following advantages:- **Flexibility:** No need to conform to a fixed set of fields -- your data defines the schema- **Multimodality:** At their core, documents are just dictionaries. This makes it easy to create and send them from any language, not just Python.You may also be familiar with our old Document Stores for vector DB integration.They are now called **Document Indexes** and offer the following improvements (see [here](#store) for the new API):- **Hybrid search:** You can now combine vector search with text search, and even filter by arbitrary fields- **Production-ready:** The new Document Indexes are a much thinner wrapper around the various vector DB libraries, making them more robust and easier to maintain- **Increased flexibility:** We strive to support any configuration or setting that you could perform through the DB's first-party clientFor now, Document Indexes support **[Weaviate](https://weaviate.io/)**, **[Qdrant](https://qdrant.tech/)**, **[ElasticSearch](https://www.elastic.co/)**, **[Redis](https://redis.io/)**,  Exact Nearest Neighbour search and **[HNSWLib](https://github.com/nmslib/hnswlib)**, with more to come.&lt;/details&gt;### Coming from Pydantic&lt;details markdown=&quot;1&quot;&gt;  &lt;summary&gt;Click to expand&lt;/summary&gt;If you come from Pydantic, you can see DocArray documents as juiced up Pydantic models, and DocArray as a collection of goodies around them.More specifically, we set out to **make Pydantic fit for the ML world** - not by replacing it, but by building on top of it!This means you get the following benefits:- **ML-focused types**: Tensor, TorchTensor, Embedding, ..., including **tensor shape validation**- Full compatibility with **FastAPI**- **DocList** and **DocVec** generalize the idea of a model to a _sequence_ or _batch_ of models. Perfect for **use in ML models** and other batch processing tasks.- **Types that are alive**: ImageUrl can `.load()` a URL to image tensor, TextUrl can load and tokenize text documents, etc.- Cloud-ready: Serialization to **Protobuf** for use with microservices and **gRPC**- **Pre-built multimodal documents** for different data modalities: Image, Text, 3DMesh, Video, Audio and more. Note that all of these are valid Pydantic models!- **Document Stores** and **Document Indexes** let you store your data and retrieve it using **vector search**The most obvious advantage here is **first-class support for ML centric data**, such as `{Torch, TF, ...}Tensor`, `Embedding`, etc.This includes handy features such as validating the shape of a tensor:```pythonfrom docarray import BaseDocfrom docarray.typing import TorchTensorimport torchclass MyDoc(BaseDoc):    tensor: TorchTensor[3, 224, 224]doc = MyDoc(tensor=torch.zeros(3, 224, 224))  # worksdoc = MyDoc(tensor=torch.zeros(224, 224, 3))  # works by reshapingtry:    doc = MyDoc(tensor=torch.zeros(224))  # fails validationexcept Exception as e:    print(e)    # tensor    # Cannot reshape tensor of shape (224,) to shape (3, 224, 224) (type=value_error)class Image(BaseDoc):    tensor: TorchTensor[3, 'x', 'x']Image(tensor=torch.zeros(3, 224, 224))  # workstry:    Image(        tensor=torch.zeros(3, 64, 128)    )  # fails validation because second dimension does not match thirdexcept Exception as e:    print()try:    Image(        tensor=torch.zeros(4, 224, 224)    )  # fails validation because of the first dimensionexcept Exception as e:    print(e)    # Tensor shape mismatch. Expected(3, 'x', 'x'), got(4, 224, 224)(type=value_error)try:    Image(        tensor=torch.zeros(3, 64)    )  # fails validation because it does not have enough dimensionsexcept Exception as e:    print(e)    # Tensor shape mismatch. Expected (3, 'x', 'x'), got (3, 64) (type=value_error)```&lt;/details&gt;### Coming from PyTorch&lt;details markdown=&quot;1&quot;&gt;  &lt;summary&gt;Click to expand&lt;/summary&gt;If you come from PyTorch, you can see DocArray mainly as a way of _organizing your data as it flows through your model_.It offers you several advantages:- Express **tensor shapes in type hints**- **Group tensors that belong to the same object**, e.g. an audio track and an image- **Go directly to deployment**, by re-using your data model as a [FastAPI](https://fastapi.tiangolo.com/) or [Jina](https://github.com/jina-ai/jina) API schema- Connect model components between **microservices**, using Protobuf and gRPCDocArray can be used directly inside ML models to handle and represent multimodaldata.This allows you to reason about your data using DocArray's abstractions deep inside of `nn.Module`,and provides a FastAPI-compatible schema that eases the transition between model training and model serving.To see the effect of this, let's first observe a vanilla PyTorch implementation of a tri-modal ML model:```pythonimport torchfrom torch import nndef encoder(x):    return torch.rand(512)class MyMultiModalModel(nn.Module):    def __init__(self):        super().__init__()        self.audio_encoder = encoder()        self.image_encoder = encoder()        self.text_encoder = encoder()    def forward(self, text_1, text_2, image_1, image_2, audio_1, audio_2):        embedding_text_1 = self.text_encoder(text_1)        embedding_text_2 = self.text_encoder(text_2)        embedding_image_1 = self.image_encoder(image_1)        embedding_image_2 = self.image_encoder(image_2)        embedding_audio_1 = self.image_encoder(audio_1)        embedding_audio_2 = self.image_encoder(audio_2)        return (            embedding_text_1,            embedding_text_2,            embedding_image_1,            embedding_image_2,            embedding_audio_1,            embedding_audio_2,        )```Not very easy on the eyes if you ask us. And even worse, if you need to add one more modality you have to touch every part of your code base, changing the `forward()` return type and making a whole lot of changes downstream from that.So, now let's see what the same code looks like with DocArray:```pythonfrom docarray import DocList, BaseDocfrom docarray.documents import ImageDoc, TextDoc, AudioDocfrom docarray.typing import TorchTensorfrom torch import nnimport torchdef encoder(x):    return torch.rand(512)class Podcast(BaseDoc):    text: TextDoc    image: ImageDoc    audio: AudioDocclass PairPodcast(BaseDoc):    left: Podcast    right: Podcastclass MyPodcastModel(nn.Module):    def __init__(self):        super().__init__()        self.audio_encoder = encoder()        self.image_encoder = encoder()        self.text_encoder = encoder()    def forward_podcast(self, docs: DocList[Podcast]) -&gt; DocList[Podcast]:        docs.audio.embedding = self.audio_encoder(docs.audio.tensor)        docs.text.embedding = self.text_encoder(docs.text.tensor)        docs.image.embedding = self.image_encoder(docs.image.tensor)        return docs    def forward(self, docs: DocList[PairPodcast]) -&gt; DocList[PairPodcast]:        docs.left = self.forward_podcast(docs.left)        docs.right = self.forward_podcast(docs.right)        return docs```Looks much better, doesn't it?You instantly win in code readability and maintainability. And for the same price you can turn your PyTorch model into a FastAPI app and reuse your Documentschema definition (see [below](#coming-from-fastapi)). Everything is handled in a pythonic manner by relying on type hints.&lt;/details&gt;### Coming from TensorFlow&lt;details markdown=&quot;1&quot;&gt;  &lt;summary&gt;Click to expand&lt;/summary&gt;Like the [PyTorch approach](#coming-from-pytorch), you can also use DocArray with TensorFlow to handle and represent multimodal data inside your ML model.First off, to use DocArray with TensorFlow we first need to install it as follows:```pip install tensorflow==2.12.0pip install protobuf==3.19.0```Compared to using DocArray with PyTorch, there is one main difference when using it with TensorFlow:While DocArray's `TorchTensor` is a subclass of `torch.Tensor`, this is not the case for the `TensorFlowTensor`: Due to some technical limitations of `tf.Tensor`, DocArray's `TensorFlowTensor` is not a subclass of `tf.Tensor` but rather stores a `tf.Tensor` in its `.tensor` attribute. How does this affect you? Whenever you want to access the tensor data to, let's say, do operations with it or hand it to your ML model, instead of handing over your `TensorFlowTensor` instance, you need to access its `.tensor` attribute.This would look like the following:```pythonfrom typing import Optionalfrom docarray import DocList, BaseDocimport tensorflow as tfclass Podcast(BaseDoc):    audio_tensor: Optional[AudioTensorFlowTensor] = None    embedding: Optional[AudioTensorFlowTensor] = Noneclass MyPodcastModel(tf.keras.Model):    def __init__(self):        super().__init__()        self.audio_encoder = AudioEncoder()    def call(self, inputs: DocList[Podcast]) -&gt; DocList[Podcast]:        inputs.audio_tensor.embedding = self.audio_encoder(            inputs.audio_tensor.tensor        )  # access audio_tensor's .tensor attribute        return inputs```&lt;/details&gt;### Coming from FastAPI&lt;details markdown=&quot;1&quot;&gt;  &lt;summary&gt;Click to expand&lt;/summary&gt;Documents are Pydantic Models (with a twist), and as such they are fully compatible with FastAPI!But why should you use them, and not the Pydantic models you already know and love?Good question!- Because of the ML-first features, types and validations, [here](#coming-from-pydantic)- Because DocArray can act as an [ORM for vector databases](#coming-from-a-vector-database), similar to what SQLModel does for SQL databasesAnd to seal the deal, let us show you how easily documents slot into your FastAPI app:```pythonimport numpy as npfrom fastapi import FastAPIfrom docarray.base_doc import DocArrayResponsefrom docarray import BaseDocfrom docarray.documents import ImageDocfrom docarray.typing import NdArray, ImageTensorclass InputDoc(BaseDoc):    img: ImageDoc    text: strclass OutputDoc(BaseDoc):    embedding_clip: NdArray    embedding_bert: NdArrayapp = FastAPI()def model_img(img: ImageTensor) -&gt; NdArray:    return np.zeros((100, 1))def model_text(text: str) -&gt; NdArray:    return np.zeros((100, 1))@app.post(&quot;/embed/&quot;, response_model=OutputDoc, response_class=DocArrayResponse)async def create_item(doc: InputDoc) -&gt; OutputDoc:    doc = OutputDoc(        embedding_clip=model_img(doc.img.tensor), embedding_bert=model_text(doc.text)    )    return docinput_doc = InputDoc(text='', img=ImageDoc(tensor=np.random.random((3, 224, 224))))async with AsyncClient(app=app, base_url=&quot;http://test&quot;) as ac:    response = await ac.post(&quot;/embed/&quot;, data=input_doc.json())```Just like a vanilla Pydantic model!&lt;/details&gt;### Coming from Jina&lt;details markdown=&quot;1&quot;&gt;  &lt;summary&gt;Click to expand&lt;/summary&gt;Jina has adopted docarray as their library for representing and serializing Documents.Jina allows to serve models and services that are built with DocArray allowing you to serve and scale these applicationsmaking full use of DocArray's serialization capabilites. ```pythonimport numpy as npfrom jina import Deployment, Executor, requestsfrom docarray import BaseDoc, DocListfrom docarray.documents import ImageDocfrom docarray.typing import NdArray, ImageTensorclass InputDoc(BaseDoc):    img: ImageDoc    text: strclass OutputDoc(BaseDoc):    embedding_clip: NdArray    embedding_bert: NdArraydef model_img(img: ImageTensor) -&gt; NdArray:    return np.zeros((100, 1))def model_text(text: str) -&gt; NdArray:    return np.zeros((100, 1))class MyEmbeddingExecutor(Executor):    @requests(on='/embed')    def encode(self, docs: DocList[InputDoc], **kwargs) -&gt; DocList[OutputDoc]:        ret = DocList[OutputDoc]()        for doc in docs:            output = OutputDoc(                embedding_clip=model_img(doc.img.tensor),                embedding_bert=model_text(doc.text),            )            ret.append(output)        return retwith Deployment(    protocols=['grpc', 'http'], ports=[12345, 12346], uses=MyEmbeddingExecutor) as dep:    resp = dep.post(        on='/embed',        inputs=DocList[InputDoc](            [InputDoc(text='', img=ImageDoc(tensor=np.random.random((3, 224, 224))))]        ),        return_type=DocList[OutputDoc],    )    print(resp)```&lt;/details&gt;### Coming from a vector database&lt;details markdown=&quot;1&quot;&gt;  &lt;summary&gt;Click to expand&lt;/summary&gt;If you came across DocArray as a universal vector database client, you can best think of it as **a new kind of ORM for vector databases**.DocArray's job is to take multimodal, nested and domain-specific data and to map it to a vector database,store it there, and thus make it searchable:```pythonfrom docarray import DocList, BaseDocfrom docarray.index import HnswDocumentIndeximport numpy as npfrom docarray.typing import ImageUrl, ImageTensor, NdArrayclass ImageDoc(BaseDoc):    url: ImageUrl    tensor: ImageTensor    embedding: NdArray[128]# create some datadl = DocList[ImageDoc](    [        ImageDoc(            url=&quot;https://upload.wikimedia.org/wikipedia/commons/2/2f/Alpamayo.jpg&quot;,            tensor=np.zeros((3, 224, 224)),            embedding=np.random.random((128,)),        )        for _ in range(100)    ])# create a Document Indexindex = HnswDocumentIndex[ImageDoc](work_dir='/tmp/test_index2')# index your dataindex.index(dl)# find similar Documentsquery = dl[0]results, scores = index.find(query, limit=10, search_field='embedding')```Currently, DocArray supports the following vector databases:- [Weaviate](https://www.weaviate.io/)- [Qdrant](https://qdrant.tech/)- [Elasticsearch](https://www.elastic.co/elasticsearch/) v8 and v7- [Redis](https://redis.io/)- [Milvus](https://milvus.io)- ExactNNMemorySearch as a local alternative with exact kNN search.- [HNSWlib](https://github.com/nmslib/hnswlib) as a local-first ANN alternativeAn integration of [OpenSearch](https://opensearch.org/) is currently in progress.Of course this is only one of the things that DocArray can do, so we encourage you to check out the rest of this readme!&lt;/details&gt;### Coming from Langchain&lt;details markdown=&quot;1&quot;&gt;  &lt;summary&gt;Click to expand&lt;/summary&gt;With DocArray, you can connect external data to LLMs through Langchain. DocArray gives you the freedom to establish flexible document schemas and choose from different backends for document storage.After creating your document index, you can connect it to your Langchain app using [DocArrayRetriever](https://python.langchain.com/docs/modules/data_connection/retrievers/integrations/docarray_retriever).Install Langchain via:```shellpip install langchain```1. Define a schema and create documents:```pythonfrom docarray import BaseDoc, DocListfrom docarray.typing import NdArrayfrom langchain.embeddings.openai import OpenAIEmbeddingsembeddings = OpenAIEmbeddings()# Define a document schemaclass MovieDoc(BaseDoc):    title: str    description: str    year: int    embedding: NdArray[1536]movies = [    {&quot;title&quot;: &quot;#1 title&quot;, &quot;description&quot;: &quot;#1 description&quot;, &quot;year&quot;: 1999},    {&quot;title&quot;: &quot;#2 title&quot;, &quot;description&quot;: &quot;#2 description&quot;, &quot;year&quot;: 2001},]# Embed `description` and create documentsdocs = DocList[MovieDoc](    MovieDoc(embedding=embeddings.embed_query(movie[&quot;description&quot;]), **movie)    for movie in movies)```2. Initialize a document index using any supported backend:```pythonfrom docarray.index import (    InMemoryExactNNIndex,    HnswDocumentIndex,    WeaviateDocumentIndex,    QdrantDocumentIndex,    ElasticDocIndex,    RedisDocumentIndex,)# Select a suitable backend and initialize it with datadb = InMemoryExactNNIndex[MovieDoc](docs)```3. Finally, initialize a retriever and integrate it into your chain!```pythonfrom langchain.chat_models import ChatOpenAIfrom langchain.chains import ConversationalRetrievalChainfrom langchain.retrievers import DocArrayRetriever# Create a retrieverretriever = DocArrayRetriever(    index=db,    embeddings=embeddings,    search_field=&quot;embedding&quot;,    content_field=&quot;description&quot;,)# Use the retriever in your chainmodel = ChatOpenAI()qa = ConversationalRetrievalChain.from_llm(model, retriever=retriever)```Alternatively, you can use built-in vector stores. Langchain supports two vector stores: [DocArrayInMemorySearch](https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/docarray_in_memory) and [DocArrayHnswSearch](https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/docarray_hnsw). Both are user-friendly and are best suited to small to medium-sized datasets.&lt;/details&gt;## See also- [Documentation](https://docs.docarray.org)- [DocArray&lt;=0.21 documentation](https://docarray.jina.ai/)- [Join our Discord server](https://discord.gg/WaMp6PVPgR)- [Donation to Linux Foundation AI&amp;Data blog post](https://jina.ai/news/donate-docarray-lf-for-inclusive-standard-multimodal-data-model/)- [Roadmap](https://github.com/docarray/docarray/issues/1714)&gt; DocArray is a trademark of LF AI Projects, LLC&gt; </longdescription>
</pkgmetadata>