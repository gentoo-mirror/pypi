<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># lbuild: generic, modular code generation in Python 3The Library Builder (pronounced *lbuild*) is a BSD licensed [Python 3.5 tool][python]for describing repositories containing modules which can copy or generate a setof files based on the user provided data and options.*lbuild* allows splitting up complex code generation projects into smallermodules with configurable options, and provides for their transparentdiscovery, documentation and dependency management.Each module is written in Python 3 and declares its options and how to generateits content via the [Jinja2 templating engine][jinja2] or a file/folder copy.You can [install *lbuild* via PyPi][pypi]: `pip install lbuild`Projects using *lbuild*:- [modm generates a HAL for thousands of embedded devices][modm] using *lbuild*  and a data-driven code generation pipeline.- [Taproot: a friendly control library and framework for RoboMaster robots][taproot]  uses *lbuild*.- [OUTPOST - Open modUlar sofTware PlatfOrm for SpacecrafT][outpost] uses *lbuild*  to assemble an execution platform targeted at embedded systems running mission  critical software.The dedicated maintainer of *lbuild* is [@salkinium][salkinium].## OverviewConsider this repository:``` $ lbuild discoverParser(lbuild)╰── Repository(repo @ ../repo)    ├── Option(option) = value in [value, special]    ├── Module(repo:module)    │   ├── Option(option) = yes in [yes, no]    │   ├── Module(repo:module:submodule)    │   │   ╰── Option(option) = REQUIRED in [1, 2, 3, 4, 5]    │   ╰── Module(repo:module:submodule2)    ╰── Module(modm:module2)```*lbuild* is called by the user with a configuration file which contains therepositories to scan, the modules to include and the options to configurethem with:```xml&lt;library&gt;  &lt;repositories&gt;    &lt;repository&gt;&lt;path&gt;../repo/repo.lb&lt;/path&gt;&lt;/repository&gt;  &lt;/repositories&gt;  &lt;options&gt;    &lt;option name=&quot;repo:option&quot;&gt;special&lt;/option&gt;    &lt;option name=&quot;repo:module:option&quot;&gt;3&lt;/option&gt;  &lt;/options&gt;  &lt;modules&gt;    &lt;module&gt;repo:module&lt;/module&gt;  &lt;/modules&gt;&lt;/library&gt;```The `repo.lb` file is compiled by *lbuild* and the two functions `init`,`prepare` are called:```pythondef init(repo):    repo.name = &quot;repo&quot;    repo.add_option(EnumerationOption(name=&quot;option&quot;,                                      enumeration=[&quot;value&quot;, &quot;special&quot;],                                      default=&quot;value&quot;))def prepare(repo, options):    repo.find_modules_recursive(&quot;src&quot;)```This gives the repository a name and declares a string option. The prepare stepadds all module files in the `src/` folder.Each `module.lb` file is then compiled by *lbuild*, and the three functions`init`, `prepare` and `build` are called:```pythondef init(module):    module.name = &quot;:module&quot;def prepare(module, options):    if options[&quot;repo:option&quot;] == &quot;special&quot;:        module.add_option(EnumerationOption(name=&quot;option&quot;, enumeration=[1, 2, 3, 4, 5]))        return True    return Falsedef build(env):    env.outbasepath = &quot;repo/module&quot;    env.copy(&quot;static.hpp&quot;)    for number in range(env[&quot;repo:module:option&quot;]):        env.template(&quot;template.cpp.in&quot;, &quot;template_{}.cpp&quot;.format(number + 1))```The init step sets the module's name and its parent name. The prepare stepthen adds a `EnumerationOption` and makes the module available, if the repository optionis set to `&quot;special&quot;`. Finally in the build step, a number of files are generatedbased on the option's content.The files are generated at the call-site of `lbuild build` which would thenlook something like this:``` $ lsmain.cpp        project.xml $ lbuild build $ tree.├── main.cpp├── repo│   ├── module│   │   ├── static.hpp│   │   ├── template_1.cpp│   │   ├── template_2.cpp│   │   └── template_3.cpp```## DocumentationThe above example shows a minimal feature set, but *lbuild* has a few moretricks up its sleeves. Let's have a look at the API in more detail with examplesfrom [the modm repository][modm].### Command Line InterfaceBefore you can build a project you need to provide a configuration.*lbuild* aims to make discovery easy from the command line:``` $ lbuild --repository ../modm/repo.lb discoverParser(lbuild)╰── Repository(modm @ ../modm)   modm: a barebone embedded library generator    ╰── Option(target) = REQUIRED in [at90can128, at90can32, at90can64, ...```This gives you an overview of the repositories and their options. In this casethe `modm:target` repository option is required, so let's check that out:``` $ lbuild -r ../modm/repo.lb discover-optionsmodm:target = REQUIRED in [at90can128, at90can32, at90can64, at90pwm1, at90pwm161, at90pwm2,                           ... a really long list ...                           stm32l4s9vit, stm32l4s9zij, stm32l4s9zit, stm32l4s9ziy]  Meta-HAL target device```You can then choose this repository option and discover the available modulesfor this specific repository option:``` $ lbuild -r ../modm/repo.lb --option modm:target=stm32f407vgt discoverParser(lbuild)╰── Repository(modm @ ../modm)   modm: a barebone embedded library generator    ├── Option(target) = stm32f407vgt in [at90can128, at90can32, at90can64, ...]    ├── Configuration(modm:disco-f407vg)    ├── Module(modm:board)   Board Support Packages    │   ╰── Module(modm:board:disco-f469ni)   STM32F469IDISCOVERY    ├── Module(modm:build)   Build System Generators    │   ├── PathOption(build.path) = build/parent-folder in [String]    │   ├── Option(project.name) = parent-folder in [String]    │   ╰── Module(modm:build:scons)  SCons Build Script Generator    │       ├── Option(info.build) = no in [yes, no]    │       ╰── Option(info.git) = Disabled in [Disabled, Info, Info+Status]    ├── Module(modm:platform)   Platform HAL    │   ├── Module(modm:platform:can)   Controller Area Network (CAN)    │   │   ╰── Module(modm:platform:can:1)   Instance 1    │   │       ├── Option(buffer.rx) = 32 in [1 .. 32 .. 65534]    │   │       ╰── Option(buffer.tx) = 32 in [1 .. 32 .. 65534]    │   ├── Module(modm:platform:core)   ARM Cortex-M Core    │   │   ├── Option(allocator) = newlib in [block, newlib, tlsf]    │   │   ├── Option(main_stack_size) = 3072 in [256 .. 3072 .. 65536]    │   │   ╰── Option(vector_table_location) = rom in [ram, rom]```You can now discover all module options in more detail:``` $ lbuild -r ../modm/repo.lb -D modm:target=stm32f407vgt discover-optionsmodm:target = stm32f407vgt in [at90can128, at90can32, at90can64, ...]  Meta-HAL target devicemodm:build:build.path = build/parent-folder in [String]  Path to the build foldermodm:build:project.name = parent-folder in [String]  Project name for executable```Or check out specific module and option descriptions:``` $ lbuild -r ../modm/repo.lb -D modm:target=stm32f407vgt discover -n :build&gt;&gt; modm:build# Build System GeneratorsThis parent module defines a common set of functionality that is independent ofthe specific build system generator implementation.&gt;&gt;&gt;&gt; modm:build:project.name  [StringOption]# Project NameThe project name defaults to the folder name you're calling lbuild from.Value: parent-folderInputs: [String]&gt;&gt;&gt;&gt; modm:build:build.path  [StringOption]# Build PathThe build path is defaulted to `build/{modm:build:project.name}`.Value: build/parent-folderInputs: [String]```The complete lbuild command line interface is available with `lbuild -h`.### ConfigurationEven though *lbuild* can be configured sorely via the command line, it isstrongly recommended to create a configuration file (default is `project.xml`)which *lbuild* will search for in the current working directory.```xml&lt;library&gt;  &lt;repositories&gt;    &lt;!-- Declare all your repository locations relative to this file here --&gt;    &lt;repository&gt;&lt;path&gt;path/to/repo.lb&lt;/path&gt;&lt;/repository&gt;    &lt;!-- You can also use environment variables in all nodes --&gt;    &lt;repository&gt;&lt;path&gt;${PROJECTHOME}/repo2.lb&lt;/path&gt;&lt;/repository&gt;    &lt;!-- You can also search for repository files --&gt;    &lt;glob&gt;ext/**/repo.lb&lt;/glob&gt;  &lt;/repositories&gt;  &lt;!-- You can also inherit from another configfile. The options you specify       here will be overwritten. --&gt;  &lt;extends&gt;path/to/config.xml&lt;/extends&gt;  &lt;!-- A repository may provide aliases for configurations, so that you can       use a string as well, instead of a path. This saves you from knowing       exactly where the configuration file is stored in the repo.       See also `repo.add_configuration(...)`. --&gt;  &lt;extends&gt;repo:name_of_config&lt;/extends&gt;  &lt;!-- A configuration alias may also be versioned --&gt;  &lt;extends&gt;repo:name_of_config:specific_version&lt;/extends&gt;  &lt;!-- You can declare the *where* the output should be generated, default is cwd --&gt;  &lt;outpath&gt;generated/folder&lt;/outpath&gt;  &lt;options&gt;    &lt;!-- Options are treated as key-value pairs --&gt;    &lt;option name=&quot;repo:repo_option_name&quot;&gt;value&lt;/option&gt;    &lt;!-- An option set is the only one allowing multiple values --&gt;    &lt;option name=&quot;repo:module:module_option_name&quot;&gt;set, options, may, contain, commas&lt;/option&gt;  &lt;/options&gt;  &lt;modules&gt;    &lt;!-- You only need to declare the modules you are actively using.         The dependencies are automatically resolved by lbuild. --&gt;    &lt;module&gt;repo:module&lt;/module&gt;    &lt;module&gt;repo:other_module:submodule&lt;/module&gt;  &lt;/modules&gt;&lt;/library&gt;```On startup, *lbuild* will search the current working directory upwards for one or more`lbuild.xml` files, which if found, are used as the base configuration, inheritedby all other configurations. This is very useful when several projects allrequire the same repositories, and you don't want to specify each repositorypath for each project.```xml&lt;library&gt;  &lt;repositories&gt;    &lt;repository&gt;&lt;path&gt;path/to/common/repo.lb&lt;/path&gt;&lt;/repository&gt;  &lt;/repositories&gt;  &lt;modules&gt;    &lt;module&gt;repo:module-required-by-all&lt;/module&gt;  &lt;/modules&gt;&lt;/library&gt;```In the simplest case your project just `&lt;extends&gt;` this base config.```xml&lt;library&gt;  &lt;extends&gt;repo:config-name&lt;/extends&gt;&lt;/library&gt;```### Files*lbuild* properly imports the declared repository and modules files, so you canuse everything that Python has to offer.In addition to `import`ing your required modules, *lbuild* provides theseglobal functions and classes for use in all files:- `localpath(path)`: remaps paths relative to the currently executing file.  All paths are already interpreted relative to this file, but you can use this  to be explicit.- `repopath(path)`: remaps paths relative to the repository file. You should use  this to reference paths that are not related to your module.- `listify(obj)`: turns obj into a list, maps `None` to empty list.- `listrify(obj)`: turns obj into a list of strings, maps `None` to empty list.- `uniquify(obj)`: turns obj into a unique list, maps `None` to empty list.- `FileReader(path)`: reads the contents of a file and turns it into a string.- `{*}Option(...)`: classes for describing options, [see Options](#Options).- `{*}Query(...)`: classes for sharing code and data, [see Queries](#Queries).- `{*}Collector(...)`: classes for describing metadata sinks, [see Collectors](#Collectors).- `Alias(...)`: links to other nodes, [see Aliases](#Aliases).- `Configuration(...)`: links to a configuration inside the repository.### Repositories*lbuild* calls these three functions for any repository file:- `init(repo)`: provides name, documentation and other global functionality.- `prepare(repo, options)`: adds all module files for this repository.- `build(env)` (*optional*): *only* called if at least one module within the  repository is built. It is meant for actions that must be performed for *any*  module, like generating a global header file, or adding to the include path.```python# You can use everything Python has to offerimport antigravitydef init(repo):    # You must give your repository a name, and it must be unique within the    # scope of your project as it is used for namespacing all modules    repo.name = &quot;name&quot;    # You can set a repository description here, either as an inline string    repo.description = &quot;Repository Description&quot;    # or as a multi-line string    repo.description = &quot;&quot;&quot;Multiline description.Use whatever markup you want, lbuild treats it all as text.&quot;&quot;&quot;    # or read it from a separate file altogether    repo.description = FileReader(&quot;module.md&quot;)    # lbuild displays the descriptions as-is, without any modification, however,    # you can set a custom format handler to change this for your repo.    # NOTE: Custom format handlers are applied to all modules and options.    def format_description(node, description):        # in modm there's unit test metadata in HTML comments, let's remove them        description = re.sub(r&quot;\n?&lt;!--.*?--&gt;\n?&quot;, &quot;&quot;, description, flags=re.S)        # forward this to the default formatter        return node.format_description(node, description)    repo.format_description = format_description    # You can also format the short descriptions for the discover views    def format_short_description(node, description):        # Remove the leading # from the Markdown headers        return node.format_short_description(node, description.replace(&quot;#&quot;, &quot;&quot;))    repo.format_short_description = format_short_description    # Add ignore patterns for all repository modules    # ignore patterns follow fnmatch rules    repo.add_ignore_patterns(&quot;*/*.lb&quot;, &quot;*/board.xml&quot;)    # Add Jinja2 filters for all repository modules    # NOTE: the filter is namespaced with the repository! {{ &quot;A&quot; | repo.number }} -&gt; 65    repo.add_filter(&quot;repo.number&quot;, lambda char: ord(char))    # Add an alias for a internal configuration    # NOTE: the configuration is namespaced with the repository! &lt;extends&gt;repo:config&lt;/extends&gt;    repo.add_configuration(Configuration(name=&quot;config&quot;,                                         description=&quot;Special Config&quot;,                                         path=&quot;path/to/config.xml&quot;)    # You can also add configuration versions    repo.add_configuration(Configuration(name=&quot;config2&quot;,                                         description=&quot;Versioned Config&quot;,                                         path={&quot;v1&quot;: &quot;path/to/config_v1.xml&quot;,                                               &quot;v2&quot;: &quot;path/to/config_v2.xml&quot;})    # See Options for more option types    repo.add_option(StringOption(name=&quot;option&quot;, default=&quot;value&quot;))def prepare(repo, options):    # Access repository options via the `options` resolver    if options[&quot;repo:option&quot;] == &quot;value&quot;:        # Adds module files directly, or via globbing, all paths relative to this file        repo.add_modules(&quot;folder/module.lb&quot;, repo.glob(&quot;*/*/module.lb&quot;))    # Searches recursively starting at basepath, adding any file that    # fnmatch(`modulefile`), while ignoring fnmatch(`ignore`) patterns    repo.add_modules_recursive(basepath=&quot;.&quot;, modulefile=&quot;*.lb&quot;, ignore=&quot;*/ignore/patterns/*&quot;)# The build step is optionaldef build(env):    # Add the generated src/ folder to the header search path collector    env.collect(&quot;::include_path&quot;, &quot;src/&quot;)    # See module.build(env) for complete feature description.```### Modules*lbuild* calls these five functions for any module file:- `init(module)`: provides module name, parent and documentation.- `prepare(module, options)`: enables modules, adds options and submodules by  taking the repository options into consideration.- `validate(env)` (*optional*): validate your inputs before building anything.- `build(env)`: generate your library and add metadata to build log.- `post_build(env, buildlog)` (*optional*): access the build log after the build  step completed.Module files are provided with these additional global classes:- `Module`: Base class for generated modules.- `ValidateException`: Exception to be raised when the `validate(env)` step fails.Note that in contrast to a repository, modules must return a boolean from the`prepare(module, options)` function, which indicates that the module is availablefor the repository option configuration. This allows for modules to &quot;share&quot; aname, but have completely different implementations.The `validate(env)` step is used to validate the input for the build step,allowing for computations that can fail to raise a `ValidateException(&quot;reason&quot;)`.*lbuild* will collect these exceptions for all modules and display themtogether before aborting the build. This step is performed before each build,and you cannot generate any files in this step, only read the repository's state.You can manually call this step via the `lbuild validate` command.The `build(env)` step is where the actual file generation happens. Here you cancopy and generate files and folders from Jinja2 templates with the substitutionsof you choice and the configuration of the modules. Each file operation isappended to a global build log, which you can also explicitly add metadata to.The `post_build(env)` step is meant for modules that need to generatefiles which receive information from all built modules. The typically use-casehere is generating scripts for build systems, which need to know about whatfiles were generated and all module's metadata.```pythondef init(module):    # give your module a hierarchical name, the repository name is implicit    module.name = &quot;repo:name&quot;    module.name = &quot;:name&quot;      # same as this    # You can set a module description here    module.description = &quot;Description&quot;    module.description = &quot;&quot;&quot;Multiline&quot;&quot;&quot;    module.description = FileReader(&quot;module.md&quot;)    # modules can have their own formatters, works the same as for repositories    module.format_description = custom_format_description    module.format_short_description = custom_format_short_description    # Add Jinja2 filters for this modules and all submodules    # NOTE: the filter is namespace with the repository! {{ 65 | repo.character }} -&gt; &quot;A&quot;    module.add_filter(&quot;repo.character&quot;, lambda number: chr(number))def prepare(module, options):    # Access repository options via the `options` resolver    if options[&quot;repo:option&quot;] == &quot;value&quot;:        # Returning False from this step disables this module        return False    # modules can depend on other modules    module.depends(&quot;repo:module1&quot;, &quot;:module2&quot;, &quot;:module3:submodule&quot;, ...)    # You can add more submodules in files    module.add_submodule(&quot;folder/submodule.lb&quot;)    # You can generate more modules here. This is useful if you have a lot of    # very similar modules (like instances of hardware peripherals) that you    # don't want to create a module file for each for.    class Instance(Module):        def __init__(self, instance):            self.instance = instance        def init(self, module):            module.name = str(self.instance)        def prepare(self, module, options):            pass        def validate(self, env): # optional            pass        def build(self, env):            pass        def post_build(self, env): # optional            pass    # You can statically create and add these submodules    for index in range(0, 5):        module.add_submodule(Instance(index))    # or make the creation dependent on a repository option    for index in options[&quot;repo:instances&quot;]:        module.add_submodule(Instance(index))    # See Options for more option types    module.add_option(StringOption(name=&quot;option&quot;, default=&quot;world&quot;))    def common_operation(args):        &quot;&quot;&quot;        You can share any function with other modules.        This is useful to not have to duplicate code across module.lb files.        &quot;&quot;&quot;        return args    # See Queries for more query types    module.add_query(Query(name=&quot;shared_function&quot;, function=common_operation))    # You can collect information from active modules, to use any post_build step    # See Collectors for more collector types    module.add_collector(        PathCollector(name=&quot;include_path&quot;, description=&quot;Global header search paths&quot;))    # Make this module available    return True# store data computed in validate step for build step.build_data = None# The validation step is optionaldef validate(env):    # Perform your input validations here    # Access all options    repo_option = env[&quot;repo:option&quot;]    defaulted_option = env.get(&quot;repo:module:option&quot;, default=&quot;hello&quot;)    # Use proper logging instead of print() please    # env.log.warning(...) and env.log.error(...) also available    env.log.debug(&quot;Repo option: '{}'&quot;.format(repo_option))    # You can query for options    if env.has_option(&quot;repo:module:option&quot;) or env.has_module(&quot;repo:module&quot;):        env.log.info(&quot;Module option: '{}'&quot;.format(env[&quot;repo:module:option&quot;]))    # Call shared functions from other modules with arguments    shared_function = env.query(&quot;repo:module:shared_function&quot;)    result = shared_function(&quot;argument&quot;)    # Or just precomputed properties without arguments    data = env.query(&quot;repo:module:shared_property&quot;)    # You may also use incomplete queries, see Name Resolution    env.has_module(&quot;:module&quot;) # instead of repo:module    env.has_option(&quot;::option&quot;) # repo:module:option    # And use fnmatch queries    # matches any module starting with `mod` and option starting with `name`.    env.has_option(&quot;:mod*:name*&quot;)    env.has_query(&quot;::shared_*&quot;)    env.has_collector(&quot;::collector&quot;)    # Raise a ValidateException if something is wrong    if defaulted_option + repo_option != &quot;hello world&quot;:        raise ValidateException(&quot;Options are invalid because ...&quot;)    # If you do heavy computations here for validation, you can store the    # data in a global variable and reuse this for the build step    global build_data    build_data = defaulted_option * 2# The build step can do everything the validation step can# But now you can finally generate filesdef build(env):    # Set the output base path, this is relative to the lbuild invocation path    env.outbasepath = &quot;repo/module&quot;    # Copy single files    env.copy(&quot;file.hpp&quot;)    # Copy single files while renaming them    env.copy(&quot;file.hpp&quot;, &quot;cool_filename.hpp&quot;)    # Relative paths are preserved!!!    env.copy(&quot;../file.hpp&quot;) # copies to repo/file.hpp    env.copy(&quot;../file.hpp&quot;, dest=&quot;file.hpp&quot;) # copies to repo/module/file.hpp    # You can also copy entire folders    env.copy(&quot;folder/&quot;, dest=&quot;renamed/&quot;)    # and ignore specific RELATIVE files/folders    env.copy(&quot;folder/&quot;, ignore=env.ignore_files(&quot;*.txt&quot;, &quot;this_specific_file.hpp&quot;))    # or ignore specific ABSOLUTE paths    env.copy(&quot;folder/&quot;, ignore=env.ignore_paths(&quot;*/folder/*.txt&quot;))    # You can also copy files out of a .zip or .tar archive    env.extract(&quot;archive.zip&quot;) # everything inside the archive    env.extract(&quot;archive.zip&quot;, dest=&quot;renamed/&quot;) # extract into folder    # You can extract only parts of the archive, like a single file    env.extract(&quot;archive.zip&quot;, src=&quot;filename.hpp&quot;, dest=&quot;renamed.hpp&quot;)    # or an a single folder somewhere in the archive    env.extract(&quot;archive.zip&quot;, src=&quot;folder/subfolder&quot;, dest=&quot;renamed/folder&quot;)    # of course, you can ignore files and folders inside the archive too    env.extract(&quot;archive.zip&quot;, src=&quot;folder&quot;, dest=&quot;renamed&quot;, ignore=env.ignore_files(&quot;*.txt&quot;))    # Set the global Jinja2 substitutions dictionary    env.substitutions = {        &quot;hello&quot;: &quot;world&quot;,        &quot;instances&quot;: map(str, env[&quot;repo:instances&quot;]),        &quot;build_data&quot;: build_data, # from validation step    }    # and generate a file from a template    env.template(&quot;template.hpp.in&quot;)    # any `.in` postfix is automatically removed, unless you rename it    for instance in env[&quot;repo:instances&quot;]:        env.template(&quot;template.hpp.in&quot;, &quot;template_{}.hpp&quot;.format(instance))    # You can explicitly add Jinja2 substitutions and filters    env.template(&quot;template.hpp.in&quot;,                 substitutions={&quot;more&quot;: &quot;subs&quot;},                 filters={&quot;stringify&quot;: lambda i: str(i)})    # Note: these filters are NOT namespaced with the repository name!    # submodules are build first, so you can access the generated files    headers = env.get_generated_local_files(lambda file: file.endswith(&quot;.hpp&quot;))    # and use this information for a new template.    env.template(&quot;module_header.hpp.in&quot;, substitutions={&quot;headers&quot;: headers})    # Add values to a collector, all these are type checked    env.collect(&quot;::include_path&quot;, &quot;repo/must_be_valid_path/&quot;, &quot;repo/folder2/&quot;)# The post build step can do everything the build step can,# but you can't add to the metadata anymore:# - env.collect() unavailable# You have access to the entire buildlog up to this pointdef post_build(env):    # The absolute path to the lbuild output directory    outpath = env.buildlog.outpath    # All modules that were built    modules = env.buildlog.modules    # All file generation operations that were done    operations = env.buildlog.operations    # All operations per module    operations = env.buildlog.operations_per_module(&quot;repo:module&quot;)    # iterate over all operations directly    for operation in buildlog:        # Get the module name that generated this file        env.log.info(&quot;Module({}) generated the '{}' file&quot;                     .format(operation.module, operation.filename))        # You can also get the filename relative to a subfolder in outpath        env.relative_output(operation.filename, &quot;subfolder/&quot;)        # or as an absolute path        env.real_output(operation.filename, &quot;subfolder/&quot;)    # get all include paths from all active modules    include_paths = env.collector_values(&quot;::include_path&quot;)```### Options*lbuild* options are mappings from strings to Python objects.Each option must have a unique name within their parent repository or module.If you do not provide a default value, the option is marked as **REQUIRED** andthe project cannot be built without it.```pythondef prepare(module, options):    # Add option to module    option = Option(...)    module.add_option(option)def build(env):    # Check if options exist    exists = env.has_option(&quot;:module:option&quot;)    # Access option value or use default if option doesn't exist    value = env.get(&quot;:module:option&quot;, default=&quot;value&quot;)    # Access option values, this may raise an exception if option doesn't exist    value = env[&quot;:module:option&quot;]```If your option requires a unique set of input values, you can tell *lbuild* to wrap the option into a set using `module.add_set_option()`:```pythondef prepare(module, options):    # Add an option, but allow a set of unique values as input and output    module.add_set_option(option)def build(env):    # a unique set of option values is returned here    for value in env[&quot;:module:option&quot;]:        print(value)```Option sets are declared as comma-separated strings, so that inheritingconfigurations or passing option values via CLI can overwrite these sets.A `StringOption` cannot be wrapped into a set for this reasons, however, it'seasy to split your string value in Python exactly how you want.```xml&lt;!-- All comma separated values are validated by the option --&gt;&lt;option name=&quot;:module:set-option&quot;&gt;value, 1, obj&lt;/option&gt;```If you want to preserve duplicates to count the number of inputs, use a listoption `module.add_list_option()`:```pythondef prepare(module, options):    # Add an option, but allow a list of values as input and output    module.add_list_option(option)def build(env):    # a list of option values is returned here    value_count = env[&quot;:module:option&quot;].count(&quot;value&quot;)```Options can have a dependency handler which is called when the projectconfiguration is merged into the module options. It will give you the choseninput value and you can return a number of module dependencies.```pythondef add_option_dependencies(value):    if special_condition(value):        # return single dependency        return &quot;repo:module&quot;    if other_special_condition(value):        # return multiple dependencies        return [&quot;:module1&quot;, &quot;:module2&quot;]    # No additional dependencies    return None```#### StringOptionThis is the most generic option, allowing to input any string.You may, however, provide your own validator that may raise a `ValueError`if the input string does not match your expectations.You may also pass a transformation function to convert the option value.The string is passed unmodified from the configuration to the module and thedependency handler.```pythondef validate_string(string):    if &quot;please&quot; not in string:        raise ValueError(&quot;Input does not contain the magic word!&quot;)def transform_string(string):    return string.lower()option = StringOption(name=&quot;option-name&quot;,                      description=&quot;inline&quot;, # or FileReader(&quot;file.md&quot;)                      default=&quot;default string&quot;,                      validate=validate_string,                      transform=transform_string,                      dependencies=add_option_dependencies)```#### PathOptionThis option operates on strings, but additionally validates them to besyntactically valid paths, so the filesystem accepts these stringsas valid arguments to path operations. This option does not check if the pathexists, or if it can be created, just if the string is properly formatted.Since an empty string is not a valid path, but it can be useful to allow anempty string as an input value to encode a special case (like a &quot;disable&quot; value),you may set `empty_ok=True` to tell the path validation to ignore empty strings.By default, the path input is not modified and must be correctly interpreted inthe context of the module that uses it (usually relocated to the output path).However, if you want to input an existing path you should set `absolute=True`,so that *lbuild* can relocate the *relative path* declared in the config filesto an absolute path, which is indepented of the CWD.This is particularly useful if you declare paths in config files that are notlocated at the project root, like options inherited from multiple `lbuild.xml`.```pythonoption = PathOption(name=&quot;option-name&quot;,                    description=&quot;path&quot;,                    default=&quot;path/to/folder/or/file&quot;,                    empty_ok=False, # is an empty path considered valid?                    absolute=False, # is the path relative to the config file?                    validate=validate_path,                    dependencies=add_option_dependencies)```#### BooleanOptionThis option maps strings from `true`, `yes`, `1`, `enable` to `bool(True)` and`false`, `no`, `0`, `disable` to `bool(False)`. You can extend this list with acustom transform handler. The dependency handler is passed this `bool` value.```pythondef transform_boolean(string):    if string == 'y': return True;    if string == 'n': return False;    return string # hand over to built-in conversionoption = BooleanOption(name=&quot;option-name&quot;,                       description=&quot;boolean&quot;,                       default=True,                       transform=transform_boolean,                       dependencies=add_option_dependencies)```#### NumericOptionThis option allows a number from [-Inf, +Inf]. You can limit this to therange [minimum, maximum].The values can be specified directly as numeric value or as a string, which isinterpreted using the `eval()` function, so that you can describe values as moreintuitive formulas when necessary.You can also suffix numbers with the SI multipliers `K`, `M`, `G`, `T`, `Ki`,`Mi`, `Gi`, and `Ti` to simplify formulas even further.Note that you should use strings to specify precise floating point values suchas &quot;1/3&quot;. The validation and dependency handlers are passed a numeric value.```pythonoption = NumericOption(name=&quot;option-name&quot;,                       description=&quot;numeric&quot;,                       minimum=0,                       maximum=&quot;5Mi*2&quot;,                       default=&quot;1K&quot;,                       validate=validate_number,                       dependencies=add_option_dependencies)```#### EnumerationOptionThis option maps a string to any generic Python object.You can provide a list, set, tuple or range, the only limitation is thatthe objects must be convertible to a string for unique identification.If this is not possible, you can provide a dictionary with a manual mappingfrom string to object. The dependency handler is passed the string value.```pythonoption = EnumerationOption(name=&quot;option-name&quot;,                           description=&quot;enumeration&quot;,                           # must be implicitly convertible to string!                           enumeration=[&quot;value&quot;, 1, obj],                           # or use a dictionary explicitly                           enumeration={&quot;value&quot;: &quot;value&quot;, &quot;1&quot;: 1, &quot;obj&quot;: obj},                           default=&quot;1&quot;,                           dependencies=add_option_dependencies)```### QueriesIt is sometimes necessary to share code and data between *lbuild* modules,which can be difficult when they are split across files and repositories.Queries allow you to share functions and computed properties with other modulesusing the global name resolution system.```pythondef prepare(module, options):    # Add queries to module    query = Query(...)    module.add_query(query)def build(env):    exists = env.has_query(&quot;:module:query&quot;)    # Access query value or use default if query doesn't exist    data = env.query(&quot;:module:query&quot;, default=&quot;value&quot;)```*Note that queries must be stateless (aka. a pure function), since module buildorder is not guaranteed. You must enforce this property yourself.*You can discover all the available queries in your repository using`lbuild discover --developer`.#### QueryThis wraps any callable object into a query. By default the name is taken fromthe object's name, however, you may overwrite this.Note that when using a lambda function, you must provide a name.The description is taken from the objects docstring.```pythondef shared_function(args):    &quot;&quot;&quot;    Describe what this query does.    :param args: what does it need?    :returns: what does it return?    &quot;&quot;&quot;    return argsquery = Query(function=shared_function)query = Query(name=&quot;different_name&quot;,              function=shared_function)```#### EnvironmentQueryThis query's result is computed only once on demand and then cached.The data must be returned from a factory function that gets passed theenvironment of the first module to access this query.The return value is then cached for all further accesses.This allows you to lazily compute your shared properties only once and only ifaccessed by any module.```pythondef factory(env):    &quot;&quot;&quot;    Describe what this query is about, but don't document the `env` argument.    :returns: an immutable object    &quot;&quot;&quot;    # You can read the build environment, but cannot modify it here    value = env[&quot;repo:module:option&quot;]    # This return data is cached, so this function is only called once.    return {&quot;key&quot;: value}query = EnvironmentQuery(name=&quot;name&quot;,                         factory=factory)```### CollectorsThe post-build step has access to the build log containing the list of modulesthat were built and what files they generated.However, these modules also need to pass additional data to the post-build steps,so that this information can be computed locally.*lbuild* allows each module to declare what metadata it wants using a collector,which is given a name, description and optional limitations depending on type.In the build step, each module may add values to this collector, which thepost-build steps then can access.```pythondef prepare(module, options):    # Add a collector to module    collector = Collector(...)    module.add_collector(collector)def build(env):    exists = env.has_collector(&quot;:module:collector&quot;)    # Add values to this collector    env.collect(&quot;:module:collector&quot;, &quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;)def post_build(env):    # Get all unique values from all operations    unique_values = env.collector_values(&quot;:module:collector&quot;)    # get all values from all operations, even duplicates!    all_values = env.collector_values(&quot;:module:collector&quot;, unique=False)```Note that the ordering of values is preserved only relative to the order theywere added within a module and only if accessing them non-uniquely!The above example will preserve the order of `value1`, `value2` and `value3`,only if the values are accessed not uniquely and only relative to each other.When you add values to a collector, the current operation is recorded, consistingout of the current module, but you may also explicitly set this to a set offile operations:```pythondef build(env):    operation = env.copy(&quot;file.hpp&quot;)    # Add values to this collector for the file operation    env.collect(&quot;:module:collector&quot;, &quot;values&quot;, operations=operation)    # The return value from a file operation is actually a set of operations    operations = env.copy(&quot;folder1/&quot;)    # So you can extend this set for multiple file operations    operations |= env.copy(&quot;folder2/&quot;)    # And then filter this set of operations    operations = filter(lambda op: op.filename.endswith(&quot;.txt&quot;), operations)    # Only add this metadata to .txt files    env.collect(&quot;:module:collector&quot;, &quot;txt-file-values&quot;, operations=operations)    # A file operation object has these properties:    operation.module # full module name, this is always available    operation.repository # repository name, always available    operation.has_filename # Some operations are specific to files    operation.filename # The generated filename relative to outpathdef post_build(env):    # You can use these operation properties to filter the collector values    txt_filter = lambda op: op.repository == &quot;repo&quot; and op.filename.endswith(&quot;.txt&quot;)    unique_txt_values = env.collector_values(&quot;:module:collector&quot;, filterfunc=txt_filter)    # May contain duplicate values!    all_txt_values = env.collector_values(&quot;:module:collector&quot;, filterfunc=txt_filter, unique=False)```If you have very special requirements for the ordering values (for examplewhen collecting compile flags), consider iterating over the collectors itemsmanually, and possibly de-duplicating and reordering the values yourself.```pythondef post_build(env):    # Get the collector, may return None if collector does not exist!    collector = env.collector(&quot;:module:collector&quot;)    if collector is not None:        for operation, values in collector.items():            # values is a list and may contain duplicates            print(operation.module, values)            if operation.has_filename: # not all operations have filenames!                print(operation.filename)```Note that collector values that were added by a module without explicitoperations do not have filename, only module names!Collectors are implemented using the same type-safe mechanisms as[Options](#Options), the only differences are the lack of dependency handlersand default values, since you can add default values in the modules build step.You may add collector values via the project configuration. However, since thesecollector values cannot be overwritten by inheriting configurations use this with care.```xml&lt;library&gt;  &lt;collectors&gt;    &lt;collect name=&quot;repo:collector_name&quot;&gt;value&lt;/collect&gt;    &lt;collect name=&quot;repo:collector_name&quot;&gt;value2&lt;/collect&gt;  &lt;/collectors&gt;&lt;/library&gt;```You can discover all the available collectors in your repository using`lbuild discover --developer`.#### CallableCollectorThis collector allows you to collect callable objects, that the post-build stepcan execute. This can be useful for providing specializations to the post-buildmodule without it needing to know how they work.```pythoncollector = CallableCollector(name=&quot;collector-name&quot;,                              description=&quot;callable&quot;)```#### StringCollectorSee [StringOption](#StringOption) for documentation.```pythoncollector = StringCollector(name=&quot;collector-name&quot;,                            description=&quot;string&quot;,                            validate=validate_function)```#### PathCollectorSee [PathOption](#PathOption) for documentation.```pythoncollector = PathCollector(name=&quot;collector-name&quot;,                          description=&quot;path&quot;,                          empty_ok=False,                          absolute=False)```#### BooleanCollectorSee [BooleanOption](#BooleanOption) for documentation.```pythoncollector = BooleanCollector(name=&quot;collector-name&quot;,                             description=&quot;boolean&quot;)```#### NumericCollectorSee [NumericOption](#NumericOption) for documentation.```pythoncollector = NumericCollector(name=&quot;collector-name&quot;,                             description=&quot;numeric&quot;,                             minimum=0,                             maximum=100)```#### EnumerationCollectorSee [EnumerationOption](#EnumerationOption) for documentation.```pythoncollector = EnumerationCollector(name=&quot;collector-name&quot;,                                 description=&quot;enumeration&quot;,                                 enumeration=enumeration)```### Aliases*lbuild* aliases are mappings from one lbuild node to another. They are usefulfor gracefully dealing with renaming or moving nodes in your lbuild module tree.Aliases will print a warning when accessed showing the alias description. Eachalias must have a unique name within their parent repository or module.Aliases can be used for any type of node that you want forwarded. You can alsoadd aliases that do not have a destination and will raise an exception with thealias description. This allows you to remove lbuild nodes while providingdetails for a workaround.```pythondef prepare(module, options):    # Move option in this module    module.add_module(Option(name=&quot;option&quot;))    # Forward the old option to the new option    module.add_alias(Alias(name=&quot;option-alias&quot;,                           destination=&quot;option&quot;,                           description=&quot;Renamed for clarity.&quot;))    # Instead of silently failing, you can provide a detailed description    # about why the node was removed and what the workaround is.    module.add_alias(Alias(name=&quot;removed-alias&quot;,                           description=&quot;Removed. Workaround: ...&quot;))    # You alias any type to any other node.    module.add_alias(Alias(name=&quot;submodule-alias&quot;,                           destination=&quot;:other-module:submodule&quot;                           description=&quot;Removed. Workaround: ...&quot;))def build(env):    # Will show a warning (once) that the alias has been moved    exists = env.has_option(&quot;:module:option-alias&quot;)    # Accesses :module:option instead    value = env[&quot;:module:option-alias&quot;]    # This will raise an exception with the alias description    value = env[&quot;:module:removed-alias&quot;]    # will check for :other-module:submodule instead    value = env.has_module[&quot;:module:submodule-alias&quot;]```### Jinja2 Configuration*lbuild* uses the [Jinja2 template engine][jinja2] with the following globalconfiguration:- Line statements start with `%% statement`.- Line comments start with `%# comment`.- Undefined variables throw an exception instead of being ignored.- Global extensions: `jinja2.ext.do`.- Global substitutions are:  + `time`: `strftime(&quot;%d %b %Y, %H:%M:%S&quot;)`  + `options`: an option resolver in the context of the current module.### Name Resolution*lbuild* manages repositories, modules and options in a tree structure andserializes identification into unique string using `:` as hierarchy delimiters.Any identifier provided via the command line, configuration, repository ormodule files use the same resolver, which allows using *partially-qualified*identifiers. In addition, globbing for multiple identifiers using fnmatchsemantics is supported.The following rules for resolving identifiers apply:1. A fully-qualified identifier specifies all parts: `repo:module:option`.2. A partially-qualified identifier adds fnmatch wildcarts: `*:m.dule:opt*`.3. `*` wildcarts for entire hierarchies can be ommitted: `::option`4. A special wildcart is `:**`, which globs for everything below the current   hierarchy level: `repo:**` selects all in `repo`, `repo:module:**` all in   `repo:module`, etc.5. Wildcarts are resolved in reverse hierarchical order. Therefore, `::option`   may be unique within the context of `:module`, but not within the entire   project.6. For accessing direct children, you may specify their name without any   delimiters: `option` within the context of `:module` will resolve to   `:module:option`.Partial identifiers were introduced to reduce verbosity and aid refactoring,it is therefore recommended to:1. Omit the repository name for accessing modules and options within the same   repository.2. Accessing a module's options with their name directly.### Execution order*lbuild* executes in this order:1. `repository:init()`2. Create repository options3. `repository:prepare(repo-options)`4. Find all modules in repositories5. `module:init()`6. `module:prepare(repo-options)`7. Create module options8. Resolve module dependencies9. `module:validate(env)` submodules-first, *optional*10. `module:build(env)` submodules-first11. `repo:build(env)`: *optional*12. `module:post_build(env)`: submodules-first, *optional*[modm]: https://modm.io/how-modm-works[taproot]: https://github.com/uw-advanced-robotics/taproot[outpost]: https://github.com/DLR-RY/outpost-core[jinja2]: http://jinja.pocoo.org[python]: https://www.python.org[pypi]: https://pypi.org/project/lbuild[salkinium]: https://github.com/salkinium[travis]: https://travis-ci.org/modm-io/lbuild[travis-svg]: https://travis-ci.org/modm-io/lbuild.svg?branch=develop</longdescription>
</pkgmetadata>