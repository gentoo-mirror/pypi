<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>patatt: cryptographic patch attestation for the masses======================================================This utility allows an easy way to add end-to-end cryptographicattestation to patches sent via mail. It does so by adapting the DKIMemail signature standard to include cryptographic signatures via theX-Developer-Signature email header.If your project workflow doesn't use patches sent via email, then youdon't need this and should simply start signing your tags and commits.Basic concepts--------------DKIM is a widely adopted standard for domain-level attestation of emailmessages. It works by hashing the message body and certain individualheaders, and then creating a cryptographic signature of the resultinghash. The receiving side obtains the public key of the sending domainfrom its DNS record and checks the signature and header/body hashes. Ifthe signature verifies and the resulting hashes are identical, thenthere is a high degree of assurance that neither the body of the messagenor any of the signed headers were modified in transit.This utility uses the exact same DKIM standard to hash the headers andthe body of the patch message, but uses a different set of fields andcanonicalization routines:- the d= field is not used (no domain signatures involved)- the q= field is not used (key lookup is left to the client)- the c= field is not used (see below for canonicalization)- the i= field is optional, but MUST be the canonical email address of  the sender, if not the same as the From: fieldCanonicalization~~~~~~~~~~~~~~~~Patatt uses the &quot;relaxed/simple&quot; canonicalization as defined by the DKIMstandard, but the message is first parsed by the &quot;git-mailinfo&quot; commandin order to achieve the following:- normalize any content-transfer-encoding modifications (convert back  from base64/quoted-printable/etc into 8-bit)- use any encountered in-body From: and Subject: headers to  rewrite the outer message headers- perform the subject-line normalization in order to strip content not  considered by git-am when applying the patch (i.e. drop [PATCH .*] and  other bracketed prefix content)To achieve this, the message is passed through git-mailinfo with thefollowing flags::    cat orig.msg | git mailinfo --encoding=utf-8 --no-scissors m p &gt; iPatatt then uses the data found in &quot;i&quot; to replace the From: and Subject:headers of the original message, and concatenates &quot;m&quot; and &quot;p&quot; backtogether to form the body of the message, which is then normalized usingCRLF line endings and the DKIM &quot;simple&quot; body canonicalization (anytrailing blank lines are removed).Any other headers included in signing are modified using the &quot;relaxed&quot;header canonicalization routines as defined in the DKIM RFC.In other words, the body and some of the headers are normalized andreconstituted using the &quot;git-mailinfo&quot; command, and then canonicalizedusing DKIM's relaxed/simple standard.Supported Signature Algorithms~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~DKIM standard mostly relies on RSA signatures, though RFC 8463 extendsit to support ED25519 keys as well. While it is possible to use any ofthe DKIM-defined algorithms, patatt only supports the followingsigning/hashing schemes:- ed25519-sha256: exactly as defined in RFC8463- openpgp-sha256: uses OpenPGP to create the signature- openssh-sha256: uses OpenSSH signing capabilitiesNote: Since GnuPG supports multiple signing key algorithms,openpgp-sha256 signatures can be done using EDDSA keys as well. However,since OpenPGP output includes additional headers, the &quot;ed25519-sha256&quot;and &quot;openpgp-sha256&quot; schemes are not interchangeable even when ed25519keys are used in both cases.Note: OpenSSH signature support was added in OpenSSH 8.0 and requiresssh-keygen that supports the -Y flag.In the future, patatt may add support for more algorithms, especially ifthat allows incorporating more hardware crypto offload devices (such asTPM).X-Developer-Key header~~~~~~~~~~~~~~~~~~~~~~Patatt adds a separate ``X-Developer-Key:`` header with public keyinformation. It is merely informational and ISN'T and SHOULDN'T be usedfor performing any kind of message validation (for obvious reasons). Itis included to make it easier for maintainers to obtain thecontributor's public key before performing whatever necessaryverification steps prior to its inclusion into their individual orproject-wide keyrings.This also allows keeping a historical record of contributor keys vialist archive services such as lore.kernel.org and others.Getting started as contributor------------------------------It is very easy to start signing your patches with patatt.Installing~~~~~~~~~~You can install from pip::    pip install --user patattMake sure your PATH includes $HOME/.local/bin.Alternatively, you can clone this repository and symlink patatt.sh intoyour path::    cd bin    ln -s ~/path/to/patatt/patatt.sh patattAfter this, you should be able to run ``patatt --help`` withoutspecifying the full path to the repository.Using PGP~~~~~~~~~If you already have a PGP key, you can simply start using it to signpatches. Add the following to your ~/.gitconfig::    [patatt]        signingkey = openpgp:KEYIDThe KEYID should be the 16-character identifier of your key, forexample::    [patatt]        signingkey = openpgp:E63EDCA9329DD07EUsing OpenSSH~~~~~~~~~~~~~If you have OpenSSH version 8.0+, then you can use your ssh keys forgenerating and verifying signatures. There are several upsides to usingopenssh as opposed to generic ed25519:- you can passphrase-protect your ssh keys- passphrase-protected keys will benefit from ssh-agent caching- you can use hardware tokens and ed25519-sk keys for higher protection- you are much more likely to remember to back up your ssh keysTo start using openssh signatures with patatt, add the following to your~/.gitconfig::    [patatt]        signingkey = openssh:~/.ssh/my_key_id.pub        selector = my_key_idNote, that the person verifying openssh signatures must also run theversion of openssh that supports this functionality.Using ed25519~~~~~~~~~~~~~If you don't already have a PGP key, you can opt to generate and use anew ed25519 key instead (see below for some considerations on pros andcons of PGP vs ed25519 keys).To generate a new keypair, run::    patatt genkeyYou will see an output similar to the following::    Generating a new ed25519 keypair    Wrote: /home/user/.local/share/patatt/private/20210505.key    Wrote: /home/user/.local/share/patatt/public/20210505.pub    Wrote: /home/user/.local/share/patatt/public/ed25519/example.org/user/default    Add the following to your .git/config (or global ~/.gitconfig):    ---    [patatt]        signingkey = ed25519:20210505    ---    Next, communicate the contents of the following file to the    repository keyring maintainers for inclusion into the project:    /home/user/.local/share/patatt/public/20210505.pubPlease make sure to back up your new private key, located in``~/.local/share/patatt/private``. It is short enough to simplyprint/write out for storing offline.Next, just do as instructions say. If the project for which you arecontributing patches already uses patatt attestation, please work withthe project maintainers to add your public key to the repository. Ifthey aren't yet using patatt, just start signing your patches andhopefully the project will start keeping its own keyring in the future.Testing if it's working~~~~~~~~~~~~~~~~~~~~~~~To test if it's working::    $ git format-patch -1 --stdout | patatt sign &gt; /tmp/testIf you didn't get an error message, then the process was successful. Youcan review /tmp/test to see that ``X-Developer-Signature`` and``X-Developer-Key`` headers were successfully added.You can now validate your own message::    $ patatt validate /tmp/testAutomatic signing via the sendemail-validate hook~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~If everything is working well, you can start automatically signing alloutgoing patches sent via git-send-email. Inside the repo you want enabledfor signing, run::    $ patatt install-hookOr you can do it manually::    $ echo 'patatt sign --hook &quot;${1}&quot;' &gt; &quot;$(git rev-parse --git-dir)/hooks/sendemail-validate&quot;    $ chmod a+x &quot;$(git rev-parse --git-dir)/hooks/sendemail-validate&quot;PGP vs OpenSSH vs ed25519 keys considerations~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~If you don't already have a PGP key that is used in your project, youmay wonder whether it makes sense to create a new PGP key, reuse yourOpenSSH key, or start using standalone ed25519 keys.Reasons to choose PGP:- you can protect the PGP private key with a passphrase (gpg-agent will  manage it for you so you only need to enter it once per session)- you can move your PGP key to an OpenPGP-compliant smartcard to further  protect your key from being leaked/stolen- you can use PGP keys to sign git tags/commits, not just mailed patchesIf you choose to create a new PGP key, you can use the following guide:https://github.com/lfit/itpol/blob/master/protecting-code-integrity.mdReasons to choose OpenSSH keys:- you can protect openssh keys with a passphrase and rely on ssh-agent  passphrase caching- you can use ssh keys with u2f hardware tokens for additional  protection of your private key data- very recent versions of git can also use ssh keys to sign tags and  commitsReasons to choose a standalone ed25519 key:- much smaller signatures, especially compared to PGP RSA keys- implements the DKIM ed25519 signing standard- faster operationIf you choose ed25519 keys, you will need to make sure that PyNaCl isinstalled (pip install should have already taken care of it for you).Getting started as a project maintainer---------------------------------------Patatt implements basic signature validation, but it's a tool aimedprimarily at contributors. If you are processing mailed-in patches, thenyou should look into using b4, which aims at making the entire processeasier. B4 properly recognizes X-Developer-Signature headers startingwith version 0.7.0 and uses the patatt library as well.- https://pypi.org/project/b4/That said, keyring management as discussed below applies both to patattand b4, so you can read on for an overview.In-git pubkey management~~~~~~~~~~~~~~~~~~~~~~~~The trickiest part of all decentralized PKI schemes is not the cryptoitself, but public key distribution and management. PGP famously triedto solve this problem by relying on cross-key certification andkeyservers, but the results were not encouraging.On the other hand, within the context of git repositories, we alreadyhave a suitable mechanism for distributing developer public keys, whichis the repository itself. Consider this:- git is already decentralized and can be mirrored to multiple  locations, avoiding any single points of failure- all contents are already versioned and key additions/removals can be  audited and &quot;git blame'd&quot;- git commits themselves can be cryptographically signed, which allows a  small subset of developers to act as &quot;trusted introducers&quot; to many  other contributors (mimicking the &quot;keysigning&quot; process)The idea of using git itself for keyring management was originallysuggested by the did:git project, though we do not currently implementthe proposed standard itself.- https://github.com/dhuseby/did-git-spec/blob/master/did-git-spec.mdKeyring structure~~~~~~~~~~~~~~~~~The keyring is structured as follows::    - dir: topdir (e.g. &quot;.keys&quot;)      |      - dir: keytype (e.g. &quot;ed25519&quot; or &quot;openpgp&quot;)        |        - dir: address-domainname (e.g. &quot;example.org&quot;)          |          - dir: address-localpart (e.g. &quot;developer&quot;)            |            - file: selector (e.g. &quot;default&quot;)The main reasoning behind this structure was to make it easy formultiple project maintainers to manage keys without causing anyunnecessary git merge complications. Keeping all public keys inindividual files helps achieve this goal.For example, let's take the following signature::    From: Konstantin Ryabitsev &lt;konstantin@linuxfoundation.org&gt;    X-Developer-Signature: v=1; a=ed25519-sha256; t=1620240207; l=2577;     h=from:subject; bh=yqviDBgyf3/dQgHcBe3B7fTP39SuKnYInPBxnOiuGcA=;     b=Xzd0287MvPE9NLX7xbQ6xnyrvqQOMK01mxHnrPmm1f6O7KKyogc8YH6IAlwIPdo+jk1CkdYYQsyZ     sS0cJdX2B4uTmV9mxOe7hssjtjLcj5/NU9zAw6WJARybaNAKH8rvThe key would be found in the following subpath::    .keys/ed25519/linuxfoundation.org/konstantin/defaultIf i= and s= fields are specified in the signature, as below::    X-Developer-Signature: v=1; a=ed25519-sha256; t=1620244687; l=12645;     i=mricon@kernel.org; s=20210505; h=from:subject;     bh=KRCBcYiMdeoSX0l1XJ2YzP/uJhmym3Pi6CmbN9fs4aM=;     b=sSY2vXzju7zU3KK4VQ5vFa5iPpDr3nrf221lnpq2+uuXmCODlAsgoqDmjKUBmbPtlY1Bcb2N0XZQ     0KX+OShCAAwB5U1dtFtRnB/mgVibMxwl68A7OivGIVYe491yll5qThen the path would reflect those parameters::    .keys/ed25519/kernel.org/mricon/20210505In the case of ed25519 keys, the contents of the file are just thebase64-encoded public key itself. For openpgp keys, the format should bethe ascii-armored public key export, for example obtained by using thefollowing command::    gpg -a --export --export-options export-minimal keyidFor openssh keys, the key contents are a single line in the usualopenssh pubkey format, e.g.::    ssh-ed25519 AAAAC3N... comment@or-hostnameWhose keys to add to the keyring~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~It does not really make sense to require cryptographic attestation forpatches submitted by occasional contributors. The only keys added to thekeyring should be those of the core maintainers who have push access tothe &quot;canonical&quot; repository location, plus the keys belonging to regularcontributors with a long-term ongoing relationship with the project.Managing the keyring: small teams~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~For smaller repositories with a handful of core maintainers, it makessense to keep the keyring in the main branch, together with all otherproject files.Managing the keyring: large teams~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~For large teams with thousands of regular contributors and teams ofsubsystem maintainers (e.g. the Linux kernel), it does not make sense tohave a centrally managed keyring tracked in the main repository.Instead, each subsystem maintainer team should manage their own keyringin a separate ref of their own repository.For example, to create a blank new ref called ``refs/meta/keyring``::    git symbolic-ref HEAD refs/meta/keyring    git reset --hard    mkdir ed25519 openpgpIndividual public key files can then be added and committed followingthe same structure as described above. Keeping the keyring outside theregular development branch ensures that it doesn't interfere withsubmitted pull requests or git-format-patch operations. Keeping the refunder ``refs/meta/`` will hide it from most GUI interfaces, but if thatis not the goal, then it can be stored in ``refs/heads`` just like anyother branch.To commit and push the files after adding them, regular git operationsshould be used::    git commit -asS    git push origin HEAD:refs/meta/keyring    # Switch back to the development environment    git checkout regular-branchTo make changes to an existing keyring ref, a similar workflow can beused::    git fetch origin refs/meta/keyring    # Verify that the commit is signed    git verify-commit FETCH_HEAD    git checkout FETCH_HEAD    # make any changes to the keys    git commit -asS    git push origin HEAD:refs/meta/keyring    git checkout regular-branchAlternatively, if key additions/updates are frequent enough, the remoteref can be checked out into its own workdir and set up for properremote tracking.Telling patatt where to find the keyring(s)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~To use the keyring with patatt or b4, just tell them which paths tocheck, via the ``keyringsrc`` setting (can be specified multipletimes and will be checked in the listed order)::    [patatt]        # Empty ref means &quot;use currently checked out ref in this repo&quot;        keyringsrc = ref:::.keys        # Use a dedicated ref in this repo called refs/meta/keyring        keyringsrc = ref::refs/meta/keyring:        # Use a ref in a different repo        keyringsrc = ref:~/path/to/another/repo:refs/heads/main:.keys        # Use a regular dir on disk        keyringsrc = ~/git/korg-pgpkeys/.keyringFor b4, use the same configuration under the ``[b4]`` section.External and local-only keyrings~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Any path on disk can be used for a keyring location, and some willalways be checked just in case. The following locations are added bydefault::    ref:::.keys    ref:::.local-keys    ref::refs/meta/keyring:    $XDG_DATA_HOME/patatt/publicThe &quot;:::&quot; means &quot;whatever ref is checked out in the current repo&quot;,and $XDG_DATA_HOME usually points at $HOME/.local/share.Getting support and contributing patches----------------------------------------Please send patches and support requests to tools@linux.kernel.org.Submissions must be made under the terms of the Linux Foundationcertificate of contribution and should include a Signed-off-by: line.Please read the DCO file for full legal definition of what that implies.Frequently seen commentary--------------------------Why is this library even needed? Why not...Why not simply PGP-sign all patches?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~PGP-signing patches causes important problems for reviewers. If a patchis inline-signed, then this not only adds textual headers/footers, butadds additional escaping in the protected body, converting all '^-'sequences into '^- -', which corrupts patches.MIME-signing is better, but has several other downsides:- messages are now sent as multipart mime structures, which causes some  tooling to no longer properly handle the patch content- the signature attachments may be stripped/quarantined by email  gateways that don't properly recognize OpenPGP mime signatures- the From/Subject headers are rarely included into protected content,  even though they are crucial parts of what ends up going into a git  commitThese considerations have resulted in many projects specificallyrequesting that patches should NOT be sent PGP-signed.Why not just rely on proper code review?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Code review is a crucial step of the development process and patatt doesnot aim to replace it. However, there are several areas where theprocess can be abused by malicious parties in the absence of end-to-endcryptographic attestation:1. A maintainer who struggles with code review volume may delegate parts   of their duties to a submaintainer. If that person submits aggregated   patch series to the maintainer after performing that work, there must   be a mechanism to ensure that none of the reviewed patches have been   modified between when they were reviewed by the trusted submaintainer   and when the upstream developer applies them to their tree. Up to   now, the only mechanism to ensure this was via signed pull requests   -- with patatt this is now also possible with regular patch series.2. It is important to ensure that what developer reviews is what   actually ends up being applied to their git tree. Linux development   process consists of collecting follow-up trailers (Tested-by,   Reviewed-by, etc), so various tooling exists to aggregate these   trailers and create the collated patch series containing all   follow-up tags (see b4, patchwork, etc). Patatt signing provides a   mechanism to ensure that what that developer reviewed and approved   and what they applied to their tree is the exact same code and hasn't   been maliciously modified in-between review and &quot;git am&quot; (e.g. by   archival services such as lore.kernel.org, mail hosting providers,   someone with access to the developer's inbox, etc).3. An attacker may attempt to impersonate a well-known developer by   submitting malicious code, perhaps with the hope that it receives   less scrutiny and is accepted without rigorous code review. Even if   this attempt is unsuccessful (and it most likely would be), this may   cause unnecessary reputation damage to the person being impersonated.   Cryptographic signatures (and lack thereof) will help the developer   quickly establish that the attack was performed without their   involvement.Why not just rely on DKIM?~~~~~~~~~~~~~~~~~~~~~~~~~~DKIM standard is great, but there are several places where it falls abit short when it comes to patch attestation:1. The signing is done by the mail gateways that may or may not be   properly checking that the &quot;From:&quot; header matches the identity of the   authenticated user. For example, a service that allows free account   registration may not check that alice@example.org sends outgoing   email with &quot;bob@example.org&quot; in the &quot;From:&quot; field, which would allow   Alice to impersonate Bob and have the messages arrive with a valid   DKIM signature.2. DKIM is usually seen as merely a spam reduction mechanism, so there's   usually little incentive for infrastructure administrators to be too   strict about how they handle the private keys used for DKIM signing.   Most likely, they are just stored on disk without a passphrase and   accessible by the SMTP daemon.3. DKIM's &quot;relaxed&quot; canonicalization standard for message bodies   replaces all multiple whitespace characters with a single space   before the body hash is signed. This poses significant problems for   patches where whitespace is syntactically significant (Python,   Makefiles, etc). A &quot;return True&quot; with a different indent will pass   DKIM signature check and may introduce a serious security   vulnerability.4. DKIM doesn't prevent typosquatting attacks. For example, an attacker   attempting to impersonate known.developer@companyname.com may send an   email from known.developer@company-name.com or any other   similar-looking address or domain, with valid DKIM signatures in   every case.</longdescription>
</pkgmetadata>