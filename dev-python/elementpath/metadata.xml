<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>***********elementpath***********.. image:: https://img.shields.io/pypi/v/elementpath.svg   :target: https://pypi.python.org/pypi/elementpath/.. image:: https://img.shields.io/pypi/pyversions/elementpath.svg   :target: https://pypi.python.org/pypi/elementpath/.. image:: https://img.shields.io/pypi/implementation/elementpath.svg   :target: https://pypi.python.org/pypi/elementpath/.. image:: https://img.shields.io/badge/License-MIT-blue.svg   :alt: MIT License   :target: https://lbesson.mit-license.org/.. image:: https://img.shields.io/pypi/dm/elementpath.svg   :target: https://pypi.python.org/pypi/elementpath/.. elementpath-introductionThe proposal of this package is to provide XPath 1.0, 2.0, 3.0 and 3.1selectors for ElementTree XML data structures, both for the standardElementTree library and for the `lxml.etree &lt;http://lxml.de&gt;`_ library.For `lxml.etree &lt;http://lxml.de&gt;`_ this package can be useful for providingXPath 2.0/3.0/3.1 selectors, because `lxml.etree &lt;http://lxml.de&gt;`_ alreadyhas it's own implementation of XPath 1.0.Installation and usage======================You can install the package with *pip* in a Python 3.7+ environment::    pip install elementpathFor using it import the package and apply the selectors on ElementTree nodes:&gt;&gt;&gt; import elementpath&gt;&gt;&gt; from xml.etree import ElementTree&gt;&gt;&gt; root = ElementTree.XML('&lt;A&gt;&lt;B1/&gt;&lt;B2&gt;&lt;C1/&gt;&lt;C2/&gt;&lt;C3/&gt;&lt;/B2&gt;&lt;/A&gt;')&gt;&gt;&gt; elementpath.select(root, '/A/B2/*')[&lt;Element 'C1' at ...&gt;, &lt;Element 'C2' at ...&gt;, &lt;Element 'C3' at ...&gt;]The *select* API provides the standard XPath result format that is a list or an elementarydatatype's value. If you want only to iterate over results you can use the generator function*iter_select* that accepts the same arguments of *select*.The selectors API works also using XML data trees based on the `lxml.etree &lt;http://lxml.de&gt;`_library:&gt;&gt;&gt; import elementpath&gt;&gt;&gt; import lxml.etree as etree&gt;&gt;&gt; root = etree.XML('&lt;A&gt;&lt;B1/&gt;&lt;B2&gt;&lt;C1/&gt;&lt;C2/&gt;&lt;C3/&gt;&lt;/B2&gt;&lt;/A&gt;')&gt;&gt;&gt; elementpath.select(root, '/A/B2/*')[&lt;Element C1 at ...&gt;, &lt;Element C2 at ...&gt;, &lt;Element C3 at ...&gt;]When you need to apply the same XPath expression to several XML data you can also use the*Selector* class, creating an instance and then using it to apply the path on distinct XMLdata:&gt;&gt;&gt; import elementpath&gt;&gt;&gt; import lxml.etree as etree&gt;&gt;&gt; selector = elementpath.Selector('/A/*/*')&gt;&gt;&gt; root = etree.XML('&lt;A&gt;&lt;B1/&gt;&lt;B2&gt;&lt;C1/&gt;&lt;C2/&gt;&lt;C3/&gt;&lt;/B2&gt;&lt;/A&gt;')&gt;&gt;&gt; selector.select(root)[&lt;Element C1 at ...&gt;, &lt;Element C2 at ...&gt;, &lt;Element C3 at ...&gt;]&gt;&gt;&gt; root = etree.XML('&lt;A&gt;&lt;B1&gt;&lt;C0/&gt;&lt;/B1&gt;&lt;B2&gt;&lt;C1/&gt;&lt;C2/&gt;&lt;C3/&gt;&lt;/B2&gt;&lt;/A&gt;')&gt;&gt;&gt; selector.select(root)[&lt;Element C0 at ...&gt;, &lt;Element C1 at ...&gt;, &lt;Element C2 at ...&gt;, &lt;Element C3 at ...&gt;]Public API classes and functions are described into the`elementpath manual on the &quot;Read the Docs&quot; site &lt;http://elementpath.readthedocs.io/en/latest/&gt;`_.For default the XPath 2.0 is used. If you need XPath 1.0 parser provide the *parser* argument:&gt;&gt;&gt; from elementpath import select, XPath1Parser&gt;&gt;&gt; from xml.etree import ElementTree&gt;&gt;&gt; root = ElementTree.XML('&lt;A&gt;&lt;B1/&gt;&lt;B2&gt;&lt;C1/&gt;&lt;C2/&gt;&lt;C3/&gt;&lt;/B2&gt;&lt;/A&gt;')&gt;&gt;&gt; select(root, '/A/B2/*', parser=XPath1Parser)[&lt;Element 'C1' at ...&gt;, &lt;Element 'C2' at ...&gt;, &lt;Element 'C3' at ...&gt;]For XPath 3.0/3.1 import the parser from *elementpath.xpath3* subpackage, that is not loadedfor default:&gt;&gt;&gt; from elementpath.xpath3 import XPath3Parser&gt;&gt;&gt; select(root, 'math:atan(1.0e0)', parser=XPath3Parser)0.7853981633974483Note: *XPath3Parser* is an alias of *XPath31Parser*.If you need only XPath 3.0 you can also use a more specific subpackage,avoiding the loading of XPath 3.1 implementation:&gt;&gt;&gt; from elementpath.xpath30 import XPath30Parser&gt;&gt;&gt; select(root, 'math:atan(1.0e0)', parser=XPath30Parser)0.7853981633974483Contributing============You can contribute to this package reporting bugs, using the issue tracker or by a pull request.In case you open an issue please try to provide a test or test data for reproducing the wrongbehaviour. The provided testing code shall be added to the tests of the package.The XPath parsers are based on an implementation of the Pratt's Top Down Operator Precedence parser.The implemented parser includes some lookup-ahead features, helpers for registering tokens and forextending language implementations. Also the token class has been generalized using a `MutableSequence`as base class. See *tdop.py* for the basic internal classes and *xpath1_parser.py* for extensionsand for a basic usage of the parser.If you like you can use the basic parser and tokens provided by the *tdop.py* module toimplement other types of parsers (I think it could be also a funny exercise!).License=======This software is distributed under the terms of the MIT License.See the file 'LICENSE' in the root directory of the presentdistribution, or http://opensource.org/licenses/MIT.</longdescription>
</pkgmetadata>