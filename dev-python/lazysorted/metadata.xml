<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>lazysorted==========lazysorted is a Python extension module for sorting sequences lazily. Itpresents the programmer with the abstraction that they are actuallyworking with a sorted list, when in fact the list is only physicallysorted when the programmer requests elements from it, and even then itis only sorted partially, just enough to return whatever was requested.The LazySorted object has a constructor that implements the sameinterface as the builtin ``sorted(...)`` function, and it supports mostof the non-mutating methods of a python list.Since the LazySorted object only sorts as much as necessary, it can befaster than using the builtin ``sorted(...)`` for tasks that do notrequire the entire data to be sorted, like:1. Computing medians2. Computing `truncated   means &lt;http://en.wikipedia.org/wiki/Truncated%5Fmean&gt;`_3. Quickly iterating through the first few sorted elements of a list4. Computing the deciles or quartiles of some dataHow to use it-------------You can use LazySorted in much the same way you use the ``sorted(...)``function and the python lists it produces:::    from lazysorted import LazySorted    from math import floor, ceil    def median(xs):        &quot;&quot;&quot;An expected linear time median function&quot;&quot;&quot;        ls = LazySorted(xs)        n = len(ls)        if n == 0:            raise ValueError(&quot;Need a non-empty iterable&quot;)        elif n % 2 == 1:            return ls[n//2]        else:            return sum(ls[(n/2-1):(n/2+1)]) / 2.0    def top_k(xs, k, key=None, reverse=False):        &quot;&quot;&quot;Efficiently computes the top k elements of xs using the given key, or        the bottom k if reverse=True&quot;&quot;&quot;        ls = LazySorted(xs, key=key, reverse=reverse)        return ls[0:k]            def trimmed_mean(xs, alpha=0.05):        &quot;&quot;&quot;Computes the mean of the xs from the alpha to (1-alpha) quantiles        in expected linear time. More robust than the ordinary sample mean.&quot;&quot;&quot;        if not 0 &lt;= alpha &lt; 0.5:            raise ValueError(&quot;alpha must be in [0, 0.5)&quot;)        ls = LazySorted(xs)        n = len(ls)        if n == 0:            raise ValueError(&quot;Need a non-empty iterable&quot;)        lower = int(floor(n * alpha))        upper = int(ceil(n * (1 - alpha)))        return sum(ls.between(lower, upper)) / (upper - lower)In addition to the ``__len__`` and ``__getitem__`` methods demostratedabove, LazySorted also supports the ``__iter__``, ``__contains__``,``index``, and ``count`` methods, just like a regular python list:::    &gt;&gt;&gt; import random    &gt;&gt;&gt; from lazysorted import LazySorted    &gt;&gt;&gt; xs = list(range(1000)) + 5 * [1234]    &gt;&gt;&gt; random.shuffle(xs)    &gt;&gt;&gt; ls = LazySorted(xs)    &gt;&gt;&gt; for x in ls:    ...     print(x)    ...     if x &gt;= 3:    ...         break    0    1    2    3    &gt;&gt;&gt; 1235 in ls    False    &gt;&gt;&gt; ls.index(821)    821    &gt;&gt;&gt; ls.count(1234)    5Although the LazySorted constructor pretends to be equivalent to the``sorted`` function, and the LazySorted object pretends to be equivalentto a sorted python list, there are a few differences between them:1. LazySorted objects are immutable, while python lists are not.2. Sorting with the builtin ``sorted`` function is guaranteed to be   stable, (ie, preserve the original order of elements that compare   equal), while LazySorted sorting is not stable.3. The LazySorted object has a ``between(i, j)`` method, which returns a   list of all the items whose sorted indices are in ``range(i, j)``,   but not necessarily in order. This is useful, for example, for   throwing away outliers when computing an alpha-trimmed mean.When the APIs differ between python2.x and python3.x, lazysortedimplements the python3.x version. So the LazySorted constructor does notsupport the ``cmp`` argument that was removed in python3.x, and theLazySorted object does not support the ``__getslice__`` method that wasalso removed in python3.x.All of the LazySorted methods have pretty good documentation, which canbe accessed through the builtin ``help(...)`` function.I've tested lazysorted and found it to work for CPython versions 2.5,2.6, 2.7, and 3.1, 3.2, and 3.3. I haven't tested 3.0.How it works------------In short, LazySorted works by using quicksort partitions lazily andkeeping track of the indices used as pivots.**`quicksort &lt;http://en.wikipedia.org/wiki/Quicksort&gt;`_** sorts a listby picking an element of the list to be the &quot;pivot&quot;, and thenpartitioning the data into the part that's greater than or equal to thepivot and the part that's less than the pivot. These two parts are thenrecursively sorted with quicksort,**`quickselect &lt;http://en.wikipedia.org/wiki/Quickselect&gt;`_** finds thekth smallest element of a list by picking a pivot element andpartitioning the data, as in quicksort. Then the algorithm recurses intothe larger or smaller part of the list, depending on whether k is largeror smaller than the index of the pivot element.There are two key observations to make from these algorithms: First ofall, if we are only interested in part of a sorted list, we only need torecurse into the part we are interested in after doing a partition.Second of all, after doing some partitions, the list is partiallysorted, with the pivots all in their sorted order and the elementsbetween two pivots guaranteed to be bigger than the pivot to their leftand smaller than the pivot to their right.So whenever some data is queried from a LazySorted object, we first lookthrough the pivots to see which pivots delimit the data we want. Then wepartition sublist(s) as necessary and recurse into the side(s) that ourdata is in.There are also some implementation details that help lazysorted to runquickly: First of all, pivots elements are chosen to be the median ofthree randomly elements, which makes the partition likely to be morebalanced and guarantees average case O(n log n) behavior.Second of all, for sufficiently small lists, lazysorted uses insertionsort instead of quicksort, which is faster on small lists. Both of thesetricks are well-known to speed up quicksort implementations.Thirdly, since it's important to find the pivots that bound an indexquickly, lazysorted stores the pivots in a binary search tree, so thatthese sorts of lookups occur in O(log n) expected time. The BSTlazysorted uses is a `Treap &lt;http://en.wikipedia.org/wiki/Treap&gt;`_,selected for its overall expected speed, especially in insertion anddeletion.lazysorted also makes a big effort to delete irrelevant pivots from theBST; for example, if there are three pivots at indices 5, 26, and 42,and both the data (between 5 and 26) and (between 26 and 42) is sorted,then we can remove the irrelevant pivot 26, and just say that the databetween indices 5 and 42 is sorted.Installation------------lazysorted requires the python headers, (Python.h). I believe they shipwith OSX, but if you don't have them they can be installed on adebian-like system with::    $ sudo apt-get install python-devThen you can install lazysorted with::    $ sudo python setup.py installAlternatively, you can install lazysorted from pypi with::    $ easy_install --user lazysortedor::    $ pip install lazysortedthough you'll still need the python headers for it to build properly.Testing-------I've put in a fair bit of effort to test that lazysorted actually doeswhat it's supposed to. You can test it yourself (after installing it)with::    $ python test.pyFAQ---**Doesn't numpy have a median and percentile function?**Yes, but it's implemented by sorting the entire array and then readingoff the requested values, not with quickselect or another O(n) selectionalgorithm. And LazySorted is empirically faster, as you can see frombenchmark.py**Isn't python3.4 going to have a statistics module with a medianfunction?**Yes, and I'm really excited about it! This is`PEP450 &lt;http://www.python.org/dev/peps/pep-0450/&gt;`_. Unfortunately, thecurrent implementation is in pure python, and computes the median bysorting the data and picking off the middle element.**Doesn't the standard library have a heapq module?**Yes, but it lacks the full generality of this module. For example, youcan use it to get the k smallest elements in O(n log k) time, but not karbitrary contiguous elements. This module represents a differentparadigm: you're allowed to program as if your list was sorted, and letthe data structure deal with the details.**How is lazysorted licensed?**lazysorted is BSD-licensed. So you can use it pretty much however youlike! See LICENSE for details.**What should I not use lazysorted for?**1. Applications requiring a stable sort; the quicksort partitions make   the order of equal elements in the sorted list undefined.2. Applications requiring guaranteed fast worst-case performance.   Although it's very unlikely, many operations in LazySorted run in   worst case O(n^2) time.3. Applications requiring high security. The random number generator is   insecure and seeded from system time, so an (ambitious) attacker   could reverse engineer the random number generator and feed   LazySorted pathological lists that make it run in O(n^2) time.4. Sorting entire lists: The builtin ``sorted(...)`` is *very*   impressively designed and implemented. It also has the advantage of   running faster than O(n log n) on lists with partial structure.**How does lazysorted work at scale?**Unfortunately, only okay. This turns out to be primarily due to the factthat CPython deals with python objects by passing around pointers tothem, causing cache misses when the list and its elements no longer fitin cache. The gory details can be found in a blog post I wrote about`Memory Locality and PythonObjects &lt;http://www.naftaliharris.com/blog/heapobjects&gt;`_.However, this effect doesn't kick in until lists grow larger than about100K values, and even past that lazysorted remains faster than completesorting.Contact me!-----------If you use this software and feel so inclined, I'd greatly appreciatehearing what you are using it for! You can hit me up on Twitter`@naftaliharris &lt;https://twitter.com/naftaliharris&gt;`_, or at my emailaddress on my `contact page &lt;http://www.naftaliharris.com/contact/&gt;`_.</longdescription>
</pkgmetadata>