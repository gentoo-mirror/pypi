<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>univers: mostly universal version and version ranges comparison and conversion===============================================================================|Build Status| |License| |Python 3.6+|.. |Build Status| image:: https://api.travis-ci.com/sbs2001/univers.svg?branch=main&amp;status=passed.. |License| image:: https://img.shields.io/badge/License-Apache%202.0-blue.svg   :target: https://scancode-licensedb.aboutcode.org/apache-2.0.html.. |Python 3.6+| image:: https://img.shields.io/badge/python-3.6+-blue.svg   :target: https://www.python.org/downloads/release/python-380/**univers** was born out of the need for a mostly universal way to store versionranges and to compare two software package versions in VulnerableCode.Package version ranges and version constraints are useful and essential:- When relating a known vulnerability or bug to a range of affected package  versions. For instance a statement such as &quot;vulnerability 123 affects   package bar, version 3.1 and version 4.2 but not version 5&quot; defines a  range of bar versions affected by a vulnerability.- When resolving the dependencies of a package to express which subset of the  versions are supported. For instance a dependency requirement statement such  as &quot;I require package foo, version 2.0 and later versions&quot; defines a range of  acceptable foo versions.Version syntaxes and range notations are quite different across ecosystems,making it is difficult to process versions and version ranges across ecosystemsin a consistent way.Existing tools and libraries typically support a single algorithms to parse andcompare versions with a single version range notation for a single packageecosystem.**univers** is different:- It tracks each ecosystem versioning scheme and how two versions are compared.- It support a growing number of package ecosystems versioning in a single  library.- It can parse version range strings using their native notation (such as an npm  range) into the common &quot;vers&quot; notation and internal object model and can  return back a native version range string rebuilt from a &quot;vers&quot; range.- It is designed to work with `Package URLs (purl) &lt;https://github.com/package-url&gt;`_.How does **univers** work ?============================**univers** wraps, embeds and implements multiple version comparison libraries,each focused on a specific ecosystem versioning scheme.For each scheme, **univers** provides an implementation for:- the version comparison procedure e.g, how to compare two versions,- parsing and converting from a native version range notation to the  **univers** normalized and unified internal model,- converting a range back to its scheme-native range syntax and to the  ``vers`` syntax.**univers** implements ``vers``, an experimental unified and mostly universalversion range syntax. It can parse and convert an existing native version rangestrings to this unified syntax. For example, this means:- converting &quot;&gt;=1.2.3&quot; as used in a Python package into ``vers:pypi/&gt;=1.2.3``,- or converting &quot;^1.0.2&quot; as used in an npm package dependency declaration into  ``vers:npm/&gt;=1.0.2|&lt;2.0.0``The supported package ecosystems versioning schemes and underlying librariesinclude:- npm that use the &quot;node-semver&quot; ranges notation and the semver versions syntax  This is supported in part by the `semantic_version  &lt;https://github.com/rbarrois/python-semanticversion&gt;`_ library.- pypi: handled by Python's packaging library and the standard   ``packaging.version`` module.- Rubygems which use a semver-like but not-quite-semver scheme and there can be  commonly more than three version segments.  Gems also use a slightly different range notation from node-semver with  different operators and slightly different semantics: for instance it uses &quot;~&gt;&quot;  as a pessimistic operator and supports exclusion with != and does not support  &quot;OR&quot; between constraints (that it call requirements).  Gem are handled by Python port of the Rubygems requirements and version  handling code from the `puppeteer tool  &lt;https://github.com/nexB/univers/blob/main/src/univers/debian.py.ABOUT&gt;`_- debian: handled by the  `debian-inspector library  &lt;https://github.com/nexB/univers/blob/main/src/univers/debian.py.ABOUT&gt;`_.- maven: handled by the embedded `pymaven library  &lt;https://github.com/nexB/univers/blob/main/src/univers/pymaven.py.ABOUT&gt;`_.- rpm: handled by the embedded `rpm_vercmp library  &lt;https://github.com/nexB/univers/blob/main/src/univers/rpm.py.ABOUT&gt;`_.- golang (using semver)- PHP composer- ebuild/gentoo: handled by the embedded `gentoo_vercmp module  &lt;https://github.com/nexB/univers/blob/main/src/univers/gentoo.py.ABOUT&gt;`_.- arch linux: handled by the embedded `arch utility module borrowed from msys2  &lt;https://github.com/nexB/univers/blob/main/src/univers/arch.py.ABOUT&gt;`_.- Alpine linux: handled using the base Gentoo version support and extras  specific to Alpine.The level of support for each ecosystem may not be even for now and new schemesand support for more package types are implemented on a continuous basis.Alternative============Rather than using ecosystem-specific version schemes and code, another approachis to use a single procedure for all the versions as implemented in `libversion&lt;https://github.com/repology/libversion&gt;`_. ``libversion`` works in the mostcommon case but may not work correctly when a task that demand precise versioncomparisons such as for dependency resolution and vulnerability lookup wherea &quot;good enough&quot; comparison accuracy is not acceptable. ``libversion`` does nothandle version range notations.Installation============    $ pip install universExamples========Compare two native Python versions:.. code:: python    from univers.versions import PypiVersion    assert PypiVersion(&quot;1.2.3&quot;) &lt; PypiVersion(&quot;1.2.4&quot;)Normalize a version range from an npm:.. code:: python    from univers.version_range import NpmVersionRange    range = NpmVersionRange.from_native(&quot;^1.0.2&quot;)    assert str(range) == &quot;vers:npm/&gt;=1.0.2|&lt;2.0.0&quot;Test if a version is within or outside a version range:.. code:: python    from univers.versions import PypiVersion    from univers.version_range import VersionRange    range = VersionRange.from_string(&quot;vers:pypi/&gt;=1.2.4&quot;)    assert PypiVersion(&quot;1.2.4&quot;) in range    assert PypiVersion(&quot;1.2.3&quot;) not in rangeDevelopment============Run these commands, starting from a git clone of https://github.com/nexB/univers ::    $ ./configure --dev    $ source venv/bin/active    $ pytest -vvsWe use the same development process as other AboutCode projects.Visit https://github.com/nexB/univers andhttps://gitter.im/aboutcode-org/vulnerablecode andhttps://gitter.im/aboutcode-org/aboutcode for support and chat.Primary license: Apache-2.0SPDX-License-Identifier: Apache-2.0 AND BSD-3-Clause AND MIT</longdescription>
</pkgmetadata>