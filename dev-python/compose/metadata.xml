<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>compose=======The classic ``compose``, with all the Pythonic features.This ``compose`` follows the lead of ``functools.partial``and returns callable ``compose`` objects which:* have a regular and unambiguous ``repr``,* retain correct signature introspection,* allow introspection of the composed callables,* can be type-checked,* can be weakly referenced,* can have attributes,* will merge when nested, and* can be pickled (if all composed callables can be pickled).For ``async``/``await`` support, different variants of``compose`` are included.Versioning----------This library's version numbers follow the `SemVer 2.0.0specification &lt;https://semver.org/spec/v2.0.0.html&gt;`_.Installation------------::    pip install composeUsage-----Basics~~~~~~Import ``compose``:.. code:: python    &gt;&gt;&gt; from compose import composeAll the usual function composition you know and love:.. code:: python    &gt;&gt;&gt; def double(x):    ...     return x * 2    ...    &gt;&gt;&gt; def increment(x):    ...     return x + 1    ...    &gt;&gt;&gt; double_then_increment = compose(increment, double)    &gt;&gt;&gt; double_then_increment(1)    3Of course any number of functions can be composed:.. code:: python    &gt;&gt;&gt; def double(x):    ...     return x * 2    ...    &gt;&gt;&gt; times_eight = compose(double, double, double)    &gt;&gt;&gt; times_16 = compose(double, double, double, double)We still get the correct signature introspection:.. code:: python    &gt;&gt;&gt; def f(a, b, c=0, **kwargs):    ...     pass    ...    &gt;&gt;&gt; def g(x):    ...     pass    ...    &gt;&gt;&gt; g_of_f = compose(g, f)    &gt;&gt;&gt; import inspect    &gt;&gt;&gt; inspect.signature(g_of_f)    &lt;Signature (a, b, c=0, **kwargs)&gt;And we can inspect all the composed callables:.. code:: python    &gt;&gt;&gt; g_of_f.functions  # in order of execution:    (&lt;function f at 0x...&gt;, &lt;function g at 0x...&gt;)``compose`` instances flatten when nested:.. code:: python   &gt;&gt;&gt; times_eight_times_two = compose(double, times_eight)   &gt;&gt;&gt; times_eight_times_two.functions == times_16.functions   TrueWhen programmatically inspecting arbitrary callables, wecan check if we are looking at a ``compose`` instance:.. code:: python    &gt;&gt;&gt; isinstance(g_of_f, compose)    True``compose`` raises a ``TypeError`` when called withno arguments or with any non-callable arguments:.. code:: python    &gt;&gt;&gt; compose()    Traceback (most recent call last):        ...    TypeError: compose() needs at least one argument.. code:: python    &gt;&gt;&gt; compose(increment, 'oops', increment)    Traceback (most recent call last):        ...    TypeError: compose() arguments must be callable``async``/``await``~~~~~~~~~~~~~~~~~~~We can compose ``async`` code by using ``acompose``or ``sacompose`` (they are mostly the same):.. code:: python    &gt;&gt;&gt; import asyncio    &gt;&gt;&gt; from compose import acompose    &gt;&gt;&gt;    &gt;&gt;&gt; async def get_data():    ...     # pretend this data is fetched from some async API    ...     await asyncio.sleep(0)    ...     return 42    ...    &gt;&gt;&gt; get_and_double_data = acompose(double, get_data)    &gt;&gt;&gt; asyncio.run(get_and_double_data())    84``acompose`` and ``sacompose`` can compose any numberof ``async`` and regular functions, in any order:.. code:: python    &gt;&gt;&gt; async def async_double(x):    ...     await asyncio.sleep(0)    ...     return x * 2    ...    &gt;&gt;&gt; async_times_16 = acompose(async_double, double, async_double, double)    &gt;&gt;&gt; asyncio.run(async_times_16(1))    16``sacompose`` provides a different way of handlinga corner case that arises when composing functionsthat we get from users or other code: what ifevery function we receive to compose is regular,not ``async``, but we want to support ``async``?* ``acompose`` handles that case by returning an  awaitable anyway - so we can just write simple  code that calls ``await`` in all cases. This  is the best choice for function composition  that we *know* will be used in ``async`` code.* ``sacompose`` handles that case by returning a  callable which will *sometimes* behave in an  ``async`` way, by returning an awaitable only  if any of the composed functions return an  awaitable. This is needed to simplify reusable  helper code that can't know if it is composing  for regular or ``async`` code:  .. code:: python    &gt;&gt;&gt; from compose import sacompose    &gt;&gt;&gt;    &gt;&gt;&gt; regular_times_4 = sacompose(double, double)    &gt;&gt;&gt; awaitable_times_4 = sacompose(double, async_double)    &gt;&gt;&gt;        &gt;&gt;&gt; regular_times_4(1) == 4    True    &gt;&gt;&gt; asyncio.run(awaitable_times_4(1)) == 4    True``acompose`` and ``sacompose`` instances flatten when nested:.. code:: python    &gt;&gt;&gt; acompose(f, acompose(f, f)).functions == (f, f, f)    True    &gt;&gt;&gt; acompose(sacompose(f, f), f).functions == (f, f, f)    True    &gt;&gt;&gt; sacompose(acompose(f, f), f).functions == (f, f, f)    True    &gt;&gt;&gt; sacompose(f, sacompose(f, f)).functions == (f, f, f)    TrueBut ``compose`` instances *don't* flatten when nested into ``acompose`` and ``sacompose``, and vice versa:.. code:: python    &gt;&gt;&gt; acompose(g_of_f).functions    (compose(&lt;function g at 0x...&gt;, &lt;function f at 0x...&gt;),)    &gt;&gt;&gt; sacompose(g_of_f).functions    (compose(&lt;function g at 0x...&gt;, &lt;function f at 0x...&gt;),)    &gt;&gt;&gt; compose(acompose(g, f)).functions    (acompose(&lt;function g at 0x...&gt;, &lt;function f at 0x...&gt;),)    &gt;&gt;&gt; compose(sacompose(g, f)).functions    (sacompose(&lt;function g at 0x...&gt;, &lt;function f at 0x...&gt;),)``compose``, ``acompose``, and ``sacompose``instances are all distinct types:.. code:: python    &gt;&gt;&gt; isinstance(g_of_f, compose)    True    &gt;&gt;&gt; isinstance(g_of_f, (acompose, sacompose))    False    &gt;&gt;&gt; isinstance(async_times_16, acompose)    True    &gt;&gt;&gt; isinstance(async_times_16, (compose, sacompose))    False    &gt;&gt;&gt; isinstance(awaitable_times_4, sacompose)    True    &gt;&gt;&gt; isinstance(awaitable_times_4, (compose, acompose))    False</longdescription>
</pkgmetadata>