<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=================================Django Rest Framework Aggregation=================================.. image:: https://codecov.io/gh/kit-oz/drf-aggregation/branch/main/graph/badge.svg?token=X1RWDJI9NG   :target: https://codecov.io/gh/kit-oz/drf-aggregationDRF Mixin for getting aggregationsKey features:- can calculate percentile (work only on PostgreSQL) and percent- grouping by multiple fields- time series (does not work on SQLite)- limiting the number of displayed records.. attention::    API not stabilized yetInstalling----------For installing use pip::    $ pip install drf-aggregationUsage-----Create a ViewSet using a ViewSet from a package or by adding a mixin to an existing one.. code:: python    from drf_aggregation.mixins import AggregationMixin    from drf_aggregation.viewsets import AggregationViewSet    class MyCustomUserViewSet(AggregationMixin, GenericViewSet):        queryset = User.objects.all()        serializer_class = UserSerializer    class UserViewSet(AggregationViewSet):        queryset = User.objects.all()        serializer_class = UserSerializerRegister url.. code:: python    from drf_aggregation.routers import AggregationRouter    aggregation_router = AggregationRouter()    aggregation_router.register(&quot;user&quot;, UserViewSet)    urlpatterns = [        path(&quot;my/custom/endpoint&quot;, UserViewSet.as_view({&quot;get&quot;: &quot;aggregation&quot;})),    ]    urlpatterns += aggregation_router.urlsGet aggregations::    # Get the number of users    /user/aggregation?aggregation=count    # Last travel date    /trip/aggregation?aggregation=maximum&amp;aggregationField=duration    # Median salary    /position/aggregation?aggregation=percentile&amp;aggregationField=salary&amp;percentile=0.5    # Top 5 ticket executors    /ticket/aggregation?aggregation=count&amp;groupBy=assigned_to&amp;limit=5&amp;order=desc    # Percentage of open tickets by service    /ticket/aggregation?aggregation=percent&amp;groupBy=service&amp;additionalFilter={&quot;type&quot;:&quot;operator&quot;,&quot;data&quot;:{&quot;attribute&quot;:&quot;state&quot;,&quot;operator&quot;:&quot;=&quot;,&quot;value&quot;:&quot;open&quot;}}    # Life expectancy depending on the year of birth    /person/aggregation?aggregation=average&amp;aggregationField=age&amp;annotations={&quot;birth_year&quot;:{&quot;field&quot;:&quot;birth_date&quot;,&quot;kind&quot;:&quot;year&quot;}}&amp;groupBy=birth_yearSupported field types---------------------- IntegerField- FloatField- DateField (only minimum and maximum)- DateTimeField (only minimum and maximum)- DurationFieldAggreagtion-----------When sending the only parameter &quot;aggregation&quot;, a dictionary with the field &quot;value&quot; is returned::    ?aggregation=average        {&quot;value&quot;:42.5}Available aggregation types:- count- sum- average- minimum- maximum- percentile- percent (return two additional values: &quot;numerator&quot; and &quot;denominator&quot;)Additional parameters for different types of aggregations~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- aggregationField - mandatory for aggregations: sum, average, minimum, maximum, percentile- percentile - from 0 to 1, mandatory for percentile- additionalFilter - filter parser is used from package `drf-complex-filter`_, mandatory for percent.. _drf-complex-filter: https://github.com/kit-oz/drf-complex-filterGrouping results----------------To group the result, a comma-separated list of required fields is passed::    ?aggregation=count&amp;groupBy=field1,field2    [        {&quot;field1&quot;:&quot;value1&quot;,&quot;field2&quot;:&quot;value3&quot;,&quot;value&quot;:2},        {&quot;field1&quot;:&quot;value2&quot;,&quot;field2&quot;:&quot;value3&quot;,&quot;value&quot;:1},        {&quot;field1&quot;:&quot;value2&quot;,&quot;field2&quot;:&quot;value4&quot;,&quot;value&quot;:3}    ]Sorting the result------------------When grouping by one field, it is enough to pass a list of fields by which you need to sort the result::    ?aggregation=count&amp;groupBy=field1&amp;orderBy=field1    [        {&quot;field1&quot;:&quot;value1&quot;,&quot;value&quot;:2},        {&quot;field1&quot;:&quot;value2&quot;,&quot;value&quot;:1},        {&quot;field1&quot;:&quot;value3&quot;,&quot;value&quot;:3}    ]To sort by aggregation result, use &quot;value&quot;::    ?aggregation=count&amp;groupBy=field1&amp;orderBy=-value    [        {&quot;field1&quot;:&quot;value3&quot;,&quot;value&quot;:3},        {&quot;field1&quot;:&quot;value1&quot;,&quot;value&quot;:2},        {&quot;field1&quot;:&quot;value2&quot;,&quot;value&quot;:1}    ]To sort when grouping by two or more fields,you must first add the ColumnIndexFilter filter backend to your ViewSet... code:: python    from drf_aggregation.filters import ColumnIndexFilter    class ModelViewSet(AggregationViewSet):        filter_backends = [ColumnIndexFilter]This filter groups the source queryset by the specified field and preserves the sorting of items.After that, you can use this index to sort the data grouped in the desired way.::    ?aggregation=count&amp;groupBy=field1,field2&amp;columnIndex=field1&amp;orderBy=-field1__index,-value    [        {&quot;field1&quot;:&quot;value2&quot;,&quot;field2&quot;:&quot;value4&quot;,&quot;value&quot;:3},        {&quot;field1&quot;:&quot;value2&quot;,&quot;field2&quot;:&quot;value3&quot;,&quot;value&quot;:1},        {&quot;field1&quot;:&quot;value1&quot;,&quot;field2&quot;:&quot;value3&quot;,&quot;value&quot;:2}    ]Limiting the number of displayed groups---------------------------------------If you have a large number of categories or you need to display only top-H, it is possible to limit the number of returned records::    ?aggregation=count&amp;groupBy=field1&amp;orderBy=-value&amp;limit=2    [        {&quot;field1&quot;:&quot;value1&quot;,&quot;value&quot;:10},        {&quot;field1&quot;:&quot;value2&quot;,&quot;value&quot;:9}    ]It is also possible to display all other groups as one additional category::    ?aggregation=count&amp;groupBy=field1orderBy=-value&amp;&amp;limit=2&amp;showOther=1        [        {&quot;field1&quot;:&quot;value1&quot;,&quot;value&quot;:10},        {&quot;field1&quot;:&quot;value2&quot;,&quot;value&quot;:9},        {&quot;field1&quot;:&quot;Other&quot;,&quot;value&quot;:45}    ]Additional options when there is a limit to the number of displayed groups:- limitBy - field for selecting the values that will remain, if not passed, the first field for grouping is used- showOther - if &quot;1&quot; is passed, all groups not included in the top will be displayed as one additional category- otherGroupName - label for additional category, default &quot;Other&quot;Time series-----------Warning! Doesn't work on SQLite because it doesn't have date / time fields.To display timeseries, you must first add the TruncateDateFilter filter backend to your ViewSet... code:: python    from drf_aggregation.filters import TruncateDateFilter    class ModelViewSet(AggregationViewSet):        filter_backends = [TruncateDateFilter]This filter will allow you to add date fields rounded to the required level,by which you can group and sort the result::    ?truncateDate=created_at=day&amp;groupBy=created_at__trunc__day    [        {&quot;created_at__trunc__day&quot;: date(2020, 10, 4), &quot;value&quot;: 1},        {&quot;created_at__trunc__day&quot;: date(2020, 11, 4), &quot;value&quot;: 2},    ]Available truncations:- year- quarter- month- week- day- hour- minute- secondFor mo details about truncations read `Django Docs`_.. _Django Docs: https://docs.djangoproject.com/en/3.1/ref/models/database-functions/#trunc</longdescription>
</pkgmetadata>