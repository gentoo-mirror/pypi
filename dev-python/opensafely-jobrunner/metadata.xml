<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># OpenSAFELY job runnerA job runner is a service that encapsulates: * the task of checking out an OpenSAFELY study repo; * executing actions defined in its `project.yaml` configuration file when   requested via a jobs queue; and * storing its results in a particular locations.Quickrefs: - [Playbooks](playbooks)End users will find more information in the [OpenSAFELY documentation](https://docs.opensafely.org).# Operating principlesIn production, this software runs as a loop on a secure server within theinfrastructure of the primary data provider.  It polls an [OpenSAFELY jobserver](https://github.com/opensafely-core/job-server), looking for requests to runjobs.Jobs belong to a `workspace`. This describes the git repo containing theOpenSAFELY-compliant project under execution; the git branch, and kind ofdatabase to use. The workspace also acts as a kind of namespace forpartitioning outputs of its jobs.An OpenSAFELY-compliant repo must provide a `project.yaml` file whichdescribes how a requested job should be converted into a command (&amp; arguments)that can be run in a subprocess on the secure server.  It incorporates the ideaof dependencies, so an action that generates a chart might depend on an actionthat extracts data from the database *for* that chart.  See the[Actions reference](https://docs.opensafely.org/actions-intro/) for more information.An action can define `outputs`; these are persisted on disk and made availableto subsequent actions in the workspace, and users who have permission to loginto the server and view the raw files.The runner takes care of executing dependencies in order. By default, it skipsre-running a dependency whose previous run produced output that still exists inthe production environment.  The runner also reports status back to the jobserver, redacting possibly-sensitive information.The runner is bundled as part of the [opensafely-cli][cli] tool so userscan test their actions locally.[cli]: https://github.com/opensafely-core/opensafely-cli## Job structureThe job server serves jobs as JSON in the following format. First, a job mustbelong to a workspace:```json{    &quot;workspace&quot;: {        &quot;name&quot;: &quot;my workspace&quot;,        &quot;repo&quot;: &quot;https://github.com/opensafely/job-integration-tests&quot;,        &quot;branch&quot;: &quot;master&quot;,        &quot;db&quot;: &quot;full&quot;    }}```Possible values for `&quot;db&quot;` are &quot;full&quot;, &quot;slice&quot;, and &quot;dummy&quot;.A workspace is a way of associating jobs related to a given combination ofbranch, repository and database. To enqueue a job, a client POSTs JSON likethis:```json{    &quot;backend&quot;: &quot;tpp&quot;,    &quot;action_id&quot;: &quot;do_thing&quot;,    &quot;workspace_id&quot;: 1}```## Consuming jobsA job runner is service installed on a machine that has access to a givenbackend. It receives jobs from the server and consumes those whose `backend` value matches thevalue of the current `BACKEND` environment variable.It must also define three environment variables which are an RFC1838 connectionURL; these correspond to the `db` requested in the job's workspace definition,and as such are named `FULL_DATABASE_URL`, `SLICE_DATABASE_URL`, and`DUMMY_DATABASE_URL`.When a job is found, the following happens:* The corresponding repo is fetched. Private repos are accessed using  the `PRIVATE_REPO_ACCESS_TOKEN` supplied in the environment.* Its `project.yaml` is parsed:  * Individual `actions` are extracted from this file  * A dependency graph is calculated for the requested action; for example, an    action might depend on three previous actions before it can be run  * Each action in the graph is checked to see if it needs to be run    * Actions that either: (a) already have output generated from a previous      run; (b) are currently running; (c) failed on their last run do not      need to be run  * If a dependency has failed, then the requested action fails  * If the dependency needs to be run, a new job is pushed to the queue, and the    current job is postponed  * If an action has no dependencies needing to be run, then its `docker run` is    executed  * On completion, a status code and message are reported back to the job    server. On success, a list of output file locations are also posted. On    failure, the message has any potentially-sensitive information redacted, and is associated with    a unique string so that a user with requisite permissions can log into the    production environment and examine the docker logs for the full error.## Output locationsEvery action defines a list of `outputs` which are persisted to a permanentstorage location.  The project author must categorise these outputs as either`highly_sensitive` or `moderately_sensitive`.  Any pseudonymised data which maybe highly disclosive (e.g. without low number redaction) should be classed as`highly_sensitive`; data which the author believes could be released followingreview should be classed as `moderately_sensitive`. This design allows tieredlevels of permissions for collaborators to review data outputs. For example, thestudy author would usually have access to `highly_sensitive` material fordebugging; but other collaborators could have access to `moderately_sensitive`data to prepare it for release (for which it is planned to add a`minimally_sensitive` category).Outputs are therefore persisted to filesystem paths according to the followingenvironment variables:```sh# A location where cohort CSVs (one row per patient) should be# stored. This folder must exist.HIGH_PRIVACY_STORAGE_BASE=/home/opensafely/high_security# A location where script outputs (some for publication) should be# storedMEDIUM_PRIVACY_STORAGE_BASE=/tmp/outputs/medium_security```## Project.yamlA valid project file looks like this:```yamlversion: &quot;3.0&quot;expectations:  population_size: 1000actions:  generate_study_population:    run: cohortextractor:latest generate_cohort --study-definition study_definition    outputs:      highly_sensitive:        cohort: output/input.csv  run_model:    run: stata-mp:latest analysis/model.do    needs: [generate_study_population]    outputs:      moderately_sensitive:        model: models/cox-model.txt        figure: figures/survival-plot.png```See the [project pipeline documentation](https://docs.opensafely.org/actions-pipelines/) for a detaileddescription of the project.yaml setup.## Local actions developmentThe [`cohortextractor` command-line tool](https://github.com/opensafely/cohort-extractor/) imports this library, and implements the action-parsing-and-running functionality as a series ofsynchronous docker commands, rather than asynchronously via the job queue.# For developersPlease see [the additional information](DEVELOPERS.md).</longdescription>
</pkgmetadata>