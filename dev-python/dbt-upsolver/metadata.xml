<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># dbt-upsolver# Using Upsolver udapter for dbt- [What is Upsolver](#what_is_upsolver)- [SQLake](#SQLake)- [What is dbt](#what_is_dbt)- [What is dbt Core](#what_is_dbt_core)- [Getting started](#getting_started)    - [Install dbt-upsolver adapter](#install_dbt_upsolver)    - [Register Upsolver account](#register_upsolver)    - [Create API token](#create_api_token)    - [Create new dbt-upsolver project](#create_new_project)- [Supported dbt commands](#supported_dbt)- [Supported Upsolver SQLake functionality](#supported_upsolver)- [Further reading](#further_reading)## What is Upsolver[Upsolver](https://upsolver.com) enables you to use familiar SQL syntaxto quickly build and deploy data pipelines, powered by a stream processing engine designed for cloud data lakes.## SQLake[SQLake](https://docs.upsolver.com/sqlake) is Upsolvers new UI and SQL console allowing to execute commands and monitor pipelines in the UI. It also includes freee trial and access to variety of examples and tutorials.## What is dbt[dbt](https://docs.getdbt.com/) is a transformation workflow that helps you get more work done while producing higher quality results.## What is dbt Coredbt Core is an open-source tool that enables data teams to transform data using analytics engineering best practices. You can install and use dbt Core on the command line.## Getting started  ### Install dbt-upsolver adapter :```sh pip install  dbt-upsolver```### Make sure the adapter is installed:```shdbt --version```#### Expect to see:```Core:  - installed: &lt;version&gt;  - latest:    &lt;version&gt;Plugins:  - upsolver: &lt;version&gt;```### Register Upsolver accountTo register just navigate to [SQL Lake Sign Up form](https://sqlake.upsolver.com/signup). You'll have access to SQL workbench with examples and tutorials after completing the registration.### Create API tokenAfter login navigate to &quot;[Settings](https://sqlake.upsolver.com/Settings)&quot; and then to &quot;[API Tokens](https://sqlake.upsolver.com/Settings/api-tokens)&quot;You will need API token and API Url to access Upsolver programatically.![API Tokens screen](https://github.com/Upsolver/upsolver-sdk-python/raw/build_package/doc/img/APITokens-m.png)Then click &quot;Generate&quot; new token and save it for future use.### Get your user name, database and schemaFor **user name** navigate to **Settings** -&gt; **User details** and copy user nameFor **database** and **schema** navigate to **Worksheets** and click **New**.You will find **database name** and **schema(catalog) name** under **Entities panel**###  Create new dbt-upsolver project```shdbt init &lt;project_name&gt;```Prompt:Which database would you like to use?[1] upsolver```shEnter a number:api_url (your api_url): https://mt-api-prod.upsolver.comtoken (your token): &lt;token&gt;user (dev username): &lt;username&gt;database (default database): &lt;database&gt;schema (default schema): &lt;schema&gt;threads (1 or more) [1]: &lt;number&gt;```####  profiles.yml should look like this:###### profiles.yml location is something like /Users/&lt;user&gt;/.dbt/profiles.yml```ymlproject_name:  target: dev  outputs:    dev:      api_url: https://mt-api-prod.upsolver.com      database: ...      schema: ...      threads: 1      token: ...      type: upsolver      user: ...```### Check connection```shdbt debug```#### - To run all models```shdbt run```#### - To run the specific model```shdbt run --select &lt;model name&gt;```## Supported Upsolver SQLake functionality:| COMMAND | STATE | MATERIALIZED || ------ | ------ | ------ || SQL compute cluster| not supported | - || SQL connections| supported | connection || SQL copy job | supported | incremental || SQL merge job | supported | incremental || SQL insert job | supported | incremental || SQL materialized views | supported | materializedview || Expectations | supported | incremental |## Configs materialization| Config | Required | Materialization | Description | Example || ------ | --------- | --------------- | ---------- | ------- || connection_type | Yes | connection | Connection identifier: S3/GLUE_CATALOG/KINESIS | connection_type='S3' || connection_options | Yes | connection | Dictionary of options supported by selected connection |           connection_options={ 'aws_role': 'aws_role', 'external_id': 'SAMPLES', 'read_only': True } || incremental_strategy | No | incremental | Define one of incremental strategies: merge/copy/insert. Default: copy | incremental_strategy='merge' || source | No | incremental | Define source to copy from: S3/KAFKA/KINESIS | source = 'S3' || target_type | No | incremental | Define target type REDSHIFT/ELASTICSEARCH/S3/SNOWFLAKE/POSTGRES. Default None for Data lake | target_type='Snowflake' || target_prefix | False | incremental | Define PREFIX for ELASTICSEARCH target type | target_prefix = 'orders' || target_location | False | incremental | Define LOCATION for S3 target type | target_location = 's3://your-bucket-name/path/to/folder/' || schema | Yes/No | incremental | Define target schema. Required if target_type, no table created in a metastore connection | schema = 'target_schema' || database | Yes/No | incremental | Define target connection. Required if target_type, no table created in a metastore connection | database = 'target_connection' || alias | Yes/No | incremental | Define target table. Required if target_type, no table created in a metastore connection | alias = 'target_table' || delete_condition | No | incremental | Records that match the ON condition and a delete condition can be deleted | delete_condition='nettotal &gt; 1000' || partition_by | No | incremental | List of dictionaries to define partition_by for target metastore table | partition_by=[{'field':'$field_name'}] || primary_key | No | incremental | List of dictionaries to define partition_by for target metastore table  | primary_key=[{'field':'customer_email', 'type':'string'}] || map_columns_by_name | No | incremental | Maps columns from the SELECT statement to the table. Boolean. Default: False | map_columns_by_name=True || sync | No | incremental/materializedview | Boolean option to define if job is synchronized or non-msynchronized. Default: False | sync=True || options | No | incremental/materializedview | Dictionary of job options | options={ 'START_FROM': 'BEGINNING', 'ADD_MISSING_COLUMNS': True } |## SQL connectionConnections are used to provide Upsolver with the proper credentials to bring your data into SQLake as well as to write out your transformed data to various services. More details on [&quot;Upsolver SQL connections&quot;](https://docs.upsolver.com/sqlake/sql-command-reference/sql-connections)As a dbt model connection is a model with materialized='connection'```sql{{ config(        materialized='connection',        connection_type={ 'S3' | 'GLUE_CATALOG' | 'KINESIS' | 'KAFKA'| 'SNOWFLAKE' },        connection_options={}        )}}```Running this model will compile CREATE CONNECTION(or ALTER CONNECTION if exists) SQL and send it to Upsolver engine. Name of the connection will be name of the model.## SQL copy jobA COPY FROM job allows you to copy your data from a given source into a table created in a metastore connection. This table then serves as your staging table and can be used with SQLake transformation jobs to write to various target locations. More details on [&quot;Upsolver SQL copy-from&quot;](https://docs.upsolver.com/sqlake/sql-command-reference/sql-jobs/create-job/copy-from)As a dbt model copy job is model with materialized='incremental'```sql{{ config(  materialized='incremental',            sync=True|False,            source = 'S3'| 'KAFKA' | ... ,        options={              'option_name': 'option_value'            },        partition_by=[{}]      )}}SELECT * FROM {{ ref(&lt;model&gt;) }}```Running this model will  compile CREATE TABLE SQL for target type Data lake (or ALTER TABLE if exists) and CREATE COPY JOB(or ALTER COPY JOB if exists) SQL and send it to Upsolver engine. Name of the table will be name of the model. Name of the job will be name of the model plus '_job'## SQL insert jobAn INSERT job defines a query that pulls in a set of data based on the given SELECT statement and inserts it into the designated target. This query is then run periodically based on the RUN_INTERVAL defined within the job. More details on [&quot;Upsolver SQL insert&quot;](https://docs.upsolver.com/sqlake/sql-command-reference/sql-jobs/create-job/sql-transformation-jobs/insert).As a dbt model insert job is model with materialized='incremental' and incremental_strategy='insert'```sql{{ config(  materialized='incremental',            sync=True|False,            map_columns_by_name=True|False,            incremental_strategy='insert',            options={              'option_name': 'option_value'            },            primary_key=[{}]          )}}SELECT ...FROM {{ ref(&lt;model&gt;) }}WHERE ...GROUP BY ...HAVING COUNT(DISTINCT orderid::string) ...```Running this model will compile CREATE TABLE SQL for target type Data lake(or ALTER TABLE if exists) and CREATE INSERT JOB(or ALTER INSERT JOB if exists) SQL and send it to Upsolver engine. Name of the table will be name of the model. Name of the job will be name of the model plus '_job'## SQL merge jobA MERGE job defines a query that pulls in a set of data based on the given SELECT statement and inserts into, replaces, or deletes the data from the designated target based on the job definition. This query is then run periodically based on the RUN_INTERVAL defined within the job. More details on [&quot;Upsolver SQL merge&quot;](https://docs.upsolver.com/sqlake/sql-command-reference/sql-jobs/create-job/sql-transformation-jobs/merge).As a dbt model merge job is model with materialized='incremental' and incremental_strategy='merge'```sql{{ config(  materialized='incremental',            sync=True|False,            map_columns_by_name=True|False,            incremental_strategy='merge',            options={              'option_name': 'option_value'            },            primary_key=[{}]          )}}SELECT ...FROM {{ ref(&lt;model&gt;) }}WHERE ...GROUP BY ...HAVING COUNT ...```Running this model will compile CREATE TABLE SQL for target type Data lake(or ALTER TABLE if exists) and CREATE MERGE JOB(or ALTER MERGE JOB if exists) SQL and send it to Upsolver engine. Name of the table will be name of the model. Name of the job will be name of the model plus '_job'## SQL materialized viewsWhen transforming your data, you may find that you need data from multiple source tables in order to achieve your desired result.In such a case, you can create a materialized view from one SQLake table in order to join it with your other table (which in this case is considered the main table). More details on [&quot;Upsolver SQL materialized views&quot;](https://docs.upsolver.com/sqlake/sql-command-reference/sql-jobs/create-job/sql-transformation-jobs/sql-materialized-views).As a dbt model materialized views  is model with materialized='materializedview'.```sql{{ config(  materialized='materializedview',            sync=True|False,            options={'option_name': 'option_value'}        )}}SELECT ...FROM {{ ref(&lt;model&gt;) }}WHERE ...GROUP BY ...```Running this model will compile CREATE MATERIALIZED VIEW SQL(or ALTER MATERIALIZED VIEW if exists) and send it to Upsolver engine. Name of the materializedview  will be name of the model.## Expectations/constraintsData quality conditions can be added to your job to drop a row or trigger a warning when a column violates a predefined condition.```sqlWITH EXPECTATION &lt;expectation_name&gt; EXPECT &lt;sql_predicate&gt;ON VIOLATION WARN```Expectations can be implemented with dbt constraintsSupported constraints: check and not_null```yamlmodels:  - name: &lt;model name&gt;    # required    config:      contract:        enforced: true    # model-level constraints    constraints:      - type: check        columns: ['&lt;column1&gt;', '&lt;column2&gt;']        expression: &quot;column1 &lt;= column2&quot;        name: &lt;constraint_name&gt;      - type: not_null        columns: ['column1', 'column2']        name: &lt;constraint_name&gt;    columns:      - name: &lt;column3&gt;        data_type: string        # column-level constraints        constraints:          - type: not_null          - type: check            expression: &quot;REGEXP_LIKE(&lt;column3&gt;, '^[0-9]{4}[a-z]{5}$')&quot;            name: &lt;constraint_name&gt;```## Projects examples&gt; projects examples link: [github.com/dbt-upsolver/examples/](https://github.com/Upsolver/dbt-upsolver/tree/main/examples)## Connection options| Option | Storage   | Editable | Optional | Config Syntax || -------| --------- | -------- | -------- | ------------- || aws_role | s3 | True | True | 'aws_role': `'&lt;aws_role&gt;'` || external_id | s3 | True | True | 'external_id': `'&lt;external_id&gt;'` || aws_access_key_id | s3 | True | True | 'aws_access_key_id': `'&lt;aws_access_key_id&gt;'` || aws_secret_access_key | s3 | True | True | 'aws_secret_access_key_id': `'&lt;aws_secret_access_key_id&gt;'` || path_display_filter | s3 | True | True | 'path_display_filter': `'&lt;path_display_filter&gt;'` || path_display_filters | s3 | True | True | 'path_display_filters': (`'&lt;filter&gt;'`, ...) || read_only | s3 | True | True | 'read_only': True/False || encryption_kms_key | s3 | True | True | 'encryption_kms_key': `'&lt;encryption_kms_key&gt;'` || encryption_customer_managed_key | s3 | True | True | 'encryption_customer_kms_key': `'&lt;encryption_customer_kms_key&gt;'` || comment | s3 | True | True | 'comment': `'&lt;comment&gt;'` || host | kafka | False | False | 'host': `'&lt;host&gt;'` || hosts | kafka | False | False | 'hosts': (`'&lt;host&gt;'`, ...) || consumer_properties | kafka | True | True | 'consumer_properties': `'&lt;consumer_properties&gt;'` || version | kafka | False | True | 'version': `'&lt;value&gt;'` || require_static_ip | kafka | True | True | 'require_static_ip': True/False || ssl | kafka | True | True | 'ssl': True/False || topic_display_filter | kafka | True | True | 'topic_display_filter': `'&lt;topic_display_filter&gt;'` || topic_display_filters | kafka | True | True | 'topic_display_filter': (`'&lt;filter&gt;'`, ...) || comment | kafka | True | True | 'comment': `'&lt;comment&gt;'` || aws_role | glue_catalog | True | True | 'aws_role': `'&lt;aws_role&gt;'` || external_id | glue_catalog | True | True | 'external_id': `'&lt;external_id&gt;'` || aws_access_key_id | glue_catalog | True | True | 'aws_access_key_id': `'&lt;aws_access_key_id&gt;'` || aws_secret_access_key | glue_catalog | True | True | 'aws_secret_access_key': `'&lt;aws_secret_access_key&gt;'` || default_storage_connection | glue_catalog | False | False | 'default_storage_connection': `'&lt;default_storage_connection&gt;'` || default_storage_location | glue_catalog | False | False | 'default_storage_location': `'&lt;default_storage_location&gt;'` || region | glue_catalog | False | True | 'region': `'&lt;region&gt;'` || database_display_filter | glue_catalog | True | True | 'database_display_filter': `'&lt;database_display_filter&gt;'` || database_display_filters | glue_catalog | True | True | 'database_display_filters': (`'&lt;filter&gt;'`, ...) || comment | glue_catalog | True | True | 'comment': `'&lt;comment&gt;'` || aws_role | kinesis | True | True | 'aws_role': `'&lt;aws_role&gt;'` || external_id | kinesis | True | True | 'external_id': `'&lt;external_id&gt;'` || aws_access_key_id | kinesis | True | True | 'aws_access_key_id': `'&lt;aws_access_key_id&gt;'` || aws_secret_access_key | kinesis | True | True | 'aws_secret_access_key': `'&lt;aws_secret_access_key&gt;'` || region | kinesis | False | False | 'region': `'&lt;region&gt;'` || read_only | kinesis | False | True | 'read_only': True/False || max_writers | kinesis | True | True | 'max_writers': `&lt;integer&gt;` || stream_display_filter | kinesis | True | True | 'stream_display_filter': `'&lt;stream_display_filter&gt;'` || stream_display_filters | kinesis | True | True | 'stream_display_filters': (`'&lt;filter&gt;'`, ...) || comment | kinesis | True | True | 'comment': `'&lt;comment&gt;'` || connection_string | snowflake | True | False | 'connection_string': `'&lt;connection_string&gt;'` || user_name | snowflake | True | False | 'user_name': `'&lt;user_name&gt;'` || password | snowflake | True | False | 'password': `'&lt;password&gt;'` || max_concurrent_connections | snowflake | True | True | 'max_concurrent_connections': `&lt;integer&gt;` || comment | snowflake | True | True | 'comment': `'&lt;comment&gt;'` || connection_string | redshift | True | False | 'connection_string': `'&lt;connection_string&gt;'` || user_name | redshift | True | False | 'user_name': `'&lt;user_name&gt;'` || password | redshift | True | False | 'password': `'&lt;password&gt;'` || max_concurrent_connections | redshift | True | True | 'max_concurrent_connections': `&lt;integer&gt;` || comment | redshift | True | True | 'comment': `'&lt;comment&gt;'` || connection_string | mysql | True | False | 'connection_string': `'&lt;connection_string&gt;'` || user_name | mysql | True | False | 'user_name': `'&lt;user_name&gt;'` || password | mysql | True | False | 'password': `'&lt;password&gt;'` || comment | mysql | True | True | 'comment': `'&lt;comment&gt;'` || connection_string | postgres | True | False | 'connection_string': `'&lt;connection_string&gt;'` || user_name | postgres | True | False | 'user_name': `'&lt;user_name&gt;'` || password | postgres | True | False | 'password': `'&lt;password&gt;'` || comment | postgres | True | True | 'comment': `'&lt;comment&gt;'` || connection_string | elasticsearch | True | False | 'connection_string': `'&lt;connection_string&gt;'` || user_name | elasticsearch | True | False | 'user_name': `'&lt;user_name&gt;'` || password | elasticsearch | True | False | 'password': `'&lt;password&gt;'` || comment | elasticsearch | True | True | 'comment': `'&lt;comment&gt;'` || connection_string | mongodb | True | False | 'connection_string': `'&lt;connection_string&gt;'` || user_name | mongodb | True | False | 'user_name': `'&lt;user_name&gt;'` || password | mongodb | True | False | 'password': `'&lt;password&gt;'` || timeout | mongodb | True | True | 'timeout': &quot;INTERVAL 'N' SECONDS&quot; || comment | mongodb | True | True | 'comment': `'&lt;comment&gt;'` || connection_string | mssql | True | False | 'connection_string': `'&lt;connection_string&gt;'` || user_name | mssql | True | False | 'user_name': `'&lt;user_name&gt;'` || password | mssql | True | False | 'password': `'&lt;password&gt;'` || comment | mssql | True | True | 'comment': `'&lt;comment&gt;'` |## Target options| Option | Storage   | Editable | Optional | Config Syntax || -------| --------- | -------- | -------- | ------------- || globally_unique_keys | datalake | False | True | 'globally_unique_keys': True/False || storage_connection | datalake | False | True | 'storage_connection': `'&lt;storage_connection&gt;'` || storage_location | datalake | False | True | 'storage_location': `'&lt;storage_location&gt;'` || compute_cluster | datalake | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || compression | datalake | True | True | 'compression': 'SNAPPY/GZIP' || compaction_processes | datalake | True | True | 'compaction_processes': `&lt;integer&gt;` || disable_compaction | datalake | True | True | 'disable_compaction': True/False || retention_date_partition | datalake | False | True | 'retention_date_partition': `'&lt;column&gt;'` || table_data_retention | datalake | True | True | 'table_data_retention': `'&lt;N DAYS&gt;'` || column_data_retention | datalake | True | True | 'column_data_retention': ({'COLUMN' : `'&lt;column&gt;'`,'DURATION': `'&lt;N DAYS&gt;'`}) || comment | datalake | True | True | 'comment': `'&lt;comment&gt;'` || storage_connection | materialized_view | False | True | 'storage_connection': `'&lt;storage_connection&gt;'` || storage_location | materialized_view | False | True | 'storage_location': `'&lt;storage_location&gt;'` || max_time_travel_duration | materialized_view | True | True | 'max_time_travel_duration': `'&lt;N DAYS&gt;'` || compute_cluster | materialized_view | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || column_transformations | snowflake | False | True | 'column_transformations': {`'&lt;column&gt;'` : `'&lt;expression&gt;'` , ...} || deduplicate_with | snowflake | False | True | 'deduplicate_with': {'COLUMNS' : ['col1', 'col2'],'WINDOW': 'N HOURS'} || exclude_columns | snowflake | False | True | 'exclude_columns': (`'&lt;exclude_column&gt;'`, ...) || create_table_if_missing | snowflake | False | True | 'create_table_if_missing': True/False} || run_interval | snowflake | False | True | 'run_interval': `'&lt;N MINUTES/HOURS/DAYS&gt;'` |## Transformation options| Option | Storage   | Editable | Optional | Config Syntax || -------| --------- | -------- | -------- | ------------- || run_interval | s3 | False | True | 'run_interval': `'&lt;N MINUTES/HOURS/DAYS&gt;'` || start_from | s3 | False | True | 'start_from': `'&lt;timestamp&gt;/NOW/BEGINNING'` || end_at | s3 | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | s3 | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || comment | s3 | True | True | 'comment': `'&lt;comment&gt;'` || skip_validations | s3 | False | True | 'skip_validations': ('ALLOW_CARTESIAN_PRODUCT', ...) || skip_all_validations | s3 | False | True | 'skip_all_validations': True/False || aggregation_parallelism | s3 | True | True | 'aggregation_parallelism': `&lt;integer&gt;` || run_parallelism | s3 | True | True | 'run_parallelism': `&lt;integer&gt;` || file_format | s3 | False | False | 'file_format': '(type = `&lt;file_format&gt;`)' || compression | s3 | False | True | 'compression': 'SNAPPY/GZIP ...' || date_pattern | s3 | False | True | 'date_pattern': `'&lt;date_pattern&gt;'` || output_offset | s3 | False | True | 'output_offset': `'&lt;N MINUTES/HOURS/DAYS&gt;'` || run_interval | elasticsearch | False | True | 'run_interval': `'&lt;N MINUTES/HOURS/DAYS&gt;'` || routing_field_name | elasticsearch | True | True | 'routing_field_name': `'&lt;routing_field_name&gt;'` || start_from | elasticsearch | False | True | 'start_from': `'&lt;timestamp&gt;/NOW/BEGINNING'` || end_at | elasticsearch | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | elasticsearch | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || skip_validations | elasticsearch | False | True | 'skip_validations': ('ALLOW_CARTESIAN_PRODUCT', ...) || skip_all_validations | elasticsearch | False | True | 'skip_all_validations': True/False || aggregation_parallelism | elasticsearch | True | True | 'aggregation_parallelism': `&lt;integer&gt;` || run_parallelism | elasticsearch | True | True | 'run_parallelism': `&lt;integer&gt;` || bulk_max_size_bytes | elasticsearch | True | True | 'bulk_max_size_bytes': `&lt;integer&gt;` || index_partition_size | elasticsearch | True | True | 'index_partition_size': 'HOURLY/DAILY ...' || comment | elasticsearch | True | True | 'comment': `'&lt;comment&gt;'` || custom_insert_expressions | snowflake | True | True | 'custom_insert_expressions': {'INSERT_TIME' : 'CURRENT_TIMESTAMP()','MY_VALUE': `'&lt;value&gt;'`} || custom_update_expressions | snowflake | True | True | 'custom_update_expressions': {'UPDATE_TIME' : 'CURRENT_TIMESTAMP()','MY_VALUE': `'&lt;value&gt;'`} || keep_existing_values_when_null | snowflake | True | True | 'keep_existing_values_when_null': True/False || add_missing_columns | snowflake | False | True | 'add_missing_columns': True/False || run_interval | snowflake | False | True | 'run_interval': `'&lt;N MINUTES/HOURS/DAYS&gt;'` || commit_interval | snowflake | True | True | 'commit_interval': `'&lt;N MINUTE[S]/HOUR[S]/DAY[S]&gt;'` || start_from | snowflake | False | True | 'start_from': `'&lt;timestamp&gt;/NOW/BEGINNING'` || end_at | snowflake | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | snowflake | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || skip_validations | snowflake | False | True | 'skip_validations': ('ALLOW_CARTESIAN_PRODUCT', ...) || skip_all_validations | snowflake | False | True | 'skip_all_validations': True/False || aggregation_parallelism | snowflake | True | True | 'aggregation_parallelism': `&lt;integer&gt;` || run_parallelism | snowflake | True | True | 'run_parallelism': `&lt;integer&gt;` || comment | snowflake | True | True | 'comment': `'&lt;comment&gt;'` || add_missing_columns | datalake | False | True | 'add_missing_columns': True/False || run_interval | datalake | False | True | 'run_interval': `'&lt;N MINUTES/HOURS/DAYS&gt;'` || start_from | datalake | False | True | 'start_from': `'&lt;timestamp&gt;/NOW/BEGINNING'` || end_at | datalake | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | datalake | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || skip_validations | datalake | False | True | 'skip_validations': ('ALLOW_CARTESIAN_PRODUCT', ...) || skip_all_validations | datalake | False | True | 'skip_all_validations': True/False || aggregation_parallelism | datalake | True | True | 'aggregation_parallelism': `&lt;integer&gt;` || run_parallelism | datalake | True | True | 'run_parallelism': `&lt;integer&gt;` || comment | datalake | True | True | 'comment': `'&lt;comment&gt;'` || run_interval | redshift | False | True | 'run_interval': `'&lt;N MINUTES/HOURS/DAYS&gt;'` || start_from | redshift | False | True | 'start_from': `'&lt;timestamp&gt;/NOW/BEGINNING'` || end_at | redshift | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | redshift | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || skip_validations | redshift | False | True | 'skip_validations': ('ALLOW_CARTESIAN_PRODUCT', ...) || skip_all_validations | redshift | False | True | 'skip_all_validations': True/False || aggregation_parallelism | redshift | True | True | 'aggregation_parallelism': `&lt;integer&gt;` || run_parallelism | redshift | True | True | 'run_parallelism': `&lt;integer&gt;` || skip_failed_files | redshift | False | True | 'skip_failed_files': True/False || fail_on_write_error | redshift | False | True | 'fail_on_write_error': True/False || comment | redshift | True | True | 'comment': `'&lt;comment&gt;'` || run_interval | postgres | False | True | 'run_interval': `'&lt;N MINUTES/HOURS/DAYS&gt;'` || start_from | postgres | False | True | 'start_from': `'&lt;timestamp&gt;/NOW/BEGINNING'` || end_at | postgres | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | postgres | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || skip_validations | postgres | False | True | 'skip_validations': ('ALLOW_CARTESIAN_PRODUCT', ...) || skip_all_validations | postgres | False | True | 'skip_all_validations': True/False || aggregation_parallelism | postgres | True | True | 'aggregation_parallelism': `&lt;integer&gt;` || run_parallelism | postgres | True | True | 'run_parallelism': `&lt;integer&gt;` || comment | postgres | True | True | 'comment': `'&lt;comment&gt;'` |## Copy options| Option | Storage    | Category | Editable | Optional | Config Syntax || -------| ---------- | -------- | -------- | -------- | ------------- || topic | kafka | source_options | False | False | 'topic': `'&lt;topic&gt;'` || exclude_columns | kafka | job_options | False | True | 'exclude_columns': (`'&lt;exclude_column&gt;'`, ...) || deduplicate_with | kafka | job_options | False | True | 'deduplicate_with': {'COLUMNS' : ['col1', 'col2'],'WINDOW': 'N HOURS'} || consumer_properties | kafka | job_options | True | True | 'consumer_properties': `'&lt;consumer_properties&gt;'` || reader_shards | kafka | job_options | True | True | 'reader_shards': `&lt;integer&gt;` || store_raw_data | kafka | job_options | False | True | 'store_raw_data': True/False || start_from | kafka | job_options | False | True | 'start_from': 'BEGINNING/NOW' || end_at | kafka | job_options | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | kafka | job_options | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || run_parallelism | kafka | job_options | True | True | 'run_parallelism': `&lt;integer&gt;` || content_type | kafka | job_options | True | True | 'content_type': 'AUTO/CSV/...' || compression | kafka | job_options | False | True | 'compression': 'AUTO/GZIP/...' || column_transformations | kafka | job_options | False | True | 'column_transformations': {`'&lt;column&gt;'` : `'&lt;expression&gt;'` , ...} || commit_interval | kafka | job_options | True | True | 'commit_interval': `'&lt;N MINUTE[S]/HOUR[S]/DAY[S]&gt;'` || skip_validations | kafka | job_options | False | True | 'skip_validations': ('MISSING_TOPIC') || skip_all_validations | kafka | job_options | False | True | 'skip_all_validations': True/False || comment | kafka | job_options | True | True | 'comment': `'&lt;comment&gt;'` || table_include_list | mysql | source_options | True | True | 'table_include_list': (`'&lt;regexFilter&gt;'`, ...) || column_exclude_list | mysql | source_options | True | True | 'column_exclude_list': (`'&lt;regexFilter&gt;'`, ...) || exclude_columns | mysql | job_options | False | True | 'exclude_columns': (`'&lt;exclude_column&gt;'`, ...) || column_transformations | mysql | job_options | False | True | 'column_transformations': {`'&lt;column&gt;'` : `'&lt;expression&gt;'` , ...} || skip_snapshots | mysql | job_options | True | True | 'skip_snapshots': True/False || end_at | mysql | job_options | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | mysql | job_options | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || snapshot_parallelism | mysql | job_options | True | True | 'snapshot_parallelism': `&lt;integer&gt;` || ddl_filters | mysql | job_options | False | True | 'ddl_filters': (`'&lt;filter&gt;'`, ...) || comment | mysql | job_options | True | True | 'comment': `'&lt;comment&gt;'` || table_include_list | postgres | source_options | False | False | 'table_include_list': (`'&lt;regexFilter&gt;'`, ...) || column_exclude_list | postgres | source_options | False | True | 'column_exclude_list': (`'&lt;regexFilter&gt;'`, ...) || heartbeat_table | postgres | job_options | False | True | 'heartbeat_table': `'&lt;heartbeat_table&gt;'` || skip_snapshots | postgres | job_options | False | True | 'skip_snapshots': True/False || publication_name | postgres | job_options | False | False | 'publication_name': `'&lt;publication_name&gt;'` || end_at | postgres | job_options | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | postgres | job_options | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || comment | postgres | job_options | True | True | 'comment': `'&lt;comment&gt;'` || parse_json_columns | postgres | job_options | False | False | 'parse_json_columns': True/False || column_transformations | postgres | job_options | False | True | 'column_transformations': {`'&lt;column&gt;'` : `'&lt;expression&gt;'` , ...} || snapshot_parallelism | postgres | job_options | True | True | 'snapshot_parallelism': `&lt;integer&gt;` || exclude_columns | postgres | job_options | False | True | 'exclude_columns': (`'&lt;exclude_column&gt;'`, ...) || location | s3 | source_options | False | False | 'location': `'&lt;location&gt;'` || date_pattern | s3 | job_options | False | True | 'date_pattern': `'&lt;date_pattern&gt;'` || file_pattern | s3 | job_options | False | True | 'file_pattern': `'&lt;file_pattern&gt;'` || initial_load_pattern | s3 | job_options | False | True | 'initial_load_pattern': `'&lt;initial_load_pattern&gt;'` || initial_load_prefix | s3 | job_options | False | True | 'initial_load_prefix': `'&lt;initial_load_prefix&gt;'` || delete_files_after_load | s3 | job_options | False | True | 'delete_files_after_load': True/False || deduplicate_with | s3 | job_options | False | True | 'deduplicate_with': {'COLUMNS' : ['col1', 'col2'],'WINDOW': 'N HOURS'} || end_at | s3 | job_options | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || start_from | s3 | job_options | False | True | 'start_from': `'&lt;timestamp&gt;/NOW/BEGINNING'` || compute_cluster | s3 | job_options | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || run_parallelism | s3 | job_options | True | True | 'run_parallelism': `&lt;integer&gt;` || content_type | s3 | job_options | True | True | 'content_type': 'AUTO/CSV...' || compression | s3 | job_options | False | True | 'compression': 'AUTO/GZIP...' || comment | s3 | job_options | True | True | 'comment': `'&lt;comment&gt;'` || column_transformations | s3 | job_options | False | True | 'column_transformations': {`'&lt;column&gt;'` : `'&lt;expression&gt;'` , ...} || commit_interval | s3 | job_options | True | True | 'commit_interval': `'&lt;N MINUTE[S]/HOUR[S]/DAY[S]&gt;'` || skip_validations | s3 | job_options | False | True | 'skip_validations': ('EMPTY_PATH') || skip_all_validations | s3 | job_options | False | True | 'skip_all_validations': True/False || exclude_columns | s3 | job_options | False | True | 'exclude_columns': (`'&lt;exclude_column&gt;'`, ...) || stream | kinesis | source_options | False | False | 'stream': `'&lt;stream&gt;'` || reader_shards | kinesis | job_options | True | True | 'reader_shards': `&lt;integer&gt;` || store_raw_data | kinesis | job_options | False | True | 'store_raw_data': True/False || start_from | kinesis | job_options | False | True | 'start_from': `'&lt;timestamp&gt;/NOW/BEGINNING'` || end_at | kinesis | job_options | False | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | kinesis | job_options | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || run_parallelism | kinesis | job_options | False | True | 'run_parallelism': `&lt;integer&gt;` || content_type | kinesis | job_options | True | True | 'content_type': 'AUTO/CSV...' || compression | kinesis | job_options | False | True | 'compression': 'AUTO/GZIP...' || comment | kinesis | job_options | True | True | 'comment': `'&lt;comment&gt;'` || column_transformations | kinesis | job_options | True | True | 'column_transformations': {`'&lt;column&gt;'` : `'&lt;expression&gt;'` , ...} || deduplicate_with | kinesis | job_options | False | True | 'deduplicate_with': {'COLUMNS' : ['col1', 'col2'],'WINDOW': 'N HOURS'} || commit_interval | kinesis | job_options | True | True | 'commit_interval': `'&lt;N MINUTE[S]/HOUR[S]/DAY[S]&gt;'` || skip_validations | kinesis | job_options | False | True | 'skip_validations': ('MISSING_STREAM') || skip_all_validations | kinesis | job_options | False | True | 'skip_all_validations': True/False || exclude_columns | kinesis | job_options | False | True | 'exclude_columns': (`'&lt;exclude_column&gt;'`, ...) || table_include_list | mssql | source_options | True | True | 'table_include_list': (`'&lt;regexFilter&gt;'`, ...) || column_exclude_list | mssql | source_options | True | True | 'column_exclude_list': (`'&lt;regexFilter&gt;'`, ...) || exclude_columns | mssql | job_options | False | True | 'exclude_columns': (`'&lt;exclude_column&gt;'`, ...) || column_transformations | mssql | job_options | False | True | 'column_transformations': {`'&lt;column&gt;'` : `'&lt;expression&gt;'` , ...} || skip_snapshots | mssql | job_options | True | True | 'skip_snapshots': True/False || end_at | mssql | job_options | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | mssql | job_options | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || snapshot_parallelism | mssql | job_options | True | True | 'snapshot_parallelism': `&lt;integer&gt;` || parse_json_columns | mssql | job_options | False | False | 'parse_json_columns': True/False || comment | mssql | job_options | True | True | 'comment': `'&lt;comment&gt;'` || collection_include_list | mongodb | source_options | True | True | 'collection_include_list': (`'&lt;regexFilter&gt;'`, ...) || exclude_columns | mongodb | job_options | False | True | 'exclude_columns': (`'&lt;exclude_column&gt;'`, ...) || column_transformations | mongodb | job_options | False | True | 'column_transformations': {`'&lt;column&gt;'` : `'&lt;expression&gt;'` , ...} || skip_snapshots | mongodb | job_options | True | True | 'skip_snapshots': True/False || end_at | mongodb | job_options | True | True | 'end_at': `'&lt;timestamp&gt;/NOW'` || compute_cluster | mongodb | job_options | True | True | 'compute_cluster': `'&lt;compute_cluster&gt;'` || snapshot_parallelism | mongodb | job_options | True | True | 'snapshot_parallelism': `&lt;integer&gt;` || comment | mongodb | job_options | True | True | 'comment': `'&lt;comment&gt;'` |## Further reading[Projects examples](https://github.com/Upsolver/dbt-upsolver/tree/main/examples)[Upsolver sqlake documentation](https://docs.upsolver.com/sqlake/)[DBT documentation](https://docs.getdbt.com/docs/introduction)[Upsolver Comunity Slack](https://join.slack.com/t/upsolvercommunity/shared_invite/zt-1zo1dbyys-hj28WfaZvMh4Z4Id3OkkhA)</longdescription>
</pkgmetadata>