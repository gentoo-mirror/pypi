<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># opentelemetry-instrumenation-digma[![Tests](https://github.com/digma-ai/opentelemetry-instrumentation-digma/actions/workflows/unit-tests.yml/badge.svg)](https://github.com/digma-ai/opentelemetry-instrumentation-digma/actions/workflows/unit-tests.yml) [![PyPI version](https://badge.fury.io/py/opentelemetry-instrumentation-digma.svg)](https://badge.fury.io/py/opentelemetry-instrumentation-digma)This package provides instrumentation helpers and tools to make it easy to set up Digma to work along with your OpenTelemetry instrumentation.In order to be able to effectively glean code-object based insights for continuous feedback and map them back in the IDE, Digma inserts additional attribute into the OTEL resource attributes. [Installing the package](#installing) [Instrumenting existing projects](#instrumenting_existing) [The Digma instrumentation helper configuration options](#the-digma-instrumentation-helper-configuration-options)[The Tracing decorator](#the-tracing-decorator)&lt;a name=&quot;installing&quot;/&gt;## Installing the package```bashpip install opentelemetry-instrumentation-digma```## Instrumenting an existing project### If you are introducing both OTEL and DigmaTo make it convenient to get started quickly with some default for both OpenTelemetry and Digma, a quick bootsrap function is provided. This is not intended for usage if you already have OpenTelmetry set up in your project, nor be used as a production configuration.```pythonfrom opentelemetry.instrumentation.digma import digma_opentelemetry_boostrapdigma_opentelemetry_boostrap(service_name='server-name', digma_backend=&quot;http://localhost:5050&quot;,                             configuration=DigmaConfiguration().trace_this_package())```### If you are already using OpenTelemtry tracing in your projectIf you have an existing OpenTelemtry instrumentaiton set up, simply use the DigmaConfiguration object to create a `Resource `object and merge it with your resource to import all of the needed attributes. ```pythonresource = Resource.create(attributes={SERVICE_NAME: service_name})resource = resource.merge(DigmaConfiguration().trace_this_package())```You can use a standard OTLP exporter to the Digma collector for local deployments:```pythonexporter = OTLPSpanExporter(endpoint=&quot;localhost:5050&quot;, insecure=True)provider.add_span_processor(BatchSpanProcessor(exporter))```Alternatively, if you're already using a collector component you can simply modify its configuration file:```yamlexporters:...otlp/digma:    endpoint: &quot;localhost:5050&quot;    tls:      insecure: trueservice:  pipelines:    traces:      exporters: [otlp/digma, ...]```## Building the package from source```bashpython -m build```&lt;a name=&quot;the-digma-instrumentation-helper-configuration-options&quot;/&gt;## The Digma instrumentation helper configuration options| Setting          | Description           | Default  || ---------------- |-------------  | -----|| `set_environment`|  Set the identifier of the deployment environment  for the current trace process. e.g. 'staging', 'ci'| Will try to read from env variable, otherwies 'UNSET' || `set_commit_id`      | Allows setting the commit identifier for the currently executing code.       |   Will try to read from env variable otherwise empty || `use_env_variable_for_commit_id` | Set a custom environment variable to read the commit identifier from in runtime.     |  'GIT_COMMIT_ID' | | `use_env_variable_for_deployment_environment` | Set a custom environment variable to read the deployment environment identifier from in runtime. | 'DEPLOYMENT_ENV' || `trace_this_package` | Specify the current package root folder. Used to aligned tracing with code | None || `trace_package` | Specify additional satellite or infra packages to track | None &lt;a name=&quot;the-tracing-decorator&quot;/&gt;## The tracing decoratorThe digma package include an optional tracing decorator intended to make span declarations easier and less repetitive. You can use the decorator at the function or class level to specify a span should be automatically created.The decorator will automatically add additional context for each span based on the wrapped method.Example usage:```python @instrumentdef standalone_function(self):    # Will create a span named 'standalone_function' (default naming)    pass    @instrument(attributes={&quot;one&quot;: &quot;two&quot;})class SomeClass:    @instrument(span_name=&quot;function_decorator&quot;, attributes={&quot;two&quot;: &quot;three&quot;})    def function_one(self):        # Will create a span named 'function_decorator' with above attributes        pass    def function_two(self):        # Will create a span named 'function_two', since SomeClass has decorator        pass       def _function_three(self):        # Will not create a span for this function as it is private        pass    @instrument(ignore=True)    def do_not_instrument(self):        # Will not create a span for this function as it is set to ignore        pass```</longdescription>
</pkgmetadata>