<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># larpix-controlControl the LArPix chip[![Documentation Status](https://readthedocs.org/projects/larpix-control/badge/?version=stable)](https://larpix-control.readthedocs.io/en/stable/?badge=stable)[![Build Status](https://travis-ci.com/larpix/larpix-control.svg?branch=master)](https://travis-ci.com/larpix/larpix-control)## Setup and installationThis code is intended to work on both Python 2.7+ and Python 3.6+.Install larpix-control from pip with```pip install larpix-control```To return your namespace to the pre-larpix state, justrun `pip uninstall larpix-control`. If you'd prefer to download the codeyourself, you can. Just run `pip install .` from the root directory ofthe repository.### TestsYou can run tests to convince yourself that the software works asexpected. After `pip install`ing this package, you can run the testsfrom the repository root directory with the simple command `pytest`.You can read the tests to see examples of how to call all of the commonfunctions.## File structureThe larpix package contains:```larpix├── controller.py├── timestamp.py├── key.py├── chip.py├── quickstart.py├── bitarrayhelper.py├── packet│   ├── packet_v2.py│   ├── packet_v1.py│   ├── packet_collection.py│   ├── sync_packet.py│   ├── trigger_packet.py│   ├── message_packet.py│   ├── timestamp_packet.py│   └── __init__.py├── io│   ├── pacman_io.py│   ├── serialport.py│   ├── multizmq_io.py│   ├── fakeio.py│   ├── zmq_io.py│   ├── io.py│   └── __init__.py├── __init__.py├── configuration│   ├── configuration_v2.py│   ├── configuration_v1.py│   ├── configuration.py│   ├── configuration_lightpix_v1.py│   └── __init__.py├── format│   ├── hdf5format.py│   ├── pacman_msg_format.py│   ├── message_format.py│   └── __init__.py├── logger│   ├── h5_logger.py│   ├── logger.py│   ├── stdout_logger.py│   └── __init__.py├── configs│   ├── __init__.py│   ├── controller│   │   ├── __init__.py│   │   ├── network-3x3-tile-channel0.json│   │   ├── network-3x3-tile-channel2.json│   │   ├── network-3x3-tile-channel1.json│   │   ├── lightpix_v1_example.json│   │   ├── v2_example.json│   │   ├── bare-die-v2-v1.0.0.json│   │   ├── pcb-10_chip_info.json│   │   ├── pcb-1_chip_info.json│   │   ├── pcb-2_chip_info.json│   │   ├── pcb-3_chip_info.json│   │   ├── pcb-4_chip_info.json│   │   ├── pcb-5_chip_info.json│   │   └── pcb-6_chip_info.json│   ├── io│   │   ├── __init__.py│   │   ├── default.json│   │   ├── daq-srv1.json│   │   ├── daq-srv2.json│   │   ├── daq-srv3.json│   │   ├── daq-srv4.json│   │   ├── daq-srv5.json│   │   ├── daq-srv6.json│   │   ├── daq-srv7.json│   │   ├── pacman.json│   │   ├── pacman_loopback.json│   │   └── loopback.json│   └── chip│       ├── __init__.py│       ├── default_v2.json│       ├── csa_bypass.json│       ├── quiet.json│       ├── default.json│       ├── physics.json│       └── default_lightpix_v1.json├── serial_helpers│   ├── analyzers.py│   ├── dataformatter.py│   ├── dataloader.py│   ├── datalogger.py│   └── __init__.py└── larpix.pyscripts/├── gen_controller_config.py└── gen_hydra_simple.py```## Minimal working exampleSo you're not a tutorials kind of person. Here's a minimal workingexample for you to play around with:```python&gt;&gt;&gt; from larpix import Controller, Packet_v2&gt;&gt;&gt; from larpix.io import FakeIO&gt;&gt;&gt; from larpix.logger import StdoutLogger&gt;&gt;&gt; controller = Controller()&gt;&gt;&gt; controller.io = FakeIO()&gt;&gt;&gt; controller.logger = StdoutLogger(buffer_length=0)&gt;&gt;&gt; controller.logger.enable()&gt;&gt;&gt; chip1 = controller.add_chip('1-1-2', version=2)  # (access key)&gt;&gt;&gt; chip1.config.threshold_global = 25&gt;&gt;&gt; controller.write_configuration('1-1-2', chip1.config.register_map['threshold_global']) # chip key, register 64[ Key: 1-1-2 | Chip: 2 | Upstream | Write | Register: 64 | Value: 25 | Parity: 1 (valid: True) ]Record: [ Key: 1-1-2 | Chip: 2 | Upstream | Write | Register: 64 | Value: 25 | Parity: 1 (valid: True) ]&gt;&gt;&gt; packet = Packet_v2(b'\x02\x91\x15\xcd[\x07\x85\x00')&gt;&gt;&gt; packet_bytes = packet.bytes()&gt;&gt;&gt; pretend_input = ([packet], packet_bytes)&gt;&gt;&gt; controller.io.queue.append(pretend_input)&gt;&gt;&gt; controller.run(0.05, 'test run')Record: [ Key: None | Chip: 2 | Downstream | Data | Channel: 5 | Timestamp: 123456789 | First packet: 0 | Dataword: 145 | Trigger: normal | Local FIFO ok | Shared FIFO ok | Parity: 0 (valid: True) ]&gt;&gt;&gt; print(controller.reads[0])[ Key: None | Chip: 2 | Downstream | Data | Channel: 5 | Timstamp: 123456789 | Dataword: 145 | Trigger: normal | Local FIFO ok | Shared FIFO ok | Parity: 0 (valid: True) ]```## TutorialThis tutorial runs through how to use all of the main functionality oflarpix-control.To access the package contents, use one of the two following `import`statements:```pythonimport larpix  # use the larpix namespace# or ...from larpix import *  # import all core larpix classes into the current namespace```The rest of the tutorial will assume you've imported all of the core larpixclasses via a ``from larpix import *`` command.### Create a LArPix ControllerThe LArPix Controller translates high-level ideas like &quot;readconfiguration register 10&quot; into communications to and from LArPix ASICs,and interprets the received data into a usable format.Controller objects communicate with LArPix ASICs via an IO interface.Currently available IO interfaces are ``SerialPort``, ``ZMQ_IO`` and``FakeIO``. We'll work with ``FakeIO`` in this tutorial, but all thecode will still work with properly initialized versions of the other IOinterfaces.Set things up with```pythonfrom larpix.io import FakeIOfrom larpix.logger import StdoutLoggercontroller = Controller()controller.io = FakeIO()controller.logger = StdoutLogger(buffer_length=0)controller.logger.enable()```The ``FakeIO`` object imitates a real IO interface for testing purposes.It directs its output to stdout (i.e. it prints the output), and ittakes its input from a manually-updated queue. At the end of eachrelevant section of the tutorial will be code for adding the expectedoutput to the queue. You'll have to refill the queue each time you runthe code.Similarly, the ``StdoutLogger`` mimics the real logger interface for testing. Itprints nicely formatted records of read / write commands to stdout every``buffer_length`` packets. The logger interface requires enabling thelogger before messages will be stored. Before ending the python session, everylogger should be disabled to flush any remaining packets stored in the buffer.### Set up LArPix ChipsChip objects represent actual LArPix ASICs. For each ASIC you want tocommunicate with, create a LArPix Chip object and add it to theController.```pythonchipid = 5chip_key = '1-1-5'chip5 = controller.add_chip(chip_key, version=2)chip5 = controller[chip_key] # get chip objectchip5 = controller[1,1,5] # gets same chip object```The `chip_key` field specifies the necessary information for the `controller.io`object to route packets to/from the chip. The details of how this key maps to aphysical chip is implemented separately for each `larpix.io` class.The key itself consists of 3 1-byte integer values that represent the 3low-level layers in larpix readout:  - the io group: this is the highest layer and represents a control system that  communicates with multiple IO channels  - the io channel: this is the middle layer and represents a single MOSI/MISO  pair  - the chip id: this is the lowest layer and represents a single chip on a  MOSI/MISO networkIf you want to interact with chip keys directly, you can instantiate one usinga valid keystring (three 1-byte integers separated by dashes, e.g. ``'1-1-2'``).Please note that the ids of 0, 1, and 255 are reserved for special functions.```pythonfrom larpix import Keyexample_key = Key(1,2,3)```You can grab relevant information from the key via a number of useful methodsand attributes:```pythonexample_key.io_group  # 1example_key.io_channel  # 2example_key.chip_id  # 3example_key.to_dict() # returns a dict with the above keys / values```If you are using a ``Key`` in a script, we recommend that you generate the keysvia the ``Key(&lt;io_group&gt;,&lt;io_channel&gt;,&lt;chip_id&gt;)`` method which will protect against updates to the keystringformatting.You can read the docs to learn more about ``Key`` functionality.### Set up LArPix Hydra networkThe controller object contains an internal structure representing the Hydranetworks on each of the io channels. This structure can be accessed via``controller.network`` and modified using the ``controller.add_network_node``and ``controller.add_network_link`` methods. However, it can be a tediousand error-prone process to add each link to the network representation. So,there exists a friendlier [configuration file](https://larpix-control.readthedocs.io/en/stable/api/configs/controller.html) that is used to generate these network links.To load a network configuration into the controller:```pythoncontroller.load('controller/v2_example.json')print(controller.chips) # chips that have been loaded into controllerlist(controller.network[1][1]['miso_ds'].edges) # all links contained in the miso_ds graphlist(controller.network[1][1]['miso_us'].nodes) # all nodes within the miso_us graphlist(controller.network[1][1]['mosi'].edges) # all links within the mosi graph```Each graph is represented by a networkx directed graph and can be examined andqueried in that way. All edges point in the direction of data flow.```pythonlist(controller.network[1][1]['mosi'].in_edges(2)) # all links pointing to chip 2 in mosi graphlist(controller.network[1][1]['miso_ds'].successors(3)) # all chips receiving downstream data packets from chip 3controller.network[1][1]['mosi'].edges[(3,2)]['uart'] # check the physical uart channel that chip 2 listens to chip 3 viacontroller.network[1][1]['mosi'].nodes[2]['root'] # check if designated root chip```After loading the network into the controller, the ``init_network`` commandautomates the process of bringing up individual chips in the network.```pythoncontroller.init_network(1,1) # issues packets required to initialize the 1,1 hydra networkprint(controller['1-1-2'].config.chip_id)print(controller['1-1-3'].config.enable_miso_downstream)```This issues configuration commands in the proper order so that upstream chipsare configured before downstream chips. If you'd like to reset the networkconfiguration```pythoncontroller.reset_network(1,1)```can be used to reverse the configuration commands issued with ``init_network``.These processes are not &quot;smart&quot; in that they blindly issue config commandsassuming the network is either fully configured or in a default state, so buyerbeware.The network initialization can be broken down into single steps by also passingalong the chip id:```pythoncontroller.init_network(1,1,2) # configures only chip 2controller.init_network(1,1,3) # configures only chip 3```But this requires initializing the chips in the proper order. You can get thechip keys in order of their depth within the network via```pythoncontroller.get_network_keys(1,1) # gets a list of chip keys starting at the root node and descendingcontroller.get_network_keys(1,1,root_first_traversal=False) # get list of chip keys starting at deepest chips and ascending```### Adjust the configuration of the LArPix ChipsEach Chip object manages its own configuration in software.Configurations can be adjusted by name using attributes of the Chip'sconfiguration:```pythonchip5.config.threshold_global = 35  # entire register = 1 numberchip5.config.enable_periodic_reset = 1  # one bit as part of a registerchip5.config.channel_mask[20] = 1  # one bit per channel```Values are validated, and invalid values will raise exceptions.Note: Changing the configuration of a Chip object does *not* change theconfiguration on the ASIC.Once the configuration is set, the new values must be sent to the LArPixASICs. There is an appropriate Controller method for that:```pythoncontroller.write_configuration(chip_key)  # send all registerscontroller.write_configuration(chip_key, 32)  # send only register 32controller.write_configuration(chip_key, [32, 50])  # send registers 32 and 50controller.write_configuration(chip_key, 'threshold_global') # send register for 'threshold_global'```Register addresses can be looked up using the configuration object:```pythonthreshold_global_reg = chip5.config.register_map['threshold_global']```And register names:```pythonthreshold_global_name = chip5.config.register_map_inv[64]```For configurations which extend over multiple registers, the relevantattribute will end in ``_addresses``. Certain configurations share asingle register, whose attribute has all of the names in it. View thedocumentation or source code to find the name to look up. (Or look atthe LArPix data sheet.)### Reading the configuration from LArPix ASICsThe current configuration state of the LArPix ASICs can be requested bysending out &quot;configuration read&quot; requests using the Controller:```pythoncontroller.read_configuration(chip_key)```The same variations to read only certain registers are implemented forreading as for writing.The responses from the LArPix ASICs are stored for inspection. See thesection on &quot;Inspecting received data&quot; for more.FakeIO queue code:```pythonpackets = chip5.get_configuration_read_packets()bytestream = b'bytes for the config read packets'controller.io.queue.append((packets, bytestream))```### Receiving data from LArPix ASICsWhen it is first initialized, the LArPix Controller ignores and discardsall data that it receives from LArPix. The Controller must be activatedby calling ``start_listening()``. All received data will then beaccumulated in an implementation-dependent queue or buffer, dependingon the IO interface used. To read the data from the buffer, call thecontroller's ``read()`` method, which returns both the raw bytestreamreceived as well as a list of LArPix Packet objects which have beenextracted from the bytestream. To stop listening for new data, call``stop_listening()``. Finally, to store the data in the controllerobject, call the ``store_packets`` method. All together:```pythoncontroller.start_listening()# Data arrives...packets, bytestream = controller.read()# More data arrives...packets2, bytestream2 = controller.read()controller.stop_listening()message = 'First data arrived!'message2 = 'More data arrived!'controller.store_packets(packets, bytestream, message)controller.store_packets(packets, bytestream2, message2)```There is a common pattern for reading data, namely to start listening,then check in periodically for new data, and then after a certain amountof time has passed, stop listening and store all the data as onecollection. The method ``run(timelimit, message)`` accomplishes just this.```pythonduration = 10  # secondsmessage = '10-second data run'controller.run(duration, message)```FakeIO queue code for the first code block:```pythonpackets = [Packet_v2()] * 40bytestream = b'bytes from the first set of packets'controller.io.queue.append((packets, bytestream))packets2 = [Packet_v2()] * 30bytestream2 = b'bytes from the second set of packets'controller.io.queue.append((packets2, bytestream2))```fakeIO queue code for the second code block:```pythonpackets = [Packet_v2()] * 5bytestream = b'[bytes from read #%d] 'for i in range(100):    controller.io.queue.append((packets, bytestream%i))```### Inspecting received dataOnce data is stored in the controller, it is available in the ``reads``attribute as a list of all data runs. Each element of the list is aPacketCollection object, which functions like a list of Packet objectseach representing one LArPix packet.PacketCollection objects can be indexed like a list:```pythonrun1 = controller.reads[0]first_packet = run1[0]  # Packet objectfirst_ten_packets = run1[0:10]  # smaller PacketCollection objectfirst_packet_bits = run1[0, 'bits']  # string representation of bits in packetfirst_ten_packet_bits = run1[0:10, 'bits']  # list of strings```PacketCollections can be printed to display the contents of the Packetsthey contain. To prevent endless scrolling, only the first ten and last tenpackets are displayed, and the number of omitted packets is noted. Toview the omitted packets, use a slice around the area of interest.```pythonprint(run1)  # prints the contents of the packetsprint(run1[10:30])  # prints 20 packets from the middle of the run```In interactive Python, returned objects are not printed, but rathertheir &quot;representation&quot; is printed (cf. the ``__repr__`` method). Therepresentation of PacketCollections is a listing of the number ofpackets, the &quot;read id&quot; (a.k.a. the run number), and the messageassociated with the PacketCollection when it was created.### Individual LArPix PacketsLArPix Packet objects represent individual LArPix UART packets. Theyhave attributes which can be used to inspect or modify the contents ofthe packet.```pythonpacket = run1[0]# all packetspacket.packet_type  # unique in that it gives the bits representationpacket.chip_id  # all other properties return Python numberspacket.chip_key # key for association to a unique chip (can be None)packet.paritypacket.downstream_marker# data packetspacket.channel_idpacket.datawordpacket.timestamppacket.trigger_typepacket.local_fifopacket.shared_fifo# config packetspacket.register_addresspacket.register_data```Internally, packets are represented as an array of bits, and thedifferent attributes use Python &quot;properties&quot; to seamlessly convertbetween the bits representation and a more intuitive integerrepresentation. The bits representation can be inspected with the``bits`` attribute.Packet objects do not restrict you from adjusting an attribute for aninappropriate packet type. For example, you can create a data packet andthen set ``packet.register_address = 5``. This will adjust the packetbits corresponding to a configuration packet's &quot;register\_address&quot;region, which is probably not what you want for your data packet.Packets have a parity bit which enforces odd parity, i.e. the sum ofall the individual bits in a packet must be an odd number. The paritybit can be accessed as above using the ``parity`` attribute.The correct parity bit can be computed using ``compute_parity()``,and the validity of a packet's parity can be checked using``has_valid_parity()``. When constructing a new packet, the correctparity bit can be assigned using ``assign_parity()``.Individual packets can be printed to show a human-readableinterpretation of the packet contents. The printed version adjusts itsoutput based on the packet type, so a data packet will show the dataword, timestamp, etc., while a configuration packet will show the registeraddress and register data.Like with PacketCollections, Packets also have a &quot;representation&quot; viewbased on the bytes that make up the packet. This can be useful forcreating new packets since a Packet's representation is also a vaildcall to the Packet constructor. So the output from an interactivesession can be copied as input or into a script to create the samepacket.With the v2 chip, more information about the internal fifo can be gathered byrunning with fifo diagonstics enabled on a given asic. In this case, the bits ofeach packet are to be interpreted differently. Each packet object can be set tobe interpreted in this mode via the ``fifo_diagnostics_enabled`` flag. See thePacket_v2 [documentation](https://larpix-control.readthedocs.io/en/stable/) formore details.### Logging communications with LArPix ASICs using the HDF5LoggerTo create a permanent record of communications with the LArPix ASICs, an`HDF5Logger` is used. To create a new logger```pythonfrom larpix.logger import HDF5Loggercontroller.logger = HDF5Logger(filename=None, buffer_length=10000) # a filename of None uses the default filename formattingcontroller.logger.enable() # starts tracking all communications```You can also initialize and enable the logger in one call by passing the``enabled`` keyword argument (which defaults to ``False``):```controller.logger = HDF5Logger(filename=None, enabled=True)```Now whenever you send or receive packets, they will be captured by the loggerand added to the logger's buffer. Once `buffer_length` packets have beencaptured the packets will be written out to the file. You can force the loggerto dump the currently held packets at any time using `HDF5Logger.flush()````pythoncontroller.verify_configuration()controller.logger.flush()```In the event that you want to temporarily stop tracking communications,the `disable` and `enable` commands do exactly what you think they might.```pythoncontroller.logger.disable() # stop tracking# any communication here is ignoredcontroller.logger.enable() # start tracking againcontroller.logger.is_enabled() # returns True if tracking```Once you have finished your tests, be sure to disable the logger. If you do not,you will lose any data still in the buffer of the logger object. We strongly recommendwrapping logger code with a `try, except` statement if you can. Any remainingpackets in the buffer are flushed to the file upon disabling.```pythoncontroller.logger.disable()```### Viewing data from the HDF5LoggerThe ``HDF5Logger`` uses a format called LArPix+HDF5v1.0 that is specified inthe ``larpix.format.hdf5format`` module (and[documentation](https://larpix-control.readthedocs.io/en/stable/)starting in v2.3.0). That module contains a ``to_file`` method which isused internally by ``HDF5Logger`` and a ``from_file`` method that youcan use to load the file contents back into LArPix Control. TheLArPix+HDF5 format is a &quot;plain HDF5&quot; format that can be inspected with``h5py`` or any language's HDF5 binding.To open the HDF5 file from python```pythonimport h5pydatafile = h5py.File('&lt;filename&gt;')```Within the datafile there is one group (`'_header'`) and two datasets(``'packets'`` and ``'messages'``). The header group contains some useful meta information aboutwhen the datafile was created and the file format version number, stored asattributes.```pythonlist(datafile.keys()) # ['_header', 'messages', 'packets']list(datafile['_header'].attrs) # ['created', 'modified', version']```The packets are stored sequentially as a `numpy` mixed-type arrays within therows of the HDF5 dataset. The columns refer to the element of the numpy mixedtype array. The specifics of the data type and entries are set by the``larpix.format.hdf5format.dtype`` object - see the larpix-control docs for more information.You can inspect a packet as a tuple simply by accessing its respective position within theHDF5 dataset.```pythonraw_value = datafile['packets'][0] # e.g. (b'0-246', 3, 246, 1, 1, -1, -1, -1, -1, -1, -1, 0, 0)raw_values = datafile['packets'][-100:] # last 100 packets in file```If you want to make use of `numpy`'s mixed type arrays, you can convert theraw values to the proper encoding by retrieving it as a list (of length1, for example) via```pythonpacket_repr = raw_values[0:1] # list with one elementpacket_repr['chip_id'] # chip key for packet, e.g. 246packet_repr['dataword'] # list of ADC values for each packetpacket_repr.dtype # description of data type (with names of each column)```You can also view entire &quot;columns&quot; of data:```python# all packets' ADC counts, including non-data packetsraw_values['dataword']# Select based on data type using a numpy bool / &quot;mask&quot; array:raw_values['dataword'][raw_values['packet_type'] == 0] # all data packets' ADC counts`````h5py`` and ``numpy`` optimize the retrieval of data so you can readcertain columns or rows without loading the entire data file into memory.Don't forget to close the file when you are done. (Not necessary ininteractive python sessions if you are about to quit.)```pythondatafile.close()```## Running with a PACMANv1r1 board (v2 asic)Before you can configure the system, you need to generate a configuration filefor the PACMAN_IO interface. This sets up the mapping from chip keys to the ipaddresses of the physical devices. One example configuration is provided in``larpix/configs/io/pacman.json``, which assumes that you can perform hostnameDNS resolution.After powering up the PACMAN board, you can create a new PACMAN io object with```pythonfrom larpix import Controllerfrom larpix.io import PACMAN_IOcontroller = Controller()controller.io = PACMAN_IO(config_filepath='&lt;io config file path&gt;')controller.load('&lt;controller config file path&gt;')controller.io.ping() # returns a dict of (io_group, ping_success)```To set the correct supply voltages```pythoncontroller.io.set_vddd() # set default vddd (~1.8V)controller.io.set_vdda() # set default vdda (~1.8V)```These automatically query the built-in ADCs and return the set voltage and currentin mV and mA, respectively. And to power on the chips```pythoncontroller.io.enable_tile()```which will enable the LDOs for VDDD/VDDA and the driver chips / FPGA outputs for IO.To bring up the Hydra network (and work around the known bugs in v2), do thefollowing:```python# First bring up the network using as few packets as possiblecontroller.io.group_packets_by_io_group = False # this throttles the data rate to avoid FIFO collisionsfor io_group, io_channels in controller.network.items():    for io_channel in io_channels:        controller.init_network(io_group, io_channel)# Configure the IO for a slower UART and differential signalingcontroller.io.double_send_packets = True # double up packets to avoid 512 bug when configuringfor io_group, io_channels in controller.network.items():    for io_channel in io_channels:        chip_keys = controller.get_network_keys(io_group,io_channel,root_first_traversal=False)        for chip_key in chip_keys:            controller[chip_key].config.clk_ctrl = 1            controller[chip_key].config.enable_miso_differential = [1,1,1,1]            controller.write_configuration(chip_key, 'enable_miso_differential')            controller.write_configuration(chip_key, 'clk_ctrl')for io_group, io_channels in controller.network.items():    for io_channel in io_channels:        controller.io.set_uart_clock_ratio(io_channel, 4, io_group=io_group)controller.io.double_send_packets = Falsecontroller.io.group_packets_by_io_group = True```At this point, you can happily interface with the ASICs using everything youlearned above. I also recommend you glance at the section below (**Running witha Bern DAQ board**), which describes some shortcut functions available in the`Controller` class. In particular, it is good practice to ``verify_configuration``before proceeding with anything.## Running with a Bern DAQ board (v1 asic)Since you have completed the tutorial with the `FakeIO` class, you are now readyto interface with some LArPix ASICs. If you have a Bern DAQ v2-3 setup you canfollow along with the rest of the tutorial.Before you can configure the system, you will need to generate a configurationfile for the ZMQ_IO or MultiZMQ_IO interface. This provides the mapping fromchip keys to physical devices. In the case of the ZMQ interface, it mapsio group #s to the IP address of the DAQ board. A number of exampleconfigurations are provided in the installation under``larpix/configs/io/&lt;config name&gt;.json``, which may work for your purposes. Werecommend reading the docs about how to create one of these configuration files.By default the system looks for configuration in the pwd, before looking for theinstallation files. If you only have one DAQ board on your network, likelyyou will load the ``io/daq-srv&lt;#&gt;.json`` configuration.With the DAQ system up and running```python&gt;&gt;&gt; from larpix import Controller&gt;&gt;&gt; from larpix.io import ZMQ_IO&gt;&gt;&gt; controller = Controller()&gt;&gt;&gt; controller.io = ZMQ_IO(config_filepath='&lt;path to config&gt;')&gt;&gt;&gt; controller.load('controller/pcb-&lt;#&gt;_chip_info.json')&gt;&gt;&gt; controller.io.ping()&gt;&gt;&gt; for key,chip in controller.chips.items():...     chip.config.load('chip/quiet.json')...     print(key, chip.config)...     controller.write_configuration(key)&gt;&gt;&gt; controller.run(1,'checking the data rate')&gt;&gt;&gt; controller.reads[-1]&lt;PacketCollection with 0 packets, read_id 0, 'checking the data rate'&gt;```This should give you a quiet state with no data packets. Occasionally, there canbe a few packets left in one of the system buffers (LArPix, FPGA, DAQ server). Asecond run command should return without any new packets.If you are using the v1.5 anode, you may need to reconfigure the miso/mosi mapping (since the miso/mosi pair for a daisy chain is not necessarily on a single channel). To do this, pass a `miso_map` or `mosi_map` to the `ZMQ_IO` object on initialization:```python&gt;&gt;&gt; controller.io = ZMQ_IO(config_filepath='&lt;path to config&gt;', miso_map={2:1}) # relabels packets received on channel 2 as packets from channel 1```### Check configurationsIf you are still receiving data, you can check that the hardware chip configurationmatch the software chip configurations with```python&gt;&gt;&gt; controller.verify_configuration()(True, {})```If the configuration read packets don't match the software chip configuration, thiswill return```python&gt;&gt;&gt; controller.verify_configuration()(False, {&lt;register&gt;: (&lt;expected&gt;, &lt;received&gt;), ...})```Missing packets will show up as```python&gt;&gt;&gt; controller.verify_configuration()(False, {&lt;register&gt;: (&lt;expected&gt;, None), ...})```If your configurations match, and you still receive data then you are likely seeingsome pickup on the sensor from the environment -- *good luck!*### Enable a single channel```python&gt;&gt;&gt; chip_key = '1-1-3'&gt;&gt;&gt; controller.disable() # mask off all channel&gt;&gt;&gt; controller.enable(chip_key, [0]) # enable channel 0 of chip```### Set the global threshold of a chip```python&gt;&gt;&gt; controller.chips[chip_key].config.global_threshold = 40&gt;&gt;&gt; controller.write_configuration(chip_key)&gt;&gt;&gt; controller.verify_configuration(chip_key)(True, {})```### Inject a pulse into a specific channel```python&gt;&gt;&gt; controller.enable_testpulse(chip_key, [0]) # connect channel 0 to the test pulse circuit and initialize the internal DAC to 255&gt;&gt;&gt; controller.issue_testpulse(chip_key, 10) # inject a pulse of size 10DAC by stepping down the DAC&lt;PacketCollection with XX packets, read_id XX, &quot;configuration write&quot;&gt;&gt;&gt;&gt; controller.disable_testpulse(chip_key) # disconnect test pulse circuit from all channels on chip```You will need to periodically reset the DAC to 255, otherwise you will receive a`ValueError` once the DAC reaches the minimum specified value.```python&gt;&gt;&gt; controller.enable_testpulse(chip_key, [0], start_dac=255)&gt;&gt;&gt; controller.issue_testpulse(chip_key, 50, min_dac=200) # the min_dac keyword sets the lower bound for the DAC (useful to avoid non-linearities at around 70-80DAC)&lt;PacketCollection with XX packets, read_id XX, &quot;configuration write&quot;&gt;&gt;&gt;&gt; controller.issue_testpulse(chip_key, 50, min_dac=200)ValueError: Minimum DAC exceeded&gt;&gt;&gt; controller.enable_testpulse(chip_key, [0], start_dac=255)&gt;&gt;&gt; controller.issue_testpulse(chip_key, 50, min_dac=200)&lt;PacketCollection with XX packets, read_id XX, &quot;configuration write&quot;&gt;```### Enable the analog monitor on a channel```python&gt;&gt;&gt; controller.enable_analog_monitor(chip_key, 0) # drive buffer output of channel 0 out on analog monitor line&gt;&gt;&gt; controller.disable_analog_monitor(chip_key) # disable the analog monitor on chip```While the software enforces that only one channel per chip is being driven out onthe analog monitor, you must disable the analog monitor if moving between chips.## Miscellaneous implementation details### Endian-nessWe use the convention that the LSB is sent out first and read in first.The location of the LSB in arrays and lists changes from object toobject based on the conventions of the other packages we interact with.In particular, pyserial sends out index 0 first, so for `bytes` objects,index 0 will generally have the LSB. On the other hand, bitstringstreats the _last_ index as the LSB, which is also how numbers areusually displayed on screen, e.g. `0100` in binary means 4 not 2. So for`BitArray` and `Bits` objects, the LSB will generally be last.Note that this combination leads to the slightly awkward convention thatthe least significant bit of a bytestring is the *last bit* of the*first byte*. For example, if bits[15:0] of a packet are`0000 0010 0000 0001` ( = 0x0201 = 513), then the bytes will be sent out as`b'\x01\x02'`.### The Configuration objectThe `Configuration` object represents all of the options in the LArPixconfiguration register. Each row in the configuration table in the LArPix datasheethas a corresponding attribute in the `Configuration` object. Per-channelattributes are stored in a list, and all other attributes are stored asa simple integer. (This includes everything from single bits to valuessuch as &quot;reset cycles,&quot; which spans 3 bytes.)`Configuration` objects also have some helper methods for enabling anddisabling per-channel settings (such as `csa_testpulse_enable` or`channel_mask`). The relevant methods are listed here and should beprefixed with either `enable_` or `disable_`: - `channels` enables/disables the `channel_mask` register - `external_trigger` enables/disables the `external_trigger_mask`    register - `testpulse` enables/disables the `csa_testpulse_enable` register - `analog_monitor` enables/disables the `csa_monitor_select` registerMost of these methods accept an optional list of channels to enable ordisable (and with no list specified acts on all channels). The exceptionis `enable_analog_monitor` (and its `disable` counterpart): the `enable`method requires a particular channel to be specified, and the `disable`method does not require any argument at all. This is because at most onechannel is allowed to have the analog monitor enabled.The machinery of the `Configuration` object ensures that each value isconverted to the appropriate set of bits when it comes time to sendactual commands to the physical chip. Although this is not transparentto you as a user of this library, you might want to know that two sets ofconfiguration options are always sent together in the same configurationpacket: - `csa_gain`, `csa_bypass`, and `internal_bypass` are combined into a   single byte, so even though they have their own attributes, they must   be written to the physical chip together - `test_mode`, `cross_trigger_mode`, `periodic_reset`, and   `fifo_diagnostic` work the same waySimilarly, all of the per-channel options (except for the pixel trimthresholds) are sent in 4 groups of 8 channels.Configurations can be loaded by importing `larpix.configs` and runningthe `load` function. This function searches for a configuration with thegiven filename relative to the current directory before searching the&quot;system&quot; location (secretly it's in the larpix/configs/ folder). This issimilar to `#include &quot;header.h&quot;` behavior in C.Configurations can be saved by calling `chip.config.write` with thedesired filename.Once the Chip object has been configured, the configuration must be sentto the physical chip.</longdescription>
</pkgmetadata>