<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Python package](https://github.com/BlackFoundryCom/black-renderer/actions/workflows/ci.yml/badge.svg)](https://github.com/BlackFoundryCom/black-renderer/actions/workflows/ci.yml)# BlackRendererBlackRenderer is a Python-based renderer for OpenType COLR fonts, with multiplebackends. It supports the new COLRv1 format as well as the old COLR format. Itfully supports variable fonts, including variable COLRv1 data.![Big Smiley Face Icon](https://github.com/BlackFoundryCom/black-renderer/blob/master/smile.png?raw=true)## Features- It's a Python library called &quot;blackrenderer&quot;- It's a command line tool called &quot;blackrenderer&quot;- Renders individual glyphs or text strings- Supports multiple graphics backends:  - Skia  - Cairo  - CoreGraphics (macOS)  - SVG  - outline extractor  - bounding box calculator- Supports multiple output formats:  - .png  - .pdf  - .svg- It uses fonttools to parse COLRv1 data- The &quot;blackrenderer&quot; tool is an &quot;hb-view&quot;-like command line app with switchable  backend. It uses HarfBuzz for shaping## Tool usage exampleBlackRenderer comes with an hb-view-like command line tool, that can be used like this:    $ blackrenderer font.ttf ABCðŸ¤© output.png --font-size=100## Library usage examplesThere is a high level function to render a text string:```pythonfrom blackrenderer.render import renderTextrenderText(&quot;myfont.ttf&quot;, &quot;ABC&quot;, &quot;output.png&quot;)  # or &quot;output.svg&quot;```The full `renderText()` signature is:```pythondef renderText(    fontPath,    textString,    outputPath,    *,    fontSize=250,    margin=20,    features=None,    variations=None,    backendName=None,)```For more control, the library exposes two main parts: the BlackRendererFontclass, and a set of backend classes. Each backend provides a Canvas class.You pass a Canvas instance to a BlackRendererFont instance when drawing aglyph. Most backends also have a Surface class, which is a generalizedconvenience class to produce a canvas for a bitmap (or SVG document) for aspecific box. Here is a minimal example:```pythonfrom blackrenderer.font import BlackRendererFontfrom blackrenderer.backends import getSurfaceClassbrFont = BlackRendererFont(&quot;my_colr_font.ttf&quot;)glyphName = &quot;A&quot;boundingBox = brFont.getGlyphBounds(glyphName)surfaceClass = getSurfaceClass(&quot;skia&quot;)surface = surfaceClass()with surface.canvas(boundingBox)    brFont.drawGlyph(glyphName, canvas)surface.saveImage(&quot;image.png&quot;)```Canvas objects support the following transformation methods:- `canvas.translate(dx, dy)`- `canvas.scale(sx, sy)`- `canvas.transform((xx, yx, xy, yy, dx, dy))`Save/restore is done with a context manager:```pythonwith canvas.savedState():    canvas.scale(0.3)    ...draw stuff...```## InstallIf you have a Python 3 environment set up, then all you need to do is:    $ pip install blackrenderer## Install for contributing / setting up an environmentHave Python 3.7 or higher installed.Open Terminal.&quot;cd&quot; into the project repo directory.Create a virtual environment:- `$ python3 -m venv venv --prompt=black-renderer`Activate the venv:- `$ source venv/bin/activate`(You need to activate the virtual environment for every new terminal session.)Upgrade pip:- `$ pip install --upgrade pip`Install the requirements:- `$ pip install -r requirements.txt`- `$ pip install -r requirements-dev.txt`Install blackrenderer in editable mode:- `$ pip install -e .`Run the tests:- `$ pytest`## Maintainers: how to releaseTo cut a release, make an annotated git tag, where the tag is in this format:v1.2.3, where 1, 2 and 3 represent major, minor and micro version numbers.You can add &quot;aN&quot; or &quot;bN&quot; or &quot;rc&quot; to mark alpha, beta or &quot;release candidate&quot;versions. Examples: v1.2.3, v1.2.3b2, v1.2.3a4, v1.2.3rc.The message for the annotated tag should contain the release notes.Then use &quot;git push --follow-tags&quot; to trigger the release bot. Example session:- `$ git tag -a v1.2.3 -m &quot;v1.2.3 -- fixed issue #12345&quot;`- `$ git push --follow-tags`This process will create a GitHub release, as well as upload the package toPyPI.</longdescription>
</pkgmetadata>