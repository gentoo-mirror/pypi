<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># typing-protocol-intersection[![tests &amp; static analysis](https://github.com/klausweiss/typing-protocol-intersection/actions/workflows/ci.yml/badge.svg)](https://github.com/klausweiss/typing-protocol-intersection/actions/workflows/ci.yml)[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/typing-protocol-intersection)](https://pypi.org/project/typing-protocol-intersection/)A tiny Python 3 package that introduces Protocol intersections (for `Protocol`s themselvessee [PEP 544](https://peps.python.org/pep-0544/)).The `ProtocolIntersection` type tells mypy that an object implements multiple protocols.It can be used either as a function parameter or as a return value.A mypy plugin that ships with the package is required for this to work.See the [examples](#examples) section below.## Supported versionsThe plugin supports python 3.7 up to 3.12 and mypy &gt;= 0.920 and &lt;= 1.6.x.## InstallationThe `typing-protocol-intersection` package is pip-installable:```shellpip install typing-protocol-intersection ```## ConfigurationAdd `typing_protocol_intersection.mypy_plugin` to `plugins` in mypy configuration:```shell&gt; cat mypy.ini[mypy]plugins = typing_protocol_intersection.mypy_plugin```## Examples### Simple example```pythonfrom typing import Protocolfrom typing_protocol_intersection import ProtocolIntersection as Hasclass X(Protocol):    x: strclass Y(Protocol):    y: strdef foo(xy: Has[X, Y]) -&gt; None:    # Note xy implements both X and Y, not just one of them    print(xy.x, xy.y)```### Complex example - valid programHere's a more complex example showing what you can write with the help of this mypy plugin:```pythonfrom types import SimpleNamespacefrom typing import Protocol, Generic, TypeVar, Dictfrom typing_protocol_intersection import ProtocolIntersection as Hasclass X(Protocol):    x: strclass Y(Protocol):    y: strT = TypeVar(&quot;T&quot;)class Builder(Generic[T]):    def __init__(self) -&gt; None:        super().__init__()        self._d: Dict[str, str] = {}    def with_x(self) -&gt; &quot;Builder[Has[T, X]]&quot;:        self._d[&quot;x&quot;] = &quot;X&quot;        return self  # type: ignore    def with_y(self) -&gt; &quot;Builder[Has[T, Y]]&quot;:        self._d[&quot;y&quot;] = &quot;Y&quot;        return self  # type: ignore    def build(self) -&gt; T:        return SimpleNamespace(**self._d)  # type: ignoreclass DesiredObject(X, Y, Protocol):    passdef get_x_y_1(o: DesiredObject) -&gt; None:    print(f&quot;{o.x=}; {o.y=}&quot;)def get_x_y_2(o: Has[X, Y]) -&gt; None:    print(f&quot;{o.x=}; {o.y=}&quot;)def main() -&gt; None:    valid_o = Builder().with_x().with_y().build()    get_x_y_1(valid_o)    get_x_y_2(valid_o)if __name__ == &quot;__main__&quot;:    main()``````shell&gt; # with plugin&gt; mypy example.pySuccess: no issues found in 1 source file```### Complex example - invalid programAnd here's how would the plugin help if you forgot to include one of the protocols while building an object:```pythonfrom types import SimpleNamespacefrom typing import Protocol, Generic, TypeVar, Dictfrom typing_protocol_intersection import ProtocolIntersection as Hasclass X(Protocol):    x: strclass Y(Protocol):    y: strT = TypeVar(&quot;T&quot;)class Builder(Generic[T]):    def __init__(self) -&gt; None:        super().__init__()        self._d: Dict[str, str] = {}    def with_x(self) -&gt; &quot;Builder[Has[T, X]]&quot;:        self._d[&quot;x&quot;] = &quot;X&quot;        return self  # type: ignore    def with_y(self) -&gt; &quot;Builder[Has[T, Y]]&quot;:        self._d[&quot;y&quot;] = &quot;Y&quot;        return self  # type: ignore    def build(self) -&gt; T:        return SimpleNamespace(**self._d)  # type: ignoreclass DesiredObject(X, Y, Protocol):    passdef get_x_y_1(o: DesiredObject) -&gt; None:    print(f&quot;{o.x=}; {o.y=}&quot;)def get_x_y_2(o: Has[X, Y]) -&gt; None:    print(f&quot;{o.x=}; {o.y=}&quot;)def main() -&gt; None:    valid_o = Builder().with_x().build()  # &lt;-- note no .with_y()    get_x_y_1(valid_o)    get_x_y_2(valid_o)if __name__ == &quot;__main__&quot;:    main()``````shell&gt; # Note the real output would contain some invisible characters which were removed here.&gt; mypy example.pyexample.py:40:15: error: Argument 1 to &quot;get_x_y_1&quot; has incompatible type &quot;ProtocolIntersection[X]&quot;; expected &quot;DesiredObject&quot;  [arg-type]example.py:40:15: note: &quot;ProtocolIntersection&quot; is missing following &quot;DesiredObject&quot; protocol member:example.py:40:15: note:     yexample.py:41:15: error: Argument 1 to &quot;get_x_y_2&quot; has incompatible type &quot;typing_protocol_intersection.types.ProtocolIntersection[X]&quot;; expected &quot;typing_protocol_intersection.types.ProtocolIntersection[Y, X]&quot;  [arg-type]example.py:41:15: note: &quot;ProtocolIntersection&quot; is missing following &quot;ProtocolIntersection&quot; protocol member:example.py:41:15: note:     yFound 2 errors in 1 file (checked 1 source file)```## Recommended usageThe `ProtocolIntersection` class name might seem a bit lengthy, but it's explicit, which is good.For brevity and better readability, it's recommended to use an alias when importing, as seen in the examples above.```pythonfrom typing_protocol_intersection import ProtocolIntersection as Has```</longdescription>
</pkgmetadata>