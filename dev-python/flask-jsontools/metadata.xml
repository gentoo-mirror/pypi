<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Build Status](https://api.travis-ci.org/kolypto/py-flask-jsontools.png?branch=master)](https://travis-ci.org/kolypto/py-flask-jsontools)[![Pythons](https://img.shields.io/badge/python-2.7%20%7C%203.4%E2%80%933.8%20%7C%20pypy-blue.svg)](.travis.yml)Flask JsonTools===============JSON API tools for FlaskTable of Contents=================* &lt;a href=&quot;#view-utilities&quot;&gt;View Utilities&lt;/a&gt;    * &lt;a href=&quot;#jsonapi&quot;&gt;@jsonapi&lt;/a&gt;        * &lt;a href=&quot;#jsonresponse&quot;&gt;JsonResponse&lt;/a&gt;        * &lt;a href=&quot;#make_json_response&quot;&gt;make_json_response()&lt;/a&gt;* &lt;a href=&quot;#flaskjsonclient&quot;&gt;FlaskJsonClient&lt;/a&gt;* &lt;a href=&quot;#class-based-views&quot;&gt;Class-Based Views&lt;/a&gt;    * &lt;a href=&quot;#methodview&quot;&gt;MethodView&lt;/a&gt;    * &lt;a href=&quot;#restfulview&quot;&gt;RestfulView&lt;/a&gt; View Utilities==============@jsonapi--------Decorate a view function that talks JSON.Such function can return:* tuples of `(response, status[, headers])`: to set custom status code and optionally - headers* Instances of [`JsonResponse`](#jsonresponse)* The result of helper function [`make_json_response`](#make_json_response)Example:```pythonfrom flask.ext.jsontools import jsonapi@app.route('/users')@jsonapidef list_users():    return [        {'id': 1, 'login': 'kolypto'},        #...    ]@app.route('/user/&lt;int:id&gt;', methods=['DELETE'])def delete_user(id):    return {'error': 'Access denied'}, 403```### JsonResponseExtends [`flask.Request`](http://flask.pocoo.org/docs/api/#incoming-request-data) and encodes the response with JSON.Views decorated with [`@jsonapi`](#jsonapi) return these objects.Arguments:* `response`: response data* `status`: status code. Optional, defaults to 200* `headers`: additional headers dict. Optional.* `**kwargs`: additional argumets for [`Response`](http://flask.pocoo.org/docs/api/#response-objects)Methods:* `preprocess_response_data(response)`: Override to get custom response behavior.* `get_json()`: Get the original response data.* `__getitem__(key)`: Get an item from the response dataThe extra methods allows to reuse views:```pythonfrom flask.ext.jsontools import jsonapi@app.route('/user', methods=['GET'])@jsonapidef list_users():    return [ { 1: 'first', 2: 'second' } ]@app.route('/user/&lt;int:id&gt;', methods=['GET'])@jsonapidef get_user(id):    return list_users().get_json()[id]  # Long form    return list_users()[id]  # Shortcut```### make_json_response()Helper function that actually preprocesses view return value into [`JsonResponse`](#jsonresponse).Accepts `rv` as any of:* tuple of `(response, status[, headers])`* Object to encode as JSONFlaskJsonClient===============FlaskJsonClient is a JSON-aware test client: it can post JSON and parse JSON responses into [`JsonResponse`](#jsonresponse).```pythonfrom myapplication import Applicationfrom flask.ext.jsontools import FlaskJsonClientdef JsonTest(unittest.TestCase):    def setUp(self):        self.app = Application(__name__)        self.app.test_client_class = FlaskJsonClient    def testCreateUser(self):        with self.app.test_client() as c:            rv = c.post('/user/', json={'name': 'kolypto'})            # rv is JsonResponse            rv.status_code            rv.get_json()['user']  # Long form for the previous            rv['user']  # Shortcut for the previous```Formatting Utils================DynamicJSONEncoder-----------In python, de-facto standard for encoding objects of custom classes is the `__json__()` method which returns the representation of the object.`DynamicJSONEncoder` is the implementation of this protocol: if an object has the `__json__()` method, its result if used forthe representation.You'll definitely want to subclass it to support other types, e.g. dates and times:```pythonfrom flask.ext.jsontools import DynamicJSONEncoderclass ApiJSONEncoder(DynamicJSONEncoder):    def default(self, o):        # Custom formats        if isinstance(o, datetime.datetime):            return o.isoformat(' ')        if isinstance(o, datetime.date):            return o.isoformat()        if isinstance(o, set):            return list(o)        # Fallback        return super(ApiJSONEncoder, self).default(o)```Now, just install the encoder to your Flask:```pythonfrom flask import Flaskapp = Flask(__name__)app.json_encoder = DynamicJSONEncoder```JsonSerializableBase--------------------Serializing SqlAlchemy models to JSON is a headache: if an attribute is present on an instance, this does not meanit's loaded from the database.`JsonSerializableBase` is a mixin for SqlAlchemy Declarative Base that adds a magic `__json__()` method, compatible with[`DynamicJSONEncoder`](#dynamicjsonencoder). When serializing, it makes sure that entity serialization will *never* issue additional requests.Example:```pythonfrom sqlalchemy.ext.declarative import declarative_basefrom flask.ext.jsontools import JsonSerializableBaseBase = declarative_base(cls=(JsonSerializableBase,))class User(Base):    #...```Now, you can safely respond with SqlAlchemy models in your JSON views, and jsontools will handle the rest :)Class-Based Views=================Module `flask.ext.jsontools.views` contains a couple of classes that allow to build class-based viewswhich dispatch to different methods.In contrast to [MethodView](http://flask.pocoo.org/docs/api/#flask.views.MethodView), this gives much higher flexibility.MethodView----------Using `MethodView` class for methods, decorate them with `@methodview()`, which takes the following arguments:* `methods=()`: Iterable of HTTP methods to use with this method.* `ifnset=None`: Conditional matching. List of route parameter names that should *not* be set for this method to match.* `ifset=None`: Conditional matching. List of route parameter names that should be set for this method to match.This allows to map HTTP methods to class methods, and in addition define when individual methods should match.Quick example:```pythonfrom flask.ext.jsontools import jsonapi, MethodView, methodviewclass UserView(MethodView):    # Canonical way to specify decorators for class-based views    decorators = (jsonapi, )    @methodview    def list(self):        &quot;&quot;&quot; List users &quot;&quot;&quot;        return db.query(User).all()    @methodview    def get(self, user_id):        &quot;&quot;&quot; Load a user by id &quot;&quot;&quot;        return db.query(User).get(user_id)userview = CrudView.as_view('user')app.add_url_rule('/user/', view_func=userview)app.add_url_rule('/user/&lt;int:user_id&gt;', view_func=userview)```Now, `GET` HTTP method is routed to two different methods depending on conditions.Keep defining more methods to get good routing :)To simplify the last step of creating the view, there's a helper:```pythonUserView.route_as_view(app, 'user', ('/user/', '/user/&lt;int:user_id&gt;'))```RestfulView-----------Since `MethodView` is mostly useful to expose APIs over collections of entities, there is a RESTful helper whichautomatically decorates some special methods with `@methodview`.| View method | HTTP method | URL     ||-------------|-------------|---------|| list()      | GET         | `/`     || create()    | POST        | `/`     || get()       | GET         | `/&lt;pk&gt;` || replace()   | PUT         | `/&lt;pk&gt;` || update()    | POST        | `/&lt;pk&gt;` || delete()    | DELETE      | `/&lt;pk&gt;` |By subclassing `RestfulView` and implementing some of these methods, you'll get a complete API endpoint with a single class.It's also required to define the list of primary key fields by defining the `primary_key` property:```pythonfrom flask.ext.jsontools import jsonapi, RestfulViewclass User(RestfulView):    decorators = (jsonapi, )    primary_key = ('id',)    #region Operation on the collection    def list():        return db.query(User).all()    def create():        db.save(user)        return user    #endregion    #region Operation on entities    def get(id):        return db.query(User).get(id)    def replace(id):        db.save(user, id)    def update(id):        db.save(user)    def delete(id):        db.delete(user)    #endregion```When a class like this is defined, its metaclass goes through the methods and decorates them with `@methodview`.This way, `list()` gets `@methodview('GET', ifnset=('id',))`, and `get()` gets `@methodview('GET', ifset=('id',))`.</longdescription>
</pkgmetadata>