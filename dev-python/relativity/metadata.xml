<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>relativity==========multi-index data structuresMotivation----------We're going to take a mental journey of discovery to see whyrelativity was written, and how you can use it to simplifysome of the most difficult problems that come up regularlywhen programming.  Rather then leaping straight from programmingwith python's standard data structures to programming withrelativistic data structures, we'll get a running startby programming in a version of python that is missingkey data structures.  Then, we will draw a line from thisdeficient bad version of python to regular python, andthen extend that line on into relativity.Dict to List''''''''''''Imagine programming without hashmaps.  For example, let's say we havea list of ``Restaurant`` objects and ``City`` objects, and we want toget how many ``Restaurants`` are in each ``City``.Normally this is simple:.. code-block:: python    restaurants_in_city = {}    for restaurant in restaurants:        city = restaurant.city        restaurants_in_city[city] = restaurants_in_city.get(city, 0) + 1    def get_restaurant_count(city):        return restaurants_in_city.get(city, 0)But, imagine how you would approach the problem if the only availabledata structure was a list... code-block:: python    cities = []    restaurants_in_city = []    for restaurant in restaurants:        missing = True        for idx, city in enumerate(cities):            if city == restaurant.city:                restaurants_in_city[idx] += 1                missing = False        if missing:            cities.append(restaurant.city)            restaurants_in_city.append(1)    def get_restaurant_count(city):        for idx, city2 in enumerate(cities):            if city == city2:                return restaurants_in_city[idx]        return 0Comparing the two examples, there are a few key differences:- there are more low value local values (``idx``)- single data structures split into multiple, which must  then be kept in sync- the code is longer, therefore harder to read,  modify, and debugLet's leave this dystopian data structure wasteland behindfor now and go back to regular python.Dict to M2M'''''''''''The same differences that showed up when programming withand without hashmaps will come up again when comparingprogramming with single-index hashmaps to relativisticmulti-index hashmaps.Returning to the restaurants and cities example, what ifa restaurant can have multiple locations and we need tokeep track of which cities each restaurant is in,as well as which restaurants are in each city.Note that we allow a restaurant to have multiplelocations within the same city, so sets must be usedto avoid double counting... code-block:: python    restaurants_in_city = {}    cities_of_restaurant = {}    for restaurant in restaurants:        for location in restaurant.locations:            restaurants_in_city.setdefault(location.city, set()).add(restaurant)            cities_of_restaurant.setdefault(restaurant, set()).add(location.city)    def get_restaurants_in_city(city):        return restaurants_in_city.get(city, set())    def get_cities_of_restaurant(restaurant):        return cities_of_restaurant.get(restaurant, set())Relativity's most basic data structure is a many-to-manymapping ``M2M``.  ``M2M`` is a systematic abstraction overassociating every key with a set of values, and everyvalue with a set of keys.  See how ``M2M`` simplifiesthe problem:.. code-block:: python    restaurant_city_m2m = M2M()    for restaurant in restaurants:        for location in restaurant.locations:            restaurant_city_m2m.add(restaurant, location.city)    get_restaurants_in_city = restaurant_city_m2m.inv.get    get_cities_of_restaurant = restaurant_city_m2m.getRecall that the advantages of having single-index hashmapswere shorter code, with fewer long lived data structuresand fewer local values.  ``M2M`` doesn't replace ``dict``any more than ``dict`` replaces ``list``.  Rather it isa new layer of abstraction that can greatly simplifya broad class of problems.Is it possible to go further?  Are there higher levelsof abstraction that can represent more complex relationshipsin fewer data structures, and be manipulated with fewerlines of code and intermediate values?M2M to M2MGraph'''''''''''''''Where relativity really shines is releiving the programmerof the burden of keeping data structures consistent with updates.Let's consider our restaurant example if we need to be ableto add and remove locations one at a time and still be ableto query.With ``M2M`` objects, the problem is doable, but fiddly toimplement:.. code-block:: python    restaurant_location = M2M()    location_city = M2M()    def add_location(location):        restaurant_location.add(location.restaurant, location)        location_city.add(location, location.city)    def remove_location(location):        del location_city[location]        del restaurant_location.inv[location]    def restaurants_in_city(city):        restaurants = set()        for location in location_city.inv[city]:            for restaurant in restaurant_location.inv[location]:                restaurants.add(restaurant)        return restaurants    def cities_of_restaurant(restaurant):        cities = set()        for location in restaurant_location[restaurant]:            for city in location_city[location]:                cities.add(city)        return citiesThis problem can be simplified by stepping up a level ofabstraction.Where ``M2M`` is a data structure of keys and values, ``M2MGraph``is a higher-level data structure of ``M2M`` s.With ``M2MGraph``, this problem becomes simple andintuitive:.. code-block:: python    data = M2MGraph([('restaurant', 'location'), ('location', 'city')])    def add_location(location):        data['restaurant', 'location', 'city'].add(            location.restaurant, location, location.city)    def remove_location(location):        data.remove('location', location)    def restaurants_in_city(city):        return data.pairs('city', 'restaurant').get(city)    def cities_of_restaurant(restaurant):        return data.pairs('restaurant', 'city').get(restaurant)Introducing Chain'''''''''''''''''Graphs are good for representing arbitrary sets of data, but theyare awkward to query overy.  ``M2MChain``s sequences of ``M2M``s, wherethe keys of ``M2M`` n are meant to be drawn from the same poolas the values of ``M2M`` n - 1.A simple way to construct a chain is with the ``chain`` helper function... code-block:: python    students2classes = M2M([        ('alice', 'math'),        ('alice', 'english'),        ('bob', 'english'),        ('carol', 'math'),        ('doug', 'chemistry')])    classmates = chain(students2clases, students2classes.inv)By chaining the student:class map to itself, we can easilyquery which students have classes together... code-block:: python    &gt;&gt;&gt; classmates.only('alice')    M2MChain([M2M([('alice', 'math'), ('alice', 'english')]), M2M([('math', 'carol'), ('math', 'alice'), ('english', 'bob'), ('english', 'alice')])])    &gt;&gt;&gt; classmates.only('alice').m2ms[1]    M2M([('math', 'carol'), ('math', 'alice'), ('english', 'bob'), ('english', 'alice')])    &gt;&gt;&gt; classmates.only('alice').m2ms[1].inv.keys()    ['bob', 'carol', 'alice']Relativity and DataBases------------------------Relativity is excellent at representing many-to-many relationshipsfrom databases which are otherwise awkward to handle.M2M + ORM'''''''''Let's consider an example from Django to start... code-block:: python    from django.db import models    class Student(models.model):        name = models.StringField()    class Course(models.model):        name = models.StringField()        students = models.ManyToMany(Student)Students take many courses, and each course has many students.Construting an ``M2M`` over these relationships is very natural:.. code-block:: python    from relativity import M2M    StudentCourse = Course.students.through    enrollments = M2M(        StudentCourse.objects.all().values_list('student', 'course'))Design Philosophy-----------------DB Feature Sets'''''''''''''''A typical SQL database, such as PostGres, MySQL, SQLServer, Oracle, or DB2offers many features which can be split into four categories:- relational data model and queries- network protocol and multiple concurrent connections- transactions, atomic updates, and MVCC_- persistent storage, backups, and read replicasLet's call these &quot;relational&quot;, &quot;network&quot;, &quot;transactional&quot;,and &quot;persistence&quot; feature sets... _MVCC: https://en.wikipedia.org/wiki/Multiversion_concurrency_control&quot;Alternative&quot; Databases'''''''''''''''''''''''The most widely used alternative is probably SQLite_.  SQLitehas relational, transactional, and persistence feature sets but does not havea network protocol.  Instead it must be embedded_as a library inside another application.Another example is the venerable ZODB_.  ZODB hasnetwork, transactional, and persistence feature setsbut replaces the relational data modelwith an object data model.As an extreme example of how less can be more, memcached_ hasonly network features.  Data is stored ephemerally in the form of opaque blobs withoutany data model.  There is no atomicity of updates: there is no way to ensure thattwo writes either both succeed or both fail.The so-called &quot;NoSQL&quot; databases (cassandra_, couchdb_, mongodb_, etc)generally provide network and persistence features but lack a relational data modeland transactionality... _embedded: https://docs.python.org/3/library/sqlite3.html.. _SQLite: https://www.sqlite.org/.. _ZODB: http://www.zodb.org/en/latest/.. _memcached: https://memcached.org/.. _cassandra: http://cassandra.apache.org/.. _couchdb: http://couchdb.apache.org/.. _mongodb: https://www.mongodb.com/Relativity: Relational à la carte'''''''''''''''''''''''''''''''''In this design space, Relativity offers a relational feature set and nothing else.Relativity allows you to build in-memory data structures that represent relationshipsamong arbitrary Python objects and then execute queries over those objects andrelationships via a very natural and pythonic API.=============  ====================  SQL            Relativity-------------  --------------------result-set     sets and M2Msjoin           chain and attachorder by       sort and sortedwhere-clause   list comprehension=============  ====================Architecture------------The fundamental unit of Relativity is the *relation*, in the form ofthe ``M2M``.  All other data structures arevarious types of ``M2M`` containers.  An ``M2M`` is a very simpledata structure that can be represented as two dicts:.. code-block:: python    {key: set(vals)}    {val: set(keys)}The main job of the ``M2M`` is to broadcast changes to theunderlying ``dict`` and ``set`` instances such that they are kept insync, and to enumerate all of the key, val pairs.Similarly, the higher order data structures --``M2MGraph``, ``M2MChain``, and ``M2MStar`` -- broadcast changes tounderlying ``M2M`` s and can return and enumerate them.``M2MChain`` and ``M2MStar``: rows of relations'''''''''''''''''''''''''''''''''''''''''''''''``M2MChain`` and ``M2MStar`` are implemented as thin wrappers over a ``list``of ``M2M``.  The main feature they bring provide &quot;row-iteration&quot;.  The differencebetween them is how they defined a row.  ``M2MChain`` represents relationshipsthat connect end-to-end.  ``M2MStar`` represents relationships that allpoint to the same base object, similar to a `star schema`_... _star schema: https://en.wikipedia.org/wiki/Star_schemaShared ``M2M`` s''''''''''''''''All of the higher order data structures are concerned with the structurebetween and among ``M2M`` s.  The contents within a particular ``M2M`` doesnot need to maintain any invariants.  That is, if all of the ``M2M`` s withinone of the higher order data structures were scrambled up, the higher orderdata structure would still be valid.(Contrast with, if you were to scramblethe key sets and val sets around within an ``M2M``, it would be totallyinconsistent.)This has important consequences, because it means that various instancesof ``M2MGraph``, ``M2MChain``, and ``M2MStar`` may *share* their underlying``M2M`` s, and continue to update them.  This means that all of these higherorder data structures can be treated as cheap and ephemeral.For example, ``M2MGraph.chain(*cols)`` will construct and return a new``M2MChain`` over the ``M2M`` s linking the passed columns.  All thatactually happens here is the ``M2MGraph`` is queried for the underlying``M2M`` s, then the list of ``M2M`` s is passed to the ``M2MChain``constructor which simply holds a reference to them.Another way to think of ``M2MGraph``, ``M2MChain`` and ``M2MStar`` isas cheap views over the underlying ``M2M`` s.  No matter how much data is inthe underlying ``M2M`` s, assembling one of these higher order data structuresover top has a fixed, low cost.Relativity &amp; Python Ecosystem-----------------------------Pandas_'''''''Both Relativity and Pandas enable clean extraction of data from a SQL databaseto an in-memory data structure which may be further processed.  Both librariesprovide data structures that can easily express queries over the in-memorydata-set that would otherwise be very difficult and tempt a developer to goback to the database multiple times.This sounds like Relativity and Pandas should be in competition; but, in practicethey are complementary.  Whereas Pandas is excellent at representing tabulardata in rows and columns, Relativity excels at representing the foreign keyrelationships that connect rows in different tables.  Pandas makes it easyto take a SQL result set and further refine it by filtering rows and adddingcolumns.  Relativity makes it easy to extract the foreign key relationshipsamong many tables and further refine them by filtering by connectedness andadding additional relationships... _Pandas: http://pandas.pydata.org/pandas-docs/stable/getting_started/overview.htmlWhen to Use&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;Use Pandas_ for doing analysis of data within rows of a table; useRelativity for doing analysis of the relationships between rows ofdifferent tables.Coming back to the students-and-classes example:.. code-block:: python    class Enrollment(models.Model):         student = models.ForeignKey(Student)         class = models.ForeignKey(Class)         grade = models.FloatField()  # 0.0 - 5.0    # Pandas is great at determining each students GPA    enrollments_data_frame.group_by(['student']).mean()Better Together&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;At a low-level, a Pandas_ ``Series`` and a Relaitivity ``M2M`` canboth represent multiple values per key, so it is easy to convertbetween the two... code-block:: python    &gt;&gt;&gt; import pandas    &gt;&gt;&gt; import relativity    &gt;&gt;&gt; s = pandas.Series(data=[1, 2, 2], index=['a', 'a', 'b'])    &gt;&gt;&gt; s    a    1    a    2    b    2    dtype: int64    &gt;&gt;&gt; m2m = relativity.M2M(s.items())    &gt;&gt;&gt; m2m    M2M([('a', 1L), ('a', 2L), ('b', 2L)])    &gt;&gt;&gt; keys, vals = zip(*m2m.iteritems())    &gt;&gt;&gt; s2 = pandas.Series(data=vals, index=keys)    &gt;&gt;&gt; s2    a    1    a    2    b    2    dtype: int64NetworkX_'''''''''NetworkX_ is the &quot;graph theory library&quot; of Python:&quot;NetworkX is a Python package for the creation, manipulation,and study of the structure, dynamics, and functions of complex networks.&quot;NetworkX_ is great at representing arbitrarily connections among a groupof nodes.  Relativity has relationship-centric APIs and data-structures,wehere the ``M2M`` represents a single relationship, and ``M2MChain``,``M2MStar``, and ``M2MGraph`` build higher order connections.  Underneath, both are backed by ``dict``... _NetworkX: https://networkx.github.io/</longdescription>
</pkgmetadata>