<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://lancetnik.github.io/Propan/&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://lancetnik.github.io/Propan/assets/img/logo-no-background.png&quot; alt=&quot;Propan logo&quot; style=&quot;height: 250px; width: 600px;&quot;/&gt;    &lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://github.com/Lancetnik/Propan/actions/workflows/tests.yml&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://github.com/Lancetnik/Propan/actions/workflows/tests.yml/badge.svg&quot; alt=&quot;Tests coverage&quot;/&gt;    &lt;/a&gt;    &lt;a href=&quot;https://coverage-badge.samuelcolvin.workers.dev/redirect/lancetnik/propan&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://coverage-badge.samuelcolvin.workers.dev/lancetnik/propan.svg&quot; alt=&quot;Coverage&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://pypi.org/project/propan&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://img.shields.io/pypi/v/propan?label=pypi%20package&quot; alt=&quot;Package version&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://pepy.tech/project/propan&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://static.pepy.tech/personalized-badge/propan?period=total&amp;units=international_system&amp;left_color=grey&amp;right_color=blue&amp;left_text=Downloads&quot; alt=&quot;downloads&quot;/&gt;    &lt;/a&gt;    &lt;br/&gt;    &lt;a href=&quot;https://pypi.org/project/propan&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://img.shields.io/pypi/pyversions/propan.svg&quot; alt=&quot;Supported Python versions&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://github.com/Lancetnik/Propan/blob/main/LICENSE&quot; target=&quot;_blank&quot;&gt;        &lt;img alt=&quot;GitHub&quot; src=&quot;https://img.shields.io/github/license/Lancetnik/Propan?color=%23007ec6&quot;&gt;    &lt;/a&gt;&lt;/p&gt;# Propan**Propan** - just *~~an another one HTTP~~* a **declarative Python MQ framework**. It's following by &lt;a href=&quot;https://fastapi.tiangolo.com/ru/&quot; target=&quot;_blank&quot;&gt;*fastapi*&lt;/a&gt;, simplify Message Brokers around code writing and provides a helpful development toolkit, which existed only in HTTP-frameworks world until now.It's designed to create reactive microservices around &lt;a href=&quot;https://microservices.io/patterns/communication-style/messaging.html&quot; target=&quot;_blank&quot;&gt;Messaging Architecture&lt;/a&gt;.It is a modern, high-level framework on top of popular specific Python brokers libraries, based on &lt;a href=&quot;https://docs.pydantic.dev/&quot; target=&quot;_blank&quot;&gt;*pydantic*&lt;/a&gt; and &lt;a href=&quot;https://fastapi.tiangolo.com/ru/&quot; target=&quot;_blank&quot;&gt;*fastapi*&lt;/a&gt;, &lt;a href=&quot;https://docs.pytest.org/en/latest/&quot; target=&quot;_blank&quot;&gt;*pytest*&lt;/a&gt; concepts.---**Documentation**: &lt;a href=&quot;https://lancetnik.github.io/Propan/&quot; target=&quot;_blank&quot;&gt;https://lancetnik.github.io/Propan/&lt;/a&gt;---### The key features are* **Simple**: Designed to be easy to use and learn.* **Intuitive**: Great editor support. Autocompletion everywhere.* [**Dependencies management**](#dependencies): Minimization of code duplication. Access to dependencies at any level of the call stack.* [**Integrations**](#http-frameworks-integrations): **Propan** is fully compatible with &lt;a href=&quot;https://lancetnik.github.io/Propan/integrations/1_integrations-index/&quot; target=&quot;_blank&quot;&gt;any HTTP framework&lt;/a&gt; you want* **MQ independent**: Single interface to popular MQ:  * **Redis** (based on &lt;a href=&quot;https://redis.readthedocs.io/en/stable/index.html&quot; target=&quot;_blank&quot;&gt;redis-py&lt;/a&gt;)  * **RabbitMQ** (based on &lt;a href=&quot;https://aio-pika.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot;&gt;aio-pika&lt;/a&gt;)  * **Kafka** (based on &lt;a href=&quot;https://aiokafka.readthedocs.io/en/stable/&quot; target=&quot;_blank&quot;&gt;aiokafka&lt;/a&gt;)  * **SQS** (based on &lt;a href=&quot;https://aiobotocore.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot;&gt;aiobotocore&lt;/a&gt;)  * **Nats** (based on &lt;a href=&quot;https://github.com/nats-io/nats.py&quot; target=&quot;_blank&quot;&gt;nats-py&lt;/a&gt;)* &lt;a href=&quot;https://lancetnik.github.io/Propan/getting_started/4_broker/5_rpc/&quot; target=&quot;_blank&quot;&gt;**RPC**&lt;/a&gt;: The framework supports RPC requests over MQ, which will allow performing long operations on remote services asynchronously.* [**Great to develop**](#cli-power): CLI tool provides great development experience:  * framework-independent way to manage the project environment  * application code *hot reload*  * robust application templates* &lt;a href=&quot;https://lancetnik.github.io/Propan/getting_started/7_testing&quot; target=&quot;_blank&quot;&gt;**Testability**&lt;/a&gt;: **Propan** allows you to test your app without external dependencies: you do not have to set up a Message Broker, you can use a virtual one!### Supported MQ brokers|                   | async                                                   | sync                 ||-------------------|:-------------------------------------------------------:|:--------------------:|| **RabbitMQ**      | :heavy_check_mark: **stable** :heavy_check_mark:        | :mag: planning :mag: || **Redis**         | :heavy_check_mark: **stable** :heavy_check_mark:        | :mag: planning :mag: || **Nats**          | :heavy_check_mark: **stable** :heavy_check_mark:        | :mag: planning :mag: || **Kafka**         | :warning: **beta** :warning:                            | :mag: planning :mag: || **SQS**           | :warning: **beta** :warning:                            | :mag: planning :mag: || **NatsJS**        | :hammer_and_wrench: **in progress** :hammer_and_wrench: | :mag: planning :mag: || **MQTT**          | :mag: planning :mag:                                    | :mag: planning :mag: || **Redis Streams** | :mag: planning :mag:                                    | :mag: planning :mag: || **Pulsar**        | :mag: planning :mag:                                    | :mag: planning :mag: |### CommunityIf you are interested in this project, please give me feedback by star or/and watch repository.If you have any questions or ideas about features to implement, welcome to [discussions](https://github.com/Lancetnik/Propan/discussions).---## Declarative?With declarative tools you can define **what you need to get**. With traditional imperative tools you must write **what you need to do**.Take a look at classic imperative tools, such as &lt;a href=&quot;https://aio-pika.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot;&gt;aio-pika&lt;/a&gt;, &lt;a href=&quot;https://pika.readthedocs.io/en/stable/&quot; target=&quot;_blank&quot;&gt;pika&lt;/a&gt;, &lt;a href=&quot;https://redis.readthedocs.io/en/stable/index.html&quot; target=&quot;_blank&quot;&gt;redis-py&lt;/a&gt;, &lt;a href=&quot;https://github.com/nats-io/nats.py&quot; target=&quot;_blank&quot;&gt;nats-py&lt;/a&gt;, etc.This is the **Quickstart** with the *aio-pika*:```pythonimport asyncioimport aio_pikaasync def main():    connection = await aio_pika.connect_robust(        &quot;amqp://guest:guest@127.0.0.1/&quot;    )    queue_name = &quot;test_queue&quot;    async with connection:        channel = await connection.channel()        queue = await channel.declare_queue(queue_name)        async with queue.iterator() as queue_iter:            async for message in queue_iter:                async with message.process():                    print(message.body)asyncio.run(main())```**aio-pika** is a great tool with a really easy learning curve. But it's still imperative. You need to *connect*, declare *channel*, *queues*, *exchanges* by yourself. Also, you need to manage *connection*, *message*, *queue* context to avoid any troubles.It is not a bad way, but it can be much easier.```pythonfrom propan import PropanApp, RabbitBrokerbroker = RabbitBroker(&quot;amqp://guest:guest@localhost:5672/&quot;)app = PropanApp(broker)@broker.handle(&quot;test_queue&quot;)async def base_handler(body):    print(body)```This is the **Propan** declarative way to write the same code. That is so much easier, isn't it?---## QuickstartInstall using `pip`:```shellpip install &quot;propan[async-rabbit]&quot;# orpip install &quot;propan[async-nats]&quot;# orpip install &quot;propan[async-redis]&quot;# orpip install &quot;propan[async-kafka]&quot;# orpip install &quot;propan[async-sqs]&quot;```### Basic usageCreate an application with the following code at `serve.py`:```pythonfrom propan import PropanAppfrom propan import RabbitBroker# from propan import RedisBroker# from propan import NatsBroker# from propan import SQSBroker# from propan import KafkaBrokerbroker = RabbitBroker(&quot;amqp://guest:guest@localhost:5672/&quot;)# broker = NatsBroker(&quot;nats://localhost:4222&quot;)# broker = RedisBroker(&quot;redis://localhost:6379&quot;)# broker = SQSBroker(&quot;http://localhost:9324&quot;, ...)# broker = KafkaBroker(&quot;localhost:9092&quot;)app = PropanApp(broker)@broker.handle(&quot;test&quot;)async def base_handler(body):    '''Handle all default exchange messages with `test` routing key'''    print(body)```And just run it:```shellpropan run serve:app```---## Type castingPropan uses `pydantic` to cast incoming function arguments to types according to their annotation.```pythonfrom pydantic import BaseModelfrom propan import PropanApp, Context, RabbitBrokerbroker = RabbitBroker(&quot;amqp://guest:guest@localhost:5672/&quot;)app = PropanApp(broker)class SimpleMessage(BaseModel):    key: int@broker.handle(&quot;test2&quot;)async def second_handler(body: SimpleMessage):    assert isinstance(body.key, int)```---## Dependencies**Propan** a has dependencies management policy close to `pytest fixtures`.You can specify in functions arguments which dependenciesyou would to use. Framework passes them from the global Context object.Already existed context fields are: *app*, *broker*, *context* (itself), *logger* and *message*.If you call not existing field, raises *pydantic.ValidationError* value.But you can specify your own dependencies, call dependencies functions (like `Fastapi Depends`)and [more](https://github.com/Lancetnik/Propan/tree/main/examples/dependencies).```pythonimport aio_pikafrom propan import PropanApp, RabbitBroker, Context, Dependsrabbit_broker = RabbitBroker(&quot;amqp://guest:guest@localhost:5672/&quot;)app = PropanApp(rabbit_broker)async def dependency(body: dict) -&gt; bool:    return True@rabbit_broker.handle(&quot;test&quot;)async def base_handler(body: dict,                       dep: bool = Depends(dependency),                       broker: RabbitBroker = Context()):    assert dep is True    assert broker is rabbit_broker```---## CLI power**Propan** has its own CLI tool that provided the following features:* project generation* multiprocessing workers* project hot reloading* custom command line arguments passing### Context passingFor example: pass your current *.env* project setting to context```bashpropan run serve:app --env=.env.dev``````pythonfrom propan import PropanApp, RabbitBrokerfrom propan.annotations import ContextRepofrom pydantic import BaseSettingsbroker = RabbitBroker(&quot;amqp://guest:guest@localhost:5672/&quot;)app = PropanApp(broker)class Settings(BaseSettings):    ...@app.on_startupasync def setup(env: str, context: ContextRepo):    settings = Settings(_env_file=env)    context.set_global(&quot;settings&quot;, settings)```### Project templateAlso, **Propan CLI** is able to generate a production-ready application template:```bashpropan create async rabbit [projectname]```*Notice: project template require* `pydantic[dotenv]` *installation.*Run the created project:```bash# Run rabbimq firstdocker compose --file [projectname]/docker-compose.yaml up -d# Run projectpropan run [projectname].app.serve:app --env=.env --reload```Now you can enjoy a new development experience!---## HTTP Frameworks integrations### Any FrameworkYou can use **Propan** `MQBrokers` without `PropanApp`.Just *start* and *stop* them according to your application lifespan.```pythonfrom propan import NatsBrokerfrom sanic import Sanicapp = Sanic(&quot;MyHelloWorldApp&quot;)broker = NatsBroker(&quot;nats://localhost:4222&quot;)@broker.handle(&quot;test&quot;)async def base_handler(body):    print(body)@app.after_server_startasync def start_broker(app, loop):    await broker.start()@app.after_server_stopasync def stop_broker(app, loop):    await broker.close()```### FastAPI PluginAlso, **Propan** can be used as part of **FastAPI**.Just import a **PropanRouter** you need and declare the message handlerusing the `@event` decorator. This decorator is similar to the decorator `@handle` for the corresponding brokers.```pythonfrom fastapi import Depends, FastAPIfrom pydantic import BaseModelfrom propan.fastapi import RabbitRouterapp = FastAPI()router = RabbitRouter(&quot;amqp://guest:guest@localhost:5672&quot;)class Incoming(BaseModel):    m: dictdef call():    return True@router.event(&quot;test&quot;)async def hello(m: Incoming, d = Depends(call)) -&gt; dict:    return { &quot;response&quot;: &quot;Hello, Propan!&quot; }app.include_router(router)```## ExamplesTo see more framework usages go to [**examples/**](https://github.com/Lancetnik/Propan/tree/main/examples)</longdescription>
</pkgmetadata>