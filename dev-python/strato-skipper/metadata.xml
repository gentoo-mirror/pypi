<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Actions Status](https://github.com/Stratoscale/skipper/workflows/build/badge.svg)](https://github.com/Stratoscale/skipper/actions)# Skipper## IntroductionUse Skipper to build &amp; test your project in an isolated environment, using Docker containers with pre-defined sane configuration.Skipper allows you to execute makefile targets inside a container (or just run arbitrary commands). You can also use Skipper to build your development and production containers.## InstallationIt is recommended to install Skipper directly from PyPi:```bashsudo pip install strato-skipper```You can also install Skipper from source:``` bash git clone http://github.com/Stratoscale/skippersudo make install```Configure bash completion for skipper by sourcing the completion script in your ~/.bashrc file:``` bashecho 'source &lt;(skipper completion)' &gt;&gt;~/.bashrc```## Python3 EnvironmentSkipper supports building and running in Python3 environmentSet your locale to UTF-8:```bashexport LC_ALL=&quot;en_US.UTF-8&quot;export LANG=&quot;en_US.UTF-8&quot;```## UsageSkipper can serve as your primary tool for your daily development tasks:* Use `skipper build` to build the images defined by the Dockerfiles in your repository. All the images will be automatically tagged with the *COMMIT_ID*.* Use `skipper push` to publish your images.* Use `skipper images` to list your images.* Use `skipper rmi` to delete your images.* Use `skipper make` to execute makefile targets inside a container.* Use `skipper run` to run arbitrary commands inside a container.* Use `skipper shell` to get an interactive shell inside a container.### Global Options```bash  -v, --verbose                 Increase verbosity  --registry                    URL of the docker registry  --build-container-image       Image to use as build container  --build-container-tag         Tag of the build container  --build-container-net         Network to connect the build container (default: net=host)  --env-file                    Environment variables file/s to pass to the container  --help                        Show this message and exit.```### BuildAs a convention, skipper infers the docker images from the Dockerfiles in the top directory of your repository. For example, assuming that there are 3 Dockerfile in the top directory of the repository:```Dockerfile.service1Dockerfile.service2Dockerfile.development```To build the image that corresponeds to `Dockerfile.service1`, run:```bashskipper build service1```In the same way you can build the image corresponded to `Dockerfile.development`:```bashskipper build development```You can also build mutliple images with single command:```bashskipper build development service2```A context path can be added to the build command, The build’s context is the files at a specified location PATH, the default is current directory:```bashskipper buid service1 --container-context /path/to/context/dir```If no image is specifed skipper will build all detected images:```bashskipper build```If you don't want to store all the Dockerfiles under the top directory of the project, you can specify the project's containers in skipper's config file (see below).### PushOnce you've built the images of your repositories as described above. You can publish them by pushing them to the registry.To push the `service1` image, run:```bashskipper --registry some-registry push service1```Note that the registry in this command must be the same registry used while building the image.### ImagesTo list local images of your repository, run:```bashskipper images```In order to also list also images that were pushed to the registry, run:```bashskipper --registry some-registry images -r```### RmiTo delete an image of your repository, run:```bashskipper rmi service1 &lt;tag&gt;```In order to delete the image from the registry, run:```bashskipper --registry some-registry rmi -r service1 &lt;tag&gt;```### MakeYou can execute a Makefile target inside a container. This is good for keeping the development in an isolated environment, without installing development tools on the host. Once a development container is defined and built, it can be shared among the team member, assuring all of them use exactly thg same development environment.Assuming your project has a Makefile with a `tests` target, you can run:```bashskipper --registry some-registry --build-container-image development --build-container-tag latest \make tests```If your Makefile is not standard (i.e. `Makefile.arm32`) you can pass it to the make command:```bashskipper --registry some-registry --build-container-image development --build-container-tag latest \make -f Makefile.arm32 tests```### RunYou can also run arbitrary commands inside your containers. ```bashskipper --registry some-registry --build-container-image development --build-container-tag latest \run gcc myprog.c -o myprog ```### ShellYou can get a shell inside your containers. ```bashskipper --registry some-registry --build-container-image development --build-container-tag latest \shell```## Configuration FileSkipper allows you to define commonly used parameters in a configuration file `skipper.yaml` at the top directory of your repositry.```yamlregistry: some-registry build-container-image: developmentbuild-container-tag: latestcontainer-context: /path/to/context/dirmake:     makefile: Makefile.arm32containers:    service1: path/to/service1/dockerfile    service2: path/to/service2/dockerfileenv:    VAR: valueenv_file: path/to/env_file.env```Using the above configuration file, we now can run a simplified version of the make command described above:```bashskipper make tests```### Published portsFor `shell`, `run` &amp; `make` commands:  By default, when you run skipper on a linux machine it will use the host network and no mapping required.  For macos and windows machines where the host network is unsupported or for a custom network, you can publish a port and make it available to services outside of the container using the --publish or -p flag. ````skipper make -p 123:123 testsskipper make -p 123-130:123-130 tests````### Environment variables:For `shell`, `run` &amp; `make` commands:You can use `-e` in order to pass environment variables to the container.````skipper make -e regex=test1 tests````Your configuration file can contain environment variables, Skipper will set the specified environment variables in the container.````env:    VAR: value````You can add an environment variables file (or multiple files) using `--env-file`.This file should use the syntax &lt;key&gt;=value (which sets the variable to the given value) or &lt;key&gt; (which takes the value from the local environment), and # for comments.The variables defined in this file will be exported to the container.Such file can look like this:````$ cat env_file.env# This is a commentKEY1=value1KEY2=value2KEY3    ````Skipper configuration file can include the environment variables file:````env_file:     - /path/to/env_file1.env    - /path/to/env_file2.env````### Variable substitution:Skipper uses the variable values from the shell environment in which skipper is run.It’s possible to use environment variables in your shell to populate valuesFor example, suppose the shell contains EXTERNAL_PORT=5000 and you supply this configuration:````env:    EXTERNAL_PORT: $EXTERNAL_PORT````When you run Skipper command with this configuration, Skipper looks for the EXTERNAL_PORT environment variable in the shell and substitutes its value in.In this example, Skipper resolves the `$EXTERNAL_PORT` to &quot;5000&quot; and will set EXTERNAL_PORT=5000 environment in the container.If an environment variable is not set, Skipper substitutes with an empty string.Both `$VARIABLE` and `${VARIABLE}` syntax are supported. Extended shell-style features, such as `${VARIABLE-default}` and `${VARIABLE/foo/bar}`, are not supported.You can use a `$$` (double-dollar sign) when your configuration needs a literal dollar sign. This also prevents Skipper from interpolating a value, so a `$$` allows you to refer to environment variables that you don’t want processed by Skipper.````env:    VAR: $$VAR_NOT_INTERPOLATED````### Shell InterpolationSkipper supports evaluating shell commands inside its configuration file using `$(command)` notation.e.g.```yamlenv:    VAR: $(expr ${MY_NUMBER:-5} + 5)volumes:    - $(which myprogram):/myprogram```### Volumes:Skipper can bind-mount a host directory into the container.you can add volumes in the configuration file:````volumes:  - /tmp:/tmp:rw  - ${HOME}/.netrc:/root/.netrc  - ${HOME}/.gocache:/tmp/.gocache````### Workdir:Skipper default to the the project directory as the working directory for the `run`, `make` and `shell` commands,you can override the workdir by specifying it in the configuration file:````workdir: /path/to/workdir````### Workspace:Skipper default to the the project base directory (e.g. /path/to/project/../) as the workspace for the `run`, `make` and `shell` commands,Note that the workspace directory is mounted by default.you can override the workspace directory by specifying it in the configuration file````workdir: $PWD````### Skipper environment variablesSkipper sets environemnt variables to inform the user about the underline system:CONTAINER_RUNTIME_COMMAND - The container conmmand used to run the skipper container. podman/docker</longdescription>
</pkgmetadata>