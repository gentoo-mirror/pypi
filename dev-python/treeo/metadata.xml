<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Treeo _A small library for creating and manipulating custom JAX Pytree classes_* **Light-weight**: has no dependencies other than `jax`.* **Compatible**: Treeo `Tree` objects are compatible with any `jax` function that accepts Pytrees.* **Standards-based**: `treeo.field` is built on top of python's `dataclasses.field`.* **Flexible**: Treeo is compatible with both dataclass and non-dataclass classes.Treeo lets you easily create class-based Pytrees so your custom objects can easily interact seamlessly with JAX. Uses of Treeo can range from just creating simple simple JAX-aware utility classes to using it as the core abstraction for full-blown frameworks. Treeo was originally extracted from the core of [Treex](https://github.com/cgarciae/treex) and shares a lot in common with [flax.struct](https://flax.readthedocs.io/en/latest/flax.struct.html#module-flax.struct).[Documentation](https://cgarciae.github.io/treeo) | [User Guide](https://cgarciae.github.io/treeo/user-guide/intro)## InstallationInstall using pip:```bashpip install treeo```## BasicsWith Treeo you can easily define your own custom Pytree classes by inheriting from Treeo's `Tree` class and using the `field` function to declare which fields are nodes (children) and which are static (metadata):```pythonimport treeo as to@dataclassclass Person(to.Tree):    height: jnp.array = to.field(node=True) # I am a node field!    name: str = to.field(node=False) # I am a static field!````field` is just a wrapper around `dataclasses.field` so you can define your Pytrees as dataclasses, but Treeo fully supports non-dataclass classes as well. Since all `Tree` instances are Pytree they work with the various functions from the`jax` library as expected:```pythonp = Person(height=jnp.array(1.8), name=&quot;John&quot;)# Trees can be jitted!jax.jit(lambda person: person)(p) # Person(height=array(1.8), name='John')# Trees can be mapped!jax.tree_map(lambda x: 2 * x, p) # Person(height=array(3.6), name='John')```#### KindsTreeo also include a kind system that lets you give semantic meaning to fields (what a field represents within your application). A kind is just a type you pass to `field` via its `kind` argument: ```pythonclass Parameter: passclass BatchStat: passclass BatchNorm(to.Tree):    scale: jnp.ndarray = to.field(node=True, kind=Parameter)    mean: jnp.ndarray = to.field(node=True, kind=BatchStat)```Kinds are very useful as a filtering mechanism via [treeo.filter](https://cgarciae.github.io/treeo/user-guide/api/filter):```python model = BatchNorm(...)# select only Parameters, mean is filtered outparams = to.filter(model, Parameter) # BatchNorm(scale=array(...), mean=Nothing)````Nothing` behaves like `None` in Python, but it is a special value that is used to represent the absence of a value within Treeo.Treeo also offers the [merge](https://cgarciae.github.io/treeo/user-guide/api/merge) function which lets you rejoin filtered Trees with a logic similar to Python `dict.update` but done recursively:```python hl_lines=&quot;3&quot;def loss_fn(params, model, ...):    # add traced params to model    model = to.merge(model, params)    ...# gradient only w.r.t. paramsparams = to.filter(model, Parameter) # BatchNorm(scale=array(...), mean=Nothing)grads = jax.grad(loss_fn)(params, model, ...)```For a more in-depth tour check out the [User Guide](https://cgarciae.github.io/treeo/user-guide/intro).## Examples### A simple Tree```pythonfrom dataclasses import dataclassimport treeo as to@dataclassclass Character(to.Tree):    position: jnp.ndarray = to.field(node=True)    # node field    name: str = to.field(node=False, opaque=True)  # static fieldcharacter = Character(position=jnp.array([0, 0]), name='Adam')# character can freely pass through jit@jax.jitdef update(character: Character, velocity, dt) -&gt; Character:    character.position += velocity * dt    return charactercharacter = update(character velocity=jnp.array([1.0, 0.2]), dt=0.1)```### A Stateful Tree```pythonfrom dataclasses import dataclassimport treeo as to@dataclassclass Counter(to.Tree):    n: jnp.array = to.field(default=jnp.array(0), node=True) # node    step: int = to.field(default=1, node=False) # static    def inc(self):        self.n += self.stepcounter = Counter(step=2) # Counter(n=jnp.array(0), step=2)@jax.jitdef update(counter: Counter):    counter.inc()    return countercounter = update(counter) # Counter(n=jnp.array(2), step=2)# map over the tree```### Full Example - Linear Regression```pythonimport jaximport jax.numpy as jnpimport matplotlib.pyplot as pltimport numpy as npimport treeo as toclass Linear(to.Tree):    w: jnp.ndarray = to.node()    b: jnp.ndarray = to.node()    def __init__(self, din, dout, key):        self.w = jax.random.uniform(key, shape=(din, dout))        self.b = jnp.zeros(shape=(dout,))    def __call__(self, x):        return jnp.dot(x, self.w) + self.b@jax.value_and_graddef loss_fn(model, x, y):    y_pred = model(x)    loss = jnp.mean((y_pred - y) ** 2)    return lossdef sgd(param, grad):    return param - 0.1 * grad@jax.jitdef train_step(model, x, y):    loss, grads = loss_fn(model, x, y)    model = jax.tree_map(sgd, model, grads)    return loss, modelx = np.random.uniform(size=(500, 1))y = 1.4 * x - 0.3 + np.random.normal(scale=0.1, size=(500, 1))key = jax.random.PRNGKey(0)model = Linear(1, 1, key=key)for step in range(1000):    loss, model = train_step(model, x, y)    if step % 100 == 0:        print(f&quot;loss: {loss:.4f}&quot;)X_test = np.linspace(x.min(), x.max(), 100)[:, None]y_pred = model(X_test)plt.scatter(x, y, c=&quot;k&quot;, label=&quot;data&quot;)plt.plot(X_test, y_pred, c=&quot;b&quot;, linewidth=2, label=&quot;prediction&quot;)plt.legend()plt.show()```</longdescription>
</pkgmetadata>