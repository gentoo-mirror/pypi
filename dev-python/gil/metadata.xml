<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Gil (git links) tool[![Linux (clang)](https://github.com/chronoxor/gil/actions/workflows/build-linux-clang.yml/badge.svg)](https://github.com/chronoxor/gil/actions/workflows/build-linux-clang.yml)[![Linux (gcc)](https://github.com/chronoxor/gil/actions/workflows/build-linux-gcc.yml/badge.svg)](https://github.com/chronoxor/gil/actions/workflows/build-linux-gcc.yml)&lt;br/&gt;[![MacOS](https://github.com/chronoxor/gil/actions/workflows/build-macos.yml/badge.svg)](https://github.com/chronoxor/gil/actions/workflows/build-macos.yml)&lt;br/&gt;[![Windows (Cygwin)](https://github.com/chronoxor/gil/actions/workflows/build-windows-cygwin.yml/badge.svg)](https://github.com/chronoxor/gil/actions/workflows/build-windows-cygwin.yml)[![Windows (MSYS2)](https://github.com/chronoxor/gil/actions/workflows/build-windows-msys2.yml/badge.svg)](https://github.com/chronoxor/gil/actions/workflows/build-windows-msys2.yml)[![Windows (MinGW)](https://github.com/chronoxor/gil/actions/workflows/build-windows-mingw.yml/badge.svg)](https://github.com/chronoxor/gil/actions/workflows/build-windows-mingw.yml)[![Windows (Visual Studio)](https://github.com/chronoxor/gil/actions/workflows/build-windows-vs.yml/badge.svg)](https://github.com/chronoxor/gil/actions/workflows/build-windows-vs.yml)Gil is a git links tool to manage complex git repositories dependencies withcycles and cross references.This tool provides a solution to the [git recursive submodules dependency problem](https://github.com/chronoxor/gil#recursive-submodules-problem).# Contents  * [Requirements](#requirements)  * [Setup](#setup)  * [Sample](#sample)  * [Usage](#usage)  * [Motivation: git submodules vs git links](#motivation-git-submodules-vs-git-links)    * [Git submodules management](#git-submodules-management)    * [Recursive submodules problem](#recursive-submodules-problem)  * [Motivation: git subtrees vs git links](#motivation-git-subtrees-vs-git-links)    * [Git subtrees management](#git-subtrees-management)    * [Subtrees manual management problem](#subtrees-manual-management-problem)# Requirements* Linux* MacOS* Windows* [git](https://git-scm.com)* [python3](https://www.python.org)# Setup```shellsudo pip3 install --prefix /usr/local gil```# SampleConsider we have the following git repository dependency graph:![gil sample](https://github.com/chronoxor/gil/raw/master/images/sample.png)Where:* Blue nodes are third-party components* Green nodes are components that we develop* Edges show components dependency with a branch### Root .gitlinks fileIn order to describe the sample model with git links we have to define root.gitlinks file in your sample repository with a following content:```shell# ProjectsCppBenchmark CppBenchmark https://github.com/chronoxor/CppBenchmark.git masterCppCommon CppCommon https://github.com/chronoxor/CppCommon.git masterCppLogging CppLogging https://github.com/chronoxor/CppLogging.git master# ModulesCatch2 modules/Catch2 https://github.com/catchorg/Catch2.git mastercpp-optparse modules/cpp-optparse https://github.com/weisslj/cpp-optparse.git masterfmt modules/fmt https://github.com/fmtlib/fmt.git masterHdrHistogram modules/HdrHistogram https://github.com/HdrHistogram/HdrHistogram_c.git masterzlib modules/zlib https://github.com/madler/zlib.git master# Scriptsbuild scripts/build https://github.com/chronoxor/CppBuildScripts.git mastercmake scripts/cmake https://github.com/chronoxor/CppCMakeScripts.git master```Each line describe git link in the following format:1. Unique name of the repository2. Relative path of the repository (started from the path of .gitlinks file)3. Git repository which will be used in `git clone` command4. Repository branch to checkout5. (Optional) Relative path in the base repository6. (Optional) Relative path in the target repositoryEmpty line or line started with `#` are not parsed (treated as comment).### CppBenchmark .gitlinks fileCppBenchmark .gitlinks file should be committed into the CppBenchmark projectand have the following content:```shell# ModulesCatch2 modules/Catch2 https://github.com/catchorg/Catch2.git mastercpp-optparse modules/cpp-optparse https://github.com/weisslj/cpp-optparse.git masterHdrHistogram modules/HdrHistogram https://github.com/HdrHistogram/HdrHistogram_c.git masterzlib modules/zlib https://github.com/madler/zlib.git master# Scriptsbuild build https://github.com/chronoxor/CppBuildScripts.git mastercmake cmake https://github.com/chronoxor/CppCMakeScripts.git master```### CppCommon .gitlinks fileCppCommon .gitlinks file should be committed into the CppCommon project andhave the following content:```shell# ModulesCatch2 modules/Catch2 https://github.com/catchorg/Catch2.git masterCppBenchmark modules/CppBenchmark https://github.com/chronoxor/CppBenchmark.git masterfmt modules/fmt https://github.com/fmtlib/fmt.git master# Scriptsbuild build https://github.com/chronoxor/CppBuildScripts.git mastercmake cmake https://github.com/chronoxor/CppCMakeScripts.git master```### CppLogging .gitlinks fileCppLogging .gitlinks file should be committed into the CppLogging project andhave the following content:```shell# ModulesCatch2 modules/Catch2 https://github.com/catchorg/Catch2.git mastercpp-optparse modules/cpp-optparse https://github.com/weisslj/cpp-optparse.git masterCppBenchmark modules/CppBenchmark https://github.com/chronoxor/CppBenchmark.git masterCppCommon modules/CppCommon https://github.com/chronoxor/CppCommon.git masterzlib modules/zlib https://github.com/madler/zlib.git master# Scriptsbuild build https://github.com/chronoxor/CppBuildScripts.git mastercmake cmake https://github.com/chronoxor/CppCMakeScripts.git master```### Update the repositoryFinally you have to update your root sample repository:```shell# Clone and link all git links dependencies from .gitlinks filegil clonegil link# The same result with a single commandgil update```As the result you'll clone all required projects and link them to each otherin a proper way:```shellWorking path: ~/gil/sample...Updating git links: ~/gil/sample/.gitlinksUpdating git links: ~/gil/sample/CppBenchmark/.gitlinksUpdate git link: ~/gil/sample/modules/Catch2 -&gt; ~/gil/sample/CppBenchmark/modules/Catch2Update git link: ~/gil/sample/modules/cpp-optparse -&gt; ~/gil/sample/CppBenchmark/modules/cpp-optparseUpdate git link: ~/gil/sample/modules/HdrHistogram -&gt; ~/gil/sample/CppBenchmark/modules/HdrHistogramUpdate git link: ~/gil/sample/modules/zlib -&gt; ~/gil/sample/CppBenchmark/modules/zlibUpdate git link: ~/gil/sample/scripts/build -&gt; ~/gil/sample/CppBenchmark/buildUpdate git link: ~/gil/sample/scripts/cmake -&gt; ~/gil/sample/CppBenchmark/cmakeUpdating git links: ~/gil/sample/CppCommon/.gitlinksUpdate git link: ~/gil/sample/modules/Catch2 -&gt; ~/gil/sample/CppCommon/modules/Catch2Update git link: ~/gil/sample/CppBenchmark -&gt; ~/gil/sample/CppCommon/modules/CppBenchmarkUpdate git link: ~/gil/sample/modules/fmt -&gt; ~/gil/sample/CppCommon/modules/fmtUpdate git link: ~/gil/sample/scripts/build -&gt; ~/gil/sample/CppCommon/buildUpdate git link: ~/gil/sample/scripts/cmake -&gt; ~/gil/sample/CppCommon/cmakeUpdating git links: ~/gil/sample/CppLogging/.gitlinksUpdate git link: ~/gil/sample/modules/Catch2 -&gt; ~/gil/sample/CppLogging/modules/Catch2Update git link: ~/gil/sample/modules/cpp-optparse -&gt; ~/gil/sample/CppLogging/modules/cpp-optparseUpdate git link: ~/gil/sample/CppBenchmark -&gt; ~/gil/sample/CppLogging/modules/CppBenchmarkUpdate git link: ~/gil/sample/CppCommon -&gt; ~/gil/sample/CppLogging/modules/CppCommonUpdate git link: ~/gil/sample/modules/zlib -&gt; ~/gil/sample/CppLogging/modules/zlibUpdate git link: ~/gil/sample/scripts/build -&gt; ~/gil/sample/CppLogging/buildUpdate git link: ~/gil/sample/scripts/cmake -&gt; ~/gil/sample/CppLogging/cmake```All repositories will be checkout to required branches.If content of any .gitlinks changes it is required to run `gil update` commandto re-update git links - new repositories will be cloned and linked properly!### Commit, push, pullYou can work and change any files in your repositories and perform all gitoperations for any repository to commit and contribute your changes.If you want to commit all changes in some repository with all changes inchild linked repositories you can do it with a single command:```shellgil commit -a -m &quot;Some big update&quot;```This command will visit the current and all child repositories and performthe corresponding `git commit` command with provided arguments.Please note that gil command visit only child repositories that are describedin .gitlinks file no parent dependencies will be processed. For this reasonif you want to commit, pull or push all repositories the corresponding commandshould be run in the root directory where root .gitlinks is placed.Pull, push commands works in a similar way:```shellgil pullgil push```### BuildPlease investigate and follow links in the sample repository in order tounderstand the logic how gil (git links) tool manages dependencies.Finally you can build sample projects with provided build scripts:* `~/gil/sample/CppBenchmark/build`* `~/gil/sample/CppCommon/build`* `~/gil/sample/CppLogging/build`Additionally each module can be cloned and successfully build without rootrepository. In this case local .gitlinks file will be used to resolve alldependencies!# UsageGil (git links) tool supports the following commands:```usage: gil command argumentsSupported commands:        help - show this help        version - show version        context - show git links context        clone [args] - clone git repositories        link - link git repositories        update - update git repositories (clone &amp; link)        pull [args] - pull git repositories        push [args] - push git repositories        commit [args] - commit git repositories        status [args] - show status of git repositories```* `gil context` - command will show the current git link context of the current directory;* `gil clone [args]` - clone all repositories that are missed in the current context;* `gil link` - link all repositories that are missed in the current context;* `gil update` - clone and link in a single operation;* `gil pull [args]` - pull all repositories in the current directory;* `gil push [args]` - push all repositories in the current directory;* `gil commit [args]` - commit all repositories in the current directory;* `gil status [args]` - show status of all repositories in the current directory;# Motivation: git submodules vs git linksGit submodules allow to get the same idea of repositories dependency, but witha serious limitation - git submodules degrade to tree-like recursive structurewith repositories duplication.## Git submodules managementGit submodules provides several operations to manage repositories dependency.### Add submodule dependency```shell# Add git submodule of 'master' branch into the relative directory 'modules/zlib'git submodule add -b master https://github.com/madler/zlib.git modules/zlib```### Initialize submodules```shell# Update all submodules in the current repositorygit submodule update --init --recursive --remote```### Refresh submodules from remote repositories```shellgit pullgit submodule update --init --recursive --remotegit pull --recurse-submodulesgit submodule foreach &quot;(git checkout master; git pull)&quot;```### Synchronize submodules with remote repositories```shellgit pullgit submodule update --init --recursive --remotegit pull --recurse-submodulesgit submodule foreach &quot;(git checkout master; git pull)&quot;git add --allgit commit -m &quot;Submodule Sync&quot;git push```### Remove submodule dependency```shell# Remove git submodule from the relative directory 'modules/zlib'git submodule deinit -f -- modules/zlibrm -rf .git/modules/modules/zlibgit rm -f modules/zlib```## Recursive submodules problemGit submodules representation of the described sample repository is thefollowing:```shell~/gil/sample/CppBenchmark~/gil/sample/CppBenchmark/build~/gil/sample/CppBenchmark/cmake~/gil/sample/CppBenchmark/modules/Catch2~/gil/sample/CppBenchmark/modules/cpp-optparse~/gil/sample/CppBenchmark/modules/HdrHistogram~/gil/sample/CppBenchmark/modules/zlib~/gil/sample/CppCommon~/gil/sample/CppCommon/build - DUPLICATE!~/gil/sample/CppCommon/cmake - DUPLICATE!~/gil/sample/CppCommon/modules/Catch2 - DUPLICATE!~/gil/sample/CppCommon/modules/CppBenchmark - DUPLICATE!~/gil/sample/CppCommon/modules/CppBenchmark/build - DUPLICATE!~/gil/sample/CppCommon/modules/CppBenchmark/cmake - DUPLICATE!~/gil/sample/CppCommon/modules/CppBenchmark/modules/Catch2 - DUPLICATE!~/gil/sample/CppCommon/modules/CppBenchmark/modules/cpp-optparse - DUPLICATE!~/gil/sample/CppCommon/modules/CppBenchmark/modules/HdrHistogram - DUPLICATE!~/gil/sample/CppCommon/modules/CppBenchmark/modules/zlib - DUPLICATE!~/gil/sample/CppCommon/modules/fmt~/gil/sample/CppLogging~/gil/sample/CppLogging/build - DUPLICATE!~/gil/sample/CppLogging/cmake - DUPLICATE!~/gil/sample/CppLogging/modules/Catch2 - DUPLICATE!~/gil/sample/CppLogging/modules/cpp-optparse - DUPLICATE!~/gil/sample/CppLogging/modules/CppBenchmark - DUPLICATE!~/gil/sample/CppLogging/modules/CppBenchmark/build - DUPLICATE!~/gil/sample/CppLogging/modules/CppBenchmark/cmake - DUPLICATE!~/gil/sample/CppLogging/modules/CppBenchmark/modules/Catch2 - DUPLICATE!~/gil/sample/CppLogging/modules/CppBenchmark/modules/cpp-optparse - DUPLICATE!~/gil/sample/CppLogging/modules/CppBenchmark/modules/HdrHistogram - DUPLICATE!~/gil/sample/CppLogging/modules/CppBenchmark/modules/zlib - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon/build - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon/cmake - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon/modules/Catch2 - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon/modules/CppBenchmark - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon/modules/CppBenchmark/build - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon/modules/CppBenchmark/cmake - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon/modules/CppBenchmark/modules/Catch2 - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon/modules/CppBenchmark/modules/cpp-optparse - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon/modules/CppBenchmark/modules/HdrHistogram - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon/modules/CppBenchmark/modules/zlib - DUPLICATE!~/gil/sample/CppLogging/modules/zlib - DUPLICATE!```Only 10 of 41 repositories are unique. Other duplicates each other multipletimes. Moreover some nested repositories included recursively! CppLoggingproject has the third level of nesting (`CppLogging -&gt; CppCommon -&gt; CppBenchmark`).Each new level heavily increases the rate of duplication. As the result allsubmodule management operations becomes slow and requires multiple executionsof synchronize script to pass changes from top level to the bottom. The countof synchronizations in the worst case equals to recursive levels count.All this issues are solved with gil (git links) tool which allows to link allrequired repositories together avoiding duplication. The tool also providesoperations to manage changes in all repositories with a [simple easy to usecommands](https://github.com/chronoxor/gil#usage).# Motivation: git subtrees vs git linksGit subtrees is an easy to use alternative to git submodules. It allows to nestone repository inside another as a sub-directory.From the one side git subtrees are very lightweight with simple workflow. Theydon't add any metadata files like git submodule does (i.e., .gitmodule) andsub-project's code is available right after the clone of the super project isdone. Contents of the module can be modified without having a separaterepository copy of the dependency somewhere else.However they have several drawbacks. Contributing code back upstream for thesub-projects is slightly more complicated. And developer should be very carefulof not mixing super and sub-project code in commits.Git subtrees requires precise manual management in case use have complicatedprojects structure and lots of upstream commits to dependent projects.## Git subtrees managementGit subtrees provides several operations to manage repositories dependency.### Add subtree dependency```shell# Add git subtree of 'master' branch into the relative directory 'modules/zlib'git subtree add -P modules/zlib https://github.com/madler/zlib.git master --squash```### Update subtree from the upstream remote repository```shellgit subtree pull -P modules/zlib https://github.com/madler/zlib.git master --squash```### Contribute changes from subtree back to the upstream remote repository```shellgit subtree push -P modules/zlib https://github.com/madler/zlib.git master```### Remove subtree dependency```shell# Remove git subtree from the relative directory 'modules/zlib'git rm -f modules/zlib```## Subtrees manual management problemInitially git subtrees lack of the same [repository duplicate problem](#recursive-submodules-problem)which git submodules have. Therefore all repositories with multiple dependencieswill be duplicated and require manual and careful management.For instance `CppBenchmark` repository presented four times in our [sample](#sample):```shell~/gil/sample/CppBenchmark~/gil/sample/CppCommon/modules/CppBenchmark - DUPLICATE!~/gil/sample/CppLogging/modules/CppBenchmark - DUPLICATE!~/gil/sample/CppLogging/modules/CppCommon/modules/CppBenchmark - DUPLICATE!```The first problem if you updated `CppBenchmark` and want to get the fix in alldependent repositories you have to update them manually with the set of`git subtree pull` commands:```shell# Commit and push changes in CppBenchmark repositorycd CppBenchmarkgit commit -a -m &quot;Bugfix in CppBenchmark&quot;git pushcd ..# Update CppCommon repositorycd CppCommongit subtree pull --prefix modules/CppBenchmark https://github.com/chronoxor/test-CppBenchmark.git main --squashgit pushcd ..# Update CppLogging repositorycd CppLogginggit subtree pull --prefix modules/CppBenchmark https://github.com/chronoxor/test-CppBenchmark.git main --squashgit subtree pull --prefix modules/CppCommon https://github.com/chronoxor/test-CppCommon.git main --squashgit pushcd ..```The second problem if you found a bug in `CppBenchmark` while debugging`CppLogging` and want to fix it in place, push the changes and update allrepositories properly. In this case you need to make the following steps:```shell# Commit and push changes in CppBenchmark but from CppLogging repositorycd CppLogginggit commit -a -m &quot;Bugfix in CppBenchmark (found in CppLogging repository)&quot;git pushgit subtree push --prefix modules/CppBenchmark https://github.com/chronoxor/test-CppBenchmark.git main --squashcd ..# Update CppBenchmark repositorycd CppBenchmarkgit pullcd ..# Update CppCommon repositorycd CppCommongit subtree pull --prefix modules/CppBenchmark https://github.com/chronoxor/test-CppBenchmark.git main --squashgit pushcd ..# Update CppLogging repositorycd CppLogginggit subtree pull --prefix modules/CppBenchmark https://github.com/chronoxor/test-CppBenchmark.git main --squashgit subtree pull --prefix modules/CppCommon https://github.com/chronoxor/test-CppCommon.git main --squashgit pushcd ..```As the result too much manual work should be done to make all repositories upto date. Definitely all commands should be stored into scripts with care. Andthis job requires some efforts and testing because it is very easy to make amistake. Git subtrees are good and easy to use for small repositories withoutcomplicated hierarchy. But working with huge complicated repositories usinggit subtrees is a big challenge as git subtrees do not suppot recursingpull/push/update commands.</longdescription>
</pkgmetadata>