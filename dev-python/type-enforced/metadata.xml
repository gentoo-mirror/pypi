<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Type Enforced[![PyPI version](https://badge.fury.io/py/type_enforced.svg)](https://badge.fury.io/py/type_enforced)[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)Enforce types in python functions# SetupMake sure you have Python 3.6.x (or higher) installed on your system. You can download it [here](https://www.python.org/downloads/).### Installation```pip install type_enforced```# Getting Started`type_enforcer` contains a basic `Enforcer` wrapper that can be used to enforce most basic python typing hints. [Technical Docs Here](https://connor-makowski.github.io/type_enforced/enforcer.html).`type_enforcer` currently supports all single level python types, single level class instances and classes themselves. For example, you can force an input to be an `int` or an instance of the self defined `MyClass`, but not a vector of the format `list(int)`. In this case, when using `type_enforcer`, you would only pass the format `list` and would not validate that the content of the list was indeed integers.You can pass multiple types in brackets to validate one of multiple types. For example, you could validate an input was an int or a float with `[int, float]`.Non specified types for variables are not enforced.Input and return typing are both supported.## Basic Usage```pyimport type_enforced@type_enforced.Enforcerdef my_fn(a: int , b: [int, str] =2, c: int =3) -&gt; None:    pass```## Interactive Example```py&gt;&gt;&gt; import type_enforced&gt;&gt;&gt; @type_enforced.Enforcer... def my_fn(a: int , b: [int, str] =2, c: int =3) -&gt; None:...     pass...&gt;&gt;&gt; my_fn(a=1, b=2, c=3)&gt;&gt;&gt; my_fn(a=1, b='2', c=3)&gt;&gt;&gt; my_fn(a='a', b=2, c=3)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;/home/conmak/development/personal/type_enforced/type_enforced/enforcer.py&quot;, line 85, in __call__    self.__check_type__(assigned_vars.get(key), value, key)  File &quot;/home/conmak/development/personal/type_enforced/type_enforced/enforcer.py&quot;, line 107, in __check_type__    self.__exception__(  File &quot;/home/conmak/development/personal/type_enforced/type_enforced/enforcer.py&quot;, line 34, in __exception__    raise TypeError(f&quot;({self.__fn__.__qualname__}): {message}&quot;)TypeError: (my_fn): Type mismatch for typed variable `a`. Expected one of the following `[&lt;class 'int'&gt;]` but got `&lt;class 'str'&gt;` instead.```## Class and Method UseType enforcer can be applied to methods individually:```pyimport type_enforcedclass my_class:    @type_enforced.Enforcer    def my_fn(self, b:int):        pass```You can also enforce all typing for all methods in a class by decorating the class itself.```pyimport type_enforced@type_enforced.Enforcerclass my_class:    def my_fn(self, b:int):        pass    def my_other_fn(self, a: int, b: [int, str]):      pass```You can also enforce types on `staticmethod`s and `classmethod`s if you are using `python &gt;= 3.10`. If you are using a python version less than this, `classmethod`s and `staticmethod`s methods will not have their types enforced.```pyimport type_enforced@type_enforced.Enforcerclass my_class:    @classmethod    def my_fn(self, b:int):        pass    @staticmethod    def my_other_fn(a: int, b: [int, str]):      pass```## Validate class instances and classesType enforcer can enforce class instances and classes easily. There are a few caveats between the two.To enforce a class instance, simply pass the class itself as a type hint:```pyimport type_enforcedclass Foo():    def __init__(self) -&gt; None:        pass@type_enforced.Enforcerclass my_class():    def __init__(self, object: Foo) -&gt; None:        self.object = objectx=my_class(Foo()) # Works great!y=my_class(Foo) # Fails!```Notice how an initialized class instance `Foo()` must be passed for the enforcer to not raise an exception.To enforce an uninitialized class object use `typing.Type[classHere]` on the class to enforce inputs to be an uninitialized class:```pyimport type_enforcedimport typingclass Foo():    def __init__(self) -&gt; None:        pass@type_enforced.Enforcerclass my_class():    def __init__(self, object_class: typing.Type[Foo]) -&gt; None:        self.object = object_class()y=my_class(Foo) # Works great!x=my_class(Foo()) # Fails```</longdescription>
</pkgmetadata>