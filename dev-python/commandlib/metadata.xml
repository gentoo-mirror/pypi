<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>CommandLib==========CommandLib is a pythonic wrapper around subprocess that lets you pass around command objectsand daisy-chain:* Arguments* Paths* Other environment variables* Runtime directory* Other runtime properties (run in shell, conceal stdout/stderr, ignore error codes, etc.)It is somewhat inspired by amoffat's sh, Kenneth Reitz's requests, jaraco's path.pyand SQLAlchemy.To install:.. code-block:: sh    $ pip install commandlibExample:.. code-block:: python    &gt;&gt;&gt; from commandlib import Command    &gt;&gt;&gt; ls = Command(&quot;ls&quot;)    &gt;&gt;&gt; ls(&quot;-t&quot;).in_dir(&quot;/&quot;).with_shell().run()    sys  tmp  run  dev  proc  etc  boot  sbin  root  vmlinuz  initrd.img  bin  lib  opt  vmlinuz.old  initrd.img.old  media  home  cdrom  lost+found  var  srv  usr  mntCommandPath example:.. code-block:: python    &gt;&gt;&gt; from commandlib import CommandPath    &gt;&gt;&gt; bin = CommandPath(&quot;/bin&quot;)    &gt;&gt;&gt; bin.ls(&quot;-t&quot;).in_dir(&quot;/&quot;).run()    sys  tmp  run  dev  proc  etc  boot  sbin  root  vmlinuz  initrd.img  bin  lib  opt  vmlinuz.old  initrd.img.old  media  home  cdrom  lost+found  var  srv  usr  mntAPI---.. code-block:: python    &gt;&gt;&gt; from commandlib import Command, run    # Create command object    &gt;&gt;&gt; py = Command(&quot;/usr/bin/python&quot;)    # Run with *additional* environment variable PYTHONPATH (*added* to global environment when command is run)    &gt;&gt;&gt; py = py.with_env(PYTHONPATH=&quot;/home/user/pythondirectory&quot;)        # Run with additional path (appended to existing PATH environment variable when command is run)    &gt;&gt;&gt; py = py.with_path(&quot;/home/user/bin&quot;)    # Run in specified directory (default is current directory)    &gt;&gt;&gt; py = py.in_dir(&quot;/home/user/mydir&quot;)    # Run in shell    &gt;&gt;&gt; py = py.with_shell()    # Suppress stderr    &gt;&gt;&gt; py = py.silently() # Suppress stdout and stderr    # Finally run command explicitly with all of the above    &gt;&gt;&gt; run(py)    &gt;&gt;&gt; py.run() # alternative syntaxWhy?----Commandlib is a library to make it easier to pass around immutable (sort of) command objects between differentmodules and classes and incrementally modify the command's behavior in a readable way - adding environmentvariables, paths, etc.* call, check_call and Popen do not have the friendliest of APIs and code that uses them a lot can get ugly fast.* sh does a similar thing but has a lot of magic (e.g. overriding import).* envoy and sarge are more focused on chaining commands rather than arguments, environment variables, etc.Advanced API------------Add trailing arguments:.. code-block:: python    &gt;&gt;&gt; from commandlib import Command, run    &gt;&gt;&gt; manage = Command(&quot;/usr/bin/python&quot;, &quot;manage.py&quot;).with_trailing_arguments(&quot;--settings&quot;, &quot;local_settings.py&quot;).in_dir(&quot;projectdir&quot;)    &gt;&gt;&gt; run(manage(&quot;runserver&quot;))    [ Runs &quot;/usr/bin/python manage.py runserver --settings local_settings.py&quot; inside projectdir ]Dynamically generate command bundles from directories with executables in them:.. code-block:: python    &gt;&gt;&gt; from commandlib import CommandPath, Command, run    &gt;&gt;&gt; postgres94 = CommandPath(&quot;/usr/lib/postgresql/9.4/bin/&quot;)    &gt;&gt;&gt; run(postgres94.postgres)    [ Runs postgres ]    &gt;&gt;&gt; run(postgres94.createdb)    [ Runs createdb ]Use with path.py (or any other library where str(object) resolves to a string:.. code-block:: python    &gt;&gt;&gt; from path import Path    &gt;&gt;&gt; postgres94 = CommandPath(Path(&quot;/usr/lib/postgresql/9.4/bin/&quot;))    &gt;&gt;&gt; run(postgres94.postgres)</longdescription>
</pkgmetadata>