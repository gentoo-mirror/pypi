<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=========================Python iRODS Client (PRC)=========================`iRODS &lt;https://www.irods.org&gt;`_ is an open source distributed data management system. This is a client API implemented in Python.Currently supported:- Python 2.7, 3.4 or newer- Establish a connection to iRODS- Authenticate via password, GSI, PAM- iRODS connection over SSL- Implement basic GenQueries (select columns and filtering)- Support more advanced GenQueries with limits, offsets, and aggregations- Query the collections and data objects within a collection- Execute direct SQL queries- Execute iRODS rules- Support read, write, and seek operations for files- Parallel PUT/GET data objects- Create collections- Rename collections- Delete collections- Create data objects- Rename data objects- Checksum data objects- Delete data objects- Register files and directories- Query metadata for collections and data objects- Add, edit, remove metadata- Replicate data objects to different resource servers- Connection pool management- Implement GenQuery result sets as lazy queries- Return empty result sets when CAT_NO_ROWS_FOUND is raised- Manage permissions- Manage users and groups- Manage resources- Unicode strings- Ticket based accessInstalling----------PRC requires Python 2.7 or 3.4+.Canonically, to install with pip:: pip install python-irodsclientor:: pip install git+https://github.com/irods/python-irodsclient.git[@branch|@commit|@tag]Uninstalling------------:: pip uninstall python-irodsclientHazard: Outdated Python--------------------------With older versions of Python (as of this writing, the aforementioned 2.7 and 3.4), wecan take preparatory steps toward securing workable versions of pip and virtualenv byusing these commands::    $ pip install --upgrade --user pip'&lt;21.0'    $ python -m pip install --user virtualenvWe are then ready to use any of the following commands relevant to and required for theinstallation::    $ python -m virtualenv ...     $ python -m pip install ...Establishing a (secure) connection----------------------------------One way of starting a session is to pass iRODS credentials as keyword arguments:&gt;&gt;&gt; from irods.session import iRODSSession&gt;&gt;&gt; with iRODSSession(host='localhost', port=1247, user='bob', password='1234', zone='tempZone') as session:...     # workload...&gt;&gt;&gt;If you're an administrator acting on behalf of another user:&gt;&gt;&gt; from irods.session import iRODSSession&gt;&gt;&gt; with iRODSSession(host='localhost', port=1247, user='rods', password='1234', zone='tempZone',           client_user='bob', client_zone='possibly_another_zone') as session:...     # workload...&gt;&gt;&gt;If no ``client_zone`` is provided, the ``zone`` parameter is used in its place.Using environment files (including any SSL settings) in ``~/.irods/``:&gt;&gt;&gt; import os&gt;&gt;&gt; import ssl&gt;&gt;&gt; from irods.session import iRODSSession&gt;&gt;&gt; try:...     env_file = os.environ['IRODS_ENVIRONMENT_FILE']... except KeyError:...     env_file = os.path.expanduser('~/.irods/irods_environment.json')...&gt;&gt;&gt; ssl_settings = {} # Or, optionally: {'ssl_context': &lt;user_customized_SSLContext&gt;}&gt;&gt;&gt; with iRODSSession(irods_env_file=env_file, **ssl_settings) as session:...     # workload...&gt;&gt;&gt;In the above example, an SSL connection can be made even if no 'ssl_context' argument is specified,in which case the Python client internally generates its own SSLContext object to bestmatch the iRODS SSL configuration parameters (such as &quot;irods_ssl_ca_certificate_file&quot;,etc.) used to initialize the iRODSSession.  Those parameters can be given either in the environment file, or in the iRODSSession constructor call as shown by the next example.A pure Python SSL session (without a local `env_file`) requires a few more things defined:&gt;&gt;&gt; import ssl&gt;&gt;&gt; from irods.session import iRODSSession&gt;&gt;&gt; ssl_settings = {'client_server_negotiation': 'request_server_negotiation',...                'client_server_policy': 'CS_NEG_REQUIRE',...                'encryption_algorithm': 'AES-256-CBC',...                'encryption_key_size': 32,...                'encryption_num_hash_rounds': 16,...                'encryption_salt_size': 8,...                'ssl_context': ssl_context...                'ssl_verify_server': 'cert',...                'ssl_ca_certificate_file': '/etc/irods/ssl/irods.crt'... }If necessary, a user may provide a custom SSLContext object; although, as of release v1.1.6, this will rarely be required:&gt;&gt;&gt; ssl_settings ['ssl_context'] = ssl.create_default_context(purpose=ssl.Purpose.SERVER_AUTH, # ... other options... )At this point, we are ready to instantiate and use the session:&gt;&gt;&gt; with iRODSSession(host='irods-provider', port=1247, user='bob', password='1234', zone='tempZone', **ssl_settings) as session:...# workloadNote that the :code:`irods_` prefix is unnecessary when providing the :code:`encryption_*` and :code:`ssl_*` options directly to theconstructor as keyword arguments, even though it is required when they are placed in the environment file.Maintaining a connection------------------------The default library timeout for a connection to an iRODS Server is 120 seconds.This can be overridden by changing the session `connection_timeout` immediately after creation of the session object:&gt;&gt;&gt; session.connection_timeout = 300This will set the timeout to five minutes for any associated connections.Session objects and cleanup---------------------------When iRODSSession objects are kept as state in an application, spurious SYS_HEADER_READ_LEN_ERR errorscan sometimes be seen in the connected iRODS server's log file. This is frequently seen at program exitbecause socket connections are terminated without having been closed out by the session object's cleanup() method.Starting with PRC Release 0.9.0, code has been included in the session object's __del__ method to callcleanup(), properly closing out network connections.  However, __del__ cannot be relied to run under allcircumstances (Python2 being more problematic), so an alternative may be to call session.cleanup() onany session variable which might not be used again.Simple PUTs and GETs--------------------We can use the just-created session object to put files to (or get them from) iRODS.&gt;&gt;&gt; logical_path = &quot;/{0.zone}/home/{0.username}/{1}&quot;.format(session,&quot;myfile.dat&quot;)&gt;&gt;&gt; session.data_objects.put( &quot;myfile.dat&quot;, logical_path)&gt;&gt;&gt; session.data_objects.get( logical_path, &quot;/tmp/myfile.dat.copy&quot; )Note that local file paths may be relative, but iRODS data objects must always be referred to bytheir absolute paths.  This is in contrast to the ``iput`` and ``iget`` icommands, which keeptrack of the current working collection (as modified by ``icd``) for the unix shell.Parallel Transfer-----------------Starting with release 0.9.0, data object transfers using put() and get() will spawn a numberof threads in order to optimize performance for iRODS server versions 4.2.9+ and file sizeslarger than a default threshold value of 32 Megabytes.Working with collections------------------------&gt;&gt;&gt; coll = session.collections.get(&quot;/tempZone/home/rods&quot;)&gt;&gt;&gt; coll.id45798&gt;&gt;&gt; coll.path/tempZone/home/rods&gt;&gt;&gt; for col in coll.subcollections:&gt;&gt;&gt;   print(col)&lt;iRODSCollection /tempZone/home/rods/subcol1&gt;&lt;iRODSCollection /tempZone/home/rods/subcol2&gt;&gt;&gt;&gt; for obj in coll.data_objects:&gt;&gt;&gt;   print(obj)&lt;iRODSDataObject /tempZone/home/rods/file.txt&gt;&lt;iRODSDataObject /tempZone/home/rods/file2.txt&gt;Create a new collection:&gt;&gt;&gt; coll = session.collections.create(&quot;/tempZone/home/rods/testdir&quot;)&gt;&gt;&gt; coll.id45799Working with data objects (files)---------------------------------Create a new data object:&gt;&gt;&gt; obj = session.data_objects.create(&quot;/tempZone/home/rods/test1&quot;)&lt;iRODSDataObject /tempZone/home/rods/test1&gt;Get an existing data object:&gt;&gt;&gt; obj = session.data_objects.get(&quot;/tempZone/home/rods/test1&quot;)&gt;&gt;&gt; obj.id12345&gt;&gt;&gt; obj.nametest1&gt;&gt;&gt; obj.collection&lt;iRODSCollection /tempZone/home/rods&gt;&gt;&gt;&gt; for replica in obj.replicas:...     print(replica.resource_name)...     print(replica.number)...     print(replica.path)...     print(replica.status)...demoResc0/var/lib/irods/Vault/home/rods/test11Using the put() method rather than the create() method will trigger different policy enforcement points (PEPs) on the server.Put an existing file as a new data object:&gt;&gt;&gt; session.data_objects.put(&quot;test.txt&quot;,&quot;/tempZone/home/rods/test2&quot;)&gt;&gt;&gt; obj2 = session.data_objects.get(&quot;/tempZone/home/rods/test2&quot;)&gt;&gt;&gt; obj2.id56789Specifying paths----------------Path strings for collection and data objects are usually expected to be absolute in most contexts in the PRC. Theymust also be normalized to a form including single slashes separating path elements and no slashes at the string's end.If there is any doubt that a path string fulfills this requirement, the wrapper class :code:`irods.path.iRODSPath`(a subclass of :code:`str`) may be used to normalize it::    if not session.collections.exists( iRODSPath( potentially_unnormalized_path )): #....The wrapper serves also as a path joiner; thus::    iRODSPath( zone, &quot;home&quot;, user )may replace::    &quot;/&quot;.join([&quot;&quot;, zone, &quot;home&quot;, user]):code:`iRODSPath` is available beginning with PRC release :code:`v1.1.2`.Reading and writing files-------------------------PRC provides `file-like objects &lt;http://docs.python.org/2/library/stdtypes.html#file-objects) for reading and writing files&gt;`_&gt;&gt;&gt; obj = session.data_objects.get(&quot;/tempZone/home/rods/test1&quot;)&gt;&gt;&gt; with obj.open('r+') as f:...   f.write('foo\nbar\n')...   f.seek(0,0)...   for line in f:...      print(line)...foobarComputing and Retrieving Checksums----------------------------------Each data object may be associated with a checksum by calling chksum() on the object in question.  Variousbehaviors can be elicited by passing in combinations of keywords (for a description of which, please consult the`header documentation &lt;https://github.com/irods/irods/blob/4-2-stable/lib/api/include/dataObjChksum.h&gt;`_ .)As with most other iRODS APIs, it is straightforward to specify keywords by adding them to an option dictionary:&gt;&gt;&gt; data_object_1.chksum()  # - computes the checksum if already in the catalog, otherwise computes and stores it...                         #   (ie. default behavior with no keywords passed in.)&gt;&gt;&gt; from irods.manager.data_object_manager import Server_Checksum_Warning&gt;&gt;&gt; import irods.keywords as kw&gt;&gt;&gt; opts = { kw.VERIFY_CHKSUM_KW:'' }&gt;&gt;&gt; try:...     data_object_2.chksum( **opts )  # - Uses verification option. (Does not auto-vivify a checksum field)....     # or:...     opts[ kw.NO_COMPUTE_KW ] = ''...     data_object_2.chksum( **opts )  # - Uses both verification and no-compute options. (Like ichksum -K --no-compute)... except Server_Checksum_Warning:...     print('some checksums are missing or wrong')Additionally, if a freshly created irods.message.RErrorStack instance is given, information can be returned and read bythe client:&gt;&gt;&gt; from irods.message import RErrorStack&gt;&gt;&gt; r_err_stk = RErrorStack()&gt;&gt;&gt; warn = None&gt;&gt;&gt; try:  # Here, data_obj has one replica, not yet checksummed....     data_obj.chksum( r_error = r_err_stk , **{kw.VERIFY_CHKSUM_KW:''} )... except Server_Checksum_Warning as exc:...     warn = exc&gt;&gt;&gt; print(r_err_stk)[RError&lt;message = u'WARNING: No checksum available for replica [0].', status = -862000 CAT_NO_CHECKSUM_FOR_REPLICA&gt;]Working with metadata---------------------To enumerate AVU's on an object. With no metadata attached, the result is an empty list:&gt;&gt;&gt; from irods.meta import iRODSMeta&gt;&gt;&gt; obj = session.data_objects.get(&quot;/tempZone/home/rods/test1&quot;)&gt;&gt;&gt; print(obj.metadata.items())[]We then add some metadata.Just as with the icommand equivalent &quot;imeta add ...&quot;, we can add multiple AVU's with the same name field:&gt;&gt;&gt; obj.metadata.add('key1', 'value1', 'units1')&gt;&gt;&gt; obj.metadata.add('key1', 'value2')&gt;&gt;&gt; obj.metadata.add('key2', 'value3')&gt;&gt;&gt; obj.metadata.add('key2', 'value4')&gt;&gt;&gt; print(obj.metadata.items())[&lt;iRODSMeta 13182 key1 value1 units1&gt;, &lt;iRODSMeta 13185 key2 value4 None&gt;,&lt;iRODSMeta 13183 key1 value2 None&gt;, &lt;iRODSMeta 13184 key2 value3 None&gt;]We can also use Python's item indexing syntax to perform the equivalent of an &quot;imeta set ...&quot;, e.g. overwritingall AVU's with a name field of &quot;key2&quot; in a single update:&gt;&gt;&gt; new_meta = iRODSMeta('key2','value5','units2')&gt;&gt;&gt; obj.metadata[new_meta.name] = new_meta&gt;&gt;&gt; print(obj.metadata.items())[&lt;iRODSMeta 13182 key1 value1 units1&gt;, &lt;iRODSMeta 13183 key1 value2 None&gt;, &lt;iRODSMeta 13186 key2 value5 units2&gt;]Now, with only one AVU on the object with a name of &quot;key2&quot;, *get_one* is assured of not throwing an exception:&gt;&gt;&gt; print(obj.metadata.get_one('key2'))&lt;iRODSMeta 13186 key2 value5 units2&gt;However, the same is not true of &quot;key1&quot;:&gt;&gt;&gt; print(obj.metadata.get_one('key1'))Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;/[...]/python-irodsclient/irods/meta.py&quot;, line 41, in get_one    raise KeyErrorKeyErrorFinally, to remove a specific AVU from an object:&gt;&gt;&gt; obj.metadata.remove('key1', 'value1', 'units1')&gt;&gt;&gt; print(obj.metadata.items())[&lt;iRODSMeta 13186 key2 value5 units2&gt;, &lt;iRODSMeta 13183 key1 value2 None&gt;]Alternately, this form of the remove() method can also be useful:&gt;&gt;&gt; for avu in obj.metadata.items():...    obj.metadata.remove(avu)&gt;&gt;&gt; print(obj.metadata.items())[]If we intended on deleting the data object anyway, we could have just done this instead:&gt;&gt;&gt; obj.unlink(force=True)But notice that the force option is important, since a data object in the trash may still have AVU's attached.At the end of a long session of AVU add/manipulate/delete operations, one should make sure to delete all unusedAVU's. We can in fact use any *\*Meta* data model in the queries below, since unattached AVU's are not awareof the (type of) catalog object they once annotated:&gt;&gt;&gt; from irods.models import (DataObjectMeta, ResourceMeta)&gt;&gt;&gt; len(list( session.query(ResourceMeta) ))4&gt;&gt;&gt; from irods.test.helpers import remove_unused_metadata&gt;&gt;&gt; remove_unused_metadata(session)&gt;&gt;&gt; len(list( session.query(ResourceMeta) ))0When altering a fetched iRODSMeta, we must copy it first to avoid errors, due to the fact the referenceis cached by the iRODS object reference.  A shallow copy is sufficient:&gt;&gt;&gt; meta = album.metadata.items()[0]&gt;&gt;&gt; meta.units'quid'&gt;&gt;&gt; import copy; meta = copy.copy(meta); meta.units = 'pounds sterling'&gt;&gt;&gt; album.metadata[ meta.name ] = metaFortunately, as of PRC &gt;= 1.1.4, we can simply do this instead:&gt;&gt;&gt; album.metadata.set( meta )In versions of iRODS 4.2.12 and later, we can also do:&gt;&gt;&gt; album.metadata.set( meta, **{kw.ADMIN_KW: ''} )or even:&gt;&gt;&gt; album.metadata(admin = True)[meta.name] = metaIn v1.1.5, the &quot;timestamps&quot; keyword is provided to enable the loading of create and modify timestampsfor every AVU returned from the server:&gt;&gt;&gt; avus = album.metadata(timestamps = True).items()&gt;&gt;&gt; avus[0].create_timedatetime.datetime(2022, 9, 19, 15, 26, 7)Atomic operations on metadata-----------------------------With release 4.2.8 of iRODS, the atomic metadata API was introduced to allow a group of metadata add and removeoperations to be performed transactionally, within a single call to the server.  This capability can be leveraged inversion 0.8.6 of the PRC.So, for example, if 'obj' is a handle to an object in the iRODS catalog (whether a data object, collection, user orstorage resource), we can send an arbitrary number of AVUOperation instances to be executed together as one indivisibleoperation on that object:&gt;&gt;&gt; from irods.meta import iRODSMeta, AVUOperation&gt;&gt;&gt; obj.metadata.apply_atomic_operations( AVUOperation(operation='remove', avu=iRODSMeta('a1','v1','these_units')),...                                       AVUOperation(operation='add', avu=iRODSMeta('a2','v2','those_units')),...                                       AVUOperation(operation='remove', avu=iRODSMeta('a3','v3')) # , ...... )The list of operations will applied in the order given, so that a &quot;remove&quot; followed by an &quot;add&quot; of the same AVUis, in effect, a metadata &quot;set&quot; operation.  Also note that a &quot;remove&quot; operation will be ignored if the AVU value givendoes not exist on the target object at that point in the sequence of operations.We can also source from a pre-built list of AVUOperations using Python's `f(*args_list)` syntax. For example, thisfunction uses the atomic metadata API to very quickly remove all AVUs from an object:&gt;&gt;&gt; def remove_all_avus( Object ):...     avus_on_Object = Object.metadata.items()...     Object.metadata.apply_atomic_operations( *[AVUOperation(operation='remove', avu=i) for i in avus_on_Object] )Special Characters------------------Of course, it is fine to put Unicode characters into your collection and data object names.  However, certainnon-printable ASCII characters, and the backquote character as well, have historically presented problems -especially for clients using iRODS's human readable XML protocol.  Consider this small, only slighly contrived,application:::    from irods.test.helpers import make_session    def create_notes( session, obj_name, content = u'' ):        get_home_coll = lambda ses: &quot;/{0.zone}/home/{0.username}&quot;.format(ses)        path = get_home_coll(session) + &quot;/&quot; + obj_name        with session.data_objects.open(path,&quot;a&quot;) as f:            f.seek(0, 2) # SEEK_END            f.write(content.encode('utf8'))        return session.data_objects.get(path)    with make_session() as session:        # Example 1 : exception thrown when name has non-printable character        try:            create_notes( session, &quot;lucky\033.dat&quot;, content = u'test' )        except:            pass        # Example 2 (Ref. issue: irods/irods #4132, fixed for 4.2.9 release of iRODS)        print(            create_notes( session, &quot;Alice`s diary&quot;).name  # note diff (' != `) in printed name        )This creates two data objects, but with less than optimal success.  The first example objectis created but receives no content because an exception is thrown trying to query its name aftercreation.   In the second example, for iRODS 4.2.8 and before, a deficiency in packStruct XML protocol causesthe backtick to be read back as an apostrophe, which could create problems manipulating or deleting the object later.As of PRC v1.1.0, we can mitigate both problems by switching in the QUASI_XML parser for the default one:::    from irods.message import (XML_Parser_Type, ET)    ET( XML_Parser_Type.QUASI_XML, session.server_version )Two dedicated environment variables may also be used to customize the Python client's XML parsing behavior via thesetting of global defaults during start-up.For example, we can set the default parser to QUASI_XML, optimized for use with version 4.2.8 of the iRODS server,in the following manner:::    Bash-Shell&gt; export PYTHON_IRODSCLIENT_DEFAULT_XML=QUASI_XML PYTHON_IRODSCLIENT_QUASI_XML_SERVER_VERSION=4,2,8Other alternatives for PYTHON_IRODSCLIENT_DEFAULT_XML are &quot;STANDARD_XML&quot; and &quot;SECURE_XML&quot;.  These two latter optionsdenote use of the xml.etree and defusedxml modules, respectively.Only the choice of &quot;QUASI_XML&quot; is affected by the specification of a particular server version.Finally, note that these global defaults, once set, may be overridden on a per-thread basis using:code:`ET(parser_type, server_version)`.  We can also revert the current thread's XML parser back to theglobal default by calling :code:`ET(None)`.Rule Execution--------------A simple example of how to execute an iRODS rule from the Python client is as follows.  Suppose we have a rule file:code:`native1.r` which contains a rule in native iRODS Rule Language::  main() {      writeLine(&quot;*stream&quot;,                *X ++ &quot; squared is &quot; ++ str(double(*X)^2) )  }  INPUT *X=&quot;3&quot;, *stream=&quot;serverLog&quot;  OUTPUT nullThe following Python client code will run the rule and produce the appropriate output in theirods server log::  r = irods.rule.Rule( session, rule_file = 'native1.r')  r.execute()With release v1.1.1, not only can we target a specific rule engine instance by name (which is useful whenmore than one is present), but we can also use a file-like object for the :code:`rule_file` parameter::  Rule( session, rule_file = io.StringIO(u'''mainRule() { anotherRule(*x); writeLine('stdout',*x) }\n'''                                         u'''anotherRule(*OUT) {*OUT='hello world!'}\n\n'''                                         u'''OUTPUT ruleExecOut\n'''),        instance_name = 'irods_rule_engine_plugin-irods_rule_language-instance' )Incidentally, if we wanted to change the :code:`native1.r` rule code print to stdout also, we could set the:code:`INPUT` parameter, :code:`*stream`, using the Rule constructor's :code:`params` keyword argument.Similarly, we can change the :code:`OUTPUT` parameter from :code:`null` to :code:`ruleExecOut`, to accommodatethe output stream, via the :code:`output` argument::  r = irods.rule.Rule( session, rule_file = 'native1.r',             instance_name = 'irods_rule_engine_plugin-irods_rule_language-instance',             params={'*stream':'&quot;stdout&quot;'} , output = 'ruleExecOut' )  output = r.execute( )  if output and len(output.MsParam_PI):      buf = output.MsParam_PI[0].inOutStruct.stdoutBuf.buf      if buf: print(buf.rstrip(b'\0').decode('utf8'))(Changing the input value to be squared in this example is left as an exercise for the reader!)To deal with errors resulting from rule execution failure, two approaches can be taken. Suppose wehave defined this in the :code:`/etc/irods/core.re` rule-base::  rule_that_fails_with_error_code(*x) {    *y = (if (*x!=&quot;&quot;) then int(*x) else 0)  # if (SOME_PROCEDURE_GOES_WRONG) {      if (*y &lt; 0) { failmsg(*y,&quot;-- my error message --&quot;); }  #-&gt; throws an error code of int(*x) in REPF      else { fail(); }                                       #-&gt; throws FAIL_ACTION_ENCOUNTERED_ERR in REPF  # }  }We can run the rule thus:&gt;&gt;&gt; Rule( session, body='rule_that_fails_with_error_code(&quot;&quot;), instance_name = 'irods_rule_engine_plugin-irods_rule_language-instance',...     ).execute( r_error = (r_errs:= irods.message.RErrorStack()) )Where we've used the Python 3.8 &quot;walrus operator&quot; for brevity.  The error will automatically be caught and translated to areturned-error stack::  &gt;&gt;&gt; pprint.pprint([vars(r) for r in r_errs])  [{'raw_msg_': 'DEBUG: fail action encountered\n'                'line 14, col 15, rule base core\n'                '        else { fail(); }\n'                '               ^\n'                '\n',    'status_': -1220000}]Note, if a stringized negative integer is given , ie. as a special fail code to be thrown within the rule,we must add this code into a special parameter to have this automatically caught as well:&gt;&gt;&gt; Rule( session, body='rule_that_fails_with_error_code(&quot;-2&quot;)',instance_name = 'irods_rule_engine_plugin-irods_rule_language-instance'...     ).execute( acceptable_errors = ( FAIL_ACTION_ENCOUNTERED_ERR, -2),...                r_error = (r_errs := irods.message.RErrorStack()) )Because the rule is written to emit a custom error message via failmsg in this case, the resulting r_error stack will now include thatcustom error message as a substring::  &gt;&gt;&gt; pprint.pprint([vars(r) for r in r_errs])  [{'raw_msg_': 'DEBUG: -- my error message --\n'                'line 21, col 20, rule base core\n'                '      if (*y &lt; 0) { failmsg(*y,&quot;-- my error message --&quot;); }  '                '#-&gt; throws an error code of int(*x) in REPF\n'                '                    ^\n'                '\n',    'status_': -1220000}]Alternatively, or in combination with the automatic catching of errors, we may also catch errors as exceptions on the clientside.  For example, if the Python rule engine is configured, and the following rule is placed in :code:`/etc/irods/core.py`::  def python_rule(rule_args, callback, rei):  #   if some operation fails():          raise RuntimeErrorwe can trap the error thus::  try:      Rule( session, body = 'python_rule', instance_name = 'irods_rule_engine_plugin-python-instance' ).execute()  except irods.exception.RULE_ENGINE_ERROR:      print('Rule execution failed!')      exit(1)  print('Rule execution succeeded!')As fail actions from native rules are not thrown by default (refer to the help text for :code:`Rule.execute`), if weanticipate these and prefer to catch them as exceptions, we can do it this way::  try:      Rule( session, body = 'python_rule', instance_name = 'irods_rule_engine_plugin-python-instance'           ).execute( acceptable_errors = () )  except (irods.exception.RULE_ENGINE_ERROR,          irods.exception.FAIL_ACTION_ENCOUNTERED_ERR) as e:      print('Rule execution failed!')      exit(1)  print('Rule execution succeeded!')Finally,  keep in mind that rule code submitted through an :code:`irods.rule.Rule` object is processed by theexec_rule_text function in the targeted plugin instance.  This may be a limitation for plugins not equipped tohandle rule code in this way.  In a sort of middle-ground case, the iRODS Python Rule Engine Plugin is notcurrently able to handle simple rule calls and the manipulation of iRODS core primitives (like simple parameterpassing and variable expansion') as flexibly as the iRODS Rule Language.Also, core.py rules may not be run directly (as is also true with :code:`irule`) by other than a rodsadmin userpending the resolution of `this issue &lt;https://github.com/irods/irods_rule_engine_plugin_python/issues/105&gt;`_.General queries---------------&gt;&gt;&gt; import os&gt;&gt;&gt; from irods.session import iRODSSession&gt;&gt;&gt; from irods.models import Collection, DataObject&gt;&gt;&gt;&gt;&gt;&gt; env_file = os.path.expanduser('~/.irods/irods_environment.json')&gt;&gt;&gt; with iRODSSession(irods_env_file=env_file) as session:...     query = session.query(Collection.name, DataObject.id, DataObject.name, DataObject.size)......     for result in query:...             print('{}/{} id={} size={}'.format(result[Collection.name], result[DataObject.name], result[DataObject.id], result[DataObject.size])).../tempZone/home/rods/manager/access_manager.py id=212665 size=2164/tempZone/home/rods/manager/access_manager.pyc id=212668 size=2554/tempZone/home/rods/manager/collection_manager.py id=212663 size=4472/tempZone/home/rods/manager/collection_manager.pyc id=212664 size=4464/tempZone/home/rods/manager/data_object_manager.py id=212662 size=10291/tempZone/home/rods/manager/data_object_manager.pyc id=212667 size=8772/tempZone/home/rods/manager/__init__.py id=212670 size=79/tempZone/home/rods/manager/__init__.pyc id=212671 size=443/tempZone/home/rods/manager/metadata_manager.py id=212660 size=4263/tempZone/home/rods/manager/metadata_manager.pyc id=212659 size=4119/tempZone/home/rods/manager/resource_manager.py id=212666 size=5329/tempZone/home/rods/manager/resource_manager.pyc id=212661 size=4570/tempZone/home/rods/manager/user_manager.py id=212669 size=5509/tempZone/home/rods/manager/user_manager.pyc id=212658 size=5233Query using other models:&gt;&gt;&gt; from irods.column import Criterion&gt;&gt;&gt; from irods.models import DataObject, DataObjectMeta, Collection, CollectionMeta&gt;&gt;&gt; from irods.session import iRODSSession&gt;&gt;&gt; import os&gt;&gt;&gt; env_file = os.path.expanduser('~/.irods/irods_environment.json')&gt;&gt;&gt; with iRODSSession(irods_env_file=env_file) as session:...    # by metadata...    # equivalent to 'imeta qu -C type like Project'...    results = session.query(Collection, CollectionMeta).filter( \...        Criterion('=', CollectionMeta.name, 'type')).filter( \...        Criterion('like', CollectionMeta.value, '%Project%'))...    for r in results:...        print(r[Collection.name], r[CollectionMeta.name], r[CollectionMeta.value], r[CollectionMeta.units])...('/tempZone/home/rods', 'type', 'Project', None)Beginning with version 0.8.3 of PRC, the 'in' genquery operator is also available:&gt;&gt;&gt; from irods.models import Resource&gt;&gt;&gt; from irods.column import In&gt;&gt;&gt; [ resc[Resource.id]for resc in session.query(Resource).filter(In(Resource.name, ['thisResc','thatResc'])) ][10037,10038]Query with aggregation(min, max, sum, avg, count):&gt;&gt;&gt; with iRODSSession(irods_env_file=env_file) as session:...     query = session.query(DataObject.owner_name).count(DataObject.id).sum(DataObject.size)...     print(next(query.get_results())){&lt;irods.column.Column 411 D_OWNER_NAME&gt;: 'rods', &lt;irods.column.Column 407 DATA_SIZE&gt;: 62262, &lt;irods.column.Column 401 D_DATA_ID&gt;: 14}In this case since we are expecting only one row we can directly call ``query.execute()``:&gt;&gt;&gt; with iRODSSession(irods_env_file=env_file) as session:...     query = session.query(DataObject.owner_name).count(DataObject.id).sum(DataObject.size)...     print(query.execute())+--------------+-----------+-----------+| D_OWNER_NAME | D_DATA_ID | DATA_SIZE |+--------------+-----------+-----------+| rods         | 14        | 62262     |+--------------+-----------+-----------+Specific Queries----------------&gt;&gt;&gt; import os&gt;&gt;&gt; from irods.session import iRODSSession&gt;&gt;&gt; from irods.models import Collection, DataObject&gt;&gt;&gt; from irods.query import SpecificQuery&gt;&gt;&gt;&gt;&gt;&gt; env_file = os.path.expanduser('~/.irods/irods_environment.json')&gt;&gt;&gt; with iRODSSession(irods_env_file=env_file) as session:...     # define our query...     sql = &quot;select data_name, data_id from r_data_main join r_coll_main using (coll_id) where coll_name = '/tempZone/home/rods/manager'&quot;...     alias = 'list_data_name_id'...     columns = [DataObject.name, DataObject.id] # optional, if we want to get results by key...     query = SpecificQuery(session, sql, alias, columns)......     # register specific query in iCAT...     _ = query.register()......     for result in query:...             print('{} {}'.format(result[DataObject.name], result[DataObject.id]))......     # delete specific query...     _ = query.remove()...user_manager.pyc 212658metadata_manager.pyc 212659metadata_manager.py 212660resource_manager.pyc 212661data_object_manager.py 212662collection_manager.py 212663collection_manager.pyc 212664access_manager.py 212665resource_manager.py 212666data_object_manager.pyc 212667access_manager.pyc 212668user_manager.py 212669__init__.py 212670__init__.pyc 212671Recherché queries-----------------In some cases you might like to use a GenQuery operator not directly offered by thisPython library, or even combine query filters in ways GenQuery may not directly support.As an example, the code below finds metadata value fields lexicographically outside the rangeof decimal integers, while also requiring that the data objects to which they are attached donot reside in the trash.&gt;&gt;&gt; search_tuple = (DataObject.name , Collection.name ,...                 DataObjectMeta.name , DataObjectMeta.value)&gt;&gt;&gt; # &quot;not like&quot; : direct instantiation of Criterion (operator in literal string)&gt;&gt;&gt; not_in_trash = Criterion ('not like', Collection.name , '%/trash/%')&gt;&gt;&gt; # &quot;not between&quot;( column, X, Y) := column &lt; X OR column &gt; Y (&quot;OR&quot; done via chained iterators)&gt;&gt;&gt; res1 = session.query (* search_tuple).filter(not_in_trash).filter(DataObjectMeta.value &lt; '0')&gt;&gt;&gt; res2 = session.query (* search_tuple).filter(not_in_trash).filter(DataObjectMeta.value &gt; '9' * 9999 )&gt;&gt;&gt; chained_results = itertools.chain ( res1.get_results(), res2.get_results() )&gt;&gt;&gt; pprint( list( chained_results ) )Instantiating iRODS objects from query results----------------------------------------------The General query works well for getting information out of the ICAT if all we're interested in isinformation representable withprimitive types (ie. object names, paths, and ID's, as strings or integers). But Python's object orientation alsoallows us to create object references to mirror the persistent entities (instances of *Collection*, *DataObject*, *User*, or *Resource*, etc.)inhabiting the ICAT.**Background:**Certain iRODS object types can be instantiated easily using the session object's custom type managers,particularly if some parameter (often just the name or path) of the object is already known:&gt;&gt;&gt; type(session.users)&lt;class 'irods.manager.user_manager.UserManager'&gt;&gt;&gt;&gt; u = session.users.get('rods')&gt;&gt;&gt; u.id10003Type managers are good for specific operations, including object creation and removal::&gt;&gt;&gt; session.collections.create('/tempZone/home/rods/subColln')&gt;&gt;&gt; session.collections.remove('/tempZone/home/rods/subColln')&gt;&gt;&gt; session.data_objects.create('/tempZone/home/rods/dataObj')&gt;&gt;&gt; session.data_objects.unlink('/tempZone/home/rods/dataObj')When we retrieve a reference to an existing collection using *get* :&gt;&gt;&gt; c = session.collections.get('/tempZone/home/rods')&gt;&gt;&gt; c&lt;iRODSCollection 10011 rods&gt;we have, in that variable *c*, a reference to an iRODS *Collection* object whose properties provideuseful information:&gt;&gt;&gt; [ x for x in dir(c) if not x.startswith('__') ]['_meta', 'data_objects', 'id', 'manager', 'metadata', 'move', 'name', 'path', 'remove', 'subcollections', 'unregister', 'walk']&gt;&gt;&gt; c.name'rods'&gt;&gt;&gt; c.path'/tempZone/home/rods'&gt;&gt;&gt; c.data_objects[&lt;iRODSDataObject 10019 test1&gt;]&gt;&gt;&gt; c.metadata.items()[ &lt;... list of AVU's attached to Collection c ... &gt; ]or whose methods can do useful things:&gt;&gt;&gt; for sub_coll in c.walk(): print('---'); pprint( sub_coll )[ ...&lt; series of Python data structures giving the complete tree structure below collection 'c'&gt; ...]This approach of finding objects by name, or via their relations with other objects (ie &quot;contained by&quot;, or in the case of metadata, &quot;attached to&quot;),is helpful if we know something about the location or identity of what we're searching for, but we don't alwayshave that kind of a-priori knowledge.So, although we can (as seen in the last example) walk an *iRODSCollection* recursively to discover all subordinatecollections and their data objects, this approach will not always be bestfor a given type of application or data discovery, especially in more advanceduse cases.**A Different Approach:**For the PRC to be sufficiently powerful for general use, we'll often need at least:* general queries, and* the capabilities afforded by the PRC's object-relational mapping.Suppose, for example, we wish to enumerate all collections in the iRODS catalog.Again, the object managers are the answer, but they are now invoked using a different scheme:&gt;&gt;&gt; from irods.collection import iRODSCollection; from irods.models import Collection&gt;&gt;&gt; all_collns = [ iRODSCollection(session.collections,result) for result in session.query(Collection) ]From there, we have the ability to do useful work, or filtering based on the results of the enumeration.And, because *all_collns* is an iterable of true objects, we can either use Python's list comprehensions orexecute more catalog queries to achieve further aims.Note that, for similar system-wide queries of Data Objects (which, as it happens, are inextricably joined to theirparent Collection objects), a bit more finesse is required.  Let us query, for example, to find all dataobjects in a particular zone with an AVU that matches the following condition::   META_DATA_ATTR_NAME = &quot;irods::alert_time&quot; and META_DATA_ATTR_VALUE like '+0%'&gt;&gt;&gt; import irods.keywords&gt;&gt;&gt; from irods.data_object import iRODSDataObject&gt;&gt;&gt; from irods.models import DataObjectMeta, DataObject&gt;&gt;&gt; from irods.column import Like&gt;&gt;&gt; q = session.query(DataObject).filter( DataObjectMeta.name == 'irods::alert_time',                                          Like(DataObjectMeta.value, '+0%') )&gt;&gt;&gt; zone_hint = &quot;&quot; # --&gt; add a zone name in quotes to search another zone&gt;&gt;&gt; if zone_hint: q = q.add_keyword( irods.keywords.ZONE_KW, zone_hint )&gt;&gt;&gt; for res in q:...      colln_id = res [DataObject.collection_id]...      collObject = get_collection( colln_id, session, zone = zone_hint)...      dataObject = iRODSDataObject( session.data_objects, parent = collObject, results=[res])...      print( '{coll}/{data}'.format (coll = collObject.path, data = dataObject.name))In the above loop we have used a helper function, *get_collection*, to minimize the number of hits to the objectcatalog. Otherwise, me might find within a typical application  that some Collection objects are being queried ata high rate of redundancy. *get_collection* can be implemented thusly:.. code:: Python    import collections  # of the Pythonic, not iRODS, kind    def makehash():        # see https://stackoverflow.com/questions/651794/whats-the-best-way-to-initialize-a-dict-of-dicts-in-python        return collections.defaultdict(makehash)    from irods.collection import iRODSCollection    from irods.models import Collection    def get_collection (Id, session, zone=None, memo = makehash()):        if not zone: zone = &quot;&quot;        c_obj = memo[session][zone].get(Id)        if c_obj is None:            q = session.query(Collection).filter(Collection.id==Id)            if zone != '': q = q.add_keyword( irods.keywords.ZONE_KW, zone )            c_id =  q.one()            c_obj = iRODSCollection(session, result = c_id)            memo[session][zone][Id] = c_obj        return c_objOnce instantiated, of course, any *iRODSDataObject*'s data to which we have access permissions is available via its open() method.As stated, this type of object discovery requires some extra study and effort, but the ability to search arbitrary iRODS zones(to which we are federated and have the user permissions) is powerful indeed.Tickets-------The :code:`irods.ticket.Ticket` class lets us issue &quot;tickets&quot; which grant limitedpermissions for other users to access our own data objects (or collections ofdata objects).   As with the iticket client, the access may be either &quot;read&quot;or &quot;write&quot;.  The recipient of the ticket could be a rodsuser, or even ananonymous user.Below is a demonstration of how to generate a new ticket for access to alogical path - in this case, say a collection containing 1 or more data objects.(We assume the creation of the granting_session and receiving_session for the usersrespectively for the users providing and consuming the ticket access.)The user who wishes to provide an access may execute the following:&gt;&gt;&gt; from irods.ticket import Ticket&gt;&gt;&gt; new_ticket = Ticket (granting_session)&gt;&gt;&gt; The_Ticket_String = new_ticket.issue('read', ...     '/zone/home/my/collection_with_data_objects_for/somebody').stringat which point that ticket's unique string may be given to other users, who can then apply theticket to any existing session object in order to gain access to the intended object(s):&gt;&gt;&gt; from irods.models import Collection, DataObject&gt;&gt;&gt; ses = receiving_session&gt;&gt;&gt; Ticket(ses, The_Ticket_String).supply()&gt;&gt;&gt; c_result = ses.query(Collection).one()&gt;&gt;&gt; c = iRODSCollection( ses.collections, c_result)&gt;&gt;&gt; for dobj in (c.data_objects):...     ses.data_objects.get( dobj.path, '/tmp/' + dobj.name ) # download objectsIn this case, however, modification will not be allowed because the ticket is for read only:&gt;&gt;&gt; c.data_objects[0].open('w').write(  # raises...     b'new content')                 #  CAT_NO_ACCESS_PERMISSIONIn another example, we could generate a ticket that explicitly allows 'write' access on aspecific data object, thus granting other users the permissions to modify as well as read it:&gt;&gt;&gt; ses = iRODSSession( user = 'anonymous', password = '', host = 'localhost',                        port = 1247, zone = 'tempZone')&gt;&gt;&gt; Ticket(ses, write_data_ticket_string ).supply()&gt;&gt;&gt; d_result = ses.query(DataObject.name,Collection.name).one()&gt;&gt;&gt; d_path = ( d_result[Collection.name] + '/' +...            d_result[DataObject.name] )&gt;&gt;&gt; old_content = ses.data_objects.open(d_path,'r').read()&gt;&gt;&gt; with tempfile.NamedTemporaryFile() as f:...     f.write(b'blah'); f.flush()...     ses.data_objects.put(f.name,d_path)As with iticket, we may set a time limit on the availability of a ticket, either as atimestamp or in seconds since the epoch:&gt;&gt;&gt; t=Ticket(ses); s = t.stringvIOQ6qzrWWPO9X7&gt;&gt;&gt; t.issue('read','/some/path')&gt;&gt;&gt; t.modify('expiry','2021-04-01.12:34:56')  # timestamp assumed as UTCTo check the results of the above, we could invoke this icommand elsewhere in a shell prompt::code:`iticket ls vIOQ6qzrWWPO9X7`and the server should report back the same expiration timestamp.And, if we are the issuer of a ticket, we may also query, filter on, andextract information based on a ticket's attributes and catalog relations:&gt;&gt;&gt; from irods.models import TicketQuery&gt;&gt;&gt; delay = lambda secs: int( time.time() + secs + 1)&gt;&gt;&gt; Ticket(ses).issue('read','/path/to/data_object').modify(                      'expiry',delay(7*24*3600))             # lasts 1 week&gt;&gt;&gt; Q = ses.query (TicketQuery.Ticket, TicketQuery.DataObject).filter(...                                                            TicketQuery.DataObject.name == 'data_object')&gt;&gt;&gt; print ([ _[TicketQuery.Ticket.expiry_ts] for _ in Q ])['1636757427']Tracking and manipulating replicas of Data objects--------------------------------------------------Putting together the techniques we've seen so far, it's not hard to write functionsthat achieve useful, common goals. Suppose that for all data objects containing replicas ona given named resource (the &quot;source&quot;) we want those replicas &quot;moved&quot; to a second, or&quot;destination&quot; resource.  We can achieve it with a function such as the one below. Itachieves the move via a replication of the data objects found to the destinationresource , followed by a trimming of each replica from the source.  We assume for our currentpurposed that all replicas are &quot;good&quot;, ie have a status of &quot;1&quot; ::  from irods.resource import iRODSResource  from irods.collection import iRODSCollection  from irods.data_object import iRODSDataObject  from irods.models import Resource,Collection,DataObject  def repl_and_trim (srcRescName, dstRescName = '', verbose = False):      objects_trimmed = 0      q = session.query(Resource).filter(Resource.name == srcRescName)      srcResc = iRODSResource( session.resources, q.one())      # loop over data objects found on srcResc      for q_row in session.query(Collection,DataObject) \                          .filter(DataObject.resc_id == srcResc.id):          collection =  iRODSCollection (session.collections, result = q_row)          data_object = iRODSDataObject (session.data_objects, parent = collection, results = (q_row,))          objects_trimmed += 1          if verbose :              import pprint              print( '--------', data_object.name, '--------')              pprint.pprint( [vars(r) for r in data_object.replicas if                              r.resource_name == srcRescName] )          if dstRescName:              objects_trimmed += 1              data_object.replicate(dstRescName)              for replica_number in [r.number for r in data_object.replicas]:                  options = { kw.DATA_REPL_KW: replica_number }                  data_object.unlink( **options )      return objects_trimmedListing Users and Groups ; calculating Group Membership-------------------------------------------------------iRODS tracks groups and users using two tables, R_USER_MAIN and R_USER_GROUP.Under this database schema, all &quot;user groups&quot; are also users:&gt;&gt;&gt; from irods.models import User, Group&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt; pprint(list((x[User.id], x[User.name]) for x in session.query(User)))[(10048, 'alice'), (10001, 'rodsadmin'), (13187, 'bobby'), (10045, 'collab'), (10003, 'rods'), (13193, 'empty'), (10002, 'public')]But it's also worth noting that the User.type field will be 'rodsgroup' for anyuser ID that iRODS internally recognizes as a &quot;Group&quot;:&gt;&gt;&gt; groups = session.query(User).filter( User.type == 'rodsgroup' )&gt;&gt;&gt; [x[User.name] for x in groups]['collab', 'public', 'rodsadmin', 'empty']Since we can instantiate iRODSGroup and iRODSUser objects directly from the rows ofa general query on the corresponding tables,  it is also straightforward to trace outthe groups' memberships:&gt;&gt;&gt; from irods.user import iRODSUser, iRODSGroup&gt;&gt;&gt; grp_usr_mapping = [ (iRODSGroup(session.groups, result), iRODSUser(session.users, result)) \...                     for result in session.query(Group,User) ]&gt;&gt;&gt; pprint( [ (x,y) for x,y in grp_usr_mapping if x.id != y.id ] )[(&lt;iRODSGroup 10045 collab&gt;, &lt;iRODSUser 10048 alice rodsuser tempZone&gt;), (&lt;iRODSGroup 10001 rodsadmin&gt;, &lt;iRODSUser 10003 rods rodsadmin tempZone&gt;), (&lt;iRODSGroup 10002 public&gt;, &lt;iRODSUser 10003 rods rodsadmin tempZone&gt;), (&lt;iRODSGroup 10002 public&gt;, &lt;iRODSUser 10048 alice rodsuser tempZone&gt;), (&lt;iRODSGroup 10045 collab&gt;, &lt;iRODSUser 13187 bobby rodsuser tempZone&gt;), (&lt;iRODSGroup 10002 public&gt;, &lt;iRODSUser 13187 bobby rodsuser tempZone&gt;)](Note that in general queries, fields cannot be compared to each other, only to literal constants; thusthe '!=' comparison in the Python list comprehension.)From the above, we can see that the group 'collab' (with user ID 10045) contains users 'bobby'(13187) and'alice'(10048) but not 'rods'(10003), as the tuple (10045,10003) is not listed. Group 'rodsadmin'(10001)contains user 'rods'(10003) but no other users; and group 'public'(10002) by default contains all canonicalusers (those whose User.type is 'rodsadmin' or 'rodsuser'). The empty group ('empty') has no users asmembers, so it doesn't show up in our final list.Group Administrator Capabilities--------------------------------With v1.1.7, PRC acquires the full range of abilities possessed by the igroupadmin command.Firstly, a groupadmin may invoke methods to create groups, and may add users to, or remove them from, anygroup to which they themselves belong:&gt;&gt;&gt; session.groups.create('lab')&gt;&gt;&gt; session.groups.addmember('lab',session.username)  # allow self to administer group&gt;&gt;&gt; session.groups.addmember('lab','otheruser')&gt;&gt;&gt; session.groups.removemember('lab','otheruser')In addition, a groupadmin may also create accounts for new users and enable their logins by initializinga native password for them:&gt;&gt;&gt; session.users.create_with_password('alice', 'change_me')iRODS Permissions (ACLs)------------------------The :code:`iRODSAccess` class offers a convenient dictionary interface mapping iRODS permissionstrings to the corresponding integer codes:&gt;&gt;&gt; from irods.access import iRODSAccess&gt;&gt;&gt; iRODSAccess.keys()['null', 'read_metadata', 'read_object', 'create_metadata', 'modify_metadata', 'delete_metadata', 'create_object', 'modify_object', 'delete_object', 'own']&gt;&gt;&gt; WRITE = iRODSAccess.to_int('modify_object')Armed with that, we can then query on all data objects with ACL's that allow our user to write them:&gt;&gt;&gt; from irods.models import (DataObject, User, DataAccess)&gt;&gt;&gt; data_objects_writable = list(session.query(DataObject, User, DataAccess).filter(User.name == session.username,  DataAccess.type &gt;= WRITE))Finally, we can also access the list of permissions available through a given session object via the :code:`available_permissions` property.Note that -- in keeping with changes in iRODS server 4.3 -- the permissions list will be longer, as appropriate, for session objects connected tothe more recent servers; and also that the embedded spaces in some 4.2 permission strings will be replaced by underscores in 4.3 and later.&gt;&gt;&gt; session.server_version(4, 2, 11)&gt;&gt;&gt; session.available_permissions.items()[('null', 1000), ('read object', 1050), ('modify object', 1120), ('own', 1200)]Getting and setting permissions-------------------------------We can find the ID's of all the collections writable (ie having &quot;modify&quot; ACL) by, but not owned by,alice (or even alice#otherZone):&gt;&gt;&gt; from irods.models import Collection,CollectionAccess,CollectionUser,User&gt;&gt;&gt; from irods.column import Like&gt;&gt;&gt; q = session.query (Collection,CollectionAccess).filter(...                                 CollectionUser.name == 'alice',  # User.zone == 'otherZone', # zone optional...                                 Like(CollectionAccess.name, 'modify%') ) #defaults to current zoneIf we then want to downgrade those permissions to read-only, we can do the following:&gt;&gt;&gt; from irods.access import iRODSAccess&gt;&gt;&gt; for c in q:...     session.acls.set( iRODSAccess('read', c[Collection.name], 'alice', # 'otherZone' # zone optional...     ))A call to :code:`session.acls.get(c)` -- with :code:`c` being the result of :code:`sessions.collections.get(c[Collection.name])` --would then verify the desired change had taken place (as well as list all ACLs stored in the catalog for that collection).One last note on permissions:  The older access manager, :code:`&lt;session&gt;.permissions`, produced inconsistent results when the :code:`get()`method was invoked with the parameter :code:`report_raw_acls` set (or defaulting) to :code:`False`.  Specifically, collections would exhibit the&quot;non-raw-ACL&quot; behavior of reporting individual member users' permissions as a by-product of group ACLs, whereas data objects would not.In release v1.1.6, we move to correct this inconsistency by introducing the synonym :code:`&lt;session&gt;.acls` that acts almost identically like :code:`&lt;session&gt;.permissions`, except that the :code:`&lt;session&gt;.acls.get(...)` method does not accept the :code:`report_raw_acls` parameter.  When we need to detect users' permissions independent of their access to an object via group membership, this can be achieved with another query.:code:`&lt;session&gt;.permissions` is therefore deprecated and, in v2.0.0, will be removed in favor of :code:`&lt;session&gt;.acls`.Managing users--------------You can create a user in the current zone (with an optional auth_str):&gt;&gt;&gt; session.users.create('user', 'rodsuser', 'MyZone', auth_str)If you want to create a user in a federated zone, use:&gt;&gt;&gt; session.users.create('user', 'rodsuser', 'OtherZone', auth_str)And more...-----------Additional code samples are available in the `test directory &lt;https://github.com/irods/python-irodsclient/tree/main/irods/test&gt;`_=======Testing=======Setting up and running tests----------------------------The Python iRODS Client comes with its own suite of tests.  Some amount of setting up may be necessary first:1. Use :code:`iinit` to specify the iRODS client environment.   For best results, point the client at a server running on the local host.2. Install the python-irodsclient along with the :code:`unittest unittest_xml_reporting` module or the older :code:`xmlrunner` equivalent.   - for PRC versions 1.1.1 and later:     *  :code:`pip install ./path-to-python-irodsclient-repo[tests]`  (when using a local Git repo); or,     *  :code:`pip install python-irodsclient[tests]'&gt;=1.1.1'`  (when installing directly from PyPI).   - earlier releases (&lt;= 1.1.0) will install the outdated :code:`xmlrunner` module automatically3. Follow further instructions in the `test directory &lt;https://github.com/irods/python-irodsclient/tree/main/irods/test&gt;`_Testing S3 parallel transfer----------------------------System requirements::- Ubuntu 18 user with Docker installed.- Local instance of iRODS server running.- Logged in sudo privileges.Run a MinIO service::  $ docker run -d -p 9000:9000 -p 9001:9001 minio/minio server /data --console-address &quot;:9001&quot;Set up a bucket :code:`s3://irods` under MinIO::  $ pip install awscli  $ aws configure  AWS Access Key ID [None]: minioadmin  AWS Secret Access Key [None]: minioadmin  Default region name [None]:  Default output format [None]:  $ aws --endpoint-url http://127.0.0.1:9000 s3 mb s3://irodsSet up s3 credentials for the iRODS s3 storage resource::  $ sudo su - irods -c &quot;/bin/echo -e 'minioadmin\nminioadmin' &gt;/var/lib/irods/s3-credentials&quot;  $ sudo chown 600 /var/lib/irods/s3-credentialsCreate the s3 storage resource::  $ sudo apt install irods-resource-plugin-s3As the 'irods' service account user::  $ iadmin mkresc s3resc s3 $(hostname):/irods/ \    &quot;S3_DEFAULT_HOSTNAME=localhost:9000;&quot;\    &quot;S3_AUTH_FILE=/var/lib/irods/s3-credentials;&quot;\    &quot;S3_REGIONNAME=us-east-1;&quot;\    &quot;S3_RETRY_COUNT=1;&quot;\    &quot;S3_WAIT_TIME_SEC=3;&quot;\    &quot;S3_PROTO=HTTP;&quot;\    &quot;ARCHIVE_NAMING_POLICY=consistent;&quot;\    &quot;HOST_MODE=cacheless_attached&quot;  $ dd if=/dev/urandom of=largefile count=40k bs=1k # create 40-megabyte test file  $ pip install 'python-irodsclient&gt;=1.1.2'  $ python -c&quot;from irods.test.helpers import make_session              import irods.keywords as kw              with make_session() as sess:                  sess.data_objects.put( 'largefile',                                         '/tempZone/home/rods/largeFile1',                                         **{kw.DEST_RESC_NAME_KW:'s3resc'} )                  sess.data_objects.get( '/tempZone/home/rods/largeFile1',                                         '/tmp/largefile')&quot;</longdescription>
</pkgmetadata>