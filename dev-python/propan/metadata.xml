<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://lancetnik.github.io/Propan/&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://lancetnik.github.io/Propan/assets/img/logo-no-background.png&quot; alt=&quot;Propan logo&quot; style=&quot;height: 250px; width: 600px;&quot;/&gt;    &lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;    &lt;a href=&quot;https://github.com/Lancetnik/Propan/actions/workflows/tests.yml&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://github.com/Lancetnik/Propan/actions/workflows/tests.yml/badge.svg&quot; alt=&quot;Tests coverage&quot;/&gt;    &lt;/a&gt;    &lt;a href=&quot;https://coverage-badge.samuelcolvin.workers.dev/redirect/lancetnik/propan&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://coverage-badge.samuelcolvin.workers.dev/lancetnik/propan.svg&quot; alt=&quot;Coverage&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://pypi.org/project/propan&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://img.shields.io/pypi/v/propan?label=pypi%20package&quot; alt=&quot;Package version&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://pepy.tech/project/propan&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://static.pepy.tech/personalized-badge/propan?period=total&amp;units=international_system&amp;left_color=grey&amp;right_color=blue&amp;left_text=Downloads&quot; alt=&quot;downloads&quot;/&gt;    &lt;/a&gt;    &lt;br/&gt;    &lt;a href=&quot;https://pypi.org/project/propan&quot; target=&quot;_blank&quot;&gt;        &lt;img src=&quot;https://img.shields.io/pypi/pyversions/propan.svg&quot; alt=&quot;Supported Python versions&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://github.com/Lancetnik/Propan/blob/main/LICENSE&quot; target=&quot;_blank&quot;&gt;        &lt;img alt=&quot;GitHub&quot; src=&quot;https://img.shields.io/github/license/Lancetnik/Propan?color=%23007ec6&quot;&gt;    &lt;/a&gt;&lt;/p&gt;# Propan**Propan** - just *&lt;s&gt;an another one HTTP&lt;/s&gt;* a **declarative Python MQ framework**. It's following by [*fastapi*](https://fastapi.tiangolo.com/ru/),simplify Message Brokers around code writing and provides a helpful development toolkit, which existed only in HTTP-frameworks world until now.It's designed to create reactive microservices around &lt;a href=&quot;https://microservices.io/patterns/communication-style/messaging.html&quot; target=&quot;_blank&quot;&gt;Messaging Architecture&lt;/a&gt;.It is a modern, high-level framework on top of popular specific Python brokers libraries, based on [*pydantic*](https://docs.pydantic.dev/) and [*fastapi*](https://fastapi.tiangolo.com/ru/), [*pytest*](https://docs.pytest.org/en/7.3.x/) concepts.---**Documentation**: &lt;a href=&quot;https://lancetnik.github.io/Propan/&quot; target=&quot;_blank&quot;&gt;https://lancetnik.github.io/Propan/&lt;/a&gt;---### The key features are* **Easy**: Designed to be easy to use and learn.* **Intuitive**: Great editor support. Autocompletion everywhere.* [**Dependencies management**](#dependencies): Minimize code duplication. Multiple features from each argument and parameter declaration.* [**Integrations**](#http-frameworks-integrations): **Propan** is ready to use in pair with [any HTTP framework](https://lancetnik.github.io/Propan/5_integrations/1_integrations-index/) you want* **MQ independent**: Single interface to popular MQ:    * **NATS** (based on [nats-py](https://github.com/nats-io/nats.py))     * **RabbitMQ** (based on [aio-pika](https://aio-pika.readthedocs.io/en/latest/))* [**RPC**](https://lancetnik.github.io/Propan/2_getting_started/4_broker/4_rpc/): The framework supports RPC requests over MQ, which will allow performing long operations on remote services asynchronously.* [**Greate to develop**](#cli-power): CLI tool provides great development experience:    * framework-independent way to rule application environment    * application code hot reloading### Supported MQ brokers|              | async                                                   | sync                 ||--------------|:-------------------------------------------------------:|:--------------------:|| **RabbitMQ** | :heavy_check_mark: **stable** :heavy_check_mark:        | :mag: planning :mag: || **Nats**     | :warning: **beta** :warning:                            | :mag: planning :mag: || **NatsJS**   | :hammer_and_wrench: **in progress** :hammer_and_wrench: | :mag: planning :mag: || **MQTT**     | :mag: planning :mag:                                    | :mag: planning :mag: || **REDIS**    | :mag: planning :mag:                                    | :mag: planning :mag: || **Kafka**    | :mag: planning :mag:                                    | :mag: planning :mag: || **SQS**      | :mag: planning :mag:                                    | :mag: planning :mag: |### CommunityIf you are interested in this project, please give me feedback by star or/and watch repository.If you have any questions or ideas about features to implement, welcome to [discussions](https://github.com/Lancetnik/Propan/discussions) or public [telegram group](https://t.me/propan_python).---## Declarative?With declarative tools you should define **what you need to get**. With traditional imperative tools you should write **what you need to do**.Take a look at classic imperative tools, such as [aio-pika](https://aio-pika.readthedocs.io/en/latest/), [pika](https://pika.readthedocs.io/en/stable/), [nats-py](https://github.com/nats-io/nats.py), etc. This is the **Quickstart** with the *aio-pika*:```pythonimport asyncioimport aio_pikaasync def main():    connection = await aio_pika.connect_robust(        &quot;amqp://guest:guest@127.0.0.1/&quot;    )    queue_name = &quot;test_queue&quot;    async with connection:        channel = await connection.channel()        queue = await channel.declare_queue(queue_name)        async with queue.iterator() as queue_iter:            async for message in queue_iter:                async with message.process():                    print(message.body)asyncio.run(main())```**aio-pika** is a really great tool with a really easy learning curve. But it's still imperative. You need to *connect*, declare *channel*, *queues*, *exchanges* by yourself. Also, you need to manage *connection*, *message*, *queue* context to avoid any troubles.It is not a bad way, but it can be easy.```pythonfrom propan import PropanApp, RabbitBrokerbroker = RabbitBroker(&quot;amqp://guest:guest@localhost:5672/&quot;)app = PropanApp(broker)@broker.handle(&quot;test_queue&quot;)async def base_handler(body):    print(body)```This is the **Propan** declarative way to write the same code. That is so much easier, isn't it?---## QuickstartInstall using `pip`:```shell$ pip install &quot;propan[async-rabbit]&quot;# or$ pip install &quot;propan[async-nats]&quot;```### Basic usageCreate an application with the following code at `serve.py`:```pythonfrom propan import PropanAppfrom propan import RabbitBroker# from propan import NatsBrokerbroker = RabbitBroker(&quot;amqp://guest:guest@localhost:5672/&quot;)# broker = NatsBroker(&quot;nats://localhost:4222&quot;)app = PropanApp(broker)@broker.handle(&quot;test&quot;)async def base_handler(body):    '''Handle all default exchange messages with `test` routing key'''    print(body)```And just run it:```shell$ propan run serve:app```---## Type castingPropan uses `pydantic` to cast incoming function arguments to types according to their annotation.```pythonfrom pydantic import BaseModelfrom propan import PropanApp, Context, RabbitBrokerbroker = RabbitBroker(&quot;amqp://guest:guest@localhost:5672/&quot;)app = PropanApp(broker)class SimpleMessage(BaseModel):    key: int@broker.handle(&quot;test2&quot;)async def second_handler(body: SimpleMessage):    assert isinstance(body.key, int)```---## Dependencies**Propan** a has dependencies management policy close to `pytest fixtures`.You can specify in functions arguments which dependenciesyou would to use. Framework passes them from the global Context object.Already existed context fields are: *app*, *broker*, *context* (itself), *logger* and *message*.If you call not existing field, raises *pydantic.error_wrappers.ValidationError* value.But you can specify your own dependencies, call dependencies functions (like `Fastapi Depends`)and [more](https://github.com/Lancetnik/Propan/tree/main/examples/dependencies).```pythonfrom logging import Loggerimport aio_pikafrom propan import PropanApp, Context, RabbitBrokerrabbit_broker = RabbitBroker(&quot;amqp://guest:guest@localhost:5672/&quot;)app = PropanApp(rabbit_broker)@rabbit_broker.handle(&quot;test&quot;)async def base_handler(body: dict,                       broker: RabbitBroker = Context()):    assert broker is rabbit_broker```---## CLI power**Propan** has its own CLI tool that provided the following features:* project generation* multiprocessing workers* project hot reloading* custom command line arguments passing### Context passingFor example: pass your current *.env* project setting to context```bash$ propan run serve:app --env=.env.dev``````pythonfrom propan import PropanApp, RabbitBrokerfrom propan.annotations import ContextRepofrom pydantic import BaseSettingsbroker = RabbitBroker(&quot;amqp://guest:guest@localhost:5672/&quot;)app = PropanApp(broker)class Settings(BaseSettings):    ...@app.on_startupasync def setup(env: str, context: ContextRepo):    settings = Settings(_env_file=env)    context.set_context(&quot;settings&quot;, settings)```### Project templateAlso, **Propan CLI** is able to generate a production-ready application template:```shell$ propan create [projectname]```*Notice: project template require* `pydantic[dotenv]` *installation.*Run the created project:```shell# Run rabbimq first$ docker compose --file [projectname]/docker-compose.yaml up -d# Run project$ propan run [projectname].app.serve:app --env=.env --reload```Now you can enjoy a new development experience!---## HTTP Frameworks integrations### Any FrameworkYou can use **Propan** `MQBrokers` without `PropanApp`.Just *start* and *stop* them according to your application lifespan.```pythonfrom propan import NatsBrokerfrom sanic import Sanicapp = Sanic(&quot;MyHelloWorldApp&quot;)broker = NatsBroker(&quot;nats://localhost:4222&quot;)@broker.handle(&quot;test&quot;)async def base_handler(body):    print(body)@app.after_server_startasync def start_broker(app, loop):    await broker.start()@app.after_server_stopasync def stop_broker(app, loop):    await broker.close()```### FastAPI PluginAlso, **Propan** can be used as part of **FastAPI**.Just import a **PropanRouter** you need and declare the message handlerusing the `@event` decorator. This decorator is similar to the decorator `@handle` for the corresponding brokers.```pythonfrom fastapi import Depends, FastAPIfrom pydantic import BaseModelfrom propan.fastapi import RabbitRouterapp = FastAPI()router = RabbitRouter(&quot;amqp://guest:guest@localhost:5672&quot;)class Incoming(BaseModel):    m: dictdef call():    return True@router.event(&quot;test&quot;)async def hello(m: Incoming, d = Depends(call)) -&gt; dict:    return { &quot;response&quot;: &quot;Hello, Propan!&quot; }app.include_router(router)```## ExamplesTo see more framework usages go to [**examples/**](https://github.com/Lancetnik/Propan/tree/main/examples)</longdescription>
</pkgmetadata>