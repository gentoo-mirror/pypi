<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>ipapy=====**ipapy** is a Python module to work with International PhoneticAlphabet (IPA) strings.-  Version: 0.0.9-  Date: 2019-05-05-  Developer: `Alberto Pettarin &lt;http://www.albertopettarin.it/&gt;`__-  License: the MIT License (MIT)-  Contact: `click here &lt;http://www.albertopettarin.it/contact.html&gt;`__-  Links: `GitHub &lt;https://github.com/pettarin/ipapy&gt;`__ -   `PyPI &lt;https://pypi.python.org/pypi/ipapy&gt;`__Installation------------.. code:: bash   $ pip install ipapyor.. code:: bash   $ git clone https://github.com/pettarin/ipapy.git   $ cd ipapyUsage-----As A Python Module~~~~~~~~~~~~~~~~~~.. code:: python   ###########   # IMPORTS #   ###########   from ipapy import UNICODE_TO_IPA   from ipapy import is_valid_ipa   from ipapy.ipachar import IPAConsonant   from ipapy.ipachar import IPAVowel   from ipapy.ipastring import IPAString   ###########   # IPAChar #   ###########   # Def.: an IPAChar is an IPA letter or diacritic/suprasegmental/tone mark   # create IPAChar from its Unicode representation   c1 = UNICODE_TO_IPA[u&quot;a&quot;]                   # vowel open front unrounded   c2 = UNICODE_TO_IPA[u&quot;e&quot;]                   # vowel close-mid front unrounded   c3 = UNICODE_TO_IPA[u&quot;\u03B2&quot;]              # consonant voiced bilabial non-sibilant-fricative   tS1 = UNICODE_TO_IPA[u&quot;t͡ʃ&quot;]                 # consonant voiceless palato-alveolar sibilant-affricate   tS2 = UNICODE_TO_IPA[u&quot;t͜ʃ&quot;]                 # consonant voiceless palato-alveolar sibilant-affricate   tS3 = UNICODE_TO_IPA[u&quot;tʃ&quot;]                 # consonant voiceless palato-alveolar sibilant-affricate   tS4 = UNICODE_TO_IPA[u&quot;ʧ&quot;]                  # consonant voiceless palato-alveolar sibilant-affricate   tS5 = UNICODE_TO_IPA[u&quot;\u0074\u0361\u0283&quot;] # consonant voiceless palato-alveolar sibilant-affricate   tS6 = UNICODE_TO_IPA[u&quot;\u0074\u035C\u0283&quot;] # consonant voiceless palato-alveolar sibilant-affricate   tS7 = UNICODE_TO_IPA[u&quot;\u0074\u0283&quot;]       # consonant voiceless palato-alveolar sibilant-affricate   tS8 = UNICODE_TO_IPA[u&quot;\u02A7&quot;]             # consonant voiceless palato-alveolar sibilant-affricate   c1 == c2    # False   c1 == c3    # False   c1 == tS1   # False   tS1 == tS2  # True (they both point to the same IPAChar object)   tS1 == tS3  # True (idem)   tS1 == tS4  # True (idem)   tS1 == tS5  # True (idem)   tS1 == tS6  # True (idem)   tS1 == tS7  # True (idem)   tS1 == tS8  # True (idem)   # create custom IPAChars   my_a1 = IPAVowel(name=&quot;my_a_1&quot;, descriptors=u&quot;open front unrounded&quot;, unicode_repr=u&quot;a&quot;)   my_a2 = IPAVowel(name=&quot;my_a_2&quot;, descriptors=[u&quot;open&quot;, &quot;front&quot;, &quot;unrounded&quot;], unicode_repr=u&quot;a&quot;)   my_a3 = IPAVowel(name=&quot;my_a_3&quot;, height=u&quot;open&quot;, backness=u&quot;front&quot;, roundness=u&quot;unrounded&quot;, unicode_repr=u&quot;a&quot;)   my_a4 = IPAVowel(name=&quot;my_a_4&quot;, descriptors=[u&quot;low&quot;, u&quot;fnt&quot;, &quot;unr&quot;], unicode_repr=u&quot;a&quot;)   my_ee = IPAVowel(name=&quot;my_e_1&quot;, descriptors=u&quot;close-mid front unrounded&quot;, unicode_repr=u&quot;e&quot;)   my_b1 = IPAConsonant(name=&quot;bilabial fricative&quot;, descriptors=u&quot;voiced bilabial non-sibilant-fricative&quot;, unicode_repr=u&quot;\u03B2&quot;)   my_b2 = IPAConsonant(name=&quot;bf&quot;, voicing=u&quot;voiced&quot;, place=u&quot;bilabial&quot;, manner=u&quot;non-sibilant-fricative&quot;, unicode_repr=u&quot;\u03B2&quot;)   my_tS = IPAConsonant(name=&quot;tS&quot;, voicing=u&quot;voiceless&quot;, place=u&quot;palato-alveolar&quot;, manner=u&quot;sibilant-affricate&quot;, unicode_repr=u&quot;t͡ʃ&quot;)   my_a1 == my_a2                  # False (two different objects)   my_a1 == c1                     # False (two different objects)   my_a1 == UNICODE_TO_IPA[&quot;a&quot;]    # False (two different objects)   # associate non-standard Unicode representation   my_aa = IPAVowel(name=&quot;a special&quot;, descriptors=[u&quot;low&quot;, u&quot;fnt&quot;, u&quot;unr&quot;], unicode_repr=u&quot;a{*}&quot;)   print(my_aa)    # &quot;a{*}&quot;   # equality vs. equivalence   my_tS == tS1                # False (my_tS is a different object than tS1)   my_tS.is_equivalent(tS1)    # True  (my_tS is equivalent to tS1...)   tS1.is_equivalent(my_tS)    # True  (... and vice versa)   # compare IPAChar objects   my_a1.is_equivalent(my_a2)  # True   my_a1.is_equivalent(my_a3)  # True   my_a1.is_equivalent(my_a4)  # True   my_a1.is_equivalent(my_ee)  # False   my_a1.is_equivalent(my_b1)  # False   my_b1.is_equivalent(my_b2)  # True   my_b1.is_equivalent(my_tS)  # False   # compare IPAChar and a Unicode string   my_b1.is_equivalent(u&quot;\u03B2&quot;)  # True   my_b1.is_equivalent(u&quot;β&quot;)       # True   my_b1.is_equivalent(u&quot;b&quot;)       # False   my_tS.is_equivalent(u&quot;tS&quot;)      # False   my_tS.is_equivalent(u&quot;tʃ&quot;)      # False (missing the combining diacritic)   my_tS.is_equivalent(u&quot;t͡ʃ&quot;)      # True (has combining diacritic)   # compare IPAChar and a string listing descriptors   my_a1.is_equivalent(u&quot;open front unrounded&quot;)                                # False (missing 'vowel')   my_a1.is_equivalent(u&quot;open front unrounded vowel&quot;)                          # True   my_a1.is_equivalent(u&quot;low fnt unr vwl&quot;)                                     # True (known abbreviations are good as well)   my_ee.is_equivalent(u&quot;open front unrounded vowel&quot;)                          # False   my_b1.is_equivalent(u&quot;voiced bilabial non-sibilant-fricative&quot;)              # False (missing 'consonant')   my_b1.is_equivalent(u&quot;voiced bilabial non-sibilant-fricative consonant&quot;)    # True   my_b1.is_equivalent(u&quot;consonant non-sibilant-fricative bilabial voiced&quot;)    # True (the order does not matter)   my_b1.is_equivalent(u&quot;consonant non-sibilant-fricative bilabial voiceless&quot;) # False   # compare IPAChar and list of descriptors   my_a1.is_equivalent([u&quot;open&quot;, u&quot;front&quot;, u&quot;unrounded&quot;])              # False   my_a1.is_equivalent([u&quot;vowel&quot;, u&quot;open&quot;, u&quot;front&quot;, u&quot;unrounded&quot;])    # True   my_a1.is_equivalent([u&quot;open&quot;, u&quot;unrounded&quot;, u&quot;vowel&quot;, u&quot;front&quot;])    # True   my_a1.is_equivalent([u&quot;low&quot;, u&quot;fnt&quot;, u&quot;unr&quot;, u&quot;vwl&quot;])               # True   #############   # IPAString #   #############   # Def.: an IPAString is a list of IPAChar objects   # check if Unicode string contains only IPA valid characters   s_uni = u&quot;əˈkiːn æˌkænˈθɑ.lə.d͡ʒi&quot;   # Unicode string of the IPA pronunciation for &quot;achene acanthology&quot;   is_valid_ipa(s_uni)                 # True   is_valid_ipa(u&quot;LoL&quot;)                # False (uppercase letter L is not IPA valid)   # create IPAString from list of IPAChar objects   new_s_ipa = IPAString(ipa_chars=[c3, c2, tS1, c1])   # create IPAString from Unicode string   s_ipa = IPAString(unicode_string=s_uni)   # IPAString is similar to regular Python string object   print(s_ipa)                            # &quot;əˈkiːn æˌkænˈθɑ.lə.d͡ʒi&quot;   len(s_ipa)                              # 21   s_ipa[0]                                # (first IPA char)   s_ipa[5:8]                              # (6th, 7th, 8th IPA chars)   s_ipa[19:]                              # (IPA chars from the 20th)   s_ipa[-1]                               # (last IPA char)   len(new_s_ipa)                          # 4   new_s_ipa.append(UNICODE_TO_IPA[u&quot;a&quot;])  # (append IPA char &quot;a&quot;)   len(new_s_ipa)                          # 5   new_s_ipa.append(UNICODE_TO_IPA[u&quot;t͡ʃ&quot;]) # (append IPA char &quot;t͡ʃ&quot;)   len(new_s_ipa)                          # 6   new_s_ipa.extend(s_ipa)                 # (append s_ipa to new_s_ipa)   len(new_s_ipa)                          # 27   double = s_ipa + new_s_ipa              # (concatenate s_ipa and new_s_ipa)   len(double)                             # 48   # new IPAString objects containing only...   print(s_ipa.consonants)                 # &quot;knknθld͡ʒ&quot;                (consonants)   print(s_ipa.vowels)                     # &quot;əiææɑəi&quot;                 (vowels)   print(s_ipa.letters)                    # &quot;əkinækænθɑləd͡ʒi&quot;         (vowels and consonants)   print(s_ipa.cns_vwl)                    # &quot;əkinækænθɑləd͡ʒi&quot;         (vowels and consonants)   print(s_ipa.cns_vwl_pstr)               # &quot;əˈkinækænˈθɑləd͡ʒi&quot;       (  + primary stress marks)   print(s_ipa.cns_vwl_pstr_long)          # &quot;əˈkiːnækænˈθɑləd͡ʒi&quot;      (    + long marks)   print(s_ipa.cns_vwl_str)                # &quot;əˈkinæˌkænˈθɑləd͡ʒi&quot;      (  + stress marks)   print(s_ipa.cns_vwl_str_len)            # &quot;əˈkiːnæˌkænˈθɑləd͡ʒi&quot;     (    + length marks)   print(s_ipa.cns_vwl_str_len_wb)         # &quot;əˈkiːn æˌkænˈθɑləd͡ʒi&quot;    (      + word breaks)   print(s_ipa.cns_vwl_str_len_wb_sb)      # &quot;əˈkiːn æˌkænˈθɑ.lə.d͡ʒi&quot;  (        + syllable breaks)   cns = s_ipa.consonants                  # (store new IPA string)   cns == s_ipa.consonants                 # False (two different objects)   cns.is_equivalent(s_ipa.consonants)     # True   cns.is_equivalent(s_ipa)                # False   # print representation and name of all IPAChar objects in IPAString   for c in s_ipa:       print(u&quot;%s\t%s&quot; % (c, c.name))   # ə vowel mid central unrounded   # ˈ suprasegmental primary-stress   # k consonant voiceless velar plosive   # i vowel close front unrounded   # ː suprasegmental long   # n consonant voiced alveolar nasal   #   suprasegmental word-break   # æ vowel near-open front unrounded   # ˌ suprasegmental secondary-stress   # k consonant voiceless velar plosive   # æ vowel near-open front unrounded   # n consonant voiced alveolar nasal   # ˈ suprasegmental primary-stress   # θ consonant voiceless dental non-sibilant-fricative   # ɑ vowel open back unrounded   # . suprasegmental syllable-break   # l consonant voiced alveolar lateral-approximant   # ə vowel mid central unrounded   # . suprasegmental syllable-break   # d͡ʒ   consonant voiced palato-alveolar sibilant-affricate   # i vowel close front unrounded   # compare IPAString objects   s_ipa_d = IPAString(unicode_string=u&quot;diff&quot;)   s_ipa_1 = IPAString(unicode_string=u&quot;at͡ʃe&quot;)   s_ipa_2 = IPAString(unicode_string=u&quot;aʧe&quot;)   s_ipa_3 = IPAString(unicode_string=u&quot;at͡ʃe&quot;, single_char_parsing=True)   s_ipa_d == s_ipa_1              # False   s_ipa_1 == s_ipa_2              # False (different objects)   s_ipa_1 == s_ipa_3              # False (different objects)   s_ipa_2 == s_ipa_3              # False (different objects)   s_ipa_d.is_equivalent(s_ipa_1)  # False   s_ipa_1.is_equivalent(s_ipa_2)  # True   s_ipa_2.is_equivalent(s_ipa_1)  # True   s_ipa_1.is_equivalent(s_ipa_3)  # True   s_ipa_2.is_equivalent(s_ipa_3)  # True   # compare IPAString and list of IPAChar objects   s_ipa_1.is_equivalent([my_a1, my_tS, my_ee])    # True   # compare IPAString and Unicode string   s_ipa_d.is_equivalent(u&quot;diff&quot;)                  # True   s_ipa_1.is_equivalent(u&quot;atse&quot;)                  # False   s_ipa_1.is_equivalent(u&quot;atSe&quot;)                  # False   s_ipa_1.is_equivalent(u&quot;at͡ʃe&quot;)                  # True   s_ipa_1.is_equivalent(u&quot;at͜ʃe&quot;)                  # True   s_ipa_1.is_equivalent(u&quot;aʧe&quot;)                   # True   s_ipa_1.is_equivalent(u&quot;at͡ʃeLOL&quot;, ignore=True)  # True (ignore chars non IPA valid)   s_ipa_1.is_equivalent(u&quot;at͡ʃeLoL&quot;, ignore=True)  # False (ignore chars non IPA valid, note extra &quot;o&quot;)   ########################   # CONVERSION FUNCTIONS #   ########################   from ipapy.kirshenbaummapper import KirshenbaumMapper   kmapper = KirshenbaumMapper()                                    # mapper to Kirshenbaum ASCII IPA   s_k_ipa = kmapper.map_ipa_string(s_ipa)                          # u&quot;@'ki:n#&amp;,k&amp;n'TA#l@#dZi&quot;   s_k_uni = kmapper.map_unicode_string(s_uni)                      # u&quot;@'ki:n#&amp;,k&amp;n'TA#l@#dZi&quot;   s_k_ipa == s_k_uni                                               # True   s_k_lis = kmapper.map_unicode_string(s_uni, return_as_list=True) # [u'@', u&quot;'&quot;, u'k', u'i', u':', u'n', u'#', u'&amp;', u',', u'k', u'&amp;', u'n', u&quot;'&quot;, u'T', u'A', u'#', u'l', u'@', u'#', u'dZ', u'i']   from ipapy.arpabetmapper import ARPABETMapper   amapper = ARPABETMapper()                                                    # mapper to ARPABET ASCII IPA (stress marks not supported yet)   s_a = amapper.map_unicode_string(u&quot;pɹuːf&quot;)                                   # error: long suprasegmental not mapped   s_a = amapper.map_unicode_string(u&quot;pɹuːf&quot;, ignore=True)                      # u&quot;PRUWF&quot;   s_a = amapper.map_unicode_string(u&quot;pɹuːf&quot;, ignore=True, return_as_list=True) # [u'P', u'R', u'UW', u'F']As A Command Line Tool~~~~~~~~~~~~~~~~~~~~~~**ipapy** comes with a command line tool to perform operations on agiven Unicode UTF-8 encoded string, representing an IPA string.Therefore, it is recommended to run it on a shell supporting UTF-8.Currently, the supported operations are:-  ``canonize``: canonize the Unicode representation of the IPA string-  ``chars``: list all IPA characters appearing in the IPA string-  ``check``: check if the given Unicode string is IPA valid-  ``clean``: remove characters that are not IPA valid-  ``u2a``: print the corresponding ARPABET (ASCII IPA) string-  ``u2k``: print the corresponding Kirshenbaum (ASCII IPA) stringRun with the ``--help`` parameter to list all the available options:.. code:: bash   $ python -m ipapy --help   usage: __main__.py [-h] [-i] [-p] [--separator [SEPARATOR]] [-s] [-u]                      command string   ipapy perform a command on the given IPA/Unicode string   positional arguments:     command               [canonize|chars|check|clean|u2a|u2k]     string                String to canonize, check, clean, or convert   optional arguments:     -h, --help            show this help message and exit     -i, --ignore          Ignore Unicode characters that are not IPA valid     -p, --print-invalid   Print Unicode characters that are not IPA valid     --separator [SEPARATOR]                           Print IPA chars separated by this character (default:                           '')     -s, --single-char-parsing                           Perform single character parsing instead of maximal                           parsing     -u, --unicode         Print each Unicode character that is not IPA valid                           with its Unicode codepoint and nameExamples:.. code:: bash   $ python -m ipapy canonize &quot;eʧiu&quot;   et͡ʃiu   $ python -m ipapy canonize &quot;eʧiu&quot; --separator &quot; &quot;   e t͡ʃ i u   $ python -m ipapy chars &quot;eʧiu&quot;   'e' vowel close-mid front unrounded (U+0065)   't͡ʃ'   consonant voiceless palato-alveolar sibilant-affricate (U+0074 U+0361 U+0283)   'i' vowel close front unrounded (U+0069)   'u' vowel close back rounded (U+0075)   $ python -m ipapy chars &quot;et͡ʃiu&quot;   'e' vowel close-mid front unrounded (U+0065)   't͡ʃ'   consonant voiceless palato-alveolar sibilant-affricate (U+0074 U+0361 U+0283)   'i' vowel close front unrounded (U+0069)   'u' vowel close back rounded (U+0075)   $ python -m ipapy chars &quot;et͡ʃiu&quot; -s   'e' vowel close-mid front unrounded (U+0065)   't' consonant voiceless alveolar plosive (U+0074)   '͡' diacritic tie-bar-above (U+0361)   'ʃ' consonant voiceless palato-alveolar sibilant-fricative (U+0283)   'i' vowel close front unrounded (U+0069)   'u' vowel close back rounded (U+0075)   $ python -m ipapy check &quot;eʧiu&quot;   True   $ python -m ipapy check &quot;LoL&quot;   False   $ python -m ipapy check &quot;LoL&quot; -p   False   LL   $ python -m ipapy check &quot;LoLOL&quot; -p -u   False   LLOL   'L' 0x4c    LATIN CAPITAL LETTER L   'O' 0x4f    LATIN CAPITAL LETTER O   $ python -m ipapy clean &quot;/eʧiu/&quot;   eʧiu   $ python -m ipapy u2k &quot;eʧiu&quot;   etSiu   $ python -m ipapy u2k &quot;eTa&quot;   The given string contains characters not IPA valid. Use the 'ignore' option to ignore them.   $ python -m ipapy u2k &quot;eTa&quot; -i   ea   $ python -m ipapy u2a &quot;eʧiu&quot; --separator &quot; &quot;   EH CH IH UWUnit Testing------------.. code:: bash   $ python run_all_unit_tests.pyLicense-------**ipapy** is released under the MIT License.Acknowledgments----------------  Bram Vanroy provided a fix to ``setup.py`` for Windows users</longdescription>
</pkgmetadata>