<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Expression[![PyPI](https://img.shields.io/pypi/v/expression.svg)](https://pypi.python.org/pypi/Expression)![Python package](https://github.com/cognitedata/expression/workflows/Python%20package/badge.svg)![Upload Python Package](https://github.com/cognitedata/expression/workflows/Upload%20Python%20Package/badge.svg)[![Documentation Status](https://readthedocs.org/projects/expression/badge/?version=latest)](https://expression.readthedocs.io/en/latest/?badge=latest)[![codecov](https://codecov.io/gh/cognitedata/expression/branch/main/graph/badge.svg)](https://codecov.io/gh/cognitedata/expression)&gt; Pragmatic functional programmingExpression aims to be a solid, type-safe, pragmatic, and high performancelibrary for frictionless and practical functional programming in Python 3.9+.By pragmatic, we mean that the goal of the library is to use simple abstractionsto enable you to do practical and productive functional programming in Python(instead of being a [Monad tutorial](https://github.com/dbrattli/OSlash)).Python is a multi-paradigm programming language that also supports functionalprogramming constructs such as functions, higher-order functions, lambdas, andin many ways favors composition over inheritance.&gt; Better Python with F#Expression tries to make a better Python by providing several functionalfeatures inspired by [F#](https://fsharp.org). This serves severalpurposes:- Enable functional programming in a Pythonic way, i.e., make sure we are not  over-abstracting things. Expression will not require purely functional  programming as would a language like Haskell.- Everything you learn with Expression can also be used with F#. Learn F# by  starting in a programming language they already know. Perhaps get inspired to  also [try out F#](https://aka.ms/fsharphome) by itself.- Make it easier for F# developers to use Python when needed, and re-use many  of the concepts and abstractions they already know and love.Expression will enable you to work with Python using many of the sameprogramming concepts and abstractions. This enables concepts such as [Railwayoriented programming](https://fsharpforfunandprofit.com/rop/) (ROP) for betterand predictable error handling. Pipelining for workflows, computationalexpressions, etc.&gt; _Expressions evaluate to a value. Statements do something._F# is a functional programming language for .NET that is succinct (concise,readable, and type-safe) and kind of[Pythonic](https://docs.python.org/3/glossary.html). F# is in many ways verysimilar to Python, but F# can also do a lot of things better than Python:- Strongly typed, if it compiles it usually works making refactoring much  safer. You can trust the type-system. With [mypy](http://mypy-lang.org/) or  [Pylance](https://github.com/microsoft/pylance-release) you often wonder who  is right and who is wrong.- Type inference, the compiler deduces types during compilation- Expression based language## Getting StartedYou can install the latest `expression` from PyPI by running `pip` (or`pip3`). Note that `expression` only works for Python 3.9+.```console&gt; pip3 install expression```## Goals- Industrial strength library for functional programming in Python.- The resulting code should look and feel like Python  ([PEP-8](https://www.python.org/dev/peps/pep-0008/)). We want to make a  better Python, not some obscure DSL or academic Monad tutorial.- Provide pipelining and pipe friendly methods. Compose all the things!- Dot-chaining on objects as an alternative syntax to pipes.- Lower the cognitive load on the programmer by:  - Avoid currying, not supported in Python by default and not a well known    concept by Python programmers.  - Avoid operator (`|`, `&gt;&gt;`, etc) overloading, this usually confuses more    than it helps.  - Avoid recursion. Recursion is not normally used in Python and any use of it    should be hidden within the SDK.- Provide [type-hints](https://docs.python.org/3/library/typing.html) for all  functions and methods.- Support PEP 634 and structural pattern matching.- Code must pass strict static type checking by  [pylance](https://devblogs.microsoft.com/python/announcing-pylance-fast-feature-rich-language-support-for-python-in-visual-studio-code/).  Pylance is awesome, use it!- [Pydantic](https://pydantic-docs.helpmanual.io/) friendly data types. Use Expression  types as part of your Pydantic data model and (de)serialize to/from JSON.## Supported featuresExpression will never provide you with all the features of F# and .NET. We areproviding a few of the features we think are useful, and will add moreon-demand as we go along.- **Pipelining** - for creating workflows.- **Composition** - for composing and creating new operators.- **Fluent or Functional** syntax, i.e., dot chain or pipeline operators.- **Pattern Matching** - an alternative flow control to `if-elif-else`.- **Error Handling** - Several error handling types.  - **Option** - for optional stuff and better `None` handling.  - **Result** - for better error handling and enables railway-oriented    programming in Python.  - **Try** - a simpler result type that pins the error to an Exception.- **Collections** - immutable collections.  - **TypedArray** - a generic array type that abstracts the details of    `bytearray`, `array.array` and `list` modules.  - **Sequence** - a better    [itertools](https://docs.python.org/3/library/itertools.html) and    fully compatible with Python iterables.  - **Block** - a frozen and immutable list type.  - **Map** - a frozen and immutable dictionary type.  - **AsyncSeq** - Asynchronous iterables.  - **AsyncObservable** - Asynchronous observables. Provided separately    by [aioreactive](https://github.com/dbrattli/aioreactive).- **Data Modelling** - sum and product types  - **TaggedUnion** - A tagged (discriminated) union type.- **Parser Combinators** - A recursive decent string parser combinator  library.- **Effects**: - lightweight computational expressions for Python. This  is amazing stuff.  - **option** - an optional world for working with optional values.  - **result** - an error handling world for working with result values.- **Mailbox Processor**: for lock free programming using the [Actor  model](https://en.wikipedia.org/wiki/Actor_model).- **Cancellation Token**: for cancellation of asynchronous (and  synchronous) workflows.- **Disposable**: For resource management.### PipeliningExpression provides a `pipe` function similar to `|&gt;` in F#. We don't want tooverload any Python operators, e.g., `|` so `pipe` is a plain old function takingN-arguments, and will let you pipe a value through any number of functions.```pythonfrom expression import pipev = 1fn = lambda x: x + 1gn = lambda x: x * 2assert pipe(v, fn, gn) == gn(fn(v))```Expression objects (e.g., `Some`, `Seq`, `Result`) also have a `pipe` method, so you can dot chain pipelinesdirectly on the object:```pythonfrom expression import Somev = Some(1)fn = lambda x: x.map(lambda y: y + 1)gn = lambda x: x.map(lambda y: y * 2)assert v.pipe(fn, gn) == gn(fn(v))```So for example with sequences you may create sequence transformingpipelines:```pythonfrom expression.collections import seq, Seqxs = Seq.of(9, 10, 11)ys = xs.pipe(    seq.map(lambda x: x * 10),    seq.filter(lambda x: x &gt; 100),    seq.fold(lambda s, x: s + x, 0))assert ys == 110```### CompositionFunctions may even be composed directly into custom operators:```pythonfrom expression import composefrom expression.collections import seq, Seqxs = Seq.of(9, 10, 11)custom = compose(    seq.map(lambda x: x * 10),    seq.filter(lambda x: x &gt; 100),    seq.fold(lambda s, x: s + x, 0))ys = custom(xs)assert ys == 110```### Fluent and FunctionalExpression can be used both with a fluent or functional syntax (or both.)#### Fluent syntaxThe fluent syntax uses methods and is very compact. But it might get you intotrouble for large pipelines since it's not a natural way of adding line breaks.```pythonfrom expression.collections import Seqxs = Seq.of(1, 2, 3)ys = xs.map(lambda x: x * 100).filter(lambda x: x &gt; 100).fold(lambda s, x: s + x, 0)```Note that fluent syntax is probably the better choice if you use mypyfor type checking since mypy may have problems inferring types throughlarger pipelines.#### Functional syntaxThe functional syntax is a bit more verbose but you can easily add newoperations on new lines. The functional syntax is great to use togetherwith pylance/pyright.```pythonfrom expression import pipefrom expression.collections import seq, Seqxs = Seq.of(1, 2, 3)ys = pipe(xs,    seq.map(lambda x: x * 100),    seq.filter(lambda x: x &gt; 100),    seq.fold(lambda s, x: s + x, 0),)```Both fluent and functional syntax may be mixed and even pipe can be usedfluently.```pythonfrom expression.collections import seq, Seqxs = Seq.of(1, 2, 3).pipe(seq.map(...))```### OptionThe `Option` type is used when a function or method cannot produce a meaningfuloutput for a given input.An option value may have a value of a given type, i.e., `Some(value)`, or it mightnot have any meaningful value, i.e., `Nothing`.```pythonfrom expression import Some, Nothing, Optiondef keep_positive(a: int) -&gt; Option[int]:    if a &gt; 0:        return Some(a)    return Nothing``````pythonfrom expression import Option, Okdef exists(x : Option[int]) -&gt; bool:    match x:        case Some(_):            return True    return False```### Option as an effectEffects in Expression is implemented as specially decorated coroutines([enhanced generators](https://www.python.org/dev/peps/pep-0342/)) using`yield`, `yield from` and `return` to consume or generate optional values:```pythonfrom expression import effect, Some@effect.option[int]()def fn():    x = yield 42    y = yield from Some(43)    return x + yxs = fn()```This enables [&quot;railway orientedprogramming&quot;](https://fsharpforfunandprofit.com/rop/), e.g., if one part of thefunction yields from `Nothing` then the function is side-tracked(short-circuit) and the following statements will never be executed. The endresult of the expression will be `Nothing`. Thus results from such an optiondecorated function can either be `Ok(value)` or `Error(error_value)`.```pythonfrom expression import effect, Some, Nothing@effect.option[int]()def fn():    x = yield from Nothing # or a function returning Nothing    # -- The rest of the function will never be executed --    y = yield from Some(43)    return x + yxs = fn()assert xs is Nothing```For more information about options:- [Tutorial](https://expression.readthedocs.io/en/latest/tutorial/optional_values.html)- [API reference](https://expression.readthedocs.io/en/latest/reference/option.html)### ResultThe `Result[T, TError]` type lets you write error-tolerant code that can becomposed. A Result works similar to `Option`, but lets you define the value usedfor errors, e.g., an exception type or similar. This is great when you want toknow why some operation failed (not just `Nothing`). This type serves the samepurpose of an `Either` type where `Left` is used for the error condition and `Right`for a success value.```pythonfrom expression import effect, Ok, Result@effect.result[int, Exception]()def fn():    x = yield from Ok(42)    y = yield from Ok(10)    return x + yxs = fn()assert isinstance(xs, Result)```A simplified type called `Try` is also available. It's a result type that ispinned to `Exception` i.e., `Result[TSource, Exception]`.### SequenceSequences is a thin wrapper on top of iterables and contains operations for working withPython iterables. Iterables are immutable by design, and perfectly suited for functionalprogramming.```pythonimport functoolsfrom expression import pipefrom expression.collections import seq# Normal python way. Nested functions are hard to read since you need to# start reading from the end of the expression.xs = range(100)ys = functools.reduce(lambda s, x: s + x, filter(lambda x: x &gt; 100, map(lambda x: x * 10, xs)), 0)# With Expression, you pipe the result, so it flows from one operator to the next:zs = pipe(    xs,    seq.map(lambda x: x * 10),    seq.filter(lambda x: x &gt; 100),    seq.fold(lambda s, x: s + x, 0),)assert ys == zs```## Tagged UnionsTagged Unions (aka discriminated unions) may look similar to normal Python Unions. Butthey are [different](https://stackoverflow.com/a/61646841) in that the operands in atype union `(A | B)` are both types, while the cases in a tagged union type `U = A | B`are both constructors for the type U and are not types themselves. One consequence isthat tagged unions can be nested in a way union types might not.In Expression you make a tagged union by defining your type as a sub-class of`TaggedUnion` with the appropriate generic types that this union represent foreach case. Then you define static or class-method constructors for creating each of thetagged union cases.```pythonfrom dataclasses import dataclassfrom expression import TaggedUnion, tag@dataclassclass Rectangle:    width: float    length: float@dataclassclass Circle:    radius: floatclass Shape(TaggedUnion):    RECTANGLE = tag(Rectangle)    CIRCLE = tag(Circle)    @staticmethod    def rectangle(width: float, length: float) -&gt; Shape:        return Shape(Shape.RECTANGLE, Rectangle(width, length))    @staticmethod    def circle(radius: float) -&gt; Shape:        return Shape(Shape.CIRCLE, Circle(radius))```Now you may pattern match the shape to get back the actual value:```python    from expression import match    shape = Shape.Rectangle(2.3, 3.3)    match shape:        case Shape(value=Rectangle(width=2.3)):            assert shape.value.width == 2.3        case _:            assert False```## Notable differences between Expression and F#In F# modules are capitalized, in Python they are lowercase([PEP-8](https://www.python.org/dev/peps/pep-0008/#package-and-module-names)).E.g in F# `Option` is both a module (`OptionModule` internally) and atype. In Python the module is `option` and the type is capitalized i.e`Option`.Thus in Expression you use `option` as the module to access module functionssuch as `option.map` and the name `Option` for the type itself.```pycon&gt;&gt;&gt; from expression import Option, option&gt;&gt;&gt; Option&lt;class 'expression.core.option.Option'&gt;&gt;&gt;&gt; option&lt;module 'expression.core.option' from '/Users/dbrattli/Developer/Github/Expression/expression/core/option.py'&gt;```## Common Gotchas and PitfallsA list of common problems and how you may solve it:### Expression is missing the function/operator I needRemember that everything is just a function, so you can easily implementa custom function yourself and use it with Expression. If you think thefunction is also usable for others, then please open a PR to include itwith Expression.## Resources and ReferencesA collection of resources that were used as reference and inspirationfor creating this library.- F# (http://fsharp.org)- Get Started with F# (https://aka.ms/fsharphome)- F# as a Better Python - Phillip Carter - NDC Oslo 2020  (https://www.youtube.com/watch?v=_QnbV6CAWXc)- OSlash (https://github.com/dbrattli/OSlash)- RxPY (https://github.com/ReactiveX/RxPY)- PEP 8 -- Style Guide for Python Code (https://www.python.org/dev/peps/pep-0008/)- PEP 342 -- Coroutines via Enhanced Generators  (https://www.python.org/dev/peps/pep-0342/)- PEP 380 -- Syntax for Delegating to a Subgenerator  (https://www.python.org/dev/peps/pep-0380)- PEP 479 -- Change StopIteration handling inside generators (https://www.python.org/dev/peps/pep-0479/)- PEP 634 -- Structural Pattern Matching (https://www.python.org/dev/peps/pep-0634/)- Thunks, Trampolines and Continuation Passing  (https://jtauber.com/blog/2008/03/30/thunks,_trampolines_and_continuation_passing/)- Tail Recursion Elimination  (http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html)- Final Words on Tail Calls  (http://neopythonic.blogspot.com/2009/04/final-words-on-tail-calls.html)- Python is the Haskell You Never Knew You Had: Tail Call Optimization  (https://sagnibak.github.io/blog/python-is-haskell-tail-recursion/)## How-to ContributeYou are very welcome to contribute with suggestions or PRs :heart_eyes: It isnice if you can try to align the code and naming with F# modules, functions,and documentation if possible. But submit a PR even if you should feel unsure.Code, doc-strings, and comments should also follow the [Google Python StyleGuide](https://google.github.io/styleguide/pyguide.html).Code checks are done using- [Black](https://github.com/psf/black)- [flake8](https://github.com/PyCQA/flake8)- [isort](https://github.com/PyCQA/isort)To run code checks on changed files every time you commit, install the pre-commit hooksby running:```console&gt; pre-commit install```## Code of ConductThis project follows https://www.contributor-covenant.org, see our [CodeofConduct](https://github.com/cognitedata/Expression/blob/main/CODE_OF_CONDUCT.md).## LicenseMIT, see [LICENSE](https://github.com/cognitedata/Expression/blob/main/LICENSE).</longdescription>
</pkgmetadata>