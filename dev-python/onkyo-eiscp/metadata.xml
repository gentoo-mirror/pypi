<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Onkyo eISCP Control===================This is a Python library to control and interact with Onkyo receiversover the network. It is also a ready-made command line script youcan use without knowing how to program.Finally, this repository contains a YAML file containing all thecommands defined by the Onkyo protocol, automatically generated byparsing the official documentation. Even if you are not usingPython, you may find this file useful when implementing your owninterface. See further down below for more information.Installation------------Most recent released version::    $ easy_install onkyo-eiscpUsage-----The package installs a script called ``onkyo``, that can be used from thecommand line::    $ onkyo system-power=offThis will turn your receiver off. You may notice that you haven't given anyinformation as to where in the network your receiver is. The script shouldin fact be able to find your Onkyo device by itself.To see which receivers the script is able to find, you can use::    $ onkyo --discoverIf you have multiple receivers on your network, then by default, it willsimply connect to the first device found (which may be a different oneevery time).You can select a specific one by filtering by name::    $ onkyo --discover    TX-NR709 192.168.178.200:60128 0009B0D34163    TX-NR609 192.168.178.169:60128 0009B0D24B75       $ onkyo -n 709 system-power=onThis will only turn on the TX-NR709 device.Or using the unique identifier::    $ onkyo -i 0009B0D24B75 system-power=onThis will turn on the TX-NR609 device.There is also an ``--all`` flag, to send you commands to all devices at once.Finally, you are of course able to manually specify the device to connect to::    $ onkyo --host 172.20.0.144 volume=55    $ onkyo --host 172.20.0.144 --port 42424 volume=55To find out which commands are available, use the ``--help-commands`` option.Commands--------A command consists of three parts: The zone, the command, and the arguments.Here are some examples::    system-power=on    zone2.power=on    main.balance=3As you can see, the basic format is::    zone.command=argumentIf you do not specify a zone, then ``main`` is assumed.There are some variations on this syntax that are possible, for example thefollowing are all equivalent::    power on    power:on    main.power on    main power onIn other words, instead of the ``.`` and ``=`` separators, whitespace maybe used, and the colon ``:`` is an alternative to ``=``. However, it's bestto use the suggested syntax above.The names of these commands are defined by this project, and are rewrittento actual low-level eISCP commands Onkyo uses. If you know them, you canalso send such low-level commands directly::    $ onkyo SLI26     # Selects the &quot;Tuner&quot; source.Notes on Power On~~~~~~~~~~~~~~~~~For the ``power on`` command to work while the device is in standby, makesure you turn on the obtusely named``Setup -&gt; Hardware -&gt; Network -&gt; Network Control`` option.Without it, you can only connect to your receiver while it is alreadyturned on.Python module-------------In a simple case, this might look like this:.. code:: python    import eiscp    # Create a receiver object, connecting to the host    receiver = eiscp.eISCP('192.168.1.125')    # Turn the receiver on, select PC input    receiver.command('power on')    receiver.command('source pc')    receiver.disconnect()Don't forget to call ``disconnect()`` to close the socket. You can also usea ``with`` statement:.. code:: python    with eiscp.eISCP('192.168.1.125') as receiver:        receiver.command('source all-ch-stereo')The command language is explained above. You can also be more explict withthe structure::    receiver.command('power', 'on', zone='main')If you prefer to send low-level ISCP commands directly, you can use the`raw` method::    receiver.raw('MVLUP')The function `command_to_iscp` will allow you to convert a high-levelcommand to a low-level ISCP message for use with `eISCP.raw`.Receiving messages~~~~~~~~~~~~~~~~~~The Onkyo receiver will send messages to you as well. Specifically, itreturns a response to every command you send, either by repeating thecommand you have sent back to you, or, in case you sent a querymessage, reporting the answer to you query. It will also send unsolicitedstatus updates to you whenver the state of the receiver changes.API-wise, the `eISCP.raw` and `eISCP.command` return theresponse received from the Onkyo device. They are blocking.To receive other messages, there is `eISCP.get`, which willeither return a message or ``None``. You may specify a custom timeoutvalue... warning::    At least for now, there is no queue. If you call    `eISCP.raw` or `eISCP.command`, any messages not picked    up via `eISCP.get` are lost.A problem with the Onkyo protocol is that there is no fool-proof way todifferentiate a response from unsolicited status updates. Generally, thiswon't be an issue, though in theory the response that is given to youafter sending ``SLI05`` may be a ``SLI06`` update from another controller.It is thus preferable to approach the protocol in a different way. Insteadof using `eISCP.raw` or `eISCP.command`, which try to serializethe exchange into a request-response scheme, you may also use`eISCP.send`, which dispatches a message without waiting for a response.You would then use `get` to process all incoming messages in the sameway, regardless of why they were sent. This works well, since a response toeither a command or a query is no different than a status update.Async API~~~~~~~~~There is also an experimental `eiscp.Receiver`, which has thesame api as `eiscp.eISCP`, but uses a background thread fornetwork communication. This allows you to handle incoming messagesvia a callback::    def message_received(message):        print message    receiver = Receiver('...')    receiver.on_message = message_receivedNote that the ``on_message`` handler is executed on the backgroundthread, so you may want to use a queue.For consistancy, `eISCP.raw` and `eISCP.command` are stilldesigned to artificially block, while `eISCP.send` is non-blocking.Device discovery~~~~~~~~~~~~~~~~You can have it find the receivers on your local network:.. code:: python    for receiver in eiscp.eISCP.discover(timeout=5):        receiver.command('power off')This will turn off all the Onkyo receivers on your network.A discovered device has an ``info`` attribute that gives you some data:.. code:: python    {'iscp_port': '60128', 'identifier': '0009B04448E0',     'area_code': 'XX', 'model_name': 'TX-NR709', 'device_category': '1'}Limitations------------ Some commands require a more complex argument structure, like  variable-length strings, and those are not yet supported (you can  send them in raw mode of course).The YAML file-------------This repository contains a YAML file containing all the commandsdefined by the Onkyo protocol, automatically generated byparsing the official Excel documentation, and then further adjustedmanually.The idea is to have a computer-readable definition of the Onkyoprotocol, where Onkyo's internal low-level commands are mapped toidentifiers that can be understood by humans, and which includedescriptions.Parsing the Onkyo Excel document gets you astonishingly far, butthere's a limit. The YAML file requires manual edits and fixes wherethe parser fails, including a lot of cosmetic corrections. Some ofthose have been made, but there's significant room for improvingthe YAML description of the protocol.The process and the specific YAML formatting have been chosen toallow future changes to the Onkyo master document to be merged withthe manual adjustments made as painlessly as possible.To summarize, if you are implementing your own interface to Onkyo,even if it's in a language other than Python, I encourage you toconsider using this YAML file as a basis for the command interfaceyou provide to users. You'll have a complete list of availablecommands, values, and even supported devices.Related Links-------------Documents from Onkyo describing the protocol, including lists of supported commands:    - http://michael.elsdoerfer.name/onkyo/ISCP_AVR_134.xlsx    - http://michael.elsdoerfer.name/onkyo/ISCP_AVR_2014.Models.xlsx    - http://michael.elsdoerfer.name/onkyo/ISCP-V1.26_2013.xlsx    - http://michael.elsdoerfer.name/onkyo/ISCP-V1.21_2011.xlsThe repository on which this was originally based on:    https://github.com/compbrain/Onkyo-TX-NR708-ControlAn implementation in Perl:    https://github.com/beanz/device-onkyo-perlAn implementation in C#:    http://code.google.com/p/onkyo-eiscp-remote-windows/An implementation in Object-C:    https://github.com/janten/onkyo-eiscp-remote-macMQTT connectivity for onkyo-eiscp, adhering to the mqtt-smarthome specification:    https://github.com/owagner/onkyo2mqttSome Java code that deserves credit for providing the original Onkyo protocol documentation linked above:    https://sites.google.com/a/webarts.ca/toms-blog/Blog/new-blog-items/javaeiscp-integraserialcontrolprotocol</longdescription>
</pkgmetadata>