<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Async-first dependency injection library based on python type hints## QuickstartFirst let's create a class we would be injecting:```pythonclass Service:    pass```Then we should create instance of container and register `Service` class in it using a provider:```pythonfrom aioinject import Container, providerscontainer = Container()container.register(providers.Callable(Service))```Then we can create a context and resolve our `Service` class from it:```pythonwith container.sync_context() as ctx:    service = ctx.resolve(Service)```If you need to inject something into a function just annotate it with inject:```pythonfrom aioinject import inject@injectdef awesome_function(service: Service):    print(service)```And call it within an active context:```pythonwith container.sync_conext() as ctx:    awesome_function()```Complete example (should run as-is):```pythonfrom typing import Annotatedfrom aioinject import Container, Inject, inject, providersclass Service:    passcontainer = Container()container.register(providers.Callable(Service))@injectdef awesome_function(    service: Service,):    print(service)with container.sync_context() as ctx:    service = ctx.resolve(Service)    awesome_function()```## Specifying DependenciesTo mark parameters for injection we can use `typing.Annotated`and `Inject` marker```pythonfrom typing import Annotatedfrom aioinject import Callable, Container, Injectclass Session:    passclass Service:    def __init__(self, session: Session):        self.session = sessioncontainer = Container()container.register(Callable(Session))container.register(Callable(Service))with container.sync_context() as ctx:    service = ctx.resolve(Service)```If you have multiple dependencies with same type you can specify concrete implementation in `Inject`:```pythonimport dataclassesfrom typing import Annotatedfrom aioinject import Container, providers, inject, Inject@dataclasses.dataclassclass Client:    name: strdef get_github_client() -&gt; Client:    return Client(name=&quot;GitHub Client&quot;)def get_gitlab_client() -&gt; Client:    return Client(name=&quot;GitLab Client&quot;)container = Container()container.register(providers.Callable(get_github_client))container.register(providers.Callable(get_gitlab_client))@injectdef injectee(    github_client: Annotated[Client, Inject(get_github_client)],    gitlab_client: Annotated[Client, Inject(get_gitlab_client)],):    print(github_client, gitlab_client)with container.sync_context() as ctx:    # Manually resolving client    client = ctx.resolve(Client, impl=get_github_client)    print(client)    injectee()```## Working with ResourcesOften you need to initialize and close a resource (file, database session, etc...),you can do that by using a `contextmanager` that would return your resource.  We would use custom `Session` class that defines `__exit__` and `__enter__` methods:```pythonimport contextlibfrom aioinject import Container, providersclass Session:    def __init__(self):        self.closed = False    def __enter__(self):        return self    def __exit__(self, exc_type, exc_val, exc_tb):        self.closed = True@contextlib.contextmanagerdef get_session() -&gt; Session:    with Session() as session:        yield sessioncontainer = Container()container.register(providers.Callable(get_session))with container.sync_context() as ctx:    session = ctx.resolve(Session)    print(session.closed)print(session.closed)  # &lt;- Session.__exit__ would be called when context closes```## Async DependenciesYou can register async resolvers the same way as you do with other dependencies,all you need to change is to use `Container.context` instead of `Container.sync_context`:```pythonimport asynciofrom aioinject import Container, providersclass Service:    passasync def get_service() -&gt; Service:    await asyncio.sleep(1)    return Service()async def main():    container = Container()    container.register(providers.Callable(get_service))    async with container.context() as ctx:        service = await ctx.resolve(Service)        print(service)if __name__ == '__main__':    asyncio.run(main())```## ProvidersWhen creating a provider you should specify the type it returns, but it can be inferred from class type or functionreturn type:### Callable`Callable` provider would create instance of a class each time:```pythonfrom aioinject import Callableclass Service:    passprovider = Callable(Service)service_one = provider.provide_sync()service_two = provider.provide_sync()print(service_one is service_two)# False```### Singleton`Singleton` works the same way as `Callable` but it caches first created object:```pythonfrom aioinject import Singletonclass Service:    passprovider = Singleton(Service)first = provider.provide_sync()second = provider.provide_sync()print(first is second)# True```### Object`Object` provider just returns an object provided to it:```pythonfrom aioinject import Objectclass Service:    passprovider = Object(Service())service = provider.provide_sync()print(service)# &lt;__main__.Service&gt;```</longdescription>
</pkgmetadata>