<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>django-optimistic-lock======================.. image:: https://secure.travis-ci.org/gavinwahl/django-optimistic-lock.png?branch=master   :target: https://travis-ci.org/gavinwahl/django-optimistic-lockImplements an offline optimistic lock [1]_ for Django models.Usage-----Add a ``VersionField`` and inherit from ``VersionedMixin``... code-block:: python    from ool import VersionField, VersionedMixin    class MyModel(VersionedMixin, models.Model):        version = VersionField()Whenever ``MyModel`` is saved, the version will be checked to ensurethe instance has not changed since it was last fetched. If there is aconflict, a ``ConcurrentUpdate`` exception will be raised.Implementation--------------A ``VersionField`` is just an integer that increments itself everytime its model is saved. ``VersionedMixin`` overrides ``_do_update``(which is called by ``save`` to actually do the update) to add an extracondition to the update query -- that the version in the database isthe same as the model's version. If they match, there have been noconcurrent modifications. If they don't match, the UPDATE statement willnot update any rows, and we know that someone else saved first.This produces SQL that looks something like::    UPDATE mymodel SET version = version + 1, ... WHERE id = %s AND version = %sWhen no rows were updated, we know someone else won and we need to raisea ``ConcurrentUpdate``.Comparison to ``django-concurrency``^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^`django-concurrency &lt;https://github.com/saxix/django-concurrency&gt;`_ beforeversion 0.7 used ``SELECT FOR UPDATE`` to implement the version checking. Iwanted to avoid database-level locking, so ``django-optimistic-lock`` adds aversion filter to the update statement, as described by Martin Fowler [1]_.Additionally, ool takes a more minimalistic approach thandjango-concurrency by only doing one thing -- optimistic locking --without any monkey-patching, middleware, settings variables, adminclasses, or form fields. django-concurrency would probably make more senseif you're looking for something that will attempt to accommodate everysituation out of the box. Use ool if you just want a straightforward modelimplementation and need to handle the UI and surrounding architectureyourself.Running the tests-----------------::    make test.. [1] http://martinfowler.com/eaaCatalog/optimisticOfflineLock.html.. [2] https://code.djangoproject.com/ticket/16649</longdescription>
</pkgmetadata>