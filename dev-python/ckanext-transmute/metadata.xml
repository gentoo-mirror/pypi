<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># ckanext-transmuteThe extension helps to validate and converts a dataset based on a specific schema.## Working with transmute`ckanext-transmute` provides an action `tsm_transmute` It helps us to transmute data with the provided convertion scheme. The action doesn't change the original data, but creates a new data dict. There are two mandatory arguments - `data` and `schema`. `data` is a data dict you have and `schema` helps you to validate/change data in it.Example:We have a data dict:```{            &quot;title&quot;: &quot;Test-dataset&quot;,            &quot;email&quot;: &quot;test@test.ua&quot;,            &quot;metadata_created&quot;: &quot;&quot;,            &quot;metadata_modified&quot;: &quot;&quot;,            &quot;metadata_reviewed&quot;: &quot;&quot;,            &quot;resources&quot;: [                {                    &quot;title&quot;: &quot;test-res&quot;,                    &quot;extension&quot;: &quot;xml&quot;,                    &quot;web&quot;: &quot;https://stackoverflow.com/&quot;,                    &quot;sub-resources&quot;: [                        {                            &quot;title&quot;: &quot;sub-res&quot;,                            &quot;extension&quot;: &quot;csv&quot;,                            &quot;extra&quot;: &quot;should-be-removed&quot;,                        }                    ],                },                {                    &quot;title&quot;: &quot;test-res2&quot;,                    &quot;extension&quot;: &quot;csv&quot;,                    &quot;web&quot;: &quot;https://stackoverflow.com/&quot;,                },            ],        }```And we want to achieve this:```{            &quot;name&quot;: &quot;test-dataset&quot;,            &quot;email&quot;: &quot;test@test.ua&quot;,            &quot;metadata_created&quot;: datetime.datetime(2022, 2, 3, 15, 54, 26, 359453),            &quot;metadata_modified&quot;: datetime.datetime(2022, 2, 3, 15, 54, 26, 359453),            &quot;metadata_reviewed&quot;: datetime.datetime(2022, 2, 3, 15, 54, 26, 359453),            &quot;attachments&quot;: [                {                    &quot;name&quot;: &quot;test-res&quot;,                    &quot;format&quot;: &quot;XML&quot;,                    &quot;url&quot;: &quot;https://stackoverflow.com/&quot;,                    &quot;sub-resources&quot;: [{&quot;name&quot;: &quot;SUB-RES&quot;, &quot;format&quot;: &quot;CSV&quot;}],                },                {                    &quot;name&quot;: &quot;test-res2&quot;,                    &quot;format&quot;: &quot;CSV&quot;,                    &quot;url&quot;: &quot;https://stackoverflow.com/&quot;,                },            ],        }```Then, our schema must be something like that:```{        &quot;root&quot;: &quot;Dataset&quot;,        &quot;types&quot;: {            &quot;Dataset&quot;: {                &quot;fields&quot;: {                    &quot;title&quot;: {                        &quot;validators&quot;: [                            &quot;tsm_string_only&quot;,                            &quot;tsm_to_lowercase&quot;,                            &quot;tsm_name_validator&quot;,                        ],                        &quot;map&quot;: &quot;name&quot;,                    },                    &quot;resources&quot;: {                        &quot;type&quot;: &quot;Resource&quot;,                        &quot;multiple&quot;: True,                        &quot;map&quot;: &quot;attachments&quot;,                    },                    &quot;metadata_created&quot;: {                        &quot;validators&quot;: [&quot;tsm_isodate&quot;],                        &quot;default&quot;: &quot;2022-02-03T15:54:26.359453&quot;,                    },                    &quot;metadata_modified&quot;: {                        &quot;validators&quot;: [&quot;tsm_isodate&quot;],                        &quot;default_from&quot;: &quot;metadata_created&quot;,                    },                    &quot;metadata_reviewed&quot;: {                        &quot;validators&quot;: [&quot;tsm_isodate&quot;],                        &quot;replace_from&quot;: &quot;metadata_modified&quot;,                    },                }            },            &quot;Resource&quot;: {                &quot;fields&quot;: {                    &quot;title&quot;: {                        &quot;validators&quot;: [&quot;tsm_string_only&quot;],                        &quot;map&quot;: &quot;name&quot;,                    },                    &quot;extension&quot;: {                        &quot;validators&quot;: [&quot;tsm_string_only&quot;, &quot;tsm_to_uppercase&quot;],                        &quot;map&quot;: &quot;format&quot;,                    },                    &quot;web&quot;: {                        &quot;validators&quot;: [&quot;tsm_string_only&quot;],                        &quot;map&quot;: &quot;url&quot;,                    },                    &quot;sub-resources&quot;: {                        &quot;type&quot;: &quot;Sub-Resource&quot;,                        &quot;multiple&quot;: True,                    },                },            },            &quot;Sub-Resource&quot;: {                &quot;fields&quot;: {                    &quot;title&quot;: {                        &quot;validators&quot;: [&quot;tsm_string_only&quot;, &quot;tsm_to_uppercase&quot;],                        &quot;map&quot;: &quot;name&quot;,                    },                    &quot;extension&quot;: {                        &quot;validators&quot;: [&quot;tsm_string_only&quot;, &quot;tsm_to_uppercase&quot;],                        &quot;map&quot;: &quot;format&quot;,                    },                    &quot;extra&quot;: {                        &quot;remove&quot;: True,                    },                }            },        },    }```There is an example of schema with nested types. The `root` field is mandatory, it's must contain a main type name, from which the scheme starts. As you can see, `Dataset` type contains `Resource` type which contans `Sub-Resource`.### TransmutatorsThere are few default transmutators you can use in your schema. Of course, you can define a custom transmutator with the `ITransmute` interface.- `tsm_name_validator` - Wrapper over CKAN default `name_validator` validator- `tsm_to_lowercase` - Casts string value to a lowercase- `tsm_to_uppercase` - Casts string value to a uppercase- `tsm_string_only` - Validates if `field.value` is string- `tsm_isodate` - Validates datetime string. Mutates an iso-like string to datetime object- `tsm_to_string` - Casts a `field.value` to `str`- `tsm_get_nested` - Allows you to pick up a value from a nested structure. Example:```data = &quot;title_translated&quot;: [    {&quot;nested_field&quot;: {&quot;en&quot;: &quot;en title&quot;, &quot;ar&quot;: &quot;العنوان ar&quot;}},]schema = ...    &quot;title&quot;: {        &quot;replace_from&quot;: &quot;title_translated&quot;,        &quot;validators&quot;: [            [&quot;tsm_get_nested&quot;, 0, &quot;nested_field&quot;, &quot;en&quot;],            &quot;tsm_to_uppercase&quot;,        ],    },    ...```This will take a value for a `title` field from `title_translated` field. Because `title_translated` is an array with nested objects, we are using the `tsm_get_nested` transmutator to achieve the value from it.- `tsm_trim_string` - Trim string with max lenght. Example to trim `hello world` to `hello`:```data = {&quot;field_name&quot;: &quot;hello world}schema = ...    &quot;field_name&quot;: {        &quot;validators&quot;: [            [&quot;tsm_trim_string&quot;, 5]        ],    },    ...```- `tsm_concat` - Trim string with max lenght. Use `$self` to point on field value. Example:```data = {&quot;id&quot;: &quot;dataset-1}schema = ...    &quot;package_url&quot;: {        &quot;replace_from&quot;: &quot;id&quot;,        &quot;validators&quot;: [            [                &quot;tsm_concat&quot;,                &quot;https://site.url/dataset/&quot;,                &quot;$self&quot;,            ]        ],    },    ...```- `tsm_unique_only` - Preserve only unique values from a list. Works only with lists.The default transmutator must receive at least one mandatory argument - `field` object. Field contains few properties: `field_name`, `value` and `type`.There is a possibility to provide more arguments to a validator like in `tsm_get_nested`. For this use a nested array with first item transmutator and other - arguments to it.### Keywords1. `map_to` (`str`) - changes the `field.name` in result dict.2. `validators` (`list[str]`) - a list of transmutators that will be applied to a `field.value`. A transmutator could be a `string` or a `list` where the first item must be transmutator name and others are arbitrary values. Example:    ```    ...    &quot;validators&quot;: [        [&quot;tsm_get_nested&quot;, &quot;nested_field&quot;, &quot;en&quot;],        &quot;tsm_to_uppercase&quot;,    ,    ...    ```    There are two transmutators: `tsm_get_nested` and `tsm_to_uppercase`.3. `multiple` (`bool`, default: `False`) - if the field could have multiple items, e.g `resources` field in dataset, mark it as `multiple` to transmute all the items successively.    ```    ...    &quot;resources&quot;: {        &quot;type&quot;: &quot;Resource&quot;,        &quot;multiple&quot;: True    },    ...    ```4. `remove` (`bool`, default: `False`) - removes a field from a result dict if `True`.5. `default` (`Any`) - the default value that will be used if the original field.value evaluates to `False`.6. `default_from` (`str` | `list`) - acts similar to `default` but accepts a `field.name` of a sibling field from which we want to take its value. Sibling field is a field that located in the same `type`. The current implementation doesn't allow to point on fields from other `types`. Could take a string that represents the `field.name` or an array of strings, to use multiple fields. See `inherit_mode` keyword for details.    ```    ...    &quot;metadata_modified&quot;: {        &quot;validators&quot;: [&quot;tsm_isodate&quot;],        &quot;default_from&quot;: &quot;metadata_created&quot;,    },    ...    ```7. `replace_from` (`str`| `list`) - acts similar to `default_from` but replaces the origin value whenever it's empty or not.8. `inherit_mode` (`str`, default: `combine`) - defines the mode for `default_from` and `replace_from`. By default we are combining valuesfrom all the fields, but we could just use first non-false value, in case if the field might be empty.9. `value` (`Any`) - a value that will be used for a field. This keyword has the highest priority. Could be used to create a new field with an arbitrary value.10. `update` (`bool`, default: `False) - if the original value is mutable (`array, object`) - you can update it. You can only update field values of the same types.## InstallationTo install ckanext-transmute:1. Activate your CKAN virtual environment, for example:     . /usr/lib/ckan/default/bin/activate2. Clone the source and install it on the virtualenv    git clone https://github.com/mutantsan/ckanext-transmute.git    cd ckanext-transmute    pip install -e .pip install -r requirements.txt3. Add `transmute` to the `ckan.plugins` setting in your CKAN   config file (by default the config file is located at   `/etc/ckan/default/ckan.ini`).4. Restart CKAN. For example if you've deployed CKAN with Apache on Ubuntu:     sudo service apache2 reload## Developer installationTo install ckanext-transmute for development, activate your CKAN virtualenv anddo:    git clone https://github.com/mutantsan/ckanext-transmute.git    cd ckanext-transmute    python setup.py develop    pip install -r dev-requirements.txt## TestsI've used TDD to write this extension, so if you changing something be sure that all the tests are valid. To run the tests, do:    pytest --ckan-ini=test.ini## License[AGPL](https://www.gnu.org/licenses/agpl-3.0.en.html)</longdescription>
</pkgmetadata>