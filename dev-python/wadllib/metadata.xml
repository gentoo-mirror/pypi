<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>..   Copyright (C) 2008-2013 Canonical Ltd.   This file is part of wadllib.   wadllib is free software: you can redistribute it and/or modify it under   the terms of the GNU Lesser General Public License as published by the   Free Software Foundation, version 3 of the License.   wadllib is distributed in the hope that it will be useful, but WITHOUT ANY   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for   more details.   You should have received a copy of the GNU Lesser General Public License   along with wadllib. If not, see &lt;http://www.gnu.org/licenses/&gt;.=======wadllib=======An Application object represents a web service described by a WADLfile.   &gt;&gt;&gt; import os   &gt;&gt;&gt; import sys   &gt;&gt;&gt; import pkg_resources   &gt;&gt;&gt; from wadllib.application import ApplicationThe first argument to the Application constructor is the URL at whichthe WADL file was found. The second argument may be raw WADL markup.   &gt;&gt;&gt; wadl_string = pkg_resources.resource_string(   ...     'wadllib.tests.data', 'launchpad-wadl.xml')   &gt;&gt;&gt; wadl = Application(&quot;http://api.launchpad.dev/beta/&quot;, wadl_string)Or the second argument may be an open filehandle containing the markup.   &gt;&gt;&gt; cleanups = []   &gt;&gt;&gt; def application_for(filename, url=&quot;http://www.example.com/&quot;):   ...    wadl_stream = pkg_resources.resource_stream(   ...    'wadllib.tests.data', filename)   ...    cleanups.append(wadl_stream)   ...    return Application(url, wadl_stream)   &gt;&gt;&gt; wadl = application_for(&quot;launchpad-wadl.xml&quot;,   ...                        &quot;http://api.launchpad.dev/beta/&quot;)Link navigation===============The preferred technique for finding a resource is to start at one ofthe resources defined in the WADL file, and follow links. This coderetrieves the definition of the root resource.   &gt;&gt;&gt; service_root = wadl.get_resource_by_path('')   &gt;&gt;&gt; service_root.url   'http://api.launchpad.dev/beta/'   &gt;&gt;&gt; service_root.type_url   '#service-root'The service root resource supports GET.   &gt;&gt;&gt; get_method = service_root.get_method('get')   &gt;&gt;&gt; get_method.id   'service-root-get'   &gt;&gt;&gt; get_method = service_root.get_method('GET')   &gt;&gt;&gt; get_method.id   'service-root-get'If we want to invoke this method, we send a GET request to the serviceroot URL.   &gt;&gt;&gt; get_method.name   'get'   &gt;&gt;&gt; get_method.build_request_url()   'http://api.launchpad.dev/beta/'The WADL description of a resource knows which representations areavailable for that resource. In this case, the server root resourcehas a a JSON representation, and it defines parameters like'people_collection_link', a link to a list of people in Launchpad. Weshould be able to use the get_parameter() method to get the WADLdefinition of the 'people_collection_link' parameter and find out moreabout it--for instance, is it a link to another resource?   &gt;&gt;&gt; def test_raises(exc_class, method, *args, **kwargs):   ...     try:   ...         method(*args, **kwargs)   ...     except Exception:   ...         # Contortion to support Python &lt; 2.6 and &gt;= 3 simultaneously.   ...         e = sys.exc_info()[1]   ...         if isinstance(e, exc_class):   ...             print(e)   ...             return   ...         raise   ...     raise Exception(&quot;Expected exception %s not raised&quot; % exc_class)   &gt;&gt;&gt; from wadllib.application import NoBoundRepresentationError   &gt;&gt;&gt; link_name = 'people_collection_link'   &gt;&gt;&gt; test_raises(   ...     NoBoundRepresentationError, service_root.get_parameter, link_name)   Resource is not bound to any representation, and no media media type was specified.Oops. The code has no way to know whether 'people_collection_link' isa parameter of the JSON representation or some other kind ofrepresentation. We can pass a media type to get_parameter and let itknow which representation the parameter lives in.   &gt;&gt;&gt; link_parameter = service_root.get_parameter(   ...     link_name, 'application/json')   &gt;&gt;&gt; test_raises(NoBoundRepresentationError, link_parameter.get_value)   Resource is not bound to any representation.Oops again. The parameter is available, but it has no value, becausethere's no actual data associated with the resource. The browser canlook up the description of the GET method to make an actual GETrequest to the service root, and bind the resulting representation tothe WADL description of the service root.You can't bind just any representation to a WADL resource description.It has to be of a media type understood by the WADL description.   &gt;&gt;&gt; from wadllib.application import UnsupportedMediaTypeError   &gt;&gt;&gt; test_raises(   ...     UnsupportedMediaTypeError, service_root.bind,   ...     '&lt;html&gt;Some HTML&lt;/html&gt;', 'text/html')   This resource doesn't define a representation for media type text/htmlThe WADL description of the service root resource has a JSONrepresentation. Here it is.   &gt;&gt;&gt; json_representation = service_root.get_representation_definition(   ...     'application/json')   &gt;&gt;&gt; json_representation.media_type   'application/json'We already have a WADL representation of the service root resource, solet's try binding it to that JSON representation. We use test JSONdata from a file to simulate the result of a GET request to theservice root.   &gt;&gt;&gt; def get_testdata(filename):   ...     return pkg_resources.resource_string(   ...         'wadllib.tests.data', filename + '.json')   &gt;&gt;&gt; def bind_to_testdata(resource, filename):   ...     return resource.bind(get_testdata(filename), 'application/json')The return value is a new Resource object that's &quot;bound&quot; to that JSONtest data.   &gt;&gt;&gt; bound_service_root = bind_to_testdata(service_root, 'root')   &gt;&gt;&gt; sorted([param.name for param in bound_service_root.parameters()])   ['bugs_collection_link', 'people_collection_link']   &gt;&gt;&gt; sorted(bound_service_root.parameter_names())   ['bugs_collection_link', 'people_collection_link']   &gt;&gt;&gt; [method.id for method in bound_service_root.method_iter]   ['service-root-get']Now the bound resource object has a JSON representation, and now'people_collection_link' makes sense. We can follow the'people_collection_link' to a new Resource object.   &gt;&gt;&gt; link_parameter = bound_service_root.get_parameter(link_name)   &gt;&gt;&gt; link_parameter.style   'plain'   &gt;&gt;&gt; print(link_parameter.get_value())   http://api.launchpad.dev/beta/people   &gt;&gt;&gt; personset_resource = link_parameter.linked_resource   &gt;&gt;&gt; personset_resource.__class__   &lt;class 'wadllib.application.Resource'&gt;   &gt;&gt;&gt; print(personset_resource.url)   http://api.launchpad.dev/beta/people   &gt;&gt;&gt; personset_resource.type_url   'http://api.launchpad.dev/beta/#people'This new resource is a collection of people.   &gt;&gt;&gt; personset_resource.id   'people'The &quot;collection of people&quot; resource supports a standard GET request aswell as a special GET and an overloaded POST. The get_method() methodis used to retrieve WADL definitions of the possible HTTP requests youmight make. Here's how to get the WADL definition of the standard GETrequest.   &gt;&gt;&gt; get_method = personset_resource.get_method('get')   &gt;&gt;&gt; get_method.id   'people-get'The method name passed into get_method() is treated case-insensitively.   &gt;&gt;&gt; personset_resource.get_method('GET').id   'people-get'To invoke the special GET request, the client sets the 'ws.op' queryparameter to the fixed string 'findPerson'.   &gt;&gt;&gt; find_method = personset_resource.get_method(   ...     query_params={'ws.op' : 'findPerson'})   &gt;&gt;&gt; find_method.id   'people-findPerson'Given an end-user's values for the non-fixed parameters, it's possibleto get the URL that should be used to invoke the method.   &gt;&gt;&gt; print(find_method.build_request_url(text='foo'))   http://api.launchpad.dev/beta/people?text=foo&amp;ws.op=findPerson   &gt;&gt;&gt; print(find_method.build_request_url(   ...     {'ws.op' : 'findPerson', 'text' : 'bar'}))   http://api.launchpad.dev/beta/people?text=bar&amp;ws.op=findPersonAn error occurs if the end-user gives an incorrect value for a fixedparameter value, or omits a required parameter.   &gt;&gt;&gt; find_method.build_request_url()   Traceback (most recent call last):   ...   ValueError: No value for required parameter 'text'   &gt;&gt;&gt; find_method.build_request_url(   ...     {'ws.op' : 'findAPerson', 'text' : 'foo'})   ... # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE   Traceback (most recent call last):   ...   ValueError: Value 'findAPerson' for parameter 'ws.op' conflicts   with fixed value 'findPerson'To invoke the overloaded POST request, the client sets the 'ws.op'query variable to the fixed string 'newTeam':   &gt;&gt;&gt; create_team_method = personset_resource.get_method(   ...     'post', representation_params={'ws.op' : 'newTeam'})   &gt;&gt;&gt; create_team_method.id   'people-newTeam'findMethod() returns None when there's no WADL method matching thename or the fixed parameters.   &gt;&gt;&gt; print(personset_resource.get_method('nosuchmethod'))   None   &gt;&gt;&gt; print(personset_resource.get_method(   ...     'post', query_params={'ws_op' : 'nosuchparam'}))   NoneLet's say the browser makes a GET request to the person set resourceand gets back a representation. We can bind that representation to ourdescription of the person set resource.   &gt;&gt;&gt; bound_personset = bind_to_testdata(personset_resource, 'personset')   &gt;&gt;&gt; bound_personset.get_parameter(&quot;start&quot;).get_value()   0   &gt;&gt;&gt; bound_personset.get_parameter(&quot;total_size&quot;).get_value()   63We can keep following links indefinitely, so long as we bind to arepresentation to each resource as we get it, and use therepresentation to find the next link.   &gt;&gt;&gt; next_page_link = bound_personset.get_parameter(&quot;next_collection_link&quot;)   &gt;&gt;&gt; print(next_page_link.get_value())   http://api.launchpad.dev/beta/people?ws.start=5&amp;ws.size=5   &gt;&gt;&gt; page_two = next_page_link.linked_resource   &gt;&gt;&gt; bound_page_two = bind_to_testdata(page_two, 'personset-page2')   &gt;&gt;&gt; print(bound_page_two.url)   http://api.launchpad.dev/beta/people?ws.start=5&amp;ws.size=5   &gt;&gt;&gt; bound_page_two.get_parameter(&quot;start&quot;).get_value()   5   &gt;&gt;&gt; print(bound_page_two.get_parameter(&quot;next_collection_link&quot;).get_value())   http://api.launchpad.dev/beta/people?ws.start=10&amp;ws.size=5Let's say the browser makes a POST request that invokes the 'newTeam'named operation. The response will include a number of HTTP headers,including 'Location', which points the way to the newly created team.   &gt;&gt;&gt; headers = { 'Location' : 'http://api.launchpad.dev/~newteam' }   &gt;&gt;&gt; response = create_team_method.response.bind(headers)   &gt;&gt;&gt; location_parameter = response.get_parameter('Location')   &gt;&gt;&gt; location_parameter.get_value()   'http://api.launchpad.dev/~newteam'   &gt;&gt;&gt; new_team = location_parameter.linked_resource   &gt;&gt;&gt; new_team.url   'http://api.launchpad.dev/~newteam'   &gt;&gt;&gt; new_team.type_url   'http://api.launchpad.dev/beta/#team'Examining links---------------The 'linked_resource' property of a parameter lets you follow a linkto another object. The 'link' property of a parameter lets you examinelinks before following them.    &gt;&gt;&gt; import json    &gt;&gt;&gt; links_wadl = application_for('links-wadl.xml')    &gt;&gt;&gt; service_root = links_wadl.get_resource_by_path('')    &gt;&gt;&gt; representation = json.dumps(    ...     {'scalar_value': 'foo',    ...      'known_link': 'http://known/',    ...      'unknown_link': 'http://unknown/'})    &gt;&gt;&gt; bound_root = service_root.bind(representation)    &gt;&gt;&gt; print(bound_root.get_parameter(&quot;scalar_value&quot;).link)    None    &gt;&gt;&gt; known_resource = bound_root.get_parameter(&quot;known_link&quot;)    &gt;&gt;&gt; unknown_resource = bound_root.get_parameter(&quot;unknown_link&quot;)    &gt;&gt;&gt; print(known_resource.link.can_follow)    True    &gt;&gt;&gt; print(unknown_resource.link.can_follow)    FalseA link whose type is unknown is a link to a resource not described byWADL. Following this link using .linked_resource or .link.follow willcause a wadllib error. You'll need to follow the link using a generalHTTP library or some other tool.    &gt;&gt;&gt; known_resource.link.follow    &lt;wadllib.application.Resource object ...&gt;    &gt;&gt;&gt; known_resource.linked_resource    &lt;wadllib.application.Resource object ...&gt;    &gt;&gt;&gt; from wadllib.application import WADLError    &gt;&gt;&gt; test_raises(WADLError, getattr, unknown_resource.link, 'follow')    Cannot follow a link when the target has no WADL    description. Try using a general HTTP client instead.    &gt;&gt;&gt; test_raises(WADLError, getattr, unknown_resource, 'linked_resource')    Cannot follow a link when the target has no WADL    description. Try using a general HTTP client instead.Creating a Resource from a representation definition====================================================Although every representation is a representation of some HTTPresource, an HTTP resource doesn't necessarily correspond directly toa WADL &lt;resource&gt; or &lt;resource_type&gt; tag. Sometimes a representationis defined within a WADL &lt;method&gt; tag.   &gt;&gt;&gt; find_method = personset_resource.get_method(   ...     query_params={'ws.op' : 'find'})   &gt;&gt;&gt; find_method.id   'people-find'   &gt;&gt;&gt; representation_definition = (   ...     find_method.response.get_representation_definition(   ...     'application/json'))There may be no WADL &lt;resource&gt; or &lt;resource_type&gt; tag for therepresentation defined here. That's why wadllib makes it possible toinstantiate an anonymous Resource object using only the representationdefinition.   &gt;&gt;&gt; from wadllib.application import Resource   &gt;&gt;&gt; anonymous_resource = Resource(   ...     wadl, &quot;http://foo/&quot;, representation_definition.tag)We can bind this resource to a representation, as long as weexplicitly pass in the representation definition.   &gt;&gt;&gt; anonymous_resource = anonymous_resource.bind(   ...     get_testdata('personset'), 'application/json',   ...     representation_definition=representation_definition)Once the resource is bound to a representation, we can get itsparameter values.   &gt;&gt;&gt; print(anonymous_resource.get_parameter(   ...     'total_size', 'application/json').get_value())   63Resource instantiation======================If you happen to have the URL to an object lying around, and you knowits type, you can construct a Resource object directly instead ofby following links.   &gt;&gt;&gt; from wadllib.application import Resource   &gt;&gt;&gt; limi_person = Resource(wadl, &quot;http://api.launchpad.dev/beta/~limi&quot;,   ...     &quot;http://api.launchpad.dev/beta/#person&quot;)   &gt;&gt;&gt; sorted([method.id for method in limi_person.method_iter])[:3]   ['person-acceptInvitationToBeMemberOf', 'person-addMember', 'person-declineInvitationToBeMemberOf']   &gt;&gt;&gt; bound_limi = bind_to_testdata(limi_person, 'person-limi')   &gt;&gt;&gt; sorted(bound_limi.parameter_names())[:3]   ['admins_collection_link', 'confirmed_email_addresses_collection_link',    'date_created']   &gt;&gt;&gt; languages_link = bound_limi.get_parameter(&quot;languages_collection_link&quot;)   &gt;&gt;&gt; print(languages_link.get_value())   http://api.launchpad.dev/beta/~limi/languagesYou can bind a Resource to a representation when you create it.   &gt;&gt;&gt; limi_data = get_testdata('person-limi')   &gt;&gt;&gt; bound_limi = Resource(   ...     wadl, &quot;http://api.launchpad.dev/beta/~limi&quot;,   ...     &quot;http://api.launchpad.dev/beta/#person&quot;, limi_data,   ...     &quot;application/json&quot;)   &gt;&gt;&gt; print(bound_limi.get_parameter(   ...     &quot;languages_collection_link&quot;).get_value())   http://api.launchpad.dev/beta/~limi/languagesBy default the representation is treated as a string and processedaccording to the media type you pass into the Resource constructor. Ifyou've already processed the representation, pass in False for the'representation_needs_processing' argument.   &gt;&gt;&gt; from wadllib import _make_unicode   &gt;&gt;&gt; processed_limi_data = json.loads(_make_unicode(limi_data))   &gt;&gt;&gt; bound_limi = Resource(wadl, &quot;http://api.launchpad.dev/beta/~limi&quot;,   ...     &quot;http://api.launchpad.dev/beta/#person&quot;, processed_limi_data,   ...     &quot;application/json&quot;, False)   &gt;&gt;&gt; print(bound_limi.get_parameter(   ...     &quot;languages_collection_link&quot;).get_value())   http://api.launchpad.dev/beta/~limi/languagesMost of the time, the representation of a resource is of the typeyou'd get by sending a standard GET to that resource. If that's notthe case, you can specify a RepresentationDefinition as the'representation_definition' argument to bind() or the Resourceconstructor, to show what the representation really looks like. Here'san example.There's a method on a person resource such as bound_limi that'sidentified by a distinctive query argument: ws.op=getMembersByStatus.   &gt;&gt;&gt; method = bound_limi.get_method(   ...     query_params={'ws.op' : 'findPathToTeam'})Invoke this method with a GET request and you'll get back a page froma list of people.   &gt;&gt;&gt; people_page_repr_definition = (   ...     method.response.get_representation_definition('application/json'))   &gt;&gt;&gt; people_page_repr_definition.tag.attrib['href']   'http://api.launchpad.dev/beta/#person-page'As it happens, we have a page from a list of people to use as test data.   &gt;&gt;&gt; people_page_repr = get_testdata('personset')If we bind the resource to the result of the method invocation ashappened above, we don't be able to access any of the parameters we'dexpect. wadllib will think the representation is of type'person-full', the default GET type for bound_limi.   &gt;&gt;&gt; bad_people_page = bound_limi.bind(people_page_repr)   &gt;&gt;&gt; print(bad_people_page.get_parameter('total_size'))   NoneSince we don't actually have a 'person-full' representation, we won'tbe able to get values for the parameters of that kind ofrepresentation.   &gt;&gt;&gt; bad_people_page.get_parameter('name').get_value()   Traceback (most recent call last):   ...   KeyError: 'name'So that's a dead end. *But*, if we pass the correct representationtype into bind(), we can access the parameters associated with a'person-page' representation.   &gt;&gt;&gt; people_page = bound_limi.bind(   ...     people_page_repr,   ...     representation_definition=people_page_repr_definition)   &gt;&gt;&gt; people_page.get_parameter('total_size').get_value()   63If you invoke the method and ask for a media type other than JSON, youwon't get anything.   &gt;&gt;&gt; print(method.response.get_representation_definition('text/html'))   NoneData type conversion--------------------The values of date and dateTime parameters are automatically converted toPython datetime objects.   &gt;&gt;&gt; data_type_wadl = application_for('data-types-wadl.xml')   &gt;&gt;&gt; service_root = data_type_wadl.get_resource_by_path('')   &gt;&gt;&gt; representation = json.dumps(   ...     {'a_date': '2007-10-20',   ...      'a_datetime': '2005-06-06T08:59:51.619713+00:00'})   &gt;&gt;&gt; bound_root = service_root.bind(representation, 'application/json')   &gt;&gt;&gt; bound_root.get_parameter('a_date').get_value()   datetime.datetime(2007, 10, 20, 0, 0)   &gt;&gt;&gt; bound_root.get_parameter('a_datetime').get_value()   datetime.datetime(2005, 6, 6, 8, ...)A 'date' field can include a timestamp, and a 'datetime' field canomit one. wadllib will turn both into datetime objects.   &gt;&gt;&gt; representation = json.dumps(   ...     {'a_date': '2005-06-06T08:59:51.619713+00:00',   ...      'a_datetime': '2007-10-20'})   &gt;&gt;&gt; bound_root = service_root.bind(representation, 'application/json')   &gt;&gt;&gt; bound_root.get_parameter('a_datetime').get_value()   datetime.datetime(2007, 10, 20, 0, 0)   &gt;&gt;&gt; bound_root.get_parameter('a_date').get_value()   datetime.datetime(2005, 6, 6, 8, ...)If a date or dateTime parameter has a null value, you get None. If thevalue is a string that can't be parsed to a datetime object, you get aValueError.   &gt;&gt;&gt; representation = json.dumps(   ...     {'a_date': 'foo', 'a_datetime': None})   &gt;&gt;&gt; bound_root = service_root.bind(representation, 'application/json')   &gt;&gt;&gt; bound_root.get_parameter('a_date').get_value()   Traceback (most recent call last):   ...   ValueError: foo   &gt;&gt;&gt; print(bound_root.get_parameter('a_datetime').get_value())   NoneRepresentation creation=======================You must provide a representation when invoking certain methods. Therepresentation() method helps you build one without knowing thedetails of how a representation is put together.   &gt;&gt;&gt; create_team_method.build_representation(   ...     display_name='Joe Bloggs', name='joebloggs')   ('application/x-www-form-urlencoded', 'display_name=Joe+Bloggs&amp;name=joebloggs&amp;ws.op=newTeam')The return value of build_representation is a 2-tuple containing themedia type of the built representation, and the string representationitself. Along with the resource's URL, this is all you need to sendthe representation to a web server.   &gt;&gt;&gt; bound_limi.get_method('patch').build_representation(name='limi2')   ('application/json', '{&quot;name&quot;: &quot;limi2&quot;}')Representations may require values for certain parameters.   &gt;&gt;&gt; create_team_method.build_representation()   Traceback (most recent call last):   ...   ValueError: No value for required parameter 'display_name'   &gt;&gt;&gt; bound_limi.get_method('put').build_representation(name='limi2')   Traceback (most recent call last):   ...   ValueError: No value for required parameter 'mugshot_link'Some representations may safely include binary data.   &gt;&gt;&gt; binary_stream = pkg_resources.resource_stream(   ...     'wadllib.tests.data', 'multipart-binary-wadl.xml')   &gt;&gt;&gt; cleanups.append(binary_stream)   &gt;&gt;&gt; binary_wadl = Application(   ...     &quot;http://www.example.com/&quot;, binary_stream)   &gt;&gt;&gt; service_root = binary_wadl.get_resource_by_path('')Define a helper that processes the representation the same wayzope.publisher would.   &gt;&gt;&gt; import cgi   &gt;&gt;&gt; import io   &gt;&gt;&gt; def assert_message_parts(media_type, doc, expected):   ...     environ = {   ...         'REQUEST_METHOD': 'POST',   ...         'CONTENT_TYPE': media_type,   ...         'CONTENT_LENGTH': str(len(doc)),   ...         }   ...     kwargs = (   ...         {'encoding': 'UTF-8'} if sys.version_info[0] &gt;= 3 else {})   ...     fs = cgi.FieldStorage(   ...         fp=io.BytesIO(doc), environ=environ, keep_blank_values=1,   ...         **kwargs)   ...     values = []   ...     def append_values(fields):   ...         for field in fields:   ...             if field.list:   ...                 append_values(field.list)   ...             else:   ...                 values.append(field.value)   ...     append_values(fs.list)   ...     assert values == expected, (   ...         'Expected %s, got %s' % (expected, values))   &gt;&gt;&gt; method = service_root.get_method('post', 'multipart/form-data')   &gt;&gt;&gt; media_type, doc = method.build_representation(   ...     text_field=&quot;text&quot;, binary_field=b&quot;\x01\x02\r\x81\r&quot;)   &gt;&gt;&gt; print(media_type)   multipart/form-data; boundary=...   &gt;&gt;&gt; assert_message_parts(media_type, doc, ['text', b'\x01\x02\r\x81\r'])   &gt;&gt;&gt; method = service_root.get_method('post', 'multipart/form-data')   &gt;&gt;&gt; media_type, doc = method.build_representation(   ...     text_field=u&quot;text&quot;, binary_field=b&quot;\x01\x02\r\x81\r&quot;)   &gt;&gt;&gt; print(media_type)   multipart/form-data; boundary=...   &gt;&gt;&gt; assert_message_parts(media_type, doc, ['text', b'\x01\x02\r\x81\r'])   &gt;&gt;&gt; method = service_root.get_method('post', 'multipart/form-data')   &gt;&gt;&gt; media_type, doc = method.build_representation(   ...     text_field=&quot;text\n&quot;, binary_field=b&quot;\x01\x02\r\x81\n\r&quot;)   &gt;&gt;&gt; print(media_type)   multipart/form-data; boundary=...   &gt;&gt;&gt; assert_message_parts(   ...     media_type, doc, ['text\r\n', b'\x01\x02\r\x81\n\r'])   &gt;&gt;&gt; method = service_root.get_method('post', 'multipart/form-data')   &gt;&gt;&gt; media_type, doc = method.build_representation(   ...     text_field=u&quot;text\n&quot;, binary_field=b&quot;\x01\x02\r\x81\n\r&quot;)   &gt;&gt;&gt; print(media_type)   multipart/form-data; boundary=...   &gt;&gt;&gt; assert_message_parts(   ...     media_type, doc, ['text\r\n', b'\x01\x02\r\x81\n\r'])   &gt;&gt;&gt; method = service_root.get_method('post', 'multipart/form-data')   &gt;&gt;&gt; media_type, doc = method.build_representation(   ...     text_field=&quot;text\r\nmore\r\n&quot;,   ...     binary_field=b&quot;\x01\x02\r\n\x81\r\x82\n&quot;)   &gt;&gt;&gt; print(media_type)   multipart/form-data; boundary=...   &gt;&gt;&gt; assert_message_parts(   ...     media_type, doc, ['text\r\nmore\r\n', b'\x01\x02\r\n\x81\r\x82\n'])   &gt;&gt;&gt; method = service_root.get_method('post', 'multipart/form-data')   &gt;&gt;&gt; media_type, doc = method.build_representation(   ...     text_field=u&quot;text\r\nmore\r\n&quot;,   ...     binary_field=b&quot;\x01\x02\r\n\x81\r\x82\n&quot;)   &gt;&gt;&gt; print(media_type)   multipart/form-data; boundary=...   &gt;&gt;&gt; assert_message_parts(   ...     media_type, doc, ['text\r\nmore\r\n', b'\x01\x02\r\n\x81\r\x82\n'])   &gt;&gt;&gt; method = service_root.get_method('post', 'text/unknown')   &gt;&gt;&gt; method.build_representation(field=&quot;value&quot;)   Traceback (most recent call last):   ...   ValueError: Unsupported media type: 'text/unknown'Options=======Some parameters take values from a predefined list of options.   &gt;&gt;&gt; option_wadl = application_for('options-wadl.xml')   &gt;&gt;&gt; definitions = option_wadl.representation_definitions   &gt;&gt;&gt; service_root = option_wadl.get_resource_by_path('')   &gt;&gt;&gt; definition = definitions['service-root-json']   &gt;&gt;&gt; param = definition.params(service_root)[0]   &gt;&gt;&gt; print(param.name)   has_options   &gt;&gt;&gt; sorted([option.value for option in param.options])   ['Value 1', 'Value 2']Such parameters cannot take values that are not in the list.   &gt;&gt;&gt; definition.validate_param_values(   ...     [param], {'has_options': 'Value 1'})   {'has_options': 'Value 1'}   &gt;&gt;&gt; definition.validate_param_values(   ...     [param], {'has_options': 'Invalid value'})   Traceback (most recent call last):   ...   ValueError: Invalid value 'Invalid value' for parameter   'has_options': valid values are: &quot;Value 1&quot;, &quot;Value 2&quot;Error conditions================You'll get None if you try to look up a nonexistent resource.   &gt;&gt;&gt; print(wadl.get_resource_by_path('nosuchresource'))   NoneYou'll get an exception if you try to look up a nonexistent resourcetype.   &gt;&gt;&gt; print(wadl.get_resource_type('#nosuchtype'))   Traceback (most recent call last):   KeyError: 'No such XML ID: &quot;#nosuchtype&quot;'You'll get None if you try to look up a method whose parameters don'tmatch any defined method.   &gt;&gt;&gt; print(bound_limi.get_method(   ...     'post', representation_params={ 'foo' : 'bar' }))   None.. cleanup   &gt;&gt;&gt; for stream in cleanups:   ...    stream.close()================NEWS for wadllib================1.3.6 (2021-09-13)==================- Remove buildout support in favour of tox.  [bug=922605]- Adjust versioning strategy to avoid importing pkg_resources, which is slow  in large environments.1.3.5 (2021-01-20)==================- Drop support for Python 3.2, 3.3, and 3.4.- Accept Unicode parameter values again when performing multipart/form-data  encoding on Python 2 (broken in 1.3.3).1.3.4 (2020-04-29)==================- Advertise support for Python 3.8.- Add Python 3.9 compatibility by using xml.etree.ElementTree if  xml.etree.cElementTree does not exist.  [bug=1870294]1.3.3 (2018-07-20)==================- Drop support for Python &lt; 2.6.- Add tox testing support.- Implement a subset of MIME multipart/form-data encoding locally rather  than using the standard library's email module, which doesn't have good  handling of binary parts and corrupts bytes in them that look like line  endings in various ways depending on the Python version.  [bug=1729754]1.3.2 (2013-02-25)==================- Impose sort order to avoid test failures due to hash randomization.  LP: #1132125- Be sure to close streams opened by pkg_resources.resource_stream() to avoid  test suite complaints.1.3.1 (2012-03-22)==================- Correct the double pass through _from_string causing datetime issues1.3.0 (2012-01-27)==================- Add Python 3 compatibility- Add the ability to inspect links before following them.- Ensure that the sample data is packaged.1.2.0 (2011-02-03)==================- It's now possible to examine a link before following it, to see  whether it has a WADL description or whether it needs to be fetched  with a general HTTP client.- It's now possible to iterate over a resource's Parameter objects  with the .parameters() method.1.1.8 (2010-10-27)==================- This revision contains no code changes, but the build system was  changed (yet again).  This time to include the version.txt file  used by setup.py.1.1.7 (2010-10-26)==================- This revision contains no code changes, but the build system was  changed (again) to include the sample data used in tests.1.1.6 (2010-10-21)==================- This revision contains no code changes, but the build system was  changed to include the sample data used in tests.1.1.5 (2010-05-04)==================- Fixed a bug (Launchpad bug 274074) that prevented the lookup of  parameter values in resources associated directly with a  representation definition (rather than a resource type with a  representation definition). Bug fix provided by James Westby.1.1.4 (2009-09-15)==================- Fixed a bug that crashed wadllib unless all parameters of a  multipart representation were provided.1.1.3 (2009-08-26)==================- Remove unnecessary build dependencies.- Add missing dependencies to setup file.- Remove sys.path hack from setup.py.1.1.2 (2009-08-20)==================- Consistently handle different versions of simplejson.1.1.1 (2009-07-14)==================- Make wadllib aware of the &lt;option&gt; tags that go beneath &lt;param&gt; tags.1.1 (2009-07-09)================- Make wadllib capable of recognizing and generating  multipart/form-data representations, including representations that  incorporate binary parameters.1.0 (2009-03-23)================- Initial release on PyPI</longdescription>
</pkgmetadata>