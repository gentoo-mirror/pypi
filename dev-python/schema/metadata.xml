<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Schema validation just got Pythonic===============================================================================**schema** is a library for validating Python data structures, such as thoseobtained from config-files, forms, external services or command-lineparsing, converted from JSON/YAML (or something else) to Python data-types... image:: https://secure.travis-ci.org/keleshev/schema.svg?branch=master    :target: https://travis-ci.org/keleshev/schema.. image:: https://img.shields.io/codecov/c/github/keleshev/schema.svg    :target: http://codecov.io/github/keleshev/schemaExample----------------------------------------------------------------------------Here is a quick example to get a feeling of **schema**, validating a list ofentries with personal information:.. code:: python    &gt;&gt;&gt; from schema import Schema, And, Use, Optional, SchemaError    &gt;&gt;&gt; schema = Schema([{'name': And(str, len),    ...                   'age':  And(Use(int), lambda n: 18 &lt;= n &lt;= 99),    ...                   Optional('gender'): And(str, Use(str.lower),    ...                                           lambda s: s in ('squid', 'kid'))}])    &gt;&gt;&gt; data = [{'name': 'Sue', 'age': '28', 'gender': 'Squid'},    ...         {'name': 'Sam', 'age': '42'},    ...         {'name': 'Sacha', 'age': '20', 'gender': 'KID'}]    &gt;&gt;&gt; validated = schema.validate(data)    &gt;&gt;&gt; assert validated == [{'name': 'Sue', 'age': 28, 'gender': 'squid'},    ...                      {'name': 'Sam', 'age': 42},    ...                      {'name': 'Sacha', 'age' : 20, 'gender': 'kid'}]If data is valid, ``Schema.validate`` will return the validated data(optionally converted with `Use` calls, see below).If data is invalid, ``Schema`` will raise ``SchemaError`` exception.If you just want to check that the data is valid, ``schema.is_valid(data)`` willreturn ``True`` or ``False``.Installation-------------------------------------------------------------------------------Use `pip &lt;http://pip-installer.org&gt;`_ or easy_install::    pip install schemaAlternatively, you can just drop ``schema.py`` file into your project—it isself-contained.- **schema** is tested with Python 2.6, 2.7, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9 and PyPy.- **schema** follows `semantic versioning &lt;http://semver.org&gt;`_.How ``Schema`` validates data-------------------------------------------------------------------------------Types~~~~~If ``Schema(...)`` encounters a type (such as ``int``, ``str``, ``object``,etc.), it will check if the corresponding piece of data is an instance of that type,otherwise it will raise ``SchemaError``... code:: python    &gt;&gt;&gt; from schema import Schema    &gt;&gt;&gt; Schema(int).validate(123)    123    &gt;&gt;&gt; Schema(int).validate('123')    Traceback (most recent call last):    ...    schema.SchemaUnexpectedTypeError: '123' should be instance of 'int'    &gt;&gt;&gt; Schema(object).validate('hai')    'hai'Callables~~~~~~~~~If ``Schema(...)`` encounters a callable (function, class, or object with``__call__`` method) it will call it, and if its return value evaluates to``True`` it will continue validating, else—it will raise ``SchemaError``... code:: python    &gt;&gt;&gt; import os    &gt;&gt;&gt; Schema(os.path.exists).validate('./')    './'    &gt;&gt;&gt; Schema(os.path.exists).validate('./non-existent/')    Traceback (most recent call last):    ...    schema.SchemaError: exists('./non-existent/') should evaluate to True    &gt;&gt;&gt; Schema(lambda n: n &gt; 0).validate(123)    123    &gt;&gt;&gt; Schema(lambda n: n &gt; 0).validate(-12)    Traceback (most recent call last):    ...    schema.SchemaError: &lt;lambda&gt;(-12) should evaluate to True&quot;Validatables&quot;~~~~~~~~~~~~~~If ``Schema(...)`` encounters an object with method ``validate`` it will runthis method on corresponding data as ``data = obj.validate(data)``. This methodmay raise ``SchemaError`` exception, which will tell ``Schema`` that that pieceof data is invalid, otherwise—it will continue validating.An example of &quot;validatable&quot; is ``Regex``, that tries to match a string or abuffer with the given regular expression (itself as a string, buffer orcompiled regex ``SRE_Pattern``):.. code:: python    &gt;&gt;&gt; from schema import Regex    &gt;&gt;&gt; import re    &gt;&gt;&gt; Regex(r'^foo').validate('foobar')    'foobar'    &gt;&gt;&gt; Regex(r'^[A-Z]+$', flags=re.I).validate('those-dashes-dont-match')    Traceback (most recent call last):    ...    schema.SchemaError: Regex('^[A-Z]+$', flags=re.IGNORECASE) does not match 'those-dashes-dont-match'For a more general case, you can use ``Use`` for creating such objects.``Use`` helps to use a function or type to convert a value while validating it:.. code:: python    &gt;&gt;&gt; from schema import Use    &gt;&gt;&gt; Schema(Use(int)).validate('123')    123    &gt;&gt;&gt; Schema(Use(lambda f: open(f, 'a'))).validate('LICENSE-MIT')    &lt;_io.TextIOWrapper name='LICENSE-MIT' mode='a' encoding='UTF-8'&gt;Dropping the details, ``Use`` is basically:.. code:: python    class Use(object):        def __init__(self, callable_):            self._callable = callable_        def validate(self, data):            try:                return self._callable(data)            except Exception as e:                raise SchemaError('%r raised %r' % (self._callable.__name__, e))Sometimes you need to transform and validate part of data, but keep original data unchanged.``Const`` helps to keep your data safe:.. code:: python    &gt;&gt; from schema import Use, Const, And, Schema    &gt;&gt; from datetime import datetime    &gt;&gt; is_future = lambda date: datetime.now() &gt; date    &gt;&gt; to_json = lambda v: {&quot;timestamp&quot;: v}    &gt;&gt; Schema(And(Const(And(Use(datetime.fromtimestamp), is_future)), Use(to_json))).validate(1234567890)    {&quot;timestamp&quot;: 1234567890}Now you can write your own validation-aware classes and data types.Lists, similar containers~~~~~~~~~~~~~~~~~~~~~~~~~If ``Schema(...)`` encounters an instance of ``list``, ``tuple``, ``set``or ``frozenset``, it will validate contents of corresponding data containeragainst all schemas listed inside that container and aggregate all errors:.. code:: python    &gt;&gt;&gt; Schema([1, 0]).validate([1, 1, 0, 1])    [1, 1, 0, 1]    &gt;&gt;&gt; Schema((int, float)).validate((5, 7, 8, 'not int or float here'))    Traceback (most recent call last):    ...    schema.SchemaError: Or(&lt;class 'int'&gt;, &lt;class 'float'&gt;) did not validate 'not int or float here'    'not int or float here' should be instance of 'int'    'not int or float here' should be instance of 'float'Dictionaries~~~~~~~~~~~~If ``Schema(...)`` encounters an instance of ``dict``, it will validate datakey-value pairs:.. code:: python    &gt;&gt;&gt; d = Schema({'name': str,    ...             'age': lambda n: 18 &lt;= n &lt;= 99}).validate({'name': 'Sue', 'age': 28})    &gt;&gt;&gt; assert d == {'name': 'Sue', 'age': 28}You can specify keys as schemas too:.. code:: python    &gt;&gt;&gt; schema = Schema({str: int,  # string keys should have integer values    ...                  int: None})  # int keys should be always None    &gt;&gt;&gt; data = schema.validate({'key1': 1, 'key2': 2,    ...                         10: None, 20: None})    &gt;&gt;&gt; schema.validate({'key1': 1,    ...                   10: 'not None here'})    Traceback (most recent call last):    ...    schema.SchemaError: Key '10' error:    None does not match 'not None here'This is useful if you want to check certain key-values, but don't careabout others:.. code:: python    &gt;&gt;&gt; schema = Schema({'&lt;id&gt;': int,    ...                  '&lt;file&gt;': Use(open),    ...                  str: object})  # don't care about other str keys    &gt;&gt;&gt; data = schema.validate({'&lt;id&gt;': 10,    ...                         '&lt;file&gt;': 'README.rst',    ...                         '--verbose': True})You can mark a key as optional as follows:.. code:: python    &gt;&gt;&gt; from schema import Optional    &gt;&gt;&gt; Schema({'name': str,    ...         Optional('occupation'): str}).validate({'name': 'Sam'})    {'name': 'Sam'}``Optional`` keys can also carry a ``default``, to be used when no key in thedata matches:.. code:: python    &gt;&gt;&gt; from schema import Optional    &gt;&gt;&gt; Schema({Optional('color', default='blue'): str,    ...         str: str}).validate({'texture': 'furry'}    ...       ) == {'color': 'blue', 'texture': 'furry'}    TrueDefaults are used verbatim, not passed through any validators specified in thevalue.default can also be a callable:.. code:: python    &gt;&gt;&gt; from schema import Schema, Optional    &gt;&gt;&gt; Schema({Optional('data', default=dict): {}}).validate({}) == {'data': {}}    TrueAlso, a caveat: If you specify types, **schema** won't validate the empty dict:.. code:: python    &gt;&gt;&gt; Schema({int:int}).is_valid({})    FalseTo do that, you need ``Schema(Or({int:int}, {}))``. This is unlike what happens withlists, where ``Schema([int]).is_valid([])`` will return True.**schema** has classes ``And`` and ``Or`` that help validating several schemasfor the same data:.. code:: python    &gt;&gt;&gt; from schema import And, Or    &gt;&gt;&gt; Schema({'age': And(int, lambda n: 0 &lt; n &lt; 99)}).validate({'age': 7})    {'age': 7}    &gt;&gt;&gt; Schema({'password': And(str, lambda s: len(s) &gt; 6)}).validate({'password': 'hai'})    Traceback (most recent call last):    ...    schema.SchemaError: Key 'password' error:    &lt;lambda&gt;('hai') should evaluate to True    &gt;&gt;&gt; Schema(And(Or(int, float), lambda x: x &gt; 0)).validate(3.1415)    3.1415In a dictionary, you can also combine two keys in a &quot;one or the other&quot; manner. To doso, use the `Or` class as a key:.. code:: python    &gt;&gt;&gt; from schema import Or, Schema    &gt;&gt;&gt; schema = Schema({    ...    Or(&quot;key1&quot;, &quot;key2&quot;, only_one=True): str    ... })    &gt;&gt;&gt; schema.validate({&quot;key1&quot;: &quot;test&quot;}) # Ok    {'key1': 'test'}    &gt;&gt;&gt; schema.validate({&quot;key1&quot;: &quot;test&quot;, &quot;key2&quot;: &quot;test&quot;}) # SchemaError    Traceback (most recent call last):    ...    schema.SchemaOnlyOneAllowedError: There are multiple keys present from the Or('key1', 'key2') conditionHooks~~~~~~~~~~You can define hooks which are functions that are executed whenever a valid key:value is found.The `Forbidden` class is an example of this.You can mark a key as forbidden as follows:.. code:: python    &gt;&gt;&gt; from schema import Forbidden    &gt;&gt;&gt; Schema({Forbidden('age'): object}).validate({'age': 50})    Traceback (most recent call last):    ...    schema.SchemaForbiddenKeyError: Forbidden key encountered: 'age' in {'age': 50}A few things are worth noting. First, the value paired with the forbiddenkey determines whether it will be rejected:.. code:: python    &gt;&gt;&gt; Schema({Forbidden('age'): str, 'age': int}).validate({'age': 50})    {'age': 50}Note: if we hadn't supplied the 'age' key here, the call would have failed too, but withSchemaWrongKeyError, not SchemaForbiddenKeyError.Second, Forbidden has a higher priority than standard keys, and consequently than Optional.This means we can do that:.. code:: python    &gt;&gt;&gt; Schema({Forbidden('age'): object, Optional(str): object}).validate({'age': 50})    Traceback (most recent call last):    ...    schema.SchemaForbiddenKeyError: Forbidden key encountered: 'age' in {'age': 50}You can also define your own hooks. The following hook will call `_my_function` if `key` is encountered... code:: python    from schema import Hook    def _my_function(key, scope, error):        print(key, scope, error)    Hook(&quot;key&quot;, handler=_my_function)Here's an example where a `Deprecated` class is added to log warnings whenever a key is encountered:.. code:: python    from schema import Hook, Schema    class Deprecated(Hook):        def __init__(self, *args, **kwargs):            kwargs[&quot;handler&quot;] = lambda key, *args: logging.warn(f&quot;`{key}` is deprecated. &quot; + (self._error or &quot;&quot;))            super(Deprecated, self).__init__(*args, **kwargs)    Schema({Deprecated(&quot;test&quot;, &quot;custom error message.&quot;): object}, ignore_extra_keys=True).validate({&quot;test&quot;: &quot;value&quot;})    ...    WARNING: `test` is deprecated. custom error message.Extra Keys~~~~~~~~~~The ``Schema(...)`` parameter ``ignore_extra_keys`` causes validation to ignore extra keys in a dictionary, and also to not return them after validating... code:: python    &gt;&gt;&gt; schema = Schema({'name': str}, ignore_extra_keys=True)    &gt;&gt;&gt; schema.validate({'name': 'Sam', 'age': '42'})    {'name': 'Sam'}If you would like any extra keys returned, use ``object: object`` as one of the key/value pairs, which will match any key and any value.Otherwise, extra keys will raise a ``SchemaError``.Customized Validation~~~~~~~~~~~~~~~~~~~~~~~The ``Schema.validate`` method accepts additional keyword arguments. Thekeyword arguments will be propagated to the ``validate`` method of anychild validatables (including any ad-hoc ``Schema`` objects), or the defaultvalue callable (if a callable is specified) for ``Optional`` keys.This feature can be used together with inheritance of the ``Schema`` classfor customized validation.Here is an example where a &quot;post-validation&quot; hook that runs after validationagainst a sub-schema in a larger schema:.. code:: python    class EventSchema(schema.Schema):        def validate(self, data, _is_event_schema=True):            data = super(EventSchema, self).validate(data, _is_event_schema=False)            if _is_event_schema and data.get(&quot;minimum&quot;, None) is None:                data[&quot;minimum&quot;] = data[&quot;capacity&quot;]            return data    events_schema = schema.Schema(        {            str: EventSchema({                &quot;capacity&quot;: int,                schema.Optional(&quot;minimum&quot;): int,  # default to capacity            })        }    )    data = {'event1': {'capacity': 1}, 'event2': {'capacity': 2, 'minimum': 3}}    events = events_schema.validate(data)    assert events['event1']['minimum'] == 1  # == capacity    assert events['event2']['minimum'] == 3Note that the additional keyword argument ``_is_event_schema`` is necessary tolimit the customized behavior to the ``EventSchema`` object itself so that itwon't affect any recursive invoke of the ``self.__class__.validate`` for thechild schemas (e.g., the call to ``Schema(&quot;capacity&quot;).validate(&quot;capacity&quot;)``).User-friendly error reporting-------------------------------------------------------------------------------You can pass a keyword argument ``error`` to any of validatable classes(such as ``Schema``, ``And``, ``Or``, ``Regex``, ``Use``) to report this errorinstead of a built-in one... code:: python    &gt;&gt;&gt; Schema(Use(int, error='Invalid year')).validate('XVII')    Traceback (most recent call last):    ...    schema.SchemaError: Invalid yearYou can see all errors that occurred by accessing exception's ``exc.autos``for auto-generated error messages, and ``exc.errors`` for errorswhich had ``error`` text passed to them.You can exit with ``sys.exit(exc.code)`` if you want to show the messagesto the user without traceback. ``error`` messages are given precedence in thatcase.A JSON API example-------------------------------------------------------------------------------Here is a quick example: validation of`create a gist &lt;http://developer.github.com/v3/gists/&gt;`_request from github API... code:: python    &gt;&gt;&gt; gist = '''{&quot;description&quot;: &quot;the description for this gist&quot;,    ...            &quot;public&quot;: true,    ...            &quot;files&quot;: {    ...                &quot;file1.txt&quot;: {&quot;content&quot;: &quot;String file contents&quot;},    ...                &quot;other.txt&quot;: {&quot;content&quot;: &quot;Another file contents&quot;}}}'''    &gt;&gt;&gt; from schema import Schema, And, Use, Optional    &gt;&gt;&gt; import json    &gt;&gt;&gt; gist_schema = Schema(And(Use(json.loads),  # first convert from JSON    ...                          # use str since json returns unicode    ...                          {Optional('description'): str,    ...                           'public': bool,    ...                           'files': {str: {'content': str}}}))    &gt;&gt;&gt; gist = gist_schema.validate(gist)    # gist:    {u'description': u'the description for this gist',     u'files': {u'file1.txt': {u'content': u'String file contents'},                u'other.txt': {u'content': u'Another file contents'}},     u'public': True}Using **schema** with `docopt &lt;http://github.com/docopt/docopt&gt;`_-------------------------------------------------------------------------------Assume you are using **docopt** with the following usage-pattern:    Usage: my_program.py [--count=N] &lt;path&gt; &lt;files&gt;...and you would like to validate that ``&lt;files&gt;`` are readable, and that``&lt;path&gt;`` exists, and that ``--count`` is either integer from 0 to 5, or``None``.Assuming **docopt** returns the following dict:.. code:: python    &gt;&gt;&gt; args = {'&lt;files&gt;': ['LICENSE-MIT', 'setup.py'],    ...         '&lt;path&gt;': '../',    ...         '--count': '3'}this is how you validate it using ``schema``:.. code:: python    &gt;&gt;&gt; from schema import Schema, And, Or, Use    &gt;&gt;&gt; import os    &gt;&gt;&gt; s = Schema({'&lt;files&gt;': [Use(open)],    ...             '&lt;path&gt;': os.path.exists,    ...             '--count': Or(None, And(Use(int), lambda n: 0 &lt; n &lt; 5))})    &gt;&gt;&gt; args = s.validate(args)    &gt;&gt;&gt; args['&lt;files&gt;']    [&lt;_io.TextIOWrapper name='LICENSE-MIT' ...&gt;, &lt;_io.TextIOWrapper name='setup.py' ...]    &gt;&gt;&gt; args['&lt;path&gt;']    '../'    &gt;&gt;&gt; args['--count']    3As you can see, **schema** validated data successfully, opened files andconverted ``'3'`` to ``int``.JSON schema-----------You can also generate standard `draft-07 JSON schema &lt;https://json-schema.org/&gt;`_ from a dict ``Schema``.This can be used to add word completion, validation, and documentation directly in code editors.The output schema can also be used with JSON schema compatible libraries.JSON: Generating~~~~~~~~~~~~~~~~Just define your schema normally and call ``.json_schema()`` on it. The output is a Python dict, you need to dump it to JSON... code:: python    &gt;&gt;&gt; from schema import Optional, Schema    &gt;&gt;&gt; import json    &gt;&gt;&gt; s = Schema({&quot;test&quot;: str,    ...             &quot;nested&quot;: {Optional(&quot;other&quot;): str}    ...             })    &gt;&gt;&gt; json_schema = json.dumps(s.json_schema(&quot;https://example.com/my-schema.json&quot;))    # json_schema    {        &quot;type&quot;:&quot;object&quot;,        &quot;properties&quot;: {            &quot;test&quot;: {&quot;type&quot;: &quot;string&quot;},            &quot;nested&quot;: {                &quot;type&quot;:&quot;object&quot;,                &quot;properties&quot;: {                    &quot;other&quot;: {&quot;type&quot;: &quot;string&quot;}                },                &quot;required&quot;: [],                &quot;additionalProperties&quot;: false            }        },        &quot;required&quot;:[            &quot;test&quot;,            &quot;nested&quot;        ],        &quot;additionalProperties&quot;:false,        &quot;$id&quot;:&quot;https://example.com/my-schema.json&quot;,        &quot;$schema&quot;:&quot;http://json-schema.org/draft-07/schema#&quot;    }You can add descriptions for the schema elements using the ``Literal`` object instead of a string. The main schema can also have a description.These will appear in IDEs to help your users write a configuration... code:: python    &gt;&gt;&gt; from schema import Literal, Schema    &gt;&gt;&gt; import json    &gt;&gt;&gt; s = Schema({Literal(&quot;project_name&quot;, description=&quot;Names must be unique&quot;): str}, description=&quot;Project schema&quot;)    &gt;&gt;&gt; json_schema = json.dumps(s.json_schema(&quot;https://example.com/my-schema.json&quot;), indent=4)    # json_schema    {        &quot;type&quot;: &quot;object&quot;,        &quot;properties&quot;: {            &quot;project_name&quot;: {                &quot;description&quot;: &quot;Names must be unique&quot;,                &quot;type&quot;: &quot;string&quot;            }        },        &quot;required&quot;: [            &quot;project_name&quot;        ],        &quot;additionalProperties&quot;: false,        &quot;$id&quot;: &quot;https://example.com/my-schema.json&quot;,        &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,        &quot;description&quot;: &quot;Project schema&quot;    }JSON: Supported validations~~~~~~~~~~~~~~~~~~~~~~~~~~~The resulting JSON schema is not guaranteed to accept the same objects as the library would accept, since some validations are not implemented orhave no JSON schema equivalent. This is the case of the ``Use`` and ``Hook`` objects for example.Implemented'''''''''''`Object properties &lt;https://json-schema.org/understanding-json-schema/reference/object.html#properties&gt;`_    Use a dict literal. The dict keys are the JSON schema properties.    Example:    ``Schema({&quot;test&quot;: str})``    becomes    ``{'type': 'object', 'properties': {'test': {'type': 'string'}}, 'required': ['test'], 'additionalProperties': False}``.    Please note that attributes are required by default. To create optional attributes use ``Optional``, like so:    ``Schema({Optional(&quot;test&quot;): str})``    becomes    ``{'type': 'object', 'properties': {'test': {'type': 'string'}}, 'required': [], 'additionalProperties': False}``    additionalProperties is set to true when at least one of the conditions is met:        - ignore_extra_keys is True        - at least one key is `str` or `object`    For example:    ``Schema({str: str})`` and ``Schema({}, ignore_extra_keys=True)``    both becomes    ``{'type': 'object', 'properties' : {}, 'required': [], 'additionalProperties': True}``    and    ``Schema({})``    becomes    ``{'type': 'object', 'properties' : {}, 'required': [], 'additionalProperties': False}``Types    Use the Python type name directly. It will be converted to the JSON name:    - ``str`` -&gt; `string &lt;https://json-schema.org/understanding-json-schema/reference/string.html&gt;`_    - ``int`` -&gt; `integer &lt;https://json-schema.org/understanding-json-schema/reference/numeric.html#integer&gt;`_    - ``float`` -&gt; `number &lt;https://json-schema.org/understanding-json-schema/reference/numeric.html#number&gt;`_    - ``bool`` -&gt; `boolean &lt;https://json-schema.org/understanding-json-schema/reference/boolean.html&gt;`_    - ``list`` -&gt; `array &lt;https://json-schema.org/understanding-json-schema/reference/array.html&gt;`_    - ``dict`` -&gt; `object &lt;https://json-schema.org/understanding-json-schema/reference/object.html&gt;`_    Example:    ``Schema(float)``    becomes    ``{&quot;type&quot;: &quot;number&quot;}```Array items &lt;https://json-schema.org/understanding-json-schema/reference/array.html#items&gt;`_    Surround a schema with ``[]``.    Example:    ``Schema([str])`` means an array of string and becomes:    ``{'type': 'array', 'items': {'type': 'string'}}```Enumerated values &lt;https://json-schema.org/understanding-json-schema/reference/generic.html#enumerated-values&gt;`_    Use `Or`.    Example:    ``Schema(Or(1, 2, 3))`` becomes    ``{&quot;enum&quot;: [1, 2, 3]}```Constant values &lt;https://json-schema.org/understanding-json-schema/reference/generic.html#constant-values&gt;`_    Use the value itself.    Example:    ``Schema(&quot;name&quot;)`` becomes    ``{&quot;const&quot;: &quot;name&quot;}```Regular expressions &lt;https://json-schema.org/understanding-json-schema/reference/regular_expressions.html&gt;`_    Use ``Regex``.    Example:    ``Schema(Regex(&quot;^v\d+&quot;))`` becomes    ``{'type': 'string', 'pattern': '^v\\d+'}```Annotations (title and description) &lt;https://json-schema.org/understanding-json-schema/reference/generic.html#annotations&gt;`_    You can use the ``name`` and ``description`` parameters of the ``Schema`` object init method.    To add description to keys, replace a str with a ``Literal`` object.    Example:    ``Schema({Literal(&quot;test&quot;, description=&quot;A description&quot;): str})``    is equivalent to    ``Schema({&quot;test&quot;: str})``    with the description added to the resulting JSON schema.`Combining schemas with allOf &lt;https://json-schema.org/understanding-json-schema/reference/combining.html#allof&gt;`_    Use ``And``    Example:    ``Schema(And(str, &quot;value&quot;))``    becomes    ``{&quot;allOf&quot;: [{&quot;type&quot;: &quot;string&quot;}, {&quot;const&quot;: &quot;value&quot;}]}``    Note that this example is not really useful in the real world, since ``const`` already implies the type.`Combining schemas with anyOf &lt;https://json-schema.org/understanding-json-schema/reference/combining.html#anyof&gt;`_    Use ``Or``    Example:    ``Schema(Or(str, int))``    becomes    ``{&quot;anyOf&quot;: [{&quot;type&quot;: &quot;string&quot;}, {&quot;type&quot;: &quot;integer&quot;}]}``Not implemented'''''''''''''''The following JSON schema validations cannot be generated from this library.- `String length &lt;https://json-schema.org/understanding-json-schema/reference/string.html#length&gt;`_    However, those can be implemented using ``Regex``- `String format &lt;https://json-schema.org/understanding-json-schema/reference/string.html#format&gt;`_    However, those can be implemented using ``Regex``- `Object dependencies &lt;https://json-schema.org/understanding-json-schema/reference/object.html#dependencies&gt;`_- `Array length &lt;https://json-schema.org/understanding-json-schema/reference/array.html#length&gt;`_- `Array uniqueness &lt;https://json-schema.org/understanding-json-schema/reference/array.html#uniqueness&gt;`_- `Numeric multiples &lt;https://json-schema.org/understanding-json-schema/reference/numeric.html#multiples&gt;`_- `Numeric ranges &lt;https://json-schema.org/understanding-json-schema/reference/numeric.html#range&gt;`_- `Property Names &lt;https://json-schema.org/understanding-json-schema/reference/object.html#property-names&gt;`_    Not implemented. We suggest listing the possible keys instead. As a tip, you can use ``Or`` as a dict key.    Example:    ``Schema({Or(&quot;name1&quot;, &quot;name2&quot;): str})``- `Annotations (default and examples) &lt;https://json-schema.org/understanding-json-schema/reference/generic.html#annotations&gt;`_- `Combining schemas with oneOf &lt;https://json-schema.org/understanding-json-schema/reference/combining.html#oneof&gt;`_- `Not &lt;https://json-schema.org/understanding-json-schema/reference/combining.html#not&gt;`_- `Object size &lt;https://json-schema.org/understanding-json-schema/reference/object.html#size&gt;`_- `additionalProperties having a different schema (true and false is supported)`JSON: Minimizing output size~~~~~~~~~~~~~~~~~~~~~~~~~~~~Explicit Reuse''''''''''''''If your JSON schema is big and has a lot of repetition, it can be made simpler and smaller by defining Schema objects as reference.These references will be placed in a &quot;definitions&quot; section in the main schema.`You can look at the JSON schema documentation for more information &lt;https://json-schema.org/understanding-json-schema/structuring.html#reuse&gt;`_.. code:: python    &gt;&gt;&gt; from schema import Optional, Schema    &gt;&gt;&gt; import json    &gt;&gt;&gt; s = Schema({&quot;test&quot;: str,    ...             &quot;nested&quot;: Schema({Optional(&quot;other&quot;): str}, name=&quot;nested&quot;, as_reference=True)    ...             })    &gt;&gt;&gt; json_schema = json.dumps(s.json_schema(&quot;https://example.com/my-schema.json&quot;), indent=4)    # json_schema    {        &quot;type&quot;: &quot;object&quot;,        &quot;properties&quot;: {            &quot;test&quot;: {                &quot;type&quot;: &quot;string&quot;            },            &quot;nested&quot;: {                &quot;$ref&quot;: &quot;#/definitions/nested&quot;            }        },        &quot;required&quot;: [            &quot;test&quot;,            &quot;nested&quot;        ],        &quot;additionalProperties&quot;: false,        &quot;$id&quot;: &quot;https://example.com/my-schema.json&quot;,        &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,        &quot;definitions&quot;: {            &quot;nested&quot;: {                &quot;type&quot;: &quot;object&quot;,                &quot;properties&quot;: {                    &quot;other&quot;: {                        &quot;type&quot;: &quot;string&quot;                    }                },                &quot;required&quot;: [],                &quot;additionalProperties&quot;: false            }        }    }This becomes really useful when using the same object several times.. code:: python    &gt;&gt;&gt; from schema import Optional, Or, Schema    &gt;&gt;&gt; import json    &gt;&gt;&gt; language_configuration = Schema({&quot;autocomplete&quot;: bool, &quot;stop_words&quot;: [str]}, name=&quot;language&quot;, as_reference=True)    &gt;&gt;&gt; s = Schema({Or(&quot;ar&quot;, &quot;cs&quot;, &quot;de&quot;, &quot;el&quot;, &quot;eu&quot;, &quot;en&quot;, &quot;es&quot;, &quot;fr&quot;): language_configuration})    &gt;&gt;&gt; json_schema = json.dumps(s.json_schema(&quot;https://example.com/my-schema.json&quot;), indent=4)    # json_schema    {        &quot;type&quot;: &quot;object&quot;,        &quot;properties&quot;: {            &quot;ar&quot;: {                &quot;$ref&quot;: &quot;#/definitions/language&quot;            },            &quot;cs&quot;: {                &quot;$ref&quot;: &quot;#/definitions/language&quot;            },            &quot;de&quot;: {                &quot;$ref&quot;: &quot;#/definitions/language&quot;            },            &quot;el&quot;: {                &quot;$ref&quot;: &quot;#/definitions/language&quot;            },            &quot;eu&quot;: {                &quot;$ref&quot;: &quot;#/definitions/language&quot;            },            &quot;en&quot;: {                &quot;$ref&quot;: &quot;#/definitions/language&quot;            },            &quot;es&quot;: {                &quot;$ref&quot;: &quot;#/definitions/language&quot;            },            &quot;fr&quot;: {                &quot;$ref&quot;: &quot;#/definitions/language&quot;            }        },        &quot;required&quot;: [],        &quot;additionalProperties&quot;: false,        &quot;$id&quot;: &quot;https://example.com/my-schema.json&quot;,        &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,        &quot;definitions&quot;: {            &quot;language&quot;: {                &quot;type&quot;: &quot;object&quot;,                &quot;properties&quot;: {                    &quot;autocomplete&quot;: {                        &quot;type&quot;: &quot;boolean&quot;                    },                    &quot;stop_words&quot;: {                        &quot;type&quot;: &quot;array&quot;,                        &quot;items&quot;: {                            &quot;type&quot;: &quot;string&quot;                        }                    }                },                &quot;required&quot;: [                    &quot;autocomplete&quot;,                    &quot;stop_words&quot;                ],                &quot;additionalProperties&quot;: false            }        }    }Automatic reuse'''''''''''''''If you want to minimize the output size without using names explicitly, you can have the library generate hashes of parts of the output JSONschema and use them as references throughout.Enable this behaviour by providing the parameter ``use_refs`` to the json_schema method.Be aware that this method is less often compatible with IDEs and JSON schema libraries.It produces a JSON schema that is more difficult to read by humans... code:: python    &gt;&gt;&gt; from schema import Optional, Or, Schema    &gt;&gt;&gt; import json    &gt;&gt;&gt; language_configuration = Schema({&quot;autocomplete&quot;: bool, &quot;stop_words&quot;: [str]})    &gt;&gt;&gt; s = Schema({Or(&quot;ar&quot;, &quot;cs&quot;, &quot;de&quot;, &quot;el&quot;, &quot;eu&quot;, &quot;en&quot;, &quot;es&quot;, &quot;fr&quot;): language_configuration})    &gt;&gt;&gt; json_schema = json.dumps(s.json_schema(&quot;https://example.com/my-schema.json&quot;, use_refs=True), indent=4)    # json_schema    {        &quot;type&quot;: &quot;object&quot;,        &quot;properties&quot;: {            &quot;ar&quot;: {                &quot;type&quot;: &quot;object&quot;,                &quot;properties&quot;: {                    &quot;autocomplete&quot;: {                        &quot;type&quot;: &quot;boolean&quot;,                        &quot;$id&quot;: &quot;#6456104181059880193&quot;                    },                    &quot;stop_words&quot;: {                        &quot;type&quot;: &quot;array&quot;,                        &quot;items&quot;: {                            &quot;type&quot;: &quot;string&quot;,                            &quot;$id&quot;: &quot;#1856069563381977338&quot;                        }                    }                },                &quot;required&quot;: [                    &quot;autocomplete&quot;,                    &quot;stop_words&quot;                ],                &quot;additionalProperties&quot;: false            },            &quot;cs&quot;: {                &quot;type&quot;: &quot;object&quot;,                &quot;properties&quot;: {                    &quot;autocomplete&quot;: {                        &quot;$ref&quot;: &quot;#6456104181059880193&quot;                    },                    &quot;stop_words&quot;: {                        &quot;type&quot;: &quot;array&quot;,                        &quot;items&quot;: {                            &quot;$ref&quot;: &quot;#1856069563381977338&quot;                        },                        &quot;$id&quot;: &quot;#-5377945144312515805&quot;                    }                },                &quot;required&quot;: [                    &quot;autocomplete&quot;,                    &quot;stop_words&quot;                ],                &quot;additionalProperties&quot;: false            },            &quot;de&quot;: {                &quot;type&quot;: &quot;object&quot;,                &quot;properties&quot;: {                    &quot;autocomplete&quot;: {                        &quot;$ref&quot;: &quot;#6456104181059880193&quot;                    },                    &quot;stop_words&quot;: {                        &quot;$ref&quot;: &quot;#-5377945144312515805&quot;                    }                },                &quot;required&quot;: [                    &quot;autocomplete&quot;,                    &quot;stop_words&quot;                ],                &quot;additionalProperties&quot;: false,                &quot;$id&quot;: &quot;#-8142886105174600858&quot;            },            &quot;el&quot;: {                &quot;$ref&quot;: &quot;#-8142886105174600858&quot;            },            &quot;eu&quot;: {                &quot;$ref&quot;: &quot;#-8142886105174600858&quot;            },            &quot;en&quot;: {                &quot;$ref&quot;: &quot;#-8142886105174600858&quot;            },            &quot;es&quot;: {                &quot;$ref&quot;: &quot;#-8142886105174600858&quot;            },            &quot;fr&quot;: {                &quot;$ref&quot;: &quot;#-8142886105174600858&quot;            }        },        &quot;required&quot;: [],        &quot;additionalProperties&quot;: false,        &quot;$id&quot;: &quot;https://example.com/my-schema.json&quot;,        &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;    }</longdescription>
</pkgmetadata>