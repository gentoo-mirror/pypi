<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Sekoia.io Automation Python SDK[![CI](https://github.com/SEKOIA-IO/sekoia-automation-sdk/actions/workflows/ci.yml/badge.svg)](https://github.com/SEKOIA-IO/sekoia-automation-sdk/actions/workflows/ci.yml)[![codecov](https://codecov.io/github/SEKOIA-IO/sekoia-automation-sdk/branch/main/badge.svg?token=13S5Q0WFRQ)](https://codecov.io/github/SEKOIA-IO/sekoia-automation-sdk)[![pypi](https://img.shields.io/pypi/v/sekoia-automation-sdk?color=%2334D058&amp;label=pypi%20package)](https://pypi.org/project/sekoia-automation-sdk/)[![pypi](https://img.shields.io/pypi/pyversions/sekoia-automation-sdk?color=%2334D058&amp;label=Python)](https://pypi.org/project/sekoia-automation-sdk/)SDK to create Sekoia.io playbook modules.Modules can define:* Triggers: daemons that create events that will start a playbook run* Actions: short-lived programs that constitute the main playbook nodes. They take arguments and produce a result.## Create a triggerHere is how you could define a very basic trigger:```pythonfrom sekoia_automation.module import Modulefrom sekoia_automation.trigger import Triggerclass MyTrigger(Trigger):    def run(self):        while True:            # Do some stuff            self.send_event('event_name', {'somekey': 'somevalue'})            # Maybe wait some timeif __name__ == &quot;__main__&quot;:    module = Module()    module.register(MyTrigger)    module.run()```You can access the Trigger's configuration with `self.configuration` and the module configuration with `self.module.configuration`.### Attach files to an eventYou can attach files to an event so that these files are available to the playbook runs.Here is how you could crete a file that should be available to the playbook run:```pythonimport osfrom sekoia_automation import constantsfrom sekoia_automation.trigger import Triggerclass MyTrigger(Trigger):    def run(self):        while True:            # Create a directory and a file            directory_name = &quot;test_dir&quot;            dirpath = os.path.join(constants.DATA_STORAGE, directory_name)            os.makedirs(dirpath)            with open(os.path.join(dirpath, &quot;test.txt&quot;) &quot;w&quot;) as f:                f.write(&quot;Hello !&quot;)            # Attach the file to the event            self.send_event('event_name', {'file_path': 'test.txt'}, directory_name)            # Maybe wait some time```Please note that:* `send_event`'s third argument should be the path of a directory, relative to `constants.DATA_STORAGE`* The directory will be the root of the playbook run's storage (&quot;test.txt&quot; will exist, not &quot;test_dir/test.txt&quot;)* You can ask the SDK to automatically remove the directory after it was copied with `remove_directory=True`* You should always do `from sekoia_automation import constants` and use `constants.DATA_STORAGE` so that it is easy to mockWhen attaching a single file to a playbook run, you can use the `write` function to create the file:```pythonfrom sekoia_automation.storage import writefrom sekoia_automation.trigger import Triggerclass MyTrigger(Trigger):    def run(self):        while True:            # Simple creation of a file            filepath = write('test.txt', {'event': 'data'})            # Attach the file to the event            self.send_event('event_name', {'file_path': os.path.basename(filepath)},                            os.path.dirname(directory_name))            # Maybe wait some time```### Persisting data to diskMost of the time, triggers have to maintain some state do to their work properly (such as a cursor).In order to make sure that this data survives a reboot of the Trigger (which can happen with no reason),it is useful to persist it to the trigger's storage.When the manipulated data is JSON serializable, it is recommended to use the `PersistentJSON` class to doso (instead of `shelve`). Used as a context manager, this class will make sure the python dict is properlysynchronised:```pythonfrom sekoia_automation.trigger import Triggerfrom sekoia_automation.storage import PersistentJSONclass MyTrigger(Trigger):    def run(self):        while True:            # Read and update state            with PersistentJSON('cache.json') as cache:        # Use cache as you would use a normal python dict```## Create an actionHere is how you could define a very basic action that simply adds its arguments as result:```pythonfrom sekoia_automation.module import Modulefrom sekoia_automation.action import Actionclass MyAction(Action):    def run(self, arguments):        return arguments  # Return value should be a JSON serializable dictif __name__ == &quot;__main__&quot;:    module = Module()    module.register(MyAction)    module.run()```There are a few more things you can do within an Action:* Access the Module's configuration with `self.module.configuration`* Add log messages with `self.log('message', 'level')`* Activate an output branch with `self.set_output('malicious')` or explicitely disable another with `self.set_output('benign', False)`* Raise an error with `self.error('error message')`. Note that raised exceptions that are not catched by your code will be automatically handled by the SDK### Working with filesActions can read and write files the same way a Trigger can:```pythonfrom sekoia_automation import constantsfilepath = os.path.join(constants.DATA_STORAGE, &quot;test.txt&quot;)```It is a common pattern to accept JSON arguments values directly or inside a file. The SDK provides an helper to easily read such arguments:```pythonclass MyAction(Action):    def run(self, arguments):        test = self.json_argument(&quot;test&quot;, arguments)        # Do somehting with test```The value will automatically be fetched from `test` if present, or read from the file at `test_path`.The SDK also provides an helper to do the opposite with results:```pythonclass MyAction(Action):    def run(self, arguments):        return self.json_result(&quot;test&quot;, {&quot;some&quot;: &quot;value&quot;})```This will create a dict with `test_path` by default or `test` if the last argument was passed directly.## Same Docker Image for several itemsIn most cases, it makes sense to define several triggers and / or actions sharing the same code and the same docker image.In this case, here is how you should define the main:```pythonif __name__ == &quot;__main__&quot;:    module = Module()    module.register(Trigger1, &quot;command_trigger1&quot;)    module.register(Trigger2, &quot;command_trigger2&quot;)    module.register(Action1, &quot;command_action1&quot;)    module.register(Action2, &quot;command_action2&quot;)    module.run()```The corresponding commands need to be correctly set in the manifests as &quot;docker_parameters&quot;.## Use with PydanticIt is recommended to use Pydantic to develop new modules. This should ease development.### Module ConfigurationA pydantic model can be used as `self.module.configuration` by adding type hints:```pythonclass MyConfigurationModel(BaseModel):    field: strclass MyModule(Module):    configuration: MyConfigurationclass MyAction(Action):    module: MyModule```### TriggersThe Trigger configuration can also be a pydantic model by adding a type hint:```pythonclass MyTrigger(Trigger):    configuration: MyConfigurationModel```You can also specify the model of created events by setting the `results_model` attribute:```pythonclass Event(BaseModel):    field: str = &quot;value&quot;class MyTrigger(Trigger):    results_model = Event```### ActionsYou can use a pydantic model as action arguments by adding a type hint:```pythonclass ActionArguments(BaseModel):    field: str = &quot;value&quot;class MyAction(Action):    def run(self, arguments: ActionArguments):        ...```The model of results can also be specified by setting the `results_model` attribute:```pythonclass Results(BaseModel):    field: str = &quot;value&quot;class MyAction(action):    results_model = Results```### Automatically generating manifestsWhen using pydantic models to describe configurations, arguments and results, manifestscan be automatically generated:```$ poetry run sekoia-automation generate-files```This will do the following:* Generate `main.py`* Generate a manifest for each action* Generate a manifest for each trigger* Update the module's manifestFor better results, it is recommended to set the `name` and `description` attributes in Actionsand Triggers.</longdescription>
</pkgmetadata>