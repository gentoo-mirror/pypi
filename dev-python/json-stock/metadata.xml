<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># json_stock下の方に日本語の説明があります## Overview- JSON-based database- Very simple to operate, but fast, and supports parallel processing.- DB itself behaves like &quot;one big JSON&quot;- description is under construction.## Usage```pythonimport json_stock as jst# open DBtest_db = jst.JsonStock(&quot;./test_db/&quot;)print(test_db)# create tabletest_db[&quot;test_table&quot;] = {}# get tabletest_table = test_db[&quot;test_table&quot;]print(test_table)# create new valuetest_table[&quot;test&quot;] = {&quot;hello&quot;: &quot;world!!&quot;}# read valueprint(test_table[&quot;test&quot;])# show tableprint(test_table)# iterate (listup all keys in the table)print([key for key in test_table])# delete valuedel test_table[&quot;test&quot;]# delete tabledel test_db[&quot;test_table&quot;]```- Advanced: transaction- If the following is written, the &quot;test&quot; key is locked in the &quot;WITH&quot; syntax, and other processes cannot change the value of the key until the program emerges from the &quot;WITH&quot; syntax.- However, this lock occurs on a per-key basis, not per-table basis, so other keys can be edited without any problem while the program is executing the &quot;WITH&quot; syntax.```python# lock the &quot;test&quot; keywith test_table.lock(&quot;test&quot;) as rec:rec.value[&quot;new_key&quot;] = &quot;hell&quot;rec.value[&quot;hello&quot;] += &quot;!!&quot;```- If you rewrite rec.value in &quot;WITH&quot; as you like, the rec.value value at the moment of leaving &quot;with&quot; is automatically reflected in the DB (&quot;commit&quot; in general DB).- Example of locking multiple keys```python# lock the &quot;test&quot; keywith test_table.lock(&quot;test&quot;) as rec, test_table.lock(&quot;test2&quot;) as rec2:rec.value[&quot;hello&quot;] += &quot;!!&quot;rec2.value[&quot;new_key&quot;] = rec.value[&quot;hello&quot;] + &quot;hell&quot;# This prevents unintentional rewriting of rec just before changing rec2, and can be used for complex transactions such as money transfer processing```- Example without &quot;WITH&quot; syntax - Example 1```pythonrec = test_table.lock(&quot;test&quot;)rec.value = &quot;hoge&quot;rec.unlock()```- Example without &quot;WITH&quot; syntax - Example 2```pythonrec = test_table.lock(&quot;test&quot;)rec.value = &quot;fuga&quot;test_table.unlock(&quot;test&quot;)```- NG Example: DO NOT write like this```pythonwith test_table.lock(&quot;test&quot;) as rec:test_table[&quot;test&quot;] = &quot;hoge&quot;# NG```- In the above example, the edit of the &quot;test&quot; key is locked in with, so if you try to edit the value via test_table, the lock is not released forever and the program freezes.- It is correct to write as follows```pythonwith test_table.lock(&quot;test&quot;) as rec:rec.value = &quot;hoge&quot;# OK```- The rec object is given special permission to edit the &quot;test&quot; key in the &quot;WITH&quot; syntax, so it can only edit that data through rec.value while it is locked.## 概要- JSONベースのデータベース- 操作が非常に単純だが、高速で、並列処理にも対応- DB自体が「1つの大きなJSON」のように振る舞う## 使用例```pythonimport json_stock as jst# DBを開く (存在しない場合はディレクトリが自動的に作成される)test_db = jst.JsonStock(&quot;./test_db/&quot;)print(test_db)# テーブルの作成 (右辺は必ず空の辞書である必要がある)test_db[&quot;test_table&quot;] = {}# テーブルの取得test_table = test_db[&quot;test_table&quot;]print(test_table)# テーブルの&quot;test&quot;キーにデータを登録 (すでにキーが存在する場合は上書き)test_table[&quot;test&quot;] = {&quot;hello&quot;: &quot;world!!&quot;}# テーブルの&quot;test&quot;キーに束縛されたデータを読み出すprint(test_table[&quot;test&quot;])# テーブルの可視化 (soutを用いれば表示レコード数上限もカスタマイズ可能)print(test_table)# for文脈でテーブルの全キーを巡回print([key for key in test_table])# &quot;test&quot;キーの値を削除del test_table[&quot;test&quot;]# テーブルの削除del test_db[&quot;test_table&quot;]```- 発展的な例: トランザクション処理- 下記のように書くと、with構文内で&quot;test&quot;キーがロックされ、withから脱出するまでは他のプロセスが当該キーの値を変更できなくなる- ただしこのロックはtable単位ではなく、キー単位で発生するので、withの間も他のkeyは問題なく編集できる```python# &quot;test&quot;キーをロックするwith test_table.lock(&quot;test&quot;) as rec:rec.value[&quot;new_key&quot;] = &quot;hell&quot;rec.value[&quot;hello&quot;] += &quot;!!&quot;```- with内でrec.valueを好きなように書き換えると、withを抜けた瞬間のrec.value値が自動的にDBに反映される (一般的なDBでいうところの「コミット」)- 複数のkeyをロックする例```python# lock the &quot;test&quot; keywith test_table.lock(&quot;test&quot;) as rec, test_table.lock(&quot;test2&quot;) as rec2:rec.value[&quot;hello&quot;] += &quot;!!&quot;rec2.value[&quot;new_key&quot;] = rec.value[&quot;hello&quot;] + &quot;hell&quot;# このように書けば、rec2を変更する直前に意図せずrecが書き換わってしまう等が防げるため、送金処理などの複雑なトランザクションにも利用できる```- with構文を使わない例 - その1```pythonrec = test_table.lock(&quot;test&quot;)rec.value = &quot;hoge&quot;rec.unlock()```- with構文を使わない例 - その2```pythonrec = test_table.lock(&quot;test&quot;)rec.value = &quot;fuga&quot;test_table.unlock(&quot;test&quot;)```- NG例: 下記のような書き方をしてはいけない```pythonwith test_table.lock(&quot;test&quot;) as rec:test_table[&quot;test&quot;] = &quot;hoge&quot;# NG```- 上記の例では、with内において&quot;test&quot;keyの編集がロックされているため、test_table経由で値の編集を試みると、永遠にロックが解除されず、フリーズする- 下記のように書くのが正しい```pythonwith test_table.lock(&quot;test&quot;) as rec:rec.value = &quot;hoge&quot;# OK```- recオブジェクトは、with構文内において、&quot;test&quot;キーを編集する特別な権限を与えられているため、ロック中はrec.valueを通じてのみ当該データを編集することができる</longdescription>
</pkgmetadata>