<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;a href=&quot;https://explosion.ai&quot;&gt;&lt;img src=&quot;https://explosion.ai/assets/img/logo.svg&quot; width=&quot;125&quot; height=&quot;125&quot; align=&quot;right&quot; /&gt;&lt;/a&gt;# cymem: A Cython Memory Helpercymem provides two small memory-management helpers for Cython. They make iteasy to tie memory to a Python object's life-cycle, so that the memory is freedwhen the object is garbage collected.[![Azure Pipelines](https://img.shields.io/azure-devops/build/explosion-ai/public/2/master.svg?logo=azure-pipelines&amp;style=flat-square)](https://dev.azure.com/explosion-ai/public/_build?definitionId=2)[![pypi Version](https://img.shields.io/pypi/v/cymem.svg?style=flat-square&amp;logo=pypi&amp;logoColor=white)](https://pypi.python.org/pypi/cymem)[![conda Version](https://img.shields.io/conda/vn/conda-forge/cymem.svg?style=flat-square&amp;logo=conda-forge&amp;logoColor=white)](https://anaconda.org/conda-forge/cymem)[![Python wheels](https://img.shields.io/badge/wheels-%E2%9C%93-4c1.svg?longCache=true&amp;style=flat-square&amp;logo=python&amp;logoColor=white)](https://github.com/explosion/wheelwright/releases)## OverviewThe most useful is `cymem.Pool`, which acts as a thin wrapper around the callocfunction:```pythonfrom cymem.cymem cimport Poolcdef Pool mem = Pool()data1 = &lt;int*&gt;mem.alloc(10, sizeof(int))data2 = &lt;float*&gt;mem.alloc(12, sizeof(float))```The `Pool` object saves the memory addresses internally, and frees them when theobject is garbage collected. Typically you'll attach the `Pool` to some cdef'dclass. This is particularly handy for deeply nested structs, which havecomplicated initialization functions. Just pass the `Pool` object into theinitializer, and you don't have to worry about freeing your struct at all —all of the calls to `Pool.alloc` will be automatically freed when the `Pool`expires.## InstallationInstallation is via [pip](https://pypi.python.org/pypi/pip), and requires [Cython](http://cython.org). Before installing, make sure that your `pip`, `setuptools` and `wheel` are up to date.```bashpip install -U pip setuptools wheelpip install cymem```## Example Use Case: An array of structsLet's say we want a sequence of sparse matrices. We need fast access, anda Python list isn't performing well enough. So, we want a C-array or C++vector, which means we need the sparse matrix to be a C-level struct — itcan't be a Python class. We can write this easily enough in Cython:```python&quot;&quot;&quot;Example without CymemTo use an array of structs, we must carefully walk the data structure whenwe deallocate it.&quot;&quot;&quot;from libc.stdlib cimport calloc, freecdef struct SparseRow:    size_t length    size_t* indices    double* valuescdef struct SparseMatrix:    size_t length    SparseRow* rowscdef class MatrixArray:    cdef size_t length    cdef SparseMatrix** matrices    def __cinit__(self, list py_matrices):        self.length = 0        self.matrices = NULL    def __init__(self, list py_matrices):        self.length = len(py_matrices)        self.matrices = &lt;SparseMatrix**&gt;calloc(len(py_matrices), sizeof(SparseMatrix*))        for i, py_matrix in enumerate(py_matrices):            self.matrices[i] = sparse_matrix_init(py_matrix)    def __dealloc__(self):        for i in range(self.length):            sparse_matrix_free(self.matrices[i])        free(self.matrices)cdef SparseMatrix* sparse_matrix_init(list py_matrix) except NULL:    sm = &lt;SparseMatrix*&gt;calloc(1, sizeof(SparseMatrix))    sm.length = len(py_matrix)    sm.rows = &lt;SparseRow*&gt;calloc(sm.length, sizeof(SparseRow))    cdef size_t i, j    cdef dict py_row    cdef size_t idx    cdef double value    for i, py_row in enumerate(py_matrix):        sm.rows[i].length = len(py_row)        sm.rows[i].indices = &lt;size_t*&gt;calloc(sm.rows[i].length, sizeof(size_t))        sm.rows[i].values = &lt;double*&gt;calloc(sm.rows[i].length, sizeof(double))        for j, (idx, value) in enumerate(py_row.items()):            sm.rows[i].indices[j] = idx            sm.rows[i].values[j] = value    return smcdef void* sparse_matrix_free(SparseMatrix* sm) except *:    cdef size_t i    for i in range(sm.length):        free(sm.rows[i].indices)        free(sm.rows[i].values)    free(sm.rows)    free(sm)```We wrap the data structure in a Python ref-counted class at as low a level aswe can, given our performance constraints. This allows us to allocate and freethe memory in the `__cinit__` and `__dealloc__` Cython special methods.However, it's very easy to make mistakes when writing the `__dealloc__` and`sparse_matrix_free` functions, leading to memory leaks. cymem prevents you fromwriting these deallocators at all. Instead, you write as follows:```python&quot;&quot;&quot;Example with Cymem.Memory allocation is hidden behind the Pool class, which remembers theaddresses it gives out.  When the Pool object is garbage collected, all ofits addresses are freed.We don't need to write MatrixArray.__dealloc__ or sparse_matrix_free,eliminating a common class of bugs.&quot;&quot;&quot;from cymem.cymem cimport Poolcdef struct SparseRow:    size_t length    size_t* indices    double* valuescdef struct SparseMatrix:    size_t length    SparseRow* rowscdef class MatrixArray:    cdef size_t length    cdef SparseMatrix** matrices    cdef Pool mem    def __cinit__(self, list py_matrices):        self.mem = None        self.length = 0        self.matrices = NULL    def __init__(self, list py_matrices):        self.mem = Pool()        self.length = len(py_matrices)        self.matrices = &lt;SparseMatrix**&gt;self.mem.alloc(self.length, sizeof(SparseMatrix*))        for i, py_matrix in enumerate(py_matrices):            self.matrices[i] = sparse_matrix_init(self.mem, py_matrix)cdef SparseMatrix* sparse_matrix_init_cymem(Pool mem, list py_matrix) except NULL:    sm = &lt;SparseMatrix*&gt;mem.alloc(1, sizeof(SparseMatrix))    sm.length = len(py_matrix)    sm.rows = &lt;SparseRow*&gt;mem.alloc(sm.length, sizeof(SparseRow))    cdef size_t i, j    cdef dict py_row    cdef size_t idx    cdef double value    for i, py_row in enumerate(py_matrix):        sm.rows[i].length = len(py_row)        sm.rows[i].indices = &lt;size_t*&gt;mem.alloc(sm.rows[i].length, sizeof(size_t))        sm.rows[i].values = &lt;double*&gt;mem.alloc(sm.rows[i].length, sizeof(double))        for j, (idx, value) in enumerate(py_row.items()):            sm.rows[i].indices[j] = idx            sm.rows[i].values[j] = value    return sm```All that the `Pool` class does is remember the addresses it gives out. When the`MatrixArray` object is garbage-collected, the `Pool` object will also be garbagecollected, which triggers a call to `Pool.__dealloc__`. The `Pool` then frees all ofits addresses. This saves you from walking back over your nested data structuresto free them, eliminating a common class of errors.## Custom AllocatorsSometimes external C libraries use private functions to allocate and free objects,but we'd still like the laziness of the `Pool`.```pythonfrom cymem.cymem cimport Pool, WrapMalloc, WrapFreecdef Pool mem = Pool(WrapMalloc(priv_malloc), WrapFree(priv_free))```</longdescription>
</pkgmetadata>