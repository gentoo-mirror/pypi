<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># AccelByte Python SDKA software development kit (SDK) for interacting with AccelByte services written in Python.This SDK was generated from OpenAPI specification documents included in the [spec](spec) directory.## SetupThis SDK requires Python 3.9 to be installed.### Install with PipInstall dependencies.```shpip install requests httpx websockets PyYAML PyJWT[crypto] mmh3 bitarray```Install from PyPI```shpip install accelbyte-py-sdk```or install from source.```shpip install git+https://github.com/AccelByte/accelbyte-python-sdk.git@{VERSION}#egg=accelbyte_py_sdk```Replace `{VERSION}` with a specific release version tag. When starting a new project, using the latest release version is recommended. For the list of available versions, see [releases](https://github.com/AccelByte/accelbyte-python-sdk/releases). **Special note only for Windows environment**If you encounter error `path too long` when attempting to install the SDK. The steps to solve this are:1. [Enable long paths in registry.](https://docs.python.org/3/using/windows.html#removing-the-max-path-limitation)2. Enable long paths in git.   ```   git config --global core.longpaths true   ```3. Restart the powershell window you used to take effect.4. Try installing SDK again.   ```   pip install git+https://github.com/AccelByte/accelbyte-python-sdk.git@{VERSION}#egg=accelbyte_py_sdk   ```### Environment VariablesThe following environment variables need to be set when using `EnvironmentConfigRepository` (default).| Name             | Required                                                                               | Example                          ||------------------|----------------------------------------------------------------------------------------|----------------------------------|| AB_BASE_URL      | Yes                                                                                    | https://demo/accelbyte.io        || AB_CLIENT_ID     | Yes                                                                                    | abcdef0123456789abcdef0123456789 || AB_CLIENT_SECRET | Yes, only if you use a private `AB_CLIENT_ID`                                          | ab#c,d)ef(ab#c,d)ef(ab#c,d)ef(ab || AB_NAMESPACE     | Yes, the SDK will automatically fill up the `{namespace}` path parameter (overridable) | accelbyte                        || AB_APP_NAME      | No, the SDK will automatically fill up the `User-Agent` header (overridable)           | MyApp                            || AB_APP_VERSION   | No, the SDK will automatically fill up the `User-Agent` header (overridable)           | 1.0.0                            |## Usage### InitializingYou'll have to initialize the SDK using the `initialize()` function.```pythonimport accelbyte_py_sdkif __name__ == &quot;__main__&quot;:    accelbyte_py_sdk.initialize()    # uses EnvironmentConfigRepository by default    #   which in turn uses '$AB_BASE_URL', '$AB_CLIENT_ID', '$AB_CLIENT_SECRET', '$AB_NAMESPACE'```You could also pass in options like so:```pythonfrom os import environimport accelbyte_py_sdkfrom accelbyte_py_sdk.core import MyConfigRepositoryif __name__ == &quot;__main__&quot;:    base_url = environ[&quot;MY_BASE_URL&quot;]    client_id = environ[&quot;MY_CLIENT_ID&quot;]    client_secret = environ[&quot;MY_CLIENT_SECRET&quot;]    namespace = environ[&quot;MY_NAMESPACE&quot;]    app_name = environ[&quot;MY_APP_NAME&quot;]    app_version = environ[&quot;MY_APP_VERSION&quot;]    my_config_repository = MyConfigRepository(        base_url=base_url,        client_id=client_id,        client_secret=client_secret,        namespace=namespace,        app_name=app_name,        app_version=app_version    )    options = {        &quot;config&quot;: my_config_repository    }    accelbyte_py_sdk.initialize(options)    # you could still set some of these options after initializing.    # ex. accelbyte_py_sdk.core.set_config_repository(my_config_repository)```### Logging In and Logging Out#### Login using Username and Password```pythonfrom os import environimport accelbyte_py_sdkfrom accelbyte_py_sdk.services.auth import login_user, logoutif __name__ == &quot;__main__&quot;:    accelbyte_py_sdk.initialize()    username = environ[&quot;AB_USERNAME&quot;]    password = environ[&quot;AB_PASSWORD&quot;]    token, error = login_user(username, password)    assert error is None    _, error = logout()    assert error is None```Here `login_user(username, password)` and `logout()` are wrapper functions.#### Login using OAuth Client (Public or Confidential)```pythonfrom os import environimport accelbyte_py_sdkfrom accelbyte_py_sdk.services.auth import login_clientif __name__ == &quot;__main__&quot;:    accelbyte_py_sdk.initialize()    client_id = environ[&quot;AB_CLIENT_ID&quot;]    client_secret = environ[&quot;AB_CLIENT_SECRET&quot;]    token, error = login_client(client_id, client_secret)    # passing '$AB_CLIENT_ID' and '$AB_CLIENT_SECRET' is same as:    # token, error = login_client()    assert error is not None```:bulb: Using `login_x(..., auto_refresh=True)` automatically refreshes the token once the expiration draws near.```python# set the refresh rate for 'login_client'# 0.5 means refresh when we 50% of the expiration duration has passedres, err = login_client(client_id, client_secret, auto_refresh=True, refresh_rate=0.5)``````python# set the refresh rate for 'login_user'# 0.5 means refresh when we 50% of the expiration duration has passedres, err = login_user(username, password, auto_refresh=True, refresh_rate=0.5)```The auto refresh is only triggered when another request is fired. If you want to the refresh run automatically in the background. Use any of the `LoginXTimer` classes.```pythonfrom accelbyte_py_sdk.services.auth import LoginClientTimer, LoginPlatformTimer, LoginUserTimer, RefreshLoginTimerres, err = login_user(username, password)if err is not None:    exit(1)# creates a threading.Timer-like object that calls login_user every 1800 seconds repeatedly 'inf' timesinterval = 1800timer = LoginUserTimer(    interval,    username=username,    password=password,    repeats=-1,  # &lt;0: repeat 'inf' times | 0 or None: repeat 0 times | &gt;0: repeat n times     autostart=True,)```To manually refresh the token:```pythonfrom accelbyte_py_sdk.core import get_token_repositoryfrom accelbyte_py_sdk.services.auth import refresh_logintoken_repo = get_token_repository()refresh_token = token_repo.get_refresh_token()token, error = refresh_login(refresh_token)assert error is None```## Using multiple SDK instancesThe examples above demonstrates using just one instance of the Python SDK (the default which is also global), but you could also instantiate multiple instances of the SDK and use them at the same time.```pythonimport accelbyte_py_sdk.services.auth as auth_serviceimport accelbyte_py_sdk.api.iam as iam_serviceimport accelbyte_py_sdk.api.iam.models as iam_modelsfrom accelbyte_py_sdk import AccelByteSDKfrom accelbyte_py_sdk.core import EnvironmentConfigRepositoryfrom accelbyte_py_sdk.core import InMemoryTokenRepository# Create 3 instances of the SDKclient_sdk = AccelByteSDK()user_sdk1 = AccelByteSDK()user_sdk2 = AccelByteSDK()# Initialize the SDKsclient_sdk.initialize(    options={        &quot;config&quot;: EnvironmentConfigRepository(),        &quot;token&quot;: InMemoryTokenRepository(),    })user_sdk1.initialize(    options={        &quot;config&quot;: EnvironmentConfigRepository(),        &quot;token&quot;: InMemoryTokenRepository(),    })user_sdk2.initialize(    options={        &quot;config&quot;: user_sdk1.get_config_repository(),  # you could also share the config repo with User 1 SDK's        &quot;token&quot;: InMemoryTokenRepository(),  # you could also do the same thing with token repos but that is not advisable.     })# Login the SDKs_, error = auth_service.login_client(sdk=client_sdk)username1, password1 = ..._, error = auth_service.login_user(username1, password1, sdk=user_sdk1)username2, password2 = ..._, error = auth_service.login_user(username2, password2, sdk=user_sdk2)# Call an endpoint as User 1result1, error = iam_service.public_create_user_v4(    body=iam_models.AccountCreateUserRequestV4.create_from_dict({...}),    sdk=user_sdk1,)# Call an endpoint as User 2result2, error = iam_service.public_create_user_v4(    body=iam_models.AccountCreateUserRequestV4.create_from_dict({...}),    sdk=user_sdk2,)# Call an endpoint as the Admin IAM Clientresult, error = admin_update_user_v4(    body=iam_models.ModelUserUpdateRequestV3.create_from_dict({...}),    user_id=result1.user_id,    sdk=client_sdk,)# Reset/Deintialize the SDKs after usingclient_sdk1.deintialize()client_sdk1.deintialize()client_sdk1.deintialize()```## Interacting with a Service Endpoint### Example AIn this example we will create a new user using the `POST` endpoint `/iam/v3/public/namespaces/{namespace}/users````pythonimport jsonimport accelbyte_py_sdkfrom accelbyte_py_sdk.services.auth import login_client# Import the wrapper 'public_create_user_v3'# to know which wrapper to use open the docs/&lt;service-name&gt;-index.md and# use the search function to find the wrapper namefrom accelbyte_py_sdk.api.iam import public_create_user_v3# This POST endpoint also requires a body of 'ModelUserCreateRequestV3'# so you will need to import that too, import it using this scheme:#  from accelbyte_py_sdk.api.&lt;service-name&gt;.models import &lt;model-name&gt;from accelbyte_py_sdk.api.iam.models import ModelUserCreateRequestV3from accelbyte_py_sdk.api.iam.models import ModelUserCreateResponseV3def main():    # 1 Initialize the SDK    accelbyte_py_sdk.initialize()    # 2 Login as a client (uses $AB_CLIENT_ID and $AB_CLIENT_SECRET)    _, error = login_client()    # 3 Create a user using the POST endpoint: /iam/v3/public/namespaces/{namespace}/users    #   * this endpoint requires:    #     - a 'body' (ModelUserCreateRequestV3)    #     - a 'namespace' (string)    #       'namespace' here is unique because it can be omitted, omitting it will result in    #       the SDK to automatically fill it out with the value of '$AB_NAMESPACE'    #   * more details on this endpoint can be found in:    #     accelbyte_py_sdk/api/iam/operations/users/public_create_user_v3.py    result, error = public_create_user_v3(        body=ModelUserCreateRequestV3.create(            auth_type=&quot;EMAILPASSWD&quot;,            country=&quot;US&quot;,            date_of_birth=&quot;2001-01-01&quot;,            display_name=&quot;************&quot;,            email_address=&quot;******@fakemail.com&quot;,            password=&quot;******************&quot;,        )    )    # 4 Check for errors    if error:      exit(1)    # 5 Do something with the result    print(json.dumps(result.to_dict(), indent=2))    # {    #   &quot;authType&quot;: &quot;EMAILPASSWD&quot;,    #   &quot;country&quot;: &quot;US&quot;,    #   &quot;dateOfBirth&quot;: &quot;2001-01-01T00:00:00Z&quot;,    #   &quot;displayName&quot;: &quot;************&quot;,    #   &quot;emailAddress&quot;: &quot;******@fakemail.com&quot;,    #   &quot;namespace&quot;: &quot;******&quot;,    #   &quot;userId&quot;: &quot;********************************&quot;    # }if __name__ == &quot;__main__&quot;:    main()```:bulb: All wrapper functions follow the return value format of `result, error`.:bulb: You could also write your own wrapper functions by using the models and operations in `accelbyte_py_sdk.api.&lt;service-name&gt;` and `accelbyte_py_sdk.api.&lt;service-name&gt;.models` respectively.:bulb: All wrapper functions have an asynchronous counterpart that ends with `_async`.### Example A (`async`)To convert `Example A` asynchronously the following steps are needed.1. Import the asyncio package.    ```python    import asyncio    ```2. Convert the main method into `async`.    ```python    # def main():    async def main():    ```3. Change how the `main` function is invoked.    ```python    if __name__ == &quot;__main__&quot;:        # main()        loop = asyncio.get_event_loop()        loop.run_until_complete(main())    ```4. Use `HttpxHttpClient`.    ```python    # accelbyte_py_sdk.initialize()    accelbyte_py_sdk.initialize(options={&quot;http&quot;: &quot;HttpxHttpClient&quot;})    ```5. Use the `async` version of the wrapper by appending `_async`.    ```python    # from accelbyte_py_sdk.api.iam import public_create_user_v3    from accelbyte_py_sdk.api.iam import public_create_user_v3_async    ```6. Use the `async` wrapper with the `await` keyword.    ```python    # result, error = public_create_user_v3(    result, error = await public_create_user_v3_async(    ```Here is the full code:```pythonimport asyncioimport jsonimport accelbyte_py_sdkfrom accelbyte_py_sdk.services.auth import login_client# Import the wrapper 'public_create_user_v3_async'# to know which wrapper to use open the docs/&lt;service-name&gt;-index.md and# use the search function to find the wrapper namefrom accelbyte_py_sdk.api.iam import public_create_user_v3_async# This POST endpoint also requires a body of 'ModelUserCreateRequestV3'# so you will need to import that too, import it using this scheme:#  from accelbyte_py_sdk.api.&lt;service-name&gt;.models import &lt;model-name&gt;from accelbyte_py_sdk.api.iam.models import ModelUserCreateRequestV3from accelbyte_py_sdk.api.iam.models import ModelUserCreateResponseV3async def main():    # 1 Initialize the SDK    accelbyte_py_sdk.initialize(options={&quot;http&quot;: &quot;HttpxHttpClient&quot;})    # 2 Login as a client (uses $AB_CLIENT_ID and $AB_CLIENT_SECRET)    _, error = login_client()    # 3 Create a user using the POST endpoint: /iam/v3/public/namespaces/{namespace}/users    #   * this endpoint requires:    #     - a 'body' (ModelUserCreateRequestV3)    #     - a 'namespace' (string)    #       'namespace' here is unique because it can be omitted, omitting it will result in    #       the SDK to automatically fill it out with the value of '$AB_NAMESPACE'    #   * more details on this endpoint can be found in:    #     accelbyte_py_sdk/api/iam/operations/users/public_create_user_v3.py    result, error = await public_create_user_v3_async(        body=ModelUserCreateRequestV3.create(            auth_type=&quot;EMAILPASSWD&quot;,            country=&quot;US&quot;,            date_of_birth=&quot;2001-01-01&quot;,            display_name=&quot;************&quot;,            email_address=&quot;******@fakemail.com&quot;,            password=&quot;******************&quot;,        )    )    # 4 Check for errors    if error:      exit(1)    # 5 Do something with the result    print(json.dumps(result.to_dict(), indent=2))    # {    #   &quot;authType&quot;: &quot;EMAILPASSWD&quot;,    #   &quot;country&quot;: &quot;US&quot;,    #   &quot;dateOfBirth&quot;: &quot;2001-01-01T00:00:00Z&quot;,    #   &quot;displayName&quot;: &quot;************&quot;,    #   &quot;emailAddress&quot;: &quot;******@fakemail.com&quot;,    #   &quot;namespace&quot;: &quot;******&quot;,    #   &quot;userId&quot;: &quot;********************************&quot;    # }if __name__ == &quot;__main__&quot;:    loop = asyncio.get_event_loop()    loop.run_until_complete(main())```---## Configuring HTTP RetryTo use the `HTTP Retry` feature, set the `HttpClient`'s `retry_policy` and `backoff_policy`.```pythonimport accelbyte_py_sdkfrom accelbyte_py_sdk.core import get_http_client# 1 Initialize the SDKaccelbyte_py_sdk.initialize()# 2 Get the HTTP Clienthttp_client = get_http_client()# 3 Configure the `retry_policy` and `backoff_policy`# 3a. Retry 3 times with 0.5 seconds delay in betweenfrom accelbyte_py_sdk.core import ConstantHttpBackoffPolicyfrom accelbyte_py_sdk.core import MaxRetriesHttpRetryPolicyhttp_client.retry_policy = MaxRetriesHttpRetryPolicy(3)# 3b. Retry when total elapsed time is less than 15 seconds, with an exponential backoff duration.from accelbyte_py_sdk.core import ExponentialHttpBackoffPolicyfrom accelbyte_py_sdk.core import MaxElapsedHttpRetryPolicyhttp_client.backoff_policy = ExponentialHttpBackoffPolicy(initial=1.0, multiplier=2.0)http_client.retry_policy = MaxElapsedHttpRetryPolicy(15)# 3c. Use custom retry and backoff policies.from datetime import timedeltafrom typing import Optionaldef my_custom_retry_policy(request, response, /, *, retries: int = 0, elapsed: Optional[timedelta] = None, **kwargs) -&gt; float:    return &quot;Retry-After&quot; in response.headers and retries == 1  # Retry if the 'Retry-After' header exists and we are on the 1st retry (2nd attempt).def my_custom_backoff_policy(request, response, /, *, retries: int = 0, elapsed: Optional[timedelta] = None, **kwargs) -&gt; float:    return response.headers.get(&quot;Retry-After&quot;, 1)  # Use the value of the 'Retry-After' response header, default to 1.0s.http_client.backoff_policy = my_custom_backoff_policyhttp_client.retry_policy = my_custom_retry_policy# 3d. Combining multiple retry policies.from accelbyte_py_sdk.core import CompositeHttpRetryPolicyfrom accelbyte_py_sdk.core import MaxRetriesHttpRetryPolicyfrom accelbyte_py_sdk.core import StatusCodesHttpRetryPolicyhttp_client.retry_policy = CompositeHttpRetryPolicy(    StatusCodesHttpRetryPolicy(401, (501, 503)),  # Retry when response status code is 401, 501 to 503 (501, 502, or 503) -- AND    MaxRetriesHttpRetryPolicy(3)                  #       when number of retries is less than or equal to 3.)```---## Validating TokensYou can use `accelbyte_py_sdk.token_validation.caching.CachingTokenValidator` or `accelbyte_py_sdk.token_validation.iam.IAMTokenValidator`.```pythontoken_validator = CachingTokenValidator(sdk)  # or IAMTokenValidator(sdk)# access_token = ...error = token_validator.validate_token(access_token)if error:    raise error```---See [tests](tests/sdk/core/_request.py) for more usage.## SamplesSample apps are available in the [samples](samples) directory## DocumentationFor documentation about AccelByte services and SDK, see [docs.accelbyte.io](https://docs.accelbyte.io/):bulb: Check out the index files in the [docs](docs) directory if you are looking for a specific endpoint.---## Misc### Utility FunctionsCheck if the SDK is initialized.```pythonimport accelbyte_py_sdkis_initialized = accelbyte_py_sdk.is_initialized()print(is_initialized)# False```Create a Basic Auth from a string tuple.```pythonimport accelbyte_py_sdkbasic_auth = accelbyte_py_sdk.core.create_basic_authentication(&quot;foo&quot;, &quot;bar&quot;)print(basic_auth)# Basic Zm9vOmJhcg==```Gets the stored access token.```pythonimport accelbyte_py_sdkaccess_token, error = accelbyte_py_sdk.core.get_access_token()print(access_token)# ************************************```Get `AB_*` environment configuration values.```pythonimport accelbyte_py_sdkbase_url, client_id, client_secret, namespace = accelbyte_py_sdk.core.get_env_config()print(f&quot;{base_url}, {client_id}, {client_secret}, {namespace}&quot;)# &lt;$AB_BASE_URL&gt;, &lt;$AB_CLIENT_ID&gt;, &lt;$AB_CLIENT_SECRET&gt;, &lt;$AB_NAMESPACE&gt;```Get `AB_*` environment user credential values.```pythonimport accelbyte_py_sdkusername, password = accelbyte_py_sdk.core.get_env_user_credentials()print(f&quot;{base_url}: {client_id}&quot;)# &lt;$AB_USERNAME&gt;: &lt;$AB_PASSWORD&gt;```Set logger level and add logger handlers.```pythonimport logging# 1. The SDK has helper functions for logging.accelbyte_py_sdk.core.set_logger_level(logging.INFO)          # 'accelbyte_py_sdk'accelbyte_py_sdk.core.set_logger_level(logging.INFO, &quot;http&quot;)  # 'accelbyte_py_sdk.http'accelbyte_py_sdk.core.set_logger_level(logging.INFO, &quot;ws&quot;)    # 'accelbyte_py_sdk.ws'# 2. You could also use this helper function for debugging.accelbyte_py_sdk.core.add_stream_handler_to_logger()          # sends content of the 'accelbyte_py_sdk' logger to 'sys.stderr'.# 3. There is a helper function that helps you get started with log files.accelbyte_py_sdk.core.add_buffered_file_handler_to_logger(    # flushes content of the 'accelbyte_py_sdk' logger to a file named 'sdk.log' every 10 logs.    filename=&quot;/path/to/sdk.log&quot;,    capacity=10,    level=logging.INFO)accelbyte_py_sdk.core.add_buffered_file_handler_to_logger(    # flushes content of the 'accelbyte_py_sdk.http' logger to a file named 'http.log' every 3 logs.    filename=&quot;/path/to/http.log&quot;,    capacity=3,    level=logging.INFO,    additional_scope=&quot;http&quot;)# 3.a. Or you could the same thing when initializing the SDK.accelbyte_py_sdk.initialize(    options={        &quot;log_files&quot;: {            &quot;&quot;: &quot;/path/to/sdk.log&quot;,                           # flushes content of the 'accelbyte_py_sdk' logger to a file named 'sdk.log' every 10 logs.            &quot;http&quot;: {                                         # flushes content of the 'accelbyte_py_sdk.http' logger to a file named 'http.log' every 3 logs.                &quot;filename&quot;: &quot;/path/to/http.log&quot;,                &quot;capacity&quot;: 3,                &quot;level&quot;: logging.INFO            }        }    })# 4. By default logs from 'accelbyte_py_sdk.http' are stringified dictionaries, you can set your own formatter like so.def format_request_response_as_yaml(data: dict) -&gt; str:    return f&quot;---\n{yaml.safe_dump(data, sort_keys=False).rstrip()}\n...&quot;http_client = accelbyte_py_sdk.core.get_http_client()http_client.request_log_formatter = format_request_response_as_yamlhttp_client.response_log_formatter = format_request_response_as_yaml```---## In-depth Topics### Generated code#### ModelsEach definition in `#/definitions/` is turned into a Model.Example:```yaml# UserProfileInfoproperties:  avatarLargeUrl:    type: string  avatarSmallUrl:    type: string  avatarUrl:    type: string  customAttributes:    additionalProperties:      type: object    type: object  dateOfBirth:    format: date    type: string    x-nullable: true  firstName:    type: string  language:    type: string  lastName:    type: string  namespace:    type: string  status:    enum:    - ACTIVE    - INACTIVE    type: string  timeZone:    type: string  userId:    type: string  zipCode:    type: stringtype: object``````python# accelbyte_py_sdk/api/basic/models/user_profile_info.pyclass UserProfileInfo(Model):    &quot;&quot;&quot;User profile info (UserProfileInfo)    Properties:        avatar_large_url: (avatarLargeUrl) OPTIONAL str        avatar_small_url: (avatarSmallUrl) OPTIONAL str        avatar_url: (avatarUrl) OPTIONAL str        custom_attributes: (customAttributes) OPTIONAL Dict[str, Any]        date_of_birth: (dateOfBirth) OPTIONAL str        first_name: (firstName) OPTIONAL str        language: (language) OPTIONAL str        last_name: (lastName) OPTIONAL str        namespace: (namespace) OPTIONAL str        status: (status) OPTIONAL Union[str, StatusEnum]        time_zone: (timeZone) OPTIONAL str        user_id: (userId) OPTIONAL str        zip_code: (zipCode) OPTIONAL str    &quot;&quot;&quot;    # region fields    avatar_large_url: str                                                                          # OPTIONAL    avatar_small_url: str                                                                          # OPTIONAL    avatar_url: str                                                                                # OPTIONAL    custom_attributes: Dict[str, Any]                                                              # OPTIONAL    date_of_birth: str                                                                             # OPTIONAL    first_name: str                                                                                # OPTIONAL    language: str                                                                                  # OPTIONAL    last_name: str                                                                                 # OPTIONAL    namespace: str                                                                                 # OPTIONAL    status: Union[str, StatusEnum]                                                                 # OPTIONAL    time_zone: str                                                                                 # OPTIONAL    user_id: str                                                                                   # OPTIONAL    zip_code: str                                                                                  # OPTIONAL    # endregion fields```there are also a number of utility functions generated with each model that should help in the ease of use.```python# accelbyte_py_sdk/api/basic/models/user_profile_info.py    ...    def with_user_id(self, value: str) -&gt; UserProfileInfo:        self.user_id = value        return self    # other with_x() methods too    def to_dict(self, include_empty: bool = False) -&gt; dict:        result: dict = {}        ...        return result    @classmethod    def create(        cls,        avatar_large_url: Optional[str] = None,        avatar_small_url: Optional[str] = None,        avatar_url: Optional[str] = None,        custom_attributes: Optional[Dict[str, Any]] = None,        date_of_birth: Optional[str] = None,        first_name: Optional[str] = None,        language: Optional[str] = None,        last_name: Optional[str] = None,        namespace: Optional[str] = None,        status: Optional[Union[str, StatusEnum]] = None,        time_zone: Optional[str] = None,        user_id: Optional[str] = None,        zip_code: Optional[str] = None,    ) -&gt; UserProfileInfo:        instance = cls()        ...        return instance    @classmethod    def create_from_dict(cls, dict_: dict, include_empty: bool = False) -&gt; UserProfileInfo:        instance = cls()        ...        return instance    @staticmethod    def get_field_info() -&gt; Dict[str, str]:        return {            &quot;avatarLargeUrl&quot;: &quot;avatar_large_url&quot;,            &quot;avatarSmallUrl&quot;: &quot;avatar_small_url&quot;,            &quot;avatarUrl&quot;: &quot;avatar_url&quot;,            &quot;customAttributes&quot;: &quot;custom_attributes&quot;,            &quot;dateOfBirth&quot;: &quot;date_of_birth&quot;,            &quot;firstName&quot;: &quot;first_name&quot;,            &quot;language&quot;: &quot;language&quot;,            &quot;lastName&quot;: &quot;last_name&quot;,            &quot;namespace&quot;: &quot;namespace&quot;,            &quot;status&quot;: &quot;status&quot;,            &quot;timeZone&quot;: &quot;time_zone&quot;,            &quot;userId&quot;: &quot;user_id&quot;,            &quot;zipCode&quot;: &quot;zip_code&quot;,        }    ...```#### OperationsEach path item in `#/paths` is turned into an Operation.Example:```yaml# GET /basic/v1/public/namespaces/{namespace}/users/{userId}/profilesdescription: 'Get user profile.&amp;lt;br&amp;gt;Other detail info: &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&amp;lt;i&amp;gt;Required  permission&amp;lt;/i&amp;gt;: resource=&amp;lt;b&amp;gt;&amp;#34;NAMESPACE:{namespace}:USER:{userId}:PROFILE&amp;#34;&amp;lt;/b&amp;gt;,  action=2 &amp;lt;b&amp;gt;(READ)&amp;lt;/b&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;&amp;lt;i&amp;gt;Action code&amp;lt;/i&amp;gt;:  11403&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;&amp;lt;i&amp;gt;Returns&amp;lt;/i&amp;gt;: user profile&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;'operationId: publicGetUserProfileInfoparameters:- description: namespace, only accept alphabet and numeric  in: path  name: namespace  required: true  type: string- description: user's id, should follow UUID version 4 without hyphen  in: path  name: userId  required: true  type: stringproduces:- application/jsonresponses:  '200':    description: Successful operation    schema:      $ref: '#/definitions/UserProfileInfo'  '400':    description: &lt;table&gt;&lt;tr&gt;&lt;td&gt;errorCode&lt;/td&gt;&lt;td&gt;errorMessage&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;validation      error&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;    schema:      $ref: '#/definitions/ValidationErrorEntity'  '401':    description: &lt;table&gt;&lt;tr&gt;&lt;td&gt;errorCode&lt;/td&gt;&lt;td&gt;errorMessage&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;20001&lt;/td&gt;&lt;td&gt;unauthorized&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;    schema:      $ref: '#/definitions/ErrorEntity'  '403':    description: &lt;table&gt;&lt;tr&gt;&lt;td&gt;errorCode&lt;/td&gt;&lt;td&gt;errorMessage&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;20013&lt;/td&gt;&lt;td&gt;insufficient      permission&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;    schema:      $ref: '#/definitions/ErrorEntity'  '404':    description: '&lt;table&gt;&lt;tr&gt;&lt;td&gt;errorCode&lt;/td&gt;&lt;td&gt;errorMessage&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;11440&lt;/td&gt;&lt;td&gt;Unable      to {action}: User profile not found in namespace [{namespace}]&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;'    schema:      $ref: '#/definitions/ErrorEntity'security:- authorization: []- HasPermission:  - NAMESPACE:{namespace}:USER:{userId}:PROFILE [READ]  authorization: []summary: Get user profiletags:- UserProfilex-authorization:  action: '2'  resource: NAMESPACE:{namespace}:USER:{userId}:PROFILE```same with the models there are also a number of utility functions generated with each operation that should help in the ease of use.```python# accelbyte_py_sdk/api/basic/operations/user_profile/get_user_profile_info.py# Copyright (c) 2021 AccelByte Inc. All Rights Reserved.# This is licensed software from AccelByte Inc, for limitations# and restrictions contact your company contract manager.# # Code generated. DO NOT EDIT!# template file: accelbyte_gaming services_py_codegen# pylint: disable=duplicate-code# pylint: disable=line-too-long# pylint: disable=missing-function-docstring# pylint: disable=missing-module-docstring# pylint: disable=too-many-arguments# pylint: disable=too-many-branches# pylint: disable=too-many-instance-attributes# pylint: disable=too-many-lines# pylint: disable=too-many-locals# pylint: disable=too-many-public-methods# pylint: disable=too-many-return-statements# pylint: disable=too-many-statements# pylint: disable=unused-import# AccelByte Gaming Services Basic Service (1.36.1)from __future__ import annotationsfrom typing import Any, Dict, List, Optional, Tuple, Unionfrom .....core import Operationfrom .....core import HeaderStrfrom .....core import HttpResponsefrom ...models import ErrorEntityfrom ...models import UserProfilePrivateInfofrom ...models import ValidationErrorEntityclass GetUserProfileInfo(Operation):    &quot;&quot;&quot;Get user profile (getUserProfileInfo)    Get user profile.    Other detail info:      * Required permission : resource= &quot;ADMIN:NAMESPACE:{namespace}:USER:{userId}:PROFILE&quot; , action=2 (READ)      *  Returns : user profile      *  Action code : 11403    Required Permission(s):        - ADMIN:NAMESPACE:{namespace}:USER:{userId}:PROFILE [READ]    Properties:        url: /basic/v1/admin/namespaces/{namespace}/users/{userId}/profiles        method: GET        tags: [&quot;UserProfile&quot;]        consumes: []        produces: [&quot;application/json&quot;]        securities: [BEARER_AUTH] or [BEARER_AUTH]        namespace: (namespace) REQUIRED str in path        user_id: (userId) REQUIRED str in path    Responses:        200: OK - UserProfilePrivateInfo (successful operation)        400: Bad Request - ValidationErrorEntity (20002: validation error)        401: Unauthorized - ErrorEntity (20001: unauthorized)        403: Forbidden - ErrorEntity (20013: insufficient permission)        404: Not Found - ErrorEntity (11440: Unable to {action}: User profile not found in namespace [{namespace}])    &quot;&quot;&quot;    # region fields    _url: str = &quot;/basic/v1/admin/namespaces/{namespace}/users/{userId}/profiles&quot;    _method: str = &quot;GET&quot;    _consumes: List[str] = []    _produces: List[str] = [&quot;application/json&quot;]    _securities: List[List[str]] = [[&quot;BEARER_AUTH&quot;], [&quot;BEARER_AUTH&quot;]]    _location_query: str = None    namespace: str                                                                                 # REQUIRED in [path]    user_id: str                                                                                   # REQUIRED in [path]    # endregion fields    # region properties    @property    def url(self) -&gt; str:        return self._url    @property    def method(self) -&gt; str:        return self._method    @property    def consumes(self) -&gt; List[str]:        return self._consumes    @property    def produces(self) -&gt; List[str]:        return self._produces    @property    def securities(self) -&gt; List[List[str]]:        return self._securities    @property    def location_query(self) -&gt; str:        return self._location_query    # endregion properties    # region get methods    # endregion get methods    # region get_x_params methods    def get_all_params(self) -&gt; dict:        return {            &quot;path&quot;: self.get_path_params(),        }    def get_path_params(self) -&gt; dict:        result = {}        if hasattr(self, &quot;namespace&quot;):            result[&quot;namespace&quot;] = self.namespace        if hasattr(self, &quot;user_id&quot;):            result[&quot;userId&quot;] = self.user_id        return result    # endregion get_x_params methods    # region is/has methods    # endregion is/has methods    # region with_x methods    def with_namespace(self, value: str) -&gt; GetUserProfileInfo:        self.namespace = value        return self    def with_user_id(self, value: str) -&gt; GetUserProfileInfo:        self.user_id = value        return self    # endregion with_x methods    # region to methods    def to_dict(self, include_empty: bool = False) -&gt; dict:        result: dict = {}        if hasattr(self, &quot;namespace&quot;) and self.namespace:            result[&quot;namespace&quot;] = str(self.namespace)        elif include_empty:            result[&quot;namespace&quot;] = &quot;&quot;        if hasattr(self, &quot;user_id&quot;) and self.user_id:            result[&quot;userId&quot;] = str(self.user_id)        elif include_empty:            result[&quot;userId&quot;] = &quot;&quot;        return result    # endregion to methods    # region response methods    # noinspection PyMethodMayBeStatic    def parse_response(self, code: int, content_type: str, content: Any) -&gt; Tuple[Union[None, UserProfilePrivateInfo], Union[None, ErrorEntity, HttpResponse, ValidationErrorEntity]]:        &quot;&quot;&quot;Parse the given response.        200: OK - UserProfilePrivateInfo (successful operation)        400: Bad Request - ValidationErrorEntity (20002: validation error)        401: Unauthorized - ErrorEntity (20001: unauthorized)        403: Forbidden - ErrorEntity (20013: insufficient permission)        404: Not Found - ErrorEntity (11440: Unable to {action}: User profile not found in namespace [{namespace}])        ---: HttpResponse (Undocumented Response)        ---: HttpResponse (Unexpected Content-Type Error)        ---: HttpResponse (Unhandled Error)        &quot;&quot;&quot;        pre_processed_response, error = self.pre_process_response(code=code, content_type=content_type, content=content)        if error is not None:            return None, None if error.is_no_content() else error        code, content_type, content = pre_processed_response        if code == 200:            return UserProfilePrivateInfo.create_from_dict(content), None        if code == 400:            return None, ValidationErrorEntity.create_from_dict(content)        if code == 401:            return None, ErrorEntity.create_from_dict(content)        if code == 403:            return None, ErrorEntity.create_from_dict(content)        if code == 404:            return None, ErrorEntity.create_from_dict(content)        return self.handle_undocumented_response(code=code, content_type=content_type, content=content)    # endregion response methods    # region static methods    @classmethod    def create(        cls,        namespace: str,        user_id: str,    ) -&gt; GetUserProfileInfo:        instance = cls()        instance.namespace = namespace        instance.user_id = user_id        return instance    @classmethod    def create_from_dict(cls, dict_: dict, include_empty: bool = False) -&gt; GetUserProfileInfo:        instance = cls()        if &quot;namespace&quot; in dict_ and dict_[&quot;namespace&quot;] is not None:            instance.namespace = str(dict_[&quot;namespace&quot;])        elif include_empty:            instance.namespace = &quot;&quot;        if &quot;userId&quot; in dict_ and dict_[&quot;userId&quot;] is not None:            instance.user_id = str(dict_[&quot;userId&quot;])        elif include_empty:            instance.user_id = &quot;&quot;        return instance    @staticmethod    def get_field_info() -&gt; Dict[str, str]:        return {            &quot;namespace&quot;: &quot;namespace&quot;,            &quot;userId&quot;: &quot;user_id&quot;,        }    @staticmethod    def get_required_map() -&gt; Dict[str, bool]:        return {            &quot;namespace&quot;: True,            &quot;userId&quot;: True,        }    # endregion static methods```#### Creating:bulb: there are 4 ways to create an instance of these models and operations.```python# 1. using the python __init__() function then setting the parameters manually:model = ModelName()model.param_a = &quot;foo&quot;model.param_b = &quot;bar&quot;# 2. using the python __init__() function together with the 'with_x' methods:# # the 'with_x' functions are type annotated and will show warnings if a wrong type is passed.model = ModelName() \    .with_param_a(&quot;foo&quot;) \    .with_param_b(&quot;bar&quot;)# 3. using the ModelName.create(..) class method:# # parameters here are also type annotated and will throw a TypeError if a required field was not filled out.model = ModelName.create(    param_a=&quot;foo&quot;,    param_b=&quot;bar&quot;,)# 4. using the ModelName.create_from_dict(..) class method:# # this method also has a 'include_empty' option that would get ignore values that evaluate to False, None, or len() == 0.model_params = {    &quot;param_a&quot;: &quot;foo&quot;,    &quot;param_b&quot;: &quot;bar&quot;,    &quot;param_c&quot;: False,    &quot;param_d&quot;: None,    &quot;param_e&quot;: [],    &quot;param_f&quot;: {},}model = ModelName.create_from_dict(model_params)# all of these apply to all operations too.```#### WrappersTo improve ergonomics the code generator also generates wrappers around the operations.The purpose of these wrappers is to automatically fill up parameters that the SDK already knows.(e.g. namespace, client_id, access_token, etc.)They are located at `accelbyte_py_sdk.api.&lt;service-name&gt;.wrappers` but can be accessed like so: `from accelbyte_py_sdk.api.&lt;service-name&gt; import &lt;wrapper-name&gt;````pythonimport accelbyte_py_sdkfrom accelbyte_py_sdk.api.iam import token_grant_v3if __name__ == &quot;__main__&quot;:    accelbyte_py_sdk.initialize()    token, error = token_grant_v3(        grant_type=&quot;client_credentials&quot;    )    assert error is not None```The wrapper function `token_grant_v3` is a wrapper for the `TokenGrantV3` operation.It automatically passes in the information needed like the Basic Auth Headers.The values are gotten from the current `ConfigRepository`.continuing from the previous examples (GetUserProfileInfo), its wrapper would be:```python# accelbyte_py_sdk/api/basic/wrappers/_user_profile.pyfrom typing import Any, Dict, List, Optional, Tuple, Unionfrom ....core import get_namespace as get_services_namespacefrom ....core import run_requestfrom ....core import same_doc_asfrom ..operations.user_profile import GetUserProfileInfo@same_doc_as(GetUserProfileInfo)def get_user_profile_info(user_id: str, namespace: Optional[str] = None):    if namespace is None:        namespace, error = get_services_namespace()        if error:            return None, error    request = GetUserProfileInfo.create(        user_id=user_id,        namespace=namespace,    )    return run_request(request)```this wrapper function automatically fills up the required path parameter `namespace`.now to use it only the `user_id` is now required.```pythonimport accelbyte_py_sdkfrom accelbyte_py_sdk.api.basic import get_user_profile_infoif __name__ == &quot;__main__&quot;:    accelbyte_py_sdk.initialize()    user_profile_info, error = get_user_profile_info(user_id=&quot;lorem&quot;)    assert error is not None    print(f&quot;Hello there {user_profile_info.first_name}!&quot;)```</longdescription>
</pkgmetadata>