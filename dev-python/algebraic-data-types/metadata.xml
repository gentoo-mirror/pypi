<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># adt [![CircleCI](https://circleci.com/gh/jspahrsummers/adt.svg?style=svg&amp;circle-token=2652421c13c636b5da0c992d77ec2fb0b128dd49)](https://circleci.com/gh/jspahrsummers/adt)`adt` is a library providing [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Python, with a clean, intuitive syntax, and support for [`typing`](https://docs.python.org/3/library/typing.html) through a [mypy plugin](#mypy-plugin)._**NOTE:** This project is experimental, and not actively maintained by the author. Contributions and forking are more than welcome._**Table of contents:**1. [What are algebraic data types?](#what-are-algebraic-data-types)    1. [Pattern matching](#pattern-matching)    1. [Compared to Enums](#compared-to-enums)    1. [Compared to inheritance](#compared-to-inheritance)    1. [Examples in other programming languages](#examples-in-other-programming-languages)1. [Installation](#installation)    1. [mypy plugin](#mypy-plugin)1. [Defining an ADT](#defining-an-adt)    1. [Generated functionality](#generated-functionality)    1. [Custom methods](#custom-methods)# What are algebraic data types?An [algebraic data type](https://en.wikipedia.org/wiki/Algebraic_data_type) (also known as an ADT) is a way to represent multiple variants of a single type, each of which can have some data associated with it. The idea is very similar to [tagged unions and sum types](https://en.wikipedia.org/wiki/Tagged_union), which in Python are represented as [Enums](#compared-to-enums).ADTs are useful for a variety of data structures, including binary trees:```python@adtclass Tree:    EMPTY: Case    LEAF: Case[int]    NODE: Case[&quot;Tree&quot;, &quot;Tree&quot;]```Abstract syntax trees (like you might implement as part of a parser, compiler, or interpreter):```python@adtclass Expression:    LITERAL: Case[float]    UNARY_MINUS: Case[&quot;Expression&quot;]    ADD: Case[&quot;Expression&quot;, &quot;Expression&quot;]    MINUS: Case[&quot;Expression&quot;, &quot;Expression&quot;]    MULTIPLY: Case[&quot;Expression&quot;, &quot;Expression&quot;]    DIVIDE: Case[&quot;Expression&quot;, &quot;Expression&quot;]```Or more generic versions of a variant type, like an `Either` type that represents a type A or a type B, but not both:```pythonL = TypeVar('L')R = TypeVar('R')@adtclass Either(Generic[L, R]):    LEFT: Case[L]    RIGHT: Case[R]```## Pattern matchingNow, defining a type isn't that interesting by itself. A lot of the expressivity of ADTs arises when you [pattern match](https://en.wikipedia.org/wiki/Pattern_matching) over them (sometimes known as &quot;destructuring&quot;).For example, we could use the `Either` ADT from above to implement a sort of error handling:```python# Defined in some other module, perhapsdef some_operation() -&gt; Either[Exception, int]:    return Either.RIGHT(22)  # Example of building a constructor# Run some_operation, and handle the success or failuredefault_value = 5unpacked_result = some_operation().match(    # In this case, we're going to ignore any exception we receive    left=lambda ex: default_value,    right=lambda result: result)```_Aside: this is very similar to how error handling is implemented in languages like [Haskell](https://www.haskell.org/), because it avoids the unpredictable control flow of raising and catching exceptions, and ensures that callers need to make an explicit decision about what to do in an error case._One can do the same thing with the `Expression` type above (just more cases to match):```pythondef handle_expression(e: Expression):    return e.match(        literal=lambda n: ...,        unary_minus=lambda expr: ...,        add=lambda lhs, rhs: ...,        minus=lambda lhs, rhs: ...,        multiply=lambda lhs, rhs: ...,        divide=lambda lhs, rhs: ...)```## Compared to EnumsADTs are somewhat similar to [`Enum`s](https://docs.python.org/3/library/enum.html) from the Python standard library (in fact, the uppercase naming convention is purposely similar).For example, an `Enum` version of `Expression` might look like:```pythonfrom enum import Enum, autoclass EnumExpression(Enum):    LITERAL = auto()    UNARY_MINUS = auto()    ADD = auto()    MINUS = auto()    MULTIPLY = auto()    DIVIDE = auto()```However, this doesn't allow data to be associated with each of these enum values. A particular value of `Expression` will tell you about a _kind_ of expression that exists, but the operands to the expressions still have to be stored elsewhere.From this perspective, ADTs are like `Enum`s that can optionally have data associated with each case.## Compared to inheritanceAlgebraic data types are a relatively recent introduction to object-oriented programming languages, for the simple reason that inheritance can replicate the same behavior.Continuing our examples with the `Expression` ADT, here's how one might represent it with inheritance in Python:```pythonfrom abc import ABCclass ABCExpression(ABC):    passclass LiteralExpression(ABCExpression):    def __init__(self, value: float):        passclass UnaryMinusExpression(ABCExpression):    def __init__(self, inner: ABCExpression):        passclass AddExpression(ABCExpression):    def __init__(self, lhs: ABCExpression, rhs: ABCExpression):        passclass MinusExpression(ABCExpression):    def __init__(self, lhs: ABCExpression, rhs: ABCExpression):        passclass MultiplyExpression(ABCExpression):    def __init__(self, lhs: ABCExpression, rhs: ABCExpression):        passclass DivideExpression(ABCExpression):    def __init__(self, lhs: ABCExpression, rhs: ABCExpression):        pass```This is noticeably more verbose, and the code to consume these types gets much more complex as well:```pythone: ABCExpression = UnaryMinusExpression(LiteralExpression(3))  # Example of creating an expressionif isinstance(e, LiteralExpression):    result = ... # do something with e.valueelif isinstance(e, UnaryMinusExpression):    result = ... # do something with e.innerelif isinstance(e, AddExpression):    result = ... # do something with e.lhs and e.rhselif isinstance(e, MinusExpression):    result = ... # do something with e.lhs and e.rhselif isinstance(e, MultiplyExpression):    result = ... # do something with e.lhs and e.rhselif isinstance(e, DivideExpression):    result = ... # do something with e.lhs and e.rhselse:    raise ValueError(f'Unexpected type of expression: {e}')```ADTs offer a simple way to define a type which is _one of a set of possible cases_, and allowing data to be associated with each case and packed/unpacked along with it.## Examples in other programming languagesAlgebraic data types are very common in functional programming languages, like [Haskell](https://www.haskell.org/) or [Scala](https://www.scala-lang.org/), but they're gaining increasing acceptance in &quot;mainstream&quot; programming languages as well.Here are a few examples.### [Rust](https://www.rust-lang.org/)Rust `enum`s are actually full-fledged ADTs. Here's how an `Either` ADT could be defined:```rustenum Either&lt;L, R&gt; {    Left(L),    Right(R),}```### [Swift](https://developer.apple.com/swift/)[Swift enumerations](https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html) are very similar to Rust's, and behave like algebraic data types through their support of &quot;associated values.&quot;```swiftenum Either&lt;L, R&gt; {    case Left(L)    case Right(R)}```### [TypeScript](https://en.wikipedia.org/wiki/Microsoft_TypeScript)[TypeScript](https://en.wikipedia.org/wiki/Microsoft_TypeScript) offers ADTs through a language feature known as [&quot;discriminated unions&quot;](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions).See this example from their documentation:```typescriptinterface Square {    kind: &quot;square&quot;;    size: number;}interface Rectangle {    kind: &quot;rectangle&quot;;    width: number;    height: number;}interface Circle {    kind: &quot;circle&quot;;    radius: number;}type Shape = Square | Rectangle | Circle;```# InstallationTo add `adt` as a library in your Python project, simply run `pip` (or `pip3`, as it may be named on your system):```pip install algebraic-data-types```This will install [the latest version from PyPI](https://pypi.org/project/algebraic-data-types/).## mypy pluginThe library also comes with a plugin for [mypy](http://mypy-lang.org/) that enables typechecking of `@adt` definitions. **If you are already using mypy, the plugin is required to avoid nonsensical type errors.**To enable the `adt` typechecking plugin, add the following to a `mypy.ini` file in your project's working directory:```[mypy]plugins = adt.mypy_plugin```# Defining an ADTTo begin defining your own data type, import the `@adt` decorator and `Case[…]` annotation:[//]: # (README_TEST:AT_TOP)```pythonfrom adt import adt, Case```Then, define a new Python class, upon which you apply the `@adt` decorator:```python@adtclass MyADT1:    pass```For each case (variant) that your ADT will have, declare a field with the `Case` annotation. It's conventional to declare your fields with ALL_UPPERCASE names, but the only true restriction is that they _cannot_ be lowercase.```python@adtclass MyADT2:    FIRST_CASE: Case    SECOND_CASE: Case```If you want to associate some data with a particular case, list the type of that data in brackets after `Case` (similar to the `Generic[…]` and `Tuple[…]` annotations from `typing`). For example, to add a case with an associated string:```python@adtclass MyADT3:    FIRST_CASE: Case    SECOND_CASE: Case    STRING_CASE: Case[str]```You can build cases with arbitrarily many associated pieces of data, as long as all the types are listed:```python@adtclass MyADT4:    FIRST_CASE: Case    SECOND_CASE: Case    STRING_CASE: Case[str]    LOTS_OF_DATA_CASE: Case[int, str, str, Dict[int, int]]```ADTs can also be recursive—i.e., an ADT can itself be stored alongside a specific case—though the class name has to be provided in double quotes (a restriction which also applies to `typing`).A typical example of a recursive ADT is a linked list. Here, the list is also made generic over a type `T`:```pythonT = TypeVar('T')@adtclass LinkedList(Generic[T]):    NIL: Case    CONS: Case[T, &quot;LinkedList[T]&quot;]```See the library's [tests](tests/) for more examples of complete ADT definitions.## Generated functionalityGiven an ADT defined as follows:```python@adtclass MyADT5:    EMPTY: Case    INTEGER: Case[int]    STRING_PAIR: Case[str, str]```The `@adt` decorator will automatically generate accessor methods of the following form:```python    def empty(self) -&gt; None:        return None    def integer(self) -&gt; int:        ... # unpacks int value and returns it    def string_pair(self) -&gt; Tuple[str, str]:        ... # unpacks strings and returns them in a tuple```These accessors can be used to obtain the data associated with the ADT case, but **accessors will throw an exception if the ADT was not constructed with the matching case**. This is a shorthand when you already know the case of an ADT object.`@adt` will also automatically generate a pattern-matching method, which can be used when you _don't_ know which case you have ahead of time:[//]: # (README_TEST:IGNORE)```python    Result = TypeVar('Result')    def match(self,              empty: Callable[[], Result],              integer: Callable[[int], Result],              string_pair: Callable[[str, str], Result]) -&gt; Result:        if ... self was constructed as EMPTY ...:            return empty()        elif ... self was constructed as INTEGER ...:            return integer(self.integer())        elif ... self was constructed as STRING_PAIR ...:            return string_pair(*self.string_pair())        # if pattern match is incomplete, an exception is raised```See the library's [tests](tests/) for examples of using these generated methods.`@adt` will also generate `__repr__`, `__str__`, and `__eq__` methods (only if they are not [defined already](#custom-methods)), to make ADTs convenient to use by default.## Custom methodsArbitrary methods can be defined on ADTs by simply including them in the class definition as normal.For example, to build &quot;safe&quot; versions of the default accessors on `ExampleADT`, which return `None` instead of throwing an exception when the case is incorrect:```python@adtclass ExampleADT:    EMPTY: Case    INTEGER: Case[int]    STRING_PAIR: Case[str, str]    @property    def safe_integer(self) -&gt; Optional[int]:        return self.match(empty=lambda: None,                          integer=lambda n: n,                          string_pair=lambda _a, _b: None)    @property    def safe_string_pair(self) -&gt; Optional[Tuple[str, str]]:        return self.match(empty=lambda: None,                          integer=lambda n: None,                          string_pair=lambda a, b: (a, b))```However, additional fields _must not_ be added to the class, as the decorator will attempt to interpret them as ADT `Case`s (which will fail).</longdescription>
</pkgmetadata>