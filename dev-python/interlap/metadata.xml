<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>InterLap: simple, fast interval overlap testing-----------------------------------------------[![Build Status](https://travis-ci.org/brentp/interlap.svg?branch=master)](https://travis-ci.org/brentp/interlap)InterLap is &gt;20 times faster than doing a naive search (see: https://brentp.github.io/interlap/benchmark.html)with **no memory overhead** because it operates on a sorted list. It is pure python and has nodependencies.It uses binary search and a knowledge of the longest observed interval to quickly query datasetswith 100's of thousands of intervals.See the documentation at [https://brentp.github.io/interlap/](https://brentp.github.io/interlap)Usage-----Interlap takes tuples or lists where the first 2 elements are start, end and the remainingelements can be anything.```Python&gt;&gt;&gt; from interlap import InterLap&gt;&gt;&gt; inter = InterLap()#Here create 10K random intervals:&gt;&gt;&gt; import random&gt;&gt;&gt; random.seed(42)&gt;&gt;&gt; sites = random.sample(range(22, 100000000, 12), 50000)&gt;&gt;&gt; ranges = [(i, i + random.randint(2000, 20000)) for i in sites]&gt;&gt;&gt; inter.update(ranges)&gt;&gt;&gt; inter.add((20, 22, {'info': 'hi'}))&gt;&gt;&gt; [20, 21] in interTrue&gt;&gt;&gt; next(inter.find((21, 21)))(20, 22, {'info': 'hi'})&gt;&gt;&gt; inter.add((2, 3, {'info': 'hello'}))*NOTE*: below shows how edge-cases are handled.&gt;&gt;&gt; list(inter.find((2, 2)))[(2, 3, {'info': 'hello'})]&gt;&gt;&gt; list(inter.find((3, 3)))[(2, 3, {'info': 'hello'})]Test every item in the InterLap. These 50K queries take &lt; 0.5 seconds:&gt;&gt;&gt; for s, e in ranges:...     assert (s, e) in interInterLap objects are iterable:&gt;&gt;&gt; for seo in inter:...     assert (seo[0], seo[1]) in inter```Installation------------```Shellpip install interlap```Example-------In general, we will want one interlap per chromosome for genomic data.The snippet below shows a simple way to do that in the process of creatingand then querying some intervals.```Pythonfrom interlap import InterLapfrom collections import defaultdictimport sys# use defaultdict to key by chromosome.inter = defaultdict(InterLap)for toks in (x.rstrip().split(&quot;\t&quot;) for x in open(sys.argv[1])):    start, end = map(int, toks[1:3])    inter[toks[0]].add((start, end, toks))# now find overlaps in another file:for toks in (x.rstrip().split(&quot;\t&quot;) for x in open(sys.argv[2])):    start, end = map(int, toks[1:3])    print list(inter[toks[0]].find((start, end)))```Why---I am aware of bx-python's interval tree (I wrote the cython version)but for some projects it is nice to have a simple dependency (or nodependency since this can be included as a single file or 30 linesof code) when we just need something a bit better than naive overlaptesting.In my testing, the method implemented here, using a sorted list and keepingtrack of the longest observed interval is the fastest *pure python* method*as long as the longest observed interval is does not cover a substantial fraction of intervals in the set*.IntervalSet Operations----------------------As of version 0.2.0 Interlap also includes an `Interval` class that behaveslike what is normally called an interval set.```python# note how it merges overlapping sub-intervals.&gt;&gt;&gt; Interval([(1, 95), (95, 100)]).add(Interval([(90, 100)]))Interval([(1, 100)])```See the doctests under the Interval class for more details</longdescription>
</pkgmetadata>