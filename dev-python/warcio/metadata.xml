<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>WARCIO: WARC (and ARC) Streaming Library========================================.. image:: https://travis-ci.org/webrecorder/warcio.svg?branch=master      :target: https://travis-ci.org/webrecorder/warcio.. image:: https://codecov.io/gh/webrecorder/warcio/branch/master/graph/badge.svg      :target: https://codecov.io/gh/webrecorder/warcioBackground----------This library provides a fast, standalone way to read and write `WARCFormat &lt;https://en.wikipedia.org/wiki/Web_ARChive&gt;`__ commonly used inweb archives. Supports Python 2.7+ and Python 3.4+ (using`six &lt;https://pythonhosted.org/six/&gt;`__, the only external dependency)warcio supports reading and writing of WARC files compliant with both the `WARC 1.0 &lt;http://bibnum.bnf.fr/WARC/WARC_ISO_28500_version1_latestdraft.pdf&gt;`__and `WARC 1.1 &lt;http://bibnum.bnf.fr/WARC/WARC_ISO_28500_version1-1_latestdraft.pdf&gt;`__ ISO standards.Install with: ``pip install warcio``This library is a spin-off of the WARC reading and writing component ofthe `pywb &lt;https://github.com/webrecorder/pywb&gt;`__ high-fidelity replaylibrary, a key component of`Webrecorder &lt;https://github.com/webrecorder/webrecorder&gt;`__The library is designed for fast, low-level access to web archivalcontent, oriented around a stream of WARC records rather than files.Reading WARC Records--------------------A key feature of the library is to be able to iterate over a stream ofWARC records using the ``ArchiveIterator``.It includes the following features:- Reading a WARC 1.0, WARC 1.1 or ARC stream- On the fly ARC to WARC record conversion- Decompressing and de-chunking HTTP payload content stored in WARC/ARC files.For example, the following prints the the url for each WARC ``response``record:.. code:: python    from warcio.archiveiterator import ArchiveIterator    with open('path/to/file', 'rb') as stream:        for record in ArchiveIterator(stream):            if record.rec_type == 'response':                print(record.rec_headers.get_header('WARC-Target-URI'))The stream object could be a file on disk or a remote network stream.The ``ArchiveIterator`` reads the WARC content in a single pass. The``record`` is represented by an ``ArcWarcRecord`` object which containsthe format (ARC or WARC), record type, the record headers, http headers(if any), and raw stream for reading the payload... code:: python    class ArcWarcRecord(object):        def __init__(self, *args):            (self.format, self.rec_type, self.rec_headers, self.raw_stream,             self.http_headers, self.content_type, self.length) = argsReading WARC Content~~~~~~~~~~~~~~~~~~~~The ``raw_stream`` can be used to read the rest of the payload directly.A special ``ArcWarcRecord.content_stream()`` function provides a stream thatautomatically decompresses and de-chunks the HTTP payload, if it iscompressed and/or transfer-encoding chunked.ARC Files~~~~~~~~~The library provides support for reading (but not writing ARC) files.The ARC format is legacy but is important to support in a consistentmatter. The ``ArchiveIterator`` can equally iterate over ARC and WARCfiles to emit ``ArcWarcRecord`` objects. The special ``arc2warc`` optionconverts ARC records to WARCs on the fly, allowing for them to beaccessed using the same API.(Special ``WARCIterator`` and ``ARCIterator`` subclasses of ``ArchiveIterator``are also available to read only WARC or only ARC files).WARC and ARC Streaming~~~~~~~~~~~~~~~~~~~~~~For example, here is a snippet for reading an ARC and a WARC using thesame API.The example streams a WARC and ARC file over HTTP using`requests &lt;http://docs.python-requests.org/en/master/&gt;`__, printing the``warcinfo`` record (or ARC header) and any response records (or all ARCrecords) that contain HTML:.. code:: python    import requests    from warcio.archiveiterator import ArchiveIterator    def print_records(url):        resp = requests.get(url, stream=True)        for record in ArchiveIterator(resp.raw, arc2warc=True):            if record.rec_type == 'warcinfo':                print(record.raw_stream.read())            elif record.rec_type == 'response':                if record.http_headers.get_header('Content-Type') == 'text/html':                    print(record.rec_headers.get_header('WARC-Target-URI'))                    print(record.content_stream().read())                    print('')    # WARC    print_records('https://archive.org/download/ExampleArcAndWarcFiles/IAH-20080430204825-00000-blackbook.warc.gz')    # ARC with arc2warc    print_records('https://archive.org/download/ExampleArcAndWarcFiles/IAH-20080430204825-00000-blackbook.arc.gz')Writing WARC Records--------------------Starting with 1.6, warcio introduces a way to capture HTTP/S traffic directlyto a WARC file, by monkey-patching Python's ``http.client`` library.This approach works well with the popular ``requests`` library often used to fetchHTTP/S content. Note that ``requests`` must be imported after the ``capture_http`` module.Quick Start to Writing a WARC~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Fetching the url ``https://example.com/`` while capturing the response and requestinto a gzip compressed WARC file named ``example.warc.gz`` can be done with the following four lines:.. code:: python    from warcio.capture_http import capture_http    import requests  # requests must be imported after capture_http    with capture_http('example.warc.gz'):        requests.get('https://example.com/')The WARC ``example.warc.gz`` will contain two records (the response is written first, then the request).To write to a default in-memory buffer (``BufferWARCWriter``), don't specify a filename, using ``with capture_http() as writer:``.Additional requests in the ``capture_http`` context and will be appended to the WARC as expected.The ``WARC-IP-Address`` header will also be added for each record if the IP address is available.The following example (similar to a `unit test from the test suite &lt;test/test_capture_http.py&gt;`__) demonstrates the resulting records created with ``capture_http``:.. code:: python    with capture_http() as writer:        requests.get('http://example.com/')        requests.get('https://google.com/')    expected = [('http://example.com/', 'response', True),                ('http://example.com/', 'request', True),                ('https://google.com/', 'response', True),                ('https://google.com/', 'request', True),                ('https://www.google.com/', 'response', True),                ('https://www.google.com/', 'request', True)               ]     actual = [                (record.rec_headers['WARC-Target-URI'],                 record.rec_type,                 'WARC-IP-Address' in record.rec_headers)                for record in ArchiveIterator(writer.get_stream())              ]     assert actual == expectedCustomizing WARC Writing~~~~~~~~~~~~~~~~~~~~~~~~The library provides a simple and extensible interface for writingstandards-compliant WARC files.The library comes with a basic ``WARCWriter`` class for writing to asingle WARC file and ``BufferWARCWriter`` for writing to an in-memorybuffer. The ``BaseWARCWriter`` can be extended to support more complexoperations.(There is no support for writing legacy ARC files)For more flexibility, such as to use a custom ``WARCWriter`` class,the above example can be written as:.. code:: python    from warcio.capture_http import capture_http    from warcio import WARCWriter    import requests  # requests *must* be imported after capture_http    with open('example.warc.gz', 'wb') as fh:        warc_writer = WARCWriter(fh)        with capture_http(warc_writer):            requests.get('https://example.com/')WARC/1.1 Support~~~~~~~~~~~~~~~~By default, warcio creates WARC 1.0 records for maximum compatibility with existing tools.To create WARC/1.1 records, simply specify the warc version as follows:.. code:: python    with capture_http('example.warc.gz', warc_version='1.1'):        ..... code:: python    WARCWriter(fh, warc_version='1.1)    ...When using WARC 1.1, the main difference is that the ``WARC-Date`` timestamp headerwill be written with microsecond precision, while WARC 1.0 only supports second precision.WARC 1.0:.. code::    WARC/1.0    ...    WARC-Date: 2018-12-26T10:11:12ZWARC 1.1:.. code::    WARC/1.1    ...    WARC-Date: 2018-12-26T10:11:12.456789ZFiltering HTTP Capture~~~~~~~~~~~~~~~~~~~~~~When capturing via HTTP, it is possible to provide a custom filter function, which can be used to determine if a particular request and response recordsshould be written to the WARC file or skipped.The filter function is called with the request and response recordbefore they are written, and can be used to substitute a different record (for example, a revisitinstead of a response), or to skip writing altogether by returning nothing, as shown below:.. code:: python    def filter_records(request, response, request_recorder):        # return None, None to indicate records should be skipped        if response.http_headers.get_statuscode() != '200':            return None, None        # the response record can be replaced with a revisit record        elif check_for_dedup():            response = create_revisit_record(...)        return request, response    with capture_http('example.warc.gz', filter_records):         requests.get('https://example.com/')Please refer to`test/test\_capture_http.py &lt;test/test_capture_http.py&gt;`__ for additional examplesof capturing ``requests`` traffic to WARC.Manual/Advanced WARC Writing~~~~~~~~~~~~~~~~~~~~~~~~~~~~Before 1.6, this was the primary method for fetching a url and thenwriting to a WARC. This process is a bit more verbose,but provides for full control of WARC creation and avoid monkey-patching.The following example loads ``http://example.com/``, creates a WARCresponse record, and writes it, gzip compressed, to ``example.warc.gz``The block and payload digests are computed automatically... code:: python    from warcio.warcwriter import WARCWriter    from warcio.statusandheaders import StatusAndHeaders    import requests    with open('example.warc.gz', 'wb') as output:        writer = WARCWriter(output, gzip=True)        resp = requests.get('http://example.com/',                            headers={'Accept-Encoding': 'identity'},                            stream=True)        # get raw headers from urllib3        headers_list = resp.raw.headers.items()        http_headers = StatusAndHeaders('200 OK', headers_list, protocol='HTTP/1.0')        record = writer.create_warc_record('http://example.com/', 'response',                                            payload=resp.raw,                                            http_headers=http_headers)        writer.write_record(record)The library also includes additional semantics for: - Creating ``warcinfo`` and ``revisit`` records - Writing ``response`` and ``request`` records together - Writing custom WARC records - Reading a full WARC record from a streamPlease refer to `warcwriter.py &lt;warcio/warcwriter.py&gt;`__ and`test/test\_writer.py &lt;test/test_writer.py&gt;`__ for additional examples.WARCIO CLI: Indexing and Recompression--------------------------------------The library currently ships with a few simple command line tools.Index~~~~~The ``warcio index`` cmd will print a simple index of the records in thewarc file as newline delimited JSON lines (NDJSON).WARC header fields to include in the index can be specified via the``-f`` flag, and are included in the JSON block (in order, forconvenience).::    warcio index ./test/data/example-iana.org-chunked.warc -f warc-type,warc-target-uri,content-length    {&quot;warc-type&quot;: &quot;warcinfo&quot;, &quot;content-length&quot;: &quot;137&quot;}    {&quot;warc-type&quot;: &quot;response&quot;, &quot;warc-target-uri&quot;: &quot;http://www.iana.org/&quot;, &quot;content-length&quot;: &quot;7566&quot;}    {&quot;warc-type&quot;: &quot;request&quot;, &quot;warc-target-uri&quot;: &quot;http://www.iana.org/&quot;, &quot;content-length&quot;: &quot;76&quot;}HTTP header fields can be included by prefixing them with the prefix``http:``. The special field ``offset`` refers to the record offset withinthe warc file.::    warcio index ./test/data/example-iana.org-chunked.warc -f offset,content-type,http:content-type,warc-target-uri    {&quot;offset&quot;: &quot;0&quot;, &quot;content-type&quot;: &quot;application/warc-fields&quot;}    {&quot;offset&quot;: &quot;405&quot;, &quot;content-type&quot;: &quot;application/http;msgtype=response&quot;, &quot;http:content-type&quot;: &quot;text/html; charset=UTF-8&quot;, &quot;warc-target-uri&quot;: &quot;http://www.iana.org/&quot;}    {&quot;offset&quot;: &quot;8379&quot;, &quot;content-type&quot;: &quot;application/http;msgtype=request&quot;, &quot;warc-target-uri&quot;: &quot;http://www.iana.org/&quot;}(Note: this library does not produce CDX or CDXJ format indexes oftenassociated with web archives. To create these indexes, please see the`cdxj-indexer &lt;https://github.com/webrecorder/cdxj-indexer&gt;`__ tool which extends warcio indexing to provide this functionality)Check~~~~~The ``warcio check`` command will check the payload and block digestsof WARC records, if possible. An exit value of 1 indicates a failure.``warcio check -v`` will print verbose output for each record in theWARC file.Recompress~~~~~~~~~~The ``recompress`` command allows for re-compressing or normalizing WARC(or ARC) files to a record-compressed, gzipped WARC file.Each WARC record is compressed individually and concatenated. This isthe 'canonical' WARC storage format used by`Webrecorder &lt;https://github.com/webrecorder/webrecorder&gt;`__ and otherweb archiving institutions, and usually stored with a ``.warc.gz``extension.It can be used to: - Compress an uncompressed WARC - Convert any ARCfile to a compressed WARC - Fix an improperly compressed WARC file (eg.a WARC compressed entirely instead of by record)::    warcio recompress ./input.arc.gz ./output.warc.gzExtract~~~~~~~The  ``extract`` command provides a way to extract either the WARC and HTTP headers and/or payload of a WARC recordto stdout. Given a WARC filename and an offset, ``extract`` will print the (decompressed) record at that offsetin the file to stdoutSpecifying --payload or --headers will output only the payload or only the WARC + HTTP headers (if any), respectively.::    warcio extract [--payload | --headers] filename offsetLicense~~~~~~~``warcio`` is licensed under the Apache 2.0 License and is part of theWebrecorder project.See `NOTICE &lt;NOTICE&gt;`__ and `LICENSE &lt;LICENSE&gt;`__ for details.</longdescription>
</pkgmetadata>