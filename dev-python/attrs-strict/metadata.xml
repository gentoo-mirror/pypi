<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![Latest version onPyPi](https://badge.fury.io/py/attrs-strict.svg)](https://badge.fury.io/py/attrs-strict)[![Supported Pythonversions](https://img.shields.io/pypi/pyversions/attrs-strict.svg)](https://pypi.org/project/attrs-strict/)[![PyPI - Implementation](https://img.shields.io/pypi/implementation/attrs-strict?style=flat-square)](https://pypi.org/project/attrs-strict)[![Build Status](https://github.com/bloomberg/attrs-strict/workflows/check/badge.svg)](https://github.com/bloomberg/attrs-strict/actions)[![Code style:black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)# attrs runtime validation`attrs-strict` is a Python package which contains runtime validation for[`attrs`](https://github.com/python-attrs/attrs) data classes based on the types existing in the typing module.## RationaleThe purpose of the library is to provide runtime validation for attributes specified in[`attrs`](https://www.attrs.org/en/stable/) data classes. The types supported are all the builtin types and most of theones defined in the typing library. For Python 2, the typing module is available through the backport found[`here`](https://pypi.org/project/typing/).## Quick StartType enforcement is based on the `type` attribute set on any field specified in an `attrs` dataclass. If the typeargument is not specified, no validation takes place.`pip install attrs-strict````pythonfrom typing import Listimport attrfrom attrs_strict import type_validator@attr.sclass SomeClass(object):    list_of_numbers = attr.ib(validator=type_validator(), type=List[int])sc = SomeClass([1, 2, 3, 4])print(sc)SomeClass(list_of_numbers=[1, 2, 3, 4])try:    SomeClass([1, 2, 3, &quot;four&quot;])except ValueError as exception:    print(repr(exception))``````consoleSomeClass(list_of_numbers=[1, 2, 3, 4])&lt;list_of_numbers must be typing.List[int] (got four that is a &lt;class 'str'&gt;) in [1, 2, 3, 'four']&gt;```Nested type exceptions are validated accordingly, and a backtrace to the initial container is maintained to ease withdebugging. This means that if an exception occurs because a nested element doesn't have the correct type, therepresentation of the exception will contain the path to the specific element that caused the exception.```pythonfrom typing import List, Tupleimport attrfrom attrs_strict import type_validator@attr.sclass SomeClass(object):    names = attr.ib(validator=type_validator(), type=List[Tuple[str, str]])try:    SomeClass(names=[(&quot;Moo&quot;, &quot;Moo&quot;), (&quot;Zoo&quot;, 123)])except ValueError as exception:    print(exception)``````consolenames must be typing.List[typing.Tuple[str, str]] (got 123 that is a &lt;class 'int'&gt;) in ('Zoo', 123) in [('Moo', 'Moo'), ('Zoo', 123)]```### What is currently supported ?Currently, there's support for simple types and types specified in the `typing` module: `List`, `Dict`, `DefaultDict`,`Set`, `Union`, `Tuple`, `NewType` `Callable`, `Literal` and any combination of them. This means that you can specifynested types like `List[List[Dict[int, str]]]` and the validation would check if attribute has the specific type.`Callable` will validate if the callable function's annotation matches the type definition. If type does not specify anyannotations then all callables will pass the validation against it. Support for `Callable` is not available for`python2`.`Literal` only allows using instances of `int`, `str`, `bool`, `Enum` or valid `Literal` types. Type checking `Literal`with any other type as argument raises `attrs_strict._error.UnsupportedLiteralError`.```pythondef fully_annotated_function(self, a: int, b: int) -&gt; str:    ...def un_annonated_function(a, b):    ...@attr.sclass Something(object):    a = attr.ib(        validator=type_validator(), type=typing.Callable    )  # Will work for any callable    b = attr.ib(validator=type_validator(), type=typing.Callable[[int, int], str])Something(a=un_annonated_function, b=fully_annotated_function)````TypeVars` or `Generics` are not supported yet but there are plans to support this in the future.## BuildingFor development, the project uses [`tox`](http://tox.readthedocs.org/) in order to install dependencies, run tests andgenerate documentation. In order to be able to do this, you need tox `pip install tox` and after that invoke `tox` inthe root of the project.## InstallationRun `pip install attrs-strict` to install the latest stable version from [PyPi](https://pypi.org/project/attrs-strict/).Documentation is hosted on [readthedocs](https://attrs-strict.readthedocs.io/en/latest/).For the latest version, on github `pip install git+https://github.com/bloomberg/attrs-strict`.</longdescription>
</pkgmetadata>