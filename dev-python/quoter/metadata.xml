<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>| |travisci| |version| |versions| |impls| |wheel| |coverage|.. |travisci| image:: https://travis-ci.org/jonathaneunice/quoter.svg?branch=master    :alt: Travis CI build status    :target: https://travis-ci.org/jonathaneunice/quoter.. |version| image:: http://img.shields.io/pypi/v/quoter.svg?style=flat    :alt: PyPI Package latest release    :target: https://pypi.python.org/pypi/quoter.. |versions| image:: https://img.shields.io/pypi/pyversions/quoter.svg    :alt: Supported versions    :target: https://pypi.python.org/pypi/quoter.. |impls| image:: https://img.shields.io/pypi/implementation/quoter.svg    :alt: Supported implementations    :target: https://pypi.python.org/pypi/quoter.. |wheel| image:: https://img.shields.io/pypi/wheel/quoter.svg    :alt: Wheel packaging support    :target: https://pypi.python.org/pypi/quoter.. |coverage| image:: https://img.shields.io/badge/test_coverage-100%25-6600CC.svg    :alt: Test line coverage    :target: https://pypi.python.org/pypi/quoterUsage=====::    from quoter import *    print single('this')       # 'this'    print double('that')       # &quot;that&quot;    print backticks('ls -l')   # `ls -l`    print braces('curlycue')   # {curlycue}    print braces('curlysue', padding=1)                               # { curlysue }Cute...but way too simple to be useful, right? Read on!Let's try something more complicated, where the output has to beintelligently based on context. Here's a taste of quoting some HTMLcontent::    print html.p(&quot;A para&quot;, &quot;.focus&quot;)    print html.img('.large', src='file.jpg')    print html.br()    print html.comment(&quot;content ends here&quot;)Yields::    &lt;p class='focus'&gt;A para&lt;/p&gt;    &lt;img class='large' src='file.jpg'&gt;    &lt;br&gt;    &lt;!-- content ends here --&gt;This goes well beyond &quot;simply wrapping some text with other text.&quot; Theoutput format varies widely, correctly interpreting CSS Selector-basedcontrols, using void/self-closing elements where needed, and usingspecialized markup such as the comment format when needed. The HTML quoterand its companion XML quoter are competitive in power and simplicity withbespoke markup-generating packages.(A similar generator for Markdown is also newly included, though it's a the&quot;demonsration&quot; rather than &quot;use in production code&quot; stage.)Finally, ``quoter`` provides a drop-dead simple, highly functional,``join`` function::    mylist = list(&quot;ABCD&quot;)    print join(mylist)    print join(mylist, sep=&quot; | &quot;, endcaps=braces)    print join(mylist, sep=&quot; | &quot;, endcaps=braces.but(padding=1))    print and_join(mylist)    print and_join(mylist[:2])    print and_join(mylist[:3])    print and_join(mylist, quoter=double, lastsep=&quot; and &quot;)Yields::    A, B, C, D    {A | B | C | D}    { A | B | C | D }    A and B    A, B, and C    A, B, C, and D    &quot;A&quot;, &quot;B&quot;, &quot;C&quot; and &quot;D&quot;Which shows a range of separators, separation styles (both Oxford andnon-Oxford commas), endcaps, padding, and individual item quoting. I daresayyou will not find a more flexible or configurable ``join`` function*anywhere* else, in any programming language, at any price.And if you like any particular style of formatting, make it your own::    &gt;&gt;&gt; my_join = join.but(sep=&quot; | &quot;, endcaps=braces.but(padding=1))    &gt;&gt;&gt; print my_join(mylist)    { A | B | C | D }Now you have a convenient specialized formatter to your own specifications.See `the rest of the storyat Read the Docs &lt;http://quoter.readthedocs.org/en/latest/&gt;`_.</longdescription>
</pkgmetadata>