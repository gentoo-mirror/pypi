<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># bagbagAn all in one python library# Install```bashpip3 install bagbag --upgrade```# Docker```bashdocker run --rm --name bagbag -v /path/to/file/run.py:/app/run.py darren2046/bagbag:latestdocker run --rm --name bagbag -v /path/to/file/run.py:/app/run.py darren2046/bagbag-gui:latest # xvfb running so can use gui application such as chromedriver with seleniumdocker run --rm --name bagbag -v /path/to/file/run.py:/app/run.py darren2046/bagbag-gui-debug:latest # HTTP Server serving vnc desktop runing on port 80```# Library* Crypto  * AES(key:str, mode:str=&quot;cfb&quot;)    * Encrypt(raw:str) -&gt; str    * Decrypt(enc:str) -&gt; str* File(path:str)  * Write(data:str)  * Append(data:str)* Lg 日志模块  * Lg.SetLevel(level:日志级别:str)  * Lg.SetFile(path:日志路径:str, size:文件大小，MB:int, during:日志保留时间，天:int, color:是否带ANSI颜色:bool=True, json:是否格式化为json:bool=False)  * Lg.Debug(message:str)  * Lg.Trace(message:str)  * Lg.Info(message:str)  * Lg.Warn(message:str)  * Lg.Error(message:str)* String(string:str) 一些字符串处理函数  * HasChinese() -&gt; bool 是否包含中文  * Language() -&gt; str 语言  * Repr() -&gt; str  * SimplifiedChineseToTraditional() -&gt; str  * TraditionalChineseToSimplified() -&gt; str  * Ommit(length:int) -&gt; str  * Filter(chars:str=&quot;1234567890qwertyuioplkjhgfdsazxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM&quot;) -&gt; str  * Len() -&gt; int  * IsIPAddress() -&gt; bool* Time 时间  * Strftime(timestamp:float|int, format:str=&quot;%Y-%m-%d %H:%M:%S&quot;) -&gt; str  * Strptime(timestring:str, format:str=None) -&gt; int* Base64  * Encode(s:str|bytes) -&gt; str  * Decode(s:str) -&gt; str|bytes* Json  * Dumps(obj, indent=4, ensure_ascii=False) -&gt; str  * Loads(s:str) -&gt; list | dict  * ExtraValueByKey(obj:list|dict, key:str) -&gt; list* Hash  * Md5sum(string:str) -&gt; str  * Md5sumFile(fpath:str, block_size=2**20) -&gt; str  * Sha256sum(data:str|bytes) -&gt; str  * Sha256sumFile(fpath:str, block_size=2**20) -&gt; str* Os  * Exit(num:int=0)  * Mkdir(path:str)  * Getenv(varname:str, defaultValue:str=None) -&gt; str | None  * ListDir(path:str) -&gt; list[str]  * Unlink(path:str)  * Move(src:str, dst:str, force:bool=True)  * Copy(src:str, dst:str, force:bool=True)  * Path    * Basedir(path:str) -&gt; str    * Join(*path) -&gt; str    * Exists(path:str) -&gt; bool    * Uniquify(path:str) -&gt; str    * IsDir(path:str) -&gt; bool    * Basename(path:str) -&gt; str* Http  * Head(url:str, Timeout:str=None, ReadBodySize:int=None, FollowRedirect:bool=True, HttpProxy:str=None, TimeoutRetryTimes:int=0, InsecureSkipVerify:int=False,Debug:bool=False)  * Get(url:str, Timeout:str=None, ReadBodySize:int=None, FollowRedirect:bool=True, HttpProxy:str=None,  TimeoutRetryTimes:int=0, InsecureSkipVerify:int=False,Debug:bool=False)  * PostRaw(url:str, Data:str, Timeout:str=None, ReadBodySize:int=None, FollowRedirect:bool=True, HttpProxy:str=None, TimeoutRetryTimes:int=0, InsecureSkipVerify:int=False,Debug:bool=False)  * PostJson(url:str, Json:dict,Timeout:str=None, ReadBodySize:int=None, FollowRedirect:bool=True, HttpProxy:str=None, TimeoutRetryTimes:int=0, InsecureSkipVerify:int=False,Debug:bool=False)  * PostForm(url:str, Data:dict, Timeout:str=None, ReadBodySize:int=None, FollowRedirect:bool=True, HttpProxy:str=None, TimeoutRetryTimes:int=0, InsecureSkipVerify:int=False,Debug:bool=False)  * Delete(url:str, Timeout:str=None, ReadBodySize:int=None, FollowRedirect:bool=True, HttpProxy:str=None, TimeoutRetryTimes:int=0, InsecureSkipVerify:int=False,Debug:bool=False)  * PutForm(url:str, Data:dict,Timeout:str=None, ReadBodySize:int=None, FollowRedirect:bool=True, HttpProxy:str=None, TimeoutRetryTimes:int=0, InsecureSkipVerify:int=False,Debug:bool=False)  * PutRaw(url:str, Data:str, Timeout:str=None, ReadBodySize:int=None, FollowRedirect:bool=True, HttpProxy:str=None, TimeoutRetryTimes:int=0, InsecureSkipVerify:int=False, Debug:bool=False)  * PutJson(url:str, Json:dict, Timeout:str=None, ReadBodySize:int=None, FollowRedirect:bool=True, HttpProxy:str=None, TimeoutRetryTimes:int=0, InsecureSkipVerify:int=False,Debug:bool=False)* Socket  * TCP    * Listen(host:str, port:int, waitQueue:int=5)      * Accept() -&gt; Chan[StreamConnection]      * AcceptOne() -&gt; StreamConnection    * Connect(host:str, port:int) -&gt; StreamConnection      * PeerAddress() -&gt; TCPPeerAddress      * Send(data:str)      * SendBytes(data:bytes)      * Recv(length:int) -&gt; str      * RecvBytes(length:int) -&gt; bytes      * Close()* Random  * Int(min:int, max:int) -&gt; int  * Choice(obj:list|str) -&gt; Any  * String(length:int, charset:str=&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;) -&gt; str  * Shuffle(li:list) -&gt; list* Funcs  * Markdown2Html(text:str) -&gt; str  * Wget(url:str, dest:str=None, override=True)  * IP2Int(ip:str) -&gt; int  * Int2IP(intip:int) -&gt; str  * ResizeImage(src:str, dst:str, width:int, quality:int=95)  * UUID() -&gt; str  * CutSentence(sentence:str, filter:bool=True) -&gt; list[str]* Tools 一些工具  * OCR(server:str)    * Recognition(fpath:str, lang:str=&quot;ch&quot;) -&gt; ocrResult      * SaveImage(fpath:str)  * WebCrawler()    * Run(self, url:str) -&gt; typing.Iterable[WebCrawlerResult]  * JavaScript    * Eval(code:str)  * BlockChain    * Tron      * TronClient(fullNodeServer:str)        * Block(blockNumber:int) -&gt; tronBlock          * Transcations() -&gt; list[tronTranscation]      * TronContract(address:str)        * Info()        * Address()      * TronAsset(name:str)        * Info()        * Name()    * Binance      * OfficalAccountVertify        * Twitter(account:str, waiteOnRateLimit:bool=True) -&gt; bool      * GetPrice(pair:str|list=None) -&gt; CoinsPairPrice | list[CoinsPairPrice]  * Twitter    * Essential(bearerToken:str)      * Search(keyword:str, sinceID:int=None, tweetPerRequest:int=10) -&gt; typing.Iterable[twitterTweet]      * Timeline(screename:str, sinceID:int=None, tweetPerRequest:int=10) -&gt; typing.Iterable[twitterTweet]    * Elevated(consumer_key:str, consumer_secret:str)      * Search(keyword:str, days:int=7) -&gt; typing.Iterable[twitterTweet]      * Timeline(screename:str) -&gt; typing.Iterable[twitterTweet]      * Followers(screename:str) -&gt; typing.Iterable[twitterUser]  * Nslookup(server:list[str]=[&quot;8.8.8.8&quot;, &quot;1.1.1.1&quot;, &quot;8.8.4.4&quot;], tcp:bool=False)    * A(domain:str) -&gt; list[str]    * AAAA(domain:str) -&gt; list[str]  * MatrixBot(apiserver:str, password:str=&quot;&quot;)    * SetRoom(room:str) -&gt; MatrixBot    * Send(message:str)    * SendImage(path:str)    * GetMessage(num:int=10) -&gt; list[MatrixBotMessage]      * Reply(message:str)      * ReplyImage(path:str)  * RSS    * Opml(opmlurl:str) -&gt; list[RSSFeed]    * Feed(feedurl:str) -&gt; list[RSSPage]  * Queue(server:str, name:str, length:int=0, timeout:int=300)    * QueueConfirm(name:str, length:int=0, timeout:int=300) -&gt; queueQueueConfirm      * Put(item:typing.Any, force:bool=False)      * Get(self) -&gt; typing.Tuple[str, typing.Any]      * Done(tid:str)      * Size(self) -&gt; int  * Kafka(topic:str, servers:str|list)    * Producer(value_serializer=lambda m: json.dumps(m).encode()) -&gt; KafkaProducer      * Send(data:dict)    * Consumer(group_id:str=None, auto_offset_reset:str='earliest') -&gt; KafkaConsumer      * Get() -&gt; dict  * Github(token:str, ratelimit:str=&quot;30/m&quot;)    * Search(pattern:str) -&gt; GithubSearchResults      * Get() -&gt; GithubSearchResult | None  * SSH(host:str, port:int=None, user:str=None, password:str=None, pkey:str=None)    * GetOutput(command:str) -&gt; str    * Close()    * Upload(localpath:str, remotepath:str=None)    * Download(remotepath:str, localpath:str=None)    * FileInfo(filepath:str)    * ListDir(dirpath:str=&quot;.&quot;) -&gt; dict  * Translater    * Baidu(appid:str, secretkey:str)      * SetLang(To:str=&quot;zh&quot;, From:str=&quot;auto&quot;) -&gt; Baidu      * Translate(text:str) -&gt; dict    * Google(httpProxy:str=None)      * SetLang(To:str=&quot;zh-CN&quot;, From:str=&quot;auto&quot;) -&gt; Google      * Translate(text:str, format:str=&quot;html&quot;) -&gt; str  * XPath(html:str)    * Find(xpath:str) -&gt; XPath | None    * Attribute(name:str) -&gt; str | None    * Text() -&gt; str    * Html() -&gt; str  * WaitGroup()    * Add()    * Done()    * Wait()  * Crontab()    * Every(interval: int = 1) -&gt; Crontab    * Second() -&gt; Crontab    * Minute() -&gt; Crontab    * Hour() -&gt; Crontab    * Day() -&gt; Crontab    * Week() -&gt; Crontab    * At(time: str) -&gt; Crontab    * Do(job_func, *args, **kwargs)    * Monday()    * Tuesday()    * Wednesday()    * Thursday()    * Friday()    * Saturday()    * Sunday()  * Elasticsearch(url:str)    * Delete(IndexName:str)    * Collection(IndexName:str)      * Index(id:int, data:dict, refresh:bool=False, Timeout:int=15)      * Refresh(Timeout:int=15)      * Delete(id:int)      * Search(key:str, value:str, page:int=1, pagesize:int=50, OrderByKey:str=None, OrderByOrder:str=&quot;ase&quot;, Highlight:str=None, mustIncludeAllWords:bool=True)  * CSV    * Reader(fpath:str)      * Read() -&gt; dict      * Close()    * Writer(fpath:str, mode:str=&quot;w&quot;)      * SetHeaders(*headers)      * Write(row:dict[str])      * Close()      * Flush()  * Xlsx    * Reader(fpath:str)      * Read() -&gt; dict      * Close()    * Writer(fpath:str, mode:str=&quot;w&quot;)      * SetHeaders(*headers)      * Write(row:dict[str])      * Close()      * Flush()  * WebServer(name:str=None) # 例子见源码文件Web.py的后半部分    * Run(host:str, port:int, block:bool=True) # 监听HTTP服务    * Route: (path:str, methods:list=[&quot;GET&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;]) # 例子见Web.py文件, 是一个装饰器    * Request()      * Method() -&gt; str # 请求的HTTP方法      * Json() -&gt; dict | list # 格式化请求的post内容为json      * Data() -&gt; str # post的http的body      * Form()        * Get(name:str, default:str=&quot;&quot;) -&gt; str | None # 获取表单的数据      * Args()        * Get(name:str, default:str=&quot;&quot;) -&gt; str | None # 获取URL的参数  * Chan() 内存队列, 跟go的chan一样  * RateLimit(rate:str, sleep:bool=True) rate可以是 次数/时间区间, 时间可以是s, m, h, d, 即秒,分,时,天. 例如一分钟限制五次: 5/m. 在低速率的时候能限制准确, 例如低于1秒10次. 高速率例如每秒50次以上, 实际速率会降低, 速率越高降低越多.    * Take() sleep=True的时候会添加一个sleep, 可以把请求平均在时间段内. 在低速率的时候能限制准确. 高速率例如每秒50次以上, 实际速率会降低, 速率越高降低越多. sleep=False的时候没有sleep, 会全在一开始扔出去, 然后block住, 等下一个周期, 在需要速率很高的时候可以这样, 例如发包的时候, 一秒限制2000个包这样.  * URL(url:str)    * Parse() -&gt; URLParseResult    * Encode() -&gt; str    * Decode() -&gt; str  * Prometheus    * MetricServer(listen:str=&quot;0.0.0.0&quot;, port:int=9105)    * PushGateway(address:str, job:str, pushinterval:int=15, instance:str=None)      * NewCounter(name:str, help:str) -&gt; prometheusCounter        * Add(num:int|float=1)      * NewCounterWithLabel(name:str, labels:list[str], help:str) -&gt; prometheusCounterVec        * Add(labels:dict|list, num:int|float=1)      * NewGauge(name:str, help:str) -&gt; prometheusGauge        * Set(num:int|float)      * NewGaugeWithLabel(name:str, labels:list[str], help:str) -&gt; prometheusGaugeVec        * Set(labels:dict|list, num:int|float=1)  * Selenium    * Firefox(seleniumServer:str=None, PACFileURL:str=None, sessionID:str=None)    * Chrome(seleniumServer:str=None, httpProxy:str=None, sessionID=None)      * Except(*xpath:str, timeout:int=30) -&gt; int | None      * ResizeWindow(width:int, height:int)      * ScrollRight(pixel:int)      * ScrollLeft(pixel:int)      * ScrollUp(pixel:int)      * ScrollDown(pixel:int)      * Url() -&gt; str      * Cookie() -&gt; list[dict]      * SetCookie(cookie_dict:dict)      * Refresh()      * GetSession() -&gt; str      * Get(url:str)      * PageSource() -&gt; str      * Title() -&gt; str      * Close()      * SwitchTabByID(number:int)      * SwitchTabByIdent(ident:str)      * Tabs() -&gt; list[str]      * NewTab() -&gt; str      * Find(xpath:str, timeout:int=60, scrollIntoElement:bool=True) -&gt; SeleniumElement        * Clear() -&gt; SeleniumElement        * Click() -&gt; SeleniumElement        * Text() -&gt; str        * Attribute(name:str) -&gt; str        * Input(string:str) -&gt; SeleniumElement        * Submit() -&gt; SeleniumElement        * PressEnter() -&gt; SeleniumElement        * ScrollIntoElement() -&gt; SeleniumElement  * Telegram(appid:str, apphash:str, sessionString:str=None)    * SessionString() -&gt; str    * ResolvePeerByUsername(username:str) -&gt; TelegramPeer | None    * PeerByIDAndHash(ID:int, Hash:int, Type:str=&quot;channel&quot;) -&gt; TelegramPeer | None      * Resolve() # 如果手动根据ID初始化一个TelegramPeer实例, 调用这个函数可以补全这个ID对应的Peer的信息      * SendMessage(message:str)      * Messages(limit:int=100, offset:int=0) -&gt; list[TelegramMessage]      * Message(id:str) -&gt; TelegramMessage        * Refresh() -&gt; TelegramMessage # 有时候同一个id, 被编辑了, 刷新一下返回最新的消息        * ClickButton(buttonText:str) -&gt; bool        * Delete()  * TelegramBotOfficial(token:str)    * GetMe() -&gt; telebot.types.User    * SetChatID(chatid:int) -&gt; TelegramBot    * SetTags(*tags:str) -&gt; TelegramBot    * SendFile(path:str)    * SendImage(path:str)    * SendVideo(path:str)    * SendAudio(path:str)    * SendLocation(latitude:float, longitude:float)    * SendMsg(msg:str, *tags:str)  * ProgressBar(iterable_obj, total=None, title=None, leave=False)  * Redis(host: str, port: int = 6379, database: int = 0, password: str = &quot;&quot;)    * Set(key:str, value:str, ttl:int=None) -&gt; (bool | None)    * Get(key:str) -&gt; (str | None)    * Del(key:str) -&gt; int    * Lock(key:str) -&gt; RedisLock      * Acquire()      * Release()    * Queue(key:str) -&gt; RedisQueue      * Size() -&gt; int      * Put(item:str)      * Get(block=True, timeout=None) -&gt; str  * MySQL(host: str, port: int, user: str, password: str, database: str, prefix:str = &quot;&quot;) # 跟5.7兼容. 因为orator跟5.7兼容, 跟8.0会有小问题, 作者很久不更新, 有空换掉这个orm. **注意, Python的MySQL操作不支持多线程, 需要每个线程连接一次MySQL, 不过这个是自动的, 在Get, Update等操作的时候如果链接异常就重连**  * SQLite(path: str, prefix:str = &quot;&quot;) **由于SQLite每次只能一个线程进行操作, 所以这里默认会有一个锁, 线程安全**    * Queue(tbname:str, size:int=None) -&gt; NamedQueue      * Size() -&gt; int      * Get(wait=True) -&gt; Any      * Put(string:Any)    * QueueConfirm(tbname:str, size:int=None, timeout:int=900) -&gt; NamedConfirmQueue      * Size() -&gt; int      * SizeStarted() -&gt; int      * SizeTotal() -&gt; int      * Get(wait=True) -&gt; typing.Tuple[int, typing.Any]      * Put(item:typing.Any)      * Done(id:int)    * Execute(sql: str) -&gt; (bool | int | list)    * Tables() -&gt; list    * Table(tbname: str) -&gt; MySQLSQLiteTable      * AddColumn(colname: str, coltype: str, default=None, nullable:bool = True) -&gt; MySQLSQLiteTable      * AddIndex(*cols: str) -&gt; MySQLSQLiteTable      * Fields(*cols: str) -&gt; MySQLSQLiteTable      * Where(key:str, opera:str, value:str) -&gt; MySQLSQLiteTable      * WhereIn(key:str, value: list) -&gt; MySQLSQLiteTable      * WhereNotIn(key:str, value: list) -&gt; MySQLSQLiteTable      * WhereNull(key:str) -&gt; MySQLSQLiteTable      * WhereNotNull(key:str) -&gt; MySQLSQLiteTable      * WhereBetween(key:str, start:int|float|str, end:int|float|str) -&gt; MySQLSQLiteTable      * WhereNotBetween(key:str, start:int|float|str, end:int|float|str) -&gt; MySQLSQLiteTable      * OrWhere(key:str, opera:str, value:str) -&gt; MySQLSQLiteTable      * OrWhereIn(key:str, value: list) -&gt; MySQLSQLiteTable      * OrderBy(*key:str) -&gt; MySQLSQLiteTable      * Limit(num:int) -&gt; MySQLSQLiteTable      * Paginate(size:int, page:int) -&gt; MySQLSQLiteTable      * Data(value:map) -&gt; MySQLSQLiteTable      * Offset(num:int) -&gt; MySQLSQLiteTable      * Insert()      * Update()      * Delete()      * InsertGetID() -&gt; int      * Exists() -&gt; bool      * Count() -&gt; int      * Find(id:int) -&gt; map      * First() -&gt; map      * Get() -&gt; list      * Columns() -&gt; list[map]    * KeyValue(tbname:str)      * Get(key:str) -&gt; Any      * Set(key:str, value:Any)      * Del(key:str)      * Keys() -&gt; list[str]其它的* Thread(func, *args:Any, daemon:bool=True) -&gt; threading.Thread # 启动线程, daemon=True* Process(func, *args:Any, daemon:bool=True) -&gt; multiprocessing.Process # 启动进程, daemon=True</longdescription>
</pkgmetadata>