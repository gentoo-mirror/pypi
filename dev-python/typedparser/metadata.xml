<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># typedparser&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/gingsi/typedparser/actions/workflows/build_py37.yml&quot;&gt;  &lt;img alt=&quot;build 3.7 status&quot; title=&quot;build 3.7 status&quot; src=&quot;https://img.shields.io/github/actions/workflow/status/gingsi/typedparser/build_py37.yml?branch=main&amp;label=build%203.7&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/gingsi/typedparser/actions/workflows/build_py39.yml&quot;&gt;  &lt;img alt=&quot;build 3.9 status&quot; title=&quot;build 3.9 status&quot; src=&quot;https://img.shields.io/github/actions/workflow/status/gingsi/typedparser/build_py39.yml?branch=main&amp;label=build%203.9&quot; /&gt;&lt;/a&gt;&lt;img alt=&quot;coverage&quot; title=&quot;coverage&quot; src=&quot;https://raw.githubusercontent.com/gingsi/typedparser/main/docs/coverage.svg&quot; /&gt;&lt;a href=&quot;https://pypi.org/project/typedparser/&quot;&gt;  &lt;img alt=&quot;version&quot; title=&quot;version&quot; src=&quot;https://img.shields.io/pypi/v/typedparser?color=success&quot; /&gt;&lt;/a&gt;&lt;/p&gt;Typing extension for python argparse using [attrs](https://www.attrs.org/en/stable/).Includes typechecking and conversion utilities to parse a dictionary into an attrs instance. ## Features* Create commandline arguments with type hints and checks whilestaying very close to the syntax of the standard library's argparse.* Utilities for typechecking and converting nested objects:  * Nested checking and conversion of python standard types  * Supports old and new style typing (e.g. `typing.List` and `list`)  * Supports positional and keyword arguments in classes  * Can also typecheck existing attrs instances  * Allows custom conversions, by default converts source type `str` to target type `Path` and    `int` to `float`  * Allows to redefine which objects will be recursed into, by default recurses into standard    containers (list, dict, etc.)  * `@definenumpy` decorator for equality check if the instances contains numpy arrays* Some object utilities in `typedparser.objects` required for everything else## InstallRequires `python&gt;=3.7````bashpip install typedparser```## Usage of the parser1. Create an attrs class (decorate with `@attr.define`)2. Define the fields with `typedparser.add_argument` - the syntax extends [add_argument from argparse](https://docs.python.org/3/library/argparse.html#the-add-argument-method).3. Parse the args with `TypedParser`, now the args are typechecked and there are typehints available.  ~~~pythonfrom typing import Optionalfrom attrs import definefrom typedparser import add_argument, TypedParser@defineclass Args:    foo: int = add_argument(&quot;foo&quot;, type=int)    bar: int = add_argument(&quot;-b&quot;, &quot;--bar&quot;, type=int, default=0)        # Syntax extensions:        # Omit argument name to create an optional argument --opt    opt: Optional[int] = add_argument(type=int)        # Use shortcut to create an optional argument -s / --short     short: Optional[int] = add_argument(shortcut=&quot;-s&quot;, type=int)def main():    parser = TypedParser.create_parser(Args)    args: Args = parser.parse_args()    print(args)if __name__ == &quot;__main__&quot;:    main()~~~### Advanced usage* Use `TypedParser.from_parser(parser, Args)` to add typing to an existing parser. This is usefulto cover usecases like subparsers or argument groups.## Usage of attr utilitiesDefine the class hierarchy and parse the input using `attrs_from_dict`:~~~pythonfrom attrs import definefrom typing import Optionalfrom typedparser import attrs_from_dict@defineclass Cfg:    foo: int = 12    bar: Optional[int] = Noneprint(attrs_from_dict(Cfg, {&quot;foo&quot;: 1, &quot;bar&quot;: 2}))# Cfg(foo=1, bar=2)@defineclass CfgNested:    sub_cfg: Cfg = Noneprint(attrs_from_dict(CfgNested, {&quot;sub_cfg&quot;: {&quot;foo&quot;: 1, &quot;bar&quot;: 2}}))# CfgNested(sub_cfg=Cfg(foo=1, bar=2))~~~### Strict mode (default)* Convert everything to the target type, e.g. if the input is a list and the annotation is a tuple,  the output will be a tuple* Raise errors if types cannot be matched, there are unknown fields in the input or  abstract annotation types are used (e.g. Sequence)### Non-strict modeEnabled by calling `attrs_from_dict` with `strict=False`* No conversion except for creating the attrs instance from the dict* Ignore silently if types cannot be matched or abstract annotation types are used* Unknown fields in the input will be added to the attrs instance if possible  (see the hint below about slots)### Skip unknownsSet `skip_unknowns=True` to ignore all unknown input fields.### HintsThe following behaviour stems from the `attrs` package:* New attributes cannot to be added after class definition to an attrs instance,  unless it is created with `@define(slots=False)`  [Explanation](https://www.attrs.org/en/21.2.0/glossary.html#term-slotted-classes)* Untyped fields or &quot;ClassVar&quot; typed fields will be ignored by @attrs.define  and therefore also by this library.## Install locally and run testsClone repository and cd into, then:~~~bashpip install -e .pip install pytest pytest-cov pylint pytest-lazy-fixturepylint typedparser# run tests for python&gt;=3.7python -m pytest --covpylint tests# run tests for python&gt;=3.9python -m pytest tests tests_py39 --covpylint tests pylint tests_py39~~~</longdescription>
</pkgmetadata>