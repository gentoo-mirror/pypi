<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. image:: https://img.shields.io/pypi/v/dwave-samplers.svg    :target: https://pypi.python.org/pypi/dwave-samplers.. image:: https://img.shields.io/pypi/pyversions/dwave-samplers.svg    :target: https://pypi.python.org/pypi/dwave-samplers.. image:: https://codecov.io/gh/dwavesystems/dwave-samplers/branch/main/graph/badge.svg    :target: https://codecov.io/gh/dwavesystems/dwave-samplers.. image:: https://circleci.com/gh/dwavesystems/dwave-samplers.svg?style=svg    :target: https://circleci.com/gh/dwavesystems/dwave-samplers.. index-start-marker==============dwave-samplers==============Ocean software provides a variety of quantum, classical, and quantum-classical`dimod &lt;https://docs.ocean.dwavesys.com/en/stable/docs_dimod/sdk_index.html&gt;`_`samplers &lt;https://docs.ocean.dwavesys.com/en/stable/concepts/samplers.html&gt;`_that run either remotely (for example, in D-Wave's`Leap &lt;https://cloud.dwavesys.com/leap/&gt;`_ environment) or locally on your CPU.*dwave-samplers* implements the following classical algorithms for solving`binary quadratic models &lt;https://docs.ocean.dwavesys.com/en/stable/concepts/bqm.html&gt;`_(BQM):* `Planar`_: an exact solver for planar Ising problems with no linear biases.* `Random`_: a sampler that draws uniform random samples.* `Simulated Annealing`_: a probabilistic heuristic for optimization and approximate  Boltzmann sampling well suited to finding good solutions of large problems.* `Steepest Descent`_: a discrete analogue of gradient descent, often used in  machine learning, that quickly finds a local minimum.* `Tabu`_: a heuristic that employs local search with methods to escape local minima.* `Tree Decomposition`_: an exact solver for problems with low treewidth.Planar======There are polynomial-time algorithms for finding the ground state of a planarIsing model [#]_... [#] Nicol Schraudolph, Dmitry Kamenetsky. *Efficient Exact Inference in Planar Ising Models*.   Advances in Neural Information Processing Systems 21 (NIPS 2008).&gt;&gt;&gt; from dwave.samplers import PlanarGraphSolver&gt;&gt;&gt; solver = PlanarGraphSolver()Get the ground state of a planar Ising model&gt;&gt;&gt; h = {}&gt;&gt;&gt; J = {(0, 1): -1, (1, 2): -1, (0, 2): 1}&gt;&gt;&gt; sampleset = solver.sample_ising(h, J)Random======Random samplers provide a useful baseline performance comparison. The variableassignments in each sample are chosen by a coin flip.&gt;&gt;&gt; from dwave.samplers import RandomSampler&gt;&gt;&gt; sampler = RandomSampler()Create a random binary quadratic model.&gt;&gt;&gt; import dimod&gt;&gt;&gt; bqm = dimod.generators.gnp_random_bqm(100, .5, 'BINARY')Get the best 5 sample found in .1 seconds.&gt;&gt;&gt; sampleset = sampler.sample(bqm, time_limit=.1, max_num_samples=5)&gt;&gt;&gt; num_reads = sampleset.info['num_reads']  # the total number of samples generatedSimulated Annealing===================`Simulated annealing &lt;https://en.wikipedia.org/wiki/Simulated_annealing&gt;`__ can beused for heuristic optimization or approximate Boltzmann sampling. The*dwave-samplers* implementation approaches the equilibrium distribution byperforming updates at a sequence of decreasing temperatures, terminating at thetarget `β`.\ [#]_ Each spin is updated once in a fixed order per pointper temperature according to a Metropolis-Hastings update. When the temperatureis low the target distribution concentrates, at equilibrium, over ground statesof the model. Samples are guaranteed to match the equilibrium for long, smoothtemperature schedules... [#] `β` represents the inverse temperature, `1/(k T)`, of a   `Boltzmann distribution &lt;https://en.wikipedia.org/wiki/Boltzmann_distribution&gt;`_   where `T` is the thermodynamic temperature in kelvin and `k` is   Boltzmann's constant.&gt;&gt;&gt; from dwave.samplers import SimulatedAnnealingSampler&gt;&gt;&gt; sampler = SimulatedAnnealingSampler()Create a random binary quadratic model.&gt;&gt;&gt; import dimod&gt;&gt;&gt; bqm = dimod.generators.gnp_random_bqm(100, .5, 'BINARY')Sample using simulated annealing with both the default temperature scheduleand a custom one.&gt;&gt;&gt; sampleset = sampler.sample(bqm)&gt;&gt;&gt; sampleset = sampler.sample(bqm, beta_range=[.1, 4.2], beta_schedule_type='linear')Steepest Descent================`Steepest descent &lt;https://en.wikipedia.org/wiki/Gradient_descent&gt;`__ is thediscrete analogue of gradient descent, but the best move is computed using a localminimization rather rather than computing a gradient. The dimension along whichto descend is determined, at each step, by the variable flip that causes thegreatest reduction in energy.Steepest descent is fast and effective for unfrustrated problems, but it can getstuck in local minima.The quadratic unconstrained binary optimization (QUBO)`E(x, y) = x + y - 2.5 * x * y`, for example, has two local minima:`(0, 0)` with an energy of `0` and `(1, 1)` with an energy of `-0.5`.&gt;&gt;&gt; from dwave.samplers import SteepestDescentSolver&gt;&gt;&gt; solver = SteepestDescentSolver()Construct the QUBO:&gt;&gt;&gt; from dimod import Binaries&gt;&gt;&gt; x, y = Binaries(['x', 'y'])&gt;&gt;&gt; qubo = x + y - 2.5 * x * yIf the solver starts uphill from the global minimum, it takes the steepest pathand finds the optimal solution.&gt;&gt;&gt; sampleset = solver.sample(qubo, initial_states={'x': 0, 'y': 1})&gt;&gt;&gt; print(sampleset)   x  y energy num_oc. num_st.0  1  1   -0.5       1       1['BINARY', 1 rows, 1 samples, 2 variables]If the solver starts in a local minimum, it gets stuck.&gt;&gt;&gt; sampleset = solver.sample(qubo, initial_states={'x': 0, 'y': 0})&gt;&gt;&gt; print(sampleset)   x  y energy num_oc. num_st.0  0  0    0.0       1       0['BINARY', 1 rows, 1 samples, 2 variables]Tabu====`Tabu search &lt;https://en.wikipedia.org/wiki/Tabu_search&gt;`__ is a heuristic thatemploys local search and can escape local minima by maintaining a &quot;tabu list&quot; ofrecently explored states that it does not revisit. The length of this tabu listis called the &quot;tenure&quot;. *dwave-samplers* implementats the`MST2 multistart tabu search algorithm &lt;https://link.springer.com/article/10.1023/B:ANOR.0000039522.58036.68&gt;`_for quadratic unconstrained binary optimization (QUBO) problems.Each read of the tabu algorithm consists of many starts. The solver takes the bestnon-tabu step repeatedly until it does not improve its energy any more.&gt;&gt;&gt; from dwave.samplers import TabuSampler&gt;&gt;&gt; sampler = TabuSampler()Construct a simple problem.&gt;&gt;&gt; from dimod import Binaries&gt;&gt;&gt; a, b = Binaries(['a', 'b'])&gt;&gt;&gt; qubo = -.5 * a + b - a * bSample using both default and custom values of tenure and number of restarts.&gt;&gt;&gt; sampleset0 = sampler.sample(qubo)&gt;&gt;&gt; sampleset1 = sampler.sample(qubo, tenure=1, num_restarts=1)Tree Decomposition==================`Tree decomposition &lt;https://en.wikipedia.org/wiki/Tree_decomposition&gt;`__-basedsolvers have a runtime that is exponential in the`treewidth &lt;https://en.wikipedia.org/wiki/Treewidth&gt;`_ of the problem graph. Forproblems with low treewidth, the solver can find ground states very quickly.However, for even moderately dense problems, performance is very poor.&gt;&gt;&gt; from dwave.samplers import TreeDecompositionSolver&gt;&gt;&gt; solver = TreeDecompositionSolver()Construct a large, tree-shaped problem.&gt;&gt;&gt; import dimod&gt;&gt;&gt; import networkx as nx&gt;&gt;&gt; tree = nx.balanced_tree(2, 5)  # binary tree with a height of five&gt;&gt;&gt; bqm = dimod.BinaryQuadraticModel('SPIN')&gt;&gt;&gt; bqm.set_linear(0, .5)&gt;&gt;&gt; for u, v in tree.edges:...     bqm.set_quadratic(u, v, 1)Because the BQM is a binary tree, it has a treewidth of 1 and can be solved exactly.&gt;&gt;&gt; sampleset = solver.sample(bqm)&gt;&gt;&gt; print(sampleset)   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 ... 62 energy num_oc.0 -1 +1 +1 -1 -1 -1 -1 +1 +1 +1 +1 +1 +1 +1 +1 -1 -1 -1 ... +1  -62.5       1['SPIN', 1 rows, 1 samples, 63 variables].. index-end-markerInstallation============To install the core package:.. code-block:: bash    pip install dwave-samplersLicense=======Released under the Apache License 2.0Contributing============Ocean's `contributing guide &lt;https://docs.ocean.dwavesys.com/en/stable/contributing.html&gt;`_has guidelines for contributing to Ocean packages.Release Notes-------------**dwave-samplers** makes use of `reno &lt;https://docs.openstack.org/reno/&gt;`_ to manage itsrelease notes.When making a contribution to **dwave-samplers** that will affect users, create a newrelease note file by running.. code-block:: bash    reno new your-short-descriptor-hereYou can then edit the file created under ``releasenotes/notes/``.Remove any sections not relevant to your changes.Commit the file along with your changes.</longdescription>
</pkgmetadata>