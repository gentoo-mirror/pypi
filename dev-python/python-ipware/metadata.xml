<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Python IPware (A Python Package)**A python package for server applications to retrieve client's IP address**[![status-image]][status-link][![version-image]][version-link][![coverage-image]][coverage-link]# Overview**Best attempt** to get client's IP address while keeping it **DRY**.# NoticeThere is no perfect `out-of-the-box` solution against fake IP addresses, aka `IP Address Spoofing`.You are encouraged to read the ([Advanced users](README.md#advanced-users)) section of this page anduse `proxy_trusted_list` and/or `proxy_count` features to match your needs, especially `if` you areplanning to include `ipware` in any authentication, security or `anti-fraud` related architecture.This is an open source project, with the source code visible to all. Therefore, it may be exploited through unimplemented, or improperly implemented features.Please use ipware `ONLY` as a complement to your `firewall` security measures!# How to install    1. easy_install python-ipware    2. pip install python-ipware    3. git clone http:#github.com/un33k/python-ipware        a. cd python-ipware        b. run python setup.py install    4. wget https:#github.com/un33k/python-ipware/zipball/master        a. unzip the downloaded file        b. cd into python-ipware-* directory        c. run python setup.py install# How to use```python# In a view or a middleware where the `request` object is availableimport ipwareipware = Ipware() # default valuesip, proxy_verified = ipware.get_client_ip(meta)if ip: # IPv4Address() or IPv6Address() object    # ip object has the following properties    # ip.is_global (is globally routable)    # ip.is_private (is private ip address)    # is_loopback (is loopback address)# proxy_verified tells if request came through proxies (count / trusted)# do something with the ip address (e.g. pass it down through the request)# note: ip address doesn't change often, so better cache it for performance,# try to have distinct session ID for public and anonymous users to cache the ip address```# Advanced users:|        Flags ⇩ | ⇩ Description                                                                                                                                                                                                                                                                                                                                                     || -------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ||      `count` ⇨ | : Total number of expected proxies (pattern: `client, proxy1, ..., proxy2`)&lt;br&gt;: if `count = 0` then `client`&lt;br&gt;: if `count = 1` then `client, proxy1`&lt;br&gt;: if `count = 2` then `client, proxy1, proxy2` &lt;br&gt;: if `count = 3` then `client, proxy1, proxy2 proxy3`                                                                                               || `proxy_list` ⇨ | : List of trusted proxies (pattern: `client, proxy1, ..., proxy2`)&lt;br&gt;: if `proxy_list = ['10.1.']` then `client, 10.1.1.1` OR `client, proxy1, 10.1.1.1`&lt;br&gt;: if `proxy_list = ['10.1', '10.2.']` then `client, 10.1.1.1` OR `client, proxy1, 10.2.2.2`&lt;br&gt;: if `proxy_list = ['10.1', '10.2.']` then `client, 10.1.1.1 10.2.2.2` OR `client, 10.1.1.1 10.2.2.2` || `publicOnly` ⇨ | : Returns only public and internet routable IP or null                                                                                                                                                                                                                                                                                                            ||     Output Field ⇩ | ⇩ Description                                                                     || -----------------: | :-------------------------------------------------------------------------------- ||             `ip` ⇨ | : Client IP address object of type IPv4Address() or IPv6Address()                 || `isRouteTrusted` ⇨ | : If proxy `count` and/or `proxy_list` provided and matched, `true`, else `false` |### Precedence OrderThe client IP address can be found in one or more request headers attributes. The lookup order is top to bottom and the default attributes are as follow.```python# The default meta precedence order - you can be more specific as per your configurationrequest_headers_precedence_order = (  &quot;X_FORWARDED_FOR&quot;, # Load balancers or proxies such as AWS ELB (default client is `leftmost` [`&lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;`])  &quot;HTTP_X_FORWARDED_FOR&quot;, # Similar to X_FORWARDED_TO  &quot;HTTP_CLIENT_IP&quot;, # Standard headers used by providers such as Amazon EC2, Heroku etc.  &quot;HTTP_X_REAL_IP&quot;,  &quot;HTTP_X_FORWARDED&quot;,  &quot;HTTP_X_CLUSTER_CLIENT_IP&quot;,  &quot;HTTP_FORWARDED_FOR&quot;,  &quot;HTTP_FORWARDED&quot;,  &quot;HTTP_VIA&quot;,  &quot;X-REAL-IP&quot;, # NGINX  &quot;X-CLUSTER-CLIENT-IP&quot;, # Rackspace Cloud Load Balancers  &quot;X_FORWARDED&quot;,  &quot;FORWARDED_FOR&quot;,  &quot;CF-CONNECTING-IP&quot;, # CloudFlare  &quot;TRUE-CLIENT-IP&quot;, # CloudFlare Enterprise,  &quot;FASTLY-CLIENT-IP&quot;, # Firebase, Fastly  &quot;FORWARDED&quot;,)```You can customize the order by providing your own list during initialization when calling `IpWare()`.```python# specific meta keyipware = IpWare(precedence=(&quot;X_FORWARDED_FOR&quot;))# multiple meta keysipware = IpWare(precedence=(&quot;X_FORWARDED_FOR&quot;, &quot;HTTP_X_FORWARDED_FOR&quot;))# usage is just to pass in the http request headers# Django (request.META)ip, proxy_verified = ipware.get_client_ip(meta=request.META)# Flask (request.environ)ip, proxy_verified = ipware.get_client_ip(meta=request.environ)# ... etc.```### Trusted ProxiesIf your node server is behind one or more known proxy server(s), you can filter out unwanted requestsby providing a `trusted proxy list`, or a known proxy `count`.You can customize the proxy IP prefixes by providing your own list during initialization when calling `IpWare(proxy_trusted_list)`.You can pass your custom list on every call, when calling the proxy-aware api to fetch the ip.```python# In the above scenario, use your load balancer IP address as a way to filter out unwanted requests.ipware = IpWare(proxy_trusted_list=[&quot;198.84.193.157&quot;])# If you have multiple proxies, simply add them to the listipware = IpWare(proxy_trusted_list=[&quot;198.84.193.157&quot;, &quot;198.84.193.158&quot;])# For proxy servers with fixed sub-domain and dynamic IP, use the following pattern.ipware = IpWare(proxy_trusted_list=[&quot;177.139.&quot;, &quot;177.140&quot;])# usage: non-strict mode (X-Forwarded-For: &lt;fake&gt;, &lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;)# The request went through our &lt;proxy1&gt; and &lt;proxy2&gt;, then our server# We choose the &lt;client&gt; ip address to the left our &lt;proxy1&gt; and ignore other ipsip, trusted_route = self.ipware.get_client_ip(meta=request.META)# usage: strict mode (X-Forwarded-For: &lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;)# The request went through our &lt;proxy1&gt; and &lt;proxy2&gt;, then our server# Total ip address are total trusted proxies + client ip# We don't allow far-end proxies, or fake addresses (exact or None)ip, trusted_route = self.ipware.get_client_ip(meta=request.META, strict=True)```In the following `example`, your public load balancer (LB) can be seen as a `trusted` proxy.````Real` Client &lt;public&gt; &lt;-&gt; &lt;public&gt; LB (Server) &lt;private&gt; &lt;-----&gt; &lt;private&gt; Django Server                                                             ^                                                             |`Fake` Client &lt;private&gt; &lt;-&gt; &lt;private&gt; LB (Server) &lt;private&gt; -+```### Proxy CountIf your python server is behind a `known` number of proxies, but you deploy on multiple providers and don't want to track proxy IPs, you still can filter out unwanted requests by providing proxy `count`.You can customize the proxy count by providing your `proxy_count` during initialization when calling `IpWare(proxy_count=2)`.```python# In the above scenario, the total number of proxies can be used as a way to filter out unwanted requests.import ipware# enforce proxy countipware = IpWare(proxy_count=1)# enforce proxy count and trusted proxiesipware = IpWare(proxy_count=1, proxy_trusted_list=[&quot;198.84.193.157&quot;])# usage: non-strict mode (X-Forwarded-For: &lt;fake&gt;, &lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;)# total number of ip addresses are greater than the total countip, trusted_route = self.ipware.get_client_ip(meta=request.META)# usage: strict mode (X-Forwarded-For: &lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;)# total number of ip addresses are exactly equal to client ip + proxy_countip, trusted_route = self.ipware.get_client_ip(meta=request.META, strict=True)```In the following `example`, your public load balancer (LB) can be seen as the `only` proxy.````Real` Client &lt;public&gt; &lt;-&gt; &lt;public&gt; LB (Server) &lt;private&gt; &lt;---&gt; &lt;private&gt; Node Server                                                            ^                                                            |                                `Fake` Client  &lt;private&gt; ---+```### Public IP Address ONLY (routable on the internet)```python# We make best attempt to return the first public IP address based on header precedence# Then we fall back on private, followed by loopbackimport ipware# no proxy enforce in this exampleipware = IpWare()ip, _ = self.ipware.get_client_ip(meta=request.META)if ip.is_global:    print('Public IP')else if ip.is_private:    print('Private IP')else if ip.loopback:    print('Loopback IP')```### Originating RequestPlease note that the [de-facto](https:#developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For) standardfor the originating client IP address is the `leftmost`as per`client, proxy1, proxy2`, and the `rightmost` proxy is the mosttrusted proxy.However, in rare cases your network has a `custom` configuration where the `rightmost` IP address is that of the originating client. If that is the case, then indicate it when creating `IpWare(leftmost=False)`.# Running the testsTo run the tests against the current environment:    ./test.sh# LicenseReleased under a ([MIT](https:#raw.githubusercontent.com/un33k/python-ipware/main/LICENSE)) license.# VersionX.Y.Z Version    `MAJOR` version -- making incompatible API changes    `MINOR` version -- adding functionality in a backwards-compatible manner    `PATCH` version -- making backwards-compatible bug fixes[status-image]: https://github.com/un33k/python-ipware/actions/workflows/ci.yml/badge.svg[status-link]: https://github.com/un33k/python-ipware/actions/workflows/ci.yml[version-image]: https://img.shields.io/pypi/v/python-ipware.svg[version-link]: https://pypi.python.org/pypi/python-ipware[coverage-image]: https://coveralls.io/repos/github/un33k/python-ipware/badge.svg[coverage-link]: https://coveralls.io/github/un33k/python-ipware[download-image]: https://img.shields.io/pypi/dm/python-ipware.svg[download-link]: https://pypi.python.org/pypi/python-ipware# Sponsors[Neekware Inc.](http://neekware.com)# Need Support?[Neekware Inc.](http://neekware.com)</longdescription>
</pkgmetadata>