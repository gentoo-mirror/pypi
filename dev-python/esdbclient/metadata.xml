<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Python gRPC Client for EventStoreDBThis [Python package](https://pypi.org/project/esdbclient/) provides a PythongRPC client for [EventStoreDB](https://www.eventstore.com/).This client has been developed in collaboration with the EventStoreDBteam. Although not all the features of EventStoreDB are supportedby this client, many of the most useful ones are presentedin an easy-to-use interface.This client has been tested to work with EventStoreDB LTS versions 21.10,without and without SSL/TLS, and with Python versions 3.7 to 3.11. Thereis 100% test coverage. The code has typing annotations, checked with mypy.The code is formatted with black and isort, and checked with flake8. Poetryis used for package management during development, and for building andpublishing distributions to [PyPI](https://pypi.org/project/esdbclient/).## SynopsisThe `ESDBClient` class can be imported from the `esdbclient` package.To run the client, you will need a connection string URI. And, toconnect to a &quot;secure&quot; EventStoreDB server, you will also need anSSL/TLS certificate.Probably the three most useful methods of `ESDBClient` are:* `append_events()` This method can be used to record events in a particular&quot;stream&quot;. This is useful for example when executing a command in an applicationthat mutates an aggregate. This method is &quot;atomic&quot; in that either all or none ofthe events will be recorded.* `read_stream_events()` This method can be used to retrieve all the recordedevents in a &quot;stream&quot;. This is useful for example when reconstructing an aggregatebefore executing a command in an application.* `subscribe_all_events()` This method can be used to receive all recordedevents across all &quot;streams&quot;. This is useful in downstream event-processingcomponents, and supports processing events with &quot;exactly-once&quot; semantics (see below).The example below uses an &quot;insecure&quot; EventStoreDB server running locally on port 2114.```pythonimport esdbclient, uuid# Construct ESDBClient with an EventStoreDB URI.client = esdbclient.ESDBClient(uri=&quot;esdb://localhost:2114?Tls=false&quot;)# Append events to a new stream.stream_name = str(uuid.uuid4())event1 = esdbclient.NewEvent(type='OrderCreated', data=b'data1')client.append_events(    stream_name=stream_name,    expected_position=None,    events=[event1],)# Append more events to an existing stream.event2 = esdbclient.NewEvent(type='OrderUpdated', data=b'data2')event3 = esdbclient.NewEvent(type='OrderDeleted', data=b'data3')client.append_events(    stream_name=stream_name,    expected_position=0,    events=[event2, event3],)# Read all events recorded in a stream.recorded = client.read_stream_events(    stream_name=stream_name)assert len(recorded) == 3assert recorded[0].data == event1.dataassert recorded[1].data == event2.dataassert recorded[2].data == event3.dataassert recorded[0].type == event1.typeassert recorded[1].type == event2.typeassert recorded[2].type == event3.type# In an event-processing component, use a &quot;catch-up&quot; subscription# to receive all events across all streams, including events that# have not yet been recorded, starting from the component's last# saved &quot;commit position&quot;.last_saved_commit_position = 0subscription = client.subscribe_all_events(    commit_position=last_saved_commit_position)# To implement &quot;exactly-once&quot; semantics, iterate over the# &quot;catch-up&quot; subscription. Process each received event,# in turn, through an event-processing policy. Save the# value of the commit_position attribute of the processed# event with new state generated by the policy in the same# atomic transaction. Use the last saved &quot;commit position&quot;# when restarting the &quot;catch-up&quot; subscription.received = []for event in subscription:    received.append(event)    if event.id == event3.id:        breakassert received[-3].data == event1.dataassert received[-2].data == event2.dataassert received[-1].data == event3.dataassert received[-3].type == event1.typeassert received[-2].type == event2.typeassert received[-1].type == event3.typeassert received[-3].commit_position &gt; 0assert received[-2].commit_position &gt; received[-3].commit_positionassert received[-1].commit_position &gt; received[-2].commit_position# Close the client after use.client.close()```See below for more details.For an example of usage, see the [eventsourcing-eventstoredb](https://github.com/pyeventsourcing/eventsourcing-eventstoredb) package.## Table of contents&lt;!-- TOC --&gt;* [Install package](#install-package)  * [From PyPI](#from-pypi)  * [With Poetry](#with-poetry)* [EventStoreDB server](#eventstoredb-server)  * [Run container](#run-container)  * [Stop container](#stop-container)* [EventStoreDB client](#eventstoredb-client)  * [Import class](#import-class)  * [Construct client](#construct-client)* [Streams](#streams)  * [Append events](#append-events)  * [Append event](#append-event)  * [Idempotent append operations](#idempotent-append-operations)  * [Read stream events](#read-stream-events)  * [How to implement snapshotting with EventStoreDB](#how-to-implement-snapshotting-with-eventstoredb)  * [Read all events](#read-all-events)  * [Get current stream position](#get-current-stream-position)  * [Get current commit position](#get-current-commit-position)  * [Get stream metadata](#get-stream-metadata)  * [Set stream metadata](#set-stream-metadata)  * [Delete stream](#delete-stream)  * [Tombstone stream](#tombstone-stream)* [Catch-up subscriptions](#catch-up-subscriptions)  * [How to implement exactly-once event processing](#how-to-implement-exactly-once-event-processing)  * [Subscribe all events](#subscribe-all-events)  * [Subscribe stream events](#subscribe-stream-events)* [Persistent subscriptions](#persistent-subscriptions)  * [Create subscription](#create-subscription)  * [Read subscription](#read-subscription)  * [Get subscription info](#get-subscription-info)  * [List subscriptions](#list-subscriptions)  * [Delete subscription](#delete-subscription)  * [Update subscription](#update-subscription)  * [Create stream subscription](#create-stream-subscription)  * [Read stream subscription](#read-stream-subscription)  * [Get stream subscription info](#get-stream-subscription-info)  * [List stream subscriptions](#list-stream-subscriptions)  * [Update stream subscription](#update-stream-subscription)  * [Delete stream subscription](#delete-stream-subscription)  * [Persistent subscription consumer](#persistent-subscription-consumer)* [Connection](#connection)  * [Reconnect](#reconnect)  * [Close](#close)* [Notes](#notes)  * [Connection strings](#connection-strings)  * [Regular expression filters](#regular-expression-filters)  * [New event objects](#new-event-objects)  * [Recorded event objects](#recorded-event-objects)  * [Asyncio client](#asyncio-client)* [Contributors](#contributors)  * [Install Poetry](#install-poetry)  * [Setup for PyCharm users](#setup-for-pycharm-users)  * [Setup from command line](#setup-from-command-line)  * [Project Makefile commands](#project-makefile-commands)&lt;!-- TOC --&gt;## Install packageIt is recommended to install Python packages into a Python virtual environment.### From PyPIYou can use pip to install this package directly from[the Python Package Index](https://pypi.org/project/esdbclient/).    $ pip install esdbclient### With PoetryYou can use Poetry to add this package to your pyproject.toml and install it.    $ poetry add esdbclient## EventStoreDB serverThe EventStoreDB server can be run locally using the official Docker container image.### Run containerFor development, you can run a &quot;secure&quot; EventStoreDB server using the following command.    $ docker run -d --name eventstoredb-secure -it -p 2113:2113 --env &quot;HOME=/tmp&quot; eventstore/eventstore:21.10.9-buster-slim --devAs we will see, the client needs an EventStoreDB connection string URI as the value ofits `uri` constructor argument. See the Notes section below for detailed informationabout EventStoreDB connection string URIs.The connection string for this &quot;secure&quot; EventStoreDB server would be:    esdb://admin:changeit@localhost:2113To connect to a &quot;secure&quot; server, you will usually need to include a &quot;username&quot;and a &quot;password&quot; in the connection string, so that the server can authenticate theclient. The default username is &quot;admin&quot; and the default password is &quot;changeit&quot;.When connecting to a &quot;secure&quot; server, the client also needs an SSL/TLScertificate as the value of its `root_certificates` constructor argument. To connectto a &quot;secure&quot; server you will need an SSL/TLS certificate so that the client canauthenticate the server. For development, you can either use the SSL/TLS certificateof the certificate authority used to create the server's certificate, or when using asingle-node cluster, you can use the server certificate itself. You can get theserver certificate with the following Python code.```pythonimport sslserver_certificate = ssl.get_server_certificate(addr=('localhost', 2113))```You can also start an &quot;insecure&quot; server using the following command.    $ docker run -d --name eventstoredb-insecure -it -p 2114:2113 eventstore/eventstore:21.10.9-buster-slim --insecureThe connection string URI for this &quot;insecure&quot; server would be:    esdb://localhost:2114?Tls=falseAs we will see, when connecting to an &quot;insecure&quot; server, there is no need to includea &quot;username&quot; and a &quot;password&quot; in the connection string. If you do, these values willbe ignored by the client, so that they will not be sent to the server over aninsecure channel.Please note, the &quot;insecure&quot; connection string uses a query string with the field-value`Tls=false`. The value of this field is by default `true`. See the Notes section belowfor more information about EventStoreDB connection strings and the fields that can beused in the query string to specify connection options.### Stop containerTo stop and remove the &quot;secure&quot; container, use the following Docker commands.    $ docker stop eventstoredb-secure$ docker rm eventstoredb-secureTo stop and remove the &quot;insecure&quot; container, use the following Docker commands.    $ docker stop eventstoredb-insecure$ docker rm eventstoredb-insecure## EventStoreDB clientThis EventStoreDB client is implemented in the `esdbclient` package withthe `ESDBClient` class.### Import classThe `ESDBClient` class can be imported from the `esdbclient` package.```pythonfrom esdbclient import ESDBClient```### Construct clientThe `ESDBClient` class can be constructed with a `uri` argument, which is required.And, to connect to a &quot;secure&quot; EventStoreDB server, the optional `root_certificates`argument is also required.The `uri` argument is expected to be an EventStoreDB connection string URI thatconforms with the standard EventStoreDB &quot;esdb&quot; or &quot;esdb+discover&quot; URI schemes. Thesyntax and semantics of EventStoreDB connection strings are explained in the Notessection below.For example, the following connection string specifies that the client shouldattempt to create a &quot;secure&quot; connection to port 2113 on &quot;localhost&quot;, and use theclient credentials &quot;username&quot; and &quot;password&quot; when making calls to the server.    esdb://username:password@localhost:2113?Tls=trueThe client must be configured to create a &quot;secure&quot; connection to a &quot;secure&quot; server,or alternatively an &quot;insecure&quot; connection to an &quot;insecure&quot; server. By default, theclient will attempt to create a &quot;secure&quot; connection. And so, when connecting to an&quot;insecure&quot; server, the connection string must specify that the client should attemptto make an &quot;insecure&quot; connection.The following connection string specifies that the client shouldattempt to create an &quot;insecure&quot; connection to port 2114 on &quot;localhost&quot;.When connecting to an &quot;insecure&quot; server, the client will ignore anyusername and password information included in the connection string,so that usernames and passwords are not sent over an &quot;insecure&quot; connection.    esdb://localhost:2114?Tls=falsePlease note, the &quot;insecure&quot; connection string uses a query string with the field-value`Tls=false`. The value of this field is by default `true`. Unless the connection stringURI includes the field-value `Tls=false` in the query string, the `root_certificates`constructor argument is also required.When connecting to a &quot;secure&quot; server, the `root_certificates` argument is expected tobe a Python `str` containing PEM encoded SSL/TLS root certificates. This value ispassed directly to `grpc.ssl_channel_credentials()`. It is used for authenticating theserver to the client. It is commonly the certificate of the certificate authority thatwas responsible for generating the SSL/TLS certificate used by the EventStoreDB server.But, alternatively for development, you can use the server's certificate itself.In the example below, the constructor argument values are taken from the operatingsystem environment. This is a typical arrangement in a production environment. It isdone this way here so that the code in this documentation can be tested with botha &quot;secure&quot; and an &quot;insecure&quot; server.```pythonimport osclient = ESDBClient(    uri=os.getenv(&quot;ESDB_URI&quot;),    root_certificates=os.getenv(&quot;ESDB_ROOT_CERTIFICATES&quot;),)```See the Notes section below for detailed information about EventStoreDB connectionstrings and the fields that can be used in the query string to specify connectionoptions.## StreamsIn EventStoreDB, a &quot;stream&quot; is a sequence of recorded events that all havethe same &quot;stream name&quot;. There will normally be many streams in a database.Each recorded event has a &quot;stream position&quot; in its stream, and a &quot;commit position&quot;in the database. The stream positions of the recorded events in a stream is a gaplesssequence starting from zero. The commit positions of the recorded events in the databaseform a sequence that is not gapless.The methods `append_events()`, `read_stream_events()` and `read_all_events()` canbe used to record and read events in the database.### Append events*requires leader*The `append_events()` method can be used to write a sequence of new events atomicallyto a &quot;stream&quot;. Writing new events either creates a stream, or appends events to the endof a stream. This method is idempotent.This method can be used to record atomically all the newevents that are generated when executing a command in an application.Three arguments are required, `stream_name`, `expected_position`and `events`.The `stream_name` argument is required, and is expected to be a Python`str` that uniquely identifies the stream in the database.The `expected_position` argument is required, is expected to be: `None`if events are being written to a new stream, and otherwise an Python `int`equal to the position in the stream of the last recorded event in the stream.The `events` argument is required, and is expected to be a sequence of newevent objects to be appended to the named stream. The `NewEvent` class shouldbe used to construct new event objects (see the Notes section below for detailsof this class).This method takes an optional `timeout` argument, which is a Python `float` that setsa deadline for the completion of the gRPC operation.Streams are created by writing events. The correct value of the `expected_position`argument when writing the first event of a new stream is `None`. Please note, it isnot possible to somehow create an &quot;empty&quot; stream in EventStoreDB.The stream positions of recorded events in a stream start from zero, and form a gaplesssequence of integers. The stream position of the first recorded event in a stream is`0`. And so when appending the second new event to a stream that has one recorded event,the correct value of the `expected_position` argument is `0`. Similarly, the streamposition of the second recorded event in a stream is `1`, and so when appending thethird new event to a stream that has two recorded events, the correct value of the`expected_position` argument is `1`. And so on...If there is a mismatch between the given value of the `expected_position` argumentand the position of the last recorded event in a stream, then an `ExpectedPositionError`exception will be raised. This effectively accomplishes optimistic concurrency control.If you wish to disable optimistic concurrency control when appending new events, youcan set the `expected_position` to a negative integer.If you need to discover the current position of the last recorded event in a stream,you can use the `get_stream_position()` method.Please note, the append events operation is atomic, so that either allor none of the given new events will be recorded. By design, it is onlypossible with EventStoreDB to atomically record new events in one stream.In the example below, a new event is appended to a new stream.```pythonfrom uuid import uuid4from esdbclient import NewEvent# Construct new event object.event1 = NewEvent(type='OrderCreated', data=b'data1')# Define stream name.stream_name1 = str(uuid4())# Append list of events to new stream.commit_position1 = client.append_events(    stream_name=stream_name1,    expected_position=None,    events=[event1],)```In the example below, two subsequent events are appended to an existingstream.```pythonevent2 = NewEvent(type='OrderUpdated', data=b'data2')event3 = NewEvent(type='OrderDeleted', data=b'data3')commit_position2 = client.append_events(    stream_name=stream_name1,    expected_position=0,    events=[event2, event3],)```If the operation is successful, this method returns an integerrepresenting the database &quot;commit position&quot; as it was when the operationwas completed.A &quot;commit position&quot; is a monotonically increasing integer representingthe position of the recorded event in a &quot;total order&quot; of all recordedevents in the database across all streams. It is the actual positionof the event record on disk. In consequence, the sequence of commitpositions is not gapless. Indeed, there are usually large differencesbetween the commit positions of successive recorded events.The &quot;commit position&quot; returned by `append_events()` is that of the lastrecorded event in the given batch of new events.The &quot;commit position&quot; returned in this way can therefore be used to waitfor a downstream component to have processed all the events that were recorded.For example, consider a user interface command that results in the recordingof new events, and a query into an eventually consistent materializedview in a downstream component that is updated from these events. If the newevents have not yet been processed, the view would be stale. The &quot;commit position&quot;can be used by the user interface to poll the downstream component until it hasprocessed those new events, after which time the view will not be stale.### Append event*requires leader*The `append_event()` method can be used to write a single new event to a stream.Three arguments are required, `stream_name`, `expected_position` and `event`.This method works in the same way as `append_events()`, however `event` is expectedto be a single `NewEvent`.This method takes an optional `timeout` argument, which is a Python `float` that setsa deadline for the completion of the gRPC operation.If the operation is successful, this method returns an integerrepresenting the database &quot;commit position&quot; as it was when the operationwas completed.Since the handling of a command in your application may result in one or manynew events, and the results of handling a command should be recorded atomically,and the writing of new events generated by a command handler is usually a concernthat is factored out and used everywhere in a project, it is more usual in a projectto use `append_events()` to record new events. However, this method may occasionallybe useful, and indeed it is used by `set_stream_metadata()`.### Idempotent append operationsSometimes it may happen that, when calling `append_events()` or `append_event()`,the new events are successfully recorded, but then somehow the connection to thedatabase gets interrupted before the successful call can return successfully tothe client. In case of an error when appending an event, it is desirable toretry appending the same event at the same position. If the event was in factsuccessfully recorded, it is convenient for the retried operation to returnsuccessfully without raising an error due to optimistic concurrency control(as described above).The example below shows the `append_events()` method being called again with`event3` and `expected_position=2`. We can see that repeating the call to`append_events()` returns successfully.```python# Retry appending event3.commit_position_retry = client.append_events(    stream_name=stream_name1,    expected_position=0,    events=[event2, event3],)```We can see that the same commit position is returned as above.```pythonassert commit_position_retry == commit_position2```By calling `read_stream_events()`, we can also see the stream has been unchangeddespite the `append_events()` method having been called twice with the same arguments.That is, there are still only three events in the stream.```pythonevents = client.read_stream_events(    stream_name=stream_name1)assert len(events) == 3```This idempotent behaviour is activated because the `NewEvent` class has an `id`attribute that, by default, is assigned a new and unique version-4 UUID when aninstance of `NewEvent` is constructed. If events with the same `id` are appendedat the same `expected_position`, the stream will be unchanged, the operation willcomplete successfully, and the same commit position will be returned to the caller.```pythonfrom uuid import UUIDassert isinstance(event1.id, UUID)assert isinstance(event2.id, UUID)assert isinstance(event3.id, UUID)assert event1.id != event2.idassert event2.id != event3.idassert events[0].id == event1.idassert events[1].id == event2.idassert events[2].id == event3.id```It is possible to set the `id` constructor argument of `NewEvent` when instantiatingthe `NewEvent` class, but in the examples above we have been using the defaultbehaviour, which is that the `id` value is generated when the `NewEvent` class isinstantiated.### Read stream eventsThe `read_stream_events()` method can be used to obtain the recorded events in astream. It returns a sequence of recorded events objects. The received recorded eventobject are instances of the `RecordedEvent` class (see the Notes section below fordetails of this class).This method has one required argument, `stream_name`, which is the name ofthe stream from which to read events. By default, the recorded events in thestream are returned in the order they were recorded.The method `read_stream_events()` also supports four optional arguments,`stream_position`, `backwards`, `limit`, and `timeout`.The optional `stream_position` argument is an optional integer that can be used toindicate the position in the stream from which to start reading. This argument is`None` by default, which means the stream will be read either from the start of thestream (the default behaviour), or from the end of the stream if `backwards` is`True`. When reading a stream from a specific position in the stream, therecorded event at that position will be included, both when reading forwardsfrom that position, and when reading backwards from that position.The optional `backwards` argument is a Python `bool`. The default is `False`, whichmeans the stream will be read forwards by default, so that events are returned in theorder they were appended, If `backwards` is `True`, the events are returned in reverseorder.The optional `limit` argument is an integer which restricts the number of events thatwill be returned. The default value is `sys.maxint`.The optional `timeout` argument is a Python `float` which sets a deadline forthe completion of the gRPC operation.The example below shows how to read the recorded events of a streamforwards from the start of the stream to the end of the stream. Thename of a stream is given when calling the method.```pythonevents = client.read_stream_events(    stream_name=stream_name1)```Now that we have a sequence of event objects, we can check we got thethree events that were appended to the stream, and that they areordered exactly as they were appended.```pythonassert len(events) == 3assert events[0].stream_name == stream_name1assert events[0].stream_position == 0assert events[0].type == event1.typeassert events[0].data == event1.dataassert events[1].stream_name == stream_name1assert events[1].stream_position == 1assert events[1].type == event2.typeassert events[1].data == event2.dataassert events[2].stream_name == stream_name1assert events[2].stream_position == 2assert events[2].type == event3.typeassert events[2].data == event3.data```The example below shows how to read recorded events in a stream forwards froma specific stream position to the end of the stream.```pythonevents = client.read_stream_events(    stream_name=stream_name1,    stream_position=1,)assert len(events) == 2assert events[0].stream_name == stream_name1assert events[0].stream_position == 1assert events[0].type == event2.typeassert events[0].data == event2.dataassert events[1].stream_name == stream_name1assert events[1].stream_position == 2assert events[1].type == event3.typeassert events[1].data == event3.data```The example below shows how to read the recorded events in a stream backwards fromthe end of the stream to the start of the stream.```pythonevents = client.read_stream_events(    stream_name=stream_name1,    backwards=True,)assert len(events) == 3assert events[0].stream_name == stream_name1assert events[0].stream_position == 2assert events[0].type == event3.typeassert events[0].data == event3.dataassert events[1].stream_name == stream_name1assert events[1].stream_position == 1assert events[1].type == event2.typeassert events[1].data == event2.data```The example below shows how to read a limited number (two) of the recorded eventsin a stream forwards from the start of the stream.```pythonevents = client.read_stream_events(    stream_name=stream_name1,    limit=2,)assert len(events) == 2assert events[0].stream_name == stream_name1assert events[0].stream_position == 0assert events[0].type == event1.typeassert events[0].data == event1.dataassert events[1].stream_name == stream_name1assert events[1].stream_position == 1assert events[1].type == event2.typeassert events[1].data == event2.data```The example below shows how to read a limited number (one) of the recordedevents in a stream backwards from a given stream position.```pythonevents = client.read_stream_events(    stream_name=stream_name1,    stream_position=2,    backwards=True,    limit=1,)assert len(events) == 1assert events[0].stream_name == stream_name1assert events[0].stream_position == 2assert events[0].type == event3.typeassert events[0].data == event3.data```The `read_stream_events()` method will raise a `NotFound` exception if the streamdoes not exist.```pythonfrom esdbclient.exceptions import NotFoundtry:    client.read_stream_events('not-a-stream')except NotFound:    pass  # The stream 'not-a-stream' does not exist.else:    raise Exception(&quot;Shouldn't get here&quot;)```### How to implement snapshotting with EventStoreDBEvent-sourced aggregates are typically reconstructed from recorded events by callinga mutator function for each recorded event, evolving from an initial state`None` to the current state of the aggregate. The function `get_aggregate()` showshow this can be done. The aggregate ID is used as a stream name. The exception`AggregateNotFound` is raised if the aggregate stream is not found.```pythondef get_aggregate(aggregate_id, mutator_func):    stream_name = aggregate_id    # Get recorded events.    try:        events = client.read_stream_events(            stream_name=stream_name,            stream_position=None        )    except NotFound as e:        raise AggregateNotFound(aggregate_id) from e    else:        # Reconstruct aggregate from recorded events.        aggregate = None        for event in events:            aggregate = mutator_func(aggregate, event)        return aggregateclass AggregateNotFound(Exception):    &quot;&quot;&quot;Raised when an aggregate is not found.&quot;&quot;&quot;```Snapshots can improve the performance of aggregates that would otherwise bereconstructed from very long streams. However, it is generally recommended todesign aggregates to have a finite lifecycle, and hence relatively short streams,thereby avoiding the need for snapshotting. This &quot;how to&quot; section is intendedmerely to show how snapshotting of aggregates can be implemented with EventStoreDBusing this Python client.Snapshotting of aggregates can be implemented by recording the current state ofan aggregate as a new event.If an aggregate object has a version number that corresponds to the stream position ofthe last event that was used to reconstruct the aggregate, and this version numberis recorded in the snapshot metadata, then any events that are recorded after thesnapshot can be selected using this version number. The aggregate can then bereconstructed from the last snapshot and any subsequent events, without havingto replay the entire history.We will use a separate stream for an aggregate's snapshots that is named after thestream used for recording its events. The name of the snapshot stream will beconstructed by prefixing the aggregate's stream name with `'$snapshot-'`.```pythonSNAPSHOT_PREFIX = '$snapshot-'def make_snapshot_stream_name(stream_name):    return f'{SNAPSHOT_PREFIX}{stream_name}'def strip_snapshot_stream_name(snapshot_stream_name):    return snapshot_stream_name.lstrip(SNAPSHOT_PREFIX)```Let's redefine the `get_aggregate()` function, so that it looks for a snapshot event,then selects subsequent aggregate events, and then calls a mutator function for eachrecorded event. We will use JSON to serialize and deserialize Python `dict` objects.Notice that the aggregate events are read from a stream for aggregateevents, whilst the snapshot is read from a separate stream for aggregate snapshots.```pythonimport jsondef get_aggregate(aggregate_id, mutator_func):    stream_name = aggregate_id    recorded_events = []    # Look for a snapshot.    try:        snapshots = client.read_stream_events(            stream_name=make_snapshot_stream_name(stream_name),            backwards=True,            limit=1        )    except NotFound:        stream_position = None    else:        snapshot = snapshots[0]        stream_position = deserialize(snapshot.metadata)['version'] + 1        recorded_events.append(snapshot)    # Get subsequent events.    try:        events = client.read_stream_events(            stream_name=stream_name,            stream_position=stream_position        )    except NotFound as e:        raise AggregateNotFound(aggregate_id) from e    else:        recorded_events += events    # Reconstruct aggregate from recorded events.    aggregate = None    for event in recorded_events:        aggregate = mutator_func(aggregate, event)    return aggregatedef serialize(d):    return json.dumps(d).encode()def deserialize(s):    return json.loads(s.decode())```To show how this can be used, let's define an &quot;immutable&quot; `Dog` aggregate class, withattributes `name` and `tricks`. The attributes `id` and `version` will indicate anaggregate object's ID and version number. The attribute `is_from_snapshot` is addedhere merely to demonstrate below when an aggregate object has been reconstructed usinga snapshot.```pythonfrom dataclasses import dataclass@dataclass(frozen=True)class Aggregate:    id: str    version: int    is_from_snapshot: bool@dataclass(frozen=True)class Dog(Aggregate):    name: str    tricks: list```Let's also define a mutator function `mutate_dog()` that can evolve the state of a`Dog` aggregate given various different types of events, `'DogRegistered'`,`'DogLearnedTrick'`, and `'$Snapshot`'. The snapshot event type is prefixed with`'$'` so that it can be filtered out when reading all events from the database.```pythondef mutate_dog(dog, event):    data = deserialize(event.data)    if event.type == 'DogRegistered':        return Dog(            id=event.stream_name,            version=event.stream_position,            is_from_snapshot=False,            name=data['name'],            tricks=[],        )    elif event.type == 'DogLearnedTrick':        assert event.stream_position == dog.version + 1        assert event.stream_name == dog.id        return Dog(            id=dog.id,            version=event.stream_position,            is_from_snapshot=dog.is_from_snapshot,            name=dog.name,            tricks=dog.tricks + [data['trick']],        )    elif event.type == '$Snapshot':        return Dog(            id=strip_snapshot_stream_name(event.stream_name),            version=deserialize(event.metadata)['version'],            is_from_snapshot=True,            name=data['name'],            tricks=data['tricks'],        )    else:        raise Exception(f&quot;Unknown event type: {event.type}&quot;)```For convenience, let's also define a `get_dog()` function that calls `get_aggregate()`with the `mutate_dog()` function as the `mutator_func` argument.```pythondef get_dog(dog_id):    return get_aggregate(        aggregate_id=dog_id,        mutator_func=mutate_dog,    )```We can also define some &quot;command&quot; functions that append new events to thedatabase. The `register_dog()` function appends a `DogRegistered` event. The`record_trick_learned()` appends a `DogLearnedTrick` event. The function`snapshot_dog()` appends a `$Snapshot` event. Notice that the`record_trick_learned()` and `snapshot_dog()` functions use `get_dog()`.Notice also that the `DogRegistered` and `DogLearnedTrick` events are appended to astream for aggregate events, whilst the `$Snapshot` is appended to a separate streamfor aggregate snapshots. The snapshot event type is prefixed with `'$'` so that it canbe filtered out when reading all events from the database.```pythondef register_dog(name):    dog_id = str(uuid4())    event = NewEvent(        type='DogRegistered',        data=serialize({'name': name}),    )    client.append_event(        stream_name=dog_id,        expected_position=None,        event=event,    )    return dog_iddef record_trick_learned(dog_id, trick):    dog = get_dog(dog_id)    event = NewEvent(        type='DogLearnedTrick',        data=serialize({'trick': trick}),    )    client.append_event(        stream_name=dog_id,        expected_position=dog.version,        event=event,    )def snapshot_dog(dog_id):    dog = get_dog(dog_id)    event = NewEvent(        type='$Snapshot',        data=serialize({'name': dog.name, 'tricks': dog.tricks}),        metadata=serialize({'version': dog.version}),    )    client.append_event(        stream_name=make_snapshot_stream_name(dog_id),        expected_position=-1,        event=event,    )```Now we can register a new dog, and record that some tricks have been learned.```python# Register a new dog.dog_id = register_dog('Fido')dog = get_dog(dog_id)assert dog.name == 'Fido'assert dog.tricks == []assert dog.version == 0assert dog.is_from_snapshot is False# Record that 'Fido' learned a new trick.record_trick_learned(dog_id, trick='roll over')dog = get_dog(dog_id)assert dog.name == 'Fido'assert dog.tricks == ['roll over']assert dog.version == 1assert dog.is_from_snapshot is False# Record that 'Fido' learned another new trick.record_trick_learned(dog_id, trick='fetch ball')dog = get_dog(dog_id)assert dog.name == 'Fido'assert dog.tricks == ['roll over', 'fetch ball']assert dog.version == 2assert dog.is_from_snapshot is False```After we call `snapshot_dog()`, the `get_dog()` function will return a `Dog`object that has been constructed using the `$Snapshot` event.```python# Snapshot 'Fido'.snapshot_dog(dog_id)dog = get_dog(dog_id)assert dog.name == 'Fido'assert dog.tricks == ['roll over', 'fetch ball']assert dog.version == 2assert dog.is_from_snapshot is True```We can continue to evolve the state of the `Dog` aggregate, usingthe snapshot both during the call the `record_trick_learned()` andwhen calling `get_dog()`.```pythonrecord_trick_learned(dog_id, trick='sit')dog = get_dog(dog_id)assert dog.name == 'Fido'assert dog.tricks == ['roll over', 'fetch ball', 'sit']assert dog.version == 3assert dog.is_from_snapshot is True```We can see from the `is_from_snapshot` attribute that the `Dog` object was indeedreconstructed from the snapshot.### Read all eventsThe method `read_all_events()` can be used to read all recorded eventsin the database in the order they were recorded. It returns an iterable ofevents that have been recorded in the database. Iterating over this iterableobject will stop when it has yielded the last recorded event. The receivedrecorded event object are instances of the `RecordedEvent` class (see theNotes section below for details of this class).This method supports seven optional arguments, `commit_position`, `backwards`,`filter_exclude`, `filter_include`, `filter_by_stream_name`, `limit`, and `timeout`.The optional `commit_position` argument is an optional integer that can be used tospecify the commit position from which to start reading. This argument is `None` bydefault, meaning that all the events will be read either from the start, orfrom the end if `backwards` is `True`. Please note, if a commit position is specified,it must be an actually existing commit position in the database.Any other number will result in a server error (at least in EventStoreDB v21.10).The optional `backwards` argument is a Python `bool`. The default is `False`, whichmeans the database will be read forwards by default, so that events are returned in theorder they were recorded, If `backwards` is `True`, the events are returned in reverseorder.The optional `filter_exclude` argument is a sequence of regular expressions thatmatch recorded events that should not be included. This argument is ignoredif `filter_include` is set to a non-empty sequence. By default, this argument is setto match the event types of &quot;system events&quot;, so that EventStoreDB system eventswill not normally be included. See the Notes section below for more informationabout filter expressions.The optional `filter_include` argument is a sequence of regular expressionsthat match recorded events that should be included. By default, this argumentis an empty tuple. If this argument is set to a non-empty sequence, the`filter_exclude` argument is ignored.The optional `filter_by_stream_name` argument is a Python `bool` that indicates whetherthe filter will apply to event types or stream names. By default, this value is `False`and so the filtering will apply to the event type strings of recorded events.The optional `limit` argument is an integer which restricts the number of events thatwill be returned. The default value is `sys.maxint`.The optional `timeout` argument is a Python `float` which sets adeadline for the completion of the gRPC operation.The filtering of events is done on the EventStoreDB server. The`limit` argument is applied on the server after filtering.When reading forwards from a specific commit position, the event at the specifiedposition WILL be included. However, when reading backwards, the event at thespecified position will NOT be included. (This non-inclusive behaviour, of excludingthe specified commit position when reading all streams backwards, differs from thebehaviour when reading a stream backwards from a specific stream position.)The example below shows how to read all events in the database in theorder they were recorded.```pythonevents = list(client.read_all_events())assert len(events) &gt;= 3```The example below shows how to read all recorded events from a specific commit position.```pythonevents = list(    client.read_all_events(        commit_position=commit_position1    ))assert len(events) == 7assert events[0].stream_name == stream_name1assert events[0].stream_position == 0assert events[0].type == event1.typeassert events[0].data == event1.dataassert events[1].stream_name == stream_name1assert events[1].stream_position == 1assert events[1].type == event2.typeassert events[1].data == event2.dataassert events[2].stream_name == stream_name1assert events[2].stream_position == 2assert events[2].type == event3.typeassert events[2].data == event3.dataassert events[3].type == &quot;DogRegistered&quot;assert events[4].type == &quot;DogLearnedTrick&quot;assert events[5].type == &quot;DogLearnedTrick&quot;assert events[6].type == &quot;DogLearnedTrick&quot;```The example below shows how to read all recorded events in reverse order.```pythonevents = list(    client.read_all_events(        backwards=True    ))assert len(events) &gt;= 3assert events[0].type == &quot;DogLearnedTrick&quot;assert events[1].type == &quot;DogLearnedTrick&quot;assert events[2].type == &quot;DogLearnedTrick&quot;assert events[3].type == &quot;DogRegistered&quot;assert events[4].stream_name == stream_name1assert events[4].stream_position == 2assert events[4].type == event3.typeassert events[4].data == event3.dataassert events[5].stream_name == stream_name1assert events[5].stream_position == 1assert events[5].type == event2.typeassert events[5].data == event2.dataassert events[6].stream_name == stream_name1assert events[6].stream_position == 0assert events[6].type == event1.typeassert events[6].data == event1.data```The example below shows how to read a limited number (one) of the recorded eventsin the database forwards from a specific commit position. Please note, when readingall events forwards from a specific commit position, the event at the specifiedposition WILL be included.```pythonevents = list(    client.read_all_events(        commit_position=commit_position1,        limit=1,    ))assert len(events) == 1assert events[0].stream_name == stream_name1assert events[0].stream_position == 0assert events[0].type == event1.typeassert events[0].data == event1.dataassert events[0].commit_position == commit_position1```The example below shows how to read a limited number (one) of the recorded eventsin the database backwards from the end. This gives the last recorded event.```pythonevents = list(    client.read_all_events(        backwards=True,        limit=1,    ))assert len(events) == 1assert events[0].type == &quot;DogLearnedTrick&quot;```The example below shows how to read a limited number (one) of the recorded eventsin the database backwards from a specific commit position. Please note, when readingall events backwards from a specific commit position, the event at the specifiedposition WILL NOT be included.```pythonevents = list(    client.read_all_events(        commit_position=commit_position2,        backwards=True,        limit=1,    ))assert len(events) == 1assert events[0].commit_position &lt; commit_position2```### Get current stream positionThe `get_stream_position()` method can be used toget the &quot;stream position&quot; of the last recorded event in a stream.This method has a `stream_name` argument, which is required.This method also takes an optional `timeout` argument, thatis expected to be a Python `float`, which sets a deadlinefor the completion of the gRPC operation.The sequence of positions in a stream is gapless. It is zero-based,so that a stream with one recorded event has a current streamposition of `0`. The current stream position is `1` when a stream hastwo events, and it is `2` when there are events, and so on.In the example below, the current stream position is obtained of thestream to which events were appended in the examples above.Because the sequence of stream positions is zero-based, and becausethree events were appended, so the current stream position is `2`.```pythonstream_position = client.get_stream_position(    stream_name=stream_name1)assert stream_position == 2```If a stream does not exist, the returned stream position value is `None`,which matches the required expected position when appending the first eventof a new stream (see above).```pythonstream_position = client.get_stream_position(    stream_name=str(uuid4()))assert stream_position == None```This method takes an optional argument `timeout` which is a Python `float` that setsa deadline for the completion of the gRPC operation.### Get current commit positionThe method `get_commit_position()` can be used to get the currentcommit position of the database.```pythoncommit_position = client.get_commit_position()```This method takes an optional argument `timeout` which is a Python `float` that setsa deadline for the completion of the gRPC operation.This method can be useful to measure progress of a downstream componentthat is processing all recorded events, by comparing the current commitposition with the recorded commit position of the last successfully processedevent in a downstream component.The value of the `commit_position` argument when reading events either by usingthe `read_all_events()` method or by using a catch-up subscription would usuallybe determined by the recorded commit position of the last successfully processedevent in a downstream component.### Get stream metadataThe method `get_stream_metadata()` gets the metadata for a stream, alongwith the version of the stream metadata.```pythonmetadata, metadata_version = client.get_stream_metadata(stream_name=stream_name1)```The returned `metadata` value is a Python `dict`. The returned `metadata_version`value is either an `int`, or `None` if the stream does not exist. These values canbe passed into `set_stream_metadata()`.### Set stream metadata*requires leader*The method `set_stream_metadata()` sets the metadata for a stream, alongwith the version of the stream metadata.```pythonmetadata[&quot;foo&quot;] = &quot;bar&quot;client.set_stream_metadata(    stream_name=stream_name1,    metadata=metadata,    expected_position=metadata_version,)```The `expected_position` argument should be the current version of the stream metadata.Please refer to the EventStoreDB documentation for more information about streammetadata.### Delete stream*requires leader*The method `delete_stream()` can be used to &quot;delete&quot; a stream.```pythoncommit_position = client.delete_stream(stream_name=stream_name1, expected_position=2)```After deleting a stream, it's still possible to append new events. Reading from adeleted stream will return only events that have been appended after it wasdeleted.### Tombstone stream*requires leader*The method `tombstone_stream()` can be used to &quot;tombstone&quot; a stream.```pythoncommit_position = client.tombstone_stream(stream_name=stream_name1, expected_position=2)```After tombstoning a stream, it's not possible to append new events.## Catch-up subscriptions&quot;Catch-up&quot; subscriptions can be used to receive events that have been recordedin the database, and also events that are recorded after a subscription was started.The method `subscribe_all_events()` starts a catch-up subscription to receive allevents that have been and will be recorded in the database. The method`subscribe_stream_events()` starts a catch-up subscription to receive events froma specific stream.Catch-up subscriptions encapsulate a streaming gRPC call which iskept open by the server, with newly recorded events sent to the clientas the client iterates over the subscription response.Many catch-up subscriptions can be created, concurrently or successively, and allwill receive all the recorded events they have been requested to receive.The received recorded event object are instances of the `RecordedEvent` class(see the Notes section below for details of this class).### How to implement exactly-once event processingThe commit positions of recorded events that are received and processed by adownstream component are usefully recorded by the downstream component so thatthe commit position of last processed event can be determined.The last recorded commit position can be used to specify the commit position from whichto subscribe when processing is resumed. Since this commit position will represent theposition of the last successfully processed event in a downstream component, so itwill be usual to want the next event after this position, because that is the nextevent that has not yet been processed. For this reason, when subscribing for eventsfrom a specific commit position using a catch-up subscription in EventStoreDB, therecorded event at the specified commit position will NOT be included in the sequenceof recorded events that are received.To accomplish &quot;exactly-once&quot; processing of recorded events in a downstreamcomponent when using a catch-up subscription, the commit position of a recordedevent should be recorded atomically and uniquely along with the result of processingrecorded events, for example in the same database as materialised views whenimplementing eventually-consistent CQRS, or in the same database as a downstreamanalytics or reporting or archiving application. By recording the commit positionof recorded events atomically with the new state that results from processingrecorded events, &quot;dual writing&quot; in the consumption of recorded events can beavoided. By also recording the commit position uniquely, the new state cannot berecorded twice, and hence the recorded state of the downstream component will beupdated only once for any recorded event. By using the greatest recorded commitposition to resume a catch-up subscription, all recorded events will eventuallybe processed. The combination of the &quot;at-most-once&quot; condition and the &quot;at-least-once&quot;condition gives the &quot;exactly-once&quot; condition.The danger with &quot;dual writing&quot; in the consumption of recorded events is that if arecorded event is successfully processed and new state recorded atomically in onetransaction with the commit position recorded in a separate transaction, one mayhappen and not the other. If the new state is recorded but the position is lost,and then the processing is stopped and resumed, the recorded event may be processedtwice. On the other hand, if the commit position is recorded but the new state islost, the recorded event may effectively not be processed at all. By eitherprocessing an event more than once, or by failing to process an event, the recordedstate of the downstream component might be inaccurate, or possibly inconsistent, andperhaps catastrophically so. Such consequences may or may not matter in your situation.But sometimes inconsistencies may halt processing until the issue is resolved. You canavoid &quot;dual writing&quot; in the consumption of events by atomically recording the commitposition of a recorded event along with the new state that results from processing thatevent in the same atomic transaction. By making the recording of the commit positionsunique, so that transactions will be rolled back when there is a conflict, you willprevent the results of any duplicate processing of a recorded event being committed.Recorded events received from a catch-up subscription cannot be acknowledged backto the EventStoreDB server. Acknowledging events, however, is an aspect of &quot;persistentsubscriptions&quot;. Hoping to rely on acknowledging events to an upstreamcomponent is an example of dual writing.### Subscribe all eventsThe`subscribe_all_events()` method can be used to start a &quot;catch-up&quot; subscriptionthat can return events from all streams in the database.This method can be used by a downstream componentto process recorded events with exactly-once semantics.This method takes an optional `commit_position` argument, which can beused to specify a commit position from which to subscribe. The defaultvalue is `None`, which means the subscription will operate from the firstrecorded event in the database. If a commit position is given, it must matchan actually existing commit position in the database. The recoded events thatare obtained will not include the event recorded at that commit position.This method also takes four other optional arguments, `filter_exclude`,`filter_include`, `filter_by_stream_name`, and `timeout`.The optional argument `filter_exclude` is a sequence of regular expressions thatmatch recorded events that should not be included. This argument is ignoredif `filter_include` is set to a non-empty sequence. By default, this argument is setto match the event types of &quot;system events&quot;, so that EventStoreDB system eventswill not normally be included. See the Notes section below for more informationabout filter expressions.The optional argument `filter_include` is a sequence of regular expressionsthat match recorded events that should be included. By default, this argumentis an empty tuple. If this argument is set to a non-empty sequence, the`filter_exclude` argument is ignored.The optional argument `filter_by_stream_name` is a Python `bool` that indicates whetherthe filter will apply to event types or stream names. By default, this value is `False`and so the filtering will apply to the event type strings of recorded events.Please note, the filtering happens on the EventStoreDB server, and the`limit` argument is applied on the server after filtering.The optional `timeout` argument is a Python `float` which sets adeadline for the completion of the gRPC operation.This method returns a Python iterator that yields recorded events, including eventsthat are recorded after the subscription was created. Iterating over this object willtherefore not stop, unless the connection to the database is lost. The call willbe ended when the iterator object is deleted from memory, which will happen when theiterator object goes out of scope or is explicitly deleted. The call may also beclosed by the server.The subscription object can be used directly, but it might be used within a threadedloop dedicated to receiving events that can be stopped in a controlled way, withrecorded events put on a queue for processing in a different thread. This packagedoesn't provide such a threaded or queuing object class. Just make sure to reconstructthe subscription (and the queue) using the last recorded commit position when resumingthe subscription after an error, to be sure all events are processed once.The example below shows how to subscribe to receive all recordedevents from the start, and then resuming from a specific commit position.Three already-recorded events are received, and then three new events arerecorded, which are then received via the subscription.```python# Append an event to a new stream.stream_name2 = str(uuid4())event4 = NewEvent(type='OrderCreated', data=b'data4')client.append_events(    stream_name=stream_name2,    expected_position=None,    events=[event4],)# Subscribe from the first recorded event in the database.subscription = client.subscribe_all_events()received_events = []# Process events received from the catch-up subscription.for event in subscription:    last_commit_position = event.commit_position    received_events.append(event)    if event.id == event4.id:        breakassert received_events[-8].id == event1.idassert received_events[-7].id == event2.idassert received_events[-6].id == event3.idassert received_events[-5].type == &quot;DogRegistered&quot;assert received_events[-4].type == &quot;DogLearnedTrick&quot;assert received_events[-3].type == &quot;DogLearnedTrick&quot;assert received_events[-2].type == &quot;DogLearnedTrick&quot;assert received_events[-1].id == event4.id# Append subsequent events to the stream.event5 = NewEvent(type='OrderUpdated', data=b'data5')client.append_events(    stream_name=stream_name2,    expected_position=0,    events=[event5],)# Receive subsequent events from the subscription.for event in subscription:    last_commit_position = event.commit_position    received_events.append(event)    if event.id == event5.id:        breakassert received_events[-2].id == event4.idassert received_events[-1].id == event5.id# Append more events to the stream.event6 = NewEvent(type='OrderDeleted', data=b'data6')client.append_events(    stream_name=stream_name2,    expected_position=1,    events=[event6],)# Resume subscribing from the last commit position.subscription = client.subscribe_all_events(    commit_position=last_commit_position)# Catch up by receiving the new event from the subscription.for event in subscription:    received_events.append(event)    if event.id == event6.id:        breakassert received_events[-3].id == event4.idassert received_events[-2].id == event5.idassert received_events[-1].id == event6.id# Append three more events to a new stream.stream_name3 = str(uuid4())event7 = NewEvent(type='OrderCreated', data=b'data7')event8 = NewEvent(type='OrderUpdated', data=b'data8')event9 = NewEvent(type='OrderDeleted', data=b'data9')client.append_events(    stream_name=stream_name3,    expected_position=None,    events=[event7, event8, event9],)# Receive the three new events from the resumed subscription.for event in subscription:    received_events.append(event)    if event.id == event9.id:        breakassert received_events[-6].id == event4.idassert received_events[-5].id == event5.idassert received_events[-4].id == event6.idassert received_events[-3].id == event7.idassert received_events[-2].id == event8.idassert received_events[-1].id == event9.id```The catch-up subscription call is ended as soon as the subscription objectgoes out of scope or is explicitly deleted from memory.```python# End the subscription.del subscription```### Subscribe stream eventsThe`subscribe_stream_events()` method can be used to start a &quot;catch-up&quot; subscriptionthat can return events that are recorded in a single stream.This method takes a required `stream_name` argument, which specifies the name of the streamfrom which recorded events will be received.This method also takes two optional arguments, `stream_position`, and `timeout`.The optional `stream_position` argument specifies a position in the stream from whichrecorded events will be received. The event at the specified stream position will notbe included.The optional `timeout` argument is a Python `float` that setsa deadline for the completion of the gRPC operation.The example below shows how to start a catch-up subscription to a stream.```python# Subscribe to events from stream2, from the start.subscription = client.subscribe_stream_events(stream_name=stream_name2)# Read from the subscription.events = []for event in subscription:    events.append(event)    if event.id == event6.id:        break# Check we got events only from stream2.assert len(events) == 3events[0].stream_name == stream_name2events[1].stream_name == stream_name2events[2].stream_name == stream_name2# Append another event to stream3.event10 = NewEvent(type=&quot;OrderUndeleted&quot;, data=b'data10')client.append_events(    stream_name=stream_name3,    expected_position=2,    events=[event10],)# Append another event to stream2.event11 = NewEvent(type=&quot;OrderUndeleted&quot;, data=b'data11')client.append_events(    stream_name=stream_name2,    expected_position=2,    events=[event11])# Continue reading from the subscription.for event in subscription:    events.append(event)    if event.id == event11.id:        break# Check we got events only from stream2.assert len(events) == 4events[0].stream_name == stream_name2events[1].stream_name == stream_name2events[2].stream_name == stream_name2events[3].stream_name == stream_name2```The example below shows how to start a catch-up subscription to a stream from aspecific stream position.```python# Subscribe to events from stream2, from the start.subscription = client.subscribe_stream_events(    stream_name=stream_name2,    stream_position=1,)# Read event from the subscription.events = []for event in subscription:    events.append(event)    if event.id == event11.id:        break# Check we got events only after position 1.assert len(events) == 2events[0].id == event6.idevents[0].stream_position == 2events[0].stream_name == stream_name2events[1].id == event11.idevents[1].stream_position == 3events[1].stream_name == stream_name2```## Persistent subscriptions### Create subscription*requires leader*The method `create_subscription()` can be used to create a&quot;persistent subscription&quot; to EventStoreDB.This method takes a required `group_name` argument, which is thename of a &quot;group&quot; of consumers of the subscription.This method also takes seven optional arguments, `from_end`, `commit_position`,`filter_exclude`, `filter_include`, `filter_by_stream_name`, `consumer_strategy`,and `timeout`.The optional `from_end` argument can be used to specify that the group of consumersof the subscription should only receive events that were recorded after the subscriptionwas created.Alternatively, the optional `commit_position` argument can be used to specify a commitposition from which commit position the group of consumers of the subscription shouldreceive events. Please note, the recorded event at the specified commit position mightbe included in the recorded events received by the group of consumers.If neither `from_end` or `commit_position` are specified, the group of consumersof the subscription will potentially receive all recorded events in the database.The optional `filter_exclude` argument is a sequence of regular expressions thatmatch recorded events that should not be included. This argument is ignoredif `filter_include` is set to a non-empty sequence. By default, this argument is setto match the event types of &quot;system events&quot;, so that EventStoreDB system eventswill not normally be received. See the Notes section below for more informationabout filter expressions.The optional `filter_include` argument is a sequence of regular expressionsthat match recorded events that should be received. By default, this argumentis an empty tuple. If this argument is set to a non-empty sequence, the`filter_exclude` argument is ignored.The optional `filter_by_stream_name` argument is a Python `bool` that indicates whetherthe filter will apply to event types or stream names. By default, this value is `False`and so the filtering will apply to the event type strings of recorded events.The optional `consumer_strategy` argument is a Python `str` that definesthe consumer strategy for this persistent subscription. The value of this argumentcan be `'DispatchToSingle'`, `'RoundRobin'`, `'Pinned'`, or `'PinnedByCorrelation'`. Thedefault value is `'DispatchToSingle'`.The optional `timeout` argument is a Python `float` which sets adeadline for the completion of the gRPC operation.The method `create_subscription()` does not return a value, becauserecorded events are obtained by the group of consumers of the subscriptionusing the `read_subscription()` method.In the example below, a persistent subscription is created.```python# Create a persistent subscription.group_name = f&quot;group-{uuid4()}&quot;client.create_subscription(group_name=group_name)```### Read subscription*requires leader*The method `read_subscription()` can be used by a group of consumers to receiverecorded events from a persistent subscription created using `create_subscription`.This method takes a required `group_name` argument, which isthe name of a &quot;group&quot; of consumers of the subscription specifiedwhen `create_subscription()` was called.This method also takes an optional `timeout` argument, thatis expected to be a Python `float`, which sets a deadlinefor the completion of the gRPC operation.This method returns a `PersistentSubscription` object, which is an iteratorgiving `RecordedEvent` objects, that also has `ack()`, `nack()` and `stop()`methods.```pythonsubscription = client.read_subscription(group_name=group_name)```The `ack()` method should be used by a consumer to indicate to the server that ithas received and successfully processed a recorded event. This will prevent thatrecorded event being received by another consumer in the same group. The `ack()`method takes an `event_id` argument, which is the ID of the recorded event thathas been received.The example below iterates over the subscription object, and calls `ack()`. The`stop()` method is called when we have received the last event, so that we cancontinue with the examples below.```pythonevents = []for event in subscription:    events.append(event)    # Acknowledge the received event.    subscription.ack(event_id=event.id)    # Break when the last event has been received.    if event.id == event11.id:        subscription.stop()```The received events are the events we appended above.```pythonassert events[-15].id == event1.idassert events[-14].id == event2.idassert events[-13].id == event3.idassert events[-12].type == &quot;DogRegistered&quot;assert events[-11].type == &quot;DogLearnedTrick&quot;assert events[-10].type == &quot;DogLearnedTrick&quot;assert events[-9].type == &quot;DogLearnedTrick&quot;assert events[-8].id == event4.idassert events[-7].id == event5.idassert events[-6].id == event6.idassert events[-5].id == event7.idassert events[-4].id == event8.idassert events[-3].id == event9.idassert events[-2].id == event10.idassert events[-1].id == event11.id```The &quot;subscription&quot; object also has an `nack()` method that should be used by a consumerto negatively acknowledge to the server that it has received but not successfullyprocessed a recorded event. The `nack()` method takes an `event_id` argument, which isthe ID of the recorded event that has been received, and an `action` argument, whichshould be a Python `str`, either `'unknown'`, `'park'`, `'retry'`, `'skip'`, or `'stop'`.Whilst there are some advantages of persistent subscriptions, in particular theprocessing of recorded events by a group of consumers, by tracking in the serverthe position in the commit sequence of events that have been processed, there isthe danger of &quot;dual writing&quot; in the consumption of events. Reliability in processingof recorded events by a group of consumers will rely instead on idempotent handlingof duplicate messages, and resilience to out-of-order delivery.### Get subscription info*requires leader*The `get_subscription_info()` method can be used to get information for apersistent subscription.This method has one required argument, `group_name`, whichshould match the value of the argument used when calling `create_subscription()`.This method also takes an optional `timeout` argument, thatis expected to be a Python `float`, which sets a deadlinefor the completion of the gRPC operation.```pythonsubscription_info = client.get_subscription_info(    group_name=group_name,)```The returned value is a `SubscriptionInfo` object.### List subscriptions*requires leader*The `list_subscriptions()` method can be used to get information for allexisting persistent subscriptions.This method takes an optional `timeout` argument, thatis expected to be a Python `float`, which sets a deadlinefor the completion of the gRPC operation.```pythonsubscriptions = client.list_subscriptions()```The returned value is a list of `SubscriptionInfo` objects.### Update subscription*requires leader*The method `update_subscription()` can be used to update a&quot;persistent subscription&quot;.This method takes a required `group_name` argument, which is thename of a &quot;group&quot; of consumers of the subscription.This method also takes three optional arguments, `from_end`, `commit_position`,and `timeout`.The optional `from_end` argument can be used to specify that the group of consumersof the subscription should only receive events that were recorded after the subscriptionwas updated.Alternatively, the optional `commit_position` argument can be used to specify a commitposition from which commit position the group of consumers of the subscription shouldreceive events. Please note, the recorded event at the specified commit position mightbe included in the recorded events received by the group of consumers.If neither `from_end` or `commit_position` are specified, the group of consumersof the subscription will potentially receive all recorded events in the database.Please note, the filter options and consumer strategy cannot be adjusted.The optional `timeout` argument is a Python `float` which sets adeadline for the completion of the gRPC operation.The method `update_subscription()` does not return a value.In the example below, a persistent subscription is updated to run from the end of thedatabase.```python# Create a persistent subscription.client.update_subscription(group_name=group_name, from_end=True)```### Delete subscription*requires leader*The `delete_subscription()` method can be used to delete a persistentsubscription.This method has one required argument, `group_name`, whichshould match the value of argument used when calling `create_subscription()`.This method also takes an optional `timeout` argument, thatis expected to be a Python `float`, which sets a deadlinefor the completion of the gRPC operation.```pythonclient.delete_subscription(    group_name=group_name,)```### Create stream subscription*requires leader*The `create_stream_subscription()` method can be used to create a persistentsubscription for a stream.This method has two required arguments, `group_name` and `stream_name`. The`group_name` argument names the group of consumers that will receive eventsfrom this subscription. The `stream_name` argument specifies which streamthe subscription will follow. The values of both these arguments are expectedto be Python `str` objects.The method also takes four optional arguments, `stream_position`, `from_end`,`consumer_strategy`, and `timeout`.This optional `stream_position` argument specifies a stream position fromwhich to subscribe. The recorded event at this streamposition will be received when reading the subscription.This optional `from_end` argument is a Python `bool`.By default, the value of this argument is `False`. If this argument is setto `True`, reading from the subscription will receive only eventsrecorded after the subscription was created. That is, it is not inclusiveof the current stream position.The optional `consumer_strategy` argument is a Python `str` that definesthe consumer strategy for this persistent subscription. The value of this argumentcan be `'DispatchToSingle'`, `'RoundRobin'`, `'Pinned'`, or `'PinnedByCorrelation'`. Thedefault value is `'DispatchToSingle'`.This method also takes an optional `timeout` argument, thatis expected to be a Python `float`, which sets a deadlinefor the completion of the gRPC operation.This method does not return a value. Events can be received by iteratingover the value returned by calling `read_stream_subscription()`.The example below creates a persistent stream subscription from the start of the stream.```python# Create a persistent stream subscription from start of the stream.group_name1 = f&quot;group-{uuid4()}&quot;client.create_stream_subscription(    group_name=group_name1,    stream_name=stream_name2,)```The example below creates a persistent stream subscription from a stream position.```python# Create a persistent stream subscription from a stream position.group_name2 = f&quot;group-{uuid4()}&quot;client.create_stream_subscription(    group_name=group_name2,    stream_name=stream_name2,    stream_position=2)```The example below creates a persistent stream subscription from the end of the stream.```python# Create a persistent stream subscription from end of the stream.group_name3 = f&quot;group-{uuid4()}&quot;client.create_stream_subscription(    group_name=group_name3,    stream_name=stream_name2,    from_end=True)```### Read stream subscription*requires leader*The `read_stream_subscription()` method can be used to read a persistentstream subscription.This method has two required arguments, `group_name` and `stream_name`, whichshould match the values of arguments used when calling `create_stream_subscription()`.This method also takes an optional `timeout` argument, thatis expected to be a Python `float`, which sets a deadlinefor the completion of the gRPC operation.This method returns a `PersistentSubscription` object, which is an iteratorgiving `RecordedEvent` objects, that also has `ack()`, `nack()` and `stop()`methods.```pythonsubscription = client.read_stream_subscription(    group_name=group_name1,    stream_name=stream_name2,)```The example below iterates over the subscription object, and calls `ack()`.The for loop breaks when we have received the last event in the stream, sothat we can finish the examples in this documentation.```pythonevents = []for event in subscription:    events.append(event)    # Acknowledge the received event.    subscription.ack(event_id=event.id)    # Stop when 'event11' has been received.    if event.id == event11.id:        subscription.stop()```We can check we received all the events that were appended to `stream_name2`in the examples above.```pythonassert len(events) == 4assert events[0].stream_name == stream_name2assert events[0].id == event4.idassert events[1].stream_name == stream_name2assert events[1].id == event5.idassert events[2].stream_name == stream_name2assert events[2].id == event6.idassert events[3].stream_name == stream_name2assert events[3].id == event11.id```### Get stream subscription info*requires leader*The `get_stream_subscription_info()` method can be used to get information for apersistent subscription for a stream.This method has two required arguments, `group_name` and `stream_name`, whichshould match the values of arguments used when calling `create_stream_subscription()`.This method also takes an optional `timeout` argument, thatis expected to be a Python `float`, which sets a deadlinefor the completion of the gRPC operation.```pythonsubscription_info = client.get_stream_subscription_info(    group_name=group_name1,    stream_name=stream_name2,)```The returned value is a `SubscriptionInfo` object.### List stream subscriptions*requires leader*The `list_stream_subscriptions()` method can be used to get information for allthe persistent subscriptions for a stream.This method has one required argument, `stream_name`.This method also takes an optional `timeout` argument, thatis expected to be a Python `float`, which sets a deadlinefor the completion of the gRPC operation.```pythonsubscriptions = client.list_stream_subscriptions(    stream_name=stream_name2,)```The returned value is a list of `SubscriptionInfo` objects.### Update stream subscription*requires leader*The method `update_stream_subscription()` can be used to update apersistent subscription for a stream.This method takes a required `group_name` argument, which is thename of a &quot;group&quot; of consumers of the subscription, and a required`stream_name` argument, which is the name of a stream.This method also takes three optional arguments, `from_end`, `stream_position`,and `timeout`.The optional `from_end` argument can be used to specify that the group of consumersof the subscription should only receive events that were recorded after the subscriptionwas updated.Alternatively, the optional `stream_position` argument can be used to specify a streamposition from which commit position the group of consumers of the subscription shouldreceive events. Please note, the recorded event at the specified stream position mightbe included in the recorded events received by the group of consumers.If neither `from_end` or `commit_position` are specified, the group of consumersof the subscription will potentially receive all recorded events in the stream.Please note, the consumer strategy cannot be adjusted.The optional `timeout` argument is a Python `float` which sets adeadline for the completion of the gRPC operation.The method `update_stream_subscription()` does not return a value.In the example below, a persistent subscription for a stream is updated to run from theend of the stream.```python# Create a persistent subscription.client.update_stream_subscription(    group_name=group_name1,    stream_name=stream_name2,    from_end=True,)```### Delete stream subscription*requires leader*The `delete_stream_subscription()` method can be used to delete a persistentsubscription for a stream.This method has two required arguments, `group_name` and `stream_name`, whichshould match the values of arguments used when calling `create_stream_subscription()`.This method also takes an optional `timeout` argument, thatis expected to be a Python `float`, which sets a deadlinefor the completion of the gRPC operation.```pythonclient.delete_stream_subscription(    group_name=group_name1,    stream_name=stream_name2,)```### Persistent subscription consumerThe reading of a persistent subscription can be encapsulated in a &quot;consumer&quot; that callsa &quot;policy&quot; function when a recorded event is received and then automatically calls`ack()` if the policy function returns normally, and `nack()` if it raises an exception,perhaps retrying the event for a certain number of times, and then parking the event.The simple example below shows how this might be done. We can see that 'event11' isacknowledged before 'event5' is finally parked.```pythonacked_events = {}nacked_events = {}class ExampleConsumer:    def __init__(self, subscription, max_retries, final_action):        self.subscription = subscription        self.max_retries = max_retries        self.final_action = final_action        self.error = None    def run(self):        try:            for event in self.subscription:                try:                    self.policy(event)                except Exception:                    if event.retry_count &lt; self.max_retries:                        action = &quot;retry&quot;                    else:                        action = self.final_action                    self.subscription.nack(event.id, action=action)                    self.after_nack(event, action)                else:                    self.subscription.ack(event.id)                    self.after_ack(event)        except Exception:            self.subscription.stop()            raise    def stop(self):        self.subscription.stop()    def policy(self, event):        # Raise an exception when we see &quot;event5&quot;.        if event.id == event5.id:            raise Exception()    def after_ack(self, event):        # Track retry count of acked events.        acked_events[event.id] = event.retry_count    def after_nack(self, event, action):        # Track retry count of nacked events.        nacked_events[event.id] = event.retry_count        if action == self.final_action:            # Stop the consumer, so we can continue with the examples.            self.stop()# Create subscription.group_name = f&quot;group-{uuid4()}&quot;client.create_subscription(group_name, commit_position=commit_position1)# Read subscription.subscription = client.read_subscription(group_name)# Construct consumer.consumer = ExampleConsumer(    subscription=subscription,    max_retries=5,    final_action=&quot;park&quot;,)# Run consumer.consumer.run()# Check 'event11' was acked and never retried.assert acked_events[event11.id] == 0assert event11.id not in nacked_events# Check 'event5' was retried five times and never acked.assert nacked_events[event5.id] == 5assert event5.id not in acked_events```## Connection### ReconnectThe `reconnect()` method can be used to manually reconnect the client to asuitable EventStoreDB node. This method uses the same routine for reading thecluster node states and then connecting to a suitable node according to theclient's node preference that is specified in the connection string URI whenthe client is constructed. This method is thread-safe, and it is &quot;conservative&quot;in that, when it is called by several threads at the same time, only onereconnection will occur. Concurrent attempts to reconnect will block untilthe client has reconnected successfully, and then they will all return normally.```pythonclient.reconnect()```An example of when it might be desirable to reconnect manually is when (for performancereasons) the client's node preference is to be connected to a follower node in thecluster, and, after a cluster leader election, the follower becomes the leader.Reconnecting to a follower node in this case is currently beyond the capabilities ofthis client, but this behavior might be implemented in a future release.Please note, nearly all the client methods are decorated with `@autoreconnect` (whichcalls the `reconnect()` method when the client detects that reconnecting is required)and a `@retry` decorator that more generally will retry operations that fail due toconnection issues.The `@autoreconnect` decorator will reconnect to a suitable node in the cluster whenthe server to which the client has been connected has become unavailable, or when theclient's gRPC channel happens to have been closed. The client will also reconnect whena method is called that requires a leader, and the client's node preference is to beconnected to a leader, but the node that the client has been connected to stops beingthe leader. In this case, the client will reconnect to the current leader. Afterreconnecting, the failed operation will be retried.The `@retry` decorator retries operations that have failed due to more generalconnection issues, such as a deadline being reached (so that the operation timesout), or in case the server throws an exception when handling a client request.Please also note, the aspects not covered by the reconnect and retry decoratorbehaviours have to do with methods that return iterators. For example, considerthe `read_all_events()` method, which returns an iterator of `RecordedEvent` objects.The method has returned and the method decorators have therefore exited before theiterating of the response begins. Therefore, it isn't possible for this method totrigger a reconnection or for it to retry, when the streaming response somehow fails.Another example is the &quot;catch-up&quot; and persistent subscription read methods, althoughwith these methods there is an initial &quot;confirmation&quot; response from the server whichis received and checked by the client before the method returns, so if the server isunavailable when the call is made, or if the channel is somehow closed, or if theserver throws an error for some reason, then the client will either reconnect andretry, or more simply just retry the operation, according the type of error thatwas encountered. However, an event-processing component that iterates over asuccessfully returned &quot;catch-up&quot; subscription response will need to be monitored forerrors, and, if it fails after it has started iterating over the response, the catch-upsubscription will need to be restarted from the event-processing component's &quot;lastsaved commit position&quot;. If the event-processing component is recording the commitposition of each recorded event atomically along with any new state that results fromprocessing the recorded events, and the commit positions are recorded with a uniquenessconstraint, then there will no danger to the projected state becoming inconsistent dueto these connection issues. In this case, the client will automatically reconnect to anode in the cluster when the subsequent call to a catch-up subscription method is made.You just need to handle the exception that occurs from the iterator, then read your lastsaved commit position, and then restart your event-processing component, using the sameclient object. The client will reconnect if there is a need to do so when the subsequentcall is made. Similarly, when reading persistent subscriptions, if there areconnectivity issues after you have started iterating over a successfully receivedresponse, then the server call will need to be restarted. In this case, the receivedevents will start with the last saved checkpoint on the server (potentially returningevents that were in fact successfully processed).### CloseThe `close()` method can be used to cleanly close the gRPC connection.```pythonclient.close()```## Notes### Connection stringsThe EventStoreDB connection string is a URI that conforms with one of two possibleschemes, either the &quot;esdb&quot; scheme or the &quot;esdb+discover&quot; scheme. The syntax andsemantics of the EventStoreDB URI schemes are explained below. The syntax isdefined using [EBNF](https://en.wikipedia.org/wiki/Extended_Backus–Naur_form).The &quot;esdb&quot; URI scheme can be defined in the following way.    esdb-uri = &quot;esdb://&quot; , [ user-info , &quot;@&quot; ] , grpc-target, { &quot;,&quot; , grpc-target } , [ &quot;?&quot; , query-string ] ;In the &quot;esdb&quot; URI scheme, after the optional user info string, there must be at leastone gRPC target. If there are several gRPC targets, they must be separated from eachother with the &quot;,&quot; character. Each gRPC target should indicate an EventStoreDB gRPCserver socket, by specifying a host and a port number separated with the &quot;:&quot; character.The host may be a hostname that can be resolved to an IP address, or an IP address.    grpc-target = ( hostname | ip-address ) , &quot;:&quot; , port-number ;The &quot;esdb+discover&quot; URI scheme can be defined in the following way.    esdb-discover-uri = &quot;esdb+discover://&quot; , [ user-info, &quot;@&quot; ] , cluster-domainname , [ &quot;?&quot; , query-string ] ;In the &quot;esdb+discover&quot; URI scheme, after the user info string, there must be a domainname which should identify a cluster of EventStoreDB servers. The client will use a DNSserver to resolve the domain name to a list of addresses of EventStoreDB servers,by querying for 'A' records. In this case, the port number &quot;2113&quot; will be used toconstruct gRPC targets from the addresses obtained from 'A' records provided by theDNS server. Therefore, if you want to use the &quot;esdb+discover&quot; URI scheme, you willneed to configure DNS when setting up your EventStoreDB cluster.With both the &quot;esdb&quot; and &quot;esdb+disocver&quot; URI schemes, the client firstly obtainsa list of gRPC targets: either directly from &quot;esdb&quot; connection strings; or indirectlyfrom &quot;esdb+discover&quot; connection strings via DNS. This list of targets is known as the&quot;gossip seed&quot;. The client will then attempt to connect to each gRPC target in turn,attempting to call the EventStoreDB Gossip API to obtain information about theEventStoreDB cluster. A member of the cluster is selected by the client, accordingto the &quot;node preference&quot; option. The client may then need to close itsconnection and reconnect to the selected server.In both the &quot;esdb&quot; and &quot;esdb+discover&quot; schemes, the URI may include a user info string.If it exists in the URI, the user info string must be separated from the rest of the URIwith the &quot;@&quot; character. The user info string must include a username and a password,separated with the &quot;:&quot; character.    user-info = username , &quot;:&quot; , password ;The user info is sent by the client as &quot;call credentials&quot; in each call to a &quot;secure&quot;server, in a &quot;basic auth&quot; authorization header. This authorization header is used bythe server to authenticate the client. The authorization header is not sent to&quot;insecure&quot; servers.In both the &quot;esdb&quot; and &quot;esdb+discover&quot; schemes, the optional query string must be oneor many field-value arguments, separated from each other with the &quot;&amp;&quot; character.    query-string = field-value, { &quot;&amp;&quot;, field-value } ;Each field-value argument must be one of the supported fields, and anappropriate value, separated with the &quot;=&quot; character.    field-value = ( &quot;Tls&quot;, &quot;=&quot; , &quot;true&quot; | &quot;false&quot; )                | ( &quot;TlsVerifyCert&quot;, &quot;=&quot; , &quot;true&quot; | &quot;false&quot; )                | ( &quot;ConnectionName&quot;, &quot;=&quot; , string )                | ( &quot;NodePreference&quot;, &quot;=&quot; , &quot;leader&quot; | &quot;follower&quot; | &quot;readonlyreplica&quot; | &quot;random&quot; )                | ( &quot;DefaultDeadline&quot;, &quot;=&quot; , integer )                | ( &quot;GossipTimeout&quot;, &quot;=&quot; , integer )                | ( &quot;MaxDiscoverAttempts&quot;, &quot;=&quot; , integer )                | ( &quot;DiscoveryInterval&quot;, &quot;=&quot; , integer )                | ( &quot;MaxDiscoverAttempts&quot;, &quot;=&quot; , integer )                | ( &quot;KeepAliveInterval&quot;, &quot;=&quot; , integer )                | ( &quot;KeepAliveInterval&quot;, &quot;=&quot; , integer ) ;The table below describes the query field-values supported by this client.| Field               | Value                                                                 | Description                                                                                                                                                       ||---------------------|-----------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|| Tls                 | &quot;true&quot;, &quot;false&quot; (default: &quot;true&quot;)                                     | If &quot;true&quot; the client will create a &quot;secure&quot; gRPC channel. If &quot;false&quot; the client will create an &quot;insecure&quot; gRPC channel. This must match the server configuration. || TlsVerifyCert       | &quot;true&quot;, &quot;false&quot; (default: &quot;true&quot;)                                     | This value is currently ignored.                                                                                                                                  || ConnectionName      | string (default: auto-generated version-4 UUID)                       | Sent in call metadata for every call, to identify the client to the cluster.                                                                                      || NodePreference      | &quot;leader&quot;, &quot;follower&quot;, &quot;readonlyreplica&quot;, &quot;random&quot; (default: &quot;leader&quot;) | The node state preferred by the client. The client will select a node from the cluster info received from the Gossip API according to this preference.            || DefaultDeadline     | integer (default: `None`)                                             | The default value (in seconds) of the `timeout` argument of client &quot;write&quot; methods such as `append_events()`.                                                     || GossipTimeout       | integer (default: 5)                                                  | The default value (in seconds) of the `timeout` argument of gossip read methods, such as `read_gossip()`.                                                         || MaxDiscoverAttempts | integer (default: 10)                                                 | The number of attempts to read gossip when connecting or reconnecting to a cluster member.                                                                        || DiscoveryInterval   | integer (default: 100)                                                | How long to wait (in milliseconds) between gossip retries.                                                                                                        || KeepAliveInterval   | integer (default: `None`)                                             | The value of the &quot;grpc.keepalive_ms&quot; gRPC channel option.                                                                                                         || KeepAliveTimeout    | integer (default: `None`)                                             | The value of the &quot;grpc.keepalive_timeout_ms&quot; gRPC channel option.                                                                                                 |Here are some examples of EventStoreDB connection string URIs.    # Get cluster info from secure server socket localhost:2113,    # and use &quot;admin&quot; and &quot;changeit&quot; as username and password    # when making calls to EventStoreDB API methods.    esdb://admin:changeit@localhost:2113    # Get cluster info from insecure server socket 127.0.0.1:2114    esdb://127.0.0.1:2114?Tls=false    # Get cluster info from addresses in 'A' records for cluster1.example.com,    # and use a default deadline for making calls to EventStore API method.    esdb+discover://admin:changeit@cluster1.example.com?DefaultDeadline=5    # Get cluster info from either localhost:2111 or localhost:2112 or    # localhost:2113, and then connect to a follower node in the cluster.    esdb://admin:changeit@localhost:2111,localhost:2112,localhost:2113?NodePreference=follower    # Get cluster info from addresses in 'A' records for cluster1.example.com,    # and configure &quot;keep alive&quot; timeout and interval in the gRPC channel.    esdb+discover://admin:changeit@cluster1.example.com?KeepAliveInterval=10000&amp;KeepAliveTimeout=10000Please note, the client is insensitive to the case of fields and values. If fields arerepeated in the query string, the query string will be parsed without error. However,the connection options used by the client will use the value of the first field. Allthe other field-values in the query string with the same field name will be ignored.Fields without values will also be ignored.If the client's node preference is &quot;leader&quot; and the node becomes a&quot;follower&quot;, the client will attempt to reconnect to the current leader when a methodis called that expects to call a leader. Methods which mutate the state of the databaseexpect to call a leader. For such methods, the HTTP header&quot;requires-leader&quot; is set to&quot;true&quot;, and this header is observed by the server, and so a node which is not a leaderthat receives such a request will return an error. This error is detected by the client,which will then close the current gRPC connection and create a new connection to theleader. The request will then be retried with the leader.If the client's node preference is &quot;follower&quot; and there are no followernodes in the cluster, then the client will raise an exception. Similarly, if theclient's node preference is &quot;readonlyreplica&quot; and there are no read-only replicanodes in the cluster, then the client will also raise an exception.The gRPC channel option &quot;grpc.max_receive_message_length&quot; is automaticallyconfigured to the value `17 * 1024 * 1024`. This value cannot be changed.### Regular expression filtersThe filter arguments in `read_all_events()`, `subscribe_all_events()`,`create_subscription()` and `get_commit_position()` are applied to the `type`attribute of recorded events.The default value of the `filter_exclude` arguments is designed to excludeEventStoreDB &quot;system&quot; and &quot;persistence subscription config&quot; events, whichotherwise would be included. System events generated by EventStoreDB allhave `type` strings that start with the `$` sign. Persistence subscriptionevents generated when manipulating persistence subscriptions all have `type`strings that start with `PersistentConfig`.For example, to match the type of EventStoreDB system events, use the regularexpression `r'\$.+'`. Please note, the constant `ESDB_SYSTEM_EVENTS_REGEX` isset to `r'\$.+'`. You can import this value(`from esdbclient import ESDB_SYSTEM_EVENTS_REGEX`) and useit when building longer sequences of regular expressions.Similarly, to match the type of EventStoreDB persistence subscription events, use theregular expression `r'PersistentConfig\d+'`. The constant `ESDB_PERSISTENT_CONFIG_EVENTS_REGEX`is set to `r'PersistentConfig\d+'`. You can also import this value(`from esdbclient import ESDB_PERSISTENT_CONFIG_EVENTS_REGEX`) and use it when buildinglonger sequences of regular expressions.The constant `DEFAULT_EXCLUDE_FILTER` is a sequence of regular expressions that matchthe events that EventStoreDB generates internally, events that are extraneous to thosewhich you append using the `append_events()` method.### New event objectsThe `NewEvent` class is used when appending events.The required argument `type` is a Python `str`, used to indicate the type ofthe event that will be recorded.The required argument `data` is a Python `bytes` object, used to indicate the data ofthe event that will be recorded.The optional argument `metadata` is a Python `bytes` object, used to indicate anymetadata of the event that will be recorded. The default value is an empty `bytes`object.The optional argument `content_type` is a Python `str`, used to indicate thetype of the data that will be recorded for this event. The default value is`application/json`, which indicates that the `data` was serialised using JSON.An alternative value for this argument is `application/octet-stream`.The optional argument `id` is a Python `UUID` object, used to specify the unique IDof the event that will be recorded. This value will default to a new version-4 UUID.```pythonnew_event1 = NewEvent(    type='OrderCreated',    data=b'{&quot;name&quot;: &quot;Greg&quot;}',)assert new_event1.type == 'OrderCreated'assert new_event1.data == b'{&quot;name&quot;: &quot;Greg&quot;}'assert new_event1.metadata == b''assert new_event1.content_type == 'application/json'assert isinstance(new_event1.id, UUID)event_id = uuid4()new_event2 = NewEvent(    type='ImageCreated',    data=b'01010101010101',    metadata=b'{&quot;a&quot;: 1}',    content_type='application/octet-stream',    id=event_id,)assert new_event2.type == 'ImageCreated'assert new_event2.data == b'01010101010101'assert new_event2.metadata == b'{&quot;a&quot;: 1}'assert new_event2.content_type == 'application/octet-stream'assert new_event2.id == event_id```### Recorded event objectsThe `RecordedEvent` class is used when reading events.The attribute `type` is a Python `str`, used to indicate the type of eventthat was recorded.The attribute `data` is a Python `bytes` object, used to indicate the data of theevent that was recorded.The attribute `metadata` is a Python `bytes` object, used to indicate the metadata ofthe event that was recorded.The attribute `content_type` is a Python `str`, used to indicate the type ofdata that was recorded for this event (usually `application/json` to indicate thatthis data can be parsed as JSON, but alternatively `application/octet-stream` toindicate that it is something else).The attribute `id` is a Python `UUID` object, used to indicate the unique ID of theevent that was recorded. Please note, when recorded events are returned from a callto `read_stream_events()` in EventStoreDB v21.10, the commit position is not actuallyset in the response. This attribute is typed as an optional value (`Optional[UUID]`),and in the case of using EventStoreDB v21.10 the value of this attribute will be `None`when reading recorded events from a stream. Recorded events will however have thisvalues set when reading recorded events from `read_all_events()` and from bothcatch-up and persistent subscriptions.The attribute `stream_name` is a Python `str`, used to indicate the name of thestream in which the event was recorded.The attribute `stream_position` is a Python `int`, used to indicate the position in thestream at which the event was recorded.The attribute `commit_position` is a Python `int`, used to indicate the commit positionat which the event was recorded.```pythonfrom esdbclient.events import RecordedEventrecorded_event = RecordedEvent(    type='OrderCreated',    data=b'{}',    metadata=b'',    content_type='application/json',    id=uuid4(),    stream_name='stream1',    stream_position=0,    commit_position=512,)```### Asyncio clientThe `esdbclient` package also includes an early version of an asynchronous I/OgRPC Python client. It follows exactly the same behaviors as the multithreaded`ESDBClient`, but uses the `grpc.aio` package and the `asyncio` module, instead of`grpc` and `threading`.The `async` function `AsyncioESDBClient` constructs the client, and connects toa server. It can be imported from `esdbclient`, and can be called with the samearguments as `ESDBClient`. It supports both the &quot;esdb&quot; and the &quot;esdb+discover&quot;connection string URI schemes, and reconnects and retries methods when connectionissues are encountered, just like `ESDBClient`.```pythonfrom esdbclient import AsyncioESDBClient```The asynchronous I/O client has `async` methods `append_events()`,`read_stream_events()`, `read_all_events()`, `subscribe_all_events()`,`delete_stream()`, `tombstone_stream()`, and `reconnect()`.These methods are equivalent to the methods on `ESDBClient`. They have the samemethod signatures, and can be called with the same arguments, to the same effect.The methods which appear on `ESDBClient` but not on `AsyncioESDBClient` will beadded soon.The example below demonstrates the `append_events()`, `read_stream_events()` and`subscribe_all_events()` methods. These are the most useful methods for writingan event-sourced application, allowing new aggregate events to be recorded, therecorded events of an aggregate to be obtained so aggregates can be reconstructed,and the state of an application to propagated and processed with &quot;exactly-once&quot;semantics.```pythonimport asyncioasync def demonstrate_asyncio_client():    # Construct client.    client = await AsyncioESDBClient(        uri=os.getenv(&quot;ESDB_URI&quot;),        root_certificates=os.getenv(&quot;ESDB_ROOT_CERTIFICATES&quot;),    )    # Append events.    stream_name = str(uuid4())    event1 = NewEvent(&quot;OrderCreated&quot;, data=b'{}')    event2 = NewEvent(&quot;OrderUpdated&quot;, data=b'{}')    event3 = NewEvent(&quot;OrderDeleted&quot;, data=b'{}')    await client.append_events(        stream_name=stream_name,        expected_position=None,        events=[event1, event2, event3]    )    # Read stream events.    recorded = await client.read_stream_events(stream_name)    assert len(recorded) == 3    assert recorded[0].id == event1.id    assert recorded[1].id == event2.id    assert recorded[2].id == event3.id    # Subscribe all events.    received = []    async for event in await client.subscribe_all_events():        received.append(event)        if event.id == event3.id:            break    assert received[-3].id == event1.id    assert received[-2].id == event2.id    assert received[-1].id == event3.id    # Close the client.    await client.close()# Run the demo.asyncio.get_event_loop().run_until_complete(    demonstrate_asyncio_client())```## Contributors### Install PoetryThe first thing is to check you have Poetry installed.    $ poetry --versionIf you don't, then please [install Poetry](https://python-poetry.org/docs/#installing-with-the-official-installer).    $ curl -sSL https://install.python-poetry.org | python3 -It will help to make sure Poetry's bin directory is in your `PATH` environment variable.But in any case, make sure you know the path to the `poetry` executable. The Poetryinstaller tells you where it has been installed, and how to configure your shell.Please refer to the [Poetry docs](https://python-poetry.org/docs/) for guidance onusing Poetry.### Setup for PyCharm usersYou can easily obtain the project files using PyCharm (menu &quot;Git &gt; Clone...&quot;).PyCharm will then usually prompt you to open the project.Open the project in a new window. PyCharm will then usually prompt you to createa new virtual environment.Create a new Poetry virtual environment for the project. If PyCharm doesn't alreadyknow where your `poetry` executable is, then set the path to your `poetry` executablein the &quot;New Poetry Environment&quot; form input field labelled &quot;Poetry executable&quot;. In the&quot;New Poetry Environment&quot; form, you will also have the opportunity to select whichPython executable will be used by the virtual environment.PyCharm will then create a new Poetry virtual environment for your project, usinga particular version of Python, and also install into this virtual environment theproject's package dependencies according to the project's `poetry.lock` file.You can add different Poetry environments for different Python versions, and switchbetween them using the &quot;Python Interpreter&quot; settings of PyCharm. If you want to usea version of Python that isn't installed, either use your favourite package manager,or install Python by downloading an installer for recent versions of Python directlyfrom the [Python website](https://www.python.org/downloads/).Once project dependencies have been installed, you should be able to run testsfrom within PyCharm (right-click on the `tests` folder and select the 'Run' option).Because of a conflict between pytest and PyCharm's debugger and the coverage tool,you may need to add ``--no-cov`` as an option to the test runner template. Alternatively,just use the Python Standard Library's ``unittest`` module.You should also be able to open a terminal window in PyCharm, and run the project'sMakefile commands from the command line (see below).### Setup from command lineObtain the project files, using Git or suitable alternative.In a terminal application, change your current working directoryto the root folder of the project files. There should be a Makefilein this folder.Use the Makefile to create a new Poetry virtual environment for theproject and install the project's package dependencies into it,using the following command.    $ make install-packagesIt's also possible to also install the project in 'editable mode'.    $ make installPlease note, if you create the virtual environment in this way, and then try toopen the project in PyCharm and configure the project to use this virtualenvironment as an &quot;Existing Poetry Environment&quot;, PyCharm sometimes has someissues (don't know why) which might be problematic. If you encounter suchissues, you can resolve these issues by deleting the virtual environmentand creating the Poetry virtual environment using PyCharm (see above).### Project Makefile commandsYou can start EventStoreDB using the following command.    $ make start-eventstoredbYou can run tests using the following command (needs EventStoreDB to be running).    $ make testYou can stop EventStoreDB using the following command.    $ make stop-eventstoredbYou can check the formatting of the code using the following command.    $ make lintYou can reformat the code using the following command.    $ make fmtTests belong in `./tests`. Code-under-test belongs in `./esdbclient`.Edit package dependencies in `pyproject.toml`. Update installed packages (and the`poetry.lock` file) using the following command.    $ make update-packages</longdescription>
</pkgmetadata>