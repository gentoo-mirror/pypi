<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>red===Python regex command-line tool, to replace functionality akin to 'perl -ne'.Installation------------From the project root directory::    $ python setup.py installUsage-----Use --help/-h to view info on the arguments::    $ red --helpThe special variables available::**line**:    for the entire line that was matched, without the trailing newline:**g**:    for groups, which you index to get that match group, as **g[0]** in &quot;(\w+) .*&quot;:**ag**:    for aggregated groups with the *-a* option, which is a list of all match groups:**d**:    for the groupdict, which you can index by named group as **d[&quot;foo&quot;]** in &quot;(?P&lt;foo&gt;\w+) .*&quot;:**ad**:    for the aggregated group dicts, a list of dictsExample usage::    $ cat test.txt     foo 1 bar 2    fiz 5 baz 10    funk 10 bunk 9    funk a bunk b    a b c d    aaaaa    bbbb    ccUse it like grep::    $ cat test.txt | red &quot;\w+ (\d+) \w+ (\d+)&quot;     foo 1 bar 2    fiz 5 baz 10    funk 10 bunk 9It works with path as argument as well, *but the path must appear directly after the regex* (oddity of argparse).::        $ red &quot;\w+ (\d+) \w+ (\d+)&quot; test.txtUse it to evaluate Python code on groups stored in variable **g**::    $ red &quot;\w+ (\d+) \w+ (\d+)&quot; test.txt -e &quot;int(g[0]) + int(g[1])&quot;    3    15    19Import an arbitrary library and do absolutely anything::    $ red '\w+ (\d+) \w+ (\d+)' test.txt -i json -e '&quot;{} =&gt; {}&quot;.format(line, json.dumps(g))'    foo 1 bar 2 =&gt; [&quot;1&quot;, &quot;2&quot;]    fiz 5 baz 10 =&gt; [&quot;5&quot;, &quot;10&quot;]    funk 10 bunk 9 =&gt; [&quot;10&quot;, &quot;9&quot;]If you want to execute a few python statements before the eval, you can do that as well with **-x**::    $ red &quot;(\w+) (\d+).*&quot; test.txt -x 'x = int(g[1]) ; y = g[0][::-1]' -e '(x, y)'    (1, 'oof')    (5, 'zif')    (10, 'knuf')Use it to aggregate across all of stdin, into list **ag**::    $ cat test.txt | red &quot;\w+ (\d+) \w+ (\d+)&quot; -a &quot;sum([int(x[0]) for x in ag])&quot;    16Aggregate has its own **-X** for an exec before the aggregate too::    $ red &quot;(\w+) (\d+).*&quot; test.txt -X 's = sum(int(g[1]) for g in ag)' -a 's'    16Evaluate on each match, and aggregate against all matches::    $ cat test.txt | red &quot;\w+ (\d+) \w+ (\d+)&quot; -a &quot;sum([int(x[0]) for x in ag])&quot; -e &quot;'adding {}'.format(g[0])&quot;    adding 1    adding 5    adding 10    16You can use named groups as well, stored in variables **d** and aggregated into **ad**::    $ cat test.txt | red &quot;\w+ (?P&lt;first&gt;\d+) \w+ \d+&quot; -e &quot;'first value is {first}'.format(**d)&quot;    first value is 1    first value is 5    first value is 10Even multiline will work, since whatever is passed into **-x** is just **exec**'d::    $ red '.*' test.txt -x '    # if you want multiline, just hit apostrophe and press enter    # and start typing    if line.startswith(&quot;foo&quot;):         print(&quot;Line started with foo: {}&quot;.format(line))    '    Line started with foo: foo 1 bar 2Get creative!::    $ cat urls.txt     https://www.google.com/    http://www.yahoo.com/    http://www.example.com/foo    $ red &quot;(.*)&quot; urls.txt -i requests -x 'response = requests.get(line)' -e '[response.status_code, response.content[:20]]'    [404, '&lt;!doctype html&gt;\n&lt;htm']    [200, '&lt;!doctype html&gt;&lt;html']    [200, '&lt;?xml version=&quot;1.0&quot; ']    $ cat somelogfile.log     INFO: visited http://www.example.com/foo    ERROR: visited https://www.google.com/    ERROR: visited http://www.yahoo.com/    $ cat somelogfile.log | red '(?P&lt;debuglevel&gt;ERROR|INFO): \S+ (?P&lt;url&gt;.*)' -i requests,collections -x 'response = requests.get(d[&quot;url&quot;])' -e '(response.status_code, response.content[0:20])' -a 'collections.Counter([d[&quot;debuglevel&quot;] for d in ad]).items()'    (404, '&lt;!doctype html&gt;\n&lt;htm')    (200, '&lt;!doctype html&gt;&lt;html')    (200, '&lt;?xml version=&quot;1.0&quot; ')    [('INFO', 1), ('ERROR', 2)]Disclaimer----------Code in -e and -a are run through **eval**, so if you paste in code from someone,it will run. Just sayin'. Only run code you trust, or have inspected personally.The same goes for any library you import with -i.Release Notes-------------:0.2.1:    Added -x for pre-eval exec, added -i for importing libraries, and -X for aggregate exec:0.2.0:    Added -i/--import functionality:0.1.1:    Path works as CLI arg:0.1.0:    Version is available on pypi, with functionality of evaluation and aggregation:0.0.1:    Project created</longdescription>
</pkgmetadata>