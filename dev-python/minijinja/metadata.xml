<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;div align=&quot;center&quot;&gt;  &lt;img src=&quot;https://github.com/mitsuhiko/minijinja/raw/main/artwork/logo.png&quot; alt=&quot;&quot; width=320&gt;  &lt;p&gt;&lt;strong&gt;MiniJinja for Python: a powerful template engine for Rust and Python&lt;/strong&gt;&lt;/p&gt;[![Build Status](https://github.com/mitsuhiko/minijinja/workflows/Tests/badge.svg?branch=main)](https://github.com/mitsuhiko/minijinja/actions?query=workflow%3ATests)[![License](https://img.shields.io/github/license/mitsuhiko/minijinja)](https://github.com/mitsuhiko/minijinja/blob/main/LICENSE)[![Crates.io](https://img.shields.io/crates/d/minijinja.svg)](https://crates.io/crates/minijinja)[![rustc 1.61.0](https://img.shields.io/badge/rust-1.61%2B-orange.svg)](https://img.shields.io/badge/rust-1.61%2B-orange.svg)[![Documentation](https://docs.rs/minijinja/badge.svg)](https://docs.rs/minijinja)&lt;/div&gt;`minijinja-py` is an experimental binding of[MiniJinja](https://github.com/mitsuhiko/minijinja) to Python.  It has somewhatlimited functionality compared to the Rust version.  These bindings use[maturin](https://www.maturin.rs/) and [pyo3](https://pyo3.rs/).You might want to use MiniJinja instead of Jinja2 when the full feature setof Jinja2 is not required and you want to have the same rendering experienceof a data set between Rust and Python.With these bindings MiniJinja can render some Python objects and valuesthat are passed to templates, but there are clear limitations with regardsto what can be done.To install MiniJinja for Python you can fetch the package [from PyPI](https://pypi.org/project/minijinja/):```$ pip install minijinja```## Basic APIThe basic API is hidden behind the `Environment` object.  It behaves almost entirelylike in `minijinja` with some Python specific changes.  For instance instead of`env.set_debug(True)` you use `env.debug = True`.  Additionally instead of using`add_template` or attaching a `source` you either pass a dictionary of templatesdirectly to the environment or a `loader` function.```pythonfrom minijinja import Environmentenv = Environment(templates={    &quot;template_name&quot;: &quot;Template source&quot;})```To render a template you can use the `render_template` method:```pythonresult = env.render_template('template_name', var1=&quot;value 1&quot;, var2=&quot;value 2&quot;)print(result)```## PurposeMiniJinja attempts a certain level of compatibility with Jinja2, but it does nottry to achieve this at all costs.  As a result you will notice that quite a fewtemplates will refuse to render with MiniJinja despite the fact that they probablylook quite innocent.  It is however possible to write templates that render to thesame results for both Jinja2 and MiniJinja.  This raises the question why you mightwant to use MiniJinja.The main benefit would be to achieve the exact same results in both Rust and Python.Additionally MiniJinja has a stronger sandbox than Jinja2 and might perform ever soslightly better in some situations.  However you should be aware that due to themarshalling that needs to happen in either direction there is a certain amount ofloss of information.## Dynamic Template LoadingMiniJinja's Python bindings inherit the underlying behavior of how MiniJinja loadstemplates.  Templates are loaded on first use and then cached.  The templates areloaded via a loader.  To trigger a reload you can call `env.reload()` oralternatively set `env.reload_before_render` to `True`.```pythondef my_loader(name):    segments = []    for segment in name.split(&quot;/&quot;):        if &quot;\\&quot; in segment or segment in (&quot;.&quot;, &quot;..&quot;):            return None        segments.append(segment)    try:        with open(os.path.join(TEMPLATES, *segments)) as f:            return f.read()    except (IOError, OSError):        passenv = Environment(loader=my_loader)env.reload_before_render = Trueprint(env.render_template(&quot;index.html&quot;))```Alternatively templates can manually be loaded and unloaded with `env.add_template`and `env.remove_template`.## Auto EscapingThe default behavior is to use auto escaping file files ending in `.html`.  You cancustomize this behavior by overriding the `auto_escape_callback`:```pythonenv = Environment(auto_escape_callback=lambda x: x.endswith((&quot;.html&quot;, &quot;.foo&quot;)))```MiniJinja uses [markupsafe](https://github.com/pallets/markupsafe) if it's availableon the Python side.  It will honor `__html__`.## FinalizersInstead of custom formatters like in MiniJinja, you can define a finalizer insteadwhich is similar to how it works in Jinja2.  It's passed a value (or optional alsothe state as first argument when `pass_state` is used) and can return a new value.If the special `NotImplemented` value is returned, the original value is renderedwithout any modification:```from minijinja import Environmentdef finalizer(value):    if value is None:return &quot;&quot;    return NotImplementedenv = Environment(finalizer=finalizer)assert env.render_str(&quot;{{ none }}&quot;) == &quot;&quot;```## State AccessFunctions passed to the environment such as filters or global functions canoptionally have the template state passed by using the `pass_state` parameter.This is similar to `pass_context` in Jinja2.  It can be used to look at thename of the template or to look up variables in the context.```pythonfrom minijinja import pass_state@pass_statedef my_filter(state, value):    return state.lookup(&quot;a_variable&quot;) + valueenv.add_filter(&quot;add_a_variable&quot;, my_filter)```## Runtime BehaviorMiniJinja uses it's own runtime model which is not matching the Pythonruntime model.  As a result there are clear gaps in beahvior between thetwo and only limited effort is made to bridge them.  For instance you willbe able to call some methods of types, but for instance builtins such asdicts and lists do not expose their methods on the MiniJinja side.  Thismeans that it's very intentional that if you pass a dictionary to MiniJinja,the Python `.items()` method is unavailable.Here is what this means for some basic types:* Python dictionaries and lists (as well as other objects that behave as sequences)  appear in the MiniJinja side as native lists.  They do not expose any specific  other behavior and when they move back to the Python side they will appear as basic  lists.  Specifically this means that a tuple (which does not exist in MiniJinja)  when moving from Python to MiniJinja turns into a list and will remain a list when  it moves back.* Python objects are represented in MiniJinja similarly to dicts, but they retain all  their meaningful Python APIs.  This means they stringify via `__str__` and they  allow the MiniJinja code to call their non-underscored methods.  Note that there is  no extra security layer in use at the moment so take care of what you pass there.* MiniJinja's python binding understand what `__html__` is when it exists on a string  subclass.  This means that a `markupsafe.Markup` object will appear as safe string in  MiniJinja.  This information can also flow back to Python again.## SponsorIf you like the project and find it useful you can [become asponsor](https://github.com/sponsors/mitsuhiko).## License and Links- [Documentation](https://docs.rs/minijinja/)- [Examples](https://github.com/mitsuhiko/minijinja/tree/main/examples)- [Issue Tracker](https://github.com/mitsuhiko/minijinja/issues)- [MiniJinja Playground](https://mitsuhiko.github.io/minijinja-playground/)- License: [Apache-2.0](https://github.com/mitsuhiko/minijinja/blob/main/LICENSE)</longdescription>
</pkgmetadata>