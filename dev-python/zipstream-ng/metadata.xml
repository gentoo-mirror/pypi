<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>zipstream-ng============[![Status](https://github.com/pR0Ps/zipstream-ng/workflows/tests/badge.svg)](https://github.com/pR0Ps/zipstream-ng/actions/workflows/tests.yml)[![Version](https://img.shields.io/pypi/v/zipstream-ng.svg)](https://pypi.org/project/zipstream-ng/)![Python](https://img.shields.io/pypi/pyversions/zipstream-ng.svg)A modern and easy to use streamable zip file generator. It can package and stream many files andfolders on the fly without needing temporary files or excessive memory.Includes the ability to calculate the total size of the stream before any data is actually added(provided no compression is used). This makes it ideal for use in web applications since the totalsize can be used to set the `Content-Length` header without having to generate the entire file first(see examples below).Features: - Generates zip data on the fly as it's requested. - Can calculate the total size of the resulting zip file before generation even begins. - Flexible API: Typical use cases are simple, complicated ones are possible. - Supports zipping data from files, bytes, strings, and any other iterable objects. - Threadsafe: Won't mangle data if multiple threads concurrently add/read data to/from the same stream. - Includes a clone of Python's `http.server` module with zip support added. Try `python -m zipstream.server`. - Automatically uses Zip64 extensions, but only if they are required. - No external dependencies.Installation------------```pip install zipstream-ng```Examples--------### Create a local zip file (simple example)Make an archive named `files.zip` in the current directory that contains all files under`/path/to/files`.```pythonfrom zipstream import ZipStreamzs = ZipStream.from_path(&quot;/path/to/files/&quot;)with open(&quot;files.zip&quot;, &quot;wb&quot;) as f:    f.writelines(zs)```### Create a local zip file (demos more of the API)```pythonfrom zipstream import ZipStream, ZIP_DEFLATED# Create a ZipStream that uses the maximum level of Deflate compression.zs = ZipStream(compress_type=ZIP_DEFLATED, compress_level=9)# Set the zip file's comment.zs.comment = &quot;Contains compressed important files&quot;# Add all the files under a path.# Will add all files under a top-level folder called &quot;files&quot; in the zip.zs.add_path(&quot;/path/to/files/&quot;)# Add another file (will be added as &quot;data.txt&quot; in the zip file).zs.add_path(&quot;/path/to/file.txt&quot;, &quot;data.txt&quot;)# Add some random data from an iterable.# This generator will only be run when the stream is generated.def random_data():    import random    for _ in range(10):        yield random.randbytes(1024)zs.add(random_data(), &quot;random.bin&quot;)# Add a file containing some static text.# Will automatically be encoded to bytes before being added (uses utf-8).zs.add(&quot;This is some text&quot;, &quot;README.txt&quot;)# Write out the zip file as it's being generated.# At this point the data in the files files will be read in and the generator# will be iterated over.with open(&quot;files.zip&quot;, &quot;wb&quot;) as f:    f.writelines(zs)```### zipserver (included)A fully-functional and useful example can be found in the included[`zipstream.server`](zipstream/server.py) module. It's a clone of Python's built in `http.server`with the added ability to serve multiple files and folders as a single zip file. Try it out byinstalling the package and running `zipserver --help` or `python -m zipstream.server --help`.![zipserver screenshot](zipserver.png)### Integration with a Flask webappA very basic [Flask](https://flask.palletsprojects.com/)-based file server that streams all thefiles under the requested path to the client as a zip file. It provides the total size of the streamin the `Content-Length` header so the client can show a progress bar as the stream is downloaded. Italso provides a `Last-Modified` header so the client can check if it already has the most recentcopy of the zipped data with a `HEAD` request instead of having to download the file and check.Note that while this example works, it's not a good idea to deploy it as-is due to the lack of inputvalidation and other checks.```pythonimport os.pathfrom flask import Flask, Responsefrom zipstream import ZipStreamapp = Flask(__name__)@app.route(&quot;/&quot;, defaults={&quot;path&quot;: &quot;.&quot;})@app.route(&quot;/&lt;path:path&gt;&quot;)def stream_zip(path):    name = os.path.basename(os.path.abspath(path))    zs = ZipStream.from_path(path)    return Response(        zs,        mimetype=&quot;application/zip&quot;,        headers={            &quot;Content-Disposition&quot;: f&quot;attachment; filename={name}.zip&quot;,            &quot;Content-Length&quot;: len(zs),            &quot;Last-Modified&quot;: zs.last_modified,        }    )if __name__ == &quot;__main__&quot;:    app.run(host=&quot;0.0.0.0&quot;, port=5000)```### Partial generation and last-minute file additionsIt's possible to generate the zip stream, but stop before finalizing it. This enables addingsomething like a file manifest or compression log after all the files have been added.`ZipStream` provides a `get_info` method that returns information on all the files that have beenadded to the stream. In this example, all that information will be added to the zip in a file named&quot;manifest.json&quot; before finalizing it.```pythonfrom zipstream import ZipStreamimport jsondef gen_zipfile()    zs = ZipStream.from_path(&quot;/path/to/files&quot;)    yield from zs.all_files()    zs.add(        json.dumps(            zs.get_info(),            indent=2        ),        &quot;manifest.json&quot;    )    yield from zs.finalize()```Comparison to stdlib--------------------Since Python 3.6 it has actually been possible to generate zip files as a stream using just thestandard library, it just hasn't been very ergonomic or efficient. Consider the typical use case ofzipping up a directory of files while streaming it over a network connection:(note that the size of the stream is not pre-calculated in this case as this would make the stdlibexample way too long).Using ZipStream:```pythonfrom zipstream import ZipStreamsend_stream(    ZipStream.from_path(&quot;/path/to/files/&quot;))```&lt;details&gt;&lt;summary&gt;The same(ish) functionality using just the stdlib:&lt;/summary&gt;```pythonimport osimport iofrom zipfile import ZipFile, ZipInfoclass Stream(io.RawIOBase):    &quot;&quot;&quot;An unseekable stream for the ZipFile to write to&quot;&quot;&quot;    def __init__(self):        self._buffer = bytearray()        self._closed = False    def close(self):        self._closed = True    def write(self, b):        if self._closed:            raise ValueError(&quot;Can't write to a closed stream&quot;)        self._buffer += b        return len(b)    def readall(self):        chunk = bytes(self._buffer)        self._buffer.clear()        return chunkdef iter_files(path):    for dirpath, _, files in os.walk(path, followlinks=True):        if not files:            yield dirpath  # Preserve empty directories        for f in files:            yield os.path.join(dirpath, f)def read_file(path):    with open(path, &quot;rb&quot;) as fp:        while True:            buf = fp.read(1024 * 64)            if not buf:                break            yield bufdef generate_zipstream(path):    stream = Stream()    with ZipFile(stream, mode=&quot;w&quot;) as zf:        toplevel = os.path.basename(os.path.normpath(path))        for f in iter_files(path):            # Use the basename of the path to set the arcname            arcname = os.path.join(toplevel, os.path.relpath(f, path))            zinfo = ZipInfo.from_file(f, arcname)            # Write data to the zip file then yield the stream content            with zf.open(zinfo, mode=&quot;w&quot;) as fp:                if zinfo.is_dir():                    continue                for buf in read_file(f):                    fp.write(buf)                    yield stream.readall()    yield stream.readall()send_stream(    generate_zipstream(&quot;/path/to/files/&quot;))```&lt;/details&gt;Tests-----This package contains extensive tests. To run them, install `pytest` (`pip install pytest`) and run`py.test` in the project directory.License-------Licensed under the [GNU LGPLv3](https://www.gnu.org/licenses/lgpl-3.0.html).</longdescription>
</pkgmetadata>