<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;h1&gt;&lt;img alt=&quot;pyceo&quot; src=&quot;https://raw.githubusercontent.com/jpsca/pyceo/master/pyceo.png&quot;&gt;&lt;a href=&quot;https://travis-ci.org/jpsca/pyceo/&quot;&gt;&lt;img src=&quot;https://travis-ci.org/jpsca/pyceo.svg?branch=master&quot;  alt=&quot;Tests&quot; align=&quot;right&quot;&gt;&lt;/a&gt;  &lt;a href=&quot;https://coveralls.io/github/jpsca/pyceo?branch=master&quot;&gt;&lt;img src=&quot;https://coveralls.io/repos/github/jpsca/pyceo/badge.svg?branch=master&quot; alt=&quot;Coverage Status&quot; align=&quot;right&quot;&gt;&lt;/a&gt;&lt;/h1&gt;*It looks good and delegates all the real work to you* ;)A minimal and ridiculously good looking command-line-interface toolkit.In four points:- Completely customizable help page, but pretty by default.- Add new commands at any time and from other files.- No sub-commands but grouping of commands instead.- Easy to use and understand.## An example![pyceo output](https://github.com/jpsca/pyceo/raw/master/output.png)This autogenerated (and completely customizable) help message comes from runningthe example below:```python# example.pyfrom pyceo import Manager, param, optioncli = Manager(&quot;Welcome to Proper v1.2.3&quot;)@cli.command(help=&quot;Creates a new Proper application at `path`.&quot;)@param(&quot;path&quot;, help=&quot;Where to create the new application.&quot;)@option(&quot;quiet&quot;, help=&quot;Supress all output.&quot;)def new(path):    &quot;&quot;&quot;The `proper new` command creates a new Proper application with a default    directory structure and configuration at the path you specify.    Example: `proper new ~/Code/blog`    This generates a skeletal Proper application at `~/Code/blog`.    &quot;&quot;&quot;    pass@cli.command()@option(&quot;num&quot;, type=int)  # Optional typedef fizzbuzz(num=3):    &quot;&quot;&quot;A bad fizz buzz.&quot;&quot;&quot;    print(&quot;fizz &quot; * num + &quot;buzz&quot;)@cli.command(group=&quot;db&quot;)@option(&quot;message&quot;, help=&quot;Revision message&quot;)@option(&quot;sql&quot;, help=&quot;Dont emit SQL to database - dump to standard output instead&quot;)@option(&quot;head&quot;, help=&quot;Specify head or &lt;branchname&gt;@head to base new revision on&quot;)def migrate(**kwargs):    &quot;&quot;&quot;Autogenerate a new revision file.    This is an alias for &quot;revision --autogenerate&quot;.&quot;&quot;&quot;    pass@cli.command(group=&quot;db&quot;)@option(&quot;name&quot;, help=&quot;Name of section in .ini file to use for Alembic config&quot;)def branches(**kwargs):    &quot;&quot;&quot;Show current branch points.    &quot;&quot;&quot;    passif __name__ == &quot;__main__&quot;:    # cli.run(default=&quot;new&quot;)    cli.run()```## How minimal?**pyceo** include a `confirm()` and `ask()` utilities, but not any features like progress bars, table formatting, [file editing](https://pypi.org/project/text-editor/), etc. It doesn't matter because for those features many dedicated python libraries can be used.You could say it *focuses on its core competencies while synergetically interface with other libraries to take it to the next level*. ðŸ’ªðŸš€## Why don't just use optparse or argparse?Are you kidding? Because this is way easier to use and understand.## Why don't just use click?Because this looks better and is easier to use and understand.## Why don't just use...?Because this library fits better my mental model. I hope it matches yours as well.</longdescription>
</pkgmetadata>