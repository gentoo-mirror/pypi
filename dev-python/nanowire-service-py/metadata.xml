<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># nanowire-service-py&lt;div align=&quot;center&quot;&gt;[![Build status](https://github.com/SpotlightData/nanowire-service-py/workflows/build/badge.svg?branch=master&amp;event=push)](https://github.com/SpotlightData/nanowire-service-py/actions?query=workflow%3Abuild)[![Python Version](https://img.shields.io/pypi/pyversions/nanowire-service-py.svg)](https://pypi.org/project/nanowire-service-py/)[![Dependencies Status](https://img.shields.io/badge/dependencies-up%20to%20date-brightgreen.svg)](https://github.com/SpotlightData/nanowire-service-py/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20author%3Aapp%2Fdependabot)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)[![Security: bandit](https://img.shields.io/badge/security-bandit-green.svg)](https://github.com/PyCQA/bandit)[![Pre-commit](https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&amp;logoColor=white)](https://github.com/SpotlightData/nanowire-service-py/blob/master/.pre-commit-config.yaml)[![Semantic Versions](https://img.shields.io/badge/%F0%9F%9A%80-semantic%20versions-informational.svg)](https://github.com/SpotlightData/nanowire-service-py/releases)[![License](https://img.shields.io/github/license/SpotlightData/nanowire-service-py)](https://github.com/SpotlightData/nanowire-service-py/blob/master/LICENSE)Wrapper for interacting with Nanowire platform&lt;/div&gt;## UsageInstall the library via `pip install nanowire-service-py`, or by adding it to requirements file and running `pip install -r requirements.txt`This library is designed for tight integration with Nanowire platform (created by Spotlight Data).The library does not have a hardcode requirement for a specific web server, so a another framework like django or flask could be utilised, however, I'd recommend using [fastapi](https://fastapi.tiangolo.com/) due to it's simplicity and speed### EnvironmentThe following environment variables need to be supplied:```pythonclass Environment(BaseModel):    # Dapr spect    DAPR_HTTP_PORT: int    DAPR_APP_ID: str    PUB_SUB: str    # Where /pending requests get made    SCHEDULER_PUB_SUB: str    # Dapr related properties    # Whether we should wait for DAPR server to be active before loading    NO_WAIT: bool = False    # Whether the service should publish to schduler    # This shouldn't be done if we have an &quot;executor&quot; worker    NO_PUBLISH: bool = False    LOG_LEVEL: Union[str, int] = &quot;DEBUG&quot;    # Postgres connection details    POSTGRES_URL: str    POSTGRES_SCHEMA: str    # Utilised for healthchecks and identifying the pod    SERVICE_ID: str = str(uuid.uuid4())```This will be verified on service startup.### EntrypointThe primary code logic should be placed in a sub-class of `BaseHandler`. User is expected to implement `validate_args` as well as `handle_body` methods:```pythonimport osfrom dotenv import load_dotenvfrom fastapi import FastAPI, Responsefrom pydantic import BaseModel, validatorfrom typing import Any, List, Optionalimport pandas as pdfrom nanowire_service_py import BaseHandler, create, TaskBodyfrom toolbox import ClusterToolload_dotenv()allowed_methods = [&quot;HDBSCAN&quot;, &quot;DBSCAN&quot;]# pydantic used to verify function bodyclass Arguments(BaseModel):    contentUrl: str    textCol: str    indexCol: str    clusterSize: float = 0.2    nLabels: int = 10    method: str = &quot;DBSCAN&quot;    customStops: Optional[List[str]] = []    maxVocab: int = 5000    memSave: bool = False    withAnomalous: bool = False    @validator('method')    def method_check(cls, method):        if method not in allowed_methods:            raise ValueError(&quot;Method has to be one of: {}, received: {}&quot;.format(&quot;,&quot;.join(allowed_methods), method))        return method# Our custom handlerclass MyHandler(BaseHandler):    def __init__(self, *args):        super().__init__(*args)        self.cluster_tool = ClusterTool(self.logger)    def validate_args(self, args: Any, task_id: str) -&gt; Arguments:        return Arguments(**args)    def handle_body(self, args: Arguments, meta: Any, task_id: str):        df = pd.read_csv(args.contentUrl, dtype='unicode')        if args.textCol not in df.columns:            raise RuntimeError(&quot;Could not find text column '{}' in CSV&quot;.format(args.textCol), { &quot;origin&quot;: &quot;CSV&quot;})        if args.indexCol not in df.columns:            raise RuntimeError(&quot;Could not find index column '{}' in CSV&quot;.format(args.indexCol), { &quot;origin&quot;: &quot;CSV&quot;})        result = self.cluster_tool.main(df, args)        return (result, meta)# Always handled by the library, pass environment directlyexecutor = create(os.environ, MyHandler)app = FastAPI()# Let's DAPR know which topics should be subscribed to@app.get(&quot;/dapr/subscribe&quot;)def subscribe():    return executor.subscriptions# Primary endpoint, where request will be delivered to# TaskBody type here verifies the post body@app.post(&quot;/subscription&quot;)def subscription(body: TaskBody, response: Response):    status = executor.handle_request(body.data.id)    response.status_code = status    # Return empty body so dapr doesn't freak out    return {}# Start heartbeat thread, which will periodically send updates to databaseexecutor.heartbeat()```Assuming the filename is `main.py` the server can then be started via `uvicorn main:app`### Handling failureThe primary validation happens within `validate_args` function by `pydantic` models. This is where anything related to input should be checked.If at any point you want the current task to fail, raise `RuntimeError` or `Exception`. This will indicate the library, that we should fail and not retry again. For example:- CSV missing columns or having incorrect text format- Not enough data passedAnything else that raises for a retryable error, should be raised via `RetryError`.## VersioningVersioning is based on [semver](https://semver.org/), however, it primarily applies to the `create` function exposed by the package.If you're using any of the internal system parts, make sure to validate before updating the version.## ContributingRead [CONTRIBUTING.md](CONTRIBUTING.md)## ðŸ›¡ License[![License](https://img.shields.io/github/license/SpotlightData/nanowire-service-py)](https://github.com/SpotlightData/nanowire-service-py/blob/master/LICENSE)This project is licensed under the terms of the `MIT` license. See [LICENSE](https://github.com/SpotlightData/nanowire-service-py/blob/master/LICENSE) for more details.## CreditsThis project was generated with [`python-package-template`](https://github.com/TezRomacH/python-package-template).</longdescription>
</pkgmetadata>