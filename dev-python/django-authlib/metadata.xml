<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>================================================django-authlib - Authentication utils for Django================================================.. image:: https://github.com/matthiask/django-authlib/actions/workflows/tests.yml/badge.svg    :target: https://github.com/matthiask/django-authlib/    :alt: CI Status.. image:: https://readthedocs.org/projects/django-authlib/badge/?version=latest    :target: https://django-authlib.readthedocs.io/en/latest/?badge=latest    :alt: Documentation Statusauthlib is a collection of authentication utilities for implementingpasswordless authentication. This is achieved by either sendingcryptographically signed links by email, or by fetching the emailaddress from third party providers such as Google, Facebook and Twitter.After all, what's the point in additionally requiring a password forauthentication when the password can be easily resetted on most websiteswhen an attacker has access to the email address?Goals=====- Stay small, simple and extensible.- Offer tools and utilities instead of imposing a framework on you.Usage=====- Install ``django-authlib`` using pip into your virtualenv.- Add ``authlib.backends.EmailBackend`` to ``AUTHENTICATION_BAcKENDS``.- Adding ``authlib`` to ``INSTALLED_APPS`` is optional and only useful  if you want to use the bundled translation files. There are no  required database tables or anything of the sort.- Have a user model which has a email field named ``email`` as username.  For convenience a base user model and manager are available in the  ``authlib.base_user`` module, ``BaseUser`` and ``BaseUserManager``.  The ``BaseUserManager`` is automatically available as ``objects`` when  you extend the ``BaseUser``.- Use the bundled views or write your own. The bundled views give  feedback using ``django.contrib.messages``, so you may want to check  that those messages are visible to the user.The Google, Facebook and Twitter OAuth clients require the followingsettings:- ``GOOGLE_CLIENT_ID``- ``GOOGLE_CLIENT_SECRET``- ``FACEBOOK_CLIENT_ID``- ``FACEBOOK_CLIENT_SECRET``- ``TWITTER_CLIENT_ID``- ``TWITTER_CLIENT_SECRET``Note that you have to configure the Twitter app to allow email access,this is not enabled by default... note::    If you want to use OAuth2 providers in development mode (without HTTPS) you    could add the following lines to your ``settings.py``:    .. code-block:: python        if DEBUG:            # NEVER set this variable in production environments!            os.environ[&quot;OAUTHLIB_INSECURE_TRANSPORT&quot;] = &quot;1&quot;    This is required because of the strictness of    `oauthlib &lt;https://pypi.org/project/oauthlib/&gt;`__ which only wants HTTPS    URLs (and rightly so).Use of bundled views====================The following URL patterns are an example for using the bundled views.For now you'll have to dig into the code (it's not much, at the time ofwriting ``django-authlib``'s Python code is less than 500 lines):.. code-block:: python    from django.conf.urls import url    from authlib import views    from authlib.facebook import FacebookOAuth2Client    from authlib.google import GoogleOAuth2Client    from authlib.twitter import TwitterOAuthClient    urlpatterns = [        url(            r&quot;^login/$&quot;,            views.login,            name=&quot;login&quot;,        ),        url(            r&quot;^oauth/facebook/$&quot;,            views.oauth2,            {                &quot;client_class&quot;: FacebookOAuth2Client,            },            name=&quot;accounts_oauth_facebook&quot;,        ),        url(            r&quot;^oauth/google/$&quot;,            views.oauth2,            {                &quot;client_class&quot;: GoogleOAuth2Client,            },            name=&quot;accounts_oauth_google&quot;,        ),        url(            r&quot;^oauth/twitter/$&quot;,            views.oauth2,            {                &quot;client_class&quot;: TwitterOAuthClient,            },            name=&quot;accounts_oauth_twitter&quot;,        ),        url(            r&quot;^email/$&quot;,            views.email_registration,            name=&quot;email_registration&quot;,        ),        url(            r&quot;^email/(?P&lt;code&gt;[^/]+)/$&quot;,            views.email_registration,            name=&quot;email_registration_confirm&quot;,        ),        url(            r&quot;^logout/$&quot;,            views.logout,            name=&quot;logout&quot;,        ),    ]Admin OAuth2============The ``authlib.admin_oauth`` app allows using Google OAuth2 to allow allusers with the same email domain to authenticate for Django'sadministration interface. You have to use authlib's authenticationbackend (``EmailBackend``) for this.Installation is as follows:- Follow the steps in the &quot;Usage&quot; section above.- Add ``authlib.admin_oauth`` to your ``INSTALLED_APPS`` before  ``django.contrib.admin``, so that our login template is picked up.- Add ``GOOGLE_CLIENT_ID`` and ``GOOGLE_CLIENT_SECRET`` to your settings  as described above.- Add a ``ADMIN_OAUTH_PATTERNS`` setting. The first item is the domain,  the second the email address of a staff account. If no matching staff  account exists, authentication fails:.. code-block:: python    ADMIN_OAUTH_PATTERNS = [        (r&quot;@example\.com$&quot;, &quot;admin@example.com&quot;),    ]- Add an entry to your URLconf:.. code-block:: python    urlpatterns = [        url(r&quot;&quot;, include(&quot;authlib.admin_oauth.urls&quot;)),        # ...    ]- Add ``https://yourdomain.com/admin/__oauth__/`` as a valid redirect  URI in your Google developers console.Please note that the ``authlib.admin_oauth.urls`` module assumes that the adminsite is registered at ``/admin/``. If this is not the case you can integratethe view yourself under a different URL.It is also allowed to use a callable instead of the email address in the``ADMIN_OAUTH_PATTERNS`` setting; the callable is passed the result of matchingthe regex. If a resulting email address does not exist, authentication (ofcourse) fails:.. code-block:: python    ADMIN_OAUTH_PATTERNS = [        (r&quot;^.*@example\.org$&quot;, lambda match: match[0]),    ]If a pattern succeeds but no matching user with staff access is foundprocessing continues with the next pattern. This means that you canauthenticate users with their individual accounts (if they have one) andfall back to an account for everyone having a Google email address onyour domain:.. code-block:: python    ADMIN_OAUTH_PATTERNS = [        (r&quot;^.*@example\.org$&quot;, lambda match: match[0]),        (r&quot;@example\.com$&quot;, &quot;admin@example.com&quot;),    ]You could also remove the fallback line; in this case users can onlyauthenticate if they have a personal staff account.Little Auth===========The ``authlib.little_auth`` app contains a basic user model with emailas username that can be used if you do not want to write your own usermodel but still profit from authlib's authentication support.Usage is as follows:- Add ``authlib.little_auth`` to your ``INSTALLED_APPS``- Set ``AUTH_USER_MODEL = &quot;little_auth.User&quot;``- Optionally also follow any of the steps above.Email Registration==================For email registration to work, two templates are needed:* ``registration/email_registration_email.txt``* ``registration/email_registration.html``A starting point would be:``email_registration_email.txt``:.. code-block:: text    Subject (1st line)    Body (3rd line onwards)    {{ url }}    ...``email_registration.html``:.. code-block:: html    {% if messages %}    &lt;ul class=&quot;messages&quot;&gt;        {% for message in messages %}        &lt;li{% if message.tags %} class=&quot;{{ message.tags }}&quot;{% endif %}&gt;            {% if message.level == DEFAULT_MESSAGE_LEVELS.ERROR %}Important: {% endif %}            {{ message }}        &lt;/li&gt;        {% endfor %}    &lt;/ul&gt;    {% endif %}    {% if form.errors and not form.non_field_errors %}    &lt;p class=&quot;errornote&quot;&gt;        {% if form.errors.items|length == 1 %}        {% translate &quot;Please correct the error below.&quot; %}        {% else %}        {% translate &quot;Please correct the errors below.&quot; %}        {% endif %}    &lt;/p&gt;    {% endif %}    {% if form.non_field_errors %}    {% for error in form.non_field_errors %}    &lt;p class=&quot;errornote&quot;&gt;        {{ error }}    &lt;/p&gt;    {% endfor %}    {% endif %}    &lt;form action='{% url &quot;email_registration&quot; %}' method=&quot;post&quot; &gt;        {% csrf_token %}        &lt;table&gt;            {{ form }}        &lt;/table&gt;        &lt;input type=&quot;submit&quot; value=&quot;login&quot;&gt;    &lt;/form&gt;The above template is inspired from:* `Messages Django documentation &lt;https://docs.djangoproject.com/en/dev/ref/contrib/messages/#displaying-messages&gt;`_* `Django login template &lt;https://github.com/django/django/blob/67d0c4644acfd7707be4a31e8976f865509b09ac/django/contrib/admin/templates/admin/login.html#L21-L44&gt;`_More details are documented in `the relevant module &lt;https://github.com/matthiask/django-authlib/blob/main/authlib/email.py&gt;`_.</longdescription>
</pkgmetadata>