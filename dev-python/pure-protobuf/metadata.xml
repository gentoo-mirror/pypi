<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># `pure-protobuf`[![Build Status](https://github.com/eigenein/protobuf/workflows/check/badge.svg)](https://github.com/eigenein/protobuf/actions)[![Coverage Status](https://coveralls.io/repos/github/eigenein/protobuf/badge.svg?branch=master)](https://coveralls.io/github/eigenein/protobuf?branch=master)[![PyPI - Downloads](https://img.shields.io/pypi/dm/pure-protobuf.svg)](https://pypistats.org/packages/pure-protobuf)[![PyPI – Version](https://img.shields.io/pypi/v/pure-protobuf.svg)](https://pypi.org/project/pure-protobuf/#history)[![PyPI – Python](https://img.shields.io/pypi/pyversions/pure-protobuf.svg)](https://pypi.org/project/pure-protobuf/#files)[![License](https://img.shields.io/pypi/l/pure-protobuf.svg)](https://github.com/eigenein/protobuf/blob/master/LICENSE)This guide describes how to use `pure-protobuf` to structure your data. It tries to follow [the standard developer guide](https://developers.google.com/protocol-buffers/docs/proto3). It also assumes that you're familiar with Protocol Buffers.### Defining a message typeLet's look at [the simple example](https://developers.google.com/protocol-buffers/docs/proto3#simple). Here's how it looks like in `proto3` syntax:```protosyntax = &quot;proto3&quot;;message SearchRequest {  string query = 1;  int32 page_number = 2;  int32 result_per_page = 3;}```And this is how you define it with `pure-protobuf`:```pythonfrom dataclasses import dataclassfrom pure_protobuf.dataclasses_ import field, messagefrom pure_protobuf.types import int32@message@dataclassclass SearchRequest:    query: str = field(1, default='')    page_number: int32 = field(2, default=int32(0))    result_per_page: int32 = field(3, default=int32(0))   assert SearchRequest(    query='hello',    page_number=int32(1),    result_per_page=int32(10),).dumps() == b'\x0A\x05hello\x10\x01\x18\x0A'```Keep in mind that `@message` decorator **must** stay on top of [`@dataclass`](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass).### SerializingEach class wrapped with `@message` gets two methods attached:- `dumps() -&gt; bytes` to serialize message into a byte string- `dump(io: IO)` to serialize message into a file-like object### DeserializingEach classes wrapped with `@message` gets two class methods attached:- `loads(bytes_: bytes) -&gt; TMessage` to deserialize a message from a byte string- `load(io: IO) -&gt; TMessage` to deserialize a message from a file-like objectThese methods are also available as standalone functions in `pure_protobuf.dataclasses_`:- `load(cls: Type[T], io: IO) -&gt; T`- `loads(cls: Type[T], bytes_: bytes) -&gt; T`### Specifying field typesIn `pure-protobuf` types are specified with [type hints](https://www.python.org/dev/peps/pep-0484/). Native Python `float`, `str`, `bytes` and `bool` types are supported. Since other Protocol Buffers types don't exist as native Python types, the package uses [`NewType`](https://docs.python.org/3/library/typing.html#newtype) to define them. They're available via `pure_protobuf.types` and named in the same way.### Assigning field numbersField numbers are provided via the `metadata` parameter of the [`field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field) function: `field(..., metadata={'number': number})`. However, to improve readability and save some characters, `pure-protobuf` provides a helper function `pure_protobuf.dataclasses_.field` which accepts field number as the first positional parameter and just passes it to the standard `field` function.### Specifying field rules[`typing.List`](https://docs.python.org/3/library/typing.html#typing.List) and [`typing.Iterable`](https://docs.python.org/3/library/typing.html#typing.Iterable) annotations are automatically converted to [repeated fields](https://developers.google.com/protocol-buffers/docs/proto3#specifying-field-rules). Repeated fields of scalar numeric types use packed encoding by default:```pythonfrom dataclasses import dataclassfrom typing import Listfrom pure_protobuf.dataclasses_ import field, messagefrom pure_protobuf.types import int32@message@dataclassclass Message:    foo: List[int32] = field(1, default_factory=list)```In case, unpacked encoding is explicitly wanted, the `packed`-argument of `field` can be used as in:```pythonfrom dataclasses import dataclassfrom typing import Listfrom pure_protobuf.dataclasses_ import field, messagefrom pure_protobuf.types import int32@message@dataclassclass Message:    foo: List[int32] = field(1, default_factory=list, packed=False)```It's also possible to wrap a field type with [`typing.Optional`](https://docs.python.org/3/library/typing.html#typing.Optional). If `None` is assigned to an `Optional` field, then the field will be skipped during serialization.### Default valuesIn `pure-protobuf` it's developer's responsibility to take care of default values. If encoded message does not contain a particular element, the corresponding field stays unassigned. It means that the standard `default` and `default_factory` parameters of the `field` function work as usual:```pythonfrom dataclasses import dataclassfrom typing import Optionalfrom pure_protobuf.dataclasses_ import field, messagefrom pure_protobuf.types import int32@message@dataclassclass Foo:    bar: int32 = field(1, default=42)    qux: Optional[int32] = field(2, default=None)assert Foo().dumps() == b'\x08\x2A'assert Foo.loads(b'') == Foo(bar=42)```In fact, the pattern `qux: Optional[int32] = field(2, default=None)` is so common that there's a convenience function `optional_field` to define an `Optional` field with `None` value by default:```pythonfrom dataclasses import dataclassfrom typing import Optionalfrom pure_protobuf.dataclasses_ import optional_field, messagefrom pure_protobuf.types import int32@message@dataclassclass Foo:    qux: Optional[int32] = optional_field(2)assert Foo().dumps() == b''assert Foo.loads(b'') == Foo(qux=None)```### EnumerationsSubclasses of the standard [`IntEnum`](https://docs.python.org/3/library/enum.html#intenum) class are supported:```pythonfrom dataclasses import dataclassfrom enum import IntEnumfrom pure_protobuf.dataclasses_ import field, messageclass TestEnum(IntEnum):    BAR = 1@message@dataclassclass Test:    foo: TestEnum = field(1)assert Test(foo=TestEnum.BAR).dumps() == b'\x08\x01'assert Test.loads(b'\x08\x01') == Test(foo=TestEnum.BAR)```### Using other message typesEmbedded messages are defined the same way as normal dataclasses:```pythonfrom dataclasses import dataclassfrom pure_protobuf.dataclasses_ import field, messagefrom pure_protobuf.types import int32@message@dataclassclass Test1:    a: int32 = field(1, default=0)@message@dataclassclass Test3:    c: Test1 = field(3, default_factory=Test1)assert Test3(c=Test1(a=int32(150))).dumps() == b'\x1A\x03\x08\x96\x01'```### Well-known message types`pure_protobuf.google` also provides built-in definitions for the following [well-known message types](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf):| Annotation   | `pure_protobuf.types.google` | `.proto`    || ------------ | ---------------------------- | ----------- || `datetime`   | `Timestamp`                  | `Timestamp` || `timedelta`  | `Duration`                   | `Duration`  || `typing.Any` | `Any_`                       | `Any`       |They're handled automatically, you have nothing to do but use them normally in type hints:```pythonfrom dataclasses import dataclassfrom datetime import datetimefrom typing import Optionalfrom pure_protobuf.dataclasses_ import field, message@message@dataclassclass Test:    timestamp: Optional[datetime] = field(1, default=None)```#### [`Any`](https://developers.google.com/protocol-buffers/docs/proto3#any)Since `pure-protobuf` is not able to download or parse `.proto` definitions, it provides a limited implementation of the [`Any`](https://developers.google.com/protocol-buffers/docs/proto3#any) message type. That is, you still have to define all message classes in the usual way. Then, `pure-protobuf` will be able to import and instantiate an encoded value:```pythonfrom dataclasses import dataclassfrom typing import Any, Optionalfrom pure_protobuf.dataclasses_ import field, messagefrom pure_protobuf.types.google import Timestamp@message@dataclassclass Message:    value: Optional[Any] = field(1)# Here `Timestamp` is used just as an example, in principle any importable user type works.message = Message(value=Timestamp(seconds=42))assert Message.loads(message.dumps()) == message```</longdescription>
</pkgmetadata>