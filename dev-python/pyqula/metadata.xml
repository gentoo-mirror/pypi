<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># SUMMARY #This is a **Py**thon library to compute **qu**antum-**la**ttice tight-binding models in different dimensionalities.# INSTALLATION ### With pip (release version) ##```bashpip install --upgrade pyqula```## Manual installation (most recent version) ##Clone the Github repository with```bashgit clone https://github.com/joselado/pyqula```and add the &quot;pyqula/src&quot; path to your Python script with```pythonimport syssys.path.append(PATH_TO_PYQULA+&quot;/src&quot;)```# Tutorials #Jupyter notebooks with tutorials can be found in the links below (part of the [Jyvaskyla Summer School 2022](https://github.com/joselado/jyvaskyla_summer_school_2022) )- [Electronic structure](https://github.com/joselado/jyvaskyla_summer_school_2022/blob/main/sessions/session1.ipynb)- [Superconductivity](https://github.com/joselado/jyvaskyla_summer_school_2022/blob/main/sessions/session2.ipynb)- [Magnetism](https://github.com/joselado/jyvaskyla_summer_school_2022/blob/main/sessions/session3.ipynb)- [Moire physics](https://github.com/joselado/jyvaskyla_summer_school_2022/blob/main/sessions/session4.ipynb)- [Topological matter](https://github.com/joselado/jyvaskyla_summer_school_2022/blob/main/sessions/session5.ipynb)# FUNCTIONALITIES ### Single particle Hamiltonians ##- Spinless, spinful and Nambu basis for orbitals- Full non-collinear electron and Nambu formalism- Include magnetism, spin-orbit coupling and superconductivity- Band structures with state-resolved expectation values- Momentum-resolved spectral functions- Local and full operator-resolved density of states- 0d, 1d, 2d and 3d tight binding models - Electronic structure unfolding in supercells## Interacting mean-field Hamiltonians ##- Selfconsistent mean-field calculations with local/non-local interactions- Both collinear and non-collinear formalism- Anomalous mean-field for non-collinear superconductors- Full selfconsistency with all Wick terms for non-collinear superconductors- Constrained and unconstrained mean-field calculations- Automatic identification of order parameters for symmetry broken states- Hermitian and non-Hermitian mean-field calculations## Topological characterization ##- Berry phases, Berry curvatures, Chern numbers and Z2 invariants- Operator-resolved Chern numbers and Berry density- Frequency resolved topological density- Spatially resolved topological flux- Real-space Chern density for amorphous systems- Wilson loop and Green's function formalism## Spectral functions ##- Spectral functions in infinite geometries- Surface spectral functions for semi-infinite systems- Interfacial spectral function in semi-infinite junctions- Single impurities in infinite systems- Operator-resolved spectral functions- Green's function renormalization algorithm## Chebyshev kernel polynomial based-algorithms ##- Local and full spectral functions- Non-local correlators and Green's functions- Locally resolved expectation values- Operator resolved spectral functions- Reaching system sizes up to 10000000 atoms on a single-core laptop## Quantum transport ##- Metal-metal transport- Metal-superconductor transport- Fully non-collinear Nambu basis- Non-equilibrium Green's function formalism- Operator-resolved transport- Differential decay rate- Tunneling and contact scanning probe spectroscopy# EXAMPLES #A variety of examples can be found in pyqula/examples. Short examples are shown below## Band structure of a Kagome lattice```pythonfrom pyqula import geometryg = geometry.kagome_lattice() # get the geometry objecth = g.get_hamiltonian() # get the Hamiltonian object(k,e) = h.get_bands() # compute the band structure```![Alt text](images/kagome.png?raw=true &quot;Band structure of a Kagome lattice&quot;)## Valley-resolved band structure of a honeycomb superlattice```pythonfrom pyqula import geometryg = geometry.honeycomb_lattice() # get the geometry objectg = g.get_supercell(7) # create a supercellh = g.get_hamiltonian() # get the Hamiltonian object(k,e,v) = h.get_bands(operator=&quot;valley&quot;) # compute the band structure```![Alt text](images/valley_supercell.png?raw=true &quot;Valley-resolved band structure of a honeycomb superlattice&quot;)## Interaction-driven spin-singlet superconductivity```pythonfrom pyqula import geometryimport numpy as npg = geometry.triangular_lattice() # geometry of a triangular latticeh = g.get_hamiltonian()  # get the Hamiltonianh.setup_nambu_spinor() # setup the Nambu form of the Hamiltonianh = h.get_mean_field_hamiltonian(U=-1.0,filling=0.15,mf=&quot;swave&quot;) # perform SCF# electron spectral-functionh.get_kdos_bands(operator=&quot;electron&quot;,nk=400,energies=np.linspace(-1.0,1.0,100))```![Alt text](images/scf_SC.png?raw=true &quot;Interaction-driven superconductivity&quot;)## Interaction driven non-unitary spin-triplet superconductor```pythonimport numpy as npfrom pyqula import geometryg = geometry.triangular_lattice() # generate the geometryh = g.get_hamiltonian() # create Hamiltonian of the systemh.add_exchange([0.,0.,1.]) # add exchange fieldh.setup_nambu_spinor() # initialize the Nambu basis# perform a superconducting non-collinear mean-field calculationh = h.get_mean_field_hamiltonian(V1=-1.0,filling=0.3,mf=&quot;random&quot;)# compute the non-unitarity of the spin-triplet superconducting d-vectord = h.get_dvector_non_unitarity() # non-unitarity of spin-triplet# electron spectral-functionh.get_kdos_bands(operator=&quot;electron&quot;,nk=400,energies=np.linspace(-2.0,2.0,400))```![Alt text](images/scf_SC_triplet.png?raw=true &quot;Interaction driven non-unitary spin-triplet superconductor&quot;)## Mean-field with local interactions of a zigzag honeycomb ribbon```pythonfrom pyqula import geometryg = geometry.honeycomb_zigzag_ribbon(10) # create geometry of a zigzag ribbonh = g.get_hamiltonian() # create hamiltonian of the systemh = h.get_mean_field_hamiltonian(U=1.0,filling=0.5,mf=&quot;ferro&quot;)(k,e,sz) = h.get_bands(operator=&quot;sz&quot;) # calculate band structure```![Alt text](images/scf_zigzag.png?raw=true &quot;Mean-field with local interactions of a zigzag honeycomb ribbon&quot;)## Non-collinear mean-field with local interactions of a square lattice```pythonfrom pyqula import geometryg = geometry.square_lattice() # geometry of a square latticeg = g.get_supercell([2,2]) # generate a 2x2 supercellh = g.get_hamiltonian() # create hamiltonian of the systemh.add_zeeman([0.,0.,0.1]) # add out-of-plane Zeeman fieldh = h.get_mean_field_hamiltonian(U=2.0,filling=0.5,mf=&quot;random&quot;) # perform SCF(k,e,c) = h.get_bands(operator=&quot;sz&quot;) # calculate band structurem = h.get_magnetization() # get the magnetization```![Alt text](images/scf_square.png?raw=true &quot;Non-collinear mean-field interactions with local interactions of a square lattice&quot;)## Interaction-induced non-collinear magnetism in a defective square lattice with spin-orbit coupling```pythonfrom pyqula import geometryg = geometry.square_lattice() # geometry of a square latticeg = g.get_supercell([7,7]) # generate a 7x7 supercellg = g.remove(i=g.get_central()[0]) # remove the central siteh = g.get_hamiltonian() # create hamiltonian of the systemh.add_rashba(.4) # add Rashba spin-orbit couplingh = h.get_mean_field_hamiltonian(U=2.0,filling=0.5,mf=&quot;random&quot;) # perform SCF(k,e,c) = h.get_bands(operator=&quot;sz&quot;) # calculate band structurem = h.get_magnetization() # get the magnetization```![Alt text](images/scf_square_vacancy.png?raw=true &quot;Interaction-induced non-collinear magnetism in a defective square lattice with spin-orbit coupling&quot;)## Band structure of twisted bilayer graphene```pythonfrom pyqula import specialhamiltonian # special Hamiltonians libraryh = specialhamiltonian.twisted_bilayer_graphene() # TBG Hamiltonian(k,e) = h.get_bands() # compute band structure```![Alt text](images/tbg.png?raw=true &quot;Band structure of twisted bilayer graphene&quot;)## Band structure of monolayer NbSe2```pythonfrom pyqula import specialhamiltonian # special Hamiltonians libraryh = specialhamiltonian.NbSe2(soc=0.5) # NbSe2 Hamiltonian(k,e,c) = h.get_bands(operator=&quot;sz&quot;,kpath=[&quot;G&quot;,&quot;K&quot;,&quot;M&quot;,&quot;G&quot;]) # compute bands```![Alt text](images/NbSe2.png?raw=true &quot;Band structure of monolayer NbSe2&quot;)## Chern number of an artificial Chern insulator```pythonfrom pyqula import geometryg = geometry.honeycomb_lattice()h = g.get_hamiltonian()h.add_rashba(0.2) # Rashba spin-orbit couplingh.add_zeeman([0.,0.,0.6]) # Zeeman fieldfrom pyqula import topology(kx,ky,omega) = h.get_berry_curvature() # compute Berry curvaturec = h.get_chern() # compute the Chern number```![Alt text](images/berry_curvature.png?raw=true &quot;Chern number of an artificial Chern insulator&quot;)## Topological phase transition in an artificial topological superconductor```pythonimport numpy as npfrom pyqula import geometryg = geometry.chain() # create a chaing = g.supercell(100) # create a large supercellg.dimensionality = 0 # make it finitefor J in np.linspace(0.,0.2,50): # loop over exchange couplings    h = g.get_hamiltonian() # create a new hamiltonian    h.add_onsite(2.0) # shift the chemical potential    h.add_rashba(.3) # add rashba spin-orbit coupling    h.add_exchange([0.,0.,J]) # add exchange coupling    h.add_swave(.1) # add s-wave superconductivity    edge = h.get_operator(&quot;location&quot;,r=g.r[0]) # projector on the edge    energies = np.linspace(-.2,.2,200) # set of energies    (e0,d0) = h.get_dos(operator=edge,energies=energies,delta=2e-3) # edge DOS```![Alt text](images/TSC.png?raw=true &quot;Topological phase transition in an artificial topological superconductor&quot;)## Spatial distribution of Majorana modes in an artificial topological superconductor```pythonimport numpy as npfrom pyqula import geometryg = geometry.chain() # create a chaing = g.supercell(100) # create a large supercellg.dimensionality = 0 # make it finiteh = g.get_hamiltonian() # create a new hamiltonianh.add_onsite(2.0) # shift the chemical potentialh.add_rashba(.3) # add rashba spin-orbit couplingh.add_exchange([0.,0.,0.15]) # add exchange couplingh.add_swave(.1) # add s-wave superconductivityenergies = np.linspace(-.15,.15,200) # set of energiesfor ri in g.r: # loop over sites    edge = h.get_operator(&quot;location&quot;,r=ri) # projector on that site    (e0,d0) = h.get_dos(operator=edge,energies=energies,delta=2e-3) # local DOS```![Alt text](images/TSC_spatial.png?raw=true &quot;Spatial distribution of Majorana modes in an artificial topological superconductor&quot;)## Unfolded electronic structure of a supercell with a defect```pythonfrom pyqula import geometryimport numpy as npg = geometry.honeycomb_lattice() # create a honeycomb latticen = 3 # size of the supercellg = g.get_supercell(n,store_primal=True) # create a supercellh = g.get_hamiltonian() # get the Hamiltonianfons = lambda r: (np.sum((r - g.r[0])**2)&lt;1e-2)*100 # onsite in the impurityh.add_onsite(fons) # add onsite energykpath = np.array(g.get_kpath(nk=200))*n # enlarged k-pathh.get_kdos_bands(operator=&quot;unfold&quot;,delta=1e-1,kpath=kpath) # unfolded bands```![Alt text](images/unfolded.png?raw=true &quot;Unfolded electronic structure of a supercell with a defect&quot;)## Moire band structure of a moire superlattice```pythonfrom pyqula import geometryfrom pyqula import potentialsg = geometry.triangular_lattice() # create geometryg = g.get_supercell([7,7]) # create a supercellh = g.get_hamiltonian() # get the Hamiltonianfmoire = potentials.commensurate_potential(g,n=3,minmax=[0,1]) # moire potentialh.add_onsite(fmoire) # add onsite energy following the moireh.get_bands(operator=fmoire) # project on the moire```![Alt text](images/moire_bands.png?raw=true &quot;Moire band structure of a moire superstructure&quot;)## Unfolded electronic structure of a moire superstructure```pythonfrom pyqula import geometryfrom pyqula import potentialsimport numpy as npg0 = geometry.triangular_lattice() # create geometryn = 5 # supercellg = g0.get_supercell(n,store_primal=True) # create a supercellh = g.get_hamiltonian() # get the Hamiltonianfmoire = potentials.commensurate_potential(g,n=3,minmax=[0,1]) # moire potentialh.add_onsite(fmoire) # add onsite energy following the moirekpath = np.array(g.get_kpath(nk=400))*n # enlarged k-pathh.get_kdos_bands(operator=&quot;unfold&quot;,delta=2e-2,kpath=kpath,                  energies=np.linspace(-3,-1,300)) # unfolded bands```![Alt text](images/unfolding_moire.png?raw=true &quot;Unfolded electronic structure of a moire superstructure&quot;)## Band structure of a nodal line semimetal slab```pythonfrom pyqula import geometryfrom pyqula import filmsg = geometry.diamond_lattice()g = films.geometry_film(g,nz=20)h = g.get_hamiltonian()(k,e) = h.get_bands()```![Alt text](images/NLSM.png?raw=true &quot;Band structure of a nodal line semimetal slab&quot;)## Band structure of a three dimensional topological insulator slab```pythonfrom pyqula import geometryfrom pyqula import filmsimport numpy as npg = geometry.diamond_lattice() # create a diamond latticeg = films.geometry_film(g,nz=60) # create a thin filmh = g.get_hamiltonian() # generate Hamiltonianh.add_strain(lambda r: 1.+abs(r[2])*0.8,mode=&quot;directional&quot;) # add axial strainh.add_kane_mele(0.1) # add intrinsic spin-orbit coupling(k,e,c)= h.get_bands(operator=&quot;surface&quot;) # compute band structure```![Alt text](images/3DTI.png?raw=true &quot;Band structure of a three dimensional topological insulator&quot;)## Surface spectral function of a 2D quantum spin-Hall insulator```pythonfrom pyqula import geometryg = geometry.honeycomb_lattice() # create a honeycomb latticeh = g.get_hamiltonian() # generate Hamiltonianh.add_soc(0.15) # add intrinsic spin-orbit couplingh.add_rashba(0.1) # add Rashba spin-orbit couplingh.get_surface_kdos(delta=1e-2) # compute surface spectral function```![Alt text](images/2DTI.png?raw=true &quot;Surface spectral function of a 2D quantum spin-Hall insulator&quot;)## Local density of states with atomic orbitals of a honeycomb nanoisland```pythonfrom pyqula import islandsg = islands.get_geometry(name=&quot;honeycomb&quot;,n=3,nedges=3) # get an islandh = g.get_hamiltonian() # get the Hamiltonianh.get_multildos(projection=&quot;atomic&quot;) # get the LDOS```![Alt text](images/ldos_island.png?raw=true &quot;Local density of states with atomic orbitals of a honeycomb nanoisland&quot;)## Interaction-driven magnetism in a honeycomb nanoisland```pythonfrom pyqula import islandsg = islands.get_geometry(name=&quot;honeycomb&quot;,n=3,nedges=3) # get an islandh = g.get_hamiltonian() # get the Hamiltonianh = h.get_mean_field_hamiltonian(U=1.0,filling=0.5,mf=&quot;ferro&quot;) # perform SCFm = h.get_magnetization() # get the magnetization in each site```![Alt text](images/scf_island.png?raw=true &quot;Interaction-driven magnetism in a honeycomb nanoisland&quot;)## Hofstadter's butterfly of a square lattice```pythonimport numpy as npfrom pyqula import geometryg = geometry.square_ribbon(40) # create square ribbon geometryfor B in np.linspace(0.,1.0,300): # loop over magnetic field    h = g.get_hamiltonian() # create a new hamiltonian    h.add_orbital_magnetic_field(B) # add an orbital magnetic field    # calculate DOS projected on the bulk    (e,d) = h.get_dos(operator=&quot;bulk&quot;,energies=np.linspace(-4.5,4.5,200))```![Alt text](images/hofstadter.png?raw=true &quot;Hofstadter's butterfly of a square lattice&quot;)## Landau levels of a Dirac semimetal```pythonimport numpy as npfrom pyqula import geometryg = geometry.honeycomb_ribbon(30) # create a honeycomb ribbonfor B in np.linspace(0.,0.02,100): # loop over magnetic field    h = g.get_hamiltonian() # create a new hamiltonian    h.add_orbital_magnetic_field(B) # add an orbital magnetic field    # calculate DOS projected on the bulk    (e,d) = h.get_dos(operator=&quot;bulk&quot;,energies=np.linspace(-1.0,1.0,200),                       delta=1e-2)```![Alt text](images/LL_Dirac.png?raw=true &quot;Landau levels of a Dirac semimetal&quot;)## Surface spectral function of a Chern insulator```pythonfrom pyqula import geometryfrom pyqula import kdosg = geometry.honeycomb_lattice() # create honeycomb latticeh = g.get_hamiltonian() # create hamiltonian of the systemh.add_haldane(0.05) # Add Haldane couplingkdos.surface(h) # surface spectral function```![Alt text](images/kdos.png?raw=true &quot;Surface spectral function of a Chern insulator&quot;)## Surface states and Berry curvature of a artificial 2D topological superconductor```pythonfrom pyqula import geometryimport numpy as npg = geometry.triangular_lattice() # get the geometryh = g.get_hamiltonian() # get the Hamiltonianh.add_onsite(2.0) # shift chemical potentialh.add_rashba(1.0) # Rashba spin-orbit couplingh.add_zeeman([0.,0.,0.6]) # Zeeman fieldh.add_swave(.3) # add superconductivity(kx,ky,omega) = h.get_berry_curvature() # compute Berry curvatureh.get_surface_kdos(energies=np.linspace(-.4,.4,300)) # surface spectral function```![Alt text](images/2DTSC.png?raw=true &quot;Surface states and Berry curvature of a artificial 2D topological superconductor&quot;)# Surface states in a topological superconductor nanoisland```pythonfrom pyqula import islandsg = islands.get_geometry(name=&quot;triangular&quot;,shape=&quot;flower&quot;,                           r=14.2,dr=2.0,nedges=6) # get a flower-shaped islandh = g.get_hamiltonian() # get the Hamiltonianh.add_onsite(3.0) # shift chemical potentialh.add_rashba(1.0) # Rashba spin-orbit couplingh.add_zeeman([0.,0.,0.6]) # Zeeman fieldh.add_swave(.3) # add superconductivityh.get_ldos() # Spatially resolved DOS```![Alt text](images/island_TSC.png?raw=true &quot;Surface states in a topological superconductor nanoisland&quot;)## Antiferromagnet-superconductor interface```pythonfrom pyqula import geometryg = geometry.honeycomb_zigzag_ribbon(20) # create geometry of a zigzag ribbonh = g.get_hamiltonian(has_spin=True) # create hamiltonian of the systemh.add_antiferromagnetism(lambda r: (r[1]&gt;0)*0.5) # add antiferromagnetismh.add_onsite(lambda r: (r[1]&gt;0)*0.3) # add chemical potentialh.add_swave(lambda r: (r[1]&lt;0)*0.3) # add superconductivity(k,e,sz) = h.get_bands(operator=&quot;sz&quot;) # calculate band structure```![Alt text](images/AF_SC.png?raw=true &quot;Antiferromagnet-superconductor interface&quot;)## Fermi surface of a triangular lattice supercell```pythonfrom pyqula import geometryimport numpy as npg = geometry.triangular_lattice() # create geometry of the systemg = g.get_supercell(2) # create a supercellh = g.get_hamiltonian() # create hamiltonian of the systemh.get_multi_fermi_surface(energies=np.linspace(-4,4,100),delta=1e-1)```![Alt text](images/fermi_surface.png?raw=true &quot;Fermi surface of a triangular lattice supercell&quot;)## Unfolded Fermi surface of a supercell with a defect```pythonfrom pyqula import geometryimport numpy as npg0 = geometry.triangular_lattice()n = 3 # size of the supercellg = g0.get_supercell(n,store_primal=True) # create a supercellh = g.get_hamiltonian() # get the Hamiltonianfons = lambda r: (np.sum((r - g.r[0])**2)&lt;1e-2)*100 # onsite in the impurityh.add_onsite(fons) # add onsite energykpath = np.array(g.get_kpath(nk=200))*n # enlarged k-pathh.get_multi_fermi_surface(nk=50,energies=np.linspace(-4,4,100),        delta=0.1,nsuper=n,operator=&quot;unfold&quot;)```![Alt text](images/unfolded_FS.png?raw=true &quot;Unfolded Fermi surface of a supercell with a defect&quot;)## Tunneling and Andreev reflection in a metal-superconductor junction```pythonfrom pyqula import geometryfrom pyqula import heterostructuresimport numpy as npg = geometry.chain() # create the geometryh = g.get_hamiltonian() # create the Hamiltonianh1 = h.copy() # first leadh2 = h.copy() # second leadh2.add_swave(.01) # the second lead is superconductinges = np.linspace(-.03,.03,100) # set of energies for dIdVfor T in np.linspace(1e-3,1.0,6): # loop over transparencies    HT = heterostructures.build(h1,h2) # create the junction    HT.set_coupling(T) # set the coupling between the leads    Gs = [HT.didv(energy=e) for e in es] # calculate conductance```![Alt text](images/andreev.png?raw=true &quot;Tunneling and Andreev reflection in a metal-superconductor junction&quot;)## From tunneling to contact transport of a topological superconductor```pythonfrom pyqula import geometryfrom pyqula import heterostructuresimport numpy as npg = geometry.chain() # create the geometryh = g.get_hamiltonian() # create teh Hamiltonianh1 = h.copy() # first leadh2 = h.copy() # second leadh2.add_onsite(2.0) # shift chemical potential in the second leadh2.add_exchange([0.,0.,.3]) # add exchange in the second leadh2.add_rashba(.3) # add Rashba SOC in the second leadh2.add_swave(.05) # add s-wave SC in the second leades = np.linspace(-.1,.1,100) # grid of energiesfor T in np.linspace(1e-3,0.5,10): # loop over transparencies    HT = heterostructures.build(h1,h2) # create the junction    HT.set_coupling(T) # set the coupling between the leads    Gs = [HT.didv(energy=e) for e in es] # calculate transmission```![Alt text](images/dIdV_TSC.png?raw=true &quot;From tunneling to contact transport of a topological superconductor&quot;)## Single impurity in an infinite honeycomb lattice```pythonfrom pyqula import geometryimport numpy as npfrom pyqula import embeddingg = geometry.honeycomb_lattice() # create geometry h = g.get_hamiltonian() # get the Hamiltonianhv = h.copy() # copy Hamiltonian to create a defective onehv.add_onsite(lambda r: (np.sum((r - g.r[0])**2)&lt;1e-2)*100) # add a defecteb = embedding.Embedding(h,m=hv) # create an embedding object(x,y,d) = eb.ldos(nsuper=19,energy=0.,delta=1e-2) # compute LDOS```![Alt text](images/single_vacancy.png?raw=true &quot;Single impurity in an infinite honeycomb lattice&quot;)## Bound state of a single magnetic impurity in an infinite superconductor```pythonfrom pyqula import geometryimport numpy as npfrom pyqula import embeddingg = geometry.square_lattice() # create geometryh = g.get_hamiltonian() # get the Hamiltonianh.add_swave(0.1) # add s-wave superconductivityh.add_onsite(3.0) # shift chemical potentialhv = h.copy() # copy Hamiltonian to create a defective onehv.add_exchange(lambda r: [0.,0.,(np.sum((r - g.r[0])**2)&lt;1e-2)*6.]) # add magnetic siteeb = embedding.Embedding(h,m=hv) # create an embedding objectei = eb.get_energy_ingap_state() # get energy of the impurity state(x,y,d) = eb.ldos(nsuper=19,energy=ei,delta=1e-3) # compute LDOS```![Alt text](images/single_YSR.png?raw=true &quot;Single magnetic impurity in an infinite superconductor&quot;)## Parity switching of a magnetic impurity in an infinite superconductor```pythonfrom pyqula import geometryfrom pyqula import embeddingimport numpy as npg = geometry.square_lattice() # create geometryfor J in np.linspace(0.,4.0,100): # loop over exchange    h = g.get_hamiltonian() # get the Hamiltonian,spinless    h.add_onsite(3.0) # shift chemical potential    h.add_swave(0.2) # add s-wave superconductivity    hv = h.copy() # copy Hamiltonian to create a defective one    # add magnetic site    hv.add_exchange(lambda r: [0.,0.,(np.sum((r - g.r[0])**2)&lt;1e-2)*J])    eb = embedding.Embedding(h,m=hv) # create an embedding object    energies = np.linspace(-0.4,0.4,100) # energies    d = [eb.dos(nsuper=2,delta=1e-2,energy=ei) for ei in energies] # compute DOS```![Alt text](images/YSR.png?raw=true &quot;Parity switching of a magnetic impurity in an infinite superconductor&quot;)</longdescription>
</pkgmetadata>