<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># MyDict&gt; Version 2.X is a breaking-API step regarding the functions that transforms the MyDict object into/from something else. Those methods have been moved to another module: mydict.jsonify. Everything else remains the same, and Python 2.X is totally discouraged at this point.A **Python** _dict_ subclass which tries to act like **JavaScript** objects, so you can use the **dot notation** (_d.foo_) to access members of the object. If the member doesn't exist yet then it's created when you assign a value to it. Brackets notation (_d['foo']_) is also accepted.## Installation```shell$ pip install mydict```## ExamplesLet's give it a try.```pythond = MyDict()d.foo = 'bar'print(d.foo)# ==&gt; 'bar'```If you try to get the value of a non-existing member then a _None_ value is returned```pythond = MyDict()if d.foo is None:    print('&quot;foo&quot; does not exist yet!')```If that value is &quot;complex&quot; (a _dict_ or another _MyDict_ instance), then it's also **recursively** transformed into a _MyDict_ object, so you can access it in the same way```pythond = MyDict()d.foo = {'bar': 'baz', 'lst': [{'a': 123}]}print(d.foo.bar)# ==&gt; 'baz'print(d.foo.lst[0].a)# ==&gt; 123```Values in lists are accessed, as you expect, with the brackets notation (_d[0]_):```pythond = MyDict()d.foo = [1, 2, 3]print(d.foo[2])# ==&gt; 3```We can instantiate it from a _dict_ of any level of complexity:```pythond = MyDict({'foo': 'bar', 'baz': [1, 2, {'foo': 'bar', 'baz': 'Hello, world!'}]})print(d.foo)# ==&gt; 'bar'print(d.baz[0])# ==&gt; 1print(d.baz[2].foo)# ==&gt; 'bar'```with keywords in the _constructor_:```pythond = MyDict(a=1, b=2.2, c=[1, 2, 3], d=[{'x': 1, 'y': [100, 200, 300]}])# ...d.a == 1d.b == 2.2d.c[0] == 1d.d[0].x == 1d.d[0].y[1] == 200```or both:```pythond = MyDict({'foo': 'bar'}, baz=123)# ...d.foo == 'bar'd.baz == 123```Please, take into account that keyword initialization has precedence over the _dict_ (first parameter of the _constructor_):```pythond = MyDict({'foo': 'bar'}, foo='BAR')# ...d.foo == 'BAR'```It's also possible to access members using a _path_ with **get** or _brackets notation_ (_d['...']_):```pythond = MyDict(foo={'bar': 'baz'})# ...d['foo.bar'] == 'baz'd.get('foo.bar') == 'baz'```But when those keys _with dots_ exists in the tree they are accessed using the corresponding key:```pythond = MyDict({'foo.bar': 'baz'})# ...# 'foo.bar' is not interpreted as a path because the key existsd['foo.bar'] = 'baz'```But there's a particular case, if a _dotted key_ exists and match an existing _path_, then this ain't work properly, or work in a different way depending on the method of access used, to be correct:```pythond = MyDict({'foo': {'bar': 'baz'}, 'foo.bar': 'BAZ'})# ...d['foo.bar'] = 'BAZ'  # the &quot;dotted field&quot; ('foo.bar') has precedence over the pathd.foo.bar = 'baz'  # it's not possible to detect a &quot;dotted key&quot; using &quot;dot notation&quot;```Personally, I don't see this as a great issue because I generally avoid using dots in keys, like in the previous case.#### TransformationYou have at your disposal a couple of functions to retrieve the **MyDict** object transformed into _something else_. For the **version 2** the original methods (to_json, from_json, get_dict) have been moved to another module: *mydict.jsonify*.##### Types of caseThe available types of case are: - *mydict.SNAKE_CASE* : *snake_case* - *mydict.CAMEL_CASE* : *camelCase* - *mydict.PASCAL_CASE* : *PascalCase*More on this later on.##### mydict.jsonify.to_jsonReturns the **MyDict** object as a _JSON_ string (_str_):```pythond = MyDict(foo=&quot;bar&quot;, arr=[1, 2, {&quot;three&quot;: 3}])mydict.jsonify.to_json(d)# '{&quot;foo&quot;: &quot;bar&quot;, &quot;arr&quot;: [1, 2, {&quot;three&quot;: 3}]}'```In addition, it's also possible to handle the _case type_ of the keys inside the object. For example, we can use *snake_case* in **MyDict** object and then &quot;export&quot; it with those keys in *camelCase*. Let's see it in action:```pythond = MyDict(my_foo='bar', my_arr=[1, 2, {&quot;other_key&quot;: 3}])mydict.jsonify.to_json(d, case_type=mydict.CAMEL_CASE)# '{&quot;myFoo&quot;: &quot;bar&quot;, &quot;myArr&quot;: [1, 2, {&quot;otherKey&quot;: 3}]}'```##### mydict.jsonify.get_dictIn some occasions you'll need a _plain old_ Python _dict_ representation of the **MyDict** object, though is a _dict_ subclass:```pythond = MyDict(foo=&quot;bar&quot;, arr=[{&quot;one&quot;: 1}, {&quot;two&quot;: 2}])mydict.jsonify.get_dict(d)# {'foo': 'bar', 'arr': [{'one': 1}, {'two': 2}]}```In addition, it's also possible to handle the **case type** of the keys inside the object, in the same way **to_json** works. For example, we can use *snake_case* in **MyDict** object and then &quot;export&quot; it with those keys in *camelCase*. Let's see it in action:```pythond = MyDict(my_foo='bar', my_arr=[1, 2, {&quot;other_key&quot;: 3}])mydict.jsonify.get_dict(d, case_type=mydict.CAMEL_CASE)# {'myArr': [1, 2, {'otherKey': 3}], 'myFoo': 'bar'}```#### Initialization from JSONIt's also possible to load a JSON from _str_, _bytes_, and file-like objects (with a _.read()_ method) using the function **mydict.jsonify.from_json**:```pythond = mydict.jsonify.from_json('{&quot;foo&quot;: &quot;bar&quot;}')# d.foo == 'bar'd = mydict.jsonify.from_json(b'{&quot;foo&quot;: &quot;bar&quot;}')# d.foo == 'bar'd = mydict.jsonify.from_json(open('/path/to/file.json', 'r'))# d = mydict.jsonify.from_json(open('/path/to/file.json', 'rb')) also works``````pythonfrom io import StringIO, BytesIOs = StringIO()s.write('{&quot;foo&quot;: &quot;bar&quot;}')d_from_s = mydict.jsonify.from_json(s)# d_from_s.foo == 'bar'b = BytesIO()b.write(b'{&quot;foo&quot;: &quot;bar&quot;}')# b.write('{&quot;foo&quot;: &quot;bar&quot;}'.encode('utf8')) is equivalentd_from_b = mydict.jsonify.from_json(b)# d_from_b.foo == 'bar'```Please, notice whether the _source_ is string or bytes the result is always *string*.In addition, there's also a param *case_type* in the **from_json** function. It works in the same way we previously mentioned for **to_json** and **get_dict**. For example:```pythond = mydict.jsonify.from_json('{&quot;myFoo&quot;: &quot;bar&quot;, &quot;myArr&quot;: [1, 2, {&quot;otherKey&quot;: 3}]}', case_type=mydict.SNAKE_CASE)# d.my_foo == 'bar'# d.my_arr == [1, 2, {'other_key': 3}]# d.my_arr[2].other_key == 3```Very useful when we collect data from an API which uses _camelCase_ for its keys but we want a more _pythonic_ way for those keys.The tests passed successfully with **Python 3.6**. **Python 2.X** is totally discouraged at this stage of the library. We recommend using **Python +3.X**```shell$ pytest mydict -v```</longdescription>
</pkgmetadata>