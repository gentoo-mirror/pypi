<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Basicco=======.. image:: https://github.com/brunonicko/basicco/workflows/MyPy/badge.svg   :target: https://github.com/brunonicko/basicco/actions?query=workflow%3AMyPy.. image:: https://github.com/brunonicko/basicco/workflows/Lint/badge.svg   :target: https://github.com/brunonicko/basicco/actions?query=workflow%3ALint.. image:: https://github.com/brunonicko/basicco/workflows/Tests/badge.svg   :target: https://github.com/brunonicko/basicco/actions?query=workflow%3ATests.. image:: https://readthedocs.org/projects/basicco/badge/?version=stable   :target: https://basicco.readthedocs.io/en/stable/.. image:: https://img.shields.io/github/license/brunonicko/basicco?color=light-green   :target: https://github.com/brunonicko/basicco/blob/master/LICENSE.. image:: https://static.pepy.tech/personalized-badge/basicco?period=total&amp;units=international_system&amp;left_color=grey&amp;right_color=brightgreen&amp;left_text=Downloads   :target: https://pepy.tech/project/basicco.. image:: https://img.shields.io/pypi/pyversions/basicco?color=light-green&amp;style=flat   :target: https://pypi.org/project/basicco/Overview--------`Base Classes`_ and `Utilities`_ for compatibility, features and validation.Motivation----------While developing Python software for Visual Effects pipelines, I found myself having towrite the same boiler-plate code over and over again, as well as struggling withcompatibility issues and feature gaps between Python 2.7 and Python 3.7+.So I decided to implement solutions for those issues at the `Base`_, and `basicco`was born.Base Classes------------CompatBase^^^^^^^^^^The goal with the `CompatBaseMeta` metaclass and the `CompatBase` class is to bridgesome of the feature gaps between Python 2.7 and Python 3.7+.This includes adding Python 2.7 workarounds for:  - `Abstract properties &lt;https://docs.python.org/3/library/abc.html#abc.abstractproperty&gt;`_:    Better `abstractmethod` decorator support for property-like descriptors.    See also `abstract_class`_.  - `PEP 487 &lt;https://peps.python.org/pep-0487/&gt;`_:    Support for `__init_subclass__` and `__set_name__`.    See also `init_subclass`_ and `set_name`_.  - `object.__dir__ &lt;https://docs.python.org/3/reference/datamodel.html#object.__dir__&gt;`_:    Base `__dir__` method.    See also `default_dir`_.  - `__eq__ override &lt;https://docs.python.org/3/reference/datamodel.html#object.__hash__&gt;`_:    Overriding `__eq__` will set `__hash__` to None. See also `implicit_hash`_.  - `PEP 307 &lt;https://peps.python.org/pep-0307/&gt;`_:    Support for pickling objects with `__slots__`.    See also `obj_state`_.  - `PEP 3155 &lt;https://peps.python.org/pep-03155/&gt;`_:    Qualified name `__qualname__` for nested classes.    See also `qualname`_.  - `__ne__ behavior &lt;https://docs.python.org/3.0/whatsnew/3.0.html#operators-and-special-methods&gt;`_:    By default, `__ne__` should negate the result of `__eq__`.    See also `safe_not_equals`_  - `PEP 0560 &lt;https://peps.python.org/pep-0560/&gt;`_:    Better handling of Generic classes.    See also `tippo &lt;https://github.com/brunonicko/tippo#generic-fixes&gt;`_.Base^^^^In addition to the compatibility solutions, the goal with the `BaseMeta` metaclass andthe `Base` class is to add useful low-level features that hopefully yield better codereadability and validation.This includes:  - `__weakref__` slot: Added by default.  - `locked_class`_: Public class attributes are read-only by default.  - `explicit_hash`_: Overriding `__eq__` without overriding `__hash__` will error.  - `namespace`_: Adds a protected `__namespace` unique to each class.  - `runtime_final`_: Runtime checking for classes and methods decorated with `final`.SlottedBase^^^^^^^^^^^The `SlottedBase` class and the `SlottedBaseMeta` metaclass offer all features from`Base` and `BaseMeta` plus implicit `__slots__` declaration.See `slotted &lt;https://github.com/brunonicko/slotted&gt;`_ for more information.Utilities---------Apart from the features integrated into the base classes, `basicco` provides manygeneral utility modules.abstract_class^^^^^^^^^^^^^^Better support for`abstract classes &lt;https://docs.python.org/3/library/abc.html#abc.abstractmethod&gt;`_.Provides abstract decorators that can be used directly on methods but also onproperty getters, classmethods, and staticmethods (even in Python 2.7)... code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from basicco.abstract_class import AbstractMeta, abstract    &gt;&gt;&gt; class Asset(with_metaclass(AbstractMeta, object)):    ...     @abstract    ...     def method(self):    ...         pass    ...    ...     @property    ...     @abstract    ...     def prop(self):    ...         return None    ...    &gt;&gt;&gt; Asset()    Traceback (most recent call last):    TypeError: Can't instantiate abstract class Asset...caller_module^^^^^^^^^^^^^Retrieve the caller's module name... code:: python    &gt;&gt;&gt; from basicco.caller_module import caller_module    &gt;&gt;&gt; def do_something():    ...     return &quot;I was called by {}&quot;.format(caller_module())    ...    &gt;&gt;&gt; do_something()    'I was called by __main__'context_vars^^^^^^^^^^^^Backport of the `contextvars` module for Python 2.7, based on`MagicStack/contextvars &lt;https://github.com/MagicStack/contextvars&gt;`_.When imported from Python 3, it simply redirects to the native`contextvars &lt;https://docs.python.org/3/library/contextvars.html&gt;`_ module... code:: python    &gt;&gt;&gt; from basicco.context_vars import ContextVar    &gt;&gt;&gt; my_var = ContextVar(&quot;my_var&quot;, default=&quot;bar&quot;)    &gt;&gt;&gt; token = my_var.set(&quot;foo&quot;)    &gt;&gt;&gt; my_var.get()    'foo'    &gt;&gt;&gt; my_var.reset(token)    &gt;&gt;&gt; my_var.get()    'bar'custom_repr^^^^^^^^^^^Custom representation functions for mappings, items, and iterables... code:: python    &gt;&gt;&gt; from basicco.custom_repr import mapping_repr    &gt;&gt;&gt; dct = {&quot;a&quot;: 1, &quot;b&quot;: 2}    &gt;&gt;&gt; mapping_repr(    ...     dct,    ...     prefix=&quot;&lt;&quot;,    ...     suffix=&quot;&gt;&quot;,    ...     template=&quot;{key}={value}&quot;,    ...     sorting=True    ... )    &quot;&lt;'a'=1, 'b'=2&gt;&quot;.. code:: python    &gt;&gt;&gt; from basicco.custom_repr import mapping_repr    &gt;&gt;&gt; items = [(&quot;a&quot;, 1), (&quot;b&quot;, 2)]    &gt;&gt;&gt; mapping_repr(    ...     items,    ...     prefix=&quot;[&quot;, suffix=&quot;]&quot;,    ...     template=(lambda i, key, value: key + &quot; -&gt; &quot; + value),    ... )    &quot;['a' -&gt; 1, 'b' -&gt; 2]&quot;.. code:: python    &gt;&gt;&gt; from basicco.custom_repr import iterable_repr    &gt;&gt;&gt; tup = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 1, 2, 3)    &gt;&gt;&gt; iterable_repr(tup, prefix=&quot;&lt;&quot;, suffix=&quot;&gt;&quot;, value_repr=str)    '&lt;a, b, c, 1, 2, 3&gt;'default_dir^^^^^^^^^^^Backport of Python 3's implementation of`object.__dir__ &lt;https://docs.python.org/3/reference/datamodel.html#object.__dir__&gt;`_.This allows for calling `super().__dir__()` from a subclass to leverage the defaultimplementation... code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from basicco.default_dir import DefaultDir    &gt;&gt;&gt; class Class(DefaultDir):    ...     def __dir__(self):    ...         return super(Class, self).__dir__()    ...    &gt;&gt;&gt; obj = Class()    &gt;&gt;&gt; dir(obj)    [...]descriptors^^^^^^^^^^^Configurable descriptors... code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from basicco.descriptors import REMOVE, Descriptor, Owner    &gt;&gt;&gt; class SlotDescriptor(Descriptor):    ...     def __get_required_slots__(self):    ...         return (self.name,)  # request a slot with the same name as this    ...     def __get_replacement__(self):    ...         return REMOVE  # remove this descriptor from the class body    ...    &gt;&gt;&gt; class PropDescriptor(Descriptor):    ...     __slots__ = (&quot;_slot_desc&quot;,)    ...     def __init__(self, slot_desc):    ...         super(PropDescriptor, self).__init__()    ...         self._slot_desc = slot_desc    ...     def __get__(self, instance, owner):    ...         if instance is not None:    ...             return getattr(instance, self._slot_desc.name)    ...         return self    ...     def __set__(self, instance, value):    ...         setattr(instance, self._slot_desc.name, value)    ...    &gt;&gt;&gt; class Stuff(Owner):    ...     _foo = SlotDescriptor()    ...     _bar = SlotDescriptor()    ...     foo = PropDescriptor(_foo)    ...     bar = PropDescriptor(_bar)    ...    &gt;&gt;&gt; stuff = Stuff()    &gt;&gt;&gt; stuff.foo = &quot;foo&quot;    &gt;&gt;&gt; stuff.bar = &quot;bar&quot;    &gt;&gt;&gt; stuff.foo    'foo'    &gt;&gt;&gt; stuff.bar    'bar'dynamic_class^^^^^^^^^^^^^Easily generate classes on the fly. This works best with a `Base`_ class.If provided a valid qualified name and module (uses `caller_module`_ by default), theclass will be pickable/importable... code:: python    &gt;&gt;&gt; from basicco import Base    &gt;&gt;&gt; from basicco.dynamic_class import make_cls    &gt;&gt;&gt; class MyClass(object):    ...     DynClass = make_cls(&quot;MyClass.DynClass&quot;, bases=(Base,), dct={&quot;foo&quot;: &quot;bar&quot;})    ...    &gt;&gt;&gt; repr(MyClass.DynClass)    &quot;&lt;class '__main__.MyClass.DynClass'&gt;&quot;dynamic_code^^^^^^^^^^^^Generate debuggable code on the fly that supports line numbers on tracebacks... code:: python    &gt;&gt;&gt; from basicco.dynamic_code import make_function, generate_unique_filename    &gt;&gt;&gt; class MyClass(object):    ...     pass    ...    &gt;&gt;&gt; bar = 'bar'    &gt;&gt;&gt; # Prepare the script and necessary data.    &gt;&gt;&gt; script = &quot;\n&quot;.join(    ...     (    ...         &quot;def __init__(self):&quot;,    ...         &quot;    self.foo = 'bar'&quot;,    ...     )    ... )    &gt;&gt;&gt; # Gather information.    &gt;&gt;&gt; name = &quot;__init__&quot;    &gt;&gt;&gt; owner_name = MyClass.__name__    &gt;&gt;&gt; module = MyClass.__module__    &gt;&gt;&gt; filename = generate_unique_filename(name, module, owner_name)    &gt;&gt;&gt; globs = {&quot;bar&quot;: bar}    &gt;&gt;&gt; # Make function and attach it as a method.    &gt;&gt;&gt; MyClass.__init__ = make_function(name, script, globs, filename, module)    &gt;&gt;&gt; obj = MyClass()    &gt;&gt;&gt; obj.foo    'bar'explicit_hash^^^^^^^^^^^^^Metaclass that forces `__hash__` to be declared whenever `__eq__` is declared... code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from basicco.explicit_hash import ExplicitHashMeta    &gt;&gt;&gt; class Asset(with_metaclass(ExplicitHashMeta, object)):    ...     def __eq__(self, other):    ...         pass    ...    Traceback (most recent call last):    TypeError: declared '__eq__' in 'Asset' but didn't declare '__hash__'fabricate_value^^^^^^^^^^^^^^^Run a value through a callable factory (or None)... code:: python    &gt;&gt;&gt; from basicco.fabricate_value import fabricate_value    &gt;&gt;&gt; fabricate_value(None, 3)  # no factory, value passthrough    3    &gt;&gt;&gt; fabricate_value(str, 3)  # callable factory    '3'    &gt;&gt;&gt; fabricate_value(&quot;str&quot;, 3)  # use an import path    '3'    &gt;&gt;&gt; fabricate_value(int)  # no input value, just the factory itself    0get_mro^^^^^^^Get consistent MRO amongst different python versions. This works even with genericclasses in Python 2.7... code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from tippo import Generic, TypeVar    &gt;&gt;&gt; from basicco.get_mro import get_mro    &gt;&gt;&gt; T = TypeVar(&quot;T&quot;)    &gt;&gt;&gt; class MyGeneric(Generic[T]):    ...     pass    ...    &gt;&gt;&gt; class SubClass(MyGeneric[T]):    ...     pass    ...    &gt;&gt;&gt; class Mixed(SubClass[T], MyGeneric[T]):    ...     pass    ...    &gt;&gt;&gt; [c.__name__ for c in get_mro(Mixed)]    ['Mixed', 'SubClass', 'MyGeneric', 'Generic', 'object']hash_cache_wrapper^^^^^^^^^^^^^^^^^^An integer subclass that pickles/copies as None. This can be used to avoid serializinga cached hash value... code:: python    &gt;&gt;&gt; from copy import copy    &gt;&gt;&gt; from basicco.hash_cache_wrapper import HashCacheWrapper    &gt;&gt;&gt; hash_cache = HashCacheWrapper(12345)    &gt;&gt;&gt; print(hash_cache)    12345    &gt;&gt;&gt; print(copy(hash_cache))    Noneimplicit_hash^^^^^^^^^^^^^Metaclass that forces `__hash__` to None when `__eq__` is declared.This is a backport of the default behavior in Python 3... code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from basicco.implicit_hash import ImplicitHashMeta    &gt;&gt;&gt; class Asset(with_metaclass(ImplicitHashMeta, object)):    ...     def __eq__(self, other):    ...         pass    ...    &gt;&gt;&gt; Asset.__hash__ is None    Trueimport_path^^^^^^^^^^^Generate importable dot paths and import from them... code:: python    &gt;&gt;&gt; import itertools    &gt;&gt;&gt; from basicco.import_path import get_path, import_path    &gt;&gt;&gt; get_path(itertools.chain)    'itertools.chain'    &gt;&gt;&gt; import_path(&quot;itertools.chain&quot;)    &lt;... 'itertools.chain'&gt;.. code:: python    &gt;&gt;&gt; from basicco.import_path import extract_generic_paths    &gt;&gt;&gt; extract_generic_paths(&quot;Tuple[int, str]&quot;)    ('Tuple', ('int', 'str'))init_subclass^^^^^^^^^^^^^Backport of the functionality of `__init_subclass__` from PEP 487 to Python 2.7.This works for both Python 2 (using `__kwargs__`) and 3 (using the new classparameters)... code:: python    &gt;&gt;&gt; from basicco.init_subclass import InitSubclass    &gt;&gt;&gt; class Foo(InitSubclass):    ...     def __init_subclass__(cls, foo=None, **kwargs):    ...         cls.foo = foo    ...    &gt;&gt;&gt; class Bar(Foo):    ...     __kwargs__ = {&quot;foo&quot;: &quot;bar&quot;}  # you can specify cls kwargs on py2 like this    ...    &gt;&gt;&gt; Bar.foo    'bar'lazy_tuple^^^^^^^^^^Lazily-evaluated tuple-like structure... code:: python    &gt;&gt;&gt; from basicco.lazy_tuple import LazyTuple    &gt;&gt;&gt; def expensive_generator():    ...     for i in range(100):    ...         yield i    ...    &gt;&gt;&gt; lazy_tuple = LazyTuple(expensive_generator())    &gt;&gt;&gt; lazy_tuple[4]    4locked_class^^^^^^^^^^^^Prevents changing public class attributes... code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from basicco.locked_class import LockedClassMeta    &gt;&gt;&gt; class Foo(with_metaclass(LockedClassMeta, object)):    ...     bar = &quot;foo&quot;    ...    &gt;&gt;&gt; Foo.bar = &quot;bar&quot;    Traceback (most recent call last):    AttributeError: can't set read-only class attribute 'bar'mangling^^^^^^^^Functions to mangle/unmangle/extract private names... code:: python    &gt;&gt;&gt; from basicco.mangling import mangle, unmangle, extract    &gt;&gt;&gt; mangle(&quot;__member&quot;, &quot;Foo&quot;)    '_Foo__member'    &gt;&gt;&gt; unmangle(&quot;_Foo__member&quot;, &quot;Foo&quot;)    '__member'    &gt;&gt;&gt; extract(&quot;_Foo__member&quot;)    ('__member', 'Foo')mapping_proxy^^^^^^^^^^^^^Mapping Proxy type (read-only dictionary) for older Python versions... code:: python    &gt;&gt;&gt; from basicco.mapping_proxy import MappingProxyType    &gt;&gt;&gt; internal_dict = {&quot;foo&quot;: &quot;bar&quot;}    &gt;&gt;&gt; proxy_dict = MappingProxyType(internal_dict)    &gt;&gt;&gt; proxy_dict[&quot;foo&quot;]    'bar'namespace^^^^^^^^^Wraps a dictionary/mapping and provides attribute-style access to it... code:: python    &gt;&gt;&gt; from basicco.namespace import Namespace    &gt;&gt;&gt; ns = Namespace({&quot;bar&quot;: &quot;foo&quot;})    &gt;&gt;&gt; ns.bar    'foo'.. code:: python    &gt;&gt;&gt; from basicco.namespace import MutableNamespace    &gt;&gt;&gt; ns = MutableNamespace({&quot;bar&quot;: &quot;foo&quot;})    &gt;&gt;&gt; ns.foo = &quot;bar&quot;    &gt;&gt;&gt; ns.foo    'bar'    &gt;&gt;&gt; ns.bar    'foo'Also provides a `NamespacedMeta` metaclass that adds a `__namespace` protected classattribute that is unique to each class... code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from basicco.namespace import NamespacedMeta    &gt;&gt;&gt; class Asset(with_metaclass(NamespacedMeta, object)):    ...     @classmethod    ...     def set_class_value(cls, value):    ...         cls.__namespace.value = value    ...    ...     @classmethod    ...     def get_class_value(cls):    ...         return cls.__namespace.value    ...    &gt;&gt;&gt; Asset.set_class_value(&quot;foobar&quot;)    &gt;&gt;&gt; Asset.get_class_value()    'foobar'null_context^^^^^^^^^^^^Backport of `contextlib.nullcontext` for Python 2.7... code:: python    &gt;&gt;&gt; from basicco.null_context import null_context    &gt;&gt;&gt; from basicco.suppress_exception import suppress_exception    &gt;&gt;&gt; def myfunction(arg, ignore_exceptions=False):    ...     if ignore_exceptions:    ...         # Use suppress_exception to ignore all exceptions.    ...         cm = suppress_exception(Exception)    ...     else:    ...         # Do not ignore any exceptions, cm has no effect.    ...         cm = null_context()    ...     with cm:    ...         pass # Do something    ...obj_state^^^^^^^^^Get/update the state of an object, slotted or not (works even in Python 2.7)... code:: python    &gt;&gt;&gt; from basicco.obj_state import get_state    &gt;&gt;&gt; class Slotted(object):    ...     __slots__ = (&quot;foo&quot;, &quot;bar&quot;)    ...     def __init__(self, foo, bar):    ...         self.foo = foo    ...         self.bar = bar    ...    &gt;&gt;&gt; slotted = Slotted(&quot;a&quot;, &quot;b&quot;)    &gt;&gt;&gt; sorted(get_state(slotted).items())    [('bar', 'b'), ('foo', 'a')]Also provides a `ReducibleMeta` metaclass that allows for pickling instances of slottedclasses in Python 2.7.qualname^^^^^^^^Python 2.7 compatible way of getting the qualified name. Based on`wbolster/qualname &lt;https://github.com/wbolster/qualname&gt;`_.Also provides a `QualnamedMeta` metaclass with a `__qualname__` class property forPython 2.7.recursive_repr^^^^^^^^^^^^^^Decorator that prevents infinite recursion for `__repr__` methods... code:: python    &gt;&gt;&gt; from basicco.recursive_repr import recursive_repr    &gt;&gt;&gt; class MyClass(object):    ...    ...     @recursive_repr    ...     def __repr__(self):    ...         return &quot;MyClass&lt;{!r}&gt;&quot;.format(self)    ...    &gt;&gt;&gt; my_obj = MyClass()    &gt;&gt;&gt; repr(my_obj)    'MyClass&lt;...&gt;'runtime_final^^^^^^^^^^^^^Runtime-checked version of the`typing.final &lt;https://docs.python.org/3/library/typing.html#typing.final&gt;`_ decorator.Can be used on methods, properties, classmethods, staticmethods, and classes that have`RuntimeFinalMeta` as a metaclass. It is also recognized by static type checkers andprevents subclassing and/or member overriding during runtime:.. code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from basicco.runtime_final import RuntimeFinalMeta, final    &gt;&gt;&gt; @final    ... class Asset(with_metaclass(RuntimeFinalMeta, object)):    ...     pass    ...    &gt;&gt;&gt; class SubAsset(Asset):    ...     pass    ...    Traceback (most recent call last):    TypeError: can't subclass final class 'Asset'.. code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from basicco.runtime_final import RuntimeFinalMeta, final    &gt;&gt;&gt; class Asset(with_metaclass(RuntimeFinalMeta, object)):    ...     @final    ...     def method(self):    ...         pass    ...    &gt;&gt;&gt; class SubAsset(Asset):    ...     def method(self):    ...         pass    Traceback (most recent call last):    TypeError: 'SubAsset' overrides final member 'method' defined by 'Asset'.. code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from basicco.runtime_final import RuntimeFinalMeta, final    &gt;&gt;&gt; class Asset(with_metaclass(RuntimeFinalMeta, object)):    ...     @property    ...     @final    ...     def prop(self):    ...         pass    ...    &gt;&gt;&gt; class SubAsset(Asset):    ...     @property    ...     def prop(self):    ...         pass    Traceback (most recent call last):    TypeError: 'SubAsset' overrides final member 'prop' defined by 'Asset'safe_not_equals^^^^^^^^^^^^^^^Backport of the default Python 3 behavior of `__ne__` behavior for Python 2.7... code:: python    &gt;&gt;&gt; from six import with_metaclass    &gt;&gt;&gt; from basicco.safe_not_equals import SafeNotEqualsMeta    &gt;&gt;&gt; class Class(with_metaclass(SafeNotEqualsMeta, object)):    ...     pass    ...    &gt;&gt;&gt; obj_a = Class()    &gt;&gt;&gt; obj_b = Class()    &gt;&gt;&gt; assert (obj_a == obj_a) is not (obj_a != obj_a)    &gt;&gt;&gt; assert (obj_b == obj_b) is not (obj_b != obj_b)    &gt;&gt;&gt; assert (obj_a == obj_b) is not (obj_a != obj_b)safe_repr^^^^^^^^^Decorator that prevents `__repr__` methods from raising exceptions and return a defaultrepresentation instead... code:: python    &gt;&gt;&gt; from basicco.safe_repr import safe_repr    &gt;&gt;&gt; class Class(object):    ...     @safe_repr    ...     def __repr__(self):    ...         raise RuntimeError(&quot;oh oh&quot;)    ...    &gt;&gt;&gt; obj = Class()    &gt;&gt;&gt; repr(obj)    &quot;&lt;__main__.Class object at ...; repr failed due to 'RuntimeError: oh oh'&gt;&quot;sentinel^^^^^^^^Easily define singleton sentinel values and their type (for type hinting)... code:: python    &gt;&gt;&gt; from basicco.sentinel import SentinelType    &gt;&gt;&gt; class MissingType(SentinelType):    ...     def __repr__(self):    ...         return &quot;MISSING&quot;    ...    &gt;&gt;&gt; MISSING = MissingType()    &gt;&gt;&gt; MISSING    MISSING    &gt;&gt;&gt; MissingType() is MISSING    True    &gt;&gt;&gt; isinstance(MISSING, MissingType)    Trueset_name^^^^^^^^Backport of the functionality of `__set_name__` from PEP 487 to Python 2.7... code:: python    &gt;&gt;&gt; from basicco.set_name import SetName    &gt;&gt;&gt; class Attribute(object):    ...     def __set_name__(self, owner, name):    ...         self.owner = owner    ...         self.name = name    ...    &gt;&gt;&gt; class Collection(SetName):    ...     foo = Attribute()    ...    &gt;&gt;&gt; Collection.foo.owner is Collection    True    &gt;&gt;&gt; Collection.foo.name    'foo'suppress_exception^^^^^^^^^^^^^^^^^^Backport of `contextlib.suppress` for Python 2.7.See `null_context`_ for an example usage.type_checking^^^^^^^^^^^^^Runtime type checking with support for import paths and type hints... code:: python    &gt;&gt;&gt; from tippo import Mapping, Literal    &gt;&gt;&gt; from itertools import chain    &gt;&gt;&gt; from basicco.type_checking import is_instance    &gt;&gt;&gt; class SubChain(chain):    ...     pass    ...    &gt;&gt;&gt; is_instance(3, int)    True    &gt;&gt;&gt; is_instance(3, (chain, int))    True    &gt;&gt;&gt; is_instance(3, ())    False    &gt;&gt;&gt; is_instance(SubChain(), &quot;itertools.chain&quot;)    True    &gt;&gt;&gt; is_instance(chain(), &quot;itertools.chain&quot;, subtypes=False)    True    &gt;&gt;&gt; is_instance(SubChain(), &quot;itertools.chain&quot;, subtypes=False)    False    &gt;&gt;&gt; is_instance({&quot;a&quot;: 1, &quot;b&quot;: 2}, Mapping[str, int])    True    &gt;&gt;&gt; is_instance(&quot;PRE&quot;, Literal[&quot;PRE&quot;, &quot;POST&quot;])    Trueunique_iterator^^^^^^^^^^^^^^^Iterator that yields unique values... code:: python    &gt;&gt;&gt; from basicco.unique_iterator import unique_iterator    &gt;&gt;&gt; list(unique_iterator([1, 2, 3, 3, 4, 4, 5]))    [1, 2, 3, 4, 5]</longdescription>
</pkgmetadata>