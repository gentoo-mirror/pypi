<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># httpx-sse[![Build Status](https://dev.azure.com/florimondmanca/public/_apis/build/status/florimondmanca.httpx-sse?branchName=master)](https://dev.azure.com/florimondmanca/public/_build?definitionId=19)[![Coverage](https://codecov.io/gh/florimondmanca/httpx-sse/branch/master/graph/badge.svg)](https://codecov.io/gh/florimondmanca/httpx-sse)[![Package version](https://badge.fury.io/py/httpx-sse.svg)](https://pypi.org/project/httpx-sse)Consume [Server-Sent Event (SSE)](https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events) messages with [HTTPX](https://www.python-httpx.org).**Table of contents**- [Installation](#installation)- [Quickstart](#quickstart)- [How-To](#how-to)- [API Reference](#api-reference)## Installation**NOTE**: This is beta software. Please be sure to pin your dependencies.```bashpip install httpx-sse==&quot;0.3.*&quot;```## Quickstart`httpx-sse` provides the [`connect_sse`](#connect_sse) and [`aconnect_sse`](#aconnect_sse) helpers for connecting to an SSE endpoint. The resulting [`EventSource`](#eventsource) object exposes the [`.iter_sse()`](#iter_sse) and [`.aiter_sse()`](#aiter_sse) methods to iterate over the server-sent events.Example usage:```pythonimport httpxfrom httpx_sse import connect_ssewith httpx.Client() as client:    with connect_sse(client, &quot;GET&quot;, &quot;http://localhost:8000/sse&quot;) as event_source:        for sse in event_source.iter_sse():            print(sse.event, sse.data, sse.id, sse.retry)```You can try this against this example Starlette server ([credit](https://sysid.github.io/sse/)):```python# Requirements: pip install uvicorn starlette sse-starletteimport asyncioimport uvicornfrom starlette.applications import Starlettefrom starlette.routing import Routefrom sse_starlette.sse import EventSourceResponseasync def numbers(minimum, maximum):    for i in range(minimum, maximum + 1):        await asyncio.sleep(0.9)        yield {&quot;data&quot;: i}async def sse(request):    generator = numbers(1, 5)    return EventSourceResponse(generator)routes = [    Route(&quot;/sse&quot;, endpoint=sse)]app = Starlette(routes=routes)if __name__ == &quot;__main__&quot;:    uvicorn.run(app)```## How-To### Calling into Python web appsYou can [call into Python web apps](https://www.python-httpx.org/async/#calling-into-python-web-apps) with HTTPX and `httpx-sse` to test SSE endpoints directly.Here's an example of calling into a Starlette ASGI app...```pythonimport asyncioimport httpxfrom httpx_sse import aconnect_ssefrom sse_starlette.sse import EventSourceResponsefrom starlette.applications import Starlettefrom starlette.routing import Routeasync def auth_events(request):    async def events():        yield {            &quot;event&quot;: &quot;login&quot;,            &quot;data&quot;: '{&quot;user_id&quot;: &quot;4135&quot;}',        }    return EventSourceResponse(events())app = Starlette(routes=[Route(&quot;/sse/auth/&quot;, endpoint=auth_events)])async def main():    async with httpx.AsyncClient(app=app) as client:        async with aconnect_sse(            client, &quot;GET&quot;, &quot;http://localhost:8000/sse/auth/&quot;        ) as event_source:            events = [sse async for sse in event_source.aiter_sse()]            (sse,) = events            assert sse.event == &quot;login&quot;            assert sse.json() == {&quot;user_id&quot;: &quot;4135&quot;}asyncio.run(main())```### Handling reconnections_(Advanced)_`SSETransport` and `AsyncSSETransport` don't have reconnection built-in. This is because how to perform retries is generally dependent on your use case. As a result, if the connection breaks while attempting to read from the server, you will get an `httpx.ReadError` from `iter_sse()` (or `aiter_sse()`).However, `httpx-sse` does allow implementing reconnection by using the `Last-Event-ID` and reconnection time (in milliseconds), exposed as `sse.id` and `sse.retry` respectively.Here's how you might achieve this using [`stamina`](https://github.com/hynek/stamina)...```pythonimport timefrom typing import Iteratorimport httpxfrom httpx_sse import connect_sse, ServerSentEventfrom stamina import retrydef iter_sse_retrying(client, method, url):    last_event_id = &quot;&quot;    reconnection_delay = 0.0    # `stamina` will apply jitter and exponential backoff on top of    # the `retry` reconnection delay sent by the server.    @retry(on=httpx.ReadError)    def _iter_sse():        nonlocal last_event_id, reconnection_delay        time.sleep(reconnection_delay)        headers = {&quot;Accept&quot;: &quot;text/event-stream&quot;}        if last_event_id:            headers[&quot;Last-Event-ID&quot;] = last_event_id        with connect_sse(client, method, url, headers=headers) as event_source:            for sse in event_source.iter_sse():                last_event_id = sse.id                if sse.retry is not None:                    reconnection_delay = sse.retry / 1000                yield sse    return _iter_sse()```Usage:```pythonwith httpx.Client() as client:    for sse in iter_sse_retrying(client, &quot;GET&quot;, &quot;http://localhost:8000/sse&quot;):        print(sse.event, sse.data)```## API Reference### `connect_sse````pythondef connect_sse(    client: httpx.Client,    method: str,    url: Union[str, httpx.URL],    **kwargs,) -&gt; ContextManager[EventSource]```Connect to an SSE endpoint and return an [`EventSource`](#eventsource) context manager.This sets `Cache-Control: no-store` on the request, as per the SSE spec, as well as `Accept: text/event-stream`.If the response `Content-Type` is not `text/event-stream`, this will raise an [`SSEError`](#sseerror).### `aconnect_sse````pythonasync def aconnect_sse(    client: httpx.AsyncClient,    method: str,    url: Union[str, httpx.URL],    **kwargs,) -&gt; AsyncContextManager[EventSource]```An async equivalent to [`connect_sse`](#connect_sse).### `EventSource````pythondef __init__(response: httpx.Response)```Helper for working with an SSE response.#### `response`The underlying [`httpx.Response`](https://www.python-httpx.org/api/#response).#### `iter_sse````pythondef iter_sse() -&gt; Iterator[ServerSentEvent]```Decode the response content and yield corresponding [`ServerSentEvent`](#serversentevent).Example usage:```pythonfor sse in event_source.iter_sse():    ...```#### `aiter_sse````pythonasync def iter_sse() -&gt; AsyncIterator[ServerSentEvent]```An async equivalent to `iter_sse`.### `ServerSentEvent`Represents a server-sent event.* `event: str` - Defaults to `&quot;message&quot;`.* `data: str` - Defaults to `&quot;&quot;`.* `id: str` - Defaults to `&quot;&quot;`.* `retry: str | None` - Defaults to `None`.Methods:* `json() -&gt; Any` - Returns `sse.data` decoded as JSON.### `SSEError`An error that occurred while making a request to an SSE endpoint.Parents:* `httpx.TransportError`## LicenseMIT# ChangelogAll notable changes to this project will be documented in this file.The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).## 0.3.1 - 2023-06-01### Added* Add `__repr__()` for `ServerSentEvent` model, which may help with debugging and other tasks. (Pull #16)## 0.3.0 - 2023-04-27### Changed* Raising an `SSEError` if the response content type is not `text/event-stream` is now performed as part of `iter_sse()` / `aiter_sse()`, instead of `connect_sse()` / `aconnect_sse()`. This allows inspecting the response before iterating on server-sent events, such as checking for error responses. (Pull #12)## 0.2.0 - 2023-03-27### Changed* `connect_sse()` and `aconnect_sse()` now require a `method` argument: `connect_sse(client, &quot;GET&quot;, &quot;https://example.org&quot;)`. This provides support for SSE requests with HTTP verbs other than `GET`. (Pull #7)## 0.1.0 - 2023-02-05_Initial release_### Added* Add `connect_sse`, `aconnect_sse()`, `ServerSentEvent` and `SSEError`.</longdescription>
</pkgmetadata>