<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># SlackersSlack webhooks API served by FastAPI## What is SlackersSlackers is a [FastAPI](https://fastapi.tiangolo.com) implementation to handle Slack interactions and events.It serves endpoints to receive [slash commands](https://api.slack.com/interactivity/slash-commands),[app actions](https://api.slack.com/interactivity/actions), [interactive components](https://api.slack.com/interactivity/components). It also listens for events sent to the Slack Events API [Slack Events](https://api.slack.com/events-api). ## InstallationYou can install Slackers with pip`$ pip install slackers`## Configuration### `SLACK_SIGNING_SECRET`You must configure the slack signing secret. This will be used to verify the incoming requests signature.   `$ export SLACK_SIGNING_SECRET=your_slack_signing_secret`## Example usageSlackers will listen for activity from the Events API on `/events`, forinteractive components on `/actions` and for slash commands on `/commands`.When an interaction is received, it will emit an event. You can listenfor these events as shown in the following examples.On receiving a request, Slackers will emit an event which you can handle yourself.Slackers will also respond to Slack with an (empty) http 200 response telling Slackall is well received.### Starting the serverAs said, Slackers uses the excellent FastAPI to serve it's endpoints. Since you're here, I'm assuming you know what FastAPI is, but if you don't, you can learn all about how that works with [this tutorial](https://fastapi.tiangolo.com/tutorial/). Slackers offers you a router which you can include in your own FastAPI.```pythonfrom fastapi import FastAPIfrom slackers.server import routerapp = FastAPI()app.include_router(router)# Optionally you can use a prefixapp.include_router(router, prefix='/slack')```### EventsOnce your server is running, the events endpoint is setup at `/events`, or if you usethe prefix as shown above, on `/slack/events`.#### Accepting the challengeWhen setting up Slack to [send events](https://api.slack.com/events-api#subscribing_to_event_types),it will first send a challenge to verify your endpoint. Slackers detects when a challenge is sent.You can simply start our api and Slackers will meet the challenge automatically.#### Responding to eventsOn receiving an event, Slackers will emit a python event, which you can act upon as shown below.```pythonimport loggingfrom slackers.hooks import eventslog = logging.getLogger(__name__)@events.on(&quot;app_mention&quot;)def handle_mention(payload):    log.info(&quot;App was mentioned.&quot;)    log.debug(payload)```### ActionsOnce your server is running, the actions endpoint is setup at `/actions`, or if you usethe prefix as shown above, on `/slack/actions`.#### Responding to actionsOn receiving an action, Slackers will emit a python event, which you can listen for as shown below. You can listen for the action type, or more specifically for the action idor callback id linked to the action.```pythonimport loggingfrom slackers.hooks import actionslog = logging.getLogger(__name__)# Listening for the action type.@actions.on(&quot;block_actions&quot;)def handle_action(payload):    log.info(&quot;Action started.&quot;)    log.debug(payload)# Listen for an action by it's action_id@actions.on(&quot;block_actions:your_action_id&quot;)def handle_action_by_id(payload):    log.info(&quot;Action started.&quot;)    log.debug(payload)# Listen for an action by it's callback_id@actions.on(&quot;block_actions:your_callback_id&quot;)def handle_action_by_callback_id(payload):    log.info(f&quot;Action started.&quot;)    log.debug(payload)```#### Interactive messagesInteractive message actions do not have an `action_id`. They do have a `name` and a `type`. To act upon interactive messages, you can listen for the action type, `interactive_message`as wel as the combination of the `interactive_message` and `name`, `type` or both.```pythonimport loggingfrom slackers.hooks import actionslog = logging.getLogger(__name__)# Listening for the action type.@actions.on(&quot;interactive_message&quot;)def handle_action(payload):    log.info(&quot;Action started.&quot;)    log.debug(payload)# Listen for an action by it's name@actions.on(&quot;interactive_message:action_name&quot;)def handle_action_by_id(payload):    log.info(&quot;Action started.&quot;)    log.debug(payload)# Listen for an action by it's type@actions.on(&quot;interactive_message:action_type&quot;)def handle_action_by_callback_id(payload):    log.info(f&quot;Action started.&quot;)    log.debug(payload)# Listen for an action by it's name and type@actions.on(&quot;interactive_message:action_name:action_type&quot;)def handle_action_by_callback_id(payload):    log.info(f&quot;Action started.&quot;)    log.debug(payload)```#### Custom responsesSlackers tries to be fast to respond to Slack. The events you are listening for with thelikes of `@actions.on(...)` are scheduled as an async task in a fire and forget fashion.After scheduling these events, Slackers will by default return an empty 200 response whichmight happen before the events are handled.In some cases you might want to act on the payload and return a custom response to Slack.For this, you can use the slackers `responder` decorator to define your custom handlerfunction. This function is then used as a callback instead of returning the default response.You must ensure your custom handler returns a `starlette.responses.Response` or one of it's subclasses. You must furthermore ensure that there is only one responder responding to yourSlack request.Please note that the events are also emitted, so you could have both `@actions.on(&quot;block_action:xyz&quot;)`and `@responder(&quot;block_action:xyz&quot;)`. Just keep in mind that the event emissions are async and arenot awaited. In other words, Slackers doesn't ensure that the response (whether your custom responseor the default) is returned before or after the events are emitted.```pythonfrom starlette.responses import JSONResponsefrom slackers.hooks import responder@responder(&quot;block_actions:your_callback_id&quot;)def custom_handler(payload):    # handle your payload    ...    return JSONResponse(content={&quot;custom&quot;: &quot;Custom Response&quot;})```### Slash commandsOnce your server is running, the commands endpoint is setup at `/commands`, or if you usethe prefix as shown above, on `/slack/commands`. Slackers will emit an event with the nameof the command, so if your command is `/engage`, you can listen for the event `engage`(without the slash)#### Responding to slash commandsOn receiving a command, Slackers will emit a python event, which you can listen for as shown below.```pythonimport loggingfrom slackers.hooks import commandslog = logging.getLogger(__name__)@commands.on(&quot;engage&quot;)  # responds to &quot;/engage&quot;  def handle_command(payload):    log.info(&quot;Command received&quot;)    log.debug(payload)```### AsyncSince events are emitted using pyee's Async event emitter, it is possible to define your event handlersas async functions. Just keep in mind that errors are in this case emitted on the 'error' event. ```pythonimport loggingfrom slackers.hooks import commandslog = logging.getLogger(__name__)@commands.on('error')def log_error(exc):    log.error(str(exc))@commands.on(&quot;engage&quot;)  # responds to &quot;/engage&quot;  async def handle_command(payload):    ...```</longdescription>
</pkgmetadata>