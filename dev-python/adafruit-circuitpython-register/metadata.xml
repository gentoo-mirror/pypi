<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Introduction============.. image:: https://readthedocs.org/projects/adafruit-micropython-register/badge/?version=latest    :target: https://docs.circuitpython.org/projects/register/en/latest/    :alt: Documentation Status.. image:: https://raw.githubusercontent.com/adafruit/Adafruit_CircuitPython_Bundle/main/badges/adafruit_discord.svg    :target: https://adafru.it/discord    :alt: Discord.. image:: https://github.com/adafruit/Adafruit_CircuitPython_Register/workflows/Build%20CI/badge.svg    :target: https://github.com/adafruit/Adafruit_CircuitPython_Register/actions/    :alt: Build Status.. image:: https://img.shields.io/badge/code%20style-black-000000.svg    :target: https://github.com/psf/black    :alt: Code Style: BlackThis library provides a variety of data descriptor class for `AdafruitCircuitPython &lt;https://github.com/adafruit/circuitpython&gt;`_ that makes it reallysimple to write a device drivers for a I2C and SPI register based devices. Datadescriptors act like basic attributes from the outside which makes using themreally easy to use.Dependencies=============This driver depends on:* `Adafruit CircuitPython &lt;https://github.com/adafruit/circuitpython&gt;`_Please ensure all dependencies are available on the CircuitPython filesystem.This is easily achieved by downloading`the Adafruit library and driver bundle &lt;https://github.com/adafruit/Adafruit_CircuitPython_Bundle&gt;`_.Installing from PyPI====================On supported GNU/Linux systems like the Raspberry Pi, you can install the driver locally `fromPyPI &lt;https://pypi.org/project/adafruit-circuitpython-register/&gt;`_. To install for current user:.. code-block:: shell    pip3 install adafruit-circuitpython-registerTo install system-wide (this may be required in some cases):.. code-block:: shell    sudo pip3 install adafruit-circuitpython-registerTo install in a virtual environment in your current project:.. code-block:: shell    mkdir project-name &amp;&amp; cd project-name    python3 -m venv .venv    source .venv/bin/activate    pip3 install adafruit-circuitpython-registerUsage Example=============Creating a driver-----------------Creating a driver with the register library is really easy. First, import theregister modules you need from the `available modules &lt;adafruit_register/index.html&gt;`_:.. code-block:: python    from adafruit_register import i2c_bit    from adafruit_bus_device import i2c_deviceNext, define where the bit is located in the device's memory map:.. code-block:: python    class HelloWorldDevice:        &quot;&quot;&quot;Device with two bits to control when the words 'hello' and 'world' are lit.&quot;&quot;&quot;        hello = i2c_bit.RWBit(0x0, 0x0)        &quot;&quot;&quot;Bit to indicate if hello is lit.&quot;&quot;&quot;        world = i2c_bit.RWBit(0x1, 0x0)        &quot;&quot;&quot;Bit to indicate if world is lit.&quot;&quot;&quot;Lastly, we need to add an ``i2c_device`` member of type `I2CDevice &lt;https://docs.circuitpython.org/projects/busdevice/en/latest/api.html#adafruit_bus_device.i2c_device.I2CDevice&gt;`_that manages sharing the I2C bus for us. Make sure the name is exact, otherwisethe registers will not be able to find it. Also, make sure that the i2c deviceimplements the `busio.I2C` interface... code-block:: python        def __init__(self, i2c, device_address=0x0):            self.i2c_device = i2c_device.I2CDevice(i2c, device_address)Thats it! Now we have a class we can use to talk to those registers:.. code-block:: python    import busio    from board import *    with busio.I2C(SCL, SDA) as i2c:        device = HelloWorldDevice(i2c)        device.hello = True        device.world = TrueAdding register types--------------------------Adding a new register type is a little more complicated because you need to becareful and minimize the amount of memory the class will take. If you don't,then a driver with five registers of your type could take up five times moreextra memory.First, determine whether the new register class should go in an existing moduleor not. When in doubt choose a new module. The more finer grained the modulesare, the fewer extra classes a driver needs to load in.Here is the start of the `RWBit` class:.. code-block:: python    class RWBit:        &quot;&quot;&quot;        Single bit register that is readable and writeable.        Values are `bool`        :param int register_address: The register address to read the bit from        :param type bit: The bit index within the byte at ``register_address``        &quot;&quot;&quot;        def __init__(self, register_address, bit):            self.bit_mask = 1 &lt;&lt; bit            self.buffer = bytearray(2)            self.buffer[0] = register_addressThe first thing done is writing an RST formatted class comment that explains thefunctionality of the register class and any requirements of the register layout.It also documents the parameters passed into the constructor (``__init__``) whichconfigure the register location in the device map. It does not include thedevice address or the i2c object because its shared on the device class instanceinstead. That way if you have multiple of the same device on the same bus, theregister classes will be shared.In ``__init__`` we only use two member variable because each costs 8 bytes ofmemory plus the memory for the value. And remember this gets multiplied by thenumber of registers of this type in a driver! Thats why we pack both theregister address and data byte into one bytearray. We could use two byte arraysof size one but each MicroPython object is 16 bytes minimum due to the garbagecollector. So, by sharing a byte array we keep it to the 16 byte minimum insteadof 32 bytes. Each `memoryview` also costs 16 bytes minimum so we avoid them too.Another thing we could do is allocate the `bytearray` only when we need it. Thishas the advantage of taking less memory up front but the cost of allocating itevery access and risking it failing. If you want to add a version of ``Foo`` thatlazily allocates the underlying buffer call it ``FooLazy``.Ok, onward. To make a `data descriptor &lt;https://docs.python.org/3/howto/descriptor.html&gt;`_we must implement ``__get__`` and ``__set__``... code-block:: python    def __get__(self, obj, objtype=None):        with obj.i2c_device as i2c:            i2c.write_then_readinto(self.buffer, self.buffer, out_end=1, in_start=1)        return bool(self.buffer[1] &amp; self.bit_mask)    def __set__(self, obj, value):        with obj.i2c_device as i2c:            i2c.write_then_readinto(self.buffer, self.buffer, out_end=1, in_start=1)            if value:                self.buffer[1] |= self.bit_mask            else:                self.buffer[1] &amp;= ~self.bit_mask            obj.i2c_device.write(self.buffer)As you can see, we have two places to get state from. First, ``self`` stores theregister class members which locate the register within the device memory map.Second, ``obj`` is the driver class that uses the register class which must bydefinition provide a `I2CDevice &lt;https://docs.circuitpython.org/projects/busdevice/en/latest/api.html#adafruit_bus_device.i2c_device.I2CDevice&gt;`_ compatibleobject as ``i2c_device``. This object does two thing for us:  1. Waits for the bus to free, locks it as we use it and frees it after.  2. Saves the device address and other settings so we don't have to.Note that we take heavy advantage of the ``start`` and ``end`` parameters to thei2c functions to slice the buffer without actually allocating anything extra.They function just like ``self.buffer[start:end]`` without the extra allocation.Thats it! Now you can use your new register class like the example above. Justremember to keep the number of members to a minimum because the class may beused a bunch of times.Documentation=============API documentation for this library can be found on `Read the Docs &lt;https://docs.circuitpython.org/projects/register/en/latest/&gt;`_.For information on building library documentation, please check out `this guide &lt;https://learn.adafruit.com/creating-and-sharing-a-circuitpython-library/sharing-our-docs-on-readthedocs#sphinx-5-1&gt;`_.Contributing============Contributions are welcome! Please read our `Code of Conduct&lt;https://github.com/adafruit/Adafruit_CircuitPython_Register/blob/main/CODE_OF_CONDUCT.md&gt;`_before contributing to help this project stay welcoming.</longdescription>
</pkgmetadata>