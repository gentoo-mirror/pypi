<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pytest-ansible[![Build Status](https://github.com/ansible-community/pytest-ansible/actions/workflows/tox.yml/badge.svg)](https://github.com/ansible-community/pytest-ansible/actions/workflows/tox.yml)[![Version](https://img.shields.io/pypi/v/pytest-ansible.svg)](https://pypi.python.org/pypi/pytest-ansible/)[![License](https://img.shields.io/pypi/l/pytest-ansible.svg)](https://pypi.python.org/pypi/pytest-ansible/)[![Supported Python Versions](https://img.shields.io/pypi/pyversions/pytest-ansible.svg)](https://pypi.python.org/pypi/pytest-ansible/)This repository contains a plugin for `pytest` which adds several fixturesfor running `ansible` modules, or inspecting `ansible_facts`. While onecan simply call out to `ansible` using the `subprocess` module, having toparse stdout to determine the outcome of the operation is unpleasant and proneto error. With `pytest-ansible`, modules return JSON data which you caninspect and act on, much like with an ansible[playbook](http://docs.ansible.com/playbooks.html).## InstallationInstall this plugin using `pip````bashpip install pytest-ansible```## UsageOnce installed, the following `pytest` command-line parameters are available:```bashpytest \    [--inventory &lt;path_to_inventory&gt;] \    [--extra-inventory &lt;path_to_extra_inventory&gt;] \    [--host-pattern &lt;host-pattern&gt;] \    [--connection &lt;plugin&gt;] \    [--module-path &lt;path_to_modules] \    [--user &lt;username&gt;] \    [--become] \    [--become-user &lt;username&gt;] \    [--become-method &lt;method&gt;] \    [--limit &lt;limit&gt;] \    [--check]```## InventoryUsing ansible first starts with defining your inventory. This can be done inseveral ways, but to start, we'll use the `ansible_adhoc` fixture.```pythondef test_my_inventory(ansible_adhoc):    hosts = ansible_adhoc()```In the example above, the `hosts` variable is an instance of the `HostManager`class and describes your ansible inventory. For this to work, you'll need totell `ansible` where to find your inventory. Inventory can be anythingsupported by ansible, which includes an [INIfile](http://docs.ansible.com/ansible/latest/intro_inventory.html) or anexecutable script that returns [properly formattedJSON](http://docs.ansible.com/ansible/latest/intro_dynamic_inventory.html).For example,```bashpytest --inventory my_inventory.ini --host-pattern all```or```bashpytest --inventory path/to/my/script.py --host-pattern webservers```or```bashpytest --inventory one.example.com,two.example.com --host-pattern all```In the above examples, the inventory provided at runtime will be used in alltests that use the `ansible_adhoc` fixture. A more realistic scenario mayinvolve using different inventory files (or host patterns) with differenttests. To accomplish this, the fixture `ansible_adhoc` allows you to customizethe inventory parameters. Read on for more detail on using the `ansible_adhoc`fixture.## Extra InventoryUsing ansible first starts with defining your extra inventory. This feature was added in version 2.3.0, and is intendedto allow the user to work with two different inventories. This can be done in several ways, but to start,we'll use the `ansible_adhoc` fixture.For example,```bashpytest --inventory my_inventory.ini --extra-inventory my_second_inventory.ini --host-pattern host_in_second_inventory```### Fixture `ansible_adhoc`The `ansible_adhoc` fixture returns a function used to initializea `HostManager` object. The `ansible_adhoc` fixture will default to parameterssupplied to the `pytest` command-line, but also allows one to provide keywordarguments used to initialize the inventory.The example below demonstrates basic usage with options supplied at run-time to`pytest`.```pythondef test_all_the_pings(ansible_adhoc):    ansible_adhoc().all.ping()```The following example demonstrates available keyword arguments when creatinga `HostManager` object.```pythondef test_uptime(ansible_adhoc):    # take down the database    ansible_adhoc(inventory='db1.example.com,', user='ec2-user',        become=True, become_user='root').all.command('reboot')```The `HostManager` object returned by the `ansible_adhoc()` function providesnumerous ways of calling ansible modules against some, or all, of theinventory. The following demonstates sample usage.```pythondef test_host_manager(ansible_adhoc):    hosts = ansible_adhoc()    # __getitem__    hosts['all'].ping()    hosts['localhost'].ping()    # __getattr__    hosts.all.ping()    hosts.localhost.ping()    # Supports [ansible host patterns](http://docs.ansible.com/ansible/latest/intro_patterns.html)    hosts['webservers:!phoenix'].ping()  # all webservers that are not in phoenix    hosts[0].ping()    hosts[0:2].ping()    assert 'one.example.com' in hosts    assert hasattr(hosts, 'two.example.com')    for a_host in hosts:        a_host.ping()```### Fixture `localhost`The `localhost` fixture is a convenience fixture that surfacesa `ModuleDispatcher` instance for ansible host running `pytest`. This isconvenient when using ansible modules that typically run on the local machine,such as cloud modules (ec2, gce etc...).```pythondef test_do_something_cloudy(localhost, ansible_adhoc):    &quot;&quot;&quot;Deploy an ec2 instance using multiple fixtures.&quot;&quot;&quot;    params = dict(        key_name='somekey',        instance_type='t2.micro',        image='ami-123456',        wait=True,        group='webserver',        count=1,        vpc_subnet_id='subnet-29e63245',        assign_public_ip=True,    )    # Deploy an ec2 instance from localhost using the `ansible_adhoc` fixture    ansible_adhoc(inventory='localhost,', connection='local').localhost.ec2(**params)    # Deploy an ec2 instance from localhost using the `localhost` fixture    localhost.ec2(**params)```### Fixture `ansible_module`The `ansible_module` fixture allows tests and fixtures to call [ansiblemodules](http://docs.ansible.com/modules.html). Unlike the `ansible_adhoc`fixture, this fixture only uses the options supplied to `pytest` at run time.A very basic example demonstrating the ansible [`ping` module](http://docs.ansible.com/ping_module.html):```pythondef test_ping(ansible_module):    ansible_module.ping()```A more involved example of updating the sshd configuration, and restarting theservice.```pythondef test_sshd_config(ansible_module):    # update sshd MaxSessions    contacted = ansible_module.lineinfile(        dest=&quot;/etc/ssh/sshd_config&quot;,        regexp=&quot;^#?MaxSessions .*&quot;,        line=&quot;MaxSessions 150&quot;)    )    # assert desired outcome    for (host, result) in contacted.items():        assert 'failed' not in result, result['msg']        assert 'changed' in result    # restart sshd    contacted = ansible_module.service(        name=&quot;sshd&quot;,        state=&quot;restarted&quot;    )    # assert successful restart    for (host, result) in contacted.items():        assert 'changed' in result and result['changed']        assert result['name'] == 'sshd'    # do other stuff ...```### Fixture `ansible_facts`The `ansible_facts` fixture returns a JSON structure representing the systemfacts for the associated inventory. Sample fact data is available in the[ansibledocumentation](http://docs.ansible.com/playbooks_variables.html#information-discovered-from-systems-facts).Note, this fixture is provided for convenience and could easily be called using`ansible_module.setup()`.A systems facts can be useful when deciding whether to skip a test ...```pythondef test_something_with_amazon_ec2(ansible_facts):    for facts in ansible_facts:        if 'ec2.internal' != facts['ansible_domain']:            pytest.skip(&quot;This test only applies to ec2 instances&quot;)```Additionally, since facts are just ansible modules, you could inspect thecontents of the `ec2_facts` module for greater granularity ...```pythondef test_terminate_us_east_1_instances(ansible_adhoc):    for facts in ansible_adhoc().all.ec2_facts():        if facts['ansible_ec2_placement_region'].startswith('us-east'):            '''do some testing'''```### Parameterizing with `pytest.mark.ansible`Perhaps the `--ansible-inventory=&lt;inventory&gt;` includes many systems, but youonly wish to interact with a subset. The `pytest.mark.ansible` marker can beused to modify the `pytest-ansible` command-line parameters for a singletest. Please note, the fixture `ansible_adhoc` is the prefer mechanism forinteracting with ansible inventory within tests.For example, to interact with the local system, you would adjust the`host_pattern` and `connection` parameters.```python@pytest.mark.ansible(host_pattern='local,', connection='local')def test_copy_local(ansible_module):    # create a file with random data    contacted = ansible_module.copy(        dest='/etc/motd',        content='PyTest is amazing!',        owner='root',        group='root',        mode='0644',    )    # assert only a single host was contacted    assert len(contacted) == 1, \        &quot;Unexpected number of hosts contacted (%d != %d)&quot; % \        (1, len(contacted))    assert 'local' in contacted    # assert the copy module reported changes    assert 'changed' in contacted['local']    assert contacted['local']['changed']```Note, the parameters provided by `pytest.mark.ansible` will apply to allclass methods.```python@pytest.mark.ansible(host_pattern='local,', connection='local')class Test_Local(object):    def test_install(self, ansible_module):        '''do some testing'''    def test_template(self, ansible_module):        '''do some testing'''    def test_service(self, ansible_module):        '''do some testing'''```### Inspecting resultsWhen using the `ansible_adhoc`, `localhost` or `ansible_module` fixtures, theobject returned will be an instance of class `AdHocResult`. The`AdHocResult` class can be inspected as follows:```pythondef test_adhoc_result(ansible_adhoc):    contacted = ansible_adhoc(inventory=my_inventory).command(&quot;date&quot;)    # As a dictionary    for (host, result) in contacted.items():        assert result.is_successful, &quot;Failed on host %s&quot; % host    for result in contacted.values():        assert result.is_successful    for host in contacted.keys():        assert host in ['localhost', 'one.example.com']    assert contacted.localhost.is_successful    # As a list    assert len(contacted) &gt; 0    assert 'localhost' in contacted    # As an iterator    for result in contacted:        assert result.is_successful    # With __getattr__    assert contacted.localhost.is_successful    # Or __gettem__    assert contacted['localhost'].is_successful```Using the `AdHocResult` object provides ways to conveniently access resultsfor different hosts involved in the ansible adhoc command. Once the specifichost result is found, you may inspect the result of the ansible adhoc commandon that use by way of the `ModuleResult` interface. The `ModuleResult`class represents the dictionary returned by the ansible module for a particularhost. The contents of the dictionary depend on the module called.The `ModuleResult` interface provides some convenient proprerties todetermine the success of the module call. Examples are included below.```pythondef test_module_result(localhost):    contacted = localhost.command(&quot;find /tmp&quot;)    assert contacted.localhost.is_successful    assert contacted.localhost.is_ok    assert contacted.localhost.is_changed    assert not contacted.localhost.is_failed    contacted = localhost.shell(&quot;exit 1&quot;)    assert contacted.localhost.is_failed    assert not contacted.localhost.is_successful```The contents of the JSON returned by an ansible module differs from module tomodule. For guidance, consult the documentation and examples for the specific[ansible module](http://docs.ansible.com/modules_by_category.html).### Exception handlingIf `ansible` is unable to connect to any inventory, an exception will be raised.```python@pytest.mark.ansible(inventory='unreachable.example.com,')def test_shutdown(ansible_module):    # attempt to ping a host that is down (or doesn't exist)    pytest.raises(pytest_ansible.AnsibleHostUnreachable):        ansible_module.ping()```Sometimes, only a single host is unreachable, and others will have properlyreturned data. The following demonstrates how to catch the exception, andinspect the results.```python@pytest.mark.ansible(inventory='good:bad')def test_inventory_unreachable(ansible_module):    exc_info = pytest.raises(pytest_ansible.AnsibleHostUnreachable, ansible_module.ping)    (contacted, dark) = exc_info.value.results    # inspect the JSON result...    for (host, result) in contacted.items():        assert result['ping'] == 'pong'    for (host, result) in dark.items():        assert result['failed'] == True```</longdescription>
</pkgmetadata>