<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=======nvector=======    |pkg_img| |tests_img| |docs_img| |health_img| |coverage_img| |versions_img| |downloads_img|The nvector library is a suite of tools written in Python to solve geographical positioncalculations. Currently the following operations are implemented:* Calculate the surface distance between two geographical positions.* Convert positions given in one reference frame into another reference frame.* Find the destination point given start point, azimuth/bearing and distance.* Find the mean position (center/midpoint) of several geographical positions.* Find the intersection between two paths.* Find the cross track distance between a path and a position.Using n-vector, the calculations become simple and non-singular. Full accuracy is achieved for any global position (and for any distance).Description===========In this library, we represent position with an &quot;n-vector&quot;,  whichis the normal vector to the Earth model (the same reference ellipsoid that isused for latitude and longitude). When using n-vector, all Earth-positions aretreated equally, and there is no need to worry about singularities ordiscontinuities. An additional benefit with using n-vector is that manyposition calculations can be solved with simple vector algebra(e.g. dot product and cross product).Converting between n-vector and latitude/longitude is unambiguous and easyusing the provided functions.n_E is n-vector in the program code, while in documents we use nE. E denotesan Earth-fixed coordinate frame, and it indicates that the three components ofn-vector are along the three axes of E. More details about the notation andreference frames can be found in the `documentation. &lt;https://www.navlab.net/nvector/#vector_symbols&gt;`_Documentation and code======================Official documentation:http://www.navlab.net/nvector/http://nvector.readthedocs.io/en/latest/*Kenneth Gade (2010):*    `A Nonsingular Horizontal Position Representation,    The Journal of Navigation, Volume 63, Issue 03, pp 395-417, July 2010.    &lt;http://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf&gt;`_Bleeding edge: https://github.com/pbrod/nvector.Official releases available at: http://pypi.python.org/pypi/nvector.Install nvector===============If you have pip installed and are online, then simply type:    $ pip install nvectorto get the lastest stable version. Using pip also has the advantage that allrequirements are automatically installed.You can download nvector and all dependencies to a folder &quot;pkg&quot;, by the following:   $ pip install --download=pkg nvectorTo install the downloaded nvector, just type:   $ pip install --no-index --find-links=pkg nvectorVerifying installation======================To verify that nvector can be seen by Python, type ``python`` from your shell.Then at the Python prompt, try to import nvector:.. parsed-literal::    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; print(nv.__version__)    0.7.7dev0To test if the toolbox is working correctly paste the following in an interactivepython session::   import nvector as nv   nv.test('--doctest-modules')or   $ py.test --pyargs nvector --doctest-modulesat the command prompt.Getting Started===============Below the object-oriented solution to some common geodesic problems are given.In the first example the functional solution is also given.The functional solutions to the remaining problems can be found inthe functional examples sectionof the tutorial.**Example 1: &quot;A and B to delta&quot;**---------------------------------.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/docs/tutorials/images/ex1img.pngGiven two positions, A and B as latitudes, longitudes and depths relative toEarth, E.Find the exact vector between the two positions, given in meters north, east,and down, and find the direction (azimuth) to B, relative to north.Assume WGS-84 ellipsoid. The given depths are from the ellipsoid surface.Use position A to define north, east, and down directions.(Due to the curvature of Earth and different directions to the North Pole,the north, east, and down directions will change (relative to Earth) fordifferent places. Position A must be outside the poles for the north and eastdirections to be defined.)Solution:    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; wgs84 = nv.FrameE(name='WGS84')    &gt;&gt;&gt; pointA = wgs84.GeoPoint(latitude=1, longitude=2, z=3, degrees=True)    &gt;&gt;&gt; pointB = wgs84.GeoPoint(latitude=4, longitude=5, z=6, degrees=True)Step1:  Find p_AB_N (delta decomposed in N).    &gt;&gt;&gt; p_AB_N = pointA.delta_to(pointB)    &gt;&gt;&gt; x, y, z = p_AB_N.pvector.ravel()    &gt;&gt;&gt; 'Ex1: delta north, east, down = {0:8.2f}, {1:8.2f}, {2:8.2f}'.format(x, y, z)    'Ex1: delta north, east, down = 331730.23, 332997.87, 17404.27'Step2: Also find the direction (azimuth) to B, relative to north:    &gt;&gt;&gt; 'azimuth = {0:4.2f} deg'.format(p_AB_N.azimuth_deg)    'azimuth = 45.11 deg'    &gt;&gt;&gt; 'elevation = {0:4.2f} deg'.format(p_AB_N.elevation_deg)    'elevation = 2.12 deg'    &gt;&gt;&gt; 'distance = {0:4.2f} m'.format(p_AB_N.length)    'distance = 470356.72 m'Functional Solution:    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; from nvector import rad, deg    &gt;&gt;&gt; lat_EA, lon_EA, z_EA = rad(1), rad(2), 3    &gt;&gt;&gt; lat_EB, lon_EB, z_EB = rad(4), rad(5), 6Step1: Convert to n-vectors:    &gt;&gt;&gt; n_EA_E = nv.lat_lon2n_E(lat_EA, lon_EA)    &gt;&gt;&gt; n_EB_E = nv.lat_lon2n_E(lat_EB, lon_EB)Step2: Find p_AB_E (delta decomposed in E).WGS-84 ellipsoid is default:    &gt;&gt;&gt; p_AB_E = nv.n_EA_E_and_n_EB_E2p_AB_E(n_EA_E, n_EB_E, z_EA, z_EB)Step3: Find R_EN for position A:    &gt;&gt;&gt; R_EN = nv.n_E2R_EN(n_EA_E)Step4: Find p_AB_N (delta decomposed in N).    &gt;&gt;&gt; p_AB_N = np.dot(R_EN.T, p_AB_E).ravel()    &gt;&gt;&gt; x, y, z = p_AB_N    &gt;&gt;&gt; 'Ex1: delta north, east, down = {0:8.2f}, {1:8.2f}, {2:8.2f}'.format(x, y, z)    'Ex1: delta north, east, down = 331730.23, 332997.87, 17404.27'Step5: Also find the direction (azimuth) to B, relative to north:    &gt;&gt;&gt; azimuth = np.arctan2(y, x)    &gt;&gt;&gt; 'azimuth = {0:4.2f} deg'.format(deg(azimuth))    'azimuth = 45.11 deg'    &gt;&gt;&gt; distance = np.linalg.norm(p_AB_N)    &gt;&gt;&gt; elevation = np.arcsin(z / distance)    &gt;&gt;&gt; 'elevation = {0:4.2f} deg'.format(deg(elevation))    'elevation = 2.12 deg'    &gt;&gt;&gt; 'distance = {0:4.2f} m'.format(distance)    'distance = 470356.72 m'See also    `Example 1 at www.navlab.net &lt;http://www.navlab.net/nvector/#example_1&gt;`_**Example 2: &quot;B and delta to C&quot;**---------------------------------.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/docs/tutorials/images/ex2img.pngA radar or sonar attached to a vehicle B (Body coordinate frame) measures thedistance and direction to an object C. We assume that the distance and twoangles (typically bearing and elevation relative to B) are already combined tothe vector p_BC_B (i.e. the vector from B to C, decomposed in B). The positionof B is given as n_EB_E and z_EB, and the orientation (attitude) of B is givenas R_NB (this rotation matrix can be found from roll/pitch/yaw by using zyx2R).Find the exact position of object C as n-vector and depth ( n_EC_E and z_EC ),assuming Earth ellipsoid with semi-major axis a and flattening f. For WGS-72,use a = 6 378 135 m and f = 1/298.26.Solution:    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; wgs72 = nv.FrameE(name='WGS72')    &gt;&gt;&gt; wgs72 = nv.FrameE(a=6378135, f=1.0/298.26)Step 1: Position and orientation of B is given 400m above E:    &gt;&gt;&gt; n_EB_E = wgs72.Nvector(nv.unit([[1], [2], [3]]), z=-400)    &gt;&gt;&gt; frame_B = nv.FrameB(n_EB_E, yaw=10, pitch=20, roll=30, degrees=True)Step 2: Delta BC decomposed in B    &gt;&gt;&gt; p_BC_B = frame_B.Pvector(np.r_[3000, 2000, 100].reshape((-1, 1)))Step 3: Decompose delta BC in E    &gt;&gt;&gt; p_BC_E = p_BC_B.to_ecef_vector()Step 4: Find point C by adding delta BC to EB    &gt;&gt;&gt; p_EB_E = n_EB_E.to_ecef_vector()    &gt;&gt;&gt; p_EC_E = p_EB_E + p_BC_E    &gt;&gt;&gt; pointC = p_EC_E.to_geo_point()    &gt;&gt;&gt; lat, lon, z = pointC.latlon_deg    &gt;&gt;&gt; msg = 'Ex2: PosC: lat, lon = {:4.4f}, {:4.4f} deg,  height = {:4.2f} m'    &gt;&gt;&gt; msg.format(lat, lon, -z)    'Ex2: PosC: lat, lon = 53.3264, 63.4681 deg,  height = 406.01 m'See also    `Example 2 at www.navlab.net &lt;http://www.navlab.net/nvector/#example_2&gt;`_**Example 3: &quot;ECEF-vector to geodetic latitude&quot;**-------------------------------------------------.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/docs/tutorials/images/ex3img.pngPosition B is given as an &quot;ECEF-vector&quot; p_EB_E (i.e. a vector from E, thecenter of the Earth, to B, decomposed in E).Find the geodetic latitude, longitude and height (latEB, lonEB and hEB),assuming WGS-84 ellipsoid.Solution:    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; wgs84 = nv.FrameE(name='WGS84')    &gt;&gt;&gt; position_B = 6371e3 * np.vstack((0.9, -1, 1.1))  # m    &gt;&gt;&gt; p_EB_E = wgs84.ECEFvector(position_B)    &gt;&gt;&gt; pointB = p_EB_E.to_geo_point()    &gt;&gt;&gt; lat, lon, z = pointB.latlon_deg    &gt;&gt;&gt; 'Ex3: Pos B: lat, lon = {:4.4f}, {:4.4f} deg, height = {:9.3f} m'.format(lat, lon, -z)    'Ex3: Pos B: lat, lon = 39.3787, -48.0128 deg, height = 4702059.834 m'See also    `Example 3 at www.navlab.net &lt;http://www.navlab.net/nvector/#example_3&gt;`_**Example 4: &quot;Geodetic latitude to ECEF-vector&quot;**-------------------------------------------------.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/docs/tutorials/images/ex4img.pngGeodetic latitude, longitude and height are given for position B as latEB,lonEB and hEB, find the ECEF-vector for this position, p_EB_E.Solution:    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; wgs84 = nv.FrameE(name='WGS84')    &gt;&gt;&gt; pointB = wgs84.GeoPoint(latitude=1, longitude=2, z=-3, degrees=True)    &gt;&gt;&gt; p_EB_E = pointB.to_ecef_vector()    &gt;&gt;&gt; 'Ex4: p_EB_E = {} m'.format(p_EB_E.pvector.ravel().tolist())    'Ex4: p_EB_E = [6373290.277218279, 222560.20067473652, 110568.82718178593] m'See also    `Example 4 at www.navlab.net &lt;http://www.navlab.net/nvector/#example_4&gt;`_**Example 5: &quot;Surface distance&quot;**---------------------------------.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/docs/tutorials/images/ex5img.pngFind the surface distance sAB (i.e. great circle distance) between twopositions A and B. The heights of A and B are ignored, i.e. if they don't havezero height, we seek the distance between the points that are at the surface ofthe Earth, directly above/below A and B. The Euclidean distance (chord length)dAB should also be found. Use Earth radius 6371e3 m.Compare the results with exact calculations for the WGS-84 ellipsoid.Solution for a sphere:    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; frame_E = nv.FrameE(a=6371e3, f=0)    &gt;&gt;&gt; positionA = frame_E.GeoPoint(latitude=88, longitude=0, degrees=True)    &gt;&gt;&gt; positionB = frame_E.GeoPoint(latitude=89, longitude=-170, degrees=True)    &gt;&gt;&gt; s_AB, azia, azib = positionA.distance_and_azimuth(positionB)    &gt;&gt;&gt; p_AB_E = positionB.to_ecef_vector() - positionA.to_ecef_vector()    &gt;&gt;&gt; d_AB = p_AB_E.length    &gt;&gt;&gt; msg = 'Ex5: Great circle and Euclidean distance = {}'    &gt;&gt;&gt; msg = msg.format('{:5.2f} km, {:5.2f} km')    &gt;&gt;&gt; msg.format(s_AB / 1000, d_AB / 1000)    'Ex5: Great circle and Euclidean distance = 332.46 km, 332.42 km'Alternative sphere solution:    &gt;&gt;&gt; path = nv.GeoPath(positionA, positionB)    &gt;&gt;&gt; s_AB2 = path.track_distance(method='greatcircle')    &gt;&gt;&gt; d_AB2 = path.track_distance(method='euclidean')    &gt;&gt;&gt; msg.format(s_AB2 / 1000, d_AB2 / 1000)    'Ex5: Great circle and Euclidean distance = 332.46 km, 332.42 km'Exact solution for the WGS84 ellipsoid:    &gt;&gt;&gt; wgs84 = nv.FrameE(name='WGS84')    &gt;&gt;&gt; point1 = wgs84.GeoPoint(latitude=88, longitude=0, degrees=True)    &gt;&gt;&gt; point2 = wgs84.GeoPoint(latitude=89, longitude=-170, degrees=True)    &gt;&gt;&gt; s_12, azi1, azi2 = point1.distance_and_azimuth(point2)    &gt;&gt;&gt; p_12_E = point2.to_ecef_vector() - point1.to_ecef_vector()    &gt;&gt;&gt; d_12 = p_12_E.length    &gt;&gt;&gt; msg = 'Ellipsoidal and Euclidean distance = {:5.2f} km, {:5.2f} km'    &gt;&gt;&gt; msg.format(s_12 / 1000, d_12 / 1000)    'Ellipsoidal and Euclidean distance = 333.95 km, 333.91 km'See also    `Example 5 at www.navlab.net &lt;http://www.navlab.net/nvector/#example_5&gt;`_**Example 6 &quot;Interpolated position&quot;**-------------------------------------.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/docs/tutorials/images/ex6img.pngGiven the position of B at time t0 and t1, n_EB_E(t0) and n_EB_E(t1).Find an interpolated position at time ti, n_EB_E(ti). All positions are givenas n-vectors.Solution:    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; wgs84 = nv.FrameE(name='WGS84')    &gt;&gt;&gt; n_EB_E_t0 = wgs84.GeoPoint(89, 0, degrees=True).to_nvector()    &gt;&gt;&gt; n_EB_E_t1 = wgs84.GeoPoint(89, 180, degrees=True).to_nvector()    &gt;&gt;&gt; path = nv.GeoPath(n_EB_E_t0, n_EB_E_t1)    &gt;&gt;&gt; t0 = 10.    &gt;&gt;&gt; t1 = 20.    &gt;&gt;&gt; ti = 16.  # time of interpolation    &gt;&gt;&gt; ti_n = (ti - t0) / (t1 - t0) # normalized time of interpolation    &gt;&gt;&gt; g_EB_E_ti = path.interpolate(ti_n).to_geo_point()    &gt;&gt;&gt; lat_ti, lon_ti, z_ti = g_EB_E_ti.latlon_deg    &gt;&gt;&gt; msg = 'Ex6, Interpolated position: lat, lon = {:2.1f} deg, {:2.1f} deg'    &gt;&gt;&gt; msg.format(lat_ti, lon_ti)    'Ex6, Interpolated position: lat, lon = 89.8 deg, 180.0 deg'Vectorized solution:    &gt;&gt;&gt; t = np.array([10, 20])    &gt;&gt;&gt; nvectors = wgs84.GeoPoint([89, 89], [0, 180], degrees=True).to_nvector()    &gt;&gt;&gt; nvectors_i = nvectors.interpolate(ti, t, kind='linear')    &gt;&gt;&gt; lati, loni, zi = nvectors_i.to_geo_point().latlon_deg    &gt;&gt;&gt; msg.format(lat_ti, lon_ti)    'Ex6, Interpolated position: lat, lon = 89.8 deg, 180.0 deg'See also    `Example 6 at www.navlab.net &lt;http://www.navlab.net/nvector/#example_6&gt;`_**Example 7: &quot;Mean position&quot;**------------------------------.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/docs/tutorials/images/ex7img.pngThree positions A, B, and C are given as n-vectors n_EA_E, n_EB_E, and n_EC_E.Find the mean position, M, given as n_EM_E.Note that the calculation is independent of the depths of the positions.Solution:    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; points = nv.GeoPoint(latitude=[90, 60, 50],    ...                      longitude=[0, 10, -20], degrees=True)    &gt;&gt;&gt; nvectors = points.to_nvector()    &gt;&gt;&gt; n_EM_E = nvectors.mean()    &gt;&gt;&gt; g_EM_E = n_EM_E.to_geo_point()    &gt;&gt;&gt; lat, lon = g_EM_E.latitude_deg, g_EM_E.longitude_deg    &gt;&gt;&gt; msg = 'Ex7: Pos M: lat, lon = {:4.4f}, {:4.4f} deg'    &gt;&gt;&gt; msg.format(lat, lon)    'Ex7: Pos M: lat, lon = 67.2362, -6.9175 deg'See also    `Example 7 at www.navlab.net &lt;http://www.navlab.net/nvector/#example_7&gt;`_**Example 8: &quot;A and azimuth/distance to B&quot;**--------------------------------------------.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/docs/tutorials/images/ex8img.pngWe have an initial position A, direction of travel given as an azimuth(bearing) relative to north (clockwise), and finally thedistance to travel along a great circle given as sAB.Use Earth radius 6371e3 m to find the destination point B.In geodesy this is known as &quot;The first geodetic problem&quot; or&quot;The direct geodetic problem&quot; for a sphere, and we see that this is similar to`Example 2 &lt;http://www.navlab.net/nvector/#example_2&gt;`_, but now the delta isgiven as an azimuth and a great circle distance. (&quot;The second/inverse geodeticproblem&quot; for a sphere is already solved in Examples`1 &lt;http://www.navlab.net/nvector/#example_1&gt;`_ and`5 &lt;http://www.navlab.net/nvector/#example_5&gt;`_.)Exact solution:    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; frame = nv.FrameE(a=6371e3, f=0)    &gt;&gt;&gt; pointA = frame.GeoPoint(latitude=80, longitude=-90, degrees=True)    &gt;&gt;&gt; pointB, azimuthb = pointA.displace(distance=1000, azimuth=200, degrees=True)    &gt;&gt;&gt; lat, lon = pointB.latitude_deg, pointB.longitude_deg    &gt;&gt;&gt; msg = 'Ex8, Destination: lat, lon = {:4.4f} deg, {:4.4f} deg'    &gt;&gt;&gt; msg.format(lat, lon)    'Ex8, Destination: lat, lon = 79.9915 deg, -90.0177 deg'    &gt;&gt;&gt; np.allclose(azimuthb, -160.01742926820506)    TrueGreatcircle solution:    &gt;&gt;&gt; pointB2, azimuthb = pointA.displace(distance=1000,    ...                                     azimuth=200,    ...                                     degrees=True,    ...                                     method='greatcircle')    &gt;&gt;&gt; lat2, lon2 = pointB2.latitude_deg, pointB.longitude_deg    &gt;&gt;&gt; msg.format(lat2, lon2)    'Ex8, Destination: lat, lon = 79.9915 deg, -90.0177 deg'    &gt;&gt;&gt; np.allclose(azimuthb, -160.0174292682187)    TrueSee also    `Example 8 at www.navlab.net &lt;http://www.navlab.net/nvector/#example_8&gt;`_**Example 9: &quot;Intersection of two paths&quot;**------------------------------------------.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/docs/tutorials/images/ex9img.pngDefine a path from two given positions (at the surface of a spherical Earth),as the great circle that goes through the two points.Path A is given by A1 and A2, while path B is given by B1 and B2.Find the position C where the two great circles intersect.Solution:    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; pointA1 = nv.GeoPoint(10, 20, degrees=True)    &gt;&gt;&gt; pointA2 = nv.GeoPoint(30, 40, degrees=True)    &gt;&gt;&gt; pointB1 = nv.GeoPoint(50, 60, degrees=True)    &gt;&gt;&gt; pointB2 = nv.GeoPoint(70, 80, degrees=True)    &gt;&gt;&gt; pathA = nv.GeoPath(pointA1, pointA2)    &gt;&gt;&gt; pathB = nv.GeoPath(pointB1, pointB2)    &gt;&gt;&gt; pointC = pathA.intersect(pathB)    &gt;&gt;&gt; pointC = pointC.to_geo_point()    &gt;&gt;&gt; lat, lon = pointC.latitude_deg, pointC.longitude_deg    &gt;&gt;&gt; msg = 'Ex9, Intersection: lat, lon = {:4.4f}, {:4.4f} deg'    &gt;&gt;&gt; msg.format(lat, lon)    'Ex9, Intersection: lat, lon = 40.3186, 55.9019 deg'Check that PointC is not between A1 and A2 or B1 and B2:    &gt;&gt;&gt; pathA.on_path(pointC)    False    &gt;&gt;&gt; pathB.on_path(pointC)    FalseCheck that PointC is on the great circle going through path A and path B:    &gt;&gt;&gt; pathA.on_great_circle(pointC)    True    &gt;&gt;&gt; pathB.on_great_circle(pointC)    TrueSee also    `Example 9 at www.navlab.net &lt;http://www.navlab.net/nvector/#example_9&gt;`_**Example 10: &quot;Cross track distance&quot;**--------------------------------------.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/docs/tutorials/images/ex10img.pngPath A is given by the two positions A1 and A2 (similar to the previousexample).Find the cross track distance sxt between the path A (i.e. the great circlethrough A1 and A2) and the position B (i.e. the shortest distance at thesurface, between the great circle and B).Also find the Euclidean distance dxt between B and the plane defined by thegreat circle. Use Earth radius 6371e3.Finally, find the intersection point on the great circle and determine if it isbetween position A1 and A2.Solution:    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; import nvector as nv    &gt;&gt;&gt; frame = nv.FrameE(a=6371e3, f=0)    &gt;&gt;&gt; pointA1 = frame.GeoPoint(0, 0, degrees=True)    &gt;&gt;&gt; pointA2 = frame.GeoPoint(10, 0, degrees=True)    &gt;&gt;&gt; pointB = frame.GeoPoint(1, 0.1, degrees=True)    &gt;&gt;&gt; pathA = nv.GeoPath(pointA1, pointA2)    &gt;&gt;&gt; s_xt = pathA.cross_track_distance(pointB, method='greatcircle')    &gt;&gt;&gt; d_xt = pathA.cross_track_distance(pointB, method='euclidean')    &gt;&gt;&gt; val_txt = '{:4.2f} km, {:4.2f} km'.format(s_xt/1000, d_xt/1000)    &gt;&gt;&gt; 'Ex10: Cross track distance: s_xt, d_xt = {}'.format(val_txt)    'Ex10: Cross track distance: s_xt, d_xt = 11.12 km, 11.12 km'    &gt;&gt;&gt; pointC = pathA.closest_point_on_great_circle(pointB)    &gt;&gt;&gt; np.allclose(pathA.on_path(pointC), True)    TrueSee also    `Example 10 at www.navlab.net &lt;http://www.navlab.net/nvector/#example_10&gt;`_Acknowledgements================The `nvector package &lt;http://pypi.python.org/pypi/nvector/&gt;`_ for`Python &lt;https://www.python.org/&gt;`_ was written by Per A. Brodtkorb at`FFI (The Norwegian Defence Research Establishment) &lt;http://www.ffi.no/en&gt;`_based on the `nvector toolbox &lt;http://www.navlab.net/nvector/#download&gt;`_ for`Matlab &lt;http://www.mathworks.com&gt;`_ written by the navigation group at`FFI &lt;http://www.ffi.no/en&gt;`_. The nvector.core and nvector.rotation module is avectorized reimplementation of the matlab nvector toolbox while the nvector.objectsmodule is a new easy to use object oriented user interface to the nvector corefunctionality documented in [GB20]_.Most of the content is based on the article by K. Gade [Gad10]_.Thus this article should be cited in publications using this page ordownloaded program code.However, if you use any of the FrameE.direct, FrameE.inverse,GeoPoint.distance_and_azimuth or GeoPoint.displace methods you should also citethe article by Karney [Kar13]_ because these methods callKarney's `geographiclib &lt;https://pypi.python.org/pypi/geographiclib&gt;`_ libraryto do the calculations... |pkg_img| image:: https://badge.fury.io/py/nvector.png   :target: https://pypi.python.org/pypi/nvector/.. |tests_img| image:: https://travis-ci.com/pbrod/Nvector.svg?branch=master   :target: https://travis-ci.com/pbrod/Nvector.. |docs_img| image:: https://readthedocs.org/projects/pip/badge/?version=stable   :target: http://Nvector.readthedocs.org/en/stable/.. |health_img| image:: https://api.codeclimate.com/v1/badges/c04214bef610b25906fe/maintainability   :target: https://codeclimate.com/github/pbrod/Nvector/maintainability   :alt: Maintainability.. |coverage_img| image:: https://codecov.io/gh/pbrod/nvector/branch/master/graph/badge.svg   :target: https://codecov.io/gh/pbrod/nvector.. |versions_img| image:: https://img.shields.io/pypi/pyversions/Nvector.svg   :target: https://github.com/pbrod/nvector.. |downloads_img| image:: https://img.shields.io/pypi/dm/nvector.svg   :alt: PyPI - DownloadsReferences==========.. [Gad10] K. Gade, `A Nonsingular Horizontal Position Representation, J. Navigation, 63(3):395-417, 2010.           &lt;http://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf&gt;`_.. [Kar13] C.F.F. Karney. `Algorithms for geodesics. J. Geodesy, 87(1):43-55, 2013. &lt;https://rdcu.be/cccgm&gt;`_.. [GB20] K. Gade and P.A. Brodtkorb, `Nvector Documentation for Python, 2020.           &lt;https://nvector.readthedocs.io/en/v0.7.6&gt;`_=========Changelog=========Version 0.7.7, June 3, 2021================================Per A Brodtkorb (27):      * Added cartopy and matplotlib to requirements.txt      * Updated appveyor.yml, setup.cfg and setup.py      * Updated .gitignore to ignore .pytest_cache      * Corrected failing doctests in objects.py      * Updated version in _installation.py      * Updated failing docstrings for python 2.7 in objects.py.      * Added '# doctest: SKIP' to all plt.show() in order to avoid the doctests hangs on the testserver.      * Fixed a bug  in _info_functional.py      * Updated pycodestyle exlude section in setup.cfg Prettified _examples.py, _examples_object_oriented.py and core.py      * Updated pycodestyle ignore section in setup.cfg      * Added doctest option to setup.cfg      * Removed print statements in test_objects.py      * Return &quot;NotImplemented&quot; instead of raising &quot;NotImplementedError&quot; in Nvector._mul__ and Nvector.__div__ in objects.py      * Fixed .travis.yml so that he file paths in coverage.xml is discoverable         under the sonar.sources folder. The problem is that SonarQube is         analysing the checked-out source code (in src/nvector) but the actual         unit tests and coverage.py is run against the installed code (in         build/lib/nvector). Thus the absolute files paths to the installed code         in the generated coverage.xml were causing Sonar to show no coverage.         The workaround was to use sed in the pipeline to replace every path to         build/lib/nvector with src/nvector in coverage.xml.      * Fixed a bug: Identical expressions should not be used on both sides of a binary operator in test:objects.py.      * Updated solutions to example 9      * Added greatcircle method to GeoPoint.distance_and_azimuth in objects.py      * Added _base_angle function that makes sure an angle is between -pi and pi.       * Added test_direct_and_inverse in test_objects.py      * Added interp_nvectors to docs/reference/nvector_summary.rst      * Added vectorized interpolation routines: interp_nvectors function to core.py and Nvector.interpolate to objects.py.      * Put try except around code in use_docstring to avoid attribute '__doc__'         of 'type' objects is not writable errors for  python2.       * Added interp_nvectors       * Reorganized _displace_great_circle       * Added check that depths also are equal on in _on_ellipsoid_path and in _on_great_circle_path      * Refactored code from use_docstring_from function into the use_docstring         function in _common.py       * Simplified the adding of examples to the docstrings of functions and classes in core.py and objects.py.Version 0.7.6, December 18, 2020================================Per A Brodtkorb (30):      * Renamed _core.py to core.py       * Removed the module index from the appendix because it was incomplete.       * Removed nvector.tests package from the reference chapter.       * Added indent function to _common.py to avoid failure on python 2.7.      * Moved isclose, allclose and array_to_list_dict from objects.py to util.py      * Moved the following function from test_nvector.py to test_rotation.py:          - test_n_E_and_wa2R_EL, test_R2zxy, test_R2zxy_x90, test_R2zxy_y90          - test_R2zxy_z90, test_R2zxy_0, test_R2xyz test_R2xyz_with_vectors       * Replaced assert_array_almost_equal with assert_allclose in test_objects.py      * Renamed test_frames.py to test_objects.py      * Added missing functions great_circle_normal and interpolate to the nvector_summary.rst      * Moved the following functions related to rotation matrices from _core to rotation module:         - E_rotation, n_E_and_wa2R_EL, n_E2R_EN, R_EL2n_E, R_EN2n_E, R2xyz, R2zyx, xyz2R, zyx2R      * Renamed select_ellipsoid to get_ellipsoid       * Moved the following utility functions from _core to util module:         - deg, rad, mdot, nthroot, get_ellipsoid, unit, _check_length_deviation      * Added _get_h1line and _make_summary to _common.py       * Replaced numpy.rollaxis with numpy.swapaxes to make the code clearer.      * _atleast_3d now broadcast the input against each other.      * Added examples to zyx2R       * Added the following references to zyx2R, xyz2R, R2xyz, R2zyx:          - https://en.wikipedia.org/wiki/Aircraft_principal_axes         - https://en.wikipedia.org/wiki/Euler_angles         - https://en.wikipedia.org/wiki/Axes_conventions      * Removed tabs from CHANGELOG.rst      * Updated CHANGELOG.rst and prepared for release v0.7.6      * Fixed the documentation so that it shows correctly in the reference manual.       * Added logo.png and docs/reference/nvector.rst      * Updated build_package.py so it generates a valid README.rst file.      * Updated THANKS.rst      * Updated CHANGELOG.rst and prepare for release 0.7.6      * Added Nvector documentation ref https://nvector.readthedocs.io/en/v0.7.5 to refs1.bib and _acknowledgements.py      * Updated README.rst      * Renamed requirements.readthedocs.txt to docs/requirements.txt       * Added .readthedocs.yml      * Added sphinxcontrib-bibtex to requirements.readthedocs.txt      * Added missing docs/tutorials/images/ex3img.png       * Deleted obsolete ex10img.png       * Updated acknowledgement with reference to Karney's article.      * Updated README.rst by moving acknowledgement to the end with references.      * Renamed position input argument to point in the FrameN, FrameB and FrameL classes.       * Deleted _example_images.py      * Renamed nvector.rst to nvector_summary.rst in docs/reference      * Added example images to tutorials/images/ folder       * Added Nvector logo, install.rst to docs       * Added src/nvector/_example_images.py      * Added docs/tutorials/whatsnext.rst      * Reorganized the documentation in docs by splitting _info.py into:           - _intro.py,           - _documentation.py          - _examples_object_oriented.py          - _images.py          - _installation.py and _acknowledgements.py         * Added docs/tutorials/index.rst, docs/intro/index.rst, docs/how-to/index.rst docs/appendix/index.rst and docs/make.bat      * updated references.Version 0.7.5, December 12, 2020================================Per A Brodtkorb (32):      * Updated CHANGELOG.rst and prepare for release 0.7.5      * Changed so that GeoPath.on_great_circle and GeoPath.on_great_circle         returns scalar result if the two points defining the path are scalars. See issue #10.      * Fixed failing doctests.      * Added doctest configuration to docs/conf.py      * Added allclose to nvector/objects.py      * Added array_to_list_dict and isclose functions in nvector.objects.py         Replaced f-string in the __repr__ method of the _Common class in         nvector.objects.py with format in order to work on python version 3.5         and below.       * Made nvector.plot.py more robust.      * Removed rtol parameter from the on_greatcircle function. See issue #12 for a discussion.      * Added nvector solution to the GeoPoint.displace method.      * Updated docs/conf.py      * Updated README.rst and LICENSE.txt      * Replaced import unittest with import pytest in test_frames.py      * Fixed issue #10: Inconsistent return types in GeoPath.track_distance:         - GeoPath, GeoPoint, Nvector and ECEFvector and Pvector now return           scalars for the case where the input is not actually arrays of points           but just single objects.      * Added extra tests for issue #10 and updated old tests and the examples in the help headers.      * Vectorized FrameE.inverse and FrameE.direct methods.      * Extended deg and rad functions in _core.py.      * Vectorized GeoPoint.distance_and_azimuth      * Made import of cartopy in nvector.plot more robust.      * Updated test_Ex10_cross_track_distance      * Updated sonar-project.properties      * Replaced deprecated sonar.XXXX.reportPath with sonar.XXXX.reportPaths      * Simplified nvector/_core.__doc__      * Updated .travis.yml      * Changed the definition of sonar addon      * Added CC_TEST_REPORTER_ID to .travis.yml      * Added python 3.8 to the CI testing.      * Changed so that setup.py is python 2.7 compatible again.      * Updated build_package.py      * Renamed CHANGES.rst to CHANGELOG.rst      * Updated setup.cfg and setup.py      * Added license.py      * Updated build_package.py      * Removed conda-build from .travis.yml      * Attempt to get travis to run the tests again....      * API change: replaced &quot;python setup.py doctests&quot; with &quot;python setup.py doctest&quot;      * Added doctest example to nvector._core._atleast_3d Made xyz2R and zyx2R code simpler.      * Replaced deprecated Nvector.mean_horizontal_position with  Nvector.mean in test_frames.py      * Added mdot to __all__ in nvector/_core.py and in documentation summary.      * Sorted the the documentation summary by function name in nvector.rst      * Removed --pyargs nvector --doctest-modules --pep8 from addopts section in setup.cfg      * Updated documentation and added missing documentation.Version 0.7.4, June 4, 2019===========================Per A Brodtkorb (2):      * Fixed PyPi badge and added downloads badge in nvector/_info.py and README.rst      * Removed obsolete and wrong badges from docs/index.rstVersion 0.7.3, June 4, 2019===========================Per A Brodtkorb (6):      * Renamed LICENSE.txt and THANKS.txt to LICENSE.rst and THANKS.rst      * Updated README.rst and nvector/_info.py      * Fixed issue 7# incorrect test for test_n_E_and_wa2R_EL.      * Removed coveralls test coverage report.      * Replaced coverage badge from coveralls to codecov.      * Updated code-climate reporter.      * Simplified duplicated code in nvector._core.      * Added tests/__init__.py      * Added &quot;--pyargs nvector&quot; to pytest options in setup.cfg      * Exclude build_package.py from distribution in MANIFEST.in      * Replaced health_img from landscape to codeclimate.      * Updated travis to explicitly install pytest-cov and pytest-pep8      * Removed dependence on pyscaffold      * Added MANIFEST.in      * Renamed set_package_version.py to build_package.pyVersion 0.7.0, June 2, 2019============================Gary van der Merwe (1):      * Add interpolate to __all__ so that it can be importedPer A Brodtkorb (26):      * Updated long_description in setup.cfg      * Replaced deprecated sphinx.ext.pngmath with sphinx.ext.imgmath      * Added imgmath to requirements for building the docs.      * Fixing shallow clone warning.      * Replaced property 'sonar.python.coverage.itReportPath' with         'sonar.python.coverage.reportPaths' instead, because it is has been removed.      * Drop python 3.4 support      * Added python 3.7 support      * Fixed a bug: Mixed scalars and np.array([1]) values don't work with np.rad2deg function.      * Added ETRS ELLIPSOID in _core.py Added ED50 as alias for International         (Hayford)/European Datum in _core.py Added sad69 as alias for South American 1969 in _core.py      * Simplified docstring for nv.test      * Generalized the setup.py.      * Replaced aliases with the correct names in setup.cfg.Version 0.6.0, December 9, 2018===============================Per A Brodtkorb (79):      * Updated requirements in setup.py      * Removed tox.ini      * Updated documentation on how to set package version      * Made a separate script to set package version in nvector/__init__.py      * Updated docstring for select_ellipsoid      * Replace GeoPoint.geo_point with GeoPoint.displace and removed deprecated GeoPoint.geo_point      * Update .travis.yml      * Fix so that codeclimate is able to parse .travis.yml      * Only run sonar and codeclimate reporter for python v3.6      * Added sonar-project.properties      * Pinned coverage to v4.3.4 due to fact that codeclimate reporter is only         compatible with Coverage.py versions &gt;=4.0,&lt;4.4.      * Updated with sonar scanner.      * Added .pylintrc      * Set up codeclimate reporter      * Updated docstring for unit function.      * Avoid division by zero in unit function.      * Reenabled the doctest of plot_mean_position      * Reset &quot;pyscaffold==2.5.11&quot;      * Replaced deprecated basemap with cartopy.      * Replaced doctest of plot_mean_position with test_plot_mean_position in         test_plot.py      * Fixed failing doctests for python v3.4 and v3.5 and made them more         robust.      * Fixed failing doctests and made them more robust.      * Increased pycoverage version to use.      * moved nvector to src/nvector/      * Reset the setup.py to require 'pyscaffold==2.5.11' which works on         python version 3.4, 3.5 and 3.6. as well as 2.7      * Updated unittests.      * Updated tests.      * Removed obsolete code      * Added test for delta_L      * Added corner testcase for         pointA.displace(distance=1000,azimuth=np.deg2rad(200))      * Added test for path.track_distance(method='exact')      * Added delta_L a function thet teturn cartesian delta vector from         positions A to B decomposed in L.      * Simplified OO-solution in example 1 by using delta_N function      * Refactored duplicated code      * Vectorized code so that the frames can take more than one position at         the time.      * Keeping only the html docs in the distribution.      * replaced link from latest to stable docs on readthedocs and updated         crosstrack distance test.      * updated documentation in setup.pyVersion 0.5.2, March 7, 2017============================Per A Brodtkorb (10):      * Fixed tests in tests/test_frames.py      * Updated to setup.cfg and tox.ini + pep8      * updated .travis.yml      * Updated Readme.rst with new example 10 picture and link to nvector docs at readthedocs.      * updated official documentation links      * Updated crosstrack distance tests.Version 0.5.1, March 5, 2017============================Cody (4):     * Explicitely numbered replacement fields     * Migrated `%` string formatingPer A Brodtkorb (29):     * pep8     * Updated failing examples     * Updated README.rst     * Removed obsolete pass statement     * Documented functions     * added .checkignore for quantifycode     * moved test_docstrings and use_docstring_from into _common.py     * Added .codeclimate.yml     * Updated installation information in _info.py     * Added GeoPath.on_path method. Clearified intersection example     * Added great_circle_normal, cross_track_distance     * Renamed intersection to intersect (Intersection is deprecated.)     * Simplified R2zyx with a call to R2xyz Improved accuracy for great circle cross track distance for small distances.     * Added on_great_circle, _on_great_circle_path, _on_ellipsoid_path, closest_point_on_great_circle and closest_point_on_path to GeoPath     * made __eq__ more robust for frames     * Removed duplicated code     * Updated tests     * Removed fishy test     * replaced zero n-vector with nan     * Commented out failing test.     * Added example 10 image     * Added 'closest_point_on_great_circle', 'on_great_circle','on_great_circle_path'.     * Updated examples + documentation     * Updated index depth     * Updated README.rst and classifier in setup.cfgVersion 0.4.1, January 19, 2016===============================pbrod (46):      * Cosmetic updates      * Updated README.rst      * updated docs and removed unused code      * updated README.rst and .coveragerc      * Refactored out _check_frames      * Refactored out _default_frame      * Updated .coveragerc      * Added link to geographiclib      * Updated external link      * Updated documentation      * Added figures to examples      * Added GeoPath.interpolate + interpolation example 6      * Added links to FFI homepage.      * Updated documentation:          - Added link to nvector toolbox for matlab          - For each example added links to the more detailed explanation on the homepage      * Updated link to nvector toolbox for matlab      * Added link to nvector on  pypi      * Updated documentation fro FrameB, FrameE, FrameL and FrameN.      * updated __all__ variable      * Added missing R_Ee to function n_EA_E_and_n_EB_E2azimuth + updated documentation      * Updated CHANGES.rst      * Updated conf.py      * Renamed info.py to _info.py      * All examples are now generated from _examples.py.Version 0.1.3, January 1, 2016==============================pbrod (31):      * Refactored      * Updated tests      * Updated docs      * Moved tests to nvector/tests      * Updated .coverage     Added travis.yml, .landscape.yml      * Deleted obsolete LICENSE      * Updated README.rst      * Removed ngs version      * Fixed bug in .travis.yml      * Updated .travis.yml      * Removed dependence on navigator.py      * Updated README.rst      * Updated examples      * Deleted skeleton.py and added tox.ini      * Renamed distance_rad_bearing_rad2point to n_EA_E_distance_and_azimuth2n_EB_E      * Renamed azimuth to n_EA_E_and_n_EB_E2azimuth           * Added tests for R2xyz as well as R2zyx      * Removed backward compatibility           * Added test_n_E_and_wa2R_EL      * Refactored tests      * Commented out failing tests on python 3+      * updated CHANGES.rst      * Removed bug in setup.pyVersion 0.1.1, January 1, 2016==============================pbrod (31):      * Initial commit: Translated code from Matlab to Python.      * Added object oriented interface to nvector library      * Added tests for object oriented interface      * Added geodesic tests.The content of this library is based on the following publication:Gade, K. (2010). A Nonsingular Horizontal Position Representation, The Journalof Navigation, Volume 63, Issue 03, pp 395-417, July 2010.(www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf)This paper should be cited in publications using this library.Copyright (c) 2015-2021, Norwegian Defence Research Establishment (FFI)All rights reserved.Redistribution and use in source and binary forms, with or withoutmodification, are permitted provided that the following conditions are met:1. Redistributions of source code must retain the above publicationinformation, copyright notice, this list of conditions and the followingdisclaimer.2. Redistributions in binary form must reproduce the above publicationinformation, copyright notice, this list of conditions and the followingdisclaimer in the documentation and/or other materials provided with thedistribution.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITEDTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULARPURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORSBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, ORCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OFSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESSINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER INCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OFTHE POSSIBILITY OF SUCH DAMAGE.============Contributers============* Kenneth Gade, FFI: Main author of Matlab toolbox nvector.* Kristian Svartveit, FFI: Contributions to matlab code: R_Ee.m and unit.m.* Brita Hafskjold Gade, FFI: Contributions to matlab code: n_EB_E2p_EB_E.m, p_EB_E2n_EB_E.m* Per A Brodtkorb, FFI: Translation of nvector from matlab to Python and maintainer of the python version.</longdescription>
</pkgmetadata>