<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># madtypes- üí¢ `MadType` is a Python metaclass that does type-validation at run-time.- üåê Generate [Json-Schema](https://json-schema.org/)- üìñ [Type hints cheat sheet](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html)- üí™ [32 tests](https://github.com/6r17/madtypes/blob/madmeta/tests/test_integrity.py) for the features and usage of MadType class- üí™ [18 tests](https://github.com/6r17/madtypes/blob/madmeta/tests/test_json_schema.py) for the features and usage of json-schema function- **[PEP589](https://peps.python.org/pep-0589/) does not perform type-checking.**&gt; TypedDict type definitions could plausibly used to perform runtime type checking of dictionaries. For example, they could be used to validate that a JSON object conforms to the schema specified by a TypedDict type. This PEP doesn‚Äôt include such functionality, since the focus of this proposal is static type checking only, and other existing types do not support this, as discussed in Class-based syntax. Such functionality can be provided by a third-party library using the [typing_inspect](https://github.com/ilevkivskyi/typing_inspect) third-party module, for example.```pythonfrom typing import TypedDictfrom madtypes import MadTypedef test_simple_dict_incorrect_setattr(): # ü§Ø DOES NOT RAISE ERROR ü§Ø    class Simple(TypedDict):        name: str    Simple(name=2)    a: Simple = { &quot;name&quot;: 2 }class Person(dict, metaclass=MadType): # üí¢ MadType does !    name: strdef test_mad_dict_type_error_with_incorrect_creation():    with pytest.raises(TypeError):        Person(name=2)```|     [![Benchmark](https://github.com/6r17/madtypes/actions/workflows/benchmark.yaml/badge.svg)](https://github.com/6r17/madtypes/actions/workflows/benchmark.yaml)               | Min   | Max   | Mean   | Min (+)        | Max (+)        | Mean (+)       ||----------------------------:|-------|-------|--------|----------------|----------------|----------------|| Correct instantiation      | 0.000 | 0.000 | 0.000  | 0.000 (18.1x) | 0.000 (23.8x) | 0.000 (17.3x) || Incorrect instantiation    | 0.000 | 0.000 | 0.000  | 0.000 (2.6x) | 0.000 (3.7x) | 0.000 (2.9x) |- :warning: MadType instanciation is much slower than pure Python.- :warning: Manually adding type-check inside a class is more effective than using MadType**MadType is appropriate to apply when** :- The described data is a business related element- You are using MadType to assert valid data- You are debugging- The instantiation occurs rarely- The schema has to be communicated with the team - ### json-schema```pythondef test_object_json_schema():    class Item(dict, metaclass=MadType):        name: str    assert json_schema(Item) == {        &quot;type&quot;: &quot;object&quot;,        &quot;properties&quot;: {&quot;name&quot;: {&quot;type&quot;: &quot;string&quot;}},        &quot;required&quot;: [&quot;name&quot;],    }```- ### Further customizationIt is possible to use the `MadType` metaclass customize primitives as well.```pythonclass SomeStringAttribute(str, metaclass=MadType):   passSomeDescriptedAttribute(2) # raise type error```- ### Field descriptionIt is possible to use this to describe a field.```pythonclass SomeDescriptedAttribute(str, metaclass=MadType):    annotation = str    description = &quot;Some description&quot;```using `json_schema` on `SomeDescription` will include the description attribute```pythonclass DescriptedString(str, metaclass=MadType):    description = &quot;Some description&quot;    annotation = strclass DescriptedItem(Schema):    descripted: DescriptedStringassert json_schema(DescriptedItem) == {    &quot;type&quot;: &quot;object&quot;,    &quot;properties&quot;: {        &quot;descripted&quot;: {            &quot;type&quot;: &quot;string&quot;,            &quot;description&quot;: &quot;Some description&quot;,        },    },    &quot;required&quot;: [&quot;descripted&quot;],}```- ### Regular expressionRegex can be defined on an Annotated type using the `pattern` attribute.:warning: be careful to respect the json-schema [specifications](https://json-schema.org/understanding-json-schema/reference/regular_expressions.html) when using `json_schema`At the moment it is not checked nor tested, and will probably render an invalid `json-schema` without warning nor error```pythondef test_pattern_definition_allows_normal_usage():    class PhoneNumber(str, metaclass=MadType):        annotation = str        pattern = r&quot;\d{3}-\d{3}-\d{4}&quot;    PhoneNumber(&quot;000-000-0000&quot;)def test_pattern_raise_type_error():    class PhoneNumber(str, metaclass=MadType):        annotation = str        pattern = r&quot;\d{3}-\d{3}-\d{4}&quot;    with pytest.raises(TypeError):        PhoneNumber(&quot;oops&quot;)def test_pattern_is_rendered_in_json_schema():    class PhoneNumber(str, metaclass=MadType):        annotation = str        pattern = r&quot;^\d{3}-\d{3}-\d{4}$&quot;        description = &quot;A phone number in the format XXX-XXX-XXXX&quot;    class Contact(Schema):        phone: PhoneNumber    schema = json_schema(Contact)    print(json.dumps(schema, indent=4))    assert schema == {        &quot;type&quot;: &quot;object&quot;,        &quot;properties&quot;: {            &quot;phone&quot;: {                &quot;pattern&quot;: &quot;^\\d{3}-\\d{3}-\\d{4}$&quot;,                &quot;description&quot;: &quot;A phone number in the format XXX-XXX-XXXX&quot;,                &quot;type&quot;: &quot;string&quot;,            }        },        &quot;required&quot;: [&quot;phone&quot;],    }```- ### Object validationIt is possible to define a `is_valid` method on a `Schema` object, which is during instantiationto allow restrictions based on multiple fields.```pythondef test_object_validation():    class Item(dict, metaclass=MadType):        title: Optional[str]        content: Optional[str]        def is_valid(self, **kwargs):            &quot;&quot;&quot;title is mandatory if content is absent&quot;&quot;&quot;            if not kwargs.get(&quot;content&quot;, None) and not kwargs.get(                &quot;title&quot;, None            ):                raise TypeError(                    &quot;Either `Title` or `Content` are mandatory for Item&quot;                )    Item(        title=&quot;foo&quot;    )  # we should be able to create with only one of title or content    Item(content=&quot;foo&quot;)    with pytest.raises(TypeError):        Item()```- ### Multiple inheritanceIt is possible to create a schema from existing schemas.:warning: careful not to use MadType of sub-classes as this would triggerand infinite recursion.```pythondef test_multiple_inheritance():    class Foo(dict):        foo: str    class Bar(dict):        bar: str    class FooBar(Foo, Bar, metaclass=MadType):        pass    FooBar(foo=&quot;foo&quot;, bar=&quot;bar&quot;)    with pytest.raises(TypeError):        FooBar()```- ### Dynamicly remove a fieldFields can be removed.```pythondef test_fields_can_be_removed():    @subtract_fields(&quot;name&quot;)    class Foo(dict, metaclass=MadType):        name: str        age: int    Foo(age=2)```[![Test](https://github.com/6r17/madtypes/actions/workflows/test.yaml/badge.svg)](./tests/test_schema.py)[![pypi](https://img.shields.io/pypi/v/madtypes)](https://pypi.org/project/madtypes/)![python: &gt;3.10](https://img.shields.io/badge/python-%3E3.10-informational)### Installation```bashpip3 install madtypes```</longdescription>
</pkgmetadata>