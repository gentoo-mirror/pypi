<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;p align=&quot;center&quot;&gt;  &lt;img src=&quot;https://raw.githubusercontent.com/goodmami/pe/main/docs/_static/pe-logo.svg&quot; alt=&quot;pe logo&quot;&gt;  &lt;br&gt;  &lt;strong&gt;Parsing Expressions&lt;/strong&gt;  &lt;br&gt;  &lt;a href=&quot;https://pypi.org/project/pe/&quot;&gt;&lt;img src=&quot;https://img.shields.io/pypi/v/pe.svg&quot; alt=&quot;PyPI link&quot;&gt;&lt;/a&gt;  &lt;img src=&quot;https://img.shields.io/pypi/pyversions/pe.svg&quot; alt=&quot;Python Support&quot;&gt;  &lt;a href=&quot;https://github.com/goodmami/pe/actions?query=workflow%3A%22Python+package%22&quot;&gt;&lt;img src=&quot;https://github.com/goodmami/pe/workflows/Python%20package/badge.svg&quot; alt=&quot;tests&quot;&gt;&lt;/a&gt;&lt;/p&gt;---**pe** is a library for parsing expressions, including [parsingexpression grammars] (PEGs). It aims to join the expressive power ofparsing expressions with the familiarity of regular expressions. Forexample:```python&gt;&gt;&gt; import pe&gt;&gt;&gt; pe.match(r'&quot;-&quot;? [0-9]+', '-38')  # match an integer&lt;Match object; span=(0, 3), match='-38'&gt;```A grammar can be used for more complicated or recursive patterns:```python&gt;&gt;&gt; float_parser = pe.compile(r'''...   Start    &lt;- INTEGER FRACTION? EXPONENT?...   INTEGER  &lt;- &quot;-&quot;? (&quot;0&quot; / [1-9] [0-9]*)...   FRACTION &lt;- &quot;.&quot; [0-9]+...   EXPONENT &lt;- [Ee] [-+]? [0-9]+... ''')&gt;&gt;&gt; float_parser.match('6.02e23')&lt;Match object; span=(0, 7), match='6.02e23'&gt;```[parsing expression grammars]: https://en.wikipedia.org/wiki/Parsing_expression_grammar**Quick Links*** [Documentation](docs/README.md)  - [Specification](docs/specification.md)  - [Guides](docs/guides/README.md)  - [API Documentation](docs/api/README.md)  - [FAQ](docs/faq.md)* [Example Parsers](examples/)## Features and Goals* Grammar notation is backward-compatible with standard PEG with few extensions* A [specification](docs/specification.md) describes the semantic  effect of parsing (e.g., for mapping expressions to function calls)* Parsers are often faster than other parsing libraries, sometimes by  a lot; see the [benchmarks]* The API is intuitive and familiar; it's modeled on the standard  API's [re] module* Grammar definitions and parser implementations are separate  - Optimizations target the abstract grammar definitions  - Multiple parsers are available (currently [packrat](pe/packrat.py)    for recursive descent and [machine](pe/machine.py) for an    iterative &quot;parsing machine&quot; as from [Medeiros and Ierusalimschy,    2008] and implemented in [LPeg]).[benchmarks]: https://github.com/goodmami/python-parsing-benchmarks[re]: https://docs.python.org/3/library/re.html[Medeiros and Ierusalimschy, 2008]: http://www.inf.puc-rio.br/~roberto/docs/ry08-4.pdf## Syntax Overview**pe** is backward compatible with standard PEG syntax and it isconservative with extensions.```regex# terminals.            # any single character&quot;abc&quot;        # string literal'abc'        # string literal[abc]        # character class# repeating expressionse            # exactly onee?           # zero or one (optional)e*           # zero or moree+           # one or more# combining expressionse1 e2        # sequence of e1 and e2e1 / e2      # ordered choice of e1 and e2(e)          # subexpression# lookahead&amp;e           # positive lookahead!e           # negative lookahead# (extension) capture substring~e           # result of e is matched substring# (extension) bindingname:e       # bind result of e to 'name'# grammarsName &lt;- ...  # define a rule named 'Name'... &lt;- Name  # refer to rule named 'Name'# (extension) auto-ignoreX &lt;  e1 e2   # define a rule 'X' with auto-ignore```## Matching Inputs with Parsing ExpressionsWhen a parsing expression matches an input, it returns a `Match`object, which is similar to those of Python's[re](https://docs.python.org/3/library/re.html) module for regularexpressions. By default, nothing is captured, but the capture operator(`~`) emits the substring of the matching expression, similar toregular expression's capturing groups:```python&gt;&gt;&gt; e = pe.compile(r'[0-9] [.] [0-9]')&gt;&gt;&gt; m = e.match('1.4')&gt;&gt;&gt; m.group()'1.4'&gt;&gt;&gt; m.groups()()&gt;&gt;&gt; e = pe.compile(r'~([0-9] [.] [0-9])')&gt;&gt;&gt; m = e.match('1.4')&gt;&gt;&gt; m.group()'1.4'&gt;&gt;&gt; m.groups()('1.4',)```### Value BindingsA value binding extracts the emitted values of a match and associatesit with a name that is made available in the `Match.groupdict()`dictionary. This is similar to named-capture groups in regularexpressions, except that it extracts the emitted values and not thesubstring of the bound expression.```python&gt;&gt;&gt; e = pe.compile(r'~[0-9] x:(~[.]) ~[0-9]')&gt;&gt;&gt; m = e.match('1.4')&gt;&gt;&gt; m.groups()('1', '4')&gt;&gt;&gt; m.groupdict(){'x': '.'}```### ActionsActions (also called &quot;semantic actions&quot;) are callables that transformparse results. When an arbitrary function is given, it is called asfollows:``` pythonfunc(*match.groups(), **match.groupdict())```The result of this function call becomes the only emitted value goingforward and all bound values are cleared.For more control, **pe** provides the [Action] class and a number ofsubclasses for various use-cases. These actions have access to moreinformation about a parse result and more control over thematch. For example, the [Pack] class takes a function and calls itwith the emitted values packed into a list:``` pythonfunc(match.groups())```And the [Join] class joins all emitted strings with a separator:``` pythonfunc(sep.join(match.groups()), **match.groupdict())```[Action]: docs/api/pe.actions.md#Action[Pack]: docs/api/pe.actions.md#Pack[Join]: docs/api/pe.actions.md#Join### Auto-ignoreThe grammar can be defined such that some rules ignore occurrences ofa pattern between sequence items. Most commonly, this is used toignore whitespace, so the default ignore pattern is simple whitespace.```python&gt;&gt;&gt; pe.match(&quot;X &lt;- 'a' 'b'&quot;, &quot;a b&quot;)  # regular rule does not match&gt;&gt;&gt; pe.match(&quot;X &lt;  'a' 'b'&quot;, &quot;a b&quot;)  # auto-ignore rule matches&lt;Match object; span=(0, 3), match='a b'&gt;```This feature can help to make grammars more readable.### ExampleHere is one way to parse a list of comma-separated integers:```python&gt;&gt;&gt; from pe.actions import Pack&gt;&gt;&gt; p = pe.compile(...   r'''...     Start  &lt;- &quot;[&quot; Values? &quot;]&quot;...     Values &lt;- Int (&quot;,&quot; Int)*...     Int    &lt;  ~( &quot;-&quot;? (&quot;0&quot; / [1-9] [0-9]*) )...   ''',...   actions={'Values': Pack(list), 'Int': int})&gt;&gt;&gt; m = p.match('[5, 10, -15]')&gt;&gt;&gt; m.value()[5, 10, -15]```## Similar Projects- [Lark](https://github.com/lark-parser/lark) (Python)- [nom](https://github.com/Geal/nom) (Rust)- [Parsimonious](https://github.com/erikrose/parsimonious) (Python)- [Rosie](https://rosie-lang.org/) (Multiple bindings)- [TatSu](https://tatsu.readthedocs.io/en/stable/) (Python)- [PEG.js](https://github.com/pegjs/pegjs) (Javascript)- [Pegged](https://github.com/PhilippeSigaud/Pegged) (D)- [pegen](https://github.com/gvanrossum/pegen) (Python / C)- [LPeg] (Lua)[LPeg]: http://www.inf.puc-rio.br/~roberto/lpeg/</longdescription>
</pkgmetadata>