<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>==========================charmonium.freeze==========================.. image:: https://img.shields.io/pypi/v/charmonium.freeze   :alt: PyPI Package   :target: https://pypi.org/project/charmonium.freeze.. image:: https://img.shields.io/pypi/dm/charmonium.freeze   :alt: PyPI Downloads   :target: https://pypi.org/project/charmonium.freeze.. image:: https://img.shields.io/pypi/l/charmonium.freeze   :alt: License   :target: https://github.com/charmoniumQ/charmonium.freeze/blob/main/LICENSE.. image:: https://img.shields.io/pypi/pyversions/charmonium.freeze   :alt: Python Versions   :target: https://pypi.org/project/charmonium.freeze.. image:: https://img.shields.io/librariesio/sourcerank/pypi/charmonium.freeze   :alt: libraries.io sourcerank   :target: https://libraries.io/pypi/charmonium.freeze.. image:: https://img.shields.io/github/stars/charmoniumQ/charmonium.freeze?style=social   :alt: GitHub stars   :target: https://github.com/charmoniumQ/charmonium.freeze.. image:: https://github.com/charmoniumQ/charmonium.freeze/actions/workflows/main.yaml/badge.svg   :alt: CI status   :target: https://github.com/charmoniumQ/charmonium.freeze/actions/workflows/main.yaml.. image:: https://codecov.io/gh/charmoniumQ/charmonium.freeze/branch/main/graph/badge.svg?token=56A97FFTGZ   :alt: Code Coverage   :target: https://codecov.io/gh/charmoniumQ/charmonium.freeze.. image:: https://img.shields.io/github/last-commit/charmoniumQ/charmonium.cache   :alt: GitHub last commit   :target: https://github.com/charmoniumQ/charmonium.freeze/commits.. image:: http://www.mypy-lang.org/static/mypy_badge.svg   :target: https://mypy.readthedocs.io/en/stable/   :alt: Checked with Mypy.. image:: https://img.shields.io/badge/code%20style-black-000000.svg   :target: https://github.com/psf/black   :alt: Code style: blackInjectively, deterministically maps arbitrary objects to hashable, immutable values----------Quickstart----------If you don't have ``pip`` installed, see the `pip install guide`_... _`pip install guide`: https://pip.pypa.io/en/latest/installing/.. code-block:: console    $ pip install charmonium.freezeFor a related project, |charmonium.cache|_, I needed a function thatdeterministically, injectively maps objects to hashable objects.- &quot;Injectively&quot; means ``freeze(a) == freeze(b)`` implies ``a == b``  (with the precondition that ``a`` and ``b`` are of the same type).- &quot;Deterministically&quot; means it should return the same value **across  subsequent process invocations** (with the same interpreter major  and minor version), unlike Python's |hash|_ function, which is not  deterministic between processes.- &quot;Hashable&quot; means one can call ``hash(...)`` on it. All hashable  values are immutable... |hash| replace:: ``hash``.. _`hash`: https://docs.python.org/3.8/reference/datamodel.html#object.__hash__.. |charmonium.cache| replace:: ``charmonium.cache``.. _`charmonium.cache`: https://github.com/charmoniumQ/charmonium.cacheHave you ever felt like you wanted to &quot;freeze&quot; a list of arbitrarydata into a hashable value? Now you can.&gt;&gt;&gt; obj = [1, 2, 3, {4, 5, 6}, object()]&gt;&gt;&gt; hash(obj)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: 'list'&gt;&gt;&gt; from charmonium.freeze import freeze&gt;&gt;&gt; freeze(obj)9561766455304166758-------------Configuration-------------By changing the configuration, we can see the exact data that gets hashed.We can change the configuration in a few ways:- Object-oriented (preferred)  &gt;&gt;&gt; from charmonium.freeze import Config  &gt;&gt;&gt; freeze(obj, Config(use_hash=False))  (1, 2, 3, frozenset({4, 5, 6}), ((('builtins', 'object'),), b'copyreg.__newobj__'))- Global variable, but in this case, we must also clear the cache when we mutate  the config.  &gt;&gt;&gt; from charmonium.freeze import global_config  &gt;&gt;&gt; global_config.use_hash = False  &gt;&gt;&gt; global_config.memo.clear()  &gt;&gt;&gt; freeze(obj)  (1, 2, 3, frozenset({4, 5, 6}), ((('builtins', 'object'),), b'copyreg.__newobj__'))``use_hash=True`` will be faster and produce less data, but I will demonstrateit with ``use_hash=False`` so you can see what data gets included in the state.See the source code ``charmonium/freeze/config.py`` for other configurationoptions.------------------Freezing Functions------------------``freeze`` on functions returns their bytecode, constants, and closure-vars. Theremarkable thing is that this is true across subsequent invocations of the sameprocess. If the user edits the script and changes the function, then it's``freeze`` will change too. This tells you if it is safe to use the cached valueof the function.  ::    (freeze(f) == freeze(g)) implies (for all x, f(x) == g(x))&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt; i = 456&gt;&gt;&gt; func = lambda x: x + i + 123&gt;&gt;&gt; pprint(freeze(func))(('&lt;lambda&gt;', None, 123, b'|\x00t\x00\x17\x00d\x01\x17\x00S\x00'), (('i', 456),))As promised, the frozen value includes the bytecode (``b'|x00t...``), theconstants (123), and the closure variables (456). When we change ``i``, we get adifferent frozen value, indicating that the ``func`` might not becomputationally equivalent to what it was before.&gt;&gt;&gt; i = 789&gt;&gt;&gt; pprint(freeze(func))(('&lt;lambda&gt;', None, 123, b'|\x00t\x00\x17\x00d\x01\x17\x00S\x00'), (('i', 789),))``freeze`` works for objects that use function as data.&gt;&gt;&gt; import functools&gt;&gt;&gt; pprint(freeze(functools.partial(print, 123)))(('print',), ('print', (123,), (), None), (frozenset({'partial',             (...,              ('args', (b'member_descriptor', b'args')),              ('func', (b'member_descriptor', b'func')),              ('keywords', (b'member_descriptor', b'keywords')))}),  ('builtins', 'object')))``freeze`` works for methods.&gt;&gt;&gt; class Greeter:...     def __init__(self, greeting):...         self.greeting = greeting...     def greet(self, name):...         print(self.greeting + &quot; &quot; + name)... &gt;&gt;&gt; pprint(freeze(Greeter.greet))(('greet',  None,  ' ',  b't\x00|\x00j\x01d\x01\x17\x00|\x01\x17\x00\x83\x01\x01\x00d\x00S\x00'),)----------------Freezing Objects----------------``freeze`` works on objects by freezing their state and freezing theirmethods. The state is found by the `pickle protocol`_, which the Python languageimplements by default for all classes. To get an idea of what this returns, call``obj.__reduce_ex__(4)``. Because we reuse an existing protocol, ``freeze`` workcorrectly on most user-defined types... _`pickle protocol`: https://docs.python.org/3/library/pickle.html#pickling-class-instances&gt;&gt;&gt; s = Greeter(&quot;hello&quot;)&gt;&gt;&gt; pprint(s.__reduce_ex__(4))(&lt;function __newobj__ at 0x...&gt;, (&lt;class '__main__.Greeter'&gt;,), {'greeting': 'hello'}, None, None)&gt;&gt;&gt; pprint(freeze(s))(((frozenset({'Greeter',              (('__init__',                (('__init__', None, b'|\x01|\x00_\x00d\x00S\x00'),)),               ('greet',                (('greet',                  None,                  ' ',                  b't\x00|\x00j\x01d\x01\x17\x00|\x01\x17\x00\x83\x01'                  b'\x01\x00d\x00S\x00'),)))}),   ('builtins', 'object')),), (('greeting', 'hello'),), b'copyreg.__newobj__')However, there can still be special cases: ``pickle`` may incorporatenon-deterministic values. In this case, there are three remedies:- If you can tweak the definition of the class, add a method called  ``__getfrozenstate__`` which returns a deterministic snapshot of the  state. This takes precedence over the Pickle protocol, if it is defined.  &gt;&gt;&gt; class Greeter:  ...     def __init__(self, greeting):  ...         self.greeting = greeting  ...     def greet(self, name):  ...         print(self.greeting + &quot; &quot; + name)  ...     def __getfrozenstate__(self):  ...         return self.greeting  ...   &gt;&gt;&gt; pprint(freeze(Greeter(&quot;hello&quot;)))  ((frozenset({'Greeter',               (('__getfrozenstate__',                 (('__getfrozenstate__', None, b'|\x00j\x00S\x00'),)),                ('__init__', (('__init__', None, b'|\x01|\x00_\x00d\x00S\x00'),)),                ('greet',                 (('greet',                   None,                   ' ',                   b't\x00|\x00j\x01d\x01\x17\x00|\x01\x17\x00\x83\x01'                   b'\x01\x00d\x00S\x00'),)))}),    ('builtins', 'object')),   'hello')- Otherwise, you can ignore certain attributes by changing the  configuration. See the source code of ``charmonium/freeze/config.py`` for more  details.  &gt;&gt;&gt; class Greeter:  ...     def __init__(self, greeting):  ...         self.greeting = greeting  ...     def greet(self, name):  ...         print(self.greeting + &quot; &quot; + name)  ...   &gt;&gt;&gt; config = Config(use_hash=False)  &gt;&gt;&gt; config.ignore_attributes.add((&quot;__main__&quot;, &quot;Greeter&quot;, &quot;greeting&quot;))  &gt;&gt;&gt; pprint(freeze(Greeter(&quot;hello&quot;), config))  (((frozenset({'Greeter',                (('__init__',                  (('__init__', None, b'|\x01|\x00_\x00d\x00S\x00'),)),                 ('greet',                  (('greet',                    None,                    ' ',                    b't\x00|\x00j\x01d\x01\x17\x00|\x01\x17\x00\x83\x01'                    b'\x01\x00d\x00S\x00'),)))}),     ('builtins', 'object')),),   (),   b'copyreg.__newobj__')  Note that ``'hello'`` is not present in the frozen object any more.- If you cannot tweak the definition of the class or monkeypatch a  ``__getfrozenstate__`` method, you can still register `single dispatch  handler`_ for that type:  .. _`single dispatch handler`: https://docs.python.org/3/library/functools.html#functools.singledispatch  &gt;&gt;&gt; from typing import Hashable, Optional, Dict, Tuple  &gt;&gt;&gt; from charmonium.freeze import _freeze_dispatch, _freeze  &gt;&gt;&gt; @_freeze_dispatch.register(Greeter)  ... def _(  ...         obj: Greeter,  ...         config: Config,  ...         tabu: Dict[int, Tuple[int, int]],  ...         level: int,  ...         index: int,  ...     ) -&gt; Tuple[Hashable, bool, Optional[int]]:  ...     # Type annotations are optional.  ...     # I have included them here for clarity.  ...   ...     # `tabu` is for object cycle detection. It is handled for you.  ...     # `level` is for logging and recursion limits. It is incremented for you.  ...     # `index` is the &quot;birth order&quot; of the children.  ...     frozen_greeting = _freeze(obj.greeting, config, tabu, level, 0)  ...   ...     return (  ...         frozen_greeting[0],  ...         # Remember that _freeze returns a triple;  ...         # we are only interested in the first element here.  ...   ...         False,  ...         # Whether the obj is immutable  ...         # If the obj is immutable, it's frozen value need not be recomputed every time.  ...         # This is handled for you.  ...   ...         None,  ...         # The depth of references contained here or None  ...         # Currently, this doesn't do anything.  ...     )  ...   &gt;&gt;&gt; freeze(Greeter(&quot;Hello&quot;))  'Hello'----------------Dictionary order----------------As of Python 3.7, dictionaries &quot;remember&quot; their insertion order. As such,&gt;&gt;&gt; freeze({&quot;a&quot;: 1, &quot;b&quot;: 2})(('a', 1), ('b', 2))&gt;&gt;&gt; freeze({&quot;b&quot;: 2, &quot;a&quot;: 1})(('b', 2), ('a', 1))This behavior is controllable by ``Config.ignore_dict_order``, which emits a ``frozenset`` of pairs.&gt;&gt;&gt; config = Config(ignore_dict_order=True)&gt;&gt;&gt; freeze({&quot;b&quot;: 2, &quot;a&quot;: 1}, config) == freeze({&quot;a&quot;: 1, &quot;b&quot;: 2}, config)True--------------Summarize diff--------------This enables a pretty neat utility to compare two arbitrary Python objects.&gt;&gt;&gt; from charmonium.freeze import summarize_diffs&gt;&gt;&gt; obj0 = [0, 1, 2, {3, 4}, {&quot;a&quot;: 5, &quot;b&quot;: 6, &quot;c&quot;: 7}, 8]&gt;&gt;&gt; obj1 = [0, 8, 2, {3, 5}, {&quot;a&quot;: 5, &quot;b&quot;: 7, &quot;d&quot;: 8}]&gt;&gt;&gt; print(summarize_diffs(obj0, obj1))let obj0_sub = obj0let obj1_sub = obj1obj0_sub.__len__() == 6obj1_sub.__len__() == 5obj0_sub[1] == 1obj1_sub[1] == 8obj0_sub[3].has() == 4obj1_sub[3].has() == no such elementobj0_sub[3].has() == no such elementobj1_sub[3].has() == 5obj0_sub[4].keys().has() == cobj1_sub[4].keys().has() == no such elementobj0_sub[4].keys().has() == no such elementobj1_sub[4].keys().has() == dobj0_sub[4]['b'] == 6obj1_sub[4]['b'] == 7And if you don't like my printing style, you can get a programaticaccess to this information.&gt;&gt;&gt; from charmonium.freeze import iterate_diffs&gt;&gt;&gt; for o1, o2 in iterate_diffs(obj0, obj1):...    print(o1, o2, sep=&quot;\n&quot;)ObjectLocation(labels=('obj0', '.__len__()'), objects=(..., 6))ObjectLocation(labels=('obj1', '.__len__()'), objects=(..., 5))ObjectLocation(labels=('obj0', '[1]'), objects=(..., 1))ObjectLocation(labels=('obj1', '[1]'), objects=(..., 8))ObjectLocation(labels=('obj0', '[3]', '.has()'), objects=(...), 4))ObjectLocation(labels=('obj1', '[3]', '.has()'), objects=(..., 'no such element'))ObjectLocation(labels=('obj0', '[3]', '.has()'), objects=(...), 'no such element'))ObjectLocation(labels=('obj1', '[3]', '.has()'), objects=(..., 5))ObjectLocation(labels=('obj0', '[4]', '.keys()', '.has()'), objects=(..., 'c'))ObjectLocation(labels=('obj1', '[4]', '.keys()', '.has()'), objects=(..., 'no such element'))ObjectLocation(labels=('obj0', '[4]', '.keys()', '.has()'), objects=(..., 'no such element'))ObjectLocation(labels=('obj1', '[4]', '.keys()', '.has()'), objects=(..., 'd'))ObjectLocation(labels=('obj0', '[4]', &quot;['b']&quot;), objects=(..., 6))ObjectLocation(labels=('obj1', '[4]', &quot;['b']&quot;), objects=(..., 7))---------Debugging---------Use the following lines to see how ``freeze`` decomposes an object intoprimitive values... code:: python    import logging, os    logger = logging.getLogger(&quot;charmonium.freeze&quot;)    logger.setLevel(logging.DEBUG)    fh = logging.FileHandler(&quot;freeze.log&quot;)    fh.setLevel(logging.DEBUG)    fh.setFormatter(logging.Formatter(&quot;%(message)s&quot;))    logger.addHandler(fh)    logger.debug(&quot;Program %d&quot;, os.getpid())    i = 0    def square_plus_i(x):        # Value of global variable will be included in the function's frozen state.        return x**2 + i    from charmonium.freeze import freeze    freeze(square_plus_i)This produces a log such as in ``freeze.log``:::    freeze begin &lt;function square_plus_i at 0x7f9228bff550&gt;     function &lt;function square_plus_i at 0x7f9228bff550&gt;      tuple (('code', &lt;code object square_plus_i at 0x7f9228c6cf50, file &quot;/tmp/ipython_edit_303agyiz/ipython_edit_rez33yf_.py&quot;, line 2&gt;), 'closure globals', {'i': 0})       tuple ('code', &lt;code object square_plus_i at 0x7f9228c6cf50, file &quot;/tmp/ipython_edit_303agyiz/ipython_edit_rez33yf_.py&quot;, line 2&gt;)        'code'        code &lt;code object square_plus_i at 0x7f9228c6cf50, file &quot;/tmp/ipython_edit_303agyiz/ipython_edit_rez33yf_.py&quot;, line 2&gt;         tuple (None, 2)          None          2         b'|\x00d\x01\x13\x00t\x00\x17\x00S\x00'       'closure globals'       dict {'i': 0}        'i'        0    freeze endI do this to find the differences between subsequent runs:.. code:: shell    $ python code.py    $ mv freeze.log freeze.0.log    $ python code.py    $ mv freeze.log freeze.1.log    $ sed -i 's/at 0x[0-9a-f]*//g' freeze.*.log    # This removes pointer values that appear in the `repr(...)`.    $ meld freeze.0.log freeze.1.log    # Alternatively, use `icdiff` or `diff -u1`.If ``freeze(obj)`` is taking a long time, try adding ``freeze(obj,Config(recursion_limit=20))``. This causes an exception if ``freeze`` recursesmore than a certain number of times. If you hit this exception, consider addingignored class, functions, attributes, or objects in ``Config``.----------Developing----------See `CONTRIBUTING.md`_ for instructions on setting up a development environment... _`CONTRIBUTING.md`: https://github.com/charmoniumQ/charmonium.freeze/tree/main/CONTRIBUTING.md----TODO----- ☐ Correctness  - ☑ Test hashing sets with different orders. Assert tests fail.  - ☑ Test hashing dicts with different orders. Assert tests fail.  - ☑ Don't include properties in hash.  - ☑ Test that freeze of an object includes freeze of its instance methods.  - ☑ Test functions with minor changes.  - ☑ Test set/dict with diff hash.  - ☑ Test obj with slots.  - ☑ Test hash for objects and classes more carefully.  - ☑ Improve test coverage.  - ☑ Investigate when modules are assumed constant.  - ☐ Detect if a module/package has a version. If present, use that. Else, use each attribute.  - ☐ Support closures which include ``import x`` and ``from x import y``- ☑ API  - ☑ Use user-customizable multidispatch.  - ☑ Bring hash into separate package.  - ☑ Make it easier to register a freeze method for a type.  - ☑ Encapsulate global config into object.  - ☑ Make freeze object-oriented with a module-level instance, like ``random.random`` and ``random.Random``.    - This makes it easier for different callers to have their own configuration options.  - ☑ Add an option which returns a single 128-bit int instead of a structured object after a certain depth. This is what ``charmonium.determ_hash`` does. Use this configuration in ``charmonium.cache``.  - ☐ Move &quot;get call graph&quot; into its own package.  - ☐ Document configuration options.  - ☑ Document ``summarize_diff`` and ``iterate_diffs``.  - ☐ Have an API for ignoring modules in ``requirements.txt`` or ``pyproject.toml``, and just tracking them by version.  - ☑ Config object should cascade with ``with config.set(a=b)``- ☑ Make ``freeze`` handle more types:  - ☑ Module: freeze by name.  - ☑ Objects: include the source-code of methods.  - ☑ C extensions. freeze by name, like module  - ☑ Methods  - ☑ fastpath for numpy arrays  - ☑ ``tqdm``  - ☑ ``numpy.int64(1234)``  - ☑ Pandas dataframe  - ☑ Catch Pickle TypeError  - ☑ Catch Pickle ImportError- ☐ Performance  - ☑ Memoize the hash of immutable data:    - If function contains no locals or globals except other immutables, it is immutable.    - If a collection is immutable and contains only immutables, it is immutable.  - ☑ Make performance benchmarks.</longdescription>
</pkgmetadata>