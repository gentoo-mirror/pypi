<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># python-ft4222The FT4222H is a High/Full Speed USB2.0-to-Quad SPI/I2C device controller. This projectprovides (incomplete) python binding to LibFT4222([user guide](http://www.ftdichip.com/Support/Documents/AppNotes/AN_329_User_Guide_for_LibFT4222.pdf)).It provides a similar api than LibFT4222 does.The complete documentation can be found [here](https://msrelectronics.gitlab.io/python-ft4222/)## Example### I2C Master```pythonimport ft4222import ft4222.I2CMaster# list devicesnbDev = ft4222.createDeviceInfoList()for i in range(nbDev):    print(ft4222.getDeviceInfoDetail(i, False))# open device with default description 'FT4222 A'dev = ft4222.openByDescription('FT4222 A')# init i2c master, clock speed 100kHzdev.i2cMaster_Init(100000)# do a i2c transfers where full control is requiredslave = 1 # address# read one byte, don't stopdata = dev.i2cMaster_ReadEx(slave, ft4222.I2CMaster.Flag.REPEATED_START, 1)[0]# read another 5 bytesdata += dev.i2cMaster_ReadEx(slave, ft4222.I2CMaster.Flag.NONE, 5)# another byte, than stopdata += dev.i2cMaster_ReadEx(slave, ft4222.I2CMaster.Flag.STOP, 1)```### GPIO```pythonimport timeimport ft4222from ft4222.GPIO import Dir, Port, Output# open device with default description 'FT4222 A'dev = ft4222.openByDescription('FT4222 A')# use GPIO2 as gpio (not suspend out)dev.setSuspendOut(False)# use GPIO3 as gpio (not wakeup)dev.setWakeUpInterrupt(False)# init GPIO2 as outputdev.gpio_Init(gpio2 = Dir.OUTPUT)# generate a square wave signal with GPIO2while True:    dev.gpio_Write(Port.P2, output)    output = not output    time.sleep(0.1)```### SPI Master and GPIOThe gpio used in this example indicate the duration of the whole spi transfer and is **not** used as chip/slave select.```pythonimport ft4222from ft4222.SPI import Cpha, Cpolfrom ft4222.SPIMaster import Mode, Clock, SlaveSelectfrom ft4222.GPIO import Port, Dirfrom time import sleep# open 'device' with default description 'FT4222 A'devA = ft4222.openByDescription('FT4222 A')# and the second 'device' on the same chipdevB = ft4222.openByDescription('FT4222 B')# init spi masterdevA.spiMaster_Init(Mode.SINGLE, Clock.DIV_8, Cpha.CLK_LEADING, Cpol.IDLE_LOW, SlaveSelect.SS0)# also use gpiodevB.gpio_Init(gpio0 = Dir.OUTPUT)# generate data to senddata = bytes([x for x in range(256)]*4)# set port0 1 (-&gt; note this is *not* the spi chip select, the chip select (SS0) is generated by the spi core)devB.gpio_Write(Port.P0, 1)for _ in range(3):    # write data in a single write    devA.spiMaster_SingleWrite(data, True)    # wait a short while    sleep(0.5)# set port0 0devB.gpio_Write(Port.P0, 1)```## AccessrightsUnder Linux, the usb device is normally not accessibly by a normal user, therefora udev rule is required. Create or extend ``/etc/udev/rules.d/99-ftdi.rules`` tocontain the following text:```bash# FTDI's ft4222 USB-I2C AdapterSUBSYSTEM==&quot;usb&quot;, ATTRS{idVendor}==&quot;0403&quot;, ATTRS{idProduct}==&quot;601c&quot;, GROUP=&quot;plugdev&quot;, MODE=&quot;0666&quot;```## Requirements### WindowsMSVCR100.dll/MSVCP100.dll from Microsoft Visual C++ 2010 Redistributable Packageneed to be installed. Today, on most systems, these DLLs (or the package) shouldalready be installed.</longdescription>
</pkgmetadata>