<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>***************************************  Python Electronic Design Automation***************************************PyEDA is a Python library for electronic design automation.`Read the docs! &lt;http://pyeda.rtfd.org&gt;`_.. image:: https://travis-ci.org/cjdrake/pyeda.png?branch=master   :target: https://travis-ci.org/cjdrake/pyedaFeatures========* Symbolic Boolean algebra with a selection of function representations:  * Logic expressions  * Truth tables, with three output states (0, 1, &quot;don't care&quot;)  * Reduced, ordered binary decision diagrams (ROBDDs)* SAT solvers:  * Backtracking  * `PicoSAT &lt;http://fmv.jku.at/picosat&gt;`_* `Espresso &lt;http://embedded.eecs.berkeley.edu/pubs/downloads/espresso/index.htm&gt;`_ logic minimization* Formal equivalence* Multi-dimensional bit vectors* DIMACS CNF/SAT parsers* Logic expression parserDownload========Bleeding edge code::   $ git clone git://github.com/cjdrake/pyeda.gitFor release tarballs and zipfiles,visit PyEDA's page at the`Cheese Shop &lt;https://pypi.python.org/pypi/pyeda&gt;`_.Installation============Latest release version using`pip &lt;http://www.pip-installer.org/en/latest&gt;`_::   $ pip3 install pyedaInstallation from the repository::   $ python3 setup.py installNote that you will need to have Python headers and libraries in order tocompile the C extensions.For MacOS, the standard Python installation should have everything you need.For Linux, you will probably need to install the Python3 &quot;development&quot; package.For Debian-based systems (eg Ubuntu, Mint)::   $ sudo apt-get install python3-devFor RedHat-based systems (eg RHEL, Centos)::   $ sudo yum install python3-develFor Windows, just grab the binaries from Christoph Gohlke's*excellent* `pythonlibs page &lt;http://www.lfd.uci.edu/~gohlke/pythonlibs/&gt;`_.Logic Expressions=================Invoke your favorite Python terminal,and invoke an interactive ``pyeda`` session::   &gt;&gt;&gt; from pyeda.inter import *Create some Boolean expression variables::   &gt;&gt;&gt; a, b, c, d = map(exprvar, &quot;abcd&quot;)Construct Boolean functions using overloaded Python operators:``~`` (NOT), ``|`` (OR), ``^`` (XOR), ``&amp;`` (AND), ``&gt;&gt;`` (IMPLIES)::   &gt;&gt;&gt; f0 = ~a &amp; b | c &amp; ~d   &gt;&gt;&gt; f1 = a &gt;&gt; b   &gt;&gt;&gt; f2 = ~a &amp; b | a &amp; ~b   &gt;&gt;&gt; f3 = ~a &amp; ~b | a &amp; b   &gt;&gt;&gt; f4 = ~a &amp; ~b &amp; ~c | a &amp; b &amp; c   &gt;&gt;&gt; f5 = a &amp; b | ~a &amp; cConstruct Boolean functions using standard function syntax::   &gt;&gt;&gt; f10 = Or(And(Not(a), b), And(c, Not(d)))   &gt;&gt;&gt; f11 = Implies(a, b)   &gt;&gt;&gt; f12 = Xor(a, b)   &gt;&gt;&gt; f13 = Xnor(a, b)   &gt;&gt;&gt; f14 = Equal(a, b, c)   &gt;&gt;&gt; f15 = ITE(a, b, c)   &gt;&gt;&gt; f16 = Nor(a, b, c)   &gt;&gt;&gt; f17 = Nand(a, b, c)Construct Boolean functions using higher order operators::   &gt;&gt;&gt; OneHot(a, b, c)   And(Or(~a, ~b), Or(~a, ~c), Or(~b, ~c), Or(a, b, c))   &gt;&gt;&gt; OneHot0(a, b, c)   And(Or(~a, ~b), Or(~a, ~c), Or(~b, ~c))   &gt;&gt;&gt; Majority(a, b, c)   Or(And(a, b), And(a, c), And(b, c))   &gt;&gt;&gt; AchillesHeel(a, b, c, d)   And(Or(a, b), Or(c, d))Investigate a function's properties::   &gt;&gt;&gt; f0.support   frozenset({a, b, c, d})   &gt;&gt;&gt; f0.inputs   (a, b, c, d)   &gt;&gt;&gt; f0.top   a   &gt;&gt;&gt; f0.degree   4   &gt;&gt;&gt; f0.cardinality   16   &gt;&gt;&gt; f0.depth   2Convert expressions to negation normal form (NNF),with only OR/AND and literals::   &gt;&gt;&gt; f11.to_nnf()   Or(~a, b)   &gt;&gt;&gt; f12.to_nnf()   Or(And(~a, b), And(a, ~b))   &gt;&gt;&gt; f13.to_nnf()   Or(And(~a, ~b), And(a, b))   &gt;&gt;&gt; f14.to_nnf()   Or(And(~a, ~b, ~c), And(a, b, c))   &gt;&gt;&gt; f15.to_nnf()   Or(And(a, b), And(~a, c))   &gt;&gt;&gt; f16.to_nnf()   And(~a, ~b, ~c)   &gt;&gt;&gt; f17.to_nnf()   Or(~a, ~b, ~c)Restrict a function's input variables to fixed values,and perform function composition::   &gt;&gt;&gt; f0.restrict({a: 0, c: 1})   Or(b, ~d)   &gt;&gt;&gt; f0.compose({a: c, b: ~d})   Or(And(~c, ~d), And(c, ~d))Test function formal equivalence::   &gt;&gt;&gt; f2.equivalent(f12)   True   &gt;&gt;&gt; f4.equivalent(f14)   TrueInvestigate Boolean identities::   # Double complement   &gt;&gt;&gt; ~~a   a   # Idempotence   &gt;&gt;&gt; a | a   a   &gt;&gt;&gt; And(a, a)   a   # Identity   &gt;&gt;&gt; Or(a, 0)   a   &gt;&gt;&gt; And(a, 1)   a   # Dominance   &gt;&gt;&gt; Or(a, 1)   1   &gt;&gt;&gt; And(a, 0)   0   # Commutativity   &gt;&gt;&gt; (a | b).equivalent(b | a)   True   &gt;&gt;&gt; (a &amp; b).equivalent(b &amp; a)   True   # Associativity   &gt;&gt;&gt; Or(a, Or(b, c))   Or(a, b, c)   &gt;&gt;&gt; And(a, And(b, c))   And(a, b, c)   # Distributive   &gt;&gt;&gt; (a | (b &amp; c)).to_cnf()   And(Or(a, b), Or(a, c))   &gt;&gt;&gt; (a &amp; (b | c)).to_dnf()   Or(And(a, b), And(a, c))   # De Morgan's   &gt;&gt;&gt; Not(a | b).to_nnf()   And(~a, ~b)   &gt;&gt;&gt; Not(a &amp; b).to_nnf()   Or(~a, ~b)Perform Shannon expansions::   &gt;&gt;&gt; a.expand(b)   Or(And(a, ~b), And(a, b))   &gt;&gt;&gt; (a &amp; b).expand([c, d])   Or(And(a, b, ~c, ~d), And(a, b, ~c, d), And(a, b, c, ~d), And(a, b, c, d))Convert a nested expression to disjunctive normal form::   &gt;&gt;&gt; f = a &amp; (b | (c &amp; d))   &gt;&gt;&gt; f.depth   3   &gt;&gt;&gt; g = f.to_dnf()   &gt;&gt;&gt; g   Or(And(a, b), And(a, c, d))   &gt;&gt;&gt; g.depth   2   &gt;&gt;&gt; f.equivalent(g)   TrueConvert between disjunctive and conjunctive normal forms::   &gt;&gt;&gt; f = ~a &amp; ~b &amp; c | ~a &amp; b &amp; ~c | a &amp; ~b &amp; ~c | a &amp; b &amp; c   &gt;&gt;&gt; g = f.to_cnf()   &gt;&gt;&gt; h = g.to_dnf()   &gt;&gt;&gt; g   And(Or(a, b, c), Or(a, ~b, ~c), Or(~a, b, ~c), Or(~a, ~b, c))   &gt;&gt;&gt; h   Or(And(~a, ~b, c), And(~a, b, ~c), And(a, ~b, ~c), And(a, b, c))Multi-Dimensional Bit Vectors=============================Create some four-bit vectors, and use slice operators::   &gt;&gt;&gt; A = exprvars('a', 4)   &gt;&gt;&gt; B = exprvars('b', 4)   &gt;&gt;&gt; A   farray([a[0], a[1], a[2], a[3]])   &gt;&gt;&gt; A[2:]   farray([a[2], a[3]])   &gt;&gt;&gt; A[-3:-1]   farray([a[1], a[2]])Perform bitwise operations using Python overloaded operators:``~`` (NOT), ``|`` (OR), ``&amp;`` (AND), ``^`` (XOR)::   &gt;&gt;&gt; ~A   farray([~a[0], ~a[1], ~a[2], ~a[3]])   &gt;&gt;&gt; A | B   farray([Or(a[0], b[0]), Or(a[1], b[1]), Or(a[2], b[2]), Or(a[3], b[3])])   &gt;&gt;&gt; A &amp; B   farray([And(a[0], b[0]), And(a[1], b[1]), And(a[2], b[2]), And(a[3], b[3])])   &gt;&gt;&gt; A ^ B   farray([Xor(a[0], b[0]), Xor(a[1], b[1]), Xor(a[2], b[2]), Xor(a[3], b[3])])Reduce bit vectors using unary OR, AND, XOR::   &gt;&gt;&gt; A.uor()   Or(a[0], a[1], a[2], a[3])   &gt;&gt;&gt; A.uand()   And(a[0], a[1], a[2], a[3])   &gt;&gt;&gt; A.uxor()   Xor(a[0], a[1], a[2], a[3])Create and test functions that implement non-trivial logic such as arithmetic::   &gt;&gt;&gt; from pyeda.logic.addition import *   &gt;&gt;&gt; S, C = ripple_carry_add(A, B)   # Note &quot;1110&quot; is LSB first. This says: &quot;7 + 1 = 8&quot;.   &gt;&gt;&gt; S.vrestrict({A: &quot;1110&quot;, B: &quot;1000&quot;}).to_uint()   8Other Function Representations==============================Consult the `documentation &lt;http://pyeda.rtfd.org&gt;`_ for information abouttruth tables, and binary decision diagrams.Each function representation has different trade-offs,so always use the right one for the job.PicoSAT SAT Solver C Extension==============================PyEDA includes an extension to the industrial-strength`PicoSAT &lt;http://fmv.jku.at/picosat&gt;`_ SAT solving engine.Use the ``satisfy_one`` method to finding a single satisfying input point::   &gt;&gt;&gt; f = OneHot(a, b, c)   &gt;&gt;&gt; f.satisfy_one()   {a: 0, b: 0, c: 1}Use the ``satisfy_all`` method to iterate through all satisfying input points::   &gt;&gt;&gt; list(f.satisfy_all())   [{a: 0, b: 0, c: 1}, {a: 0, b: 1, c: 0}, {a: 1, b: 0, c: 0}]For more interesting examples, see the following documentation chapters:* `Solving Sudoku &lt;http://pyeda.readthedocs.org/en/latest/sudoku.html&gt;`_* `All Solutions to the Eight Queens Puzzle &lt;http://pyeda.readthedocs.org/en/latest/queens.html&gt;`_Espresso Logic Minimization C Extension=======================================PyEDA includes an extension to the famous Espresso library for the minimizationof two-level covers of Boolean functions.Use the ``espresso_exprs`` function to minimize multiple expressions::   &gt;&gt;&gt; f1 = Or(~a &amp; ~b &amp; ~c, ~a &amp; ~b &amp; c, a &amp; ~b &amp; c, a &amp; b &amp; c, a &amp; b &amp; ~c)   &gt;&gt;&gt; f2 = Or(~a &amp; ~b &amp; c, a &amp; ~b &amp; c)   &gt;&gt;&gt; f1m, f2m = espresso_exprs(f1, f2)   &gt;&gt;&gt; f1m   Or(And(~a, ~b), And(a, b), And(~b, c))   &gt;&gt;&gt; f2m   And(~b, c)Use the ``espresso_tts`` function to minimize multiple truth tables::   &gt;&gt;&gt; X = exprvars('x', 4)   &gt;&gt;&gt; f1 = truthtable(X, &quot;0000011111------&quot;)   &gt;&gt;&gt; f2 = truthtable(X, &quot;0001111100------&quot;)   &gt;&gt;&gt; f1m, f2m = espresso_tts(f1, f2)   &gt;&gt;&gt; f1m   Or(x[3], And(x[0], x[2]), And(x[1], x[2]))   &gt;&gt;&gt; f2m   Or(x[2], And(x[0], x[1]))Execute Unit Test Suite=======================If you have `Nose &lt;http://nose.readthedocs.org/en/latest&gt;`_ installed,run the unit test suite with the following command::   $ make testIf you have `Coverage &lt;https://pypi.python.org/pypi/coverage&gt;`_ installed,generate a coverage report (including HTML) with the following command::   $ make coverPerform Static Lint Checks==========================If you have `Pylint &lt;http://www.pylint.org&gt;`_ installed,perform static lint checks with the following command::   $ make lintBuild the Documentation=======================If you have `Sphinx &lt;http://sphinx-doc.org&gt;`_ installed,build the HTML documentation with the following command::   $ make htmlPython Versions Supported=========================PyEDA is developed using Python 3.3+.It is **NOT** compatible with Python 2.7, or Python 3.2.Citations=========I recently discovered that people actually use this software in the real world.Feel free to send me a pull request if you would like your project listed hereas well.* `A Model-Based Approach for Reliability Assessment in Component-Based Systems &lt;https://www.phmsociety.org/sites/phmsociety.org/files/phm_submission/2014/phmc_14_025.pdf&gt;`_* `bunsat &lt;http://www.react.uni-saarland.de/tools/bunsat&gt;`_,  used for the SAT paper `Fast DQBF Refutation &lt;http://www.react.uni-saarland.de/publications/sat14.pdf&gt;`_.* `Solving Logic Riddles with PyEDA &lt;http://nicky.vanforeest.com/misc/pyeda/puzzle.html&gt;`_Contact the Authors===================* Chris Drake (cjdrake AT gmail DOT com), http://cjdrake.github.io</longdescription>
</pkgmetadata>