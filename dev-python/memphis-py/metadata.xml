<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;div align=&quot;center&quot;&gt;    ![github memphis banner](https://user-images.githubusercontent.com/70286779/229371212-8531c1e1-1a9d-4bbe-9285-b4dbb8601bfa.jpeg)  &lt;/div&gt;&lt;div align=&quot;center&quot;&gt;  &lt;h4&gt;**[Memphis](https://memphis.dev)** is a next-generation alternative to traditional message brokers.  &lt;/h4&gt;    &lt;a href=&quot;https://landscape.cncf.io/?selected=memphis&quot;&gt;&lt;img width=&quot;200&quot; alt=&quot;CNCF Silver Member&quot; src=&quot;https://github.com/cncf/artwork/raw/master/other/cncf-member/silver/white/cncf-member-silver-white.svg#gh-dark-mode-only&quot;&gt;&lt;/a&gt;  &lt;/div&gt;&lt;div align=&quot;center&quot;&gt;    &lt;img width=&quot;200&quot; alt=&quot;CNCF Silver Member&quot; src=&quot;https://github.com/cncf/artwork/raw/master/other/cncf-member/silver/color/cncf-member-silver-color.svg#gh-light-mode-only&quot;&gt;  &lt;/div&gt;  &lt;p align=&quot;center&quot;&gt;  &lt;a href=&quot;https://memphis.dev/docs/&quot;&gt;Docs&lt;/a&gt; - &lt;a href=&quot;https://twitter.com/Memphis_Dev&quot;&gt;Twitter&lt;/a&gt; - &lt;a href=&quot;https://www.youtube.com/channel/UCVdMDLCSxXOqtgrBaRUHKKg&quot;&gt;YouTube&lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://discord.gg/WZpysvAeTf&quot;&gt;&lt;img src=&quot;https://img.shields.io/discord/963333392844328961?color=6557ff&amp;label=discord&quot; alt=&quot;Discord&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/memphisdev/memphis/issues?q=is%3Aissue+is%3Aclosed&quot;&gt;&lt;img src=&quot;https://img.shields.io/github/issues-closed/memphisdev/memphis?color=6557ff&quot;&gt;&lt;/a&gt;   &lt;img src=&quot;https://img.shields.io/npm/dw/memphis-dev?color=ffc633&amp;label=installations&quot;&gt;&lt;a href=&quot;https://github.com/memphisdev/memphis/blob/master/CODE_OF_CONDUCT.md&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Code%20of%20Conduct-v1.0-ff69b4.svg?color=ffc633&quot; alt=&quot;Code Of Conduct&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://docs.memphis.dev/memphis/release-notes/releases/v0.4.2-beta&quot;&gt;&lt;img alt=&quot;GitHub release (latest by date)&quot; src=&quot;https://img.shields.io/github/v/release/memphisdev/memphis?color=61dfc6&quot;&gt;&lt;/a&gt;&lt;img src=&quot;https://img.shields.io/github/last-commit/memphisdev/memphis?color=61dfc6&amp;label=last%20commit&quot;&gt;&lt;/p&gt;A simple, robust, and durable cloud-native message broker wrapped with&lt;br&gt;an entire ecosystem that enables cost-effective, fast, and reliable development of modern queue-based use cases.&lt;br&gt;&lt;br&gt;Memphis enables the building of modern queue-based applications that require&lt;br&gt;large volumes of streamed and enriched data, modern protocols, zero ops, rapid development,&lt;br&gt;extreme cost reduction, and a significantly lower amount of dev time for data-oriented developers and data engineers.## Installation```sh$ pip3 install memphis-py```## Importing```pythonfrom memphis import Memphis, Headersfrom memphis.types import Retention, Storage```### Connecting to MemphisFirst, we need to create Memphis `object` and then connect with Memphis by using `memphis.connect`.```pythonasync def main():  try:    memphis = Memphis()    await memphis.connect(      host=&quot;&lt;memphis-host&gt;&quot;,      username=&quot;&lt;application-type username&gt;&quot;,      account_id=&quot;&lt;account_id&gt;&quot;, # You can find it on the profile page in the Memphis UI. This field should be sent only on the cloud version of Memphis, otherwise it will be ignored      connection_token=&quot;&lt;broker-token&gt;&quot;, # you will get it on application type user creation      password=&quot;&lt;string&gt;&quot;, # depends on how Memphis deployed - default is connection token-based authentication      port=&quot;&lt;port&gt;&quot;, # defaults to 6666      reconnect=True, # defaults to True      max_reconnect=3, # defaults to 3      reconnect_interval_ms=1500, # defaults to 1500      timeout_ms=1500, # defaults to 1500      # for TLS connection:      key_file='&lt;key-client.pem&gt;',       cert_file='&lt;cert-client.pem&gt;',       ca_file='&lt;rootCA.pem&gt;'      )    ...  except Exception as e:    print(e)  finally:    await memphis.close()if __name__ == '__main__':  asyncio.run(main())```Once connected, the entire functionalities offered by Memphis are available.### Disconnecting from MemphisTo disconnect from Memphis, call `close()` on the memphis object.```pythonawait memphis.close()```### Creating a Station**Unexist stations will be created automatically through the SDK on the first producer/consumer connection with default values.**&lt;br&gt;&lt;br&gt;_If a station already exists nothing happens, the new configuration will not be applied_```pythonstation = memphis.station(  name=&quot;&lt;station-name&gt;&quot;,  schema_name=&quot;&lt;schema-name&gt;&quot;,  retention_type=Retention.MAX_MESSAGE_AGE_SECONDS, # MAX_MESSAGE_AGE_SECONDS/MESSAGES/BYTES. Defaults to MAX_MESSAGE_AGE_SECONDS  retention_value=604800, # defaults to 604800  storage_type=Storage.DISK, # Storage.DISK/Storage.MEMORY. Defaults to DISK  replicas=1, # defaults to 1  idempotency_window_ms=120000, # defaults to 2 minutes  send_poison_msg_to_dls=True, # defaults to true  send_schema_failed_msg_to_dls=True, # defaults to true  tiered_storage_enabled=False # defaults to false)```### Retention typesMemphis currently supports the following types of retention:```pythonmemphis.types.Retention.MAX_MESSAGE_AGE_SECONDS```Means that every message persists for the value set in retention value field (in seconds)```pythonmemphis.types.Retention.MESSAGES```Means that after max amount of saved messages (set in retention value), the oldest messages will be deleted```pythonmemphis.types.Retention.BYTES```Means that after max amount of saved bytes (set in retention value), the oldest messages will be deleted### Retention ValuesThe `retention values` are directly related to the `retention types` mentioned above, where the values vary according to the type of retention chosen.All retention values are of type `int` but with different representations as follows:`memphis.types.Retention.MAX_MESSAGE_AGE_SECONDS` is represented **in seconds**, `memphis.types.Retention.MESSAGES` in a **number of messages** and finally `memphis.types.Retention.BYTES` in a **number of bytes**.After these limits are reached oldest messages will be deleted.### Storage typesMemphis currently supports the following types of messages storage:```pythonmemphis.types.Storage.DISK```Means that messages persist on disk```pythonmemphis.types.Storage.MEMORY```Means that messages persist on the main memory### Destroying a StationDestroying a station will remove all its resources (producers/consumers)```pythonstation.destroy()```### Attaching a Schema to an Existing Station```pythonawait memphis.attach_schema(&quot;&lt;schema-name&gt;&quot;, &quot;&lt;station-name&gt;&quot;)```### Detaching a Schema from Station```pythonawait memphis.detach_schema(&quot;&lt;station-name&gt;&quot;)```### Produce and Consume messagesThe most common client operations are `produce` to send messages and `consume` toreceive messages.Messages are published to a station and consumed from it by creating a consumer.Consumers are pull based and consume all the messages in a station unless you are using a consumers group, in this case messages are spread across all members in this group.Memphis messages are payload agnostic. Payloads are `bytearray`.In order to stop getting messages, you have to call `consumer.destroy()`. Destroy will terminate regardlessof whether there are messages in flight for the client.### Creating a Producer```pythonproducer = await memphis.producer(station_name=&quot;&lt;station-name&gt;&quot;, producer_name=&quot;&lt;producer-name&gt;&quot;, generate_random_suffix=False)```### Producing a messageWithout creating a producer.In cases where extra performance is needed the recommended way is to create a producer firstand produce messages by using the produce function of it```pythonawait memphis.produce(station_name='test_station_py', producer_name='prod_py',  message='bytearray/protobuf class/dict/string/graphql.language.ast.DocumentNode', # bytearray / protobuf class (schema validated station - protobuf) or bytearray/dict (schema validated station - json schema) or string/bytearray/graphql.language.ast.DocumentNode (schema validated station - graphql schema)   generate_random_suffix=False, #defaults to false  ack_wait_sec=15, # defaults to 15  headers=headers, # default to {}  async_produce=False, #defaults to false  msg_id=&quot;123&quot;)```With creating a producer```pythonawait producer.produce(  message='bytearray/protobuf class/dict/string/graphql.language.ast.DocumentNode', # bytearray / protobuf class (schema validated station - protobuf) or bytearray/dict (schema validated station - json schema) or string/bytearray/graphql.language.ast.DocumentNode (schema validated station - graphql schema)  ack_wait_sec=15) # defaults to 15```### Add headers```pythonheaders= Headers()headers.add(&quot;key&quot;, &quot;value&quot;)await producer.produce(  message='bytearray/protobuf class/dict/string/graphql.language.ast.DocumentNode', # bytearray / protobuf class (schema validated station - protobuf) or bytearray/dict (schema validated station - json schema) or string/bytearray/graphql.language.ast.DocumentNode (schema validated station - graphql schema)  headers=headers) # default to {}```### Async produceMeaning your application won't wait for broker acknowledgement - use only in case you are tolerant for data loss```pythonawait producer.produce(  message='bytearray/protobuf class/dict/string/graphql.language.ast.DocumentNode', # bytearray / protobuf class (schema validated station - protobuf) or bytearray/dict (schema validated station - json schema) or string/bytearray/graphql.language.ast.DocumentNode (schema validated station - graphql schema)  headers={}, async_produce=True)```### Message IDStations are idempotent by default for 2 minutes (can be configured), Idempotency achieved by adding a message id```pythonawait producer.produce(  message='bytearray/protobuf class/dict', # bytes / protobuf class (schema validated station - protobuf) or bytes/dict (schema validated station - json schema)  headers={},   async_produce=True,  msg_id=&quot;123&quot;)```### Destroying a Producer```pythonproducer.destroy()```### Creating a Consumer```pythonconsumer = await memphis.consumer(  station_name=&quot;&lt;station-name&gt;&quot;,  consumer_name=&quot;&lt;consumer-name&gt;&quot;,  consumer_group=&quot;&lt;group-name&gt;&quot;, # defaults to the consumer name  pull_interval_ms=1000, # defaults to 1000  batch_size=10, # defaults to 10  batch_max_time_to_wait_ms=5000, # defaults to 5000  max_ack_time_ms=30000, # defaults to 30000  max_msg_deliveries=10, # defaults to 10  generate_random_suffix=False,  start_consume_from_sequence=1, # start consuming from a specific sequence. defaults to 1  last_messages=-1 # consume the last N messages, defaults to -1 (all messages in the station))```### Setting a context for message handler function```pythoncontext = {&quot;key&quot;: &quot;value&quot;}consumer.set_context(context)```### Processing messagesOnce all the messages in the station were consumed the msg_handler will receive error: `Memphis: TimeoutError`.```pythonasync def msg_handler(msgs, error, context):  for msg in msgs:    print(&quot;message: &quot;, msg.get_data())    await msg.ack()  if error:    print(error)consumer.consume(msg_handler)```### Fetch a single batch of messages```pythonmsgs = await memphis.fetch_messages(  station_name=&quot;&lt;station-name&gt;&quot;,  consumer_name=&quot;&lt;consumer-name&gt;&quot;,  consumer_group=&quot;&lt;group-name&gt;&quot;, # defaults to the consumer name  batch_size=10, # defaults to 10  batch_max_time_to_wait_ms=5000, # defaults to 5000  max_ack_time_ms=30000, # defaults to 30000  max_msg_deliveries=10, # defaults to 10  generate_random_suffix=False  start_consume_from_sequence=1 # start consuming from a specific sequence. defaults to 1  last_messages=-1 # consume the last N messages, defaults to -1 (all messages in the station)))```### Fetch a single batch of messages after creating a consumer```pythonmsgs = await consumer.fetch(batch_size=10) # defaults to 10```### Acknowledge a messageAcknowledge a message indicates the Memphis server to not re-send the same message again to the same consumer / consumers group```pythonawait message.ack()```### Delay the message after a given durationDelay the message and tell Memphis server to re-send the same message again to the same consumer group. The message will be redelivered only in case `consumer.max_msg_deliveries` is not reached yet.```pythonawait message.delay(delay_in_seconds)```### Get headers Get headers per message```pythonheaders = message.get_headers()```### Get message sequence numberGet message sequence number```pythonsequence_number = msg.get_sequence_number()```### Destroying a Consumer```pythonconsumer.destroy()```### Check connection status```pythonmemphis.is_connected()```</longdescription>
</pkgmetadata>