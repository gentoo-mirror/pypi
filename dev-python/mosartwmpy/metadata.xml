<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>[![build](https://github.com/IMMM-SFA/mosartwmpy/actions/workflows/build.yml/badge.svg)](https://github.com/IMMM-SFA/mosartwmpy/actions/workflows/build.yml)[![codecov](https://codecov.io/gh/IMMM-SFA/mosartwmpy/branch/main/graph/badge.svg?token=IPOY8984MB)](https://codecov.io/gh/IMMM-SFA/mosartwmpy)[![DOI](https://joss.theoj.org/papers/10.21105/joss.03221/status.svg)](https://doi.org/10.21105/joss.03221)[![DOI](https://zenodo.org/badge/312114600.svg)](https://zenodo.org/badge/latestdoi/312114600)## mosartwmpy`mosartwmpy` is a python translation of MOSART-WM, a model for water routing and reservoir management written in Fortran. The original code can be found at [IWMM](https://github.com/IMMM-SFA/iwmm) and [E3SM](https://github.com/E3SM-Project/E3SM), in which MOSART is the river routing component of a larger suite of earth-science models. The motivation for rewriting is largely for developer convenience -- running, debugging, and adding new capabilities were becoming increasingly difficult due to the complexity of the codebase and lack of familiarity with Fortran. This version aims to be intuitive, lightweight, and well documented, while still being highly interoperable.For a quick start, check out the [Jupyter notebook tutorial](https://github.com/IMMM-SFA/mosartwmpy/blob/main/notebooks/tutorial.ipynb)!## getting startedEnsure you have Python &gt;= 3.8 available (consider using a [virtual environment](https://github.com/pyenv/pyenv), see the docs [here](https://mosartwmpy.readthedocs.io/en/latest/virtualenv.html) for a brief tutorial), then install `mosartwmpy` with:```shellpip install mosartwmpy```Alternatively, install via conda with:```shellconda install -c conda-forge mosartwmpy```Download a sample input dataset spanning May 1981 by running the following and selecting option `1` for &quot;tutorial&quot;. This will download and unpack the inputs to your current directory. Optionally specify a path to download and extract to instead of the current directory.```shellpython -m mosartwmpy.download```Settings are defined by the merger of the `mosartwmpy/config_defaults.yaml` and a user specified file which can override any of the default settings. Create a `config.yaml` file that defines your simulation (if you chose an alternate download directory in the step above, you will need to update the paths to point at your data):&gt; `config.yaml`&gt; ```yaml&gt; simulation:&gt;   name: tutorial&gt;   start_date: 1981-05-24&gt;   end_date: 1981-05-26&gt;&gt; grid:&gt;   path: ./input/domains/mosart_conus_nldas_grid.nc&gt;&gt; runoff:&gt;   read_from_file: true&gt;   path: ./input/runoff/runoff_1981_05.nc&gt;&gt; water_management:&gt;   enabled: true&gt;   demand:&gt;     read_from_file: true&gt;     path: ./input/demand/demand_1981_05.nc&gt;   reservoirs:&gt;     enable_istarf: true&gt;     parameters:&gt;       path: ./input/reservoirs/reservoirs.nc&gt;     dependencies:&gt;       path: ./input/reservoirs/dependency_database.parquet&gt;     streamflow:&gt;       path: ./input/reservoirs/mean_monthly_reservoir_flow.parquet&gt;     demand:&gt;       path: ./input/reservoirs/mean_monthly_reservoir_demand.parquet&gt; ````mosartwmpy` implements the [Basic Model Interface](https://csdms.colorado.edu/wiki/BMI) defined by the CSDMS, so driving it should be familiar to those accustomed to the BMI. To launch the simulation, open a python shell and run the following:```pythonfrom mosartwmpy import Model# path to the configuration yaml fileconfig_file = 'config.yaml'# initialize the modelmosart_wm = Model()mosart_wm.initialize(config_file)# advance the model one timestepmosart_wm.update()# advance until the `simulation.end_date` specified in config.yamlmosart_wm.update_until(mosart_wm.get_end_time())```## model inputInput for `mosartwmpy` consists of many files defining the characteristics of the discrete grid, the river network, surface and subsurface runoff, water demand, and dams/reservoirs.Currently, the gridded data is expected to be provided at the same spatial resolution.Runoff input can be provided at any time resolution; each timestep will select the runoff at the closest time in the past.Currently, demand input is read monthly but will also pad to the closest time in the past.Efforts are under way for more robust demand handling.Dams/reservoirs require four different input files: the physical characteristics, the average monthly flow expected during the simulation period, the average monthly demand expected during the simulation period, and a database mapping each GRanD ID to grid cell IDs allowed to extract water from it.These dam/reservoir input files can be generated from raw GRanD data, raw elevation data, and raw ISTARF data using the [provided utility](mosartwmpy/utilities/CREATE_GRAND_PARAMETERS.md).The best way to understand the expected format of the input files is to examine the sample inputs provided by the download utility: `python -m mosartwmpy.download`.#### multi-file inputTo use multi-file demand or runoff input, use year/month/day placeholders in the file path options like so:* If your files look like `runoff-1999.nc`, use `runoff-{Y}.nc` as the path* If your files look like `runoff-1999-02.nc`, use `runoff-{Y}-{M}.nc` as the path* If your files look like `runoff-1999-02-03`, use `runoff-{Y}-{M}-{D}.nc` as the path, but be sure to provide files for leap days as well!## model outputBy default, key model variables are output on a monthly basis at a daily averaged resolution to `./output/&lt;simulation name&gt;/&lt;simulation name&gt;_&lt;year&gt;_&lt;month&gt;.nc`. See the configuration file for examples of how to modify the outputs, and the `./mosartwmpy/state/state.py` file for state variable names.Alternatively, certain model outputs deemed most important can be accessed using the BMI interface methods. For example:```pythonfrom mosartwmpy import Modelmosart_wm = Model()mosart_wm.initialize()# get a list of model output variablesmosart_wm.get_output_var_names()# get the flattened numpy.ndarray of values for an output variablesupply = mosart_wm.get_value_ptr('supply_water_amount')```## subdomainsTo simulate only a subset of basins (defined here as a collection of grid cells that share the same outlet cell),use the configuration option `grid -&gt; subdomain` (see example below) and provide a list of latitude/longitudecoordinate pairs representing each basin of interest (any single coordinate pair within the basin). For example, tosimulate only the Columbia River basin and the Lake Washington regions, one could enter the coordinates for Portland andSeattle:&gt; `config.yaml`&gt; ```yaml&gt; grid:&gt;   subdomain:&gt;     - 47.6062,-122.3321&gt;     - 45.5152,-122.6784&gt;   unmask_output: true&gt; ```By default, the output files will still store empty NaN-like values for grid cells outside the subdomain, butfor even faster simulations and smaller output files set the `grid -&gt; unmask_output` option to `false`. Disabling this option causes the output files to only store values for grid cells within the subdomain. These smaller fileswill likely take extra processing to effectively interoperate with other models.## visualization`Model` instances can plot the current value of certain input and output variables (those available from `Model.get_output_var_name` and `Model.get_input_var_names`):```pythonfrom mosartwmpy import Modelconfig_file = 'config.yaml'mosart_wm = Model()mosart_wm.initialize(config_file)for _ in range(8):    mosart_wm.update()mosart_wm.plot_variable('outgoing_water_volume_transport_along_river_channel', log_scale=True)```![River transport](https://github.com/IMMM-SFA/mosartwmpy/raw/main/docs/_static/river_transport.png)Using provided utility functions, the output of a simulation can be plotted as well.Plot the storage, inflow, and outflow of a particular GRanD dam:```pythonfrom mosartwmpy import Modelfrom mosartwmpy.plotting.plot import plot_reservoirconfig_file = 'config.yaml'mosart_wm = Model()mosart_wm.initialize(config_file)mosart_wm.update_until()plot_reservoir(    model=mosart_wm,    grand_id=310,    start='1981-05-01',    end='1981-05-31',)```![Grand Coulee](https://github.com/IMMM-SFA/mosartwmpy/raw/main/docs/_static/grand_coulee_1981_05.png)Plot a particular output variable (as defined in `config.yaml`) over time:```pythonfrom mosartwmpy import Modelfrom mosartwmpy.plotting.plot import plot_variableconfig_file = 'config.yaml'mosart_wm = Model()mosart_wm.initialize(config_file)mosart_wm.update_until()plot_variable(    model=mosart_wm,    variable='RIVER_DISCHARGE_OVER_LAND_LIQ',    start='1981-05-01',    end='1981-05-31',    log_scale=True,    cmap='winter_r',)```![River network no tiles](https://github.com/IMMM-SFA/mosartwmpy/raw/main/docs/_static/river_without_tiles_1981_05.png)If `cartopy`, `scipy`, and `geoviews` are installed, tiles can be displayed along with the plot:```pythonplot_variable(    model=mosart_wm,    variable='RIVER_DISCHARGE_OVER_LAND_LIQ',    start='1981-05-01',    end='1981-05-31',    log_scale=True,    cmap='winter_r',    tiles='StamenWatercolor')```![River network with tiles](https://github.com/IMMM-SFA/mosartwmpy/raw/main/docs/_static/river_with_tiles_1981_05.png)## model couplingA common use case for `mosartwmpy` is to run coupled with output from the Community Land Model (CLM). To see an example of how to drive `mosartwmpy` with runoff from a coupled model, check out the [Jupyter notebook tutorial](https://github.com/IMMM-SFA/mosartwmpy/blob/main/notebooks/tutorial.ipynb)!## testing and validationBefore running the tests or validation, make sure to download the &quot;sample_input&quot; and &quot;validation&quot; datasets using the download utility `python -m mosartwmpy.download`.To execute the tests, run `./test.sh` or `python -m unittest discover mosartwmpy/tests` from the repository root.To execute the validation, run a model simulation that includes the years 1981 - 1982, note your output directory, and then run `python -m mosartwmpy.validate` from the repository root. This will ask you for the simulation output directory, think for a moment, and then open a figure with several plots representing the NMAE (Normalized Mean Absolute Error) as a percentage and the spatial sums of several key variables compared between your simulation and the validation scenario. Use these plots to assist you in determining if the changes you have made to the code have caused unintended deviation from the validation scenario. The NMAE should be 0% across time if you have caused no deviations. A non-zero NMAE indicates numerical difference between your simulation and the validation scenario. This might be caused by changes you have made to the code, or alternatively by running a simulation with different configuration or parameters (i.e. larger timestep, fewer iterations, etc). The plots of the spatial sums can assist you in determining what changed and the overall magnitude of the changes.If you wish to merge code changes that intentionally cause significant deviation from the validation scenario, please work with the maintainers to create a new validation dataset.</longdescription>
</pkgmetadata>