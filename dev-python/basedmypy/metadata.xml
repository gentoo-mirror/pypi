<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Basedmypy -- Based Static Typing for Python===========================================Ever tried to use pythons type system and thought to yourself &quot;This doesn't seem based&quot;.Well fret no longer as basedmypy got you covered!Baseline--------Basedmypy has baseline, baseline is based! It allows you to adopt new strictness or featureswithout the burden of fixing up every usage, just save all current errors to the baselinefile and deal with them later... code-block:: python    def foo(a):        print(a).. code-block:: bash    &gt; mypy test.py    error: missing typehints !!!!!    Epic fail bro!    &gt; mypy --write-baseline test.py    test.py:1:1: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]    Baseline successfully written to .mypy/baseline.json    &gt; mypy test.py    Success: no issues found in 1 source fileThen on subsequent runs the existing errors will be filtered out... code-block:: python    def foo(a):        print(a)    def bar(b: str, c: int) -&gt; bool:        return b + c.. code-block:: bash    &gt; mypy test.py    test.py:4:5: error: Returning Any from function declared to return &quot;bool&quot;  [no-any-return]    test.py:4:16: error: Unsupported operand types for + (&quot;str&quot; and &quot;int&quot;)  [operator]    Found 2 errors in 1 file (checked 1 source file)Intersection Types------------------Using the ``&amp;`` operator or ``basedtyping.Intersection`` you can denote intersection types... code-block:: python    class Growable(ABC, Generic[T]):        @abstractmethod        def add(self, item: T): ...    class Resettable(ABC):        @abstractmethod        def reset(self): ...    def f(x: Resettable &amp; Growable[str]):        x.reset()        x.add(&quot;first&quot;)Type Joins----------Mypy joins types like so:.. code-block:: python    a: int    b: str    reveal_type(a if bool() else b)  # Revealed type is &quot;builtins.object&quot;Basedmypy joins types into unions instead:.. code-block:: python    a: int    b: str    reveal_type(a if bool() else b)  # Revealed type is &quot;int | str&quot;Bare Literals-------------``Literal`` is so cumbersome! just use a bare literal instead... code-block:: python    class Color(Enum):        RED = auto()    a: 1 | 2    b: True | Color.REDDefault Return Type-------------------With the ``default_return`` option, the default return type of functions becomes ``None`` instead of `Any`... code-block:: python    def f(name: str):        print(f&quot;Hello, {name}!&quot;)    reveal_type(f)  # (str) -&gt; NoneNested TypeVars---------------With nested ``TypeVar``\s you are able to have functions with polymorphic generic parameters... code-block:: python    E = TypeVar(&quot;E&quot;)    I = TypeVar(&quot;I&quot;, bound=Iterable[E])    def foo(i: I, e: E) -&gt; I:        assert e not in i        return i    reveal_type(foo([&quot;based&quot;], &quot;mypy&quot;))  # N: Revealed type is &quot;list[str]&quot;    reveal_type(foo({1, 2}, 3))  # N: Revealed type is &quot;set[int]&quot;Overload Implementation Inference---------------------------------Specifying types in overload implementations is completely redundant! basedmypy will infer them... code-block:: python    @overload    def f(a: int) -&gt; str: ...    @overload    def f(a: str) -&gt; int: ...    def f(a):        reveal_type(a)  # int | str        return None  # error: expected str | int    class A:        @property        def foo(self) -&gt; int: ...        @foo.setter        def foo(self, value): ...  # no need for annotationsInfer Function Parameters-------------------------Infer the type of a function parameter from it's default value... code-block:: python    def f(a=1, b=True):        reveal_type((a, b))  # (int, bool)Better Types in Messages------------------------.. code-block:: python    T = TypeVar(&quot;T&quot;, bound=int)    def f(a: T, b: list[str | 1 | 2]) -&gt; Never:        reveal_type((a, b))    reveal_type(f)Mypy shows::    Revealed type is &quot;Tuple[T`-1, Union[builtins.str, Literal[1], Literal[2]]]&quot;    Revealed type is &quot;def [T &lt;: builtins.int] (a: T`-1, b: Union[builtins.str, Literal[1], Literal[2]]) -&gt; &lt;nothing&gt;&quot;Basedmypy shows::    Revealed type is &quot;(T@f, str | 1 | 2)&quot;    Revealed type is &quot;def [T: int] (a: T, b: str | 1 | 2) -&gt; Never&quot;Ignore Unused Type Ignores--------------------------In code that is targeting multiple versions of python or multiple platforms it is difficultto work with `type: ignore` comments and use the `warn_unused_ignore` option.The ``unused-ignore`` error code can be used for this situation... code-block:: python    if sys.platform != &quot;linux&quot;:      foo()  # type: ignore[misc, unused-ignore]</longdescription>
</pkgmetadata>