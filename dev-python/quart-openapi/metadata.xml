<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>=============Quart-OpenAPI=============.. image:: https://travis-ci.com/factset/quart-openapi.svg?branch=master   :target: https://travis-ci.com/factset/quart-openapiDocumentation can be found on https://factset.github.io/quart-openapi/.. inclusion-marker-do-not-removeQuart-OpenAPI is an extension for Quart_ that adds support for generating a openapi.json file using openapi 3.0.If you are familiar with Quart_, this just wraps around it to add a openapi.json route similar to Flask-RESTX_generating a swagger.json route and adds a Resource base class for building RESTful APIs.Compatibility=============Quart-OpenAPI requires Python 3.6+ because Quart_ requires it.Starting from version 1.6.0, Quart-OpenAPI requires python 3.7+ in order to avoid having to maintain multiple versionsof function definitions for compatibility with the older versions of Quart_ that supported Python 3.6.Installation============You can install via pip.. code-block:: console    $ pip install quart-openapiIf you are developing the module and want to also be able to build the documentation, make sureto also install the dependencies from the extras 'doc' package like so:.. code-block:: console    $ pip install 'quart-openapi[doc]'    $ python setup.py build_sphinxQuick Start===========If you're familiar with Quart_ then the quick start doesn't change much:.. code-block:: python    from quart_openapi import Pint, Resource    app = Pint(__name__, title='Sample App')    @app.route('/')    class Root(Resource):      async def get(self):        '''Hello World Route        This docstring will show up as the description and short-description        for the openapi docs for this route.        '''        return &quot;hello&quot;This is equivalent to using the following with Quart_ as normal:.. code-block:: python    from quart import Quart    app = Quart(__name__)    @app.route('/')    async def hello():      return &quot;hello&quot;Except that by using ``Pint`` and ``Resource`` it will alsoadd a route for '/openapi.json' which will contain the documentation of the route and use the docstring for thedescription.Unit Tests==========Unit tests can be run through setuptools also:.. code-block:: console    $ python setup.py testRequest Validation==================Request validation like you can get with Flask-RESTX_!You can either create validator models on the fly or you can create a jsonschema document for base modelsand then use references to it. For an on-the-fly validator:.. code-block:: python    expected = app.create_validator('sample_request', {      'type': 'object',      'properties': {        'foobar': {          'type': 'string'        },        'baz': {          'oneOf': [            { 'type': 'integer' },            { 'type': 'number', 'format': 'float' }          ]        }      }    })    @app.route('/')    class Sample(Resource):      @app.expect(expected)      async def post(self):        # won't get here if the request didn't match the expected schema        data = await request.get_json()        return jsonify(data)The default content type is 'application/json', but you can specify otherwise in the decorator:.. code-block:: json   {     &quot;$schema&quot;: &quot;http://json-schema.org/schema#&quot;,     &quot;id&quot;: &quot;schema.json&quot;,     &quot;components&quot;: {       &quot;schemas&quot;: {         &quot;binaryData&quot;: {           &quot;type&quot;: &quot;string&quot;,           &quot;format&quot;: &quot;binary&quot;         }       }     }   }.. code-block:: python   app = Pint(__name__, title='Validation Example',                 base_model_schema='schema.json')   stream = app.create_ref_validator('binaryData', 'schemas')   @app.route('/')   class Binary(Resource):     @app.expect((stream, 'application/octet-stream',                  {'description': 'gzip compressed data'}))     @app.response(HTTPStatus.OK, 'Success')     async def post(self):       # if the request didn't have a 'content-type' header with a value       # of 'application/octet-stream' it will be rejected as invalid.       raw_data = await request.get_data(raw=True)       # ... do something with the data       return &quot;Success!&quot;In the example above, it'll open, read, and json parse the file *schema.json* and then use it as the basisfor referencing models and creating validators. Currently the validator won't do more than validate content-typefor content-types other than 'application/json'... _Quart: https://pgjones.gitlab.io/quart/.. _Flask-RESTX: https://flask-restx.readthedocs.io/en/stable/</longdescription>
</pkgmetadata>