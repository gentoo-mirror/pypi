<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># SlinkInspired by [uplink](https://uplink.readthedocs.io/en/stable/), a simple way to build rest API clients without OpenAPI,and without a lot of requests boilerplate.## Install```shellpoetry install```## Basic UsageModel your resource in Pydantic```pythonfrom pydantic import BaseModelclass MyResource(BaseModel):    name: str    value: int```Create an API```pythonfrom slink import Api, get, post, Query, Bodyclass MyTestApi(Api):    # Define a get    @get(&quot;rest/api/3/{resource_key}&quot;)    def get_resource(self, resource_key: str):        return MyResource(**self.response.json())    # Define it with some query params    @get(&quot;rest/api/3/{resource_key}/param&quot;, testvalue=Query())    def get_resource_with_param(self, resource_key: str, testvalue: str):        return MyResource(**self.response.json())    # And post your body content    @post(&quot;rest/api/3/{resource_key}&quot;, body=Body())    def post_resource(self, resource_key: str, body: dict):        return MyResource(**self.response.json())```Then use it:```pythonapi = MyTestApi(base_url=&quot;http://example.com/&quot;)result = api.get_resource(resource_key=&quot;REST&quot;)result = api.get_resource_with_param(resource_key=&quot;REST&quot;, testvalue=&quot;test&quot;)result = api.post_resource(resource_key=&quot;TEST&quot;, body={&quot;foo&quot;: &quot;bar&quot;})```## PaginationSlink allows you to elegantly iterate most style of paged APIs. As example, we can implement one of the most commonpagination patterns, an an offseted pagination API. With such an API, you request an offset of the dataset with somelimit on the size of the data returned:```pythonclass OffsettedPager:    def __init__(self, max_count=5) -&gt; None:        self.max_count = max_count    def pages(self, url: str) -&gt; Generator[Tuple[str, dict], requests.Response, None]:        start_at = 0        total = None        while total is None or start_at &lt; total:            # yield a tuple of the next url and any parameters to be added to the original request, get back the response to update the iteration            response = yield url, {                &quot;startAt&quot;: start_at,                &quot;maxCount&quot;: self.max_count,            }            total = response.json()[&quot;total&quot;]            start_at += self.max_count```You can then use the pager with the `@get_pages` decorator to iterate through the pages:```pythonclass PagedApi(Api):    @get_pages(&quot;rest/api/3/pages&quot;, pager=OffsetedPager())    def get_paginated(self)        # our data field in the json result just contains a list of ints, but they could be a much more complicated object        for value in self.response.json()[&quot;data&quot;]:            yield int(value)api = PagedApi(base_url=base_url)all_results = list(api.get_paginated())  # note the list construction because pages are returned as generators```Another example would be a pagination API where there is a next link:```pythonclass LinkedPager:    def pages(self, url) -&gt; Generator[Tuple[str, dict], requests.Response, None]:        response = yield url, {}  # first page is just the raw url        # use assignment operator since python 3.8        while next_url := response.json()[&quot;links&quot;].get(&quot;next&quot;):            response = yield next_url, {}```Note in both cases, iteration can be stopped early by simply stopping calling the endpoint, ie the following will makeany more requests once it finds the required value:```pythonfor e in api.get_paginated():    if e == value_to_find:        break```## Limitations and TODOs- [x] ~~put, delete~~- [ ] error handling and robustness- [ ] retry patterns- [ ] patch, head- [ ] supporting other http client libraries, including async ones</longdescription>
</pkgmetadata>