<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># BG-SpaceAnatomical space conventions made easy.[![Python Version](https://img.shields.io/pypi/pyversions/bg-space.svg)](https://pypi.org/project/bg-space)[![PyPI](https://img.shields.io/pypi/v/bg-space.svg)](https://pypi.org/project/bg-space)[![Build Status](https://travis-ci.com/brainglobe/bg-space.svg?branch=master)](https://travis-ci.com/brainglobe/bg-space)[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)[![Coverage Status](https://coveralls.io/repos/github/brainglobe/bg-space/badge.svg)](https://coveralls.io/github/brainglobe/bg-space)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/python/black)[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.4552537.svg)](https://doi.org/10.5281/zenodo.4552537)Working with anatomical images, one often encounters the problem of matching the orientation of stacks with different conventions about axes orientation and order. Moreover, when multiple swaps and flips are involved, it can be annoying to map the same transformations to volumes and points (e.g., coordinates or meshes).`bg-space` provides a neat way of defining an anatomical space, and of operating stacks and point transformations between spaces.If you use `bg-space` for your analyses, please cite its Zenodo DOI https://zenodo.org/record/4552537#.YDAFzi1Q2Rs!## InstallationYou can install `bg-space` with:```pip install bg-space```## UsageTo define a new anatomical space, it is sufficient to give the directions of the stack origin position:```pythonsource_origin = (&quot;Left&quot;, &quot;Superior&quot;, &quot;Anterior&quot;)target_origin = (&quot;Inferior&quot;, &quot;Posterior&quot;, &quot;Right&quot;)```A stack can be then easily transformed from the source to the target space:```pythonimport bg_space as bgimport numpy as npstack = np.random.rand(3, 2, 4)mapped_stack = bg.map_stack_to(source_origin, target_origin, stack)```The transformation is handled only with numpy index operations; *i.e.*, no compleximage affine transformations are applied. This is often useful as the preparatory step for starting any kind of image registration.A shortened syntax can be used to define a space using initials of the origin directions:```pythonmapped_stack = bg.map_stack_to(&quot;lsa&quot;, &quot;ipr&quot;, stack)```---**NOTE**When you work with a stack, the origin is the upper left corner when you show the first element `stack[0, :, :]` with matplotlib or when you open the stack with ImageJ. First dimension is the one that you are slicing, the second the height of the image, and the third the width of the image.---## The `AnatomicalSpace` classSometimes, together with the stack we have to move a set of points (cell coordinates, meshes, etc.). This introduces the additional complexity of keeping track, together with the axes swaps and flips, of the change of the origin offset.To handle this situation, we can define a source space using the `AnatomicalSpace`class, specifying also the stack shape:```pythonstack = np.random.rand(3, 2, 4)  # a stack in source spaceannotations = np.array([[0, 0, 0], [2, 1, 3]])  # related point annotationssource_space = bg.AnatomicalSpace(target_origin, stack.shape)mapped_stack = source_space.map_stack_to(&quot;ipr&quot;, stack)  # transform the stackmapped_annotations = source_space.map_points_to(&quot;ipr&quot;, annotations)  # transform the points```The points are transformed through the generation of a transformation matrix.Finally, if we want to log this matrix (e.g., to reconstruct the full transformations sequence of a registration), we can get it:```pythontarget_space = bg.AnatomicalSpace(&quot;ipr&quot;, stack.shape)transformation_matrix = source_space.transformation_matrix_to(target_space)#Â equivalent to:transformation_matrix = source_space.transformation_matrix_to(&quot;ipr&quot;, stack.shape)```The target get always be defined as a `bg.AnatomicalSpace` object, or a valid origin specification plus a shape (the shape is required only if axes flips are required).## Matching space resolutions and offsetsThe `AnatomicalSpace` class can deal also with stack resampling/padding/cropping. This requires simply specifying values for resolutions and offsets when instantiating a `AnatomicalSpace` object. Once that is done, using `AnatomicalSpace.transformation_matrix_to` creating affine transformation matrices from one space to the other will be a piece of cake!```pythonsource_space = bgs.AnatomicalSpace(&quot;asl&quot;, resolution=(2, 1, 2), offset=(1, 0, 0))target_space = bgs.AnatomicalSpace(&quot;sal&quot;, resolution=(1, 1, 1), offset=(0, 0, 2))source_space.transformation_matrix_to(target_space)```Moreover, we can now use those space objects to resample stacks, and to generate stacks matching a target shape with the correct padding/cropping simply by specifying a target offset:```pythonsource_space = bgs.AnatomicalSpace(&quot;asl&quot;, resolution=(2, 1, 2), offset=(1, 0, 0))target_space = bgs.AnatomicalSpace(&quot;asl&quot;, resolution=(1, 1, 1), shape=(5, 4, 2))  # we need a target shapesource_space.transformation_matrix_to(target_space, stack, to_target_shape=True)```## Easy iteration over projectionsFinally, another convenient feature of BGSpace is the possibility of iterating easily through the projections of the stack and generate section names and axes labels:```pythonsc = bg.AnatomicalSpace(&quot;asl&quot;)  # origin for the stack to be plottedfor i, (plane, labels) in enumerate(zip(sc.sections, sc.axis_labels)):    axs[i].imshow(stack.mean(i))        axs[i].set_title(f&quot;{plane.capitalize()} view&quot;)    axs[i].set_ylabel(labels[0])    axs[i].set_xlabel(labels[1])```![](/docs/img/projections.png)## ContributingContributions are very welcome. Please see the [contributing guide](https://github.com/brainglobe/.github/blob/main/CONTRIBUTING.md).</longdescription>
</pkgmetadata>