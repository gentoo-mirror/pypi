<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># About pywarts`pywarts` is a pure-python parsing library for the Warts format.Warts is an extensible binary format produced by[Scamper](http://www.caida.org/tools/measurement/scamper/), anInternet measurement tool from CAIDA, to store measurement resultssuch as traceroutes and pings.This library started off from the [Python implementation fromCMAND](https://github.com/cmand/scamper), by Robert Beverly, but hasnow vastly diverged.  The parsing architecture is loosely inspiredfrom the [Ryu](https://osrg.github.io/ryu/) packet parser, although itis less complex because the requirements are less stringent.## Installation```pip install scamper-pywarts```## Features- pure-Python, no dependency, works with both python2 and python3- can read all basic Warts data types (ping, traceroute)- easily extensible for other Warts data types (patches are welcome)- nice class-based interface- reasonably good performance (a few minutes to parse a 80 MiB warts file with traceroute data)- streaming-like interface: no more than one record is pulled in  memory at any given time, so it should handle very large Warts file  with a limited amount of memory.  You can probably even consume data  directly from the output of a running Scamper process.## Using pywartsFor now, the only public API is very low-level: it simply reads from astream (for instance a file) and returns Warts records as Python objects.To read records, call `warts.parse_record` repeatedly until it returns`None`.  Remember to open your input Warts files in binary mode!The returned value of `warts.parse_record` is an instance of anappropriate subclass (e.g. `Traceroute`), depending on the record type.Be aware that all optional attributes are set to None if not present inthe input file.  You should always check for this possibility in your usercode.Here is an example that opens a file, and repeatedly parses recordsuntil it finds a Traceroute record (warts files usually have a fewinitial records with mostly uninteresting data).```import wartsfrom warts.traceroute import Traceroutewith open('my_file.warts', 'rb') as f:    record = warts.parse_record(f)    while not isinstance(record, Traceroute):        record = warts.parse_record(f)    if record.src_address:        print(&quot;Traceroute source address:&quot;, record.src_address)    if record.dst_address:        print(&quot;Traceroute destination address:&quot;, record.dst_address)    print(&quot;Number of hops:&quot;, len(record.hops))    print(record.hops)```To know which attributes are available, look at the definition of therelevant class (there will be real documentation at some point).  Forinstance, for `Traceroute`, almost all attributes are optional and definedhere:[traceroute.py](https://github.com/drakkar-lig/scamper-pywarts/blob/master/warts/traceroute.py#L34).Some attributes are not optional and are defined in the `parse()` methodof the class.  For instance, a traceroute object `t` always provides alist of `TracerouteHop` objects in `t.hops`.If parsing fails, an instance of `errors.ParseError` is thrown.`pywarts` generally tries to clean up after itself, so the filedescriptor should point to the next record even after a parsing error.Of course, this is not always possible, especially if the input fileis incorrectly formatted.## Difference with the implementation from CMANDHere is some points on which `pywarts` improves from the code from&lt;https://github.com/cmand/scamper&gt;:- fully python3-compatible- nicer class-based interface, instead of huge dicts with all flags- properly handles unknown flags and options, by ignoring them- attribute names have been generally made more readable (although  that often means longer names)- possibly quite a bit faster (it would need proper benchmarks), because  of the way we parse flags and strings.  Also, we read a whole record  into memory before parsing it, which is a bit faster than calling  `read()` repeatedly on very small amount of data.However, there are some areas where the CMAND code does more things:- `pywarts` does not implement the deprecated address format (it is  quite complex and has been deprecated for several years)- there are some nice scripts in &lt;https://github.com/cmand/scamper&gt;,  for instance a script to attach to and control a running Scamper  process# Developement## High-levelSome currently unanswered questions:- What should the high-level API look like, and is there even a need  for a higher-level API?  Just an iterator of records?  Allow to  filter by record type?  Try to parse further, for instance decode  flags or produce different objects for UDP, TCP and ICMP  traceroutes?- Should we try to normalise values when parsing?  For instance,  should we use `ipaddr` objects for addresses?  Some times are  expressed in centiseconds, some in microseconds, some in seconds.  Should we normalize that to a common base?  Are floats acceptable  for time values?- What should we do when there is a parsing error?  How can the user  continue parsing the next record if he/she wants to?Please open issues if you have ideas and thoughts on these questions.</longdescription>
</pkgmetadata>