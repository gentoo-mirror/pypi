<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># pylibyamlpylibyaml is a simple Python module that monkey patches PyYAML toautomatically enable the fast LibYAML-based parser and emitter if theyare installed.## InstallationTo install, run:    pip install pylibyamlThere is no explicit requirement for PyYAML or LibYAML to be installedin advance, but this package will be useless without them. Please referto the PyYAML installation documentation, especially the points aboutinstalling the LibYAML bindings.- https://pyyaml.org/wiki/PyYAMLDocumentation- https://pyyaml.org/wiki/LibYAML## UsageRun `import pylibyaml` **BEFORE** `import yaml`, and enjoy!```pythonimport pylibyamlimport yamlyaml.safe_load(stream)yaml.load(stream, Loader=yaml.SafeLoader)yaml.safe_dump(data)yaml.dump(data, Dumper=yaml.SafeDumper)```Most existing code should run without modification. Any references to`yaml.Loader` and `yaml.Dumper` (including `Safe`, `Unsafe`, and `Full`flavors) will automatically point to their `yaml.cyaml.CLoader` and`yaml.cyaml.CDumper` equivalents. The convenience methods (`safe_load`,`safe_dump`, etc.) will all use the C classes, as well as the methodsfor adding resolvers, constructors, or representers. Objects thatinherit from `YAMLObject` should work as intended.## Details### BackgroundPyYAML is the canonical YAML parser and emitter library for Python. Itis not particularly fast.LibYAML is a C library for parsing and emitting YAML. It is very fast.By default, the setup.py script for PyYAML checks whether LibYAML isinstalled and if so, builds and installs LibYAML bindings.For the bindings to actually be used, they need to be explicitlyselected. The PyYAML documentation suggests some variations of thefollowing:&gt; When LibYAML bindings are installed, you may use fast LibYAML-basedparser and emitter as follows:    &gt;&gt;&gt; yaml.load(stream, Loader=yaml.CLoader)    &gt;&gt;&gt; yaml.dump(data, Dumper=yaml.CDumper)&gt; In order to use LibYAML based parser and emitter, use the classes&gt; CParser and CEmitter. For instance,    from yaml import load, dump    try:        from yaml import CLoader as Loader, CDumper as Dumper    except ImportError:        from yaml import Loader, Dumper    # ...    data = load(stream, Loader=Loader)    # ...    output = dump(data, Dumper=Dumper)    This approach is repetitive, inconvenient, and ineffectual when dealingwith third-party libraries that also use PyYAML.### ImplementationThe approach taken by `pylibyaml` is to rebind the global names of theLoaders and Dumpers in the `yaml` module to the LibYAML versions if theyare available, before the various functions and classes are defined.For example, compare the following.Without pylibyaml:    &gt;&gt;&gt; import yaml    &gt;&gt;&gt; yaml.Loader    &lt;class 'yaml.loader.Loader'&gt;    &gt;&gt;&gt; yaml.Dumper    &lt;class 'yaml.dumper.Dumper'&gt;    &gt;&gt;&gt; help(yaml.dump)    Help on function dump in module yaml:    dump(data, stream=None, Dumper=&lt;class 'yaml.dumper.Dumper'&gt;, **kwds)        Serialize a Python object into a YAML stream.        If stream is None, return the produced string instead.Using pylibyaml (with LibYAML bindings available):    &gt;&gt;&gt; import pylibyaml    &gt;&gt;&gt; import yaml    &gt;&gt;&gt; yaml.Loader    &lt;class 'yaml.cyaml.CLoader'&gt;    &gt;&gt;&gt; yaml.Dumper    &lt;class 'yaml.cyaml.CDumper'&gt;    &gt;&gt;&gt; help(yaml.dump)    Help on function dump in module yaml:    dump(data, stream=None, Dumper=&lt;class 'yaml.cyaml.CDumper'&gt;, **kwds)        Serialize a Python object into a YAML stream.        If stream is None, return the produced string instead.Note that the top-level names now point to the cyaml versions, and thatthe default function arguments have changed.The code samples above will still run without modification, but the secondcan be simplified - the logic of determining the best loader and dumper isnot longer required.    import pylibyaml    from yaml import load, dump    from yaml import Loader, Dumper    # ...    data = load(stream, Loader=Loader)    # ...    output = dump(data, Dumper=Dumper)## Caveats### This is a rather ugly hack.In order need to rebind the names of the default loaders and dumpersprior to the function and class definitions in PyYAML's `__init__.py`,we use `inspect` to get the source, edit it, and reload it with`importlib`. This works for now (the current version of PyYAML is5.3.1), and as far back as 3.11, but it may not always.### LibYAML and PyYAML are not 100% interchangeable.From the [PyYAML docs](https://pyyaml.org/wiki/PyYAMLDocumentation):&gt; Note that there are some subtle (but not really significant)&gt; differences between pure Python and&gt; [LibYAML](https://pyyaml.org/wiki/LibYAML) based parsers and emitters.</longdescription>
</pkgmetadata>