<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>## RequirementsPython3 (Required)PIP3 (Required)Ubuntu 16.04+ / MacOS / Windows 10GCC / C++ (Will depend on the OS you are using. Ubuntu, and MacOS it comes by default. Some flavors of Linux distribution like Amazon Linux/RED Hat Linux might not have GCC or C++-related libraries installed)For this tutorial, we are assuming you are using Python3 and PIP3. Also, make sure you have the necessary build tools installed (might vary from OS to OS). If you get any errors while installing any dependent packages feel free to reach out to us but most of it can quickly be solved by a simple Google search.## Alectio SDKAlectioSDK is a package that enables developers to build an ML pipeline as a Flask app to interact with Alectio's platform. It is designed for Alectio's clients, who prefer to keep their model and data on their own server.The package is currently under active development. More functionalities that aim to enhance robustness will be added soon, but for now, the package provides a class `alectio_sdk.sdk.Pipeline` that interfaces with customer-side processes in a consistent manner. Customers need to implement 4 processes as python functions:- A process to train the model- A process to test the model- A process to apply the model to infer unlabeled data- A process to assign each data point in the dataset to a unique index (Refer to one of the examples to know how)A Pipeline can be created inside the `main.py` file using the following syntax:```pythonimport yamlfrom alectio_sdk.sdk import Pipelinefrom processes import train, test, infer, getdatasetstate# All the variables can be declared inside the .yaml filewith open(&quot;./config.yaml&quot;, &quot;r&quot;) as stream: args = yaml.safe_load(stream)# Initialising the Experiment PipelineAlectioPipeline = Pipeline( name=args[&quot;exp_name&quot;], train_fn=train, # A process to train the model test_fn=test, # A process to test the model infer_fn=infer, # A process to apply the model to infer unlabeled data getstate_fn=getdatasetstate, # A process to assign each data point in the dataset to a unique index args=args, # Any arguments that user ants to use inside his train, test, infer functions. token=&quot;xxxxxx7041a6xxxxx7948cexxxxxxxx&quot;, # Experiment token multiple_initialisations={&quot;seeds&quot;: [], &quot;limit_value&quot;: 0}, # Multiple seed initialisation feature)```Refer to the alectio examples for more clarity on the use of the Pipeline class.## Train the ModelThe logic for training the model should be implemented in this process. The function should look like this:```pythondef train(args, labeled, resume_from, ckpt_file):    &quot;&quot;&quot;    Training Function        Input args:    args* # Arguments passed to Alectio Pipeline    labeled: list # List of labeled indices for training    resume_from: str # Path to last checkpoint file    ckpt_file: str # Path to saved model        Returns:    None    or    output_dict: dict # Labels and Hyperparams    &quot;&quot;&quot;    # implement your logic to train the model    # with the selected data indexed by `labeled`    # lbs &lt;- dictionary of indices of train data and their ground-truth        return {'labels': lbs, 'hyperparams': hyperparameters}```The name of the function can be anything you like. It takes an argument as shown in the example above.| key | value ||--|--|| resume_from | a string that specifies which checkpoint to resume from || ckpt_file | a string that specifies the name of checkpoint to be saved for the current loop || labeled | a list of indices of selected samples used to train the model in this loop |Depending on your situation, the samples indicated in labeled might not be labeled (despite the variable name). We call it labeled because, in the active learning setting, this list represents the pool of samples iteratively labeled by the human oracle.## Test the ModelThe logic for testing the model should be implemented in this process. The function representing this process should look like this:```pythondef test(args, ckpt_file):    &quot;&quot;&quot;    testing function    Input args:    args* # Arguments passed to Alectio Pipeline    ckpt_file: str # Path to saved model    Returns:    output_dict: dict # Preds and Labels    &quot;&quot;&quot;    # implement your testing logic here    # put the predictions and labels into    # two dictionaries    # lbs &lt;- dictionary of indices of test data and their ground-truth    # prd &lt;- dictionary of indices of test data and their prediction        return {'predictions': prd, 'labels': lbs}```The test function takes arguments as shown in the example above.| key | value ||--|--|| ckpt_file | a string that specifies which checkpoint to test model |The test function needs to return a dictionary with two keys:| key | value ||--|--|| predictions | a dictionary of an index and a prediction for each test sample || labels | a dictionary of an index and a ground truth label for each test sample |The format of the values depends on the type of ML problem. Please refer to the examples directory for details.## Apply InferenceThe logic for applying the model to infer the unlabeled data should be implemented in this process. The function representing this process should look like this:```pythondef infer(args, unlabeled, ckpt_file):    &quot;&quot;&quot;    Inference Function    Input args:    args* # Arguments passed to Alectio Pipeline    unlabeled: list # List of labeled indices for inference    ckpt_file: str # Path to saved model    returns:    output_dict: dict    &quot;&quot;&quot;    # implement your inference logic here    # outputs &lt;- save the output from the model on the unlabeled data as a dictionary    return {'outputs': outputs}```The infer function takes an argument payload, which is a dictionary with 2 keys:| key | value ||--|--|| ckpt_file | a string that specifies which checkpoint to use to infer on the unlabeled data || unlabeled | a list of of indices of unlabeled data in the training set |The infer function needs to return a dictionary with one key.| key | value ||--|--|| outputs | a dictionary of indexes mapped to the models output before an activation function is applied |For example, if it is a classification problem, return the output **before** applying softmax.For more details about the format of the output, please refer to the [examples](./examples) directory.## config.yamlPut in all the requirements that are required for the model to train. This will be read and used in processes.py when the model trains. For example if config.yaml looks like this:``` pythonLOG_DIR:  &quot;./log&quot;DATA_DIR: &quot;./data&quot;EXPT_DIR: &quot;./log&quot;exptname:  &quot;ManualAL&quot;  # Model configsbackbone:     &quot;Resnet101&quot;description:  &quot;Pedestrian detection&quot;epochs: 10..```You can access them inside your any of the above 4 processes as lets say args[&quot;backbone&quot;] , args[&quot;description&quot;] etc.## SDK- Features### 1. Tracking CO2 emissionsThe alectio SDK is capable of tracking the CO2 emissions during the experiment. The SDK uses an open-source package called code carbon to track the CO2 emissions along with the (CPU, GPU, and RAM) usage. This data is tracked and synced, once the experiment ends, with the user account where the user can see the total CO2 emission on his dashboard.### 2. Time-Saved InformationThe SDK uses linear interpolation to estimate the time that a user saved to train his model in each active learning cycle. The time-saved information is logged after each AL cycle and gets synced with the platform at the end of the experiment. The time-saved insights can be seen on the user dashboard.### 3. Storing HyperparametersThe SDK has the ability to track the hyperparameters for each AL cycle. To use this feature the user just needs to return a dictionary of their hyperparameters. Currently, the SDK supports a limited number of hyperparameters, the list of these parameters is shown below:```pythonhyperparameter_names = [                &quot;optimizer_name&quot;, # Name of the optimizer used                &quot;loss&quot;, # Loss of the training process                &quot;running_loss&quot;, # Running Loss                 &quot;epochs&quot;, # Number of epochs for which the model was trained                 &quot;batch_size&quot;, # batch size on which the model was trained                &quot;loss_function&quot;, # name of loss function used for training                &quot;activation&quot;, # List of activation functions used                 &quot;optimizer&quot;, # Can be a state_dict in case of Pytorch            ]```The syntax for storing these values is shown in the train function section.### 4. Running Multiple Seed InitializationThe SDK can also help the user choose the right seed for his experiment by training his model on a range of seed values and selecting the best seed depending on the performance of models on these seed values. In order to use this feature the user can just use the multiple_initialisations argument of the Alectio Pipeline. The syntax is as shown below:```pythonfrom alectio_sdk.sdk import PipelineAlectioPipeline = Pipeline(    name=args[&quot;exp_name&quot;],    train_fn=train,    test_fn=test,    infer_fn=infer,    getstate_fn=getdatasetstate,    args=args,    token=&quot;xxxxxx7041a6xxxxx7948cexxxxxxxx&quot;,    multiple_initialisations={&quot;seeds&quot;: [10, 42, 36, 78], &quot;limit_value&quot;: 4000},)```The input of this argument is a dict with 2 keys.| key | value ||--|--|| seed | a list containing different seed values you want to test your model on. || limit_value | The number of samples from which you want to select the training samples from. |### 5. Accessing Alectio Public DatasetsThe user can access Alectio Public Datasets usin the Alectio SDK. The user needs to select the public dataset he wants to use during creating his/her project on the Alectio platform. Alectio Public datasets contain training, validation and testing data. The code snippet to use the Public datasets is as given below.&lt;p&gt;&lt;details open&gt;&lt;summary&gt;1. Pytorch&lt;/summary&gt;&lt;br/&gt;```python# Pytorch Syntaximport torchvisionfrom torchvision import transformsfrom alectio_sdk.sdk.alectio_dataset import AlectioDatasetfrom torch.utils.data import DataLoader, Subset# create a public dataset object# token = experiment token# root = directory in which you want to download your dataset# framework = pytorch/tensorflowalectio_dataset = AlectioDataset(token=&quot;your_exp_token_goes_here&quot;, root=&quot;./data&quot;, framework=&quot;pytorch&quot;)# train datasettrain_transforms = transforms.Compose(    [        transforms.Resize((224, 224)),        transforms.RandomHorizontalFlip(),        transforms.ToTensor(),        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),    ])# call the get dataset function # dataset_type = train/test/validation# transforms = augmentations/transformations you want to perform# Returns # DataLoader Object | Length of dataset | Mapping of labels and indicestrain_dataset, train_dataset_len, train_class_to_idx = alectio_dataset.get_dataset(    dataset_type=&quot;train&quot;, transforms=train_transforms)```&lt;/details&gt;&lt;details open&gt;&lt;summary&gt;2. Tensorflow&lt;/summary&gt;&lt;br/&gt;```python# Tensorflow Syntaximport tensorflow as tffrom alectio_sdk.sdk.alectio_dataset import AlectioDataset# create a public dataset object# token = experiment token# root = directory in which you want to download your dataset# framework = pytorch/tensorflowalectio_dataset = AlectioDataset(token=&quot;your_exp_token_goes_here&quot;, root=&quot;./data&quot;, framework=&quot;tensorflow&quot;)# train dataset# all transforms supported by Tensoflow ImageDataGenerator can be added to the transform dicttrain_transforms = dict(    featurewise_center=False,    samplewise_center=False,    featurewise_std_normalization=False,    samplewise_std_normalization=False,    zca_whitening=False,    channel_shift_range=0.0,    fill_mode='nearest',    cval=0.0,    horizontal_flip=False,    vertical_flip=False,    rescale=None,    preprocessing_function=None,    data_format=None,)# call the get dataset function # dataset_type = train/test/validation# transforms = dict of augmentations/transformations you want to perform# Returns # Imagedatagenerator Object | Length of dataset | Mapping of labels and indicestrain_dataset, train_dataset_len, train_class_to_idx = alectio_dataset.get_dataset(    dataset_type=&quot;train&quot;, transforms=train_transforms)```&lt;/details&gt;&lt;/p&gt;## Installation### 0. Key ManagementIf you have not already created your Client ID and Client Secret then do so by visiting: 1. Open [Alectio PRO](https://pro.alectio.com) | [Alectio Community](https://community.alectio.com) 2. Login here and create a project and an experiment. 3. An experiment token will be generated. 4. Enter your experiment token in main.py to authenticate. 5. Please visit &lt;https://github.com/alectio/AlectioExamples&gt; for detailed examples.### 1. Set up a virtual environmentWe recommend to set-up a virtual environment.For example, you can use python's built-in virtual environment via:```pythonpython3 -m venv envsource env/bin/activate```### 2. Install AlectioSDK/requirements  ```pythonpip install .pip install -r requirements.txt```### 3. Run ExamplesThe remaining installation instructions are detailed in the [examples](./examples) directory. We cover one example for [topic classification](./examples/topic_classification), one example for [image classification](./examples/image_classification) and one example for [object detection](./examples/object_detection)</longdescription>
</pkgmetadata>