<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>![Build Status](https://github.com/aws/aws-xray-sdk-python/actions/workflows/IntegrationTesting.yaml/badge.svg)[![codecov](https://codecov.io/gh/aws/aws-xray-sdk-python/branch/master/graph/badge.svg)](https://codecov.io/gh/aws/aws-xray-sdk-python)### :mega: OpenTelemetry Python with AWS X-RayAWS X-Ray supports using OpenTelemetry Python and the AWS Distro for OpenTelemetry (ADOT) Collector to instrument your application and send trace data to X-Ray. The OpenTelemetry SDKs are an industry-wide standard for tracing instrumentation. They provide more instrumentations and have a larger community for support, but may not have complete feature parity with the X-Ray SDKs. See [choosing between the ADOT and X-Ray SDKs](https://docs.aws.amazon.com/xray/latest/devguide/xray-instrumenting-your-app.html#xray-instrumenting-choosing) for more help with choosing between the two.If you want additional features when tracing your Python applications, please [open an issue on the OpenTelemetry Python Instrumentation repository](https://github.com/open-telemetry/opentelemetry-python-contrib/issues/new?labels=feature-request&amp;template=feature_request.md&amp;title=X-Ray%20Compatible%20Feature%20Request).### :mega: Python Versions End-of-Support NoticeAWS X-Ray SDK for Python versions `&gt;2.11.0` has dropped support for Python 2.7, 3.4, 3.5, and 3.6.# AWS X-Ray SDK for Python![Screenshot of the AWS X-Ray console](/images/example_servicemap.png?raw=true)## InstallingThe AWS X-Ray SDK for Python is compatible with Python 3.7, 3.8, 3.9, 3.10, and 3.11.Install the SDK using the following command (the SDK's non-testing dependencies will be installed).```pip install aws-xray-sdk```To install the SDK's testing dependencies, use the following command.```pip install tox```## Getting HelpUse the following community resources for getting help with the SDK. We use the GitHubissues for tracking bugs and feature requests.* Ask a question in the [AWS X-Ray Forum](https://forums.aws.amazon.com/forum.jspa?forumID=241&amp;start=0).* Open a support ticket with [AWS Support](http://docs.aws.amazon.com/awssupport/latest/user/getting-started.html).* If you think you may have found a bug, open an [issue](https://github.com/aws/aws-xray-sdk-python/issues/new).## Opening IssuesIf you encounter a bug with the AWS X-Ray SDK for Python, we want to hear aboutit. Before opening a new issue, search the [existing issues](https://github.com/aws/aws-xray-sdk-python/issues)to see if others are also experiencing the issue. Include the version of the AWS X-RaySDK for Python, Python language, and botocore/boto3 if applicable. In addition, include the repro case when appropriate.The GitHub issues are intended for bug reports and feature requests. For help andquestions about using the AWS SDK for Python, use the resources listedin the [Getting Help](https://github.com/aws/aws-xray-sdk-python#getting-help) section. Keeping the list of open issues lean helps us respond in a timely manner.## DocumentationThe [developer guide](https://docs.aws.amazon.com/xray/latest/devguide) provides in-depthguidance about using the AWS X-Ray service.The [API Reference](http://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/)provides guidance for using the SDK and module-level documentation.## Quick Start### Configuration```pythonfrom aws_xray_sdk.core import xray_recorderxray_recorder.configure(    sampling=False,    context_missing='LOG_ERROR',    plugins=('EC2Plugin', 'ECSPlugin', 'ElasticBeanstalkPlugin'),    daemon_address='127.0.0.1:3000',    dynamic_naming='*mysite.com*')```### Start a custom segment/subsegmentUsing context managers for implicit exceptions recording:```pythonfrom aws_xray_sdk.core import xray_recorderwith xray_recorder.in_segment('segment_name') as segment:    # Add metadata or annotation here if necessary    segment.put_metadata('key', dict, 'namespace')    with xray_recorder.in_subsegment('subsegment_name') as subsegment:        subsegment.put_annotation('key', 'value')        # Do something here    with xray_recorder.in_subsegment('subsegment2') as subsegment:        subsegment.put_annotation('key2', 'value2')        # Do something else ```async versions of context managers:```pythonfrom aws_xray_sdk.core import xray_recorderasync with xray_recorder.in_segment_async('segment_name') as segment:    # Add metadata or annotation here if necessary    segment.put_metadata('key', dict, 'namespace')    async with xray_recorder.in_subsegment_async('subsegment_name') as subsegment:        subsegment.put_annotation('key', 'value')        # Do something here    async with xray_recorder.in_subsegment_async('subsegment2') as subsegment:        subsegment.put_annotation('key2', 'value2')        # Do something else ```Default begin/end functions:```pythonfrom aws_xray_sdk.core import xray_recorder# Start a segmentsegment = xray_recorder.begin_segment('segment_name')# Start a subsegmentsubsegment = xray_recorder.begin_subsegment('subsegment_name')# Add metadata or annotation here if necessarysegment.put_metadata('key', dict, 'namespace')subsegment.put_annotation('key', 'value')xray_recorder.end_subsegment()# Close the segmentxray_recorder.end_segment()```### Oversampling MitigationTo modify the sampling decision at the subsegment level, subsegments that inherit the decision of their direct parent (segment or subsegment) can be created using `xray_recorder.begin_subsegment()` and unsampled subsegments can be created using`xray_recorder.begin_subsegment_without_sampling()`.The code snippet below demonstrates creating a sampled or unsampled subsegment based on the sampling decision of each SQS message processed by Lambda.```pythonfrom aws_xray_sdk.core import xray_recorderfrom aws_xray_sdk.core.models.subsegment import Subsegmentfrom aws_xray_sdk.core.utils.sqs_message_helper import SqsMessageHelperdef lambda_handler(event, context):    for message in event['Records']:        if SqsMessageHelper.isSampled(message):            subsegment = xray_recorder.begin_subsegment('sampled_subsegment')            print('sampled - processing SQS message')        else:            subsegment = xray_recorder.begin_subsegment_without_sampling('unsampled_subsegment')            print('unsampled - processing SQS message')        xray_recorder.end_subsegment()   ```The code snippet below demonstrates wrapping a downstream AWS SDK request with an unsampled subsegment.```pythonfrom aws_xray_sdk.core import xray_recorder, patch_allimport boto3patch_all()def lambda_handler(event, context):    subsegment = xray_recorder.begin_subsegment_without_sampling('unsampled_subsegment')    client = boto3.client('sqs')    print(client.list_queues())        xray_recorder.end_subsegment()```### CaptureAs a decorator:```pythonfrom aws_xray_sdk.core import xray_recorder@xray_recorder.capture('subsegment_name')def myfunc():    # Do something heremyfunc()```or as a context manager:```pythonfrom aws_xray_sdk.core import xray_recorderwith xray_recorder.capture('subsegment_name') as subsegment:    # Do something here    subsegment.put_annotation('mykey', val)    # Do something more```Async capture as decorator:```pythonfrom aws_xray_sdk.core import xray_recorder@xray_recorder.capture_async('subsegment_name')async def myfunc():    # Do something hereasync def main():    await myfunc()```or as context manager:```pythonfrom aws_xray_sdk.core import xray_recorderasync with xray_recorder.capture_async('subsegment_name') as subsegment:    # Do something here    subsegment.put_annotation('mykey', val)    # Do something more```### Adding annotations/metadata using recorder```pythonfrom aws_xray_sdk.core import xray_recorder# Start a segment if no segment existsegment1 = xray_recorder.begin_segment('segment_name')# This will add the key value pair to segment1 as it is activexray_recorder.put_annotation('key', 'value')# Start a subsegment so it becomes the active trace entitysubsegment1 = xray_recorder.begin_subsegment('subsegment_name')# This will add the key value pair to subsegment1 as it is activexray_recorder.put_metadata('key', 'value')if xray_recorder.is_sampled():    # some expensitve annotations/metadata generation code here    val = compute_annotation_val()    metadata = compute_metadata_body()    xray_recorder.put_annotation('mykey', val)    xray_recorder.put_metadata('mykey', metadata)```### Generate NoOp Trace and Entity IdX-Ray Python SDK will by default generate no-op trace and entity id for unsampled requests and secure random trace and entity id for sampled requests. If customer wants to enable generating secure random trace and entity id for all the (sampled/unsampled) requests (this is applicable for trace id injection into logs use case) then they should set the `AWS_XRAY_NOOP_ID` environment variable as False.### Disabling X-RayOften times, it may be useful to be able to disable X-Ray for specific use cases, whether to stop X-Ray from sending traces at any moment, or to test code functionality that originally depended on X-Ray instrumented packages to begin segments prior to the code call. For example, if your application relied on an XRayMiddleware to instrument incoming web requests, and you have a method which begins subsegments based on the segment generated by that middleware, it would be useful to be able to disable X-Ray for your unit tests so that `SegmentNotFound` exceptions are not thrown when you need to test your method.There are two ways to disable X-Ray, one is through environment variables, and the other is through the SDKConfig module.**Disabling through the environment variable:**Prior to running your application, make sure to have the environment variable `AWS_XRAY_SDK_ENABLED` set to `false`. **Disabling through the SDKConfig module:**```from aws_xray_sdk import global_sdk_configglobal_sdk_config.set_sdk_enabled(False)```**Important Notes:*** Environment Variables always take precedence over the SDKConfig module when disabling/enabling. If your environment variable is set to `false` while your code calls `global_sdk_config.set_sdk_enabled(True)`, X-Ray will still be disabled.* If you need to re-enable X-Ray again during runtime and acknowledge disabling/enabling through the SDKConfig module, you may run the following in your application:```import osfrom aws_xray_sdk import global_sdk_configdel os.environ['AWS_XRAY_SDK_ENABLED']global_sdk_config.set_sdk_enabled(True)```### Trace AWS Lambda functions```pythonfrom aws_xray_sdk.core import xray_recorderdef lambda_handler(event, context):    # ... some code    subsegment = xray_recorder.begin_subsegment('subsegment_name')    # Code to record    # Add metadata or annotation here, if necessary    subsegment.put_metadata('key', dict, 'namespace')    subsegment.put_annotation('key', 'value')    xray_recorder.end_subsegment()    # ... some other code```### Trace ThreadPoolExecutor```pythonimport concurrent.futuresimport requestsfrom aws_xray_sdk.core import xray_recorderfrom aws_xray_sdk.core import patchpatch(('requests',))URLS = ['http://www.amazon.com/',        'http://aws.amazon.com/',        'http://example.com/',        'http://www.bilibili.com/',        'http://invalid-domain.com/']def load_url(url, trace_entity):    # Set the parent X-Ray entity for the worker thread.    xray_recorder.set_trace_entity(trace_entity)    # Subsegment captured from the following HTTP GET will be    # a child of parent entity passed from the main thread.    resp = requests.get(url)    # prevent thread pollution    xray_recorder.clear_trace_entities()    return resp# Get the current active segment or subsegment from the main thread.current_entity = xray_recorder.get_trace_entity()with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:    # Pass the active entity from main thread to worker threads.    future_to_url = {executor.submit(load_url, url, current_entity): url for url in URLS}    for future in concurrent.futures.as_completed(future_to_url):        url = future_to_url[future]        try:            data = future.result()        except Exception:            pass```### Trace SQL queriesBy default, if no other value is provided to `.configure()`, SQL trace streaming is enabledfor all the supported DB engines. Those currently are:- Any engine attached to the Django ORM.- Any engine attached to SQLAlchemy.The behaviour can be toggled by sending the appropriate `stream_sql` value, for example:```pythonfrom aws_xray_sdk.core import xray_recorderxray_recorder.configure(service='fallback_name', stream_sql=True)```### Patch third-party libraries```pythonfrom aws_xray_sdk.core import patchlibs_to_patch = ('boto3', 'mysql', 'requests')patch(libs_to_patch)```#### Automatic module patchingFull modules in the local codebase can be recursively patched by providing the module referencesto the patch function.```pythonfrom aws_xray_sdk.core import patchlibs_to_patch = ('boto3', 'requests', 'local.module.ref', 'other_module')patch(libs_to_patch)```An `xray_recorder.capture()` decorator will be applied to all functions and class methods in thegiven module and all the modules inside them recursively. Some files/modules can be excluded byproviding to the `patch` function a regex that matches them.```pythonfrom aws_xray_sdk.core import patchlibs_to_patch = ('boto3', 'requests', 'local.module.ref', 'other_module')ignore = ('local.module.ref.some_file', 'other_module.some_module\.*')patch(libs_to_patch, ignore_module_patterns=ignore)```### Django#### Add Django middlewareIn django settings.py, use the following.```pythonINSTALLED_APPS = [    # ... other apps    'aws_xray_sdk.ext.django',]MIDDLEWARE = [    'aws_xray_sdk.ext.django.middleware.XRayMiddleware',    # ... other middlewares]```You can configure the X-Ray recorder in a Django app under the ‘XRAY_RECORDER’ namespace. For a minimal configuration, the 'AWS_XRAY_TRACING_NAME' is required unless it is specified in an environment variable.```XRAY_RECORDER = {    'AWS_XRAY_TRACING_NAME': 'My application', # Required - the segment name for segments generated from incoming requests}```For more information about configuring Django with X-Ray read more about it in the [API reference](https://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/frameworks.html)#### SQL tracingIf Django's ORM is patched - either using the `AUTO_INSTRUMENT = True` in your settings fileor explicitly calling `patch_db()` - the SQL query trace streaming can then be enabled or disabled updating the `STREAM_SQL` variable in your settings file. It is enabled by default.#### Automatic patchingThe automatic module patching can also be configured through Django settings.```pythonXRAY_RECORDER = {    'PATCH_MODULES': [        'boto3',        'requests',        'local.module.ref',        'other_module',    ],    'IGNORE_MODULE_PATTERNS': [        'local.module.ref.some_file',        'other_module.some_module\.*',    ],    ...}```If `AUTO_PATCH_PARENT_SEGMENT_NAME` is also specified, then a segment parent will be created with the supplied name, wrapping the automatic patching so that it captures any danglingsubsegments created on the import patching.### Django in LambdaX-Ray can't search on http annotations in subsegments.   To enable searching the middleware adds the http values as annotationsThis allows searching in the X-Ray console like soThis is configurable in settings with `URLS_AS_ANNOTATION` that has 3 valid values`LAMBDA` - the default, which uses URLs as annotations by default if running in a lambda context`ALL` - do this for every request (useful if running in a mixed lambda/other deployment)`NONE` - don't do this for any (avoiding hitting the 50 annotation limit)```annotation.url BEGINSWITH &quot;https://your.url.com/here&quot;```### Add Flask middleware```pythonfrom aws_xray_sdk.core import xray_recorderfrom aws_xray_sdk.ext.flask.middleware import XRayMiddlewareapp = Flask(__name__)xray_recorder.configure(service='fallback_name', dynamic_naming='*mysite.com*')XRayMiddleware(app, xray_recorder)```### Add Bottle middleware(plugin)```pythonfrom aws_xray_sdk.core import xray_recorderfrom aws_xray_sdk.ext.bottle.middleware import XRayMiddlewareapp = Bottle()xray_recorder.configure(service='fallback_name', dynamic_naming='*mysite.com*')app.install(XRayMiddleware(xray_recorder))```### Serverless Support for Flask &amp; Django &amp; Bottle Using X-RayServerless is an application model that enables you to shift more of your operational responsibilities to AWS. As a result, you can focus only on your applications and services, instead of the infrastructure management tasks such as server provisioning, patching, operating system maintenance, and capacity provisioning. With serverless, you can deploy your web application to [AWS Lambda](https://aws.amazon.com/lambda/) and have customers interact with it through a Lambda-invoking endpoint, such as [Amazon API Gateway](https://aws.amazon.com/api-gateway/). X-Ray supports the Serverless model out of the box and requires no extra configuration. The middlewares in Lambda generate `Subsegments` instead of `Segments` when an endpoint is reached. This is because `Segments` cannot be generated inside the Lambda function, but it is generated automatically by the Lambda container. Therefore, when using the middlewares with this model, it is important to make sure that your methods only generate `Subsegments`.The following guide shows an example of setting up a Serverless application that utilizes API Gateway and Lambda:[Instrumenting Web Frameworks in a Serverless Environment](https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-python-serverless.html)### Working with aiohttpAdding aiohttp middleware. Support aiohttp &gt;= 2.3.```pythonfrom aiohttp import webfrom aws_xray_sdk.ext.aiohttp.middleware import middlewarefrom aws_xray_sdk.core import xray_recorderfrom aws_xray_sdk.core.async_context import AsyncContextxray_recorder.configure(service='fallback_name', context=AsyncContext())app = web.Application(middlewares=[middleware])app.router.add_get(&quot;/&quot;, handler)web.run_app(app)```Tracing aiohttp client. Support aiohttp &gt;=3.```pythonfrom aws_xray_sdk.ext.aiohttp.client import aws_xray_trace_configasync def foo():    trace_config = aws_xray_trace_config()    async with ClientSession(loop=loop, trace_configs=[trace_config]) as session:        async with session.get(url) as resp            await resp.read()```### Use SQLAlchemy ORMThe SQLAlchemy integration requires you to override the Session and Query Classes for SQL AlchemySQLAlchemy integration uses subsegments so you need to have a segment started before you make a query.```pythonfrom aws_xray_sdk.core import xray_recorderfrom aws_xray_sdk.ext.sqlalchemy.query import XRaySessionMakerxray_recorder.begin_segment('SQLAlchemyTest')Session = XRaySessionMaker(bind=engine)session = Session()xray_recorder.end_segment()app = Flask(__name__)xray_recorder.configure(service='fallback_name', dynamic_naming='*mysite.com*')XRayMiddleware(app, xray_recorder)```### Add Flask-SQLAlchemy```pythonfrom aws_xray_sdk.core import xray_recorderfrom aws_xray_sdk.ext.flask.middleware import XRayMiddlewarefrom aws_xray_sdk.ext.flask_sqlalchemy.query import XRayFlaskSqlAlchemyapp = Flask(__name__)app.config[&quot;SQLALCHEMY_DATABASE_URI&quot;] = &quot;sqlite:///:memory:&quot;XRayMiddleware(app, xray_recorder)db = XRayFlaskSqlAlchemy(app)```### Ignoring httplib requestsIf you want to ignore certain httplib requests you can do so based on the hostname or URL that is being requsted. The hostname is matched using the Python [fnmatch library](https://docs.python.org/3/library/fnmatch.html) which does Unix glob style matching.```pythonfrom aws_xray_sdk.ext.httplib import add_ignored as xray_add_ignored# ignore requests to test.myapp.comxray_add_ignored(hostname='test.myapp.com')# ignore requests to a subdomain of myapp.com with a glob patternxray_add_ignored(hostname='*.myapp.com')# ignore requests to /test-url and /other-test-urlxray_add_ignored(urls=['/test-path', '/other-test-path'])# ignore requests to myapp.com for /test-urlxray_add_ignored(hostname='myapp.com', urls=['/test-url'])```If you use a subclass of httplib to make your requests, you can also filter on the class name that initiates the request. This must use the complete package name to do the match.```pythonfrom aws_xray_sdk.ext.httplib import add_ignored as xray_add_ignored# ignore all requests made by botocorexray_add_ignored(subclass='botocore.awsrequest.AWSHTTPConnection')```## LicenseThe AWS X-Ray SDK for Python is licensed under the Apache 2.0 License. See LICENSE and NOTICE.txt for more information.</longdescription>
</pkgmetadata>