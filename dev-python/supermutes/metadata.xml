<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>supermutes==========This library works with python 2.6, 2.7 and 3.2.It defines three kinds of mutables.dot---The ``dot`` module contains classes that allow dot-notation to be used forwhen accessing a ``list`` or ``dict`` object.eg::    &gt;&gt;  from supermutes.dot import dotify    &gt;&gt;  d = dotify({'a':[1, 2, 3, 4, 5], 'b': {'c': 5}})    &gt;&gt;  d.a._0    1    &gt;&gt;  d.b.c    5    &gt;&gt;  d.c = {'f': 9}    &gt;&gt;  d.c.f    9readonly--------The ``readonly`` module contains classes that transform ``dict`` and ``list``objects into ones that cannot have any values changed on them.eg::    &gt;&gt;  from supermutes.readonly import readonly    &gt;&gt;  r = readonly({'a':[1, 2, 3, 4, 5], 'b': {'c': 5}})    &gt;&gt;  r    {'a': [1, 2, 3, 4, 5], 'b': {'c': 5}}    &gt;&gt;  r['a'].append(5)    supermutes.readonly.ReadOnlyClassException: Cannot write to object.    &gt;&gt; r['b']['d'] = 6    supermutes.readonly.ReadOnlyClassException: Cannot write to object.A decorator function is also available for readonly objects. It willreadonly-fy the output of the decorated function/methodeg::    from supermutes.decorators import return_readonly    @return_readonly    def get_list():        return ['12']OrderedDefaultDict------------------The ``ordered`` module contains the ``OrderedDefaultDict`` class. It is animplementation that is meant to be the child of an ``OrderedDict`` and a``defaultdict`` from the python standard library.Creating Sub Classes--------------------Upon declaration of a sub class of any of the supermutes, that class will beset as the defacto class for recursively changing data sets.To reset the classes back to the original set, use the ``reset_mapping`` methodinside the moduleeg::    &gt;&gt;&gt; from supermutes.dot import DotDict, DotList, reset_mapping    &gt;&gt;&gt; class MySubClass(DotDict): pass    &gt;&gt;&gt; d = MySubClass({'a': {'b': {'c': 3}}})    &gt;&gt;&gt; d.a.b    {'c': 3}    &gt;&gt;&gt; d.a.b.__class__    &lt;class '__main__.MySubClass'&gt;    &gt;&gt;&gt; f = DotList([1, {}])    &gt;&gt;&gt; f[1].__class__    &lt;class '__main__.MySubClass'&gt;    &gt;&gt;&gt; reset_mapping()    &gt;&gt;&gt; f = DotList([1, {}])    &gt;&gt;&gt; f[1].__class__    &lt;class 'supermutes.dot.DotDict'&gt;Writing your own ``Supermutable``---------------------------------If you would like to contribute, and write a supermutable that behaves in aparticular fashion, just try to follow these guidelines:    * It should inherit from the mutable type that it is adapting (eg ``dict``      ``list`` etc.)    * It should also inherit from ``base.SuperMutable``. This takes care of      all of the registering of any subclasses so that for example, all sub      dicts added to the SuperMutable are changed accordingly. See example.py      for a working sample.Building--------After cloning the repo::    $ pip install -r test-requirements.txt    $ nosetests``supermutes`` has a build job at http://travis-ci.org/alexcouper/supermutes</longdescription>
</pkgmetadata>