<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Python Adaptive Card Builder**Easily Build and Export Multilingual Adaptive Cards Through Python**&lt;br&gt;- Programmatically construct adaptive cards like Lego, without the learning curve of Adaptive Card 'Templating'- Avoid the curly-braces jungle of traditional JSON editing- Build pythonically, but with minimal abstraction while preserving readability- Output built cards to JSON or a Python Dictionary in a single method call- Auto-translate all text elements in a card with a single method call- Combine multiple individual cards through the + operator&lt;br&gt;**View this package on pypi** &lt;br&gt;https://pypi.org/project/adaptivecardbuilder/&lt;br&gt;**Installation via pip** &lt;br&gt;```pythonpip install adaptivecardbuilder```&lt;br&gt;**Learn about Adaptive Cards:** &lt;br&gt;- Home Page: https://adaptivecards.io/- Adaptive Card Designer: https://adaptivecards.io/designer/- Schema Explorer: https://adaptivecards.io/explorer/- Documentation: https://docs.microsoft.com/en-us/adaptive-cards/&lt;br&gt;### Adaptive Card Builder &quot;Hello World&quot;:```pythonfrom adaptivecardbuilder import *# initialize cardcard = AdaptiveCard()# Add a textblockcard.add(TextBlock(text=&quot;0.45 miles away&quot;, separator=&quot;true&quot;, spacing=&quot;large&quot;))# add column setcard.add(ColumnSet())# First column contentscard.add(Column(width=2))card.add(TextBlock(text=&quot;BANK OF LINGFIELD BRANCH&quot;))card.add(TextBlock(text=&quot;NE Branch&quot;, size=&quot;ExtraLarge&quot;, weight=&quot;Bolder&quot;))card.add(TextBlock(text=&quot;4.2 stars&quot;, isSubtle=True, spacing=&quot;None&quot;))card.add(TextBlock(text=f&quot;Some review text for illustration&quot;, size=&quot;Small&quot;))# Back up to column setcard.up_one_level() # Second column contentscard.add(Column(width=1))card.add(Image(url=&quot;https://s17026.pcdn.co/wp-content/uploads/sites/9/2018/08/Business-bank-account-e1534519443766.jpeg&quot;))# Serialize to a json payload with a one-linerawait card.to_json()```Output when rendered in https://adaptivecards.io/visualizer/ : &lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44293915/83967653-7ac06000-a8bb-11ea-843a-d045856ddf7f.png&quot; alt=&quot;table&quot; width=&quot;500&quot;/&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;## A &quot;Visual&quot; AlternativeThe ```AdaptiveCard``` class also supports a more visual approach to building cards by passing a list of elements to the ```add()``` method instead. &lt;br&gt; This allows us to freely indent our code within the method call and better illustrate card structure.When using this visual alternative approach to building cards, we can use specific strings to execute logic.- Strings containing ```&quot;&lt;&quot;``` move us up/back a level in the tree- Strings containing ```&quot;^&quot;``` will move us back to the top of the tree```pythoncard = AdaptiveCard()# Add a list of elementscard.add([    TextBlock(&quot;Top Level&quot;),    ColumnSet(),        Column(),            TextBlock(&quot;Column 1 Top Item&quot;),            TextBlock(&quot;Column 1 Second Item&quot;),            &quot;&lt;&quot;,        Column(),            TextBlock(&quot;Column 2 Top Item&quot;),            TextBlock(&quot;Column 2 Second Item&quot;),            &quot;&lt;&quot;,        &quot;&lt;&quot;,    TextBlock(&quot;Lowest Level&quot;),    ActionOpenUrl(title=&quot;View Website&quot;, url=&quot;someurl.com&quot;),    ActionShowCard(title=&quot;Click to Comment&quot;),        InputText(ID=&quot;comment&quot;, placeholder=&quot;Type Here&quot;),        ActionSubmit(title=&quot;Submit Comment&quot;)])await card.to_json()```Output when rendered in https://adaptivecards.io/visualizer/ : &lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44293915/84180249-177f2b00-aa7f-11ea-94ec-c2923a9d3bd1.png&quot;  width=&quot;400&quot;/&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;## Combining/Chaining CardsWe can also combine the contents of multiple cards through the ```+``` operator:```pythondef create_single_card(input_text_id: int):    card = AdaptiveCard()    card.add([        TextBlock(&quot;Top Level&quot;),        ColumnSet(),            Column(),                TextBlock(&quot;Column 1 Top Item&quot;),                TextBlock(&quot;Column 1 Second Item&quot;),                &quot;&lt;&quot;,            Column(),                TextBlock(&quot;Column 2 Top Item&quot;),                TextBlock(&quot;Column 2 Second Item&quot;),                &quot;&lt;&quot;,            &quot;&lt;&quot;,        TextBlock(&quot;Lowest Level&quot;),        ActionOpenUrl(title=&quot;View Website&quot;, url=&quot;someurl.com&quot;),        ActionShowCard(title=&quot;Click to Comment&quot;),            InputText(ID=f&quot;comment_{input_text_id}&quot;, placeholder=&quot;Type Here&quot;),            ActionSubmit(title=&quot;Submit Comment&quot;)    ])    return card# Use above function to create cardscard1 = create_single_card(1)card2 = create_single_card(2)# Add the contents of card1 and card2combined_card = card1 + card2await combined_card.to_json()```&lt;br&gt;Output when rendered in https://adaptivecards.io/visualizer/ : &lt;img src=&quot;https://i.ibb.co/McPxYYF/Malay-screenshot.png&quot; width=&quot;400&quot;/&gt;&lt;br&gt;To preserve intra-card ordering of elements, AdaptiveCardBuilder moves all actions in the outermost action container of each card into their bodies by placing them in ActionSets instead. Each constituent card's actions is therefore attached to the appropriate portion of the combined card.The ```combine_adaptive_cards``` function can also be used to combine a list of adaptive cards together, in a left-to-right fashion. The following code essentially produces the same result as the code above, except an arbitrary length list of cards can now be passed:```pythoncard1 = create_single_card(1)card2 = create_single_card(2)card3 = create_single_card(3)# Add the contents of all above cardscombined_card = combine_adaptive_cards([card1, card2, card3])await combined_card.to_json()```&lt;br&gt;&lt;br&gt;## Translating Card ElementsPassing translator arguments to the ```to_json()``` method will translate cards. &lt;br&gt;Using the example above, we can translate the created card in the same method call. &lt;br&gt;To view a list of supported languages and language codes, go to:https://docs.microsoft.com/en-us/azure/cognitive-services/translator/language-support```python# Translate all text in card to Malayawait card.to_json(translator_to_lang='ms', translator_key='&lt;YOUR AZURE API KEY&gt;')```&lt;img src=&quot;https://i.ibb.co/kBTJb1m/Malay-screenshot.png&quot; width=&quot;400&quot;/&gt;&lt;br&gt;&lt;br&gt;If any ```translator_to_lang``` argument is passed, translation will apply to all elements with translatable text attributes. &lt;br&gt;To specify that a given Adaptive element **should not** be translated, simply pass the keyworded argument ```dont_translate=True``` during the construction of any element, and AdaptiveCardBuilder will leave this specific element untranslated.&lt;br&gt;&lt;br&gt;## ConceptsThe ```AdaptiveCard``` class centrally handles all construction &amp; element-addition operations: &lt;br&gt;```pythonfrom adaptivecardbuilder import *card = AdaptiveCard() # initialize    # Structure:    # |--Card    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body=[]    # |   |--Actions=[]card.add(TextBlock(text=&quot;Header&quot;, weight=&quot;Bolder&quot;))card.add(TextBlock(text=&quot;Subheader&quot;))card.add(TextBlock(text=&quot;*Quote*&quot;, isSubtle=&quot;true&quot;))    # |--Card    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body    # |       |--TextBlock    # |       |--TextBlock    # |       |--TextBlock    # |   |--Actionscard_json = await card.to_json() # output to json```&lt;br&gt;When rendered:&lt;img src=&quot;https://user-images.githubusercontent.com/44293915/83965757-ff0be680-a8ad-11ea-8936-108e3faa6fee.png&quot; alt=&quot;table&quot; width=&quot;500&quot;/&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;**Each individual adaptive object (e.g. TextBlock, Column)** is implemented as a class. &lt;br&gt;These are simply Python object representations of the standard Adaptive Card elements that take keyworded arguments as parameters. &lt;br&gt;View the Schema Explorer at https://adaptivecards.io/explorer/ to see which keyword arguments each Adaptive Object is allowed to take.```pythonTextBlock(text=&quot;Header&quot;, weight=&quot;Bolder&quot;)# Internal representation&gt;&gt;&gt; {        &quot;type&quot;: &quot;TextBlock&quot;,        &quot;text&quot;: &quot;Header&quot;,        &quot;weight&quot;: &quot;Bolder&quot;    }```&lt;br&gt;&lt;br&gt;### Pointer LogicCentral to the ```AdaptiveCard``` class is an internal ```_pointer``` attribute. When we add an element to the card, the element is by default **added to the item container** of whichever object is being pointed at. &lt;br&gt;Conceptually, an adaptive object (e.g. Column, Container) can have up to two kinds of containers (python ```list```s):1. **Item** containers (these hold non-interactive elements like TextBlocks, Images)2. **Action** containers (these hold interactive actions like ActionShowUrl, ActionSubmit)For instance:- ```AdaptiveCard``` objects have both **item** (```body=[]```) and **action** (```actions=[]```) containers- ```ColumnSet``` objects have a single **item** (```columns=[]```) container- ```Column``` objects have a single **item** (```items=[]```) container- ```ActionSet``` objects have a single **action** (```actions=[]```) containerThe ```card.add()``` method will add a given AdaptiveObject to the appropriate container. For instance, if an Action-type object is passed, such as a ```ActionSubmit``` or ```ActionOpenUrl```, then this will be added to the parent object's **action** container.If the parent object does not have the appropriate container for the element being added, then this will throw an ```AssertionError``` and a corresponding suggestion.&lt;br&gt;&lt;br&gt;### Recursing Into an Added Element**When adding elements that can *themselves* contain other elements** (e.g. column sets and columns), the pointer will by default **recurse into the added element**, so that any elements added thereafter will go straight into the added element's container (making our code less verbose). &lt;br&gt;This is essentially a **depth-first** approach to building cards:```pythoncard = AdaptiveCard()     # |--Card               &lt;- Pointer    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body=[]    # |   |--Actions=[]card.add(TextBlock(text=&quot;Header&quot;, weight=&quot;Bolder&quot;))    # |--Card               &lt;- Pointer    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body                   # |       |--TextBlock     &lt;- added    # |   |--Actionscard.add(TextBlock(text=&quot;Subheader&quot;))card.add(TextBlock(text=&quot;*Quote*&quot;, isSubtle=&quot;true&quot;))    # |--Card               &lt;- Pointer    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body                   # |       |--TextBlock    # |       |--TextBlock     &lt;- added    # |       |--TextBlock     &lt;- added    # |   |--Actionscard.add(ColumnSet())    # |--Card    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body    # |       |--TextBlock    # |       |--TextBlock    # |       |--TextBlock    # |       |--ColumnSet        &lt;- Pointer &lt;- added    # |   |--Actionscard.add(Column(width=1))    # |--Card    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body    # |       |--TextBlock    # |       |--TextBlock    # |       |--TextBlock    # |       |--ColumnSet    # |           |--Column         &lt;- Pointer &lt;- added    # |   |--Actionscard.add(TextBlock(text=&quot;&lt;Column 1 Contents&gt;&quot;))    # |--Card    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body    # |       |--TextBlock    # |       |--TextBlock    # |       |--TextBlock    # |       |--ColumnSet    # |           |--Column         &lt;- Pointer    # |               |--TextBlock  &lt;- added    # |   |--Actions```&lt;br&gt;Rendered: &lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44293915/83966745-fd452180-a8b3-11ea-9115-0056f8667102.png&quot; alt=&quot;table&quot; width=&quot;500&quot;/&gt;&lt;br&gt;&lt;br&gt;Observe that when adding a ```TextBlock``` to a ```Column```'s items, the pointer stays at the ```Column``` level, rather than recursing into the ```TextBlock```. The ```add()``` method will only recurse into the added element if it has an **item** or **action** container within it.Because of the depth-first approach, we'll need to **back ourselves out** of a container once we are done adding elements to it. &lt;br&gt;One easy method to doing so is by using the ```up_one_level()``` method, can be called multiple times and just moves the pointer one step up the element tree.```pythoncard = AdaptiveCard()card.add(TextBlock(text=&quot;Header&quot;, weight=&quot;Bolder&quot;))card.add(TextBlock(text=&quot;Subheader&quot;))card.add(TextBlock(text=&quot;*Quote*&quot;, isSubtle=&quot;true&quot;))card.add(ColumnSet())card.add(Column(width=1))card.add(TextBlock(text=&quot;&lt;Column 1 Contents&gt;&quot;))    # |--Card    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body    # |       |--TextBlock    # |       |--TextBlock    # |       |--TextBlock    # |       |--ColumnSet    # |           |--Column         &lt;- Pointer    # |               |--TextBlock  &lt;- added    # |   |--Actionscard.up_one_level()    # |--Card    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body    # |       |--TextBlock    # |       |--TextBlock    # |       |--TextBlock    # |       |--ColumnSet          &lt;- Pointer    # |           |--Column            # |               |--TextBlock      # |   |--Actionscard.add(Column(width=1))    # |--Card    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body    # |       |--TextBlock    # |       |--TextBlock    # |       |--TextBlock    # |       |--ColumnSet           # |           |--Column            # |               |--TextBlock    # |           |--Column         &lt;- Pointer &lt;- added    # |   |--Actionscard.add(TextBlock(text=&quot;Column 2 Contents&quot;))    # |--Card    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body    # |       |--TextBlock    # |       |--TextBlock    # |       |--TextBlock    # |       |--ColumnSet           # |           |--Column            # |               |--TextBlock    # |           |--Column         &lt;- Pointer    # |               |--TextBlock  &lt;- added    # |   |--Actions```&lt;br&gt;Rendered: &lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44293915/83967818-d17a6980-a8bc-11ea-9518-1a3e15dfa38e.png&quot; alt=&quot;table&quot; width=&quot;500&quot;/&gt;&lt;br&gt;&lt;br&gt;We can also use the ```card.save_level()``` method to create a &quot;checkpoint&quot; at any level if we intend to back ourselves out to the level we are currently at in our code block. To &quot;reload&quot; to that checkpoint, use ```card.load_level(checkpoint)```.```python# checkpoints examplecard = AdaptiveCard()card.add(Container())card.add(TextBlock(text=&quot;Text as the first item, at the container level&quot;))# create checkpoint herecontainer_level = card.save_level()# add nested columnsets and columns for funfor i in range(1, 6):    card.add(ColumnSet())    card.add(Column(style=&quot;emphasis&quot;))    card.add(TextBlock(text=f&quot;Nested Column {i}&quot;))    # our pointer continues to move downwards into the nested structure# reset pointer back to container levelcard.load_level(container_level)card.add(TextBlock(text=&quot;Text at the container level, below all the nested containers&quot;))await card.to_json()```&lt;img src=&quot;https://user-images.githubusercontent.com/44293915/83975014-3055d800-a8e9-11ea-8f6a-3284ee9a48db.png&quot; alt=&quot;table&quot; width=&quot;450&quot;/&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;## Adding ActionsAs previously mentioned, the AdaptiveCard's ```add()``` method will automatically add action elements to the appropriate containers.Let's first move our pointer back to the top level using the ```back_to_top()``` method:```pythoncard.back_to_top() # back to top of tree    # |--Card                   &lt;- Pointer    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body                   # |       |--TextBlock    # |       |--TextBlock    # |       |--TextBlock    # |       |--ColumnSet           # |           |--Column            # |               |--TextBlock    # |           |--Column             # |               |--TextBlock    # |   |--Actions```&lt;br&gt;Our pointer is now pointing at the main Card object. &lt;br&gt;Because it has an **Actions** container, the next action element to be added will be sent there.```python# Adding single url actioncard.add(ActionOpenUrl(url=&quot;someurl.com&quot;, title=&quot;Open Me&quot;))    # |--Card                       &lt;- Pointer    # |   |--Schema=&quot;XXX&quot;    # |   |--Version=&quot;1.0&quot;    # |   |--Body                   # |       |--TextBlock    # |       |--TextBlock    # |       |--TextBlock    # |       |--ColumnSet           # |           |--Column            # |               |--TextBlock    # |           |--Column             # |               |--TextBlock    # |   |--Actions                        # |       |--ActionOpenUrl      &lt;- added```&lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44293915/83968535-da216e80-a8c1-11ea-8dd2-33ff5aa21fc3.png&quot; alt=&quot;table&quot; width=&quot;500&quot;/&gt;</longdescription>
</pkgmetadata>