<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>methodtools===========Expand functools features to methods, classmethods, staticmethods and even for(unofficial) hybrid methods.For now, methodtools only provides `methodtools.lru_cache`.Use `methodtools` module instead of `functools` module. Than it will work asyou expected... code:: python    from methodtools import lru_cache    class A(object):        # cached method. the storage lifetime follows `self` object        @lru_cache()        def cached_method(self, args):            ...        # cached classmethod. the storage lifetime follows `A` class        @lru_cache()  # the order is important!        @classmethod  # always lru_cache on top of classmethod        def cached_classmethod(self, args):            ...        # cached staticmethod. the storage lifetime follows `A` class        @lru_cache()  # the order is important!        @staticmethod  # always lru_cache on top of staticmethod        def cached_staticmethod(self, args):            ...    @lru_cache()  # just same as functools.lru_cache    def cached_function():        ...Installation------------PyPI is the recommended way... sourcecode:: shell    $ pip install methodtoolsTo browse versions and tarballs, visit:    `&lt;https://pypi.python.org/pypi/methodtools/&gt;`_.. note::    If you are working on Python 2, install also `functools32`.See also--------- [Documentation](https://methodtools.readthedocs.io/en/latest/)- This project is derived from `Ring &lt;https://github.com/youknowone/ring/&gt;`_,  a rich cache interface using the same method handling technique.- To learn more about bound method dispatching, see also  [wirerope](https://github.com/youknowone/wirerope).</longdescription>
</pkgmetadata>