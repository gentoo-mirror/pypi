<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>.. contents::Linux AIO API wrapperThis is about in-kernel, file-descriptor-based asynchronous I/O.It has nothing to do with the ``asyncio`` standard module.Linux AIO primer----------------When sending or expecting data, the typical issue a developer faces is knowingwhen the operation will complete, so the program can carry on.- read/write/recv/send: blocks until stuff happened- same, on a non-blocking file descriptor: errors out instead of blocking,  developper has to implement retry somehow, and may end up wasting CPU time  just resubmitting the same operation over and over.- select/poll/epoll: kernel tells the program when (re)submitting an operation  should not block (if developer is careful to not have competing IO sources)AIO is the next level: the application expresses the intention that some IOoperation happens when the file descriptor accepts it *and* providescorresponding buffer to the kernel.Compared to select/poll/epoll, this avoids one round-trip to userland when theoperation becomes possible:- kernel sends notification (ex: fd is readable)- program initiates actual IO (ex: read from fd)Instead, kernel only has to notify userland the operation is already completed,and application may either process received data, or submit more data to send.Edge cases----------Because of this high level of integration, low-level implementationconstraints which are abstracted by higher-overhead APIs may become apparent.For example, when submitting AIO blocks to an USB gadget endpoint file, theblock should be aligned to page boundaries because some USB Device Controllersdo not have the ability to read/write partial pages.In python, this means ``mmap`` should be used to allocate such buffer insteadof just any ``bytearray``.Another place where implementation details appear is completion statuses,``res`` and ``res2``. Their meaning depends on the module handling operationson used file descriptor, so python-libaio transmits these values withoutassuming their meaning (rather than, say, raise on negative values).Yet another place is application-initiated closures: there is a fundamentalrace-condition when cancelling an AIO block (maybe hardware-triggeredcompletion will happen first, or maybe software-initiated cancellation will).In any case, a completion event will be produced and application may checkwhich origin won. A consequence of this is that AIO context closure may taketime: while requesting cancellation does not block, software should wait forhardware to hand the buffers back.python 2 Notes--------------In python 2.7, a memoryview of a bytearray, despite being writable, is rejectedby ctypes:.. code:: python    &gt;&gt;&gt; from ctypes import c_char    &gt;&gt;&gt; a = bytearray(b'foo')    &gt;&gt;&gt; c_char.from_buffer(a)    c_char('f')    &gt;&gt;&gt; b = memoryview(a)    &gt;&gt;&gt; b.readonly    False    &gt;&gt;&gt; c_char.from_buffer(b)    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;    TypeError: expected a writeable buffer objectThis means that it is not possible to only read or write a few bytes at thebeginning of a large buffer without having to copy memory.The same code works fine with python 3.x .This is considered a python 2.7 ctypes or memoryview bug, and not a python-libaio bug.Also, memoryview refuses to use an mmap object:.. code:: python    &gt;&gt;&gt; import mmap    &gt;&gt;&gt; a = mmap.mmap(-1, 16*1024)    &gt;&gt;&gt; b = memoryview(a)    Traceback (most recent call last):      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;    TypeError: cannot make memory view because object does not have the buffer interface    &gt;&gt;&gt;...but ctypes is happy with it:.. code:: python    &gt;&gt;&gt; import ctypes    &gt;&gt;&gt; c = (ctypes.c_char * len(a)).from_buffer(a)    &gt;&gt;&gt;...and memoryview accepts being constructed over ctype objects:.. code:: python    &gt;&gt;&gt; d = memoryview(c)    &gt;&gt;&gt;...and it really works !.. code:: python    &gt;&gt;&gt; a[0]    '\x00'    &gt;&gt;&gt; c[0]    '\x00'    &gt;&gt;&gt; d[0]    '\x00'    &gt;&gt;&gt; d[0] = '\x01'    &gt;&gt;&gt; c[0]    '\x01'    &gt;&gt;&gt; a[0]    '\x01'    &gt;&gt;&gt; a[0] = '\x02'    &gt;&gt;&gt; c[0]    '\x02'    &gt;&gt;&gt; d[0]    '\x02'This is considered a python 2.7 memoryview or mmap bug.</longdescription>
</pkgmetadata>