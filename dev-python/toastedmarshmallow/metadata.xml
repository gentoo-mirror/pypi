<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>*************************************************************:fire:toastedmarshmallow:fire:: Makes Marshmallow Toasty Fast*************************************************************Toasted Marshmallow implements a JIT for marshmallow that speeds up dumpingobjects 10-25X (depending on your schema).  Toasted Marshmallow allows you tohave the great API that`Marshmallow &lt;https://github.com/marshmallow-code/marshmallow&gt;`_ provideswithout having to sacrifice performance!::    Benchmark Result:      Original Time: 2682.61 usec/dump      Optimized Time: 176.38 usec/dump      Speed up: 15.21xEven ``PyPy`` benefits from ``toastedmarshmallow``!::    Benchmark Result:    Original Time: 189.78 usec/dump    Optimized Time: 20.03 usec/dump    Speed up: 9.48xInstalling toastedmarshmallow-----------------------------.. code-block:: bash  pip install toastedmarshmallowThis will *also* install a slightly-forked ``marshmallow`` that includes somehooks Toastedmarshmallow needs enable the JIT to run before falling backto the original marshmallow code.  These changes are minimal making it easierto track upstream.  You can find the changes`Here &lt;https://github.com/marshmallow-code/marshmallow/pull/629/files&gt;`_.This means you should **remove** ``marshmallow`` from your requirements andreplace it with ``toastedmarshmallow``.  By default there is nodifference unless you explicitly enable Toasted Marshmallow.Enabling Toasted Marshmallow----------------------------Enabling Toasted Marshmallow on an existing Schema is just one line of code,set the ``jit`` property on any ``Schema`` instance to ``toastedmarshmallow.Jit``.  For example:.. code-block:: python    from datetime import date    import toastedmarshmallow    from marshmallow import Schema, fields, pprint    class ArtistSchema(Schema):        name = fields.Str()    class AlbumSchema(Schema):        title = fields.Str()        release_date = fields.Date()        artist = fields.Nested(ArtistSchema())    schema = AlbumSchema()    # Specify the jit method as toastedmarshmallow's jit    schema.jit = toastedmarshmallow.Jit    # And that's it!  Your dump methods are 15x faster!It's also possible to use the ``Meta`` class on the ``Marshmallow`` schemato specify all instances of a given ``Schema`` should be optimized:.. code-block:: python    import toastedmarshmallow    from marshmallow import Schema, fields, pprint    class ArtistSchema(Schema):        class Meta:            jit = toastedMarshmallow.Jit        name = fields.Str()You can also enable Toasted Marshmallow globally by setting the environmentvariable ``MARSHMALLOW_SCHEMA_DEFAULT_JIT`` to ``toastedmarshmallow.Jit`` .Future versions of Toasted Marshmallow may make this the default.How it works------------Toasted Marshmallow works by generating code at runtime to optimize dumpingobjects without going through layers and layers of reflection.  The generatedcode optimistically assumes the objects being passed in are schematically valid,falling back to the original marshmallow code on failure.For example, taking ``AlbumSchema`` from above, Toastedmarshmallow willgenerate the following 3 methods:.. code-block:: python    def InstanceSerializer(obj):        res = {}        value = obj.release_date; value = value() if callable(value) else value; res[&quot;release_date&quot;] = _field_release_date__serialize(value, &quot;release_date&quot;, obj)        value = obj.artist; value = value() if callable(value) else value; res[&quot;artist&quot;] = _field_artist__serialize(value, &quot;artist&quot;, obj)        value = obj.title; value = value() if callable(value) else value; value = str(value) if value is not None else None; res[&quot;title&quot;] = value        return res    def DictSerializer(obj):        res = {}        if &quot;release_date&quot; in obj:            value = obj[&quot;release_date&quot;]; value = value() if callable(value) else value; res[&quot;release_date&quot;] = _field_release_date__serialize(value, &quot;release_date&quot;, obj)        if &quot;artist&quot; in obj:            value = obj[&quot;artist&quot;]; value = value() if callable(value) else value; res[&quot;artist&quot;] = _field_artist__serialize(value, &quot;artist&quot;, obj)        if &quot;title&quot; in obj:            value = obj[&quot;title&quot;]; value = value() if callable(value) else value; value = str(value) if value is not None else None; res[&quot;title&quot;] = value        return res    def HybridSerializer(obj):        res = {}        try:            value = obj[&quot;release_date&quot;]        except (KeyError, AttributeError, IndexError, TypeError):            value = obj.release_date        value = value; value = value() if callable(value) else value; res[&quot;release_date&quot;] = _field_release_date__serialize(value, &quot;release_date&quot;, obj)        try:            value = obj[&quot;artist&quot;]        except (KeyError, AttributeError, IndexError, TypeError):            value = obj.artist        value = value; value = value() if callable(value) else value; res[&quot;artist&quot;] = _field_artist__serialize(value, &quot;artist&quot;, obj)        try:            value = obj[&quot;title&quot;]        except (KeyError, AttributeError, IndexError, TypeError):            value = obj.title        value = value; value = value() if callable(value) else value; value = str(value) if value is not None else None; res[&quot;title&quot;] = value        return resToastedmarshmallow will invoke the proper serializer based upon the input.Since Toastedmarshmallow is generating code at runtime, it's critical youre-use Schema objects.  If you're creating a new Schema object every time youserialize/deserialize an object you'll likely have much worse performance.</longdescription>
</pkgmetadata>