<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># IBM Analog Hardware Acceleration Kit![PyPI](https://img.shields.io/pypi/v/aihwkit)[![Documentation Status](https://readthedocs.org/projects/aihwkit/badge/?version=latest)](https://aihwkit.readthedocs.io/en/latest/?badge=latest)[![Build Status](https://travis-ci.com/IBM/aihwkit.svg?branch=master)](https://travis-ci.com/IBM/aihwkit)![PyPI - License](https://img.shields.io/pypi/l/aihwkit)[![arXiv](https://img.shields.io/badge/arXiv-2104.02184-green.svg)](https://arxiv.org/abs/2104.02184)## Description_IBM Analog Hardware Acceleration Kit_ is an open source Python toolkit forexploring and using the capabilities of in-memory computing devices in thecontext of artificial intelligence.&gt; :warning: This library is currently in beta and under active development.&gt; Please be mindful of potential issues and keep an eye for improvements,&gt; new features and bug fixes in upcoming versions.The toolkit consists of two main components:### Pytorch integrationA series of primitives and features that allow using the toolkit within[`PyTorch`]:* Analog neural network modules (fully connected layer, 1d/2d/3d convolution  layers, LSTM layer, sequential container).* Analog training using torch training workflow:  * Analog torch optimizers (SGD).  * Analog in-situ training using customizable device models and algorithms    (Tiki-Taka).* Analog inference using torch inference workflow:  * State-of-the-art statistical model of a phase-change memory (PCM) array    calibrated on hardware measurements from a 1 million PCM devices chip.  * Hardware-aware training with hardware non-idealities and noise    included in the forward pass to make the trained models more    robust during inference on Analog hardware.### Analog devices simulatorA high-performant (CUDA-capable) C++ simulator that allows forsimulating a wide range of analog devices and crossbar configurationsby using abstract functional models of material characteristics withadjustable parameters. Features include:* Forward pass output-referred noise and device fluctuations, as well  as adjustable ADC and DAC discretization and bounds* Stochastic update pulse trains for rows and columns with finite  weight update size per pulse coincidence* Device-to-device systematic variations, cycle-to-cycle noise and  adjustable asymmetry during analog update* Adjustable device behavior for exploration of material specifications for  training and inference* State-of-the-art dynamic input scaling, bound management, and update  management schemes### Other featuresAlong with the two main components, the toolkit includes otherfunctionalities such as:* A library of device presets that are calibrated to real hardware data and  based on models in the literature, along with configuration that specifies a particular device and optimizer choice.* A module for executing high-level use cases (&quot;experiments&quot;), such as neural  network training with minimal code overhead.* A utility to automatically convert a downloaded model (e.g., pre-trained) to its equivalent Analog  model by replacing all linear/conv layers to Analog layers (e.g., for convenient hardware-aware training).* Integration with the [AIHW Composer] platform, a no-code web experience, that allows executing  experiments in the cloud.## Example### Training example```pythonfrom torch import Tensorfrom torch.nn.functional import mse_loss# Import the aihwkit constructs.from aihwkit.nn import AnalogLinearfrom aihwkit.optim import AnalogSGDx = Tensor([[0.1, 0.2, 0.4, 0.3], [0.2, 0.1, 0.1, 0.3]])y = Tensor([[1.0, 0.5], [0.7, 0.3]])# Define a network using a single Analog layer.model = AnalogLinear(4, 2)# Use the analog-aware stochastic gradient descent optimizer.opt = AnalogSGD(model.parameters(), lr=0.1)opt.regroup_param_groups(model)# Train the network.for epoch in range(10):    pred = model(x)    loss = mse_loss(pred, y)    loss.backward()    opt.step()    print('Loss error: {:.16f}'.format(loss))```You can find more examples in the [`examples/`] folder of the project, andmore information about the library in the [documentation]. Please note thatthe examples have some additional dependencies - you can install them via`pip install -r requirements-examples.txt`.## What is Analog AI?In traditional hardware architecture, computation and memory are siloed indifferent locations. Information is moved back and forth between computationand memory units every time an operation is performed, creating a limitationcalled the [von Neumann bottleneck].Analog AI delivers radical performance improvements by combining compute andmemory in a single device, eliminating the von Neumann bottleneck. By leveragingthe physical properties of memory devices, computation happens at the same placewhere the data is stored. Such in-memory computing hardware increases the speedand energy-efficiency needed for next generation AI workloads.## What is an in-memory computing chip?An in-memory computing chip typically consists of multiple arrays of memorydevices that communicate with each other. Many types of memory devices such as[phase-change memory] (PCM), [resistive random-access memory] (RRAM), and[Flash memory] can be used for in-memory computing.Memory devices have the ability to store synaptic weights in their analogcharge (Flash) or conductance (PCM, RRAM) state. When these devices are arrangedin a crossbar configuration, it allows to perform an analog matrix-vectormultiplication in a single time step, exploiting the advantages of analogstorage capability and [Kirchhoff’s circuits laws]. You can learn more aboutit in our [online demo].In deep learning, data propagation through multiple layers of a neural networkinvolves a sequence of matrix multiplications, as each layer can be representedas a matrix of synaptic weights. The devices are arranged in multiple crossbararrays, creating an artificial neural network where all matrix multiplicationsare performed in-place in an analog manner. This structure allows to run deeplearning models at reduced energy consumption.## How to cite?In case you are using the _IBM Analog Hardware Acceleration Kit_ foryour research, please cite the AICAS21 paper that describes the toolkit:&gt; Malte J. Rasch, Diego Moreda, Tayfun Gokmen, Manuel Le Gallo, Fabio Carta,&gt; Cindy Goldberg, Kaoutar El Maghraoui, Abu Sebastian, Vijay Narayanan.&gt; &quot;A flexible and fast PyTorch toolkit for simulating training and inference on&gt; analog crossbar arrays&quot; (2021 IEEE 3rd International Conference on Artificial Intelligence Circuits and Systems)&gt;&gt; https://ieeexplore.ieee.org/abstract/document/9458494## Installation### Installing from PyPIThe preferred way to install this package is by using the[Python package index]:```bash$ pip install aihwkit```&gt; :warning: Note that currently we provide CPU-only pre-built packages for&gt; specific combinations of architectures and versions, and in some cases a&gt; pre-built package might still not be available.If you encounter any issues during download or want to compile the packagefor your environment, please refer to the [advanced installation] guide.That section describes the additional libraries and tools required forcompiling the sources, using a build system based on `cmake`.## AuthorsIBM Analog Hardware Acceleration Kit has been developed by IBM Research,with Malte Rasch, Tayfun Gokmen, Diego Moreda, Manuel Le Gallo-Bourdeau, and Kaoutar El Maghraouias the initial core authors, along with many [contributors].You can contact us by opening a new issue in the repository, or alternativelyat the ``aihwkit@us.ibm.com`` email address.## LicenseThis project is licensed under [Apache License 2.0].[Apache License 2.0]: LICENSE.txt[`CUDA Toolkit`]: https://developer.nvidia.com/accelerated-computing-toolkit[`OpenBLAS`]: https://www.openblas.net/[Python package index]: https://pypi.org/project/aihwkit[`PyTorch`]: https://pytorch.org/[`examples/`]: examples/[documentation]: https://aihwkit.readthedocs.io/[contributors]: https://github.com/IBM/aihwkit/graphs/contributors[advanced installation]: https://aihwkit.readthedocs.io/en/latest/advanced_install.html[von Neumann bottleneck]: https://en.wikipedia.org/wiki/Von_Neumann_architecture#Von_Neumann_bottleneck[phase-change memory]: https://en.wikipedia.org/wiki/Phase-change_memory[resistive random-access memory]: https://en.wikipedia.org/wiki/Resistive_random-access_memory[Flash memory]: https://en.wikipedia.org/wiki/Flash_memory[Kirchhoff’s circuits laws]: https://en.wikipedia.org/wiki/Kirchhoff%27s_circuit_laws[online demo]: https://analog-ai-demo.mybluemix.net/[AIHW Composer]: https://aihw-composer.draco.res.ibm.com</longdescription>
</pkgmetadata>