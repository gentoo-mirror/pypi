<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>|Build Status|_.. |Build Status| image:: https://github.com/matthewwithanm/django-imagekit/actions/workflows/python.yml/badge.svg?branch=develop.. _Build Status: https://github.com/matthewwithanm/django-imagekit/actions/workflows/python.ymlImageKit is a Django app for processing images. Need a thumbnail? Ablack-and-white version of a user-uploaded image? ImageKit will make them foryou. If you need to programmatically generate one image from another, you needImageKit.ImageKit comes with a bunch of image processors for common tasks like resizingand cropping, but you can also create your own. For an idea of what's possible,check out the `Instakit`__ project.**For the complete documentation on the latest stable version of ImageKit, see**`ImageKit on RTD`_... _`ImageKit on RTD`: http://django-imagekit.readthedocs.org__ https://github.com/fish2000/instakitInstallation============1. Install `Pillow`_. (If you're using an ``ImageField`` in Django,   you should have already done this.)2. ``pip install django-imagekit``3. Add ``'imagekit'`` to your ``INSTALLED_APPS`` list in your project's ``settings.py``.. _`Pillow`: http://pypi.python.org/pypi/PillowUsage Overview==============.. _specs:Specs-----You have one image and you want to do something to it to create another image.But how do you tell ImageKit what to do? By defining an image spec.An **image spec** is a type of **image generator** that generates a new imagefrom a source image.Defining Specs In Models^^^^^^^^^^^^^^^^^^^^^^^^The easiest way to use define an image spec is by using an ImageSpecField onyour model class:.. code-block:: python    from django.db import models    from imagekit.models import ImageSpecField    from imagekit.processors import ResizeToFill    class Profile(models.Model):        avatar = models.ImageField(upload_to='avatars')        avatar_thumbnail = ImageSpecField(source='avatar',                                          processors=[ResizeToFill(100, 50)],                                          format='JPEG',                                          options={'quality': 60})    profile = Profile.objects.all()[0]    print(profile.avatar_thumbnail.url)    # &gt; /media/CACHE/images/982d5af84cddddfd0fbf70892b4431e4.jpg    print(profile.avatar_thumbnail.width)  # &gt; 100As you can probably tell, ImageSpecFields work a lot like Django'sImageFields. The difference is that they're automatically generated byImageKit based on the instructions you give. In the example above, the avatarthumbnail is a resized version of the avatar image, saved as a JPEG with aquality of 60.Sometimes, however, you don't need to keep the original image (the avatar inthe above example); when the user uploads an image, you just want to process itand save the result. In those cases, you can use the ``ProcessedImageField``class:.. code-block:: python    from django.db import models    from imagekit.models import ProcessedImageField    from imagekit.processors import ResizeToFill    class Profile(models.Model):        avatar_thumbnail = ProcessedImageField(upload_to='avatars',                                               processors=[ResizeToFill(100, 50)],                                               format='JPEG',                                               options={'quality': 60})    profile = Profile.objects.all()[0]    print(profile.avatar_thumbnail.url)    # &gt; /media/avatars/MY-avatar.jpg    print(profile.avatar_thumbnail.width)  # &gt; 100This is pretty similar to our previous example. We don't need to specify a&quot;source&quot; any more since we're not processing another image field, but we do needto pass an &quot;upload_to&quot; argument. This behaves exactly as it does for DjangoImageFields... note::    You might be wondering why we didn't need an &quot;upload_to&quot; argument for our    ImageSpecField. The reason is that ProcessedImageFields really are just like    ImageFields—they save the file path in the database and you need to run    syncdb (or create a migration) when you add one to your model.    ImageSpecFields, on the other hand, are virtual—they add no fields to your    database and don't require a database. This is handy for a lot of reasons,    but it means that the path to the image file needs to be programmatically    constructed based on the source image and the spec.Defining Specs Outside of Models^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Defining specs as models fields is one very convenient way to process images,but it isn't the only way. Sometimes you can't (or don't want to) add fields toyour models, and that's okay. You can define image spec classes and use themdirectly. This can be especially useful for doing image processing in views—particularly when the processing being done depends on user input... code-block:: python    from imagekit import ImageSpec    from imagekit.processors import ResizeToFill    class Thumbnail(ImageSpec):        processors = [ResizeToFill(100, 50)]        format = 'JPEG'        options = {'quality': 60}It's probably not surprising that this class is capable of processing an imagein the exact same way as our ImageSpecField above. However, unlike with theimage spec model field, this class doesn't define what source the spec is actingon, or what should be done with the result; that's up to you:.. code-block:: python    source_file = open('/path/to/myimage.jpg', 'rb')    image_generator = Thumbnail(source=source_file)    result = image_generator.generate().. note::    You don't have to use ``open``! You can use whatever File-like object you    want—including a model's ``ImageField``.The result of calling ``generate()`` on an image spec is a file-like objectcontaining our resized image, with which you can do whatever you want. Forexample, if you wanted to save it to disk:.. code-block:: python    dest = open('/path/to/dest.jpg', 'wb')    dest.write(result.read())    dest.close()Using Specs In Templates^^^^^^^^^^^^^^^^^^^^^^^^If you have a model with an ImageSpecField or ProcessedImageField, you caneasily use those processed image just as you would a normal image field:.. code-block:: html    &lt;img src=&quot;{{ profile.avatar_thumbnail.url }}&quot; /&gt;(This is assuming you have a view that's setting a context variable named&quot;profile&quot; to an instance of our Profile model.)But you can also generate processed image files directly in your template—fromany image—without adding anything to your model. In order to do this, you'llfirst have to define an image generator class (remember, specs are a type ofgenerator) in your app somewhere, just as we did in the last section. You'llalso need a way of referring to the generator in your template, so you'll needto register it... code-block:: python    from imagekit import ImageSpec, register    from imagekit.processors import ResizeToFill    class Thumbnail(ImageSpec):        processors = [ResizeToFill(100, 50)]        format = 'JPEG'        options = {'quality': 60}    register.generator('myapp:thumbnail', Thumbnail).. note::    You can register your generator with any id you want, but choose wisely!    If you pick something too generic, you could have a conflict with another    third-party app you're using. For this reason, it's a good idea to prefix    your generator ids with the name of your app. Also, ImageKit recognizes    colons as separators when doing pattern matching (e.g. in the generateimages    management command), so it's a good idea to use those too!.. warning::    This code can go in any file you want—but you need to make sure it's loaded!    In order to keep things simple, ImageKit will automatically try to load an    module named &quot;imagegenerators&quot; in each of your installed apps. So why don't    you just save yourself the headache and put your image specs in there?Now that we've created an image generator class and registered it with ImageKit,we can use it in our templates!generateimage&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;The most generic template tag that ImageKit gives you is called &quot;generateimage&quot;.It requires at least one argument: the id of a registered image generator.Additional keyword-style arguments are passed to the registered generator class.As we saw above, image spec constructors expect a source keyword argument, sothat's what we need to pass to use our thumbnail spec:.. code-block:: html    {% load imagekit %}    {% generateimage 'myapp:thumbnail' source=source_file %}This will output the following HTML:.. code-block:: html    &lt;img src=&quot;/media/CACHE/images/982d5af84cddddfd0fbf70892b4431e4.jpg&quot; width=&quot;100&quot; height=&quot;50&quot; /&gt;You can also add additional HTML attributes; just separate them from yourkeyword args using two dashes:.. code-block:: html    {% load imagekit %}    {% generateimage 'myapp:thumbnail' source=source_file -- alt=&quot;A picture of Me&quot; id=&quot;mypicture&quot; %}Not generating HTML image tags? No problem. The tag also functions as anassignment tag, providing access to the underlying file object:.. code-block:: html    {% load imagekit %}    {% generateimage 'myapp:thumbnail' source=source_file as th %}    &lt;a href=&quot;{{ th.url }}&quot;&gt;Click to download a cool {{ th.width }} x {{ th.height }} image!&lt;/a&gt;thumbnail&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;Because it's such a common use case, ImageKit also provides a &quot;thumbnail&quot;template tag:.. code-block:: html    {% load imagekit %}    {% thumbnail '100x50' source_file %}Like the generateimage tag, the thumbnail tag outputs an &lt;img&gt; tag:.. code-block:: html    &lt;img src=&quot;/media/CACHE/images/982d5af84cddddfd0fbf70892b4431e4.jpg&quot; width=&quot;100&quot; height=&quot;50&quot; /&gt;Comparing this syntax to the generateimage tag above, you'll notice a fewdifferences.First, we didn't have to specify an image generator id; unless we tell itotherwise, thumbnail tag uses the generator registered with the id&quot;imagekit:thumbnail&quot;. **It's important to note that this tag is *not* using theThumbnail spec class we defined earlier**; it's using the generator registeredwith the id &quot;imagekit:thumbnail&quot; which, by default, is``imagekit.generatorlibrary.Thumbnail``.Second, we're passing two positional arguments (the dimensions and the sourceimage) as opposed to the keyword arguments we used with the generateimage tag.Like with the generateimage tag, you can also specify additional HTML attributesfor the thumbnail tag, or use it as an assignment tag:.. code-block:: html    {% load imagekit %}    {% thumbnail '100x50' source_file -- alt=&quot;A picture of Me&quot; id=&quot;mypicture&quot; %}    {% thumbnail '100x50' source_file as th %}Using Specs in Forms^^^^^^^^^^^^^^^^^^^^In addition to the model field above, there's also a form field version of the``ProcessedImageField`` class. The functionality is basically the same (itprocesses an image once and saves the result), but it's used in a form class:.. code-block:: python    from django import forms    from imagekit.forms import ProcessedImageField    from imagekit.processors import ResizeToFill    class ProfileForm(forms.Form):        avatar_thumbnail = ProcessedImageField(spec_id='myapp:profile:avatar_thumbnail',                                               processors=[ResizeToFill(100, 50)],                                               format='JPEG',                                               options={'quality': 60})The benefit of using ``imagekit.forms.ProcessedImageField`` (as opposed to``imagekit.models.ProcessedImageField`` above) is that it keeps the logic forcreating the image outside of your model (in which you would use a normal DjangoImageField). You can even create multiple forms, each with their ownProcessedImageField, that all store their results in the same image field.Processors----------So far, we've only seen one processor: ``imagekit.processors.ResizeToFill``. ButImageKit is capable of far more than just resizing images, and that power comesfrom its processors.Processors take a PIL image object, do something to it, and return a new one.A spec can make use of as many processors as you'd like, which will all be runin order... code-block:: python    from imagekit import ImageSpec    from imagekit.processors import TrimBorderColor, Adjust    class MySpec(ImageSpec):        processors = [            TrimBorderColor(),            Adjust(contrast=1.2, sharpness=1.1),        ]        format = 'JPEG'        options = {'quality': 60}The ``imagekit.processors`` module contains processors for many commonimage manipulations, like resizing, rotating, and color adjustments. However,if they aren't up to the task, you can create your own. All you have to do isdefine a class that implements a ``process()`` method:.. code-block:: python    class Watermark(object):        def process(self, image):            # Code for adding the watermark goes here.            return imageThat's all there is to it! To use your fancy new custom processor, just includeit in your spec's ``processors`` list:.. code-block:: python    from imagekit import ImageSpec    from imagekit.processors import TrimBorderColor, Adjust    from myapp.processors import Watermark    class MySpec(ImageSpec):        processors = [            TrimBorderColor(),            Adjust(contrast=1.2, sharpness=1.1),            Watermark(),        ]        format = 'JPEG'        options = {'quality': 60}Note that when you import a processor from ``imagekit.processors``, imagekitin turn imports the processor from `PILKit`_. So if you are looking foravailable processors, look at PILKit... _`PILKit`: https://github.com/matthewwithanm/pilkitAdmin-----ImageKit also contains a class named ``imagekit.admin.AdminThumbnail``for displaying specs (or even regular ImageFields) in the`Django admin change list`_. AdminThumbnail is used as a property onDjango admin classes:.. code-block:: python    from django.contrib import admin    from imagekit.admin import AdminThumbnail    from .models import Photo    class PhotoAdmin(admin.ModelAdmin):        list_display = ('__str__', 'admin_thumbnail')        admin_thumbnail = AdminThumbnail(image_field='thumbnail')    admin.site.register(Photo, PhotoAdmin)To use specs defined outside of models:.. code-block:: python        from django.contrib import admin    from imagekit.admin import AdminThumbnail    from imagekit import ImageSpec    from imagekit.processors import ResizeToFill    from imagekit.cachefiles import ImageCacheFile    from .models import Photo    class AdminThumbnailSpec(ImageSpec):        processors = [ResizeToFill(100, 30)]        format = 'JPEG'        options = {'quality': 60 }    def cached_admin_thumb(instance):        # `image` is the name of the image field on the model        cached = ImageCacheFile(AdminThumbnailSpec(instance.image))        # only generates the first time, subsequent calls use cache        cached.generate()        return cached    class PhotoAdmin(admin.ModelAdmin):        list_display = ('__str__', 'admin_thumbnail')        admin_thumbnail = AdminThumbnail(image_field=cached_admin_thumb)    admin.site.register(Photo, PhotoAdmin) AdminThumbnail can even use a custom template. For more information, see``imagekit.admin.AdminThumbnail``... _`Django admin change list`: https://docs.djangoproject.com/en/dev/intro/tutorial02/#customize-the-admin-change-listManagement Commands-------------------ImageKit has one management command—``generateimages``—which will generate cachefiles for all of your registered image generators. You can also pass it a listof generator ids in order to generate images selectively.Community=========Please use `the GitHub issue tracker &lt;https://github.com/matthewwithanm/django-imagekit/issues&gt;`_to report bugs with django-imagekit. `A mailing list &lt;https://groups.google.com/forum/#!forum/django-imagekit&gt;`_also exists to discuss the project and ask questions, as well as the official`#imagekit &lt;irc://irc.freenode.net/imagekit&gt;`_ channel on Freenode.Contributing============We love contributions! And you don't have to be an expert with the library—oreven Django—to contribute either: ImageKit's processors are standalone classesthat are completely separate from the more intimidating internals of Django'sORM. If you've written a processor that you think might be useful to otherpeople, open a pull request so we can take a look!You can also check out our list of `open, contributor-friendly issues`__ forideas.Check out our `contributing guidelines`_ for more information about pitching inwith ImageKit.__ https://github.com/matthewwithanm/django-imagekit/issues?labels=contributor-friendly&amp;state=open.. _`contributing guidelines`: https://github.com/matthewwithanm/django-imagekit/blob/develop/CONTRIBUTING.rst</longdescription>
</pkgmetadata>