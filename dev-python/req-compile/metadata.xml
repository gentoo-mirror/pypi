<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>New in version 0.10.21:* Allow for setuptools backend projects specified only by pyproject.toml and setup.cfgREADME for Req-Compile Python Requirements Compiler===================================================.. image:: https://img.shields.io/pypi/v/req-compile.svg    :alt: PyPI package version    :target: https://pypi.python.org/pypi/req-compile.. image:: https://github.com/sputt/req-compile/actions/workflows/build.yml/badge.svg    :alt: Github build status    :target: https://github.com/sputt/req-compile========================================Req-Compile Python Requirements Compiler========================================Req-Compile is a Python requirements compiler geared toward large Python projects. It allows you to:* Produce an output file consisting of fully constrained exact versions of your requirements* Identify sources of constraints on your requirements* Constrain your output requirements using requirements that will not be included in the output* Save distributions that are downloaded while compiling in a configurable location* Use a current solution as a source of requirements. In other words, you can easily compile a subset from an existing solution.Why use it?-----------**pip** and **pip-tools** are missing features and lack usability for some important workflows:* Using a previous solution as an input file to avoid hitting the network* pip-compile can't consider constraints that are not included in the final output. While pip accepts a constraints file, there is no way to stop at the &quot;solving&quot; phase, which would be used to push a fully solved solution to your repo* Track down where conflicting constraints originate* Treating source directories recursively as sources of requirements, like with --find-links* Configuring a storage location for downloaded distributions. Finding a fresh solution to a set of input requirements always requires downloading distributionsA common workflow that is difficult to achieve with other tools:You have a project with requirements ``requirements.txt`` and test requirements ``test-requirements.txt``. You wantto produce a fully constrained output of ``requirements.txt`` to use to deploy your application. Easy, right? Justcompile ``requirements.txt``. However, if your test requirements will in any way constrain packages you need,even those needed transitively, it means you will have tested with different versions than you'll ship.For this reason, you can use Req-Compile to compile ``requirements.txt`` using ``test-requirements.txt`` as constraints.The Basics----------Install and run~~~~~~~~~~~~~~~Req-Compile can be simply installed by running::    pip install req-compileTwo entrypoint scripts are provided::    req-compile &lt;input reqfile1&gt; ... &lt;input_reqfileN&gt; [--constraints constraint_file] [repositories, such as --index-url https://...]    req-candidates [requirement] [repositories, such as --index-url https://...]Producing output requirements~~~~~~~~~~~~~~~~~~~~~~~~~~~~~To produce a fully constrained set of requirements for a given number of input requirements files, pass requirementsfiles to req-compile::    &gt; cat requirements.txt    astroid &gt;= 2.0.0    isort &gt;= 4.2.5    mccabe    &gt; req-compile req-compile requirements.txt    astroid==2.9.0            # requirements.txt (&gt;=2.0.0)    isort==5.10.1             # requirements.txt (&gt;=4.2.5)    lazy-object-proxy==1.7.1  # astroid (&gt;=1.4.0)    mccabe==0.6.1             # requirements.txt    setuptools==60.0.1        # astroid (&gt;=20.0)    typed-ast==1.5.1          # astroid (&lt;2.0,&gt;=1.4.0)    typing_extensions==4.0.1  # astroid (&gt;=3.10)    wrapt==1.13.3             # astroid (&lt;1.14,&gt;=1.11)Output is always emitted to stdout. Possible inputs include::    &gt; req-compile    &gt; req-compile .    # Compiles the current directory (looks for a setup.py or pyproject.toml)    &gt; req-compile subdir/project    # Compiles the project in the subdir/project directory    &gt; req-candidates --paths-only | req-compile    # Search for candidates and compile them piped in via stdin    &gt; echo flask | req-compile    # Compile the requirement 'flask' using the default remote index (PyPI)    &gt; req-compile . --extra test    # Compiles the current directory with the extra &quot;test&quot;Specifying source of distributions~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Req-Compile supports obtaining python distributions from multiple sources, each of which can be specified more than once. The following sourcescan be specified, resolved in the same order (e.g. source takes precedence over index-url):* ``--solution``  Load a previous solution and use it as a source of distributions. This will allow a full  recompilation of a working solution without requiring any other source. If the  solution file can't be found, a warning will be emitted but not cause a failure* ``--source``  Use a local filesystem with source python packages to compile from. This will search the entire  tree specified at the source directory, until an __init__.py is reached. ``--remove-source`` can  be supplied to remove results that were obtained from source directories. You may want to do  this if compiling for a project and only third party requirements compilation results need to be saved.* ``--find-links``  Read a directory to load distributions from. The directory can contain anything  a remote index would, wheels, zips, and source tarballs. This matches pip's command line.* ``--index-url``  URL of a remote index to search for packages in. When compiling, it's necessary to download  a package to determine its requirements. ``--wheel-dir`` can be supplied to specify where to save  these distributions. Otherwise they will be deleted after compilation is complete.All options can be repeated multiple times, with the resolution order within types matching whatwas passed on the commandline. However, overall resolution order will always match the orderof the list above.By default, PyPI (https://pypi.org/) is added as a default source. It can be removed by passing``--no-index`` on the commandline.Identifying source of constraints~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Why did I just get version 1.11.0 of ``six``? Find out by examining the output::    six==1.11.0  # astroid, pathlib2, pymodbus (==1.11.0), pytest (&gt;=1.10.0), more_itertools (&lt;2.0.0,&gt;=1.0.0)In the above output, the (==1.11.0) indicates that pymodbus, the requirement name listed before theparenthesis, specifically requested version 1.11.0 of six.Constraining output~~~~~~~~~~~~~~~~~~~Constrain production outputs with test requirements using the ``--constraints`` flag. More than one file can bepassed::    &gt; cat requirements.txt    astroid    &gt; cat test-requirements.txt    pylint&lt;1.6    &gt; req-compile requirements.txt --constraints test-requirements.txt    astroid==1.4.9            # pylint (&lt;1.5.0,&gt;=1.4.5), requirements.txt    lazy-object-proxy==1.7.1  # astroid    six==1.16.0               # astroid, pylint    wrapt==1.13.3             # astroidNote that astroid is constrained by ``pylint``, even though ``pylint`` is not included in the output.If a passed constraints file is fully pinned, Req-Compile will not attempt to find a solution forthe requirements passed in the constraints files. This behavior only occurs if ALL of the requirementslisted in the constraints files are pinned. This is because pinning a single requirement maystill bring in transitive requirements that would affect the final solution. The heuristic ofchecking that all requirements are pinned assumes that you are providing a full solution.Advanced Features-----------------Compiling a constrained subset~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Input can be supplied via stdin as well as via as through files. For example, to supply a fullsolution through a second compilation in order to obtain a subset of requirements, thefollowing cmdline might be used::    &gt; req-compile requirements.txt --constraints compiled-requirements.txtor, for example to consider two projects together::    &gt; req-compile /some/other/project /myproject | req-compile /myproject --solution -which is equivalent to::    &gt; req-compile /myproject --constraints /some/other/projectResolving constraint conflicts~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Conflicts will automatically print the source of each conflicting requirement::    &gt; cat projectreqs.txt    astroid&lt;1.6    pylint&gt;=1.5    &gt; req-compile projectreqs.txt    No version of astroid could possibly satisfy the following requirements (astroid&lt;1.6,&lt;3,&gt;=2.3.0):      projectreqs.txt -&gt; astroid&lt;1.6      projectreqs.txt -&gt; pylint 2.4.1 -&gt; astroid&lt;3,&gt;=2.3.0Saving distributions~~~~~~~~~~~~~~~~~~~~Files downloading during the compile process can be saved for later install. This can optimizethe execution times of builds when a separate compile step is required::    &gt; req-compile projectreqs.txt --wheel-dir .wheeldir &gt; compiledreqs.txt    &gt; pip install -r compiledreqs.txt --find-links .wheeldir --no-indexCookbook--------Some useful patterns for projects are outlined below.Compile, then install~~~~~~~~~~~~~~~~~~~~~After requirements are compiled, the usual next step is to install theminto a virtualenv.A script for test might run::    &gt; req-compile --extra test --solution compiled-requirements.txt --wheel-dir .wheeldir &gt; compiled-requirements.txt    &gt; pip-sync compiled-requirement.txt --find-links .wheeldir --no-index    or    &gt; pip install -r compiled-requirements.txt --find-links .wheeldir --no-indexThis would produce an environment containing all of the requirements and test requirements for the projectin the current directory (as defined by a setup.py). This is a *stable* set, in that only changes tothe requirements and constraints would produce a new output. To produce a totally fresh compilation,don't pass in a previous solution.The find-links parameter to the sync or pip install will *reuse* the wheels already downloaded by Req-Compile duringthe compilation phase. This will make the installation step entirely offline.When taking this environment to deploy, trim down the set to the install requirements::    &gt; req-compile --solution compiled-requirements.txt --no-index &gt; install-requirements.txtinstall-requirements.txt will contain the pinned requirements that should be installed in yourtarget environment. The reason for this extra step is that you don't want to distributeyour test requirements, and you also want your installed requirements to be the sameversions that you've tested with. In order to get all of your explicitly declaredrequirements and all of the transitive dependencies, you can use the prior solution toextract a subset. Passing the ``--no-index`` makes it clear that this command will nothit the remote index at all (though this would naturally be the case as solution filestake precedence over remote indexes in repository search order).Compile for a group of projects~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Req-Compile can discover requirements that are grouped together on the filesystem. The``req-candidates`` command will print discovered projects and with the ``--paths-only`` optionswill dump their paths to stdout. This allows recursive discovery of projects that youmay want to compile together.For example, consider a filesystem with this layout::    solution      \_ utilities      |   \_ network_helper      |_ integrations      |   \_ github      \_ frameworks          |_ neural_net          \_ clusterIn each of the leaf nodes, there is a setup.py and full python project. To compile thesetogether and ensure that their requirements will all install into the same environment::    &gt; cd solution    &gt; req-candidates --paths-only    /home/user/projects/solution/utilities/network_helper    /home/user/projects/solution/integrations/github    /home/user/projects/solution/frameworks/neural_net    /home/user/projects/solution/frameworks/cluster    &gt; req-candidates --paths-only | req-compile --extra test --solution compiled-requirements.txt --wheel-dir .wheeldir &gt; compiled-requirements.txt    .. all reqs and all test reqs compiled together...</longdescription>
</pkgmetadata>