<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># auth-libБиблиотека функций авторизации для микросервисов Твой ФФ!## Примеры использования```pythonfrom auth_lib.fastapi import UnionAuthfrom fastapi import APIRouter, Dependsrouter = APIRouter(prefix=&quot;/...&quot;)## Чтобы дернуть ручку нужен один скоуп, авторизация обязательна## Юзкейс https://github.com/profcomff/timetable-api/blob/a374c74cd960941100f6c923ff9c3ff706a1ed09/calendar_backend/routes/room/room.py#L45@router.smth(&quot;/&quot;)async def foo(_=Depends(UnionAuth(scopes=[&quot;service.resource.method&quot;], allow_none=False, auto_error=True))):  pass  ## Чтобы дернуть ручку нужно два скоупа, авторизация обязательна## Юзкейс https://github.com/profcomff/print-api/blob/775f36fdd185eec8d9096d3472b7730cf5ac9798/print_service/routes/user.py#L78@router.smth(&quot;/&quot;)async def bar(_=Depends(UnionAuth(scopes=[&quot;scope1&quot;, &quot;scope2&quot;], allow_none=False, auto_error=True))):  pass  ## Чтобы дернуть ручку не нужны скоупы, авторизация необязательна, но если передана недействительная сессия, то кинет ошибку@router.smth(&quot;/&quot;)async def baz(_=Depends(UnionAuth(scopes=[], allow_none=True, auto_error=True))):  pass## Чтобы дернуть ручку не нужны скоупы, авторизация обязательна@router.smth(&quot;/&quot;)async def foo(_=Depends(UnionAuth(scopes=[], allow_none=False, auto_error=True))):  pass```Depends вызывает инстанс класса с нужными параметрами и возвращает словарь со всеми полями отсюда https://api.test.profcomff.com/#/Logout/me_me_getОписание класса UnionAuthПоля```scopes: list[str] - список имен скоупов, которые нужны в данной ручке. Например [&quot;printer.user.create&quot;, &quot;printer.user.delete&quot;]allow_none: bool - Если true, то при отсутствии нужного заголовка в запросе ручка будет доступна юзеру, если заголовк передан, то обработка идет в зависимости от следующего параметраauto_error: bool - если true, то при несовпадении скоупов/завершенной сессии и тд(на запрос GET /me не 200) - кинет 401, если false, то не будет кидать ошибки, но будет возвращать None```Чтобы задать хост авторизации надо в переменные окружения или в .env файл прописать AUTH_URL=&quot;...&quot;Defaults ```pythonauth_url=&quot;https://api.test.profcomff.com/auth/&quot;AUTH_AUTO_ERROR: bool = TrueAUTH_ALLOW_NONE: bool = False```Пример мока библиотеки:Установите нужные завивсимости```shellpip install 'auth-lib-profcomff[testing]'``````pythonimport pytestfrom fastapi.testclient import TestClientfrom fastapi import FastAPI@pytest.fixturedef client(auth_mock):    yield TestClient(FastAPI())@pytest.mark.authenticated(&quot;scope1&quot;, &quot;scope2&quot;, ...)def test1(client):    &quot;&quot;&quot;    В этом тесте будут выданы скоупы scope1, scope2,    библиотека не будет проверять токен через АПИ, будет просто возвращать    нужный словарь, как будто пользователь авторизован с нужными скоупами    &quot;&quot;&quot;    assert 2*2 == 4    @pytest.mark.authenticated()def test2(client):    &quot;&quot;&quot;    В этом тесте скоупов выдано не будет,    но библиотека не будет проверять токен через АПИ, будет просто возвращать    нужный словарь, как будто пользователь авторизован с нужными скоупами    &quot;&quot;&quot;    assert 2*2 == 4def test3(client):    &quot;&quot;&quot;    В этом тесте скоупов выдано не будет, библиотека будет проверять     токен через АПИ    &quot;&quot;&quot;    assert 2*2 == 4```</longdescription>
</pkgmetadata>