<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Official Python repository for TrueData (Market Data APIs)----This Python library attempts to make it easy for you to connect to TrueData Market Data Apis, thereby allowing you to concentrate on startegy development, while this library works to get you all the data you need from the TrueData backend both for Real Time &amp; Historical.Please make sure you follow us on our Telegram channel where we push a lot of information with regards to API updates, implementation ideas, tips &amp; tricks to use this library &amp; raw feed, etc...* [TrueData Market Data API - Telegram Channel](https://t.me/truedata_ws_api)* [TrueData Market Data APIs - Website](https://www.truedata.in/api)We have also built a sandbox environmemt for testing the raw feed. Please feel free to use this environment to check/test/compare your results with the raw data feed (real time &amp; historical).* [TrueData Market Data API - Sandbox Environment](https://wstest.truedata.in)We are trying to improve this library continuously and feedback for the same is welcome. ----## What have we covered so far ?**WebSocket APIs**  * Live data (Streaming Ticks) - Enabled by Default  * Live Data (Streaming 1 min bars) - Needs to be enabled from our backend  * Live Data (Streaming 5 min bars) - Needs to be enabled from our backend   * Live data (Streaming Ticks + 1 min bars) - Needs to be enabled from our backend  * Live Data (Streaming Ticks + 5 min bars) - Needs to be enabled from our backend  * Live Data (Streaming Ticks + 1 min bars + 5 min bars) - Needs to be enabled from our backend  * Live Data (Streaming 1 min + 5 min bars) - Needs to be enabled from our backend **REST APIs**  *  Historical Data  ----# Getting Started **Installation*** Installing the truedata-ws library from PyPi```shell scriptpython3 -m pip install truedata_ws```or```shell scriptpip3 install truedata_ws```**Minimum Requirements**The minimum required versions are:-```- Python &gt;= 3.7```**In-built dependencies**All these dependencies should get installed automatically when you install the truedata_ws library. In case of an issue, make sure you meet the requirements as mentioned below.```- websocket-client&gt;=0.57.0- colorama&gt;=0.4.3- python-dateutil&gt;=2.8.1- pandas&gt;=1.0.3- setuptools&gt;=50.3.2- requests&gt;=2.25.0- lz4==3.1.3 (Note lz4 versions &gt;3.1.3 currently have some errors and thus  lz4 should not be upgraded till these dependency issues are resolved).```**Connecting / Logging in*** Connecting / Logging in (Both Real time &amp; Historical data feed subscriptions)```pythonfrom truedata_ws.websocket.TD import TDtd_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;')# This connects you to the default real time port which is 8082 &amp; the REST History feed. # If you have been authorized on another live port please enter another parameter# Example# td_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;', live_port=8084)```* Connecting / Logging in (For Historical Data Subscription Only)```pythonfrom truedata_ws.websocket.TD import TDtd_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;', live_port=None)```* Connecting / Logging in (For Real time Data Subscription Only)```pythonfrom truedata_ws.websocket.TD import TDtd_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;', historical_api=False)```----# Automatic Reconnection of Real Time Streaming FeedIn case of a Websocket disconnection, the library will check for the internet connection and once the connection is steady, it will try to re-connect the Websocket, automatically.Once the websocket connection is re-established, the library will automatically re-subscribe the symbols &amp; restart the live data seamlessly.----# LoggingWe have integrated the python stdlib logger.You can provide LOG_LEVEL and LOG_FORMAT if you want.Please try with various log levels &amp; formats to understand what works best for you for a particular setting. Below are 2 samples provided to you. Please test with both to see what works best for you. ```pythonfrom truedata_ws.websocket.TD import TDimport loggingtd_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;', live_port=realtime_port,  url=url,             log_level=logging.WARNING, log_format=&quot;%(message)s&quot;)# td_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;', log_level=logging.WARNING, log_format=&quot;(%(asctime)s) %(levelname)s :: %(message)s (PID:%(process)d Thread:%(thread)d)&quot;)```Also, If you have subscribed only for a 1 min streaming feed, the bar data would stream every 1 min for all the symbols.  It is therefore recommended enabling logging the Heartbeat responses received from the server. These Heartbeats come every 5 seconds and help establish a steady connection with the server.   To enable the *Heartbeats*, change your logging level to DEBUG as follows:-```pythonfrom truedata_ws.websocket.TD import TDimport loggingtd_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;', live_port=realtime_port, url=url,             log_level=logging.DEBUG, log_format=&quot;%(message)s&quot;)```The logging level to DEBUG, enables you to see:-1) Market Status messages (Market Open / Close messages as and when they happen) 2) Automatic Touchline update messages3) Symbol Add Remove messages4) Heartbeat messages (every 5 seconds)If you do not want to see these messages, set your logging level to WARNINGAdditional LOG_LEVEL info can be found at https://docs.python.org/3/library/logging.html#logging-levels. Additional LOG_FORMAT info can be found at https://docs.python.org/3/library/logging.html#logrecord-attributes.If you really know what you are doing, you can simply provide a log handler. ```pythontd_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;', log_handler=log_handler_obj)```----# Real Time Data Streaming (Live)* Starting Live Data For Multiple symbols```pythonreq_ids = td_obj.start_live_data(['&lt;symbol_1&gt;', '&lt;symbol_2&gt;', '&lt;symbol_3&gt;', ...])# Example:# req_ids = td_obj.start_live_data(['CRUDEOIL-I', 'BANKNIFTY-I', 'RELIANCE', 'ITC'])# This returns a list that can be used to reference data later```* Accessing Touchline Data The touchline data is useful post market hours as this provides the last updates / settlement updates / snap quotes. Please note that it is not recommended to use this during market hours as all the fields of the touchline data already form a part of the real time market data feed.```pythonimport timetime.sleep(1)# You need to wait until for 1 sec for all of the touchline data to populatefor req_id in req_ids:    print(td_obj.touchline_data[req_id])```* Accessing live streaming data  All updated relevant live data can be found in the object at `td_obj.live_data[req_id]`.For more details try: `print(f&quot;{type(td_obj.live_data[req_id])} -&gt; {td_obj.live_data[req_id]})````pythonlast_traded_price       = td_obj.live_data[req_id].ltpchange_perc             = td_obj.live_data[req_id].change_percday_high                = td_obj.live_data[req_id].day_highhighest_available_bid   = td_obj.live_data[req_id].best_bid_price```&gt; **VERY IMPORTANT**&gt;&gt;(Streaming Tick &amp; Bar data `[1 min , 5 min]` Simultaneously)&gt; &gt;The same code works without any changes, if you are subscribed to&gt; &gt;`Tick only` or `Bar only` streaming. &gt; &gt;&gt;`td_obj.live_data[req_id]`&gt; However, if you are subscribed to both `tick &amp; bar` streaming, then:- &gt;&gt;&gt;`Tick` streaming data could be found at  `td_obj.live_data[req_id]`.&gt; &gt;&gt;`1 Min` streaming bar data can be found at `td_obj.one_min_live_data[req_id]`.&gt; &gt;&gt;`5 Min` streaming bar data can be found at `td_obj.five_min_live_data[req_id]`.  * Stopping live data```pythontd_obj.stop_live_data(['&lt;symbol_1&gt;', '&lt;symbol_2&gt;', '&lt;symbol_3&gt;', ...])```* Disconnect from the WebSocket service```pythontd_obj.disconnect()```----**QUICK START LIVE DATA CODE (STREAM USING CALLBACKS (Recommended))**The code snippet below shows you how easy it is to stream the data using Callbacks.```Pythonfrom truedata_ws.websocket.TD import TDimport timeimport loggingusername = 'your_username'password = 'your_password'realtime_port = 8082url = 'push.truedata.in'# Disable the Production url above and Enable the Replay url below, when you need to work with the replay feed# Make sure to re-enable the Production url prior to live market start# url = 'replay.truedata.in'symbols = ['&lt;symbol_1&gt;', '&lt;symbol_2&gt;', '&lt;symbol_3&gt;', ...]td_obj = TD(username, password, live_port=realtime_port, url=url, log_level=logging.DEBUG, log_format=&quot;%(message)s&quot;)print('\nStarting Real Time Feed.... ')req_ids = td_obj.start_live_data(symbols)live_data_objs = {}time.sleep(1)  # very important - to ensure that the touchine data is populatedfor req_id in req_ids:    print(f'touchlinedata -&gt; {td_obj.touchline_data[req_id]}')@td_obj.trade_callbackdef strategy_callback(symbol_id, tick_data):    print(f'Trade  update &gt; {tick_data}')@td_obj.bidask_callbackdef new_bidask(symbol_id, tick_data):    print(f&quot;BidAsk update &gt; {tick_data}&quot;)@td_obj.one_min_bar_callbackdef new_one_min(symbol_id, bar_data):    print(f&quot;one min &gt; {bar_data}&quot;)@td_obj.five_min_bar_callbackdef new_five_min(symbol_id, bar_data):    print(f&quot;five min &gt; {bar_data}&quot;)# Keep your thread alivewhile True:    time.sleep(120)```**QUICK START LIVE DATA CODE (Using While Loop)**You can also, use a While Loop to stream the data which is recommended for beginners to intermediate developers.In this example we will simply print data in the format given below:-* Symbol &gt; LTP &gt; Change```Pythonfrom truedata_ws.websocket.TD import TDfrom copy import deepcopyimport timeimport loggingusername = 'your_username'password = 'your_password'realtime_port = 8082# url = 'push.truedata.in'# Disable the Production url above and Enable the Replay url below, when you need to work with the replay feed# Make sure to re-enable the Production url prior to live market starturl = 'replay.truedata.in'symbols = ['&lt;symbol_1&gt;', '&lt;symbol_2&gt;', '&lt;symbol_3&gt;', ...]td_obj = TD(username, password, live_port=realtime_port, url=url, log_level=logging.WARNING, log_format=&quot;%(message)s&quot;)req_ids = td_obj.start_live_data(symbols)subs = td_obj.live_websocket.subslive_data_objs = {}one_min_live_data_objs = {}five_min_live_data_objs = {}time.sleep(3)if 'tick' in subs :    for req_id in req_ids:        live_data_objs[req_id] = deepcopy(td_obj.live_data[req_id])if '1min' in subs:    for req_id in req_ids:        one_min_live_data_objs[req_id] = deepcopy(td_obj.one_min_live_data[req_id])if '5min' in subs:    for req_id in req_ids:        five_min_live_data_objs[req_id] = deepcopy(td_obj.five_min_live_data[req_id])while True:    for req_id in req_ids:        if 'tick' in subs  and not td_obj.live_data[req_id] == live_data_objs[req_id] :            live_data_objs[req_id] = deepcopy(td_obj.live_data[req_id])            print( 'tick -&gt;' , td_obj.live_data[req_id])        if '1min' in subs and not td_obj.one_min_live_data[req_id] == one_min_live_data_objs[req_id]:            one_min_live_data_objs[req_id] = deepcopy(td_obj.one_min_live_data[req_id])            print('one min -&gt;' , td_obj.one_min_live_data[req_id])        if '5min' in subs and not (td_obj.five_min_live_data[req_id] == five_min_live_data_objs[req_id]):            five_min_live_data_objs[req_id] = deepcopy(td_obj.five_min_live_data[req_id])            print('five min -&gt;' , td_obj.five_min_live_data[req_id])    time.sleep(0.05)  # important otherwise cpu will overthrottle.```----**CONVERTING REAL TIME STREAM TO DICT**In some cases, some people may need to convert the real time stream to dict. This could be either to push the real timestream into pandas, a SQL database or work with processing the stream differently at your end.So, if you need to convert the Real Time Stream to dict, use the **to_dict()** function.```pythontd_obj.live_data[req_id].to_dict()```Here is a sample code to push the data into a pandas Dataframe. Please adapt to your code as this is just a sample and there could be better ways to do the same thing more efficiently. ```pythonfrom truedata_ws.websocket.TD import TDimport timeimport pandas as pdfrom copy import deepcopytd_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;')symbols = ['CRUDEOIL-I', 'GOLD-I', 'NIFTY-I']symbol_ids = td_obj.get_req_id_list(2000, len(symbols))  # symbol_ids = list(range(2000, 2000+len(symbols)))live_data_objs = {}td_obj.start_live_data(symbols, req_id=symbol_ids)time.sleep(1)for symbol_id in symbol_ids:live_data_objs[symbol_id] = deepcopy(td_obj.live_data[symbol_id])df = pd.DataFrame()# pd.set_option(&quot;display.max_rows&quot;, None, &quot;display.max_columns&quot;, None)while True:time.sleep(0.05)for req_id in symbol_ids:if td_obj.live_data[req_id] != live_data_objs[req_id]:live_data_objs[req_id] = deepcopy(td_obj.live_data[req_id])            # picking up trade packets &amp; discarding only bid ask packetsif td_obj.live_data[req_id].tick_type == 1:  op_dict = deepcopy(td_obj.live_data[req_id].to_dict())temp_df = pd.DataFrame.from_records([op_dict])# temp_df = pd.DataFrame(op_dict, index=[0])  # BOTH WORKdf = df.append(temp_df, ignore_index=True)print(df)  # just printing out the df with each update```----# Option Chain StreamingIt is possible to stream single or multiple option chains within respective pandas dataframes, using the steps &amp; sample as explained below.The Option Chain Streaming allows the following fields in the dataframe. (In case you don't need any of these columns, with pandas you can pick and choose and create your dataframe columns accordingly)```symbols, strike, type (CE/PE), ltp, ltt (last traded time), ltq (last traded qty), volume (total volume), price change, price change %, oi, oi Change, OI Change %, bid, bid qty, ask, ask qty``` **Starting Option Chain data for a symbol**```pythonfrom datetime import datetime as dtfrom truedata_ws.websocket.TD import TDtd_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;')nifty_chain = td_obj.start_option_chain( 'NIFTY' , dt(2021 , 8 , 26) )#enabling option chain for NIFTY with corresponding expiry. ```* start_option_chain function takes following arguments:  * symbols for egs: NIFTY , BANKNIFTY , SBIN etc......  * expiry : date (date object)   * chain_length : number of strike need to pull with respect to future prices. default value is 10 (int)  * bid_ask : enable live quote . default value is false (boolean)  * market_open_post_hours : extra parameter for updating the chain in extra NSE session like (muhurat session) , default is False**Pulling an Option Chain**```pythondf = nifty_chain.get_option_chain()#returns a dataframe that contain option chain for repective symbol```this get_option_chain function can call anywhere  that will return respective option chain**Stop Option Chain Updates**```pythonnifty_chain.stop_option_chain()#this function call will stop updating the respective option chain. ```**An example for pulling option chain and live data simultaneously*** A common mistake people make, is leaving while loop without putting proper time sleep, which could overclock your CPU. However, if you use a larger number of symbols, this sleep would need to be smaller else your code would insert an unwanted lag into the data stream. ```pythonfrom truedata_ws.websocket.TD import TDfrom copy import deepcopyimport timeimport loggingfrom datetime import datetime as dttd_obj = TD('&lt;your_login&gt;', '&lt;your_password&gt;' , log_level= logging.WARNING )symbols = ['BANKNIFTY-I' , 'NIFTY 50' , 'NIFTY21072915600CE' , 'SBIN' ]#starting live data for symbols req_ids = td_obj.start_live_data(symbols)live_data_objs = {}time.sleep(1)# initilizing option chain with symbol expiry chain length(optional) , bid ask (optional)sbi_chain = td_obj.start_option_chain( 'SBIN', dt(2021 , 8 , 26) )bnf_chain = td_obj.start_option_chain( 'BANKNIFTY', dt(2021 , 8 , 26) , chain_length = 20 )nifty_chain = td_obj.start_option_chain( 'NIFTY', dt(2021 , 8 , 26), chain_length = 10, bid_ask = True)time.sleep(2)for req_id in req_ids:    live_data_objs[req_id] = deepcopy(td_obj.live_data[req_id])print(sbi_chain.get_option_chain())print(nifty_chain.get_option_chain())print(bnf_chain.get_option_chain())count = 1while True:    for req_id in req_ids:        if not td_obj.live_data[req_id] == live_data_objs[req_id]:            #this will priint live tick that requested             print( f'{td_obj.live_data[req_id].symbol} ==&gt; {td_obj.live_data[req_id].ltp}')            live_data_objs[req_id] = deepcopy(td_obj.live_data[req_id])            # fetching option chain every 50 ticks            if count % 50 == 0:                print(sbi_chain.get_option_chain())                print(nifty_chain.get_option_chain())                print(bnf_chain.get_option_chain())            count += 1    time.sleep(0.05)  # important otherwise cpu will overthrottle.```----# Historical Data&gt;Historical Data is provided over REST (from the backend) using Start time, End time or Duration * Using no parameters```pythonhist_data_1 = td_obj.get_historic_data('BANKNIFTY-I')# This returns 1 minute bars from the start of the present day until current time```* Using a given duration (For available duration options, please read the limitations section)```pythonhist_data_2 = td_obj.get_historic_data('BANKNIFTY-I', duration='3 D')```* Using a specified bar_size (For available bar_size options, please read the limitations section)```pythonhist_data_3 = td_obj.get_historic_data('BANKNIFTY-I', bar_size='30 mins')```* Using start time INSTEAD of duration```pythonfrom dateutil.relativedelta import relativedeltahist_data_4 = td_obj.get_historic_data('BANKNIFTY-I', start_time=datetime.now()-relativedelta(days=3))```* Using a specific ending time```pythonfrom datetime import datetimehist_data_5 = td_obj.get_historic_data('BANKNIFTY-I', end_time=datetime(2021, 3, 5, 12, 30))# Any time can be given here```* Using a specific number of bars (Enabled for Tick, 1 min &amp; EOD bars)You can specify the number of bars (or ticks) which you want to see or use in your code.This is currently enabled for Ticks , 1 min bars &amp; EOD Bars.```pythonhist_data_6=td_app.get_n_historical_bars(symbol, no_of_bars=30, bar_size=barsize```* Enabling / Disabling Bid Ask data with Tick Data HistoryIf you have subscribed for Historical Bid Ask (not activated by default), you can control the visibility of this data depending upon your needs by setting the bidask parameter to True, like, `bidask=True`.  ```pythonhist_data_7 = td_obj.get_historic_data(symbol, duration='1 D', bar_size='tick', bidask=True)```&gt; Default `bidask=False`* Storing data for later useUntil v3.x.x, requested data was stored in the `td_obj` at `td_obj.hist_data[req_id]`.As of v4.0.1, you need to **explicitly** provide a ticker_id to store the data for later use. For example,```pythontd_obj.get_historic_data('BANKNIFTY-I', ticker_id=1000)# At any later pointprint(td_obj.hist_data[1000])```**IMPORTANT NOTE:**Now that we have covered the basic parameters, you can mix and match the parameters as you please. If a parameter is not specified, the defaults are as follows```pythonend_time = datetime.now()duration = &quot;1 D&quot;bar_size = &quot;1 min&quot;```* Example of mix and match```pythonhist_data_8 = td_obj.get_historic_data('BANKNIFTY-I', duration='3 D', bar_size='15 mins')```*On a side note: You can convert historical data to **Pandas DataFrames** with a single line*```pythonimport pandas as pddf = pd.DataFrame(hist_data_1)```**Get Bhavcopy**This function enables you to get the NSE &amp; MCX bhavcopies for the day / date. ```pythoneq_bhav     = td_obj.get_bhavcopy('EQ')fo_bhav     = td_obj.get_bhavcopy('FO')mcx_bhav    = td_obj.get_bhavcopy('MCX')```The request checks if the latest completed bhavcopy has arrived for that segment and, if arrived, it returns the data. In case it has not arrived it provides the date and time of the last bhavcopy available which can also be pulled by providing the bhavcopy date.```*No complete bhavcopy found for requested date. Last available for 2021-03-19 16:46:00.*```&gt;In this case, if you need the bhavcopy of the date provided, you can get it by giving the date for which the bhavcopy is required as shown below..```pythonspecific_bhav = td_obj.get_bhavcopy('EQ', date=datetime.datetime(2021, 3, 19))```**Limitations and caveats for historical data**1) If you provide both duration and start time, duration will be used and start time will be ignored.2) If you provide neither duration nor start time, duration = &quot;1 D&quot; will be used3) If you do not provide the bar size bar_size = &quot;1 min&quot; will be used4) The following BAR_SIZES are available:    - tick    - 1 min    - 2 mins    - 3 mins    - 5 mins    - 10 mins    - 15 mins    - 30 mins    - 60 mins    - eod (or EOD)    - week (or WEEK)    - month (or MONTH)   5) The following annotation can be used for DURATION:-    - D = Days    - W = Weeks    - M = Months    - Y = Years**Get Gainers losers information**This function enables you to get the NSE gainers losers information at present state. ```pythongainers = td_obj.get_gainers(segment = &quot;NSEEQ&quot; , topn= 10 , df_style= False)losers = td_obj.get_losers(segment = &quot;NSEEQ&quot; , topn= 10 )```The function call return a dataframe or list that contains gainers losers information accoriding to your style preferred * gainers , losers function takes following arguments:  * segment (string) : NSEEQ, NSEFUT, NSEOPT, MCX  * topn (int) : default 10 , top n number    * df_style : default is True , output style customization ----# Example StrategiesHere we cover 4 sample strategies. The first 2 use tick data and the last 2 use bar data. We also explain how you can use these strategies using both callbacks and with a constant state check mechanism.**Differences between Callback and State Check strategies** * In the context of this library, callbacks are meant to be light-weight. Primarily used for quick POCs and other speedy development.  * The callback execution happens on the websocket thread and will therefore be harder to divide computation across processing cores.Strategy 1   - Tick based   - Callback   - BUY when past 50 ticks SMA goes above 100 ticks SMA.   - SELLS when past 50 ticks SMA goes below 100 ticks SMA.Strategy 2   - Tick based   - State Check   - BUY when past 50 ticks SMA goes above 100 ticks SMA.   - SELLS when past 50 ticks SMA goes below 100 ticks SMA.Strategy 3   - Minute Bar based   - Callback   - BUY when past 50 bars close SMA goes above 100 bars close SMA.   - SELLS when past 50 bars close SMA goes below 100 bars close SMA.Strategy 4   - Minute Bar based   - State Check   - BUY when past 50 bars close SMA goes above 100 bars close SMA.   - SELLS when past 50 bars close SMA goes below 100 bars close SMA.### Strategy 1```pythonfrom truedata_ws.websocket.TD import TDfrom copy import deepcopyimport time , osimport loggingtd_obj = TD( '&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;', log_level= logging.WARNING)symbols = ['CRUDEOIL-I', 'GOLD-I', 'SILVER-I']# generating symbol_id for distinguishing which symbol it is for comparison etc....symbol_ids = td_obj.get_req_id_list(2000, len(symbols))is_market_open = Truedata = {}# fetching historical data for strategy calculation ,for symbol_id, symbol in zip(symbol_ids, symbols):    print(f&quot;Requesting historical data for {symbol}&quot;)    symbol_hist_data = td_obj.get_historic_data(symbol, duration='1 D', bar_size='tick')    data[symbol_id] = list(map(lambda x: x['ltp'], symbol_hist_data))[-100:]# live data initilizing for required symbols , passing symbol_id that generatedsymbol_ids = td_obj.start_live_data(symbols, req_id=symbol_ids)time.sleep(1)# bidask_callback callback function , strategy is logic is inside call back function@td_obj.bidask_callbackdef new_bidask(symbol_id, tick_data):        data[symbol_id] = data[symbol_id][1:] + [td_obj.live_data[symbol_id].ltp]        if sum(data[symbol_id][-50:]) / 50 &gt; sum(data[symbol_id]) / 100:            print(f'{td_obj.live_data[symbol_id].symbol} -                     SEND OMS LONG SIGNAL {sum(data[symbol_id][-50:]) / 50:.2f} &gt;                     {sum(data[symbol_id]) / 100:.2f},' , f'ltp = {td_obj.[symbol_id].ltp:.2f}')        else:            print(f'{td_obj.live_data[symbol_id].symbol} - SEND OMS SHORT SIGNAL                     {sum(data[symbol_id][-50:]) / 50:.2f} &lt; {sum(data[symbol_id]) / 100:.2f}' ,                     f'ltp = {td_obj.live_data[symbol_id].ltp:.2f}')# keeping the while loop to keep the program runningwhile is_market_open:    time.sleep(10)# Graceful exittd_obj.clear_bidask_callback()td_obj.stop_live_data(symbols)td_obj.disconnect()```### Strategy 2```pythonfrom truedata_ws.websocket.TD import TDimport timetd_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;')symbols = ['CRUDEOIL-I', 'GOLD-I', 'SILVER-I']symbol_ids = td_obj.get_req_id_list(2000, len(symbols))is_market_open = Truedata = {}live_data_objs = {}for sym_id, symbol in zip(symbol_ids, symbols):    print(f&quot;Requesting historical data for {symbol}&quot;)    symbol_hist_data = td_obj.get_historic_data(symbol, duration='1 D', bar_size='tick')    data[sym_id] = list(map(lambda x: x['ltp'], symbol_hist_data))[-100:]td_obj.start_live_data(symbols, req_id=symbol_ids)for symbol_id in symbol_ids:    live_data_objs[symbol_id] = deepcopy(td_obj.live_data[symbol_id])time.sleep(1)while is_market_open:  # Remember to keep your main thread alive.    for symbol_id in symbol_ids:        if live_data_objs[symbol_id] != td_obj.live_data[symbol_id]:            live_data_objs[symbol_id] = deepcopy(td_obj.live_data[symbol_id])            if sum(data[symbol_id][-50:]) / 50 &gt; sum(data[symbol_id]) / 100:                print(f'{live_data_objs[symbol_id].symbol} - SEND OMS LONG SIGNAL                         {sum(data[symbol_id][-50:]) / 50:.2f} &gt; {sum(data[symbol_id]) / 100:.2f}',                        f'ltp = {live_data_objs[symbol_id].ltp:.2f}')            else:                print(f'{live_data_objs[symbol_id].symbol} - SEND OMS SHORT SIGNAL                         {sum(data[symbol_id][-50:]) / 50:.2f} &lt; {sum(data[symbol_id]) / 100:.2f}',                        f'ltp = {live_data_objs[symbol_id].ltp:.2f}')    time.sleep(0.01)```### Strategy 3```pythonfrom truedata_ws.websocket.TD import TDfrom copy import deepcopyimport timetd_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;')symbols = ['CRUDEOIL-I', 'GOLD-I', 'SILVER-I']symbol_ids = td_obj.get_req_id_list(2000, len(symbols))is_market_open = Truedata = {}live_data_objs = {}for sym_id, symbol in zip(symbol_ids, symbols):    print(f&quot;Requesting historical data for {symbol}&quot;)    symbol_hist_data = td_obj.get_historic_data(symbol, duration='1 D', bar_size='1 min')    data[sym_id] = list(map(lambda x: x['c'], symbol_hist_data))[-100:]td_obj.start_live_data(symbols, req_id=symbol_ids)time.sleep(1)for sym_id in symbol_ids:    live_data_objs[sym_id] = deepcopy(td_obj.live_data[sym_id])@td_obj.bar_callbackdef strategy_callback(symbol_id, min_data):    data[symbol_id] = data[symbol_id][1:] + [min_data.close]    if sum(data[symbol_id][-50:]) / 50 &gt; sum(data[symbol_id]) / 100:        print(f'{min_data.symbol} - SEND OMS LONG SIGNAL                 {sum(data[symbol_id][-50:]) / 50:.2f} &gt; {sum(data[symbol_id]) / 100:.2f}',                f'ltp = {min_data.ltp:.2f}')    else:        print(f'{min_data.symbol} - SEND OMS SHORT SIGNAL                 {sum(data[symbol_id][-50:]) / 50:.2f} &lt; {sum(data[symbol_id]) / 100:.2f},'                f'ltp = {min_data.ltp:.2f}')while is_market_open:  # Remember to keep your main thread alive.    time.sleep(120)# Graceful exittd_obj.clear_bar_callback()td_obj.stop_live_data(symbols)td_obj.disconnect()```### Strategy 4```pythonfrom truedata_ws.websocket.TD import TDfrom copy import deepcopyimport timetd_obj = TD('&lt;enter_your_login_id&gt;', '&lt;enter_your_password&gt;')symbols = ['CRUDEOIL-I', 'GOLD-I', 'SILVER-I']symbol_ids = td_obj.get_req_id_list(2000, len(symbols))is_market_open = Truedata = {}live_data_objs = {}for symbol_id, symbol in zip(symbol_ids, symbols):    print(f&quot;Requesting historical data for {symbol}&quot;)    symbol_hist_data = td_obj.get_historic_data(symbol, duration='1 D', bar_size='1 min')    data[symbol_id] = list(map(lambda x: x['c'], symbol_hist_data))[-100:]td_obj.start_live_data(symbols, req_id=symbol_ids)time.sleep(1)for symbol_id in symbol_ids:    # If you are subscribed ONLY to min data, just USE live_data NOT min_live_data    live_data_objs[symbol_id] = deepcopy(td_obj.one_min_live_data[symbol_id])while is_market_open:    time.sleep(0.1)  # Adding this reduces CPU overthrottle    for symbol_id in symbol_ids:        # If you are subscribed ONLY to min data, just USE live_data NOT min_live_data        if live_data_objs[symbol_id] != td_obj.one_min_live_data[symbol_id]:            live_data_objs[symbol_id] = deepcopy(td_obj.one_min_live_data[symbol_id])            # Here is where you can do your manipulation on the min data            data[symbol_id] = data[symbol_id][1:] + [live_data_objs[symbol_id].close]            if sum(data[symbol_id][-50:]) / 50 &gt; sum(data[symbol_id]) / 100:                print(f'{live_data_objs[symbol_id].symbol} - SEND OMS LONG SIGNAL                         {sum(data[symbol_id][-50:]) / 50:.2f} &gt; {sum(data[symbol_id]) / 100:.2f}, '                        f'ltp = {live_data_objs[symbol_id].close:.2f}')            else:                print(f'{live_data_objs[symbol_id].symbol} - SEND OMS SHORT SIGNAL                         {sum(data[symbol_id][-50:]) / 50:.2f} &lt; {sum(data[symbol_id]) / 100:.2f}, '                        f'ltp = {live_data_objs[symbol_id].close:.2f}')# Graceful exittd_obj.stop_live_data(symbols)td_obj.disconnect()``` ----# Release NotesVersion 4.3.5* Index segment masters IND updated to IN* Bugs removedVersion 4.3.3* Websocket Feed Reconnection - Handling Improved* Delivery data parameter added to EOD Data* Bugs fixedVersion 4.3.2* `week` &amp; `month` now available in bar sizes* Real Time Streaming of Larger Datasets Optimized* Bugs fixedVersion 4.3.1* `min_live_data` dict in td_obj changed to `one_min_live_data`* `five_min_live_data` dict added to `td_obj` for 5 min bar min* Callback for respective bar data changed to `@td_obj.one_min_bar_callback` and `@td_obj.five_min_bar_callback` * Market status message added to logger `DEBUG` level.* All option chain feature works for respective subscriptionsVersion 4.2.3* Option Chain Streaming Optimized* LTQ, Price Change &amp; Price Change % added to Options Change Streaming* Rate Limiting now handled gracefully by the library* Bugs Removed Version 4.2.2* OI when Null (first few ticks of first time traded options) throws error - Fixed* Readme Updated with sample codes for Logging, callbacks etc...* Bugs RemovedVersion 4.2.1* Decompression added for pulling smaller files and for faster downloads* Decompression added for gethistoric data &amp; getnhistoric data* Requirements updated (lz4==3.1.3  pivoted due to build issue in new version)* Bugs fixedVersion 4.0.8* Gainers Losers function included * Currency option chains added* Bugfix: Automatic Reconnection due to Network Issue - FixedVersion 4.0.7* Option chains now include Previous OI, OI Change &amp; Volume* `market_close` parameter changed to `market_open_post_hours`. Default is False. Set to true when markets live post normal trading hours (eg. Mahurat Trading) * Bugfix - Python 32 bit - Float error handled.* Bugfix - Removed the dict in case stoplivedata is called.Version 4.0.6* Option chains into pandas enabled &gt; td_obj.start_option_chain(Symbol, Expiry_date, chain length, bid_ask)* The option chain is enabled for tick and 1 min bar streaming* The option chain also works post and pre market hours using the touchline data* History - Call Specific Number of historical Bars (Tick, 1 min &amp; EOD)* Code cleanedVersion 4.0.1* Breaking changes made to `td_obj.get_historic_data` -&gt; ONLY if the `ticker_id` parameter is given, data can later be accessed at `td_obj.hist_data[ticker_id]`.* If you are subscribed to tick+min streaming, you can access the min bar data at `td_obj.min_live_data[req_id]` in additional to your tick feed at `td_obj.live_data[req_id]`.* Log Handler added + logging convenience parameters added + logging README section* Examples added to repo.* Examples + descriptions + differences updated in README.Version 3.0.2* Automatic streaming websocket reconnect enabled. * Automatic subscription of symbols &amp; restart of live data after reconnect* Now Avoiding server calls for repeated / duplicate streaming symbols...Version 3.0.1* Historical feed via Websocket - Deprecated* Historical feed via REST - Added * More time frames have been added* `get_bhavcopy` added* Code cleaned up to improve dependancy handling (eg. for websocket-client)Version 0.3.11* Refactored `query_time` to `end_time` in `td_obj.get_historic_data()` function.* Refactored `truedata_id` to `symbol_id` in `td_obj.touchline_data` objects.* Filled missing values in `td_obj.live_data` objects upon initialization.* Added better debugging information for error reporting.* Cleaned up the code base.### Stay Updated with the latest on this API&gt;Please make sure you follow us on our Telegram channel where we push a lot of information with regards to API updates, implementation ideas, tips &amp; tricks to use this library &amp; raw feed, etc...* [TrueData Market Data API - Telegram Channel](https://t.me/truedata_ws_api)* [TrueData Market Data APIs - Website](https://www.truedata.in/api)### Sandbox Environment&gt;We have also built a sandbox environmemt for testing the raw feed. Please feel free to use this environment to check/test/compare your results with the raw data feed (real time &amp; historical).* [TrueData Market Data API - Sandbox Environment](https://wstest.truedata.in)We are trying to improve this library continuously and feedback for the same is welcome.</longdescription>
</pkgmetadata>