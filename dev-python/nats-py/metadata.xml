<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># NATS - Python3 Client for AsyncioAn [asyncio](https://docs.python.org/3/library/asyncio.html) Python client for the [NATS messaging system](https://nats.io).[![docs](https://img.shields.io/static/v1?label=docs&amp;message=docs&amp;color=informational)](https://nats-io.github.io/nats.py/)[![pypi](https://img.shields.io/pypi/v/nats-py.svg)](https://pypi.org/project/nats-py)[![Build Status](https://travis-ci.com/nats-io/nats.py.svg?branch=main)](http://travis-ci.com/nats-io/nats.py)[![Versions](https://img.shields.io/pypi/pyversions/nats-py.svg)](https://pypi.org/project/nats-py)[![License Apache 2.0](https://img.shields.io/badge/License-Apache2-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0)## Supported platformsShould be compatible with at least [Python +3.7](https://docs.python.org/3.7/library/asyncio.html).## Installing```bashpip install nats-py```## Getting started```pythonimport asyncioimport natsfrom nats.errors import ConnectionClosedError, TimeoutError, NoServersErrorasync def main():    # It is very likely that the demo server will see traffic from clients other than yours.    # To avoid this, start your own locally and modify the example to use it.    nc = await nats.connect(&quot;nats://demo.nats.io:4222&quot;)    # You can also use the following for TLS against the demo server.    #    # nc = await nats.connect(&quot;tls://demo.nats.io:4443&quot;)    async def message_handler(msg):        subject = msg.subject        reply = msg.reply        data = msg.data.decode()        print(&quot;Received a message on '{subject} {reply}': {data}&quot;.format(            subject=subject, reply=reply, data=data))    # Simple publisher and async subscriber via coroutine.    sub = await nc.subscribe(&quot;foo&quot;, cb=message_handler)    # Stop receiving after 2 messages.    await sub.unsubscribe(limit=2)    await nc.publish(&quot;foo&quot;, b'Hello')    await nc.publish(&quot;foo&quot;, b'World')    await nc.publish(&quot;foo&quot;, b'!!!!!')    # Synchronous style with iterator also supported.    sub = await nc.subscribe(&quot;bar&quot;)    await nc.publish(&quot;bar&quot;, b'First')    await nc.publish(&quot;bar&quot;, b'Second')    try:        async for msg in sub.messages:            print(f&quot;Received a message on '{msg.subject} {msg.reply}': {msg.data.decode()}&quot;)            await sub.unsubscribe()    except Exception as e:        pass    async def help_request(msg):        print(f&quot;Received a message on '{msg.subject} {msg.reply}': {msg.data.decode()}&quot;)        await nc.publish(msg.reply, b'I can help')    # Use queue named 'workers' for distributing requests    # among subscribers.    sub = await nc.subscribe(&quot;help&quot;, &quot;workers&quot;, help_request)    # Send a request and expect a single response    # and trigger timeout if not faster than 500 ms.    try:        response = await nc.request(&quot;help&quot;, b'help me', timeout=0.5)        print(&quot;Received response: {message}&quot;.format(            message=response.data.decode()))    except TimeoutError:        print(&quot;Request timed out&quot;)    # Remove interest in subscription.    await sub.unsubscribe()    # Terminate connection to NATS.    await nc.drain()if __name__ == '__main__':    asyncio.run(main())```## JetStreamStarting v2.0.0 series, the client now has JetStream support:```pythonimport asyncioimport natsfrom nats.errors import TimeoutErrorasync def main():    nc = await nats.connect(&quot;localhost&quot;)    # Create JetStream context.    js = nc.jetstream()    # Persist messages on 'foo's subject.    await js.add_stream(name=&quot;sample-stream&quot;, subjects=[&quot;foo&quot;])    for i in range(0, 10):        ack = await js.publish(&quot;foo&quot;, f&quot;hello world: {i}&quot;.encode())        print(ack)    # Create pull based consumer on 'foo'.    psub = await js.pull_subscribe(&quot;foo&quot;, &quot;psub&quot;)    # Fetch and ack messagess from consumer.    for i in range(0, 10):        msgs = await psub.fetch(1)        for msg in msgs:            print(msg)    # Create single ephemeral push based subscriber.    sub = await js.subscribe(&quot;foo&quot;)    msg = await sub.next_msg()    await msg.ack()    # Create single push based subscriber that is durable across restarts.    sub = await js.subscribe(&quot;foo&quot;, durable=&quot;myapp&quot;)    msg = await sub.next_msg()    await msg.ack()    # Create deliver group that will be have load balanced messages.    async def qsub_a(msg):        print(&quot;QSUB A:&quot;, msg)        await msg.ack()    async def qsub_b(msg):        print(&quot;QSUB B:&quot;, msg)        await msg.ack()    await js.subscribe(&quot;foo&quot;, &quot;workers&quot;, cb=qsub_a)    await js.subscribe(&quot;foo&quot;, &quot;workers&quot;, cb=qsub_b)    for i in range(0, 10):        ack = await js.publish(&quot;foo&quot;, f&quot;hello world: {i}&quot;.encode())        print(&quot;\t&quot;, ack)    # Create ordered consumer with flow control and heartbeats    # that auto resumes on failures.    osub = await js.subscribe(&quot;foo&quot;, ordered_consumer=True)    data = bytearray()    while True:        try:            msg = await osub.next_msg()            data.extend(msg.data)        except TimeoutError:            break    print(&quot;All data in stream:&quot;, len(data))    await nc.close()if __name__ == '__main__':    asyncio.run(main())```## TLSTLS connections can be configured with an [ssl context](https://docs.python.org/3/library/ssl.html#context-creation)```pythonssl_ctx = ssl.create_default_context(purpose=ssl.Purpose.SERVER_AUTH)ssl_ctx.load_verify_locations('ca.pem')ssl_ctx.load_cert_chain(certfile='client-cert.pem',                        keyfile='client-key.pem')await nats.connect(servers=[&quot;tls://127.0.0.1:4443&quot;], tls=ssl_ctx, tls_hostname=&quot;localhost&quot;)```Setting the scheme to `tls` in the connect URL will make the client create a [default ssl context](https://docs.python.org/3/library/ssl.html#ssl.create_default_context) automatically:```pythonimport asyncioimport sslfrom nats.aio.client import Client as NATSasync def run():    nc = NATS()    await nc.connect(&quot;tls://demo.nats.io:4443&quot;)```*Note*: If getting SSL certificate errors in OS X, try first installing the `certifi` certificate bundle. If using Python 3.7 for example, then run:```ps$ /Applications/Python\ 3.7/Install\ Certificates.command -- pip install --upgrade certifiCollecting certifi... -- removing any existing file or link -- creating symlink to certifi certificate bundle -- setting permissions -- update complete```## NKEYS and JWT User CredentialsSince [v0.9.0](https://github.com/nats-io/nats.py/releases/tag/v0.9.0) release,you can also optionally install [NKEYS](https://github.com/nats-io/nkeys.py) in order to usethe new NATS v2.0 auth features:```shpip install nats-py[nkeys]```Usage:```pythonawait nats.connect(&quot;tls://connect.ngs.global:4222&quot;, user_credentials=&quot;/path/to/secret.creds&quot;)```## Development1. [Install nats server](https://docs.nats.io/running-a-nats-service/introduction/installation).1. Make sure the server is available in your PATH: `nats-server -v`.1. Install dependencies: `python3 -m pipenv install --dev`.1. Run tests: `python3 -m pytest`.## LicenseUnless otherwise noted, the NATS source files are distributed underthe Apache Version 2.0 license found in the LICENSE file.</longdescription>
</pkgmetadata>