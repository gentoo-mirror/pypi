<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Mousse&gt; Collections of my most used functions, classes and patterns. I was craving for a delicious mousse as I was comming up with the name.## Installation---```shpip install -U mousse```## Components---### Dataclass&gt; This is a self-implement, minimal version of [pydantic](https://pydantic-docs.helpmanual.io), with some minor changes.```pyfrom typing import *from mousse import Dataclass, asdict, asclass, Fieldclass Foo(Dataclass):    name: str    number: float    items: List[str] = []class Bar(Dataclass):    foo: Foo    index: int = Field(..., alias=&quot;id&quot;)foo = Foo(    name=&quot;foo&quot;,     number=42.0,     items=[&quot;banana&quot;, &quot;egg&quot;])bar = Bar(id=1, foo=foo)print(bar.foo)# Foo(name=&quot;foo&quot;, number=42.0, items=['banana', 'egg'])#convert back to dictionarybar_dict = asdict(bar)print(bar_dict)# {'foo': {'name': 'foo', 'number': 42.0, 'items': ['banana', 'egg']}, 'id': 1}#conver back to dataclassbar = asclass(Bar, bar_dict)print(bar)# Bar(foo=Foo(name=&quot;foo&quot;, number=42.0, items=['banana', 'egg']), index=1)# load from file (.json, .yaml)bar = asclass(Bar, path=&quot;bar.json&quot;)print(bar)# Bar(foo=Foo(name=&quot;foo&quot;, number=42.0, items=['banana', 'egg']), index=1)```Some helper functions are:- `validate`: Check data type of variable```pyfrom typing import *from mousse import validate, Dataclassclass Foo(Dataclass):    name: str    number: float    items: List[str] = []Number = Union[int, float]validate(int, 1) # Truevalidate(int, 1.0) # Falsevalidate(Number, 1) # Truevalidate(Number, 1.0) # Truevalidate(Dict[str, Any], {    &quot;a&quot;: 1,    &quot;b&quot;: &quot;a&quot;}) # Truevalidate(Dict[str, int], {    &quot;a&quot;: 1,    &quot;b&quot;: &quot;a&quot;}) # Falsevalidate(Tuple[int, float], (1, 1.2)) # Truevalidate(Tuple[int, float], (1.0, 1.2)) # Falsevalidate(Tuple[Number, Number], (1, 1.2)) # Truefoo = Foo(    name=&quot;foo&quot;,     number=42.0,     items=[&quot;banana&quot;, &quot;egg&quot;])validate(Foo, foo) # Truevalidate(List[Foo], [foo]) # Truevalidate(List[Foo], (foo,)) # Falsevalidate(Sequence[Foo], (foo,)) # True```- `parse`: Attempt to parse data```pyfrom typing import *from mousse import parse, Dataclassclass Foo(Dataclass):    name: str    number: float    items: List[str] = []parse(float, 1) # 1.0parse(Union[int, float], 1) # 1parse(Union[float, int], 1) # 1.0parse(Dict[str, Any], {    1: 2,    2: 3}) # {'1': 2, '2': 3}parse(Dict[str, float], {    1: 2,    2: 3}) # {'1': 2.0, '2': 3.0}parse(Foo, {    &quot;name&quot;: &quot;foo&quot;,    &quot;number&quot;: 42.2,    &quot;items&quot;: [1, 2, 3]}) # Foo(name=&quot;foo&quot;, number=42.2, items=['1', '2', '3'])```---### Config&gt; This is how I manage the configuration of my application. By creating a Config object that can be loaded once and refered everywhere. Of course, by default, the Config object cannot be changed by convention means. A changing config during runtime is evil.```py# entry_point.pyfrom mousse import load_configload_config(    &quot;foo&quot;, # to identified a key for the configuration,    path=&quot;config.yaml&quot; # also support json)# config.yaml# foo:#   name: foo#   number: 42.0#   items:#     - name: banana#       price: 12#     - name: egg#       price: 10# id: 1``````py# anywhere.pyfrom typing import *from mousse import get_config, asdict, asclass, Dataclass# This can be called anytimeconfig = get_config(&quot;foo&quot;)# before load_configprint(config)# Config()# after load_configprint(config)# Config(foo=Config(items=[Config(price=12), Config(price=10)]), id=1)print(config.foo)# Config(items=[Config(price=12), Config(price=10)])print(config.foo.items[0].price)# 12# reassignment is forbidden config.foo = &quot;bar&quot;# AssertionError: Permission denied# compatible with asdictconfig_data = asdict(config)print(config_data)# {#     &quot;foo&quot;: {#         &quot;name&quot;: &quot;foo&quot;,#         &quot;number&quot;: 42.0,#         &quot;items&quot;: [#             {#                 &quot;name&quot;: &quot;banana&quot;,#                 &quot;price&quot;: 12#             },#             {#                 &quot;name&quot;: &quot;egg&quot;,#                 &quot;price&quot;: 10#             }#         ]#     },#     &quot;id&quot;: 1# }class Item(Dataclass):    name: str    price: intclass Foo(Dataclass):    name: str    number: float    items: List[Item]class Bar(Dataclass):    foo: Foo    id: int# compatible with asclassbar = asclass(Bar, config)print(bar)# Bar(foo=Foo(name=&quot;foo&quot;, number=42.0, items=[Item(name=&quot;banana&quot;, price=12), Item(name=&quot;egg&quot;, price=10)]), id=1)```### Logger---&gt; This module is for managing logging process, with pre-defined logging format and both file logging and stdout logging.```py# entry_point.pyfrom mousse import get_loggerlogger = get_logger(    &quot;foo&quot;, # key to identify logger,)logger.add_handler(&quot;RotatingFileHandler&quot;, path=&quot;logs/foo.out&quot;)``````py# anywhere.pyfrom mousse import get_loggerlogger = get_logger(&quot;foo&quot;)logger.info(&quot;This is&quot;, &quot;my&quot;, &quot;logger number:&quot;, 1)# [2022-05-09 20:28:04] [43050 4345906560] [INFO] [anywhere:.&lt;module&gt;:1] This is my logger number: 1```The format of the log is:```txt[{date} {time}] [{process_id} {thread_id}] [{level}] [{file}:{caller}:{lineno}] {msg}```### Pattern---&gt; A collection of my most used design patterns#### Registry pattern```py# registry.pyfrom mousse import Registrypokedex = Registry()class Pokemon:    def __init__(self, name:str):        self.name = name``````py# kanto.pyfrom .registry import pokedex, Pokemon@pokedex.registerclass Pikachu(Pokemon):    def sound(self):        return &quot;pika pika chu&quot;@pokedex.registerclass Charmander(Pokemon):    def sound(self):        return &quot;charman charman der&quot;``````py# johto.pyfrom .registry import pokedex, Pokemon@pokedex.registerclass Chikorita(Pokemon):    def sound(self):        return &quot;chiko chiko&quot;``````pyfrom . import kanto, johtofrom .registry import pokedexpikachu = pokedex(&quot;Pikachu&quot;, &quot;1st&quot;)print(pikachu.name, pikachu.sound())charmander = pokedex(&quot;Charmander&quot;, &quot;2nd&quot;)print(charmander.name, charmander.sound())chikorita = pokedex(&quot;Chikorita&quot;, &quot;3rd&quot;)print(chikorita.name, chikorita.sound())```</longdescription>
</pkgmetadata>