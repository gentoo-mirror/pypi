<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>Pyt===Pyt is a lightweight wrapper around `Python’s unittestmodule &lt;https://docs.python.org/3/library/unittest.html&gt;`__ that addssome nice features and enhancements over the stock ``unittest`` module.Quickstart~~~~~~~~~~Pyt overrides unittest’s built-in pathfinding to be smarter and lessverbose, so you can match tests using prefix matching which makesrunning a test like:::   $ python -m unittest tests.foo_test.BarTestCase.test_cheas simple as:::   $ pyt foo.Bar.cheBut it’s even less verbose if you want it to be, pyt can reach into themodules and classes to do its matching, so you don’t even need tospecify the module and class if you don’t want to:::   $ pyt cheMore examples^^^^^^^^^^^^^To run all the ``Happy`` tests:::   $ pyt HappyTo run all the ``newmodule`` tests:::   $ pyt newmoduleTo run more than one test:::   $ pyt test1 test2 ...To run every test ``pyt`` can find:::   $ pytAnd the way I like to run all tests in the current directory:::   $ pyt -vbWhich can also be written:::   $ pyt --verbose --bufferFlags~~~~~To see everything pyt can do::   $ pyt --help–warnings^^^^^^^^^This will convert warnings into errors.::   $ pyt --warnings–rerun^^^^^^If your last testrun had failing tests this will rerun only the teststhat failed.::   $pyt --rerunThings to be aware of~~~~~~~~~~~~~~~~~~~~~pyt uses Python’s PEP 8 style conventions^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^``pyt`` uses `Python’s code stylingconventions &lt;http://www.python.org/dev/peps/pep-0008/&gt;`__ to decide whatis the module and class, so, given input like this:::   $ pyt foo.bar.Baz.che``pyt`` will consider ``foo.bar`` to be the module, ``Baz`` to be aclass (because it starts with a capital letter), and ``che`` to be amethod (since it comes after the class).Likewise, ``pyt`` uses unittest conventions, so a test module should endwith ``_test`` (eg, ``foo.bar_test``) or start with test (eg,``test_foo.py``) and a TestCase class should extend``unittest.TestCase``, and test methods should start with ``test_`` (eg,``test_che``).Vague input can cause pyt to run more tests than you expect^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^So if you have something like this:::   project/     __init__.py     user.py     foo/       __init__.py       user.py     tests/       __init__.py       user_test.py       foo/         __init__.py         user_test.pyAnd you want to run tests for ``foo.user`` and you run:::   $ pyt userit will run both ``tests/user_test`` and ``tests.foo.user_test``, thesolution is to just be more verbose when you have to be:::   $ pyt foo.userEnvironment Variables^^^^^^^^^^^^^^^^^^^^^If you are running the tests within pyt, you might notice there is anenvironment variable ``PYT_TEST_COUNT`` that contains the count of howmany tests pyt found to run.Installation------------Use ``pip``:::   $ pip install pytYou can also get it directly from the repo:::   $ pip install --upgrade git+https://github.com/Jaymon/pyt#egg=pytIf you install pyt using Python 3 it can also be invoked using the``pyt3`` command:::   $ pyt3 --helpLikewise, Python 2 installs a ``pyt2`` command:::   $ pyt2 --helpTesting-------Testing in 2.7 on most systems:::   $ python -m unittest pyt_testTesting in 3.5 on MacOS:::   $ python3.5 -m unittest pyt_test</longdescription>
</pkgmetadata>