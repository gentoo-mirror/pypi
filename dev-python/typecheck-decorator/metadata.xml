<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>A decorator for functions, ``@tc.typecheck``, to be used together withPython3 annotations on function parameters and function results.The decorator will perform dynamic argument type checking for every call to the function.::  @tc.typecheck  def foo1(a:int, b=None, c:str=&quot;mydefault&quot;) -&gt; bool :      print(a, b, c)      return b is not None and a != bThe parts ``:int``, ``:str``, and ``-&gt; bool`` are annotations.This is a syntactic feature introduced in Python 3 where ``:`` (for parameters)and ``-&gt;`` (for results) are delimiters and the rest can bean arbitrary expression.It is important to understand that, as such,*annotations do not have any semantics whatsoever*.There must be explicit Python code somewherethat looks at them and does something in order to give them a meaning.The ``@tc.typecheck`` decorator gives the above annotations the following meaning:``foo1``'s argument ``a`` must have type ``int``,``b`` has no annotation and can have any type whatsoever, it will not be checked,``c`` must have type string,and the function's result must be either``True`` (not ``17`` or ``&quot;yes&quot;`` or ``[3,7,44]`` or some such) or``False`` (not ``0`` or ``None`` or ``[]`` or some such).If any argument has the wrong type, a ``TypeCheckError`` exception will be raisedat run time.Class types, collection types, fixed-length collections andtype predicates can be annotated as well.As of Python 3.5, PEP 484 specifies that annotations should be types andtheir normal use will be type checking.Many advanced types (such as ``Sequence[int]``) can now be defined via the``typing`` module, which is also available at PyPI for earlier versions ofPython 3.The present module supports these ``typing`` annotations, but it predatesPython 3.5 and therefore has other forms of type specification (via typepredicates) as well.Many of these are equivalent, but some are more powerful.Here is a more complex example:::  import typecheck as tc  @tc.typecheck  def foo2(record:(int,int,bool), rgb:tc.re(&quot;^[rgb]$&quot;)) -&gt; tc.any(int,float) :      # don't expect the following to make much sense:      a = record[0]; b = record[1]      return a/b if (a/b == float(a)/b) else float(a)/b  foo2((4,10,True), &quot;r&quot;)   # OK  foo2([4,10,True], &quot;g&quot;)   # OK: list is acceptable in place of tuple  foo2((4,10,1), &quot;rg&quot;)     # Wrong: 1 is not a bool, string is too long  foo2(None,     &quot;R&quot;)      # Wrong: None is no tuple, string has illegal characterThese annotations mean that ``record`` is a 3-tuple of two ints andan actual bool and ``rgb`` is a one-character string that iseither &quot;r&quot; or &quot;g&quot; or &quot;b&quot; by virtue of a regular expression test.The result will be a number that can be either int or float.The first and third of these are expressible with ``typing`` annotations aswell, the second is not. The closest approximation would look like this:::  import typing as tg  import typecheck as tc  @tc.typecheck  def foo2(record:tg.Tuple[int,int,bool], rgb:str) -&gt; tg.Union[int,float] :      &quot;&quot;&quot;rgb must be one of &quot;r&quot;,&quot;g&quot;,&quot;b&quot;.&quot;&quot;&quot;      a = record[0]; b = record[1]      return a/b if (a/b == float(a)/b) else float(a)/b  foo2((4,10,True), &quot;r&quot;)   # OK  foo2([4,10,True], &quot;g&quot;)   # OK: list is acceptable in place of tuple  foo2((4,10,1), &quot;rg&quot;)     # Wrong: 1 is not a bool (but meant-to-be-too-long string is not detected)  foo2(None,     &quot;R&quot;)      # Wrong: None is no tuple (but meant-to-be-illegal character is not detected)Other kinds of annotations:- ``tc.optional(int)`` or ``tg.Optional[int]`` will allow int and None,- ``tc.enum(1, 2.0, &quot;three&quot;)`` allows to define ad-hoc enumeration types,- ``tc.map_of(str, tc.list_of(Person))`` or  ``tg.Mapping[str, tg.MutableSequence[Person]]``  describe dictionaries or other mappings where all  keys are strings and all values are homogeneous lists of Persons,- and so on.Tox-tested on CPython 3.3, 3.4, 3.5.Find the documentation athttps://github.com/prechelt/typecheck-decorator</longdescription>
</pkgmetadata>