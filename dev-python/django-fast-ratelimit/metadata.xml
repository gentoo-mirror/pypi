<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># django-fast-ratelimitDjango-fast-ratelimit provides a secure and fast ratelimit facility based on the django caching framework.It uses a &quot;Fixed window counter&quot;-algorithm based on:https://medium.com/figma-design/an-alternative-approach-to-rate-limiting-f8a06cf7c94c## Installation```bashpip install django-fast-ratelimit```Note: pip &gt;= 19 is required## usageDecorator:```pythonimport ratelimit@ratelimit.decorate(key=&quot;ip&quot;, rate=&quot;1/s&quot;)def expensive_func(request):    # how many ratelimits request limiting    if request.ratelimit[&quot;request_limit&quot;] &gt; 0:        # reschedule with end of rate epoch        return request_waiting(request.ratelimit[&quot;end&quot;])```or async```pythonimport ratelimitimport asyncio@ratelimit.decorate(key=&quot;ip&quot;, rate=&quot;1/s&quot;)async def expensive_func(request):    # how many ratelimits request limiting    if request.ratelimit[&quot;request_limit&quot;] &gt; 0:        # reschedule with end of rate epoch        await asyncio.sleep(request.ratelimit[&quot;end&quot;])```blocking Decorator (raises RatelimitError):```pythonimport ratelimit@ratelimit.decorate(key=&quot;ip&quot;, rate=&quot;1/s&quot;, block=True, decorate_name=&quot;ratelimit&quot;, methods=ratelimit.UNSAFE)def expensive_func(request):    # how many ratelimits request limiting    if request.ratelimit[&quot;end&quot;] &gt; 0:```decorate View (requires group):```pythonimport ratelimitfrom django.views.generic import Viewfrom django.utils.decorators import method_decorator@method_decorator(ratelimit.decorate(  key=&quot;ip&quot;, rate=&quot;1/s&quot;, block=True, methods=ratelimit.SAFE, group=&quot;required&quot;), name=&quot;dispatch&quot;)class FooView(View):    ...```manual```pythonimport ratelimitdef func(request):    ratelimit.get_ratelimit(key=&quot;ip&quot;, rate=&quot;1/s&quot;, request=request, group=&quot;123&quot;, action=ratelimit.Action.INCREASE)    # or only for GET    ratelimit.get_ratelimit(        key=&quot;ip&quot;, rate=&quot;1/s&quot;, request=request, group=&quot;123&quot;, methods=&quot;GET&quot;, action=ratelimit.Action.INCREASE    )    # also simple calls possible (note: key in bytes format)    ratelimit.get_ratelimit(        key=b&quot;abc&quot;, rate=&quot;1/s&quot;, group=&quot;123&quot;, action=ratelimit.Action.INCREASE    )    # retrieve ratelimit    rlimit = ratelimit.get_ratelimit(        key=&quot;ip&quot;, rate=&quot;1/s&quot;, request=request, group=&quot;123&quot;    )    # reset (clears internal counter)    counter_before_reset = rlimit.reset()    # reset epoch (resets to the start of request/epoch)    counter_before_reset = rlimit.reset(request)    # decrease counter by arbitary amount    rlimit.reset(19)    # increase counter by arbitary amount    rlimit.reset(-19)    # check constraints of rate    r = ratelimit.parse_rate(&quot;1/s&quot;)  # returns tuple (amount, period)    assert(r[1]==1)  #  assert period is 1 second    # for simple naming use o2g (object to group)    ratelimit.get_ratelimit(        key=b&quot;abc&quot;, rate=r, group=ratelimit.o2g(func), action=ratelimit.Action.INCREASE    )```manual async```pythonimport ratelimitasync def func(request):    # retrieve ratelimit    rlimit = await ratelimit.aget_ratelimit(        key=&quot;ip&quot;, rate=&quot;1/s&quot;, request=request, group=&quot;123&quot;    )    # reset (clears internal counter)    await rlimit.areset()    # reset epoch (resets to the start of request/epoch)    await rlimit.areset(request)    # decrease counter by arbitary amount    await rlimit.areset(19)    # increase counter by arbitary amount    await rlimit.reset(-19)```## parameters### ratelimit.get_ratelimit:-   group: group name, can be callable (fun(request))-   rate: rate limit, multiple modes    Note: if count (first argument) is 0, then it raises the Disabled exception, the second argument must be greater then 0    -   str: default mode , specify rate in form of &quot;1/4s&quot; or &quot;2/s&quot; or &quot;2/m&quot;    -   2 element tuple/list: first argument is amount, second are seconds    -   callable: can return of two-   methods: set of checked methods, can be callable (fun(request, group)), modes:    -   callable(request, group): allow dynamic    -   ratelimit.ALL (default): all methods are checked    -   \(&quot;HEAD&quot;, &quot;GET&quot;\): list of checked methods    -   ratelimit.invertedset([&quot;HEAD&quot;, &quot;GET&quot;]): inverted set of checked methods. Here: every method is checked, except HEAD, GET-   request: ingoing request (optional if key supports it and methods=ratelimit.ALL (default))-   key: multiple modes possible:    -   bool: True: skip key (should only be used for baking), False: disable cache (like RATELIMIT_ENABLE=False)    -   int: sidestep cache, value will be used for request_limit. 0 is for never blocking, &gt;=1 blocks    -   str: &quot;path.to.method:argument&quot;    -   str: &quot;inbuildmethod:argument&quot; see methods for valid arguments    -   str: &quot;inbuildmethod&quot; method which is ready to use for (request, group)    -   tuple,list: [&quot;method&quot;, args...]: method (can be also inbuild) with arbitary arguments    -   bytes: static key (supports mode without request)    -   callable: check return of function (fun(request, group)), return must be string (converted to bytes), bytes, bool or int (see &quot;key&quot; for effects)-   empty_to: convert empty keys (b&quot;&quot;) to parameter. Must be bytes, bool or int (see &quot;key&quot; for effects) (default: keep b&quot;&quot;)-   cache: specify cache to use, defaults to RATELIMIT_DEFAULT_CACHE setting (default: &quot;default&quot;)-   hash_algo: name of hash algorithm for creating cache_key (defaults to RATELIMIT_KEY_HASH setting (default: &quot;sha256&quot;))    Note: group is seperately hashed-   hashctx: optimation parameter, read the code and only use if you know what you are doing. It basically circumvents the parameter hashing and only hashes the key. If the key parameter is True even the key is skipped-   action {ratelimit.Action}:    -   PEEK: only lookup    -   INCREASE: count up and return result    -   RESET: return former result and reset    -   RESET_EPOCH: return count after reset of epoch. If neither epoch nor request is given like peek (default: {PEEK})-   epoch:    -   None: (default): use request as epoch    -   int: RESET_EPOCH resets by int. Negative int increases    -   object: attach counter to an open object (Note: it cannot be object() directly and neither an object with slots)returns the dataclass Ratelimitor raises `ratelimit.Disabled` in case of the count in the rate is zero### ratelimit.RatelimitFields-   count: how often in the window the ip whatever was calling-   limit: limit when it should block-   request_limit: &gt;=1 should block or reject, 0: should accept-   end: when does the block end-   group: group name-   group_key, cache: Optional, when specified reset and areset can be used, internal fields-   waited_ms: internal field, stores info how long was waited, in ms instead of rate secondsFunctions:-   can_reset: is a reset possible or were bypasses used-   reset: function to reset count if cache was used. When given an epoch the same as RESET_EPOCH-   areset: async version of reset-   check(block=False): raise RatelimitExceeded when block = True and ratelimit is exceeded-   acheck(wait=False, block=False): raise RatelimitExceeded when block = True and ratelimit is exceeded, wait for end of ratelimit duration when wait=True-   decorate_object(obj, name=&quot;ratelimit&quot;, block=False, replace=False): attach to object obj with name and use old limits too, pass block to check-   adecorate_object(obj, name=&quot;ratelimit&quot;, wait=False, block=False, replace=False): attach to object obj with name and use old limits too, pass block and wait to acheckNote: decorate_object with name=None behaves like check (except return value), the same applies for adecorate_objectarguments:-   wait: wait until end timestamp when ratelimit was exceeded. Next call should work again, applied before block-   block: raise a RatelimitExceeded exception-   replace: ignore potential old ratelimit object atttached to object and just replace itwhy only async methods have wait? It doesn't really block (only the userlandthread). In contrast to its sync equivalent it doesn't block the webserver significantlyExample: decorate_object```pythonimport ratelimitclass Foo():    passr = get_ratelimit(    group=&quot;foo&quot;,    rate=&quot;1/s&quot;,    key=b&quot;foo&quot;,    action=ratelimit.Action.INCREASE,)# manual wayfoo = r.decorate_object(Foo(), name=&quot;ratelimit&quot;)if not foo.ratelimit.check():    raise ratelimit.RatelimitExceeded(&quot;custom message&quot;, ratelimit=r)else:    pass    # do cool stuff# simplifiedfoo2 = r.decorate_object(Foo(), block=True)# artistic (no point in doing so)r.decorate_object(Foo(), name=&quot;ratelimit_is_cool&quot;).ratelimit_is_cool.check(block=True)# like check with instance of Foo() as return valuefoo3 r.decorate_object(Foo(), name=None, wait=True)# decorate function@r.decorate_object(block=True)def fn():    pass# of course also this works@r.decorate_objectdef fn():    pass```### ratelimit.aget_ratelimit:same as `get_ratelimit` but supports async methods and has an optional parameter:`wait`, which suspends the execution (via `asyncio.sleep`) for the time specified in rate (second argument).This is only possible in async mode, as it would block too much in sync mode.### ratelimit.decorate:All of ratelimit.get_ratelimit except request. group is here optional (except for decorations with method_decorator (no access to wrapped function)).Also supports:-   block: should hard block with an RatelimitExceeded exception (subclass of PermissionDenied) or only annotate request with ratelimit-   decorate_name: under what name the ratelimit is attached to the request. set to None/empty to not decorate request. Uses Ratelimit.decorate_object. Defaults to &quot;ratelimit&quot;-   wait (only async functions): suspends executionNote: wait is tricky with method_decorator: you must ensure that the function decorated is asyncwhy only async methods have wait? It doesn't really block (only the userlandthread). In contrast to its sync equivalent it doesn't block the webserver significantly## helpers### ratelimit.invertedset:inverts a collection, useful for http methods### ratelimit.get_RATELIMIT_TRUSTED_PROXY:get the `RATELIMIT_TRUSTED_PROXIES` parsed as setnote: this function is cached. If you change this setting while testing you may have to call:`ratelimit.get_RATELIMIT_TRUSTED_PROXY.cache_clear()`### ratelimit.get_ip:get client ip from request, using `RATELIMIT_TRUSTED_PROXIES` and forwarded headers```pythonimport ratelimitratelimit.get_ip(request)```### ratelimit.o2g:auto generate group names for method/function as input, see tests/test_decorators for more infoExample:```pythonimport ratelimitclass O2gView(View):    def get(self, request, *args, **kwargs):        request.ratelimit2 = ratelimit.get_ratelimit(            group=ratelimit.o2g(self.get),            rate=&quot;1/s&quot;,            key=b&quot;o2gtest&quot;,            action=ratelimit.Action.INCREASE,        )        if request.ratelimit2.request_limit &gt; 0:            return HttpResponse(status=400)        return HttpResponse()```### ratelimit.RatelimitExceededRaised when the ratelimit was exceededException, required keyword argument is ratelimit with the ratelimit.The next arguments are passed to the underlying standard exception class for e.g. customizing the error message### ratelimit.DisabledStronger variant of RatelimitExceeded. Used for cases where limit is 0 and there is no way to pass the ratelimit.It is a shortcut for disabling api.Note: it is weaker than the setting `RATELIMIT_ENABLE`Note: it isn't a subclass from RatelimitExceeded because APIs should be able to differ both casesNote: in contrast to RatelimitExceeded it is raised in (a)get_ratelimit and when using decorate, the view function isn't called.### ratelimit.protect_sync_onlyfor libraries. In case of async return protected asyncified function otherwise call library directly## recipesjitter:```pythonimport ratelimitimport asyncioimport secretsasync def foo()    r = await ratelimit.aget_ratelimit(        group=&quot;foo&quot;,        rate=&quot;1/s&quot;,        key=b&quot;foo&quot;,        action=ratelimit.Action.INCREASE,    )    # 100ms jitter    await asyncio.sleep(secrets.randbelow(100) / 100)    # raise when limit reached, wait until full second jitter is eliminated in raise case as end was created before the jitter    await r.acheck(wait=True, block=True)```## methodsSee in methods which methods are available. Here some of them:-   ip: use ip address as key, argument: [netmask ipv4/]netmask ipv6-   user: authenticated user primary key or b&quot;&quot;-   user_or_ip: use autenticated user primary key as key. If not autenticated fallback to ip, also with netmask argument-   user_and_ip: same like user_or_ip except that the ip matching also applies for authenticated users-   get: generate key from multiple sources, input can be multiple input args or a dict with options## settings-   `RATELIMIT_TESTCLIENT_FALLBACK`: in case instead of a client ip a testclient is detected map to the fallback. Set to &quot;invalid&quot; to fail. Default ::1-   `RATELIMIT_GROUP_HASH`: hash function which is used for the group hash (default: md5)-   `RATELIMIT_KEY_HASH`: hash function which is used as default for the key hash, can be overridden with hash_algo (default: md5)-   `RATELIMIT_ENABLE` disable ratelimit (e.g. for tests) (default: enabled)-   `RATELIMIT_KEY_PREFIX`: internal prefix for the hash keys (so you don't have to create a new cache). Defaults to &quot;frl:&quot;.-   `RATELIMIT_DEFAULT_CACHE`: default cache to use, defaults to &quot;default&quot; and can be overridden by cache parameter-   `RATELIMIT_TRUSTED_PROXIES`: &quot;all&quot; for allowing all ip addresses to provide forward informations, or an iterable with proxy ips (will be transformed to a set). Note there is a special ip: &quot;unix&quot; for unix sockets. Default: [&quot;unix&quot;]    Used headers are: `Forwarded`, `X-Forwarded-For`## Update Notes:in version 3.0.0 the name parameter of (a)decorate_object was changed to ratelimitin version 2.0.0 the parameter `raise_on_limit` was removed and replaced by check(block=True)in version 1.0.0 the parameter `include_reset` was removedin version 1.2.0 reset_epoch calls return the counter before reset instead of the count after## TODO:-   document and test wait parameter-   improve documentation decorate_name and decorate_object</longdescription>
</pkgmetadata>