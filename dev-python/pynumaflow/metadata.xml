<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Python SDK for NumaflowThis SDK provides the interface for writing [UDFs](https://numaflow.numaproj.io/user-guide/user-defined-functions/user-defined-functions/) and [UDSinks](https://numaflow.numaproj.io/user-guide/sinks/user-defined-sinks/) in Python.## Implement a User Defined Function (UDF)### Map```pythonfrom pynumaflow.function import Messages, Message, Datum, Serverfrom typing import Listdef my_handler(keys: List[str], datum: Datum) -&gt; Messages:    val = datum.value    _ = datum.event_time    _ = datum.watermark    messages = Messages(Message(value=val, keys=keys))    return messagesif __name__ == &quot;__main__&quot;:    grpc_server = Server(map_handler=my_handler)    grpc_server.start()```### MapT - Map with event time assignment capabilityIn addition to the regular Map function, MapT supports assigning a new event time to the message.MapT is only supported at source vertex to enable (a) early data filtering and (b) watermark assignment by extracting new event time from the message payload.```pythonimport datetimefrom pynumaflow.function import MessageTs, MessageT, Datum, Serverfrom typing import Listdef mapt_handler(keys: List[str], datum: Datum) -&gt; MessageTs:    val = datum.value    new_event_time = datetime.time()    _ = datum.watermark    message_t_s = MessageTs(MessageT(new_event_time, val, keys))    return message_t_sif __name__ == &quot;__main__&quot;:    grpc_server = Server(mapt_handler=mapt_handler)    grpc_server.start()```### Reduce```pythonimport aiorunimport asynciofrom typing import Iterator, Listfrom pynumaflow.function import Messages, Message, Datum, Metadata, AsyncServerasync def my_handler(keys: List[str], datums: Iterator[Datum], md: Metadata) -&gt; Messages:    interval_window = md.interval_window    counter = 0    async for _ in datums:        counter += 1    msg = (        f&quot;counter:{counter} interval_window_start:{interval_window.start} &quot;        f&quot;interval_window_end:{interval_window.end}&quot;    )    return Messages(Message(str.encode(msg), keys))if __name__ == &quot;__main__&quot;:    grpc_server = AsyncServer(reduce_handler=my_handler)    aiorun.run(grpc_server.start())```### Sample ImageA sample UDF [Dockerfile](examples/function/forward_message/Dockerfile) is provided under [examples](examples/function/forward_message).## Implement a User Defined Sink (UDSink)```pythonfrom typing import Iteratorfrom pynumaflow.sink import Datum, Responses, Response, Sinkdef my_handler(datums: Iterator[Datum]) -&gt; Responses:    responses = Responses()    for msg in datums:        print(&quot;User Defined Sink&quot;, msg.value.decode(&quot;utf-8&quot;))        responses.append(Response.as_success(msg.id))    return responsesif __name__ == &quot;__main__&quot;:    grpc_server = Sink(my_handler)    grpc_server.start()```### Sample ImageA sample UDSink [Dockerfile](examples/sink/log/Dockerfile) is provided under [examples](examples/sink/log).### Datum MetadataThe Datum object contains the message payload and metadata. Currently, there are two fieldsin metadata: the message ID, the message delivery count to indicate how many times the messagehas been delivered. You can use these metadata to implement customized logic. For example,```python...def my_handler(keys: List[str], datum: Datum) -&gt; Messages:    num_delivered = datum.metadata.num_delivered    # Choose to do specific actions, if the message delivery count reaches a certain threshold.    if num_delivered &gt; 3:        ...```</longdescription>
</pkgmetadata>