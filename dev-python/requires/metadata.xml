<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription>&lt;a href=&quot;https://github.com/dynamic-graphics-inc/dgpy-libs&quot;&gt;&lt;img align=&quot;right&quot; src=&quot;https://github.com/dynamic-graphics-inc/dgpy-libs/blob/main/docs/images/dgpy_banner.svg?raw=true&quot; alt=&quot;drawing&quot; height=&quot;120&quot; width=&quot;300&quot;/&gt;&lt;/a&gt;# requires[![Wheel](https://img.shields.io/pypi/wheel/requires.svg)](https://img.shields.io/pypi/wheel/requires.svg)[![Version](https://img.shields.io/pypi/v/requires.svg)](https://img.shields.io/pypi/v/requires.svg)[![py_versions](https://img.shields.io/pypi/pyversions/requires.svg)](https://img.shields.io/pypi/pyversions/requires.svg)[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)**Install:** `pip install requires`Decorate that lets youRequire/Import dependencies at runtime.Python dependency management can be mind bottlingly complex. Optional dependencies are pretty common. Why not require the dependency at run time if a function requires said dependency?This package has come in handy in lambda-land where you only get 250mb (on aws)!___## Usage:```python# This will faildef uno():    return json.dumps({'a': 1, 'b': 2})try:    uno()except NameError as ne:    print(&quot;Error:&quot;, ne)```    Error: name 'json' is not defined```python# This will not failimport requires  # Module is callable! (checkout funkify for more info -- `pip install funkify`)@requires('json')def uno():    return json.dumps({'a': 1, 'b': 2})uno()```    '{&quot;a&quot;: 1, &quot;b&quot;: 2}'```pythonimport requires@requires('from json import dumps')def uno():    return dumps({'a': 1, 'b': 2})uno()```    '{&quot;a&quot;: 1, &quot;b&quot;: 2}'```pythondef dos():    return dumps({'a': 1, 'b': 2})dos()```    '{&quot;a&quot;: 1, &quot;b&quot;: 2}'```pythonimport requires@requires(_from='json', _import='dumps')def dos():    return dumps({'a': 1, 'b': 2})dos()```    '{&quot;a&quot;: 1, &quot;b&quot;: 2}'```pythonimport requires@requires(_import='rapidjson', pip='python-rapidjson', conda_forge='python-rapidjson')def tres():    return rapidjson.dumps({'a': 1, 'b': 2})tres()  # Will err if not install with where to install instructions```    '{&quot;a&quot;:1,&quot;b&quot;:2}'```python# should errordef quatro():    return path.join('a', 'b')try:    quatro()except NameError as ne:    print(&quot;ERROR:&quot;, ne)```    ERROR: name 'path' is not defined```pythonfrom requires import Requirementos_path_req = Requirement(_import='path', _from='os')@os_path_reqdef quatro():    return path.join('a', 'b')assert isinstance(quatro(), str)```## Enforcing requirements```pythonimport requirestry:    import alibraryexcept ModuleNotFoundError:    requirement = requires.Requirement(        _import='alibrary',        pip=True,        conda_forge='alibrary-conda-listing',        details=&quot;Install details&quot;    )try:    requirement.raise_error()except requires.RequirementError as err:    print(&quot;ERROR:&quot;)    print(err)```    ERROR:    Module/Package(s) not found/installed; could not import: `import alibrary`        pip install alibrary        conda install -c conda-forge alibrary-conda-listing        Install details## Less verbose version:```pythonimport requirestry:    import alibraryexcept ModuleNotFoundError:    requires.Requirement(        _import='alibrary',        pip=True,        conda_forge='alibrary-conda-listing',        details=&quot;Install details&quot;    ).raise_error()```___## Future ideas? - Adding support for requiring particular package versions? - Auto install? - Allow non pip/conda/conda-forge locations?</longdescription>
</pkgmetadata>