<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Pythonic toolbox[![PyPI version](https://badge.fury.io/py/pythonic-toolbox.svg)](https://badge.fury.io/py/pythonic-toolbox)[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)[![Supported Python versions](https://img.shields.io/pypi/pyversions/pythonic-toolbox.svg?style=flat&amp;logo=python&amp;logoColor=yellow&amp;labelColor=5c5c5c)](https://pypi.org/project/pythonic-toolbox)[![Stability](https://img.shields.io/pypi/status/pythonic-toolbox.svg?style=flat)](https://badge.fury.io/py/pythonic-toolbox)[![CodeQL Status](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/codeql-analysis.yml/badge.svg?branch=master)](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/codeql-analysis.yml)[![Python3.6 Test Status](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python36.yml/badge.svg?branch=master)](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python36.yml)[![Python3.7 Test Status](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python37.yml/badge.svg?branch=master)](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python37.yml)[![Python3.8 Test Status](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python38.yml/badge.svg?branch=master)](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python38.yml)[![Python3.9 Test Status](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python39.yml/badge.svg?branch=master)](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python39.yml)[![Python3.10 Test Status](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python310.yml/badge.svg?branch=master)](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python310.yml)[![Python3.11 Test Status](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python311.yml/badge.svg?branch=master)](https://github.com/albertmenglongli/pythonic-toolbox/actions/workflows/tests-python311.yml)[![SNYK Status](https://snyk.io/test/github/albertmenglongli/pythonic-toolbox/badge.svg)](https://snyk.io/test/github/albertmenglongli/pythonic-toolbox)## Table of Contents* [Introduction](#Introduction)* [Installation](#Installation)* [Usage](#Usage)* [context](#context)* [SkipContext](#SkipContext)* [decorators](#decorators)* [ignore_unexpected_kwargs](#ignore_unexpected_kwargs)* [retry](#retry)* [deque_utils](#deque_utils)* [deque_pop_any](#deque_pop_any)* [deque_split](#deque_split)* [dict_utils](#dict_utils)* [DictObj](#DictObj)* [FinalDictObj](#FinalDictObj)* [RangeKeyDict](#RangeKeyDict)* [StrKeyIdDict](#StrKeyIdDict)* [collect_leaves](#collect_leaves)* [dict_until](#dict_until)* [select_list_of_dicts](#select_list_of_dicts)* [unique_list_of_dicts](#unique_list_of_dicts)* [walk_leaves](#walk_leaves)* [functional_utils](#functional_utils)* [filter_multi](#filter_multi)* [list_utils](#list_utils)* [filter_allowable](#filter_allowable)* [sort_with_custom_orders](#sort_with_custom_orders)* [unpack_list](#unpack_list)* [until](#until)* [string_utils](#string_utils)* [substitute_string_template_dict](#substitute_string_template_dict)&gt; README.md is auto generated by the script **tests/generate_readme_markdown.py** from testing files,&gt;&gt; **DO NOT EDIT DIRECTLY!**   ;)```bashpython3 tests/generate_readme_markdown.py```## IntroductionA python3.6+ toolbox with multi useful utils, functions, decorators in pythonic way, and is fully tested from python3.6 to python3.11 .## Installation```bashpip3 install pythonic-toolbox --upgrade```## Usage### context#### SkipContext```python3import itertoolsimport pytestfrom pythonic_toolbox.utils.context_utils import SkipContext# Usage: define a class that inherits the SkipContext,# and takes control of the skip or not logicclass MyWorkStation(SkipContext):    def __init__(self, week_day: str):        working_days = {'monday', 'tuesday', 'wednesday', 'thursday', 'friday'}        weekends = {'saturday', 'sunday'}        if week_day.lower() not in working_days.union(weekends):            raise ValueError(f'Invalid weekday {week_day}')        skip = True if week_day.lower() in weekends else False        super(MyWorkStation, self).__init__(skip=skip)seven_week_days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']logged_opening_days = []total_working_hours = 0for cur_week_day in seven_week_days:    # MyWorkStation will skip the code block when encountering weekends    with MyWorkStation(week_day=cur_week_day):        # log this working day        logged_opening_days.append(cur_week_day)        # accumulate working hours, 8 hours on each working day        total_working_hours += 8# only working days are loggedassert logged_opening_days == ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']assert total_working_hours == 8 * 5# test basic SkipContextcount_iterator = itertools.count(start=0, step=1)flg_skip = Truewith SkipContext(skip=flg_skip):    # if skip = True, all codes inside the context will be skipped(not executed)    next(count_iterator)  # this will not be executed    assert sum([1, 1]) == 3    raise Exception('Codes will not be executed')assert next(count_iterator) == 0  # check previous context is skippedflg_skip = Falsewith SkipContext(skip=flg_skip):    # codes will be executed as normal, if skip = False    next(count_iterator)  # generate value 1    assert sum([1, 1]) == 2assert next(count_iterator) == 2  # check previous context is executedwith pytest.raises(Exception) as exec_info:    with SkipContext(skip=False):        # if skip = False, this SkipContextManager is transparent,        # internal exception will be detected as normal        raise Exception('MyError')assert exec_info.value.args[0] == 'MyError'# another example: ensure there will be only one job, who acquire the lock, run the increase +1from multiprocessing import Manager, Poolimport timefrom pythonic_toolbox.utils.context_utils import SkipContextdef plain_cronjob_increase(ns, lock):    start = time.time()    with lock:        now = time.time()        if now - start &gt;= 0.5:            pass        else:            ns.cnt += 1            time.sleep(1)    return ns.cntclass PreemptiveLockContext(SkipContext):    def __init__(self, lock):        self.start_time = time.perf_counter()        self.lock = lock        self.acquired = self.lock.acquire(timeout=0.5)        skip = not self.acquired        super(PreemptiveLockContext, self).__init__(skip=skip)    def __exit__(self, type, value, traceback):        if self.acquired:            time.sleep(1)            self.lock.release()        if type is None:            return  # No exception        else:            if issubclass(type, self.SkipContentException):                return True  # Suppress special SkipWithBlockException            return Falsedef cronjob_increase(ns, lock):    # for those who cannot acquire the lock within some time    # this context block will be skipped, quite simple    with PreemptiveLockContext(lock):        ns.cnt += 1    return ns.cntmanager = Manager()lock = manager.Lock()ns = manager.Namespace()pool = Pool(2)ns.cnt = 0processes = [pool.apply_async(plain_cronjob_increase, args=(ns, lock)) for __ in range(0, 2)]result = [p.get() for p in processes]assert result == [1, 1]assert ns.cnt == 1# reset global cnt=0ns.cnt = 0processes = [pool.apply_async(cronjob_increase, args=(ns, lock)) for __ in range(0, 2)]result = [p.get() for p in processes]assert result == [1, 1]assert ns.cnt == 1```### decorators#### ignore_unexpected_kwargs```python3import pytestfrom pythonic_toolbox.decorators.common import ignore_unexpected_kwargs# Following functions are named under Metasyntactic Variables, like:# foobar, foo, bar, baz, qux, quux, quuz, corge,# grault, garply, waldo, fred, plugh, xyzzy, thuddef foo(a, b=0, c=3):    return a, b, cdct = {'a': 1, 'b': 2, 'd': 4}with pytest.raises(TypeError) as __:    assert foo(**dct) == (1, 2, 3)wrapped_foo = ignore_unexpected_kwargs(foo)assert wrapped_foo(**dct) == (1, 2, 3)assert wrapped_foo(0, 0, 0) == (0, 0, 0)assert wrapped_foo(a=1, b=2, c=3) == (1, 2, 3)@ignore_unexpected_kwargsdef bar(*args: int):    return sum(args)# should not change original behaviorassert bar(1, 2, 3) == 6assert bar(1, 2, 3, unexpected='Gotcha') == 6nums = [1, 2, 3]assert bar(*nums, unexpected='Gotcha') == 6@ignore_unexpected_kwargsdef qux(a, b, **kwargs):    # function with Parameter.VAR_KEYWORD Aka **kwargs    return a, b, kwargs.get('c', 3), kwargs.get('d', 4)assert qux(**{'a': 1, 'b': 2, 'd': 4, 'e': 5}) == (1, 2, 3, 4)class Person:    @ignore_unexpected_kwargs    def __init__(self, name, age, sex):        self.name = name        self.age = age        self.sex = sex    @classmethod    @ignore_unexpected_kwargs    def create(cls, name, age, sex):        return cls(name, age, sex)    @staticmethod    @ignore_unexpected_kwargs    def greetings(name):        return f'Hello, I am {name}'params = {    'name': 'albert',    'age': 34,    'sex': 'male',    'height': '170cm',}__ = Person(**params)__ = Person('albert', 35, 'male', height='170cm')# test cases for classmethod, staticmethod__ = Person.create(**params)assert Person.greetings(**params)```#### retry```python3import pytestfrom pythonic_toolbox.decorators.common import retry# use decorator without any arguments, using retry default params@retrydef func_fail_first_time():    &quot;&quot;&quot;func_fail_first_time&quot;&quot;&quot;    self = func_fail_first_time    if not hasattr(self, 'call_times'):        # set attribute call_times for function, to count call times        self.call_times = 0    self.call_times += 1    if self.call_times == 1:        raise Exception('Fail when first called')    return 'ok'assert func_fail_first_time() == 'ok'assert func_fail_first_time.call_times == 2assert func_fail_first_time.__doc__ == 'func_fail_first_time'@retry(tries=2, delay=0.1)  # use decorator with customized paramsdef func_fail_twice():    &quot;&quot;&quot;func_fail_twice&quot;&quot;&quot;    self = func_fail_twice    if not hasattr(self, 'call_times'):        self.call_times = 0    self.call_times += 1    if self.call_times &lt;= 2:        raise Exception('Fail when called first, second time')    return 'ok'assert func_fail_twice() == 'ok'assert func_fail_twice.call_times == 3assert func_fail_twice.__doc__ == 'func_fail_twice'@retry(tries=2, delay=0.1)def func_fail_three_times():    &quot;&quot;&quot;func_fail_three_times&quot;&quot;&quot;    self = func_fail_three_times    if not hasattr(self, 'call_times'):        self.call_times = 0    self.call_times += 1    if self.call_times &lt;= 3:  # 1, 2, 3        raise Exception('Fail when called first, second, third time')    return 'ok'with pytest.raises(Exception) as exec_info:    func_fail_three_times()assert func_fail_three_times.call_times == 3assert exec_info.value.args[0] == 'Fail when called first, second, third time'import asyncio@retryasync def async_func_fail_first_time():    &quot;&quot;&quot;async_func_fail_first_time&quot;&quot;&quot;    self = async_func_fail_first_time    if not hasattr(self, 'call_times'):        self.call_times = 0    self.call_times += 1    if self.call_times == 1:        raise Exception('Fail when first called')    return 'ok'@retry(delay=0.1)async def async_func_fail_first_time2():    &quot;&quot;&quot;async_func_fail_first_time2&quot;&quot;&quot;    self = async_func_fail_first_time2    if not hasattr(self, 'call_times'):        self.call_times = 0    self.call_times += 1    if self.call_times == 1:        raise Exception('Fail when first called')    return 'ok'async def async_main():    assert await async_func_fail_first_time() == 'ok'    assert async_func_fail_first_time.__doc__ == 'async_func_fail_first_time'    assert async_func_fail_first_time.call_times == 2    assert await async_func_fail_first_time2() == 'ok'    assert async_func_fail_first_time2.call_times == 2    assert async_func_fail_first_time2.__doc__ == 'async_func_fail_first_time2'loop = asyncio.get_event_loop()if loop.is_closed():    loop = asyncio.new_event_loop()try:    loop.run_until_complete(async_main())finally:    loop.close()import randomfail_count = 0@retry(delay=0.1)async def always_fail_func():    nonlocal fail_count    fail_count += 1    await asyncio.sleep(random.random())    raise ValueError()async def async_main_for_always_fail():    nonlocal fail_count    tasks = [always_fail_func() for i in range(0, 3)]    results = await asyncio.gather(*tasks, return_exceptions=True)    assert all(map(lambda e: isinstance(e, ValueError), results))    assert fail_count == 2 * 3  # each func run twice, three func callsloop = asyncio.get_event_loop()if loop.is_closed():    loop = asyncio.new_event_loop()try:    loop.run_until_complete(async_main_for_always_fail())finally:    loop.close()```### deque_utils#### deque_pop_any```python3from collections import dequeimport pytestfrom pythonic_toolbox.utils.deque_utils import deque_pop_anyqueue = deque([1, 2, 3, 4, 5])assert deque_pop_any(queue, idx=1) == 2assert queue == deque([1, 3, 4, 5])# edge case: same as deque.popleft()queue = deque([1, 2, 3, 4, 5])assert deque_pop_any(queue, idx=0) == 1assert queue == deque([2, 3, 4, 5])# edge case: same as deque.popright()queue = deque([1, 2, 3, 4, 5])assert deque_pop_any(queue, idx=len(queue) - 1) == 5assert queue == deque([1, 2, 3, 4])queue = deque([1, 2, 3, 4, 5])with pytest.raises(IndexError) as exec_info:    deque_pop_any(queue, idx=102)# edge case: pop from empty dequequeue = deque()with pytest.raises(IndexError) as exec_info:    deque_pop_any(queue, idx=0)assert exec_info.value.args[0] == 'pop from empty deque'```#### deque_split```python3import pytestfrom collections import dequefrom pythonic_toolbox.utils.deque_utils import deque_splitqueue1, queue2 = deque_split(deque([1, 2, 3, 4, 5]), num=3)assert queue1 == deque([1, 2, 3])assert queue2 == deque([4, 5])queue1, queue2 = deque_split(deque([1, 2, 3, 4, 5]), num=0)assert queue1 == deque([])assert queue2 == deque([1, 2, 3, 4, 5])queue1, queue2 = deque_split(deque([1, 2, 3, 4, 5]), num=100)assert queue1 == deque([1, 2, 3, 4, 5])assert queue2 == deque([])with pytest.raises(ValueError) as exec_info:    deque_split(deque([1, 2, 3, 4, 5]), -1)assert exec_info.value.args[0] == 'num must be integer: 0 &lt;= num &lt;= sys.maxsize'```### dict_utils#### DictObj```python3from copy import deepcopyimport pytestfrom pythonic_toolbox.utils.dict_utils import DictObjnaive_dct = {    'key1': 'val1',    'key2': 'val2',}obj = DictObj(naive_dct)# test basic functional methods like dictassert len(obj) == 2assert bool(obj) is True# same behavior like ordinary dict according to the python version (FILO for popitem for 3.6+)assert obj.popitem() == ('key2', 'val2')assert obj.popitem() == ('key1', 'val1')with pytest.raises(KeyError) as __:    obj.popitem()# a key can be treated like an attribute# an attribute can be treated like a keyobj.key3 = 'val3'assert obj.pop('key3') == 'val3'with pytest.raises(KeyError) as __:    obj.pop('key4')obj.key5 = 'val5'del obj.key5with pytest.raises(KeyError) as __:    obj.pop('key5')with pytest.raises(AttributeError) as __:    del obj.key5# test deepcopyobj = DictObj({'languages': ['Chinese', 'English']})copied_obj = deepcopy(obj)assert copied_obj == objcopied_obj.languages = obj.languages + ['Japanese']assert obj.languages == ['Chinese', 'English']assert copied_obj.languages == ['Chinese', 'English', 'Japanese']assert copied_obj != objperson_dct = {'name': 'Albert', 'age': '34', 'sex': 'Male', 'languages': ['Chinese', 'English']}person = DictObj(person_dct)assert DictObj(person_dct) == DictObj(person_dct)assert person.to_dict() == person_dctassert set(person.keys()) == {'name', 'age', 'sex', 'languages'}assert hasattr(person, 'name') is Trueassert person.name == 'Albert'assert person['name'] == 'Albert'person.languages.append('Japanese')assert person.languages == ['Chinese', 'English', 'Japanese']person.height = '170'assert person['height'] == '170'assert 'height' in personassert 'height' in person.keys()assert hasattr(person, 'height') is Truedel person['height']assert 'height' not in personassert 'height' not in person.keys()person['height'] = '170cm'person.update({'weight': '50'})weight_val = person.pop('weight')assert weight_val == '50'person.update(DictObj({'weight': '50kg'}))assert person.weight == '50kg'expected = {    'name': 'Albert', 'age': '34', 'sex': 'Male',    'languages': ['Chinese', 'English', 'Japanese'],  # appended new language    'height': '170cm',  # new added attribute    'weight': '50kg',  # new added attribute}assert person.to_dict() == expectedrepr_expected: str = (&quot;{'name': 'Albert', 'age': '34', 'sex': 'Male', &quot;                      &quot;'languages': ['Chinese', 'English', 'Japanese'],&quot;                      &quot; 'height': '170cm', 'weight': '50kg'}&quot;)assert repr(person) == repr_expected# nested structure will be detected, and changed to DictObjchessboard_data = {    'position': [        [{'name': 'knight'}, {'name': 'pawn'}],        [{'name': 'pawn'}, {'name': 'queen'}],    ]}chessboard_obj = DictObj(chessboard_data)# test comparing instances of DictObjassert DictObj(chessboard_data) == DictObj(chessboard_data)assert isinstance(chessboard_obj.position, list)assert len(chessboard_obj.position) == 2assert isinstance(chessboard_obj.position[0][0], DictObj)assert chessboard_obj.position[0][0].name == 'knight'assert chessboard_obj.position[1][1].name == 'queen'# edge case empty DictObjempty_dict_obj = DictObj({})assert len(empty_dict_obj) == 0assert bool(empty_dict_obj) is Falseobj_dict = DictObj({'data': 'oops'})assert obj_dict.data == 'oops'# params validationinvalid_key_dct = {    1: '1',}# test when dict's key is not strwith pytest.raises(ValueError) as __:    __ = DictObj(invalid_key_dct)complicated_key_dct = {    '1abc': 'Gotcha',  # '1abc' is not valid identifier for Python, so obj.1abc will cause SyntaxError    'class': 'MyClass',  # 'class' is keyword in Python, so obj.class will cause SyntaxError}obj_dict = DictObj(complicated_key_dct)assert obj_dict['1abc'] == 'Gotcha'assert getattr(obj_dict, '1abc') == 'Gotcha'# you can access '1abc' as attribute by adding prefix '_'assert obj_dict._1abc == 'Gotcha'del obj_dict._1abcassert obj_dict['class'] == 'MyClass'assert getattr(obj_dict, 'class') == 'MyClass'# you can access 'class' as attribute by adding prefix '_'assert obj_dict._class == 'MyClass'# test re-assign new value for 'class'obj_dict._class = 'MyClass2'assert obj_dict._class == 'MyClass2'assert obj_dict['class'] == 'MyClass2'assert getattr(obj_dict, 'class') == 'MyClass2'del obj_dict._class# if assign new attributes (_2, _try), ObjDict will treat it like what the originally are# this is fully considered by design, you're not encouraged to mess up keysobj_dict._2x = 'NewAttr'assert obj_dict._2x == 'NewAttr'assert obj_dict['_2x'] == 'NewAttr'with pytest.raises(KeyError):    __ = obj_dict['2x']with pytest.raises(AttributeError):    __ = getattr(obj_dict, '2x')obj_dict._try = 'NewAttr'assert obj_dict._try == 'NewAttr'assert obj_dict['_try'] == 'NewAttr'with pytest.raises(KeyError):    __ = obj_dict['NewAttr']with pytest.raises(AttributeError):    __ = getattr(obj_dict, 'NewAttr')# Demo for messing up key 'class'# delete and re-assign _classcomplicated_key_dct = {    'class': 'MyClass',  # 'class' is keyword in Python, so obj.class will cause SyntaxError}obj_dict = DictObj(complicated_key_dct)assert obj_dict['class'] == 'MyClass'obj_dict._class = 'MyClass2'assert obj_dict['class'] == 'MyClass2'del obj_dict._class# obj_dict has no knowledge about 'class' or '_class'# so '_class' is a brand-new attribute, and will be stored as '_class'obj_dict._class = 'MyClass3'with pytest.raises(KeyError):    # Oops!!! by-design    # 'class' cannot be accessed as key anymore,    # because we store '_class' as key as other valid keys behave    assert obj_dict['class'] == 'MyClass3'assert obj_dict['_class'] == 'MyClass3'# thread safe testingimport sysfrom threading import Threadfrom pythonic_toolbox.decorators.decorator_utils import method_synchronizedclass MyObjDict(DictObj):    # implement a thread-safe method to increase the value of cnt    @method_synchronized    def increase_cnt_by_n(self, n):        self.cnt += ndef increase_cnt_by_100(dict_obj):    for i in range(100):        dict_obj.increase_cnt_by_n(1)sw_interval = sys.getswitchinterval()try:    sys.setswitchinterval(0.0001)    my_dict_obj = MyObjDict({'cnt': 0})    threads = [Thread(target=increase_cnt_by_100, args=(my_dict_obj,)) for _ in range(100)]    [t.start() for t in threads]    [t.join() for t in threads]    assert my_dict_obj.cnt == 10000finally:    sys.setswitchinterval(sw_interval)# test copy/deepcopy of DictObjimport copyperson = DictObj({'name': 'albert', 'age': 33})team = DictObj({'leader': person})shallow_copy_of_team = copy.copy(team)assert team.leader is shallow_copy_of_team.leaderdeep_copy_of_team = copy.deepcopy(team)assert team.leader is not deep_copy_of_team.leaderassert team.leader == deep_copy_of_team.leader```#### FinalDictObj```python3from typing import castimport pytestfrom pythonic_toolbox.utils.dict_utils import FinalDictObjperson_dct = {'name': 'Albert', 'age': '34', 'sex': 'Male', 'languages': ['Chinese', 'English']}fixed_person = FinalDictObj(person_dct)assert fixed_person.name == 'Albert'# FINAL means once initialized, you cannot change the key/attribute anymorewith pytest.raises(RuntimeError) as exec_info:    fixed_person.name = 'Steve'expected_error_str = 'Cannot modify attribute/item in an already initialized FinalDictObj'assert exec_info.value.args[0] == expected_error_strwith pytest.raises(RuntimeError) as __:    fixed_person.popitem()with pytest.raises(RuntimeError) as __:    fixed_person.pop('name')assert isinstance(fixed_person.languages, tuple)with pytest.raises(AttributeError) as exec_info:    # list values are changed into tuple to avoid being modified    cast(list, fixed_person.languages).append('Japanese')expected_error_str = &quot;'tuple' object has no attribute 'append'&quot;assert exec_info.value.args[0] == expected_error_strassert fixed_person.to_dict() == person_dct# nested structure will be detected, and changed to FinalDictObjchessboard_data = {    'position': [        [{'name': 'knight'}, {'name': 'pawn'}],        [{'name': 'pawn'}, {'name': 'queen'}],    ]}chessboard_obj = FinalDictObj(chessboard_data)# test comparing instances of FinalDictObjassert FinalDictObj(chessboard_data) == FinalDictObj(chessboard_data)assert isinstance(chessboard_obj.position, tuple)assert isinstance(chessboard_obj.position[0][0], FinalDictObj)assert chessboard_obj.position[1][1].name == 'queen'with pytest.raises(RuntimeError) as __:    chessboard_obj.position[1][1].name = 'knight'# test for keyword/non-identifier key as attributefinal_obj_dict = FinalDictObj({    'class': 'MyClass',  # 'class' is keyword in Python, so obj.class will cause SyntaxError})assert final_obj_dict['class'] == 'MyClass'assert getattr(final_obj_dict, 'class') == 'MyClass'assert final_obj_dict._class == 'MyClass'# test copy/deepcopy of FileDictObjimport copyperson = FinalDictObj({'name': 'albert', 'age': 33})team = FinalDictObj({'leader': person})shallow_copy_of_team = copy.copy(team)assert team.leader is shallow_copy_of_team.leaderassert team.leader == shallow_copy_of_team.leaderdeep_copy_of_team = copy.deepcopy(team)assert team.leader is not deep_copy_of_team.leaderassert team.leader == deep_copy_of_team.leader```#### RangeKeyDict```python3import pytestfrom pythonic_toolbox.utils.dict_utils import RangeKeyDict# test normal caserange_key_dict: RangeKeyDict[float, str] = RangeKeyDict({    (float('-inf'), 0): 'Negative',    (0, 60): 'F',  # 0 &lt;= val &lt; 60    (60, 70): 'D',  # 60 &lt;= val &lt; 70    (70, 80): 'C',  # 70 &lt;= val &lt; 80    (80, 90): 'B',  # 80 &lt;= val &lt; 90    (90, 100): 'A',  # 90 &lt;= val &lt; 100    100: 'A+',  # val == 100})# Big O of querying is O(log n), n is the number of ranges, due to using bisect insideassert range_key_dict[-1] == 'Negative'assert range_key_dict[0] == 'F'assert range_key_dict[55] == 'F'assert range_key_dict[60] == 'D'assert range_key_dict[75] == 'C'assert range_key_dict[85] == 'B'assert range_key_dict[95] == 'A'assert range_key_dict[100] == 'A+'with pytest.raises(KeyError) as exec_info:    _ = range_key_dict['95']  # when key is not comparable with other integer keysassert exec_info.value.args[0] == &quot;KeyError: '95' is not comparable with other keys&quot;with pytest.raises(KeyError) as exec_info:    _ = range_key_dict[150]assert exec_info.value.args[0] == 'KeyError: 150'assert range_key_dict.get(150, 'N/A') == 'N/A'# test comparison with other RangeKeyDictassert RangeKeyDict({(0, 10): '1'}) == RangeKeyDict({(0, 10): '1'})assert RangeKeyDict({(0, 10): '1'}) != RangeKeyDict({(0, 10): '2'})assert RangeKeyDict({(0, 10): '1'}) != RangeKeyDict({(0, 1000): '1'})with pytest.raises(ValueError):    # [1, 1) is not a valid range    # there's no value x satisfy 1 &lt;= x &lt; 1    RangeKeyDict({(1, 1): '1'})with pytest.raises(ValueError):    # [1, -1) is not a valid range    RangeKeyDict({(1, -1): '1'})# validate input keys types and detect range overlaps(segment intersect)with pytest.raises(ValueError) as exec_info:    RangeKeyDict({        (0, 10): 'val-between-0-and-10',        (0, 5): 'val-between-0-and-5'    })expected_error_msg = (&quot;Duplicated left boundary key 0 detected: &quot;                      &quot;(0, 10): 'val-between-0-and-10', (0, 5): 'val-between-0-and-5'&quot;)assert exec_info.value.args[0] == expected_error_msgwith pytest.raises(ValueError) as exec_info:    RangeKeyDict({        (0, 10): 'val-between-0-and-10',        (5, 15): 'val-between-5-and-15'    })expected_error_msg = (&quot;Overlap detected: &quot;                      &quot;(0, 10): 'val-between-0-and-10', (5, 15): 'val-between-5-and-15'&quot;)assert exec_info.value.args[0] == expected_error_msgfrom functools import total_ordering@total_orderingclass Age:    def __init__(self, val: float):        if not isinstance(val, (int, float)):            raise ValueError('Invalid age value')        self.val = val    def __le__(self, other):        return self.val &lt;= other.val    def __repr__(self):        return f'Age({repr(self.val)})'    def __hash__(self):        return hash(self.val)age_categories_map: RangeKeyDict[Age, str] = RangeKeyDict({    (Age(0), Age(2)): 'Baby',    (Age(2), Age(15)): 'Children',    (Age(15), Age(25)): 'Youth',    (Age(25), Age(65)): 'Adults',    (Age(65), Age(123)): 'Seniors',})assert age_categories_map[Age(0.5)] == 'Baby'assert age_categories_map[Age(12)] == 'Children'assert age_categories_map[Age(20)] == 'Youth'assert age_categories_map[Age(35)] == 'Adults'assert age_categories_map[Age(70)] == 'Seniors'```#### StrKeyIdDict```python3import pytestfrom pythonic_toolbox.utils.dict_utils import StrKeyIdDictdata = {1: 'a', 2: 'b', '3': 'c'}my_dict = StrKeyIdDict(data)# usage: value can be accessed by id (str: int-like/uuid-like/whatever) or id (int)assert my_dict['1'] == my_dict[1] == 'a'assert my_dict.keys() == {'1', '2', '3'}  # all keys are str typemy_dict['4'] = 'd'assert my_dict['4'] == 'd'my_dict[4] = 'd'assert my_dict['4'] == 'd'my_dict.update({4: 'd'})assert my_dict['4'] == 'd'# test comparing instances of the classassert StrKeyIdDict(data) == StrKeyIdDict(data)assert StrKeyIdDict(data) != StrKeyIdDict(dict(data, **{'4': 'd'}))assert StrKeyIdDict(data) == {'1': 'a', '2': 'b', '3': 'c'}assert StrKeyIdDict(data) != {'1': 'a', '2': 'b', '3': 'd'}assert StrKeyIdDict(data) != {1: 'a', 2: 'b', 3: 'c'}  # StrKeyIdDict assumes all keys are strings# test delete keydel my_dict[4]assert my_dict.keys() == {'1', '2', '3'}  # '4' is not in the dict anymore# assign value to an arbitrary string key that is not in the dictmy_dict.update({'some-uuid': 'something'})assert my_dict['some-uuid'] == 'something'with pytest.raises(TypeError):    # key '1', 1 both stands for key '1',    # so we get duplicated keys when initializing instance, oops!    my_dict = StrKeyIdDict({'1': 'a', 1: 'A'})assert my_dict.get(1) == 'a'assert my_dict.get('NotExistKey') is Noneassert my_dict.get('NotExistKey', 'NotExistValue') == 'NotExistValue'# test edge casesassert StrKeyIdDict() == {}# test shallow copymy_dict[5] = ['e1', 'e2', 'e3']copy_dict = my_dict.copy()copy_dict[1] = 'A'assert my_dict[1] == 'a'my_dict['5'].append('e4')assert copy_dict['5'] == ['e1', 'e2', 'e3', 'e4']# test deep copyfrom copy import deepcopycopy_dict = deepcopy(my_dict)my_dict[5].append('e5')assert my_dict['5'] == ['e1', 'e2', 'e3', 'e4', 'e5']assert copy_dict[5] == ['e1', 'e2', 'e3', 'e4']# test constructormy_dict = StrKeyIdDict(uuid1='a', uuid2='b')assert my_dict['uuid1'] == 'a'# test constructor (from keys)my_dict = StrKeyIdDict.fromkeys([1, 2, 3], None)assert my_dict == {'1': None, '2': None, '3': None}# test update and overwritemy_dict.update(StrKeyIdDict({1: 'a', 2: 'b', 3: 'c', 4: 'd'}))assert my_dict == {'1': 'a', '2': 'b', '3': 'c', '4': 'd'}my_dict = StrKeyIdDict([(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')])assert my_dict['1'] == my_dict[1] == 'a'# reassign StrKeyIdDict instance to another StrKeyIdDict instancemy_dict = StrKeyIdDict(my_dict)assert my_dict == {'1': 'a', '2': 'b', '3': 'c', '4': 'd'}assert dict(my_dict) == {'1': 'a', '2': 'b', '3': 'c', '4': 'd'}# test case when &quot;key&quot; is &quot;data&quot;, which is a reserved keyword inside StrKeyIdDictmy_dict = StrKeyIdDict({'data': 'data_value', '1': 'a'})assert my_dict['data'] == 'data_value'assert my_dict['1'] == 'a'# delete key 'data', should not affect other keysdel my_dict['data']assert my_dict['1'] == 'a'```#### collect_leaves```python3from pythonic_toolbox.utils.dict_utils import collect_leaves# a nested dict-like structmy_dict = {    'node_1': {        'node_1_1': {            'node_1_1_1': 'A',        },        'node_1_2': {            'node_1_2_1': 'B',            'node_1_2_2': 'C',            'node_1_2_3': None,        },        'node_1_3': [  # dict list            {                'node_1_3_1_1': 'D',                'node_1_3_1_2': 'E',            },            {                'node_1_3_2_1': 'FF',                'node_1_3_2_2': 'GG',            }        ]    }}expected = ['A', 'B', 'C', None, 'D', 'E', 'FF', 'GG']assert collect_leaves(my_dict) == expectedexpected = ['A', 'B', 'C', 'D', 'E', 'FF', 'GG']assert collect_leaves(my_dict, leaf_pred=lambda lf: lf) == expectedassert collect_leaves(my_dict, keypath_pred=lambda kp: len(kp) == 1) == []expected = ['B', 'C']assert collect_leaves(my_dict, keypath_pred=lambda kp: kp[-1] in {'node_1_2_1', 'node_1_2_2'}) == expectedexpected = ['C']assert collect_leaves(my_dict, leaf_pred=lambda lf: lf == 'C') == expectedassert collect_leaves(my_dict,                      keypath_pred=lambda kp: kp[-1] == 'node_1_2_2',                      leaf_pred=lambda lf: lf == 'C') == expectedassert collect_leaves(my_dict,                      keypath_pred=lambda kp: kp[-1] == 'node_1_1_1',                      leaf_pred=lambda lf: lf == 'C') == []expected = ['D', 'E', 'FF', 'GG']assert collect_leaves(my_dict,                      keypath_pred=lambda kp: len(kp) &gt;= 2 and kp[-2] == 'node_1_3') == expectedexpected = ['FF', 'GG']assert collect_leaves(my_dict,                      keypath_pred=lambda kp: len(kp) &gt;= 2 and kp[-2] == 'node_1_3',                      leaf_pred=lambda lf: isinstance(lf, str) and len(lf) == 2) == expected# edge casesassert collect_leaves([]) == []assert collect_leaves({}) == []assert collect_leaves(None) == []```#### dict_until```python3from pythonic_toolbox.utils.dict_utils import dict_untildata = {'full_name': 'Albert Lee', 'pen_name': None}assert dict_until(data, keys=['name', 'full_name']) == 'Albert Lee'assert dict_until(data, keys=['full_name', 'name']) == 'Albert Lee'assert dict_until(data, keys=['name', 'english_name']) is Noneassert dict_until(data, keys=['name', 'english_name'], default='anonymous') == 'anonymous'# test when pen_name is set None on purposeassert dict_until(data, keys=['pen_name'], default='anonymous') is None# test when value with None value is not acceptableassert dict_until(data, keys=['pen_name'], terminate=lambda x: x is not None, default='anonymous') == 'anonymous'```#### select_list_of_dicts```python3from pythonic_toolbox.utils.dict_utils import select_list_of_dictsdict_lst = [    {'name': 'Tony Stark', 'sex': 'male', 'age': 49, 'alias': 'Iron Man'},    {'name': 'Peter Parker', 'sex': 'male', 'age': 16, 'alias': 'Spider Man'},    # another Peter Parker from multiverse    {'name': 'Peter Parker', 'sex': 'male', 'age': 16, 'alias': 'Spider Man'},    {'name': 'Carol Danvers', 'sex': 'female', 'alias': 'Captain Marvel'},    {'name': 'Natasha Romanoff', 'sex': 'female', 'age': 35, 'alias': 'Black Widow'},]assert select_list_of_dicts(dict_lst, [lambda d: d['sex'] == 'female']) == [    {'name': 'Carol Danvers', 'sex': 'female', 'alias': 'Captain Marvel'},    {'name': 'Natasha Romanoff', 'sex': 'female', 'age': 35, 'alias': 'Black Widow'}]assert select_list_of_dicts(dict_lst, [lambda d: d['sex'] == 'female'], keys=['name']) == [    {'name': 'Carol Danvers'}, {'name': 'Natasha Romanoff'}]# unique is supported for return listassert select_list_of_dicts(dict_lst, [lambda d: d['sex'] == 'male'], keys=['name', 'age']) == [    {'name': 'Tony Stark', 'age': 49},    {'name': 'Peter Parker', 'age': 16},    {'name': 'Peter Parker', 'age': 16},]assert select_list_of_dicts(dict_lst, [lambda d: d['sex'] == 'male'], keys=['name', 'age'], unique=True) == [    {'name': 'Tony Stark', 'age': 49},    {'name': 'Peter Parker', 'age': 16}]# dict keys are ordered as the keys passed-inassert list(select_list_of_dicts(dict_lst, keys=['name', 'age'], unique=True)[0].keys()) == ['name', 'age']assert list(select_list_of_dicts(dict_lst, keys=['age', 'name'], unique=True)[0].keys()) == ['age', 'name']# locate Captain Marvel, with default val for missing keyassert select_list_of_dicts(dict_lst,                            preds=[lambda d: d['alias'] == 'Captain Marvel'],                            keys=['name', 'sex', 'age', 'alias'],                            val_for_missing_key='Unknown')[0]['age'] == 'Unknown'# edge cases, get the original dictassert select_list_of_dicts([]) == []assert select_list_of_dicts(dict_lst) == dict_lst# new list of dicts is returned, leaving the original list of dicts untouchedblack_widow = select_list_of_dicts(dict_lst, [lambda d: d['name'] == 'Natasha Romanoff'])[0]black_widow['age'] += 1assert black_widow['age'] == 36# we don't modify the original dict data, Natasha is always 35 years oldassert select_list_of_dicts(dict_lst, [lambda d: d['name'] == 'Natasha Romanoff'])[0]['age'] == 35# filter the ones with age infoassert len(select_list_of_dicts(dict_lst, [lambda d: 'age' in d])) == 4assert len(select_list_of_dicts(dict_lst, [lambda d: 'age' in d], unique=True)) == 3```#### unique_list_of_dicts```python3from pythonic_toolbox.utils.dict_utils import unique_list_of_dictsdict_lst = [    {'name': 'Tony Stark', 'sex': 'male', 'age': 49, 'alias': 'Iron Man'},    {'name': 'Peter Parker', 'sex': 'male', 'age': 16, 'alias': 'Spider Man'},    # Peter Parkers from multiverse in same age.    {'name': 'Peter Parker', 'sex': 'male', 'age': 16, 'alias': 'Spider Man'},    {'name': 'Peter Parker', 'sex': 'male', 'age': 16, 'alias': 'Spider Man'},]# Only one Peter Parker will be kept, for all data are exactly same.assert unique_list_of_dicts(dict_lst) == [    {'name': 'Tony Stark', 'sex': 'male', 'age': 49, 'alias': 'Iron Man'},    {'name': 'Peter Parker', 'sex': 'male', 'age': 16, 'alias': 'Spider Man'},]# edge casesassert unique_list_of_dicts([]) == []```#### walk_leaves```python3from pythonic_toolbox.utils.dict_utils import walk_leavesdata = {    'k1': {        'k1_1': 1,        'k1_2': 2,    },    'k2': 'N/A',  # stands for not available}expected = {    'k1': {        'k1_1': 2,        'k1_2': 4,    },    'k2': 'N/A',  # stands for not available}assert walk_leaves(data) == data  # no transform function provided, just a deepcopyassert walk_leaves(data, trans_fun=lambda x: x * 2 if isinstance(x, int) else x) == expected# if inplace is set True, will change data inplace, return nothingassert walk_leaves(data, trans_fun=lambda x: x * 2 if isinstance(x, int) else x, inplace=True) is Noneassert data == expecteddata = [{'name': 'lml', 'age': 33}, {'name': 'albert', 'age': 18}]expected = [{'name': 'lml', 'age': 66}, {'name': 'albert', 'age': 36}]assert walk_leaves(data, trans_fun=lambda x: x * 2 if isinstance(x, int) else x) == expectedassert walk_leaves(data, trans_fun=lambda x: x * 2 if isinstance(x, int) else x, inplace=True) is Noneassert data == expected# edge casesassert walk_leaves(None) is Noneassert walk_leaves([]) == []assert walk_leaves({}) == {}assert walk_leaves(None, inplace=True) is Noneassert walk_leaves([], inplace=True) is Noneassert walk_leaves({}, inplace=True) is None```### functional_utils#### filter_multi```python3from pythonic_toolbox.utils.functional_utils import lfilter_multi, filter_multifrom collections.abc import Iterabledef is_even(x):    return x % 2 == 0def is_divisible_by_5(x):    return x % 5 == 0# select numbers which are divisible by 2 and 5assert lfilter_multi([is_even, is_divisible_by_5], range(1, 30)) == [10, 20]assert lfilter_multi([is_even, is_divisible_by_5], [5, 10, 15, 20]) == [10, 20]from itertools import count, takewhile# if you want to pass an iterator, make sure the iterator will end/break,# Note: a bare count(start=0, step=2) will generate number like 0, 2, 4, 6, .... (never ends)even_numbers_less_equal_than_50 = takewhile(lambda x: x &lt;= 50, count(start=0, step=2))expected = [0, 10, 20, 30, 40, 50]assert lfilter_multi([is_even, is_divisible_by_5], even_numbers_less_equal_than_50) == expected# testing for filter_multi, not converted to list directlynum_iterator = filter_multi([is_even, is_divisible_by_5], [5, 10, 15, 20])assert type(num_iterator) is filterassert isinstance(num_iterator, Iterable)expected = [10, 20]for idx, value in enumerate(num_iterator):    assert value == expected[idx]# when items are infinite, choose filter_multi instead of lfilter_multiexpected = [0, 10, 20, 30, 40, 50]for idx, value in enumerate(filter_multi([is_even, is_divisible_by_5], count(start=0, step=1))):    if value &gt; 50:        break    else:        assert value == expected[idx]```### list_utils#### filter_allowable```python3from pythonic_toolbox.utils.list_utils import filter_allowablefruits = ['apple', 'banana', 'orange']vegetables = ['carrot', 'potato', 'tomato']meats = ['beef', 'chicken', 'fish']foods = fruits + vegetables + meatsassert list(filter_allowable(foods)) == foodsassert list(filter_allowable(foods, allow_list=[], block_list=[])) == foodsassert list(filter_allowable(foods, allow_list=['apple', 'banana', 'blueberry'])) == ['apple', 'banana']assert list(filter_allowable(foods, allow_list=[], block_list=foods)) == []assert list(filter_allowable(foods, block_list=meats)) == fruits + vegetablesassert list(filter_allowable(foods, allow_list=['apple'], block_list=[])) == ['apple']assert list(filter_allowable(foods, allow_list=['apple'], block_list=['apple'])) == []assert list(filter_allowable(foods + ['blueberry'], allow_list=[], block_list=foods)) == ['blueberry']assert list(filter_allowable(['blueberry'], allow_list=[], block_list=[])) == ['blueberry']assert list(filter_allowable(['blueberry'], allow_list=[], block_list=['apple', 'banana'])) == ['blueberry']assert list(filter_allowable(['blueberry'], allow_list=['orange'], block_list=['apple', 'banana'])) == []# test cases with parameter keyassert list(filter_allowable(foods, allow_list=['a', 'b'], key=lambda x: x[0])) == ['apple', 'banana', 'beef']# test some basic casesassert list(filter_allowable()) == []assert list(filter_allowable(candidates=None)) == []assert list(filter_allowable(candidates=[])) == []assert list(filter_allowable(candidates=[], allow_list=[], block_list=[])) == []```#### sort_with_custom_orders```python3from operator import itemgetterfrom typing import Listimport pytestfrom pythonic_toolbox.utils.list_utils import sort_with_custom_orders# basic usagevalues = ['branch2', 'branch1', 'branch3', 'master', 'release']expected = ['master', 'release', 'branch1', 'branch2', 'branch3']assert sort_with_custom_orders(values, prefix_orders=['master', 'release']) == expectedassert sort_with_custom_orders(values, prefix_orders=['master', 'release'], reverse=True) == expected[::-1]values = [1, 2, 3, 9, 9]expected = [9, 9, 1, 2, 3]assert sort_with_custom_orders(values, prefix_orders=[9, 8, 7]) == expectedvalues = [1, 2, 3, 9]expected = [9, 2, 3, 1]assert sort_with_custom_orders(values, prefix_orders=[9], suffix_orders=[1]) == expectedassert sort_with_custom_orders([]) == []assert sort_with_custom_orders([], prefix_orders=[], suffix_orders=[]) == []assert sort_with_custom_orders([], prefix_orders=['master']) == []# tests for unhashable valuesvalues = [[2, 2], [1, 1], [3, 3], [6, 0]]assert sort_with_custom_orders(values, prefix_orders=[[3, 3]]) == [[3, 3], [1, 1], [2, 2], [6, 0]]# if &quot;key&quot; is provided, items are sorted in order of key(item)# items in prefix_orders/suffix_orders don't need to be one-one correspondence with items to sort# sum([6]) == sum([3, 3]) == sum([6, 0])assert sort_with_custom_orders(values, prefix_orders=[[6]], key=sum) == [[3, 3], [6, 0], [1, 1], [2, 2]]# tests for list of dictsvalues = [{2: 2}, {1: 1}, {1: 2}]assert sort_with_custom_orders(values, prefix_orders=[{2: 2}],                               key=lambda data: sum(data.values())) == [{2: 2}, {1: 2}, {1: 1}]branch_info: List[dict] = [{'branch': 'master', 'commit_id': 'v1.2'}, {'branch': 'release', 'commit_id': 'v1.1'}]# Assume that we prefer choosing branch in order: release &gt; master &gt; others (develop, hotfix etc.)res = sort_with_custom_orders(branch_info,                              prefix_orders=[{'branch': 'release'}, {'branch': 'master'}],                              key=itemgetter('branch'))expected = [{'branch': 'release', 'commit_id': 'v1.1'}, {'branch': 'master', 'commit_id': 'v1.2'}]assert res == expectedbranch_info = [{'branch': 'develop', 'commit_id': 'v1.3'}, {'branch': 'master', 'commit_id': 'v1.2'}]res = sort_with_custom_orders(branch_info,                              prefix_orders=[{'branch': 'release'}, {'branch': 'master'}],                              key=itemgetter('branch'))expected = [{'branch': 'master', 'commit_id': 'v1.2'}, {'branch': 'develop', 'commit_id': 'v1.3'}]assert res == expected# tests for exceptionswith pytest.raises(ValueError) as exec_info:    sort_with_custom_orders([1, 2, 3], prefix_orders=[3], suffix_orders=[3])assert exec_info.value.args[0] == 'prefix and suffix contains same value'with pytest.raises(ValueError) as exec_info:    sort_with_custom_orders([1, 2, 3], prefix_orders=[1, 1])assert exec_info.value.args[0] == 'prefix_orders contains duplicated values'# tests for classclass Person:    def __init__(self, id, name, age):        self.id = id        self.name = name        self.age = age    def __lt__(self, other: 'Person'):        return self.age &lt; other.age    def __eq__(self, other: 'Person'):        return self.age == other.age    def __hash__(self):        return self.id    def __str__(self):        return f'Person({self.id}, {self.name}, {self.age})'    def __repr__(self):        return str(self)Albert = Person(1, 'Albert', 28)Alice = Person(2, 'Alice', 26)Menglong = Person(3, 'Menglong', 33)persons = [Albert, Alice, Menglong]expected = [Alice, Albert, Menglong]assert sort_with_custom_orders(persons) == expectedexpected = [Menglong, Alice, Albert]assert sort_with_custom_orders(persons, prefix_orders=[Menglong, Person(4, 'Anyone', 40)]) == expected```#### unpack_list```python3import pytestfrom pythonic_toolbox.utils.list_utils import unpack_listfirst, second, third = unpack_list(['a', 'b', 'c', 'd'], target_num=3)assert first == 'a' and second == 'b' and third == 'c'first, second, third = unpack_list(['a', 'b'], target_num=3, default=None)assert first == 'a' and second == 'b' and third is Nonefirst, second, third = unpack_list(range(1, 3), target_num=3, default=None)assert first == 1 and second == 2 and third is Nonefirst, second, third = unpack_list([], target_num=3, default=0)assert first == second == third == 0first, second, *rest = unpack_list(['a', 'b', 'c'], target_num=4, default='x')assert first == 'a' and second == 'b' and rest == ['c', 'x']# test case for type rangefirst, second, third = unpack_list(range(1, 3), target_num=3, default=None)assert first == 1 and second == 2 and third is Nonedef fib():    a, b = 0, 1    while 1:        yield a        a, b = b, a + b# test case for type generatorfib_generator = fib()  # generates data like [0, 1, 1, 2, 3, 5, 8, 13, 21 ...]first, second, third, *rest = unpack_list(fib_generator, target_num=6)assert first == 0 and second == 1 and third == 1assert rest == [2, 3, 5]seventh, eighth = unpack_list(fib_generator, target_num=2)assert seventh == 8 and eighth == 13# test edge case, nothing to unpackempty = unpack_list([], target_num=0, default=None)assert empty == []res = unpack_list([], target_num=2, default=None)assert res == [None, None]empty = unpack_list(['a', 'b'], target_num=0, default=None)assert empty == []empty = unpack_list(range(0, 0), target_num=0)assert empty == []empty = unpack_list(iter([]), target_num=0, default=None)assert empty == []with pytest.raises(ValueError):    # ValueError: not enough values to unpack (expected 3, got 2)    first, second, third = unpack_list([1, 2], target_num=2)```#### until```python3from itertools import countfrom pythonic_toolbox.utils.list_utils import until# basic usagecounter = count(1, 2)  # generator of odd numbers: 1, 3, 5, 7 ...assert until(counter, lambda x: x &gt; 10) == 11assert until([1, 2, 3], lambda x: x &gt; 10, default=11) == 11# edge casesassert until([], default=3) == 3  # nothing provided, return defaultassert until(None, lambda x: x &gt; 10, default=11) == 11```### string_utils#### substitute_string_template_dict```python3from unittest.mock import patch, PropertyMockimport pytestfrom pythonic_toolbox.utils.string_utils import substitute_string_template_dict, CycleError# simple usage# both $variable ${variable} declarations are supported in string template formatstr_template_dict = {    'greeting': 'Good Morning, Everyone!',    'first_name': 'Albert',    'last_name': 'Lee',    'full_name': '$first_name $last_name',    'age': 34,    'speech': '$greeting, I am $full_name, a ${age}-year-old programmer, very glad to meet you!'}output_dict = substitute_string_template_dict(str_template_dict)assert output_dict['full_name'] == 'Albert Lee'expected_speech = 'Good Morning, Everyone!, I am Albert Lee, a 34-year-old programmer, very glad to meet you!'assert output_dict['speech'] == expected_speech# complex usage, with dynamic values, and multi value-providing holdersstr_template_dict = {    'first_name': 'Daenerys',    'last_name': 'Targaryen',    'nick_name': 'Dany',    'full_name': '$first_name $last_name',    'speech': &quot;$nick_name: I'm $full_name ($title1, $title2, $title3), it's $current_time_str, $greeting!&quot;,}variables_dict = {'title1': 'Queen of Meereen',                  'title2': 'Mother of Dragons'}class DynamicVariables:    @property    def current_time_str(self):        import datetime        return datetime.datetime.now().strftime(&quot;%H:%M:%S&quot;)class DefaultUnknownTitle:    &quot;&quot;&quot;    A class will always return UnknownTitle, when try to access attribute like    title1, title2, ..., titleX    &quot;&quot;&quot;    def __getattribute__(self, item):        if isinstance(item, str) and item.startswith('title') and item[len(item) - 1:].isdigit():            return 'UnknownTitle'        return super(DefaultUnknownTitle, self).__getattribute__(item)expected_speech = (&quot;Dany: I'm Daenerys Targaryen (Queen of Meereen, Mother of Dragons, UnknownTitle), &quot;                   &quot;it's 08:00:00, good morning everyone!&quot;)# using mock to make DynamicVariables().current_time_str always return 08:00:00with patch.object(DynamicVariables, 'current_time_str', return_value='08:00:00', new_callable=PropertyMock):    output_dict = substitute_string_template_dict(str_template_dict, variables_dict, DynamicVariables(),                                                  DefaultUnknownTitle(),                                                  greeting='good morning everyone')    assert output_dict['speech'] == expected_speech# edge casesassert substitute_string_template_dict({}) == {}# cycle detectionstr_template_dict = {    'variable_a': 'Hello $variable_b',  # variable_a depends on variable_b    'variable_b': 'Hello $variable_a',  # variable_b depends on variable_a, it's a cycle!}with pytest.raises(CycleError) as exec_info:    substitute_string_template_dict(str_template_dict)```</longdescription>
</pkgmetadata>