<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<email>gentoo@houseofsuns.org</email>
		<name>Markus Walter</name>
	</maintainer>
	<longdescription># Blip Flow AnalysisBlip Flow Analysis provides a solution for chatbot constructors to identify problems in flow structure that can be originated from bad structuring or poor organization.# InstallationUse [pip](https://pip.pypa.io/en/stable/) to install:```shell scriptpip install blip_flowanalysis```# Usage## Missing Trackings analysisUsing the `MissingTrackigns` analyser:```pythonimport blip_flowanalysis as bfa# Replace __chatbot_as_json__ parameter by your json bot.bot_flow = bfa.Flow(__chatbot_as_json__)analyser = bfa.MissingTrackings(minimum=1)# Return `True` if amount of Trackings is above minimum, `False` otherwise.print(analyser.analyse(bot_flow)) ```## Process HTTP Return Validation analysisUsing the `ProcessHTTPReturnValidation` analyser:```python# import jsonimport blip_flowanalysis as bfabot_json = str(&quot;Your chatbot json here.&quot;)# bot_json = json.load(&quot;or your chatbot json file here&quot;)bot_flow = bfa.Flow(bot_json)http_analyser = bfa.ProcessHTTPReturnValidation()# Report with &quot;summary&quot; and &quot;details&quot; with long scripts detections.report = http_analyser.analyse(bot_flow)print(report)```Output is like:```{    &quot;summary&quot;: {        &quot;process HTTP actions&quot;: n_process_http,        &quot;process HTTP actions regular&quot;: n_regular,        &quot;process HTTP actions missing status&quot;: n_missing_status,        &quot;process HTTP actions missing body&quot;: n_missing_body,        &quot;process HTTP actions improper declared body&quot;: n_improper_declared_body,        &quot;process HTTP actions any used body before status&quot;: n_any_used_body_before_status,        &quot;states count&quot;: n_states,        &quot;states with irregular process HTTP action&quot;: n_irregular_states    },    &quot;details&quot;: [        {            &quot;state id&quot;: state_id,  # State ID on bot flow.            &quot;state name&quot;: state_name,  # State name on bot flow.            &quot;io action&quot;: io_action,  # Any of inputActions and outputActions.            &quot;action number&quot;: action_number,  # Action position on actions list.            &quot;http method&quot;: http_method,  # Examples: GET, PUT, POST, ...            &quot;status variable&quot;: status_variable,  # Variable with response status value            &quot;body variable&quot;: body_variable,  # Variable with response body value            &quot;all paths used status&quot;: true/false,  # Check if all paths after process HTTP used status            &quot;all paths used body&quot;: true/false,  # Check if all paths after process HTTP used body            &quot;declared status&quot;: true/false,  # Check if status variable was declared            &quot;declared body&quot;: true/false,  # Check if body variable was declared            &quot;must use body&quot;: true/false,  # Check if HTTP method requires use body            &quot;must not declare body&quot;: true/false,  # Check if HTTP method requires not use body            &quot;paths with missing status&quot;: [  # Empty if &quot;all paths used status&quot; is true                {                    &quot;path&quot;: [                        {&quot;id&quot;: state_id, &quot;name&quot;: state_name},  # States on this path                        ...                    ],                    &quot;status use&quot;: {}  # On &quot;paths with miss status&quot; it is empty                    &quot;body use&quot;: {                        &quot;state&quot;: {&quot;id&quot;: state_id, &quot;name&quot;: state_name},  # State with first body use                        &quot;stage on state&quot;: stage,  # inputActions, outputs or outputActions                        &quot;index on stage&quot;: index  # Index on stage with first body use                    }                },                ...            ],            &quot;paths with missing body&quot;: [                {                    &quot;path&quot;: [                        {&quot;id&quot;: state_id, &quot;name&quot;: state_name},  # States on this path                        ...                    ],                    &quot;status use&quot;: {                        &quot;state&quot;: {&quot;id&quot;: state_id, &quot;name&quot;: state_name},  # State with first status use                        &quot;stage on state&quot;: stage,  # inputActions, outputs or outputActions                        &quot;index on stage&quot;: index  # Index on stage with first status use                    }                    &quot;body use&quot;: {}  # On &quot;paths with miss body&quot; it is empty                },                ...            ],            &quot;paths with body before status&quot;: [                {                    &quot;path&quot;: [                        {&quot;id&quot;: state_id, &quot;name&quot;: state_name},  # States on this path                        ...                    ],                    &quot;status use&quot;: {                        &quot;state&quot;: {&quot;id&quot;: state_id, &quot;name&quot;: state_name},  # State with first status use                        &quot;stage on state&quot;: stage,  # inputActions, outputs or outputActions                        &quot;index on stage&quot;: index  # Index on stage with first status use                    }                    &quot;body use&quot;: {                        &quot;state&quot;: {&quot;id&quot;: state_id, &quot;name&quot;: state_name},  # State with first body use                        &quot;stage on state&quot;: stage,  # inputActions, outputs or outputActions                        &quot;index on stage&quot;: index  # Index on stage with first body use                    }                },                ...            ],            &quot;causes&quot;: causes  # Explain why this process HTTP return validation is irregular.        },        ...    ]}```## Long Scripts analysisUsing the `LongScript` analyser:```python# import jsonimport blip_flowanalysis as bfabot_json = str(&quot;Your chatbot json here.&quot;)# bot_json = json.load(&quot;or your chatbot json file here&quot;)bot_flow = bfa.Flow(bot_json)ls_analyser = bfa.LongScript()# Report with &quot;summary&quot; and &quot;details&quot; with long scripts detections.report = ls_analyser.analyse(bot_flow)print(report)```Output is like:```{    &quot;summary&quot;: {        &quot;scripts count&quot;: n_scripts,        &quot;scripts too long&quot;: n_long_scripts,        &quot;states count&quot;: n_states,        &quot;states with too long scripts&quot;: n_irregular_states    },    &quot;details&quot;: [        {            &quot;state id&quot;: state_id,  # State ID on bot flow.            &quot;state name&quot;: state_name,  # State name on bot flow.            &quot;io action&quot;: io_action,  # Any of inputActions and outputActions.            &quot;action number&quot;: action_number,  # Action position on actions list.            &quot;script&quot;: script,  # Script.            &quot;chars&quot;: length,  # Code characters quantity.            &quot;lines&quot;: lines,  # Not blank code lines quantity.            &quot;functions&quot;: functions,  # Top level functions quantity.            &quot;commands&quot;: commands,  # Commands quantity.            &quot;lines by commands&quot;: lines_by_commands,  # Lines commands ratio.            &quot;causes&quot;: cause  # Explain why this script was detected.        },        ...    ]}```## Duplicated Paths analysisUsing the `DuplicatedPaths` analyser:```python# import jsonimport blip_flowanalysis as bfabot_json = str(&quot;Your chatbot json here.&quot;)# bot_json = json.load(&quot;or your chatbot json file here&quot;)bot_flow = bfa.Flow(bot_json)dp_analyser = bfa.DuplicatedPaths()# Report with &quot;summary&quot; and &quot;details&quot; with long scripts detections.report = dp_analyser.analyse(bot_flow)print(report)```Output is like:```{    &quot;summary&quot;: {        &quot;pairs of duplicated paths&quot;: n_duplicated_paths,        &quot;states count&quot;: n_states,        &quot;states on duplicated paths&quot;: n_irregular_states    },    &quot;details&quot;: [        {            &quot;levels quantity&quot;: n_levels,  # Quantity of levels on path            &quot;states quantity&quot;: n_states_on_path,  # Quantity of states on path            &quot;root 0&quot;: {&quot;id&quot;: state_id, &quot;name&quot;: state_name},  # State as root on path 0            &quot;root 1&quot;: {&quot;id&quot;: state_id, &quot;name&quot;: state_name},  # State as root on path 1            &quot;path 0&quot;: {  # Path 0                &quot;level 0&quot;: [  # First level on path 0                    {&quot;id&quot;: state_id, &quot;name&quot;: state_name},  # States on level 0 on path 0                    ...  # Other states                ],                ...  # Other levels            },            &quot;path 1&quot;: {  # Path 1                &quot;level 0&quot;: [  # First level on path 1                    {&quot;id&quot;: state_id, &quot;name&quot;: state_name},  # States on level 0 on path 1                    ...  # Other states                ],                ...  # Other levels            },        },        ...    ]}```# Author[Take Data&amp;Analytics Research](anaytics.dar@take.net)# License[MIT License](LICENSE)</longdescription>
</pkgmetadata>